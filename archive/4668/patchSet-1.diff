commit 34717f5ad774df02af06db103230ec5cbaccc019 (refs/changes/68/4668/1)
Author: Josh Wilsdon <josh@wilsdon.ca>
Date:   2018-08-13T17:26:17+00:00 (1 year, 2 months ago)
    
    Revert "TRITON-557 improve CNAPI handling for heartbeats and server status Reviewed by: Orlando Vazquez <orlando@joyent.com> Approved by: Orlando Vazquez <orlando@joyent.com>"
    
    This reverts commit 34db7565a8334d26fcf67756ebe1dc4ca821cb7c. This needs more work as a bug was found in nightly.
    
    Change-Id: I951dceeb97e5d8150e9687bdf4ca989c697820bc

diff --git a/bin/cnapi.js b/bin/cnapi.js
index 7d9fc4c..9edfe99 100755
--- a/bin/cnapi.js
+++ b/bin/cnapi.js
@@ -54,7 +54,6 @@ common.loadConfig(configFilename, function (error, config) {
     });
 
     metricsManager.createRestifyMetrics();
-    metricsManager.createNodejsMetrics();
     metricsManager.listen(function metricsServerStarted() {
         app = new App(config, {
             log: cnapiLog,
diff --git a/docs/index.md b/docs/index.md
index dc3f8f4..34ea5d7 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -175,101 +175,31 @@ Use it as so:
                     -X POST \
                     -d '{ "datacenter_name": "foo" }'
 
-
 # Metrics
 
 CNAPI exposes metrics via [node-triton-metrics](https://github.com/joyent/node-triton-metrics) on `http://<ADMIN_IP>:8881/metrics.`
 
-# Heartbeats
-
-After setup, each server is populated with agents which allow the Triton
-services to monitor and perform actions on these servers. One of these agents is
-`cn-agent`, its responsibility is to execute tasks on the server and to
-periodically post server usage and information to CNAPI. CNAPI in turn uses
-these heartbeat events to determine whether a server is running.
-
-Every time CNAPI receives a heartbeat via POST to
-`/servers/:uuid/events/heartbeat`, CNAPI updates its in-memory store which maps
-server\_uuid to last\_heartbeat, setting the value to the current time.
-
-Every `HEARTBEAT_RECONCILIATION_PERIOD_SECONDS` (currently 5) seconds, CNAPI
-will check the heartbeats stored in its in-memory store and for each server:
-
- * If the `last_heartbeat` is not stale (more on this below), it does nothing
-   for this server.
-
- * If CNAPI has not previously written data for this server, it tries to
-   add/update an entry to the `cnapi_status` bucket in moray. If successful, it
-   will also try to update the server's `status` property to `running`.
-
- * If the `last_heartbeat` is stale, it tries to update the `cnapi_status`
-   bucket in moray with the last last\_heartbeat value this CNAPI has seen.
-   If the `cnapi_status` entry is updated, the server's `status` it also
-   attempts to set the `status` property to `unknown` for this server.
-
-To determine whether a heartbeat is "stale", CNAPI compares the last\_heartbeat
-against the current time. If the last heartbeat is more than
-`HEARTBEAT_LIFETIME_SECONDS` seconds old, the heartbeat is considered stale.
-The process that runs periodically to check heartbeats is called the reconciler.
-
-Any time CNAPI writes to the `cnapi_status` bucket, it also includes the
-`cnapi_instance` property identifying the CNAPI instance in which the value was
-observed. This way, if there are multiple CNAPI's, it is possible to determine
-which CNAPI has last received heartbeats for a given CN.
-
-There are a few artedi metrics that are exposed related to heartbeating. These
-will be available when polling the /metrics endpoint with prometheus. The
-available metrics are:
-
-## heartbeating_servers_count
-
-A gauge indicating how many servers have recently (within the heartbeat
-lifetime) heartbeated to this server.
-
-## reconciler_new_heartbeaters_total
 
-A counter that indicates how many times this CNAPI has seen a heartbeat from a
-new server, or a server that it had forgotten (e.g. because it went stale).
-
-## reconciler_stale_heartbeaters_total
-
-A counter that indicates the number of times CNAPI noticed that a server had not
-heartbeated recently and the last_heartbeat was considered stale.
-
-## reconciler_usurped_heartbeaters_total
-
-A counter that indicates the of times CNAPI went to update cnapi\_status but
-found that another server had updated it more recently.
-
-## reconciler_server_put_total
-
-A counter indicating the number of times CNAPI attempted to put cnapi\_servers
-objects into moray.
-
-## reconciler_server_put_etag_failures_total
-
-A counter indicating how many times there were Etag failures putting
-cnapi\_servers objects into moray because the data changed between get and put.
-
-## reconciler_server_put_failures_total
-
-A counter indicating the total number of putObject calls to cnapi\_servers
-have failed.
-
-## reconciler_status_put_total
-
-A counter indicating the number of times CNAPI attempted to put cnapi\_status
-objects into moray.
-
-## reconciler_status_put_etag_failures_total
+# Heartbeats
 
-A counter indicating how many times there were Etag failures putting
-cnapi\_status objects into moray because the data changed between get and put.
+Each server is populated with services which allow the headnode to monitor
+usage and interact with the compute nodes in general. One of these is the
+`cn-agent` agent, its responsibility is to execute tasks on the server in
+addition to periodically posting server usage and information to the headnode.
+CNAPI in turn uses these heartbeat events to determine whether a compute node
+is running.
 
-## reconciler_status_failures_total
+If a compute node is not setup (and therefore has no agents besides Ur), CNAPI
+uses the frequency of the sysinfo messages sent by Ur.
 
-A counter indicating the total number of putObject calls to cnapi\_status
-have failed.
+Server status, stored in the `status` property on `/server` entries, is
+calculated based on the time of the last received heartbeat (corresponding to
+the `last_heartbeat` property) and can hold the values "running" or "unknown".
+These heartbeat requests originate on the `cn-agent` running on each setup
+compute node. Every time a CNAPI instance receives a heartbeat message from a
+compute node, it refreshes a timeout corresponding to 2x the heartbeat period.
+If a heartbeat is not received again before this timeout expires, the server is
+marked as having `status` "uknown".
 
 
 # Resetting to Factory Defaults
@@ -581,7 +511,7 @@ A CNAPI server record looks like the following
 | **hostname**                         | *String*         | Hostname of server if any                                                  |
 | **kernel_flags**                     |                  |
 | **last_boot**                        | *ISODate String* | Time of last boot
-| **last_heartbeat**                   |                  | Timestamp indicating last-received heartbeat from compute node *DEPRECATED*
+| **last_heartbeat**                   |                  | Timestamp indicating last-received heartbeat from compute node
 | **memory_arc_bytes**                 |                  |
 | **memory_available_bytes**           |                  |
 | **memory_provisionable_bytes**       |                  |
diff --git a/docs/static.md b/docs/static.md
index 9c1e1f9..26640d6 100644
--- a/docs/static.md
+++ b/docs/static.md
@@ -145,100 +145,26 @@ Use it as so:
                     -d '{ "datacenter_name": "foo" }'
 
 
-# Metrics
-
-CNAPI exposes metrics via [node-triton-metrics](https://github.com/joyent/node-triton-metrics) on `http://<ADMIN_IP>:8881/metrics.`
-
 # Heartbeats
 
-After setup, each server is populated with agents which allow the Triton
-services to monitor and perform actions on these servers. One of these agents is
-`cn-agent`, its responsibility is to execute tasks on the server and to
-periodically post server usage and information to CNAPI. CNAPI in turn uses
-these heartbeat events to determine whether a server is running.
-
-Every time CNAPI receives a heartbeat via POST to
-`/servers/:uuid/events/heartbeat`, CNAPI updates its in-memory store which maps
-server\_uuid to last\_heartbeat, setting the value to the current time.
-
-Every `HEARTBEAT_RECONCILIATION_PERIOD_SECONDS` (currently 5) seconds, CNAPI
-will check the heartbeats stored in its in-memory store and for each server:
-
- * If the `last_heartbeat` is not stale (more on this below), it does nothing
-   for this server.
-
- * If CNAPI has not previously written data for this server, it tries to
-   add/update an entry to the `cnapi_status` bucket in moray. If successful, it
-   will also try to update the server's `status` property to `running`.
-
- * If the `last_heartbeat` is stale, it tries to update the `cnapi_status`
-   bucket in moray with the last last\_heartbeat value this CNAPI has seen.
-   If the `cnapi_status` entry is updated, the server's `status` it also
-   attempts to set the `status` property to `unknown` for this server.
-
-To determine whether a heartbeat is "stale", CNAPI compares the last\_heartbeat
-against the current time. If the last heartbeat is more than
-`HEARTBEAT_LIFETIME_SECONDS` seconds old, the heartbeat is considered stale.
-The process that runs periodically to check heartbeats is called the reconciler.
-
-Any time CNAPI writes to the `cnapi_status` bucket, it also includes the
-`cnapi_instance` property identifying the CNAPI instance in which the value was
-observed. This way, if there are multiple CNAPI's, it is possible to determine
-which CNAPI has last received heartbeats for a given CN.
-
-There are a few artedi metrics that are exposed related to heartbeating. These
-will be available when polling the /metrics endpoint with prometheus. The
-available metrics are:
-
-## heartbeating_servers_count
-
-A gauge indicating how many servers have recently (within the heartbeat
-lifetime) heartbeated to this server.
-
-## reconciler_new_heartbeaters_total
-
-A counter that indicates how many times this CNAPI has seen a heartbeat from a
-new server, or a server that it had forgotten (e.g. because it went stale).
-
-## reconciler_stale_heartbeaters_total
-
-A counter that indicates the number of times CNAPI noticed that a server had not
-heartbeated recently and the last_heartbeat was considered stale.
-
-## reconciler_usurped_heartbeaters_total
-
-A counter that indicates the of times CNAPI went to update cnapi\_status but
-found that another server had updated it more recently.
-
-## reconciler_server_put_total
-
-A counter indicating the number of times CNAPI attempted to put cnapi\_servers
-objects into moray.
-
-## reconciler_server_put_etag_failures_total
-
-A counter indicating how many times there were Etag failures putting
-cnapi\_servers objects into moray because the data changed between get and put.
-
-## reconciler_server_put_failures_total
-
-A counter indicating the total number of putObject calls to cnapi\_servers
-have failed.
-
-## reconciler_status_put_total
-
-A counter indicating the number of times CNAPI attempted to put cnapi\_status
-objects into moray.
-
-## reconciler_status_put_etag_failures_total
-
-A counter indicating how many times there were Etag failures putting
-cnapi\_status objects into moray because the data changed between get and put.
+Each server is populated with services which allow the headnode to monitor
+usage and interact with the compute nodes in general. One of these is the
+`cn-agent` agent, its responsibility is to execute tasks on the server in
+addition to periodically posting server usage and information to the headnode.
+CNAPI in turn uses these heartbeat events to determine whether a compute node
+is running.
 
-## reconciler_status_failures_total
+If a compute node is not setup (and therefore has no agents besides Ur), CNAPI
+uses the frequency of the sysinfo messages sent by Ur.
 
-A counter indicating the total number of putObject calls to cnapi\_status
-have failed.
+Server status, stored in the `status` property on `/server` entries, is
+calculated based on the time of the last received heartbeat (corresponding to
+the `last_heartbeat` property) and can hold the values "running" or "unknown".
+These heartbeat requests originate on the `cn-agent` running on each setup
+compute node. Every time a CNAPI instance receives a heartbeat message from a
+compute node, it refreshes a timeout corresponding to 2x the heartbeat period.
+If a heartbeat is not received again before this timeout expires, the server is
+marked as having `status` "uknown".
 
 
 # Resetting to Factory Defaults
@@ -550,7 +476,7 @@ A CNAPI server record looks like the following
 | **hostname**                         | *String*         | Hostname of server if any                                                  |
 | **kernel_flags**                     |                  |
 | **last_boot**                        | *ISODate String* | Time of last boot
-| **last_heartbeat**                   |                  | Timestamp indicating last-received heartbeat from compute node *DEPRECATED*
+| **last_heartbeat**                   |                  | Timestamp indicating last-received heartbeat from compute node
 | **memory_arc_bytes**                 |                  |
 | **memory_available_bytes**           |                  |
 | **memory_provisionable_bytes**       |                  |
diff --git a/lib/app.js b/lib/app.js
index 680398e..04b1b79 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -28,7 +28,6 @@ var sdcClients = require('sdc-clients');
 var sprintf = require('sprintf').sprintf;
 var util = require('util');
 var once = require('once');
-var os = require('os');
 
 var amqp = require('amqp');
 var buckets = require('./apis/moray').BUCKETS;
@@ -36,7 +35,6 @@ var common = require('./common');
 var createServer = require('./server').createServer;
 var Designation = require('./designation');
 var EffluentLogger = require('effluent-logger');
-var HeartbeatReconciler = require('./heartbeat_reconciler');
 var ModelBase = require('./models/base');
 var ModelImage = require('./models/image');
 var ModelPlatform = require('./models/platform');
@@ -87,27 +85,12 @@ function App(config, opts) {
 
     self.serversNeedSysinfo = {};
 
-    self.cnapi_instance = os.hostname();
-
     self.log.info({ config: config }, 'cnapi config');
     self.config.log = self.log;
     self.collectedGlobalSysinfo = false;
     self.metricsManager = opts.metricsManager;
     self.taskCallbacks = {};
 
-    // Will store current heartbeat status for all servers we've seen recently.
-    self.observedHeartbeats = {};
-    self.heartbeatingServersGauge = self.metricsManager.collector.gauge({
-        name: 'heartbeating_servers_count',
-        help: 'Number of servers from which this CNAPI has recent heartbeats'
-    });
-    self.metricsManager.addPreCollectFunc(function _hbServersGaugeSet(cb) {
-        var heartbeatingServers = Object.keys(self.observedHeartbeats).length;
-
-        self.heartbeatingServersGauge.set(heartbeatingServers);
-        cb();
-    });
-
     ModelBase.init(self);
     ModelImage.init(self);
     ModelPlatform.init(self);
@@ -335,7 +318,7 @@ App.prototype.initializeConnections = function (callback) {
     self.setupMorayClient();
     self.setupWorkflowClient();
     self.setupWaitlistDirector();
-    self.setupServerHeartbeatReconciler();
+    self.setupServerHeartbeatTimeouts();
 
     self.setupAmqpClient();
     self.startSysinfoChecker();
@@ -346,13 +329,12 @@ App.prototype.initializeConnections = function (callback) {
 
 
 /**
- * Starts the timer for the updater that will periodically check whether there
- * are servers that have started or stopped heartbeating to this CNAPI and
- * update the status accordingly (the heartbeat reconciler).
+ * Sets up timeouts, which when fired will trigger a server's status to be
+ * marked as "unknown". The timeouts are cleared and reinitiated after every
+ * heartbeat.
  */
 
-App.prototype.setupServerHeartbeatReconciler =
-function setupServerHeartbeatReconciler() {
+App.prototype.setupServerHeartbeatTimeouts = function () {
     var self = this;
 
     wait();
@@ -367,30 +349,51 @@ function setupServerHeartbeatReconciler() {
     }
 
     function onMorayConnection() {
-        self.heartbeatReconciler = new HeartbeatReconciler({
-            app: self,
-            log: self.log,
-            metricsManager: self.metricsManager,
-            moray: self.moray.getClient()
-        });
+        var listopts = {};
+
+        // List all servers in moray
+        ModelServer.list(listopts, function (error, servers) {
+            if (error) {
+                self.log.warn(
+                    error,
+                    'error attempting to list servers for heartbeat timeouts');
+                setTimeout(function () {
+                    wait();
+                }, 5000);
+                return;
+            }
 
-        // Start a timer to periodically check and update the cnapi_status
-        // bucket, and the servers' 'status' fields.
-        self.resetPeriodicHeartbeatReconcilerTimer();
+            if (!servers) {
+                self.log.error(
+                    'no servers or errors returned');
+                return;
+            }
+
+            // For every server, set a timeout using
+            // self.onServerHeartbeatTimeoutExpired
+            async.forEach(
+                servers,
+                function (server) {
+                    self.refreshServerHeartbeatTimeout(server.uuid);
+                });
+        });
     }
 };
 
 
-App.prototype.resetPeriodicHeartbeatReconcilerTimer =
-function AppResetPeriodicHeartbeatReconcilerTimer() {
+/**
+ * For a given server, this clears and refreshes to the maximum duration the
+ * timeout which amongst other things marks a server's status as "unknown".
+ */
+
+App.prototype.refreshServerHeartbeatTimeout = function (uuid) {
     var self = this;
-    self.periodicHeartbeatHeartbeatReconcilerTimer =
-        setTimeout(function () {
-            self.heartbeatReconciler.reconcile(function _onReconciled() {
-                // Reschedule the timer each time the heartbeats are reconciled.
-                self.resetPeriodicHeartbeatReconcilerTimer();
-            });
-        }, common.HEARTBEAT_RECONCILIATION_PERIOD_SECONDS * 1000);
+
+    clearTimeout(self.statusTimeouts[uuid]);
+    self.statusTimeouts[uuid] = setTimeout(function () {
+        var server = new ModelServer(uuid);
+        server.onHeartbeatTimeoutExpired();
+    }, common.HEARTBEATER_PERIOD * 2 * 1000);
 };
 
 
@@ -512,24 +515,24 @@ App.prototype.setupMorayClient = function () {
 };
 
 
-App.prototype.onVmsUpdate = function (uuid, vmsUpdate, callback) {
+App.prototype.onVmsUpdate = function (uuid, heartbeat, callback) {
     var self = this;
 
-    self.log.trace(vmsUpdate, 'vms update');
+    self.log.trace(heartbeat, 'vms update');
     if (!callback) {
         callback = function () {};
     }
 
-    if (! vmsUpdate.vms) {
-        vmsUpdate.vms = [];
+    if (! heartbeat.vms) {
+        heartbeat.vms = [];
     }
 
-    self.log.trace('VMs update (%s) received -- %d zones.',
-        uuid, Object.keys(vmsUpdate.vms).length);
+    self.log.trace('Heartbeat (%s) received -- %d zones.',
+        uuid, Object.keys(heartbeat.vms).length);
 
     if (!self.moray.connected) {
         self.log.warn(
-            'cannot refresh server from VMs update: cannot reach moray');
+            'cannot refresh server from heartbeat: cannot reach moray');
         callback();
         return;
     }
@@ -549,16 +552,16 @@ App.prototype.onVmsUpdate = function (uuid, vmsUpdate, callback) {
             return;
         }
 
-        vmsUpdate.transport = 'http';
+        heartbeat.transport = 'http';
 
         server.updateFromVmsUpdate(
-            vmsUpdate,
+            heartbeat,
             function (updateError) {
                 if (updateError) {
                     self.log.error(
                         new VError(
                         updateError,
-                        'updating server record with VMs update'));
+                        'updating server record with heartbeat'));
                     return;
                 }
 
diff --git a/lib/common.js b/lib/common.js
index 713c925..f721517 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var fs = require('fs');
@@ -13,14 +13,7 @@ var libuuid = require('libuuid');
 var qs = require('querystring');
 
 
-var HEARTBEAT_RECONCILIATION_PERIOD_SECONDS = 5;
-
-/*
- * Number of seconds before we consider a heartbeat stale.
- * Currently cn-agent is set to push this data every 5 seconds. So we allow for
- * one failure and a 1 second delay by setting the lifetime to 11 seconds.
- */
-var HEARTBEAT_LIFETIME_SECONDS = 11;
+var HEARTBEATER_PERIOD = 5;
 
 /**
  * RFC 2254 Escaping of filter strings
@@ -164,7 +157,5 @@ module.exports = {
     filterEscape: filterEscape,
     randSort: randSort,
     orderedKVString: orderedKVString,
-    HEARTBEAT_RECONCILIATION_PERIOD_SECONDS:
-        HEARTBEAT_RECONCILIATION_PERIOD_SECONDS,
-    HEARTBEAT_LIFETIME_SECONDS: HEARTBEAT_LIFETIME_SECONDS
+    HEARTBEATER_PERIOD: HEARTBEATER_PERIOD
 };
diff --git a/lib/endpoints/allocations.js b/lib/endpoints/allocations.js
index a29d3d1..7238203 100644
--- a/lib/endpoints/allocations.js
+++ b/lib/endpoints/allocations.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -389,6 +389,7 @@ Allocations.capacity = function handlerAllocationsCapacity(req, res, next) {
 
 function getServers(log, serverUuids, reserved, filterHeadnode, useVmapi, cb) {
     var options = {
+        wantFinal: true,
         uuid: serverUuids,
         default: false,
         setup: true,
diff --git a/lib/endpoints/servers.js b/lib/endpoints/servers.js
index 03d4458..8d3caa6 100644
--- a/lib/endpoints/servers.js
+++ b/lib/endpoints/servers.js
@@ -129,6 +129,7 @@ Server.list = function handlerSeverList(req, res, next) {
     async.waterfall([
         function (cb) {
             var options = {};
+            options.wantFinal = true;
 
             options.uuid = req.params.uuids &&
                 req.params.uuids.split(new RegExp('\s*,\s*', 'g'));
@@ -1006,42 +1007,17 @@ Server.resumeCnAgent = function handlerResumeCnAgent(req, res, next) {
     });
 };
 
-/*
- * This endpoint has only one job. That's to update the value of:
- *
- *     app.observedHeartbeats[serverUuid].last_heartbeat
- *
- * to the current timestamp, indicating that we just got a heartbeat for this
- * server. The actual processing of these heartbeats happens elsewhere via a
- * periodic timer.
- */
 Server.eventHeartbeat = function handlerServerEventHeartbeat(req, res, next) {
-    var app = req.stash.app;
     var rules = {
         'server_uuid': ['isStringType']
     };
-    var serverUuid;
 
     if (validation.ensureParamsValid(req, res, rules, { strict: true })) {
         next();
         return;
     }
-
-    serverUuid = req.params.server_uuid;
-
-    if (!app.observedHeartbeats) {
-        app.observedHeartbeats = {};
-    }
-
-    if (!app.observedHeartbeats[serverUuid]) {
-        app.observedHeartbeats[serverUuid] = {
-            server_uuid: serverUuid
-        };
-    }
-
-    app.observedHeartbeats[serverUuid].last_heartbeat =
-        (new Date()).toISOString();
-
+    var server = new ModelServer(req.params.server_uuid);
+    server.onHeartbeat();
     res.send(204);
     next();
 };
diff --git a/lib/heartbeat_reconciler.js b/lib/heartbeat_reconciler.js
deleted file mode 100644
index 59dc4d4..0000000
--- a/lib/heartbeat_reconciler.js
+++ /dev/null
@@ -1,416 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2018, Joyent, Inc.
- */
-
-/*
- * This file contains the logic used to reconcile the heartbeats we receive
- * from cn-agent via the /servers/:server_uuid/events/heartbeat which are
- * written to CNAPI memory, with the cnapi_status bucket in Moray and the
- * 'status' field of servers. It sets servers' status to 'running' when it sees
- * a current heartbeat, and sets the status to 'unknown' when there has been no
- * heartbeat within HEARTBEAT_LIFETIME_SECONDS so long as no other CNAPI
- * instance has received a more recent heartbeat.
- */
-
-var assert = require('assert-plus');
-var vasync = require('vasync');
-var VError = require('verror');
-
-var buckets = require('./apis/moray').BUCKETS;
-var common = require('./common');
-
-function HeartbeatReconciler(opts) {
-    var self = this;
-
-    assert.object(opts, opts);
-    assert.object(opts.app, 'opts.app');
-    assert.object(opts.log, 'opts.log');
-    assert.object(opts.metricsManager, 'opts.metricsManager');
-    assert.object(opts.moray, 'opts.moray');
-
-    self.app = opts.app;
-    self.log = opts.log;
-    self.metricsManager = opts.metricsManager;
-    self.moray = opts.moray;
-
-    self.newHeartbeatersCounter = self.metricsManager.collector.counter({
-        name: 'reconciler_new_heartbeaters_total',
-        help: 'Counter incremented whenever a server starts heartbeating ' +
-            'that has not been seen in CNAPIs recent memory'
-    });
-    self.newHeartbeatersCounter.add(0);
-
-    self.staleHeartbeatersCounter = self.metricsManager.collector.counter({
-        name: 'reconciler_stale_heartbeaters_total',
-        help: 'Number of times servers failed to heartbeat within the ' +
-            'heartbeat lifetime'
-    });
-    self.staleHeartbeatersCounter.add(0);
-
-    self.usurpedHeartbeatersCounter = self.metricsManager.collector.counter({
-        name: 'reconciler_usurped_heartbeaters_total',
-        help: 'Number of times another CNAPI has seen more recent heartbeats ' +
-            'for a server'
-    });
-    self.usurpedHeartbeatersCounter.add(0);
-
-    self.serverPutsCounter = self.metricsManager.collector.counter({
-        name: 'reconciler_server_put_total',
-        help: 'Number of times putObject was attempted for a cnapi_servers ' +
-            'record to update the status field'
-    });
-    self.serverPutsCounter.add(0);
-
-    self.serverPutEtagFailuresCounter = self.metricsManager.collector.counter({
-        name: 'reconciler_server_put_etag_failures_total',
-        help: 'Number Etag failures while trying to put cnapi_servers objects'
-    });
-    self.serverPutEtagFailuresCounter.add(0);
-
-    self.serverPutFailuresCounter = self.metricsManager.collector.counter({
-        name: 'reconciler_server_put_failures_total',
-        help: 'Total number of failures trying to put cnapi_servers objects'
-    });
-    self.serverPutFailuresCounter.add(0);
-
-    self.statusPutsCounter = self.metricsManager.collector.counter({
-        name: 'reconciler_status_put_total',
-        help: 'Number of times putObject was attempted for a cnapi_status ' +
-            'record to update the last_heartbeat'
-    });
-    self.statusPutsCounter.add(0);
-
-    self.statusPutEtagFailuresCounter = self.metricsManager.collector.counter({
-        name: 'reconciler_status_put_etag_failures_total',
-        help: 'Number Etag failures while trying to put cnapi_status objects'
-    });
-    self.statusPutEtagFailuresCounter.add(0);
-
-    self.statusPutFailuresCounter = self.metricsManager.collector.counter({
-        name: 'reconciler_status_put_failures_total',
-        help: 'Total number of failures trying to put cnapi_status objects'
-    });
-    self.statusPutFailuresCounter.add(0);
-}
-
-HeartbeatReconciler.prototype._serverUpdate =
-function heartbeatServerUpdate(serverUuid, opts, callback) {
-    var self = this;
-
-    assert.object(opts, 'opts');
-    assert.string(opts.nowISO, 'opts.nowISO');
-    assert.string(opts.stale, 'opts.stale');
-
-    var cnapiStatusBucket = buckets.status.name;
-    var cnapiServersBucket = buckets.servers.name;
-    var moray = self.moray;
-    var observedStatus = self.app.observedHeartbeats[serverUuid];
-
-    if (observedStatus.last_status_update === undefined) {
-        // We either haven't seen this server before, or we lost our memory
-        // of it. Either way it is new-to-us.
-        self.newHeartbeatersCounter.increment();
-    }
-
-    vasync.pipeline({arg: {}, funcs: [
-        function _getStatusObject(ctx, cb) {
-            // Get the existing cnapi_status entry (if any) for this server.
-            moray.getObject(cnapiStatusBucket, serverUuid,
-                function _onGetObject(err, obj) {
-                    if (!err) {
-                        ctx.statusEtag = obj._etag;
-                        ctx.statusObj = obj.value;
-                        cb();
-                        return;
-                    }
-
-                    if (VError.hasCauseWithName(err, 'ObjectNotFoundError')) {
-                        cb();
-                        return;
-                    }
-
-                    self.log.error({
-                        err: err,
-                        serverUuid: serverUuid
-                    }, 'Error getting cnapi_status object from Moray');
-                    cb(err);
-                });
-        }, function _checkForTakeover(ctx, cb) {
-            if (!ctx.curStatusObj) {
-                // If there's no record in cnapi_status, no other CNAPI knows
-                // about this server either.
-                cb();
-                return;
-            }
-
-            if (ctx.statusObj.last_heartbeat > observedStatus.last_heartbeat) {
-                // Some CNAPI has inserted a newer heartbeat into moray.
-                if (ctx.statusObj.cnapi_instance === self.app.cnapi_instance) {
-                    self.log.error({
-                        cnapiInstance: self.app.cnapi_instance,
-                        existingHeartbeat: ctx.statusObj.last_heartbeat,
-                        newHeartbeat: observedStatus.last_heartbeat,
-                        serverUuid: serverUuid
-                    }, 'Malfunction: cnapi_status heartbeat from the future');
-                } else {
-                    self.log.debug({
-                        serverUuid: serverUuid,
-                        usurper: ctx.statusObj.cnapi_instance
-                    }, 'Another CNAPI took over for server we lost.');
-                    // Delete from our memory, if it comes back we treat as new.
-                    delete self.app.observedHeartbeats[serverUuid];
-                    self.usurpedHeartbeatersCounter.increment();
-                }
-                // In any case, we'll not overwrite a newer last_heartbeat.
-                ctx.skip = true;
-                cb();
-                return;
-            }
-
-            /*
-             * Here we know:
-             *
-             *  - there's an existing record for this server in cnapi_status
-             *  - the existing record has an older last_heartbeat than we've
-             *    seen
-             *
-             * so we'll plow forward and update, since we have newer intel.
-             *
-             */
-             cb();
-        }, function _putStatusObject(ctx, cb) {
-            ctx.didPut = false;
-
-            if (ctx.skip) {
-                cb();
-                return;
-            }
-
-            self.statusPutsCounter.increment();
-
-            moray.putObject(cnapiStatusBucket, serverUuid, {
-                cnapi_instance: self.app.cnapi_instance,
-                last_heartbeat: observedStatus.last_heartbeat,
-                server_uuid: serverUuid
-            }, { etag: ctx.statusEtag }, function _onPutObject(err) {
-                if (err) {
-                    self.statusPutFailuresCounter.increment();
-
-                    self.log.error({
-                        err: err,
-                        serverUuid: serverUuid
-                    }, 'Error putting cnapi_status object to Moray');
-
-                    if (VError.hasCauseWithName(err, 'EtagConflictError')) {
-                        // If the put fails due to Etag conflict (or any other
-                        // error), we'll record it but not do anything else.
-                        // Since the state won't have changed unless we got a
-                        // fresh heartbeat, we'll just try again next time the
-                        // reconciler is run.
-                        self.statusPutEtagFailuresCounter.increment();
-                    }
-                } else {
-                    // Update our observed state to indicate we've written now.
-                    observedStatus.last_status_update = opts.nowISO;
-                    ctx.didPut = true;
-                }
-
-                cb(err);
-            });
-        }, function _evaluateNeedForUpdatingServerStatus(ctx, cb) {
-            if (ctx.skip || !ctx.didPut) {
-                cb();
-                return;
-            }
-
-            // If we got here, we updated the record in cnapi_servers, so we
-            // want to make sure the 'status' is correct in the server object.
-            if (observedStatus.last_heartbeat !== undefined &&
-                observedStatus.last_heartbeat < opts.stale) {
-
-                // Lifetime of last heartbeat expired, we don't know status but
-                // no other CNAPI could know either (since we'd not get here
-                // unless we just put the cnapi_status record).
-                ctx.newServerStatus = 'unknown';
-                self.staleHeartbeatersCounter.increment();
-            } else {
-                ctx.newServerStatus = 'running';
-            }
-
-            self.log.trace({
-                newStatus: ctx.newServerStatus,
-                serverUuid: serverUuid
-            }, 'Will update "status" for server');
-
-            if (ctx.newServerStatus === 'unknown') {
-                // We're not in control of this server any more. Delete from our
-                // memory and treat as new if it shows up again.
-                delete self.app.observedHeartbeats[serverUuid];
-            }
-
-            cb();
-        }, function _getExistingServerObj(ctx, cb) {
-            if (ctx.newServerStatus === undefined) {
-                // We're only here to get the server object so we can update it,
-                // if we're not updating it, no need to grab current object.
-                cb();
-                return;
-            }
-
-            moray.getObject(cnapiServersBucket, serverUuid,
-                function _gotServerObject(err, serverObj) {
-                    if (err) {
-                        // If there was any error getting the server (including
-                        // NotFound) we won't be able to do a put even though we
-                        // might already have updated the last_heartbeat in
-                        // cnapi_status. So what we do is remove our in-memory
-                        // record of this server so that next time it heartbeats
-                        // and the reconciler runs, we'll treat it as a new
-                        // server and try again.
-                        self.log.error({
-                            err: err,
-                            serverUuid: serverUuid
-                        }, 'Error getting cnapi_servers object from Moray');
-                        delete self.app.observedHeartbeats[serverUuid];
-                        cb(err);
-                        return;
-                    }
-
-                    if (serverObj.value.status === ctx.newServerStatus) {
-                        self.log.debug({
-                            newStatus: ctx.newServerStatus,
-                            serverUuid: serverUuid
-                        }, 'Server already has target status no update needed');
-                    } else {
-                        ctx.serverEtag = serverObj._etag;
-                        ctx.serverObj = serverObj.value;
-                    }
-
-                    cb();
-                });
-        }, function _putServerObj(ctx, cb) {
-            var newServerObj;
-
-            if (ctx.serverObj === undefined) {
-                // We're only here to put the updated server object. If we
-                // didn't load a server record, there's nothing to update.
-                cb();
-                return;
-            }
-
-            assert.string(ctx.newServerStatus, 'ctx.newServerStatus');
-
-            newServerObj = ctx.serverObj;
-            newServerObj.status = ctx.newServerStatus;
-
-            self.serverPutsCounter.increment();
-
-            moray.putObject(cnapiServersBucket, serverUuid, newServerObj,
-                {etag: ctx.serverEtag}, function _onPutServer(err) {
-
-                if (err) {
-                    self.serverPutFailuresCounter.increment();
-                    self.log.error({
-                        err: err,
-                        serverUuid: serverUuid
-                    }, 'Error updating server in moray');
-
-                    if (VError.hasCauseWithName(err, 'EtagConflictError')) {
-                        self.serverPutEtagFailuresCounter.increment();
-                    }
-
-                    // On *any* error putting the new server record, we'll
-                    // remove the in-memory state for this server. This way on
-                    // the next reconciliation after the next heartbeat, we'll
-                    // treat it as a new server and try to update it again.
-                    delete self.app.observedHeartbeats[serverUuid];
-                }
-
-                cb(err);
-            });
-        }
-    ]}, function _updatePipelineComplete(err) {
-        callback(err);
-    });
-};
-
-/*
- * In the server_status bucket we have objects that look like:
- *
- *   {
- *       "server_uuid": <uuid>,
- *       "last_heartbeat": <timestamp>,
- *       "cnapi_instance": <uuid>
- *   }
- *
- * In each CNAPI instance we also maintain the ModelServer.heartbeatByServerUuid
- *
- */
-HeartbeatReconciler.prototype.reconcile =
-function heartbeatReconcile(callback) {
-    var self = this;
-
-    var expirationMs = (common.HEARTBEAT_LIFETIME_SECONDS * 1000);
-    var now = Date.now();
-    var nowISO = new Date(now).toISOString();
-    var stale = new Date(now - expirationMs).toISOString();
-    var toUpdate = [];
-    var uuids = Object.keys(self.app.observedHeartbeats);
-
-    self.log.trace({
-        nowISO: nowISO,
-        numUuids: uuids.length,
-        stale: stale
-    }, 'Running heartbeat reconciler.');
-
-    function _selectServersToUpdate(serverUuid) {
-        var server = self.app.observedHeartbeats[serverUuid];
-
-        if (server.last_status_update === undefined) {
-            // If there's no last_status_update it's new to us and we need
-            // to update since we don't know the history.
-            self.log.trace({server: server},
-                'No last_status_update for server, selecting for update.');
-            return true;
-        }
-
-        if (server.last_heartbeat !== undefined &&
-            server.last_heartbeat < stale) {
-
-            // If the last_heartbeat is stale, we need to update status to
-            // 'unknown' unless some other CNAPI is now seeing it.
-            self.log.trace({server: server}, 'last_heartbeat is stale, need ' +
-                'to update with the last one we actually saw.');
-            return true;
-        }
-
-        // No need to update the status otherwise.
-        self.log.trace({server: server}, 'No need to update heartbeat status');
-        return false;
-    }
-
-    toUpdate = uuids.filter(_selectServersToUpdate);
-
-    /*
-     * We do this serially to try to cause minimum disruption to other things
-     * going on.
-     */
-    vasync.forEachPipeline({
-        func: function _updateServer(serverUuid, cb) {
-            self._serverUpdate(serverUuid, {
-                nowISO: nowISO,
-                stale: stale
-            }, cb);
-        },
-        inputs: toUpdate
-    }, function _pipelineComplete(err) {
-        callback(err);
-    });
-};
-
-module.exports = HeartbeatReconciler;
diff --git a/lib/models/server.js b/lib/models/server.js
index 6c2215e..cb77f18 100644
--- a/lib/models/server.js
+++ b/lib/models/server.js
@@ -22,7 +22,6 @@ var qs = require('querystring');
 var restify = require('restify');
 var sprintf = require('sprintf').sprintf;
 var util = require('util');
-var vasync = require('vasync');
 var VError = require('verror');
 var once = require('once');
 
@@ -95,6 +94,7 @@ ModelServer.init = function (app) {
 
     ModelServer.tasks = {};
     ModelServer.log = app.getLog();
+    ModelServer.heartbeatByServerUuid = {};
 };
 
 
@@ -146,6 +146,8 @@ ModelServer.list = function (params, callback) {
 
     this.log.debug(params, 'Listing servers');
 
+    var wantFinal = params.wantFinal;
+
     var filterParams = [
         'datacenter',
         'setup',
@@ -214,47 +216,78 @@ ModelServer.list = function (params, callback) {
     }
 
     var servers = [];
+    var serverStatus = {};
 
-    var req = moray.findObjects(
-        buckets.servers.name,
-        filter,
-        findOpts);
 
-    req.on('error', _onError);
-    req.on('record', _onRecord);
-    req.on('end', _onEnd);
+    async.parallel([
+        // Get all server records
+        function (next) {
+            var req = moray.findObjects(
+                buckets.servers.name,
+                filter,
+                findOpts);
 
-    function _onError(error) {
-        self.log.error(error, 'error retriving servers');
-        callback(error);
-    }
+            req.on('error', onError);
+            req.on('record', onRecord);
+            req.on('end', next);
 
-    function _onRecord(server) {
-        servers.push(server.value);
-    }
+            function onError(error) {
+                self.log.error(error, 'error retriving servers');
+                next(error);
+            }
+
+            function onRecord(server) {
+                servers.push(server.value);
+            }
+        },
+
+        // Get all server record last_heartbeat data
+        function (next) {
+            // XXX write me a getAllServerStatuses function that can return >
+            // 1000 results
+            if (extras.last_heartbeat === false) {
+                next();
+                return;
+            }
+
+            var req = moray.findObjects(
+                buckets.status.name, '(server_uuid=*)', {});
 
-    function _onEnd() {
+            req.on('error', onError);
+            req.on('record', onRecord);
+            req.on('end', next);
+
+            function onError(error) {
+                self.log.error(error, 'error retriving last_heartbeats');
+                next(error);
+            }
+
+            function onRecord(status) {
+                serverStatus[status.value.server_uuid] =
+                    status.value;
+            }
+        }
+    ], function (err) {
+        processResults(err);
+    });
+
+    function processResults(err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        if (!wantFinal) {
+            callback(null, servers);
+            return;
+        }
         async.map(
             servers,
             function (server, cb) {
-                var heartbeatInfo =
-                    ModelServer.getApp().observedHeartbeats[server.uuid];
                 var serverModel = new ModelServer(server.uuid);
 
-                if (extras.last_heartbeat === true) {
-                    /*
-                     * IMPORTANT:
-                     *
-                     * extras=last_heartbeat is deprecated, it will removed in a
-                     * future version.
-                     */
-                    if (heartbeatInfo &&
-                        heartbeatInfo.last_heartbeat !== undefined) {
-
-                        server.last_heartbeat = heartbeatInfo.last_heartbeat;
-                    } else {
-                        server.last_heartbeat = null;
-                    }
+                if (serverStatus.hasOwnProperty(server.uuid)) {
+                    server.last_heartbeat =
+                        serverStatus[server.uuid].last_heartbeat;
                 }
 
                 serverModel.setRaw(server);
@@ -625,7 +658,7 @@ ModelServer.prototype.filterFields = function (fields, callback) {
 
 
 ModelServer.prototype.updateFromVmsUpdate =
-function (vmsUpdate, callback) {
+function (heartbeat, callback) {
     var self = this;
 
     var serverobj = {};
@@ -643,6 +676,9 @@ function (vmsUpdate, callback) {
         // Update the server's disk
         updateDisk,
 
+        // Update the server status
+        updateStatus,
+
         // Write the change to moray
         writeServerRecord
     ],
@@ -653,7 +689,7 @@ function (vmsUpdate, callback) {
     function getServer(cb) {
         self.getRaw(function (err, so, s) {
             if (err) {
-                cb(new VError(err, 'retrieving server on VMs update'));
+                cb(new VError(err, 'retrieving server on heartbeat'));
                 return;
             }
 
@@ -665,7 +701,7 @@ function (vmsUpdate, callback) {
     function initializeServer(cb) {
         if (!serverobj) {
             self.log.info(
-                'VMs update server %s was not found in moray, ' +
+                'heartbeat server %s was not found in moray, ' +
                 'initializing new server record', self.uuid);
             // Initialize new server record from default params
             ModelServer.initialValues({}, function (error, so) {
@@ -685,7 +721,7 @@ function (vmsUpdate, callback) {
             if (!serverobj.sysinfo) {
                 ModelServer.getApp().needSysinfoFromServer(self.uuid);
             }
-            ModelServer.carryForwardVMChanges(vmsUpdate, serverobj);
+            ModelServer.carryForwardVMChanges(heartbeat, serverobj);
         }
 
         cb();
@@ -702,10 +738,10 @@ function (vmsUpdate, callback) {
             ['total_bytes', 'memory_total_bytes'] ];
 
         memoryKeys.forEach(function (keys) {
-            if (vmsUpdate.meminfo &&
-                vmsUpdate.meminfo.hasOwnProperty(keys[0]))
+            if (heartbeat.meminfo &&
+                heartbeat.meminfo.hasOwnProperty(keys[0]))
             {
-                serverobj[keys[1]] = vmsUpdate.meminfo[keys[0]];
+                serverobj[keys[1]] = heartbeat.meminfo[keys[0]];
             } else {
                 self.log.warn('update missing "%s" property', keys[0]);
             }
@@ -725,9 +761,9 @@ function (vmsUpdate, callback) {
             total_memory_bytes - (total_memory_bytes * reservation_ratio);
 
         serverobj.memory_provisionable_bytes -= 1024 * 1024 *
-            Object.keys(vmsUpdate.vms)
+            Object.keys(heartbeat.vms)
                 .map(function (uuid) {
-                    return vmsUpdate.vms[uuid];
+                    return heartbeat.vms[uuid];
                 })
                 .reduce(function (prev, curr) {
                     return prev + curr.max_physical_memory;
@@ -755,10 +791,10 @@ function (vmsUpdate, callback) {
         ];
 
         diskKeys.forEach(function (keys) {
-            if (vmsUpdate.diskinfo &&
-                vmsUpdate.diskinfo.hasOwnProperty(keys[0]))
+            if (heartbeat.diskinfo &&
+                heartbeat.diskinfo.hasOwnProperty(keys[0]))
             {
-                serverobj[keys[1]] = vmsUpdate.diskinfo[keys[0]];
+                serverobj[keys[1]] = heartbeat.diskinfo[keys[0]];
             } else {
                 self.log.warn('update missing "%s" property', keys[0]);
             }
@@ -767,6 +803,12 @@ function (vmsUpdate, callback) {
         cb();
     }
 
+    function updateStatus(cb) {
+        serverobj.status = 'running';
+        serverobj.last_heartbeat = (new Date()).toISOString();
+        cb();
+    }
+
     function writeServerRecord(cb) {
         self.modify(serverobj, function (err) {
             if (err) {
@@ -810,9 +852,6 @@ ModelServer.prototype.getRaw = function (extras, callback) {
             buckets.servers.name,
             uuid,
             function (error, obj) {
-                var heartbeatInfo =
-                    ModelServer.getApp().observedHeartbeats[uuid];
-
                 if (error && VError.hasCauseWithName(error,
                                                      'ObjectNotFoundError'))
                 {
@@ -831,34 +870,41 @@ ModelServer.prototype.getRaw = function (extras, callback) {
                 server = clone(obj.value);
                 self.value = obj.value;
 
-                /*
-                 * If:
-                 *
-                 *  - we're the only CNAPI, or we happen to be the CNAPI
-                 *    handling this CN
-                 *  - the server is running
-                 *  - the caller requested extras=last_heartbeat
-                 *
-                 * we'll include the last_heartbeat value we've got. Otherwise
-                 * we'll set it to null.
-                 *
-                 * NOTE: this field is deprecated, and still exists only for
-                 * backward compatibility. All code for extras=last_heartbeat
-                 * can be removed in a future version.
-                 *
-                 */
+
                 if (extras.last_heartbeat) {
-                    if (heartbeatInfo &&
-                        heartbeatInfo.last_heartbeat !== undefined) {
-
-                        self.value.last_heartbeat = server.last_heartbeat =
-                            heartbeatInfo.last_heartbeat;
-                    } else {
-                        self.value.last_heartbeat =
-                            server.last_heartbeat = null;
-                    }
+                    ModelServer.getMoray().getObject(
+                        buckets.status.name,
+                        uuid,
+                        function (getStatusError, statusObj) {
+                            if (getStatusError &&
+                                VError.hasCauseWithName(getStatusError,
+                                                        'ObjectNotFoundError'))
+                            {
+                                self.log.error(
+                                    'last_heartbeat for %s not found in moray',
+                                    uuid);
+
+                                self.value.last_heartbeat =
+                                    server.last_heartbeat =
+                                    null;
+
+                                callback(null, server);
+                                return;
+                            } else if (getStatusError) {
+                                self.log.error(getStatusError,
+                                    'Error fetching last heartbeat from moray');
+                                callback(error);
+                                return;
+                            }
+
+                            self.value.last_heartbeat =
+                                server.last_heartbeat =
+                                statusObj.value.last_heartbeat;
+                            callback(null, server);
+                        });
+                } else {
+                    callback(null, server);
                 }
-                callback(null, server);
             });
     }
 };
@@ -1066,6 +1112,264 @@ ModelServer.prototype.modify = function (server, callback) {
 };
 
 
+
+/**
+ * This function is invoked whenever a heartbeat is received from a compute
+ * node. It takes care of refreshing two timeouts:
+ *
+ *     1) the timeout responsible for changing status => running/unknown.
+ *
+ *     2) the timeout responsible for throttling incoming heartbeats to prevent
+ *        overly taxing moray with heartbeats which are already out of date.
+ *
+ *
+ * It is also is responsible for writing `last_heartbeat` to a server's
+ * `cnapi_status` bucket in moray.
+ *
+ * The goal of this is to accept new heartbeats and if we receive a heartbeat
+ * while another is being written out to moray for the same server, stage it,
+ * and then write it out when the original heartbeat write operation returns,
+ * or a timeout is exhausted.
+ */
+
+ModelServer.prototype.onHeartbeat = function () {
+    var self = this;
+    var uuid = self.uuid;
+
+    ModelServer.getApp().refreshServerHeartbeatTimeout(self.uuid);
+
+    if (!ModelServer.getApp().collectedGlobalSysinfo) {
+        return;
+    }
+
+    if (!ModelServer.getMoray().connected) {
+        self.log.warn(
+            'cannot refresh server from heartbeat: cannot reach moray');
+        return;
+    }
+
+
+    if (!ModelServer.heartbeatByServerUuid) {
+        ModelServer.heartbeatByServerUuid = {};
+    }
+
+    if (!ModelServer.heartbeatByServerUuid[uuid]) {
+        ModelServer.heartbeatByServerUuid[uuid] = {};
+    }
+
+    var heartbeat = {
+        server_uuid: uuid,
+        last_heartbeat: (new Date()).toISOString()
+    };
+
+    // Check if we are still processing a heartbeat for this server: When we
+    // begin processing a heartbeat we check if this value is set. If it is, we
+    // override the `next` value and return. In this way we avoid having
+    // multiple concurrent writes to moray for single server.
+
+    if (ModelServer.heartbeatByServerUuid[uuid].current) {
+        ModelServer.heartbeatByServerUuid[uuid].next = heartbeat;
+        self.log.warn('already writing heartbeat from %s @ %s', uuid,
+        ModelServer.heartbeatByServerUuid[uuid].current.last_heartbeat);
+
+        if (ModelServer.heartbeatByServerUuid[uuid].timeout) {
+            clearTimeout(ModelServer.heartbeatByServerUuid[uuid].timeout);
+            writeNext();
+        } else {
+            resetTimeout();
+        }
+
+        return;
+    } else {
+        ModelServer.heartbeatByServerUuid[uuid] = {
+            current: heartbeat
+        };
+    }
+
+    // Set a timeout to clear the `current` value. If it is not set, we set a
+    // timeout to clear it. The reason for the timeout is do not end up stuck
+    // in this state (and end up ignoring future heartbeats).
+    resetTimeout();
+
+    doPut();
+
+    function doPut() {
+        ModelServer.getMoray().putObject(
+            buckets.status.name,
+            self.uuid,
+            heartbeat,
+            function (error) {
+                if (error) {
+                    self.log.error(error, 'modifying server last_heartbeat');
+                }
+
+                // If `.next` is set for this server once we've written the
+                // value to moray, it means we have a new heartbeat staged for
+                // writing into moray. If not set, do nothing, wait for next
+                // heartbeat to come in as usual.
+                if (ModelServer.heartbeatByServerUuid[uuid].next) {
+                    writeNext();
+                    return;
+                } else {
+                    clearTimeout(
+                        ModelServer.heartbeatByServerUuid[uuid].timeout);
+                    ModelServer.heartbeatByServerUuid[uuid] = {};
+                }
+            });
+    }
+
+
+    return;
+
+    function resetTimeout() {
+        clearTimeout(ModelServer.heartbeatByServerUuid[uuid].timeout);
+        ModelServer.heartbeatByServerUuid[uuid].timeout =
+            setTimeout(function () {
+                self.log.warn('firing heartbeatByServer timeout for %s');
+                // write the "next" heartbeat
+                writeNext();
+            }, common.HEARTBEATER_PERIOD * 2 * 1000);
+    }
+
+    function writeNext() {
+        if (!ModelServer.heartbeatByServerUuid[uuid].next) {
+            self.log.warn('onHeartbeat/writeNext called but .next not set');
+            return;
+        }
+
+        var nextHb = ModelServer.heartbeatByServerUuid[uuid].next;
+        delete ModelServer.heartbeatByServerUuid[uuid].next;
+        ModelServer.heartbeatByServerUuid[uuid].current = nextHb;
+        doPut();
+    }
+};
+
+
+/**
+ * Fetch from moray the stored `last_heartbeat` value for a given compute node.
+ */
+
+ModelServer.prototype.getLastHeartbeat =
+function Server$getLastHeartbeat(callback) {
+    var self = this;
+    var uuid = this.uuid;
+
+    ModelServer.getMoray().getObject(
+        buckets.status.name,
+        uuid,
+        onGetObject);
+
+    function onGetObject(error, obj) {
+        if (error && VError.hasCauseWithName(error, 'ObjectNotFoundError')) {
+            self.log.error(
+                'last_heartbeat for %s not found in moray', uuid);
+            callback();
+            return;
+        } else if (error) {
+            self.log.error(
+                error, 'error fetching last_heartbeat from moray');
+            callback(error);
+            return;
+        }
+
+        callback(null, obj.value.last_heartbeat);
+    }
+};
+
+
+/**
+ * This is called when we have determined that the sime since last heartbeat
+ * for a given compute has exceeded the threshold for us to consider it
+ * reachable.
+ */
+ModelServer.prototype.onHeartbeatTimeoutExpired = function () {
+    var self = this;
+
+    self.log.warn('server %s heartbeat timeout', self.uuid);
+
+    var uuid = self.uuid;
+    var lasthb;
+    var server, serverobj;
+
+    clearTimeout(ModelServer.getApp().statusTimeouts[uuid]);
+    ModelServer.getApp().statusTimeouts[uuid] = null;
+
+    // Get server
+    // Get last_heartbeat
+    // modify server status if last_heartbeat is not within range
+
+    async.waterfall([
+        getLastHeartbeat,
+        getServer,
+        function (next) {
+            if (!serverobj) {
+                self.log.info(
+                    { uuid: uuid },
+                    'could not find server');
+                return next();
+            }
+            var now = Date.now();
+            var then = new Date(lasthb).valueOf();
+            var timeout = common.HEARTBEATER_PERIOD;
+
+            if ((now - then) > timeout * 2 * 1000) {
+                server.modify({ status: 'unknown' }, function (err) {
+                    if (err) {
+                        self.log.error(err);
+                    }
+                    self.log.warn(
+                        { uuid: uuid },
+                        'no heartbeat from server in %d ' +
+                        'seconds, status => unknown',
+                        common.HEARTBEATER_PERIOD);
+                });
+            } else {
+                // It we got here it me means we didn't receive a heartbeat
+                // from that server before our timeout, but when we checked
+                // the server the last_heartbeat timestamp appears to have
+                // been updated by another cnapi instance. Everything is
+                // okay.
+                self.log.info(
+                    { uuid: uuid },
+                    'no heartbeat from server but last_heartbeat looks ' +
+                    'ok (now=%d then=%d d=%d)',
+                    now, then, now-then);
+            }
+        }
+    ],
+    function (err) {
+        if (err) {
+            self.log.error(err,
+                'writing status after server heartbeat timeout exceeeded');
+        }
+    });
+
+    function getLastHeartbeat(next) {
+        self.getLastHeartbeat(function (err, hb) {
+            if (err) {
+                return next(err);
+            }
+            lasthb = hb;
+            next();
+        });
+    }
+
+    function getServer(next) {
+        ModelServer.get(uuid, function (err, s, so) {
+            if (err) {
+                self.log.error(
+                    err,
+                    'error looking up server with expired heartbeat timer');
+            }
+            server = s;
+            serverobj = so;
+            next();
+        });
+    }
+};
+
+
+
 function clone(obj, dest) {
     var target = dest ? dest : ((obj instanceof Array) ? [] : {});
     for (var i in obj) {
@@ -1199,11 +1503,11 @@ ModelServer.prototype.getFinal = function (/* extras, */ callback) {
 
 
 /**
- * Compare the VMs given in a vmUpdate with those stored in moray for a
+ * Compare the VMs given in a heartbeat with those stored in moray for a
  * particular server.
  */
 ModelServer.carryForwardVMChanges =
-function (vmsUpdate, serverobj) {
+function (heartbeat, serverobj) {
     var self = this;
 
     var vms = {};
@@ -1214,26 +1518,26 @@ function (vmsUpdate, serverobj) {
         serverobj.vms = {};
     }
 
-    if (!vmsUpdate.vms) {
-        self.log.warn({ server: this.uuid }, 'VMs update missing VMs');
+    if (!heartbeat.vms) {
+        self.log.warn({ server: this.uuid }, 'heartbeat vms member empty');
         serverobj.vms = {};
         return;
     }
 
-    for (vmuuid in vmsUpdate.vms) {
+    for (vmuuid in heartbeat.vms) {
         if (!serverobj.vms[vmuuid]) {
             self.log.trace({ vm_uuid: vmuuid },
-                'VMs update shows vm changed (now exists)');
+                           'heartbeat shows vm changed (now exists)');
         }
 
-        vms[vmuuid] = vmsUpdate.vms[vmuuid];
+        vms[vmuuid] = heartbeat.vms[vmuuid];
 
         if (serverobj.vms[vmuuid] &&
             serverobj.vms[vmuuid].last_modified !==
-            vmsUpdate.vms[vmuuid].last_modified)
+            heartbeat.vms[vmuuid].last_modified)
         {
             self.log.trace({ vm_uuid: vmuuid },
-                'changed because last modified changed');
+                           'changed because last modified changed');
         }
     }
 
diff --git a/package.json b/package.json
index e59d330..771ed66 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "cnapi",
   "description": "SmartDataCenter Compute Node API",
-  "version": "1.11.5",
+  "version": "1.11.4",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
@@ -13,7 +13,6 @@
     "deep-equal": "1.0.1",
     "dox": "0.9.0",
     "effluent-logger": "git+https://github.com/joshwilsdon/effluent-logger.git#d662f161a07f94045ad2afb45442931511c40e51",
-    "gc-stats": "1.2.0",
     "jsprim": "1.4.1",
     "libuuid": "0.2.1",
     "moray": "3.5.0",
@@ -24,7 +23,7 @@
     "sdc-clients": "10.0.3",
     "sprintf": "0.1.5",
     "trace-event": "1.3.0",
-    "triton-metrics": "0.3.0",
+    "triton-metrics": "0.1.1",
     "vasync": "1.6.4",
     "verror": "1.9.0",
     "wf-client": "0.2.1",
