From 41a2e264a4e0ff9ab3bf08a793f10ab546abb6df Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Tue, 8 Oct 2019 21:17:36 +0000
Subject: [PATCH] use node-qlocker instead of locker.js

---
 lib/backends/smartos/lib/update-wait-flag.js |   4 +-
 node_modules/locker.js                       | 174 -------------------
 package.json                                 |   3 +-
 3 files changed, 4 insertions(+), 177 deletions(-)
 delete mode 100755 node_modules/locker.js

diff --git a/lib/backends/smartos/lib/update-wait-flag.js b/lib/backends/smartos/lib/update-wait-flag.js
index e940ac0..76fd1fe 100644
--- a/lib/backends/smartos/lib/update-wait-flag.js
+++ b/lib/backends/smartos/lib/update-wait-flag.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  *
  * EXPLANATION:
  *
@@ -47,7 +47,7 @@
  */
 
 var fs = require('fs');
-var lock = require('locker').lock;
+var lock = require('qlocker').lock;
 
 function setWaitFlag(uuid, filename, timeout, log, callback)
 {
diff --git a/node_modules/locker.js b/node_modules/locker.js
deleted file mode 100755
index 85fb7dd..0000000
--- a/node_modules/locker.js
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (c) 2015, Joyent, Inc. All rights reserved.
- */
-// vim: set sts=4 sw=4 et:
-
-var mod_path = require('path');
-var mod_fs = require('fs');
-var mod_assert = require('assert');
-
-var mod_lockfd = require('lockfd');
-
-// If we fail to lock (i.e. the call to fcntl() in node-lockfd), and
-// the errno is in this list, then we should back off for some delay
-// and retry.  Note that an EDEADLK, in particular, is not necessarilly
-// a permanent failure in a program using multiple lock files through
-// multiple threads of control.
-var RETRY_CODES = [
-    'EAGAIN',
-    'ENOLCK',
-    'EDEADLK'
-];
-var RETRY_DELAY = 250; // ms
-
-var LOCKFILE_MODE = 0644;
-
-var LOCKFILES = [];
-var NEXT_HOLDER_ID = 1;
-
-function lockfile_create(path) {
-    path = mod_path.normalize(path);
-
-    mod_assert.strictEqual(lockfile_lookup(path), null);
-
-    var lf = {
-        lf_path: path,
-        lf_state: 'UNLOCKED',
-        lf_cbq: [],
-        lf_fd: -1,
-        lf_holder_id: -1
-    };
-
-    LOCKFILES.push(lf);
-
-    return (lf);
-}
-
-function lockfile_lookup(path) {
-    path = mod_path.normalize(path);
-
-    for (var i = 0; i < LOCKFILES.length; i++) {
-        var lf = LOCKFILES[i];
-
-        if (lf.lf_path === path)
-            return (lf);
-    }
-
-    return (null);
-}
-
-// Make an unlock callback for this lockfile to hand to the waiter for whom
-// we acquired the lock:
-function lockfile_make_unlock(lf) {
-    var holder_id;
-
-    mod_assert.strictEqual(lf.lf_holder_id, -1);
-
-    lf.lf_holder_id = holder_id = ++NEXT_HOLDER_ID;
-
-    return (function __unlock(ulcb) {
-        mod_assert.strictEqual(lf.lf_holder_id, holder_id,
-            'mismatched lock holder or already unlocked');
-        lf.lf_holder_id = -1;
-
-        mod_assert.strictEqual(lf.lf_state, 'LOCKED');
-        mod_assert.notStrictEqual(lf.lf_fd, -1);
-
-        lf.lf_state = 'UNLOCKING';
-
-        mod_fs.close(lf.lf_fd, function (err) {
-            lf.lf_state = 'UNLOCKED';
-            lf.lf_fd = -1;
-
-            ulcb(err);
-
-            lockfile_dispatch(lf);
-        });
-    });
-}
-
-function lockfile_dispatch(lf) {
-    if (lf.lf_state !== 'UNLOCKED')
-        return;
-
-    if (lf.lf_cbq.length === 0) {
-        // No more waiters to service for now.
-        return;
-    }
-
-    lockfile_to_locking(lf);
-}
-
-function lockfile_to_locking(lf) {
-    mod_assert.strictEqual(lf.lf_state, 'UNLOCKED');
-    mod_assert.strictEqual(lf.lf_fd, -1);
-
-    lf.lf_state = 'LOCKING';
-
-    // Open the lock file, creating it if it does not exist:
-    mod_fs.open(lf.lf_path, 'w+', LOCKFILE_MODE, function __opencb(err, fd) {
-        mod_assert.strictEqual(lf.lf_state, 'LOCKING');
-        mod_assert.strictEqual(lf.lf_fd, -1);
-
-        if (err) {
-            lf.lf_state = 'UNLOCKED';
-
-            // Dispatch error to the first waiter
-            lf.lf_cbq.shift()(err);
-            lockfile_dispatch(lf);
-            return;
-        }
-
-        lf.lf_fd = fd;
-
-        // Attempt to get an exclusive lock on the file via our file
-        // descriptor:
-        mod_lockfd.lockfd(lf.lf_fd, function __lockfdcb(_err) {
-            mod_assert.strictEqual(lf.lf_state, 'LOCKING');
-
-            if (_err) {
-                var do_retry = (RETRY_CODES.indexOf(_err.code) !== -1);
-
-                // We could not lock the file, so we should close our fd now:
-                mod_fs.close(lf.lf_fd, function __closecb(__err) {
-                    // It would be most unfortunate to fail here:
-                    mod_assert.ifError(__err);
-
-                    lf.lf_fd = -1;
-                    lf.lf_state = 'UNLOCKED';
-
-                    if (do_retry) {
-                        // Back off and try again.
-                        setTimeout(function __tocb() {
-                            lockfile_dispatch(lf);
-                        }, RETRY_DELAY);
-                        return;
-                    }
-
-                    // Report the condition to the first waiter:
-                    lf.lf_cbq.shift()(_err);
-
-                    lockfile_dispatch(lf);
-                });
-                return;
-            }
-
-            lf.lf_state = 'LOCKED';
-
-            // Dispatch locking success to first waiter, with unlock callback:
-            lf.lf_cbq.shift()(null, lockfile_make_unlock(lf));
-        });
-    });
-}
-
-exports.lock = function (path, callback) {
-    var lf = lockfile_lookup(path);
-    if (!lf) {
-        lf = lockfile_create(path);
-    }
-
-    lf.lf_cbq.push(callback);
-
-    lockfile_dispatch(lf);
-
-};
diff --git a/package.json b/package.json
index 52664b5..9360f50 100644
--- a/package.json
+++ b/package.json
@@ -13,16 +13,17 @@
     "cueball": "2.7.1",
     "digest-stream": "0.2.2",
     "forkexec": "1.1.0",
+    "fs-ext": "1.3.0",
     "imgmanifest": "3.1.0",
     "jsprim": "2.0.0",
     "kstat": "1.0.1",
     "lazy-property": "1.0.0",
-    "lockfd": "1.2.0",
     "lstream": "0.0.4",
     "mkdirp": "^0.3.4",
     "nodeunit": "0.9.1",
     "once": "1.3.0",
     "pty.js": "0.3.1",
+    "qlocker": "git+https://github.com/joyent/node-qlocker.git#424110bf9b098f68c07e1aff4806ea8623c71921",
     "restify": "4.3.0",
     "rimraf": "2.4.3",
     "sdc-clients": "11.3.1",
-- 
2.17.2 (Apple Git-113)

