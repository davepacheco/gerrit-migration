commit 3e7f198ee6264b3fc4bd54f10fc3b3383992a7a3
Author: Tim Foster <tim.foster@joyent.com>
Date:   2019-09-03T12:21:48+00:00 (5 weeks ago)
    
    OS-7601 want channel support for imgadm

diff --git a/src/img/CHANGES.md b/src/img/CHANGES.md
index 52b63c41..8e7a03d5 100644
--- a/src/img/CHANGES.md
+++ b/src/img/CHANGES.md
@@ -5,6 +5,20 @@ Known issues:
 - Docker image imports are experimental. Docker image import also only supports
   Docker Registry v2.
 
+## 3.9.4
+
+- OS-7601 want channel support for imgadm.
+  This change adds channel support for 'imgapi' sources.
+
+  The 'import' subcommand takes a '-C <channel>' argument, allowing users
+  to override the channel for all configured sources.
+
+  Otherwise, channels can be specified as a component of any URL parameter, e.g.
+
+      imgadm sources -a 'https://updates.joyent.com?channel=experimental'
+      or
+      imgadm import -S 'https://updates.joyent.com?channel=experimental' <uuid>
+
 ## 3.9.3
 
 - joyent/smartos-live#771 imgadm vacuum will try to reap images used by bhyve vms
diff --git a/src/img/README.md b/src/img/README.md
index ea650a83..a10af7c0 100644
--- a/src/img/README.md
+++ b/src/img/README.md
@@ -16,7 +16,7 @@ This can only be run in the global zone (GZ).
 
 # Development
 
-The src/img tree has not binary components, so you can get away
+The src/img tree has no binary components, so you can get away
 with faster edit/test cycle than having to do a full smartos platform
 build and rebooting on it. Here is how:
 
@@ -48,6 +48,10 @@ build and rebooting on it. Here is how:
     # Or run the test suite:
     ssh root@MY-SMARTOS-BOX /var/img/test/runtests
 
+Note that at the time of writing, version 3.9.4, we have backported
+imgapi channel support to the version of sdc-clients that is included
+in `node_modules`. This solution was preferred over upgrading sdc-clients
+in order to minimize the size of the platform image.
 
 Before commits, please (a) run the test suite on a test box per the notes
 above and (b) maintain style by running `make check`.
diff --git a/src/img/lib/cli.js b/src/img/lib/cli.js
index 5ae0801c..4e9b11f8 100644
--- a/src/img/lib/cli.js
+++ b/src/img/lib/cli.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  *
  * * *
  *
@@ -485,7 +485,7 @@ CLI.prototype.printHelp = function printHelp(cb) {
         '    imgadm avail [<filters>]               list available images',
         '    imgadm show <uuid|docker-repo-tag>     show manifest of an available image',
         '',
-        '    imgadm import [-P <pool>] <image-id>   import image from a source',
+        '    imgadm import [-C <channel>] [-P <pool>] <image-id>   import image from a source',
         '    imgadm install [-P <pool>] -m <manifest> -f <file>',
         '                                           import from local image data',
         '',
@@ -1325,6 +1325,12 @@ CLI.prototype.do_import = function do_import(subcmd, opts, args, cb) {
     var log = self.log;
     var zpool = opts.P || common.DEFAULT_ZPOOL;
 
+    // reload any configured sources, using this channel argument instead
+    if (opts.channel !== undefined) {
+        self.tool.channel = opts.channel;
+        self.tool.init();
+    }
+
     vasync.pipeline({arg: {}, funcs: [
         function validateArg(ctx, next) {
             if (common.UUID_RE.test(arg)) {
@@ -1373,6 +1379,7 @@ CLI.prototype.do_import = function do_import(subcmd, opts, args, cb) {
             if (opts.source) {
                 getOpts.sources = opts.source.map(function (s) {
                     return self.tool.sourceFromInfo({
+                        channel: opts.channel,
                         url: s,
                         type: 'imgapi'
                     });
@@ -1462,6 +1469,12 @@ CLI.prototype.do_import.help = (
     + '{{options}}'
 );
 CLI.prototype.do_import.options = [
+    {
+        names: ['channel', 'C'],
+        type: 'string',
+        help: 'The channel to import from. This overrides any channel '
+            + 'parameter that may be set in the source url.'
+    },
     {
         names: ['help', 'h'],
         type: 'bool',
diff --git a/src/img/lib/imgadm.js b/src/img/lib/imgadm.js
index c60fb9fd..dc59bd02 100644
--- a/src/img/lib/imgadm.js
+++ b/src/img/lib/imgadm.js
@@ -405,11 +405,13 @@ function checkFileChecksum(opts, cb) {
 function IMGADM(options) {
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
+    assert.optionalString(options.channel, 'options.channel');
 
     this.log = options.log;
     this._manifestFromUuid = null;
     this.sources = null;
     this._db = new Database(options);
+    this.channel = options.channel;
 }
 
 IMGADM.prototype.init = function init(callback) {
@@ -447,6 +449,9 @@ IMGADM.prototype.init = function init(callback) {
         async.forEachSeries(
             sourcesInfo,
             function oneSource(sourceInfo, nextSource) {
+                if (self.channel !== undefined) {
+                    sourceInfo.channel = self.channel;
+                }
                 self._addSource(sourceInfo, true, nextSource);
             },
             function doneSources(err) {
@@ -498,6 +503,7 @@ IMGADM.prototype._addSource = function _addSource(
     assert.object(sourceInfo, 'sourceInfo');
     assert.string(sourceInfo.url, 'sourceInfo.url');
     assert.string(sourceInfo.type, 'sourceInfo.type');
+    assert.optionalString(sourceInfo.channel, 'sourceInfo.channel');
     assert.optionalBool(sourceInfo.insecure, 'sourceInfo.secure');
     assert.bool(skipPingCheck, 'skipPingCheck');
     assert.func(callback, 'callback');
@@ -508,7 +514,8 @@ IMGADM.prototype._addSource = function _addSource(
     for (var i = 0; i < self.sources.length; i++) {
         if (self.sources[i].normUrl === normUrl
             && self.sources[i].type === sourceInfo.type
-            && self.sources[i].insecure === sourceInfo.insecure)
+            && self.sources[i].insecure === sourceInfo.insecure
+            && self.sources[i].channel === sourceInfo.channel)
         {
             return callback(null, false, self.sources[i]);
         }
@@ -538,6 +545,7 @@ IMGADM.prototype.sourceFromInfo = function sourceFromInfo(sourceInfo) {
 
     return mod_sources.createSource(sourceInfo.type, {
         url: sourceInfo.url,
+        channel: sourceInfo.channel,
         insecure: sourceInfo.insecure,
         log: this.log,
         userAgent: this.userAgent,
@@ -1096,6 +1104,7 @@ IMGADM.prototype.sourcesGetImportInfo =
     assert.string(opts.arg, 'opts.arg');
     assert.optionalArrayOfObject(opts.sources, 'opts.sources');
     assert.optionalBool(opts.ensureActive, 'opts.ensureActive');
+    assert.optionalString(opts.channel, 'opts.channel');
     var ensureActive = (opts.ensureActive === undefined
             ? true : opts.ensureActive);
     assert.func(cb, 'cb');
@@ -1603,8 +1612,14 @@ IMGADM.prototype._importImage = function _importImage(opts, cb) {
         }
     };
 
-    logCb('Importing %s from "%s"',
-        source.titleFromImportInfo(opts.importInfo), source.url);
+    if (source.channel !== undefined) {
+        logCb('Importing %s from "%s", channel "%s"',
+            source.titleFromImportInfo(opts.importInfo), source.url,
+            source.channel);
+    } else {
+        logCb('Importing %s from "%s"',
+            source.titleFromImportInfo(opts.importInfo), source.url);
+    }
 
     var context = {};
     vasync.pipeline({arg: context, funcs: [
diff --git a/src/img/lib/sources/imgapi.js b/src/img/lib/sources/imgapi.js
index f51e5916..1fcb4e25 100644
--- a/src/img/lib/sources/imgapi.js
+++ b/src/img/lib/sources/imgapi.js
@@ -50,6 +50,7 @@ function ImgapiSource(opts) {
             }
             this._client = imgapi.createClient({
                 url: self.normUrl,
+                channel: self.channel,
                 version: '~2',
                 headers: headers,
                 log: self.log,
diff --git a/src/img/lib/sources/source.js b/src/img/lib/sources/source.js
index 816692f8..0b0b78e4 100644
--- a/src/img/lib/sources/source.js
+++ b/src/img/lib/sources/source.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2015, Joyent, Inc. All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -36,18 +36,24 @@ var errors = require('../errors');
 function Source(opts) {
     assert.object(opts, 'opts');
     assert.string(opts.url, 'opts.url');
+    assert.optionalString(opts.channel, 'opts.channel');
     assert.optionalBool(opts.insecure, 'opts.insecure');
     assert.object(opts.log, 'opts.log');
     assert.string(opts.userAgent, 'opts.userAgent');
 
     this.log = opts.log.child({
         component: 'source',
-        source: {type: this.type, url: this.url, insecure: opts.insecure}
+        source: {
+            type: this.type,
+            url: this.url,
+            insecure: opts.insecure,
+            channel: opts.channel}
     }, true);
     this.url = opts.url;
     this.insecure = opts.insecure;
     this.normUrl = common.normUrlFromUrl(this.url);
     this.userAgent = opts.userAgent;
+    this.channel = opts.channel;
 }
 
 /**
@@ -55,11 +61,13 @@ function Source(opts) {
  * a roundtripping serialization.
  */
 Source.prototype.toJSON = function toJSON() {
-    return {type: this.type, url: this.url, insecure: this.insecure};
+    return {type: this.type, url: this.url, insecure: this.insecure,
+        channel: this.channel};
 };
 
 Source.prototype.toString = function toString() {
     var extra = (this.insecure ? ' (insecure)' : '');
+    extra += (this.channel ? ' (channel=' + this.channel + ')' : '');
     return format('"%s" image source "%s"%s',
         this.type, this.url, extra);
 };
diff --git a/src/img/man/imgadm.1m.md b/src/img/man/imgadm.1m.md
index 1d6d9e90..c5d871f5 100644
--- a/src/img/man/imgadm.1m.md
+++ b/src/img/man/imgadm.1m.md
@@ -42,6 +42,11 @@ The manifest is a JSON serialized description.
 The identifier for an image is its UUID. Most commands operate on images by
 UUID.
 
+Image API servers that support channels can be configured as sources by
+specifying URLs with the 'channel=<channel name>' parameter. The 'import'
+command also allows a '-C' argument to override all sources and use the
+supplied channel.
+
 
 ## OPTIONS
 
@@ -76,6 +81,9 @@ UUID.
         An image source is a URL to a server implementing the IMGAPI, or
         the Docker Registry API. The default IMGAPI is https://images.joyent.com
 
+        Image API server channels can be specified by including a
+        '?channel=<channel name>' parameter as part of the supplied <url>.
+
         Usage:
             imgadm sources [--verbose|-v] [--json|-j]  # list sources
             imgadm sources -a <url> [-t <type>]        # add a source
@@ -167,8 +175,14 @@ UUID.
         Options:
             -h, --help                Show this help.
             -q, --quiet               Disable progress bar.
+            -C <channel>              Override the channel used for all sources
+                                      when looking for images.
             -P <pool>                 Name of zpool in which to look for the image.
                                       Default is "zones".
+            -S <url>                  Specify the URL from which to import the
+                                      image. The URL may include a '?channel='
+                                      parameter, but note that the -C argument,
+                                      if used, will take precedence.
 
 
     imgadm install [-P <pool>] -m <manifest> -f <file>
diff --git a/src/img/node_modules/backoff/lib/function_call.js b/src/img/node_modules/backoff/lib/function_call.js
index 6c95410c..37319d78 100644
--- a/src/img/node_modules/backoff/lib/function_call.js
+++ b/src/img/node_modules/backoff/lib/function_call.js
@@ -25,6 +25,7 @@ function FunctionCall(fn, args, callback) {
     this.backoff_ = null;
     this.strategy_ = null;
     this.failAfter_ = -1;
+    this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;
 
     this.state_ = FunctionCall.State_.PENDING;
 }
@@ -43,6 +44,11 @@ FunctionCall.State_ = {
     ABORTED: 3
 };
 
+// The default retry predicate which considers any error as retriable.
+FunctionCall.DEFAULT_RETRY_PREDICATE_ = function(err) {
+  return true;
+};
+
 // Checks whether the call is pending.
 FunctionCall.prototype.isPending = function() {
     return this.state_ == FunctionCall.State_.PENDING;
@@ -71,6 +77,16 @@ FunctionCall.prototype.setStrategy = function(strategy) {
     return this; // Return this for chaining.
 };
 
+// Sets the predicate which will be used to determine whether the errors
+// returned from the wrapped function should be retried or not, e.g. a
+// network error would be retriable while a type error would stop the
+// function call.
+FunctionCall.prototype.retryIf = function(retryPredicate) {
+    precond.checkState(this.isPending(), 'FunctionCall in progress.');
+    this.retryPredicate_ = retryPredicate;
+    return this;
+};
+
 // Returns all intermediary results returned by the wrapped function since
 // the initial call.
 FunctionCall.prototype.getLastResult = function() {
@@ -91,19 +107,24 @@ FunctionCall.prototype.failAfter = function(maxNumberOfRetry) {
 
 // Aborts the call.
 FunctionCall.prototype.abort = function() {
-    precond.checkState(!this.isCompleted(), 'FunctionCall already completed.');
+    if (this.isCompleted() || this.isAborted()) {
+      return;
+    }
 
     if (this.isRunning()) {
         this.backoff_.reset();
     }
 
     this.state_ = FunctionCall.State_.ABORTED;
+    this.lastResult_ = [new Error('Backoff aborted.')];
+    this.emit('abort');
+    this.doCallback_();
 };
 
 // Initiates the call to the wrapped function. Accepts an optional factory
 // function used to create the backoff instance; used when testing.
 FunctionCall.prototype.start = function(backoffFactory) {
-    precond.checkState(!this.isAborted(), 'FunctionCall aborted.');
+    precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');
     precond.checkState(this.isPending(), 'FunctionCall already started.');
 
     var strategy = this.strategy_ || new FibonacciBackoffStrategy();
@@ -152,8 +173,9 @@ FunctionCall.prototype.handleFunctionCallback_ = function() {
     this.lastResult_ = args; // Save last callback arguments.
     events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));
 
-    if (args[0]) {
-        this.backoff_.backoff(args[0]);
+    var err = args[0];
+    if (err && this.retryPredicate_(err)) {
+        this.backoff_.backoff(err);
     } else {
         this.state_ = FunctionCall.State_.COMPLETED;
         this.doCallback_();
diff --git a/src/img/node_modules/backoff/lib/strategy/exponential.js b/src/img/node_modules/backoff/lib/strategy/exponential.js
index 9e19f609..8074a40f 100644
--- a/src/img/node_modules/backoff/lib/strategy/exponential.js
+++ b/src/img/node_modules/backoff/lib/strategy/exponential.js
@@ -2,6 +2,7 @@
 //      Licensed under the MIT license.
 
 var util = require('util');
+var precond = require('precond');
 
 var BackoffStrategy = require('./strategy');
 
@@ -10,12 +11,25 @@ function ExponentialBackoffStrategy(options) {
     BackoffStrategy.call(this, options);
     this.backoffDelay_ = 0;
     this.nextBackoffDelay_ = this.getInitialDelay();
+    this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;
+
+    if (options && options.factor !== undefined) {
+        precond.checkArgument(options.factor > 1,
+            'Exponential factor should be greater than 1 but got %s.',
+            options.factor);
+        this.factor_ = options.factor;
+    }
 }
 util.inherits(ExponentialBackoffStrategy, BackoffStrategy);
 
+// Default multiplication factor used to compute the next backoff delay from
+// the current one. The value can be overridden by passing a custom factor as
+// part of the options.
+ExponentialBackoffStrategy.DEFAULT_FACTOR = 2;
+
 ExponentialBackoffStrategy.prototype.next_ = function() {
     this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
-    this.nextBackoffDelay_ = this.backoffDelay_ * 2;
+    this.nextBackoffDelay_ = this.backoffDelay_ * this.factor_;
     return this.backoffDelay_;
 };
 
diff --git a/src/img/node_modules/backoff/node_modules/precond/package.json b/src/img/node_modules/backoff/node_modules/precond/package.json
index 6050a6c1..5abecd8f 100644
--- a/src/img/node_modules/backoff/node_modules/precond/package.json
+++ b/src/img/node_modules/backoff/node_modules/precond/package.json
@@ -15,15 +15,15 @@
   ],
   "repository": {
     "type": "git",
-    "url": "https://github.com/MathieuTurcotte/node-precond.git"
+    "url": "git+https://github.com/MathieuTurcotte/node-precond.git"
   },
   "devDependencies": {
     "nodeunit": "0.9",
     "jshint": "2.5"
   },
   "scripts": {
-    "pretest": "node_modules/.bin/jshint lib/ examples/ index.js",
-    "test": "node_modules/.bin/nodeunit tests/"
+    "pretest": "jshint lib/ examples/ index.js",
+    "test": "nodeunit tests/"
   },
   "engines": {
     "node": ">= 0.6"
@@ -34,5 +34,27 @@
   ],
   "bugs": {
     "url": "https://github.com/MathieuTurcotte/node-precond/issues"
-  }
+  },
+  "_id": "precond@0.2.3",
+  "dist": {
+    "shasum": "aa9591bcaa24923f1e0f4849d240f47efc1075ac",
+    "tarball": "https://registry.npmjs.org/precond/-/precond-0.2.3.tgz"
+  },
+  "_from": "precond@>=0.2.0 <0.3.0",
+  "_npmVersion": "1.3.11",
+  "_npmUser": {
+    "name": "mathieu",
+    "email": "turcotte.mat@gmail.com"
+  },
+  "maintainers": [
+    {
+      "name": "mathieu",
+      "email": "turcotte.mat@gmail.com"
+    }
+  ],
+  "directories": {},
+  "_shasum": "aa9591bcaa24923f1e0f4849d240f47efc1075ac",
+  "_resolved": "https://registry.npmjs.org/precond/-/precond-0.2.3.tgz",
+  "readme": "ERROR: No README data found!",
+  "homepage": "https://github.com/MathieuTurcotte/node-precond#readme"
 }
diff --git a/src/img/node_modules/backoff/package.json b/src/img/node_modules/backoff/package.json
index ae43f565..5bd6144b 100644
--- a/src/img/node_modules/backoff/package.json
+++ b/src/img/node_modules/backoff/package.json
@@ -1,7 +1,7 @@
 {
   "name": "backoff",
   "description": "Fibonacci and exponential backoffs.",
-  "version": "2.4.0",
+  "version": "2.5.0",
   "license": "MIT",
   "author": {
     "name": "Mathieu Turcotte",
@@ -15,7 +15,7 @@
   ],
   "repository": {
     "type": "git",
-    "url": "https://github.com/MathieuTurcotte/node-backoff.git"
+    "url": "git+https://github.com/MathieuTurcotte/node-backoff.git"
   },
   "dependencies": {
     "precond": "0.2"
@@ -32,11 +32,40 @@
   "engines": {
     "node": ">= 0.6"
   },
-  "file": [
+  "files": [
     "index.js",
-    "lib"
+    "lib",
+    "tests"
   ],
+  "gitHead": "811118fd1f89e9ca4e6b67292b9ef5da6c4f60e9",
   "bugs": {
     "url": "https://github.com/MathieuTurcotte/node-backoff/issues"
-  }
+  },
+  "homepage": "https://github.com/MathieuTurcotte/node-backoff#readme",
+  "_id": "backoff@2.5.0",
+  "_shasum": "f616eda9d3e4b66b8ca7fca79f695722c5f8e26f",
+  "_from": "backoff@>=2.4.1 <3.0.0",
+  "_npmVersion": "2.14.12",
+  "_nodeVersion": "4.2.4",
+  "_npmUser": {
+    "name": "mathieu",
+    "email": "turcotte.mat@gmail.com"
+  },
+  "dist": {
+    "shasum": "f616eda9d3e4b66b8ca7fca79f695722c5f8e26f",
+    "tarball": "https://registry.npmjs.org/backoff/-/backoff-2.5.0.tgz"
+  },
+  "maintainers": [
+    {
+      "name": "mathieu",
+      "email": "turcotte.mat@gmail.com"
+    }
+  ],
+  "_npmOperationalInternal": {
+    "host": "packages-13-west.internal.npmjs.com",
+    "tmp": "tmp/backoff-2.5.0.tgz_1457796071422_0.5366517049260437"
+  },
+  "directories": {},
+  "_resolved": "https://registry.npmjs.org/backoff/-/backoff-2.5.0.tgz",
+  "readme": "ERROR: No README data found!"
 }
diff --git a/src/img/node_modules/sdc-clients/lib/imgapi.js b/src/img/node_modules/sdc-clients/lib/imgapi.js
index 13bd6c28..4d4d8b94 100644
--- a/src/img/node_modules/sdc-clients/lib/imgapi.js
+++ b/src/img/node_modules/sdc-clients/lib/imgapi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -68,7 +68,7 @@ var assert = require('assert-plus');
 var restify = require('restify');
 var SSHAgentClient = require('ssh-agent');
 var mod_url = require('url');
-
+var backoff = require('backoff');
 
 
 // ---- globals
@@ -233,7 +233,7 @@ function simpleMerge(a, b) {
  *        are given, the latter wins.
  *      - `channel` {String} Optional. The channel to use, for IMGAPI servers
  *        that use channels.
- *        See <https://mo.joyent.com/docs/imgapi/master/#ListChannels>.
+ *        See <https://updates.joyent.com/docs/#ListChannels>.
  *      - `user` {String} Optional. Used for basic or http-signature auth.
  *      - `password` {String} Optional. If provided, this implies that basic
  *        auth should be used for client requests.
@@ -278,7 +278,8 @@ function IMGAPI(options) {
     } else {
         this.url = options.url;
     }
-    this._basePath = parsed.path;  // the URL subpath *without* a trailing '/'
+    // the URL subpath *without* a trailing '/' or query params
+    this._basePath = parsed.path.split('?')[0];
     if (this._basePath.slice(-1) === '/') {
         this._basePath = this._basePath.slice(0, -1);
     }
@@ -487,6 +488,9 @@ IMGAPI.prototype.adminGetState = function adminGetState(callback) {
  *      See the doc link above for a full list of supported filters.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param callback {Function} `function (err, images, res)`
  *
  * NOTE about filters.limit and filters.marker:
@@ -510,6 +514,7 @@ IMGAPI.prototype.listImages = function listImages(filters, options, callback) {
     assert.object(filters, 'filters');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     self._getAuthHeaders(function (hErr, headers) {
@@ -530,7 +535,9 @@ IMGAPI.prototype.listImages = function listImages(filters, options, callback) {
 
     function listImagesWithLimit(headers, cb) {
         // limit and marker come straight from filters
-        var path = self._path('/images', filters, {channel: self.channel});
+        var path = self._path('/images', {
+            channel: options.channel || self.channel
+        }, filters);
         var reqOpts = {
             path: path,
             headers: headers
@@ -573,7 +580,9 @@ IMGAPI.prototype.listImages = function listImages(filters, options, callback) {
                 filters.limit = limit;
             }
 
-            var path = self._path('/images', filters, {channel: self.channel});
+            var path = self._path('/images', {
+                channel: options.channel || self.channel
+            }, filters);
             var reqOpts = {
                 path: path,
                 headers: headers
@@ -602,7 +611,7 @@ IMGAPI.prototype.listImages = function listImages(filters, options, callback) {
                 }
                 // No marker means this is the first query and we
                 // shouldn't shift() the array
-                if (marker) {
+                if (marker && sImages.length && sImages[0].uuid === marker) {
                     sImages.shift();
                 }
                 // We hit this when we either reached an empty page of
@@ -638,6 +647,9 @@ IMGAPI.prototype.listImages = function listImages(filters, options, callback) {
  *      If given this will only return images accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.getImage =
@@ -659,11 +671,12 @@ function getImage(uuid, account, options, callback) {
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path('/images/' + uuid, {
         account: account,
-        channel: self.channel
+        channel: options.channel || self.channel
     });
     self._getAuthHeaders(function (hErr, headers) {
         if (hErr) {
@@ -697,6 +710,9 @@ function getImage(uuid, account, options, callback) {
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.createImage =
@@ -718,9 +734,13 @@ function createImage(data, account, options, callback) {
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
-    var path = self._path('/images', {account: account, channel: self.channel});
+    var path = self._path('/images', {
+        account: account,
+        channel: options.channel || self.channel
+    });
     self._getAuthHeaders(function (hErr, headers) {
         if (hErr) {
             callback(hErr);
@@ -757,6 +777,9 @@ function createImage(data, account, options, callback) {
  *      - incremental {Boolean} Optional. Default false. Create an incremental
  *        image.
  *      - headers {Object} Optional Additional request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {UUID} account : Optional. The UUID of the account on behalf of whom
  *      this request is being made. If given this will only return images
  *      accessible to that account.
@@ -774,12 +797,13 @@ function createImageFromVm(data, options, account, callback) {
     assert.string(options.vm_uuid, 'options.vm_uuid');
     assert.optionalBool(options.incremental, 'options.incremental');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.optionalString(account, 'account');
     assert.func(callback, 'callback');
 
     var path = self._path('/images');
     path += self._qs({
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'create-from-vm',
         vm_uuid: options.vm_uuid,
         incremental: options.incremental,
@@ -880,6 +904,9 @@ function createImageFromVmAndWait(data, options, account, callback) {
  *          Append '?channel=<channel>' to select a particular source
  *          channel, if relevant.
  *      - headers {Object} Optional Additional request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.adminImportImage = function adminImportImage(
@@ -894,12 +921,13 @@ IMGAPI.prototype.adminImportImage = function adminImportImage(
     assert.optionalBool(options.skipOwnerCheck, 'options.skipOwnerCheck');
     assert.optionalString(options.source, 'options.source');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
     assert.string(data.uuid, 'data.uuid');
 
     var path = self._path('/images/' + data.uuid);
     path += self._qs({
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'import',
         skip_owner_check: options.skipOwnerCheck,
         source: options.source
@@ -950,6 +978,9 @@ IMGAPI.prototype.adminImportImage = function adminImportImage(
  * @param {Object} options: For backward compat, this argument is optional.
  *      - skipOwnerCheck {Boolean} Optional. Default false.
  *      - headers {Object} Optional Additional request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.adminImportRemoteImageAndWait =
@@ -964,14 +995,18 @@ function adminImportRemoteImageAndWait(uuid, source, options, callback) {
     assert.object(options, 'options');
     assert.optionalBool(options.skipOwnerCheck, 'options.skipOwnerCheck');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
+    assert.optionalNumber(options.retries, 'options.retries');
     assert.func(callback, 'callback');
 
     var path = self._path('/images/' + uuid, {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'import-remote',
         source: source,
         skip_owner_check: options.skipOwnerCheck
     });
+
+    var maxRetries = options.retries || 1;
     self._getAuthHeaders(function (hErr, headers) {
         if (hErr) {
             callback(hErr);
@@ -984,24 +1019,141 @@ function adminImportRemoteImageAndWait(uuid, source, options, callback) {
             path: path,
             headers: headers
         };
-        self.client.post(reqOpts, function (err, req, res, obj) {
-            if (err) {
-                callback(err, null, res);
-            } else {
-                var wfapiUrl = res.headers['workflow-api'];
 
-                assert.string(wfapiUrl, 'wfapiUrl');
-                assert.string(obj['job_uuid'], 'job_uuid');
-                assert.string(obj['image_uuid'], 'image_uuid');
+        // Keep latest HTTP response handy:
+        var theResponse;
 
-                waitForJob(wfapiUrl, obj['job_uuid'], function (jErr) {
-                    if (jErr) {
-                        callback(jErr);
-                        return;
+        var retry = backoff.exponential({
+            maxDelay: Infinity
+        });
+
+        retry.failAfter(maxRetries);
+
+        retry.on('backoff', function (number, delay, err) {
+            self.client.log.trace({
+                attempt: number,
+                delay: delay,
+                err: err
+            }, 'retry backoff');
+        });
+
+        retry.on('ready', function (number, delay) {
+            self.client.log.trace({
+                attempt: number,
+                delay: delay
+            }, 'retry ready');
+
+            self.client.post(reqOpts, function (err, req, res, obj) {
+                if (err) {
+                    theResponse = res;
+                    return retry.backoff(err);
+                } else {
+                    var wfapiUrl = res.headers['workflow-api'];
+                    try {
+                        assert.string(wfapiUrl, 'wfapiUrl');
+                        assert.string(obj.job_uuid, 'job_uuid');
+                        assert.string(obj.image_uuid, 'image_uuid');
+                    } catch (e) {
+                        return retry.backoff(e);
                     }
-                    self.getImage(obj['image_uuid'], callback);
-                });
+
+                    return waitForJob(wfapiUrl, obj.job_uuid, function (jErr) {
+                        if (jErr) {
+                            retry.backoff(jErr);
+                        } else {
+                            retry.reset();
+                            self.getImage(obj.image_uuid, callback);
+                        }
+                    });
+                }
+            });
+
+        });
+
+        retry.on('fail', function (err) {
+            self.client.log.trace({err: err}, 'retry fail');
+            callback(err, null, theResponse);
+        });
+
+        retry.emit('ready');
+
+    });
+};
+
+
+/**
+ * Import a docker image layer (operator/admin use only).
+ *
+ * @param {Object} options.
+ *      - repo {String} Required. The docker repo, e.g. 'busybox',
+ *        'quay.io/foo/bar', 'trentm/busybox', 'myreg.example.com:5000/blah'.
+ *      - tag {String} Required. The image repository tag
+ *      - regAuth {String} Optional. Registry auth info formatted as is
+ *        the 'x-registry-auth' header in `docker` client requests.
+ *      - public {Boolean} Optional. Value for IMGAPI `manifest.public`.
+ *        Default true.
+ *      - headers {Object} Optional Additional request headers.
+ * @param {Function} callback : `function (err, res)`
+ */
+IMGAPI.prototype.adminImportDockerImage = function adminImportDockerImage(
+        options, callback) {
+    var self = this;
+    if (callback === undefined) {
+        callback = options;
+        options = {};
+    }
+    assert.object(options, 'options');
+    assert.string(options.repo, 'options.repo');
+    assert.string(options.tag, 'options.tag');
+    assert.optionalString(options.regAuth, 'options.regAuth');
+    assert.optionalBool(options.public, 'options.public');
+    assert.optionalObject(options.headers, 'options.headers');
+    assert.func(callback, 'callback');
+
+    var path = self._path('/images');
+    path += self._qs({
+        channel: self.channel,
+        action: 'import-docker-image',
+        tag: options.tag,
+        repo: options.repo,
+        public: options.public
+    });
+
+    self._getAuthHeaders(function (hErr, headers) {
+        if (hErr) {
+            callback(hErr);
+            return;
+        }
+        if (options.regAuth) {
+            headers['x-registry-auth'] = options.regAuth;
+        }
+        if (options.headers) {
+            simpleMerge(headers, options.headers);
+        }
+        var reqOpts = {
+            path: path,
+            headers: headers
+        };
+
+        self.rawClient.post(reqOpts, function (connectErr, req) {
+            if (connectErr) {
+                callback(connectErr);
+                return;
             }
+
+            req.on('result', function (resultErr, res) {
+                if (resultErr) {
+                    extendErrFromRawBody(resultErr, res, function () {
+                        callback(resultErr, null, res);
+                    });
+                    return;
+                }
+
+                res.setEncoding('utf8');
+                callback(null, res);
+            });
+
+            req.end();
         });
     });
 };
@@ -1092,6 +1244,9 @@ function pollJob(client, job_uuid, cb) {
  * @param {Object} options: For backward compat, this argument is optional.
  *      - skipOwnerCheck {Boolean} Optional. Default false.
  *      - headers {Object} Optional Additional request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, job, res)`
  */
 IMGAPI.prototype.adminImportRemoteImage =
@@ -1106,10 +1261,11 @@ function adminImportRemoteImage(uuid, source, options, callback) {
     assert.object(options, 'options');
     assert.optionalBool(options.skipOwnerCheck, 'options.skipOwnerCheck');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path('/images/' + uuid, {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'import-remote',
         source: source,
         skip_owner_check: options.skipOwnerCheck
@@ -1158,6 +1314,9 @@ function adminImportRemoteImage(uuid, source, options, callback) {
  *        Can be "local" or "manta". Will try to default to "manta" when
  *        available, otherwise "local".
  *      - headers {Object} Optional Additional request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {UUID} account : Optional. The UUID of the account on behalf of whom
  *      this request is being made. If given this will only return images
  *      accessible to that account.
@@ -1169,6 +1328,7 @@ IMGAPI.prototype.addImageFile = function addImageFile(options, account,
     assert.object(options, 'options');
     assert.string(options.uuid, 'options.uuid');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     if (callback === undefined) {
         callback = account;
         account = undefined;
@@ -1180,7 +1340,7 @@ IMGAPI.prototype.addImageFile = function addImageFile(options, account,
     if (options.source) {
         assert.string(options.source, 'options.source');
         var path = self._path(format('/images/%s/file', uuid), {
-            channel: self.channel,
+            channel: options.channel || self.channel,
             source: options.source,
             storage: options.storage
         });
@@ -1243,7 +1403,7 @@ IMGAPI.prototype.addImageFile = function addImageFile(options, account,
         }
 
         var path = self._path(format('/images/%s/file', uuid), {
-            channel: self.channel,
+            channel: options.channel || self.channel,
             compression: options.compression,
             account: account,
             sha1: options.sha1,
@@ -1318,6 +1478,9 @@ IMGAPI.prototype.addImageFile = function addImageFile(options, account,
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, res)`
  */
 IMGAPI.prototype.getImageFile =
@@ -1336,10 +1499,11 @@ function getImageFile(uuid, filePath, account, options, callback) {
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s/file', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         account: account
     });
     self._getAuthHeaders(function (hErr, headers) {
@@ -1402,6 +1566,9 @@ function getImageFile(uuid, filePath, account, options, callback) {
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, stream)`
  *      The `stream` is also an HTTP response object, i.e. headers are on
  *      `stream.headers`.
@@ -1421,10 +1588,11 @@ IMGAPI.prototype.getImageFileStream = function getImageFileStream(
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s/file', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         account: account
     });
     self._getAuthHeaders(function (hErr, headers) {
@@ -1473,6 +1641,9 @@ IMGAPI.prototype.getImageFileStream = function getImageFileStream(
  *        this is required, otherwise it will be retrieved with `fs.stat`.
  *      - {String} sha1 : SHA-1 hash of the icon file being uploaded.
  *      - headers {Object} Optional Additional request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {UUID} account : Optional. The UUID of the account on behalf of whom
  *      this request is being made. If given this will only return images
  *      accessible to that account.
@@ -1489,6 +1660,7 @@ IMGAPI.prototype.addImageIcon = function addImageIcon(options, account,
     assert.optionalString(options.sha1, 'options.sha1');
     assert.optionalNumber(options.size, 'options.size');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     if (callback === undefined) {
         callback = account;
         account = undefined;
@@ -1525,7 +1697,7 @@ IMGAPI.prototype.addImageIcon = function addImageIcon(options, account,
         }
 
         var path = self._path(format('/images/%s/icon', uuid), {
-            channel: self.channel,
+            channel: options.channel || self.channel,
             account: account,
             sha1: options.sha1
         });
@@ -1597,6 +1769,9 @@ IMGAPI.prototype.addImageIcon = function addImageIcon(options, account,
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, res)`
  */
 IMGAPI.prototype.getImageIcon =
@@ -1615,10 +1790,11 @@ function getImageIcon(uuid, filePath, account, options, callback) {
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s/icon', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         account: account
     });
     self._getAuthHeaders(function (hErr, headers) {
@@ -1682,6 +1858,9 @@ function getImageIcon(uuid, filePath, account, options, callback) {
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, stream)`
  *      The `stream` is also an HTTP response object, i.e. headers are on
  *      `stream.headers`.
@@ -1701,10 +1880,11 @@ IMGAPI.prototype.getImageIconStream = function getImageIconStream(
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s/icon', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         account: account
     });
     self._getAuthHeaders(function (hErr, headers) {
@@ -1748,6 +1928,9 @@ IMGAPI.prototype.getImageIconStream = function getImageIconStream(
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.deleteImageIcon =
@@ -1765,10 +1948,11 @@ function deleteImageIcon(uuid, account, options, callback) {
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s/icon', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         account: account
     });
     self._getAuthHeaders(function (hErr, headers) {
@@ -1810,6 +1994,9 @@ function deleteImageIcon(uuid, account, options, callback) {
  *          then the files are saved to it. If the basename of "PATH" is not a
  *          dir, then "PATH.imgmanifest" and "PATH.zfs[.EXT]" are created.
  *      - headers {Object} Optional. Additional request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.exportImage =
@@ -1824,11 +2011,12 @@ function exportImage(uuid, account, options, callback) {
     assert.object(options, 'options');
     assert.string(options.manta_path, 'manta_path');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.optionalString(account, 'account');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'export',
         manta_path: options.manta_path,
         account: account
@@ -1865,6 +2053,9 @@ function exportImage(uuid, account, options, callback) {
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.activateImage =
@@ -1882,10 +2073,11 @@ function activateImage(uuid, account, options, callback) {
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'activate',
         account: account
     });
@@ -1921,6 +2113,9 @@ function activateImage(uuid, account, options, callback) {
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.disableImage =
@@ -1938,10 +2133,11 @@ function disableImage(uuid, account, options, callback) {
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'disable',
         account: account
     });
@@ -1977,6 +2173,9 @@ function disableImage(uuid, account, options, callback) {
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.enableImage =
@@ -1994,10 +2193,11 @@ function enableImage(uuid, account, options, callback) {
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'enable',
         account: account
     });
@@ -2034,6 +2234,9 @@ function enableImage(uuid, account, options, callback) {
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.addImageAcl =
@@ -2052,10 +2255,11 @@ function addImageAcl(uuid, acl, account, options, callback) {
     assert.arrayOfString(acl, 'acl');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s/acl', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'add',
         account: account
     });
@@ -2092,6 +2296,9 @@ function addImageAcl(uuid, acl, account, options, callback) {
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.removeImageAcl =
@@ -2110,10 +2317,11 @@ function removeImageAcl(uuid, acl, account, options, callback) {
     assert.arrayOfString(acl, 'acl');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s/acl', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'remove',
         account: account
     });
@@ -2150,6 +2358,9 @@ function removeImageAcl(uuid, acl, account, options, callback) {
  *      accessible to that account.
  * @param options {Object} Optional request options.
  *      - headers {Object} Optional extra request headers.
+ *      - channel {String} Optional override for the channel set on the
+ *        constructor. This is only relevant for IMGAPI servers that
+ *        support channels.
  * @param {Function} callback : `function (err, image, res)`
  */
 IMGAPI.prototype.updateImage =
@@ -2168,10 +2379,11 @@ function updateImage(uuid, data, account, options, callback) {
     assert.object(data, 'data');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         action: 'update',
         account: account
     });
@@ -2234,11 +2446,12 @@ function deleteImage(uuid, account, options, callback) {
     assert.optionalString(account, 'account');
     assert.object(options, 'options');
     assert.optionalObject(options.headers, 'options.headers');
+    assert.optionalString(options.channel, 'options.channel');
     assert.optionalBool(options.forceAllChannels, 'options.forceAllChannels');
     assert.func(callback, 'callback');
 
     var path = self._path(format('/images/%s', uuid), {
-        channel: self.channel,
+        channel: options.channel || self.channel,
         account: account,
         force_all_channels: options.forceAllChannels
     });
diff --git a/src/img/node_modules/sdc-clients/package.json b/src/img/node_modules/sdc-clients/package.json
index cecebfa9..d1f3b977 100644
--- a/src/img/node_modules/sdc-clients/package.json
+++ b/src/img/node_modules/sdc-clients/package.json
@@ -1,7 +1,7 @@
 {
   "name": "sdc-clients",
   "description": "Contains node.js client libraries for SDC REST APIs.",
-  "version": "8.1.3",
+  "version": "8.2.0",
   "homepage": "http://www.joyent.com",
   "private": true,
   "repository": {
@@ -11,15 +11,15 @@
   "main": "./lib/index.js",
   "dependencies": {
     "assert-plus": "0.1.5",
-    "async": "0.1.22",
-    "backoff": "2.3.0",
+    "async": "~0.9.0",
+    "backoff": "^2.4.1",
     "bunyan": "^1.2.3",
     "clone": "0.1.8",
-    "ufds": "git://github.com/joyent/node-ufds.git#5aa8791",
+    "ufds": "git://github.com/joyent/node-ufds.git#a7c674b76696fe7ab0fff1e2486f20d3af6a0d1a",
     "lru-cache": "2.3.0",
     "libuuid": "0.1.2",
     "once": "^1.3.1",
-    "restify": "^2.8.4",
+    "restify": "git://github.com/joyent/node-restify.git#fd5d5b5",
     "ssh-agent": "0.2.1",
     "vasync": "^1.6.2",
     "verror": "^1.6.0"
@@ -30,8 +30,5 @@
   "engines": {
     "node": ">=0.8.14"
   },
-  "license": "MPL-2.0",
-  "bugs": {
-    "url": "https://github.com/joyent/node-sdc-clients/issues"
-  }
+  "license": "MPL-2.0"
 }
diff --git a/src/img/package.json b/src/img/package.json
index a00e0c3c..dd8878c9 100644
--- a/src/img/package.json
+++ b/src/img/package.json
@@ -1,13 +1,13 @@
 {
   "name": "imgadm",
   "description": "Manage SmartOS virtual machine images.",
-  "version": "3.9.3",
+  "version": "3.9.4",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
     "assert-plus": "0.1.5",
     "async": "0.9.0",
-    "backoff": "2.4.0",
+    "backoff": "2.5.0",
     "bunyan": "1.3.5",
     "cmdln": "3.2.1",
     "concat-stream": "1.4.10",
@@ -21,7 +21,7 @@
     "progbar": "1.1.0",
     "restify": "2.8.5",
     "rimraf": "2.2.8",
-    "sdc-clients": "git://github.com/joyent/node-sdc-clients.git#29dea8e",
+    "sdc-clients": "8.2.0",
     "tabula": "1.4.1",
     "vasync": "1.6.2",
     "verror": "1.6.0"
diff --git a/src/img/test/import.test.js b/src/img/test/import.test.js
index 882a0ea0..06e7b3f4 100644
--- a/src/img/test/import.test.js
+++ b/src/img/test/import.test.js
@@ -54,13 +54,24 @@ var WRKDIR = '/var/tmp/img-test-import';
 var CACHEDIR = '/var/tmp/img-test-cache';
 
 /*
- * Pick an image that (a) exists on images.joyent.com (they *do* occassionally
+ * Pick an image that (a) exists on images.joyent.com (they *do* occasionally
  * get deprecated) and (b) is relatively small and (c) is unlikely to collide
  * with current usage.
  */
 // minimal-32@15.2.0
 var TEST_IMAGE_UUID = '0764d78e-3472-11e5-8949-4f31abea4e05';
 
+/*
+ * An image that only exists on the experimental channel of updates.joyent.com.
+ * Similar to the note above, hopefully this image will always be here and will
+ * not be present on images.joyent.com, since tests rely on this fact.
+ * During setup, we import the origin image for this experimental image.
+ */
+var TEST_EXPERIMENTAL_SOURCE =
+    'https://updates.joyent.com?channel=experimental';
+var TEST_EXPERIMENTAL_ORIGIN = 'fd2cc906-8938-11e3-beab-4359c665ac99';
+var TEST_EXPERIMENTAL_UUID = 'b323e23f-e762-4677-a2c8-b56f3bd5ef48';
+
 var CACHEFILE = format('%s/%s.file', CACHEDIR, TEST_IMAGE_UUID);
 
 
@@ -93,6 +104,13 @@ test('setup: get test image in local SDC IMGAPI (if available)', function (t) {
     });
 });
 
+test('setup: get origin for experimental image', function (t) {
+    exec('imgadm import ' + TEST_EXPERIMENTAL_ORIGIN, function (err, o, e) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
 test('setup: CACHEDIR (' + CACHEDIR + ')', function (t) {
     mkdirp(CACHEDIR, function (err) {
         t.ifError(err);
@@ -359,7 +377,115 @@ test('pre-downloaded file (bad checksum); imgadm import ' + TEST_IMAGE_UUID,
     }); // cp
 });
 
+// Force removal of any dangling experimental image and sources which might
+// prevent these tests from reporting correct results.
+test('setup8: rm experimental image ' + TEST_EXPERIMENTAL_UUID, function (t) {
+    var cmd = format(
+        'imgadm delete %s ;'
+            + 'imgadm sources -d https://updates.joyent.com ;'
+            + 'imgadm sources -d '
+            + TEST_EXPERIMENTAL_SOURCE,
+        TEST_EXPERIMENTAL_UUID);
+    t.exec(cmd, function () {
+        // it's ok if any of these fail, since those may not have been
+        // configured in the first place.
+        t.end();
+    });
+});
+
+// With no configured experimental sources, this should fail, which will
+// also help determine whether the image has perhaps been added to
+// images.joyent.com, in which case, maintainers should select a different
+// TEST_EXPERIMENTAL_UUID (and TEST_EXPERIMENTAL_ORIGIN if necessary)
+test('experimental image import fails', function (t) {
+    var cmd = 'imgadm import ' + TEST_EXPERIMENTAL_UUID;
+    exec(cmd, function (err, o, e) {
+        t.ok(/ActiveImageNotFound/.test(e),
+            'ActiveImageNotFound error code on stderr');
+        t.end();
+    });
+});
+
+test('setup9: add updates.joyent.com source', function (t) {
+    var cmd = 'imgadm sources -a https://updates.joyent.com';
+    exec(cmd, function () {
+        t.end();
+    });
+});
+
+// With a -C argument, this should succeed, assuming our test experimental
+// image does still exist on that channel.
+test('experimental image import with -C arg', function (t) {
+    var cmd = 'imgadm import -C experimental ' + TEST_EXPERIMENTAL_UUID;
+    exec(cmd, function (err, stdout, stderr) {
+        t.ifError(err);
+        exec('imgadm get ' + TEST_EXPERIMENTAL_UUID, function (err2, o, e) {
+            t.ifError(err2);
+            t.end();
+        });
+    });
+});
+
+test('setup10: delete experimental image', function (t) {
+    var cmd = format('imgadm delete %s', TEST_EXPERIMENTAL_UUID);
+    exec(cmd, function () {
+        t.end();
+    });
+});
 
+// With a -S argument, this should succeed
+test('experimental image import with -S channel url', function (t) {
+    var cmd = ('imgadm import '
+            + '-S ' + TEST_EXPERIMENTAL_SOURCE + ' '
+            + TEST_EXPERIMENTAL_UUID);
+    exec(cmd, function (err, stdout, stderr) {
+        t.ifError(err);
+        exec('imgadm get ' + TEST_EXPERIMENTAL_UUID, function (err2, o, e) {
+            t.ifError(err2);
+            t.end();
+        });
+    });
+});
+
+// delete our experimental image and our updates.joyent.com url, then add
+// that source, this time with a channel.
+test('setup11: delete experimental image', function (t) {
+    var cmd = format(
+        'imgadm delete %s ; '
+            + 'imgadm sources -d https://updates.joyent.com ; '
+            + 'imgadm sources -a '
+            + TEST_EXPERIMENTAL_SOURCE + ' ',
+        TEST_EXPERIMENTAL_UUID);
+    exec(cmd, function (err, o, e) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+// With a configured experimental channel, this should succeed
+test('experimental image import configured channel', function (t) {
+    var cmd = 'imgadm import ' + TEST_EXPERIMENTAL_UUID;
+    exec(cmd, function (err, stdout, stderr) {
+        t.ifError(err);
+        exec('imgadm get ' + TEST_EXPERIMENTAL_UUID, function (err2, o, e) {
+            t.ifError(err2);
+            t.end();
+        });
+    });
+});
+
+test('experimental channel sources show up in list output', function (t) {
+    exec('imgadm list -o uuid,source | grep ' + TEST_EXPERIMENTAL_UUID,
+    function (err, o, e) {
+        t.ifError(err);
+        var firstLine = o.split(/\n/g)[0];
+        var results = firstLine.split('  ');
+        t.equal(results.length, 2);
+        t.equal(results[0], TEST_EXPERIMENTAL_UUID);
+        t.equal(results[1], TEST_EXPERIMENTAL_SOURCE);
+        t.end();
+    });
+});
 
 // Need a test IMGAPI for the following:
 // TODO: test case importing from IMGAPI *with an origin*
