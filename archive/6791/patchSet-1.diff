commit 2ffde82a61a75f8a09e849aac0acb930b0d9af05
Author: Rui Loura <rui.loura@joyent.com>
Date:   2019-08-13T16:09:39-04:00 (8 weeks ago)
    
    MANTA-4499 update rust-moray to work with and stay pined to cueball v0.1.0

diff --git a/Cargo.toml b/Cargo.toml
index 1f978dc..f468e5c 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -6,9 +6,9 @@ authors = ["Rui Loura <rui@joyent.com>",
 edition = "2018"
 
 [dependencies]
-cueball = { git = "https://github.com/joyent/rust-cueball" }
-cueball-static-resolver = { git = "https://github.com/joyent/rust-cueball-static-resolver" }
-cueball-tcp-stream-connection = { git = "https://github.com/joyent/rust-cueball-tcp-stream-connection" }
+cueball = { git = "https://github.com/joyent/rust-cueball", tag="v0.1.0" }
+cueball-static-resolver = { git = "https://github.com/joyent/rust-cueball-static-resolver", tag="v0.1.0" }
+cueball-tcp-stream-connection = { git = "https://github.com/joyent/rust-cueball-tcp-stream-connection", tag="v0.1.0" }
 
 # This branch is pinned util the following are all resolved:
 # - MANTA-4287
@@ -23,6 +23,8 @@ slog = { version = "2.4.1", features = [ "max_level_trace" ] }
 slog-bunyan = { git = "https://github.com/kellymclaughlin/bunyan", branch = "build-on-smartos" }
 
 uuid = {version = "0.7.4", features = ["v4"] }
+trust-dns-resolver = "0.11.1"
+
 
 [dev-dependencies]
 slog-term = "2.4.0"
diff --git a/examples/createbucket.rs b/examples/createbucket.rs
index 0238792..9f5ebd4 100644
--- a/examples/createbucket.rs
+++ b/examples/createbucket.rs
@@ -10,14 +10,13 @@ use moray::client::MorayClient;
 use std::io::Error;
 use std::sync::Mutex;
 
-use slog::{o, Logger, Drain};
+use slog::{o, Drain, Logger};
 
 fn main() -> Result<(), Error> {
     let ip_arr: [u8; 4] = [10, 77, 77, 103];
     let port: u16 = 2021;
     let opts = buckets::MethodOptions::default();
 
-
     let plain = slog_term::PlainSyncDecorator::new(std::io::stdout());
     let log = Logger::root(
         Mutex::new(slog_term::FullFormat::new(plain).build()).fuse(),
diff --git a/examples/findobjects.rs b/examples/findobjects.rs
index 287192a..315a83e 100644
--- a/examples/findobjects.rs
+++ b/examples/findobjects.rs
@@ -6,9 +6,8 @@ use libmanta::moray as manta;
 use moray::client::MorayClient;
 use moray::objects;
 
-
+use slog::{o, Drain, Logger};
 use std::io::{Error, ErrorKind};
-use slog::{o, Logger, Drain};
 use std::sync::Mutex;
 
 fn main() -> Result<(), Error> {
@@ -85,7 +84,7 @@ fn main() -> Result<(), Error> {
                 ErrorKind::Other,
                 format!("Unknown bucket type {}", &o.bucket),
             );
-            return Err(e)
+            return Err(e);
         }
         let manta_obj: manta::ObjectType =
             serde_json::from_value(o.value.clone()).unwrap();
@@ -105,8 +104,10 @@ fn main() -> Result<(), Error> {
     mclient.find_objects("manta", "(type=directory)", &opts, |o| {
         assert_eq!(count, 1, "should only be one result");
         if o.bucket != "manta" {
-            return Err(Error::new(ErrorKind::Other,
-                format!("Unknown bucket type {}", &o.bucket)));
+            return Err(Error::new(
+                ErrorKind::Other,
+                format!("Unknown bucket type {}", &o.bucket),
+            ));
         }
         let manta_obj: manta::ObjectType =
             serde_json::from_value(o.value.clone()).unwrap();
diff --git a/examples/listbuckets.rs b/examples/listbuckets.rs
index 2e0d41a..c3c220e 100644
--- a/examples/listbuckets.rs
+++ b/examples/listbuckets.rs
@@ -1,22 +1,22 @@
 /*
  * Copyright 2019 Joyent, Inc.
  */
+
 use moray::buckets;
 use moray::client::MorayClient;
 
-
-use std::io::Error;
+use slog::{o, Drain, Logger};
+use std::io::{Error, ErrorKind};
+use std::net::IpAddr;
 use std::net::SocketAddr;
 use std::str::FromStr;
-use slog::{o, Logger, Drain};
 use std::sync::Mutex;
-
+use trust_dns_resolver::Resolver;
 
 fn client_fromstr(
     addr: &str,
     opts: buckets::MethodOptions,
 ) -> Result<(), Error> {
-
     let plain = slog_term::PlainSyncDecorator::new(std::io::stdout());
     let log = Logger::root(
         Mutex::new(slog_term::FullFormat::new(plain).build()).fuse(),
@@ -56,50 +56,28 @@ fn client_fromparts(
     })
 }
 
-fn client_reconnect(
-    addr: SocketAddr,
-    opts: buckets::MethodOptions,
-    log: Logger,
-) -> Result<(), Error> {
-    let mut mclient = MorayClient::new(addr, log, None).unwrap();
-    let mut count: u64 = 0;
-    mclient.list_buckets(opts.clone(), |_| {
-        count += 1;
-        Ok(())
-    })?;
-
-    println!("Found {} buckets before reconnect", count);
-    println!("Reconnecting");
-
-    let mut after_count = 0;
-    match mclient.list_buckets(opts.clone(), |_| {
-        after_count += 1;
-        Ok(())
-    }) {
-        Ok(()) => {
-            println!("Found {} buckets after reconnect", after_count);
-            assert_eq!(count, after_count, "match counts after reconnect");
-            Ok(())
-        }
-        Err(e) => Err(e),
-    }
-}
-
 fn main() -> Result<(), Error> {
-
     let plain = slog_term::PlainSyncDecorator::new(std::io::stdout());
     let log = Logger::root(
         Mutex::new(slog_term::FullFormat::new(plain).build()).fuse(),
         o!("build-id" => "0.1.0"),
     );
 
+    let resolver = Resolver::from_system_conf().unwrap();
+    let response = resolver.lookup_ip("1.moray.east.joyent.us")?;
+    let ipaddr: Vec<IpAddr> = response.iter().collect();
+    dbg!(&ipaddr);
+    let ipaddr = ipaddr[0];
 
-    let ip_arr: [u8; 4] = [10, 77, 77, 103];
-    let port: u16 = 2021;
+    let ip_arr = match ipaddr {
+        IpAddr::V4(ip) => ip.octets(),
+        _ => {
+            return Err(Error::new(ErrorKind::Other, "Need IPv4"));
+        }
+    };
 
-    let i: Vec<String> = ip_arr.iter().map(|o| o.to_string()).collect();
-    let ip = i.join(".");
-    let addr = format!("{}:{}", ip, port.to_string().as_str());
+    let port: u16 = 2021;
+    let addr = format!("{}:{}", ipaddr.to_string(), port.to_string().as_str());
 
     let opts = buckets::MethodOptions::default();
     println!("MorayClient from_str");
@@ -112,8 +90,5 @@ fn main() -> Result<(), Error> {
     println!("MorayClient from_parts");
     client_fromparts(ip_arr, port, opts.clone(), log.clone())?;
 
-    println!("MorayClient reconnect");
-    client_reconnect(sockaddr, opts, log.clone())?;
-    println!("MorayClient reconnect success");
     Ok(())
 }
diff --git a/examples/putobject.rs b/examples/putobject.rs
index 0436039..56babe7 100644
--- a/examples/putobject.rs
+++ b/examples/putobject.rs
@@ -8,12 +8,10 @@ extern crate serde_json;
 use moray::buckets;
 use moray::client::MorayClient;
 use moray::objects::{self, Etag};
+use slog::{o, Drain, Logger};
 use std::io::{Error, ErrorKind};
-use slog::{o, Logger, Drain};
 use std::sync::Mutex;
 
-
-
 fn main() -> Result<(), Error> {
     let ip_arr: [u8; 4] = [10, 77, 77, 9];
     let port: u16 = 2021;
@@ -29,7 +27,6 @@ fn main() -> Result<(), Error> {
         o!("build-id" => "0.1.0"),
     );
 
-
     let mut mclient = MorayClient::from_parts(ip_arr, port, log, None)?;
 
     println!("===confirming bucket exists===");
@@ -44,7 +41,7 @@ fn main() -> Result<(), Error> {
                 bucket_name
             );
             let e = Error::new(ErrorKind::Other, e);
-            return Err(e)
+            return Err(e);
         }
         Ok(()) => (),
     }
diff --git a/examples/sql.rs b/examples/sql.rs
index 1c1d385..6660328 100644
--- a/examples/sql.rs
+++ b/examples/sql.rs
@@ -3,18 +3,20 @@
  */
 use moray::client::MorayClient;
 use serde_json::{Map, Value};
+use slog::{o, Drain, Logger};
 use std::io::Error;
-use slog::{o, Logger, Drain};
 use std::sync::Mutex;
 
-
 fn query_handler(resp: &Value) -> Result<(), Error> {
     dbg!(&resp);
     Ok(())
 }
 
-fn query_client_string_opts(ip: [u8; 4], port: u16, log: Logger) -> Result<(), Error> {
-
+fn query_client_string_opts(
+    ip: [u8; 4],
+    port: u16,
+    log: Logger,
+) -> Result<(), Error> {
     let mut mclient = MorayClient::from_parts(ip, port, log, None)?;
 
     // The sql interface does not take 'limit' in opts
@@ -23,8 +25,11 @@ fn query_client_string_opts(ip: [u8; 4], port: u16, log: Logger) -> Result<(), E
     mclient.sql(query, vec![], r#"{}"#, query_handler)
 }
 
-fn query_client_map_opts(ip: [u8; 4], port: u16, log: Logger) -> Result<(), Error> {
-
+fn query_client_map_opts(
+    ip: [u8; 4],
+    port: u16,
+    log: Logger,
+) -> Result<(), Error> {
     let mut mclient = MorayClient::from_parts(ip, port, log, None)?;
 
     // The sql interface does not take 'limit' in opts
diff --git a/src/client.rs b/src/client.rs
index 063860a..7a5b11f 100644
--- a/src/client.rs
+++ b/src/client.rs
@@ -8,8 +8,8 @@ use cueball::connection_pool::ConnectionPool;
 use cueball_static_resolver::StaticIpResolver;
 use cueball_tcp_stream_connection::TcpStreamWrapper;
 
-use std::ops::DerefMut;
 use slog::Logger;
+use std::ops::DerefMut;
 
 use std::str::FromStr;
 
@@ -22,50 +22,42 @@ use super::buckets;
 use super::meta;
 use super::objects;
 
-
-pub struct MorayClient
-{
-    connection_pool:
-        ConnectionPool<TcpStreamWrapper, StaticIpResolver, fn(&Backend)
-            -> TcpStreamWrapper>
+pub struct MorayClient {
+    connection_pool: ConnectionPool<
+        TcpStreamWrapper,
+        StaticIpResolver,
+        fn(&Backend) -> TcpStreamWrapper,
+    >,
 }
 
 ///
 /// MorayClient
 ///
 impl MorayClient {
-
     pub fn new(
-            address: SocketAddr,
-            log: Logger,
-            opts: Option<ConnectionPoolOptions>
-        ) -> Result<MorayClient, Error> {
-
+        address: SocketAddr,
+        log: Logger,
+        opts: Option<ConnectionPoolOptions>,
+    ) -> Result<MorayClient, Error> {
         let primary_backend = (address.ip(), address.port());
         let resolver = StaticIpResolver::new(vec![primary_backend]);
 
         let pool_opts = match opts {
-            None => {
-                ConnectionPoolOptions {
-                    maximum: 5,
-                    claim_timeout: Some(5000),
-                    log: log,
-                    rebalancer_action_delay: None,
-                    decoherence_interval: None,
-                    decoherence_delay: None,
-                }
+            None => ConnectionPoolOptions {
+                max_connections: Some(5),
+                claim_timeout: Some(5000),
+                log: Some(log),
+                rebalancer_action_delay: None,
+                decoherence_interval: None,
             },
-            Some(opts) => opts
+            Some(opts) => opts,
         };
 
-        let pool =
-            ConnectionPool::<TcpStreamWrapper, StaticIpResolver, fn(&Backend)
-                -> TcpStreamWrapper>::new(
-                    pool_opts,
-                    resolver,
-                    TcpStreamWrapper::new,
-        );
-
+        let pool = ConnectionPool::<
+            TcpStreamWrapper,
+            StaticIpResolver,
+            fn(&Backend) -> TcpStreamWrapper,
+        >::new(pool_opts, resolver, TcpStreamWrapper::new);
 
         Ok(MorayClient {
             connection_pool: pool,
@@ -76,7 +68,7 @@ impl MorayClient {
         ip: I,
         port: u16,
         log: Logger,
-        opts: Option<ConnectionPoolOptions>
+        opts: Option<ConnectionPoolOptions>,
     ) -> Result<MorayClient, Error> {
         Self::new(SocketAddr::new(ip.into(), port), log, opts)
     }
@@ -195,7 +187,8 @@ impl MorayClient {
             &mut self.connection_pool.claim().unwrap().deref_mut(),
             name,
             config,
-            opts)
+            opts,
+        )
     }
 
     pub fn sql<F, V>(
@@ -209,21 +202,22 @@ impl MorayClient {
         F: FnMut(&Value) -> Result<(), Error>,
         V: Into<Value>,
     {
-        meta::sql(&mut self.connection_pool.claim().unwrap().deref_mut(),
-        stmt,
-        vals,
-        opts,
-        query_handler)
+        meta::sql(
+            &mut self.connection_pool.claim().unwrap().deref_mut(),
+            stmt,
+            vals,
+            opts,
+            query_handler,
+        )
     }
 
     pub fn from_str(
-            s: &str,
-            log: Logger,
-            opts: Option<ConnectionPoolOptions>
-        ) -> Result<MorayClient, Error> {
-
-            let addr = SocketAddr::from_str(s).expect("Error parsing address");
-            Self::new(addr, log, opts)
+        s: &str,
+        log: Logger,
+        opts: Option<ConnectionPoolOptions>,
+    ) -> Result<MorayClient, Error> {
+        let addr = SocketAddr::from_str(s).expect("Error parsing address");
+        Self::new(addr, log, opts)
     }
 }
 
