From ee4e68228e2f77b81d0ae2e9bfa3542535194eee Mon Sep 17 00:00:00 2001
From: Kody A Kantor <kody@kkantor.com>
Date: Thu, 28 Feb 2019 21:34:30 +0000
Subject: [PATCH] OS-7646 want ZFS metaslab load/unload counters

---
 usr/src/lib/libfakekernel/common/kstat.c      |  6 +++
 usr/src/lib/libfakekernel/common/mapfile-vers |  3 +-
 usr/src/uts/common/fs/zfs/metaslab.c          | 48 +++++++++++++++++++
 usr/src/uts/common/fs/zfs/sys/metaslab_impl.h |  9 ++++
 4 files changed, 65 insertions(+), 1 deletion(-)

diff --git a/usr/src/lib/libfakekernel/common/kstat.c b/usr/src/lib/libfakekernel/common/kstat.c
index 849f0ddf0e..4b6d2baa08 100644
--- a/usr/src/lib/libfakekernel/common/kstat.c
+++ b/usr/src/lib/libfakekernel/common/kstat.c
@@ -12,6 +12,7 @@
 /*
  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  * Copyright 2017 RackTop Systems.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -40,6 +41,11 @@ void
 kstat_named_init(kstat_named_t *knp, const char *name, uchar_t type)
 {}
 
+/*ARGSUSED*/
+void
+kstat_named_setstr(kstat_named_t *knp, const char *src)
+{}
+
 /*ARGSUSED*/
 void
 kstat_install(kstat_t *ksp)
diff --git a/usr/src/lib/libfakekernel/common/mapfile-vers b/usr/src/lib/libfakekernel/common/mapfile-vers
index aa59ad2e46..c7aa5a8f7d 100644
--- a/usr/src/lib/libfakekernel/common/mapfile-vers
+++ b/usr/src/lib/libfakekernel/common/mapfile-vers
@@ -13,7 +13,7 @@
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
 # Copyright (c) 2017, Joyent, Inc.
 # Copyright 2017 RackTop Systems.
-# Copyright 2018, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 #
@@ -155,6 +155,7 @@ SYMBOL_VERSION SUNWprivate_1.1 {
 	kstat_create;
 	kstat_create_zone;
 	kstat_named_init;
+	kstat_named_setstr;
 	kstat_delete;
 	kstat_install;
 	kstat_waitq_enter;
diff --git a/usr/src/uts/common/fs/zfs/metaslab.c b/usr/src/uts/common/fs/zfs/metaslab.c
index f652a3ef1a..04e44b8feb 100644
--- a/usr/src/uts/common/fs/zfs/metaslab.c
+++ b/usr/src/uts/common/fs/zfs/metaslab.c
@@ -720,6 +720,7 @@ metaslab_group_activate(metaslab_group_t *mg)
 {
 	metaslab_class_t *mc = mg->mg_class;
 	metaslab_group_t *mgprev, *mgnext;
+	char kstat_name[KSTAT_STRLEN];
 
 	ASSERT3U(spa_config_held(mc->mc_spa, SCL_ALLOC, RW_WRITER), !=, 0);
 
@@ -744,6 +745,33 @@ metaslab_group_activate(metaslab_group_t *mg)
 		mgprev->mg_next = mg;
 		mgnext->mg_prev = mg;
 	}
+
+	/* Create a kstat to monitor the loading and unloading of metaslabs. */
+	(void) snprintf(kstat_name, sizeof (kstat_name), "%llx",
+	    (unsigned long long) mg->mg_vd->vdev_guid);
+
+	mutex_init(&mg->mg_kstat_lock, NULL, MUTEX_DEFAULT, NULL);
+	if ((mg->mg_kstat = kstat_create("zfs_metaslab_group", 0,
+	    kstat_name, "misc", KSTAT_TYPE_NAMED,
+	    sizeof (metaslab_group_kstat_t) / sizeof (kstat_named_t),
+	    KSTAT_FLAG_VIRTUAL)) != NULL) {
+
+		metaslab_group_kstat_t *mg_kstat = kmem_zalloc(
+		    sizeof (metaslab_group_kstat_t), KM_SLEEP);
+		kstat_named_init(&mg_kstat->mg_loads, "loads",
+		    KSTAT_DATA_UINT64);
+		kstat_named_init(&mg_kstat->mg_unloads, "unloads",
+		    KSTAT_DATA_UINT64);
+		kstat_named_init(&mg_kstat->mg_spa_name, "spa_name",
+		    KSTAT_DATA_STRING);
+		kstat_named_setstr(&mg_kstat->mg_spa_name,
+		    mg->mg_vd->vdev_spa->spa_name);
+
+		mg->mg_kstat->ks_data = mg_kstat;
+		mg->mg_kstat->ks_lock = &mg->mg_kstat_lock;
+		kstat_install(mg->mg_kstat);
+	}
+
 	mc->mc_rotor = mg;
 }
 
@@ -820,6 +848,11 @@ metaslab_group_passivate(metaslab_group_t *mg)
 
 	mg->mg_prev = NULL;
 	mg->mg_next = NULL;
+
+	if (mg->mg_kstat != NULL) {
+		kstat_delete(mg->mg_kstat);
+	}
+	mutex_destroy(&mg->mg_kstat_lock);
 }
 
 boolean_t
@@ -1538,6 +1571,7 @@ metaslab_load_impl(metaslab_t *msp)
 int
 metaslab_load(metaslab_t *msp, uint64_t txg)
 {
+	kstat_t *ksp;
 	ASSERT(MUTEX_HELD(&msp->ms_lock));
 
 	/*
@@ -1549,6 +1583,12 @@ metaslab_load(metaslab_t *msp, uint64_t txg)
 		return (0);
 	VERIFY(!msp->ms_loading);
 
+	ksp = msp->ms_group->mg_kstat;
+	if (ksp != NULL) {
+		metaslab_group_kstat_t *mg_ksp = ksp->ks_data;
+		atomic_inc_64(&mg_ksp->mg_loads.value.ui64);
+	}
+
 	msp->ms_loading = B_TRUE;
 	int error = metaslab_load_impl(msp);
 	msp->ms_loading = B_FALSE;
@@ -1562,6 +1602,14 @@ void
 metaslab_unload(metaslab_t *msp)
 {
 	ASSERT(MUTEX_HELD(&msp->ms_lock));
+
+	if (msp->ms_group != NULL) {
+		kstat_t *ksp = msp->ms_group->mg_kstat;
+		if (ksp != NULL) {
+			metaslab_group_kstat_t *mg_ksp = ksp->ks_data;
+			atomic_inc_64(&mg_ksp->mg_unloads.value.ui64);
+		}
+	}
 	range_tree_vacate(msp->ms_allocatable, NULL, NULL);
 	msp->ms_loaded = B_FALSE;
 	msp->ms_loaded_txg = 0;
diff --git a/usr/src/uts/common/fs/zfs/sys/metaslab_impl.h b/usr/src/uts/common/fs/zfs/sys/metaslab_impl.h
index a04264a23f..33da2a0c00 100644
--- a/usr/src/uts/common/fs/zfs/sys/metaslab_impl.h
+++ b/usr/src/uts/common/fs/zfs/sys/metaslab_impl.h
@@ -276,8 +276,17 @@ struct metaslab_group {
 	boolean_t		mg_initialize_updating;
 	kmutex_t		mg_ms_initialize_lock;
 	kcondvar_t		mg_ms_initialize_cv;
+
+	kstat_t			*mg_kstat;
+	kmutex_t		mg_kstat_lock;
 };
 
+typedef struct metaslab_group_kstat {
+	kstat_named_t	mg_loads;
+	kstat_named_t	mg_unloads;
+	kstat_named_t	mg_spa_name;
+} metaslab_group_kstat_t;
+
 /*
  * This value defines the number of elements in the ms_lbas array. The value
  * of 64 was chosen as it covers all power of 2 buckets up to UINT64_MAX.
-- 
2.21.0

