commit bb2792626067f9893ee9dee3b6b568f6ad02a394 (refs/changes/17/3917/5)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-05-09T22:24:31+00:00 (1 year, 5 months ago)
    
    TRITON-314 Want to expose etags to NAPI consumers

diff --git a/lib/apis/moray.js b/lib/apis/moray.js
index cf50852..1968b08 100644
--- a/lib/apis/moray.js
+++ b/lib/apis/moray.js
@@ -244,6 +244,31 @@ function getObj(moray, bucket, key, callback) {
 }
 
 
+/**
+ * Puts an object into Moray, using its current etag, and updating it with
+ * the new one afterwards.
+ *
+ * @param moray {MorayClient}
+ * @param bucket {Bucket schema object}
+ * @param obj {Object}
+ * @param callback {Function} `function (err, obj)`
+ */
+function putObj(moray, bucket, obj, callback) {
+    moray.putObject(bucket.name, obj.key(), obj.raw(), {
+        etag: obj.etag
+    }, function (err, res) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        obj.etag = res.etag;
+
+        callback(null, obj);
+    });
+}
+
+
 /**
  * Lists objects in moray
  *
@@ -332,46 +357,38 @@ function setTestPrefix(pfx) {
  * - `moray` {MorayClient}
  * - `bucket` {Bucket schema object}
  * - `key` {String} : bucket key to update
+ * - `original` {Object}: The original value stored in Moray
+ * - `etag` {String}: The etag for the original Moray object
  * - `remove` {Boolean} : remove all keys in val from the object (optional)
- * - `replace` {Boolean} : replace the object in moray with val (optional)
  * - `val` {Object} : keys to update in the object
  * @param callback {Function} `function (err, netObj)`
  */
 function updateObj(opts, callback) {
-    // XXX: should assert opts.* here
-    if (opts.replace) {
-        return opts.moray.putObject(opts.bucket.name, opts.key, opts.val,
-            function (err2) {
-            if (err2) {
-                return callback(err2);
-            }
-
-            // Return an object in similar form to getObject()
-            return callback(null, { value: opts.val });
-        });
-    }
-
-    getObj(opts.moray, opts.bucket, opts.key, function (err, res) {
-        if (err) {
-            return callback(err);
+    assert.object(opts, 'opts');
+    assert.object(opts.original, 'opts.original');
+    assert.string(opts.etag, 'opts.etag');
+    assert.func(callback, 'callback');
+
+    var value = jsprim.deepCopy(opts.original);
+    for (var k in opts.val) {
+        if (opts.remove) {
+            delete value[k];
+        } else {
+            value[k] = opts.val[k];
         }
+    }
 
-        for (var k in opts.val) {
-            if (opts.remove) {
-                delete res.value[k];
-            } else {
-                res.value[k] = opts.val[k];
-            }
+    opts.moray.putObject(opts.bucket.name, opts.key, value, {
+        etag: opts.etag
+    }, function (err2, info) {
+        if (err2) {
+            callback(err2);
+            return;
         }
 
-        opts.moray.putObject(opts.bucket.name, opts.key, res.value,
-            { etag: res._etag }, function (err2) {
-            if (err2) {
-                return callback(err2);
-            }
+        value.etag = info.etag;
 
-            return callback(null, res);
-        });
+        callback(null, { value: value });
     });
 }
 
@@ -415,6 +432,7 @@ module.exports = {
     delObj: delObj,
     filter: ldapFilter,
     getObj: getObj,
+    putObj: putObj,
     initBucket: initBucket,
     listObjs: listObjs,
     setTestPrefix: setTestPrefix,
diff --git a/lib/endpoints/aggregations.js b/lib/endpoints/aggregations.js
index 029eaa4..0310a3b 100644
--- a/lib/endpoints/aggregations.js
+++ b/lib/endpoints/aggregations.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -14,10 +14,34 @@
 
 'use strict';
 
+var assert = require('assert-plus');
 var mod_aggr = require('../models/aggregation');
+var reqToOpts = require('../util/common').reqToOpts;
 var restify = require('restify');
 
 
+// --- Internal helpers
+
+/**
+ * Ensures that the aggregation exists, returning 404 if it does not. If it
+ * exists, then the aggregation is stored in req._aggr so it can be used for
+ * further validation.
+ */
+function ensureAggrExists(req, res, next) {
+    mod_aggr.get(reqToOpts(req), function (err, aggr) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        req._aggr = aggr;
+        res.etag = aggr.etag;
+
+        next();
+    });
+}
+
+
 
 // --- Restify handlers
 
@@ -48,14 +72,16 @@ function listAggregations(req, res, next) {
  * POST /aggregations: create an aggregation
  */
 function postAggregation(req, res, next) {
-    mod_aggr.create({ app: req.app, log: req.log, params: req.params },
-        function (err, aggr) {
+    mod_aggr.create(reqToOpts(req), function (err, aggr) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', aggr.etag);
         res.send(200, aggr.serialize());
-        return next();
+
+        next();
     });
 }
 
@@ -64,19 +90,10 @@ function postAggregation(req, res, next) {
  * GET /aggregations/:id: get an aggregation
  */
 function getAggregation(req, res, next) {
-    mod_aggr.get({ app: req.app, log: req.log, params: req.params },
-        function (err, aggr) {
-        if (err) {
-            return next(err);
-        }
-
-        if (!aggr) {
-            return next(new restify.ResourceNotFoundError('not found'));
-        }
-
-        res.send(200, aggr.serialize());
-        return next();
-    });
+    assert.object(req._aggr, 'req._aggr');
+    res.header('Etag', req._aggr.etag);
+    res.send(200, req._aggr.serialize());
+    next();
 }
 
 
@@ -84,14 +101,18 @@ function getAggregation(req, res, next) {
  * PUT /aggregations/:id: update an aggregation
  */
 function putAggregation(req, res, next) {
-    mod_aggr.update({ app: req.app, log: req.log, params: req.params },
-        function (err, aggr) {
+    mod_aggr.update(reqToOpts(req, {
+        existingAggr: req._aggr
+    }), function (err, aggr) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', aggr.etag);
         res.send(200, aggr.serialize());
-        return next();
+
+        next();
     });
 }
 
@@ -100,14 +121,14 @@ function putAggregation(req, res, next) {
  * DELETE /aggregations/:id: delete an aggregation
  */
 function deleteAggregation(req, res, next) {
-    mod_aggr.del({ app: req.app, log: req.log, params: req.params },
-        function (err) {
+    mod_aggr.del(reqToOpts(req), function (err) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
         res.send(204);
-        return next();
+        next();
     });
 }
 
@@ -116,6 +137,11 @@ function deleteAggregation(req, res, next) {
  * Register all endpoints with the restify server
  */
 function register(http, before) {
+    var aggrRequired = before.concat([
+        ensureAggrExists,
+        restify.conditionalRequest()
+    ]);
+
     http.get({ path: '/aggregations', name: 'ListAggregations' },
         before, listAggregations);
     http.head({ path: '/aggregations', name: 'HeadAggregations' },
@@ -125,15 +151,15 @@ function register(http, before) {
             before, postAggregation);
 
     http.get({ path: '/aggregations/:id', name: 'GetAggregation' },
-        before, getAggregation);
+        aggrRequired, getAggregation);
     http.head({ path: '/aggregations/:id', name: 'HeadAggregation' },
-        before, getAggregation);
+        aggrRequired, getAggregation);
 
     http.put({ path: '/aggregations/:id', name: 'UpdateAggregation' },
-            before, putAggregation);
+        aggrRequired, putAggregation);
 
     http.del({ path: '/aggregations/:id', name: 'DeleteAggregation' },
-        before, deleteAggregation);
+        aggrRequired, deleteAggregation);
 }
 
 
diff --git a/lib/endpoints/fabrics/networks.js b/lib/endpoints/fabrics/networks.js
index db4c5e2..beb60d5 100644
--- a/lib/endpoints/fabrics/networks.js
+++ b/lib/endpoints/fabrics/networks.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -14,9 +14,12 @@
 
 'use strict';
 
+var assert = require('assert-plus');
 var constants = require('../../util/constants');
 var mod_common = require('./common');
 var mod_fabric_net = require('../../models/network');
+var mod_jsprim = require('jsprim');
+var mod_restify = require('restify');
 var mod_vlan = require('../../models/vlan');
 
 
@@ -28,14 +31,14 @@ var mod_vlan = require('../../models/vlan');
 /**
  * Return the options object for passing to the mod_fabric_net functions.
  */
-function reqOpts(req) {
-    return {
+function reqOpts(req, extra) {
+    return mod_jsprim.mergeObjects({
         app: req.app,
         log: req.log,
         fabric: true,
         owner_uuid: req.params.owner_uuid,
         params: req.params
-    };
+    }, extra);
 }
 
 
@@ -57,6 +60,30 @@ function getParentVLAN(req, res, next) {
 }
 
 
+/**
+ * Ensures the network exists, and also takes care of performing ownership
+ * checks.
+ */
+function ensureFabricNetworkExists(req, res, next) {
+    mod_fabric_net.get(reqOpts(req), function (err, net) {
+        if (err) {
+            if (err.name === 'InvalidParamsError') {
+                next(new mod_restify.ResourceNotFoundError(err,
+                    'network not found'));
+                return;
+            }
+            next(err);
+            return;
+        }
+
+        req.params.network = net;
+        req._network = net;
+        res.etag = net.etag;
+
+        next();
+    });
+}
+
 
 // --- Endpoints
 
@@ -67,7 +94,9 @@ function getParentVLAN(req, res, next) {
  * fabric network
  */
 function delFabricNetwork(req, res, next) {
-    mod_fabric_net.del(reqOpts(req), function (err) {
+    mod_fabric_net.del(reqOpts(req, {
+        existingNet: req._network
+    }), function (err) {
         if (err) {
             return next(err);
         }
@@ -96,11 +125,14 @@ function createFabricNetwork(req, res, next) {
 
     mod_fabric_net.create(reqOpts(req), function (err, net) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', net.etag);
         res.send(200, net.serialize({ fabric: true }));
-        return next();
+
+        next();
     });
 }
 
@@ -110,14 +142,10 @@ function createFabricNetwork(req, res, next) {
  * GET /fabrics/:owner_uuid/vlans/:vlan_id/networks/:uuid - get a fabric network
  */
 function getFabricNetwork(req, res, next) {
-    mod_fabric_net.get(reqOpts(req), function (err, net) {
-        if (err) {
-            return next(err);
-        }
-
-        res.send(200, net.serialize({ fabric: true }));
-        return next();
-    });
+    assert.object(req._network, 'req._network');
+    res.header('Etag', req._network.etag);
+    res.send(200, req._network.serialize({ fabric: true }));
+    next();
 }
 
 
@@ -151,11 +179,14 @@ function updateFabricNetwork(req, res, next) { // eslint-disable-line
 
     mod_fabric_net.update(reqOpts(req), function (err, net) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', net.etag);
         res.send(200, net.serialize({ fabric: true }));
-        return next();
+
+        next();
     });
 }
 
@@ -169,17 +200,22 @@ function register(http, serverBefore) {
         mod_common.ensureOverlaysEnabled,
         getParentVLAN
     ]);
+    var fabricNetRequired = before.concat([
+        ensureFabricNetworkExists,
+        mod_restify.conditionalRequest()
+    ]);
     var path = '/fabrics/:owner_uuid/vlans/:vlan_id/networks';
     var perObjPath = path + '/:uuid';
 
-    http.del({ path: perObjPath, name: 'delFabricNetwork' },
-        before, delFabricNetwork);
+    http.post({ path: path, name: 'createFabricNetwork' },
+        before, createFabricNetwork);
     http.get({ path: path, name: 'listFabricNetworks' }, before,
         listFabricNetworks);
+
     http.get({ path: perObjPath, name: 'getFabricNetwork' },
-        before, getFabricNetwork);
-    http.post({ path: path, name: 'createFabricNetwork' },
-        before, createFabricNetwork);
+        fabricNetRequired, getFabricNetwork);
+    http.del({ path: perObjPath, name: 'delFabricNetwork' },
+        fabricNetRequired, delFabricNetwork);
 
     // XXX: unsupported for now
     // http.put({ path: perObjPath, name: 'updateFabricNetwork' },
diff --git a/lib/endpoints/fabrics/vlans.js b/lib/endpoints/fabrics/vlans.js
index 4a4873c..24187e8 100644
--- a/lib/endpoints/fabrics/vlans.js
+++ b/lib/endpoints/fabrics/vlans.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -14,9 +14,12 @@
 
 'use strict';
 
+var assert = require('assert-plus');
 var mod_common = require('./common');
 var mod_fabric = require('../../models/fabric');
 var mod_vlan = require('../../models/vlan');
+var reqToOpts = require('../../util/common').reqToOpts;
+var restify = require('restify');
 
 
 
@@ -43,6 +46,20 @@ function getFabric(req, res, next) {
 }
 
 
+function ensureVlanExists(req, res, next) {
+    mod_vlan.get(reqToOpts(req), function (err, vlan) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        req._vlan = vlan;
+        res.etag = vlan.etag;
+
+        next();
+    });
+}
+
 
 // --- Endpoints
 
@@ -52,18 +69,18 @@ function getFabric(req, res, next) {
  * POST /fabrics/:owner_uuid/vlans: create a fabric VLAN
  */
 function createFabricVLAN(req, res, next) {
-    mod_vlan.create({
-        app: req.app,
-        fabric: req._fabric,
-        log: req.log,
-        params: req.params
-    }, function (err, vlan) {
+    mod_vlan.create(reqToOpts(req, {
+        fabric: req._fabric
+    }), function (err, vlan) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', vlan.etag);
         res.send(200, vlan.serialize());
-        return next();
+
+        next();
     });
 }
 
@@ -73,17 +90,14 @@ function createFabricVLAN(req, res, next) {
  * DELETE /fabrics/:owner_uuid/vlans/:vlan_id: delete a fabric VLAN
  */
 function delFabricVLAN(req, res, next) {
-    mod_vlan.del({
-        app: req.app,
-        log: req.log,
-        params: req.params
-    }, function (err) {
+    mod_vlan.del(reqToOpts(req), function (err) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
         res.send(204);
-        return next();
+        next();
     });
 }
 
@@ -93,18 +107,10 @@ function delFabricVLAN(req, res, next) {
  * GET /fabrics/:owner_uuid/vlans/:vlan_id: get a fabric VLAN
  */
 function getFabricVLAN(req, res, next) {
-    mod_vlan.get({
-        app: req.app,
-        log: req.log,
-        params: req.params
-    }, function (err, vlan) {
-        if (err) {
-            return next(err);
-        }
-
-        res.send(200, vlan.serialize());
-        return next();
-    });
+    assert.object(req._vlan, 'req._vlan');
+    res.header('Etag', req._vlan.etag);
+    res.send(200, req._vlan.serialize());
+    next();
 }
 
 
@@ -135,17 +141,18 @@ function listFabricVLANs(req, res, next) {
  * DELETE /fabrics/:owner_uuid/vlans/:vlan_id: delete a fabric VLAN
  */
 function updateFabricVLAN(req, res, next) {
-    mod_vlan.update({
-        app: req.app,
-        log: req.log,
-        params: req.params
-    }, function (err, vlan) {
+    mod_vlan.update(reqToOpts(req, {
+        existingVlan: req._vlan
+    }), function (err, vlan) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', vlan.etag);
         res.send(200, vlan.serialize());
-        return next();
+
+        next();
     });
 }
 
@@ -158,18 +165,24 @@ function register(http, serverBefore) {
     var before = serverBefore.concat([
         mod_common.ensureOverlaysEnabled
     ]);
+    var vlanRequired = before.concat([
+        ensureVlanExists,
+        restify.conditionalRequest()
+    ]);
     var path = '/fabrics/:owner_uuid/vlans';
     var perObjPath = path + '/:vlan_id';
 
     http.del({ path: perObjPath, name: 'delFabricVLAN' },
         before, delFabricVLAN);
-    http.get({ path: path, name: 'listFabricVLANs' }, before, listFabricVLANs);
-    http.get({ path: perObjPath, name: 'getFabricVLAN' },
-        before, getFabricVLAN);
+    http.get({ path: path, name: 'listFabricVLANs' },
+        before, listFabricVLANs);
     http.post({ path: path, name: 'createFabricVLAN' },
         before.concat(getFabric), createFabricVLAN);
+
+    http.get({ path: perObjPath, name: 'getFabricVLAN' },
+        vlanRequired, getFabricVLAN);
     http.put({ path: perObjPath, name: 'updateFabricVLAN' },
-        before, updateFabricVLAN);
+        vlanRequired, updateFabricVLAN);
 }
 
 
diff --git a/lib/endpoints/network-pools.js b/lib/endpoints/network-pools.js
index 10f01c2..da86f95 100644
--- a/lib/endpoints/network-pools.js
+++ b/lib/endpoints/network-pools.js
@@ -14,20 +14,42 @@
 
 'use strict';
 
+var assert = require('assert-plus');
 var mod_pool = require('../models/network-pool');
+var reqToOpts = require('../util/common').reqToOpts;
 var restify = require('restify');
 
 
 
 // --- Restify handlers
 
+/**
+ * Ensures that the pool exists, returning 404 if it does not. If it exists,
+ * then the pool is stored in req._pool so it can be used for further
+ * validation.
+ */
+function ensurePoolExists(req, res, next) {
+    mod_pool.get(req.app, req.log, req.params, function (err, pool) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        req._pool = pool;
+        res.etag = pool.etag;
+
+        next();
+    });
+}
+
+
 
 
 /**
  * GET /network_pools: get the list of network pools
  */
 function listNetworkPools(req, res, next) {
-    mod_pool.list(req.app, req.log, req.params, function (err, pools) {
+    mod_pool.list(reqToOpts(req), function (err, pools) {
         if (err) {
             return next(err);
         }
@@ -49,11 +71,14 @@ function listNetworkPools(req, res, next) {
 function postNetworkPool(req, res, next) {
     mod_pool.create(req.app, req.log, req.params, function (err, pool) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', pool.etag);
         res.send(200, pool.serialize());
-        return next();
+
+        next();
     });
 }
 
@@ -62,18 +87,10 @@ function postNetworkPool(req, res, next) {
  * GET /network_pools/:uuid: get a network pool
  */
 function getNetworkPool(req, res, next) {
-    mod_pool.get(req.app, req.log, req.params, function (err, pool) {
-        if (err) {
-            return next(err);
-        }
-
-        if (!pool) {
-            return next(new restify.ResourceNotFoundError('not found'));
-        }
-
-        res.send(200, pool.serialize());
-        return next();
-    });
+    assert.object(req._pool, 'req._pool');
+    res.header('Etag', req._pool.etag);
+    res.send(200, req._pool.serialize());
+    next();
 }
 
 
@@ -81,13 +98,18 @@ function getNetworkPool(req, res, next) {
  * PUT /network_pools/:uuid: update a network pool
  */
 function putNetworkPool(req, res, next) {
-    mod_pool.update(req.app, req.log, req.params, function (err, pool) {
+    mod_pool.update(reqToOpts(req, {
+        oldPool: req._pool
+    }), function (err, pool) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', pool.etag);
         res.send(200, pool.serialize());
-        return next();
+
+        next();
     });
 }
 
@@ -96,13 +118,16 @@ function putNetworkPool(req, res, next) {
  * DELETE /network_pools/:uuid: delete a network pool
  */
 function deleteNetworkPool(req, res, next) {
-    mod_pool.del(req.app, req.log, req.params, function (err) {
+    mod_pool.del(reqToOpts(req, {
+        existingPool: req._pool
+    }), function (err) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
         res.send(204);
-        return next();
+        next();
     });
 }
 
@@ -111,21 +136,26 @@ function deleteNetworkPool(req, res, next) {
  * Register all endpoints with the restify server
  */
 function register(http, before) {
+    var poolRequired = before.concat([
+        ensurePoolExists,
+        restify.conditionalRequest()
+    ]);
+
     http.get({ path: '/network_pools', name: 'ListNetworkPools' },
         before, listNetworkPools);
     http.head({ path: '/network_pools', name: 'HeadNetworkPools' },
         before, listNetworkPools);
     http.post({ path: '/network_pools', name: 'CreateNetworkPool' },
-            before, postNetworkPool);
+        before, postNetworkPool);
 
     http.get({ path: '/network_pools/:uuid', name: 'GetNetworkPool' },
-        before, getNetworkPool);
+        poolRequired, getNetworkPool);
     http.head({ path: '/network_pools/:uuid', name: 'HeadNetworkPool' },
-        before, getNetworkPool);
+        poolRequired, getNetworkPool);
     http.put({ path: '/network_pools/:uuid', name: 'UpdateNetworkPool' },
-            before, putNetworkPool);
+        poolRequired, putNetworkPool);
     http.del({ path: '/network_pools/:uuid', name: 'DeleteNetworkPool' },
-        before, deleteNetworkPool);
+        poolRequired, deleteNetworkPool);
 }
 
 
diff --git a/lib/endpoints/networks/common.js b/lib/endpoints/networks/common.js
index 3e850bb..95cf5f2 100644
--- a/lib/endpoints/networks/common.js
+++ b/lib/endpoints/networks/common.js
@@ -14,11 +14,21 @@
 
 'use strict';
 
+var assert = require('assert-plus');
 var mod_net = require('../../models/network');
 var mod_restify = require('restify');
+var reqToOpts = require('../../util/common').reqToOpts;
 
 
 
+// --- Globals
+
+var USE_FULL_GET_SCHEMA = {
+    'getnetwork': true,
+    'headnetwork': true,
+    'deletenetwork': true
+};
+
 // --- Exports
 
 
@@ -27,13 +37,26 @@ var mod_restify = require('restify');
  * Ensures the network exists, returning 404 if it does not. If it exists,
  * the network is stored in req.params._network so it can be used for
  * further validation.
+ *
+ * If this is a USE_FULL_GET_SCHEMA request, then we want to make sure
+ * we pass through everything to the GET_SCHEMA so that we perform
+ * ownership checks.
  */
 function ensureNetworkExists(netKey, req, res, next) {
-    var opts = {
-        app: req.app,
-        log: req.log,
-        params: { uuid: req.params[netKey] }
-    };
+    var opts;
+
+    if (USE_FULL_GET_SCHEMA[req.route.name]) {
+        assert.equal(netKey, 'uuid');
+        opts = reqToOpts(req);
+    } else {
+        opts = {
+            app: req.app,
+            log: req.log,
+            params: {
+                uuid: req.params[netKey]
+            }
+        };
+    }
 
     mod_net.get(opts, function (err, net) {
         if (err) {
@@ -51,9 +74,10 @@ function ensureNetworkExists(netKey, req, res, next) {
          * of the allowed symbolic names, like "admin".
          */
         req.params[netKey] = net.uuid;
-
         req.params.network = net;
         req._network = net;
+        res.etag = net.etag;
+
         next();
     });
 }
diff --git a/lib/endpoints/networks/index.js b/lib/endpoints/networks/index.js
index c22cf1a..af1e3b1 100644
--- a/lib/endpoints/networks/index.js
+++ b/lib/endpoints/networks/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -14,10 +14,12 @@
 
 'use strict';
 
+var assert = require('assert-plus');
 var errors = require('../../util/errors');
 var mod_common = require('./common');
 var mod_net = require('../../models/network');
 var mod_pool = require('../../models/network-pool');
+var reqToOpts = require('../../util/common').reqToOpts;
 var restify = require('restify');
 
 
@@ -30,8 +32,13 @@ var restify = require('restify');
  * Ensures the network isn't in use in a network pool
  */
 function ensureNetworkUnused(req, res, next) {
-    mod_pool.list(req.app, req.log, { networks: [ req.params.uuid ] },
-        function (err, usedBy) {
+    mod_pool.list({
+        app: req.app,
+        log: req.log,
+        params: {
+            networks: [ req.params.uuid ]
+        }
+    }, function (err, usedBy) {
         if (err) {
             next(err);
             return;
@@ -87,25 +94,12 @@ function listNetworks(req, res, next) {
  * GET /networks/:uuid: get an individual network
  */
 function getNetwork(req, res, next) {
-    var opts = {
-        app: req.app,
-        log: req.log,
-        params: req.params
-    };
+    assert.object(req._network, 'req._network');
 
-    mod_net.get(opts, function (err, net) {
-        req.log.trace('getNetwork: cb entry');
-        if (err) {
-            return next(err);
-        }
-
-        if (!net) {
-            return next(new restify.ResourceNotFoundError('network not found'));
-        }
-
-        res.send(200, net.serialize());
-        return next();
-    });
+    req.log.trace('getNetwork: cb entry');
+    res.header('Etag', req._network.etag);
+    res.send(200, req._network.serialize());
+    next();
 }
 
 
@@ -122,11 +116,14 @@ function postNetwork(req, res, next) {
     mod_net.create(opts, function (err, net) {
         req.log.debug('postNetwork: cb entry');
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', net.etag);
         res.send(200, net.serialize());
-        return next();
+
+        next();
     });
 }
 
@@ -144,13 +141,16 @@ function putNetwork(req, res, next) {
     mod_net.update(opts, function (err, net) {
         req.log.debug('putNetwork: cb entry');
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
         var ser = net.serialize();
 
+        res.header('Etag', net.etag);
         res.send(200, ser);
-        return next();
+
+        next();
     });
 }
 
@@ -159,13 +159,9 @@ function putNetwork(req, res, next) {
  * DELETE /networks/:uuid: delete a network
  */
 function deleteNetwork(req, res, next) {
-    var opts = {
-        app: req.app,
-        log: req.log,
-        params: req.params
-    };
-
-    mod_net.del(opts, function (err) {
+    mod_net.del(reqToOpts(req, {
+        existingNet: req._network
+    }), function (err) {
         req.log.debug('deleteNetwork: cb entry');
         if (err) {
             return next(err);
@@ -181,26 +177,27 @@ function deleteNetwork(req, res, next) {
  */
 function register(http, before) {
     var netRequired = before.concat([
-        mod_common.ensureNetworkExists.bind(null, 'uuid')
+        mod_common.ensureNetworkExists.bind(null, 'uuid'),
+        restify.conditionalRequest()
     ]);
 
     http.post({ path: '/networks', name: 'CreateNetwork' },
-            before, postNetwork);
-    http.get(
-        { path: '/networks', name: 'ListNetworks' }, before, listNetworks);
-    http.head(
-        { path: '/networks', name: 'HeadNetworks' }, before, listNetworks);
+        before, postNetwork);
+    http.get({ path: '/networks', name: 'ListNetworks' },
+        before, listNetworks);
+    http.head({ path: '/networks', name: 'HeadNetworks' },
+        before, listNetworks);
 
     http.get({ path: '/networks/:uuid', name: 'GetNetwork' },
-        before, getNetwork);
+        netRequired, getNetwork);
     http.head({ path: '/networks/:uuid', name: 'HeadNetwork' },
-        before, getNetwork);
+        netRequired, getNetwork);
 
     http.put({ path: '/networks/:uuid', name: 'PutNetwork' },
         netRequired, putNetwork);
 
     http.del({ path: '/networks/:uuid', name: 'DeleteNetwork' },
-        before.concat(ensureNetworkUnused), deleteNetwork);
+        netRequired.concat(ensureNetworkUnused), deleteNetwork);
 }
 
 
diff --git a/lib/endpoints/networks/ips.js b/lib/endpoints/networks/ips.js
index 094b81a..01ea52c 100644
--- a/lib/endpoints/networks/ips.js
+++ b/lib/endpoints/networks/ips.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -14,8 +14,10 @@
 
 'use strict';
 
+var assert = require('assert-plus');
 var mod_common = require('./common');
 var mod_ip = require('../../models/ip');
+var reqToOpts = require('../../util/common').reqToOpts;
 var restify = require('restify');
 var util_ip = require('../../util/ip');
 var mod_jsprim = require('jsprim');
@@ -25,6 +27,46 @@ var mod_jsprim = require('jsprim');
 // --- Helper functions
 
 
+/*
+ * The API pretends that IPs exist when they don't actually exist in Moray,
+ * so that consumers can do a GET on an IP to find out if it's in use.
+ * Doing a get({ returnObject: true }) here first serves several purposes:
+ *
+ * 1) Allows us to determine whether we should do a create or an update in
+ *    Moray in UpdateIP.
+ * 2) For an update, the existing record is needed to ensure that all of
+ *    belongs_to_uuid, owner_uuid and belongs_to_type will be set.
+ * 3) Sets the etag so that HTTP consumers can set If-Match headers.
+ *
+ * We store the IP object in req._ip for the handlers that come later in
+ * the chain.
+ */
+function ensureIpExists(req, res, next) {
+    req.params.network = req._network;
+
+    mod_ip.get({
+        app: req.app,
+        log: req.log,
+        params: req.params,
+        returnObject: true
+    }, function (err, ip) {
+        if (err) {
+            if (err.name === 'InvalidParamsError') {
+                next(new restify.ResourceNotFoundError(err,
+                    'network not found'));
+                return;
+            }
+
+            next(err);
+            return;
+        }
+
+        req._ip = ip;
+        res.etag = ip.etag;
+
+        next();
+    });
+}
 
 /**
  * Validate IP before calling ips/:ip_addr endpoints
@@ -83,25 +125,12 @@ function listIPs(req, res, next) {
  * GET /networks/:network_uuid/ips/:ip_addr: get IP
  */
 function getIP(req, res, next) {
-    req.params.network = req._network;
-
-    var getOpts = {
-        app: req.app,
-        log: req.log,
-        params: req.params,
-        // If the IP doesn't exist in moray, return a record anyway, so that
-        // consumers know it's available:
-        returnObject: true
-    };
-
-    mod_ip.get(getOpts, function (err, ip) {
-        if (err) {
-            return next(err);
-        }
-
-        res.send(200, ip.serialize());
-        return next();
-    });
+    assert.object(req._ip, 'req._ip');
+    if (req._ip.etag !== null) {
+        res.header('Etag', req._ip.etag);
+    }
+    res.send(200, req._ip.serialize());
+    next();
 }
 
 
@@ -109,67 +138,39 @@ function getIP(req, res, next) {
  * PUT /networks/:network_uuid/ips/:ip_addr: update IP
  */
 function putIP(req, res, next) {
+    var opts = reqToOpts(req, {
+        existingIP: req._ip
+    });
+
     // the mod_ip.* functions require a network model object:
-    req.params.network = req._network;
+    opts.params.network = req._network;
 
-    if (mod_jsprim.hasKey(req.params, 'free') && req.params.free &&
-        !mod_jsprim.hasKey(req.params, 'unassign')) {
+    function sendResponse(err, ip) {
+        if (err) {
+            next(err);
+            return;
+        }
 
-        return mod_ip.del(req.app, req.log, req.params, function (err) {
-            if (err && err.statusCode !== 404) {
-                return next(err);
-            }
+        res.header('Etag', ip.etag);
+        res.send(200, ip.serialize());
 
-            res.send(200, {
-                ip: req.params.ip_addr,
-                network_uuid: req.params.network_uuid,
-                reserved: false,
-                free: true
-            });
-            return next();
-        });
+        next();
     }
 
-    /*
-     * The API pretends that IPs exist when they don't actually exist in Moray,
-     * so that consumers can do a GET on an IP to find out if it's in use.
-     * Doing a GET here first serves two purposes:
-     *
-     * 1) Determines whether we should do a create or an update in Moray.
-     * 2) For an update, the existing record is needed to ensure that all of
-     *    belongs_to_uuid, owner_uuid and belongs_to_type will be set.
-     */
-
-    mod_ip.get({ app: req.app, log: req.log, params: req.params },
-        function (err, ip) {
-        if (err || !ip) {
-            if (err && err.statusCode !== 404) {
-                return next(err);
-            }
-
-            // Not found in moray, so do a create
-            return mod_ip.create(req.app, req.log, req.params,
-                function (err2, ip2) {
-                if (err2) {
-                    return next(err2);
-                }
-
-                res.send(200, ip2.serialize());
-                return next();
-            });
-        }
+    if (mod_jsprim.hasKey(req.params, 'free') && req.params.free &&
+        !mod_jsprim.hasKey(req.params, 'unassign')) {
+        mod_ip.del(opts, sendResponse);
+        return;
+    }
 
+    if (opts.existingIP.etag === null) {
+        // Not found in Moray, so do a create
+        mod_ip.create(opts, sendResponse);
+    } else {
         // IP found in moray, so do an update
-        req.params.oldIP = ip.serialize();
-        mod_ip.update(req.app, req.log, req.params, function (err2, ip2) {
-            if (err2) {
-                return next(err2);
-            }
-
-            res.send(200, ip2.serialize());
-            return next();
-        });
-    });
+        req.params.oldIP = opts.existingIP.serialize();
+        mod_ip.update(opts, sendResponse);
+    }
 }
 
 
@@ -180,20 +181,21 @@ function register(http, before) {
     var beforeAll = before.concat([
         mod_common.ensureNetworkExists.bind(null, 'network_uuid')
     ]);
-    var beforeIP = beforeAll.concat(validateIP);
+    var ipRequired = beforeAll.concat([
+        validateIP,
+        ensureIpExists,
+        restify.conditionalRequest()
+    ]);
 
-    http.get(
-        { path: '/networks/:network_uuid/ips', name: 'ListIPs' },
+    http.get({ path: '/networks/:network_uuid/ips', name: 'ListIPs' },
         beforeAll, listIPs);
-    http.head(
-        { path: '/networks/:network_uuid/ips', name: 'HeadIPs' },
+    http.head({ path: '/networks/:network_uuid/ips', name: 'HeadIPs' },
         beforeAll, listIPs);
-    http.get(
-        { path: '/networks/:network_uuid/ips/:ip_addr', name: 'GetIP' },
-        beforeIP, getIP);
-    http.put(
-        { path: '/networks/:network_uuid/ips/:ip_addr', name: 'UpdateIP' },
-        beforeIP, putIP);
+
+    http.get({ path: '/networks/:network_uuid/ips/:ip_addr', name: 'GetIP' },
+        ipRequired, getIP);
+    http.put({ path: '/networks/:network_uuid/ips/:ip_addr', name: 'UpdateIP' },
+        ipRequired, putIP);
 }
 
 
diff --git a/lib/endpoints/networks/nics.js b/lib/endpoints/networks/nics.js
index 148743c..273255b 100644
--- a/lib/endpoints/networks/nics.js
+++ b/lib/endpoints/networks/nics.js
@@ -30,10 +30,14 @@ function postNetworkNic(req, res, next) {
     mod_nic.create(reqToOpts(req),
         function (err, nic) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
+
+        res.header('Etag', nic.etag);
         res.send(200, nic.serialize());
-        return next();
+
+        next();
     });
 }
 
diff --git a/lib/endpoints/nics.js b/lib/endpoints/nics.js
index 0f7cc97..29d9ac5 100644
--- a/lib/endpoints/nics.js
+++ b/lib/endpoints/nics.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -14,10 +14,10 @@
 
 'use strict';
 
+var assert = require('assert-plus');
 var mod_nic = require('../models/nic');
 var reqToOpts = require('../util/common').reqToOpts;
 var restify = require('restify');
-var util = require('util');
 
 
 
@@ -27,6 +27,26 @@ var util = require('util');
  *   are the same?
  */
 
+// --- Internal helpers
+
+/**
+ * Ensures that the NIC exists, returning 404 if it does not. If it exists, then
+ * the NIC is stored in req._nic so it can be used for further validation.
+ */
+function ensureNicExists(req, res, next) {
+    mod_nic.get(reqToOpts(req), function (err, nic) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        req._nic = nic;
+        res.etag = nic.etag;
+
+        next();
+    });
+}
+
 
 
 // --- Endpoints
@@ -59,9 +79,13 @@ function listNics(req, res, next) {
  * (http://www.w3.org/Addressing/URL/url-spec.txt) and RFC 1738
  * (http://www.ietf.org/rfc/rfc1738.txt), a colon in a HTTP path is reserved
  * and therefore technically not allowed. In the interests of being
- * well-behaved, :mac is specified by either:
+ * well-behaved, clients should send :mac as either:
+ *
  * - the address with colons removed.(eg: /nics/90b8d0173717)
  * - the address with dashes instead of colons (eg: /nics/90-b8-d0-17-37-17)
+ *
+ * NAPI will accept a MAC with colons (90:b8:d0:17:37:17), but this should
+ * only be taken advantage of by humans and avoided by software consumers.
  */
 
 
@@ -69,20 +93,10 @@ function listNics(req, res, next) {
  * GET /nics/:mac: get a nic
  */
 function getNic(req, res, next) {
-    mod_nic.get(reqToOpts(req), function (err, nic) {
-        req.log.debug({ err: err, nic: nic }, 'getNic: cb entry');
-        if (err) {
-            return next(err);
-        }
-
-        if (!nic) {
-            return next(new restify.ResourceNotFoundError(
-                util.format('Unknown nic "%s"', req.params.mac)));
-        }
-
-        res.send(200, nic.serialize());
-        return next();
-    });
+    assert.object(req._nic, 'req._nic');
+    res.header('Etag', req._nic.etag);
+    res.send(200, req._nic.serialize());
+    next();
 }
 
 
@@ -90,13 +104,19 @@ function getNic(req, res, next) {
  * PUT /nics/:mac_address: modify a nic's parameters
  */
 function putNic(req, res, next) {
-    mod_nic.update(reqToOpts(req), function (err, nic) {
+    mod_nic.update(reqToOpts(req, {
+        existingNic: req._nic
+    }), function (err, nic) {
         req.log.debug({ err: err, nic: nic }, 'putNic: cb entry');
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
+
+        res.header('Etag', nic.etag);
         res.send(200, nic.serialize());
-        return next();
+
+        next();
     });
 }
 
@@ -108,11 +128,14 @@ function postNic(req, res, next) {
     mod_nic.create(reqToOpts(req), function (err, nic) {
         req.log.debug({ err: err, nic: nic }, 'postNic: cb entry');
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
+        res.header('Etag', nic.etag);
         res.send(200, nic.serialize());
-        return next();
+
+        next();
     });
 }
 
@@ -121,7 +144,9 @@ function postNic(req, res, next) {
  * DELETE /nics/:mac: delete a nic
  */
 function deleteNic(req, res, next) {
-    mod_nic.del(reqToOpts(req), function (err) {
+    mod_nic.del(reqToOpts(req, {
+        existingNic: req._nic
+    }), function (err) {
         req.log.debug({ err: err }, 'deleteNic: cb entry');
         if (err) {
             return next(err);
@@ -136,6 +161,11 @@ function deleteNic(req, res, next) {
  * Register all endpoints with the restify server
  */
 function register(http, before) {
+    var nicRequired = before.concat([
+        ensureNicExists,
+        restify.conditionalRequest()
+    ]);
+
     http.get({ path: '/nics', name: 'ListNics' },
         before, listNics);
     http.head({ path: '/nics', name: 'HeadNics' },
@@ -144,13 +174,13 @@ function register(http, before) {
             before, postNic);
 
     http.get({ path: '/nics/:mac', name: 'GetNic' },
-        before, getNic);
+        nicRequired, getNic);
     http.head({ path: '/nics/:mac', name: 'HeadNic' },
-        before, getNic);
+        nicRequired, getNic);
     http.put({ path: '/nics/:mac', name: 'UpdateNic' },
-            before, putNic);
+        nicRequired, putNic);
     http.del({ path: '/nics/:mac', name: 'DeleteNic' },
-        before, deleteNic);
+        nicRequired, deleteNic);
 }
 
 
diff --git a/lib/models/aggregation.js b/lib/models/aggregation.js
index e048fff..71edd59 100644
--- a/lib/models/aggregation.js
+++ b/lib/models/aggregation.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -79,6 +79,9 @@ var LIST_SCHEMA = {
 };
 
 var UPDATE_SCHEMA = {
+    required: {
+        id: validate.string
+    },
     optional: {
         lacp_mode: validateLACPmode,
         nic_tags_provided: mod_nicTag.validateExists.bind(null, false),
@@ -283,6 +286,9 @@ Object.defineProperty(Aggr.prototype, 'id', {
     get: function () { return this.params.id; }
 });
 
+Aggr.prototype.key = function aggrKey() {
+    return this.params.id;
+};
 
 /**
  * Returns the raw moray form of the aggregation
@@ -363,8 +369,7 @@ function createAggr(opts, callback) {
         }
 
         var aggr = new Aggr(validated);
-        app.moray.putObject(BUCKET.name, aggr.id, aggr.raw(),
-            { etag: null }, function (pErr) {
+        mod_moray.putObj(app.moray, BUCKET, aggr, function (pErr) {
             if (pErr) {
                 if (VError.hasCauseWithName(pErr, 'EtagConflictError')) {
                     callback(new errors.InvalidParamsError(
@@ -453,29 +458,27 @@ function listAggrs(opts, callback) {
 function updateAggr(opts, callback) {
     opts.log.debug(opts.params, 'updateAggr: entry');
 
-    getAggr(opts, function (getErr, oldAggr) {
-        if (getErr) {
-            return callback(getErr);
+    validate.params(UPDATE_SCHEMA, opts, opts.params,
+        function (vErr, params) {
+        if (vErr) {
+            callback(vErr);
+            return;
         }
 
-        validate.params(UPDATE_SCHEMA, opts, opts.params,
-            function (err, params) {
-            if (err) {
-                return callback(err);
+        mod_moray.updateObj({
+            moray: opts.app.moray,
+            bucket: BUCKET,
+            original: opts.existingAggr.raw(),
+            etag: opts.existingAggr.etag,
+            key: params.id,
+            val: params
+        }, function (uErr, rec) {
+            if (uErr) {
+                callback(uErr);
+                return;
             }
 
-            mod_moray.updateObj({
-                moray: opts.app.moray,
-                bucket: BUCKET,
-                key: oldAggr.id,
-                val: params
-            }, function (err2, rec) {
-                if (err2) {
-                    return callback(err2);
-                }
-
-                return callback(null, new Aggr(rec.value));
-            });
+            callback(null, new Aggr(rec.value));
         });
     });
 }
diff --git a/lib/models/ip/index.js b/lib/models/ip/index.js
index abe2a54..2eb036c 100644
--- a/lib/models/ip/index.js
+++ b/lib/models/ip/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -260,8 +260,9 @@ function getIP(opts, callback) {
     log.debug(params, 'getIP: entry');
     var ip = util_ip.toIPAddr(params.ip);
     if (!ip) {
-        return callback(new restify.InvalidArgumentError(
+        callback(new restify.InvalidArgumentError(
             'Invalid IP %s', params.ip));
+        return;
     }
 
     var ipBucket = common.getBucketObj(params.network_uuid);
@@ -303,6 +304,7 @@ function getIP(opts, callback) {
  *
  * @param app {App}
  * @param log {Log}
+ * @param existingIP {Object}: The IP being updated
  * @param params {Object}:
  * - `belongs_to_type`: Belongs to type (optional)
  * - `belongs_to_uuid`: Belongs to UUID (optional)
@@ -312,13 +314,17 @@ function getIP(opts, callback) {
  * - `reserved`: Reserved (optional)
  * @param callback {Function} `function (err, ipObj)`
  */
-function updateIP(app, log, params, callback) {
+function updateIP(opts, callback) {
+    var params = opts.params;
+    var log = opts.log;
+
     log.debug(params, 'updateIP: entry');
     var ip = util_ip.toIPAddr(params.ip);
 
     if (!ip) {
-        return callback(new restify.InvalidArgumentError(
+        callback(new restify.InvalidArgumentError(
             'Invalid IP "%s"', params.ip));
+        return;
     }
 
     var validateParams = {
@@ -373,7 +379,9 @@ function updateIP(app, log, params, callback) {
         var updateOpts = {
             bucket: common.getBucketObj(params.network_uuid),
             key: key,
-            moray: app.moray,
+            original: opts.existingIP.raw(),
+            etag: opts.existingIP.etag,
+            moray: opts.app.moray,
             val: validatedParams
         };
 
@@ -403,7 +411,6 @@ function updateIP(app, log, params, callback) {
 
             rec.value.network = params.network;
             rec.value.network_uuid = params.network_uuid;
-            rec.value.etag = rec._etag;
             var newIP = new IP(rec.value);
 
             log.info({
@@ -421,15 +428,19 @@ function updateIP(app, log, params, callback) {
 /**
  * Creates an IP
  *
- * @param app {App}
- * @param log {Log}
- * @param params {Object}:
- * - `ip`: IP address (required)
- * - `network_uuid`: Network UUID (required)
- * - `network`: Network object (required)
+ * @param opts {App}
+ * - `app`: The application object
+ * - `log`: The Bunyan logger
+ * - `params`: The parameters for the IP:
+ *   - `ip`: IP address (required)
+ *   - `network_uuid`: Network UUID (required)
+ *   - `network`: Network object (required)
  * @param callback {Function} `function (err, ipObj)`
  */
-function createIP(app, log, params, callback) {
+function createIP(opts, callback) {
+    var params = opts.params;
+    var log = opts.log;
+
     log.debug(params, 'createIP: entry');
 
     validate.params(CREATE_SCHEMA, null, params,
@@ -450,8 +461,8 @@ function createIP(app, log, params, callback) {
         var ipBucket = common.getBucketObj(validated.network.uuid);
         log.debug({ params: params, bucket: ipBucket }, 'addIP: creating IP');
 
-        app.moray.putObject(ipBucket.name, key, ip.raw(),
-            { etag: null }, function (err) {
+        opts.app.moray.putObject(ipBucket.name, key, ip.raw(),
+            { etag: null }, function (err, res) {
             if (err) {
                 log.error({
                     err: err,
@@ -459,7 +470,8 @@ function createIP(app, log, params, callback) {
                     obj: ip.serialize()
                 }, 'Error creating IP');
 
-                return callback(err);
+                callback(err);
+                return;
             }
 
             log.info({
@@ -467,7 +479,9 @@ function createIP(app, log, params, callback) {
                 obj: ip.serialize()
             }, 'Created IP');
 
-            return callback(null, ip);
+            ip.etag = res.etag;
+
+            callback(null, ip);
         });
     });
 }
@@ -535,22 +549,29 @@ function batchCreateIPs(app, log, params, callback) {
 /*
  * Deletes an IP
  *
- * @param app {App}
- * @param log {Log}
- * @param params {Object}:
- * - `ip`: IP number or address (required)
- * - `network_uuid`: Network UUID (required)
+ * @param opts {Object}:
+ * - `app` {App}
+ * - `log` {Log}
+ * - `params` {Object}:
+ *   - `ip`: IP number or address (required)
+ *   - `network_uuid`: Network UUID (required)
  * @param callback {Function} `function (err, ipObj)`
  */
-function deleteIP(app, log, params, callback) {
+function deleteIP(opts, callback) {
+    var params = opts.params;
+    var log = opts.log;
+
     log.debug(params, 'deleteIP: entry');
+
     var ip = util_ip.toIPAddr(params.ip);
     if (!ip) {
-        return callback(new restify.InvalidArgumentError(
+        callback(new restify.InvalidArgumentError(
             'Invalid IP "%s"', params.ip));
+        return;
     }
 
     var use_strings = params.network.ip_use_strings;
+    var bucket = common.bucketName(params.network.uuid);
     var key = common.getIPKey(use_strings, ip);
     var val = {
         reserved: false
@@ -563,27 +584,20 @@ function deleteIP(app, log, params, callback) {
     }
 
     log.info(params, 'deleteIP: deleting IP %s', ip.toString());
-    mod_moray.updateObj({
-        bucket: common.getBucketObj(params.network_uuid),
-        key: key,
-        moray: app.moray,
-        replace: true,
-        val: val
+
+    opts.app.moray.putObject(bucket, key, val, {
+        etag: opts.existingIP.etag
     }, function (err, res) {
         if (err) {
-            log.error({
-                err: err,
-                ip: params.ip
-            }, 'Error deleting IP');
-
-        } else {
-            log.info({
-                ip: params.ip,
-                raw: res.value
-            }, 'Deleted IP');
+            callback(err);
+            return;
         }
 
-        return callback(err, res);
+        val.etag = res.etag;
+        val.network = params.network;
+        val.network_uuid = params.network.uuid;
+
+        callback(null, new IP(val));
     });
 }
 
diff --git a/lib/models/network-pool.js b/lib/models/network-pool.js
index 86580c2..129961d 100644
--- a/lib/models/network-pool.js
+++ b/lib/models/network-pool.js
@@ -428,6 +428,14 @@ NetworkPool.prototype.isOwner = function poolHasOwner(owner) {
 };
 
 
+/**
+ * Returns the key for storing this NetworkPool object.
+ */
+NetworkPool.prototype.key = function poolKey() {
+    return this.uuid;
+};
+
+
 /**
  * Returns the raw moray form of the network pool
  */
@@ -515,8 +523,7 @@ function createNetworkPool(app, log, params, callback) {
         }
 
         var pool = new NetworkPool(validatedParams);
-        app.moray.putObject(BUCKET.name, pool.uuid, pool.raw(), { etag: null },
-            function (err2) {
+        mod_moray.putObj(app.moray, BUCKET, pool, function (err2) {
             if (err2) {
                 callback(err2);
                 return;
@@ -582,10 +589,13 @@ function getNetworkPool(app, log, params, callback) {
 /**
  * Lists network pools
  */
-function listNetworkPools(app, log, oparams, callback) {
-    log.debug({ params: oparams }, 'listNetworkPools: entry');
+function listNetworkPools(opts, callback) {
+    var app = opts.app;
+    var log = opts.log;
+
+    log.debug({ params: opts.params }, 'listNetworkPools: entry');
 
-    validate.params(LIST_SCHEMA, null, oparams, function (valErr, params) {
+    validate.params(LIST_SCHEMA, null, opts.params, function (valErr, params) {
         if (valErr) {
             callback(valErr);
             return;
@@ -680,60 +690,53 @@ function listNetworkPools(app, log, oparams, callback) {
 /**
  * Updates a network pool
  */
-function updateNetworkPool(app, log, params, callback) {
-    log.debug(params, 'updateNetworkPool: entry');
+function updateNetworkPool(opts, callback) {
+    var app = opts.app;
+    var log = opts.log;
+    var params = opts.params;
+    var oldPool = opts.oldPool;
 
-    getNetworkPool(app, log, params, function (getErr, oldPool) {
-        if (getErr) {
-            callback(getErr);
+    log.debug(opts.params, 'updateNetworkPool: entry');
+
+    if (!params.hasOwnProperty('networks') &&
+        params.hasOwnProperty('owner_uuids') &&
+        oldPool.params.hasOwnProperty('networks')) {
+        /*
+         * We need to fetch the networks to validate owner_uuid, so just
+         * let validateNetworks() take care of it.
+         */
+        params.networks = oldPool.params.networks;
+    }
+
+    validate.params(UPDATE_SCHEMA, opts, params,
+        function (err, validatedParams) {
+        if (err) {
+            callback(err);
             return;
         }
 
-        if (!params.hasOwnProperty('networks') &&
-            params.hasOwnProperty('owner_uuids') &&
-            oldPool.params.hasOwnProperty('networks')) {
-            // We need to fetch the networks to validate owner_uuid, so just
-            // let validateNetworks() take care of it
-            params.networks = oldPool.params.networks;
+        if (validatedParams.hasOwnProperty('owner_uuids') &&
+            validatedParams.owner_uuids.length === 0) {
+            validatedParams.owner_uuids = null;
         }
 
-        var uopts = {
-            app: app,
-            log: log,
-            oldPool: oldPool
-        };
-
-        validate.params(UPDATE_SCHEMA, uopts, params,
-            function (err, validatedParams) {
-            if (err) {
-                callback(err);
-                return;
-            }
+        var updatedParams = oldPool.raw();
+        updatedParams._netobjs = oldPool.params._netobjs;
+        updatedParams.etag = oldPool.etag;
 
-            if (validatedParams.hasOwnProperty('owner_uuids') &&
-                validatedParams.owner_uuids.length === 0) {
-                validatedParams.owner_uuids = null;
-            }
+        for (var p in validatedParams) {
+            updatedParams[p] = validatedParams[p];
+        }
 
-            var updatedParams = oldPool.raw();
-            updatedParams._netobjs = oldPool.params._netobjs;
+        var newPool = new NetworkPool(updatedParams);
 
-            for (var p in validatedParams) {
-                updatedParams[p] = validatedParams[p];
+        mod_moray.putObj(app.moray, BUCKET, newPool, function (err2) {
+            if (err2) {
+                callback(err2);
+                return;
             }
 
-            var newPool = new NetworkPool(updatedParams);
-
-            app.moray.putObject(BUCKET.name, params.uuid, newPool.raw(), {
-                etag: oldPool.etag
-            }, function (err2) {
-                if (err2) {
-                    callback(err2);
-                    return;
-                }
-
-                callback(null, newPool);
-            });
+            callback(null, newPool);
         });
     });
 }
@@ -742,15 +745,18 @@ function updateNetworkPool(app, log, params, callback) {
 /**
  * Deletes a network pool
  */
-function deleteNetworkPool(app, log, params, callback) {
-    log.debug(params, 'deleteNetworkPool: entry');
+function deleteNetworkPool(opts, callback) {
+    opts.log.debug(opts.params, 'deleteNetworkPool: entry');
 
-    validate.params(DELETE_SCHEMA, null, params, function (err) {
+    validate.params(DELETE_SCHEMA, null, opts.params, function (err, params) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
-        app.moray.delObject(BUCKET.name, params.uuid, callback);
+        opts.app.moray.delObject(BUCKET.name, params.uuid, {
+            etag: opts.existingPool.etag
+        }, callback);
     });
 }
 
diff --git a/lib/models/network.js b/lib/models/network.js
index 3fda650..0368849 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -1575,7 +1575,7 @@ function createNetwork(opts, callback) {
                 'createNetwork: creating moray record');
 
             app.moray.putObject(BUCKET.name, network.uuid, raw, { etag: null },
-                function (err) {
+                function (err, res) {
                 if (err) {
                     log.error(err, 'Error creating network');
 
@@ -1590,6 +1590,8 @@ function createNetwork(opts, callback) {
                     return cb(err);
                 }
 
+                network.etag = res.etag;
+
                 return cb();
             });
         },
@@ -1809,11 +1811,14 @@ function updateNetwork(opts, callback) {
                 batch = batch.concat(updates);
             }
 
-            app.moray.batch(batch, function (err3) {
+            app.moray.batch(batch, function (err3, res) {
                 if (err3) {
                     return callback(err3);
                 }
                 var toReturn = new Network(batch[0].value);
+                toReturn.etag =
+                    util_common.getEtag(res.etags, BUCKET.name, toReturn.uuid);
+
                 return callback(null, toReturn);
             });
         });
@@ -2050,6 +2055,9 @@ function getNetwork(opts, callback) {
  * Deletes a network
  */
 function deleteNetwork(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.existingNet, 'opts.existingNet');
+
     var app = opts.app;
     var log = opts.log;
     var params = opts.params;
@@ -2057,13 +2065,6 @@ function deleteNetwork(opts, callback) {
     log.debug(params, 'deleteNetwork: entry');
 
     vasync.pipeline({ funcs: [
-        function checkNet(_, cb) {
-            /*
-             * We use getNetwork() to do parameter validation for us,
-             * including the ownership checks.
-             */
-            getNetwork(opts, cb);
-        },
         function checkNetNICs(_, cb) {
             mod_nic_list({
                 app: app,
@@ -2087,7 +2088,9 @@ function deleteNetwork(opts, callback) {
             });
         },
         function deleteNet(_, cb) {
-            mod_moray.delObj(app.moray, BUCKET, params.uuid, cb);
+            app.moray.delObject(BUCKET.name, params.uuid, {
+                etag: opts.existingNet.etag
+            }, cb);
         },
         function deleteNetBucket(_, cb) {
             var bucketName = mod_ip.bucketName(params.uuid);
diff --git a/lib/models/nic-tag.js b/lib/models/nic-tag.js
index 89b2ffc..cc69653 100644
--- a/lib/models/nic-tag.js
+++ b/lib/models/nic-tag.js
@@ -298,6 +298,14 @@ Object.defineProperty(NicTag.prototype, 'name', {
 });
 
 
+/**
+ * Returns the key for storing this NicTag object.
+ */
+NicTag.prototype.key = function nicTagKey() {
+    return this.name;
+};
+
+
 /**
  * Returns an object suitable for passing to a moray batch
  */
@@ -379,8 +387,7 @@ function createNicTag(app, log, params, callback) {
         }
 
         var tag = new NicTag(params);
-        app.moray.putObject(BUCKET.name, tag.name, tag.raw(), { etag: null },
-            function (err2) {
+        mod_moray.putObj(app.moray, BUCKET, tag, function (err2) {
             if (err2) {
                 callback(err2);
                 return;
diff --git a/lib/models/nic/common.js b/lib/models/nic/common.js
index 2bb9dd0..9a2185e 100644
--- a/lib/models/nic/common.js
+++ b/lib/models/nic/common.js
@@ -23,6 +23,7 @@ var mod_nicTag = require('../nic-tag');
 var mod_pool = require('../network-pool');
 var mod_portolan_moray = require('portolan-moray');
 var util = require('util');
+var util_common = require('../../util/common.js');
 var util_intersect = require('../../util/intersect');
 var validate = require('../../util/validate');
 
@@ -485,12 +486,20 @@ function commitBatch(opts, callback) {
 
     opts.log.info({ batch: opts.batch }, 'commitBatch: enter');
 
-    opts.app.moray.batch(opts.batch, function (err) {
+    opts.app.moray.batch(opts.batch, function (err, res) {
         if (err) {
             opts.log.error(err, 'commitBatch error');
+            callback(err);
+            return;
         }
 
-        return callback(err);
+        if (opts.nic) {
+            opts.nic.etag =
+                util_common.getEtag(res.etags,
+                    BUCKET.name, opts.nic.mac.toLong().toString());
+        }
+
+        callback();
     });
 }
 
diff --git a/lib/models/nic/del.js b/lib/models/nic/del.js
index 2927814..45cb8dc 100644
--- a/lib/models/nic/del.js
+++ b/lib/models/nic/del.js
@@ -16,7 +16,6 @@
 
 var assert = require('assert-plus');
 var common = require('./common');
-var getNic = require('./get').get;
 var restify = require('restify');
 var validate = require('../../util/validate');
 var vasync = require('vasync');
@@ -38,13 +37,6 @@ function validateDeleteParams(opts, callback) {
     });
 }
 
-function getExistingNic(opts, cb) {
-    getNic(opts, function (err, nic) {
-        opts.existingNic = nic;
-        return cb(err);
-    });
-}
-
 function listVnetCns(opts, cb) {
     if (!opts.existingNic.isFabric()) {
         return cb();
@@ -134,7 +126,6 @@ function del(opts, callback) {
         arg: opts,
         funcs: [
             validateDeleteParams,
-            getExistingNic,
             listVnetCns,
             addNicToBatch,
             delIPs,
diff --git a/lib/models/nic/obj.js b/lib/models/nic/obj.js
index d66aaf0..6755e61 100644
--- a/lib/models/nic/obj.js
+++ b/lib/models/nic/obj.js
@@ -331,7 +331,10 @@ Nic.prototype.delBatch = function nicDelBatch(opts) {
         {
             bucket: BUCKET.name,
             key: this.mac.toLong().toString(),
-            operation: 'delete'
+            operation: 'delete',
+            options: {
+                etag: this.etag
+            }
         }
     ];
 
diff --git a/lib/models/nic/update.js b/lib/models/nic/update.js
index c94b7e7..1774634 100644
--- a/lib/models/nic/update.js
+++ b/lib/models/nic/update.js
@@ -18,7 +18,6 @@ var assert = require('assert-plus');
 var common = require('./common');
 var constants = require('../../util/constants');
 var errors = require('../../util/errors');
-var getNic = require('./get').get;
 var mod_ip = require('../ip');
 var mod_net = require('../network');
 var mod_nicTag = require('../nic-tag');
@@ -163,18 +162,6 @@ function getUpdatedNicParams(opts) {
 
 // --- Internal functions in the update chain
 
-/**
- * Get the existing nic from moray
- */
-function getExistingNic(opts, callback) {
-    opts.log.trace('getExistingNic: entry');
-
-    getNic(opts, function (err, res) {
-        opts.existingNic = res;
-        return callback(err);
-    });
-}
-
 
 /**
  * Validate update params
@@ -288,7 +275,6 @@ function update(opts, callback) {
     vasync.pipeline({
         arg: opts,
         funcs: [
-            getExistingNic,
             validateUpdateParams,
             prepareUpdate,
             provision.nicAndIP
diff --git a/lib/models/vlan.js b/lib/models/vlan.js
index 810864e..603a481 100644
--- a/lib/models/vlan.js
+++ b/lib/models/vlan.js
@@ -20,6 +20,7 @@ var fmt = require('util').format;
 var mod_fabric = require('./fabric');
 var mod_moray = require('../apis/moray');
 var mod_net = require('./network');
+var util_common = require('../util/common.js');
 var validate = require('../util/validate');
 var VError = require('verror');
 
@@ -238,7 +239,7 @@ function createFabricVLAN(opts, callback) {
 
         batch.push(vlan.batch());
 
-        app.moray.batch(batch, function (bErr) {
+        app.moray.batch(batch, function (bErr, res) {
             if (bErr) {
                 // XXX: distinguish between which of these conflicted, and
                 // retry if it was the fabric
@@ -255,6 +256,9 @@ function createFabricVLAN(opts, callback) {
                 return;
             }
 
+            vlan.etag =
+                util_common.getEtag(res.etags, BUCKET.name, vlan.id);
+
             callback(null, vlan);
         });
     });
@@ -346,20 +350,24 @@ function getFabricVLAN(opts, callback) {
 
     validate.params(validators, null, opts.params, function (err, validated) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var key = morayVlanKey(validated);
         mod_moray.getObj(app.moray, BUCKET, key, function (err2, res) {
             if (err2) {
-                return callback(err2);
+                callback(err2);
+                return;
             }
 
             if (validated.fields) {
                 res.value.fields = validated.fields;
             }
 
-            return callback(null, new FabricVLAN(res.value));
+            res.value.etag = res._etag;
+
+            callback(null, new FabricVLAN(res.value));
         });
     });
 }
@@ -457,6 +465,8 @@ function updateFabricVLAN(opts, callback) {
         mod_moray.updateObj({
             bucket: BUCKET,
             key: morayVlanKey(validated),
+            original: opts.existingVlan.raw(),
+            etag: opts.existingVlan.etag,
             moray: app.moray,
             val: updateParams
         }, function (uErr, res) {
diff --git a/lib/util/common.js b/lib/util/common.js
index bd45f2a..2ab22e5 100644
--- a/lib/util/common.js
+++ b/lib/util/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -15,6 +15,7 @@
 'use strict';
 
 var errors = require('./errors');
+var mod_jsprim = require('jsprim');
 
 
 
@@ -59,8 +60,12 @@ function repeat(repeatCb, afterCb) {
  * Extracts necessary params from a restify request object for passing to
  * model functions
  */
-function reqToOpts(req) {
-    return { app: req.app, log: req.log, params: req.params };
+function reqToOpts(req, extra) {
+    return mod_jsprim.mergeObjects({
+        app: req.app,
+        log: req.log,
+        params: req.params
+    }, extra);
 }
 
 
@@ -94,9 +99,20 @@ function translateParams(from, map, to) {
 }
 
 
+function getEtag(etags, bucket, key) {
+    for (var i = 0; i < etags.length; ++i) {
+        if (etags[i].bucket === bucket && etags[i].key === key) {
+            return etags[i].etag;
+        }
+    }
+
+    return null;
+}
+
 
 module.exports = {
     arrayify: arrayify,
+    getEtag: getEtag,
     repeat: repeat,
     requireParams: requireParams,
     reqToOpts: reqToOpts,
diff --git a/test/lib/aggr.js b/test/lib/aggr.js
index 0a51279..55e5a21 100644
--- a/test/lib/aggr.js
+++ b/test/lib/aggr.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -20,9 +20,10 @@ var log = require('./log');
 var mod_client = require('./client');
 var util = require('util');
 
-var doneRes = common.doneRes;
-var doneErr = common.doneErr;
 
+// --- Globals
+
+var TYPE = 'aggr';
 
 
 // --- Exports
@@ -44,10 +45,10 @@ function create(t, opts, callback) {
     assert.object(opts.params, 'opts.params');
 
     log.debug({ params: opts.params }, 'creating aggr');
-    opts.type = 'aggr';
+    opts.type = TYPE;
     opts.reqType = 'create';
 
-    client.createAggr(opts.params,
+    client.createAggr(opts.params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -56,34 +57,19 @@ function create(t, opts, callback) {
  * Delete an aggregation
  */
 function del(t, opts, callback) {
-    var client = opts.client || mod_client.get();
-    var desc = opts.desc ? (' ' + opts.desc) : '';
-
     assert.object(t, 't');
+    assert.object(opts, 'opts');
     assert.string(opts.id, 'opts.id');
 
-    log.debug({ aggrId: opts.id }, 'delete aggr');
-
-    client.deleteAggr(opts.id, function (err, obj, _, res) {
-        if (opts.expErr) {
-            t.ok(err, 'expected error');
-            if (err) {
-                var code = opts.expCode || 422;
-                t.equal(err.statusCode, code, 'status code');
-                t.deepEqual(err.body, opts.expErr, 'error body');
-            }
-
-            return doneErr(err, t, callback);
-        }
-
-        if (common.ifErr(t, err, 'delete aggr: ' + opts.id + desc)) {
-            return doneErr(err, t, callback);
-        }
+    var client = opts.client || mod_client.get();
+    var params = opts.params || {};
 
-        t.equal(res.statusCode, 204, 'delete status code: ' + opts.id);
+    log.debug({ aggrId: opts.id }, 'delete aggr');
+    opts.id = opts.id;
+    opts.type = TYPE;
 
-        return doneRes(obj, t, callback);
-    });
+    client.deleteAggr(opts.id, params, common.reqOpts(t, opts),
+        common.afterAPIdelete.bind(null, t, opts, callback));
 }
 
 
@@ -104,9 +90,9 @@ function get(t, opts, callback) {
     log.debug({ aggrId: opts.id }, 'get aggr');
 
     opts.reqType = 'get';
-    opts.type = 'aggr';
+    opts.type = TYPE;
 
-    client.getAggr(opts.id,
+    client.getAggr(opts.id, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -131,9 +117,9 @@ function list(t, opts, callback) {
     log.debug({ params: params }, 'list aggrs');
 
     opts.reqType = 'list';
-    opts.type = 'aggr';
+    opts.type = TYPE;
 
-    client.listAggrs(params,
+    client.listAggrs(params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -156,9 +142,9 @@ function update(t, opts, callback) {
     log.debug({ aggrId: opts.id, params: opts.params }, 'updating aggr');
 
     opts.reqType = 'update';
-    opts.type = 'aggr';
+    opts.type = TYPE;
 
-    client.updateAggr(opts.id, opts.params,
+    client.updateAggr(opts.id, opts.params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
diff --git a/test/lib/common.js b/test/lib/common.js
index 88d7b18..7f057d1 100644
--- a/test/lib/common.js
+++ b/test/lib/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -308,11 +308,22 @@ function addToState(opts, type, obj) {
     opts.state[type].push(newObj);
 }
 
+function requestHeaders(opts) {
+    var headers = opts.headers || {};
+
+    headers['x-request-id'] = mod_uuid.v4();
+
+    if (opts.etag) {
+        headers['If-Match'] = opts.etag;
+    }
+
+    return headers;
+}
 
 /**
  * Shared test code for after API methods are called
  */
-function afterAPIcall(t, opts, callback, err, obj, _, res) {
+function afterAPIcall(t, opts, callback, err, obj, req, res) {
     var desc = opts.desc ? (' ' + opts.desc) : '';
     assert.string(opts.reqType, 'opts.reqType');
     assert.string(opts.type, 'opts.type');
@@ -330,11 +341,13 @@ function afterAPIcall(t, opts, callback, err, obj, _, res) {
             t.deepEqual(obj, {}, 'body (error expected)' + desc);
         }
 
-        return done(err, null, opts, t, callback);
+        done(err, null, req, res, opts, t, callback);
+        return;
     }
 
     if (ifErr(t, err, type + desc)) {
-        return done(err, null, opts, t, callback);
+        done(err, null, req, res, opts, t, callback);
+        return;
     }
 
     t.equal(res.statusCode, 200, 'status code' + desc);
@@ -400,7 +413,7 @@ function afterAPIcall(t, opts, callback, err, obj, _, res) {
         addToState(opts, opts.type + 's', obj);
     }
 
-    return done(null, obj, opts, t, callback);
+    done(null, obj, req, res, opts, t, callback);
 }
 
 
@@ -421,29 +434,32 @@ function afterAPIdelete(t, opts, callback, err, obj, req, res) {
             t.deepEqual(err.body, opts.expErr, 'error body');
         }
 
-        return done(err, null, opts, t, callback);
+        done(err, null, req, res, opts, t, callback);
+        return;
     }
 
     // mightNotExist allows for calling mod_whatever.dellAllCreated() when
     // some of the created objects were actually deleted during the test:
     if (opts.mightNotExist && err && err.restCode === 'ResourceNotFound') {
-        return done(null, obj, opts, t, callback);
+        done(null, obj, req, res, opts, t, callback);
+        return;
     }
 
     if (ifErr(t, err, type + desc)) {
-        return done(err, null, opts, t, callback);
+        done(err, null, req, res, opts, t, callback);
+        return;
     }
 
     t.equal(res.statusCode, 204, type + 'status code' + desc);
 
-    return done(null, obj, opts, t, callback);
+    done(null, obj, req, res, opts, t, callback);
 }
 
 
 /**
  * Shared test code for after API list methods are called
  */
-function afterAPIlist(t, opts, callback, err, obj, _, res) {
+function afterAPIlist(t, opts, callback, err, obj, req, res) {
     assert.string(opts.type, 'opts.type');
     assert.string(opts.id, 'opts.id');
     assert.optionalArray(opts.present, 'opts.present');
@@ -460,11 +476,13 @@ function afterAPIlist(t, opts, callback, err, obj, _, res) {
             t.deepEqual(err.body, opts.expErr, type + 'error body' + desc);
         }
 
-        return done(err, null, opts, t, callback);
+        done(err, null, req, res, opts, t, callback);
+        return;
     }
 
     if (ifErr(t, err, type + desc)) {
-        return done(err, null, opts, t, callback);
+        done(err, null, req, res, opts, t, callback);
+        return;
     }
 
     t.equal(res.statusCode, 200, 'status code' + desc);
@@ -542,7 +560,7 @@ function afterAPIlist(t, opts, callback, err, obj, _, res) {
         }
     }
 
-    return done(null, obj, opts, t, callback);
+    done(null, obj, req, res, opts, t, callback);
 }
 
 
@@ -575,6 +593,7 @@ function assertArgs(t, opts, callback) {
     assert.optionalObject(opts.partialExp, 'opts.partialExp');
     assert.ok(opts.exp || opts.partialExp || opts.expErr,
         'one of exp, expErr, partialExp required');
+    assert.optionalString(opts.etag, 'opts.etag');
     assert.optionalObject(opts.params, 'opts.params');
     assert.optionalObject(opts.state, 'opts.state');
     assert.optionalFunc(callback, 'callback');
@@ -621,12 +640,13 @@ function createClient(url, t) {
 /**
  * Finish a test
  */
-function done(err, res, opts, t, callback) {
+function done(err, obj, req, res, opts, t, callback) {
     if (callback) {
-        return callback(opts.continueOnErr ? null : err, res);
+        callback(opts.continueOnErr ? null : err, obj, req, res);
+        return;
     }
 
-    return t.end();
+    t.end();
 }
 
 
@@ -742,11 +762,27 @@ function randomMAC() {
 /**
  * Generate request opts
  */
-function requestOpts(t, desc) {
-    var reqId = mod_uuid.v4();
-    t.ok(reqId, fmt('req ID: %s%s', reqId, (desc ? ': ' + desc : '')));
+function requestOpts(t, opts) {
+    assert.object(t, 't');
+
+    var desc;
+    if (typeof (opts) === 'undefined') {
+        desc = '';
+        opts = {};
+    } else if (typeof (opts) === 'string') {
+        desc = ': ' + opts;
+        opts = {};
+    } else {
+        assert.object(opts, 'opts');
+        desc = opts.desc ? ': ' + opts.desc : '';
+    }
+
+    var headers = requestHeaders(opts);
+    var reqId = headers['x-request-id'];
+
+    t.ok(reqId, fmt('req ID: %s%s', reqId, desc));
 
-    return { headers: { 'x-request-id': reqId } };
+    return { headers: headers };
 }
 
 
@@ -779,6 +815,7 @@ module.exports = {
     lastCreated: lastCreated,
     missingParamErr: missingParamErr,
     randomMAC: randomMAC,
+    reqHeaders: requestHeaders,
     reqOpts: requestOpts,
     uuidSort: uuidSort
 };
diff --git a/test/lib/fabric-net.js b/test/lib/fabric-net.js
index 3c609d3..fc969a9 100644
--- a/test/lib/fabric-net.js
+++ b/test/lib/fabric-net.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -62,7 +62,6 @@ function createFabricNet(t, opts, callback) {
     common.assertArgs(t, opts, callback);
 
     var client = opts.client || mod_client.get();
-    var desc = opts.desc || '';
     var params = clone(opts.params);
     var owner = params.owner_uuid;
     var vlan = params.vlan_id;
@@ -103,7 +102,7 @@ function createFabricNet(t, opts, callback) {
         }
     }
 
-    client.createFabricNetwork(owner, vlan, params, common.reqOpts(t, desc),
+    client.createFabricNetwork(owner, vlan, params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -220,7 +219,7 @@ function getFabricNet(t, opts, callback) {
     delete params.uuid;
     delete params.vlan_id;
 
-    client.getFabricNetwork(owner, vlan, net, params, common.reqOpts(t),
+    client.getFabricNetwork(owner, vlan, net, params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
diff --git a/test/lib/ip.js b/test/lib/ip.js
index b635ff4..c37f733 100644
--- a/test/lib/ip.js
+++ b/test/lib/ip.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -51,6 +51,7 @@ function freeIPrecord(net, ip) {
  */
 function getIP(t, opts, callback) {
     var client = opts.client || mod_client.get();
+    var params = opts.params || {};
 
     common.assertArgs(t, opts, callback);
     assert.string(opts.net, 'opts.net');
@@ -59,7 +60,7 @@ function getIP(t, opts, callback) {
     opts.type = TYPE;
     opts.reqType = 'get';
 
-    client.getIP(opts.net, opts.ip, opts.params || {},
+    client.getIP(opts.net, opts.ip, params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -88,7 +89,7 @@ function listIPs(t, opts, callback) {
 
     log.debug({ params: params, net: opts.net }, 'list IPs');
 
-    client.listIPs(opts.net, params, common.reqOpts(t, opts.desc),
+    client.listIPs(opts.net, params, common.reqOpts(t, opts),
         common.afterAPIlist.bind(null, t, opts, callback));
 }
 
@@ -121,7 +122,7 @@ function updateIP(t, opts, callback) {
     opts.type = TYPE;
     opts.reqType = 'update';
 
-    client.updateIP(opts.net, opts.ip, opts.params,
+    client.updateIP(opts.net, opts.ip, opts.params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
diff --git a/test/lib/net.js b/test/lib/net.js
index 5307155..d9f093e 100644
--- a/test/lib/net.js
+++ b/test/lib/net.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -90,7 +90,7 @@ function createNet(t, opts, callback) {
         }
     }
 
-    client.createNetwork(params, common.reqOpts(t, opts.desc),
+    client.createNetwork(params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -101,17 +101,20 @@ function createNet(t, opts, callback) {
  */
 function createAndGet(t, opts, callback) {
     opts.reqType = 'create';
-    createNet(t, opts, function (err, res) {
+    createNet(t, opts, function (err, net, _, res) {
         if (err) {
-            return doneErr(err, t, callback);
+            doneErr(err, t, callback);
+            return;
         }
 
         if (!opts.params.uuid) {
-            opts.params.uuid = res.uuid;
+            opts.params.uuid = net.uuid;
         }
 
-        opts.params.uuid = res.uuid;
-        return getNet(t, opts, callback);
+        opts.params.uuid = net.uuid;
+        opts.etag = res.headers['etag'];
+
+        getNet(t, opts, callback);
     });
 }
 
@@ -130,7 +133,7 @@ function delNet(t, opts, callback) {
     opts.type = TYPE;
     opts.id = opts.uuid;
 
-    client.deleteNetwork(opts.uuid, params,
+    client.deleteNetwork(opts.uuid, params, common.reqOpts(t, opts),
         common.afterAPIdelete.bind(null, t, opts, callback));
 }
 
@@ -172,9 +175,13 @@ function delAllCreatedNets(t) {
  */
 function getNet(t, opts, callback) {
     common.assertArgs(t, opts, callback);
+    assert.object(opts.params, 'opts.params');
 
     var client = opts.client || mod_client.get();
-    var params = opts.params || {};
+    var params = {
+        params: opts.params.params || {},
+        headers: common.reqHeaders(opts)
+    };
 
     opts.reqType = 'get';
     opts.type = TYPE;
@@ -215,7 +222,7 @@ function listNets(t, opts, callback) {
 
     log.debug({ params: params }, 'list networks');
 
-    client.listNetworks(params, common.reqOpts(t, opts.desc),
+    client.listNetworks(params, common.reqOpts(t, opts),
         common.afterAPIlist.bind(null, t, opts, callback));
 }
 
@@ -239,7 +246,7 @@ function updateNet(t, opts, callback) {
     opts.type = TYPE;
     opts.reqType = 'update';
 
-    client.updateNetwork(opts.params.uuid, opts.params,
+    client.updateNetwork(opts.params.uuid, opts.params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -249,12 +256,15 @@ function updateNet(t, opts, callback) {
  * that network.
  */
 function updateAndGet(t, opts, callback) {
-    updateNet(t, opts, function (err, res) {
+    updateNet(t, opts, function (err, _, req, res) {
         if (err) {
-            return doneErr(err, t, callback);
+            doneErr(err, t, callback);
+            return;
         }
 
-        return getNet(t, opts, callback);
+        opts.etag = res.headers['etag'];
+
+        getNet(t, opts, callback);
     });
 }
 
diff --git a/test/lib/nic-tag.js b/test/lib/nic-tag.js
index 49f9955..895ed6c 100644
--- a/test/lib/nic-tag.js
+++ b/test/lib/nic-tag.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -196,7 +196,7 @@ function listTags(t, opts, callback) {
 
     log.debug({ params: params }, 'list nic tags');
 
-    client.listNicTags(params, common.reqOpts(t, opts.desc),
+    client.listNicTags(params, common.reqOpts(t, opts),
         common.afterAPIlist.bind(null, t, opts, callback));
 }
 
@@ -214,7 +214,7 @@ function updateTag(t, opts, callback) {
     opts.type = TYPE;
     opts.reqType = 'update';
 
-    client.updateNicTag(name, opts.params, common.reqOpts(t, opts.desc),
+    client.updateNicTag(name, opts.params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
diff --git a/test/lib/nic.js b/test/lib/nic.js
index 23805eb..20b4b4d 100644
--- a/test/lib/nic.js
+++ b/test/lib/nic.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -86,7 +86,7 @@ function createNic(t, opts, callback) {
     opts.reqType = 'create';
 
 
-    client.createNic(mac, clone(opts.params),
+    client.createNic(mac, clone(opts.params), common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -96,12 +96,15 @@ function createNic(t, opts, callback) {
  * that nic.
  */
 function createAndGetNic(t, opts, callback) {
-    createNic(t, opts, function (err, res) {
+    createNic(t, opts, function (err, _, req, res) {
         if (err) {
-            return doneErr(err, t, callback);
+            doneErr(err, t, callback);
+            return;
         }
 
-        return getNic(t, opts, callback);
+        opts.etag = res.headers['etag'];
+
+        getNic(t, opts, callback);
     });
 }
 
@@ -201,7 +204,7 @@ function delNic(t, opts, callback) {
     opts.id = opts.mac;
     opts.type = TYPE;
 
-    client.deleteNic(opts.mac, params, common.reqOpts(t),
+    client.deleteNic(opts.mac, params, common.reqOpts(t, opts),
         common.afterAPIdelete.bind(null, t, opts, callback));
 }
 
@@ -210,6 +213,8 @@ function delNic(t, opts, callback) {
  * Get a nic and compare the output
  */
 function getNic(t, opts, callback) {
+    common.assertArgs(t, opts, callback);
+
     var client = opts.client || mod_client.get();
 
     assert.object(t, 't');
@@ -222,7 +227,8 @@ function getNic(t, opts, callback) {
 
     opts.type = TYPE;
     opts.reqType = 'get';
-    client.getNic(opts.mac, common.afterAPIcall.bind(null, t, opts, callback));
+    client.getNic(opts.mac, common.reqOpts(t, opts),
+        common.afterAPIcall.bind(null, t, opts, callback));
 }
 
 
@@ -254,7 +260,7 @@ function listNics(t, opts, callback) {
 
     log.debug({ params: params }, 'list networks');
 
-    client.listNics(params, common.reqOpts(t, opts.desc),
+    client.listNics(params, common.reqOpts(t, opts),
         common.afterAPIlist.bind(null, t, opts, callback));
 }
 
@@ -276,7 +282,7 @@ function provisionNic(t, opts, callback) {
         opts.fillIn = [ 'ip', 'mac', 'primary', 'state' ];
     }
 
-    client.provisionNic(opts.net, opts.params, common.reqOpts(t),
+    client.provisionNic(opts.net, opts.params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -292,7 +298,7 @@ function updateNic(t, opts, callback) {
     opts.type = TYPE;
     opts.reqType = 'update';
 
-    client.updateNic(opts.mac, opts.params, common.reqOpts(t),
+    client.updateNic(opts.mac, opts.params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
diff --git a/test/lib/pool.js b/test/lib/pool.js
index 3f6b91f..8d57a0d 100644
--- a/test/lib/pool.js
+++ b/test/lib/pool.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -19,6 +19,7 @@ var clone = require('clone');
 var common = require('./common');
 var log = require('./log');
 var mod_client = require('./client');
+var mod_jsprim = require('jsprim');
 var util = require('util');
 
 var doneRes = common.doneRes;
@@ -64,7 +65,7 @@ function create(t, opts, callback) {
         opts.exp.name = name;
     }
 
-    client.createNetworkPool(name, clone(opts.params),
+    client.createNetworkPool(name, clone(opts.params), common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -75,19 +76,22 @@ function create(t, opts, callback) {
  */
 function createAndGet(t, opts, callback) {
     opts.reqType = 'create';
-    create(t, opts, function (err, res) {
+    create(t, opts, function (err, pool, _, res) {
         if (err) {
-            return doneErr(err, t, callback);
+            doneErr(err, t, callback);
+            return;
         }
 
-        opts.uuid = res.uuid;
+        opts.uuid = pool.uuid;
         if (opts.exp && !opts.params.uuid) {
             // We were assigned a UUID by NAPI, so add that to the
             // expected params
-            opts.exp.uuid = res.uuid;
+            opts.exp.uuid = pool.uuid;
         }
 
-        return get(t, opts, callback);
+        opts.etag = res.headers['etag'];
+
+        get(t, opts, callback);
     });
 }
 
@@ -106,7 +110,7 @@ function del(t, opts, callback) {
     opts.id = opts.uuid;
     var params = opts.params || {};
 
-    client.deleteNetworkPool(opts.uuid, params,
+    client.deleteNetworkPool(opts.uuid, params, common.reqOpts(t, opts),
         common.afterAPIdelete.bind(null, t, opts, callback));
 }
 
@@ -169,6 +173,9 @@ function get(t, opts, callback) {
         params.params = opts.params;
     }
 
+    params.headers =
+        mod_jsprim.mergeObjects(common.reqHeaders(opts), params.headers);
+
     client.getNetworkPool(opts.uuid, params,
         common.afterAPIcall.bind(null, t, opts, callback));
 }
@@ -224,7 +231,7 @@ function update(t, opts, callback) {
 
     opts.type = 'pool';
     opts.reqType = 'update';
-    client.updateNetworkPool(opts.uuid, opts.params,
+    client.updateNetworkPool(opts.uuid, opts.params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -234,12 +241,15 @@ function update(t, opts, callback) {
  * that nic.
  */
 function updateAndGet(t, opts, callback) {
-    update(t, opts, function (err, res) {
+    update(t, opts, function (err, _, req, res) {
         if (err) {
-            return doneErr(err, t, callback);
+            doneErr(err, t, callback);
+            return;
         }
 
-        return get(t, opts, callback);
+        opts.etag = res.headers['etag'];
+
+        get(t, opts, callback);
     });
 }
 
diff --git a/test/lib/vlan.js b/test/lib/vlan.js
index 986a6b7..816d6af 100644
--- a/test/lib/vlan.js
+++ b/test/lib/vlan.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -58,7 +58,7 @@ function createVLAN(t, opts, callback) {
         opts.desc = JSON.stringify(opts.params);
     }
 
-    client.createFabricVLAN(owner, params, common.reqOpts(t, opts.desc),
+    client.createFabricVLAN(owner, params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -99,7 +99,7 @@ function delVLAN(t, opts, callback) {
     log.debug({ opts: opts, owner: owner, vlan: vlan, params: params },
         'deleting VLAN');
 
-    client.deleteFabricVLAN(owner, vlan, params,
+    client.deleteFabricVLAN(owner, vlan, params, common.reqOpts(t, opts),
         common.afterAPIdelete.bind(null, t, opts, callback));
 }
 
@@ -152,7 +152,7 @@ function getVLAN(t, opts, callback) {
     delete params.owner_uuid;
     delete params.vlan_id;
 
-    client.getFabricVLAN(owner, vlan, params,
+    client.getFabricVLAN(owner, vlan, params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
@@ -183,7 +183,7 @@ function listVLANs(t, opts, callback) {
 
     log.debug({ params: params }, 'list vlans');
 
-    client.listFabricVLANs(owner, params,
+    client.listFabricVLANs(owner, params, common.reqOpts(t, opts),
         common.afterAPIlist.bind(null, t, opts, callback));
 }
 
@@ -211,7 +211,7 @@ function updateVLAN(t, opts, callback) {
 
     opts.type = TYPE;
     opts.reqType = 'update';
-    client.updateFabricVLAN(owner, vlan, params,
+    client.updateFabricVLAN(owner, vlan, params, common.reqOpts(t, opts),
         common.afterAPIcall.bind(null, t, opts, callback));
 }
 
diff --git a/test/unit/etags.test.js b/test/unit/etags.test.js
new file mode 100644
index 0000000..d0e8304
--- /dev/null
+++ b/test/unit/etags.test.js
@@ -0,0 +1,839 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Unit tests for "etag" headers.
+ *
+ * We test manipulating the different kinds of NAPI objects and making sure that
+ * they all return the latest "etag" header, and honor "If-Match" headers.
+ *
+ * For each NAPI object, we do the following operations:
+ *
+ *   - Create the object, and ensure the returned etag matches a successive GET
+ *   - Get the object with a bad etag, which should produce a 412
+ *   - Update the object with a bad etag, which should produce a 412
+ *   - Verify that the object is unchanged, and the etag is the same
+ *   - Update with the correct, current etag, which should return a new etag
+ *   - Verify that the object is changed, and the etag matches the update result
+ *   - Delete with a bad etag, which should produce a 412
+ *   - Verify that the object is unchanged, and the etag is the same
+ *   - Delete with the correct, current etag
+ *   - Verify that the object is gone
+ */
+
+'use strict';
+
+var fmt = require('util').format;
+var h = require('./helpers');
+var mod_aggr = require('../lib/aggr');
+var mod_ip = require('../lib/ip');
+var mod_jsprim = require('jsprim');
+var mod_net = require('../lib/net');
+var mod_nic = require('../lib/nic');
+var mod_nicTag = require('../lib/nic-tag');
+var mod_pool = require('../lib/pool');
+var mod_server = require('../lib/server');
+var mod_uuid = require('node-uuid');
+var mod_vlan = require('../lib/vlan');
+var test = require('tape');
+
+
+// --- Globals
+
+var INCORRECT = 'not the correct etag';
+var OWNER = mod_uuid.v4();
+var MORAY;
+var NAPI;
+
+var AGGR;
+var AGGR_ETAG;
+
+var IP;
+var IP_ETAG;
+
+var NET;
+var NET_ETAG;
+var NET_NUM;
+var NET_PARAMS;
+
+var NIC;
+var NIC_ETAG;
+
+var POOL;
+var POOL_ETAG;
+
+var VLAN;
+var VLAN_ETAG;
+
+// --- Internal helpers
+
+function verifyEtag(t, etag, type) {
+    t.equal(typeof (etag), 'string',
+        fmt('received %s etag "%s"', type, etag));
+    t.notEqual(etag, 'null',
+        fmt('%s etag is not the string "null"', type));
+}
+
+function verifyUpdate(t, etag1, etag2, type) {
+    t.notEqual(etag1, etag2,
+        fmt('%s etag should change after update', type));
+}
+
+function precondError(etag) {
+    return {
+        code: 'PreconditionFailed',
+        message: fmt('if-match \'%s\' didn\'t match etag \'%s\'',
+            INCORRECT, etag)
+    };
+}
+
+function checkEtag(t, etag) {
+    return function (err, _, req, res) {
+        if (h.ifErr(t, err, 'getNetwork() error')) {
+            t.end();
+            return;
+        }
+
+        t.deepEqual(res.headers['etag'], etag,
+            'etags should match');
+        t.end();
+    };
+}
+
+function checkIP(t) {
+    mod_ip.get(t, {
+        net: NET.uuid,
+        ip: IP.ip,
+        exp: IP
+    }, checkEtag(t, IP_ETAG));
+}
+
+
+function checkNetwork(t) {
+    mod_net.get(t, {
+        params: {
+            uuid: NET.uuid
+        },
+        exp: NET
+    }, checkEtag(t, NET_ETAG));
+}
+
+
+function checkPool(t) {
+    mod_pool.get(t, {
+        uuid: POOL.uuid,
+        exp: POOL
+    }, checkEtag(t, POOL_ETAG));
+}
+
+
+function checkNic(t) {
+    mod_nic.get(t, {
+        mac: NIC.mac,
+        ignore: [ 'modified_timestamp' ],
+        exp: NIC
+    }, checkEtag(t, NIC_ETAG));
+}
+
+
+function checkAggr(t) {
+    mod_aggr.get(t, {
+        id: AGGR.id,
+        exp: AGGR
+    }, checkEtag(t, AGGR_ETAG));
+}
+
+
+function checkVLAN(t) {
+    mod_vlan.get(t, {
+        params: {
+            vlan_id: VLAN.vlan_id,
+            owner_uuid: OWNER
+        },
+        exp: VLAN
+    }, checkEtag(t, VLAN_ETAG));
+}
+
+
+// --- Setup
+
+test('Initial setup', function (t) {
+    h.reset();
+
+    NET_NUM = h.NET_NUM;
+    NET_PARAMS = h.validNetworkParams();
+
+    t.test('create client and server', function (t2) {
+        h.createClientAndServer(function (err, res, moray) {
+            NAPI = res;
+            MORAY = moray;
+
+            t2.ifError(err, 'server creation');
+            t2.ok(NAPI, 'have NAPI client object');
+            t2.ok(MORAY, 'have MORAY client object');
+            t2.end();
+        });
+    });
+
+    t.test('create nic tag', function (t2) {
+        mod_nicTag.create(t2, {
+            name: NET_PARAMS.nic_tag
+        });
+    });
+});
+
+
+// --- Create and update tests
+
+test('Verify basic network routes', function (t) {
+    t.test('Create network', function (t2) {
+        mod_net.create(t2, {
+            params: NET_PARAMS,
+            partialExp: NET_PARAMS
+        }, function (err, net, _, res) {
+            if (h.ifErr(t2, err, 'createNetwork() error')) {
+                t2.end();
+                return;
+            }
+
+            NET = net;
+            NET_ETAG = res.headers['etag'];
+
+            verifyEtag(t2, NET_ETAG, 'network');
+            checkNetwork(t2);
+        });
+    });
+
+    t.test('Get network with incorrect etag', function (t2) {
+        mod_net.get(t2, {
+            params: {
+                uuid: NET.uuid
+            },
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(NET_ETAG)
+        });
+    });
+
+    t.test('Update network with incorrect etag', function (t2) {
+        mod_net.update(t2, {
+            params: {
+                uuid: NET.uuid,
+                name: 'not-used-name'
+            },
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(NET_ETAG)
+        });
+    });
+
+    t.test('Verify that network is unchanged', checkNetwork);
+
+    t.test('Update network with correct etag', function (t2) {
+        var newName = 'updated-name';
+
+        NET.name = newName;
+
+        mod_net.update(t2, {
+            params: {
+                uuid: NET.uuid,
+                name: newName
+            },
+            etag: NET_ETAG,
+            exp: NET
+        }, function (err, _, req, res) {
+            if (h.ifErr(t2, err, 'updateNetwork() error')) {
+                t2.end();
+                return;
+            }
+
+            if (!mod_jsprim.hasKey(res.headers, 'etag')) {
+                t2.fail('updateNetwork() response is missing an "etag"');
+                t2.end();
+                return;
+            }
+
+            verifyUpdate(t2, res.headers['etag'], NET_ETAG, 'network');
+
+            NET_ETAG = res.headers['etag'];
+
+            checkNetwork(t2);
+        });
+    });
+});
+
+test('Verify basic IP routes', function (t) {
+    var owner = mod_uuid.v4();
+
+    t.test('Create IP', function (t2) {
+        var params = {
+            belongs_to_type: 'other',
+            belongs_to_uuid: owner,
+            owner_uuid: owner
+        };
+
+        mod_ip.update(t2, {
+            net: NET.uuid,
+            ip: fmt('10.0.%d.50', NET_NUM),
+            params: params,
+            headers: {
+                'If-Match': '""'
+            },
+            partialExp: params
+        }, function (err, ip, _, res) {
+            if (h.ifErr(t2, err, 'updateIP() error')) {
+                t2.end();
+                return;
+            }
+
+            IP = ip;
+            IP_ETAG = res.headers['etag'];
+
+            verifyEtag(t2, IP_ETAG, 'IP');
+            checkIP(t2);
+        });
+    });
+
+    t.test('Get IP with incorrect etag', function (t2) {
+        mod_ip.get(t2, {
+            net: NET.uuid,
+            ip: IP.ip,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(IP_ETAG)
+        });
+    });
+
+    t.test('Update IP with incorrect If-None-Match', function (t2) {
+        mod_ip.update(t2, {
+            net: NET.uuid,
+            ip: IP.ip,
+            params: {
+                reserved: true
+            },
+            headers: {
+                'If-Match': '""'
+            },
+            expCode: 412,
+            expErr: {
+                code: 'PreconditionFailed',
+                message:
+                    fmt('if-match \'""\' didn\'t match etag \'%s\'', IP_ETAG)
+            }
+        });
+    });
+
+    t.test('Update IP with incorrect etag', function (t2) {
+        mod_ip.update(t2, {
+            net: NET.uuid,
+            ip: IP.ip,
+            params: {
+                reserved: true
+            },
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(IP_ETAG)
+        });
+    });
+
+    t.test('Verify that IP is unchanged', checkIP);
+
+    t.test('Update IP with correct etag', function (t2) {
+        IP.reserved = true;
+
+        mod_ip.update(t2, {
+            net: NET.uuid,
+            ip: IP.ip,
+            params: {
+                reserved: true
+            },
+            etag: IP_ETAG,
+            exp: IP
+        }, function (err, _, req, res) {
+            if (h.ifErr(t2, err, 'updateIP() error')) {
+                t2.end();
+                return;
+            }
+
+            if (!mod_jsprim.hasKey(res.headers, 'etag')) {
+                t2.fail('updateIP() response is missing an "etag"');
+                t2.end();
+                return;
+            }
+
+            verifyUpdate(t2, res.headers['etag'], IP_ETAG, 'IP');
+
+            IP_ETAG = res.headers['etag'];
+
+            checkIP(t2);
+        });
+    });
+});
+
+
+test('Verify basic network pool routes', function (t) {
+    t.test('Create network pool', function (t2) {
+        var params = {
+            networks: [ NET.uuid ]
+        };
+
+        mod_pool.create(t2, {
+            name: 'test-pool-name',
+            params: params,
+            partialExp: params
+        }, function (err, pool, _, res) {
+            if (h.ifErr(t2, err, 'createNetworkPool() error')) {
+                t2.end();
+                return;
+            }
+
+            POOL = pool;
+            POOL_ETAG = res.headers['etag'];
+
+            verifyEtag(t2, POOL_ETAG, 'network pool');
+            checkPool(t2);
+        });
+    });
+
+    t.test('Get network pool with incorrect etag', function (t2) {
+        mod_pool.get(t2, {
+            uuid: POOL.uuid,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(POOL_ETAG)
+        });
+    });
+
+    t.test('Update pool with incorrect etag', function (t2) {
+        mod_pool.update(t2, {
+            uuid: POOL.uuid,
+            params: {
+                name: 'not-used-name'
+            },
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(POOL_ETAG)
+        });
+    });
+
+    t.test('Verify that pool is unchanged', checkPool);
+
+    t.test('Update pool with correct etag', function (t2) {
+        var newName = 'test-pool-name-updated';
+
+        POOL.name = newName;
+
+        mod_pool.update(t2, {
+            uuid: POOL.uuid,
+            params: {
+                name: newName
+            },
+            etag: POOL_ETAG,
+            exp: POOL
+        }, function (err, _, req, res) {
+            if (h.ifErr(t2, err, 'updateNetworkPool() error')) {
+                t2.end();
+                return;
+            }
+
+            if (!mod_jsprim.hasKey(res.headers, 'etag')) {
+                t2.fail('updateNetworkPool() response is missing an "etag"');
+                t2.end();
+                return;
+            }
+
+            verifyUpdate(t2, res.headers['etag'], POOL_ETAG, 'network pool');
+
+            POOL_ETAG = res.headers['etag'];
+
+            checkPool(t2);
+        });
+    });
+});
+
+
+test('Verify basic VLAN routes', function (t) {
+    t.test('Create VLAN', function (t2) {
+        var params = {
+            vlan_id: 2,
+            owner_uuid: OWNER
+        };
+
+        mod_vlan.create(t2, {
+            params: params,
+            partialExp: params
+        }, function (err, vlan, _, res) {
+            if (h.ifErr(t2, err, 'createFabricVLAN() error')) {
+                t2.end();
+                return;
+            }
+
+            VLAN = vlan;
+            VLAN_ETAG = res.headers['etag'];
+
+            verifyEtag(t2, VLAN_ETAG, 'fabric VLAN');
+            checkVLAN(t2);
+        });
+    });
+
+    t.test('Get VLAN with incorrect etag', function (t2) {
+        mod_vlan.get(t2, {
+            params: VLAN,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(VLAN_ETAG)
+        });
+    });
+
+    t.test('Update VLAN with incorrect etag', function (t2) {
+        mod_vlan.update(t2, {
+            params: VLAN,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(VLAN_ETAG)
+        });
+    });
+
+    t.test('Verify that VLAN is unchanged', checkVLAN);
+
+    t.test('Update VLAN with correct etag', function (t2) {
+        var newName = 'test-pool-name-updated';
+
+        VLAN.name = newName;
+
+        mod_vlan.update(t2, {
+            params: VLAN,
+            etag: VLAN_ETAG,
+            exp: VLAN
+        }, function (err, _, req, res) {
+            if (h.ifErr(t2, err, 'updateFabricVLAN() error')) {
+                t2.end();
+                return;
+            }
+
+            if (!mod_jsprim.hasKey(res.headers, 'etag')) {
+                t2.fail('updateFabricVLAN() response is missing an "etag"');
+                t2.end();
+                return;
+            }
+
+            verifyUpdate(t2, res.headers['etag'], VLAN_ETAG, 'fabric VLAN');
+
+            VLAN_ETAG = res.headers['etag'];
+
+            checkVLAN(t2);
+        });
+    });
+});
+
+
+test('Verify basic NIC routes', function (t) {
+    var mac = '0a:0b:0c:0d:0e:0f';
+    var belongs_to_uuid = mod_uuid.v4();
+    var owner_uuid = mod_uuid.v4();
+
+    t.test('Provision NIC', function (t2) {
+        var params = {
+            belongs_to_type: 'server',
+            belongs_to_uuid: belongs_to_uuid,
+            owner_uuid: owner_uuid
+        };
+
+        mod_nic.create(t2, {
+            mac: mac,
+            params: params,
+            partialExp: params
+        }, function (err, nic, _, res) {
+            if (h.ifErr(t2, err, 'createNic() error')) {
+                t2.end();
+                return;
+            }
+
+            NIC = nic;
+            NIC_ETAG = res.headers['etag'];
+
+            verifyEtag(t2, NIC_ETAG, 'NIC');
+            checkNic(t2);
+        });
+    });
+
+    t.test('Get NIC with incorrect etag', function (t2) {
+        mod_nic.get(t2, {
+            mac: NIC.mac,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(NIC_ETAG)
+        });
+    });
+
+    t.test('Update NIC with incorrect etag', function (t2) {
+        mod_nic.update(t2, {
+            mac: NIC.mac,
+            params: {
+                allow_ip_spoofing: true
+            },
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(NIC_ETAG)
+        });
+    });
+
+    t.test('Verify that NIC is unchanged', checkNic);
+
+    t.test('Update NIC with correct etag', function (t2) {
+        NIC.allow_ip_spoofing = true;
+
+        mod_nic.update(t2, {
+            mac: NIC.mac,
+            params: {
+                allow_ip_spoofing: true
+            },
+            etag: NIC_ETAG,
+            ignore: [ 'modified_timestamp' ],
+            exp: NIC
+        }, function (err, _, req, res) {
+            if (h.ifErr(t2, err, 'updateNic() error')) {
+                t2.end();
+                return;
+            }
+
+            if (!mod_jsprim.hasKey(res.headers, 'etag')) {
+                t2.fail('updateNic() response is missing an "etag"');
+                t2.end();
+                return;
+            }
+
+            verifyUpdate(t2, res.headers['etag'], NIC_ETAG, 'NIC');
+
+            NIC_ETAG = res.headers['etag'];
+
+            checkNic(t2);
+        });
+    });
+
+});
+
+
+test('Verify aggregation routes', function (t) {
+    t.test('Create aggregation', function (t2) {
+        var params = {
+            macs: [ NIC.mac ],
+            name: 'aggr0',
+            lacp_mode: 'off'
+        };
+
+        mod_aggr.create(t2, {
+            params: params,
+            partialExp: params
+        }, function (err, aggr, _, res) {
+            if (h.ifErr(t2, err, 'createAggr() error')) {
+                t2.end();
+                return;
+            }
+
+            AGGR = aggr;
+            AGGR_ETAG = res.headers['etag'];
+
+            verifyEtag(t2, AGGR_ETAG, 'aggregation');
+            checkAggr(t2);
+        });
+    });
+
+    t.test('Get aggregation with incorrect etag', function (t2) {
+        mod_aggr.get(t2, {
+            id: AGGR.id,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(AGGR_ETAG)
+        });
+    });
+
+    t.test('Update aggregation with incorrect etag', function (t2) {
+        mod_aggr.update(t2, {
+            id: AGGR.id,
+            params: {
+                lacp_mode: 'passive'
+            },
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(AGGR_ETAG)
+        });
+    });
+
+    t.test('Verify that aggregation is unchanged', checkAggr);
+
+    t.test('Update aggregation with correct etag', function (t2) {
+        AGGR.lacp_mode = 'passive';
+
+        mod_aggr.update(t2, {
+            id: AGGR.id,
+            params: {
+                lacp_mode: 'passive'
+            },
+            etag: AGGR_ETAG,
+            exp: AGGR
+        }, function (err, _, req, res) {
+            if (h.ifErr(t2, err, 'updateAggr() error')) {
+                t2.end();
+                return;
+            }
+
+            if (!mod_jsprim.hasKey(res.headers, 'etag')) {
+                t2.fail('updateAggr() response is missing an "etag"');
+                t2.end();
+                return;
+            }
+
+            verifyUpdate(t2, res.headers['etag'], AGGR_ETAG, 'aggregation');
+
+            AGGR_ETAG = res.headers['etag'];
+
+            checkAggr(t2);
+        });
+    });
+});
+
+
+// --- Delete tests
+
+test('Verify aggregation delete routes', function (t) {
+    t.test('Delete aggregation with incorrect etag', function (t2) {
+        mod_aggr.del(t2, {
+            id: AGGR.id,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(AGGR_ETAG)
+        });
+    });
+
+    t.test('Verify that aggregation still exists', checkAggr);
+
+    t.test('Delete aggregation with good etag', function (t2) {
+        mod_aggr.del(t2, {
+            id: AGGR.id,
+            etag: AGGR_ETAG
+        });
+    });
+
+    t.test('Verify that aggregation is gone', function (t2) {
+        mod_aggr.get(t2, {
+            id: AGGR.id,
+            expCode: 404,
+            expErr: {
+                code: 'ResourceNotFound',
+                message: 'aggregation not found'
+            }
+        });
+    });
+});
+
+test('Verify NIC delete routes', function (t) {
+    t.test('Delete NIC with incorrect etag', function (t2) {
+        mod_nic.del(t2, {
+            mac: NIC.mac,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(NIC_ETAG)
+        });
+    });
+
+    t.test('Verify that NIC still exists', checkNic);
+
+    t.test('Delete NIC with good etag', function (t2) {
+        mod_nic.del(t2, {
+            mac: NIC.mac,
+            etag: NIC_ETAG
+        });
+    });
+
+    t.test('Verify that NIC is gone', function (t2) {
+        mod_nic.get(t2, {
+            mac: NIC.mac,
+            expCode: 404,
+            expErr: {
+                code: 'ResourceNotFound',
+                message: 'nic not found'
+            }
+        });
+    });
+});
+
+
+test('Verify network pool delete routes', function (t) {
+    t.test('Delete pool with incorrect etag', function (t2) {
+        mod_pool.del(t2, {
+            uuid: POOL.uuid,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(POOL_ETAG)
+        });
+    });
+
+    t.test('Verify that pool still exists', checkNetwork);
+
+    t.test('Delete pool with good etag', function (t2) {
+        mod_pool.del(t2, {
+            uuid: POOL.uuid,
+            etag: POOL_ETAG
+        });
+    });
+
+    t.test('Verify that pool is gone', function (t2) {
+        mod_pool.get(t2, {
+            uuid: POOL.uuid,
+            expCode: 404,
+            expErr: {
+                code: 'ResourceNotFound',
+                message: 'network pool not found'
+            }
+        });
+    });
+});
+
+
+
+
+test('Verify network delete routes', function (t) {
+    t.test('Delete network with incorrect etag', function (t2) {
+        mod_net.del(t2, {
+            uuid: NET.uuid,
+            etag: INCORRECT,
+            expCode: 412,
+            expErr: precondError(NET_ETAG)
+        });
+    });
+
+    t.test('Verify that network still exists', checkNetwork);
+
+    t.test('Delete network with good etag', function (t2) {
+        mod_net.del(t2, {
+            uuid: NET.uuid,
+            etag: NET_ETAG
+        });
+    });
+
+    t.test('Verify that network is gone', function (t2) {
+        mod_net.get(t2, {
+            params: {
+                uuid: NET.uuid
+            },
+            expCode: 404,
+            expErr: {
+                code: 'ResourceNotFound',
+                message: 'network not found'
+            }
+        });
+    });
+});
+
+
+// --- Teardown
+
+test('Stop server', mod_server.close);
diff --git a/test/unit/network-owner.test.js b/test/unit/network-owner.test.js
index d61a963..f8fba0a 100644
--- a/test/unit/network-owner.test.js
+++ b/test/unit/network-owner.test.js
@@ -17,6 +17,7 @@
 var constants = require('../../lib/util/constants');
 var helpers = require('./helpers');
 var mod_err = require('../../lib/util/errors');
+var mod_net = require('../lib/net');
 var mod_nic = require('../lib/nic');
 var mod_server = require('../lib/server');
 var mod_uuid = require('node-uuid');
@@ -546,6 +547,26 @@ test('pool update', function (t) {
 
 
 
+// --- Network get tests
+
+
+test('provisionable_by network: other owner', function (t) {
+    mod_net.get(t, {
+        params: {
+            uuid: nets[0].uuid,
+            params: {
+                provisionable_by: mod_uuid.v4()
+            }
+        },
+        expCode: 403,
+        expErr: {
+            code: 'NotAuthorized',
+            message: constants.msg.NET_OWNER
+        }
+    });
+});
+
+
 // --- Nic provision tests
 
 
