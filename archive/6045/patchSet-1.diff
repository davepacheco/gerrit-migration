commit bf446d08bdba752b1ee19d850533df7b06bb2cf8
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2019-04-04T14:06:48+00:00 (6 months ago)
    
    OS-7696 bhyve should avoid all-cpu cross calls

diff --git a/usr/src/compat/freebsd/sys/smp.h b/usr/src/compat/freebsd/sys/smp.h
index 8a91c6c8d7..3d6413ce16 100644
--- a/usr/src/compat/freebsd/sys/smp.h
+++ b/usr/src/compat/freebsd/sys/smp.h
@@ -19,11 +19,6 @@
 
 #include <sys/cpuset.h>
 
-void	smp_rendezvous(void (*)(void *),
-		       void (*)(void *),
-		       void (*)(void *),
-		       void *arg);
-
 #define	IPI_AST	0
 
 void	ipi_cpu(int cpu, u_int ipi);
diff --git a/usr/src/uts/i86pc/io/vmm/intel/ept.c b/usr/src/uts/i86pc/io/vmm/intel/ept.c
index a9838793e5..4915537b0a 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/ept.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/ept.c
@@ -49,6 +49,9 @@ __FBSDID("$FreeBSD$");
 #include <sys/systm.h>
 #include <sys/smp.h>
 #include <sys/sysctl.h>
+#ifndef __FreeBSD__
+#include <sys/hma.h>
+#endif
 
 #include <vm/vm.h>
 #include <vm/pmap.h>
@@ -167,6 +170,7 @@ ept_dump(uint64_t *ptp, int nlevels)
 }
 #endif
 
+#ifdef __FreeBSD__
 static void
 invept_single_context(void *arg)
 {
@@ -184,6 +188,13 @@ ept_invalidate_mappings(u_long eptp)
 
 	smp_rendezvous(NULL, invept_single_context, NULL, &invept_desc);
 }
+#else /* __FreeBSD__ */
+void
+ept_invalidate_mappings(u_long eptp)
+{
+	hma_vmx_invept_allcpus((uintptr_t)eptp);
+}
+#endif /* __FreeBSD__ */
 
 static int
 ept_pinit(pmap_t pmap)
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
index e42e0c4025..d03955ec06 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_glue.c
@@ -142,19 +142,6 @@ cpusetobj_ffs(const cpuset_t *set)
 #endif
 }
 
-void
-smp_rendezvous(void (* setup_func)(void *), void (* action_func)(void *),
-    void (* teardown_func)(void *), void *arg)
-{
-	cpuset_t cpuset;
-
-	ASSERT(setup_func == NULL);
-	ASSERT(teardown_func == NULL);
-
-	CPUSET_ALL(cpuset);
-	xc_sync((xc_arg_t)arg, 0, 0, CPUSET2BV(cpuset), (xc_func_t)action_func);
-}
-
 struct kmem_item {
 	void			*addr;
 	size_t			size;
diff --git a/usr/src/uts/i86pc/ml/hma_asm.s b/usr/src/uts/i86pc/ml/hma_asm.s
index 3b5995bb1a..49afbdd240 100644
--- a/usr/src/uts/i86pc/ml/hma_asm.s
+++ b/usr/src/uts/i86pc/ml/hma_asm.s
@@ -10,21 +10,12 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 
 #include <sys/asm_linkage.h>
 
-#if defined(__lint)
-
-int
-hma_vmx_vmxon(uintptr_t arg)
-{
-	return (0);
-}
-
-#else	/* __lint */
 	ENTRY_NP(hma_vmx_vmxon)
 	push	%rbp
 	movq	%rsp, %rbp
@@ -39,4 +30,23 @@ hma_vmx_vmxon(uintptr_t arg)
 	leave
 	ret
 	SET_SIZE(hma_vmx_vmxon)
-#endif	/* __lint */
+
+	ENTRY_NP(hma_vmx_do_invept)
+	push	%rbp
+	movq	%rsp, %rbp
+	pushq	%rdi
+	pushq	%rsi
+
+	/* build INVEPT descriptor on stack */
+	xorl	%eax, %eax
+	pushq	%rax;
+	pushq	%rsi
+
+	invept	(%rsp), %rdi
+	ja	1f	/* CF=0, ZF=0 (success) */
+	incl	%eax
+1:
+
+	leave
+	ret
+	SET_SIZE(hma_vmx_do_invept)
diff --git a/usr/src/uts/i86pc/os/hma.c b/usr/src/uts/i86pc/os/hma.c
index c7c0984db7..4a37c4f8dd 100644
--- a/usr/src/uts/i86pc/os/hma.c
+++ b/usr/src/uts/i86pc/os/hma.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/cpuvar.h>
@@ -69,6 +69,10 @@ static hma_svm_asid_t hma_svm_cpu_asid[NCPU];
 static int hma_vmx_init(void);
 static int hma_svm_init(void);
 
+/* Helpers from ml/hma_asm.s */
+int hma_vmx_do_invept(int, uintptr_t);
+int hma_vmx_vmxon(uintptr_t);
+
 void
 hma_init(void)
 {
@@ -197,8 +201,34 @@ hma_vmx_vpid_free(uint16_t vpid)
 	id_free(hma_vmx_vpid, (id_t)vpid);
 }
 
+#define	INVEPT_SINGLE_CONTEXT	1
+#define	INVEPT_ALL_CONTEXTS	2
 
-extern int hma_vmx_vmxon(uintptr_t);
+
+static int
+hma_vmx_invept_xcall(xc_arg_t arg1, xc_arg_t arg2 __unused,
+    xc_arg_t arg3 __unused)
+{
+	uintptr_t eptp = (uintptr_t)arg1;
+
+	VERIFY0(hma_vmx_do_invept(INVEPT_SINGLE_CONTEXT, eptp));
+	return (0);
+}
+
+void
+hma_vmx_invept_allcpus(uintptr_t eptp)
+{
+	cpuset_t set;
+
+	cpuset_zero(&set);
+	mutex_enter(&cpu_lock);
+
+	cpuset_or(&set, &cpu_active_set);
+	xc_sync((xc_arg_t)eptp, 0, 0, CPUSET2BV(set),
+	    hma_vmx_invept_xcall);
+
+	mutex_exit(&cpu_lock);
+}
 
 static int
 hma_vmx_cpu_vmxon(xc_arg_t arg1 __unused, xc_arg_t arg2 __unused,
@@ -265,9 +295,21 @@ hma_vmx_cpu_setup(cpu_setup_t what, int id, void *arg __unused)
 		return (0);
 	}
 
-	/* Perform initialization if it has not been previously attempted. */
-	if (hma_cpu_status[id] != HCS_UNINITIALIZED) {
-		return ((hma_cpu_status[id] == HCS_READY) ? 0 : -1);
+	switch (hma_cpu_status[id]) {
+	case HCS_READY:
+		/*
+		 * If an already-initialized CPU is going back online, perform
+		 * an all-contexts invept to eliminate the possibility of
+		 * cached EPT state causing issues.
+		 */
+		VERIFY0(hma_vmx_do_invept(INVEPT_ALL_CONTEXTS, (uintptr_t)0));
+		return (0);
+	case HCS_ERROR:
+		return (-1);
+	case HCS_UNINITIALIZED:
+	default:
+		VERIFY3U(hma_cpu_status[id], ==, HCS_UNINITIALIZED);
+		break;
 	}
 
 	/* Allocate the VMXON page for this CPU */
@@ -311,6 +353,9 @@ hma_vmx_cpu_setup(cpu_setup_t what, int id, void *arg __unused)
 	return (hma_cpu_status[id] != HCS_READY);
 }
 
+#define	INVEPT_ALL_TYPES \
+	(IA32_VMX_EPT_VPID_INVEPT_SINGLE | IA32_VMX_EPT_VPID_INVEPT_ALL)
+
 static int
 hma_vmx_init(void)
 {
@@ -341,6 +386,17 @@ hma_vmx_init(void)
 	/* Record the VMX revision for later VMXON usage */
 	hma_vmx_revision = (uint32_t)msr;
 
+	/* Confirm INVEPT functionality */
+	msr = rdmsr(MSR_IA32_VMX_EPT_VPID_CAP);
+	if ((msr & IA32_VMX_EPT_VPID_INVEPT) == 0) {
+		msg = "VMX does not support INVEPT";
+		goto bail;
+	}
+	if ((msr & INVEPT_ALL_TYPES) != INVEPT_ALL_TYPES) {
+		msg = "VMX does not support necessary INVEPT types";
+		goto bail;
+	}
+
 	mutex_enter(&cpu_lock);
 	/* Perform VMX configuration for already-online CPUs. */
 	cp = cpu_active;
diff --git a/usr/src/uts/i86pc/sys/hma.h b/usr/src/uts/i86pc/sys/hma.h
index 0f4beb0452..16ab708896 100644
--- a/usr/src/uts/i86pc/sys/hma.h
+++ b/usr/src/uts/i86pc/sys/hma.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #ifndef _SYS_HMA_H
@@ -50,6 +50,11 @@ extern void hma_unregister(hma_reg_t *);
 extern uint16_t hma_vmx_vpid_alloc(void);
 extern void hma_vmx_vpid_free(uint16_t);
 
+/*
+ * On all active CPUs, perform a single-context INVEPT on the given EPTP.
+ */
+extern void hma_vmx_invept_allcpus(uintptr_t);
+
 struct hma_svm_asid {
 	uint64_t hsa_gen;
 	uint32_t hsa_asid;
diff --git a/usr/src/uts/intel/sys/x86_archext.h b/usr/src/uts/intel/sys/x86_archext.h
index 59a974dfd2..f5f5f1d9a1 100644
--- a/usr/src/uts/intel/sys/x86_archext.h
+++ b/usr/src/uts/intel/sys/x86_archext.h
@@ -463,6 +463,10 @@ extern "C" {
 #define	MSR_IA32_VMX_BASIC	0x480
 #define	IA32_VMX_BASIC_INS_OUTS	(1UL << 54)
 
+#define	MSR_IA32_VMX_EPT_VPID_CAP	0x48c
+#define	IA32_VMX_EPT_VPID_INVEPT	(1UL << 20)
+#define	IA32_VMX_EPT_VPID_INVEPT_SINGLE	(1UL << 25)
+#define	IA32_VMX_EPT_VPID_INVEPT_ALL	(1UL << 26)
 
 #define	MCI_CTL_VALUE		0xffffffff
 
