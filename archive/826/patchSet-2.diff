From 28a49e92ff7171f50452f2aced5e8bc5ad74c821 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <jmc@joyent.com>
Date: Mon, 31 Oct 2016 17:42:24 -0700
Subject: [PATCH] TOOLS-1598 v8plus can be overwhelmed by cross-thread calls

---
 v8plus_csup.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/v8plus_csup.c b/v8plus_csup.c
index f551b03..669ba31 100644
--- a/v8plus_csup.c
+++ b/v8plus_csup.c
@@ -106,12 +106,29 @@ v8plus_async_callback(uv_async_t *async __UNUSED)
 v8plus_async_callback(uv_async_t *async __UNUSED, int status __UNUSED)
 #endif
 {
+	int processed = 0;
+
 	if (v8plus_in_event_thread() != B_TRUE)
 		v8plus_panic("async callback called outside of event loop");
 
 	for (;;) {
 		v8plus_async_call_t *vac = NULL;
 
+		/*
+		 * If a high rate of work arrives from other threads, it's
+		 * possible that we'll remain in this loop forever.  To
+		 * prevent that from happening, we will process a maximum
+		 * of 1000 function calls per turn of the event loop.
+		 */
+		if (processed > 1000) {
+			/*
+			 * Make sure this callback is called again on the
+			 * next turn.
+			 */
+			uv_async_send(&_v8plus_uv_async);
+			break;
+		}
+
 		/*
 		 * Fetch the next queued method:
 		 */
@@ -130,6 +147,7 @@ v8plus_async_callback(uv_async_t *async __UNUSED, int status __UNUSED)
 		/*
 		 * Run the queued method:
 		 */
+		processed++;
 		if (vac->vac_flags & ACF_COMPLETED)
 			v8plus_panic("async call already run");
 
@@ -172,6 +190,7 @@ v8plus_async_callback(uv_async_t *async __UNUSED, int status __UNUSED)
 			v8plus_panic("could not signal async call condvar");
 		if (pthread_mutex_unlock(&vac->vac_mtx) != 0)
 			v8plus_panic("could not unlock async call mutex");
+
 	}
 }
 
-- 
2.21.0

