commit 91c2224fbc3c30fbdbd7e0d01b1c0697cc7871db (refs/changes/74/4774/3)
Author: Rui Loura <rui@joyent.com>
Date:   2018-08-31T15:27:03+00:00 (1 year, 1 month ago)
    
    TRITON-658 "triton instance create" command failed for a CN where there is no "external" nictag

diff --git a/lib/middleware/networks.js b/lib/middleware/networks.js
index 4268d38..64428a9 100644
--- a/lib/middleware/networks.js
+++ b/lib/middleware/networks.js
@@ -8,10 +8,24 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
+
+/*
+ * This middleware module is responsible for adding the following properties to
+ * the request ('req') object:
+ *
+ *    * external_nets: uuids of all publically-accessible networks accessible by
+ *                     the requesting user
+ *
+ *    * internal_nets: uuids of all internally-accessible networks accessible
+ *                     by the requesting user
+ *
+ *    * networks:      full NAPI network objects of all of the networks
+ *                     accessible by the requesting user
+ */
 var assert = require('assert-plus');
 
 
-var modNetworks = require('../networks');
+var modNets = require('../networks');
 
 
 function loadNetworks(req, res, next) {
@@ -70,7 +84,7 @@ function loadNetworks(req, res, next) {
 
         // Always skip admin network pools:
         pools = pools.filter(function (pool) {
-            return (pool.nic_tag !== modNetworks.ADMIN_NIC_TAG);
+            return (!modNets.isAdmin(pool));
         });
 
         pools = plugins.filterListNetworks({ account: req.account }, pools);
@@ -86,10 +100,9 @@ function loadNetworks(req, res, next) {
                 }
             });
 
-            if (pool.nic_tag === modNetworks.EXTERNAL_NIC_TAG) {
+            if (modNets.isExternal(pool)) {
                 externalNetworks.push(pool.uuid);
-            } else if (pool.nic_tag === modNetworks.INTERNAL_NIC_TAG ||
-                isFabric === true) {
+            } else if (modNets.isInternal(pool) || isFabric === true) {
                 internalNetworks.push(pool.uuid);
             }
         });
@@ -104,8 +117,7 @@ function loadNetworks(req, res, next) {
             // Always skip admin networks, and don't add networks which are
             // already in contained pools:
             nets = nets.filter(function (net) {
-                return net.nic_tag !== modNetworks.ADMIN_NIC_TAG &&
-                    !networksInPools[net.uuid];
+                return (!modNets.isAdmin(net) && !networksInPools[net.uuid]);
             });
 
             nets = plugins.filterListNetworks({ account: req.account }, nets);
@@ -113,10 +125,9 @@ function loadNetworks(req, res, next) {
             networks = networks.concat(nets);
 
             networks.forEach(function (net) {
-                if (net.nic_tag === modNetworks.EXTERNAL_NIC_TAG) {
+                if (modNets.isExternal(net)) {
                     externalNetworks.push(net.uuid);
-                } else if (net.nic_tag === modNetworks.INTERNAL_NIC_TAG ||
-                    net.fabric === true) {
+                } else if (modNets.isInternal(net) || net.fabric === true) {
                     internalNetworks.push(net.uuid);
                 }
             });
diff --git a/lib/networks.js b/lib/networks.js
index c54aad7..dd4096c 100644
--- a/lib/networks.js
+++ b/lib/networks.js
@@ -16,6 +16,45 @@ var ADMIN_NIC_TAG = 'admin';
 var EXTERNAL_NIC_TAG = 'external';
 var INTERNAL_NIC_TAG = 'internal';
 
+/*
+ * Check if a network or pool is named or tagged with the following nictag
+ * accounting for rack aware nictag format of "<tag>_rack_<rack id>".
+ */
+function _isNetCommon(net, tag) {
+    if (net.name === tag) {
+        return true;
+    }
+
+    var rackTag = new RegExp('^' + tag + '_rack_[a-z0-9_-]+$', 'i');
+
+    if (net.nic_tag === tag || net.nic_tag.search(rackTag) === 0) {
+        return true;
+    }
+
+    /* Is this a network pool? */
+    if (net.nic_tags_present) {
+        var tagsLen = net.nic_tags_present.length;
+
+        if (net.nic_tags_present.indexOf(tag) !== -1) {
+            return true;
+        }
+
+        /*
+         * We could start at i = 1 here because in the case of network pools
+         * the nic_tag property is set to the first element of the
+         * nic_tags_provided array.  But that is some what of an obsecure
+         * assumption that could change in the future.
+         */
+        for (var i = 0; i < tagsLen; i++) {
+            if (net.nic_tags_present[i].search(rackTag) === 0) {
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
 function checkFabricNetworks(napiClient, networks, accountUuid, cb) {
     assert.object(napiClient, 'napiClient');
     assert.arrayOfUuid(networks, 'networks');
@@ -107,11 +146,26 @@ function getDefaultFabricNetworkForUser(ufdsClient, dataCenterName, account,
     });
 }
 
+function isAdmin(net) {
+    return _isNetCommon(net, ADMIN_NIC_TAG);
+}
+
+function isExternal(net) {
+    return _isNetCommon(net, EXTERNAL_NIC_TAG);
+}
+
+function isInternal(net) {
+    return _isNetCommon(net, INTERNAL_NIC_TAG);
+}
+
 
 module.exports = {
     ADMIN_NIC_TAG: ADMIN_NIC_TAG,
     checkFabricNetworks: checkFabricNetworks,
     EXTERNAL_NIC_TAG: EXTERNAL_NIC_TAG,
     getDefaultFabricNetworkForUser: getDefaultFabricNetworkForUser,
-    INTERNAL_NIC_TAG: INTERNAL_NIC_TAG
+    INTERNAL_NIC_TAG: INTERNAL_NIC_TAG,
+    isAdmin: isAdmin,
+    isExternal: isExternal,
+    isInternal: isInternal
 };
diff --git a/lib/plugin-manager.js b/lib/plugin-manager.js
index d418b3d..6744a3a 100644
--- a/lib/plugin-manager.js
+++ b/lib/plugin-manager.js
@@ -47,6 +47,7 @@
 
 var assert = require('assert-plus');
 var jsprim = require('jsprim');
+var modNets = require('./networks');
 var path = require('path');
 var vasync = require('vasync');
 
@@ -100,13 +101,11 @@ function init(app) {
                     return cb(err);
                 }
 
-                var ADMIN_NIC_TAG = 'admin';
-
                 var networks = [];
                 var networksInPools = {};
 
                 pools = pools.filter(function (pool) {
-                    return (pool.nic_tag !== ADMIN_NIC_TAG);
+                    return (!modNets.isAdmin(pool));
                 });
 
                 pools.forEach(function addNets(pool) {
@@ -124,8 +123,8 @@ function init(app) {
                     }
 
                     nets = nets.filter(function (net) {
-                        return net.nic_tag !== ADMIN_NIC_TAG &&
-                            !networksInPools[net.uuid];
+                        return (!modNets.isAdmin(net) &&
+                            !networksInPools[net.uuid]);
                     });
 
                     return cb(null, networks.concat(nets));
diff --git a/package.json b/package.json
index 011e611..283bab2 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "cloudapi",
     "description": "SmartDataCenter CloudAPI",
-    "version": "9.2.3",
+    "version": "9.2.4",
     "author": "Joyent (joyent.com)",
     "private": true,
     "engines": {
diff --git a/plugins/filter_owner_networks.js b/plugins/filter_owner_networks.js
index d27456f..217f358 100644
--- a/plugins/filter_owner_networks.js
+++ b/plugins/filter_owner_networks.js
@@ -46,9 +46,7 @@
  */
 
 var assert = require('assert-plus');
-
-
-var EXTERNAL_NIC_TAG = 'external';
+var modNets = require('../lib/networks');
 
 
 /*
@@ -133,9 +131,7 @@ function findOwnerExternalNetwork(api, cfg) {
             });
 
             var external = owned.filter(function filterExternal(network) {
-                var tags = network.nic_tags_present;
-                return network.nic_tag === EXTERNAL_NIC_TAG ||
-                    (tags && tags.indexOf(EXTERNAL_NIC_TAG) !== -1);
+                return (modNets.isExternal(network));
             });
 
             if (external.length === 0) {
diff --git a/test/common.js b/test/common.js
index 6697db3..95c7677 100644
--- a/test/common.js
+++ b/test/common.js
@@ -1117,6 +1117,26 @@ function removeTagsFromServer(nicTags, server, client, callback) {
     });
 }
 
+function getOrCreateNicTag(tagName, client, callback) {
+    client.napi.getNicTag(tagName, function onGetNicTag(err, nicTag) {
+        if (err) {
+            if (err.statusCode === 404) {
+                createNicTag();
+            } else {
+                callback(err);
+            }
+        } else {
+            callback(null, nicTag);
+        }
+    });
+
+    function createNicTag() {
+        client.napi.createNicTag(tagName, function onCreateNicTag(err, nicTag) {
+            callback(err, nicTag);
+        });
+    }
+}
+
 /*
  * Make the already imported image with name "imageName" provisionable by making
  * it public.
@@ -1239,6 +1259,7 @@ module.exports = {
 
     // common functions to add/remove nic tags in tests
     addNicTagsToServer: addNicTagsToServer,
+    getOrCreateNicTag: getOrCreateNicTag,
     removeTagsFromServer: removeTagsFromServer,
 
     sdc_128_package: SDC_128_PACKAGE,
diff --git a/test/machines.test.js b/test/machines.test.js
index a42e4c4..785d788 100644
--- a/test/machines.test.js
+++ b/test/machines.test.js
@@ -162,28 +162,12 @@ test('Get test server', function (t) {
 });
 
 test('Create nic tag', function (t) {
-    CLIENT.napi.getNicTag(NIC_TAG_NAME, function onGetNicTag(err, nicTag) {
-        if (err) {
-            if (err.statusCode === 404) {
-                createNicTag();
-            } else {
-                t.ifError(err, 'getNicTag');
-                t.end();
-            }
-        } else {
-            NIC_TAG = nicTag;
-            t.end();
-        }
-    });
-
-    function createNicTag() {
-        CLIENT.napi.createNicTag(NIC_TAG_NAME, function onCreateNicTag(err,
-            nicTag) {
+    common.getOrCreateNicTag(NIC_TAG_NAME, CLIENT,
+        function onGetOrCreate(err, nicTag) {
             t.ifError(err, 'createNicTag: nicTag ' + NIC_TAG_NAME);
             NIC_TAG = nicTag;
             t.end();
-        });
-    }
+    });
 });
 
 test('Add nic tag to test server', function (t) {
@@ -1240,6 +1224,238 @@ test('ListMachines destroyed', function (t) {
 });
 
 
+test('Create machine with external RAN network pool', function (t) {
+    var server;
+    var networkPoolUuid;
+    var machId;
+    var nets = {};
+    var networkUuids = [];
+    var nicTag = 'external_rack_e50';
+    var nicTagWrong = 'external_rack_error0';
+    var goodNet = 'machines-test-network-pool-rack-1';
+    var badNet = 'machines-test-network-pool-rack-2';
+
+    var networks = [
+        {
+            name: goodNet,
+            vlan_id: 97,
+            subnet: '10.99.55.0/24',
+            provision_start_ip: '10.99.55.5',
+            provision_end_ip: '10.99.55.250',
+            nic_tag: nicTag,
+            owner_uuids: []
+        },
+        {
+            name: badNet,
+            vlan_id: 98,
+            subnet: '10.99.67.0/24',
+            provision_start_ip: '10.99.67.5',
+            provision_end_ip: '10.99.67.250',
+            nic_tag: nicTagWrong,
+            owner_uuids: []
+        }
+    ];
+
+    function createNicTags(_, done) {
+        var nicTags = [nicTag, nicTagWrong];
+
+        vasync.forEachParallel({
+            func: function (tag, cb) {
+                common.getOrCreateNicTag(tag, CLIENT,
+                    function onGetOrCreate(err) {
+                        t.ifError(err, 'createNicTag: nicTag ' + tag);
+                        cb(err);
+                });
+            },
+            inputs: nicTags
+        }, function (createErr) {
+            t.ifError(createErr);
+            done(createErr);
+        });
+    }
+
+    function getTestServer(_, done) {
+        common.getTestServer(CLIENT, function onGetTestServer(err, testServer) {
+            t.ifError(err);
+            server = testServer;
+            done(err);
+        });
+    }
+
+    function assignNicTagToServer(_, done) {
+        common.addNicTagsToServer([nicTag], server, CLIENT,
+            function onAddNicTagsToServer(addNicTagsErr, job) {
+
+            t.ifError(addNicTagsErr, 'assign NIC tag to server: ' + nicTag);
+            waitForJob(CLIENT, job.job_uuid, function (jobErr) {
+                t.ifError(jobErr, 'wait for job assign NIC tag to server');
+                done(jobErr);
+            });
+        });
+    }
+
+    function createNetwork(params, done) {
+        CLIENT.napi.createNetwork(params, function (err, net) {
+            t.ifError(err, 'create network');
+            if (err) {
+                done(err);
+                return;
+            }
+            nets[net.name] = net.uuid;
+            networkUuids.push(net.uuid);
+            done();
+        });
+    }
+
+    function createNetworksForPool(_, done) {
+        vasync.forEachPipeline({
+            func: createNetwork,
+            inputs: networks
+        }, function (err, results) {
+            t.ifError(err, 'create networks for pool');
+            if (err) {
+                done(err);
+                return;
+            }
+            done();
+        });
+    }
+
+    function createPool(_, done) {
+        CLIENT.napi.createNetworkPool('external',
+            {networks: networkUuids}, function (err, net) {
+            if (err) {
+                done(err);
+                return;
+            }
+            networkPoolUuid = net.uuid;
+            done();
+        });
+    }
+
+    function runTest(_, done) {
+        var obj = {
+            image: IMAGE_UUID,
+            package: SDC_128.name,
+            firewall_enabled: true
+        };
+
+        // provision machine without specifying network (should pickup network
+        // from external network pool)
+        machinesCommon.createMachine(t, CLIENT, obj,
+            function (cErr, machineUuid) {
+
+            machId = machineUuid;
+
+            machinesCommon.waitForRunningMachine(CLIENT, machineUuid,
+                function (err) {
+                    t.ifError(err);
+
+                    if (err) {
+                        done(err);
+                        return;
+                    }
+                    machinesCommon.getMachine(t, CLIENT, machineUuid,
+                        function (gErr, machine) {
+                            t.ifError(gErr);
+                            t.ok(machine.networks.indexOf(nets[goodNet]) !== -1,
+                                'rack network exists');
+                            t.ok(machine.networks.indexOf(nets[badNet]) === -1,
+                                'alt network does not exist');
+                            done(gErr);
+                    });
+            });
+        });
+    }
+
+    vasync.pipeline({
+        funcs: [
+            createNicTags,
+            getTestServer,
+            assignNicTagToServer,
+            createNetworksForPool,
+            createPool,
+            runTest
+        ]
+    }, function (err, results) {
+        // This teardown intentionally plows past errors to make sure we don't
+        // leave behind any artifacts.
+        vasync.pipeline({ funcs: [
+            function deleteNetworkPool(_, done) {
+                if (!networkPoolUuid) {
+                    done();
+                    return;
+                }
+                CLIENT.napi.deleteNetworkPool(networkPoolUuid,
+                    function (delNetworkPoolErr, net) {
+
+                    t.ifError(delNetworkPoolErr, 'delete network pool');
+                    done();
+                });
+            },
+
+            // Machine must be deleted first because the network cannot be
+            // deleted while nics are still provisioned.
+            function deleteMach(_, done) {
+                if (!machId) {
+                    done();
+                    return;
+                }
+                CLIENT.del('/my/machines/' + machId, function (dErr, req, res) {
+                    t.ifError(err, 'DELETE /my/machines error');
+                    t.equal(res.statusCode, 204, 'DELETE /my/machines status');
+                    done();
+                });
+            },
+
+            function waitDeletedMach(_, done) {
+                if (!machId) {
+                    done();
+                    return;
+                }
+                machinesCommon.waitForDeletedMachine(CLIENT, machId,
+                    function (waitDelErr) {
+                        t.ifError(waitDelErr, 'wait for deleted machine');
+                        done();
+                });
+            },
+
+            function deleteNetwork(_, done) {
+                vasync.forEachParallel({
+                    func: function delNetwork(netUuid, cb) {
+                        CLIENT.napi.deleteNetwork(netUuid, function (dnErr) {
+                            t.ifError(dnErr);
+                            cb();
+                        });
+                    },
+                    inputs: networkUuids
+                }, function (delPipelineErr) {
+                    t.ifError(delPipelineErr);
+                    done();
+                });
+            },
+
+            function deleteNicTags(_, done) {
+                var nicTags = [nicTag];
+                common.removeTagsFromServer(nicTags, server, CLIENT,
+                    function (removeErr, job) {
+
+                    t.ifError(removeErr, 'remove NIC tags from server: '
+                        + nicTags);
+
+                    waitForJob(CLIENT, job.job_uuid, function (jobErr) {
+                        t.ifError(jobErr, 'waitForJob ' + job.job_uuid);
+                        done();
+                    });
+                });
+            }
+        ]}, function (tdErr, tdResults) {
+            t.ifError(tdErr, 'teardown error');
+            t.end();
+        });
+    });
+});
+
 test('CreateMachine using query args', function (t) {
     var query = '/my/machines?image=' + IMAGE_UUID +
                 '&package=' + SDC_128.name +
@@ -1814,7 +2030,6 @@ test('Create Machine using multiple networks and IPs', function (t) {
     });
 });
 
-
 test('Wait For Running Machine provisioned with multiple IPs', waitForRunning);
 
 
