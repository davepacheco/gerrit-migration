commit e63c9c274af331147a2abcc77dd264f464ceaf40 (refs/changes/20/3720/1)
Author: Patrick Mooney <pmooney@pfmooney.com>
Date:   2018-03-24T04:44:14+00:00 (1 year, 7 months ago)
    
    OS-6815 viona should pad short frames

diff --git a/usr/src/uts/i86pc/io/viona/viona.c b/usr/src/uts/i86pc/io/viona/viona.c
index db5f46ae75..4de9cb9fac 100644
--- a/usr/src/uts/i86pc/io/viona/viona.c
+++ b/usr/src/uts/i86pc/io/viona/viona.c
@@ -1512,6 +1512,8 @@ viona_recv_plain(viona_vring_t *ring, const mblk_t *mp, size_t msz)
 	caddr_t buf = NULL;
 	boolean_t end = B_FALSE;
 
+	ASSERT(msz >= MIN_BUF_SIZE);
+
 	n = vq_popchain(ring, iov, VTNET_MAXSEGS, &cookie);
 	if (n <= 0) {
 		/* Without available buffers, the frame must be dropped. */
@@ -1549,11 +1551,8 @@ viona_recv_plain(viona_vring_t *ring, const mblk_t *mp, size_t msz)
 		copied += viona_copy_mblk(mp, copied, buf, len, &end);
 	}
 
-	/*
-	 * Is the copied data long enough to be considered an ethernet frame of
-	 * the minimum length?  Does it match the total length of the mblk?
-	 */
-	if (copied < MIN_BUF_SIZE || copied != msz) {
+	/* Was the expected amount of data copied? */
+	if (copied != msz) {
 		VIONA_PROBE5(too_short, viona_vring_t *, ring,
 		    uint16_t, cookie, mblk_t *, mp, size_t, copied,
 		    size_t, msz);
@@ -1599,6 +1598,8 @@ viona_recv_merged(viona_vring_t *ring, const mblk_t *mp, size_t msz)
 	const size_t hdr_sz = sizeof (struct virtio_net_mrgrxhdr);
 	boolean_t end = B_FALSE;
 
+	ASSERT(msz >= MIN_BUF_SIZE);
+
 	n = vq_popchain(ring, iov, VTNET_MAXSEGS, &cookie);
 	if (n <= 0) {
 		/* Without available buffers, the frame must be dropped. */
@@ -1687,11 +1688,8 @@ viona_recv_merged(viona_vring_t *ring, const mblk_t *mp, size_t msz)
 	/* Account for the header size in the first buffer */
 	uelem[0].len += hdr_sz;
 
-	/*
-	 * Is the copied data long enough to be considered an ethernet frame of
-	 * the minimum length?  Does it match the total length of the mblk?
-	 */
-	if (copied < MIN_BUF_SIZE || copied != msz) {
+	/* Was the expected amount of data copied? */
+	if (copied != msz) {
 		/* Do not override an existing error */
 		VIONA_PROBE5(too_short, viona_vring_t *, ring,
 		    uint16_t, cookie, mblk_t *, mp, size_t, copied,
@@ -1755,10 +1753,16 @@ viona_rx(void *arg, mac_resource_handle_t mrh, mblk_t *mp, boolean_t loopback)
 		size = msgsize(mp);
 
 		/*
-		 * Stripping the VLAN tag off already-small frames can cause
-		 * them to fall below the minimum size.  If this happens, pad
-		 * them out as they would have been if they lacked the tag in
-		 * the first place.
+		 * Ethernet frames are expected to be padded out in order to
+		 * meet the minimum size.
+		 *
+		 * A special case is made for frames which are short by
+		 * VLAN_TAGSZ, having been stripped of their VLAN tag while
+		 * traversing MAC.  A preallocated (and recycled) mblk is used
+		 * for that specific condition.
+		 *
+		 * All other frames that fall short on length will have custom
+		 * zero-padding allocated appended to them.
 		 */
 		if (size == NEED_VLAN_PAD_SIZE) {
 			ASSERT(MBLKL(viona_vlan_pad_mp) == VLAN_TAGSZ);
@@ -1769,6 +1773,22 @@ viona_rx(void *arg, mac_resource_handle_t mrh, mblk_t *mp, boolean_t loopback)
 
 			pad->b_cont = viona_vlan_pad_mp;
 			size += VLAN_TAGSZ;
+		} else if (size < MIN_BUF_SIZE) {
+			const size_t pad_size = MIN_BUF_SIZE - size;
+			mblk_t *zero_mp;
+
+			zero_mp = allocb(pad_size, BPRI_MED);
+			if (zero_mp == NULL) {
+				err = ENOMEM;
+				goto pad_drop;
+			}
+
+			VIONA_PROBE3(rx_pad_short, viona_vring_t *, ring,
+			    mblk_t *, mp, size_t, pad_size);
+			zero_mp->b_wptr += pad_size;
+			bzero(zero_mp->b_rptr, pad_size);
+			linkb(mp, zero_mp);
+			size += pad_size;
 		}
 
 		if (do_merge) {
@@ -1779,12 +1799,16 @@ viona_rx(void *arg, mac_resource_handle_t mrh, mblk_t *mp, boolean_t loopback)
 
 		/*
 		 * The VLAN padding mblk is meant for continual reuse, so
-		 * remove it from the chain to prevent it from being freed
+		 * remove it from the chain to prevent it from being freed.
+		 *
+		 * Custom allocated padding does not require this treatment and
+		 * is freed normally.
 		 */
 		if (pad != NULL) {
 			pad->b_cont = NULL;
 		}
 
+pad_drop:
 		if (err != 0) {
 			*mpdrop_prevp = mp;
 			mpdrop_prevp = &mp->b_next;
