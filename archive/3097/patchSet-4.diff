From 55cb54622a40e49c51c84abd0fbf59a64ba4fbae Mon Sep 17 00:00:00 2001
From: Chris Burroughs <chris.burroughs@joyent.com>
Date: Wed, 6 Dec 2017 16:28:45 -0500
Subject: [PATCH] HEAD-2207 booter should warm cache by writing out files for
 every CN

---
 lib/boot-files.js             |   4 +-
 lib/booter.js                 |  20 ++-
 lib/bootparams.js             |  67 +++++++-
 lib/cache.js                  | 287 ++++++++++++++++++++++++++++++++++
 lib/dhcpd.js                  |  58 +++++--
 package.json                  |   3 +-
 sapi_manifests/dhcpd/template |  11 +-
 test/lib/mocks.js             |   5 +-
 test/lib/server.js            |  13 +-
 9 files changed, 439 insertions(+), 29 deletions(-)
 create mode 100644 lib/cache.js

diff --git a/lib/boot-files.js b/lib/boot-files.js
index 5b37db5..ce559d6 100644
--- a/lib/boot-files.js
+++ b/lib/boot-files.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -31,7 +31,7 @@ var mod_vasync = require('vasync');
 function extractBootOpts(opts) {
     var bootOpts = {
         adminUuid: opts.config.adminUuid,
-        cacheDir: fmt('%s/cache', opts.config.tftpRoot),
+        cacheDir: opts.config.cache.dir,
         cnapi: opts.cnapi,
         disableHash: opts.config.disableHash || false,
         disableBootTimeFiles: opts.config.disableBootTimeFiles || false,
diff --git a/lib/booter.js b/lib/booter.js
index 16722ea..5fa83eb 100644
--- a/lib/booter.js
+++ b/lib/booter.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -17,9 +17,9 @@ var bootparams = require('./bootparams');
 var bunyan = require('bunyan');
 var fs = require('fs');
 var menu = require('./menulst');
+var mod_cache = require('./cache');
 var mod_clients = require('./clients');
 var path = require('path');
-var util = require('util');
 
 
 
@@ -59,11 +59,12 @@ function main() {
     case 'bootparams':
         bootparams.getBootParams({
             adminUuid: config.adminUuid,
-            cacheDir: util.format('%s/cache', config.tftpRoot),
+            cacheDir: config.cache.dir,
             mac: getArg('MAC address'),
             napi: napi,
             cnapi: cnapi,
-            log: log
+            log: log,
+            pipelineTimeoutSeconds: -1
         }, standardHandler);
         break;
     case 'bootparams-cnapi':
@@ -72,7 +73,7 @@ function main() {
     case 'menu-lst':
         bootparams.getBootParams({
             adminUuid: config.adminUuid,
-            cacheDir: util.format('%s/cache', config.tftpRoot),
+            cacheDir: config.cache.dir,
             mac: getArg('MAC address'),
             napi: napi,
             cnapi: cnapi,
@@ -93,7 +94,7 @@ function main() {
     case 'boot-ipxe':
         bootparams.getBootParams({
             adminUuid: config.adminUuid,
-            cacheDir: util.format('%s/cache', config.tftpRoot),
+            cacheDir: config.cache.dir,
             mac: getArg('MAC address'),
             napi: napi,
             cnapi: cnapi,
@@ -108,6 +109,12 @@ function main() {
             });
         });
         break;
+    case 'full-cache-refresh':
+        var cacheSentinel = new mod_cache.CacheSentinel({
+            log: log, cnapi: cnapi, napi: napi,
+            adminUuid: config.adminUuid, cacheConfig: config.cache});
+        cacheSentinel.refreshCache();
+        break;
     default:
         usage();
         break;
@@ -148,6 +155,7 @@ function usage() {
     console.log('bootparams <MAC address>');
     console.log('bootparams-cnapi <CN UUID | default>');
     console.log('boot-ipxe <MAC address>');
+    console.log('full-cache-refresh');
     console.log('get-nic <MAC address>');
     console.log('menu-lst <MAC address>');
     console.log('ping-napi');
diff --git a/lib/bootparams.js b/lib/bootparams.js
index 47e01ba..0036ae3 100644
--- a/lib/bootparams.js
+++ b/lib/bootparams.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -18,6 +18,7 @@ var mod_clients = require('./clients');
 var mod_json = require('./json-file');
 var util = require('util');
 var vasync = require('vasync');
+var verror = require('verror');
 
 
 
@@ -65,6 +66,12 @@ function macsToAggrs(aggrs) {
  * Gets the boot params for a MAC from the on-disk cache
  */
 function getFromCache(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.string(opts.dir, 'opts.dir');
+    assert.object(opts.log, 'opts.log');
+    assert.string(opts.mac, 'opts.mac');
+    assert.optionalObject(opts.err, 'opts.err');
+
     var dir = opts.dir;
     var log = opts.log;
     var mac = opts.mac;
@@ -112,6 +119,8 @@ function getBootParams(opts, callback) {
     assert.object(opts.log, 'opts.log');
     assert.string(opts.mac, 'opts.mac');
     assert.object(opts.napi, 'opts.napi');
+    assert.optionalNumber(opts.pipelineTimeoutSeconds,
+                          'opts.pipelineTimeoutSeconds');
 
     var cacheDir = opts.cacheDir;
     var adminUuid = opts.adminUuid;
@@ -120,6 +129,46 @@ function getBootParams(opts, callback) {
     var mac = opts.mac;
     var napi = opts.napi;
 
+    /*
+     * getBootParams performs several calls to external services (e.g. napi &
+     * cnapi).  If those services are too slow, iPXE on the CN will give up
+     * before booter can respond, even though CacheSentinel has likely fetched
+     * perfectly good recent values from those services already.  To avoid being
+     * stuck in an infinite "too slow" retry loop, a timer is set which will
+     * callback with the last cached values if a budget for all external calls
+     * is exceeded.
+     *
+     * See the dhcp.h files in https://github.com/joyent/ipxe> for descriptions
+     * of relevant timeouts.  Since HEAD-2321 the longest our iPXE will wait for
+     * a DHCPDISCOVER is 32 seconds.  The default timeout value below is
+     * intended to give a generous pad of time between calling back and getting
+     * the reply packet to the CN before 32 seconds have elapsed.  "Bulk"
+     * callers filling the cache should use -1 to disable this timer and
+     * allowing them to refresh the cache in the background even in the face of
+     * slow external services.
+     */
+    var pipelineTimeout;
+    var pipelineTimeoutSeconds = opts.pipelineTimeoutSeconds || 28 * 1000;
+    var pipelineTimedOut = false;
+    if (pipelineTimeoutSeconds > 0) {
+        pipelineTimeout = setTimeout(function _timeout() {
+            pipelineTimedOut = true;
+            var timeoutInfo = {adminUuid: adminUuid, mac: mac,
+                               pipelineTimeoutSeconds: pipelineTimeoutSeconds};
+            log.warn(
+                timeoutInfo,
+                'getBootParams timed out; calling back with cached result');
+            getFromCache({
+                dir: cacheDir,
+                err: new verror.VError({info: timeoutInfo},
+                                       'timeout during getBootParams pipeline'),
+                log: log,
+                mac: mac
+            }, callback);
+        }, pipelineTimeoutSeconds);
+        pipelineTimeout.unref();
+    }
+
     var uuid;
     var params = null;
     var vArg = {
@@ -276,6 +325,14 @@ function getBootParams(opts, callback) {
             mod_clients.napiGetNicTags
         ]
     }, function (err, res) {
+        if (pipelineTimedOut) {
+            log.warn('getBootParams pipeline timed out; pipeline cb no-op');
+            return;
+        }
+        if (pipelineTimeout) {
+            clearTimeout(pipelineTimeout);
+        }
+
         if (err) {
             return getFromCache({
                 dir: cacheDir,
@@ -384,6 +441,11 @@ function getBootParams(opts, callback) {
             name: mac,
             payload: params
         }, function (storeErr) {
+            if (pipelineTimedOut) {
+                log.warn('getBootParams pipeline timed out; pipeline cb no-op');
+                return;
+            }
+
             if (storeErr) {
                 return callback(storeErr);
             }
@@ -402,5 +464,6 @@ function getBootParams(opts, callback) {
 
 
 module.exports = {
-    getBootParams: getBootParams
+    getBootParams: getBootParams,
+    getFromCache: getFromCache
 };
diff --git a/lib/cache.js b/lib/cache.js
new file mode 100644
index 0000000..e858b8a
--- /dev/null
+++ b/lib/cache.js
@@ -0,0 +1,287 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+/* jsl:ignore */
+'use strict';
+/* jsl:end */
+
+// stdlib
+const fs = require('fs');
+const path = require('path');
+
+// npm
+var assert = require('assert-plus');
+const vasync = require('vasync');
+const verror = require('verror');
+
+// local
+const mod_bootparams = require('./bootparams');
+
+
+/*
+ * From the upstream docs <https://nodejs.org/docs/latest-v4.x/api/timers.html>
+ * "To follow browser behavior, when using delays larger than 2147483647
+ * milliseconds (approximately 25 days) or less than 1, Node will use 1 as the
+ * delay."  Such short intervals would not make sense as intentional values for
+ * booter cache management.
+ */
+function isSafeTimerValueSeconds(val) {
+    const maxSeconds =  Math.floor(2147483647 / 1000);
+    return val > 0 && val < maxSeconds;
+}
+
+
+/*
+ * To boot a CN, booter needs information from other services, such as which
+ * platform image to use.  However, those services could be located on the down
+ * CNs that are trying to boot, resulting in a circular dependency in need of
+ * manual intervention.  To guard against this situation, the bootparams module
+ * writes out local cache of the last used values for each CN.  When there is an
+ * error connecting to the required services, those local files are used as a
+ * fallback.  CacheSentinel performs two periodic tasks for the maintenance of
+ * those cache files:
+ *
+ * Refresh: On a configurable time interval, gather the list of *all* current
+ * CNs (not just recently booted ones) and pre-populate the cache with their
+ * current configuration.  This narrows the vulnerability window of bad or
+ * missing data to the refresh period.  CNs that boot during the window, or have
+ * their configuration changed through a sdcadm workflow will still have their
+ * cached values updated normally.
+ *
+ * Purge: On a configurable time interval, delete cache files that have not been
+ * updated in a long (configurable) time.  This is to remove cache files for
+ * decommissioned CNs so the cache size does not grow indefinitely with obsolete
+ * data.  Purging is only done if the last refresh completed without error.
+ */
+function CacheSentinel(opts) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.cnapi, 'opts.cnapi');
+    assert.object(opts.napi, 'opts.napi');
+    assert.uuid(opts.adminUuid, 'opts.adminUuid');
+
+    assert.object(opts.cacheConfig, 'opts.cacheConfig');
+    assert.string(opts.cacheConfig.dir, 'opts.cacheConfig.dir');
+    assert.number(opts.cacheConfig.refreshIntervalSeconds,
+                  'opts.cacheConfig.refreshIntervalSeconds');
+    assert.ok(isSafeTimerValueSeconds(opts.cacheConfig.refreshIntervalSeconds),
+              'Invalid timer value refreshIntervalSeconds');
+    assert.number(opts.cacheConfig.purgeIntervalSeconds,
+                  'opts.cacheConfig.purgeIntervalSeconds');
+    assert.ok(isSafeTimerValueSeconds(opts.cacheConfig.purgeIntervalSeconds),
+              'Invalid timer value purgeIntervalSeconds');
+    assert.number(opts.cacheConfig.maxCacheFileAgeSeconds,
+                  'opts.cacheConfig.maxCacheFileAgeSeconds');
+    assert.ok(opts.cacheConfig.maxCacheFileAgeSeconds > 0,
+              'maxCacheFileAgeSeconds must be positive');
+    assert.number(opts.cacheConfig.refreshConcurrency,
+                  'opts.cacheConfig.refreshConcurrency');
+    assert.ok(opts.cacheConfig.refreshConcurrency > 0,
+              'refreshConcurrency must be positive');
+
+    this.log = opts.log;
+    this.cnapi = opts.cnapi;
+    this.napi = opts.napi;
+    this.adminUuid = opts.adminUuid;
+
+    this.cacheDir = opts.cacheConfig.dir;
+    this.refreshInterval = opts.cacheConfig.refreshIntervalSeconds * 1000;
+    this.purgeInterval = opts.cacheConfig.purgeIntervalSeconds * 1000;
+    this.maxCacheFileAge = opts.cacheConfig.maxCacheFileAgeSeconds * 1000;
+    this.refreshConcurrency = opts.cacheConfig.refreshConcurrency;
+
+    this.refreshStartTime = undefined;
+    this.purgeStartTime = undefined;
+    // TODO(cburroughs): This should be exposed as a metric for operators to
+    // monitor
+    this.lastRefreshSuccessTime = undefined;
+    this.lastRefreshSuccessful = undefined;
+}
+
+
+CacheSentinel.prototype.start = function start() {
+    this.log.info({'adminUuid': this.adminUuid,
+                   'cacheDir': this.cacheDir,
+                   'refreshInterval': this.refreshInterval,
+                   'purgeInterval': this.purgeInterval,
+                   'maxCacheFileAge': this.maxCacheFileAge,
+                   'refreshConcurrency': this.refreshConcurrency},
+                  'starting CacheSentinel');
+    this.setNextRefreshTimeout();
+    this.setNextPurgeTimeout();
+};
+
+
+CacheSentinel.prototype.setNextRefreshTimeout =
+    function setNextRefreshTimeout() {
+        const timeout = setTimeout(this.refreshCache.bind(this),
+                                   this.refreshInterval);
+        timeout.unref();
+};
+
+
+CacheSentinel.prototype.setNextPurgeTimeout = function setNextPurgeTimeout() {
+    const timeout = setTimeout(this.purgeCache.bind(this), this.purgeInterval);
+    timeout.unref();
+};
+
+
+CacheSentinel.prototype.refreshCache = function refreshCache() {
+    this.refreshStartTime = Date.now();
+    this.lastRefreshSuccessful = undefined;
+
+    const self = this;
+    vasync.pipeline({
+        arg: {},
+        funcs: [
+            function stepListServers(ctx, next) {
+                self.cnapi.listServers(function onList(err, servers) {
+                    if (err) {
+                        return next(new verror.VError(
+                            err,
+                            'unable to list servers during refresh'));
+                    }
+                    ctx.servers = servers;
+                    return next();
+                });
+            },
+            function stepListNics(ctx, next) {
+                self.napi.listNics(
+                    {nic_tag: 'admin', belongs_to_type: 'server'},
+                    function onList(err, nics) {
+                        if (err) {
+                        return next(new verror.VError(
+                            err,
+                            'unable to list nics during refresh'));
+                        }
+                        ctx.nics = nics;
+                        return next();
+                    });
+            },
+            function stepFilterToMacs(ctx, next) {
+                const serverUUIDs = ctx.servers.map(function (s) {
+                    return s.uuid;
+                });
+                const currentNics = ctx.nics.filter(
+                    function (nic) {
+                        return serverUUIDs.indexOf(nic.belongs_to_uuid) > -1;
+                    });
+                ctx.macs = currentNics.map(function (n) {
+                    return n.mac;
+                });
+                self.log.debug(
+                    'found %d current macs ' +
+                        'total-servers:%d total-admin nics:%d',
+                    ctx.macs.length, serverUUIDs.length, ctx.nics.length);
+                next();
+            },
+            function stepFillCacheViaBootParams(ctx, next) {
+                const qErrors = [];
+                const queue = vasync.queue(function worker(mac, cb) {
+                    mod_bootparams.getBootParams({
+                        adminUuid: self.adminUuid,
+                        cacheDir: self.cacheDir,
+                        mac: mac,
+                        napi: self.napi,
+                        cnapi: self.cnapi,
+                        log: self.log,
+                        pipelineTimeout: -1
+                    }, cb);
+                }, self.refreshConcurrency);
+                queue.push(ctx.macs, function qTaskDone(qErr) {
+                    if (qErr) {
+                        qErrors.push(qErr);
+                    }
+                });
+                queue.on('end', function () {
+                    if (qErrors.length) {
+                        self.log.error(new verror.MultiError(qErrors),
+                                  'error while fetching cache boot params');
+                    } else {
+                        const now = Date.now();
+                        const duration = now - self.refreshStartTime;
+                        self.lastRefreshSuccessTime = now;
+                        self.lastRefreshSuccessful = true;
+                        self.log.info('cache refresh for %d items in %d ms',
+                                      ctx.macs.length, duration);
+                    }
+                    self.setNextRefreshTimeout();
+                    next();
+                });
+                queue.close();
+            }
+        ]
+    }, function pipelineDone(err, results) {
+        if (err) {
+            self.log.error(err,
+                           'error while preparing to refresh cache');
+            self.lastRefreshSuccessful = false;
+            self.setNextRefreshTimeout();
+            return;
+        }
+    });
+};
+
+
+CacheSentinel.prototype.purgeCache = function purgeCache() {
+    this.purgeStartTime = Date.now();
+
+    if (!this.lastRefreshSuccessful) {
+        this.log.warn('last refresh failed; delaying purge. Last success at %d',
+                      this.lastRefreshSuccessTime);
+        this.setNextPurgeTimeout();
+        return;
+    }
+
+    const self = this;
+    const purgedPaths = [];
+    const checkAndPurgeCacheFile = function (fpath, cb) {
+        fs.stat(fpath, function withStat(err, stats) {
+            if (err) {
+                return cb(
+                    new verror.VError(err, 'error stating file %s', fpath));
+            }
+            const age = Date.now() - stats.mtime;
+            if (age > self.maxCacheFileAge) {
+                self.log.debug(
+                    'file %s last modifed %d, %d ms old; unlinking',
+                    fpath, stats.mtime, age);
+                purgedPaths.push(fpath);
+                return fs.unlink(fpath, cb);
+            }
+            return cb();
+        });
+    };
+    fs.readdir(self.cacheDir, function onRead(err, cacheFiles) {
+        if (err) {
+            self.log.error(err);
+            self.setNextPurgeTimeout();
+            return;
+        }
+
+        vasync.forEachParallel({
+            func: checkAndPurgeCacheFile,
+            inputs: cacheFiles.map(function (p) {
+                return path.join(self.cacheDir, p);
+            })
+        }, function (err2, results) {
+            if (err2) {
+                self.log.error(err, 'error during purge process');
+            }
+            self.log.info({purged: purgedPaths},
+                          'purged %d cache entries', purgedPaths.length);
+            self.setNextPurgeTimeout();
+        });
+    });
+};
+
+
+module.exports = {
+    CacheSentinel: CacheSentinel
+};
diff --git a/lib/dhcpd.js b/lib/dhcpd.js
index fd974ae..93788fd 100755
--- a/lib/dhcpd.js
+++ b/lib/dhcpd.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -20,6 +20,8 @@ var fs = require('fs');
 var dgram = require('dgram');
 var dhcp = require('./dhcp');
 var mod_boot_files = require('./boot-files');
+var mod_bootparams = require('./bootparams');
+var mod_cache = require('./cache');
 var mod_clients = require('./clients');
 var sprintf = require('sprintf').sprintf;
 var uuid = require('node-uuid');
@@ -39,6 +41,10 @@ function DHCPD(opts) {
     this.cnapi = mod_clients.createCNAPIclient(this.config);
     this.log = opts.log;
     this.napi = mod_clients.createNAPIclient(this.config);
+
+    this.cacheSentinel = new mod_cache.CacheSentinel(
+        {log: this.log, cnapi: this.cnapi, napi: this.napi,
+         adminUuid: this.config.adminUuid, cacheConfig: this.config.cache});
 }
 
 
@@ -59,6 +65,7 @@ DHCPD.prototype.start = function () {
             self.config.listenIp, self.config.port);
     });
     this.sock.bind(this.config.port, this.config.listenIp);
+    this.cacheSentinel.start();
 };
 
 
@@ -121,18 +128,9 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
             + 'identifier');
     }
 
-    mod_boot_files.writeAll({
-        cnapi: self.cnapi,
-        config: self.config,
-        log: log,
-        mac: mac,
-        napi: self.napi
-    }, function _afterParams(pErr, params) {
-        if (pErr) {
-            log.error(pErr, 'error writing param files');
-            return;
-        }
 
+
+    var _sendReplyWithParams = function (params) {
         var packetOpts = self.buildPacketOpts(packet, params.bootParams, log);
         self.sendReply(packet, packetOpts, log, function (sendErr) {
             if (sendErr) {
@@ -142,7 +140,41 @@ DHCPD.prototype.handleMessage = function (msg, peer) {
 
             log.info('Reply sent');
         });
-    });
+    };
+    /*
+     * Booter handles only two types of DHCP messages: DHCPDISCOVER and
+     * DHCPREQUEST (coming in that order).  On the initial DHCPDISCOVER,
+     * external services (e.g. napi & cnapi) are consulted and boot files
+     * written out.  On the followup DHCPREQUEST, the local cache is used
+     * instead of consulting external servies.
+     */
+    if (msgType === 'DHCPDISCOVER') {
+        mod_boot_files.writeAll({
+            cnapi: self.cnapi,
+            config: self.config,
+            log: log,
+            mac: mac,
+            napi: self.napi
+        }, function _afterParams(pErr, params) {
+            if (pErr) {
+                log.error(pErr, 'error writing param files');
+                return;
+            }
+            _sendReplyWithParams(params);
+        });
+    } else {
+        mod_bootparams.getFromCache({
+            dir: self.config.cache.dir,
+            log: log,
+            mac: mac
+        }, function _afterCache(err, params) {
+            if (err) {
+                log.error(err, 'unable to get params from cache');
+                return;
+            }
+            _sendReplyWithParams(params);
+        });
+    }
 };
 
 
diff --git a/package.json b/package.json
index 2077e73..06eff60 100644
--- a/package.json
+++ b/package.json
@@ -15,7 +15,8 @@
     "sdc-clients": "10.3.0",
     "sdc-bunyan-serializers": "git+https://github.com/joyent/sdc-bunyan-serializers.git#a3e7780",
     "sprintf": "0.1.0",
-    "vasync": "1.6.2"
+    "vasync": "1.6.2",
+    "verror":  "1.10.0"
   },
   "devDependencies": {
     "clone": "0.1.4",
diff --git a/sapi_manifests/dhcpd/template b/sapi_manifests/dhcpd/template
index 8ada40f..3cd9c67 100644
--- a/sapi_manifests/dhcpd/template
+++ b/sapi_manifests/dhcpd/template
@@ -32,6 +32,13 @@
   "serverIp": "{{{dhcpd_admin_ip}}}",
   "leaseTime": {{{dhcp_lease_time}}},
   "resolvers": {{{resolvers}}}{{^resolvers}}[]{{/resolvers}},
-  "netmask": "{{{admin_netmask}}}"{{#allow_missing_class_id}},
-  "allowMissingClassID": true{{/allow_missing_class_id}}
+  "netmask": "{{{admin_netmask}}}",
+  {{#allow_missing_class_id}}"allowMissingClassID": true,{{/allow_missing_class_id}}
+  "cache": {
+    "dir": "/tftpboot/cache",
+    "refreshIntervalSeconds": 300,
+    "purgeIntervalSeconds": 3600,
+    "maxCacheFileAgeSeconds": 604800,
+    "refreshConcurrency": 16
+  }
 }
diff --git a/test/lib/mocks.js b/test/lib/mocks.js
index 0166a3c..fb79211 100644
--- a/test/lib/mocks.js
+++ b/test/lib/mocks.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -319,13 +319,16 @@ function registerMocks() {
         'vasync',
         'verror',
         '../../lib/boot-files',
+        '../../lib/cache',
         '../../lib/dhcpd',
         '../lib/bootparams',
+        '../lib/cache',
         '../lib/dhcpd',
         '../lib/menulst',
         './bootparams',
         './boot-files',
         './clients',
+        './cache',
         './dhcp',
         './find',
         './json-file',
diff --git a/test/lib/server.js b/test/lib/server.js
index 45631ee..16b79ae 100644
--- a/test/lib/server.js
+++ b/test/lib/server.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -90,7 +90,16 @@ function serverConfig() {
         port: 10067,
         resolvers: [],
         serverIp: '10.99.99.9',
-        tftpRoot: '/tmp/tftpRoot'
+        tftpRoot: '/tmp/tftpRoot',
+        // For testing of other server components, intervals set to a high value
+        // that will not fire during a unit test run of any reasonable length.
+        cache: {
+            dir: '/tmp/tftpRoot/cache',
+            refreshIntervalSeconds: 3000,
+            purgeIntervalSeconds: 36000,
+            maxCacheFileAgeSeconds: 604800,
+            refreshConcurrency: 1
+        }
     };
 }
 
-- 
2.21.0

