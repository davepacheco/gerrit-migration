From 7ee0b1f56fd382069b6451bf6c93d430f9fe6dbf Mon Sep 17 00:00:00 2001
From: Sam Gwydir <sam@samgwydir.com>
Date: Mon, 23 Oct 2017 11:05:42 -0700
Subject: [PATCH] MORAY-424 Add new option for indexes to allow disabling
 Postgres index

---
 test/buckets.test.js         | 150 ++++++++++++++++++++++++++++++++++-
 test/invalid-buckets.test.js |  12 +++
 2 files changed, 159 insertions(+), 3 deletions(-)

diff --git a/test/buckets.test.js b/test/buckets.test.js
index d91666d..db1f41a 100644
--- a/test/buckets.test.js
+++ b/test/buckets.test.js
@@ -8,6 +8,7 @@
  * Copyright 2017, Joyent, Inc.
  */
 
+var util = require('util');
 var jsprim = require('jsprim');
 var tape = require('tape');
 var uuid = require('libuuid').create;
@@ -815,6 +816,150 @@ test('update bucket (bucket not found)', function (t) {
     });
 });
 
+// Use moray's sql method to ask for index from postgres
+test('update bucket (pgIndexDisabled: undefined -> false)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+    cfg.index.foo = {
+        type: 'string',
+        unique: false
+    };
+    c.createBucket(b, cfg, function (err) {
+        t.ifError(err);
+        cfg.index.foo = {
+            type: 'string',
+            unique: false,
+            pgIndexDisabled: false
+        };
+        cfg.post.push(function two(req, cb) {
+            cb();
+        });
+        c.updateBucket(b, cfg, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                var count = 0;
+                var res = c.sql('SELECT indexname FROM pg_indexes where ' +
+                    'indexname LIKE \'' + b + '_foo_idx\';');
+                res.on('record', function (r) {
+                    count += 1;
+                });
+                res.on('end', function () {
+                    t.equal(count, 1, 'one rows returned');
+                });
+                t.end();
+            });
+        });
+    });
+});
+
+test('update bucket (pgIndexDisabled: undefined -> true)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+    cfg.index.bar = {
+        type: 'string',
+        unique: false
+    };
+    c.createBucket(b, cfg, function (err) {
+        t.ifError(err);
+        cfg.index.bar = {
+            type: 'string',
+            unique: false,
+            pgIndexDisabled: true
+        };
+        cfg.post.push(function two(req, cb) {
+            cb();
+        });
+        c.updateBucket(b, cfg, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                var count = 0;
+                var res = c.sql('SELECT indexname FROM pg_indexes where ' +
+                    'indexname LIKE \'' + b + '_bar_idx\';');
+                res.on('record', function (r) {
+                    count += 1;
+                });
+                res.on('end', function () {
+                    t.equal(count, 0, 'zero rows returned');
+                });
+                t.end();
+            });
+        });
+    });
+});
+
+test('update bucket (pgIndexDisabled: false -> true)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+    cfg.index.baz = {
+        type: 'string',
+        unique: false,
+        pgIndexDisabled: false
+    };
+    c.createBucket(b, cfg, function (err) {
+        t.ifError(err);
+        cfg.index.baz = {
+            type: 'string',
+            unique: false,
+            pgIndexDisabled: true
+        };
+        cfg.post.push(function two(req, cb) {
+            cb();
+        });
+        c.updateBucket(b, cfg, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                var count = 0;
+                var res = c.sql('SELECT indexname FROM pg_indexes where ' +
+                    'indexname LIKE \'' + b + '_baz_idx\';');
+                res.on('record', function (r) {
+                    count += 1;
+                });
+                res.on('end', function () {
+                    t.equal(count, 0, 'zero rows returned');
+                });
+                t.end();
+            });
+        });
+    });
+});
+
+// Use moray's sql method to ask for index from postgres
+test('update bucket (pgIndexDisabled: true -> false)', function (t) {
+    var cfg = jsprim.deepCopy(FULL_CFG);
+    cfg.index.bee = {
+        type: 'string',
+        unique: false,
+        pgIndexDisabled: true
+    };
+    c.createBucket(b, cfg, function (err) {
+        t.ifError(err);
+        cfg.index.bee = {
+            type: 'string',
+            unique: false,
+            pgIndexDisabled: false
+        };
+        cfg.post.push(function two(req, cb) {
+            cb();
+        });
+        c.updateBucket(b, cfg, function (err2) {
+            t.ifError(err2);
+            c.getBucket(b, function (err3, bucket) {
+                t.ifError(err3);
+                var count = 0;
+                var res = c.sql('SELECT indexname FROM pg_indexes where ' +
+                    'indexname LIKE \'' + b + '_bee_idx\';');
+                res.on('record', function (r) {
+                    count += 1;
+                });
+                res.on('end', function () {
+                    t.equal(count, 1, 'one row returned');
+                });
+                t.end();
+            });
+        });
+    });
+});
+
 
 test('create bucket bad index type', function (t) {
     c.createBucket(b, {index: {foo: 'foo'}}, function (err) {
@@ -895,7 +1040,7 @@ test('good index names', function (t) {
         'version', 'worker',
 
         // Single letter
-        'a', 'b', 'v', 'A', 'Z', 'V'
+        'a', 'b', 'v'
     ];
 
     t.test('create bucket', function (t2) {
@@ -905,12 +1050,11 @@ test('good index names', function (t) {
         });
     });
 
-
+    var schema = { index: {} };
     t.test('update bucket w/ different index names', function (t2) {
         vasync.forEachPipeline({
             inputs: names,
             func: function checkIndexName(name, cb) {
-                var schema = { index: {} };
                 schema.index[name] = { type: 'string' };
                 c.updateBucket(b, schema, function (err) {
                     t2.ifError(err, JSON.stringify(name) + ' should be okay');
diff --git a/test/invalid-buckets.test.js b/test/invalid-buckets.test.js
index 4343cc1..b341a7e 100644
--- a/test/invalid-buckets.test.js
+++ b/test/invalid-buckets.test.js
@@ -171,6 +171,18 @@ var BAD_BUCKETS = [
         errname: 'InvalidBucketConfigError',
         errmsg: 'bucket.index[\'foo\'].unique should be boolean'
     },
+    {
+        config: {
+            index: {
+                foo: {
+                    type: 'string',
+                    pgIndexDisabled: 'yes'
+                }
+            }
+        },
+        errname: 'InvalidBucketConfigError',
+        errmsg: 'bucket.index[\'foo\'].pgIndexDisabled should be boolean'
+    },
     {
         config: {
             index: {
-- 
2.21.0

