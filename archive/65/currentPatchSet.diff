commit 3771c6fbd979ad41e7a71b19f9e2b7ff99542134 (refs/changes/65/65/3)
Author: Joshua M. Clulow <jmc@joyent.com>
Date:   2016-07-15T06:39:02+00:00 (3 years, 3 months ago)
    
    MANATEE-310 manatee should not use pfexec (no-op) for zfs commands
    Reviewed by: Dave Pacheco <dap@joyent.com>

diff --git a/lib/postgresMgr.js b/lib/postgresMgr.js
index 09748df..dc7ecc4 100644
--- a/lib/postgresMgr.js
+++ b/lib/postgresMgr.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /**
@@ -790,7 +790,7 @@ PostgresMgr.prototype._primary = function _primary(stdby, callback) {
             self._restart(cb);
         },
         function _snapshot(_, cb) {
-            self._snapShotter.createSnapshot(Date.now(), cb);
+            self._snapShotter.createSnapshot(String(Date.now()), cb);
         },
         function _startReplCheck(_, cb) {
             if (!stdby) {
diff --git a/lib/snapShotter.js b/lib/snapShotter.js
index bad3147..88d3bae 100644
--- a/lib/snapShotter.js
+++ b/lib/snapShotter.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /**
@@ -22,12 +22,18 @@
  */
 var assert = require('assert-plus');
 var EventEmitter = require('events').EventEmitter;
-var exec = require('child_process').exec;
+var forkexec = require('forkexec');
 var once = require('once');
 var restify = require('restify');
 var util = require('util');
 var vasync = require('vasync');
-var verror = require('verror');
+
+/*
+ * For determining if a ZFS snapshot name is at least somewhat well-formed.
+ * Can also be used to break a snapshot, e.g. "data/set@snapname" into
+ * "data/set" and "snapname" components.
+ */
+var RE_SNAPSHOT = new RegExp('^([^@]+)@([^@]+)$');
 
 /**
  * Takes periodic zfs snapshots of a pg data dir.
@@ -67,6 +73,12 @@ function SnapShotter(options) {
 
     this._log = options.log;
 
+    /*
+     * This number is used to correlate the "begin" and "end" messages for
+     * particular invocations of zfs(1M) in trace log messages.
+     */
+    this._zfsRuns = 0;
+
     /** @type {number} The snapshot period in ms */
     this._pollInterval = options.pollInterval || 1 * 1000;
 
@@ -129,7 +141,7 @@ SnapShotter.prototype.start = function start(callback) {
                 if (skipSnapshot) {
                     return (cb());
                 }
-                self.createSnapshot(Date.now(), cb);
+                self.createSnapshot(String(Date.now()), cb);
             }
         ], 'arg': {}}, function (err) {
             if (err) {
@@ -153,38 +165,72 @@ SnapShotter.prototype.start = function start(callback) {
         log.info('cleaning up snapshots');
         vasync.pipeline({funcs: [
             function _getSnapshots(_, cb) {
+                assert.string(self._dataset, 'self._dataset');
+                assert.ok(!RE_SNAPSHOT.test(self._dataset), self._dataset +
+                    ' should not be a snapshot');
+
                 /*
-                 * get the snapshot and sort ascending by name. This guarantees
-                 * the earliest snapshot is on top.
-                 */
-                var cmd = 'zfs list -t snapshot -H -d 1 -s name -o name ' +
-                    self._dataset;
-                exec(cmd, function (err, stdout, stderr) {
-                    log.debug({snapshots: stdout}, 'got snapshots');
-                    _.snapshots = stdout.split('\n');
-                    return cb(err);
-                });
-            },
-            function _stripSnapshots(_, cb) {
-                /*
-                 * MANATEE-214 A snapshot name is just time since epoch in ms.
-                 * So it's a 13 digit number like 1405378955344. We only want
-                 * snapshots that look like this to avoid using other snapshots
-                 * as they may have been created by an operator.
+                 * List snapshots sorted by creation time in ascending order.
+                 * This makes the oldest snapshot appear first in the list.
                  */
-                var regex = /^\d{13}$/;
-                var snaps = [];
-                for (var i = 0; i < _.snapshots.length; i++) {
-                    var snapshot = _.snapshots[i].split('@')[1];
-                    // only push snapshots that we created.
-                    if (regex.test(snapshot) === true) {
-                        snaps.push(_.snapshots[i]);
+                self._execZfs({
+                    label: 'list snapshots for cleanup',
+                    args: [
+                        'list',
+                        '-t', 'snapshot',
+                        '-H',
+                        '-d', '1',
+                        '-s', 'creation',
+                        '-o', 'name',
+                        self._dataset
+                    ]
+                }, function (err, info) {
+                    if (err) {
+                        log.error({
+                            err: err,
+                            duration_ms: info.duration_ms
+                        }, 'failure to list snapshots for cleanup');
+                        cb(err);
+                        return;
                     }
-                }
 
-                _.snapshots = snaps;
+                    /*
+                     * Snapshots created by Manatee are named for their
+                     * creation time, expressed as the number of milliseconds
+                     * since the UNIX epoch.  Filter out any snapshots that do
+                     * not match this pattern, as they were likely created by
+                     * the operator or another tool.
+                     */
+                    var ignored = 0;
+                    _.snapshots = info.stdout.split('\n').filter(function (l) {
+                        var t = RE_SNAPSHOT.exec(l);
+
+                        if (!t) {
+                            return (false);
+                        }
+
+                        if (!t[2].match(/^\d{13}$/)) {
+                            /*
+                             * This line describes a well-formed snapshot,
+                             * but the snapshot name does not match our
+                             * expected format.
+                             */
+                            ignored++;
+                            return (false);
+                        }
+
+                        return (true);
+                    });
 
-                return cb();
+                    log.info({
+                        duration_ms: info.duration_ms,
+                        snapshots_count: _.snapshots.length,
+                        snapshots_ignored: ignored
+                    }, 'cleanup: found %d snapshots, ignored %d snapshots',
+                        _.snapshots.length, ignored);
+
+                    cb();
+                });
             },
             function _deleteSnapshots(_, cb) {
                 cb = once(cb);
@@ -251,18 +297,27 @@ SnapShotter.prototype.start = function start(callback) {
  */
 SnapShotter.prototype.createSnapshot = function createSnapshot(name, callback) {
     var self = this;
+
+    assert.string(name, 'name');
+    assert.string(self._dataset, 'self._dataset');
+    assert.func(callback, 'callback');
+
     var snapshot = self._dataset + '@' + name;
-    var log = self._log;
-    log.info({
+    var log = self._log.child({
         snapshot: snapshot
-    }, 'creating snapshot');
+    });
+
+    log.info('creating ZFS snapshot');
+
     self._writeSnapshot(snapshot, function (err) {
         if (err) {
-            log.warn({err: err}, 'error while creating snapshot');
+            log.warn(err, 'error while creating ZFS snapshot');
+        } else {
+            log.info('ZFS snapshot created');
         }
 
         // ignore all errors and try again later.
-        return callback();
+        callback();
     });
 };
 
@@ -278,24 +333,30 @@ SnapShotter.prototype.createSnapshot = function createSnapshot(name, callback) {
  */
 SnapShotter.prototype._writeSnapshot = function (snapshot, callback) {
     var self = this;
-    var log = self._log;
-    var cmd = 'pfexec zfs snapshot ' + snapshot;
-    log.info({
-        snapshot: snapshot,
-        cmd: cmd
-    }, 'SnapShotter.writeSnapshot: entering');
 
-    exec(cmd, function (err) {
-        if (err) {
-            err = new verror.VError(err);
-        }
+    assert.string(snapshot, 'snapshot');
+    assert.ok(RE_SNAPSHOT.test(snapshot), 'invalid snapshot: ' + snapshot);
+    assert.func(callback, 'callback');
+
+    var log = self._log.child({
+        snapshot: snapshot
+    });
+
+    log.info('SnapShotter.writeSnapshot: entering');
 
+    self._execZfs({
+        label: 'write snapshot',
+        args: [
+            'snapshot',
+            snapshot
+        ]
+    }, function (err, info) {
         log.info({
             err: err,
-            snapshot: snapshot
+            duration_ms: info.duration_ms
         }, 'SnapShotter.writeSnapshot: exiting');
 
-        return callback(err);
+        callback(err);
     });
 };
 
@@ -305,24 +366,96 @@ SnapShotter.prototype._writeSnapshot = function (snapshot, callback) {
  */
 SnapShotter.prototype._deleteSnapshot = function (snapshot, callback) {
     var self = this;
-    var log = self._log;
-    var cmd = 'pfexec zfs destroy ' + snapshot;
-    log.info({
-        snapshot: snapshot,
-        cmd: cmd
-    }, 'SnapShotter._deleteSnapshot: entering');
 
-    exec(cmd, function (err) {
-        if (err) {
-            err = new verror.VError(err);
-        }
+    assert.string(snapshot, 'snapshot');
+    assert.ok(RE_SNAPSHOT.test(snapshot), 'invalid snapshot: ' + snapshot);
+    assert.func(callback, 'callback');
 
+    var log = self._log.child({
+        snapshot: snapshot
+    });
+
+    log.info('SnapShotter._deleteSnapshot: entering');
+
+    self._execZfs({
+        label: 'delete snapshot',
+        args: [
+            'destroy',
+            snapshot
+        ]
+    }, function (err, info) {
         log.info({
             err: err,
-            snapshot: snapshot
+            duration_ms: info.duration_ms
         }, 'SnapShotter._deleteSnapshot: exiting');
 
-        return callback(err, snapshot);
+        callback(err, snapshot);
+    });
+};
+
+/*
+ * Run a "zfs" command, reporting the start and end, and the resultant output,
+ * at the TRACE level in the log.
+ *
+ * The "label" property of the options object should be a string that reflects
+ * the reason we are running this command, and the "args" array should be the
+ * arguments to "zfs".
+ *
+ * The callback will be called with the following two arguments:
+ *
+ *   error:
+ *     A VError object if execution was not successful, or null
+ *     for successful executions.
+ *
+ *   info:
+ *     The "info" object returned by forkExecWait(), augmented with
+ *     the property "duration_ms": the total execution time as a number
+ *     of milliseconds.  The most useful property of this object is
+ *     the string-valued property "stdout", containing the result of
+ *     a successful process execution.
+ *
+ */
+SnapShotter.prototype._execZfs = function (opts, callback) {
+    var self = this;
+
+    assert.object(opts, 'opts');
+    assert.string(opts.label, 'opts.label');
+    assert.arrayOfString(opts.args, 'opts.args');
+
+    assert.number(self._zfsRuns);
+    var log = self._log.child({
+        zfs_run: ++self._zfsRuns,
+        zfs_label: opts.label,
+        zfs_args: opts.args
+    });
+
+    log.trace('_execZfs: start zfs command');
+    var begin = process.hrtime();
+
+    forkexec.forkExecWait({
+        argv: [
+            '/sbin/zfs'
+        ].concat(opts.args),
+        includeStderr: true
+    }, function (err, info) {
+        var dur = process.hrtime(begin);
+
+        if (!info) {
+            info = {};
+        }
+        info.duration_ms = Math.round(dur[0] * 1000 + dur[1] / 1000000);
+
+        log.trace({
+            err: err,
+            zfs_info: info
+        }, '_execZfs: end zfs command');
+
+        /*
+         * Note that "forkexec" already adorns the error object with a
+         * reasonably complete message about the exact failure, including the
+         * stderr output if there was any.
+         */
+        callback(err, info);
     });
 };
 
diff --git a/package.json b/package.json
index c49f7d2..43dee53 100644
--- a/package.json
+++ b/package.json
@@ -26,7 +26,7 @@
         "cmdln": "3.2.0",
         "extsprintf": "1.3.0",
         "iniparser": "1.0.5",
-        "forkexec": "0.1.0",
+        "forkexec": "1.1.0",
         "manatee-state-machine": "git://github.com/joyent/manatee-state-machine#master",
         "manta": "1.2.6",
         "node-uuid": "1.4.1",
