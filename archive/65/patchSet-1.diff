From 3ebf68d33116401f9ea75cadd53dd30ba64f0c95 Mon Sep 17 00:00:00 2001
From: "Joshua M. Clulow" <jmc@joyent.com>
Date: Wed, 13 Jul 2016 02:51:04 +0000
Subject: [PATCH] MANATEE-310 manatee should not use pfexec (no-op) for zfs
 commands

---
 lib/snapShotter.js | 245 ++++++++++++++++++++++++++++++++-------------
 1 file changed, 176 insertions(+), 69 deletions(-)

diff --git a/lib/snapShotter.js b/lib/snapShotter.js
index bad3147..d2a8d26 100644
--- a/lib/snapShotter.js
+++ b/lib/snapShotter.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /**
@@ -20,14 +20,21 @@
  *                           (_/
  *
  */
-var assert = require('assert-plus');
+var mod_assert = require('assert-plus');
 var EventEmitter = require('events').EventEmitter;
-var exec = require('child_process').exec;
+var mod_child = require('child_process');
 var once = require('once');
 var restify = require('restify');
 var util = require('util');
 var vasync = require('vasync');
-var verror = require('verror');
+var mod_verror = require('verror');
+
+/*
+ * For determining if a ZFS snapshot name is at least somewhat well-formed.
+ * Can also be used to break a snapshot, e.g. "data/set@snapname" into
+ * "data/set" and "snapname" components.
+ */
+var RE_SNAPSHOT = new RegExp('^([^@]+)@([^@]+)$');
 
 /**
  * Takes periodic zfs snapshots of a pg data dir.
@@ -53,13 +60,13 @@ var verror = require('verror');
  * @throws {Error} If the options object is malformed.
  */
 function SnapShotter(options) {
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
+    mod_assert.object(options, 'options');
+    mod_assert.object(options.log, 'options.log');
 
-    assert.string(options.dataset, 'options.dataset');
-    assert.optionalNumber(options.pollInterval, 'options.pollInterval');
-    assert.optionalNumber(options.snapshotNumber, 'options.snapshotNumber');
-    assert.optionalString(options.healthUrl, 'options.healthUrl');
+    mod_assert.string(options.dataset, 'options.dataset');
+    mod_assert.optionalNumber(options.pollInterval, 'options.pollInterval');
+    mod_assert.optionalNumber(options.snapshotNumber, 'options.snapshotNumber');
+    mod_assert.optionalString(options.healthUrl, 'options.healthUrl');
 
     EventEmitter.call(this);
 
@@ -67,6 +74,12 @@ function SnapShotter(options) {
 
     this._log = options.log;
 
+    /*
+     * This number is used to correlate the "begin" and "end" messages for
+     * particular invocations of zfs(1M) in trace log messages.
+     */
+    this._zfsRuns = 0;
+
     /** @type {number} The snapshot period in ms */
     this._pollInterval = options.pollInterval || 1 * 1000;
 
@@ -153,38 +166,50 @@ SnapShotter.prototype.start = function start(callback) {
         log.info('cleaning up snapshots');
         vasync.pipeline({funcs: [
             function _getSnapshots(_, cb) {
+                mod_assert.string(self._dataset, 'self._dataset');
+                mod_assert.ok(!RE_SNAPSHOT.test(self._dataset), self._dataset +
+                    ' should not be a snapshot');
+
                 /*
-                 * get the snapshot and sort ascending by name. This guarantees
-                 * the earliest snapshot is on top.
-                 */
-                var cmd = 'zfs list -t snapshot -H -d 1 -s name -o name ' +
-                    self._dataset;
-                exec(cmd, function (err, stdout, stderr) {
-                    log.debug({snapshots: stdout}, 'got snapshots');
-                    _.snapshots = stdout.split('\n');
-                    return cb(err);
-                });
-            },
-            function _stripSnapshots(_, cb) {
-                /*
-                 * MANATEE-214 A snapshot name is just time since epoch in ms.
-                 * So it's a 13 digit number like 1405378955344. We only want
-                 * snapshots that look like this to avoid using other snapshots
-                 * as they may have been created by an operator.
+                 * List snapshots sorted by creation time in ascending order.
+                 * This makes the oldest snapshot appear first in the list.
                  */
-                var regex = /^\d{13}$/;
-                var snaps = [];
-                for (var i = 0; i < _.snapshots.length; i++) {
-                    var snapshot = _.snapshots[i].split('@')[1];
-                    // only push snapshots that we created.
-                    if (regex.test(snapshot) === true) {
-                        snaps.push(_.snapshots[i]);
+                self._execZfs({
+                    info: 'list snapshots for cleanup',
+                    args: [
+                        'list',
+                        '-t', 'snapshot',
+                        '-H',
+                        '-d', '1',
+                        '-s', 'creation',
+                        '-o', 'name',
+                        self._dataset
+                    ]
+                }, function (err, stdout, stderr) {
+                    if (err) {
+                        log.error(err, 'failure to list snapshots for cleanup');
+                        cb(err);
+                        return;
                     }
-                }
 
-                _.snapshots = snaps;
-
-                return cb();
+                    /*
+                     * Snapshots created by Manatee are named for their
+                     * creation time, expressed as the number of milliseconds
+                     * since the UNIX epoch.  Filter out any snapshots that do
+                     * not match this pattern, as they were likely created by
+                     * the operator or another tool.
+                     */
+                    _.snapshots = stdout.split('\n').filter(function (snap) {
+                        var t = RE_SNAPSHOT.exec(snap);
+
+                        if (t && t[2].match(/^\d{13}$/)) {
+                            return (true);
+                        }
+
+                        return (false);
+                    });
+                    cb();
+                });
             },
             function _deleteSnapshots(_, cb) {
                 cb = once(cb);
@@ -251,18 +276,27 @@ SnapShotter.prototype.start = function start(callback) {
  */
 SnapShotter.prototype.createSnapshot = function createSnapshot(name, callback) {
     var self = this;
+
+    mod_assert.string(name, 'name');
+    mod_assert.string(self._dataset, 'self._dataset');
+    mod_assert.func(callback, 'callback');
+
     var snapshot = self._dataset + '@' + name;
-    var log = self._log;
-    log.info({
+    var log = self._log.child({
         snapshot: snapshot
-    }, 'creating snapshot');
+    });
+
+    log.info('creating ZFS snapshot');
+
     self._writeSnapshot(snapshot, function (err) {
         if (err) {
-            log.warn({err: err}, 'error while creating snapshot');
+            log.warn(err, 'error while creating ZFS snapshot');
+        } else {
+            log.info('ZFS snapshot created');
         }
 
         // ignore all errors and try again later.
-        return callback();
+        callback();
     });
 };
 
@@ -278,24 +312,29 @@ SnapShotter.prototype.createSnapshot = function createSnapshot(name, callback) {
  */
 SnapShotter.prototype._writeSnapshot = function (snapshot, callback) {
     var self = this;
-    var log = self._log;
-    var cmd = 'pfexec zfs snapshot ' + snapshot;
-    log.info({
-        snapshot: snapshot,
-        cmd: cmd
-    }, 'SnapShotter.writeSnapshot: entering');
 
-    exec(cmd, function (err) {
-        if (err) {
-            err = new verror.VError(err);
-        }
+    mod_assert.string(snapshot, 'snapshot');
+    mod_assert.ok(RE_SNAPSHOT.test(snapshot), 'invalid snapshot: ' + snapshot);
+    mod_assert.func(callback, 'callback');
+
+    var log = self._log.child({
+        snapshot: snapshot
+    });
 
+    log.info('SnapShotter.writeSnapshot: entering');
+
+    self._execZfs({
+        info: 'write snapshot',
+        args: [
+            'snapshot',
+            snapshot
+        ]
+    }, function (err) {
         log.info({
-            err: err,
-            snapshot: snapshot
+            err: err
         }, 'SnapShotter.writeSnapshot: exiting');
 
-        return callback(err);
+        callback(err);
     });
 };
 
@@ -305,24 +344,92 @@ SnapShotter.prototype._writeSnapshot = function (snapshot, callback) {
  */
 SnapShotter.prototype._deleteSnapshot = function (snapshot, callback) {
     var self = this;
-    var log = self._log;
-    var cmd = 'pfexec zfs destroy ' + snapshot;
-    log.info({
-        snapshot: snapshot,
-        cmd: cmd
-    }, 'SnapShotter._deleteSnapshot: entering');
 
-    exec(cmd, function (err) {
-        if (err) {
-            err = new verror.VError(err);
-        }
+    mod_assert.string(snapshot, 'snapshot');
+    mod_assert.ok(RE_SNAPSHOT.test(snapshot), 'invalid snapshot: ' + snapshot);
+    mod_assert.func(callback, 'callback');
 
+    var log = self._log.child({
+        snapshot: snapshot
+    });
+
+    log.info('SnapShotter._deleteSnapshot: entering');
+
+    self._execZfs({
+        info: 'delete snapshot',
+        args: [
+            'destroy',
+            snapshot
+        ]
+    }, function (err) {
         log.info({
-            err: err,
-            snapshot: snapshot
+            err: err
         }, 'SnapShotter._deleteSnapshot: exiting');
 
-        return callback(err, snapshot);
+        callback(err, snapshot);
+    });
+};
+
+/*
+ * Run a "zfs" command, reporting the start and end, and the resultant output,
+ * at the TRACE level in the log.
+ *
+ * The "info" property of the options object should be a string that reflects
+ * the reason we are running this command, and the "args" array should be the
+ * arguments to "zfs".
+ *
+ * The callback will be called with the usual arguments to the
+ * "child_process.execFile()" library routine.
+ */
+SnapShotter.prototype._execZfs = function (opts, callback) {
+    var self = this;
+
+    mod_assert.object(opts, 'opts');
+    mod_assert.string(opts.info, 'opts.info');
+    mod_assert.arrayOfString(opts.args, 'opts.args');
+
+    mod_assert.number(self._zfsRuns);
+    var log = self._log.child({
+        zfs_run: ++self._zfsRuns,
+        zfs_info: opts.info,
+        zfs_args: opts.args
+    });
+
+    log.trace('_execZfs: start zfs command');
+    var begin = process.hrtime();
+    mod_child.execFile('/sbin/zfs', opts.args, function (err, stdout, stderr) {
+        var dur = process.hrtime(begin);
+
+        log.trace({
+            err: err,
+            zfs_code: err ? err.code : 0,
+            zfs_signal: err ? err.signal : null,
+            zfs_stdout: stdout,
+            zfs_stderr: stderr,
+            zfs_duration_ms: Math.round(dur[0] * 1000 + dur[1] / 1000000)
+        }, '_execZfs: end zfs command');
+
+        if (err) {
+            var msg = 'could not run zfs(1M)';
+
+            if (typeof (err.code) === 'number') {
+                /*
+                 * If "code" is a number, the command exited normally.  Try
+                 * to present an error message that includes the stderr
+                 * output from the "zfs" command itself:
+                 */
+                msg = 'zfs(1M) failed';
+                if (stderr.trim()) {
+                    msg += ': ' + stderr.trim();
+                }
+            }
+
+            err = new mod_verror.VError(err, msg);
+            err.stdout = stdout;
+            err.stderr = stderr;
+        }
+
+        callback(err, stdout, stderr);
     });
 };
 
-- 
2.21.0

