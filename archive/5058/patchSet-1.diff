From 455d7cd9f8424dd437f35d121ac6412e284eab16 Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Tue, 6 Nov 2018 20:26:25 +0000
Subject: [PATCH] OS-7353 bhyve support for persistent pci slots for disks
 OS-7004 support adding new disks to bhyve VMs via 'vmadm update'

---
 src/Makefile                        |   1 +
 src/vm/node_modules/VM.js           | 157 +++++++++-
 src/vm/node_modules/proptable.js    |   9 +
 src/vm/tests/test-bhyve-pci.js      |   2 +-
 src/vm/tests/test-bhyve-pci_slot.js | 441 ++++++++++++++++++++++++++++
 5 files changed, 593 insertions(+), 17 deletions(-)
 create mode 100644 src/vm/tests/test-bhyve-pci_slot.js

diff --git a/src/Makefile b/src/Makefile
index f402ccd5..b54ee74f 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -126,6 +126,7 @@ JS_CHECK_TARGETS=\
 	vm/tests/test-sysinfo.js \
 	vm/tests/test-tmpfs.js \
 	vm/tests/test-update.js \
+	vm/tests/test-bhyve-pci_slot.js \
 	vm/tests/test-vrrp-nics.js \
 	vm/tests/test-vminfod.js \
 	vm/tests/test-vminfod-zonewatcher.js \
diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 710ce962..fb997762 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -1299,16 +1299,8 @@ exports.validate = function (brand, action, payload, options, callback)
 
                 if (!dev.hasOwnProperty('pci_slot')) {
                     errors.missing_properties.push(prop_prefix + '.pci_slot');
-                } else {
-                    var a = dev.pci_slot.split(':');
-                    if (a.length < 1 || a.length > 3
-                        || isNaN(a[0]) || a[0] < 0 || a[0] > 255
-                        || (a.length > 1
-                        && (isNaN(a[1]) || a[1] < 0 || a[1] > 31))
-                        || (a.length > 2
-                        && (isNaN(a[2]) || a[2] < 0 || a[2] > 7))) {
-                        errors.bad_values.push(prop_prefix + '.pci_slot');
-                    }
+                } else if (util.isError(parse_pci_slot(dev.pci_slot))) {
+                    errors.bad_values.push(prop_prefix + '.pci_slot');
                 }
 
                 if (dev.hasOwnProperty('model') && dev.model !== 'passthru') {
@@ -4848,6 +4840,10 @@ function checkPayloadProperties(payload, vmobj, log, callback)
 
                     while ((keys.length > 0) && live_ok) {
                         key = keys.pop();
+                        if (key === 'pci_slot'
+                            && vmobj.state === 'provisioning') {
+                            continue;
+                        }
                         if ([
                             'compression',
                             'path',
@@ -5843,6 +5839,11 @@ function buildDiskZonecfg(vmobj, payload)
                 + disk.image_name + '")\n';
         }
 
+        if (disk.hasOwnProperty('pci_slot')) {
+            zcfg = zcfg + 'add property (name=pci-slot, value="'
+                + disk.pci_slot + '")\n';
+        }
+
         zcfg = zcfg + 'end\n';
     }
 
@@ -6621,6 +6622,7 @@ function buildZonecfgUpdate(vmobj, payload, log)
         payload.zlog_name = 'platform.log';
         setAttr('zlog-mode', 'zlog_mode');
         setAttr('zlog-name', 'zlog_name');
+
     }
 
     // NOTE: Thanks to normalizePayload() we'll only have these when relevant
@@ -13737,6 +13739,83 @@ function setDockerRestartOpts(uuid, options, callback) {
     });
 }
 
+function fixBhyveDevs(opts, cb)
+{
+    var vmobj = opts.vmobj;
+    var log = opts.log;
+    var unassigned = [];
+    var updates = [];
+    var name2slot = {cdrom: 3, disk: 4};
+    var slots = {};
+
+    Object.keys(name2slot).forEach(function (name) {
+        slots[name2slot[name]] = {};
+    });
+
+    assert(vmobj.brand === 'bhyve');
+
+    vmobj.disks.forEach(function (dev) {
+        if (dev.hasOwnProperty('pci_slot')) {
+            var bsf = parse_pci_slot(dev.pci_slot);
+            if (util.isError(bsf)) {
+                cb(bsf);
+                return;
+            }
+            if (bsf.bus === 0 && slots.hasOwnProperty(bsf.slot)) {
+                if (slots[bsf.slot].hasOwnProperty(bsf.fn)) {
+                    var err = new Error('VM ' + vmobj.uuid
+                        + ' has multiple disks in pci_slot "' + dev.pci_slot
+                        + '": "' + slots[bsf.slot][bsf.fn].path
+                        + '" and "' + dev.path);
+                    log.error({err: err, vmobj: vmobj},
+                        'failed to assign PCI slots');
+                    cb(err);
+                    return;
+                }
+                slots[bsf.slot][bsf.fn] = dev;
+            }
+        } else {
+            unassigned.push(dev);
+        }
+    });
+
+    // Fill in the cdrom and disk slots' functions based on next available
+    unassigned.forEach(function (dev) {
+        var media = dev.media || 'disk';
+        var slot = name2slot[media];
+        var fn = 0;
+        var err;
+
+        if (slot === undefined) {
+            err = new Error('VM ' + vmobj.uuid
+                + ' has no PCI bus or slot assigned for ' + media
+                + ' devices; automatic pci_slot assignment not possible');
+            log.error({err: err, vmobj: vmobj}, 'failed to assign PCI slots');
+            cb(err);
+            return;
+        }
+        while (slots[slot].hasOwnProperty(fn)) {
+            fn += 1;
+        }
+        if (fn > 7) {
+            err = new Error('VM ' + vmobj.uuid + ' has more than 7 '
+                + media + ' devices');
+            log.error({err: err, vmobj: vmobj}, 'failed to assign PCI slots');
+            cb(err);
+            return;
+        }
+        slots[slot][fn] = dev;
+
+        updates.push({
+            path: dev.path,
+            pci_slot: '0:' + slot + ':' + fn
+        });
+    });
+    if (updates) {
+        VM.update(vmobj.uuid, {update_disks: updates}, {log: log}, cb);
+    }
+}
+
 exports.start = function (uuid, extra, options, callback)
 {
     var load_fields;
@@ -13834,7 +13913,7 @@ exports.start = function (uuid, extra, options, callback)
     log.info('Starting VM ' + uuid);
 
     async.series([
-        function (cb) {
+        function _loadVM(cb) {
             /*
              * If we're being called by something that just loaded the object,
              * we can use that instead of loading again ourselves.
@@ -13874,7 +13953,7 @@ exports.start = function (uuid, extra, options, callback)
                 vmobj = obj;
                 cb();
             });
-        }, function (cb) {
+        }, function _validateNicTags(cb) {
             validateNicTags(vmobj.nics, log, function (e) {
                 if (e) {
                     cb(e);
@@ -13882,7 +13961,7 @@ exports.start = function (uuid, extra, options, callback)
                 }
                 cb();
             });
-        }, function (cb) {
+        }, function _getDockerDeps(cb) {
             var im;
             var to_download = [];
 
@@ -13919,7 +13998,7 @@ exports.start = function (uuid, extra, options, callback)
                 cb();
                 return;
             }
-        }, function (cb) {
+        }, function _restartDocker(cb) {
             if (!vmobj.docker || !vmobj.zonepath) {
                 cb();
                 return;
@@ -13940,7 +14019,13 @@ exports.start = function (uuid, extra, options, callback)
                     value: 0
                 }, cb);
             }
-        }, function (cb) {
+        }, function _persistBhyveDevs(cb) {
+            if (vmobj.brand != 'bhyve') {
+                cb();
+                return;
+            }
+            fixBhyveDevs({vmobj: vmobj, log: log}, cb);
+        }, function _start(cb) {
             var err;
             var vm_type = BRAND_OPTIONS[vmobj.brand].features.type;
 
@@ -15928,7 +16013,13 @@ exports.update = function (uuid, payload, options, callback)
                 // use in createVolume()
                 if (vmobj.hasOwnProperty('disks')) {
                     for (n in vmobj.disks) {
-                        matches = vmobj.disks[n].path.match(/^.*-disk(\d+)$/);
+                        if (vmobj.brand === 'bhyve') {
+                            matches =
+                                vmobj.disks[n].path.match(/^.*\/disk(\d+)$/);
+                        } else {
+                            matches =
+                                vmobj.disks[n] .path.match(/^.*-disk(\d+)$/);
+                        }
                         if (matches) {
                             used_disk_indexes.push(Number(matches[1]));
                         }
@@ -17715,3 +17806,37 @@ function zoneConfigLockpath(uuid) {
 
     return sprintf('/var/run/vm.%s.config.lockfile', uuid);
 }
+
+/*
+ * Returns object with {bus, slot, fn} or an Error. slotstr is of the form
+ * bus:slot:fn, slot:fn, or slot.  If bus and/or fn are not specified, they will
+ * be returned as 0.
+ */
+function parse_pci_slot(slotstr) {
+    var bsf = slotstr.split(':');
+    var bus, slot, fn;
+
+    if (bsf.length == 1) {
+        bus = 0;
+        slot = parseInt(bsf[0], 10);
+        fn = 0;
+    } else if (bsf.length == 2) {
+        bus = 0;
+        slot = parseInt(bsf[0], 10);
+        fn = parseInt(bsf[1], 10);
+    } else if (bsf.length == 3) {
+        bus = parseInt(bsf[0], 10);
+        slot = parseInt(bsf[1], 10);
+        fn = parseInt(bsf[2], 10);
+    } else {
+        return new Error(sprintf('pci_slot "%s" is not valid', slotstr));
+    }
+
+    if (Number.isNaN(bus) || bus < 0 || bus > 255
+        || Number.isNaN(slot) || slot < 0 || slot > 31
+        || Number.isNaN(fn) || fn < 0 || fn > 7) {
+        return new Error(sprintf('pci_slot "%s" is not valid', slotstr));
+    }
+
+    return {bus: bus, slot: slot, fn: fn};
+}
diff --git a/src/vm/node_modules/proptable.js b/src/vm/node_modules/proptable.js
index d0865f2a..4b9786a0 100644
--- a/src/vm/node_modules/proptable.js
+++ b/src/vm/node_modules/proptable.js
@@ -655,6 +655,15 @@ exports.properties = {
             type: 'string'
         },
         zonexml: 'zone.device.match'
+    }, 'disks.*.pci_slot': {
+        payload: {
+            allowed: {
+                'bhyve': ['add', 'update']
+            },
+            type: 'string'
+        },
+        updatable: true,
+        zonexml: 'zone.device.net-attr.pci-slot'
     }, 'disks.*.refreservation': {
         payload: {
             allowed: {
diff --git a/src/vm/tests/test-bhyve-pci.js b/src/vm/tests/test-bhyve-pci.js
index 6f9aa445..55755c38 100644
--- a/src/vm/tests/test-bhyve-pci.js
+++ b/src/vm/tests/test-bhyve-pci.js
@@ -39,7 +39,7 @@ require('nodeunit-plus');
 VM.loglevel = 'DEBUG';
 
 var payload = {
-    alias: 'test-create-bhyve-' + process.pid,
+    alias: 'test-bhyve-pci-' + process.pid,
     autoboot: false,
     brand: 'bhyve',
     ram: "1024",
diff --git a/src/vm/tests/test-bhyve-pci_slot.js b/src/vm/tests/test-bhyve-pci_slot.js
new file mode 100644
index 00000000..ecc975ca
--- /dev/null
+++ b/src/vm/tests/test-bhyve-pci_slot.js
@@ -0,0 +1,441 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc.
+ *
+ */
+
+var async = require('/usr/node/node_modules/async');
+var assert = require('/usr/node/node_modules/assert-plus');
+var common = require('./common.js');
+var execFile = require('child_process').execFile;
+var fs = require('fs');
+var sprintf = require('/usr/node/node_modules/sprintf').sprintf;
+var VM = require('/usr/vm/node_modules/VM');
+var vmtest = require('../common/vmtest.js');
+
+// this puts test stuff in global, so we need to tell jsl about that:
+/* jsl:import ../node_modules/nodeunit-plus/index.js */
+require('nodeunit-plus');
+
+VM.loglevel = 'DEBUG';
+
+var afterVmobj = {};
+var beforeVmobj;
+var image_uuid = vmtest.CURRENT_BHYVE_CENTOS_UUID;
+
+var base_payload = {
+    alias: 'test-bhyve-pci_slot' + process.pid,
+    brand: 'bhyve',
+    do_not_inventory: true,
+    autoboot: false,
+    ram: 1024,
+    vcpus: 1,
+    disks: [
+        {
+            image_uuid: image_uuid,
+            boot: true,
+            model: 'virtio'
+        },
+        {
+            size: 512,
+            model: 'virtio'
+        }
+    ]
+};
+
+function dup(thing) {
+    return JSON.parse(JSON.stringify(thing));
+}
+
+/*
+ * Creates a VM using the specified payload and boots it so that any disks that
+ * do not have PCI slots assigned get persistent assignments.  If
+ * opts.expects_bsf is specified, an operator script is used to run lspci in the
+ * guest.  The virtio-blk devices in that output are compared to those in
+ * expect_bsf.  expect_bsf should not be used when adding a cdrom as the guest
+ * will end up at a UEFI shell and will never execute the operator script.
+ *
+ * opts.t           test object
+ * opts.payload     VM.create payload
+ * opts.disks       list of disks to compare to vmobj after booting
+ * opts.expect_bsf  list of 'b:s:f' (bus slot function) elements (decimal)
+ */
+function testCreateAndCheckDisks(opts) {
+    var t = opts.t;
+    var payload = opts.payload;
+    var expect_bsf = opts.expect_bsf;
+    var disks = opts.disks;
+    var update = opts.update;
+    var vmobj;
+    var lspci_md = 'lspci-output';
+    var guest_lspci = '#! /bin/bash\n'
+        + 'lspci -n -d 1af4:1001 | mdata-put ' + lspci_md + '\n'
+        + 'poweroff\n';
+
+    async.waterfall([
+        function _create(next) {
+            VM.create(payload, function _create_cb(err, obj) {
+                if (err) {
+                    t.ok(false, 'error creating VM: ' + err);
+                } else {
+                    t.ok(true, 'VM created with uuid ' + obj.uuid);
+                }
+                vmobj = obj;
+                next(err);
+            });
+        },
+        function _update(next) {
+            if (!update) {
+                t.ok(true, 'Skipping update - nothing to do');
+                next();
+                return;
+            }
+            VM.update(vmobj.uuid, update, function _update_cb(err) {
+                if (err) {
+                    t.ok(false, 'error updating VM: ' + err);
+                } else {
+                    t.ok(true, 'VM updated');
+                }
+                next(err);
+            });
+        },
+        function _add_operator_script(next) {
+            if (!expect_bsf) {
+                t.ok(true, 'Skipping guest PCI slot check');
+                next();
+                return;
+            }
+            var _payload = {
+                set_internal_metadata: {
+                    'operator-script': guest_lspci
+                }
+            };
+            VM.update(vmobj.uuid, _payload, function _update_cb(err) {
+                if (err) {
+                    t.ok(false, 'error updating VM with operator script: '
+                        + err);
+                } else {
+                    t.ok(true, 'VM updated with operator script');
+                }
+                next(err);
+            });
+        },
+        function _start(next) {
+            VM.start(vmobj.uuid, {}, function _start_cb(err) {
+                if (err) {
+                    t.ok(false, 'error starting VM: ' + err);
+                } else {
+                    t.ok(true, 'VM started');
+                }
+                next(err);
+            });
+        },
+        function _wait_operator_script(next) {
+            if (!expect_bsf) {
+                next();
+                return;
+            }
+            VM.waitForZoneState(payload, 'installed', function (err) {
+                t.ok(!err, 'zone stopped after running operator script');
+                next(err);
+            });
+        },
+        function _load(next) {
+            VM.load(vmobj.uuid, function _load_cb(err, obj) {
+                if (err) {
+                    t.ok(false, 'error creating VM: ' + err);
+                } else {
+                    t.ok(true, 'VM loaded uuid ' + obj.uuid);
+                    vmobj = obj;
+                }
+                next(err);
+            });
+        },
+        function _check(next) {
+            checkDisks({
+                t: t,
+                haves: vmobj.disks,
+                wants: disks,
+                uuid: vmobj.uuid
+            });
+            next(null);
+        },
+        function _check_lspci_md(next) {
+            if (!expect_bsf) {
+                next();
+                return;
+            }
+            var cm = vmobj.customer_metadata;
+            if (!cm.hasOwnProperty(lspci_md)) {
+                t.ok(false, 'customer_metadata["' + lspci_md
+                    + '"] not found');
+                next();
+                return;
+            }
+            var guest_bsf = [];
+            var lines = cm[lspci_md].trim().split('\n');
+            lines.forEach(function _gather_guest_pci(line) {
+                /* lspci reports bb:ss.f, with each number in hex */
+                var bsf = line.split(' ')[0].replace('.', ':').split(':');
+                guest_bsf.push(sprintf('%d:%d:%d', parseInt(bsf[0], 16),
+                    parseInt(bsf[1], 16), parseInt(bsf[2], 16)));
+            });
+            t.equal(guest_bsf.sort().join(' '), expect_bsf.sort().join(' '),
+                'PCI slots occupied: ' + expect_bsf.sort().join(' '));
+            next();
+        }
+    ], function _done(err) {
+        if (!vmobj || !vmobj.uuid) {
+            t.ok(true, 'no cleanup required');
+            t.end();
+            return;
+        }
+        VM.delete(vmobj.uuid, {}, function _delete_cb(_err) {
+            if (err) {
+                t.ok(false, 'error deleting VM: ' + _err);
+            } else {
+                t.ok(true, 'deleted VM: ' + vmobj.uuid);
+            }
+            t.end();
+        });
+    });
+}
+
+function checkDisks(opts) {
+    var t = opts.t;
+    var haves = opts.haves;
+    var uuid = opts.uuid;
+    var wants = opts.wants;
+
+    wants.forEach(function _check_disk(want) {
+        var found = false;
+        var path = sprintf(want.path, uuid);
+
+        t.ok(true, 'Checking disk ' + path);
+
+        haves.forEach(function _select_disk(have) {
+            if (path !== have.path) {
+                return;
+            }
+            found = true;
+            Object.keys(want).forEach(function _check_prop(prop) {
+                if (prop === 'path') {
+                    return;
+                }
+                t.equal(have[prop], want[prop], 'matching prop: ' + prop
+                    + '=' + have[prop]);
+            });
+        });
+        t.ok(found, 'disk ' + path + ' found');
+    });
+}
+
+test('Boot bhyve instance to verify disk.*.pci_slot are populated',
+    function _verify_populate_on_boot(t) {
+        var payload = dup(base_payload);
+        var check_disks = [
+            {
+                path: '/dev/zvol/rdsk/zones/%s/disk0',
+                image_uuid: image_uuid,
+                boot: true,
+                model: 'virtio',
+                pci_slot: '0:4:0'
+            }, {
+                path: '/dev/zvol/rdsk/zones/%s/disk1',
+                image_uuid: undefined,
+                model: 'virtio',
+                pci_slot: '0:4:1'
+            }
+        ];
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            disks: check_disks,
+            expect_bsf: ['0:4:0', '0:4:1']
+        });
+    });
+
+test('Verify cdrom is in PCI slot 3:0',
+    function _verify_cdrom_on_boot(t) {
+        var payload = dup(base_payload);
+
+        payload.disks.pop();
+        payload.disks.push({
+            // cdrom media is not created. Choose a file that exists.
+            path: '/usr/share/bhyve/uefi-rom.bin',
+            model: 'ahci',
+            media: 'cdrom'
+        });
+
+        var check_disks = [
+            {
+                path: '/dev/zvol/rdsk/zones/%s/disk0',
+                image_uuid: image_uuid,
+                boot: true,
+                model: 'virtio',
+                pci_slot: '0:4:0'
+            }, {
+                path: '/usr/share/bhyve/uefi-rom.bin',
+                image_uuid: undefined,
+                model: 'ahci',
+                pci_slot: '0:3:0',
+                media: 'cdrom'
+            }
+        ];
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            disks: check_disks
+        });
+    });
+
+test('Verify 8 disks assigned properly',
+    function _verify_8_disks(t) {
+        var payload = dup(base_payload);
+        var check_disks = [
+            {
+                path: '/dev/zvol/rdsk/zones/%s/disk0',
+                image_uuid: image_uuid,
+                boot: true,
+                model: 'virtio',
+                pci_slot: '0:4:0'
+            }
+        ];
+        var i;
+
+        payload.disks.pop();
+        for (i = 1; i < 8; i++) {
+            payload.disks.push({
+                size: 256,
+                model: 'virtio'
+            });
+            check_disks.push({
+                path: '/dev/zvol/rdsk/zones/%s/disk' + i,
+                pci_slot: '0:4:' + i
+            });
+        }
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            disks: check_disks,
+            expect_bsf: [
+                '0:4:0', '0:4:1', '0:4:2', '0:4:3',
+                '0:4:4', '0:4:5', '0:4:6', '0:4:7'
+            ]});
+    });
+
+test('Verify create time assignments are sticky',
+    function _verify_create_sticky_disks(t) {
+        var payload = dup(base_payload);
+        var check_disks = [
+            {
+                path: '/dev/zvol/rdsk/zones/%s/disk0',
+                image_uuid: image_uuid,
+                boot: true,
+                model: 'virtio',
+                pci_slot: '0:4:0'
+            }
+        ];
+        var i;
+
+        payload.disks.pop();
+        for (i = 1; i < 4; i++) {
+            payload.disks.push({
+                size: 256,
+                model: 'virtio',
+                pci_slot: '0:4:' + (i + 4)
+            });
+            check_disks.push({
+                path: '/dev/zvol/rdsk/zones/%s/disk' + i,
+                pci_slot: '0:4:' + (i + 4)
+            });
+        }
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            disks: check_disks,
+            expect_bsf: [ '0:4:0', '0:4:5', '0:4:6', '0:4:7' ]
+        });
+    });
+
+/*
+ * Verifies that "slot:fn" and "slot" are accepted and placed in the right
+ * places.
+ */
+test('Verify alternate slot schemes are allowed',
+    function _verify_partial_bsf_disks(t) {
+        var check_disks = [
+            {path: '/dev/zvol/rdsk/zones/%s/disk0', pci_slot: '0:4:0'},
+            {path: '/dev/zvol/rdsk/zones/%s/disk1', pci_slot: '4:1'},
+            {path: '/dev/zvol/rdsk/zones/%s/disk2', pci_slot: '5'}
+        ];
+        var payload = dup(base_payload);
+        payload.disks.pop();
+        payload.disks.push({size: 256, model: 'virtio', pci_slot: '4:1'});
+        payload.disks.push({size: 256, model: 'virtio', pci_slot: '5'});
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            disks: check_disks,
+            expect_bsf: [ '0:4:0', '0:4:1', '0:5:0' ]
+        });
+    });
+
+test('Verify holes are filled', function _verify_holes_filled(t) {
+        var check_disks = [
+            {path: '/dev/zvol/rdsk/zones/%s/disk0', pci_slot: '0:4:0'},
+            {path: '/dev/zvol/rdsk/zones/%s/disk1', pci_slot: '0:4:2'},
+            {path: '/dev/zvol/rdsk/zones/%s/disk2', pci_slot: '0:4:1'}
+        ];
+        var payload = dup(base_payload);
+        payload.flexible_disk_size = 13 * 1024;
+        payload.disks.pop();
+        payload.disks.push({size: 256, model: 'virtio', pci_slot: '0:4:2'});
+
+        var update_payload = {
+            add_disks: [ {
+                size: 512,
+                model: 'virtio'
+            } ]
+        };
+
+        testCreateAndCheckDisks({
+            t: t,
+            payload: payload,
+            update: update_payload,
+            disks: check_disks,
+            expect_bsf: [ '0:4:0', '0:4:1', '0:4:2' ]
+        });
+    });
+
+function notest(name, cb) {
+    test(name, function _skip(t) {
+        t.ok(true, 'skip test');
+        t.end();
+    });
+}
-- 
2.21.0

