commit 48600343609328ebb5366f2ff64109a67ed6db6b (refs/changes/79/479/3)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-09-16T16:36:20+00:00 (3 years, 1 month ago)
    
    joyent/node-cueball#20 better handling of 'end' events
    joyent/node-cueball#21 counters for errors

diff --git a/lib/pool-monitor.js b/lib/pool-monitor.js
index 7541c9a..3c73508 100644
--- a/lib/pool-monitor.js
+++ b/lib/pool-monitor.js
@@ -71,6 +71,7 @@ CueBallPoolMonitor.prototype.toKangOptions = function () {
 		    pool.p_lastRebalance.getTime() / 1000);
 		obj.resolvers = pool.p_resolver.r_resolvers;
 		obj.state = pool.getState();
+		obj.counters = pool.p_counters;
 		obj.options = {};
 		obj.options.domain = pool.p_resolver.r_domain;
 		obj.options.service = pool.p_resolver.r_service;
diff --git a/lib/pool.js b/lib/pool.js
index 9043e32..e120f91 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -223,22 +223,27 @@ ConnectionFSM.prototype.state_connect = function (on, once, timeout) {
 	once(this.cf_conn, 'error', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-connect');
 	});
 	once(this.cf_conn, 'connectError', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-connect');
 	});
 	once(this.cf_conn, 'close', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('close-during-connect');
 	});
 	once(this.cf_conn, 'timeout', function () {
 		self.cf_lastError = new mod_errors.ConnectionTimeoutError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('timeout-during-connect');
 	});
 	once(this.cf_conn, 'connectTimeout', function (err) {
 		self.cf_lastError = new mod_errors.ConnectionTimeoutError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('timeout-during-connect');
 	});
 	once(this, 'closeAsserted', function () {
 		self.gotoState('closed');
@@ -302,6 +307,7 @@ ConnectionFSM.prototype.state_error = function (on, once, timeout) {
 	} else {
 		this.cf_log.warn(this.cf_lastError, 'failed to connect to ' +
 		    'backend %s (%j)', this.cf_backend.key, this.cf_backend);
+		this.cf_pool._incrCounter('retries-exhausted');
 		this.gotoState('closed');
 	}
 };
@@ -385,14 +391,17 @@ ConnectionFSM.prototype.state_idle = function (on, once, timeout) {
 	once(this.cf_conn, 'error', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-idle');
 	});
 	once(this.cf_conn, 'close', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('close-during-idle');
 	});
 	once(this.cf_conn, 'end', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('end-during-idle');
 	});
 	once(this, 'closeAsserted', function () {
 		self.gotoState('closed');
@@ -452,8 +461,8 @@ ConnectionFSM.prototype.state_ping = function (on, once, timeout) {
 	this.cf_shadow = new ConnectionHandle(this);
 
 	once(this, 'releaseAsserted', function () {
-		if (this.cf_closeAfter === true) {
-			this.gotoState('closed');
+		if (self.cf_closeAfter === true) {
+			self.gotoState('closed');
 		} else {
 			self.gotoState('idle');
 		}
@@ -461,14 +470,17 @@ ConnectionFSM.prototype.state_ping = function (on, once, timeout) {
 	once(this.cf_conn, 'error', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-ping');
 	});
 	once(this.cf_conn, 'close', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('close-during-ping');
 	});
 	once(this.cf_conn, 'end', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('end-during-ping');
 	});
 	once(this, 'closeAsserted', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
@@ -526,14 +538,16 @@ ConnectionFSM.prototype.state_busy = function (on, once, timeout) {
 	once(this.cf_conn, 'error', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-busy');
 	});
 	once(this.cf_conn, 'end', function () {
-		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
-		self.gotoState('error');
+		self.cf_closeAfter = true;
+		self.cf_pool._incrCounter('end-during-busy');
 	});
 	once(this.cf_conn, 'close', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('close-during-busy');
 	});
 	once(this, 'closeAsserted', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
@@ -663,6 +677,8 @@ function CueBallConnectionPool(options) {
 	this.p_initq = new Queue();
 	this.p_waiters = new Queue();
 
+	this.p_counters = {};
+
 	var self = this;
 	if (options.resolver !== undefined && options.resolver !== null) {
 		this.p_resolver = options.resolver;
@@ -701,6 +717,12 @@ function CueBallConnectionPool(options) {
 }
 mod_util.inherits(CueBallConnectionPool, FSM);
 
+CueBallConnectionPool.prototype._incrCounter = function (counter) {
+	if (this.p_counters[counter] === undefined)
+		this.p_counters[counter] = 0;
+	++this.p_counters[counter];
+};
+
 CueBallConnectionPool.prototype.on_resolver_added = function (k, backend) {
 	backend.key = k;
 	var idx = Math.floor(Math.random() * (this.p_keys.length + 1));
