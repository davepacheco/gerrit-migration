From 240729c61c78ae09e93c228bdbedc49cf6fc1cf2 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Thu, 15 Sep 2016 17:29:50 -0700
Subject: [PATCH] joyent/node-cueball#20 better handling of 'end' events
 joyent/node-cueball#21 counters for errors

---
 lib/pool-monitor.js |  1 +
 lib/pool.js         | 30 ++++++++++++++++++++++++++----
 2 files changed, 27 insertions(+), 4 deletions(-)

diff --git a/lib/pool-monitor.js b/lib/pool-monitor.js
index 7541c9a..3c73508 100644
--- a/lib/pool-monitor.js
+++ b/lib/pool-monitor.js
@@ -71,6 +71,7 @@ CueBallPoolMonitor.prototype.toKangOptions = function () {
 		    pool.p_lastRebalance.getTime() / 1000);
 		obj.resolvers = pool.p_resolver.r_resolvers;
 		obj.state = pool.getState();
+		obj.counters = pool.p_counters;
 		obj.options = {};
 		obj.options.domain = pool.p_resolver.r_domain;
 		obj.options.service = pool.p_resolver.r_service;
diff --git a/lib/pool.js b/lib/pool.js
index 905bf5a..7dcb255 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -223,22 +223,27 @@ ConnectionFSM.prototype.state_connect = function (on, once, timeout) {
 	once(this.cf_conn, 'error', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-connect');
 	});
 	once(this.cf_conn, 'connectError', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-connect');
 	});
 	once(this.cf_conn, 'close', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('close-during-connect');
 	});
 	once(this.cf_conn, 'timeout', function () {
 		self.cf_lastError = new mod_errors.ConnectionTimeoutError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('timeout-during-connect');
 	});
 	once(this.cf_conn, 'connectTimeout', function (err) {
 		self.cf_lastError = new mod_errors.ConnectionTimeoutError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('timeout-during-connect');
 	});
 	once(this, 'closeAsserted', function () {
 		self.gotoState('closed');
@@ -296,6 +301,7 @@ ConnectionFSM.prototype.state_error = function (on, once, timeout) {
 	} else {
 		this.cf_log.warn(this.cf_lastError, 'failed to connect to ' +
 		    'backend %s (%j)', this.cf_backend.key, this.cf_backend);
+		this.cf_pool._incrCounter('retries-exhausted');
 		this.gotoState('closed');
 	}
 };
@@ -378,14 +384,17 @@ ConnectionFSM.prototype.state_idle = function (on, once, timeout) {
 	once(this.cf_conn, 'error', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-idle');
 	});
 	once(this.cf_conn, 'close', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('close-during-idle');
 	});
 	once(this.cf_conn, 'end', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('end-during-idle');
 	});
 	once(this, 'closeAsserted', function () {
 		self.gotoState('closed');
@@ -445,8 +454,8 @@ ConnectionFSM.prototype.state_ping = function (on, once, timeout) {
 	this.cf_shadow = new ConnectionHandle(this);
 
 	once(this, 'releaseAsserted', function () {
-		if (this.cf_closeAfter === true) {
-			this.gotoState('closed');
+		if (self.cf_closeAfter === true) {
+			self.gotoState('closed');
 		} else {
 			self.gotoState('idle');
 		}
@@ -454,14 +463,17 @@ ConnectionFSM.prototype.state_ping = function (on, once, timeout) {
 	once(this.cf_conn, 'error', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-ping');
 	});
 	once(this.cf_conn, 'close', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('close-during-ping');
 	});
 	once(this.cf_conn, 'end', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('end-during-ping');
 	});
 	once(this, 'closeAsserted', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
@@ -519,14 +531,16 @@ ConnectionFSM.prototype.state_busy = function (on, once, timeout) {
 	once(this.cf_conn, 'error', function (err) {
 		self.cf_lastError = err;
 		self.gotoState('error');
+		self.cf_pool._incrCounter('error-during-busy');
 	});
 	once(this.cf_conn, 'end', function () {
-		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
-		self.gotoState('error');
+		self.cf_closeAfter = true;
+		self.cf_pool._incrCounter('end-during-busy');
 	});
 	once(this.cf_conn, 'close', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
 		self.gotoState('error');
+		self.cf_pool._incrCounter('close-during-busy');
 	});
 	once(this, 'closeAsserted', function () {
 		self.cf_lastError = new mod_errors.ConnectionClosedError(self);
@@ -656,6 +670,8 @@ function CueBallConnectionPool(options) {
 	this.p_initq = new Queue();
 	this.p_waiters = new Queue();
 
+	this.p_counters = {};
+
 	var self = this;
 	if (options.resolver !== undefined && options.resolver !== null) {
 		this.p_resolver = options.resolver;
@@ -694,6 +710,12 @@ function CueBallConnectionPool(options) {
 }
 mod_util.inherits(CueBallConnectionPool, FSM);
 
+CueBallConnectionPool.prototype._incrCounter = function (counter) {
+	if (this.p_counters[counter] === undefined)
+		this.p_counters[counter] = 0;
+	++this.p_counters[counter];
+};
+
 CueBallConnectionPool.prototype.on_resolver_added = function (k, backend) {
 	backend.key = k;
 	var idx = Math.floor(Math.random() * (this.p_keys.length + 1));
-- 
2.21.0

