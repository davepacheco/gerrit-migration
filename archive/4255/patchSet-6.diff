From 9b28bf5791cd3d9de809fa909a565f807adfd0b7 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 19 Jun 2018 23:18:50 +0000
Subject: [PATCH] MORAY-295 Add support for filtering subnets by contained
 addresses MORAY-471 Filtering on arrays is broken for non-equality tests
 MORAY-327 Add support for "numrange" and "daterange" types MORAY-476 Add
 support for "date", "mac", and "uuid" types MORAY-477 Float values put into
 "number" fields get truncated to integers Reviewed by: Jason King
 <jason.king@joyent.com> Reviewed by: Dan McDonald <danmcd@joyent.com>
 Approved by: Dan McDonald <danmcd@joyent.com>

---
 test/arrays.test.js  |  24 +-
 test/buckets.test.js |  37 ++-
 test/network.test.js | 429 ++++++++++++++++++++++++++++++++++
 test/objects.test.js | 546 ++++++++++++++++++++++++++++++++++++++++++-
 test/ranges.test.js  | 429 ++++++++++++++++++++++++++++++++++
 5 files changed, 1450 insertions(+), 15 deletions(-)
 create mode 100644 test/network.test.js
 create mode 100644 test/ranges.test.js

diff --git a/test/arrays.test.js b/test/arrays.test.js
index efa9bc4..37f44f1 100644
--- a/test/arrays.test.js
+++ b/test/arrays.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var once = require('once');
@@ -38,12 +38,10 @@ function test(name, setup) {
         });
     });
 
-    tape.test(name + ' - main', function (t) {
-        setup(t);
-    });
+    tape.test(name + ' - main', setup);
 
     tape.test(name + ' - teardown', function (t) {
-    // May or may not exist, just blindly ignore
+        // May or may not exist, just blindly ignore
         c.delBucket(b, function () {
             c.once('close', function () {
                 helper.cleanupServer(server, function () {
@@ -388,6 +386,22 @@ test('schema array, array value (number)', function (t) {
                 req.once('record', checkObject);
                 req.once('end', cb);
             },
+            function gt(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(id>=0)');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            },
+            function lt(_, cb) {
+                cb = once(cb);
+
+                var req = c.findObjects(b, '(id<=4)');
+                req.once('error', cb);
+                req.once('record', checkObject);
+                req.once('end', cb);
+            },
             function presence(_, cb) {
                 cb = once(cb);
 
diff --git a/test/buckets.test.js b/test/buckets.test.js
index d91666d..3608746 100644
--- a/test/buckets.test.js
+++ b/test/buckets.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var jsprim = require('jsprim');
@@ -36,6 +36,13 @@ var FULL_CFG = {
             type: 'number',
             unique: true
         },
+        numr: {
+            type: 'numrange'
+        },
+        numr_u: {
+            type: 'numrange',
+            unique: true
+        },
         bool: {
             type: 'boolean'
         },
@@ -43,6 +50,20 @@ var FULL_CFG = {
             type: 'boolean',
             unique: true
         },
+        date: {
+            type: 'date'
+        },
+        date_u: {
+            type: 'date',
+            unique: true
+        },
+        daterange: {
+            type: 'daterange'
+        },
+        daterange_u: {
+            type: 'daterange',
+            unique: true
+        },
         ip: {
             type: 'ip'
         },
@@ -50,12 +71,26 @@ var FULL_CFG = {
             type: 'ip',
             unique: true
         },
+        mac: {
+            type: 'mac'
+        },
+        mac_u: {
+            type: 'mac',
+            unique: true
+        },
         subnet: {
             type: 'subnet'
         },
         subnet_u: {
             type: 'subnet',
             unique: true
+        },
+        uuid: {
+            type: 'uuid'
+        },
+        uuid_u: {
+            type: 'uuid',
+            unique: true
         }
     },
     pre: [function onePre(req, cb) { cb(); }],
diff --git a/test/network.test.js b/test/network.test.js
new file mode 100644
index 0000000..fbd3e2e
--- /dev/null
+++ b/test/network.test.js
@@ -0,0 +1,429 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var fmt = require('util').format;
+var once = require('once');
+var tape = require('tape');
+var libuuid = require('libuuid');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var helper = require('./helper.js');
+
+// --- Globals
+
+var uuid = {
+    v1: libuuid.create,
+    v4: libuuid.create
+};
+
+var c; // client
+var server;
+var b; // bucket
+
+var BUCKET_CFG = {
+    index: {
+        mac: {
+            type: 'mac'
+        },
+        ip: {
+            type: 'ip'
+        },
+        ip_a: {
+            type: '[ip]'
+        },
+        subnet: {
+            type: 'subnet'
+        },
+        subnet_a: {
+            type: '[subnet]'
+        }
+    }
+};
+
+function test(name, setup) {
+    tape.test(name + ' - setup', function (t) {
+        b = 'moray_unit_test_' + uuid.v4().substr(0, 7);
+        helper.createServer(null, function (s) {
+            server = s;
+            c = helper.createClient();
+            c.on('connect', t.end.bind(t));
+        });
+    });
+
+    tape.test(name + ' - main', setup);
+
+    tape.test(name + ' - teardown', function (t) {
+        // May or may not exist, just blindly ignore
+        c.delBucket(b, function () {
+            c.once('close', function () {
+                helper.cleanupServer(server, function () {
+                    t.pass('closed');
+                    t.end();
+                });
+            });
+            c.close();
+        });
+    });
+}
+
+// --- Tests
+
+test('MAC addresses - findObjects()', function (t) {
+    var key1 = uuid.v4();
+    var obj1 = {
+        mac: '04:31:f4:15:28:ec'
+    };
+
+    var key2 = uuid.v4();
+    var obj2 = {
+        mac: '1f:10:76:e3:7a:bc'
+    };
+
+    var key3 = uuid.v4();
+    var obj3 = {
+        mac: '47:33:47:03:7a:b0'
+    };
+
+    var key4 = uuid.v4();
+    var obj4 = {
+        mac: '6f:4d:67:cd:42:9c'
+    };
+
+    var key5 = uuid.v4();
+    var obj5 = {
+        mac: 'af:4d:67:cd:42:9c'
+    };
+
+    var ALL = [ obj1, obj2, obj3, obj4, obj5 ];
+
+    function put(k, o) {
+        return function (_, cb) {
+            c.putObject(b, k, o, cb);
+        };
+    }
+
+    function check(f, errnom) {
+        return function (_, cb) {
+            var msg = fmt('findObjects(%j) fails w/ %s', f, errnom);
+            var res = c.findObjects(b, f);
+
+            res.on('record', function (row) {
+                t.deepEqual(row, null, msg);
+            });
+
+            res.on('error', function (err) {
+                if (VError.hasCauseWithName(err, errnom)) {
+                    t.pass(msg);
+                } else {
+                    t.ifError(err, msg);
+                }
+
+                cb();
+            });
+
+            res.on('end', function () {
+                t.fail(msg);
+                cb();
+            });
+        };
+    }
+
+    function inv(f) {
+        return check(f, 'InvalidQueryError');
+    }
+
+    function expect(f, os) {
+        return function (_, cb) {
+            var res = c.findObjects(b, f, {
+                sort: {
+                    attribute: 'mac'
+                }
+            });
+
+            var rows = [];
+            res.on('record', function (row) {
+                rows.push(row.value);
+            });
+
+            res.on('error', function (err) {
+                t.ifError(err, fmt('findObjects(%j)', f));
+                cb();
+            });
+
+            res.on('end', function () {
+                t.deepEqual(rows, os, fmt('findObjects(%j) results', f));
+                cb();
+            });
+        };
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, BUCKET_CFG, cb);
+            },
+
+            put(key1, obj1),
+            put(key2, obj2),
+            put(key3, obj3),
+            put(key4, obj4),
+            put(key5, obj5),
+
+            // equality tests
+            expect('(mac=04:31:f4:15:28:ec)', [ obj1 ]),
+            expect('(mac=1f:10:76:e3:7a:bc)', [ obj2 ]),
+            expect('(mac=47:33:47:03:7a:b0)', [ obj3 ]),
+            expect('(mac=6f:4d:67:cd:42:9c)', [ obj4 ]),
+            expect('(mac=af:4d:67:cd:42:9c)', [ obj5 ]),
+
+            // not equal tests
+            expect('!(mac=04:31:f4:15:28:ec)', [ obj2, obj3, obj4, obj5 ]),
+            expect('!(mac=1f:10:76:e3:7a:bc)', [ obj1, obj3, obj4, obj5 ]),
+            expect('!(mac=47:33:47:03:7a:b0)', [ obj1, obj2, obj4, obj5 ]),
+            expect('!(mac=6f:4d:67:cd:42:9c)', [ obj1, obj2, obj3, obj5 ]),
+            expect('!(mac=af:4d:67:cd:42:9c)', [ obj1, obj2, obj3, obj4 ]),
+
+            // greater/eq tests
+            expect('(mac>=2c:23:ad:de:ec:6b)', [ obj3, obj4, obj5 ]),
+            expect('(mac>=1f:10:76:e3:7a:bc)', [ obj2, obj3, obj4, obj5 ]),
+
+            // lesser/eq tests
+            expect('(mac<=2c:23:ad:de:ec:6b)', [ obj1, obj2 ]),
+            expect('(mac<=6f:4d:67:cd:42:9c)', [ obj1, obj2, obj3, obj4 ]),
+
+            // fetch everything
+            expect('(mac=*)', ALL),
+            expect('(mac>=00:00:00:00:00:00)', ALL),
+            expect('(mac<=ff:ff:ff:ff:ff:ff)', ALL),
+
+            // invalid values
+            inv('(mac=foo)'),
+            inv('(mac<=foo)'),
+            inv('(mac>=foo)'),
+            inv('(mac=3q:1c:c0:8b:09:b7)'),
+            inv('(mac<=3q:1c:c0:8b:09:b7)'),
+            inv('(mac>=3q:1c:c0:8b:09:b7)'),
+            inv('(mac=1c:c0:8b:09:b7)'),
+            inv('(mac<=1c:c0:8b:09:b7)'),
+            inv('(mac>=1c:c0:8b:09:b7)')
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+test('Network ranges - invalid filters', function (t) {
+    function check(attr, ext, val) {
+        var f = fmt('(%s:%s:=%s)', attr, ext, val);
+
+        return function (_, cb) {
+            var msg = fmt('findObjects(%j) fails w/ InvalidQueryError', f);
+            var res = c.findObjects(b, f);
+
+            res.on('record', function (row) {
+                t.deepEqual(row, null, msg);
+            });
+
+            res.on('error', function (err) {
+                if (VError.hasCauseWithName(err, 'InvalidQueryError')) {
+                    t.pass(msg);
+                } else {
+                    t.ifError(err, msg);
+                }
+
+                cb();
+            });
+
+            res.on('end', function () {
+                t.fail(msg);
+                cb();
+            });
+        };
+    }
+
+    function genTests(ip, subnet) {
+        return [
+            // invalid "within" tests
+            check(ip, 'within', '5'),
+            check(ip, 'within', '1.2.3/24'),
+            check(ip, 'within', '300.0.0.0/8'),
+            check(ip, 'within', '1.2.3.0/240'),
+            check(ip, 'within', '1.2.3.0/24x'),
+
+            check(subnet, 'within', '1.2.3.0/24'),
+            check(subnet, 'within', 'fd00::/64'),
+
+            // invalid "contains" tests
+            check(subnet, 'contains', 'foo)'),
+            check(subnet, 'contains', 'true)'),
+            check(subnet, 'contains', '1.2.3.300)'),
+            check(subnet, 'contains', '1.2.3.4.5)'),
+            check(subnet, 'contains', 'fd00::xxx)'),
+            check(subnet, 'contains', '5)'),
+
+            check(ip, 'contains', '1.2.3.4'),
+            check(ip, 'contains', 'fd00::1')
+        ];
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, BUCKET_CFG, cb);
+            }
+        ].concat(genTests('ip', 'subnet'), genTests('ip_a', 'subnet_a')),
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+test('Network ranges - findObjects()', function (t) {
+    var key1 = uuid.v4();
+    var obj1 = {
+        ip: '10.1.3.5',
+        ip_a: [ '10.1.3.5' ],
+        subnet: '10.1.3.0/24',
+        subnet_a: [ '10.1.3.0/24' ]
+    };
+
+    var key2 = uuid.v4();
+    var obj2 = {
+        ip: '192.168.40.234',
+        ip_a: [ '192.168.40.234' ],
+        subnet: '192.168.0.0/16',
+        subnet_a: [ '192.168.0.0/16' ]
+    };
+
+
+    var key3 = uuid.v4();
+    var obj3 = {
+        ip: '::ffff:172.16.0.5',
+        ip_a: [ '::ffff:172.16.0.5' ],
+        subnet: '::ffff:172.16.0.0/112',
+        subnet_a: [ '::ffff:172.16.0.0/112' ]
+    };
+
+    var key4 = uuid.v4();
+    var obj4 = {
+        ip: 'fd00::321',
+        ip_a: [ 'fd00::321' ],
+        subnet: 'fd00::/64',
+        subnet_a: [ 'fd00::/64' ]
+    };
+
+    var key5 = uuid.v4();
+    var obj5 = {
+        ip: 'fe80::92e2:baff:fe07:b60',
+        ip_a: [ 'fe80::92e2:baff:fe07:b60' ],
+        subnet: 'fe80::/10',
+        subnet_a: [ 'fe80::/10' ]
+    };
+
+    function put(k, o) {
+        return function (_, cb) {
+            c.putObject(b, k, o, cb);
+        };
+    }
+
+    function expect(attr, ext, val, os) {
+        var f = fmt('(%s:%s:=%s)', attr, ext, val);
+
+        return function (_, cb) {
+            var res = c.findObjects(b, f, {
+                sort: {
+                    attribute: 'ip'
+                }
+            });
+
+            var rows = [];
+            res.on('record', function (row) {
+                rows.push(row.value);
+            });
+
+            res.on('error', function (err) {
+                t.ifError(err, fmt('findObjects(%j)', f));
+                cb();
+            });
+
+            res.on('end', function () {
+                t.deepEqual(rows, os, fmt('findObjects(%j) results', f));
+                cb();
+            });
+        };
+    }
+
+    function genTests(ip, subnet) {
+        return [
+            // "within" tests
+            expect(ip, 'within', '0.0.0.0/0', [ obj1, obj2 ]),
+            expect(ip, 'within', '10.0.0.0/8', [ obj1 ]),
+            expect(ip, 'within', '10.1.0.0/16', [ obj1 ]),
+            expect(ip, 'within', '10.1.3.0/24', [ obj1 ]),
+            expect(ip, 'within', '10.1.4.0/24', [ ]),
+            expect(ip, 'within', '192.0.0.0/8', [ obj2 ]),
+            expect(ip, 'within', '192.168.0.0/16', [ obj2 ]),
+            expect(ip, 'within', '192.168.40.0/24', [ obj2 ]),
+            expect(ip, 'within', '192.168.1.0/24', [ ]),
+            expect(ip, 'within', '::ffff:0.0.0.0/96', [ obj3 ]),
+            expect(ip, 'within', '::ffff:172.16.0.0/112', [ obj3 ]),
+            expect(ip, 'within', '::ffff:172.16.0.0/120', [ obj3 ]),
+            expect(ip, 'within', 'fd00::/64', [ obj4 ]),
+            expect(ip, 'within', 'fd00::0000/64', [ obj4 ]),
+            expect(ip, 'within', 'fe80::/10', [ obj5 ]),
+            expect(ip, 'within', 'fe80::0000/10', [ obj5 ]),
+            expect(ip, 'within', '::/0', [ obj3, obj4, obj5 ]),
+            expect(ip, 'within', '0::/0', [ obj3, obj4, obj5 ]),
+            expect(ip, 'within', '0::0/0', [ obj3, obj4, obj5 ]),
+
+            // "contains" tests
+            expect(subnet, 'contains', '10.1.3.0', [ obj1 ]),
+            expect(subnet, 'contains', '10.1.3.20', [ obj1 ]),
+            expect(subnet, 'contains', '10.1.3.255', [ obj1 ]),
+            expect(subnet, 'contains', '10.1.4.0', [ ]),
+            expect(subnet, 'contains', '192.168.20.30', [ obj2 ]),
+            expect(subnet, 'contains', '192.168.1.3', [ obj2 ]),
+            expect(subnet, 'contains', '192.168.255.255', [ obj2 ]),
+            expect(subnet, 'contains', '192.169.0.0', [ ]),
+            expect(subnet, 'contains', '::ffff:172.16.5.4', [ obj3 ]),
+            expect(subnet, 'contains', '::ffff:172.16.250.20', [ obj3 ]),
+            expect(subnet, 'contains', 'fd00::50:20', [ obj4 ]),
+            expect(subnet, 'contains', 'fd00::abcd:1234', [ obj4 ]),
+            expect(subnet, 'contains', 'fd00::1', [ obj4 ]),
+            expect(subnet, 'contains', 'fd00::01', [ obj4 ]),
+            expect(subnet, 'contains', 'fd00::001', [ obj4 ]),
+            expect(subnet, 'contains', 'fd00::0001', [ obj4 ]),
+            expect(subnet, 'contains', 'fe80::8:20ff:fe3e:27b0', [ obj5 ]),
+            expect(subnet, 'contains', 'fe80::92b8:d0ff:feb3:8b45', [ obj5 ])
+        ];
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, BUCKET_CFG, cb);
+            },
+
+            put(key1, obj1),
+            put(key2, obj2),
+            put(key3, obj3),
+            put(key4, obj4),
+            put(key5, obj5)
+        ].concat(genTests('ip', 'subnet'), genTests('ip_a', 'subnet_a')),
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
diff --git a/test/objects.test.js b/test/objects.test.js
index 5d159b7..2fcbb6e 100644
--- a/test/objects.test.js
+++ b/test/objects.test.js
@@ -17,6 +17,7 @@ var util = require('util');
 var net = require('net');
 var VError = require('verror');
 
+var fmt = util.format;
 var helper = require('./helper.js');
 
 
@@ -30,6 +31,23 @@ var uuid = {
 
 var BUCKET_CFG = {
     index: {
+        date: {
+            type: 'date'
+        },
+        date_a: {
+            type: '[date]'
+        },
+        date_u: {
+            type: 'date',
+            unique: true
+        },
+        dater: {
+            type: 'daterange'
+        },
+        dater_u: {
+            type: 'daterange',
+            unique: true
+        },
         str: {
             type: 'string'
         },
@@ -53,6 +71,13 @@ var BUCKET_CFG = {
             type: 'number',
             unique: true
         },
+        numr: {
+            type: 'numrange'
+        },
+        numr_u: {
+            type: 'numrange',
+            unique: true
+        },
         bool: {
             type: 'boolean'
         },
@@ -73,6 +98,16 @@ var BUCKET_CFG = {
             type: 'ip',
             unique: true
         },
+        mac: {
+            type: 'mac'
+        },
+        mac_a: {
+            type: '[mac]'
+        },
+        mac_u: {
+            type: 'mac',
+            unique: true
+        },
         subnet: {
             type: 'subnet'
         },
@@ -82,6 +117,13 @@ var BUCKET_CFG = {
         subnet_u: {
             type: 'subnet',
             unique: true
+        },
+        uuid: {
+            type: 'uuid'
+        },
+        uuid_u: {
+            type: 'uuid',
+            unique: true
         }
     },
     pre: [function (req, cb) {
@@ -104,6 +146,20 @@ var c; // client
 var server;
 var b; // bucket
 
+var INDEXES = Object.keys(BUCKET_CFG.index);
+
+var NUM_NON_UNIQUE_INDEXES = INDEXES.reduce(function (acc, i) {
+    return acc + (BUCKET_CFG.index[i].unique ? 0 : 1);
+}, 0);
+
+var NUM_UNIQUE_INDEXES = INDEXES.reduce(function (acc, i) {
+    return acc + (BUCKET_CFG.index[i].unique ? 1 : 0);
+}, 0);
+
+var NUM_ARRAY_INDEXES = INDEXES.reduce(function (acc, i) {
+    return acc + (BUCKET_CFG.index[i].type[0] === '[' ? 1 : 0);
+}, 0);
+
 function test(name, setup) {
     tape.test(name + ' - setup', function (t) {
         b = 'moray_unit_test_' + uuid.v4().substr(0, 7);
@@ -454,23 +510,38 @@ test('del object w/etag conflict', function (t) {
 test('MORAY-406: Put an object with null values', function (t) {
     var k = uuid.v4();
     var v = {
+        date: null,
+        date_a: null,
+        date_u: null,
+        dater: null,
+        dater_u: null,
         str: null,
         str_a: null,
         str_u: null,
+        str_2: null,
         num: null,
         num_a: null,
         num_u: null,
+        numr: null,
+        numr_u: null,
         bool: null,
         bool_a: null,
         bool_u: null,
         ip: null,
         ip_a: null,
         ip_u: null,
+        mac: null,
+        mac_a: null,
+        mac_u: null,
         subnet: null,
         subnet_a: null,
-        subnet_u: null
+        subnet_u: null,
+        uuid: null,
+        uuid_u: null
     };
 
+    t.equal(Object.keys(v).length, INDEXES.length, 'all fields tested');
+
     t.test('putObject()', function (t2) {
         c.putObject(b, k, v, function (err) {
             t2.ifError(err);
@@ -1510,51 +1581,88 @@ test('MORAY-403: updateObjects() of every type', function (t) {
     var v4 = uuid.v4();
 
     var changed1 = {
+        str_2: v2,
+
+        date: '2018-06-14T20:36:55.151Z',
+        date_u: '1920-04-13T12:30:00.000Z',
+        date_a: [ '2015-06-29T01:23:45.678Z', '2016-06-15T00:00:00.000Z' ],
+        dater: '[1861-04-12T00:00:00.000Z,1865-05-09T00:00:00.000Z]',
+        dater_u: '(1835-01-25T04:00:00.000Z,1835-01-25T07:00:00.000Z)',
         str: 'a1',
         str_a: [ 'foo', 'bar', 'baz' ],
         str_u: 'u1',
-        str_2: v2,
         num: 1,
         num_a: [ 1, 1, 2, 3, 5, 8 ],
         num_u: 2003,
+        numr: '(9000,)',
+        numr_u: '(2,100]',
         bool: true,
         bool_a: [ true, false, false, true ],
         bool_u: false,
         ip: '1.2.3.4',
         ip_a: [ '1.2.3.4', 'fd00::30e' ],
         ip_u: '127.0.0.1',
+        mac: '23:56:dc:b1:6a:d6',
+        mac_a: [ '1b:a5:bc:32:ab:d5', '50:f4:66:89:48:90' ],
+        mac_u: '1e:da:0b:d2:93:da',
         subnet: 'fc00::/7',
         subnet_a: [ 'fe80::/10', 'fc00::/7', '10.0.0.0/8' ],
-        subnet_u: '172.16.0.0/12'
+        subnet_u: '172.16.0.0/12',
+        uuid: '392d019e-7723-4db7-a830-ff1a2415a5bc',
+        uuid_u: '62f13c43-59aa-c188-f40b-aeca10628785'
     };
 
     var changed2 = {
+        str_2: v3,
+
+        date: '1823-12-02T00:00:00.000Z',
+        date_u: '0528-06-21T12:03:00.000Z',
+        date_a: [ '1582-10-04T23:59:59.999Z', '1582-10-15T00:00:00.000Z' ],
+        dater: '[1618-05-23T00:00:00.000Z,1648-05-15T00:00:00.000Z]',
+        dater_u: '(1483-11-10T00:00:00.000Z,1546-02-18T00:00:00.000Z]',
         str: 'a2',
         str_a: [ 'red', 'blue', 'green' ],
         str_u: 'u2',
-        str_2: v3,
         num: 2,
         num_a: [ 1, 10, 100, 1000, 10000 ],
         num_u: 3002,
+        numr: '(,9000)',
+        numr_u: '[2,100)',
         bool: false,
         bool_a: [ false, true, true, false ],
         bool_u: true,
         ip: '4.3.2.1',
         ip_a: [ '192.168.1.1', '2001:4860:4860::8888' ],
         ip_u: '127.0.0.2',
+        mac: '3f:30:6e:af:f5:c1',
+        mac_a: [
+            '54:d1:2a:38:84:c9',
+            '12:b9:58:25:41:5c',
+            '51:8f:55:00:ac:60'
+        ],
+        mac_u: '01:ae:57:fa:f4:8c',
         subnet: 'fd00:1234::/64',
         subnet_a: [ 'fd4e::/64', 'fc12:3456::/64', '192.168.0.0/16' ],
-        subnet_u: '172.16.1.0/24'
+        subnet_u: '172.16.1.0/24',
+        uuid: '1d96d942-9be7-68ea-f9f9-e9fbe0b7a18b',
+        uuid_u: '69bf5a59-869c-6da4-f2b5-dd1ed6aa977e'
     };
 
     var changed3 = {
+        date_a: [],
         str_a: [],
         num_a: [],
         bool_a: [],
         ip_a: [],
+        mac_a: [],
         subnet_a: []
     };
 
+    t.equal(Object.keys(changed1).length, INDEXES.length, 'all fields tested');
+    t.equal(Object.keys(changed2).length, INDEXES.length, 'all fields tested');
+    t.equal(Object.keys(changed3).length, NUM_ARRAY_INDEXES,
+        'all array fields tested');
+
     function doUpdate(fields, filter, count, cb) {
         c.updateObjects(b, fields, filter, function (err, res) {
             t.ifError(err, 'updateObjects() error');
@@ -1904,7 +2012,7 @@ test('MORAY-291: add partial ip not ok', function (t) {
             c.putObject(b, k, v, function (err, meta) {
                 if (err) {
                     t.ok(err, 'received an error');
-                    t.ok(jsprim.endsWith(err.message, errmsg),
+                    t.notEqual(err.message.indexOf(errmsg), -1,
                         'with the right message');
                     return (cb());
                 }
@@ -1930,8 +2038,8 @@ test('MORAY-291: add ip/cidr not ok', function (t) {
             c.putObject(b, k, v, function (err, meta) {
                 if (err) {
                     t.ok(err, 'received an error');
-                    t.ok(jsprim.endsWith(err.message, errmsg,
-                        'with the right message'));
+                    t.notEqual(err.message.indexOf(errmsg), -1,
+                        'with the right message');
                     return (cb());
                 }
                 t.notOk(false, 'did not error on ip/cidr input');
@@ -2193,10 +2301,34 @@ test('MORAY-291: able to query <= on IP types', function (t) {
 
 test('MORAY-298: presence filter works for all types', function (t) {
     var recs = [
+        {
+            k: 'date',
+            v: '1989-11-09T21:43:56.987Z'
+        },
+        {
+            k: 'date_a',
+            v: [ '1961-08-13T00:11:22.333Z' ]
+        },
+        {
+            k: 'date_u',
+            v: '1961-08-13T00:11:22.333Z'
+        },
+        {
+            k: 'dater',
+            v: '[1776-07-04T00:00:00.000Z,)'
+        },
+        {
+            k: 'dater_u',
+            v: '[1492-12-25T00:00:00.000Z,)'
+        },
         {
             k: 'str',
             v: 'string'
         },
+        {
+            k: 'str_a',
+            v: [ 'my string' ]
+        },
         {
             k: 'str_u',
             v: 'unique string'
@@ -2205,10 +2337,30 @@ test('MORAY-298: presence filter works for all types', function (t) {
             k: 'num',
             v: 40
         },
+        {
+            k: 'num_a',
+            v: [ 75.75 ]
+        },
+        {
+            k: 'num_u',
+            v: 50.521
+        },
+        {
+            k: 'numr',
+            v: '[18,)'
+        },
+        {
+            k: 'numr_u',
+            v: '[21,)'
+        },
         {
             k: 'bool',
             v: true
         },
+        {
+            k: 'bool_a',
+            v: [ true, false, true ]
+        },
         {
             k: 'bool_u',
             v: true
@@ -2217,20 +2369,50 @@ test('MORAY-298: presence filter works for all types', function (t) {
             k: 'ip',
             v: '192.168.5.2'
         },
+        {
+            k: 'ip_a',
+            v: [ '10.10.10.25', '10.50.20.35', '10.75.35.30' ]
+        },
         {
             k: 'ip_u',
             v: '192.168.5.3'
         },
+        {
+            k: 'mac',
+            v: '52:fa:1e:e3:ef:9b'
+        },
+        {
+            k: 'mac_a',
+            v: [ '32:ed:64:95:c0:b3', '4d:c8:5e:c8:56:d3' ]
+        },
+        {
+            k: 'mac_u',
+            v: '44:bc:b2:10:15:87'
+        },
         {
             k: 'subnet',
             v: '192.168.5.0/24'
         },
+        {
+            k: 'subnet_a',
+            v: [ '192.168.4.0/24', '192.168.5.0/24', '192.168.6.0/24' ]
+        },
         {
             k: 'subnet_u',
             v: '192.168.6.0/24'
+        },
+        {
+            k: 'uuid',
+            v: '9f100df6-43e8-64fd-f109-ba9cfbec8cdb'
+        },
+        {
+            k: 'uuid_u',
+            v: '4201e559-174b-c756-9cfc-fdd1e2ff92fe'
         }
     ];
 
+    t.equal(recs.length, INDEXES.length - 1, 'all fields tested');
+
     vasync.forEachParallel({
         inputs: recs,
         func: function presence(rec, cb) {
@@ -2261,7 +2443,7 @@ test('MORAY-298: presence filter works for all types', function (t) {
 
                 req.on('record', function (obj) {
                     n++;
-                    t.equal(obj.value[rec.k], rec.v, 'value' + desc);
+                    t.deepEqual(obj.value[rec.k], rec.v, 'value' + desc);
                 });
 
                 return req;
@@ -2403,3 +2585,349 @@ test('MORAY-311: ext filters survive undefined fields', function (t) {
         });
     });
 });
+
+test('UniqueAttributeError for every type', function (t) {
+    var conflict = {
+        date_u: '2015-10-21T00:00:00.000Z',
+        dater_u: '(2015-10-21T00:00:00.000Z,)',
+        str_u: 'hello',
+        num_u: 40,
+        numr_u: '(9000,)',
+        bool_u: true,
+        ip_u: '1.2.3.4',
+        mac_u: '58:57:1a:d1:42:a1',
+        subnet_u: '10.0.0.0/8',
+        uuid_u: '725f6c18-12de-c9ef-fb37-d3d14ba3d24f'
+    };
+
+    function checkConflicts(_, cb) {
+        function checkConflict(attr, cb2) {
+            var o = {};
+            o[attr] = conflict[attr];
+
+            c.putObject(b, uuid.v4(), o, function (err) {
+                var msg =
+                    fmt('putObject(%j) fails with UniqueAttributeError', o);
+
+                if (err) {
+                    if (VError.hasCauseWithName(err, 'UniqueAttributeError')) {
+                        t.pass(msg);
+                    } else {
+                        t.ifError(err, msg);
+                    }
+                } else {
+                    t.fail(msg);
+                }
+
+                cb2();
+            });
+        }
+
+        vasync.forEachPipeline({
+            inputs: Object.keys(conflict),
+            func: checkConflict
+        }, cb);
+    }
+
+    function noConflict(attr, value) {
+        return function (_, cb) {
+            var k = uuid.v4();
+            var o = {};
+            o[attr] = value;
+
+            c.putObject(b, k, o, function (pErr) {
+                if (pErr) {
+                    t.ifError(pErr, 'putObject() error');
+                    cb();
+                    return;
+                }
+
+                c.getObject(b, k, function (gErr, mo) {
+                    t.ifError(gErr, 'getObject() error');
+                    assertObject(t, mo, k, o);
+                    cb();
+                });
+            });
+        };
+    }
+
+    t.equal(Object.keys(conflict).length, NUM_UNIQUE_INDEXES,
+        'all unique fields tested');
+
+    vasync.pipeline({
+        funcs: [
+            function (_, cb) {
+                c.putObject(b, uuid.v4(), conflict, cb);
+            },
+
+            checkConflicts,
+
+            /*
+             * Check that values that are similar, but not the same, can be
+             * loaded into the bucket.
+             */
+            noConflict('date_u', '2015-10-21T00:00:00.001Z'),
+            noConflict('dater_u', '(2015-10-21T00:00:00.001Z,)'),
+            noConflict('str_u', 'Hello'),
+            noConflict('num_u', 40.1),
+            noConflict('numr_u', '(,9000)'),
+            noConflict('numr_u', '(9001,)'),
+            noConflict('bool_u', false),
+            noConflict('ip_u', '1.2.3.5'),
+            noConflict('mac_u', '38:7c:0e:5d:bf:9b'),
+            noConflict('subnet_u', '10.0.0.0/24'),
+            noConflict('uuid_u', '725f6c18-12de-c9ef-fb37-d3d14ba3d24e')
+        ]
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+
+});
+
+test('InvalidIndexTypeError/InvalidQueryError for every type', function (t) {
+    /*
+     * For the array-type columns, place the bad values at the end of the array,
+     * so that it can be found by the InvalidQueryError tests below. (There's
+     * also no point in testing invalid values that are no in an array, since
+     * Moray implicitly wraps singleton values.)
+     */
+    var tests = [
+        {
+            attr: 'date',
+            values: [
+                'foo',
+                'August 1, 2020',
+                '1970-01-01T00:00:00.000',
+                '1970-01-01 00:00:00.000Z',
+                '-1970-01-01T00:00:00.000Z',
+                '1970-01-01',
+                0,
+                1529346379184
+            ]
+        },
+        {
+            attr: 'date_a',
+            values: [
+                [ '1970-01-01T00:00:00.000Z', 'Thursday, 1 January 1970' ],
+                [ 0 ],
+                [ 1529346379184 ]
+            ]
+        },
+        {
+            attr: 'dater',
+            values: [
+                '{,}',
+                '[,foo]',
+                '[foo,]'
+            ]
+        },
+        {
+            attr: 'numr',
+            values: [
+                '{,}',
+                '[,foo]',
+                '[foo,]',
+                '[,2.foo]',
+                '[2.foo,]'
+            ]
+        },
+        {
+            attr: 'bool',
+            values: [
+                'foo',
+                'truef',
+                'troo',
+                'tf',
+                'ft',
+                23
+            ]
+        },
+        {
+            attr: 'bool_a',
+            values: [
+                [ true, false, true, 'bar' ]
+            ]
+        },
+        {
+            attr: 'ip',
+            values: [
+                'foo',
+                '1.2.3.4.5',
+                '1.2.3',
+                'fd00:::1'
+            ]
+        },
+        {
+            attr: 'ip_a',
+            values: [
+                [ '1.2.3.4', 'fd00::1', 'foo' ]
+            ]
+        },
+        {
+            attr: 'mac',
+            values: [
+                'foo',
+                true,
+                2012543500901123,
+                '33:06:49:0f:4b:3q',
+                '333:06:49:0f:4b:3b',
+                '33:006:49:0f:4b:3b',
+                '06:49:0f:4b:3b',
+                'ab:33:06:49:0f:4b:3b'
+            ]
+        },
+        {
+            attr: 'mac_a',
+            values: [
+                [ '6a:94:d5:ab:54:ba', 'foo' ]
+            ]
+        },
+        {
+            attr: 'subnet',
+            values: [
+                'foo',
+                '1.2.3.0/40',
+                'fd00::/-20',
+                'fd00::/150',
+                'fd00:::/64'
+            ]
+        },
+        {
+            attr: 'subnet_a',
+            values: [
+                [ 'fd00::/64', 'foo' ]
+            ]
+        },
+        {
+            attr: 'uuid',
+            values: [
+                'foo',
+                '0123',
+                'abcd',
+                '5ec7875-bd10-401a-cfc1-dc1e90018abe',
+                '5ec78759-bd1-401a-cfc1-dc1e90018abe',
+                '5ec78759-bd10-401-cfc1-dc1e90018abe',
+                '5ec78759-bd10-401a-cfc-dc1e90018abe',
+                '5ec78759-bd10-401a-cfc1-dc1e90018ab',
+                '1-5ec78759-bd10-401a-cfc1-dc1e90018abe'
+            ]
+        },
+
+        /*
+         * Unfortunately, Moray is extremely accepting for string type columns,
+         * and some services rely on this. (For example, UFDS sends arrays and
+         * expects to be stringified such that its contents are separated by a
+         * comma.) We just leave empty "values" arrays here, and hopefully can
+         * someday tighten things up.
+         */
+        {
+            attr: 'str',
+            values: [ ]
+        },
+        {
+            attr: 'str_a',
+            values: [ ]
+        },
+        {
+            attr: 'str2',
+            values: [ ]
+        },
+        /*
+         * And, naturally, the same goes for number type columns! Workflow sends
+         * strings that get turned into NaN, which get turned into NULL, and
+         * UFDS sends input like [ '4' ], which parseInt()/parseFloat() will
+         * happily coerce into a string and then parse.
+         */
+        {
+            attr: 'num',
+            values: [ ]
+        },
+        {
+            attr: 'num_a',
+            values: [ ]
+        }
+    ];
+
+    t.equal(tests.length, NUM_NON_UNIQUE_INDEXES, 'all fields tested');
+
+    function tryKV(t2, attr, value, cb) {
+        var o = {};
+        o[attr] = value;
+
+        c.putObject(b, uuid.v4(), o, function (err) {
+            var msg = fmt('putObject(%j) fails with InvalidIndexTypeError', o);
+
+            if (err) {
+                if (VError.hasCauseWithName(err, 'InvalidIndexTypeError')) {
+                    t2.pass(msg);
+                } else {
+                    t2.ifError(err, msg);
+                }
+            } else {
+                t2.fail(msg);
+            }
+
+            cb();
+        });
+    }
+
+    function tryQuery(t2, attr, value, cb) {
+        var filter = fmt('(%s=%s)', attr, value);
+        var msg = fmt('findObjects(%j) fails w/ InvalidQueryError', filter);
+        var res = c.findObjects(b, filter);
+
+        res.on('record', function (row) {
+            t2.deepEqual(row, null, msg);
+        });
+
+        res.on('error', function (err) {
+            if (VError.hasCauseWithName(err, 'InvalidQueryError')) {
+                t2.pass(msg);
+            } else {
+                t2.ifError(err, msg);
+            }
+
+            cb();
+        });
+
+        res.on('end', function () {
+            t2.fail(msg);
+            cb();
+        });
+    }
+
+    tests.forEach(function (info) {
+        if (info.values.length === 0) {
+            return;
+        }
+
+        t.test(fmt('InvalidIndexTypeError for %j', info.attr), function (t2) {
+            vasync.forEachPipeline({
+                inputs: info.values,
+                func: function (value, cb) {
+                    tryKV(t2, info.attr, value, cb);
+                }
+            }, function (err) {
+                t2.ifError(err, info.attr + ' tests error');
+                t2.end();
+            });
+        });
+
+        t.test(fmt('InvalidQueryError for %j', info.attr), function (t2) {
+            vasync.forEachPipeline({
+                inputs: info.values,
+                func: function (value, cb) {
+                    if (Array.isArray(value)) {
+                        value = value[value.length - 1];
+                    }
+
+                    tryQuery(t2, info.attr, value, cb);
+                }
+            }, function (err) {
+                t2.ifError(err, info.attr + ' tests error');
+                t2.end();
+            });
+        });
+    });
+});
diff --git a/test/ranges.test.js b/test/ranges.test.js
new file mode 100644
index 0000000..ef322e8
--- /dev/null
+++ b/test/ranges.test.js
@@ -0,0 +1,429 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var fmt = require('util').format;
+var once = require('once');
+var tape = require('tape');
+var libuuid = require('libuuid');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var helper = require('./helper.js');
+
+// --- Globals
+
+var uuid = {
+    v1: libuuid.create,
+    v4: libuuid.create
+};
+
+// XXX: Need some tests that return no results
+
+var c; // client
+var server;
+var b; // bucket
+
+var BUCKET_CFG = {
+    index: {
+        date: {
+            type: 'date'
+        },
+        daterange: {
+            type: 'daterange'
+        },
+        num: {
+            type: 'number'
+        },
+        numrange: {
+            type: 'numrange'
+        }
+    }
+};
+
+
+
+function test(name, setup) {
+    tape.test(name + ' - setup', function (t) {
+        b = 'moray_unit_test_' + uuid.v4().substr(0, 7);
+        helper.createServer(null, function (s) {
+            server = s;
+            c = helper.createClient();
+            c.on('connect', t.end.bind(t));
+        });
+    });
+
+    tape.test(name + ' - main', setup);
+
+    tape.test(name + ' - teardown', function (t) {
+        // May or may not exist, just blindly ignore
+        c.delBucket(b, function () {
+            c.once('close', function () {
+                helper.cleanupServer(server, function () {
+                    t.pass('closed');
+                    t.end();
+                });
+            });
+            c.close();
+        });
+    });
+}
+
+// --- Tests
+
+test('Ranges - invalid filters', function (t) {
+    function check(f, errnom) {
+        return function (_, cb) {
+            var msg = fmt('findObjects(%j) fails w/ %s', f, errnom);
+            var res = c.findObjects(b, f);
+
+            res.on('record', function (row) {
+                t.deepEqual(row, null, msg);
+            });
+
+            res.on('error', function (err) {
+                if (VError.hasCauseWithName(err, errnom)) {
+                    t.pass(msg);
+                } else {
+                    t.ifError(err, msg);
+                }
+
+                cb();
+            });
+
+            res.on('end', function () {
+                t.fail(msg);
+                cb();
+            });
+        };
+    }
+
+    function inv(f) {
+        return check(f, 'InvalidQueryError');
+    }
+
+    function noidx(f) {
+        return check(f, 'NotIndexedError');
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, BUCKET_CFG, cb);
+            },
+
+            /* BEGIN JSSTYLED */
+
+            // invalid "within" tests
+            inv('(num:within:=5)'),
+            inv('(num:within:=foo)'),
+            inv('(num:within:=true)'),
+            inv('(num:within:={5,6})'),
+            inv('(num:within:={5,6])'),
+            inv('(num:within:=[foo,bar])'),
+
+            inv('(date:within:=5)'),
+            inv('(date:within:=foo)'),
+            inv('(date:within:=true)'),
+            inv('(date:within:={5,6})'),
+            inv('(date:within:={5,6])'),
+            inv('(date:within:=[foo,bar])'),
+
+            inv('(numrange:within:=[,])'),
+            inv('(daterange:within:=[,])'),
+
+            // invalid "contains" tests
+
+            /*
+             * It would be great if we could make the validation here strict,
+             * but currently the number parsing needs to ignore some bad input.
+             * Making this part strict would be nice though:
+             *
+             * inv('(numrange:contains:=l5)'),
+             * inv('(numrange:contains:=foo)'),
+             * inv('(numrange:contains:=true)'),
+             * inv('(numrange:contains:=[5,6])'),
+             * inv('(numrange:contains:={5,6})'),
+             * inv('(numrange:contains:={5,6])'),
+             * inv('(numrange:contains:=[foo,bar])'),
+             */
+
+            inv('(daterange:contains:=[2016-06-05T16:23:04.776Z,2017-06-05T16:23:04.776Z])'),
+            inv('(daterange:contains:=foo)'),
+            inv('(daterange:contains:=true)'),
+            inv('(daterange:contains:=[foo,bar])'),
+            inv('(daterange:contains:=1758-05-06T00:00:00.000)'),
+            inv('(daterange:contains:=1758-05-06 00:00:00.000Z)'),
+
+            inv('(num:contains:=5)'),
+            inv('(date:contains:=1993-05-06T00:00:00.000Z)'),
+
+            // invalid "overlaps" tests
+            inv('(numrange:overlaps:=5l)'),
+            inv('(numrange:overlaps:=l5)'),
+            inv('(numrange:overlaps:=foo)'),
+            inv('(numrange:overlaps:=true)'),
+            inv('(numrange:overlaps:={5,6})'),
+            inv('(numrange:overlaps:={5,6])'),
+            inv('(numrange:overlaps:=[foo,bar])'),
+
+            inv('(daterange:overlaps:=5l)'),
+            inv('(daterange:overlaps:=l5)'),
+            inv('(daterange:overlaps:=foo)'),
+            inv('(daterange:overlaps:=true)'),
+            inv('(daterange:overlaps:={2016-06-05T16:23:04.776Z,2016-06-05T16:23:04.776Z})'),
+            inv('(daterange:overlaps:={2016-06-05T16:23:04.776Z,2016-06-05T16:23:04.776Z])'),
+            inv('(daterange:overlaps:=[foo,bar])'),
+
+            inv('(num:overlaps:=[,])'),
+            inv('(date:overlaps:=[,])'),
+
+            // no indexes for these attributes
+            noidx('nonum:overlaps:=[1,2]'),
+            noidx('nonum:within:=[1,2]'),
+            noidx('nonumrange:contains:=20')
+
+            /* END JSSTYLED */
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+
+test('Numeric ranges - findObjects()', function (t) {
+    var key1 = uuid.v4();
+    var obj1 = {
+        num: -20,
+        numrange: '[-15,-5]'
+    };
+
+    var key2 = uuid.v4();
+    var obj2 = {
+        num: -10,
+        numrange: '(5,15)'
+    };
+
+    var key3 = uuid.v4();
+    var obj3 = {
+        num: 10,
+        numrange: '(,15]'
+    };
+
+    var key4 = uuid.v4();
+    var obj4 = {
+        num: 20,
+        numrange: '[5,)'
+    };
+
+    function put(k, o) {
+        return function (_, cb) {
+            c.putObject(b, k, o, cb);
+        };
+    }
+
+    function expect(f, os) {
+        return function (_, cb) {
+            var res = c.findObjects(b, f, {
+                sort: {
+                    attribute: 'num'
+                }
+            });
+
+            var rows = [];
+            res.on('record', function (row) {
+                rows.push(row.value);
+            });
+
+            res.on('error', function (err) {
+                t.ifError(err, fmt('findObjects(%j)', f));
+                cb();
+            });
+
+            res.on('end', function () {
+                t.deepEqual(rows, os, fmt('findObjects(%j) results', f));
+                cb();
+            });
+        };
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, BUCKET_CFG, cb);
+            },
+
+            put(key1, obj1),
+            put(key2, obj2),
+            put(key3, obj3),
+            put(key4, obj4),
+
+            // "within" tests
+            expect('(num:within:=[-20,-10])', [ obj1, obj2 ]),
+            expect('(num:within:=\\(-20,-10])', [ obj2 ]),
+            expect('(num:within:=[-20.5,-19.5])', [ obj1 ]),
+            expect('(num:within:=[-20,-10\\))', [ obj1 ]),
+            expect('(num:within:=\\(0,\\))', [ obj3, obj4 ]),
+            expect('(num:within:=[10,20])', [ obj3, obj4 ]),
+            expect('(num:within:=[10,20\\))', [ obj3 ]),
+            expect('(num:within:=\\(10,20])', [ obj4 ]),
+            expect('(num:within:=[-15,15])', [ obj2, obj3 ]),
+            expect('(num:within:=[,])', [ obj1, obj2, obj3, obj4 ]),
+            expect('(num:within:=[,0])', [ obj1, obj2 ]),
+            expect('(num:within:=[,0\\))', [ obj1, obj2 ]),
+            expect('(num:within:=[0,])', [ obj3, obj4 ]),
+            expect('(num:within:=\\(0,])', [ obj3, obj4 ]),
+            expect('(num:within:=[-5,5])', []),
+            expect('(num:within:=[15,15])', []),
+
+            // "contains" tests
+            expect('(numrange:contains:=-15)', [ obj1, obj3 ]),
+            expect('(numrange:contains:=-10)', [ obj1, obj3 ]),
+            expect('(numrange:contains:=-5)', [ obj1, obj3 ]),
+            expect('(numrange:contains:=-4)', [ obj3 ]),
+            expect('(numrange:contains:=0)', [ obj3 ]),
+            expect('(numrange:contains:=4)', [ obj3 ]),
+            expect('(numrange:contains:=5)', [ obj3, obj4 ]),
+            expect('(numrange:contains:=15)', [ obj3, obj4 ]),
+            expect('(numrange:contains:=20)', [ obj4 ]),
+
+            // "overlaps" tests
+            expect('(numrange:overlaps:=\\(-16,-4\\))', [ obj1, obj3 ]),
+            expect('(numrange:overlaps:=\\(-14,-6\\))', [ obj1, obj3 ]),
+            expect('(numrange:overlaps:=[-10,-10])', [ obj1, obj3 ]),
+            expect('(numrange:overlaps:=[0,4])', [ obj3 ]),
+            expect('(numrange:overlaps:=[0,10])', [ obj2, obj3, obj4 ]),
+            expect('(numrange:overlaps:=[7,20])', [ obj2, obj3, obj4 ]),
+            expect('(numrange:overlaps:=[15,20])', [ obj3, obj4 ]),
+            expect('(numrange:overlaps:=\\(15,20])', [ obj4 ]),
+            expect('(numrange:overlaps:=[20,])', [ obj4 ]),
+            expect('(numrange:overlaps:=\\(,\\))', [ obj1, obj2, obj3, obj4 ]),
+            expect('(numrange:overlaps:=[,])', [ obj1, obj2, obj3, obj4 ])
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
+test('Date ranges - findObjects()', function (t) {
+    var key1 = uuid.v4();
+    var obj1 = {
+        date: '2016-06-05T16:23:04.776Z',
+        daterange: '[1758-05-06T00:00:00.000Z,1993-05-06T00:00:00.000Z]'
+    };
+
+    var key2 = uuid.v4();
+    var obj2 = {
+        date: '2017-06-05T16:23:04.776Z',
+        daterange: '(2018-01-01T12:00:00.000Z,2020-09-09T09:09:09.009Z)'
+    };
+
+    var key3 = uuid.v4();
+    var obj3 = {
+        date: '2018-03-09T12:00:00.000Z',
+        daterange: '(,2020-09-09T09:09:09.009Z]'
+    };
+
+    var key4 = uuid.v4();
+    var obj4 = {
+        date: '2018-06-05T14:30:00.000Z',
+        daterange: '[2005-05-05T05:05:05.555Z,)'
+    };
+
+    function put(k, o) {
+        return function (_, cb) {
+            c.putObject(b, k, o, cb);
+        };
+    }
+
+    function expect(f, os) {
+        return function (_, cb) {
+            var res = c.findObjects(b, f, {
+                sort: {
+                    attribute: 'date'
+                }
+            });
+
+            var rows = [];
+            res.on('record', function (row) {
+                rows.push(row.value);
+            });
+
+            res.on('error', function (err) {
+                t.ifError(err, fmt('findObjects(%j)', f));
+                cb();
+            });
+
+            res.on('end', function () {
+                t.deepEqual(rows, os, fmt('findObjects(%j) results', f));
+                cb();
+            });
+        };
+    }
+
+    vasync.pipeline({
+        funcs: [
+            function bucket(_, cb) {
+                c.putBucket(b, BUCKET_CFG, cb);
+            },
+
+            put(key1, obj1),
+            put(key2, obj2),
+            put(key3, obj3),
+            put(key4, obj4),
+
+            /* BEGIN JSSTYLED */
+
+            // "within" tests
+            expect('(date:within:=[2016-06-05T16:23:04.776Z,2017-06-05T16:23:04.776Z])', [ obj1, obj2 ]),
+            expect('(date:within:=\\(2016-06-05T16:23:04.776Z,2017-06-05T16:23:04.776Z])', [ obj2 ]),
+            expect('(date:within:=[2016-06-05T16:23:04.776Z,2017-06-05T16:23:04.776Z\\))', [ obj1 ]),
+            expect('(date:within:=\\(2018-01-01T12:00:00Z,\\))', [ obj3, obj4 ]),
+            expect('(date:within:=[2018-03-09T12:00:00Z,2018-06-05T14:30:00Z])', [ obj3, obj4 ]),
+            expect('(date:within:=[2018-03-09T12:00:00Z,2018-06-05T14:30:00Z\\))', [ obj3 ]),
+            expect('(date:within:=\\(2018-03-09T12:00:00Z,2018-06-05T14:30:00Z])', [ obj4 ]),
+            expect('(date:within:=[2017-01-01T12:00:00Z,2018-05-05T12:00:00Z])', [ obj2, obj3 ]),
+            expect('(date:within:=[,])', [ obj1, obj2, obj3, obj4 ]),
+            expect('(date:within:=[,2018-01-01T12:00:00Z])', [ obj1, obj2 ]),
+            expect('(date:within:=[,2018-01-01T12:00:00Z\\))', [ obj1, obj2 ]),
+            expect('(date:within:=[2018-01-01T12:00:00Z,])', [ obj3, obj4 ]),
+            expect('(date:within:=\\(2018-01-01T12:00:00Z,])', [ obj3, obj4 ]),
+
+            // "contains" tests
+            expect('(daterange:contains:=1758-05-06T00:00:00.000Z)', [ obj1, obj3 ]),
+            expect('(daterange:contains:=1814-08-24T00:00:00.000Z)', [ obj1, obj3 ]),
+            expect('(daterange:contains:=1945-05-08T00:00:00.000Z)', [ obj1, obj3 ]),
+            expect('(daterange:contains:=1962-07-05T00:00:00.000Z)', [ obj1, obj3 ]),
+            expect('(daterange:contains:=2005-04-27T00:00:00.000Z)', [ obj3 ]),
+            expect('(daterange:contains:=2010-12-17T00:00:00.000Z)', [ obj3, obj4 ]),
+            expect('(daterange:contains:=2999-12-31T23:59:59.999Z)', [ obj4 ]),
+
+            // "overlaps" tests
+            expect('(daterange:overlaps:=\\(1789-05-05T00:00:00.000Z,1799-11-09T00:00:00.000Z\\))', [ obj1, obj3 ]),
+            expect('(daterange:overlaps:=[1993-05-06T00:00:00.000Z,1993-05-06T00:00:00.000Z])', [ obj1, obj3 ]),
+            expect('(daterange:overlaps:=[2018-01-01T12:00:00.000Z,2999-12-31T23:59:59.999Z])', [ obj2, obj3, obj4 ]),
+            expect('(daterange:overlaps:=[2020-09-09T09:09:09.009Z,2020-09-09T09:09:09.009Z])', [ obj3, obj4 ]),
+            expect('(daterange:overlaps:=\\(2010-12-17T00:00:00.000Z,2013-06-06T00:00:00.000Z])', [ obj3, obj4 ]),
+            expect('(daterange:overlaps:=\\(1739-10-22T00:00:00.000Z,1748-10-18T00:00:00.000Z\\))', [ obj3 ]),
+            expect('(daterange:overlaps:=[2999-12-31T23:59:59.999Z,])', [ obj4 ]),
+            expect('(daterange:overlaps:=\\(,\\))', [ obj1, obj2, obj3, obj4 ]),
+            expect('(daterange:overlaps:=[,])', [ obj1, obj2, obj3, obj4 ])
+
+            /* END JSSTYLED */
+        ],
+        arg: null
+    }, function (err) {
+        t.ifError(err);
+        t.end();
+    });
+});
-- 
2.21.0

