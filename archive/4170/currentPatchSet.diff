commit 53d861d9982e9e8e63da29efec748f9f7184c8ca (refs/changes/70/4170/5)
Author: Robert Mustacchi <rm@joyent.com>
Date:   2018-06-11T21:26:27+00:00 (1 year, 4 months ago)
    
    OS-6947 ucode shouldn't need install step
    Reviewed by: Jason King <jason.king@joyent.com>
    Approved by: Cody Peter Mello <cody.mello@joyent.com>

diff --git a/Makefile b/Makefile
index c05357aa..a9b7e1a0 100644
--- a/Makefile
+++ b/Makefile
@@ -59,6 +59,7 @@ CSTYLE =	$(ROOT)/tools/cstyle
 MANCHECK =	$(ROOT)/tools/mancheck/mancheck
 MANCF =		$(ROOT)/tools/mancf/mancf
 TZCHECK =	$(ROOT)/tools/tzcheck/tzcheck
+UCODECHECK =	$(ROOT)/tools/ucodecheck/ucodecheck
 
 CTFBINDIR = \
 	$(ROOT)/projects/illumos/usr/src/tools/proto/*/opt/onbld/bin/i386
@@ -114,6 +115,7 @@ TOOLS_TARGETS = \
 	$(MANCHECK) \
 	$(MANCF) \
 	$(TZCHECK) \
+	$(UCODECHECK) \
 	tools/cryptpass
 
 world: 0-extra-stamp 0-illumos-stamp 1-extra-stamp 0-livesrc-stamp \
@@ -345,6 +347,10 @@ $(MANCHECK): 0-illumos-stamp
 $(TZCHECK): 0-illumos-stamp
 	(cd tools/tzcheck && gmake tzcheck CC=$(NATIVE_CC) $(SUBDIR_DEFS))
 
+.PHONY: $(UCODECHECK)
+$(UCODECHECK): 0-illumos-stamp
+	(cd tools/ucodecheck && gmake ucodecheck CC=$(NATIVE_CC) $(SUBDIR_DEFS))
+
 .PHONY: sdcman
 sdcman:
 	(cd $(ROOT)/man/sdc && gmake install DESTDIR=$(PROTO) $(SUBDIR_DEFS))
diff --git a/tools/build_live b/tools/build_live
index 340e0504..280c2dd8 100755
--- a/tools/build_live
+++ b/tools/build_live
@@ -178,6 +178,19 @@ function bi_run_tzcheck
 	bi_emit_done
 }
 
+function bi_run_ucodecheck
+{
+	local ucodecheck="$bi_wsroot/tools/ucodecheck/ucodecheck"
+
+	bi_emit_start 'Checking microcode files...'
+
+	if ! "$ucodecheck" -f "$bi_manifest" -p "$bi_wsroot/proto"; then
+		fail "not ucodecheck clean"
+	fi
+
+	bi_emit_done
+}
+
 #
 # Create a blank ramdisk image file, then attach it as a lofi device.
 #
@@ -327,38 +340,6 @@ function bi_smf_seeds
 	bi_emit_done
 }
 
-#
-# The ucode files that are installed by illumos for both Intel and AMD
-# are versions that have all of the different processors combined into
-# one file. However, the ucode update logic in the OS needs that to be
-# expanded into a per-processor file which is normally done by ucodeadm
-# as part of setting up a boot archive. To make sure that microcode
-# updates can be applied we take care of setting this up here. Over
-# time, we should change this to do it as part of the illumos build
-# process and likely illumos should just deliver the decomposed files.
-#
-function bi_expand_ucode
-{
-	local ucodeadm="/usr/sbin/ucodeadm -i -R "
-	local ucode_root="$bi_mnt_root/platform/i86pc/ucode"
-	local intc_file="$ucode_root/intel-ucode.txt"
-	local intc_dir="GenuineIntel"
-	local amd_file="$ucode_root/amd-ucode.bin"
-	local amd_dir="AuthenticAMD"
-
-	bi_emit_start 'Generating microcode files'
-
-	if ! pfexec $ucodeadm $ucode_root/$intc_dir $intc_file; then
-		fail "failed to generate Intel microcode files"
-	fi
-
-	if ! pfexec $ucodeadm $ucode_root/$amd_dir $amd_file; then
-		fail "failed to generate AMD microcode files"
-	fi
-
-	bi_emit_done
-}
-
 function bi_create_password
 {
 	local pwgen="$bi_wsroot/tools/pwgen"
@@ -904,6 +885,7 @@ bi_log_setup "$bi_wsroot/log/build_live.$bi_buildstamp.$(date +%s).log"
 #
 bi_run_mancheck
 bi_run_tzcheck
+bi_run_ucodecheck
 
 bi_setup_work_dir
 
@@ -957,7 +939,6 @@ bi_copy_files
 bi_gen_whatis
 bi_smf_import
 bi_smf_seeds
-bi_expand_ucode
 bi_create_password
 bi_gen_etcrelease
 bi_gen_buildstamp_module
diff --git a/tools/ucodecheck/.gitignore b/tools/ucodecheck/.gitignore
new file mode 100644
index 00000000..9c78c755
--- /dev/null
+++ b/tools/ucodecheck/.gitignore
@@ -0,0 +1,2 @@
+*.o
+ucodecheck
diff --git a/tools/ucodecheck/Makefile b/tools/ucodecheck/Makefile
new file mode 100644
index 00000000..bc9c5250
--- /dev/null
+++ b/tools/ucodecheck/Makefile
@@ -0,0 +1,65 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2018 Joyent, Inc.
+#
+
+PROG =		ucodecheck
+
+OBJECTS =					\
+		common.o			\
+		custr.o				\
+		ucodecheck.o			\
+		manifest.o			\
+		parser.o			\
+		strlist.o			\
+		strpath.o
+
+SRC =		$(OBJECTS:%=.o%.c)
+
+CFLAGS =					\
+		-Wall -Wextra -Werror 		\
+		-std=c99 			\
+		-D__EXTENSIONS__ 		\
+		-D_REENTRANT			\
+		-I../common			\
+		-I../../src/common/strings
+
+LDLIBS =					\
+		-lumem				\
+		-lavl
+
+
+ILLUMOS_SRC =	../../projects/illumos
+TOOLS_BIN =	$(ILLUMOS_SRC)/usr/src/tools/proto/root_i386-nd/opt/onbld/bin
+CC =		gcc
+ALTCTFCONVERT =	$(TOOLS_BIN)/i386/ctfconvert-altexec
+
+COMPILE_C =	$(CC) -c -gdwarf-2 $(CFLAGS) -o $@ $^
+
+all: $(PROG)
+
+%.o: %.c
+	$(COMPILE_C)
+
+%.o: ../common/%.c
+	$(COMPILE_C)
+
+%.o: ../../src/common/strings/%.c
+	$(COMPILE_C)
+
+$(PROG): $(OBJECTS)
+	$(CC) -o $@ $^ $(LDLIBS)
+	$(ALTCTFCONVERT) -l $(PROG) $@
+
+clean:
+	rm -f $(OBJECTS) $(PROG)
diff --git a/tools/ucodecheck/ucodecheck.c b/tools/ucodecheck/ucodecheck.c
new file mode 100644
index 00000000..98bf4cc4
--- /dev/null
+++ b/tools/ucodecheck/ucodecheck.c
@@ -0,0 +1,335 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Verify that all of the microcode files that we care about are shipped.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <strings.h>
+#include <libgen.h>
+#include <fcntl.h>
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/debug.h>
+#include <err.h>
+#include <errno.h>
+#include <dirent.h>
+#include <ctype.h>
+#include <sys/avl.h>
+#include <limits.h>
+#include <unistd.h>
+
+#include "common.h"
+#include "parser.h"
+#include "manifest.h"
+#include "custr.h"
+#include "strpath.h"
+
+static const char *ucc_progname;
+static const char *amd_ucodedir = "platform/i86pc/ucode/AuthenticAMD";
+static const char *intc_ucodedir = "platform/i86pc/ucode/GenuineIntel";
+
+typedef struct ucodecheck {
+	const char	*ucc_manifest_path;
+	const char	*ucc_proto_path;
+	int		ucc_proto_dir;
+	boolean_t	ucc_verbose;
+	avl_tree_t	ucc_manifest_ents;
+	avl_tree_t	ucc_proto_ents;
+	uint_t		ucc_errors;
+} ucodecheck_t;
+
+typedef struct ucode_ent {
+	avl_node_t uce_node;
+	char *uce_name;
+} ucode_ent_t;
+
+static int
+ucode_ent_comparator(const void *l, const void *r)
+{
+	int ret;
+	const ucode_ent_t *ll = l, *rr = r;
+
+	ret = strcmp(ll->uce_name, rr->uce_name);
+	return (ret < 0 ? -1 : ret > 0 ? 1 : 0);
+}
+
+/*
+ * We only concern ourselves with files that match the directory
+ */
+static me_cb_ret_t
+ucc_manifest_cb(manifest_ent_t *me, void *arg)
+{
+	ucodecheck_t *ucc = arg;
+	ucode_ent_t *ent;
+	avl_index_t where;
+
+	static size_t intc_len = 0;
+	static size_t amd_len = 0;
+
+	if (amd_len == 0) {
+		amd_len = strlen(amd_ucodedir);
+	}
+
+	if (intc_len == 0) {
+		intc_len = strlen(intc_ucodedir);
+	}
+
+	if (strncmp(amd_ucodedir, me->me_name, amd_len) != 0 &&
+	    strncmp(intc_ucodedir, me->me_name, intc_len) != 0) {
+		return (MECB_NEXT);
+	}
+
+	/*
+	 * The only entries we expect in here are files and the directory entry
+	 * themselves. If for some reason they exist, then we need to error and
+	 * figure out what happened.
+	 */
+	if (me->me_type != ME_TYPE_FILE) {
+		if (me->me_type == ME_TYPE_DIRECTORY)
+			return (MECB_NEXT);
+
+		err(EXIT_FAILURE, "encountered manifest entry (%s) with "
+		    "unexpected type: %u", me->me_name, me->me_type);
+	}
+
+	if ((ent = malloc(sizeof (ucode_ent_t))) == NULL) {
+		err(EXIT_FAILURE, "failed to allocate memory for ucode entry "
+		    "for manifest entry %s", me->me_name);
+	}
+
+	ent->uce_name = strdup(me->me_name);
+	if (ent->uce_name == NULL) {
+		err(EXIT_FAILURE, "failed to duplicate name for ucode entry "
+		    "%s", ent->uce_name);
+	}
+
+	if (avl_find(&ucc->ucc_manifest_ents, ent, &where) != NULL) {
+		err(EXIT_FAILURE, "encountered duplicated ucode entry for %s",
+		    ent->uce_name);
+	}
+
+	avl_insert(&ucc->ucc_manifest_ents, ent, where);
+
+	return (MECB_NEXT);
+}
+
+static void
+ucc_read_proto(ucodecheck_t *ucc, const char *dir)
+{
+	uint_t nfound = 0;
+	int dirfd;
+	DIR *d;
+	struct dirent *dp;
+
+	if ((dirfd = openat(ucc->ucc_proto_dir, dir, O_RDONLY)) < 0) {
+		err(EXIT_FAILURE, "failed to open proto directory %s, current "
+		    "root is at %s", dir, ucc->ucc_proto_path);
+	}
+
+	if ((d = fdopendir(dirfd)) == NULL) {
+		err(EXIT_FAILURE, "failed to turn proto fd dir to DIR *");
+	}
+
+	while ((dp = readdir(d)) != NULL) {
+		struct stat st;
+		ucode_ent_t *ent;
+		avl_index_t where;
+
+		if (strcmp(dp->d_name, ".") == 0)
+			continue;
+		if (strcmp(dp->d_name, "..") == 0)
+			continue;
+
+		if (fstatat(dirfd, dp->d_name, &st, AT_SYMLINK_NOFOLLOW) != 0) {
+			err(EXIT_FAILURE, "failed to stat \"%s/%s\"", dir,
+			    dp->d_name);
+		}
+
+		if (!S_ISREG(st.st_mode)) {
+			errx(EXIT_FAILURE, "encountered non-regular file at "
+			    "\"%s/%s\"", dir, dp->d_name);
+		}
+
+
+		if ((ent = malloc(sizeof (ucode_ent_t))) == NULL) {
+			err(EXIT_FAILURE, "failed to allocate memory for "
+			    "ucode entry for proto entry %s/%s", dir,
+			    dp->d_name);
+		}
+
+		if (asprintf(&ent->uce_name, "%s/%s", dir, dp->d_name) == -1) {
+			err(EXIT_FAILURE, "failed to duplicate name for ucode "
+			    "entry %s", ent->uce_name);
+		}
+
+		if (avl_find(&ucc->ucc_proto_ents, ent, &where) != NULL) {
+			errx(EXIT_FAILURE, "encountered duplicated ucode entry "
+			    "for %s", ent->uce_name);
+		}
+
+		avl_insert(&ucc->ucc_proto_ents, ent, where);
+
+		nfound++;
+	}
+
+	if (nfound == 0) {
+		errx(EXIT_FAILURE, "failed to find ucode files at \"%s/%s\", "
+		    "suspicious build", dir, dp->d_name);
+	}
+
+	if (closedir(d) != 0) {
+		err(EXIT_FAILURE, "failed to close directory %s", dir);
+	}
+
+	if (ucc->ucc_verbose) {
+		printf("found %u entries in %s\n", nfound, dir);
+	}
+}
+
+/*
+ * For each entry in the proto AVL, make sure we found the corresponding entry
+ * in the manifest. Note we don't check the reverse (that every entry in the
+ * manifest is here) as that is the job of the general build tools.
+ */
+static void
+ucc_check_proto(ucodecheck_t *ucc)
+{
+	ucode_ent_t *ent;
+
+	for (ent = avl_first(&ucc->ucc_proto_ents); ent != NULL;
+	    ent = AVL_NEXT(&ucc->ucc_proto_ents, ent)) {
+		ucode_ent_t *manifest;
+
+		manifest = avl_find(&ucc->ucc_manifest_ents, ent, NULL);
+		if (manifest == NULL) {
+			(void) fprintf(stderr, "missing from manifest: %s\n",
+			    ent->uce_name);
+			ucc->ucc_errors++;
+			continue;
+		}
+
+		if (ucc->ucc_verbose) {
+			(void) printf("%s OK\n", ent->uce_name);
+		}
+	}
+}
+
+static void
+ucc_usage(const char *fmt, ...)
+{
+	if (fmt != NULL) {
+		va_list ap;
+
+		(void) fprintf(stderr, "%s: ", ucc_progname);
+		va_start(ap, fmt);
+		(void) vfprintf(stderr, fmt, ap);
+		va_end(ap);
+		(void) fputs("\n", stderr);
+	}
+
+	(void) fprintf(stderr, "Usage: %s [-v] -f manifest -p proto\n"
+	    "\n"
+	    "Check for consistency between microcode files in the proto area "
+	    "and manifest\n"
+	    "\n"
+	    "\t-f  Use manifest file manifest to search\n"
+	    "\t-h  Show this message\n"
+	    "\t-p  Path to proto area to search\n"
+	    "\t-v  Verbose (print on success as well as on error)\n",
+	    ucc_progname);
+}
+
+int
+main(int argc, char *argv[])
+{
+	int c, fd;
+	ucodecheck_t ucc;
+
+	ucc_progname = basename(argv[0]);
+	bzero(&ucc, sizeof (ucc));
+
+	while ((c = getopt(argc, argv, ":f:hp:v")) != -1) {
+		switch (c) {
+		case 'f':
+			ucc.ucc_manifest_path = strdup(optarg);
+			if (ucc.ucc_manifest_path == NULL) {
+				err(EXIT_FAILURE, "failed to allocate memory "
+				    "for manifest path");
+			}
+			break;
+		case 'p':
+			ucc.ucc_proto_path = strdup(optarg);
+			if (ucc.ucc_proto_path == NULL) {
+				err(EXIT_FAILURE, "failed to allocate memory "
+				    "for proto path");
+			}
+			break;
+		case 'h':
+			ucc_usage(NULL);
+			return (2);
+		case 'v':
+			ucc.ucc_verbose = B_TRUE;
+			break;
+		case ':':
+			ucc_usage("Option -%c requires an operand\n", optopt);
+			return (2);
+		case '?':
+			ucc_usage("Unrecognised option: -%c\n", optopt);
+			return (2);
+		}
+	}
+
+	if (ucc.ucc_manifest_path == NULL) {
+		ucc_usage("missing required manifest path (-f)");
+		return (2);
+	}
+
+	if (ucc.ucc_proto_path == NULL) {
+		ucc_usage("missing required proto path (-p)");
+		return (2);
+	}
+
+	if ((fd = open(ucc.ucc_proto_path, O_RDONLY)) < 0) {
+		err(EXIT_FAILURE, "failed to open proto path %s",
+		    ucc.ucc_proto_path);
+	}
+	ucc.ucc_proto_dir = fd;
+
+	avl_create(&ucc.ucc_manifest_ents, ucode_ent_comparator,
+	    sizeof (ucode_ent_t), offsetof(ucode_ent_t, uce_node));
+	avl_create(&ucc.ucc_proto_ents, ucode_ent_comparator,
+	    sizeof (ucode_ent_t), offsetof(ucode_ent_t, uce_node));
+
+	if (read_manifest_file(ucc.ucc_manifest_path, ucc_manifest_cb,
+	    &ucc) != 0) {
+		err(EXIT_FAILURE, "failed to read manifest file\n");
+	}
+
+	ucc_read_proto(&ucc, amd_ucodedir);
+	ucc_read_proto(&ucc, intc_ucodedir);
+
+	ucc_check_proto(&ucc);
+
+	if (ucc.ucc_errors > 0) {
+		errx(EXIT_FAILURE, "ucode errors found: %u", ucc.ucc_errors);
+	}
+
+	return (0);
+}
