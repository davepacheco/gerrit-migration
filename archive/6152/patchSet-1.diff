commit 31fa3767c78f81ed3197f90c66bd3165ca547a49
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2019-04-23T15:47:22-06:00 (6 months ago)
    
    MANTA-4239 Return proper errors from boray when buckets or objects are not found or already exist

diff --git a/src/bucket.rs b/src/bucket.rs
index 456d85c..03b9a59 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -19,6 +19,7 @@ use rust_fast::protocol::{FastMessage, FastMessageData};
 
 type Timestamptz = chrono::DateTime<chrono::Utc>;
 
+
 #[derive(Serialize, Deserialize)]
 pub struct GetBucketPayload {
     owner     : Uuid,
@@ -169,12 +170,25 @@ pub fn put_handler(msg_id: u32,
 
     // Make db request and form response
     put(payload, pool)
-        .and_then(|resp| {
+        .and_then(|maybe_resp| {
             let method = String::from("putbucket");
-            let value = array_wrap(serde_json::to_value(resp).unwrap());
-            let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-            response.push(msg);
-            Ok(response)
+            match maybe_resp {
+                Some(resp) => {
+                    let value = array_wrap(serde_json::to_value(resp).unwrap());
+                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(msg);
+                    Ok(response)
+                },
+                None => {
+                    let value = json!({
+                        "name": "BucketAlreadyExistsError",
+                        "message": "requested bucket already exists"
+                    });
+                    let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, value));
+                    response.push(err_msg);
+                    Ok(response)
+                }
+            }
         })
         //TODO: Proper error handling
         .map_err(|_e| other_error("postgres error"))
@@ -198,33 +212,41 @@ pub fn delete_handler(msg_id: u32,
 
     let payload = match payload_result {
         Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for deletebucket function"))
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload \
+                                          for deletebucket function"))
     };
 
     // Make db request and form response
     let response_msg: Result<FastMessage, IOError> =
         delete(payload, pool)
-        .and_then(|resp| {
+        .and_then(|affected_rows| {
             let method = String::from("deletebucket");
-            let value = array_wrap(serde_json::to_value(resp).unwrap());
-            let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-            // response.push(msg);
-            // Ok(response)
-            Ok(msg)
+            if affected_rows > 0 {
+                let value = array_wrap(serde_json::to_value(affected_rows).unwrap());
+                let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                Ok(msg)
+            } else {
+                let value = json!({
+                    "name": "BucketNotFoundError",
+                    "message": "requested bucket not found"
+                });
+                let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, value));
+                Ok(err_msg)
+            }
         })
         .or_else(|e| {
-            let method = String::from("deletebucket");
-            // let err_str = format!("{}", e);
+            // TODO: Write a helper function to deconstruct the postgres::Error
+            // and populate meaningful name and message fields for the error
+            // dependent on the details of the postgres error.
+            let err_str = format!("{}", e);
             let value = array_wrap(json!({
-                "name": "BucketNotFoundError",
-                "message": e.to_string()
+                "name": "PostgresError",
+                "message": err_str
             }));
-            // let value = array_wrap(serde_json::to_value(e).unwrap());
-            let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, value));
-            // response.push(err_msg);
-            // Ok(response)
+            let method = String::from("deletebucket");
+            let err_msg_data = FastMessageData::new(method, value);
+            let err_msg = FastMessage::error(msg_id, err_msg_data);
             Ok(err_msg)
-            // other_error()
         });
 
     response.push(response_msg.unwrap());
@@ -271,6 +293,7 @@ fn put_sql(vnode: &u64) -> String {
      &".manta_bucket \
        (id, owner, name) \
        VALUES ($1, $2, $3) \
+       ON CONFLICT DO NOTHING \
        RETURNING id, owner, name, created"].concat()
 }
 
diff --git a/src/object.rs b/src/object.rs
index a821c36..1d5ab9a 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -223,20 +223,45 @@ pub fn delete_handler(msg_id: u32,
 
     let payload = match payload_result {
         Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for deleteobject function"))
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload \
+                                          for deleteobject function"))
     };
 
     // Make db request and form response
-    delete(payload, pool)
-        .and_then(|resp| {
+    let response_msg: Result<FastMessage, IOError> =
+        delete(payload, pool)
+        .and_then(|affected_rows| {
             let method = String::from("deleteobject");
-            let value = array_wrap(serde_json::to_value(resp).unwrap());
-            let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-            response.push(msg);
-            Ok(response)
+            if affected_rows > 0 {
+                let value = array_wrap(serde_json::to_value(affected_rows).unwrap());
+                let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                Ok(msg)
+            } else {
+                let value = json!({
+                    "name": "ObjectNotFoundError",
+                    "message": "requested object not found"
+                });
+                let err_msg = FastMessage::error(msg_id, FastMessageData::new(method, value));
+                Ok(err_msg)
+            }
         })
-        //TODO: Proper error handling
-        .map_err(|_e| other_error("postgres error"))
+        .or_else(|e| {
+            // TODO: Write a helper function to deconstruct the postgres::Error
+            // and populate meaningful name and message fields for the error
+            // dependent on the details of the postgres error.
+            let err_str = format!("{}", e);
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": err_str
+            }));
+            let method = String::from("deleteobject");
+            let err_msg_data = FastMessageData::new(method, value);
+            let err_msg = FastMessage::error(msg_id, err_msg_data);
+            Ok(err_msg)
+        });
+
+    response.push(response_msg.unwrap());
+    Ok(response)
 }
 
 fn array_wrap(v: Value) -> Value {
