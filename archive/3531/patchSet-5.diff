From c34f7c2c834dc5a9b871356c0f85214dc25c5881 Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Sun, 14 Jan 2018 17:54:27 +0000
Subject: [PATCH] OS-6669 create bhyve brand Reviewed by: Dan McDonald
 <danmcd@joyent.com> Reviewed by: Jerry Jelinek <jerry.jelinek@joyent.com>
 Approved by: Jerry Jelinek <jerry.jelinek@joyent.com>

---
 manifest                                  |   9 +
 usr/src/Targetdirs                        |  25 +-
 usr/src/cmd/bhyve/Makefile                |  10 +-
 usr/src/cmd/bhyve/Makefile.com            |  10 +-
 usr/src/cmd/bhyve/bhyverun.c              |  15 +-
 usr/src/cmd/bhyve/smbiostbl.c             |  78 ++++
 usr/src/cmd/bhyve/smbiostbl.h             |   5 +
 usr/src/cmd/bhyve/zhyve.c                 | 170 ++++++++
 usr/src/cmd/zoneadmd/zoneadmd.c           |   4 +
 usr/src/lib/brand/Makefile                |   3 +-
 usr/src/lib/brand/bhyve/Makefile          |  32 ++
 usr/src/lib/brand/bhyve/Makefile.bhyve    |  17 +
 usr/src/lib/brand/bhyve/zone/Makefile     |  42 ++
 usr/src/lib/brand/bhyve/zone/SYSbhyve.xml |   9 +
 usr/src/lib/brand/bhyve/zone/attach       |  26 ++
 usr/src/lib/brand/bhyve/zone/boot.c       | 487 ++++++++++++++++++++++
 usr/src/lib/brand/bhyve/zone/config.xml   |  70 ++++
 usr/src/lib/brand/bhyve/zone/detach       |  19 +
 usr/src/lib/brand/bhyve/zone/platform.xml | 142 +++++++
 usr/src/lib/brand/bhyve/zone/statechange  |  18 +
 usr/src/lib/brand/bhyve/zone/uninstall    |  23 +
 usr/src/lib/libvmmapi/common/vmmapi.c     |   8 -
 22 files changed, 1194 insertions(+), 28 deletions(-)
 create mode 100644 usr/src/cmd/bhyve/zhyve.c
 create mode 100644 usr/src/lib/brand/bhyve/Makefile
 create mode 100644 usr/src/lib/brand/bhyve/Makefile.bhyve
 create mode 100644 usr/src/lib/brand/bhyve/zone/Makefile
 create mode 100644 usr/src/lib/brand/bhyve/zone/SYSbhyve.xml
 create mode 100755 usr/src/lib/brand/bhyve/zone/attach
 create mode 100644 usr/src/lib/brand/bhyve/zone/boot.c
 create mode 100644 usr/src/lib/brand/bhyve/zone/config.xml
 create mode 100755 usr/src/lib/brand/bhyve/zone/detach
 create mode 100644 usr/src/lib/brand/bhyve/zone/platform.xml
 create mode 100644 usr/src/lib/brand/bhyve/zone/statechange
 create mode 100755 usr/src/lib/brand/bhyve/zone/uninstall

diff --git a/manifest b/manifest
index a153fb51a8..ba9cd9bf8b 100644
--- a/manifest
+++ b/manifest
@@ -525,6 +525,7 @@ d etc/xdg/autostart 0755 root sys
 d etc/zfs 0755 root sys
 d etc/zones 0755 root sys
 f etc/zones/SUNWblank.xml 0444 root bin
+f etc/zones/SYSbhyve.xml 0444 root bin
 f etc/zones/index 0644 root sys
 s etc/zprofile=profile
 d kernel 0755 root sys
@@ -5091,6 +5092,14 @@ f usr/lib/audit/audit_record_attr 0444 root bin
 d usr/lib/autofs 0755 root sys
 f usr/lib/autofs/automountd 0555 root bin
 d usr/lib/brand 0755 root bin
+d usr/lib/brand/bhyve 0555 root sys
+f usr/lib/brand/bhyve/attach 0555 root sys
+f usr/lib/brand/bhyve/boot 0555 root sys
+f usr/lib/brand/bhyve/detach 0555 root sys
+f usr/lib/brand/bhyve/uninstall 0555 root sys
+f usr/lib/brand/bhyve/config.xml 0444 root sys
+f usr/lib/brand/bhyve/platform.xml 0444 root sys
+f usr/lib/brand/bhyve/statechange 0555 root sys
 d usr/lib/brand/lx 0755 root bin
 s usr/lib/brand/lx/64=amd64
 d usr/lib/brand/lx/amd64 0755 root bin
diff --git a/usr/src/Targetdirs b/usr/src/Targetdirs
index c8e8df75cb..e7ec8b9a39 100644
--- a/usr/src/Targetdirs
+++ b/usr/src/Targetdirs
@@ -28,6 +28,7 @@
 # Copyright 2016 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
 # Copyright 2016 Nexenta Systems, Inc.
 # Copyright 2017 RackTop Systems.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -47,20 +48,22 @@ $(BUILD64)	TARGETDIRS += $(DIRS64)
 
 TARGETDIRS	+= $(FILELINKS) $(DIRLINKS)
 
-i386_DIRS=			\
-	/boot/acpi		\
-	/boot/acpi/tables	\
-	/boot/grub		\
-	/boot/grub/bin		\
-	/platform/i86pc		\
-	/lib/libmvec		\
-	/usr/lib/brand/lx	\
+i386_DIRS= \
+	/boot/acpi \
+	/boot/acpi/tables \
+	/boot/grub \
+	/boot/grub/bin \
+	/lib/libmvec \
+	/platform/i86pc \
+	/usr/lib/brand/bhyve \
+	/usr/lib/brand/lx \
 	/usr/lib/brand/lx/amd64 \
 	/usr/lib/brand/lx/distros \
-	/usr/lib/xen		\
-	/usr/lib/xen/bin
+	/usr/lib/xen \
+	/usr/lib/xen/bin \
+	/usr/share/bhyve
 
-sparc_DIRS=				\
+sparc_DIRS= \
 	/usr/lib/ldoms
 
 sparc_64ONLY= $(POUND_SIGN)
diff --git a/usr/src/cmd/bhyve/Makefile b/usr/src/cmd/bhyve/Makefile
index f47daead31..0ffbff6b6f 100644
--- a/usr/src/cmd/bhyve/Makefile
+++ b/usr/src/cmd/bhyve/Makefile
@@ -11,9 +11,11 @@
 
 #
 # Copyright 2014 Pluribus Networks Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 PROG =		bhyve
+ZHYVE =		$(ROOT)/usr/lib/brand/bhyve/zhyve
 
 include ../Makefile.cmd
 
@@ -29,9 +31,11 @@ lint	:=	TARGET = lint
 
 all clean clobber lint:	$(SUBDIRS)
 
-install: $(SUBDIRS)
-	-$(RM) $(ROOTUSRSBINPROG)
-	-$(LN) $(ISAEXEC) $(ROOTUSRSBINPROG)
+install: $(SUBDIRS) $(USRSHAREFILES)
+	$(RM) $(ROOTUSRSBINPROG)
+	$(LN) $(ISAEXEC) $(ROOTUSRSBINPROG)
+	$(RM) $(ZHYVE)
+	$(LN) $(ROOTUSRSBIN64)/$(PROG) $(ZHYVE)
 
 $(SUBDIRS):	FRC
 	@cd $@; pwd; $(MAKE) CW_NO_SHADOW=true __GNUC= $(TARGET)
diff --git a/usr/src/cmd/bhyve/Makefile.com b/usr/src/cmd/bhyve/Makefile.com
index b9ad3fde70..1f7e87e074 100644
--- a/usr/src/cmd/bhyve/Makefile.com
+++ b/usr/src/cmd/bhyve/Makefile.com
@@ -11,7 +11,7 @@
 
 #
 # Copyright 2015 Pluribus Networks Inc.
-# Copyright 2017 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 PROG= bhyve
@@ -61,7 +61,8 @@ SRCS =	acpi.c			\
 	vmm_instruction_emul.c	\
 	xmsr.c			\
 	spinup_ap.c		\
-	bhyve_sol_glue.c
+	bhyve_sol_glue.c	\
+	zhyve.c
 
 OBJS = $(SRCS:.c=.o)
 
@@ -83,10 +84,13 @@ CPPFLAGS =	-I$(COMPAT)/freebsd -I$(CONTRIB)/freebsd \
 		-I$(SRC)/uts/i86pc \
 		-I$(SRC)/lib/libdladm/common \
 		-DWITHOUT_CAPSICUM
-LDLIBS +=	-lsocket -lnsl -ldlpi -ldladm -lkstat -lmd -luuid -lvmmapi -lz
+LDLIBS +=	-lsocket -lnsl -ldlpi -ldladm -lmd -luuid -lvmmapi -lz -lnvpair
 
 POST_PROCESS += ; $(GENSETDEFS) $@
 
+# Real main is in zhyve.c
+bhyverun.o :=	CPPFLAGS += -Dmain=bhyve_main
+
 all: $(PROG)
 
 $(PROG): $(OBJS)
diff --git a/usr/src/cmd/bhyve/bhyverun.c b/usr/src/cmd/bhyve/bhyverun.c
index de8084d0f1..7a19ffd2a4 100644
--- a/usr/src/cmd/bhyve/bhyverun.c
+++ b/usr/src/cmd/bhyve/bhyverun.c
@@ -129,6 +129,7 @@ int bcons_wait = 0;
 int bcons_connected = 0;
 pthread_mutex_t bcons_wait_lock = PTHREAD_MUTEX_INITIALIZER;
 pthread_cond_t bcons_wait_done = PTHREAD_COND_INITIALIZER;
+void (*vm_started_cb)(void) = NULL;
 #endif
 
 static cpuset_t cpumask;
@@ -881,9 +882,9 @@ main(int argc, char *argv[])
 	memflags = 0;
 
 #ifdef	__FreeBSD__
-	optstr = "abehuwxACHIPSWYp:g:c:s:m:l:U:";
+	optstr = "abehuwxACHIPSWYp:g:c:s:m:l:B:U:";
 #else
-	optstr = "abehuwxACHIPSWYg:c:s:m:l:U:";
+	optstr = "abehuwxACHIPSWYg:c:s:m:l:B:U:";
 #endif
 	while ((c = getopt(argc, argv, optstr)) != -1) {
 		switch (c) {
@@ -896,6 +897,12 @@ main(int argc, char *argv[])
 		case 'b':
 			bvmcons = 1;
 			break;
+		case 'B':
+			if (smbios_parse(optarg) != 0) {
+				errx(EX_USAGE, "invalid SMBIOS "
+				    "configuration '%s'", optarg);
+			}
+			break;
 #ifdef	__FreeBSD__
 		case 'p':
 			if (pincpu_parse(optarg) != 0) {
@@ -1107,6 +1114,10 @@ main(int argc, char *argv[])
 #ifdef	__FreeBSD__
 	mevent_dispatch();
 #else
+	if (vm_started_cb != NULL) {
+		vm_started_cb();
+	}
+
 	pthread_exit(NULL);
 #endif
 
diff --git a/usr/src/cmd/bhyve/smbiostbl.c b/usr/src/cmd/bhyve/smbiostbl.c
index 59a1358bd0..c11500be63 100644
--- a/usr/src/cmd/bhyve/smbiostbl.c
+++ b/usr/src/cmd/bhyve/smbiostbl.c
@@ -33,6 +33,7 @@ __FBSDID("$FreeBSD$");
 #include <errno.h>
 #include <md5.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <uuid.h>
@@ -825,3 +826,80 @@ smbios_build(struct vmctx *ctx)
 
 	return (0);
 }
+
+int
+smbios_parse(const char *opts)
+{
+	char *buf;
+	char *lasts;
+	char *token;
+	char *end;
+	long type;
+	struct {
+		const char *key;
+		const char **targetp;
+	} type1_map[] = {
+		{ "manufacturer", &smbios_type1_strings[0] },
+		{ "product", &smbios_type1_strings[1] },
+		{ "version", &smbios_type1_strings[2] },
+		{ "serial", &smbios_type1_strings[3] },
+		{ "sku", &smbios_type1_strings[4] },
+		{ "family", &smbios_type1_strings[5] },
+		{ "uuid", (const char **)&guest_uuid_str },
+		{ 0 }
+	};
+
+	if ((buf = strdup(opts)) == NULL) {
+		(void) fprintf(stderr, "out of memory\n");
+		return (-1);
+	}
+
+	if ((token = strtok_r(buf, ",", &lasts)) == NULL) {
+		(void) fprintf(stderr, "too few fields\n");
+		goto fail;
+	}
+
+	errno = 0;
+	type = strtol(token, &end, 10);
+	if (errno != 0 || *end != '\0') {
+		(void) fprintf(stderr, "first token '%s' is not an integer\n",
+		    token);
+		goto fail;
+	}
+
+	/* For now, only type 1 is supported. */
+	if (type != 1) {
+		(void) fprintf(stderr, "unsupported type %d\n", type);
+		goto fail;
+	}
+
+	while ((token = strtok_r(NULL, ",", &lasts)) != NULL) {
+		char *val;
+		int i;
+
+		if ((val = strchr(token, '=')) == NULL) {
+			(void) fprintf(stderr, "invalid key=value: '%s'\n",
+			    token);
+			goto fail;
+		}
+		*val = '\0';
+		val++;
+
+		for (i = 0; type1_map[i].key != NULL; i++) {
+			if (strcmp(token, type1_map[i].key) == 0) {
+				break;
+			}
+		}
+		if (type1_map[i].key == NULL) {
+			(void) fprintf(stderr, "invalid key '%s'\n", token);
+			goto fail;
+		}
+		*type1_map[i].targetp = val;
+	}
+
+	return (0);
+
+fail:
+	free(buf);
+	return (-1);
+}
diff --git a/usr/src/cmd/bhyve/smbiostbl.h b/usr/src/cmd/bhyve/smbiostbl.h
index e8b3a4fe29..6101859fbd 100644
--- a/usr/src/cmd/bhyve/smbiostbl.h
+++ b/usr/src/cmd/bhyve/smbiostbl.h
@@ -26,11 +26,16 @@
  * $FreeBSD$
  */
 
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
 #ifndef _SMBIOSTBL_H_
 #define _SMBIOSTBL_H_
 
 struct vmctx;
 
 int	smbios_build(struct vmctx *ctx);
+int	smbios_parse(const char *opts);
 
 #endif /* _SMBIOSTBL_H_ */
diff --git a/usr/src/cmd/bhyve/zhyve.c b/usr/src/cmd/bhyve/zhyve.c
new file mode 100644
index 0000000000..6162731037
--- /dev/null
+++ b/usr/src/cmd/bhyve/zhyve.c
@@ -0,0 +1,170 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <libnvpair.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#define	ZHYVE_CMD_FILE	"/var/run/bhyve/zhyve.cmd"
+#define	ZHYVE_LOG_FILE	"/tmp/zhyve.log"
+
+#define	FILE_PROVISIONING	"/var/svc/provisioning"
+#define	FILE_PROVISION_SUCCESS	"/var/svc/provision_success"
+
+extern int bhyve_main(int, char **);
+void (*vm_started_cb)(void);
+const char *cmdname;
+
+/*
+ * Much like basename() but does not alter the path passed to it.
+ */
+static void
+get_cmdname(const char *path)
+{
+	cmdname = strrchr(path, '/');
+	if (cmdname == NULL) {
+		cmdname = path;
+		return;
+	}
+	assert(*cmdname == '/');
+	cmdname++;
+}
+
+/*
+ * Do a read of the specified size or return an error.  Returns 0 on success
+ * and -1 on error.  Sets errno to EINVAL if EOF is encountered.  For other
+ * errors, see read(2).
+ */
+static int
+full_read(int fd, char *buf, size_t len)
+{
+	ssize_t nread = 0;
+	size_t totread = 0;
+
+	while (totread < len) {
+		nread = read(fd, buf + totread, len - totread);
+		if (nread == 0) {
+			errno = EINVAL;
+			return (-1);
+		}
+		if (nread < 0) {
+			if (errno == EINTR || errno == EAGAIN) {
+				continue;
+			}
+			return (-1);
+		}
+		totread += nread;
+	}
+	assert(totread == len);
+
+	return (0);
+}
+
+/*
+ * Reads the command line options from the packed nvlist in the file referenced
+ * by path.  On success, 0 is returned and the members of *argv reference memory
+ * allocated from an nvlist.  On failure, -1 is returned.
+ */
+
+static int
+parse_options_file(const char *path, uint *argcp, char ***argvp)
+{
+	int fd = -1;
+	struct stat stbuf;
+	char *buf = NULL;
+	nvlist_t *nvl = NULL;
+	int ret;
+
+	if ((fd = open(path, O_RDONLY)) < 0 ||
+	    fstat(fd, &stbuf) != 0 ||
+	    (buf = malloc(stbuf.st_size)) == NULL ||
+	    full_read(fd, buf, stbuf.st_size) != 0 ||
+	    nvlist_unpack(buf, stbuf.st_size, &nvl, 0) != 0 ||
+	    nvlist_lookup_string_array(nvl, "zhyve_args", argvp, argcp) != 0) {
+		nvlist_free(nvl);
+		ret = -1;
+	} else {
+		ret = 0;
+	}
+
+	free(buf);
+	(void) close(fd);
+
+	(void) printf("Configuration from %s:\n", path);
+	nvlist_print(stdout, nvl);
+
+	return (ret);
+}
+
+static void
+mark_provisioned(void)
+{
+	if (rename(FILE_PROVISIONING, FILE_PROVISION_SUCCESS) != 0) {
+		(void) fprintf(stderr, "Cannot rename %s to %s: %s\n",
+		    FILE_PROVISIONING, FILE_PROVISION_SUCCESS,
+		    strerror(errno));
+	}
+}
+
+int
+main(int argc, char **argv)
+{
+	uint zargc;
+	char **zargv;
+	int fd;
+	struct stat stbuf;
+
+	get_cmdname(argv[0]);
+	if (strcmp(cmdname, "zhyve") != 0) {
+		return (bhyve_main(argc, argv));
+	}
+
+	fd = open("/dev/null", O_WRONLY);
+	assert(fd >= 0);
+	if (fd != STDIN_FILENO) {
+		(void) dup2(fd, STDIN_FILENO);
+		(void) close(fd);
+	}
+	fd = open(ZHYVE_LOG_FILE, O_WRONLY|O_CREAT|O_APPEND, 0644);
+	assert(fd >= 0);
+	(void) dup2(fd, STDOUT_FILENO);
+	setvbuf(stdout, NULL, _IONBF, 0);
+	(void) dup2(fd, STDERR_FILENO);
+	setvbuf(stderr, NULL, _IONBF, 0);
+	if (fd != STDOUT_FILENO && fd != STDERR_FILENO) {
+		(void) close(fd);
+	}
+
+	if (parse_options_file(ZHYVE_CMD_FILE, &zargc, &zargv) != 0) {
+		(void) fprintf(stderr, "%s: failed to parse %s: %s\n",
+		    cmdname, ZHYVE_CMD_FILE, strerror(errno));
+		return (1);
+	}
+
+	if (lstat(FILE_PROVISIONING, &stbuf) == 0) {
+		vm_started_cb = mark_provisioned;
+	}
+
+	return (bhyve_main(zargc, zargv));
+}
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.c b/usr/src/cmd/zoneadmd/zoneadmd.c
index 1d5d63a9a2..196ccaf263 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.c
+++ b/usr/src/cmd/zoneadmd/zoneadmd.c
@@ -840,11 +840,15 @@ setup_subproc_env(boolean_t debug)
 	struct zone_attrtab atab;
 	char net_resources[MAXNAMELEN * 2];
 	char dev_resources[MAXNAMELEN * 2];
+	char didstr[16];
 
 	/* snap_hndl is null when called through the set_brand_env code path */
 	if (snap_hndl == NULL)
 		return (Z_OK);
 
+	(void) snprintf(didstr, sizeof (didstr), "%d", zone_did);
+	(void) setenv("_ZONECFG_did", didstr, 1);
+
 	/*
 	 * "net" resources are exported because zoneadmd does not handle
 	 * automatic configuration of vnics and so that the bhyve boot hook
diff --git a/usr/src/lib/brand/Makefile b/usr/src/lib/brand/Makefile
index cd19a0bf2c..bab69e385a 100644
--- a/usr/src/lib/brand/Makefile
+++ b/usr/src/lib/brand/Makefile
@@ -20,6 +20,7 @@
 #
 #
 # Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2018, Joyent, Inc.
 #
 # lib/brand/Makefile
 #
@@ -30,7 +31,7 @@ include ../../Makefile.master
 # Build everything in parallel; use .WAIT for dependencies
 .PARALLEL:
 
-i386_SUBDIRS= lx
+i386_SUBDIRS= lx bhyve
 i386_MSGSUBDIRS= lx
 
 SUBDIRS= shared .WAIT sn1 solaris10 ipkg labeled $($(MACH)_SUBDIRS)
diff --git a/usr/src/lib/brand/bhyve/Makefile b/usr/src/lib/brand/bhyve/Makefile
new file mode 100644
index 0000000000..b95c3cefbd
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/Makefile
@@ -0,0 +1,32 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+default: all
+
+# Build everything in parallel; use .WAIT for dependencies
+.PARALLEL:
+
+SUBDIRS =	zone
+
+all :=		TARGET= all
+install :=	TARGET= install
+clean :=	TARGET= clean
+clobber :=	TARGET= clobber
+lint :=		TARGET= lint
+
+all install clean clobber lint: $(SUBDIRS)
+
+$(SUBDIRS): FRC
+	@cd $@; pwd; $(MAKE) $(TARGET)
+
+FRC:
diff --git a/usr/src/lib/brand/bhyve/Makefile.bhyve b/usr/src/lib/brand/bhyve/Makefile.bhyve
new file mode 100644
index 0000000000..c2ac3fac2c
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/Makefile.bhyve
@@ -0,0 +1,17 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+BRAND=	bhyve
+
+include $(SRC)/lib/brand/Makefile.brand
+
diff --git a/usr/src/lib/brand/bhyve/zone/Makefile b/usr/src/lib/brand/bhyve/zone/Makefile
new file mode 100644
index 0000000000..8e9586f525
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/Makefile
@@ -0,0 +1,42 @@
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+include $(SRC)/cmd/Makefile.cmd
+include ../Makefile.bhyve
+include $(SRC)/cmd/Makefile.cmd.64
+
+PROGS =		attach detach statechange uninstall
+
+PROG1 =		boot
+PROGS +=	$(PROG1)
+CLEANFILES +=	$(PROGS)
+$(PROG1) :=	LDLIBS += -lnvpair
+
+TEMPLATES =	SYSbhyve.xml
+XMLDOCS =	config.xml platform.xml
+CLOBBERFILES =	$(ROOTXMLDOCS) $(ROOTTEMPLATES) $(ROOTPROGS)
+
+# This shouldn't be necessary, but for some reason the same thing in
+# ../../Makefile.brand is not being picked up.
+$(ROOTPROGS) :=	FILEMODE = 755
+
+all: $(PROGS)
+
+install: $(PROGS) $(ROOTPROGS) $(ROOTXMLDOCS) $(ROOTTEMPLATES)
+
+clean:
+	$(RM) $(CLEANFILES)
+
+lint:
+
+include $(SRC)/cmd/Makefile.targ
diff --git a/usr/src/lib/brand/bhyve/zone/SYSbhyve.xml b/usr/src/lib/brand/bhyve/zone/SYSbhyve.xml
new file mode 100644
index 0000000000..4fd8cb5406
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/SYSbhyve.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+    DO NOT EDIT THIS FILE.  Use zonecfg(1M) instead.
+-->
+<!DOCTYPE zone PUBLIC "-//Sun Microsystems Inc//DTD Zones//EN" "file:///usr/share/lib/xml/dtd/zonecfg.dtd.1">
+<zone name="SYSbhyve" zonepath="" autoboot="false" brand="bhyve" >
+  <attr name="bootrom" type="string" value="/usr/share/bhyve/uefi-csm-rom.bin"/>
+  <attr name="com1" type="string" value="/dev/zconsole"/>
+</zone>
diff --git a/usr/src/lib/brand/bhyve/zone/attach b/usr/src/lib/brand/bhyve/zone/attach
new file mode 100755
index 0000000000..626e608579
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/attach
@@ -0,0 +1,26 @@
+#!/bin/ksh -p
+#
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+. /usr/lib/brand/jcommon/libhooks.ksh
+
+function jcommon_attach_hook
+{
+	jattach_kvm_final_setup
+}
+
+ps_brand="bhyve"
+. /usr/lib/brand/jcommon/cattach
diff --git a/usr/src/lib/brand/bhyve/zone/boot.c b/usr/src/lib/brand/bhyve/zone/boot.c
new file mode 100644
index 0000000000..efbff6a32f
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/boot.c
@@ -0,0 +1,487 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * This program runs as a child of zoneadmd, which sets a variety of
+ * _ZONECFG_<resource>_<instance> properties so that child processes don't have
+ * to parse xml.
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <libnvpair.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <zone.h>
+
+/* These two paths must be relative to the zone root. */
+#define	BHYVE_DIR		"var/run/bhyve"
+#define	BHYVE_ARGS_FILE		BHYVE_DIR "/" "zhyve.cmd"
+
+#define ZH_MAXARGS		100
+
+#define	DEFAULT_BOOTROM		"/usr/share/bhyve/uefi-csm-rom.bin"
+
+typedef enum {
+	PCI_SLOT_HOSTBRIDGE = 0,	/* Not used here, but reserved */
+	PCI_SLOT_LPC,
+	PCI_SLOT_CD,
+	PCI_SLOT_BOOT_DISK,
+	PCI_SLOT_OTHER_DISKS,
+	PCI_SLOT_NICS
+} pci_slot_t;
+
+boolean_t debug;
+
+#define	dprintf(x) if (debug) (void)printf x
+
+char *
+get_zcfg_var(const char *rsrc, const char *inst, const char *prop)
+{
+	char envvar[MAXNAMELEN];
+	char *ret;
+
+	if (prop == NULL) {
+		if (snprintf(envvar, sizeof (envvar), "_ZONECFG_%s_%s",
+		    rsrc, inst) >= sizeof (envvar)) {
+			return (NULL);
+		}
+	} else {
+		if (snprintf(envvar, sizeof (envvar), "_ZONECFG_%s_%s_%s",
+		    rsrc, inst, prop) >= sizeof (envvar)) {
+			return (NULL);
+		}
+	}
+
+	ret = getenv(envvar);
+
+	dprintf(("%s: '%s=%s'\n", __func__, envvar, ret ? ret : "<null>"));
+
+	return (ret);
+}
+
+boolean_t
+is_env_true(const char *rsrc, const char *inst, const char *prop)
+{
+	char *val = get_zcfg_var(rsrc, inst, prop);
+
+	return (val != NULL && strcmp(val, "true") == 0);
+}
+
+int
+add_arg(int *argc, char **argv, char *val)
+{
+	if (*argc >= ZH_MAXARGS) {
+		(void) printf("Error: too many arguments\n");
+		return (1);
+	}
+	argv[*argc] = strdup(val);
+	assert(argv[*argc] != NULL);
+	dprintf(("%s: argv[%d]='%s'\n", __func__, *argc, argv[*argc]));
+	(*argc)++;
+	return (0);
+}
+
+int
+add_cpu(int *argc, char **argv)
+{
+	char *val;
+
+	if ((val = get_zcfg_var("attr", "vcpus", NULL)) != NULL) {
+		if (add_arg(argc, argv, "-c") != 0 ||
+		    add_arg(argc, argv, val) != 0) {
+			return (1);
+		}
+	}
+	return (0);
+}
+
+int
+add_ram(int *argc, char **argv)
+{
+	char *val;
+
+	if ((val = get_zcfg_var("attr", "ram", NULL)) != NULL) {
+		if (add_arg(argc, argv, "-m") != 0 ||
+		    add_arg(argc, argv, val) != 0) {
+			return (1);
+		}
+	}
+	return (0);
+}
+
+int
+add_disks(int *argc, char **argv)
+{
+	char *disks;
+	char *disk;
+	char *lasts;
+	int next_cd = 0;
+	int next_other = 0;
+	char slotconf[MAXNAMELEN];
+	char *boot = NULL;
+
+	if ((disks = get_zcfg_var("device", "resources", NULL)) == NULL) {
+		return (0);
+	}
+
+	for (disk = strtok_r(disks, " ", &lasts); disk != NULL;
+	    disk = strtok_r(NULL, " ", &lasts)) {
+		int pcislot;
+		int pcifn;
+		char *path;
+
+		/* zoneadmd is not careful about a trailing delimiter. */
+		if (disk[0] == '\0') {
+			continue;
+		}
+
+		if ((path = get_zcfg_var("device", disk, "path")) == NULL) {
+			(void) printf("Error: disk %s has no path\n", disk);
+			return (-1);
+		}
+
+		/* Allow at most one "primary" disk */
+		if (is_env_true("device", disk, "boot")) {
+			if (boot != NULL) {
+				(void) printf("Error: "
+				    "multiple boot disks: %s %s\n",
+				    boot, path);
+				return (-1);
+			}
+			boot = path;
+			pcislot = PCI_SLOT_BOOT_DISK;
+			pcifn = 0;
+		} else if (is_env_true("device", disk, "cdrom")) {
+			pcislot = PCI_SLOT_CD;
+			pcifn = next_cd;
+			next_cd++;
+		} else {
+			pcislot = PCI_SLOT_OTHER_DISKS;
+			pcifn = next_other;
+			next_other++;
+		}
+
+		if (snprintf(slotconf, sizeof (slotconf),
+		    "%d:%d,virtio-blk,%s", pcislot, pcifn, path) >=
+		    sizeof (slotconf)) {
+			(void) printf("Error: disk path '%s' too long\n", path);
+			return (-1);
+		}
+
+		if (add_arg(argc, argv, "-s") != 0 ||
+		    add_arg(argc, argv, slotconf) != 0) {
+			return (-1);
+		}
+	}
+
+	return (0);
+}
+
+int
+add_nets(int *argc, char **argv)
+{
+	char *nets;
+	char *net;
+	char *lasts;
+	int nextpcifn = 1;		/* 0 reserved for primary */
+	char slotconf[MAXNAMELEN];
+	char *primary = NULL;
+
+	if ((nets = get_zcfg_var("net", "resources", NULL))== NULL) {
+		return (0);
+	}
+
+	for (net = strtok_r(nets, " ", &lasts); net != NULL;
+	    net = strtok_r(NULL, " ", &lasts)) {
+		int pcifn;
+
+		/* zoneadmd is not careful about a trailing delimiter. */
+		if (net[0] == '\0') {
+			continue;
+		}
+
+		/* Allow at most one "primary" net */
+		if (is_env_true("net", net, "primary")) {
+			if (primary != NULL) {
+				(void) printf("Error: "
+				    "multiple primary nets: %s %s\n",
+				    primary, net);
+				return (-1);
+			}
+			primary = net;
+			pcifn = 0;
+		} else {
+			pcifn = nextpcifn;
+			nextpcifn++;
+		}
+
+		if (snprintf(slotconf, sizeof (slotconf),
+		    "%d:%d,virtio-net-viona,%s", PCI_SLOT_NICS, pcifn, net) >=
+		    sizeof (slotconf)) {
+			(void) printf("Error: net '%s' too long\n", net);
+			return (-1);
+		}
+
+		if (add_arg(argc, argv, "-s") != 0 ||
+		    add_arg(argc, argv, slotconf) != 0) {
+			return (-1);
+		}
+	}
+
+	return (0);
+}
+
+int
+add_lpc(int *argc, char **argv)
+{
+	char *lpcdevs[] = { "bootrom", "com1", "com2", NULL };
+	const int bootrom_idx = 0;
+	int i;
+	char *val;
+	char conf[MAXPATHLEN];
+	boolean_t found_bootrom = B_FALSE;
+
+	assert(strcmp(lpcdevs[bootrom_idx], "bootrom") == 0);
+
+	(void) snprintf(conf, sizeof (conf), "%d,lpc", PCI_SLOT_LPC);
+	if (add_arg(argc, argv, "-s") != 0 ||
+	    add_arg(argc, argv, conf) != 0) {
+		return (-1);
+	}
+
+	for (i = 0; lpcdevs[i] != NULL; i++) {
+		if ((val = get_zcfg_var("attr", lpcdevs[i], NULL)) == NULL) {
+			continue;
+		}
+		if (i == bootrom_idx) {
+			found_bootrom = B_TRUE;
+		}
+		if (snprintf(conf, sizeof (conf), "%s,%s", lpcdevs[i], val) >=
+		    sizeof (conf)) {
+			(void) printf("Error: value of attr '%s' too long\n",
+			    lpcdevs[i]);
+			return (-1);
+		}
+		if (add_arg(argc, argv, "-l") != 0 ||
+		    add_arg(argc, argv, conf) != 0) {
+			return (-1);
+		}
+	}
+
+	if (!found_bootrom) {
+		if (add_arg(argc, argv, "-l") != 0 ||
+		    add_arg(argc, argv, "bootrom," DEFAULT_BOOTROM) != 0) {
+			return (-1);
+		}
+	}
+
+	return (0);
+}
+
+int
+add_bhyve_opts(int *argc, char **argv)
+{
+	char *val;
+	char *tok;
+	char *lasts;
+
+	if ((val = get_zcfg_var("attr", "bhyve_opts", NULL)) == NULL) {
+		return (0);
+	}
+
+	val = strdup(val);
+	if (val == NULL) {
+		(void) printf("Error: strdup failed\n");
+		return (-1);
+	}
+
+	for (tok = strtok_r(val, " \t", &lasts); tok != NULL;
+	    tok = strtok_r(NULL, " \t", &lasts)) {
+		if (tok[0] == '\0') {
+			continue;
+		}
+		if (add_arg(argc, argv, tok) != 0) {
+			return (-1);
+		}
+	}
+
+	free(val);
+	return (0);
+}
+
+/* Must be called last */
+int
+add_vmname(int *argc, char **argv)
+{
+	char buf[32];				/* VM_MAX_NAMELEN */
+	char *val = getenv("_ZONECFG_did");
+
+	if (val == NULL || val[0] == '\0') {
+		val = "SYSbhyve-unknown";
+	} else {
+		(void) snprintf(buf, sizeof (buf), "SYSbhyve-%s", val);
+		val = buf;
+	}
+	if (add_arg(argc, argv, val) != 0) {
+		return (-1);
+	}
+	return (0);
+}
+
+/*
+ * Write the entire buffer or return an error.  This function could be more
+ * paranoid and call fdsync() at the end.  That's not really need for this use
+ * case because it is being written to tmpfs.
+ */
+int
+full_write(int fd, char *buf, size_t buflen)
+{
+	ssize_t nwritten;
+	size_t totwritten = 0;
+
+	while (totwritten < buflen) {
+		nwritten = write(fd, buf + totwritten, buflen - totwritten);
+		if (nwritten < 0) {
+			if (errno == EAGAIN || errno == EINTR) {
+				continue;
+			}
+			return (-1);
+		}
+		assert(nwritten > 0);
+		totwritten += nwritten;
+	}
+	assert(totwritten == buflen);
+
+	return (0);
+}
+
+void
+init_debug(void)
+{
+	char *val = getenv("_ZONEADMD_brand_debug");
+
+	debug = (val != NULL && val[0] != '\0');
+}
+
+
+int
+main(int argc, char **argv)
+{
+	int fd;
+	char *zhargv[ZH_MAXARGS] = {
+		"zhyve",	/* Squats on argv[0] */
+		"-H",		/* vmexit on halt isns */
+		"-B", "1,product=SmartDC HVM",
+		NULL };
+	int zhargc;
+	nvlist_t *nvl;
+	char *nvbuf;
+	size_t nvbuflen;
+	char zoneroot[MAXPATHLEN];
+	int zrfd;
+	char *zonename;
+	char *zonepath;
+
+	init_debug();
+
+	if (argc != 3) {
+		(void) printf("Error: bhyve boot program called with "
+		    "%d args, expecting 2\n", argc - 1);
+		return (1);
+	}
+	zonename = argv[1];
+	zonepath = argv[2];
+
+	for (zhargc = 0; zhargv[zhargc] != NULL; zhargc++) {
+		dprintf(("def_arg: argv[%d]='%s'\n", zhargc, zhargv[zhargc]));
+	}
+
+	if (add_lpc(&zhargc, (char **)&zhargv) != 0 ||
+	    add_cpu(&zhargc, (char **)&zhargv) != 0 ||
+	    add_ram(&zhargc, (char **)&zhargv) != 0 ||
+	    add_disks(&zhargc, (char **)&zhargv) != 0 ||
+	    add_nets(&zhargc, (char **)&zhargv) != 0 ||
+	    add_bhyve_opts(&zhargc, (char **)&zhargv) != 0 ||
+	    add_vmname(&zhargc, (char **)&zhargv) != 0) {
+		return (1);
+	}
+
+	/*
+	 * This and other dynamically allocated resources are intentionally
+	 * leaked.  It's a short-lived program and it will all get mopped up on
+	 * exit.
+	 */
+	if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0 ||
+	    nvlist_add_string_array(nvl, "zhyve_args", zhargv, zhargc) != 0) {
+		(void) printf("Error: failed to create nvlist: %s\n",
+		    strerror(errno));
+		return (1);
+	}
+
+	if (debug) {
+		dprintf(("packing nvlist:\n"));
+		nvlist_print(stdout, nvl);
+	}
+
+	if (nvlist_pack(nvl, &nvbuf, &nvbuflen, NV_ENCODE_XDR, 0) != 0) {
+		(void) printf("Error: failed to pack nvlist\n");
+		return (1);
+	}
+
+	if (snprintf(zoneroot, sizeof (zoneroot), "%s/root", zonepath) >=
+	    sizeof (zoneroot)) {
+		(void) printf("Error: zonepath '%s' too long\n", zonepath);
+		return (1);
+	}
+
+	if ((zrfd = open(zoneroot, O_RDONLY|O_SEARCH)) < 0) {
+		(void) printf("Error: cannot open zone root '%s': %s\n",
+		    zoneroot, strerror(errno));
+		return (1);
+	}
+
+	/*
+	 * This mkdirat() and the subsequent openat() are only safe because the
+	 * zone root is always under the global zone's exclusive control (always
+	 * read-only in all zones) and the writable directory is a tmpfs file
+	 * system that was just mounted and no zone code has run yet.
+	 */
+	if (mkdirat(zrfd, BHYVE_DIR, 0700) != 0 && errno != EEXIST) {
+		(void) printf("Error: failed to create directory %s "
+		    "in zone: %s\n" BHYVE_DIR, strerror(errno));
+		return (1);
+	}
+
+	fd = openat(zrfd, BHYVE_ARGS_FILE, O_WRONLY|O_CREAT|O_EXCL, 0600);
+	if (fd < 0) {
+		(void) printf("Error: failed to create file %s in zone: %s\n",
+		    BHYVE_ARGS_FILE, strerror(errno));
+		return (1);
+	}
+	if (full_write(fd, nvbuf, nvbuflen) != 0) {
+		(void) printf("Error: failed to write %s: %s\n",
+		    BHYVE_ARGS_FILE, strerror(errno));
+		(void) unlink(BHYVE_ARGS_FILE);
+		return (1);
+	}
+
+	return (0);
+}
diff --git a/usr/src/lib/brand/bhyve/zone/config.xml b/usr/src/lib/brand/bhyve/zone/config.xml
new file mode 100644
index 0000000000..1dc3143fad
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/config.xml
@@ -0,0 +1,70 @@
+<?xml version="1.0"?>
+
+<!--
+ This file and its contents are supplied under the terms of the
+ Common Development and Distribution License ("CDDL"), version 1.0.
+ You may only use this file in accordance with the terms of version
+ 1.0 of the CDDL.
+
+ A full copy of the text of the CDDL should have accompanied this
+ source.  A copy of the CDDL is also available via the Internet at
+ http://www.illumos.org/license/CDDL.
+
+ Copyright (c) 2018, Joyent, Inc.
+
+ DO NOT EDIT THIS FILE.
+-->
+
+<!DOCTYPE brand PUBLIC "-//Joyent Inc//DTD Brands//EN"
+    "file:///usr/share/lib/xml/dtd/brand.dtd.1">
+
+<brand name="bhyve">
+	<modname></modname>
+
+	<initname>/usr/lib/brand/bhyve/zhyve</initname>
+	<restartinit>false</restartinit>
+	<login_cmd />
+	<forcedlogin_cmd />
+	<user_cmd />
+
+	<!-- XXX-mg
+	  Until we have better separation of concerns, bhyve brand will use the
+	  kvm installer, which is intertwined with vmadm.
+	-->
+	<install>/usr/lib/brand/kvm/kinstall -z %z -R %R</install>
+	<installopts>R:t:U:q:z:</installopts>
+	<boot>/usr/lib/brand/bhyve/boot %z %R</boot>
+	<halt />
+	<verify_cfg />
+	<verify_adm />
+	<postclone />
+	<postinstall />
+	<attach>/usr/lib/brand/bhyve/attach -z %z -R %R</attach>
+	<detach>/usr/lib/brand/bhyve/detach -z %z -R %R</detach>
+	<clone />
+	<uninstall>/usr/lib/brand/bhyve/uninstall -z %z -R %R</uninstall>
+	<prestatechange>/usr/lib/brand/bhyve/statechange pre %z %R</prestatechange>
+	<poststatechange>/usr/lib/brand/bhyve/statechange post %z %R</poststatechange>
+
+	<privilege set="default" name="net_rawaccess" ip-type="exclusive" />
+	<privilege set="default" name="proc_clock_highres" />
+	<privilege set="default" name="proc_lock_memory" />
+	<privilege set="default" name="sys_admin" />
+	<privilege set="default" name="sys_mount" />
+
+	<privilege set="prohibited" name="dtrace_kernel" />
+	<privilege set="prohibited" name="proc_zone" />
+	<privilege set="prohibited" name="sys_config" />
+	<privilege set="prohibited" name="sys_devices" />
+	<privilege set="prohibited" name="sys_ip_config" ip-type="shared" />
+	<privilege set="prohibited" name="sys_linkdir" />
+	<privilege set="prohibited" name="sys_net_config" />
+	<privilege set="prohibited" name="sys_res_config" />
+	<privilege set="prohibited" name="sys_suser_compat" />
+	<privilege set="prohibited" name="xvm_control" />
+	<privilege set="prohibited" name="virt_manage" />
+	<privilege set="prohibited" name="sys_ppp_config" ip-type="shared" />
+
+	<privilege set="required" name="proc_exec" />
+	<privilege set="required" name="sys_mount" />
+</brand>
diff --git a/usr/src/lib/brand/bhyve/zone/detach b/usr/src/lib/brand/bhyve/zone/detach
new file mode 100755
index 0000000000..8a41815258
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/detach
@@ -0,0 +1,19 @@
+#!/bin/ksh -p
+#
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+ps_brand="bhyve"
+. /usr/lib/brand/jcommon/cdetach
diff --git a/usr/src/lib/brand/bhyve/zone/platform.xml b/usr/src/lib/brand/bhyve/zone/platform.xml
new file mode 100644
index 0000000000..681960c73c
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/platform.xml
@@ -0,0 +1,142 @@
+<?xml version="1.0"?>
+
+<!--
+ This file and its contents are supplied under the terms of the
+ Common Development and Distribution License ("CDDL"), version 1.0.
+ You may only use this file in accordance with the terms of version
+ 1.0 of the CDDL.
+
+ A full copy of the text of the CDDL should have accompanied this
+ source.  A copy of the CDDL is also available via the Internet at
+ http://www.illumos.org/license/CDDL.
+
+ Copyright (c) 2018, Joyent, Inc.
+
+ DO NOT EDIT THIS FILE.
+-->
+
+<!DOCTYPE platform PUBLIC "-//Joyent Inc//Zones Platform//EN"
+    "file:///usr/share/lib/xml/dtd/zone_platform.dtd.1">
+
+<platform name="bhyve" allow-exclusive-ip="true">
+
+	<!-- Global filesystems to mount when booting the zone -->
+	<global_mount special="/dev" directory="/dev" type="dev"
+	    opt="attrdir=%R/root/dev"/>
+	<global_mount special="/lib" directory="/lib"
+	    opt="ro,nodevices,nosub" type="lofs" />
+	<global_mount special="/usr" directory="/usr"
+	    opt="ro,nodevices,nosub" type="lofs" />
+
+	<!-- Local filesystems to mount when booting the zone -->
+	<mount special="swap" directory="/var/run" type="tmpfs"
+	    opt="size=50m"/>
+
+	<!-- Needed by dlmgmtd -->
+	<mount special="swap" directory="/etc/svc/volatile" type="tmpfs"
+	    opt="size=10m" />
+
+	<!-- Devices to create under /dev -->
+	<device match="arp" />
+	<device match="bpf" />
+	<device match="conslog" />
+	<device match="cpu/self/cpuid" />
+	<device match="crypto" />
+	<device match="cryptoadm" />
+	<device match="dsk" />
+	<device match="dtrace/*" />
+	<device match="dtrace/provider/*" />
+	<device match="fd" />
+	<device match="ipnet" />
+	<device match="kstat" />
+	<device match="lo0" />
+	<device match="lofictl" />
+	<device match="lofi" />
+	<device match="log" />
+	<device match="logindmux" />
+	<device match="nsmb" />
+	<device match="net/*" />
+	<device match="null" />
+	<device match="openprom" arch="sparc" />
+	<device match="poll" />
+	<device match="pool" />
+	<device match="ptmx" />
+	<device match="pts/*" />
+	<device match="random" />
+	<device match="rdsk" />
+	<device match="rlofi" />
+	<device match="rmt" />
+	<device match="sad/user" />
+	<device match="svvslo0" />
+	<device match="svvslo1" />
+	<device match="svvslo2" />
+	<device match="svvslo3" />
+	<device match="swap" />
+	<device match="sysevent" />
+	<device match="tcp" />
+	<device match="tcp6" />
+	<device match="term" />
+	<device match="ticlts" />
+	<device match="ticots" />
+	<device match="ticotsord" />
+	<device match="tty" />
+	<device match="udp" />
+	<device match="udp6" />
+	<device match="urandom" />
+	<device match="viona" />
+	<!--
+	    Careful: this is not just about catching both /dev/vmmctl and the
+	    /dev/vmm directory.  In fact it's required to prevent a race where
+	    sdev processes "/dev/vmm/", sees it doesn't exist in the global
+	    /dev (as the module isn't loaded), then never updates its own sdev
+	    directory.  Adding the glob here ensures it's checked as needed.
+	-->
+	<device match="vmm*" />
+	<device match="vnd/*" />
+	<device match="zero" />
+	<device match="zfs" />
+
+	<!-- Devices to create in exclusive IP zone only -->
+	<device match="dld" ip-type="exclusive" />
+	<device match="icmp" ip-type="exclusive" />
+	<device match="icmp6" ip-type="exclusive" />
+	<device match="ip" ip-type="exclusive" />
+	<device match="ip6" ip-type="exclusive" />
+	<device match="ipauth" ip-type="exclusive" />
+	<device match="ipf" ip-type="exclusive" />
+	<device match="ipl" ip-type="exclusive" />
+	<device match="iplookup" ip-type="exclusive" />
+	<device match="ipmpstub" ip-type="exclusive" />
+	<device match="ipnat" ip-type="exclusive" />
+	<device match="ipscan" ip-type="exclusive" />
+	<device match="ipsecah" ip-type="exclusive" />
+	<device match="ipsecesp" ip-type="exclusive" />
+	<device match="ipstate" ip-type="exclusive" />
+	<device match="ipsync" ip-type="exclusive" />
+	<device match="keysock" ip-type="exclusive" />
+	<device match="rawip" ip-type="exclusive" />
+	<device match="rawip6" ip-type="exclusive" />
+	<device match="rts" ip-type="exclusive" />
+	<device match="sad/admin" ip-type="exclusive" />
+	<device match="sctp" ip-type="exclusive" />
+	<device match="sctp6" ip-type="exclusive" />
+	<device match="spdsock" ip-type="exclusive" />
+	<device match="sppp" ip-type="exclusive" />
+	<device match="sppptun" ip-type="exclusive" />
+	<device match="vni" ip-type="exclusive" />
+
+	<!-- Renamed devices to create under /dev -->
+	<device match="zcons/%z/zoneconsole" name="zconsole" />
+
+	<!-- Symlinks to create under /dev -->
+	<symlink source="console" target="zconsole" />
+	<symlink source="dtremote" target="/dev/null" />
+	<symlink source="msglog" target="zconsole" />
+	<symlink source="stderr" target="./fd/2" />
+	<symlink source="stdin" target="./fd/0" />
+	<symlink source="stdout" target="./fd/1" />
+	<symlink source="syscon" target="zconsole" />
+	<symlink source="sysmsg" target="zconsole" />
+	<symlink source="systty" target="zconsole" />
+
+</platform>
diff --git a/usr/src/lib/brand/bhyve/zone/statechange b/usr/src/lib/brand/bhyve/zone/statechange
new file mode 100644
index 0000000000..22f494b6a8
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/statechange
@@ -0,0 +1,18 @@
+#! /bin/ksh
+
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+# Copyright (c) 2018, Joyent, Inc.
+#
+
+ps_brand=bhyve
+
+. /usr/lib/brand/jcommon/statechange
diff --git a/usr/src/lib/brand/bhyve/zone/uninstall b/usr/src/lib/brand/bhyve/zone/uninstall
new file mode 100755
index 0000000000..136044ad9e
--- /dev/null
+++ b/usr/src/lib/brand/bhyve/zone/uninstall
@@ -0,0 +1,23 @@
+#!/bin/ksh -p
+#
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright (c) 2014 Joyent, Inc.  All rights reserved.
+#
+
+function jcommon_uninstall_hook
+{
+	:
+}
+
+. /usr/lib/brand/jcommon/cuninstall
diff --git a/usr/src/lib/libvmmapi/common/vmmapi.c b/usr/src/lib/libvmmapi/common/vmmapi.c
index 2c2a477875..0bb42db98f 100644
--- a/usr/src/lib/libvmmapi/common/vmmapi.c
+++ b/usr/src/lib/libvmmapi/common/vmmapi.c
@@ -136,18 +136,10 @@ vm_device_open(const char *name)
         int fd, len;
         char *vmfile;
 
-#ifdef	__FreeBSD__
 	len = strlen("/dev/vmm/") + strlen(name) + 1;
-#else
-	len = strlen("/devices/pseudo/vmm@0:") + strlen(name) + 1;
-#endif
 	vmfile = malloc(len);
 	assert(vmfile != NULL);
-#ifdef	__FreeBSD__
 	snprintf(vmfile, len, "/dev/vmm/%s", name);
-#else
-	snprintf(vmfile, len, "/devices/pseudo/vmm@0:%s", name);
-#endif
 
         /* Open the device file */
         fd = open(vmfile, O_RDWR, 0);
-- 
2.21.0

