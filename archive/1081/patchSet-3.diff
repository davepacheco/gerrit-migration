From 47b616c1331f758fc06fd6d8cc1baf3c1316b897 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Wed, 7 Dec 2016 19:24:57 +0000
Subject: [PATCH] TOOLS-1629 Want library for setting up sandboxed Moray
 instances

---
 Makefile                |  67 +++++++
 README.md               | 101 ++++++++++
 deps/javascriptlint     |   2 +-
 lib/client.js           | 382 ++++++++++++++++++++++++++++++++++++
 lib/index.js            |  53 +++++
 lib/pg-server.js        | 133 +++++++++++++
 lib/run.js              | 132 +++++++++++++
 lib/sandbox.js          | 251 ++++++++++++++++++++++++
 package.json            |  34 ++++
 test/lib/log.js         |  21 ++
 test/unit/basic.test.js | 425 ++++++++++++++++++++++++++++++++++++++++
 test/unit/run.js        |  32 +++
 tools/eslint.node.conf  |   1 +
 13 files changed, 1633 insertions(+), 1 deletion(-)
 create mode 100644 Makefile
 create mode 100644 README.md
 create mode 100644 lib/client.js
 create mode 100644 lib/index.js
 create mode 100644 lib/pg-server.js
 create mode 100644 lib/run.js
 create mode 100644 lib/sandbox.js
 create mode 100644 package.json
 create mode 100644 test/lib/log.js
 create mode 100644 test/unit/basic.test.js
 create mode 100644 test/unit/run.js

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..5671231
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,67 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2016, Joyent, Inc.
+#
+
+#
+# Mock Moray Makefile
+#
+
+#
+# Tools
+#
+
+ISTANBUL	:= node_modules/.bin/istanbul
+FAUCET		:= node_modules/.bin/faucet
+NPM		:= npm
+
+#
+# Files
+#
+
+JS_FILES	:= $(shell find lib test -name '*.js')
+JSL_CONF_NODE	= tools/jsl.node.conf
+JSL_FILES_NODE	= $(JS_FILES)
+JSSTYLE_FILES	= $(JS_FILES)
+JSSTYLE_FLAGS	= -f tools/jsstyle.conf
+ESLINT		= ./node_modules/.bin/eslint
+ESLINT_CONF	= tools/eslint.node.conf
+ESLINT_FILES	= $(JS_FILES)
+
+include ./tools/mk/Makefile.defs
+include ./tools/mk/Makefile.smf.defs
+
+#
+# Repo-specific targets
+#
+
+.PHONY: all
+all: $(TAPE)
+	$(NPM) rebuild
+
+$(ESLINT): | $(NPM_EXEC)
+	$(NPM) install
+
+$(ISTANBUL): | $(NPM_EXEC)
+	$(NPM) install
+
+$(FAUCET): | $(NPM_EXEC)
+	$(NPM) install
+
+CLEAN_FILES += ./node_modules/
+
+.PHONY: test
+test: $(ISTANBUL) $(FAUCET)
+	$(ISTANBUL) cover --print none test/unit/run.js | $(FAUCET)
+
+.PHONY: check
+check:: $(ESLINT)
+	$(ESLINT) -c $(ESLINT_CONF) $(ESLINT_FILES)
+
+include ./tools/mk/Makefile.deps
+include ./tools/mk/Makefile.targ
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..7ca812e
--- /dev/null
+++ b/README.md
@@ -0,0 +1,101 @@
+<!--
+    This Source Code Form is subject to the terms of the Mozilla Public
+    License, v. 2.0. If a copy of the MPL was not distributed with this
+    file, You can obtain one at http://mozilla.org/MPL/2.0/.
+-->
+
+<!--
+    Copyright 2016, Joyent, Inc.
+-->
+
+# node-moray-sandbox
+
+This repository is part of the Joyent Manta and Triton projects. For
+contribution guidelines, issues, and general documentation, visit the main
+[Triton](https://github.com/joyent/triton) and
+[Manta](https://github.com/joyent/manta) project pages.
+
+## Overview
+
+This is a node library for spinning up a temporary Moray server that can be
+used for unit testing programs that depend on Moray. Before running, make
+sure that you have Postgres 9.2 installed. On both Mac OS X and SmartOS:
+
+```
+pkgin in postgresql92-client postgresql92-server
+```
+
+## Examples
+
+You can spawn a new temporary Moray instance by running:
+
+```js
+var mod_moray_sandbox = require('moray-sandbox');
+
+mod_moray_sandbox.create(log, function (err, moray) {
+    // Do what you need with the client, and then shutdown Moray:
+    moray.stop();
+});
+```
+
+If you need multiple Moray clients that point to the same server, you can
+use the client's `.clone()` method to create a new one with the same
+configuration:
+
+```js
+var clone1 = moray.clone();
+var clone2 = moray.clone();
+```
+
+If you need to create multiple Moray instances, you can avoid the overhead
+of initializing multiple Postgres instances by doing:
+
+```js
+var mod_moray_sandbox = require('moray-sandbox');
+
+mod_moray_sandbox.createPG(log, function (err, pg) {
+    pg.spawnMoray(function (err, moray1) {
+        // Do what you need with the client of Moray instance #1
+    });
+    pg.spawnMoray(function (err, moray2) {
+        // Do what you need with the client of Moray instance #2
+    });
+    // Once finished, call moray1.close(), moray2.close(), and pg.stop()
+});
+```
+
+Note that the library consumer is responsible for calling `.close()` on every
+client it creates via `.create()`, `.spawnMoray()`, and `.clone()` before
+stopping Postgres. If there is only a single client, for convenience, you can
+call `.stop()` on a client and it will handle closing the client for you before
+stopping Postgres.
+
+If you want to test your application's ability to handle errors, you can
+inject a series of errors to be returned by future Moray client calls. For
+example, to make the first call to `.batch()` actually call out to Moray,
+and the second one return a fake error, you can do:
+
+```js
+moray.setMockErrors({ batch: [ null, fakeErr, fakeErr, null ] });
+```
+
+Passing in `null` in the array allows you to interleave successes and
+failures. If you want to check that your errors have been dequeued, you can
+get the remaining mock errors. For example, if `.batch()` should have only
+been called three times after setting the mock errors earlier:
+
+```js
+var assert = require('assert-plus');
+
+var remaining = moray.getMockErrors();
+assert.deepEqual({ batch: [ null ] }, remaining, 'batch() called thrice');
+```
+
+You can clear out any remaining errors by calling the method with
+an empty object:
+
+```js
+moray.setMockErrors({ });
+```
+
+Clients created using `.clone()` share mock errors with the original client.
diff --git a/deps/javascriptlint b/deps/javascriptlint
index 040bf5e..ad52812 160000
--- a/deps/javascriptlint
+++ b/deps/javascriptlint
@@ -1 +1 @@
-Subproject commit 040bf5e429969ae42d976b570fd64c9e17fab20f
+Subproject commit ad52812e77bdfb1e90fb71a1201adb2b665a27e6
diff --git a/lib/client.js b/lib/client.js
new file mode 100644
index 0000000..fac55e8
--- /dev/null
+++ b/lib/client.js
@@ -0,0 +1,382 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Mock client object for accessing a temporary Moray instance
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var clone = require('clone');
+var EventEmitter = require('events').EventEmitter;
+var mod_moray_client = require('moray');
+var VError = require('verror');
+
+
+// --- Internals
+
+
+function emitFakeErr(err) {
+    var res = new EventEmitter();
+    setImmediate(function () {
+        res.emit('error', err);
+    });
+    return res;
+}
+
+
+// --- Exports
+
+
+function MockMorayClient(opts) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.pgmgr, 'opts.pgmgr');
+    assert.object(opts.stack, 'opts.stack');
+    assert.object(opts.config, 'opts.config');
+    assert.optionalObject(opts.mock_errors, 'opts.mock_errors');
+
+    this.closed = false;
+    this.stack = opts.stack;
+
+    this._pgmgr = opts.pgmgr;
+    this._config = opts.config;
+    this._config.log = opts.log;
+    this._client = mod_moray_client.createClient(this._config);
+    this.log = opts.log;
+
+    if (opts.mock_errors) {
+        this._mock_errors = opts.mock_errors;
+    } else {
+        this._mock_errors = {
+           last_moray_error: null,
+           errors: {}
+        };
+    }
+
+    this._pgmgr.clients.push(this);
+
+    Object.seal(this);
+}
+
+
+/**
+ * If there's an error in _mock_errors for the given operation, return it.
+ */
+MockMorayClient.prototype._getNextError = function (op, details) {
+    var mock_errors = this._mock_errors;
+    if (!mock_errors.errors.hasOwnProperty(op) ||
+        !Array.isArray(mock_errors.errors[op]) ||
+        mock_errors.errors[op].length === 0) {
+        return null;
+    }
+
+    var morayErr = mock_errors.errors[op].shift();
+
+    // Allow passing null in the array to allow interleaving successes
+    // and errors.
+    if (morayErr === null) {
+        return null;
+    }
+
+    mock_errors.last_moray_error = clone(details);
+    mock_errors.last_moray_error.op = op;
+    mock_errors.last_moray_error.msg = morayErr.message;
+
+    return morayErr;
+};
+
+
+MockMorayClient.prototype.getMockErrors = function getMockErrors() {
+    return this._mock_errors.errors;
+};
+
+
+MockMorayClient.prototype.setMockErrors = function setMockErrors(errors) {
+    assert.object(errors, 'errors');
+    this._mock_errors.errors = errors;
+};
+
+
+MockMorayClient.prototype.getLastMockError = function getLastMockError() {
+    return this._mock_errors.last_moray_error;
+};
+
+
+MockMorayClient.prototype.batch = function batchProxy(data, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('batch', { batch: data });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.batch.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.close = function closeProxy() {
+    this.closed = true;
+    this._client.close.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.createBucket =
+    function createBucketProxy(bucket, schema, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var details = { bucket: bucket, schema: schema };
+    var err = this._getNextError('createBucket', details);
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.createBucket.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.delBucket =
+    function deleteBucketProxy(bucket, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('delBucket', { bucket: bucket });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.delBucket.apply(this._client, arguments);
+};
+MockMorayClient.prototype.deleteBucket = MockMorayClient.prototype.delBucket;
+
+
+MockMorayClient.prototype.listBuckets =
+    function listBucketsProxy(opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('listBuckets', {});
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.listBuckets.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.delObject =
+    function delObjectProxy(bucket, key, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('delObject',
+        { bucket: bucket, key: key });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.delObject.apply(this._client, arguments);
+};
+MockMorayClient.prototype.deleteObject = MockMorayClient.prototype.delObject;
+
+
+MockMorayClient.prototype.deleteMany =
+    function deleteManyProxy(bucket, filter, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('deleteMany',
+        { bucket: bucket, filter: filter });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.deleteMany.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.findObjects =
+    function findObjectsProxy(bucket, filter) {
+    var details = { bucket: bucket, filter: filter };
+    var err = this._getNextError('findObjects', details);
+    if (err) {
+        return emitFakeErr(err);
+    }
+
+    return this._client.findObjects.apply(this._client, arguments);
+};
+MockMorayClient.prototype.find = MockMorayClient.prototype.findObjects;
+
+
+MockMorayClient.prototype.getBucket =
+    function getBucketProxy(bucket, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('getBucket', { bucket: bucket });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.getBucket.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.getObject =
+    function getObjectProxy(bucket, key, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('getObject', { bucket: bucket, key: key });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.getObject.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.putObject =
+    function putObjectProxy(bucket, key, value, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var details = { bucket: bucket, key: key, value: value };
+    var err = this._getNextError('putObject', details);
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.putObject.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.reindexObjects =
+    function reindexObjectsProxy(bucket, count, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var details = { bucket: bucket, count: count };
+    var err = this._getNextError('reindexObjects', details);
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.reindexObjects.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.sql = function sqlProxy(sql, args) {
+    var err = this._getNextError('sql', { sql: sql, args: args });
+    if (err) {
+        return emitFakeErr(err);
+    }
+
+    return this._client.sql.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.updateBucket =
+    function updateBucketProxy(bucket, schema, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('updateBucket',
+        { bucket: bucket, schema: schema });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.updateBucket.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.putBucket =
+    function putBucketProxy(bucket, schema, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('putBucket',
+        { bucket: bucket, schema: schema });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.putBucket.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.updateObjects =
+    function updateObjectsProxy(bucket, fields, filter, opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('updateObjects',
+        { bucket: bucket, fields: fields, filter: filter });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.updateObjects.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.versionInternal =
+    function versionInternalProxy(opts, callback) {
+    var cb = (typeof (opts) === 'function' ? opts : callback);
+    var err = this._getNextError('versionInternal', { });
+    if (err) {
+        cb(err);
+        return;
+    }
+
+    this._client.versionInternal.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.on = function onProxy() {
+    this._client.on.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.once = function onceProxy() {
+    this._client.once.apply(this._client, arguments);
+};
+
+
+MockMorayClient.prototype.removeListener = function removeListenerProxy() {
+    this._client.removeListener.apply(this._client, arguments);
+};
+
+
+/**
+ * Create a clone of this client that shares the same mock errors. This means
+ * that they use different versions of the real Moray client, so .close() will
+ * only affect one and not the other.
+ */
+MockMorayClient.prototype.clone = function duplicateClient() {
+    return new MockMorayClient({
+        log: this.log,
+        pgmgr: this._pgmgr,
+        config: this._config,
+        mock_errors: this._mock_errors,
+        stack: getOpenStack()
+    });
+};
+
+
+MockMorayClient.prototype.stop = function destroyPG() {
+    this.close();
+    this._pgmgr.stop();
+};
+
+
+function getOpenStack() {
+    return new VError({
+        name: 'PGStopError',
+        constructorOpt: getOpenStack
+    }, 'Cannot stop PG until all clients are closed; client opened at:');
+}
+
+
+module.exports = {
+    getOpenStack: getOpenStack,
+    MockMorayClient: MockMorayClient
+};
diff --git a/lib/index.js b/lib/index.js
new file mode 100644
index 0000000..0de0511
--- /dev/null
+++ b/lib/index.js
@@ -0,0 +1,53 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Library for standing up temporary Moray instances
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var getOpenStack = require('./client').getOpenStack;
+var TemporaryPostgres = require('./pg-server').TemporaryPostgres;
+
+
+// --- Exports
+
+
+function createMockPostgres(log, callback) {
+    assert.object(log, 'log');
+    assert.func(callback, 'callback');
+    return new TemporaryPostgres(log, callback);
+}
+
+
+function createMockMorayAndPG(log, callback) {
+    assert.object(log, 'log');
+    assert.func(callback, 'callback');
+
+    var stack = getOpenStack();
+
+    createMockPostgres(log, function (pErr, pg) {
+        if (pErr) {
+            callback(pErr);
+            return;
+        }
+        pg._spawnMoray(stack, function (err, moray) {
+            callback(err, moray, pg);
+        });
+    });
+}
+
+
+module.exports = {
+    createPG: createMockPostgres,
+    create: createMockMorayAndPG
+};
diff --git a/lib/pg-server.js b/lib/pg-server.js
new file mode 100644
index 0000000..c9465ec
--- /dev/null
+++ b/lib/pg-server.js
@@ -0,0 +1,133 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Object for tracking PG server state and spawning new Moray instances.
+ *
+ * Each instance of TemporaryPostgres spawns a new child run.js program,
+ * which will take care of initializing and managing the Postgres server.
+ * There are several kinds of messages that we can receive from the child:
+ *
+ *     - "log-file", specifying where to find the child's log
+ *     - "up", indicating that Postgres is running and initialized
+ *     - "error", indicating a failure in the child process
+ *     - "client-info", containing a new Moray instance's configuration
+ *
+ * All of these but "log_file" contain a "req_id" field indicating what
+ * request from TemporaryPostgres resulted in the failure. The only
+ * message sent to the child is "createdb", which requests that a new
+ * Moray instance be started.
+ *
+ * The child is the session leader of its own process group, and handles
+ * cleanup of the Postgres processes by signalling the group. This ensures
+ * that Postgres gets terminated and its files removed even when the parent
+ * terminates fatally. (This does not protect against a bug crashing run.js,
+ * though; ctrun(1) can be used to wrap the parent node process, run.js and
+ * Postgres in their own process contract.)
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var mod_child = require('child_process');
+var mod_client = require('./client');
+var mod_uuid = require('uuid');
+
+var getOpenStack = mod_client.getOpenStack;
+var MockMorayClient = mod_client.MockMorayClient;
+
+function TemporaryPostgres(log, callback) {
+    this.clients = [];
+
+    // Set up internal state
+    this._original = mod_uuid.v4();
+    this._cbs = { };
+    this._cbs[this._original] = callback;
+    this._stacks = { };
+    this._log = log;
+
+    // Start child process
+    this._child = mod_child.fork('run.js', [ this._original ], {
+        cwd: __dirname,
+        detached: true
+    });
+    this._child.on('message', this._processResponse.bind(this));
+
+    Object.seal(this);
+}
+
+
+TemporaryPostgres.prototype._processResponse =
+    function processResponse(response) {
+    switch (response.type) {
+    case 'error':
+        this._log.error(response, 'Error message from Moray or Postgres');
+        this._cbs[response.req_id](response);
+        return;
+    case 'up':
+        this._log.info(response, 'Postgres server is up and running');
+        this._cbs[response.req_id](null, this);
+        return;
+    case 'client-info':
+        this._log.info(response, 'New Moray server ready');
+        var client = new MockMorayClient({
+            log: this._log,
+            pgmgr: this,
+            config: response.config,
+            stack: this._stacks[response.req_id]
+        });
+        this._cbs[response.req_id](null, client);
+        delete this._cbs[response.req_id];
+        delete this._stacks[response.req_id];
+        return;
+    case 'log-file':
+        this._log.info('Child will log to the file ' + response.path);
+        return;
+    default:
+        this._log.error(response, 'Uknown message received from child');
+        return;
+    }
+};
+
+
+TemporaryPostgres.prototype._spawnMoray =
+    function spawnNewMorayInternal(stack, callback) {
+    assert.object(stack, 'stack');
+    assert.func(callback, 'callback');
+
+    var req_id = mod_uuid.v4();
+    assert.ok(!this._cbs.hasOwnProperty(req_id), 'unique req_id');
+    assert.ok(!this._stacks.hasOwnProperty(req_id), 'unique req_id');
+
+    this._cbs[req_id] = callback;
+    this._stacks[req_id] = stack;
+    this._child.send({ req_id: req_id, type: 'createdb' });
+};
+
+
+TemporaryPostgres.prototype.spawnMoray = function spawnNewMoray(callback) {
+    this._spawnMoray(getOpenStack(), callback);
+};
+
+
+TemporaryPostgres.prototype.stop = function stopPostgres() {
+    this.clients.forEach(function (client) {
+        if (!client.closed) {
+            throw client.stack;
+        }
+    });
+
+    this._child.disconnect();
+};
+
+
+module.exports = {
+    TemporaryPostgres: TemporaryPostgres
+};
diff --git a/lib/run.js b/lib/run.js
new file mode 100644
index 0000000..ea17e49
--- /dev/null
+++ b/lib/run.js
@@ -0,0 +1,132 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * This file is run in its own process via child_process.fork(), and
+ * communicates with its parent via process.on('message', ...) and
+ * process.send(). See pg-server.js for further details on how the
+ * two interact.
+ */
+
+'use strict';
+
+var MoraySandbox = require('./sandbox');
+var mod_bunyan = require('bunyan');
+var mod_tmp = require('tmp');
+var mod_vasync = require('vasync');
+
+var fmt = require('util').format;
+
+// --- Globals
+
+var ORIGINAL_REQ = process.argv[2];
+
+var LOG_FILE =
+    (process.env.TMPDIR || '/tmp') + '/moray-sandbox-log-' + process.pid;
+
+var sandbox;
+var log = mod_bunyan.createLogger({
+    name: 'moray-sandbox',
+    streams: [ {
+        level: (process.env.LOG_LEVEL || 'info'),
+        path: LOG_FILE
+    } ]
+});
+
+function haltPG() {
+    if (sandbox) {
+        sandbox.stop();
+    }
+}
+
+process.on('disconnect', haltPG);
+process.on('SIGTERM', haltPG);
+
+process.send({ type: 'log-file', path: LOG_FILE });
+
+mod_tmp.dir({ unsafeCleanup: true }, function (dErr, path, cleanup) {
+    if (dErr) {
+        process.send({
+            type: 'error',
+            req_id: ORIGINAL_REQ,
+            err: dErr.stack,
+            message: dErr.message
+        });
+        return;
+    }
+    sandbox = new MoraySandbox(log, path, cleanup);
+    log.info('Starting up sandboxed Moray instance');
+    mod_vasync.pipeline({
+        'funcs': [
+            function (_, cb) { sandbox._initDB(cb); },
+            function (_, cb) { sandbox._startPG(cb); }
+        ]
+    }, function (err) {
+        if (err) {
+            log.error(err, 'Postgres setup failed');
+            process.send({
+                type: 'error',
+                req_id: ORIGINAL_REQ,
+                err: err.stack,
+                message: err.message
+            });
+            sandbox.stop();
+        } else {
+            // We've successfully set up Postgres. Start listening to incoming
+            // messages and reply to the parent.
+            log.info('Moray/Postgres setup succeeded');
+            process.on('message', function (message) {
+                switch (message.type) {
+                case 'createdb':
+                    createdb(message.req_id);
+                    return;
+                default:
+                    log.error(message,
+                        'Child received unknown message from parent');
+                    process.send({
+                        type: 'error',
+                        req_id: message.req_id,
+                        message: fmt('Unknown message type: %j', message.type)
+                    });
+                    return;
+                }
+            });
+            process.send({ type: 'up', req_id: ORIGINAL_REQ });
+        }
+    });
+});
+
+
+function createdb(req_id) {
+    mod_vasync.waterfall([
+        function (cb) {
+            sandbox._createDB(req_id, cb);
+        },
+        function (connstr, cb) {
+            sandbox._startMoray(connstr, cb);
+        }
+    ], function (err, params) {
+        if (err) {
+            log.error(err, 'Creating new Moray instance failed');
+            process.send({
+                type: 'error',
+                req_id: req_id,
+                err: err.stack,
+                message: err.message
+            });
+        } else {
+            process.send({
+                type: 'client-info',
+                req_id: req_id,
+                config: params
+            });
+        }
+    });
+}
diff --git a/lib/sandbox.js b/lib/sandbox.js
new file mode 100644
index 0000000..e1cae0b
--- /dev/null
+++ b/lib/sandbox.js
@@ -0,0 +1,251 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Library for standing up temporary Moray instances.
+ *
+ * To stand up a new Moray instance, we go through the following steps:
+ *
+ * 1. Initialize a new DB directory w/ initdb.
+ * 2. Start Postgres listening on a Unix socket.
+ * 3. Create a new DB to back our Moray instance.
+ * 4. Start the Moray server in standalone mode (no Manatee).
+ * 5. Set up the "buckets_config" table in our new DB.
+ */
+
+'use strict';
+
+var mod_forkexec = require('forkexec');
+var mod_fs = require('fs');
+var mod_moray_server = require('moray-server/lib');
+var mod_util = require('util');
+var mod_vasync = require('vasync');
+var VError = require('verror');
+
+
+// --- Globals
+
+var BIND_IP = '127.0.0.1';
+
+var PG_CONFIG = [
+    'listen_addresses = \'\'',
+    'fsync = off',
+    'synchronous_commit = off',
+    'full_page_writes = off'
+].join('\n');
+
+var mkTableSQL = 'CREATE TABLE IF NOT EXISTS buckets_config ( ' +
+    'name text PRIMARY KEY, ' +
+    'index text NOT NULL, ' +
+    'pre text NOT NULL, ' +
+    'post text NOT NULL, ' +
+    'options text, ' +
+    'mtime timestamp without time zone DEFAULT now() NOT NULL' +
+');';
+
+
+// --- Internal
+
+function getRandomInt(min, max) {
+    return Math.floor(Math.random() * (max - min)) + min;
+}
+
+
+function mkMorayConfig(log, connstr) {
+    var morayPort = getRandomInt(2000, 10000);
+    return {
+        server: {
+            log: log,
+            name: 'moray-sandbox',
+            port: morayPort,
+            bindip: BIND_IP,
+            bunyan: {
+                level: 'info'
+            },
+            audit: false,
+            standalone: {
+                pg: {
+                    connectTimeout: 3000,
+                    maxConnections: 15,
+                    maxIdleTime: 120000,
+                    checkInterval: 30000,
+                    queryTimeout: 30000
+                },
+                url: connstr
+            },
+            cache: {
+                size: 1000,
+                expiry: 60
+            }
+        },
+        client: {
+            host: BIND_IP,
+            port: morayPort
+        }
+    };
+}
+
+
+function MoraySandbox(log, baseDir, cleanup) {
+    this.log      = log;
+    this.baseDir  = baseDir;
+    this.dbDir    = mod_util.format('%s/db', baseDir);
+    this.unixDir  = mod_util.format('%s/unix', baseDir);
+    this._cleanup = cleanup;
+    this.stopping = false;
+    this.pg_child = null;
+    this.servers  = [];
+
+    Object.seal(this);
+}
+
+
+MoraySandbox.prototype._initDB = function initDB(callback) {
+    var self = this;
+    var args = [ 'initdb', '-D', self.dbDir, '-E', 'UNICODE', '-A', 'trust' ];
+    self.log.info({ cmd: 'initdb', argv: args }, 'Executing command');
+    mod_forkexec.forkExecWait({ argv: args }, function (err, info) {
+        self.log.info(info, 'Finished initdb');
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        var cfg = mod_util.format('%s/postgresql.conf', self.dbDir);
+        mod_fs.appendFile(cfg, PG_CONFIG, function (fErr) {
+            if (fErr) {
+                callback(new VError(fErr, 'Failed to append to PG config'));
+                return;
+            }
+
+            mod_fs.mkdir(self.unixDir, function (mErr) {
+                if (mErr) {
+                    callback(new VError(mErr,
+                        'Failed to create directory for Unix sockets'));
+                    return;
+                }
+
+                callback();
+            });
+        });
+    });
+};
+
+
+MoraySandbox.prototype._startPG = function startPG(callback) {
+    var self = this;
+    var args = [ 'postgres', '-D', self.dbDir, '-k', self.unixDir ];
+    self.log.info({ cmd: 'postgres', argv: args }, 'Executing command');
+    self.pg_child = mod_forkexec.forkExecWait({ argv: args },
+        function (err, info) {
+        if (err) {
+            self.log.error(info, 'Postgres exited with an error');
+        } else {
+            self.log.info(info, 'Postgres exited non-fatally');
+        }
+        self._cleanup();
+    });
+    callback();
+};
+
+
+MoraySandbox.prototype._createDB = function createDB(req_id, callback) {
+    var self = this;
+    var attempt = 1;
+    var args = [ 'createdb', '-E', 'UNICODE', '-h', self.unixDir, req_id ];
+    function retry() {
+        self.log.info({ cmd: 'createdb', argv: args }, 'Executing command');
+        self.pg_child = mod_forkexec.forkExecWait({ argv: args },
+            function (err, info) {
+            if (err) {
+                if (attempt < 5) {
+                    // If PG is slow to start, createdb will fail the first time
+                    self.log.error(info,
+                        'Failed to create moray database; retrying');
+                    attempt += 1;
+                    retry();
+                    return;
+                } else {
+                    self.log.error(info,
+                        'Failed to create moray database; aborting');
+                }
+            }
+            callback(err, self.unixDir + ' ' + req_id);
+        });
+    }
+
+    retry();
+};
+
+
+MoraySandbox.prototype._startMoray = function startMoray(connstr, callback) {
+    var self = this;
+    var config = mkMorayConfig(self.log, connstr);
+    var server = mod_moray_server.createServer(config.server);
+    server.on('ready', function setupDB() {
+        server.db_conn.pg(function (cErr, pg) {
+            if (cErr) {
+                callback(cErr);
+                return;
+            }
+
+            var q = pg.query(mkTableSQL);
+
+            q.once('error', function (err) {
+                self.log.error(err, 'Error setting up database and tables');
+                pg.release();
+                callback(err);
+            });
+
+            q.once('end', function () {
+                self.log.info('Database and tables ready');
+                pg.release();
+                callback(null, config.client);
+            });
+        });
+    });
+    server.listen();
+    self.servers.push(server);
+};
+
+
+MoraySandbox.prototype.stop = function stopAll() {
+    var self = this;
+    if (self.stopping) {
+        return;
+    }
+
+    self.stopping = true;
+
+    function killPostgres() {
+        self.log.info('Killing off Postgres children');
+
+        // Send SIGTERM to process group.
+        process.kill(-process.pid, 'SIGTERM');
+
+        // Give Postgres time to shut down before removing its files.
+        setTimeout(self._cleanup, 5000);
+    }
+
+    if (self.pg_child) {
+        mod_vasync.forEachParallel({
+            'inputs': self.servers,
+            'func': function (server, cb) {
+                server.on('close', cb);
+                server.close();
+            }
+        }, killPostgres);
+    } else {
+        self._cleanup();
+    }
+};
+
+
+module.exports = MoraySandbox;
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..6ba31e4
--- /dev/null
+++ b/package.json
@@ -0,0 +1,34 @@
+{
+  "name": "moray-sandbox",
+  "description": "Library for managing temporary, sandboxed Moray instances",
+  "main": "./lib/index.js",
+  "version": "0.1.0",
+  "keywords": [ "moray" ],
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/joyent/node-moray-sandbox.git"
+  },
+  "dependencies": {
+    "assert-plus": "1.0.0",
+    "bunyan": "^1.8.5",
+    "clone": "1.0.2",
+    "forkexec": "1.1.0",
+    "moray-server": "git+https://github.com/joyent/moray.git#78ca9a6",
+    "uuid": "3.0.0",
+    "vasync": "1.6.4",
+    "verror": "1.9.0",
+    "tmp": "0.0.28"
+  },
+  "devDependencies": {
+    "moray": "^2.0.0",
+    "faucet": "0.0.1",
+    "istanbul": "^0.4.0",
+    "tape": "3.0.3",
+    "eslint": "2.13.1",
+    "eslint-plugin-joyent": "1.0.1"
+  },
+  "peerDependencies": {
+    "moray": "^2.0.0"
+  },
+  "license": "MPL-2.0"
+}
diff --git a/test/lib/log.js b/test/lib/log.js
new file mode 100644
index 0000000..0bff473
--- /dev/null
+++ b/test/lib/log.js
@@ -0,0 +1,21 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Bunyan logger for tests
+ */
+
+'use strict';
+
+module.exports = require('bunyan').createLogger({
+    name: 'sandbox-test',
+    level: (process.env.LOG_LEVEL || 'fatal'),
+    stream: process.stderr
+});
diff --git a/test/unit/basic.test.js b/test/unit/basic.test.js
new file mode 100644
index 0000000..ee79785
--- /dev/null
+++ b/test/unit/basic.test.js
@@ -0,0 +1,425 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
+ * Unit tests for basic usage
+ */
+
+'use strict';
+
+var log = require('../lib/log');
+var mod_mock_moray = require('../../lib');
+var util = require('util');
+var test = require('tape');
+
+
+// --- Globals
+
+
+var pg1, client1; // Client we store data in
+var client2; // Same PG server as client 1, shouldn't see data
+var client3; // Different PG server than clients 1 & 2, shouldn't see data
+
+var BUCKET = 'test_bucket';
+var BUCKET_SCHEMA = {
+    name: BUCKET,
+    index: {
+        email: {
+            type: 'string',
+            unique: true
+        },
+        subnet: {
+            type: 'subnet'
+        }
+    },
+    options: {
+        version: 1
+    },
+    post: [],
+    pre: []
+};
+
+var OBJECT_KEY1 = 'test_key1';
+var OBJECT_VALUE1 = {
+    email: 'contact@example.com',
+    subnet: 'fd0e::/64'
+};
+
+var OBJECT_KEY2 = 'test_key2';
+var OBJECT_VALUE2 = {
+    email: 'sales@example.com',
+    subnet: 'fe80::/64'
+};
+
+var SQL_STR = 'SELECT * FROM %s WHERE subnet >> inet(\'fd0e::1:234\');';
+
+
+// --- Setup tests
+
+
+test('Initial startup', function (t) {
+    t.plan(3);
+    t.test('Start client 1', function (t2) {
+        mod_mock_moray.create(log, function (err, mock, pg) {
+            t2.ifError(err, 'Creation should succeed');
+            t2.ok(mock, 'Should receive client 1');
+            client1 = mock;
+            pg1 = pg;
+            t2.end();
+        });
+    });
+    t.test('Start client 2', function (t2) {
+        pg1.spawnMoray(function (err, mock) {
+            t2.ifError(err, 'Creation should succeed');
+            t2.ok(mock, 'Should receive client 1');
+            client2 = mock;
+            t2.end();
+        });
+    });
+    t.test('Start client 3', function (t2) {
+        mod_mock_moray.create(log, function (err, mock) {
+            t2.ifError(err, 'Creation should succeed');
+            t2.ok(mock, 'Should receive client 2');
+            client3 = mock;
+            t2.end();
+        });
+    });
+});
+
+
+// --- Client tests
+
+
+test('Create and get bucket', function (t) {
+    t.plan(7);
+    t.test('Create bucket in client 1', function (t2) {
+        client1.createBucket(BUCKET, BUCKET_SCHEMA, function (err) {
+            t2.ifError(err, 'Bucket creation should succeed');
+            t2.end();
+        });
+    });
+    t.test('Get bucket from client 1', function (t2) {
+        client1.getBucket(BUCKET, function (err, bucket) {
+            t2.ifError(err, 'Bucket fetch should succeed');
+            BUCKET_SCHEMA.mtime = bucket.mtime;
+            t2.deepEqual(BUCKET_SCHEMA, bucket, 'Bucket values equal');
+            t2.end();
+        });
+    });
+    t.test('Client 2 shouldn\'t have bucket', function (t2) {
+        client2.getBucket(BUCKET, function (err, bucket) {
+            t2.ok(err, 'Bucket fetch should fail');
+            t2.deepEqual(undefined, bucket, 'Bucket is undefined');
+            t2.end();
+        });
+    });
+    t.test('Client 3 shouldn\'t have bucket', function (t2) {
+        client3.getBucket(BUCKET, function (err, bucket) {
+            t2.ok(err, 'Bucket fetch should fail');
+            t2.deepEqual(undefined, bucket, 'Bucket is undefined');
+            t2.end();
+        });
+    });
+    t.test('List buckets from client 1', function (t2) {
+        client1.listBuckets(function (err, buckets) {
+            t2.ifError(err, 'Bucket fetch should succeed');
+            t2.deepEqual(buckets, [ BUCKET_SCHEMA ],
+                'There should only be one bucket');
+            t2.end();
+        });
+    });
+    t.test('Client 2 shouldn\'t have any buckets', function (t2) {
+        client2.listBuckets(function (err, buckets) {
+            t2.ifError(err, 'Bucket fetch should succeed');
+            t2.deepEqual(buckets, [ ],
+                'There should only be zero buckets');
+            t2.end();
+        });
+    });
+    t.test('Client 3 shouldn\'t have any buckets', function (t2) {
+        client3.listBuckets(function (err, buckets) {
+            t2.ifError(err, 'Bucket fetch should succeed');
+            t2.deepEqual(buckets, [ ],
+                'There should only be zero buckets');
+            t2.end();
+        });
+    });
+});
+
+
+test('Store and get objects', function (t) {
+    t.plan(4);
+    t.test('Put object 1 in bucket', function (t2) {
+        client1.putObject(BUCKET, OBJECT_KEY1, OBJECT_VALUE1, function (err) {
+            t2.ifError(err, 'Put should succeed');
+            t2.end();
+        });
+    });
+    t.test('Put object 2 in bucket', function (t2) {
+        client1.putObject(BUCKET, OBJECT_KEY2, OBJECT_VALUE2, function (err) {
+            t2.ifError(err, 'Put should succeed');
+            t2.end();
+        });
+    });
+    t.test('Get object 1 from bucket', function (t2) {
+        client1.getObject(BUCKET, OBJECT_KEY1, function (err, obj) {
+            t2.ifError(err, 'Get should succeed');
+            t2.deepEqual(obj.value, OBJECT_VALUE1, 'Objects should be equal');
+            t2.end();
+        });
+    });
+    t.test('Get object 2 from bucket', function (t2) {
+        client1.getObject(BUCKET, OBJECT_KEY2, function (err, obj) {
+            t2.ifError(err, 'Get should succeed');
+            t2.deepEqual(obj.value, OBJECT_VALUE2, 'Objects should be equal');
+            t2.end();
+        });
+    });
+});
+
+
+test('Use SQL on bucket', function (t) {
+    var res = client1.sql(util.format(SQL_STR, BUCKET));
+    t.plan(1);
+    res.on('record', function (r) {
+        t.deepEqual(JSON.parse(r._value), OBJECT_VALUE1,
+            'Objects should be equal');
+    });
+    res.on('error', function (err) {
+        t.ifError(err, 'SQL shouldn\'t fail');
+        t.end();
+    });
+    res.on('end', function () {
+        t.end();
+    });
+});
+
+
+test('Delete objects from bucket', function (t) {
+    t.plan(2);
+    t.test('Delete object 1 from bucket', function (t2) {
+        client1.delObject(BUCKET, OBJECT_KEY1, function (err) {
+            t2.ifError(err, 'Delete should succeed');
+            t2.end();
+        });
+    });
+    t.test('Delete object 2 from bucket', function (t2) {
+        client1.delObject(BUCKET, OBJECT_KEY2, function (err) {
+            t2.ifError(err, 'Delete should succeed');
+            t2.end();
+        });
+    });
+});
+
+
+// --- Mock errors tests
+
+
+test('Fake deleteMany() errors', function (t) {
+    var client1clone = client1.clone();
+
+    var filter = '(email=*)';
+
+    var msg1 = 'first fake error';
+    var msg2 = 'second fake error';
+    var msg3 = 'unused fake error';
+
+    var err1 = new Error(msg1);
+    var err2 = new Error(msg2);
+    var err3 = new Error(msg3);
+
+    err1.name = 'FirstError';
+    err2.name = 'SecondError';
+    err3.name = 'UnusedError';
+
+    var errors = {
+        deleteMany: [ err1, err2 ],
+        batch: [ err3 ]
+    };
+
+    t.test('set and get fake errors', function (t2) {
+        client1.setMockErrors(errors);
+        t2.deepEqual(client1clone.getMockErrors(), errors,
+            'Clone has same errors');
+        t2.end();
+    });
+
+    t.test('client1.deleteMany() returns err1', function (t2) {
+        client1.deleteMany(BUCKET, filter, function (err) {
+            t2.equal(err, err1, 'Error passed to callback');
+            var last = {
+                bucket: BUCKET,
+                filter: filter,
+                msg: 'first fake error',
+                op: 'deleteMany'
+            };
+            t2.deepEqual(client1.getLastMockError(), last,
+                'client1.getLastMockError()');
+            t2.deepEqual(client1clone.getLastMockError(), last,
+                'client1clone.getLastMockError()');
+            t2.end();
+        });
+    });
+
+    t.test('client1clone.deleteMany() returns err2', function (t2) {
+        client1clone.deleteMany(BUCKET, filter, function (err) {
+            t2.equal(err, err2, 'Correct error');
+            var last = {
+                bucket: BUCKET,
+                filter: filter,
+                msg: 'second fake error',
+                op: 'deleteMany'
+            };
+            t2.deepEqual(client1.getLastMockError(), last,
+                'client1.getLastMockError()');
+            t2.deepEqual(client1clone.getLastMockError(), last,
+                'client1clone.getLastMockError()');
+            t2.end();
+        });
+    });
+
+    t.test('no more mock deleteMany() errors', function (t2) {
+        client1.deleteMany(BUCKET, filter, function (err) {
+            t2.equal(err, null, 'No callback error');
+            t2.end();
+        });
+    });
+
+    t.test('cleanup', function (t2) {
+        client1.setMockErrors({});
+        client1clone.close();
+        t2.end();
+    });
+});
+
+
+test('Fake findObjects() errors w/ interleaved success', function (t) {
+    var filter = '(email=contact@example.com)';
+
+    var err1 = new Error('first fake error');
+    var err2 = new Error('second fake error');
+    var err3 = new Error('unused fake error');
+
+    err1.name = 'FirstError';
+    err2.name = 'SecondError';
+    err3.name = 'UnusedError';
+
+    var errors = {
+        findObjects: [ err1, null, err2 ],
+        batch: [ err3 ]
+    };
+
+    t.test('put object in bucket', function (t2) {
+        client1.putObject(BUCKET, OBJECT_KEY1, OBJECT_VALUE1, function (err) {
+            t2.ifError(err, 'putObject() error');
+            t2.end();
+        });
+    });
+
+    t.test('set and get fake errors', function (t2) {
+        client1.setMockErrors(errors);
+        t2.deepEqual(client1.getMockErrors(), errors,
+            'Client returns set errors');
+        t2.end();
+    });
+
+    function failedFind(expErr) {
+        return function (t2) {
+            var res = client1.findObjects(BUCKET, filter);
+            res.on('record', function (r) {
+                t2.equal(r, {}, 'Unexpected record returned');
+            });
+            res.on('error', function (err) {
+                t2.equal(expErr, err, 'Correct error emitted');
+                t2.deepEqual(client1.getLastMockError(), {
+                    bucket: BUCKET,
+                    filter: filter,
+                    msg: expErr.message,
+                    op: 'findObjects'
+                }, 'client1.getLastMockError()');
+                t2.end();
+            });
+            res.on('end', function () {
+                t2.fail('findObjects() should not emit "end"');
+                t2.end();
+            });
+        };
+    }
+
+    function successfulFind(t2) {
+        var count = 0;
+        var res = client1.findObjects(BUCKET, filter);
+        res.on('record', function (r) {
+            t2.ok(r, 'Record returned');
+            t2.deepEqual(r.key, OBJECT_KEY1, 'Record has correct key');
+            t2.deepEqual(r.value, OBJECT_VALUE1, 'Record has correct value');
+            count += 1;
+        });
+        res.on('error', function (err) {
+            t2.equal(err, {}, 'Unexpected error emitted');
+            t2.end();
+        });
+        res.on('end', function () {
+            t2.equal(count, 1, 'One record returned');
+            t2.end();
+        });
+    }
+
+    t.test('client1.findObjects() emits err1', failedFind(err1));
+    t.test('client1.findObjects() uses interleaved null', successfulFind);
+    t.test('client1.findObjects() emits err2', failedFind(err2));
+    t.test('no more findObjects() errors', successfulFind);
+
+    t.test('cleanup', function (t2) {
+        client1.setMockErrors({});
+        client1.delObject(BUCKET, OBJECT_KEY1, function (err) {
+            t2.ifError(err, 'delObject() error');
+            t2.end();
+        });
+    });
+});
+
+
+// --- deleteBucket() tests
+
+
+test('Delete bucket', function (t) {
+    t.plan(3);
+    t.test('Delete invalid bucket with client 2', function (t2) {
+        client2.delBucket(BUCKET, function (err) {
+            t2.ok(err, 'Deleting should fail');
+            t2.end();
+        });
+    });
+    t.test('Delete invalid bucket with client 3', function (t2) {
+        client3.delBucket(BUCKET, function (err) {
+            t2.ok(err, 'Deleting should fail');
+            t2.end();
+        });
+    });
+    t.test('Delete valid bucket with client 1', function (t2) {
+        client1.delBucket(BUCKET, function (err) {
+            t2.ifError(err, 'Deleting should succeed');
+            t2.end();
+        });
+    });
+});
+
+
+// --- Teardown tests
+
+
+test('Shutdown server', function (t) {
+    client1.close();
+    client2.close();
+    pg1.stop();
+    client3.stop();
+    t.end();
+});
diff --git a/test/unit/run.js b/test/unit/run.js
new file mode 100644
index 0000000..5d66fe7
--- /dev/null
+++ b/test/unit/run.js
@@ -0,0 +1,32 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2014 Patrick Mooney. All rights reserved.
+ */
+
+'use strict';
+
+var assert = require('assert');
+var fs = require('fs');
+var path = require('path');
+
+function runTests(directory) {
+    fs.readdir(directory, function (err, files) {
+        assert.ifError(err);
+        files.filter(function (f) {
+            return (/\.test\.js$/.test(f));
+        }).map(function (f) {
+            return (path.join(directory, f));
+        }).forEach(require);
+    });
+}
+
+// --- Run All Tests
+
+(function main() {
+    runTests(__dirname);
+})();
diff --git a/tools/eslint.node.conf b/tools/eslint.node.conf
index ccc6f09..ae6d704 100644
--- a/tools/eslint.node.conf
+++ b/tools/eslint.node.conf
@@ -15,5 +15,6 @@
         "node": true
     },
     "rules": {
+        "strict": [ "error", "global" ]
     }
 }
-- 
2.21.0

