commit eddf2b75896eb04cbd4eea500b504f72cfff3458 (refs/changes/15/4215/2)
Author: Jason King <jason.king@joyent.com>
Date:   2018-06-14T10:28:28-05:00 (1 year, 4 months ago)
    
    Improve mblk handling when examining IP header

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index 1584e912a1..a368cb0d82 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -396,43 +396,50 @@ overlay_get_vl3_ips(mblk_t *mp, struct in6_addr *src, struct in6_addr *dst)
 {
 	uint16_t sap;
 
-	if (MBLKL(mp) >= sizeof (struct ether_vlan_header) + sizeof (ip6_t)) {
-		struct ether_vlan_header *eth =
-		    (struct ether_vlan_header *)mp->b_rptr;
-		ipha_t *iphp = (ipha_t *)(eth + 1);
-		ip6_t *ip6hp = (ip6_t *)(eth + 1);
-		sap = ntohs(eth->ether_tpid);
-
-		if (sap == ETHERTYPE_VLAN) {
-			sap = ntohs(eth->ether_type);
-		} else {
-			struct ether_header *e = (struct ether_header *)eth;
+#if 1
+	/* Temporary until mblk helpers are integrated */
+	struct ether_vlan_header *eth = (struct ether_vlan_header *)mp->b_rptr;
+	ipha_t *iphp = (ipha_t *)(eth + 1);
+	ip6_t *ip6hp = (ip6_t *)(eth + 1);
+	size_t mlen = MBLKL(mp);
 
-			iphp = (ipha_t *)(e + 1);
-			ip6hp = (ip6_t *)(e + 1);
-		}
+	if (mlen < sizeof (struct ether_vlan_header))
+		return (EINVAL);
+	mlen -= sizeof (struct ether_vlan_header);
 
-		switch (sap) {
-		case ETHERTYPE_IP:
-			ASSERT3U(IPH_HDR_VERSION(iphp), ==, IPV4_VERSION);
-			IN6_IPADDR_TO_V4MAPPED(iphp->ipha_src, src);
-			IN6_IPADDR_TO_V4MAPPED(iphp->ipha_dst, dst);
-			break;
-		case ETHERTYPE_IPV6:
-			ASSERT3U(IPH_HDR_VERSION(iphp), ==, IPV6_VERSION);
-			bcopy(&ip6hp->ip6_src, src, sizeof (*src));
-			bcopy(&ip6hp->ip6_dst, dst, sizeof (*dst));
-			break;
-		default:
+	/* We currently don't support routing on untagged vlans */
+	if ((sap = ntohs(eth->ether_tpid)) != ETHERTYPE_VLAN)
+		return (EINVAL);
+
+	sap = ntohs(eth->ether_type);
+	if (mlen == 0) {
+		if ((mp = mp->b_cont) == NULL)
 			return (EINVAL);
-		}
+		mlen = MBLKL(mp);
+		iphp = (ipha_t *)mp->b_rptr;
+		ip6hp = (ip6_t *)mp->b_rptr;
+	}
 
-		return (0);
+	switch (sap) {
+	case ETHERTYPE_IP:
+		if (mlen < sizeof (ipha_t))
+			return (EINVAL);
+		ASSERT3U(IPH_HDR_VERSION(iphp), ==, IPV4_VERSION);
+		IN6_IPADDR_TO_V4MAPPED(iphp->ipha_src, src);
+		IN6_IPADDR_TO_V4MAPPED(iphp->ipha_dst, dst);
+		break;
+	case ETHERTYPE_IPV6:
+		if (mlen < sizeof (ip6_t))
+			return (EINVAL);
+		ASSERT3U(IPH_HDR_VERSION(iphp), ==, IPV6_VERSION);
+		bcopy(&ip6hp->ip6_src, src, sizeof (*src));
+		bcopy(&ip6hp->ip6_dst, dst, sizeof (*dst));
+		break;
+	default:
+		return (EINVAL);
 	}
 
-#if 1
-	/* Temporary until mblk helpers are integrated */
-	return (EINVAL);
+	return (0);
 #else
 	size_t soff, doff;
 	uint32_t v4s, v4d;
