From e5d1a4673837c3aba7a8689513c107c4e962b6b2 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Fri, 7 Apr 2017 19:39:05 +0000
Subject: [PATCH] OS-5846 procfs should follow VFS rules Reviewed by: Jerry
 Jelinek <jerry.jelinek@joyent.com> Reviewed by: Robert Mustacchi
 <rm@joyent.com> Approved by: Jerry Jelinek <jerry.jelinek@joyent.com>

---
 usr/src/uts/common/fs/proc/prvnops.c | 29 +++++++++++++++++++++++++---
 usr/src/uts/common/fs/vnode.c        | 17 ++++++++++++++++
 usr/src/uts/common/sys/vnode.h       | 10 +++++++++-
 3 files changed, 52 insertions(+), 4 deletions(-)

diff --git a/usr/src/uts/common/fs/proc/prvnops.c b/usr/src/uts/common/fs/proc/prvnops.c
index 9ac5639d94..93a3d68ea5 100644
--- a/usr/src/uts/common/fs/proc/prvnops.c
+++ b/usr/src/uts/common/fs/proc/prvnops.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*	Copyright (c) 1984,	 1986, 1987, 1988, 1989 AT&T	*/
@@ -3555,6 +3555,25 @@ prlookup(vnode_t *dp, char *comp, vnode_t **vpp, pathname_t *pathp,
 			return (error);
 		/* FALLTHROUGH */
 	case PR_FD:
+		/*
+		 * Performing a VOP_LOOKUP on the underlying vnode and emitting
+		 * the resulting vnode, without encapsulation, as our own is a
+		 * very special case when it comes to the assumptions built
+		 * into VFS.
+		 *
+		 * Since the resulting vnode is highly likely to be at some
+		 * abitrary position in another filesystem, we insist that the
+		 * VTRAVERSE flag is set on the parent.  This prevents things
+		 * such as the v_path freshness logic from mistaking the
+		 * resulting vnode as a "real" child of the parent, rather than
+		 * a consequence of this "procfs wormhole".
+		 *
+		 * Failure to establish such protections can lead to
+		 * incorrectly calculated v_paths being set on nodes reached
+		 * through these lookups.
+		 */
+		ASSERT((dp->v_flag & VTRAVERSE) != 0);
+
 		dp = pnp->pr_realvp;
 		return (VOP_LOOKUP(dp, comp, vpp, pathp, flags, rdir, cr, ct,
 		    direntflags, realpnp));
@@ -3804,7 +3823,8 @@ pr_lookup_piddir(vnode_t *dp, char *comp)
 		vp = (type == PR_CURDIR)? up->u_cdir :
 		    (up->u_rdir? up->u_rdir : rootdir);
 
-		if (vp == NULL) {	/* can't happen? */
+		if (vp == NULL) {
+			/* can't happen(?) */
 			prunlock(dpnp);
 			prfreenode(pnp);
 			return (NULL);
@@ -3815,6 +3835,7 @@ pr_lookup_piddir(vnode_t *dp, char *comp)
 		 */
 		VN_HOLD(vp);
 		pnp->pr_realvp = vp;
+		PTOV(pnp)->v_flag |= VTRAVERSE;
 		break;
 	default:
 		break;
@@ -4236,8 +4257,10 @@ pr_lookup_fddir(vnode_t *dp, char *comp)
 		pnp->pr_parent = dp;		/* needed for prlookup */
 		VN_HOLD(dp);
 		vp = PTOV(pnp);
-		if (pnp->pr_realvp->v_type == VDIR)
+		if (pnp->pr_realvp->v_type == VDIR) {
 			vp->v_type = VDIR;
+			vp->v_flag |= VTRAVERSE;
+		}
 	}
 
 	return (vp);
diff --git a/usr/src/uts/common/fs/vnode.c b/usr/src/uts/common/fs/vnode.c
index 305387a283..d2562caa58 100644
--- a/usr/src/uts/common/fs/vnode.c
+++ b/usr/src/uts/common/fs/vnode.c
@@ -3055,6 +3055,23 @@ vn_setpath_common(vnode_t *pvp, vnode_t *vp, const char *name, size_t len,
 
 	/* Take snapshot of parent dir */
 	mutex_enter(&pvp->v_lock);
+
+	if ((pvp->v_flag & VTRAVERSE) != 0) {
+		/*
+		 * When the parent vnode has VTRAVERSE set in its flags, normal
+		 * assumptions about v_path calculation no longer apply.  The
+		 * primary situation where this occurs is via the VFS tricks
+		 * which procfs plays in order to allow /proc/PID/(root|cwd) to
+		 * yield meaningful results.
+		 *
+		 * When this flag is set, v_path on the child must not be
+		 * updated since the calculated value is likely to be
+		 * incorrect, given the current context.
+		 */
+		mutex_exit(&pvp->v_lock);
+		return;
+	}
+
 retrybuf:
 	if (pvp->v_path == vn_vpath_empty) {
 		/*
diff --git a/usr/src/uts/common/sys/vnode.h b/usr/src/uts/common/sys/vnode.h
index c779cc1ff6..3ce834ae13 100644
--- a/usr/src/uts/common/sys/vnode.h
+++ b/usr/src/uts/common/sys/vnode.h
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
@@ -401,6 +401,14 @@ typedef struct vn_vfslocks_entry {
 
 #define	V_SYSATTR	0x40000	/* vnode is a GFS system attribute */
 
+/*
+ * Indication that VOP_LOOKUP operations on this vnode may yield results from a
+ * different VFS instance.  The main use of this is to suppress v_path
+ * calculation logic when filesystems such as procfs emit results which defy
+ * expectations about normal VFS behavior.
+ */
+#define	VTRAVERSE	0x80000
+
 /*
  * Vnode attributes.  A bit-mask is supplied as part of the
  * structure to indicate the attributes the caller wants to
-- 
2.21.0

