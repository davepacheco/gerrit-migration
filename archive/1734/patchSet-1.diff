From f7a2c9a4216df49f6c0c84674c9f55daa59678ab Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Thu, 23 Mar 2017 23:30:52 +0000
Subject: [PATCH] OS-5846 procfs should follow VFS rules

---
 usr/src/man/man4/proc.4              | 14 ++---
 usr/src/uts/common/fs/proc/prvnops.c | 85 +++++++++++++++-------------
 2 files changed, 50 insertions(+), 49 deletions(-)

diff --git a/usr/src/man/man4/proc.4 b/usr/src/man/man4/proc.4
index 4f123bfd93..18452a1897 100644
--- a/usr/src/man/man4/proc.4
+++ b/usr/src/man/man4/proc.4
@@ -1,7 +1,7 @@
 '\" te
 .\" Copyright 1989 AT&T
 .\" Copyright (c) 2006, Sun Microsystems, Inc. All Rights Reserved.
-.\" Copyright 2015, Joyent, Inc.
+.\" Copyright (c) 2017, Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
@@ -1280,15 +1280,11 @@ thread stacks of a multi-threaded process.
 .SS "cwd"
 .LP
 A symbolic link to the process's current working directory. See \fBchdir\fR(2).
-A \fBreadlink\fR(2) of \fB/proc/\fIpid\fR/cwd\fR yields a null string. However,
-it can be opened, listed, and searched as a directory, and can be the target of
-\fBchdir\fR(2).
 .SS "root"
 .LP
 A symbolic link to the process's root directory.
 \fB/proc/\fR\fIpid\fR\fB/root\fR can differ from the system root directory if
-the process or one of its ancestors executed \fBchroot\fR(2) as super user. It
-has the same semantics as \fB/proc/\fR\fIpid\fR\fB/cwd\fR.
+the process or one of its ancestors executed \fBchroot\fR(2) as super user.
 .SS "fd"
 .LP
 A directory containing references to the open files of the process. Each entry
@@ -1298,10 +1294,8 @@ is a decimal number corresponding to an open file descriptor in the process.
 If an entry refers to a regular file, it can be opened with normal file system
 semantics but, to ensure that the controlling process cannot gain greater
 access than the controlled process, with no file access modes other than its
-read/write open modes in the controlled process. If an entry refers to a
-directory, it can be accessed with the same semantics as
-\fB/proc/\fIpid\fR/cwd\fR. An attempt to open any other type of entry fails
-with \fBEACCES\fR.
+read/write open modes in the controlled process. An attempt to open any other
+type of entry fails with \fBEACCES\fR.
 .SS "object"
 .LP
 A directory containing read-only files with names corresponding to the
diff --git a/usr/src/uts/common/fs/proc/prvnops.c b/usr/src/uts/common/fs/proc/prvnops.c
index 9ac5639d94..349a6efc53 100644
--- a/usr/src/uts/common/fs/proc/prvnops.c
+++ b/usr/src/uts/common/fs/proc/prvnops.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2016 Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*	Copyright (c) 1984,	 1986, 1987, 1988, 1989 AT&T	*/
@@ -255,10 +255,13 @@ propen(vnode_t **vpp, int flag, cred_t *cr, caller_context_t *ct)
 	 * Just do it if we are opening the current or root directory.
 	 */
 	switch (type) {
-	case PR_OBJECT:
-	case PR_FD:
 	case PR_CURDIR:
 	case PR_ROOTDIR:
+		/* These should never be opened directly, as symlinks. */
+		return (EACCES);
+
+	case PR_OBJECT:
+	case PR_FD:
 		rvp = pnp->pr_realvp;
 		vtype = rvp->v_type;
 		if ((type == PR_OBJECT && (flag & FWRITE)) ||
@@ -3522,6 +3525,7 @@ static vnode_t *(*pr_lookup_function[PR_NFILES])() = {
 	pr_lookup_notdir,	/* old pagedata file			*/
 };
 
+/* ARGSUSED */
 static int
 prlookup(vnode_t *dp, char *comp, vnode_t **vpp, pathname_t *pathp,
     int flags, vnode_t *rdir, cred_t *cr, caller_context_t *ct,
@@ -3547,21 +3551,6 @@ prlookup(vnode_t *dp, char *comp, vnode_t **vpp, pathname_t *pathp,
 		return (0);
 	}
 
-	switch (type) {
-	case PR_CURDIR:
-	case PR_ROOTDIR:
-		/* restrict lookup permission to owner or root */
-		if ((error = praccess(dp, VEXEC, 0, cr, ct)) != 0)
-			return (error);
-		/* FALLTHROUGH */
-	case PR_FD:
-		dp = pnp->pr_realvp;
-		return (VOP_LOOKUP(dp, comp, vpp, pathp, flags, rdir, cr, ct,
-		    direntflags, realpnp));
-	default:
-		break;
-	}
-
 	if ((type == PR_OBJECTDIR || type == PR_FDDIR || type == PR_PATHDIR) &&
 	    (error = praccess(dp, VEXEC, 0, cr, ct)) != 0)
 		return (error);
@@ -3804,7 +3793,8 @@ pr_lookup_piddir(vnode_t *dp, char *comp)
 		vp = (type == PR_CURDIR)? up->u_cdir :
 		    (up->u_rdir? up->u_rdir : rootdir);
 
-		if (vp == NULL) {	/* can't happen? */
+		if (vp == NULL) {
+			/* can't happen(?) */
 			prunlock(dpnp);
 			prfreenode(pnp);
 			return (NULL);
@@ -4237,7 +4227,7 @@ pr_lookup_fddir(vnode_t *dp, char *comp)
 		VN_HOLD(dp);
 		vp = PTOV(pnp);
 		if (pnp->pr_realvp->v_type == VDIR)
-			vp->v_type = VDIR;
+			vp->v_type = VLNK;
 	}
 
 	return (vp);
@@ -4700,6 +4690,10 @@ prgetnode(vnode_t *dp, prnodetype_t type)
 
 	case PR_CURDIR:
 	case PR_ROOTDIR:
+		vp->v_type = VLNK;
+		pnp->pr_mode = 0777;
+		break;
+
 	case PR_FDDIR:
 	case PR_OBJECTDIR:
 	case PR_PATHDIR:
@@ -6012,31 +6006,20 @@ prreadlink(vnode_t *vp, uio_t *uiop, cred_t *cr, caller_context_t *ctp)
 {
 	prnode_t *pnp = VTOP(vp);
 	char *buf;
-	int ret = EINVAL;
 	char idbuf[16];
-	int length, rlength;
+	int length, rlength, err;
 	contract_t *ct;
 
 	switch (pnp->pr_type) {
 	case PR_SELF:
 		(void) snprintf(idbuf, sizeof (idbuf), "%d", curproc->p_pid);
-		ret = uiomove(idbuf, strlen(idbuf), UIO_READ, uiop);
-		break;
+		return (uiomove(idbuf, strlen(idbuf), UIO_READ, uiop));
+
 	case PR_OBJECT:
-	case PR_FD:
-	case PR_CURDIR:
-	case PR_ROOTDIR:
 		if (pnp->pr_realvp->v_type == VDIR)
-			ret = 0;
-		break;
-	case PR_PATH:
-		buf = kmem_alloc(MAXPATHLEN, KM_SLEEP);
-
-		if ((ret = prreadlink_lookup(pnp, buf, MAXPATHLEN, cr)) == 0)
-			ret = uiomove(buf, strlen(buf), UIO_READ, uiop);
+			return (0);
+		return (EINVAL);
 
-		kmem_free(buf, MAXPATHLEN);
-		break;
 	case PR_CT:
 		ASSERT(pnp->pr_contract != NULL);
 		ct = pnp->pr_contract;
@@ -6046,14 +6029,38 @@ prreadlink(vnode_t *vp, uio_t *uiop, cred_t *cr, caller_context_t *ctp)
 		rlength = snprintf(buf, length, CTFS_ROOT "/%s/%d",
 		    ct->ct_type->ct_type_name, ct->ct_id);
 		ASSERT(rlength < length);
-		ret = uiomove(buf, rlength, UIO_READ, uiop);
+		err = uiomove(buf, rlength, UIO_READ, uiop);
 		kmem_free(buf, length);
+		return (err);
+
+	case PR_CURDIR:
+	case PR_ROOTDIR:
+		/* restrict readlink permission to owner or root */
+		if ((err = praccess(vp, VEXEC, 0, cr, ctp)) != 0) {
+			return (err);
+		}
 		break;
-	default:
+	case PR_FD:
+		/* symlinks are only necessary for directories */
+		if (pnp->pr_realvp->v_type != VDIR)
+			return (EINVAL);
+		break;
+	case PR_PATH:
 		break;
+
+	default:
+		return (EINVAL);
 	}
 
-	return (ret);
+	/*
+	 * Handle actual readlink from the above CURDIR/ROOTDIR/FD/PATH cases.
+	 */
+	buf = kmem_alloc(MAXPATHLEN, KM_SLEEP);
+	if ((err = prreadlink_lookup(pnp, buf, MAXPATHLEN, cr)) == 0) {
+		err = uiomove(buf, strlen(buf), UIO_READ, uiop);
+	}
+	kmem_free(buf, MAXPATHLEN);
+	return (err);
 }
 
 /*ARGSUSED2*/
-- 
2.21.0

