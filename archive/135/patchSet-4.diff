From d103e8b98085dbb5f7707242723b9d3ce74f2723 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Tue, 26 Jul 2016 15:05:29 +0000
Subject: [PATCH] OS-5536 update to ACPI version 6.x Reviewed by: Patrick
 Mooney <patrick.mooney@joyent.com> Reviewed by: Robert Mustacchi
 <rm@joyent.com>

---
 .../cmd/mdb/i86pc/modules/apix/amd64/Makefile |    3 +
 .../cmd/mdb/i86pc/modules/apix/ia32/Makefile  |    3 +
 .../mdb/i86pc/modules/pcplusmp/amd64/Makefile |    3 +
 .../mdb/i86pc/modules/pcplusmp/ia32/Makefile  |    3 +
 .../cmd/mdb/i86pc/modules/unix/amd64/Makefile |    3 +
 .../cmd/mdb/i86pc/modules/unix/ia32/Makefile  |    3 +
 .../cmd/mdb/i86pc/modules/uppc/amd64/Makefile |    4 +-
 .../cmd/mdb/i86pc/modules/uppc/ia32/Makefile  |    4 +-
 .../mdb/i86xpv/modules/unix/amd64/Makefile    |    3 +
 .../cmd/mdb/i86xpv/modules/unix/ia32/Makefile |    3 +
 .../mdb/i86xpv/modules/xpv_psm/amd64/Makefile |    4 +-
 .../mdb/i86xpv/modules/xpv_psm/ia32/Makefile  |    4 +-
 .../i86xpv/modules/xpv_uppc/amd64/Makefile    |    4 +-
 .../mdb/i86xpv/modules/xpv_uppc/ia32/Makefile |    4 +-
 usr/src/uts/i86pc/acpi_drv/Makefile           |    4 +-
 usr/src/uts/i86pc/acpidev/Makefile            |    3 +
 usr/src/uts/i86pc/acpinex/Makefile            |    4 +
 usr/src/uts/i86pc/acpippm/Makefile            |    4 +
 usr/src/uts/i86pc/amd_iommu/Makefile          |    3 +
 usr/src/uts/i86pc/amd_opteron/Makefile        |    3 +-
 usr/src/uts/i86pc/apix/Makefile               |    2 +
 usr/src/uts/i86pc/cpr/Makefile                |    2 +
 usr/src/uts/i86pc/cpudrv/Makefile             |    4 +
 usr/src/uts/i86pc/drmach_acpi/Makefile        |    4 +
 .../i86pc/io/acpi/acpidev/acpidev_resource.c  |   85 +-
 usr/src/uts/i86pc/io/ppm/acpisleep.c          |   24 +-
 usr/src/uts/i86pc/io/psm/psm_common.c         |    6 +-
 usr/src/uts/i86pc/isa/Makefile                |    4 +
 usr/src/uts/i86pc/npe/Makefile                |    3 +
 usr/src/uts/i86pc/pci-ide/Makefile            |    3 +
 usr/src/uts/i86pc/pci/Makefile                |    3 +
 usr/src/uts/i86pc/pcplusmp/Makefile           |    4 +
 usr/src/uts/i86pc/tzmon/Makefile              |    3 +
 usr/src/uts/i86pc/unix/Makefile               |   12 +
 usr/src/uts/i86pc/uppc/Makefile               |    3 +-
 usr/src/uts/i86xpv/amd_opteron/Makefile       |    2 +
 usr/src/uts/i86xpv/isa/Makefile               |    4 +
 usr/src/uts/i86xpv/npe/Makefile               |    3 +
 usr/src/uts/i86xpv/pci-ide/Makefile           |    3 +
 usr/src/uts/i86xpv/pci/Makefile               |    3 +
 usr/src/uts/i86xpv/rootnex/Makefile           |    3 +
 usr/src/uts/i86xpv/unix/Makefile              |    5 +
 usr/src/uts/i86xpv/xpv_psm/Makefile           |    3 +
 usr/src/uts/i86xpv/xpv_uppc/Makefile          |    4 +-
 usr/src/uts/intel/Makefile.files              |   81 +-
 usr/src/uts/intel/acpica/Makefile             |    6 +-
 usr/src/uts/intel/io/acpica/acpi_enum.c       |   99 +-
 usr/src/uts/intel/io/acpica/acpica.c          |   26 +-
 usr/src/uts/intel/io/acpica/ahids.c           |  245 +
 usr/src/uts/intel/io/acpica/changes.txt       | 8627 +++++++++++++----
 usr/src/uts/intel/io/acpica/debugger/dbcmds.c | 1079 ---
 .../uts/intel/io/acpica/debugger/dbdisply.c   | 1057 --
 usr/src/uts/intel/io/acpica/debugger/dbexec.c | 1105 ---
 .../uts/intel/io/acpica/debugger/dbfileio.c   |  578 --
 .../uts/intel/io/acpica/debugger/dbhistry.c   |  220 -
 .../uts/intel/io/acpica/debugger/dbinput.c    | 1091 ---
 .../uts/intel/io/acpica/debugger/dbmethod.c   |  525 -
 .../uts/intel/io/acpica/debugger/dbnames.c    |  934 --
 .../uts/intel/io/acpica/debugger/dbstats.c    |  561 --
 .../uts/intel/io/acpica/debugger/dbutils.c    |  523 -
 .../uts/intel/io/acpica/debugger/dbxface.c    |  536 -
 .../intel/io/acpica/disassembler/dmbuffer.c   |  628 +-
 .../intel/io/acpica/disassembler/dmcstyle.c   |  877 ++
 .../intel/io/acpica/disassembler/dmdeferred.c |  264 +
 .../intel/io/acpica/disassembler/dmnames.c    |   45 +-
 .../intel/io/acpica/disassembler/dmobject.c   |  589 --
 .../intel/io/acpica/disassembler/dmopcode.c   |  629 +-
 .../intel/io/acpica/disassembler/dmresrc.c    |   48 +-
 .../intel/io/acpica/disassembler/dmresrcl.c   |  135 +-
 .../intel/io/acpica/disassembler/dmresrcl2.c  |  174 +-
 .../intel/io/acpica/disassembler/dmresrcs.c   |   63 +-
 .../intel/io/acpica/disassembler/dmutils.c    |   41 +-
 .../uts/intel/io/acpica/disassembler/dmwalk.c |  313 +-
 .../uts/intel/io/acpica/dispatcher/dsargs.c   |   42 +-
 .../intel/io/acpica/dispatcher/dscontrol.c    |   71 +-
 .../uts/intel/io/acpica/dispatcher/dsdebug.c  |  250 +
 .../uts/intel/io/acpica/dispatcher/dsfield.c  |  187 +-
 .../uts/intel/io/acpica/dispatcher/dsinit.c   |   86 +-
 .../uts/intel/io/acpica/dispatcher/dsmethod.c |  270 +-
 .../uts/intel/io/acpica/dispatcher/dsmthdat.c |   61 +-
 .../uts/intel/io/acpica/dispatcher/dsobject.c |  109 +-
 .../uts/intel/io/acpica/dispatcher/dsopcode.c |  106 +-
 .../uts/intel/io/acpica/dispatcher/dsutils.c  |  122 +-
 .../uts/intel/io/acpica/dispatcher/dswexec.c  |   92 +-
 .../uts/intel/io/acpica/dispatcher/dswload.c  |   86 +-
 .../uts/intel/io/acpica/dispatcher/dswload2.c |   78 +-
 .../uts/intel/io/acpica/dispatcher/dswscope.c |    7 +-
 .../uts/intel/io/acpica/dispatcher/dswstate.c |   28 +-
 usr/src/uts/intel/io/acpica/events/evevent.c  |   30 +-
 usr/src/uts/intel/io/acpica/events/evglock.c  |   14 +-
 usr/src/uts/intel/io/acpica/events/evgpe.c    |  228 +-
 usr/src/uts/intel/io/acpica/events/evgpeblk.c |   67 +-
 .../uts/intel/io/acpica/events/evgpeinit.c    |   60 +-
 .../uts/intel/io/acpica/events/evgpeutil.c    |  109 +-
 .../uts/intel/io/acpica/events/evhandler.c    |  606 ++
 usr/src/uts/intel/io/acpica/events/evmisc.c   |   30 +-
 usr/src/uts/intel/io/acpica/events/evregion.c |  872 +-
 usr/src/uts/intel/io/acpica/events/evrgnini.c |  124 +-
 usr/src/uts/intel/io/acpica/events/evsci.c    |   95 +-
 usr/src/uts/intel/io/acpica/events/evxface.c  |  384 +-
 usr/src/uts/intel/io/acpica/events/evxfevnt.c |   85 +-
 usr/src/uts/intel/io/acpica/events/evxfgpe.c  |  262 +-
 usr/src/uts/intel/io/acpica/events/evxfregn.c |   46 +-
 .../uts/intel/io/acpica/executer/exconcat.c   |  460 +
 .../uts/intel/io/acpica/executer/exconfig.c   |  146 +-
 .../uts/intel/io/acpica/executer/exconvrt.c   |   66 +-
 .../uts/intel/io/acpica/executer/excreate.c   |   47 +-
 .../uts/intel/io/acpica/executer/exdebug.c    |  128 +-
 usr/src/uts/intel/io/acpica/executer/exdump.c |  347 +-
 .../uts/intel/io/acpica/executer/exfield.c    |  238 +-
 .../uts/intel/io/acpica/executer/exfldio.c    |  124 +-
 usr/src/uts/intel/io/acpica/executer/exmisc.c |  308 +-
 .../uts/intel/io/acpica/executer/exmutex.c    |   81 +-
 .../uts/intel/io/acpica/executer/exnames.c    |   26 +-
 .../uts/intel/io/acpica/executer/exoparg1.c   |  176 +-
 .../uts/intel/io/acpica/executer/exoparg2.c   |   78 +-
 .../uts/intel/io/acpica/executer/exoparg3.c   |   50 +-
 .../uts/intel/io/acpica/executer/exoparg6.c   |   41 +-
 usr/src/uts/intel/io/acpica/executer/exprep.c |   93 +-
 .../uts/intel/io/acpica/executer/exregion.c   |   65 +-
 .../uts/intel/io/acpica/executer/exresnte.c   |   38 +-
 .../uts/intel/io/acpica/executer/exresolv.c   |   69 +-
 .../uts/intel/io/acpica/executer/exresop.c    |   66 +-
 .../uts/intel/io/acpica/executer/exstore.c    |  283 +-
 .../uts/intel/io/acpica/executer/exstoren.c   |   34 +-
 .../uts/intel/io/acpica/executer/exstorob.c   |   30 +-
 .../uts/intel/io/acpica/executer/exsystem.c   |   34 +-
 .../uts/intel/io/acpica/executer/extrace.c    |  427 +
 .../uts/intel/io/acpica/executer/exutils.c    |  168 +-
 usr/src/uts/intel/io/acpica/hardware/hwacpi.c |   38 +-
 .../uts/intel/io/acpica/hardware/hwesleep.c   |   32 +-
 usr/src/uts/intel/io/acpica/hardware/hwgpe.c  |  114 +-
 usr/src/uts/intel/io/acpica/hardware/hwpci.c  |   30 +-
 usr/src/uts/intel/io/acpica/hardware/hwregs.c |   68 +-
 .../uts/intel/io/acpica/hardware/hwsleep.c    |   70 +-
 .../uts/intel/io/acpica/hardware/hwtimer.c    |   29 +-
 .../uts/intel/io/acpica/hardware/hwvalid.c    |   19 +-
 .../uts/intel/io/acpica/hardware/hwxface.c    |  201 +-
 .../uts/intel/io/acpica/hardware/hwxfsleep.c  |  139 +-
 .../uts/intel/io/acpica/namespace/nsaccess.c  |   48 +-
 .../uts/intel/io/acpica/namespace/nsalloc.c   |   35 +-
 .../intel/io/acpica/namespace/nsarguments.c   |  305 +
 .../uts/intel/io/acpica/namespace/nsconvert.c |  566 ++
 .../uts/intel/io/acpica/namespace/nsdump.c    |  248 +-
 .../uts/intel/io/acpica/namespace/nsdumpdv.c  |   10 +-
 .../uts/intel/io/acpica/namespace/nseval.c    |  277 +-
 .../uts/intel/io/acpica/namespace/nsinit.c    |  252 +-
 .../uts/intel/io/acpica/namespace/nsload.c    |   62 +-
 .../uts/intel/io/acpica/namespace/nsnames.c   |  317 +-
 .../uts/intel/io/acpica/namespace/nsobject.c  |   40 +-
 .../uts/intel/io/acpica/namespace/nsparse.c   |   69 +-
 .../uts/intel/io/acpica/namespace/nspredef.c  | 1054 +-
 .../uts/intel/io/acpica/namespace/nsprepkg.c  |  788 ++
 .../uts/intel/io/acpica/namespace/nsrepair.c  |  469 +-
 .../uts/intel/io/acpica/namespace/nsrepair2.c |  426 +-
 .../uts/intel/io/acpica/namespace/nssearch.c  |   47 +-
 .../uts/intel/io/acpica/namespace/nsutils.c   |  175 +-
 .../uts/intel/io/acpica/namespace/nswalk.c    |   47 +-
 .../uts/intel/io/acpica/namespace/nsxfeval.c  |  370 +-
 .../uts/intel/io/acpica/namespace/nsxfname.c  |  112 +-
 .../uts/intel/io/acpica/namespace/nsxfobj.c   |   17 +-
 usr/src/uts/intel/io/acpica/osl.c             |   30 +-
 usr/src/uts/intel/io/acpica/parser/psargs.c   |   78 +-
 usr/src/uts/intel/io/acpica/parser/psloop.c   |  687 +-
 usr/src/uts/intel/io/acpica/parser/psobject.c |  686 ++
 usr/src/uts/intel/io/acpica/parser/psopcode.c |  195 +-
 usr/src/uts/intel/io/acpica/parser/psopinfo.c |  284 +
 usr/src/uts/intel/io/acpica/parser/psparse.c  |   73 +-
 usr/src/uts/intel/io/acpica/parser/psscope.c  |   14 +-
 usr/src/uts/intel/io/acpica/parser/pstree.c   |   13 +-
 usr/src/uts/intel/io/acpica/parser/psutils.c  |   39 +-
 usr/src/uts/intel/io/acpica/parser/pswalk.c   |    4 +-
 usr/src/uts/intel/io/acpica/parser/psxface.c  |  172 +-
 .../uts/intel/io/acpica/resources/rsaddr.c    |   41 +-
 .../uts/intel/io/acpica/resources/rscalc.c    |  103 +-
 .../uts/intel/io/acpica/resources/rscreate.c  |  148 +-
 .../uts/intel/io/acpica/resources/rsdump.c    |  607 +-
 .../intel/io/acpica/resources/rsdumpinfo.c    |  360 +
 .../uts/intel/io/acpica/resources/rsinfo.c    |    6 +-
 usr/src/uts/intel/io/acpica/resources/rsio.c  |    6 +-
 usr/src/uts/intel/io/acpica/resources/rsirq.c |   36 +-
 .../uts/intel/io/acpica/resources/rslist.c    |   43 +-
 .../uts/intel/io/acpica/resources/rsmemory.c  |    6 +-
 .../uts/intel/io/acpica/resources/rsmisc.c    |  184 +-
 .../uts/intel/io/acpica/resources/rsserial.c  |   30 +-
 .../uts/intel/io/acpica/resources/rsutils.c   |   93 +-
 .../uts/intel/io/acpica/resources/rsxface.c   |  154 +-
 usr/src/uts/intel/io/acpica/tables/tbdata.c   |  869 ++
 usr/src/uts/intel/io/acpica/tables/tbfadt.c   |  446 +-
 usr/src/uts/intel/io/acpica/tables/tbfind.c   |   47 +-
 usr/src/uts/intel/io/acpica/tables/tbinstal.c |  876 +-
 usr/src/uts/intel/io/acpica/tables/tbprint.c  |  272 +
 usr/src/uts/intel/io/acpica/tables/tbutils.c  |  504 +-
 usr/src/uts/intel/io/acpica/tables/tbxface.c  |  261 +-
 usr/src/uts/intel/io/acpica/tables/tbxfload.c |  538 +
 usr/src/uts/intel/io/acpica/tables/tbxfroot.c |   90 +-
 .../uts/intel/io/acpica/utilities/utaddress.c |   36 +-
 .../uts/intel/io/acpica/utilities/utalloc.c   |  165 +-
 .../uts/intel/io/acpica/utilities/utascii.c   |  161 +
 .../uts/intel/io/acpica/utilities/utbuffer.c  |  362 +
 .../uts/intel/io/acpica/utilities/utcache.c   |   48 +-
 .../uts/intel/io/acpica/utilities/utclib.c    |  441 +-
 .../uts/intel/io/acpica/utilities/utcopy.c    |  176 +-
 .../uts/intel/io/acpica/utilities/utdebug.c   |  401 +-
 .../uts/intel/io/acpica/utilities/utdecode.c  |  234 +-
 .../uts/intel/io/acpica/utilities/utdelete.c  |  210 +-
 .../uts/intel/io/acpica/utilities/uterror.c   |  325 +
 .../uts/intel/io/acpica/utilities/uteval.c    |   31 +-
 .../uts/intel/io/acpica/utilities/utexcep.c   |  179 +
 .../uts/intel/io/acpica/utilities/utglobal.c  |  240 +-
 usr/src/uts/intel/io/acpica/utilities/uthex.c |  111 +
 usr/src/uts/intel/io/acpica/utilities/utids.c |  156 +-
 .../uts/intel/io/acpica/utilities/utinit.c    |  173 +-
 .../uts/intel/io/acpica/utilities/utlock.c    |    5 +-
 .../uts/intel/io/acpica/utilities/utmath.c    |   42 +-
 .../uts/intel/io/acpica/utilities/utmisc.c    | 1178 +--
 .../uts/intel/io/acpica/utilities/utmutex.c   |   63 +-
 .../uts/intel/io/acpica/utilities/utnonansi.c |  667 ++
 .../uts/intel/io/acpica/utilities/utobject.c  |   61 +-
 usr/src/uts/intel/io/acpica/utilities/utosi.c |  176 +-
 .../uts/intel/io/acpica/utilities/utownerid.c |  239 +
 .../uts/intel/io/acpica/utilities/utpredef.c  |  452 +
 .../uts/intel/io/acpica/utilities/utprint.c   |  812 ++
 .../uts/intel/io/acpica/utilities/utresrc.c   |  110 +-
 .../uts/intel/io/acpica/utilities/utstate.c   |   86 +-
 .../uts/intel/io/acpica/utilities/utstring.c  |  277 +
 .../uts/intel/io/acpica/utilities/uttrack.c   |  262 +-
 .../uts/intel/io/acpica/utilities/utuuid.c    |  103 +
 .../uts/intel/io/acpica/utilities/utxface.c   |  510 +-
 .../uts/intel/io/acpica/utilities/utxferror.c |  251 +-
 .../uts/intel/io/acpica/utilities/utxfinit.c  |  340 +
 .../uts/intel/io/acpica/utilities/utxfmutex.c |    8 +-
 usr/src/uts/intel/io/pci/pci_resource.c       |   14 +-
 usr/src/uts/intel/pci_autoconfig/Makefile     |    4 +
 usr/src/uts/intel/power/Makefile              |    4 +
 usr/src/uts/intel/sys/acpi/acapps.h           |  113 +-
 usr/src/uts/intel/sys/acpi/acbuffer.h         |  255 +
 usr/src/uts/intel/sys/acpi/acclib.h           |  167 +
 usr/src/uts/intel/sys/acpi/accommon.h         |    5 +-
 usr/src/uts/intel/sys/acpi/acconfig.h         |   47 +-
 usr/src/uts/intel/sys/acpi/acdebug.h          |  156 +-
 usr/src/uts/intel/sys/acpi/acdisasm.h         |  342 +-
 usr/src/uts/intel/sys/acpi/acdispat.h         |   27 +-
 usr/src/uts/intel/sys/acpi/acevents.h         |   69 +-
 usr/src/uts/intel/sys/acpi/acexcep.h          |  444 +-
 usr/src/uts/intel/sys/acpi/acglobal.h         |  458 +-
 usr/src/uts/intel/sys/acpi/achware.h          |   23 +-
 usr/src/uts/intel/sys/acpi/acinterp.h         |   52 +-
 usr/src/uts/intel/sys/acpi/aclocal.h          |  273 +-
 usr/src/uts/intel/sys/acpi/acmacros.h         |  285 +-
 usr/src/uts/intel/sys/acpi/acnames.h          |   36 +-
 usr/src/uts/intel/sys/acpi/acnamesp.h         |  149 +-
 usr/src/uts/intel/sys/acpi/acobject.h         |   44 +-
 usr/src/uts/intel/sys/acpi/acopcode.h         |   24 +-
 usr/src/uts/intel/sys/acpi/acoutput.h         |  221 +-
 usr/src/uts/intel/sys/acpi/acparser.h         |   55 +-
 usr/src/uts/intel/sys/acpi/acpi.h             |    3 +-
 usr/src/uts/intel/sys/acpi/acpi_pci.h         |   10 +-
 usr/src/uts/intel/sys/acpi/acpiosxf.h         |  209 +-
 usr/src/uts/intel/sys/acpi/acpixf.h           |  719 +-
 usr/src/uts/intel/sys/acpi/acpredef.h         | 1343 ++-
 usr/src/uts/intel/sys/acpi/acresrc.h          |   23 +-
 usr/src/uts/intel/sys/acpi/acrestyp.h         |   73 +-
 usr/src/uts/intel/sys/acpi/acstruct.h         |   55 +-
 usr/src/uts/intel/sys/acpi/actables.h         |  127 +-
 usr/src/uts/intel/sys/acpi/actbl.h            |  110 +-
 usr/src/uts/intel/sys/acpi/actbl1.h           |  419 +-
 usr/src/uts/intel/sys/acpi/actbl2.h           |  657 +-
 usr/src/uts/intel/sys/acpi/actbl3.h           |  433 +-
 usr/src/uts/intel/sys/acpi/actypes.h          |  315 +-
 usr/src/uts/intel/sys/acpi/acutils.h          |  536 +-
 usr/src/uts/intel/sys/acpi/acuuid.h           |   90 +
 usr/src/uts/intel/sys/acpi/amlcode.h          |   20 +-
 usr/src/uts/intel/sys/acpi/amlresrc.h         |   58 +-
 .../uts/intel/sys/acpi/platform/accygwin.h    |   15 +-
 .../uts/intel/sys/acpi/platform/acdragonfly.h |  128 +
 .../intel/sys/acpi/platform/acdragonflyex.h   |   84 +
 usr/src/uts/intel/sys/acpi/platform/acefi.h   |  208 +-
 usr/src/uts/intel/sys/acpi/platform/acefiex.h |  855 ++
 usr/src/uts/intel/sys/acpi/platform/acenv.h   |  160 +-
 usr/src/uts/intel/sys/acpi/platform/acenvex.h |   75 +
 .../uts/intel/sys/acpi/platform/acfreebsd.h   |   14 +-
 usr/src/uts/intel/sys/acpi/platform/acgcc.h   |   21 +-
 usr/src/uts/intel/sys/acpi/platform/achaiku.h |  106 +
 usr/src/uts/intel/sys/acpi/platform/acintel.h |    2 +-
 usr/src/uts/intel/sys/acpi/platform/aclinux.h |  170 +-
 .../uts/intel/sys/acpi/platform/aclinuxex.h   |  158 +
 .../uts/intel/sys/acpi/platform/acmacosx.h    |   58 +
 usr/src/uts/intel/sys/acpi/platform/acmsvc.h  |   50 +-
 .../uts/intel/sys/acpi/platform/acmsvcex.h    |   54 +
 .../uts/intel/sys/acpi/platform/acnetbsd.h    |   25 +-
 usr/src/uts/intel/sys/acpi/platform/acos2.h   |    2 +-
 usr/src/uts/intel/sys/acpi/platform/acqnx.h   |   74 +
 .../uts/intel/sys/acpi/platform/acsolaris.h   |    8 +
 usr/src/uts/intel/sys/acpi/platform/acwin.h   |    2 +-
 usr/src/uts/intel/sys/acpi/platform/acwin64.h |    3 +-
 usr/src/uts/intel/sys/acpi/platform/acwinex.h |   52 +
 297 files changed, 38831 insertions(+), 25110 deletions(-)
 create mode 100644 usr/src/uts/intel/io/acpica/ahids.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbcmds.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbdisply.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbexec.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbfileio.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbhistry.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbinput.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbmethod.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbnames.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbstats.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbutils.c
 delete mode 100644 usr/src/uts/intel/io/acpica/debugger/dbxface.c
 create mode 100644 usr/src/uts/intel/io/acpica/disassembler/dmcstyle.c
 create mode 100644 usr/src/uts/intel/io/acpica/disassembler/dmdeferred.c
 delete mode 100644 usr/src/uts/intel/io/acpica/disassembler/dmobject.c
 create mode 100644 usr/src/uts/intel/io/acpica/dispatcher/dsdebug.c
 create mode 100644 usr/src/uts/intel/io/acpica/events/evhandler.c
 create mode 100644 usr/src/uts/intel/io/acpica/executer/exconcat.c
 create mode 100644 usr/src/uts/intel/io/acpica/executer/extrace.c
 create mode 100644 usr/src/uts/intel/io/acpica/namespace/nsarguments.c
 create mode 100644 usr/src/uts/intel/io/acpica/namespace/nsconvert.c
 create mode 100644 usr/src/uts/intel/io/acpica/namespace/nsprepkg.c
 create mode 100644 usr/src/uts/intel/io/acpica/parser/psobject.c
 create mode 100644 usr/src/uts/intel/io/acpica/parser/psopinfo.c
 create mode 100644 usr/src/uts/intel/io/acpica/resources/rsdumpinfo.c
 create mode 100644 usr/src/uts/intel/io/acpica/tables/tbdata.c
 create mode 100644 usr/src/uts/intel/io/acpica/tables/tbprint.c
 create mode 100644 usr/src/uts/intel/io/acpica/tables/tbxfload.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utascii.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utbuffer.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/uterror.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utexcep.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/uthex.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utnonansi.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utownerid.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utpredef.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utprint.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utstring.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utuuid.c
 create mode 100644 usr/src/uts/intel/io/acpica/utilities/utxfinit.c
 create mode 100644 usr/src/uts/intel/sys/acpi/acbuffer.h
 create mode 100644 usr/src/uts/intel/sys/acpi/acclib.h
 create mode 100644 usr/src/uts/intel/sys/acpi/acuuid.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/acdragonfly.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/acdragonflyex.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/acefiex.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/acenvex.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/achaiku.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/aclinuxex.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/acmacosx.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/acmsvcex.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/acqnx.h
 create mode 100644 usr/src/uts/intel/sys/acpi/platform/acwinex.h

diff --git a/usr/src/cmd/mdb/i86pc/modules/apix/amd64/Makefile b/usr/src/cmd/mdb/i86pc/modules/apix/amd64/Makefile
index 2eadc490bb..0746936b9a 100644
--- a/usr/src/cmd/mdb/i86pc/modules/apix/amd64/Makefile
+++ b/usr/src/cmd/mdb/i86pc/modules/apix/amd64/Makefile
@@ -20,6 +20,7 @@
 #
 #
 # Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2016, Joyent, Inc.
 #
 
 MODULE = apix.so
@@ -40,3 +41,5 @@ CPPFLAGS += -I../../../../common
 CPPFLAGS += -I../../common
 CPPFLAGS += -I$(SRC)/uts/intel
 CPPFLAGS += -I$(SRC)/uts/i86pc
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86pc/modules/apix/ia32/Makefile b/usr/src/cmd/mdb/i86pc/modules/apix/ia32/Makefile
index 8671b51407..50f50feb8e 100644
--- a/usr/src/cmd/mdb/i86pc/modules/apix/ia32/Makefile
+++ b/usr/src/cmd/mdb/i86pc/modules/apix/ia32/Makefile
@@ -20,6 +20,7 @@
 #
 #
 # Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2016, Joyent, Inc.
 #
 
 MODULE = apix.so
@@ -39,3 +40,5 @@ CPPFLAGS += -I../../../../common
 CPPFLAGS += -I../../common
 CPPFLAGS += -I$(SRC)/uts/intel
 CPPFLAGS += -I$(SRC)/uts/i86pc
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86pc/modules/pcplusmp/amd64/Makefile b/usr/src/cmd/mdb/i86pc/modules/pcplusmp/amd64/Makefile
index ba3f361c2f..b94a4d3ca1 100644
--- a/usr/src/cmd/mdb/i86pc/modules/pcplusmp/amd64/Makefile
+++ b/usr/src/cmd/mdb/i86pc/modules/pcplusmp/amd64/Makefile
@@ -20,6 +20,7 @@
 #
 #
 # Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2016, Joyent, Inc.
 #
 
 MODULE = pcplusmp.so
@@ -40,3 +41,5 @@ CPPFLAGS += -I../../../../common
 CPPFLAGS += -I../../common
 CPPFLAGS += -I$(SRC)/uts/intel
 CPPFLAGS += -I$(SRC)/uts/i86pc
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86pc/modules/pcplusmp/ia32/Makefile b/usr/src/cmd/mdb/i86pc/modules/pcplusmp/ia32/Makefile
index c2bd1f6d91..ac2e1b4f2e 100644
--- a/usr/src/cmd/mdb/i86pc/modules/pcplusmp/ia32/Makefile
+++ b/usr/src/cmd/mdb/i86pc/modules/pcplusmp/ia32/Makefile
@@ -20,6 +20,7 @@
 #
 #
 # Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2016, Joyent, Inc.
 #
 
 MODULE = pcplusmp.so
@@ -39,3 +40,5 @@ CPPFLAGS += -I../../../../common
 CPPFLAGS += -I../../common
 CPPFLAGS += -I$(SRC)/uts/intel
 CPPFLAGS += -I$(SRC)/uts/i86pc
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86pc/modules/unix/amd64/Makefile b/usr/src/cmd/mdb/i86pc/modules/unix/amd64/Makefile
index 26afa1c288..f80ce95abd 100644
--- a/usr/src/cmd/mdb/i86pc/modules/unix/amd64/Makefile
+++ b/usr/src/cmd/mdb/i86pc/modules/unix/amd64/Makefile
@@ -22,6 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
 
 MODULE = unix.so
 MDBTGT = kvm
@@ -44,3 +45,5 @@ CERRWARN += -_gcc=-Wno-char-subscripts
 CERRWARN += -_gcc=-Wno-parentheses
 CERRWARN += -_gcc=-Wno-unused-label
 CERRWARN += -_gcc=-Wno-uninitialized
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86pc/modules/unix/ia32/Makefile b/usr/src/cmd/mdb/i86pc/modules/unix/ia32/Makefile
index 2c76a010bd..10adfd03cd 100644
--- a/usr/src/cmd/mdb/i86pc/modules/unix/ia32/Makefile
+++ b/usr/src/cmd/mdb/i86pc/modules/unix/ia32/Makefile
@@ -22,6 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
 
 MODULE = unix.so
 MDBTGT = kvm
@@ -43,3 +44,5 @@ CERRWARN += -_gcc=-Wno-char-subscripts
 CERRWARN += -_gcc=-Wno-parentheses
 CERRWARN += -_gcc=-Wno-unused-label
 CERRWARN += -_gcc=-Wno-uninitialized
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86pc/modules/uppc/amd64/Makefile b/usr/src/cmd/mdb/i86pc/modules/uppc/amd64/Makefile
index 501eecf8c5..59a29b5d49 100644
--- a/usr/src/cmd/mdb/i86pc/modules/uppc/amd64/Makefile
+++ b/usr/src/cmd/mdb/i86pc/modules/uppc/amd64/Makefile
@@ -22,7 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-#ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 
 MODULE = uppc.so
 MDBTGT = kvm
@@ -42,3 +42,5 @@ CPPFLAGS += -I../../common
 CPPFLAGS += -I../../../../common
 CPPFLAGS += -I$(SRC)/uts/intel
 CPPFLAGS += -I$(SRC)/uts/i86pc
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86pc/modules/uppc/ia32/Makefile b/usr/src/cmd/mdb/i86pc/modules/uppc/ia32/Makefile
index f10ce9e177..74586333d1 100644
--- a/usr/src/cmd/mdb/i86pc/modules/uppc/ia32/Makefile
+++ b/usr/src/cmd/mdb/i86pc/modules/uppc/ia32/Makefile
@@ -22,7 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-#ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 
 MODULE = uppc.so
 MDBTGT = kvm
@@ -41,3 +41,5 @@ CPPFLAGS += -I../../common
 CPPFLAGS += -I../../../../common
 CPPFLAGS += -I$(SRC)/uts/intel
 CPPFLAGS += -I$(SRC)/uts/i86pc
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86xpv/modules/unix/amd64/Makefile b/usr/src/cmd/mdb/i86xpv/modules/unix/amd64/Makefile
index 95922ff772..48e79ed8dc 100644
--- a/usr/src/cmd/mdb/i86xpv/modules/unix/amd64/Makefile
+++ b/usr/src/cmd/mdb/i86xpv/modules/unix/amd64/Makefile
@@ -22,6 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
 
 MODULE = unix.so
 MDBTGT = kvm
@@ -48,3 +49,5 @@ CERRWARN += -_gcc=-Wno-char-subscripts
 CERRWARN += -_gcc=-Wno-parentheses
 CERRWARN += -_gcc=-Wno-unused-label
 CERRWARN += -_gcc=-Wno-uninitialized
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86xpv/modules/unix/ia32/Makefile b/usr/src/cmd/mdb/i86xpv/modules/unix/ia32/Makefile
index 975ae705dc..53764e7633 100644
--- a/usr/src/cmd/mdb/i86xpv/modules/unix/ia32/Makefile
+++ b/usr/src/cmd/mdb/i86xpv/modules/unix/ia32/Makefile
@@ -22,6 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
 
 MODULE = unix.so
 MDBTGT = kvm
@@ -47,3 +48,5 @@ CERRWARN += -_gcc=-Wno-char-subscripts
 CERRWARN += -_gcc=-Wno-parentheses
 CERRWARN += -_gcc=-Wno-unused-label
 CERRWARN += -_gcc=-Wno-uninitialized
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86xpv/modules/xpv_psm/amd64/Makefile b/usr/src/cmd/mdb/i86xpv/modules/xpv_psm/amd64/Makefile
index 37ad26071b..c052cddb20 100644
--- a/usr/src/cmd/mdb/i86xpv/modules/xpv_psm/amd64/Makefile
+++ b/usr/src/cmd/mdb/i86xpv/modules/xpv_psm/amd64/Makefile
@@ -22,7 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-#ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 
 MODULE = xpv_psm.so
 MDBTGT = kvm
@@ -44,3 +44,5 @@ CPPFLAGS += -I$(SRC)/uts/common
 CPPFLAGS += -I$(SRC)/uts/i86xpv
 CPPFLAGS += -I$(SRC)/uts/i86pc
 CPPFLAGS += -I$(SRC)/uts/intel
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86xpv/modules/xpv_psm/ia32/Makefile b/usr/src/cmd/mdb/i86xpv/modules/xpv_psm/ia32/Makefile
index 8aa3060c26..4a8fa4861e 100644
--- a/usr/src/cmd/mdb/i86xpv/modules/xpv_psm/ia32/Makefile
+++ b/usr/src/cmd/mdb/i86xpv/modules/xpv_psm/ia32/Makefile
@@ -22,7 +22,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-#ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 
 MODULE = xpv_psm.so
 MDBTGT = kvm
@@ -43,3 +43,5 @@ CPPFLAGS += -I$(SRC)/uts/common
 CPPFLAGS += -I$(SRC)/uts/i86xpv
 CPPFLAGS += -I$(SRC)/uts/i86pc
 CPPFLAGS += -I$(SRC)/uts/intel
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/amd64/Makefile b/usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/amd64/Makefile
index 3e2bc789c1..ac563c6b4b 100644
--- a/usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/amd64/Makefile
+++ b/usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/amd64/Makefile
@@ -22,7 +22,7 @@
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-#ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 
 MODULE = xpv_uppc.so
 MDBTGT = kvm
@@ -44,3 +44,5 @@ CPPFLAGS += -I$(SRC)/uts/common
 CPPFLAGS += -I$(SRC)/uts/i86xpv
 CPPFLAGS += -I$(SRC)/uts/i86pc
 CPPFLAGS += -I$(SRC)/uts/intel
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/ia32/Makefile b/usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/ia32/Makefile
index f91d8ee72c..95348006c0 100644
--- a/usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/ia32/Makefile
+++ b/usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/ia32/Makefile
@@ -22,7 +22,7 @@
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-#ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 
 MODULE = xpv_uppc.so
 MDBTGT = kvm
@@ -43,3 +43,5 @@ CPPFLAGS += -I$(SRC)/uts/common
 CPPFLAGS += -I$(SRC)/uts/i86xpv
 CPPFLAGS += -I$(SRC)/uts/i86pc
 CPPFLAGS += -I$(SRC)/uts/intel
+
+CERRWARN += -_gcc=-Wno-unused-function
diff --git a/usr/src/uts/i86pc/acpi_drv/Makefile b/usr/src/uts/i86pc/acpi_drv/Makefile
index b1aafef9b2..ce5eb13317 100644
--- a/usr/src/uts/i86pc/acpi_drv/Makefile
+++ b/usr/src/uts/i86pc/acpi_drv/Makefile
@@ -23,7 +23,7 @@
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 #
 
 #	This makefile drives the production of the acpi_drv 
@@ -63,6 +63,8 @@ $(NOT_RELEASE_BUILD)DEBUG_DEFS	+= $(DEBUG_FLGS)
 
 CPPFLAGS	+= -DSUNDDI
 
+CERRWARN	+= -_gcc=-Wno-unused-function
+
 LDFLAGS		+= -dy -N misc/acpica
 
 #
diff --git a/usr/src/uts/i86pc/acpidev/Makefile b/usr/src/uts/i86pc/acpidev/Makefile
index ab9cbde6ee..b59e9501b1 100644
--- a/usr/src/uts/i86pc/acpidev/Makefile
+++ b/usr/src/uts/i86pc/acpidev/Makefile
@@ -24,6 +24,8 @@
 # Copyright (c) 2009, Intel Corporation.
 # All rights reserved.
 #
+# Copyright 2016, Joyent, Inc.
+#
 #	This makefile drives the production of the ACPI device configuration
 #	kernel module.
 #
@@ -61,6 +63,7 @@ INSTALL_TARGET	= $(BINARY) $(ROOTMODULE)
 LDFLAGS		+= -dy -N misc/acpica
 
 CERRWARN	+= -_gcc=-Wno-uninitialized
+CERRWARN	+= -_gcc=-Wno-unused-function
 CERRWARN	+= -_gcc=-Wno-type-limits
 
 #
diff --git a/usr/src/uts/i86pc/acpinex/Makefile b/usr/src/uts/i86pc/acpinex/Makefile
index 0b51c74a45..5269dc4115 100644
--- a/usr/src/uts/i86pc/acpinex/Makefile
+++ b/usr/src/uts/i86pc/acpinex/Makefile
@@ -24,6 +24,8 @@
 # Copyright (c) 2009, Intel Corporation.
 # All rights reserved.
 #
+# Copyright 2016, Joyent, Inc.
+#
 #	This makefile drives the production of the ACPI virtual nexus 
 #	kernel module.
 #
@@ -60,6 +62,8 @@ INSTALL_TARGET	= $(BINARY) $(ROOTMODULE)
 #
 LDFLAGS		+= -dy -N misc/acpica -N misc/acpidev
 
+CERRWARN	+= -_gcc=-Wno-unused-function
+
 #
 #	Default build targets.
 #
diff --git a/usr/src/uts/i86pc/acpippm/Makefile b/usr/src/uts/i86pc/acpippm/Makefile
index 65a42fdfa8..0f08acc855 100644
--- a/usr/src/uts/i86pc/acpippm/Makefile
+++ b/usr/src/uts/i86pc/acpippm/Makefile
@@ -24,6 +24,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 # Copyright (c) 2011 Bayard G. Bell. All rights reserved.
+# Copyright 2016 Joyent, Inc.
 #
 #	This makefile drives the production of the power managment
 #	module for the ACPI subsystem
@@ -58,6 +59,9 @@ ALL_TARGET	= $(BINARY) $(SRC_CONFILE)
 LINT_TARGET	= $(MODULE).lint
 INSTALL_TARGET	= $(BINARY) $(ROOTMODULE) $(ROOT_CONFFILE)
 
+$(OBJS_DIR)/acpippm.o :=	CERRWARN	+= -_gcc=-Wno-unused-function
+$(OBJS_DIR)/acpisleep.o :=	CERRWARN	+= -_gcc=-Wno-unused-function
+
 #
 # lint pass one enforcement
 #
diff --git a/usr/src/uts/i86pc/amd_iommu/Makefile b/usr/src/uts/i86pc/amd_iommu/Makefile
index a90023cde9..b676a83fc2 100644
--- a/usr/src/uts/i86pc/amd_iommu/Makefile
+++ b/usr/src/uts/i86pc/amd_iommu/Makefile
@@ -21,6 +21,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 #	This Makefile drives production of the amd_iommu driver kernel module.
 #
 #
@@ -58,6 +60,7 @@ LDFLAGS         += -dy -Nmisc/iommulib -Nmisc/acpica
 
 CERRWARN	+= -_gcc=-Wno-uninitialized
 CERRWARN	+= -_gcc=-Wno-parentheses
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86pc/amd_opteron/Makefile b/usr/src/uts/i86pc/amd_opteron/Makefile
index c074a57d61..911d5ebd71 100644
--- a/usr/src/uts/i86pc/amd_opteron/Makefile
+++ b/usr/src/uts/i86pc/amd_opteron/Makefile
@@ -20,7 +20,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 #
 
 #
@@ -63,6 +63,7 @@ INSTALL_TARGET  = $(BINARY) $(ROOTMODULE)
 #
 #	Overrides and additions
 #
+$(OBJS_DIR)/ao_mca.o :=	CERRWARN	+= -_gcc=-Wno-unused-function
 CLEANFILES	+= $(AO_MCA_DISP_C)
 CPPFLAGS	+= -I$(SRCDIR) -I$(OBJS_DIR)
 ASFLAGS		+= -I$(SRCDIR) -I$(OBJS_DIR)
diff --git a/usr/src/uts/i86pc/apix/Makefile b/usr/src/uts/i86pc/apix/Makefile
index e65d4cf1ee..18100b7ced 100644
--- a/usr/src/uts/i86pc/apix/Makefile
+++ b/usr/src/uts/i86pc/apix/Makefile
@@ -22,6 +22,7 @@
 # uts/i86pc/apix/Makefile
 #
 # Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2016, Joyent, Inc.
 #
 #	This makefile drives the production of the pcplusmp "mach"
 #	kernel module.
@@ -63,6 +64,7 @@ $(NOT_RELEASE_BUILD)DEBUG_DEFS	+= $(DEBUG_FLGS)
 LDFLAGS		+= -dy -N misc/acpica
 
 CERRWARN	+= -_gcc=-Wno-uninitialized
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86pc/cpr/Makefile b/usr/src/uts/i86pc/cpr/Makefile
index c8c403adac..a1dd7e68ee 100644
--- a/usr/src/uts/i86pc/cpr/Makefile
+++ b/usr/src/uts/i86pc/cpr/Makefile
@@ -23,6 +23,7 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 # Copyright (c) 2011 Bayard G. Bell. All rights reserved.
+# Copyright 2016, Joyent, Inc.
 #
 #	This makefile drives the production of the cpr misc kernel module.
 #
@@ -76,6 +77,7 @@ CERRWARN	+= -_gcc=-Wno-unused-variable
 CERRWARN	+= -_gcc=-Wno-unused-label
 CERRWARN	+= -_gcc=-Wno-uninitialized
 CERRWARN	+= -_gcc=-Wno-parentheses
+$(OBJS_DIR)/cpr_impl.o := 	CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86pc/cpudrv/Makefile b/usr/src/uts/i86pc/cpudrv/Makefile
index 8a59334d72..61a77839ab 100644
--- a/usr/src/uts/i86pc/cpudrv/Makefile
+++ b/usr/src/uts/i86pc/cpudrv/Makefile
@@ -20,6 +20,7 @@
 #
 #
 # Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2016, Joyent, Inc.
 #
 #	This makefile drives the production of the cpu driver
 #	kernel module.
@@ -57,6 +58,9 @@ CFLAGS += $(CCVERBOSE)
 
 CERRWARN	+= -_gcc=-Wno-uninitialized
 CERRWARN	+= -_gcc=-Wno-parentheses
+CERRWARN	+= -_gcc=-Wno-unused-function
+
+EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
 
 #
 # Link to acpica for ACPI services
diff --git a/usr/src/uts/i86pc/drmach_acpi/Makefile b/usr/src/uts/i86pc/drmach_acpi/Makefile
index c803d07f77..23e40f018e 100644
--- a/usr/src/uts/i86pc/drmach_acpi/Makefile
+++ b/usr/src/uts/i86pc/drmach_acpi/Makefile
@@ -25,6 +25,8 @@
 # Copyright (c) 2010, Intel Corporation.
 # All rights reserved.
 #
+# Copyright 2016 Joyent, Inc.
+#
 #	This makefile drives the production of the drmach_acpi loadable module.
 #
 #	i86pc architecture dependent
@@ -61,6 +63,8 @@ INSTALL_TARGET	= $(BINARY) $(ROOTMODULE)
 DEF_BUILDS	= $(DEF_BUILDS64)
 ALL_BUILDS	= $(ALL_BUILDS64)
 
+$(OBJS_DIR)/drmach_acpi.o :=	CERRWARN	+= -_gcc=-Wno-unused-function
+
 #
 # lint pass one enforcement
 #
diff --git a/usr/src/uts/i86pc/io/acpi/acpidev/acpidev_resource.c b/usr/src/uts/i86pc/io/acpi/acpidev/acpidev_resource.c
index e9664c7614..ef05a80280 100644
--- a/usr/src/uts/i86pc/io/acpi/acpidev/acpidev_resource.c
+++ b/usr/src/uts/i86pc/io/acpi/acpidev/acpidev_resource.c
@@ -21,6 +21,8 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ *
+ * Copyright 2016, Joyent, Inc.
  */
 /*
  * Copyright (c) 2009-2010, Intel Corporation.
@@ -431,7 +433,7 @@ acpidev_resource_address64(acpidev_resource_handle_t rhdl,
 	uint_t high;
 
 	ASSERT(addrp != NULL && rhdl != NULL);
-	if (addrp->AddressLength == 0) {
+	if (addrp->Address.AddressLength == 0) {
 		return (AE_OK);
 	}
 
@@ -471,10 +473,11 @@ acpidev_resource_address64(acpidev_resource_handle_t rhdl,
 			acpidev_regspec_t reg;
 
 			reg.phys_hi = high;
-			reg.phys_mid = addrp->Minimum >> 32;
-			reg.phys_low = addrp->Minimum & 0xFFFFFFFF;
-			reg.size_hi = addrp->AddressLength >> 32;
-			reg.size_low = addrp->AddressLength & 0xFFFFFFFF;
+			reg.phys_mid = addrp->Address.Minimum >> 32;
+			reg.phys_low = addrp->Address.Minimum & 0xFFFFFFFF;
+			reg.size_hi = addrp->Address.AddressLength >> 32;
+			reg.size_low = addrp->Address.AddressLength &
+			    0xFFFFFFFF;
 			rc = acpidev_resource_insert_reg(rhdl, &reg);
 			if (ACPI_FAILURE(rc)) {
 				ACPIDEV_DEBUG(CE_WARN, "!acpidev: failed to "
@@ -487,19 +490,21 @@ acpidev_resource_address64(acpidev_resource_handle_t rhdl,
 			acpidev_ranges_t range;
 
 			range.child_hi = high;
-			range.child_mid = addrp->Minimum >> 32;
-			range.child_low = addrp->Minimum & 0xFFFFFFFF;
+			range.child_mid = addrp->Address.Minimum >> 32;
+			range.child_low = addrp->Address.Minimum & 0xFFFFFFFF;
 			/* It's IO on parent side if Translation is true. */
 			if (addrp->Info.Mem.Translation) {
 				range.parent_hi = ACPIDEV_REG_TYPE_IO;
 			} else {
 				range.parent_hi = high;
 			}
-			paddr = addrp->Minimum + addrp->TranslationOffset;
+			paddr = addrp->Address.Minimum +
+			    addrp->Address.TranslationOffset;
 			range.parent_mid = paddr >> 32;
 			range.parent_low = paddr & 0xFFFFFFFF;
-			range.size_hi = addrp->AddressLength >> 32;
-			range.size_low = addrp->AddressLength & 0xFFFFFFFF;
+			range.size_hi = addrp->Address.AddressLength >> 32;
+			range.size_low = addrp->Address.AddressLength &
+			    0xFFFFFFFF;
 			rc = acpidev_resource_insert_range(rhdl, &range);
 			if (ACPI_FAILURE(rc)) {
 				ACPIDEV_DEBUG(CE_WARN, "!acpidev: failed to "
@@ -539,10 +544,11 @@ acpidev_resource_address64(acpidev_resource_handle_t rhdl,
 			acpidev_regspec_t reg;
 
 			reg.phys_hi = high;
-			reg.phys_mid = addrp->Minimum >> 32;
-			reg.phys_low = addrp->Minimum & 0xFFFFFFFF;
-			reg.size_hi = addrp->AddressLength >> 32;
-			reg.size_low = addrp->AddressLength & 0xFFFFFFFF;
+			reg.phys_mid = addrp->Address.Minimum >> 32;
+			reg.phys_low = addrp->Address.Minimum & 0xFFFFFFFF;
+			reg.size_hi = addrp->Address.AddressLength >> 32;
+			reg.size_low = addrp->Address.AddressLength &
+			    0xFFFFFFFF;
 			rc = acpidev_resource_insert_reg(rhdl, &reg);
 			if (ACPI_FAILURE(rc)) {
 				ACPIDEV_DEBUG(CE_WARN, "!acpidev: failed to "
@@ -555,19 +561,21 @@ acpidev_resource_address64(acpidev_resource_handle_t rhdl,
 			acpidev_ranges_t range;
 
 			range.child_hi = high;
-			range.child_mid = addrp->Minimum >> 32;
-			range.child_low = addrp->Minimum & 0xFFFFFFFF;
+			range.child_mid = addrp->Address.Minimum >> 32;
+			range.child_low = addrp->Address.Minimum & 0xFFFFFFFF;
 			/* It's Memory on parent side if Translation is true. */
 			if (addrp->Info.Io.Translation) {
 				range.parent_hi = ACPIDEV_REG_TYPE_MEMORY;
 			} else {
 				range.parent_hi = high;
 			}
-			paddr = addrp->Minimum + addrp->TranslationOffset;
+			paddr = addrp->Address.Minimum +
+			    addrp->Address.TranslationOffset;
 			range.parent_mid = paddr >> 32;
 			range.parent_low = paddr & 0xFFFFFFFF;
-			range.size_hi = addrp->AddressLength >> 32;
-			range.size_low = addrp->AddressLength & 0xFFFFFFFF;
+			range.size_hi = addrp->Address.AddressLength >> 32;
+			range.size_low = addrp->Address.AddressLength &
+			    0xFFFFFFFF;
 			rc = acpidev_resource_insert_range(rhdl, &range);
 			if (ACPI_FAILURE(rc)) {
 				ACPIDEV_DEBUG(CE_WARN, "!acpidev: failed to "
@@ -583,14 +591,15 @@ acpidev_resource_address64(acpidev_resource_handle_t rhdl,
 			uint64_t end;
 			acpidev_bus_range_t bus;
 
-			end = addrp->Minimum + addrp->AddressLength;
-			if (end < addrp->Minimum || end > UINT_MAX) {
+			end = addrp->Address.Minimum +
+			    addrp->Address.AddressLength;
+			if (end < addrp->Address.Minimum || end > UINT_MAX) {
 				ACPIDEV_DEBUG(CE_WARN, "!acpidev: bus range "
 				    "in ADDRESS64 is invalid.");
 				rc = AE_ERROR;
 				break;
 			}
-			bus.bus_start = addrp->Minimum & 0xFFFFFFFF;
+			bus.bus_start = addrp->Address.Minimum & 0xFFFFFFFF;
 			bus.bus_end = end & 0xFFFFFFFF;
 			ASSERT(bus.bus_start <= bus.bus_end);
 			rc = acpidev_resource_insert_bus(rhdl, &bus);
@@ -696,12 +705,16 @@ acpidev_resource_walk_producer(ACPI_RESOURCE *rscp, void *ctxp)
 		}
 
 		*(ACPI_RESOURCE_ADDRESS *)&addr64 = rscp->Data.Address;
-		addr64.Granularity = rscp->Data.ExtAddress64.Granularity;
-		addr64.Minimum = rscp->Data.ExtAddress64.Minimum;
-		addr64.Maximum = rscp->Data.ExtAddress64.Maximum;
-		addr64.TranslationOffset =
-		    rscp->Data.ExtAddress64.TranslationOffset;
-		addr64.AddressLength = rscp->Data.ExtAddress64.AddressLength;
+		addr64.Address.Granularity =
+		    rscp->Data.ExtAddress64.Address.Granularity;
+		addr64.Address.Minimum =
+		    rscp->Data.ExtAddress64.Address.Minimum;
+		addr64.Address.Maximum =
+		    rscp->Data.ExtAddress64.Address.Maximum;
+		addr64.Address.TranslationOffset =
+		    rscp->Data.ExtAddress64.Address.TranslationOffset;
+		addr64.Address.AddressLength =
+		    rscp->Data.ExtAddress64.Address.AddressLength;
 		if (ACPI_FAILURE(rc = acpidev_resource_address64(rhdl,
 		    &addr64))) {
 			ACPIDEV_DEBUG(CE_WARN,
@@ -911,12 +924,16 @@ acpidev_resource_walk_consumer(ACPI_RESOURCE *rscp, void *ctxp)
 		}
 
 		*(ACPI_RESOURCE_ADDRESS *)&addr64 = rscp->Data.Address;
-		addr64.Granularity = rscp->Data.ExtAddress64.Granularity;
-		addr64.Minimum = rscp->Data.ExtAddress64.Minimum;
-		addr64.Maximum = rscp->Data.ExtAddress64.Maximum;
-		addr64.TranslationOffset =
-		    rscp->Data.ExtAddress64.TranslationOffset;
-		addr64.AddressLength = rscp->Data.ExtAddress64.AddressLength;
+		addr64.Address.Granularity =
+		    rscp->Data.ExtAddress64.Address.Granularity;
+		addr64.Address.Minimum =
+		    rscp->Data.ExtAddress64.Address.Minimum;
+		addr64.Address.Maximum =
+		    rscp->Data.ExtAddress64.Address.Maximum;
+		addr64.Address.TranslationOffset =
+		    rscp->Data.ExtAddress64.Address.TranslationOffset;
+		addr64.Address.AddressLength =
+		    rscp->Data.ExtAddress64.Address.AddressLength;
 		if (ACPI_FAILURE(rc = acpidev_resource_address64(rhdl,
 		    &addr64))) {
 			ACPIDEV_DEBUG(CE_WARN,
diff --git a/usr/src/uts/i86pc/io/ppm/acpisleep.c b/usr/src/uts/i86pc/io/ppm/acpisleep.c
index 6b94e50909..f2eb080f48 100644
--- a/usr/src/uts/i86pc/io/ppm/acpisleep.c
+++ b/usr/src/uts/i86pc/io/ppm/acpisleep.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2012 Joyent, Inc.  All rights reserved.
+ * Copyright 2016, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -57,19 +57,6 @@
 
 int acpi_rtc_wake = 0x0;		/* wake in N seconds */
 
-/*
- * Execute optional ACPI methods for suspend/resume.
- * The value can be ACPI_EXECUTE_GTS and/or ACPI_EXECUTE_BFS.
- * Global so it can be set in /etc/system.
- * From usr/src/uts/intel/io/acpica/changes.txt:
- *    It has been seen on some systems where the execution of these
- *    methods causes errors and also prevents the machine from entering S5.
- *    It is therefore suggested that host operating systems do not execute
- *    these methods by default. In the future, perhaps these methods can be
- *    optionally executed based on the age of the system...
- */
-int acpi_sleep_flags = ACPI_NO_OPTIONAL_METHODS;
-
 #if 0	/* debug */
 static uint8_t	branchbuf[64 * 1024];	/* for the HDT branch trace stuff */
 #endif	/* debug */
@@ -100,7 +87,7 @@ acpi_enter_sleepstate(s3a_t *s3ap)
 
 	PT(PT_SWV);
 	/* Set waking vector */
-	if (AcpiSetFirmwareWakingVector(wakephys) != AE_OK) {
+	if (AcpiSetFirmwareWakingVector(wakephys, NULL) != AE_OK) {
 		PT(PT_SWV_FAIL);
 		PMD(PMD_SX, ("Can't SetFirmwareWakingVector(%lx)\n",
 		    (long)wakephys))
@@ -156,9 +143,8 @@ acpi_enter_sleepstate(s3a_t *s3ap)
 	 * Tell the hardware to sleep.
 	 */
 	PT(PT_SXE);
-	PMD(PMD_SX, ("Calling AcpiEnterSleepState(%d, %d) ...\n", Sx,
-	    acpi_sleep_flags))
-	if (AcpiEnterSleepState(Sx, acpi_sleep_flags) != AE_OK) {
+	PMD(PMD_SX, ("Calling AcpiEnterSleepState(%d) ...\n", Sx))
+	if (AcpiEnterSleepState(Sx) != AE_OK) {
 		PT(PT_SXE_FAIL);
 		PMD(PMD_SX, ("... failed!\n"))
 	}
@@ -178,7 +164,7 @@ acpi_exit_sleepstate(s3a_t *s3ap)
 	PMD(PMD_SX, ("!We woke up!\n"))
 
 	PT(PT_LSS);
-	if (AcpiLeaveSleepStatePrep(Sx, acpi_sleep_flags) != AE_OK) {
+	if (AcpiLeaveSleepStatePrep(Sx) != AE_OK) {
 		PT(PT_LSS_FAIL);
 		PMD(PMD_SX, ("Problem with LeaveSleepState!\n"))
 	}
diff --git a/usr/src/uts/i86pc/io/psm/psm_common.c b/usr/src/uts/i86pc/io/psm/psm_common.c
index 9c17d85228..623c6e5617 100644
--- a/usr/src/uts/i86pc/io/psm/psm_common.c
+++ b/usr/src/uts/i86pc/io/psm/psm_common.c
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2012, Joyent, Inc. All rights reserved.
+ * Copyright 2016, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -167,7 +167,7 @@ acpi_get_gsiv(dev_info_t *dip, ACPI_HANDLE pciobj, int devno, int ipin,
  */
 static int
 acpi_eval_lnk(dev_info_t *dip, char *lnkname, int *pci_irqp,
-iflag_t *intr_flagp, acpi_psm_lnk_t *acpipsmlnkp)
+    iflag_t *intr_flagp, acpi_psm_lnk_t *acpipsmlnkp)
 {
 	ACPI_HANDLE	tmpobj;
 	ACPI_HANDLE	lnkobj;
@@ -980,7 +980,7 @@ acpi_poweroff(void)
 		return (1);
 	}
 	ACPI_DISABLE_IRQS();
-	status = AcpiEnterSleepState(5, ACPI_NO_OPTIONAL_METHODS);
+	status = AcpiEnterSleepState(5);
 	ACPI_ENABLE_IRQS();
 
 	/* we should be off; if we get here it's an error */
diff --git a/usr/src/uts/i86pc/isa/Makefile b/usr/src/uts/i86pc/isa/Makefile
index 73e7e3c617..9cfd72f370 100644
--- a/usr/src/uts/i86pc/isa/Makefile
+++ b/usr/src/uts/i86pc/isa/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 #	This makefile drives the production of the ISA nexus driver
 #
 #	i86pc implementation architecture dependent
@@ -54,6 +56,8 @@ ALL_TARGET	= $(BINARY)
 LINT_TARGET	= $(MODULE).lint
 INSTALL_TARGET	= $(BINARY) $(ROOTMODULE)
 
+$(OBJS_DIR)/isa.o :=	CERRWARN	+= -_gcc=-Wno-unused-function
+
 #
 # lint pass one enforcement
 #
diff --git a/usr/src/uts/i86pc/npe/Makefile b/usr/src/uts/i86pc/npe/Makefile
index 93d7c4a2bc..c431ce7d75 100644
--- a/usr/src/uts/i86pc/npe/Makefile
+++ b/usr/src/uts/i86pc/npe/Makefile
@@ -24,6 +24,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 #	This makefile drives the production of the PCI-E nexus driver
 #
 #	i86pc implementation architecture dependent
@@ -80,6 +82,7 @@ LINTTAGS	+= -erroff=E_ASSIGN_NARROW_CONV
 
 CERRWARN	+= -_gcc=-Wno-uninitialized
 CERRWARN	+= -_gcc=-Wno-parentheses
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86pc/pci-ide/Makefile b/usr/src/uts/i86pc/pci-ide/Makefile
index 2a50977aac..399ccc95e5 100644
--- a/usr/src/uts/i86pc/pci-ide/Makefile
+++ b/usr/src/uts/i86pc/pci-ide/Makefile
@@ -25,6 +25,8 @@
 # Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 
 #
 #	This makefile drives the production of the pci-ide "drv"
@@ -68,6 +70,7 @@ DEBUG_DEFS	+= $(DEBUG_FLGS)
 INC_PATH	+= -I$(UTSBASE)/common/io/pci-ide
 
 CERRWARN	+= -_gcc=-Wno-switch
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86pc/pci/Makefile b/usr/src/uts/i86pc/pci/Makefile
index 5a4e6e891a..f2f9952670 100644
--- a/usr/src/uts/i86pc/pci/Makefile
+++ b/usr/src/uts/i86pc/pci/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 
 #
 #	This makefile drives the production of the PCI nexus driver
@@ -77,6 +79,7 @@ LINTTAGS	+= -erroff=E_ASSIGN_NARROW_CONV
 
 CERRWARN	+= -_gcc=-Wno-parentheses
 CERRWARN	+= -_gcc=-Wno-uninitialized
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86pc/pcplusmp/Makefile b/usr/src/uts/i86pc/pcplusmp/Makefile
index 6590ef9f28..92c455017d 100644
--- a/usr/src/uts/i86pc/pcplusmp/Makefile
+++ b/usr/src/uts/i86pc/pcplusmp/Makefile
@@ -24,6 +24,8 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016, Joyent, Inc.
+#
 
 #
 #	This makefile drives the production of the pcplusmp "mach"
@@ -65,6 +67,8 @@ $(NOT_RELEASE_BUILD)DEBUG_DEFS	+= $(DEBUG_FLGS)
 #
 LDFLAGS		+= -dy -N misc/acpica
 
+CERRWARN	+= -_gcc=-Wno-unused-function
+
 #
 # For now, disable these lint checks; maintainers should endeavor
 # to investigate and remove these for maximum lint coverage.
diff --git a/usr/src/uts/i86pc/tzmon/Makefile b/usr/src/uts/i86pc/tzmon/Makefile
index 4410c18c88..b8f15a547b 100644
--- a/usr/src/uts/i86pc/tzmon/Makefile
+++ b/usr/src/uts/i86pc/tzmon/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 
 #	This makefile drives the production of the tzmon
 #	ThermalZone Monitor driver kernel module.
@@ -60,6 +62,7 @@ DEBUG_FLGS      =
 $(NOT_RELEASE_BUILD)DEBUG_DEFS	+= $(DEBUG_FLGS)
 
 CPPFLAGS	+= -DSUNDDI
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 LDFLAGS		+= -dy -N misc/acpica
 
diff --git a/usr/src/uts/i86pc/unix/Makefile b/usr/src/uts/i86pc/unix/Makefile
index 27389eea17..2d024c5fb9 100644
--- a/usr/src/uts/i86pc/unix/Makefile
+++ b/usr/src/uts/i86pc/unix/Makefile
@@ -22,6 +22,7 @@
 #
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
+# Copyright 2016 Joyent, Inc.
 #
 #	This makefile drives the production of unix (and unix.o).
 #
@@ -125,6 +126,17 @@ CLEANLINTFILES	+= $(LINT_LIB) $(DBOOT_LINT_LIB) $(DBOOT_LINTS)
 $(OBJS_DIR)/instr_size.o :=	EXTRA_OPTIONS	= -I$(SRC)/common/dis/i386
 $(OBJS_DIR)/instr_size.ln :=	EXTRA_OPTIONS	= -I$(SRC)/common/dis/i386
 
+# Additional definition for files including ACPI headers
+$(OBJS_DIR)/cpu_acpi.o :=	EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+$(OBJS_DIR)/cpu_idle.o :=	EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+$(OBJS_DIR)/cpupm_amd.o :=	EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+$(OBJS_DIR)/cpupm_intel.o :=	EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+$(OBJS_DIR)/cpupm_mach.o :=	EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+$(OBJS_DIR)/cpupm_throttle.o :=	EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+$(OBJS_DIR)/pwrnow.o :=		EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+$(OBJS_DIR)/speedstep.o :=	EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+$(OBJS_DIR)/turbo.o :=		EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+
 CFLAGS += -DDIS_MEM
 
 #
diff --git a/usr/src/uts/i86pc/uppc/Makefile b/usr/src/uts/i86pc/uppc/Makefile
index cd34be9e4f..5e3dc71b4c 100644
--- a/usr/src/uts/i86pc/uppc/Makefile
+++ b/usr/src/uts/i86pc/uppc/Makefile
@@ -23,7 +23,7 @@
 # Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-#ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 #
 #	This makefile drives the production of the uppc mach
 #	kernel module.
@@ -59,6 +59,7 @@ INSTALL_TARGET	= $(BINARY) $(ROOTMODULE)
 #
 #	Overrides.
 #
+CERRWARN	+= -_gcc=-Wno-unused-function
 DEBUG_FLGS	=
 DEBUG_DEFS	+= $(DEBUG_FLGS)
 
diff --git a/usr/src/uts/i86xpv/amd_opteron/Makefile b/usr/src/uts/i86xpv/amd_opteron/Makefile
index 23e03c33e3..49f2519a8b 100644
--- a/usr/src/uts/i86xpv/amd_opteron/Makefile
+++ b/usr/src/uts/i86xpv/amd_opteron/Makefile
@@ -21,6 +21,7 @@
 # Use is subject to license terms.
 #
 # Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2016 Joyent, Inc.
 #
 
 #
@@ -64,6 +65,7 @@ INSTALL_TARGET  = $(BINARY) $(ROOTMODULE)
 #
 #	Overrides and additions
 #
+$(OBJS_DIR)/ao_mca.o :=	CERRWARN	+= -_gcc=-Wno-unused-function
 CLEANFILES	+= $(AO_MCA_DISP_C)
 CPPFLAGS	+= -I$(SRCDIR) -I$(OBJS_DIR)
 ASFLAGS		+= -I$(SRCDIR) -I$(OBJS_DIR)
diff --git a/usr/src/uts/i86xpv/isa/Makefile b/usr/src/uts/i86xpv/isa/Makefile
index c6a37b99b4..04df9350d3 100644
--- a/usr/src/uts/i86xpv/isa/Makefile
+++ b/usr/src/uts/i86xpv/isa/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 #	This makefile drives the production of the ISA nexus driver
 #
 #	i86xpv implementation architecture dependent
@@ -54,6 +56,8 @@ ALL_TARGET	= $(BINARY)
 LINT_TARGET	= $(MODULE).lint
 INSTALL_TARGET	= $(BINARY) $(ROOTMODULE)
 
+$(OBJS_DIR)/isa.o :=	CERRWARN	+= -_gcc=-Wno-unused-function
+
 #
 # lint pass one enforcement
 #
diff --git a/usr/src/uts/i86xpv/npe/Makefile b/usr/src/uts/i86xpv/npe/Makefile
index f460ef6d41..0a3ed67eb1 100644
--- a/usr/src/uts/i86xpv/npe/Makefile
+++ b/usr/src/uts/i86xpv/npe/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 #	This makefile drives the production of the PCI-E nexus driver
 #
 #	i86xpv implementation architecture dependent
@@ -74,6 +76,7 @@ LINTTAGS	+= -erroff=E_SUSPICIOUS_COMPARISON
 
 CERRWARN	+= -_gcc=-Wno-uninitialized
 CERRWARN	+= -_gcc=-Wno-parentheses
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86xpv/pci-ide/Makefile b/usr/src/uts/i86xpv/pci-ide/Makefile
index 449973b7a6..496f59c4a6 100644
--- a/usr/src/uts/i86xpv/pci-ide/Makefile
+++ b/usr/src/uts/i86xpv/pci-ide/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 
 #
 #	This makefile drives the production of the pci-ide "drv"
@@ -66,6 +68,7 @@ DEBUG_DEFS	+= $(DEBUG_FLGS)
 INC_PATH	+= -I$(UTSBASE)/common/io/pci-ide
 
 CERRWARN	+= -_gcc=-Wno-switch
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86xpv/pci/Makefile b/usr/src/uts/i86xpv/pci/Makefile
index a57bbefc42..e032aa6018 100644
--- a/usr/src/uts/i86xpv/pci/Makefile
+++ b/usr/src/uts/i86xpv/pci/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 
 #
 #	This makefile drives the production of the PCI nexus driver
@@ -72,6 +74,7 @@ LINTTAGS	+= -erroff=E_SUSPICIOUS_COMPARISON
 
 CERRWARN	+= -_gcc=-Wno-uninitialized
 CERRWARN	+= -_gcc=-Wno-parentheses
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86xpv/rootnex/Makefile b/usr/src/uts/i86xpv/rootnex/Makefile
index af3f6354f4..125f0c25f6 100644
--- a/usr/src/uts/i86xpv/rootnex/Makefile
+++ b/usr/src/uts/i86xpv/rootnex/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 
 #
 #	This makefile drives the production of the rootnex driver
@@ -66,6 +68,7 @@ LINTTAGS	+= -erroff=E_BAD_PTR_CAST_ALIGN
 CERRWARN	+= -_gcc=-Wno-uninitialized
 CERRWARN	+= -_gcc=-Wno-unused-label
 CERRWARN	+= -_gcc=-Wno-parentheses
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/i86xpv/unix/Makefile b/usr/src/uts/i86xpv/unix/Makefile
index 989e79399d..e55eed347f 100644
--- a/usr/src/uts/i86xpv/unix/Makefile
+++ b/usr/src/uts/i86xpv/unix/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 #	This makefile drives the production of unix (and unix.o).
 #
 #	i86xpv implementation architecture dependent
@@ -119,6 +121,9 @@ CLEANLINTFILES	+= $(LINT_LIB) $(DBOOT_LINT_LIB) $(DBOOT_LINTS)
 $(OBJS_DIR)/instr_size.o :=	EXTRA_OPTIONS	= -I$(SRC)/common/dis/i386
 $(OBJS_DIR)/instr_size.ln :=	EXTRA_OPTIONS	= -I$(SRC)/common/dis/i386
 
+# Additional definition for files including ACPI headers
+$(OBJS_DIR)/cpupm_mach.o :=	EXTRA_OPTIONS	= -DACPI_USE_SYSTEM_CLIBRARY
+
 CFLAGS += -DDIS_MEM
 
 #
diff --git a/usr/src/uts/i86xpv/xpv_psm/Makefile b/usr/src/uts/i86xpv/xpv_psm/Makefile
index 009ccabac1..23d1b62ba4 100644
--- a/usr/src/uts/i86xpv/xpv_psm/Makefile
+++ b/usr/src/uts/i86xpv/xpv_psm/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 
 #
 #	This makefile drives the production of the xpv_psm mach
@@ -77,6 +79,7 @@ CERRWARN	+= -_gcc=-Wno-type-limits
 CERRWARN	+= -_gcc=-Wno-parentheses
 CERRWARN	+= -_gcc=-Wno-uninitialized
 CERRWARN	+= -_gcc=-Wno-empty-body
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #	Default build targets.
 #
diff --git a/usr/src/uts/i86xpv/xpv_uppc/Makefile b/usr/src/uts/i86xpv/xpv_uppc/Makefile
index d66402e579..81537582ac 100644
--- a/usr/src/uts/i86xpv/xpv_uppc/Makefile
+++ b/usr/src/uts/i86xpv/xpv_uppc/Makefile
@@ -23,7 +23,7 @@
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# ident	"%Z%%M%	%I%	%E% SMI"
+# Copyright 2016 Joyent, Inc.
 #
 #	This makefile drives the production of the xpv_uppc mach
 #	kernel module.
@@ -62,6 +62,8 @@ INSTALL_TARGET	= $(BINARY) $(ROOTMODULE)
 DEBUG_FLGS	=
 DEBUG_DEFS	+= $(DEBUG_FLGS)
 
+CERRWARN	+= -_gcc=-Wno-unused-function
+
 #
 #
 # Depends on ACPI CA interpreter
diff --git a/usr/src/uts/intel/Makefile.files b/usr/src/uts/intel/Makefile.files
index e9e77646e7..d31a5f3815 100644
--- a/usr/src/uts/intel/Makefile.files
+++ b/usr/src/uts/intel/Makefile.files
@@ -207,41 +207,54 @@ KRTLD_OBJS +=		\
 #
 #	misc. modules
 #
-ACPICA_OBJS	+= dbcmds.o dbdisply.o \
-		   dbexec.o dbfileio.o dbhistry.o dbinput.o dbstats.o \
-		   dbutils.o dbxface.o evevent.o evgpe.o evgpeblk.o \
-		   evmisc.o evregion.o evrgnini.o evsci.o evxface.o \
-		   evxfevnt.o evxfregn.o hwacpi.o hwesleep.o hwgpe.o \
-		   hwregs.o hwsleep.o hwtimer.o hwxfsleep.o dsfield.o \
-		   dsinit.o dsmethod.o \
-		   dsmthdat.o dsobject.o dsopcode.o dsutils.o dswexec.o \
-		   dswload.o dswscope.o dswstate.o exconfig.o exconvrt.o \
-		   excreate.o exdump.o exfield.o exfldio.o exmisc.o \
-		   exmutex.o exnames.o exoparg1.o exoparg2.o exoparg3.o \
-		   exoparg6.o exprep.o exregion.o exresnte.o exresolv.o \
-		   exresop.o exstore.o exstoren.o exstorob.o exsystem.o \
-		   exutils.o psargs.o psopcode.o psparse.o psscope.o \
-		   pstree.o psutils.o pswalk.o psxface.o nsaccess.o \
-		   nsalloc.o nsdump.o nsdumpdv.o nseval.o nsinit.o \
-		   nsload.o nsnames.o nsobject.o nsparse.o nssearch.o \
-		   nsutils.o nswalk.o nsxfeval.o nsxfname.o nsxfobj.o \
-		   rsaddr.o rscalc.o rscreate.o rsdump.o rsserial.o \
+ACPICA_OBJS	+= \
+		   dmbuffer.o dmcstyle.o dmdeferred.o dmnames.o dmopcode.o \
+		   dmresrc.o dmresrcl.o dmresrcl2.o dmresrcs.o dmutils.o \
+		   dmwalk.o \
+		   \
+		   dsargs.o dscontrol.o dsdebug.o dsfield.o dsinit.o \
+		   dsmethod.o dsmthdat.o dsobject.o dsopcode.o dsutils.o \
+		   dswexec.o dswload.o dswload2.o dswscope.o dswstate.o \
+		   \
+		   evevent.o evglock.o evgpe.o evgpeblk.o evgpeinit.o \
+		   evgpeutil.o evhandler.o evmisc.o evregion.o evrgnini.o \
+		   evsci.o evxface.o evxfevnt.o evxfgpe.o evxfregn.o \
+		   \
+		   exconcat.o exconfig.o exconvrt.o excreate.o exdebug.o \
+		   exdump.o exfield.o exfldio.o exmisc.o exmutex.o exnames.o \
+		   exoparg1.o exoparg2.o exoparg3.o exoparg6.o exprep.o \
+		   exregion.o exresnte.o exresolv.o exresop.o exstore.o \
+		   exstoren.o exstorob.o exsystem.o extrace.o exutils.o \
+		   \
+		   hwacpi.o hwesleep.o hwgpe.o hwpci.o hwregs.o hwsleep.o \
+		   hwtimer.o hwvalid.o hwxface.o hwxfsleep.o \
+		   \
+		   psargs.o psloop.o psobject.o psopcode.o psopinfo.o \
+		   psparse.o psscope.o pstree.o psutils.o pswalk.o psxface.o \
+		   \
+		   nsaccess.o nsalloc.o nsarguments.o nsconvert.o nsdump.o \
+		   nsdumpdv.o nseval.o nsinit.o nsload.o nsnames.o nsobject.o \
+		   nsparse.o nspredef.o nsprepkg.o nsrepair.o nsrepair2.o \
+		   nssearch.o nsutils.o nswalk.o nsxfeval.o nsxfname.o \
+		   nsxfobj.o \
+		   \
+		   rsaddr.o rscalc.o rscreate.o rsdump.o rsdumpinfo.o \
 		   rsinfo.o rsio.o rsirq.o rslist.o rsmemory.o rsmisc.o \
-		   rsutils.o rsxface.o tbfadt.o tbfind.o tbinstal.o  \
-		   tbutils.o tbxface.o tbxfroot.o utaddress.o \
-		   utalloc.o utclib.o utcopy.o utdebug.o utdelete.o \
-		   uteval.o utglobal.o utinit.o utmath.o utmisc.o \
-		   utobject.o utresrc.o utxface.o utxfmutex.o acpica.o \
-		   acpi_enum.o \
-		   master_ops.o osl.o osl_ml.o acpica_ec.o utcache.o \
-		   utmutex.o utstate.o dmbuffer.o dmnames.o dmobject.o \
-		   dmopcode.o dmresrc.o dmresrcl.o dmresrcl2.o dmresrcs.o \
-		   dmutils.o \
-		   dmwalk.o psloop.o nspredef.o hwxface.o hwvalid.o \
-		   utlock.o utids.o nsrepair.o nsrepair2.o \
-		   dbmethod.o dbnames.o dsargs.o dscontrol.o dswload2.o \
-		   evglock.o evgpeinit.o evgpeutil.o evxfgpe.o exdebug.o \
-		   hwpci.o utdecode.o utosi.o utxferror.o
+		   rsserial.o rsutils.o rsxface.o \
+		   \
+		   tbdata.o tbfadt.o tbfind.o tbinstal.o tbprint.o tbutils.o \
+		   tbxface.o tbxfload.o tbxfroot.o \
+		   \
+		   utaddress.o utalloc.o utascii.o utbuffer.o utcache.o \
+		   utclib.o utcopy.o utdebug.o utdecode.o utdelete.o \
+		   uterror.o uteval.o utexcep.o utglobal.o uthex.o utids.o \
+		   utinit.o utlock.o utmath.o utmisc.o utmutex.o utnonansi.o \
+		   utobject.o utosi.o utownerid.o utpredef.o utprint.o \
+		   utresrc.o utstate.o utstring.o uttrack.o utuuid.o utxface.o \
+		   utxferror.o utxfinit.o utxfmutex.o \
+		   \
+		   acpi_enum.o acpica_ec.o acpica.o ahids.o master_ops.o \
+		   osl_ml.o osl.o
 
 
 AGP_OBJS += agpmaster.o
diff --git a/usr/src/uts/intel/acpica/Makefile b/usr/src/uts/intel/acpica/Makefile
index c901c5d2ba..d7742eec50 100644
--- a/usr/src/uts/intel/acpica/Makefile
+++ b/usr/src/uts/intel/acpica/Makefile
@@ -2,6 +2,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 #
 #	This makefile drives the production of the ACPI CA services
 #	kernel module.
@@ -45,7 +47,8 @@ DEBUG_DEFS	+= $(DEBUG_FLGS)
 #
 # lint pass one non-enforcement
 #
-CFLAGS += $(CCVERBOSE) -DPWRDMN -DACPI_USE_LOCAL_CACHE -DACPI_DEBUG_OUTPUT
+CFLAGS += $(CCVERBOSE) -DPWRDMN -DACPI_USE_LOCAL_CACHE -DACPI_DEBUG_OUTPUT \
+	-DACPI_USE_SYSTEM_CLIBRARY
 
 #
 # 3rd party code is not lint clean
@@ -60,6 +63,7 @@ LINTFLAGS += -errwarn=%none
 CERRWARN	+= -_gcc=-Wno-unused-variable
 CERRWARN	+= -_gcc=-Wno-parentheses
 CERRWARN	+= -_gcc=-Wno-uninitialized
+CERRWARN	+= -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/intel/io/acpica/acpi_enum.c b/usr/src/uts/intel/io/acpica/acpi_enum.c
index 85502d4bc1..aec75712f5 100644
--- a/usr/src/uts/intel/io/acpica/acpi_enum.c
+++ b/usr/src/uts/intel/io/acpica/acpi_enum.c
@@ -19,6 +19,7 @@
  * CDDL HEADER END
  */
 /*
+ * Copyright 2016, Joyent, Inc.
  * Copyright (c) 2012 Gary Mills
  *
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
@@ -135,7 +136,7 @@ parse_resources_irq(ACPI_RESOURCE *resource_ptr, int *interrupt_count)
 		    resource_ptr->Data.Irq.Interrupts[i];
 		used_interrupts |= 1 << resource_ptr->Data.Irq.Interrupts[i];
 		if (acpi_enum_debug & PARSE_RES_IRQ) {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "IRQ num %u, intr # = %u",
 			    i, resource_ptr->Data.Irq.Interrupts[i]);
 		}
@@ -151,7 +152,7 @@ parse_resources_dma(ACPI_RESOURCE *resource_ptr, int *dma_count)
 		dma[(*dma_count)++] = resource_ptr->Data.Dma.Channels[i];
 		used_dmas |= 1 << resource_ptr->Data.Dma.Channels[i];
 		if (acpi_enum_debug & PARSE_RES_DMA) {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "DMA num %u, channel # = %u",
 			    i, resource_ptr->Data.Dma.Channels[i]);
 		}
@@ -171,7 +172,7 @@ parse_resources_io(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 	io[*io_count].regspec_size = acpi_io.AddressLength;
 	io[*io_count].regspec_addr = acpi_io.Minimum;
 	if (acpi_enum_debug & PARSE_RES_IO) {
-		cmn_err(CE_NOTE, "parse_resources() "\
+		cmn_err(CE_NOTE, "!parse_resources() "\
 		    "IO min 0x%X, max 0x%X, length: 0x%X",
 		    acpi_io.Minimum,
 		    acpi_io.Maximum,
@@ -193,7 +194,7 @@ parse_resources_fixed_io(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 	io[*io_count].regspec_addr = fixed_io.Address;
 	io[*io_count].regspec_size = fixed_io.AddressLength;
 	if (acpi_enum_debug & PARSE_RES_IO) {
-		cmn_err(CE_NOTE, "parse_resources() "\
+		cmn_err(CE_NOTE, "!parse_resources() "\
 		    "Fixed IO 0x%X, length: 0x%X",
 		    fixed_io.Address, fixed_io.AddressLength);
 	}
@@ -214,7 +215,7 @@ parse_resources_fixed_mem32(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 	io[*io_count].regspec_addr = fixed_mem32.Address;
 	io[*io_count].regspec_size = fixed_mem32.AddressLength;
 	if (acpi_enum_debug & PARSE_RES_MEMORY) {
-		cmn_err(CE_NOTE, "parse_resources() "\
+		cmn_err(CE_NOTE, "!parse_resources() "\
 		    "Fixed Mem 32 %ul, length: %ul",
 		    fixed_mem32.Address, fixed_mem32.AddressLength);
 	}
@@ -237,16 +238,16 @@ parse_resources_mem32(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 		io[*io_count].regspec_size = mem32.AddressLength;
 		(*io_count)++;
 		if (acpi_enum_debug & PARSE_RES_MEMORY) {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "Mem 32 0x%X, length: 0x%X",
 			    mem32.Minimum, mem32.AddressLength);
 		}
 		return;
 	}
 	if (acpi_enum_debug & PARSE_RES_MEMORY) {
-		cmn_err(CE_NOTE, "parse_resources() "\
+		cmn_err(CE_NOTE, "!parse_resources() "\
 		    "MEM32 Min Max not equal!");
-		cmn_err(CE_NOTE, "parse_resources() "\
+		cmn_err(CE_NOTE, "!parse_resources() "\
 		    "Mem 32 Minimum 0x%X, Maximum: 0x%X",
 		    mem32.Minimum, mem32.Maximum);
 	}
@@ -259,22 +260,22 @@ parse_resources_addr16(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 	ACPI_RESOURCE_ADDRESS16 addr16 =
 	    resource_ptr->Data.Address16;
 
-	if (addr16.AddressLength == 0)
+	if (addr16.Address.AddressLength == 0)
 		return;
 
 	if (acpi_enum_debug & PARSE_RES_ADDRESS) {
 		if (addr16.ResourceType == ACPI_MEMORY_RANGE) {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "ADDRESS 16 MEMORY RANGE");
 		} else
 		if (addr16.ResourceType == ACPI_IO_RANGE) {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "ADDRESS 16 IO RANGE");
 		} else {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "ADDRESS 16 OTHER");
 		}
-		cmn_err(CE_NOTE, "parse_resources() "\
+		cmn_err(CE_NOTE, "!parse_resources() "\
 		    "%s "\
 		    "MinAddressFixed 0x%X, "\
 		    "MaxAddressFixed 0x%X, "\
@@ -285,16 +286,16 @@ parse_resources_addr16(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 		    "CONSUMER" : "PRODUCER",
 		    addr16.MinAddressFixed,
 		    addr16.MaxAddressFixed,
-		    addr16.Minimum,
-		    addr16.Maximum,
-		    addr16.AddressLength);
+		    addr16.Address.Minimum,
+		    addr16.Address.Maximum,
+		    addr16.Address.AddressLength);
 	}
 	if (addr16.ProducerConsumer == ACPI_PRODUCER ||
 	    (addr16.ResourceType != ACPI_MEMORY_RANGE &&
 	    addr16.ResourceType != ACPI_IO_RANGE)) {
 		return;
 	}
-	if (addr16.AddressLength > 0) {
+	if (addr16.Address.AddressLength > 0) {
 		if (addr16.ResourceType == ACPI_MEMORY_RANGE) {
 			/* memory */
 			io[*io_count].regspec_bustype = 0;
@@ -302,8 +303,8 @@ parse_resources_addr16(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 			/* io */
 			io[*io_count].regspec_bustype = 1;
 		}
-		io[*io_count].regspec_addr = addr16.Minimum;
-		io[*io_count].regspec_size = addr16.AddressLength;
+		io[*io_count].regspec_addr = addr16.Address.Minimum;
+		io[*io_count].regspec_size = addr16.Address.AddressLength;
 		(*io_count)++;
 	}
 }
@@ -315,22 +316,22 @@ parse_resources_addr32(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 	ACPI_RESOURCE_ADDRESS32 addr32 =
 	    resource_ptr->Data.Address32;
 
-	if (addr32.AddressLength == 0)
+	if (addr32.Address.AddressLength == 0)
 		return;
 
 	if (acpi_enum_debug & PARSE_RES_ADDRESS) {
 		if (addr32.ResourceType == ACPI_MEMORY_RANGE) {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "ADDRESS 32 MEMORY RANGE");
 		} else
 		if (addr32.ResourceType == ACPI_IO_RANGE) {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "ADDRESS 32 IO RANGE");
 		} else {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "ADDRESS 32 OTHER");
 		}
-		cmn_err(CE_NOTE, "parse_resources() "\
+		cmn_err(CE_NOTE, "!parse_resources() "\
 		    "%s "\
 		    "MinAddressFixed 0x%X, "\
 		    "MaxAddressFixed 0x%X, "\
@@ -341,16 +342,16 @@ parse_resources_addr32(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 		    "CONSUMER" : "PRODUCER",
 		    addr32.MinAddressFixed,
 		    addr32.MaxAddressFixed,
-		    addr32.Minimum,
-		    addr32.Maximum,
-		    addr32.AddressLength);
+		    addr32.Address.Minimum,
+		    addr32.Address.Maximum,
+		    addr32.Address.AddressLength);
 	}
 	if (addr32.ProducerConsumer == ACPI_PRODUCER ||
 	    (addr32.ResourceType != ACPI_MEMORY_RANGE &&
 	    addr32.ResourceType != ACPI_IO_RANGE)) {
 		return;
 	}
-	if (addr32.AddressLength > 0) {
+	if (addr32.Address.AddressLength > 0) {
 		if (addr32.ResourceType == ACPI_MEMORY_RANGE) {
 			/* memory */
 			io[*io_count].regspec_bustype = 0;
@@ -358,8 +359,8 @@ parse_resources_addr32(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 			/* io */
 			io[*io_count].regspec_bustype = 1;
 		}
-		io[*io_count].regspec_addr = addr32.Minimum;
-		io[*io_count].regspec_size = addr32.AddressLength;
+		io[*io_count].regspec_addr = addr32.Address.Minimum;
+		io[*io_count].regspec_size = addr32.Address.AddressLength;
 		(*io_count)++;
 	}
 }
@@ -371,23 +372,23 @@ parse_resources_addr64(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 	ACPI_RESOURCE_ADDRESS64 addr64 =
 	    resource_ptr->Data.Address64;
 
-	if (addr64.AddressLength == 0)
+	if (addr64.Address.AddressLength == 0)
 		return;
 
 	if (acpi_enum_debug & PARSE_RES_ADDRESS) {
 		if (addr64.ResourceType == ACPI_MEMORY_RANGE) {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "ADDRESS 64 MEMORY RANGE");
 		} else
 		if (addr64.ResourceType == ACPI_IO_RANGE) {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "ADDRESS 64 IO RANGE");
 		} else {
-			cmn_err(CE_NOTE, "parse_resources() "\
+			cmn_err(CE_NOTE, "!parse_resources() "\
 			    "ADDRESS 64 OTHER");
 		}
 #ifdef _LP64
-		cmn_err(CE_NOTE, "parse_resources() "\
+		cmn_err(CE_NOTE, "!parse_resources() "\
 		    "%s "\
 		    "MinAddressFixed 0x%X, "\
 		    "MaxAddressFixed 0x%X, "\
@@ -398,11 +399,11 @@ parse_resources_addr64(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 		    "CONSUMER" : "PRODUCER",
 		    addr64.MinAddressFixed,
 		    addr64.MaxAddressFixed,
-		    addr64.Minimum,
-		    addr64.Maximum,
-		    addr64.AddressLength);
+		    addr64.Address.Minimum,
+		    addr64.Address.Maximum,
+		    addr64.Address.AddressLength);
 #else
-		cmn_err(CE_NOTE, "parse_resources() "\
+		cmn_err(CE_NOTE, "!parse_resources() "\
 		    "%s "\
 		    "MinAddressFixed 0x%X, "\
 		    "MaxAddressFixed 0x%X, "\
@@ -413,9 +414,9 @@ parse_resources_addr64(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 		    "CONSUMER" : "PRODUCER",
 		    addr64.MinAddressFixed,
 		    addr64.MaxAddressFixed,
-		    addr64.Minimum,
-		    addr64.Maximum,
-		    addr64.AddressLength);
+		    addr64.Address.Minimum,
+		    addr64.Address.Maximum,
+		    addr64.Address.AddressLength);
 #endif
 	}
 	if (addr64.ProducerConsumer == ACPI_PRODUCER ||
@@ -423,7 +424,7 @@ parse_resources_addr64(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 	    addr64.ResourceType != ACPI_IO_RANGE)) {
 		return;
 	}
-	if (addr64.AddressLength > 0) {
+	if (addr64.Address.AddressLength > 0) {
 		if (addr64.ResourceType == ACPI_MEMORY_RANGE) {
 			/* memory */
 			io[*io_count].regspec_bustype = 0;
@@ -431,8 +432,8 @@ parse_resources_addr64(ACPI_RESOURCE *resource_ptr, struct regspec *io,
 			/* io */
 			io[*io_count].regspec_bustype = 1;
 		}
-		io[*io_count].regspec_addr = addr64.Minimum;
-		io[*io_count].regspec_size = addr64.AddressLength;
+		io[*io_count].regspec_addr = addr64.Address.Minimum;
+		io[*io_count].regspec_size = addr64.Address.AddressLength;
 		(*io_count)++;
 	}
 }
@@ -699,7 +700,7 @@ process_cids(ACPI_OBJECT *rv, device_id_t **dd)
 			break;
 		default:
 			if (acpi_enum_debug & PROCESS_CIDS) {
-				cmn_err(CE_NOTE, "unexpected CID type: %d",
+				cmn_err(CE_NOTE, "!unexpected CID type: %d",
 				    obj.Type);
 			}
 			break;
@@ -824,7 +825,7 @@ isa_acpi_callback(ACPI_HANDLE ObjHandle, uint32_t NestingLevel, void *a,
 		 */
 		if (!((info->CurrentStatus & 0x7) == 7)) {
 			if (acpi_enum_debug & DEVICES_NOT_ENUMED) {
-				cmn_err(CE_NOTE, "parse_resources() "
+				cmn_err(CE_NOTE, "!parse_resources() "
 				    "Bad status 0x%x for %s",
 				    info->CurrentStatus, path);
 			}
@@ -841,7 +842,7 @@ isa_acpi_callback(ACPI_HANDLE ObjHandle, uint32_t NestingLevel, void *a,
 	if (!(info->Valid & ACPI_VALID_HID)) {
 		/* No _HID, we skip this node */
 		if (acpi_enum_debug & DEVICES_NOT_ENUMED) {
-			cmn_err(CE_NOTE, "parse_resources() "
+			cmn_err(CE_NOTE, "!parse_resources() "
 			    "No _HID for %s", path);
 		}
 		goto done;
@@ -1064,7 +1065,7 @@ acpi_isa_device_enum(dev_info_t *isa_dip)
 	}
 
 	if (acpi_enum_debug & ISA_DEVICE_ENUM) {
-		cmn_err(CE_NOTE, "acpi_isa_device_enum() called");
+		cmn_err(CE_NOTE, "!acpi_isa_device_enum() called");
 	}
 
 	if (acpica_init() != AE_OK) {
diff --git a/usr/src/uts/intel/io/acpica/acpica.c b/usr/src/uts/intel/io/acpica/acpica.c
index 999002f5c3..0fba611701 100644
--- a/usr/src/uts/intel/io/acpica/acpica.c
+++ b/usr/src/uts/intel/io/acpica/acpica.c
@@ -20,8 +20,8 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, Joyent, Inc. All rights reserved.
  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright 2016, Joyent, Inc.
  */
 /*
  * Copyright (c) 2009, Intel Corporation.
@@ -96,6 +96,9 @@ static kstat_t	*acpica_ksp;
  */
 int acpica_init_state = ACPICA_NOT_INITIALIZED;
 
+void *AcpiGbl_DbBuffer;
+uint32_t AcpiGbl_DbConsoleDebugLevel;
+
 /*
  * Following are set by acpica_process_user_options()
  *
@@ -192,37 +195,42 @@ static int
 acpica_install_handlers()
 {
 	ACPI_STATUS	rv = AE_OK;
+	ACPI_STATUS	res;
 
 	/*
 	 * Install ACPI CA default handlers
 	 */
-	if (AcpiInstallAddressSpaceHandler(ACPI_ROOT_OBJECT,
+	if ((res = AcpiInstallAddressSpaceHandler(ACPI_ROOT_OBJECT,
 	    ACPI_ADR_SPACE_SYSTEM_MEMORY,
-	    ACPI_DEFAULT_HANDLER, NULL, NULL) != AE_OK) {
+	    ACPI_DEFAULT_HANDLER, NULL, NULL)) != AE_OK &&
+	    res != AE_SAME_HANDLER) {
 		cmn_err(CE_WARN, "!acpica: no default handler for"
 		    " system memory");
 		rv = AE_ERROR;
 	}
 
-	if (AcpiInstallAddressSpaceHandler(ACPI_ROOT_OBJECT,
+	if ((res = AcpiInstallAddressSpaceHandler(ACPI_ROOT_OBJECT,
 	    ACPI_ADR_SPACE_SYSTEM_IO,
-	    ACPI_DEFAULT_HANDLER, NULL, NULL) != AE_OK) {
+	    ACPI_DEFAULT_HANDLER, NULL, NULL)) != AE_OK &&
+	    res != AE_SAME_HANDLER) {
 		cmn_err(CE_WARN, "!acpica: no default handler for"
 		    " system I/O");
 		rv = AE_ERROR;
 	}
 
-	if (AcpiInstallAddressSpaceHandler(ACPI_ROOT_OBJECT,
+	if ((res = AcpiInstallAddressSpaceHandler(ACPI_ROOT_OBJECT,
 	    ACPI_ADR_SPACE_PCI_CONFIG,
-	    ACPI_DEFAULT_HANDLER, NULL, NULL) != AE_OK) {
+	    ACPI_DEFAULT_HANDLER, NULL, NULL)) != AE_OK &&
+	    res != AE_SAME_HANDLER) {
 		cmn_err(CE_WARN, "!acpica: no default handler for"
 		    " PCI Config");
 		rv = AE_ERROR;
 	}
 
-	if (AcpiInstallAddressSpaceHandler(ACPI_ROOT_OBJECT,
+	if ((res = AcpiInstallAddressSpaceHandler(ACPI_ROOT_OBJECT,
 	    ACPI_ADR_SPACE_DATA_TABLE,
-	    ACPI_DEFAULT_HANDLER, NULL, NULL) != AE_OK) {
+	    ACPI_DEFAULT_HANDLER, NULL, NULL)) != AE_OK &&
+	    res != AE_SAME_HANDLER) {
 		cmn_err(CE_WARN, "!acpica: no default handler for"
 		    " Data Table");
 		rv = AE_ERROR;
diff --git a/usr/src/uts/intel/io/acpica/ahids.c b/usr/src/uts/intel/io/acpica/ahids.c
new file mode 100644
index 0000000000..51dc8dc803
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/ahids.c
@@ -0,0 +1,245 @@
+/******************************************************************************
+ *
+ * Module Name: ahids - Table of ACPI/PNP _HID/_CID values
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("ahids")
+
+
+/*
+ * ACPI/PNP Device IDs with description strings
+ */
+const AH_DEVICE_ID  AslDeviceIds[] =
+{
+    {"10EC5640",    "Realtek I2S Audio Codec"},
+    {"80860F09",    "Intel PWM Controller"},
+    {"80860F0A",    "Intel Atom UART Controller"},
+    {"80860F0E",    "Intel SPI Controller"},
+    {"80860F14",    "Intel Baytrail SDIO/MMC Host Controller"},
+    {"80860F28",    "Intel SST Audio DSP"},
+    {"80860F41",    "Intel Baytrail I2C Host Controller"},
+    {"ACPI0001",    "SMBus 1.0 Host Controller"},
+    {"ACPI0002",    "Smart Battery Subsystem"},
+    {"ACPI0003",    "Power Source Device"},
+    {"ACPI0004",    "Module Device"},
+    {"ACPI0005",    "SMBus 2.0 Host Controller"},
+    {"ACPI0006",    "GPE Block Device"},
+    {"ACPI0007",    "Processor Device"},
+    {"ACPI0008",    "Ambient Light Sensor Device"},
+    {"ACPI0009",    "I/O xAPIC Device"},
+    {"ACPI000A",    "I/O APIC Device"},
+    {"ACPI000B",    "I/O SAPIC Device"},
+    {"ACPI000C",    "Processor Aggregator Device"},
+    {"ACPI000D",    "Power Meter Device"},
+    {"ACPI000E",    "Time and Alarm Device"},
+    {"ACPI000F",    "User Presence Detection Device"},
+    {"ACPI0010",    "Processor Container Device"},
+    {"ACPI0011",    "Generic Buttons Device"},
+    {"ACPI0012",    "NVDIMM Root Device"},
+    {"ACPI0013",    "Generic Event Device"},
+    {"ADMA0F28",    "Intel Audio DMA"},
+    {"AMCR0F28",    "Intel Audio Machine Driver"},
+    {"ATK4001",     "Asus Radio Control Button"},
+    {"ATML1000",    "Atmel Touchscreen Controller"},
+    {"AUTH2750",    "AuthenTec AES2750"},
+    {"BCM2E39",     "Broadcom BT Serial Bus Driver over UART Bus Enumerator"},
+    {"BCM4752E",    "Broadcom GPS Controller"},
+    {"BMG0160",     "Bosch Gyro Sensor"},
+    {"CPLM3218",    "Capella Micro CM3218x Ambient Light Sensor"},
+    {"DELLABCE",    "Dell Airplane Mode Switch Driver"},
+    {"DLAC3002",    "Qualcomm Atheros Bluetooth UART Transport"},
+    {"FTTH5506",    "FocalTech 5506 Touch Controller"},
+    {"HAD0F28",     "Intel HDMI Audio Driver"},
+    {"INBC0000",    "GPIO Expander"},
+    {"INT0002",     "Virtual GPIO Controller"},
+    {"INT0800",     "Intel 82802 Firmware Hub Device"},
+    {"INT3394",     "ACPI System Fan"},
+    {"INT3396",     "Standard Power Management Controller"},
+    {"INT33A0",     "Intel Smart Connect Technology Device"},
+    {"INT33A1",     "Intel Power Engine"},
+    {"INT33BB",     "Intel Baytrail SD Host Controller"},
+    {"INT33BD",     "Intel Baytrail Mailbox Device"},
+    {"INT33BE",     "Camera Sensor OV5693"},
+    {"INT33C0",     "Intel Serial I/O SPI Host Controller"},
+    {"INT33C1",     "Intel Serial I/O SPI Host Controller"},
+    {"INT33C2",     "Intel Serial I/O I2C Host Controller"},
+    {"INT33C3",     "Intel Serial I/O I2C Host Controller"},
+    {"INT33C4",     "Intel Serial I/O UART Host Controller"},
+    {"INT33C5",     "Intel Serial I/O UART Host Controller"},
+    {"INT33C6",     "Intel SD Host Controller"},
+    {"INT33C7",     "Intel Serial I/O GPIO Host Controller"},
+    {"INT33C8",     "Intel Smart Sound Technology Host Controller"},
+    {"INT33C9",     "Wolfson Microelectronics Audio WM5102"},
+    {"INT33CA",     "Intel SPB Peripheral"},
+    {"INT33CB",     "Intel Smart Sound Technology Audio Codec"},
+    {"INT33D1",     "Intel GPIO Buttons"},
+    {"INT33D2",     "Intel GPIO Buttons"},
+    {"INT33D3",     "Intel GPIO Buttons"},
+    {"INT33D4",     "Intel GPIO Buttons"},
+    {"INT33D6",     "Intel Virtual Buttons Device"},
+    {"INT33F0",     "Camera Sensor MT9M114"},
+    {"INT33F4",     "XPOWER PMIC Controller"},
+    {"INT33F5",     "TI PMIC Controller"},
+    {"INT33FB",     "MIPI-CSI Camera Sensor OV2722"},
+    {"INT33FC",     "Intel Baytrail GPIO Controller"},
+    {"INT33FD",     "Intel Baytrail Power Management IC"},
+    {"INT33FE",     "XPOWER Battery Device"},
+    {"INT3400",     "Intel Dynamic Power Performance Management"},
+    {"INT3401",     "Intel Extended Thermal Model CPU"},
+    {"INT3403",     "DPTF Temperature Sensor"},
+    {"INT3406",     "Intel Dynamic Platform & Thermal Framework Display Participant"},
+    {"INT3407",     "DPTF Platform Power Meter"},
+    {"INT340E",     "Motherboard Resources"},
+    {"INT3420",     "Intel Bluetooth RF Kill"},
+    {"INT3F0D",     "ACPI Motherboard Resources"},
+    {"INTCF1A",     "Sony IMX175 Camera Sensor"},
+    {"INTCFD9",     "Intel Baytrail SOC GPIO Controller"},
+    {"INTL9C60",    "Intel Baytrail SOC DMA Controller"},
+    {"INVN6500",    "InvenSense MPU-6500 Six Axis Gyroscope and Accelerometer"},
+    {"LNXCPU",      "Linux Logical CPU"},
+    {"LNXPOWER",    "ACPI Power Resource (power gating)"},
+    {"LNXPWRBN",    "System Power Button"},
+    {"LNXSYBUS",    "System Bus"},
+    {"LNXSYSTM",    "ACPI Root Node"},
+    {"LNXTHERM",    "ACPI Thermal Zone"},
+    {"LNXVIDEO",    "ACPI Video Controller"},
+    {"MAX17047",    "Fuel Gauge Controller"},
+    {"MSFT0101",    "TPM 2.0 Security Device"},
+    {"NXP5442",     "NXP 5442 Near Field Communications Controller"},
+    {"NXP5472",     "NXP NFC"},
+    {"PNP0000",     "8259-compatible Programmable Interrupt Controller"},
+    {"PNP0001",     "EISA Interrupt Controller"},
+    {"PNP0002",     "MCA Interrupt Controller"},
+    {"PNP0003",     "IO-APIC Interrupt Controller"},
+    {"PNP0100",     "PC-class System Timer"},
+    {"PNP0103",     "HPET System Timer"},
+    {"PNP0200",     "PC-class DMA Controller"},
+    {"PNP0300",     "IBM PC/XT Keyboard Controller (83 key)"},
+    {"PNP0301",     "IBM PC/XT Keyboard Controller (86 key)"},
+    {"PNP0302",     "IBM PC/XT Keyboard Controller (84 key)"},
+    {"PNP0303",     "IBM Enhanced Keyboard (101/102-key, PS/2 Mouse)"},
+    {"PNP0400",     "Standard LPT Parallel Port"},
+    {"PNP0401",     "ECP Parallel Port"},
+    {"PNP0500",     "Standard PC COM Serial Port"},
+    {"PNP0501",     "16550A-compatible COM Serial Port"},
+    {"PNP0510",     "Generic IRDA-compatible Device"},
+    {"PNP0800",     "Microsoft Sound System Compatible Device"},
+    {"PNP0A03",     "PCI Bus"},
+    {"PNP0A05",     "Generic Container Device"},
+    {"PNP0A06",     "Generic Container Device"},
+    {"PNP0A08",     "PCI Express Bus"},
+    {"PNP0B00",     "AT Real-Time Clock"},
+    {"PNP0B01",     "Intel PIIX4-compatible RTC/CMOS Device"},
+    {"PNP0B02",     "Dallas Semiconductor-compatible RTC/CMOS Device"},
+    {"PNP0C01",     "System Board"},
+    {"PNP0C02",     "PNP Motherboard Resources"},
+    {"PNP0C04",     "x87-compatible Floating Point Processing Unit"},
+    {"PNP0C08",     "ACPI Core Hardware"},
+    {"PNP0C09",     "Embedded Controller Device"},
+    {"PNP0C0A",     "Control Method Battery"},
+    {"PNP0C0B",     "Fan (Thermal Solution)"},
+    {"PNP0C0C",     "Power Button Device"},
+    {"PNP0C0D",     "Lid Device"},
+    {"PNP0C0E",     "Sleep Button Device"},
+    {"PNP0C0F",     "PCI Interrupt Link Device"},
+    {"PNP0C10",     "System Indicator Device"},
+    {"PNP0C11",     "Thermal Zone"},
+    {"PNP0C12",     "Device Bay Controller"},
+    {"PNP0C14",     "Windows Management Instrumentation Device"},
+    {"PNP0C15",     "Docking Station"},
+    {"PNP0C33",     "Error Device"},
+    {"PNP0C40",     "Standard Button Controller"},
+    {"PNP0C50",     "HID Protocol Device (I2C bus)"},
+    {"PNP0C60",     "Display Sensor Device"},
+    {"PNP0C70",     "Dock Sensor Device"},
+    {"PNP0C80",     "Memory Device"},
+    {"PNP0D10",     "XHCI USB Controller with debug"},
+    {"PNP0D15",     "XHCI USB Controller without debug"},
+    {"PNP0D20",     "EHCI USB Controller without debug"},
+    {"PNP0D25",     "EHCI USB Controller with debug"},
+    {"PNP0D40",     "SDA Standard Compliant SD Host Controller"},
+    {"PNP0D80",     "Windows-compatible System Power Management Controller"},
+    {"PNP0F03",     "Microsoft PS/2-style Mouse"},
+    {"PNP0F13",     "PS/2 Mouse"},
+    {"RTL8723",     "Realtek Wireless Controller"},
+    {"SMB0349",     "Charger"},
+    {"SMO91D0",     "Sensor Hub"},
+    {"SMSC3750",    "SMSC 3750 USB MUX"},
+    {"SSPX0000",    "Intel SSP Device"},
+    {"TBQ24296",    "Charger"},
+
+    {NULL, NULL}
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiAhMatchHardwareId
+ *
+ * PARAMETERS:  HardwareId          - String representation of an _HID or _CID
+ *
+ * RETURN:      ID info struct. NULL if HardwareId is not found
+ *
+ * DESCRIPTION: Lookup an _HID/_CID in the device ID table
+ *
+ ******************************************************************************/
+
+const AH_DEVICE_ID *
+AcpiAhMatchHardwareId (
+    char                    *HardwareId)
+{
+    const AH_DEVICE_ID      *Info;
+
+
+    for (Info = AslDeviceIds; Info->Name; Info++)
+    {
+        if (!strcmp (HardwareId, Info->Name))
+        {
+            return (Info);
+        }
+    }
+
+    return (NULL);
+}
diff --git a/usr/src/uts/intel/io/acpica/changes.txt b/usr/src/uts/intel/io/acpica/changes.txt
index 69dcdf708c..ff863a7c3c 100644
--- a/usr/src/uts/intel/io/acpica/changes.txt
+++ b/usr/src/uts/intel/io/acpica/changes.txt
@@ -1,51 +1,3738 @@
+----------------------------------------
+27 May 2016. Summary of changes for version 20160527:
+
+This release is available at https://acpica.org/downloads
+
+
+1) ACPICA kernel-resident subsystem:
+
+Temporarily reverted the new arbitrary bit length/alignment support in 
+AcpiHwRead/AcpiHwWrite for the Generic Address Structure. There have been 
+a number of regressions with the new code that need to be fully resolved 
+and tested before this support can be finally integrated into ACPICA. 
+Apologies for any inconveniences these issues may have caused.
+
+The ACPI message macros are not configurable (ACPI_MSG_ERROR, 
+ACPI_MSG_EXCEPTION, ACPI_MSG_WARNING, ACPI_MSG_INFO, ACPI_MSG_BIOS_ERROR, 
+and ACPI_MSG_BIOS_WARNING). Lv Zheng.
+
+Fixed a couple of GCC warnings associated with the use of the -Wcast-qual 
+option. Adds a new return macro, return_STR. Junk-uk Kim.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version: 136.8K Code, 51.6K Data, 188.4K Total
+    Debug Version:     201.5K Code, 82.2K Data, 283.7K Total
+  Previous Release:
+    Non-Debug Version: 137.4K Code, 52.6K Data, 190.0K Total
+    Debug Version:     200.9K Code, 82.2K Data, 283.1K Total
+
+----------------------------------------
+22 April 2016. Summary of changes for version 20160422:
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed a regression in the GAS (generic address structure) arbitrary bit 
+support in AcpiHwRead/AcpiHwWrite. Problem could cause incorrect behavior 
+and incorrect return values. Lv Zheng. ACPICA BZ 1270.
+
+ACPI 6.0: Added support for new/renamed resource macros. One new argument 
+was added to each of these macros, and the original name has been 
+deprecated. The AML disassembler will always disassemble to the new 
+names. Support for the new macros was added to iASL, disassembler, 
+resource manager, and the acpihelp utility. ACPICA BZ 1274.
+
+    I2cSerialBus  -> I2cSerialBusV2
+    SpiSerialBus  -> SpiSerialBusV2
+    UartSerialBus -> UartSerialBusV2
+
+ACPI 6.0: Added support for a new integer field that was appended to the 
+package object returned by the _BIX method. This adds iASL compile-time 
+and AML runtime error checking. ACPICA BZ 1273.
+
+ACPI 6.1: Added support for a new PCCT subtable, "HW-Reduced Comm 
+Subspace Type2" (Headers, Disassembler, and data table compiler).
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version: 137.4K Code, 52.6K Data, 190.0K Total
+    Debug Version:     201.5K Code, 82.2K Data, 283.7K Total
+  Previous Release:
+    Non-Debug Version: 137.1K Code, 51.5K Data, 188.6K Total
+    Debug Version:     201.0K Code, 82.0K Data, 283.0K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Implemented an ASL grammar extension to allow/enable executable 
+"module-level code" to be created and executed under the various 
+operators that create new scopes. This type of AML code is already 
+supported in all known AML interpreters, and the grammar change will 
+appear in the next version of the ACPI specification. Simplifies the 
+conditional runtime creation of named objects under these object types: 
+
+    Device
+    PowerResource
+    Processor
+    Scope
+    ThermalZone
+
+iASL: Implemented a new ASL extension, a "For" loop macro to add greater 
+ease-of-use to the ASL language. The syntax is similar to the 
+corresponding C operator, and is implemented with the existing AML While 
+opcode -- thus requiring no changes to existing AML interpreters.
+
+    For (Initialize, Predicate, Update) {TermList}
+
+Grammar:
+    ForTerm :=
+        For (
+            Initializer    // Nothing | TermArg => ComputationalData
+            Predicate      // Nothing | TermArg => ComputationalData
+            Update         // Nothing | TermArg => ComputationalData
+        ) {TermList}
+
+
+iASL: The _HID/_ADR detection and validation has been enhanced to search 
+under conditionals in order to allow these objects to be conditionally 
+created at runtime.
+
+iASL: Fixed several issues with the constant folding feature. The 
+improvement allows better detection and resolution of statements that can 
+be folded at compile time. ACPICA BZ 1266. 
+
+iASL/Disassembler: Fixed a couple issues with the Else{If{}...} 
+conversion to the ASL ElseIf operator where incorrect ASL code could be 
+generated.
+
+iASL/Disassembler: Fixed a problem with the ASL+ code disassembly where 
+sometimes an extra (and extraneous) set of parentheses were emitted for 
+some combinations of operators. Although this did not cause any problems 
+with recompilation of the disassembled code, it made the code more 
+difficult to read. David Box. ACPICA BZ 1231.
+
+iASL: Changed to ignore the unreferenced detection for predefined names 
+of resource descriptor elements, when the resource descriptor is 
+created/defined within a control method.
+
+iASL: Disassembler: Fix a possible fault with externally declared Buffer 
+objects.
+
+----------------------------------------
+18 March 2016. Summary of changes for version 20160318:
+
+1) ACPICA kernel-resident subsystem:
+
+Added support for arbitrary bit lengths and bit offsets for registers 
+defined by the Generic Address Structure. Previously, only aligned bit 
+lengths of 8/16/32/64 were supported. This was sufficient for many years, 
+but recently some machines have been seen that require arbitrary bit-
+level support. ACPICA BZ 1240. Lv Zheng.
+
+Fixed an issue where the \_SB._INI method sometimes must be evaluated 
+before any _REG methods are evaluated. Lv Zheng.
+
+Implemented several changes related to ACPI table support 
+(Headers/Disassembler/TableCompiler):
+NFIT: For ACPI 6.1, updated to add some additional new fields and 
+constants.
+FADT: Updated a warning message and set compliance to ACPI 6.1 (Version 
+6).
+DMAR: Added new constants per the 10/2014 DMAR spec.
+IORT: Added new subtable per the 10/2015 IORT spec.
+HEST: For ACPI 6.1, added new constants and new subtable.
+DBG2: Added new constants per the 12/2015 DBG2 spec.
+FPDT: Fixed several incorrect fields, add the FPDT boot record structure. 
+ACPICA BZ 1249.
+ERST/EINJ: Updated disassembler with new "Execute Timings" actions.
+
+Updated header support for the DMAR table to match the current version of 
+the related spec.
+
+Added extensions to the ASL Concatenate operator to allow any ACPI object 
+to be passed as an operand. Any object other than Integer/String/Buffer 
+simply returns a string containing the object type. This extends the 
+usefulness of the Printf macros. Previously, Concatenate would abort the 
+control method if a non-data object was encountered.
+
+ACPICA source code: Deployed the C "const" keyword across the source code 
+where appropriate. ACPICA BZ 732. Joerg Sonnenberger (NetBSD).
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version: 137.1K Code, 51.5K Data, 188.6K Total
+    Debug Version:     201.0K Code, 82.0K Data, 283.0K Total
+  Previous Release:
+    Non-Debug Version: 136.2K Code, 51.5K Data, 187.7K Total
+    Debug Version:     200.4K Code, 82.0K Data, 282.4K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL/Disassembler: Improved the heuristic used to determine the number of 
+arguments for an externally defined control method (a method in another 
+table). Although this is an improvement, there is no deterministic way to 
+"guess" the number of method arguments. Only the ACPI 6.0 External opcode 
+will completely solve this problem as it is deployed (automatically) in 
+newer BIOS code.
+
+iASL/Disassembler: Fixed an ordering issue for emitted External() ASL 
+statements that could cause errors when the disassembled file is 
+compiled. ACPICA BZ 1243. David Box.
+
+iASL: Fixed a regression caused by the merger of the two versions of the 
+local strtoul64. Because of a dependency on a global variable, strtoul64 
+could return an error for integers greater than a 32-bit value. ACPICA BZ 
+1260.
+
+iASL: Fixed a regression where a fault could occur for an ASL Return 
+statement if it invokes a control method that is not resolved. ACPICA BZ 
+1264.
+
+AcpiXtract: Improved input file validation: detection of binary files and 
+non-acpidump text files.
+
+----------------------------------------
+12 February 2016. Summary of changes for version 20160212:
+
+1) ACPICA kernel-resident subsystem:
+
+Implemented full support for the ACPI 6.1 specification (released in 
+January). This version of the specification is available at:  
+http://www.uefi.org/specifications
+
+Only a relatively small number of changes were required in ACPICA to 
+support ACPI 6.1, in these areas:
+- New predefined names
+- New _HID values
+- A new subtable for HEST
+- A few other header changes for new values
+
+Ensure \_SB_._INI is executed before any _REG methods are executed. There 
+appears to be existing BIOS code that relies on this behavior. Lv Zheng.
+
+Reverted a change made in version 20151218 which enabled method 
+invocations to be targets of various ASL operators (SuperName and Target 
+grammar elements). While the new behavior is supported by the ACPI 
+specification, other AML interpreters do not support this behavior and 
+never will. The ACPI specification will be updated for ACPI 6.2 to remove 
+this support. Therefore, the change was reverted to the original ACPICA 
+behavior.
+
+ACPICA now supports the GCC 6 compiler.
+
+Current Release: (Note: build changes increased sizes)
+    Non-Debug Version: 136.2K Code, 51.5K Data, 187.7K Total
+    Debug Version:     200.4K Code, 82.0K Data, 282.4K Total
+Previous Release:
+    Non-Debug Version: 102.7K Code, 28.4K Data, 131.1K Total
+    Debug Version:     200.4K Code, 81.9K Data, 282.3K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Completed full support for the ACPI 6.0 External() AML opcode. The 
+compiler emits an external AML opcode for each ASL External statement. 
+This opcode is used by the disassembler to assist with the disassembly of 
+external control methods by specifying the required number of arguments 
+for the method. AML interpreters do not use this opcode. To ensure that 
+interpreters do not even see the opcode, a block of one or more external 
+opcodes is surrounded by an "If(0)" construct. As this feature becomes 
+commonly deployed in BIOS code, the ability of disassemblers to correctly 
+disassemble AML code will be greatly improved. David Box.
+
+iASL: Implemented support for an optional cross-reference output file. 
+The -lx option will create a the cross-reference file with the suffix 
+"xrf". Three different types of cross-reference are created in this file:
+- List of object references made from within each control method
+- Invocation (caller) list for each user-defined control method
+- List of references to each non-method object in the namespace
+
+iASL: Method invocations as ASL Target operands are now disallowed and 
+flagged as errors in preparation for ACPI 6.2 (see the description of the 
+problem above).
+
+----------------------------------------
+8 January 2016. Summary of changes for version 20160108:
+
+1) ACPICA kernel-resident subsystem:
+
+Updated all ACPICA copyrights and signons to 2016: Added the 2016 
+copyright to all source code module headers and utility/tool signons. 
+This includes the standard Linux dual-license header. This affects 
+virtually every file in the ACPICA core subsystem, iASL compiler, all 
+ACPICA utilities, and the ACPICA test suite.
+
+Fixed a regression introduced in version 20151218 concerning the 
+execution of so-called module-level ASL/AML code. Namespace objects 
+created under a module-level If() construct were not properly/fully 
+entered into the namespace and could cause an interpreter fault when 
+accessed.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+Current Release:
+    Non-Debug Version: 102.7K Code, 28.4K Data, 131.1K Total
+    Debug Version:     200.4K Code, 81.9K Data, 282.4K Total
+  Previous Release:
+    Non-Debug Version: 102.6K Code, 28.4K Data, 131.0K Total
+    Debug Version:     200.3K Code, 81.9K Data, 282.3K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Fixed a problem with the compilation of the GpioIo and GpioInt resource 
+descriptors. The _PIN field name was incorrectly defined to be an array 
+of 32-bit values, but the _PIN values are in fact 16 bits each. This 
+would cause incorrect bit width warnings when using Word (16-bit) fields 
+to access the descriptors.
+
+
+----------------------------------------
+18 December 2015. Summary of changes for version 20151218:
+
+1) ACPICA kernel-resident subsystem:
+
+Implemented per-AML-table execution of "module-level code" as individual 
+ACPI tables are loaded into the namespace during ACPICA initialization. 
+In other words, any module-level code within an AML table is executed 
+immediately after the table is loaded, instead of batched and executed 
+after all of the tables have been loaded. This provides compatibility 
+with other ACPI implementations. ACPICA BZ 1219. Bob Moore, Lv Zheng, 
+David Box.
+
+To fully support the feature above, the default operation region handlers 
+for the SystemMemory, SystemIO, and PCI_Config address spaces are now 
+installed before any ACPI tables are loaded. This enables module-level 
+code to access these address spaces during the table load and module-
+level code execution phase. ACPICA BZ 1220. Bob Moore, Lv Zheng, David 
+Box.
+
+Implemented several changes to the internal _REG support in conjunction 
+with the changes above. Also, changes to the AcpiExec/AcpiNames/Examples 
+utilities for the changes above. Although these tools were changed, host 
+operating systems that simply use the default handlers for SystemMemory, 
+SystemIO, and PCI_Config spaces should not require any update. Lv Zheng.
+
+For example, in the code below, DEV1 is conditionally added to the 
+namespace by the DSDT via module-level code that accesses an operation 
+region. The SSDT references DEV1 via the Scope operator. DEV1 must be 
+created immediately after the DSDT is loaded in order for the SSDT to 
+successfully reference DEV1. Previously, this code would cause an 
+AE_NOT_EXIST exception during the load of the SSDT. Now, this code is 
+fully supported by ACPICA.
+
+    DefinitionBlock ("", "DSDT", 2, "Intel", "DSDT1", 1)
+    {
+        OperationRegion (OPR1, SystemMemory, 0x400, 32)
+        Field (OPR1, AnyAcc, NoLock, Preserve)
+        {
+            FLD1, 1
+        }
+        If (FLD1)
+        {
+            Device (\DEV1)
+            {
+            }
+        }
+    }
+    DefinitionBlock ("", "SSDT", 2, "Intel", "SSDT1", 1)
+    {
+        External (\DEV1, DeviceObj)
+        Scope (\DEV1)
+        {
+        }
+    }
+
+Fixed an AML interpreter problem where control method invocations were 
+not handled correctly when the invocation was itself a SuperName argument 
+to another ASL operator. In these cases, the method was not invoked. 
+ACPICA BZ 1002. Affects the following ASL operators that have a SuperName 
+argument:
+    Store
+    Acquire, Wait
+    CondRefOf, RefOf
+    Decrement, Increment
+    Load, Unload
+    Notify
+    Signal, Release, Reset
+    SizeOf
+
+Implemented automatic String-to-ObjectReference conversion support for 
+packages returned by predefined names (such as _DEP). A common BIOS error 
+is to add double quotes around an ObjectReference namepath, which turns 
+the reference into an unexpected string object. This support detects the 
+problem and corrects it before the package is returned to the caller that 
+invoked the method. Lv Zheng.
+
+Implemented extensions to the Concatenate operator. Concatenate now 
+accepts any type of object, it is not restricted to simply 
+Integer/String/Buffer. For objects other than these 3 basic data types, 
+the argument is treated as a string containing the name of the object 
+type. This expands the utility of Concatenate and the Printf/Fprintf 
+macros. ACPICA BZ 1222.
+
+Cleaned up the output of the ASL Debug object. The timer() value is now 
+optional and no longer emitted by default. Also, the basic data types of 
+Integer/String/Buffer are simply emitted as their values, without a data 
+type string -- since the data type is obvious from the output. ACPICA BZ 
+1221.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version: 102.6K Code, 28.4K Data, 131.0K Total
+    Debug Version:     200.3K Code, 81.9K Data, 282.3K Total
+  Previous Release:
+    Non-Debug Version: 102.0K Code, 28.3K Data, 130.3K Total
+    Debug Version:     199.6K Code, 81.8K Data, 281.4K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Fixed some issues with the ASL Include() operator. This operator 
+was incorrectly defined in the iASL parser rules, causing a new scope to 
+be opened for the code within the include file. This could lead to 
+several issues, including allowing ASL code that is technically illegal 
+and not supported by AML interpreters. Note, this does not affect the 
+related #include preprocessor operator. ACPICA BZ 1212.
+
+iASL/Disassembler: Implemented support for the ASL ElseIf operator. This 
+operator is essentially an ASL macro since there is no AML opcode 
+associated with it. The code emitted by the iASL compiler for ElseIf is 
+an Else opcode followed immediately by an If opcode. The disassembler 
+will now emit an ElseIf if it finds an Else immediately followed by an 
+If. This simplifies the decoded ASL, especially for deeply nested 
+If..Else and large Switch constructs. Thus, the disassembled code more 
+closely follows the original source ASL. ACPICA BZ 1211. Example:
+
+    Old disassembly:
+        Else
+        {
+            If (Arg0 == 0x02)
+            {
+                Local0 = 0x05
+            }
+        }
+
+    New disassembly:
+        ElseIf (Arg0 == 0x02)
+        {
+            Local0 = 0x05
+        }
+
+AcpiExec: Added support for the new module level code behavior and the 
+early region installation. This required a small change to the 
+initialization, since AcpiExec must install its own operation region 
+handlers.
+
+AcpiExec: Added support to make the debug object timer optional. Default 
+is timer disabled. This cleans up the debug object output -- the timer 
+data is rarely used.
+
+AcpiExec: Multiple ACPI tables are now loaded in the order that they 
+appear on the command line. This can be important when there are 
+interdependencies/references between the tables.
+
+iASL/Templates. Add support to generate template files with multiple 
+SSDTs within a single output file. Also added ommand line support to 
+specify the number of SSDTs (in addition to a single DSDT). ACPICA BZ 
+1223, 1225.
+
+
+----------------------------------------
+24 November 2015. Summary of changes for version 20151124:
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed a possible regression for a previous update to FADT handling. The 
+FADT no longer has a fixed table ID, causing some issues with code that 
+was hardwired to a specific ID. Lv Zheng.
+
+Fixed a problem where the method auto-serialization could interfere with 
+the current SyncLevel. This change makes the auto-serialization support 
+transparent to the SyncLevel support and management.
+
+Removed support for the _SUB predefined name in AcpiGetObjectInfo. This 
+interface is intended for early access to the namespace during the 
+initial namespace device discovery walk. The _SUB method has been seen to 
+access operation regions in some cases, causing errors because the 
+operation regions are not fully initialized.
+
+AML Debugger: Fixed some issues with the terminate/quit/exit commands 
+that can cause faults. Lv Zheng.
+
+AML Debugger: Add thread ID support so that single-step mode only applies 
+to the AML Debugger thread. This prevents runtime errors within some 
+kernels. Lv Zheng. 
+
+Eliminated extraneous warnings from AcpiGetSleepTypeData. Since the _Sx 
+methods that are invoked by this interface are optional, removed warnings 
+emitted for the case where one or more of these methods do not exist. 
+ACPICA BZ 1208, original change by Prarit Bhargava.
+
+Made a major pass through the entire ACPICA source code base to 
+standardize formatting that has diverged a bit over time. There are no 
+functional changes, but this will of course cause quite a few code 
+differences from the previous ACPICA release.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version: 102.0K Code, 28.3K Data, 130.3K Total
+    Debug Version:     199.6K Code, 81.8K Data, 281.4K Total
+  Previous Release:
+    Non-Debug Version: 101.7K Code, 27.9K Data, 129.6K Total
+    Debug Version:     199.3K Code, 81.4K Data, 280.7K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL/acpiexec/acpixtract/disassembler: Added support to allow multiple 
+definition blocks within a single ASL file and the resulting AML file. 
+Support for this type of file was also added to the various tools that 
+use binary AML files: acpiexec, acpixtract, and the AML disassembler. The 
+example code below shows two definition blocks within the same file:
+
+    DefinitionBlock ("dsdt.aml", "DSDT", 2, "Intel", "Template", 
+0x12345678)
+    {
+    }
+    DefinitionBlock ("", "SSDT", 2, "Intel", "Template", 0xABCDEF01)
+    {
+    }
+
+iASL: Enhanced typechecking for the Name() operator. All expressions for 
+the value of the named object must be reduced/folded to a single constant 
+at compile time, as per the ACPI specification (the AML definition of 
+Name()).
+
+iASL: Fixed some code indentation issues for the -ic and -ia options (C 
+and assembly headers). Now all emitted code correctly begins in column 1.
+
+iASL: Added an error message for an attempt to open a Scope() on an 
+object defined in an SSDT. The DSDT is always loaded into the namespace 
+first, so any attempt to open a Scope on an SSDT object will fail at 
+runtime.
+
+
+----------------------------------------
+30 September 2015. Summary of changes for version 20150930:
+
+1) ACPICA kernel-resident subsystem:
+
+Debugger: Implemented several changes and bug fixes to assist support for 
+the in-kernel version of the AML debugger. Lv Zheng.
+- Fix the "predefined" command for in-kernel debugger.
+- Do not enter debug command loop for the help and version commands.
+- Disallow "execute" command during execution/single-step of a method.
+
+Interpreter: Updated runtime typechecking for all operators that have 
+target operands. The operand is resolved and validated that it is legal. 
+For example, the target cannot be a non-data object such as a Device, 
+Mutex, ThermalZone, etc., as per the ACPI specification.
+
+Debugger: Fixed the double-mutex user I/O handshake to work when local 
+deadlock detection is enabled.
+
+Debugger: limited display of method locals and arguments (LocalX and 
+ArgX) to only those that have actually been initialized. This prevents 
+lines of extraneous output.
+
+Updated the definition of the NFIT table to correct the bit polarity of 
+one flag: ACPI_NFIT_MEM_ARMED --> ACPI_NFIT_MEM_NOT_ARMED
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version: 101.7K Code, 27.9K Data, 129.6K Total
+    Debug Version:     199.3K Code, 81.4K Data, 280.7K Total
+  Previous Release:
+    Non-Debug Version: 101.3K Code, 27.7K Data, 129.0K Total
+    Debug Version:     198.6K Code, 80.9K Data, 279.5K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Improved the compile-time typechecking for operands of many of the 
+ASL operators:
+
+-- Added an option to disable compiler operand/operator typechecking (-
+ot).
+
+-- For the following operators, the TermArg operands are now validated 
+when possible to be Integer data objects: BankField, OperationRegion, 
+DataTableRegion, Buffer, and Package.
+
+-- Store (Source, Target): Both the source and target operands are 
+resolved and checked that the operands are both legal. For example, 
+neither operand can be a non-data object such as a Device, Mutex, 
+ThermalZone, etc. Note, as per the ACPI specification, the CopyObject 
+operator can be used to store an object to any type of target object.
+
+-- Store (Source, Target): If the source is a Package object, the target 
+must be a Package object, LocalX, ArgX, or Debug. Likewise, if the target 
+is a Package, the source must also be a Package.
+
+-- Store (Source, Target): A warning is issued if the source and target 
+resolve to the identical named object.
+
+-- Store (Source, <method invocation>): An error is generated for the 
+target method invocation, as this construct is not supported by the AML 
+interpreter.
+
+-- For all ASL math and logic operators, the target operand must be a 
+data object (Integer, String, Buffer, LocalX, ArgX, or Debug). This 
+includes the function return value also.
+
+-- External declarations are also included in the typechecking where 
+possible. External objects defined using the UnknownObj keyword cannot be 
+typechecked, however.
+
+iASL and Disassembler: Added symbolic (ASL+) support for the ASL Index 
+operator:
+- Legacy code: Index(PKG1, 3)
+- New ASL+ code: PKG1[3]
+This completes the ACPI 6.0 ASL+ support as it was the only operator not 
+supported.
+
+iASL: Fixed the file suffix for the preprocessor output file (.i). Two 
+spaces were inadvertently appended to the filename, causing file access 
+and deletion problems on some systems.
+
+ASL Test Suite (ASLTS): Updated the master makefile to generate all 
+possible compiler output files when building the test suite -- thus 
+exercising these features of the compiler. These files are automatically 
+deleted when the test suite exits.
+
+
+----------------------------------------
+18 August 2015. Summary of changes for version 20150818:
+
+1) ACPICA kernel-resident subsystem:
+
+Fix a regression for AcpiGetTableByIndex interface causing it to fail. Lv 
+Zheng. ACPICA BZ 1186.
+
+Completed development to ensure that the ACPICA Disassembler and Debugger 
+are fully standalone components of ACPICA. Removed cross-component 
+dependences. Lv Zheng.
+
+The max-number-of-AML-loops is now runtime configurable (previously was 
+compile-time only). This is essentially a loop timeout to force-abort 
+infinite AML loops. ACPCIA BZ 1192.
+
+Debugger: Cleanup output to dump ACPI names and namepaths without any 
+trailing underscores. Lv Zheng. ACPICA BZ 1135.
+
+Removed unnecessary conditional compilations across the Debugger and 
+Disassembler components where entire modules could be left uncompiled.
+
+The aapits test is deprecated and has been removed from the ACPICA git 
+tree. The test has never been completed and has not been maintained, thus 
+becoming rather useless. ACPICA BZ 1015, 794.
+
+A batch of small changes to close bugzilla and other reports:
+- Remove duplicate code for _PLD processing. ACPICA BZ 1176.
+- Correctly cleanup after a ACPI table load failure. ACPICA BZ 1185.
+- iASL: Support POSIX yacc again in makefile. Jung-uk Kim.
+- ACPI table support: general cleanup and simplification. Lv Zheng, Bob 
+Moore.
+- ACPI table support: fix for a buffer read overrun in AcpiTbFindTable. 
+ACPICA BZ 1184.
+- Enhance parameter validation for DataTableRegion and LoadTable ASL/AML 
+operators.
+- Debugger: Split debugger initialization/termination interfaces. Lv 
+Zheng.
+- AcpiExec: Emit OemTableId for SSDTs during the load phase for table 
+identification.
+- AcpiExec: Add debug message during _REG method phase during table 
+load/init.
+- AcpiNames: Fix a regression where some output was missing and no longer 
+emitted.
+- Debugger: General cleanup and simplification. Lv Zheng.
+- Disassembler: Cleanup use of several global option variables. Lv Zheng.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version: 101.3K Code, 27.7K Data, 129.0K Total
+    Debug Version:     198.6K Code, 80.9K Data, 279.5K Total
+  Previous Release:
+    Non-Debug Version: 100.9K Code, 24.5K Data, 125.4K Total
+    Debug Version:     197.8K Code, 81.5K Data, 279.3K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+AcpiExec: Fixed a problem where any more than 32 ACPI tables in the XSDT 
+were not handled properly and caused load errors. Now, properly invoke 
+and use the ACPICA auto-reallocate mechanism for ACPI table data 
+structures. ACPICA BZ 1188
+
+AcpiNames: Add command-line wildcard support for ACPI table files. ACPICA 
+BZ 1190.
+
+AcpiExec and AcpiNames: Add -l option to load ACPI tables only. For 
+AcpiExec, this means that no control methods (like _REG/_INI/_STA) are 
+executed during initialization. ACPICA BZ 1187, 1189.
+
+iASL/Disassembler: Implemented a prototype "listing" mode that emits AML 
+that corresponds to each disassembled ASL statement, to simplify 
+debugging. ACPICA BZ 1191.
+
+Debugger: Add option to the "objects" command to display a summary of the 
+current namespace objects (Object type and count). This is displayed if 
+the command is entered with no arguments.
+
+AcpiNames: Add -x option to specify debug level, similar to AcpiExec.
+
+
+----------------------------------------
+17 July 2015. Summary of changes for version 20150717:
+
+1) ACPICA kernel-resident subsystem:
+
+Improved the partitioning between the Debugger and Disassembler 
+components. This allows the Debugger to be used standalone within kernel 
+code without the Disassembler (which is used for single stepping also). 
+This renames and moves one file, dmobject.c to dbobject.c. Lv Zheng.
+
+Debugger: Implemented a new command to trace the execution of control 
+methods (Trace). This is especially useful for the in-kernel version of 
+the debugger when file I/O may not be available for method trace output. 
+See the ACPICA reference for more information. Lv Zheng.
+
+Moved all C library prototypes (used for the local versions of these 
+functions when requested) to a new header, acclib.h
+Cleaned up the use of non-ANSI C library functions. These functions are 
+implemented locally in ACPICA. Moved all such functions to a common 
+source file, utnonansi.c
+
+Debugger: Fixed a problem with the "!!" command (get last command 
+executed) where the debugger could enter an infinite loop and eventually 
+crash.
+
+Removed the use of local macros that were used for some of the standard C 
+library functions to automatically cast input parameters. This mostly 
+affected the is* functions where the input parameter is defined to be an 
+int. This required a few modifications to the main ACPICA source code to 
+provide casting for these functions and eliminate possible compiler 
+warnings for these parameters.
+
+Across the source code, added additional status/error checking to resolve 
+issues discovered by static source code analysis tools such as Coverity.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version: 100.9K Code, 24.5K Data, 125.4K Total
+    Debug Version:     197.8K Code, 81.5K Data, 279.3K Total
+  Previous Release:
+    Non-Debug Version: 100.6K Code, 27.6K Data, 128.2K Total
+    Debug Version:     196.2K Code, 81.0K Data, 277.2K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Fixed a regression where the device map file feature no longer 
+worked properly when used in conjunction with the disassembler. It only 
+worked properly with the compiler itself.
+
+iASL: Implemented a new warning for method LocalX variables that are set 
+but never used (similar to a C compiler such as gcc). This also applies 
+to ArgX variables that are not defined by the parent method, and are 
+instead (legally) used as local variables.
+
+iASL/Preprocessor: Finished the pass-through of line numbers from the 
+preprocessor to the compiler. This ensures that compiler errors/warnings 
+have the correct original line numbers and filenames, regardless of any 
+#include files.
+
+iASL/Preprocessor: Fixed a couple of issues with comment handling and the 
+pass-through of comments to the preprocessor output file (which becomes 
+the compiler input file). Also fixed a problem with // comments that 
+appear after a math expression.
+
+iASL: Added support for the TCPA server table to the table compiler and 
+template generator. (The client table was already previously supported)
+
+iASL/Preprocessor: Added a permanent #define of the symbol "__IASL__" to 
+identify the iASL compiler.
+
+Cleaned up the use of the macros NEGATIVE and POSITIVE which were defined 
+multiple times. The new names are ACPI_SIGN_NEGATIVE and 
+ACPI_SIGN_POSITIVE.
+
+AcpiHelp: Update to expand help messages for the iASL preprocessor 
+directives.
+
+
+----------------------------------------
+19 June 2015. Summary of changes for version 20150619:
+
+Two regressions in version 20150616 have been addressed:
+
+Fixes some problems/issues with the C library macro removal (ACPI_STRLEN, 
+etc.) This update changes ACPICA to only use the standard headers for 
+functions, or the prototypes for the local versions of the C library 
+functions. Across the source code, this required some additional casts 
+for some Clib invocations for portability. Moved all local prototypes to 
+a new file, acclib.h
+
+Fixes several problems with recent changes to the handling of the FACS 
+table that could cause some systems not to boot.
+
+
+----------------------------------------
+16 June 2015. Summary of changes for version 20150616:
+
+
+1) ACPICA kernel-resident subsystem:
+
+Across the entire ACPICA source code base, the various macros for the C 
+library functions (such as ACPI_STRLEN, etc.) have been removed and 
+replaced by the standard C library names (strlen, etc.) The original 
+purpose for these macros is no longer applicable. This simplification 
+reduces the number of macros used in the ACPICA source code 
+significantly, improving readability and maintainability.
+
+Implemented support for a new ACPI table, the OSDT. This table, the 
+"override" SDT, can be loaded directly by the host OS at boot time. It 
+enables the replacement of existing namespace objects that were installed 
+via the DSDT and/or SSDTs. The primary purpose for this is to replace 
+buggy or incorrect ASL/AML code obtained via the BIOS. The OSDT is slated 
+for inclusion in a future version of the ACPI Specification. Lv Zheng/Bob 
+Moore.
+
+Added support for systems with (improperly) two FACS tables -- a "32-bit" 
+table (via FADT 32-bit legacy field) and a "64-bit" table (via the 64-bit 
+X field). This change will support both automatically. There continues to 
+be systems found with this issue. This support requires a change to the 
+AcpiSetFirmwareWakingVector interface. Also, a public global variable has 
+been added to allow the host to select which FACS is desired 
+(AcpiGbl_Use32BitFacsAddresses). See the ACPICA reference for more 
+details Lv Zheng.
+
+Added a new feature to allow for systems that do not contain an FACS. 
+Although this is already supported on hardware-reduced platforms, the 
+feature has been extended for all platforms. The reasoning is that we do 
+not want to abort the entire ACPICA initialization just because the 
+system is seriously buggy and has no FACS.
+
+Fixed a problem where the GUID strings for NFIT tables (in acuuid.h) were 
+not correctly transcribed from the ACPI specification in ACPICA version 
+20150515.
+
+Implemented support for the _CLS object in the AcpiGetObjectInfo external 
+interface.
+
+Updated the definitions of the TCPA and TPM2 ACPI tables to the more 
+recent TCG ACPI Specification, December 14, 2014. Table disassembler and 
+compiler also updated. Note: The TCPA "server" table is not supported by 
+the disassembler/table-compiler at this time.
+
+ACPI 6.0: Added definitions for the new GIC version field in the MADT.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version: 100.6K Code, 27.6K Data, 128.2K Total
+    Debug Version:     196.2K Code, 81.0K Data, 277.2K Total
+  Previous Release:
+    Non-Debug Version:  99.9K Code, 27.5K Data, 127.4K Total
+    Debug Version:     195.2K Code, 80.8K Data, 276.0K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Disassembler: Fixed a problem with the new symbolic operator disassembler 
+where incorrect ASL code could be emitted in some cases for the "non-
+commutative" operators -- Subtract, Divide, Modulo, ShiftLeft, and 
+ShiftRight. The actual problem cases seem to be rather unusual in common 
+ASL code, however. David Box.
+
+Modified the linux version of acpidump to obtain ACPI tables from not 
+just /dev/mem (which may not exist) and /sys/firmware/acpi/tables. Lv 
+Zheng.
+
+iASL: Fixed a problem where the user preprocessor output file (.i) 
+contained extra data that was not expected. The compiler was using this 
+file as a temporary file and passed through #line directives in order to 
+keep compiler error messages in sync with the input file and line number 
+across multiple include files. The (.i) is no longer a temporary file as 
+the compiler uses a new, different file for the original purpose.
+
+iASL: Fixed a problem where comments within the original ASL source code 
+file were not passed through to the preprocessor output file, nor any 
+listing files.
+
+iASL: Fixed some issues for the handling of the "#include" preprocessor 
+directive and the similar (but not the same) "Include" ASL operator.
+
+iASL: Add support for the new OSDT in both the disassembler and compiler.
+
+iASL: Fixed a problem with the constant folding support where a Buffer 
+object could be incorrectly generated (incorrectly formed) during a 
+conversion to a Store() operator.
+
+AcpiHelp: Updated for new NFIT GUIDs, "External" AML opcode, and new 
+description text for the _REV predefined name. _REV now permanently 
+returns 2, as per the ACPI 6.0 specification.
+
+Debugger: Enhanced the output of the Debug ASL object for references 
+produced by the Index operator. For Buffers and strings, only output the 
+actual byte pointed to by the index. For packages, only print the single 
+package element decoded by the index. Previously, the entire 
+buffer/string/package was emitted.
+
+iASL/Table-compiler: Fixed a regression where the "generic" data types 
+were no longer recognized, causing errors.
+
+
+----------------------------------------
+15 May 2015. Summary of changes for version 20150515:
+
+This release implements most of ACPI 6.0 as described below.
+
+1) ACPICA kernel-resident subsystem:
+
+Implemented runtime argument checking and return value checking for all 
+new ACPI 6.0 predefined names. This includes: _BTH, _CR3, _DSD, _LPI, 
+_MTL, _PRR, _RDI, _RST, _TFP, _TSN.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  99.9K Code, 27.5K Data, 127.4K Total
+    Debug Version:     195.2K Code, 80.8K Data, 276.0K Total
+  Previous Release:
+    Non-Debug Version:  99.1K Code, 27.3K Data, 126.4K Total
+    Debug Version:     192.8K Code, 79.9K Data, 272.7K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL compiler: Added compile-time support for all new ACPI 6.0 predefined 
+names (argument count validation and return value typechecking.)
+
+iASL disassembler and table compiler: implemented support for all new 
+ACPI 6.0 tables. This includes: DRTM, IORT, LPIT, NFIT, STAO, WPBT, XENV. 
+
+iASL disassembler and table compiler: Added ACPI 6.0 changes to existing 
+tables: FADT, MADT.
+
+iASL preprocessor: Added a new directive to enable inclusion of binary 
+blobs into ASL code. The new directive is #includebuffer. It takes a 
+binary file as input and emits a named ascii buffer object into the ASL 
+code.
+
+AcpiHelp: Added support for all new ACPI 6.0 predefined names.
+
+AcpiHelp: Added a new option, -d, to display all iASL preprocessor 
+directives.
+
+AcpiHelp: Added a new option, -t, to display all known/supported ACPI 
+tables.
+
+
+----------------------------------------
+10 April 2015. Summary of changes for version 20150410:
+
+Reverted a change introduced in version 20150408 that caused
+a regression in the disassembler where incorrect operator
+symbols could be emitted.
+
+
+----------------------------------------
+08 April 2015. Summary of changes for version 20150408:
+
+
+1) ACPICA kernel-resident subsystem:
+
+Permanently set the return value for the _REV predefined name. It now 
+returns 2 (was 5). This matches other ACPI implementations. _REV will be 
+deprecated in the future, and is now defined to be 1 for ACPI 1.0, and 2 
+for ACPI 2.0 and later. It should never be used to differentiate or 
+identify operating systems.
+
+Added the "Windows 2015" string to the _OSI support. ACPICA will now 
+return TRUE to a query with this string.
+
+Fixed several issues with the local version of the printf function.
+
+Added the C99 compiler option (-std=c99) to the Unix makefiles.
+
+  Current Release:
+    Non-Debug Version:  99.9K Code, 27.4K Data, 127.3K Total
+    Debug Version:     195.2K Code, 80.7K Data, 275.9K Total
+  Previous Release:
+    Non-Debug Version:  98.8K Code, 27.3K Data, 126.1K Total
+    Debug Version:     192.1K Code, 79.8K Data, 271.9K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Implemented an enhancement to the constant folding feature to 
+transform the parse tree to a simple Store operation whenever possible:
+    Add (2, 3, X) ==> is converted to: Store (5, X)
+    X = 2 + 3     ==> is converted to: Store (5, X)
+
+Updated support for the SLIC table (Software Licensing Description Table) 
+in both the Data Table compiler and the disassembler. The SLIC table 
+support now conforms to "Microsoft Software Licensing Tables (SLIC and 
+MSDM). November 29, 2011. Copyright 2011 Microsoft". Note: Any SLIC data 
+following the ACPI header is now defined to be "Proprietary Data", and as 
+such, can only be entered or displayed as a hex data block.
+
+Implemented full support for the MSDM table as described in the document 
+above. Note: The format of MSDM is similar to SLIC. Any MSDM data 
+following the ACPI header is defined to be "Proprietary Data", and can 
+only be entered or displayed as a hex data block.
+
+Implemented the -Pn option for the iASL Table Compiler (was only 
+implemented for the ASL compiler). This option disables the iASL 
+preprocessor.
+
+Disassembler: For disassembly of Data Tables, added a comment field 
+around the Ascii equivalent data that is emitted as part of the "Raw 
+Table Data" block. This prevents the iASL Preprocessor from possible 
+confusion if/when the table is compiled.
+
+Disassembler: Added an option (-df) to force the disassembler to assume 
+that the table being disassembled contains valid AML. This feature is 
+useful for disassembling AML files that contain ACPI signatures other 
+than DSDT or SSDT (such as OEMx or other signatures).
+
+Changes for the EFI version of the tools:
+1) Fixed a build error/issue
+2) Fixed a cast warning
+
+iASL: Fixed a path issue with the __FILE__ operator by making the 
+directory prefix optional within the internal SplitInputFilename 
+function.
+
+Debugger: Removed some unused global variables.
+
+Tests: Updated the makefile for proper generation of the AAPITS suite.
+
+
+----------------------------------------
+04 February 2015. Summary of changes for version 20150204:
+
+ACPICA kernel-resident subsystem:
+
+Updated all ACPICA copyrights and signons to 2014. Added the 2014 
+copyright to all module headers and signons, including the standard Linux 
+header. This affects virtually every file in the ACPICA core subsystem, 
+iASL compiler, all ACPICA utilities, and the test suites.
+
+Events: Introduce ACPI_GPE_DISPATCH_RAW_HANDLER to fix GPE storm issues.
+A raw gpe handling mechanism was created to allow better handling of GPE
+storms that aren't easily managed by the normal handler. The raw handler
+allows disabling/renabling of the the GPE so that interrupt storms can be
+avoided in cases where events cannot be timely serviced. In this 
+scenario, handlers should use the AcpiSetGpe() API to disable/enable the 
+GPE. This API will leave the reference counts undisturbed, thereby 
+preventing unintentional clearing of the GPE when the intent in only to 
+temporarily disable it. Raw handlers allow enabling and disabling of a 
+GPE by removing GPE register locking. As such, raw handlers much provide 
+their own locks while using GPE API's to protect access to GPE data 
+structures.
+Lv Zheng
+
+Events: Always modify GPE registers under the GPE lock.
+Applies GPE lock around AcpiFinishGpe() to protect access to GPE register
+values. Reported as bug by joe.liu@apple.com.
+
+Unix makefiles: Separate option to disable optimizations and 
+_FORTIFY_SOURCE. This change removes the _FORTIFY_SOURCE flag from the 
+NOOPT disable option and creates a separate flag (NOFORTIFY) for this 
+purpose. Some toolchains may define _FORTIFY_SOURCE which leads redefined 
+errors when building ACPICA. This allows disabling the option without 
+also having to disable optimazations.
+David Box
+
+  Current Release:
+    Non-Debug Version: 101.7K Code, 27.9K Data, 129.6K Total
+    Debug Version:     199.2K Code, 82.4K Data, 281.6K Total
+
+--
+--------------------------------------
+07 November 2014. Summary of changes for version 20141107:
+
+This release is available at https://acpica.org/downloads
+
+This release introduces and implements language extensions to ASL that 
+provide support for symbolic ("C-style") operators and expressions. These 
+language extensions are known collectively as ASL+.
+
+
+1) iASL Compiler/Disassembler and Tools:
+
+Disassembler: Fixed a problem with disassembly of the UartSerialBus 
+macro. Changed "StopBitsNone" to the correct "StopBitsZero". David E. 
+Box.
+
+Disassembler: Fixed the Unicode macro support to add escape sequences. 
+All non-printable ASCII values are emitted as escape sequences, as well 
+as the standard escapes for quote and backslash. Ensures that the 
+disassembled macro can be correctly recompiled.
+
+iASL: Added Printf/Fprintf macros for formatted output. These macros are 
+translated to existing AML Concatenate and Store operations. Printf 
+writes to the ASL Debug object. Fprintf allows the specification of an 
+ASL name as the target. Only a single format specifier is required, %o, 
+since the AML interpreter dynamically converts objects to the required 
+type. David E. Box.
+
+    (old)    Store (Concatenate (Concatenate (Concatenate (Concatenate
+                 (Concatenate (Concatenate (Concatenate ("", Arg0),
+                 ": Unexpected value for "), Arg1), ", "), Arg2),
+                 " at line "), Arg3), Debug)
+
+    (new)    Printf ("%o: Unexpected value for %o, %o at line %o",
+                 Arg0, Arg1, Arg2, Arg3)
+
+    (old)    Store (Concatenate (Concatenate (Concatenate (Concatenate
+                 ("", Arg1), ": "), Arg0), " Successful"), STR1)
+
+    (new)    Fprintf (STR1, "%o: %o Successful", Arg1, Arg0)
+
+iASL: Added debug options (-bp, -bt) to dynamically prune levels of the 
+ASL parse tree before the AML code is generated. This allows blocks of 
+ASL code to be removed in order to help locate and identify problem 
+devices and/or code. David E. Box.
+
+AcpiExec: Added support (-fi) for an optional namespace object 
+initialization file. This file specifies initial values for namespace 
+objects as necessary for debugging and testing different ASL code paths 
+that may be taken as a result of BIOS options.
+
+
+2) Overview of symbolic operator support for ASL (ASL+)
+-------------------------------------------------------
+
+As an extension to the ASL language, iASL implements support for symbolic 
+(C-style) operators for math and logical expressions. This can greatly 
+simplify ASL code as well as improve both readability and 
+maintainability. These language extensions can exist concurrently with 
+all legacy ASL code and expressions.
+
+The symbolic extensions are 100% compatible with existing AML 
+interpreters, since no new AML opcodes are created. To implement the 
+extensions, the iASL compiler transforms the symbolic expressions into 
+the legacy ASL/AML equivalents at compile time.
+
+Full symbolic expressions are supported, along with the standard C 
+precedence and associativity rules.
+
+Full disassembler support for the symbolic expressions is provided, and 
+creates an automatic migration path for existing ASL code to ASL+ code 
+via the disassembly process. By default, the disassembler now emits ASL+ 
+code with symbolic expressions. An option (-dl) is provided to force the 
+disassembler to emit legacy ASL code if desired.
+
+Below is the complete list of the currently supported symbolic operators 
+with examples. See the iASL User Guide for additional information.
+
+
+ASL+ Syntax      Legacy ASL Equivalent
+-----------      ---------------------
+
+    // Math operators
+
+Z = X + Y        Add (X, Y, Z)
+Z = X - Y        Subtract (X, Y, Z)
+Z = X * Y        Multiply (X, Y, Z)
+Z = X / Y        Divide (X, Y, , Z)
+Z = X % Y        Mod (X, Y, Z)
+Z = X << Y       ShiftLeft (X, Y, Z)
+Z = X >> Y       ShiftRight (X, Y, Z)
+Z = X & Y        And (X, Y, Z)
+Z = X | Y        Or (X, Y, Z)
+Z = X ^ Y        Xor (X, Y, Z)
+Z = ~X           Not (X, Z)
+X++              Increment (X)
+X--              Decrement (X)
+
+    // Logical operators
+
+(X == Y)         LEqual (X, Y)
+(X != Y)         LNotEqual (X, Y)
+(X < Y)          LLess (X, Y)
+(X > Y)          LGreater (X, Y)
+(X <= Y)         LLessEqual (X, Y)
+(X >= Y)         LGreaterEqual (X, Y)
+(X && Y)         LAnd (X, Y)
+(X || Y)         LOr (X, Y)
+(!X)             LNot (X)
+
+    // Assignment and compound assignment operations
+
+X = Y           Store (Y, X)
+X += Y          Add (X, Y, X)
+X -= Y          Subtract (X, Y, X)
+X *= Y          Multiply (X, Y, X)
+X /= Y          Divide (X, Y, , X)
+X %= Y          Mod (X, Y, X)
+X <<= Y         ShiftLeft (X, Y, X)
+X >>= Y         ShiftRight (X, Y, X)
+X &= Y          And (X, Y, X)
+X |= Y          Or (X, Y, X)
+X ^= Y          Xor (X, Y, X)
+
+
+3) ASL+ Examples:
+-----------------
+
+Legacy ASL:
+        If (LOr (LOr (LEqual (And (R510, 0x03FB), 0x02E0), LEqual (
+            And (R520, 0x03FB), 0x02E0)), LOr (LEqual (And (R530, 
+0x03FB), 
+            0x02E0), LEqual (And (R540, 0x03FB), 0x02E0))))
+        {
+            And (MEMB, 0xFFFFFFF0, SRMB)
+            Store (MEMB, Local2)
+            Store (PDBM, Local1)
+            And (PDBM, 0xFFFFFFFFFFFFFFF9, PDBM)
+            Store (SRMB, MEMB)
+            Or (PDBM, 0x02, PDBM)
+        }
+
+ASL+ version:
+        If (((R510 & 0x03FB) == 0x02E0) ||
+            ((R520 & 0x03FB) == 0x02E0) ||
+            ((R530 & 0x03FB) == 0x02E0) || 
+            ((R540 & 0x03FB) == 0x02E0))
+        {
+            SRMB = (MEMB & 0xFFFFFFF0)
+            Local2 = MEMB
+            Local1 = PDBM
+            PDBM &= 0xFFFFFFFFFFFFFFF9
+            MEMB = SRMB
+            PDBM |= 0x02
+        }
+
+Legacy ASL:
+        Store (0x1234, Local1)
+        Multiply (Add (Add (Local1, TEST), 0x20), Local2, Local3)
+        Multiply (Local2, Add (Add (Local1, TEST), 0x20), Local3)
+        Add (Local1, Add (TEST, Multiply (0x20, Local2)), Local3)
+        Store (Index (PKG1, 0x03), Local6)
+        Store (Add (Local3, Local2), Debug)
+        Add (Local1, 0x0F, Local2)
+        Add (Local1, Multiply (Local2, Local3), Local2)
+        Multiply (Add (Add (Local1, TEST), 0x20), ToBCD (Local1), Local3)
+
+ASL+ version:
+        Local1 = 0x1234
+        Local3 = (((Local1 + TEST) + 0x20) * Local2)
+        Local3 = (Local2 * ((Local1 + TEST) + 0x20))
+        Local3 = (Local1 + (TEST + (0x20 * Local2)))
+        Local6 = Index (PKG1, 0x03)
+        Debug = (Local3 + Local2)
+        Local2 = (Local1 + 0x0F)
+        Local2 = (Local1 + (Local2 * Local3))
+        Local3 = (((Local1 + TEST) + 0x20) * ToBCD (Local1))
+
+
+----------------------------------------
+26 September 2014. Summary of changes for version 20140926:
+
+1) ACPICA kernel-resident subsystem:
+
+Updated the GPIO operation region handler interface (GeneralPurposeIo). 
+In order to support GPIO Connection objects with multiple pins, along 
+with the related Field objects, the following changes to the interface 
+have been made: The Address is now defined to be the offset in bits of 
+the field unit from the previous invocation of a Connection. It can be 
+viewed as a "Pin Number Index" into the connection resource descriptor. 
+The BitWidth is the exact bit width of the field. It is usually one bit, 
+but not always. See the ACPICA reference guide (section 8.8.6.2.1) for 
+additional information and examples.
+
+GPE support: During ACPICA/GPE initialization, ensure that all GPEs with 
+corresponding _Lxx/_Exx methods are disabled (they may have been enabled 
+by the firmware), so that they cannot fire until they are enabled via 
+AcpiUpdateAllGpes. Rafael J. Wysocki.
+
+Added a new return flag for the Event/GPE status interfaces -- 
+AcpiGetEventStatus and AcpiGetGpeStatus. The new 
+ACPI_EVENT_FLAGS_HAS_HANDLER flag is used to indicate that the event or 
+GPE currently has a handler associated with it, and can thus actually 
+affect the system. Lv Zheng.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  99.1K Code, 27.3K Data, 126.4K Total
+    Debug Version:     192.8K Code, 79.9K Data, 272.7K Total
+  Previous Release:
+    Non-Debug Version:  98.8K Code, 27.3K Data, 126.1K Total
+    Debug Version:     192.1K Code, 79.8K Data, 271.9K Total
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Fixed a memory allocation/free regression introduced in 20140828 
+that could cause the compiler to crash. This was introduced inadvertently 
+during the effort to eliminate compiler memory leaks. ACPICA BZ 1111, 
+1113.
+
+iASL: Removed two error messages that have been found to create false 
+positives, until they can be fixed and fully validated (ACPICA BZ 1112):
+1) Illegal forward reference within a method
+2) Illegal reference across two methods
+
+iASL: Implemented a new option (-lm) to create a hardware mapping file 
+that summarizes all GPIO, I2C, SPI, and UART connections. This option 
+works for both the compiler and disassembler. See the iASL compiler user 
+guide for additional information and examples (section 6.4.6).
+
+AcpiDump: Added support for the version 1 (ACPI 1.0) RSDP in addition to 
+version 2. This corrects the AE_BAD_HEADER exception seen on systems with 
+a version 1 RSDP. Lv Zheng ACPICA BZ 1097.
+
+AcpiExec: For Unix versions, don't attempt to put STDIN into raw mode 
+unless STDIN is actually a terminal. Assists with batch-mode processing. 
+ACPICA BZ 1114.
+
+Disassembler/AcpiHelp: Added another large group of recognized _HID 
+values.
+
+
+----------------------------------------
+28 August 2014. Summary of changes for version 20140828:
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed a problem related to the internal use of the Timer() operator where 
+a 64-bit divide could cause an attempted link to a double-precision math 
+library. This divide is not actually necessary, so the code was 
+restructured to eliminate it. Lv Zheng.
+
+ACPI 5.1: Added support for the runtime validation of the _DSD package 
+(similar to the iASL support).
+
+ACPI 5.1/Headers: Added support for the GICC affinity subtable to the 
+SRAT table. Hanjun Guo <hanjun.guo@linaro.org>.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  98.8K Code, 27.3K Data, 126.1K Total
+    Debug Version:     192.1K Code, 79.8K Data, 271.9K Total
+  Previous Release:
+    Non-Debug Version:  98.7K Code, 27.3K Data, 126.0K Total1
+    Debug Version:     192.0K Code, 79.7K Data, 271.7K Total
+
+2) iASL Compiler/Disassembler and Tools:
+
+AcpiExec: Fixed a problem on unix systems where the original terminal 
+state was not always properly restored upon exit. Seen when using the -v 
+option. ACPICA BZ 1104.
+
+iASL: Fixed a problem with the validation of the ranges/length within the 
+Memory24 resource descriptor. There was a boundary condition when the 
+range was equal to the (length -1) caused by the fact that these values 
+are defined in 256-byte blocks, not bytes. ACPICA BZ 1098
+
+Disassembler: Fixed a problem with the GpioInt descriptor interrupt 
+polarity 
+flags. The flags are actually 2 bits, not 1, and the "ActiveBoth" keyword 
+is 
+now supported properly.
+
+ACPI 5.1: Added the GICC affinity subtable to the SRAT table. Supported 
+in the disassembler, data table compiler, and table template generator.
+
+iASL: Added a requirement for Device() objects that one of either a _HID 
+or _ADR must exist within the scope of a Device, as per the ACPI 
+specification. Remove a similar requirement that was incorrectly in place 
+for the _DSD object.
+
+iASL: Added error detection for illegal named references within control 
+methods that would cause runtime failures. Now trapped as errors are: 1) 
+References to objects within a non-parent control method. 2) Forward 
+references (within a method) -- for control methods, AML interpreters use 
+a one-pass parse of control methods. ACPICA BZ 1008.
+
+iASL: Added error checking for dependencies related to the _PSx power 
+methods. ACPICA BZ 1029.
+1) For _PS0, one of these must exist within the same scope: _PS1, _PS2, 
+_PS3.
+2) For _PS1, _PS2, and PS3: A _PS0 object must exist within the same 
+scope.
+
+iASL and table compiler: Cleanup miscellaneous memory leaks by fully 
+deploying the existing object and string caches and adding new caches for 
+the table compiler.
+
+iASL: Split the huge parser source file into multiple subfiles to improve 
+manageability. Generation now requires the M4 macro preprocessor, which 
+is part of the Bison distribution on both unix and windows platforms.
+
+AcpiSrc: Fixed and removed all extraneous warnings generated during 
+entire ACPICA source code scan and/or conversion.
+
+
+----------------------------------------
+
+24 July 2014. Summary of changes for version 20140724: 
+
+The ACPI 5.1 specification has been released and is available at: 
+http://uefi.org/specs/access
+
+
+0) ACPI 5.1 support in ACPICA:
+
+ACPI 5.1 is fully supported in ACPICA as of this release.
+
+New predefined names. Support includes iASL and runtime ACPICA 
+validation.
+    _CCA (Cache Coherency Attribute).
+    _DSD (Device-Specific Data). David Box.
+
+Modifications to existing ACPI tables. Support includes headers, iASL 
+Data Table compiler, disassembler, and the template generator.
+    FADT - New fields and flags. Graeme Gregory.
+    GTDT - One new subtable and new fields. Tomasz Nowicki.
+    MADT - Two new subtables. Tomasz Nowicki.
+    PCCT - One new subtable.
+
+Miscellaneous.
+    New notification type for System Resource Affinity change events.
+
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed a regression introduced in 20140627 where a fault can happen during 
+the deletion of Alias AML namespace objects. The problem affected both 
+the core ACPICA and the ACPICA tools including iASL and AcpiExec.
+
+Implemented a new GPE public interface, AcpiMarkGpeForWake. Provides a 
+simple mechanism to enable wake GPEs that have no associated handler or 
+control method. Rafael Wysocki.
+
+Updated the AcpiEnableGpe interface to disallow the enable if there is no 
+handler or control method associated with the particular GPE. This will 
+help avoid meaningless GPEs and even GPE floods. Rafael Wysocki.
+
+Updated GPE handling and dispatch by disabling the GPE before clearing 
+the status bit for edge-triggered GPEs. Lv Zheng.
+
+Added Timer() support to the AML Debug object. The current timer value is 
+now displayed with each invocation of (Store to) the debug object to 
+enable simple generation of execution times for AML code (method 
+execution for example.) ACPICA BZ 1093.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  98.7K Code, 27.3K Data, 126.0K Total
+    Debug Version:     192.0K Code, 79.7K Data, 271.7K Total
+  Previous Release:
+    Non-Debug Version:  98.7K Code, 27.2K Data, 125.9K Total
+    Debug Version:     191.7K Code, 79.6K Data, 271.3K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Fixed an issue with the recently added local printf implementation, 
+concerning width/precision specifiers that could cause incorrect output. 
+Lv Zheng. ACPICA BZ 1094.
+
+Disassembler: Added support to detect buffers that contain UUIDs and 
+disassemble them to an invocation of the ToUUID operator. Also emit 
+commented descriptions of known ACPI-related UUIDs.
+
+AcpiHelp: Added support to display known ACPI-related UUIDs. New option, 
+-u. Adds three new files. 
+
+iASL: Update table compiler and disassembler for DMAR table changes that 
+were introduced in September 2013. With assistance by David Woodhouse.
+
+----------------------------------------
+27 June 2014. Summary of changes for version 20140627:
+
+1) ACPICA kernel-resident subsystem:
+
+Formatted Output: Implemented local versions of standard formatted output 
+utilities such as printf, etc. Over time, it has been discovered that 
+there are in fact many portability issues with printf, and the addition 
+of this feature will fix/prevent these issues once and for all. Some 
+known issues are summarized below:
+
+1) Output of 64-bit values is not portable. For example, UINT64 is %ull 
+for the Linux kernel and is %uI64 for some MSVC versions.
+2) Invoking printf consistently in a manner that is portable across both 
+32-bit and 64-bit platforms is difficult at best in many situations.
+3) The output format for pointers varies from system to system (leading 
+zeros especially), and leads to inconsistent output from ACPICA across 
+platforms.
+4) Certain platform-specific printf formats may conflict with ACPICA use.
+5) If there is no local C library available, ACPICA now has local support 
+for printf.
+
+-- To address these printf issues in a complete manner, ACPICA now 
+directly implements a small subset of printf format specifiers, only 
+those that it requires. Adds a new file, utilities/utprint.c. Lv Zheng.
+
+Implemented support for ACPICA generation within the EFI environment. 
+Initially, the AcpiDump utility is supported in the UEFI shell 
+environment. Lv Zheng.
+
+Added a new external interface, AcpiLogError, to improve ACPICA 
+portability. This allows the host to redirect error messages from the 
+ACPICA utilities. Lv Zheng.
+
+Added and deployed new OSL file I/O interfaces to improve ACPICA 
+portability:
+  AcpiOsOpenFile
+  AcpiOsCloseFile
+  AcpiOsReadFile
+  AcpiOsWriteFile
+  AcpiOsGetFileOffset
+  AcpiOsSetFileOffset
+There are C library implementations of these functions in the new file 
+service_layers/oslibcfs.c -- however, the functions can be implemented by 
+the local host in any way necessary. Lv Zheng.
+
+Implemented a mechanism to disable/enable ACPI table checksum validation 
+at runtime. This can be useful when loading tables very early during OS 
+initialization when it may not be possible to map the entire table in 
+order to compute the checksum. Lv Zheng.
+
+Fixed a buffer allocation issue for the Generic Serial Bus support. 
+Originally, a fixed buffer length was used. This change allows for 
+variable-length buffers based upon the protocol indicated by the field 
+access attributes. Reported by Lan Tianyu. Lv Zheng.
+
+Fixed a problem where an object detached from a namespace node was not 
+properly terminated/cleared and could cause a circular list problem if 
+reattached. ACPICA BZ 1063. David Box.
+
+Fixed a possible recursive lock acquisition in hwregs.c. Rakib Mullick.
+
+Fixed a possible memory leak in an error return path within the function 
+AcpiUtCopyIobjectToIobject. ACPICA BZ 1087. Colin Ian King.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  98.7K Code, 27.2K Data, 125.9K Total
+    Debug Version:     191.7K Code, 79.6K Data, 271.3K Total
+  Previous Release:
+    Non-Debug Version:  96.8K Code, 27.2K Data, 124.0K Total
+    Debug Version:     189.5K Code, 79.7K Data, 269.2K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Disassembler: Add dump of ASCII equivalent text within a comment at the 
+end of each line of the output for the Buffer() ASL operator.
+
+AcpiDump: Miscellaneous changes:
+  Fixed repetitive table dump in -n mode.
+  For older EFI platforms, use the ACPI 1.0 GUID during RSDP search if 
+the ACPI 2.0 GUID fails.
+
+iASL: Fixed a problem where the compiler could fault if incorrectly given 
+an acpidump output file as input. ACPICA BZ 1088. David Box.
+
+AcpiExec/AcpiNames: Fixed a problem where these utilities could fault if 
+they are invoked without any arguments.
+
+Debugger: Fixed a possible memory leak in an error return path. ACPICA BZ 
+1086. Colin Ian King.
+
+Disassembler: Cleaned up a block of code that extracts a parent Op 
+object. Added a comment that explains that the parent is guaranteed to be 
+valid in this case. ACPICA BZ 1069.
+
+
+----------------------------------------
+24 April 2014. Summary of changes for version 20140424:
+
+1) ACPICA kernel-resident subsystem:
+
+Implemented support to skip/ignore NULL address entries in the RSDT/XSDT. 
+Some of these tables are known to contain a trailing NULL entry. Lv 
+Zheng.
+
+Removed an extraneous error message for the case where there are a large 
+number of system GPEs (> 124). This was the "32-bit FADT register is too 
+long to convert to GAS struct" message, which is irrelevant for GPEs 
+since the GPEx_BLK_LEN fields of the FADT are always used instead of the 
+(limited capacity) GAS bit length. Also, several changes to ensure proper 
+support for GPE numbers > 255, where some "GPE number" fields were 8-bits 
+internally.
+
+Implemented and deployed additional configuration support for the public 
+ACPICA external interfaces. Entire classes of interfaces can now be 
+easily modified or configured out, replaced by stubbed inline functions 
+by default. Lv Zheng.
+
+Moved all public ACPICA runtime configuration globals to the public 
+ACPICA external interface file for convenience. Also, removed some 
+obsolete/unused globals. See the file acpixf.h. Lv Zheng.
+
+Documentation: Added a new section to the ACPICA reference describing the 
+maximum number of GPEs that can be supported by the FADT-defined GPEs in 
+block zero and one. About 1200 total. See section 4.4.1 of the ACPICA 
+reference.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  96.8K Code, 27.2K Data, 124.0K Total
+    Debug Version:     189.5K Code, 79.7K Data, 269.2K Total
+  Previous Release:
+    Non-Debug Version:  97.0K Code, 27.2K Data, 124.2K Total
+    Debug Version:     189.7K Code, 79.5K Data, 269.2K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL and disassembler: Add full support for the LPIT table (Low Power 
+Idle Table). Includes support in the disassembler, data table compiler, 
+and template generator.
+
+AcpiDump utility:
+1) Add option to force the use of the RSDT (over the XSDT).
+2) Improve validation of the RSDP signature (use 8 chars instead of 4).
+
+iASL: Add check for predefined packages that are too large.  For 
+predefined names that contain subpackages, check if each subpackage is 
+too large. (Check for too small already exists.)
+
+Debugger: Updated the GPE command (which simulates a GPE by executing the 
+GPE code paths in ACPICA). The GPE device is now optional, and defaults 
+to the GPE 0/1 FADT-defined blocks.
+
+Unix application OSL: Update line-editing support. Add additional error 
+checking and take care not to reset terminal attributes on exit if they 
+were never set. This should help guarantee that the terminal is always 
+left in the previous state on program exit.
+
+
+----------------------------------------
+25 March 2014. Summary of changes for version 20140325:
+
+1) ACPICA kernel-resident subsystem:
+
+Updated the auto-serialize feature for control methods. This feature 
+automatically serializes all methods that create named objects in order 
+to prevent runtime errors. The update adds support to ignore the 
+currently executing AML SyncLevel when invoking such a method, in order 
+to prevent disruption of any existing SyncLevel priorities that may exist 
+in the AML code. Although the use of SyncLevels is relatively rare, this 
+change fixes a regression where an AE_AML_MUTEX_ORDER exception can 
+appear on some machines starting with the 20140214 release.
+
+Added a new external interface to allow the host to install ACPI tables 
+very early, before the namespace is even created. AcpiInstallTable gives 
+the host additional flexibility for ACPI table management. Tables can be 
+installed directly by the host as if they had originally appeared in the 
+XSDT/RSDT. Installed tables can be SSDTs or other ACPI data tables 
+(anything except the DSDT and FACS). Adds a new file, tbdata.c, along 
+with additional internal restructuring and cleanup. See the ACPICA 
+Reference for interface details. Lv Zheng.
+
+Added validation of the checksum for all incoming dynamically loaded 
+tables (via external interfaces or via AML Load/LoadTable operators). Lv 
+Zheng.
+
+Updated the use of the AcpiOsWaitEventsComplete interface during Notify 
+and GPE handler removal. Restructured calls to eliminate possible race 
+conditions. Lv Zheng.
+
+Added a warning for the use/execution of the ASL/AML Unload (table) 
+operator. This will help detect and identify machines that use this 
+operator if and when it is ever used. This operator has never been seen 
+in the field and the usage model and possible side-effects of the drastic 
+runtime action of a full table removal are unknown.
+
+Reverted the use of #pragma push/pop which was introduced in the 20140214 
+release. It appears that push and pop are not implemented by enough 
+compilers to make the use of this feature feasible for ACPICA at this 
+time. However, these operators may be deployed in a future ACPICA 
+release.
+
+Added the missing EXPORT_SYMBOL macros for the install and remove SCI 
+handler interfaces.
+
+Source code generation:
+1) Disabled the use of the "strchr" macro for the gcc-specific 
+generation. For some versions of gcc, this macro can periodically expose 
+a compiler bug which in turn causes compile-time error(s).
+2) Added support for PPC64 compilation. Colin Ian King.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  97.0K Code, 27.2K Data, 124.2K Total
+    Debug Version:     189.7K Code, 79.5K Data, 269.2K Total
+  Previous Release:
+    Non-Debug Version:  96.5K Code, 27.2K Data, 123.7K Total
+    Debug Version:     188.6K Code, 79.0K Data, 267.6K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Disassembler: Added several new features to improve the readability of 
+the resulting ASL code. Extra information is emitted within comment 
+fields in the ASL code:
+1) Known _HID/_CID values are decoded to descriptive text.
+2) Standard values for the Notify() operator are decoded to descriptive 
+text.
+3) Target operands are expanded to full pathnames (in a comment) when 
+possible.
+
+Disassembler: Miscellaneous updates for extern() handling:
+1) Abort compiler if file specified by -fe option does not exist.
+2) Silence unnecessary warnings about argument count mismatches.
+3) Update warning messages concerning unresolved method externals.
+4) Emit "UnknownObj" keyword for externals whose type cannot be 
+determined.
+
+AcpiHelp utility:
+1) Added the -a option to display both the ASL syntax and the AML 
+encoding for an input ASL operator. This effectively displays all known 
+information about an ASL operator with one AcpiHelp invocation.
+2) Added substring match support (similar to a wildcard) for the -i 
+(_HID/PNP IDs) option.
+
+iASL/Disassembler: Since this tool does not yet support execution on big-
+endian machines, added detection of endianness and an error message if 
+execution is attempted on big-endian. Support for big-endian within iASL 
+is a feature that is on the ACPICA to-be-done list.
+
+AcpiBin utility:
+1) Remove option to extract binary files from an acpidump; this function 
+is made obsolete by the AcpiXtract utility.
+2) General cleanup of open files and allocated buffers.
+
+
+----------------------------------------
+14 February 2014. Summary of changes for version 20140214:
+
+1) ACPICA kernel-resident subsystem:
+
+Implemented a new mechanism to proactively prevent problems with ill-
+behaved reentrant control methods that create named ACPI objects. This 
+behavior is illegal as per the ACPI specification, but is nonetheless 
+frequently seen in the field. Previously, this could lead to an 
+AE_ALREADY_EXISTS exception if the method was actually entered by more 
+than one thread. This new mechanism detects such methods at table load 
+time and marks them "serialized" to prevent reentrancy. A new global 
+option, AcpiGbl_AutoSerializeMethods, has been added to disable this 
+feature if desired. This mechanism and global option obsoletes and 
+supersedes the previous AcpiGbl_SerializeAllMethods option.
+
+Added the "Windows 2013" string to the _OSI support. ACPICA will now 
+respond TRUE to _OSI queries with this string. It is the stated policy of 
+ACPICA to add new strings to the _OSI support as soon as possible after 
+they are defined. See the full ACPICA _OSI policy which has been added to 
+the utilities/utosi.c file.
+
+Hardened/updated the _PRT return value auto-repair code:
+1) Do not abort the repair on a single subpackage failure, continue to 
+check all subpackages.
+2) Add check for the minimum subpackage length (4).
+3) Properly handle extraneous NULL package elements.
+
+Added support to avoid the possibility of infinite loops when traversing 
+object linked lists. Never allow an infinite loop, even in the face of 
+corrupted object lists.
+
+ACPICA headers: Deployed the use of #pragma pack(push) and #pragma 
+pack(pop) directives to ensure that the ACPICA headers are independent of 
+compiler settings or other host headers.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  96.5K Code, 27.2K Data, 123.7K Total
+    Debug Version:     188.6K Code, 79.0K Data, 267.6K Total
+  Previous Release:
+    Non-Debug Version:  96.2K Code, 27.0K Data, 123.2K Total
+    Debug Version:     187.5K Code, 78.3K Data, 265.8K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL/Table-compiler: Fixed a problem with support for the SPMI table. The 
+first reserved field was incorrectly forced to have a value of zero. This 
+change correctly forces the field to have a value of one. ACPICA BZ 1081.
+
+Debugger: Added missing support for the "Extra" and "Data" subobjects 
+when displaying object data.
+
+Debugger: Added support to display entire object linked lists when 
+displaying object data.
+
+iASL: Removed the obsolete -g option to obtain ACPI tables from the 
+Windows registry. This feature has been superseded by the acpidump 
+utility. 
+
+
+----------------------------------------
+14 January 2014. Summary of changes for version 20140114:
+
+1) ACPICA kernel-resident subsystem:
+
+Updated all ACPICA copyrights and signons to 2014. Added the 2014 
+copyright to all module headers and signons, including the standard Linux 
+header. This affects virtually every file in the ACPICA core subsystem, 
+iASL compiler, all ACPICA utilities, and the test suites.
+
+Improved parameter validation for AcpiInstallGpeBlock. Added the 
+following checks:
+1) The incoming device handle refers to type ACPI_TYPE_DEVICE.
+2) There is not already a GPE block attached to the device.
+Likewise, with AcpiRemoveGpeBlock, ensure that the incoming object is a 
+device.
+
+Correctly support "references" in the ACPI_OBJECT. This change fixes the 
+support to allow references (namespace nodes) to be passed as arguments 
+to control methods via the evaluate object interface. This is probably 
+most useful for testing purposes, however.
+
+Improved support for 32/64 bit physical addresses in printf()-like 
+output. This change improves the support for physical addresses in printf 
+debug statements and other output on both 32-bit and 64-bit hosts. It 
+consistently outputs the appropriate number of bytes for each host. The 
+%p specifier is unsatisfactory since it does not emit uniform output on 
+all hosts/clib implementations (on some, leading zeros are not supported, 
+leading to difficult-to-read output).
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  96.2K Code, 27.0K Data, 123.2K Total
+    Debug Version:     187.5K Code, 78.3K Data, 265.8K Total
+  Previous Release:
+    Non-Debug Version:  96.1K Code, 27.0K Data, 123.1K Total
+    Debug Version:     185.6K Code, 77.3K Data, 262.9K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Fix a possible fault when using the Connection() operator. Fixes a 
+problem if the parent Field definition for the Connection operator refers 
+to an operation region that does not exist. ACPICA BZ 1064.
+
+AcpiExec: Load of local test tables is now optional. The utility has the 
+capability to load some various tables to test features of ACPICA. 
+However, there are enough of them that the output of the utility became 
+confusing. With this change, only the required local tables are displayed 
+(RSDP, XSDT, etc.) along with the actual tables loaded via the command 
+line specification. This makes the default output simler and easier to 
+understand. The -el command line option restores the original behavior 
+for testing purposes.
+
+AcpiExec: Added support for overlapping operation regions. This change 
+expands the simulation of operation regions by supporting regions that 
+overlap within the given address space. Supports SystemMemory and 
+SystemIO. ASLTS test suite updated also. David Box. ACPICA BZ 1031.
+
+AcpiExec: Added region handler support for PCI_Config and EC spaces. This 
+allows AcpiExec to simulate these address spaces, similar to the current 
+support for SystemMemory and SystemIO.
+
+Debugger: Added new command to read/write/compare all namespace objects. 
+The command "test objects" will exercise the entire namespace by writing 
+new values to each data object, and ensuring that the write was 
+successful. The original value is then restored and verified.
+
+Debugger: Added the "test predefined" command. This change makes this 
+test public and puts it under the new "test" command. The test executes 
+each and every predefined name within the current namespace.
+
+
+----------------------------------------
+18 December 2013. Summary of changes for version 20131218:
+
+Global note: The ACPI 5.0A specification was released this month. There 
+are no changes needed for ACPICA since this release of ACPI is an 
+errata/clarification release. The specification is available at 
+acpi.info. 
+
+
+1) ACPICA kernel-resident subsystem:
+
+Added validation of the XSDT root table if it is present. Some older 
+platforms contain an XSDT that is ill-formed or otherwise invalid (such 
+as containing some or all entries that are NULL pointers). This change 
+adds a new function to validate the XSDT before actually using it. If the 
+XSDT is found to be invalid, ACPICA will now automatically fall back to 
+using the RSDT instead. Original implementation by Zhao Yakui. Ported to 
+ACPICA and enhanced by Lv Zheng and Bob Moore.
+
+Added a runtime option to ignore the XSDT and force the use of the RSDT. 
+This change adds a runtime option that will force ACPICA to use the RSDT 
+instead of the XSDT (AcpiGbl_DoNotUseXsdt). Although the ACPI spec 
+requires that an XSDT be used instead of the RSDT, the XSDT has been 
+found to be corrupt or ill-formed on some machines. Lv Zheng.
+
+Added a runtime option to favor 32-bit FADT register addresses over the 
+64-bit addresses. This change adds an option to favor 32-bit FADT 
+addresses when there is a conflict between the 32-bit and 64-bit versions 
+of the same register. The default behavior is to use the 64-bit version 
+in accordance with the ACPI specification. This can now be overridden via 
+the AcpiGbl_Use32BitFadtAddresses flag. ACPICA BZ 885. Lv Zheng.
+
+During the change above, the internal "Convert FADT" and "Verify FADT" 
+functions have been merged to simplify the code, making it easier to 
+understand and maintain. ACPICA BZ 933.
+
+Improve exception reporting and handling for GPE block installation. 
+Return an actual status from AcpiEvGetGpeXruptBlock and don't clobber the 
+status when exiting AcpiEvInstallGpeBlock. ACPICA BZ 1019.
+
+Added helper macros to extract bus/segment numbers from the HEST table. 
+This change adds two macros to extract the encoded bus and segment 
+numbers from the HEST Bus field - ACPI_HEST_BUS and ACPI_HEST_SEGMENT. 
+Betty Dall <betty.dall@hp.com>
+
+Removed the unused ACPI_FREE_BUFFER macro. This macro is no longer used 
+by ACPICA. It is not a public macro, so it should have no effect on 
+existing OSV code. Lv Zheng.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  96.1K Code, 27.0K Data, 123.1K Total
+    Debug Version:     185.6K Code, 77.3K Data, 262.9K Total
+  Previous Release:
+    Non-Debug Version:  95.9K Code, 27.0K Data, 122.9K Total
+    Debug Version:     185.1K Code, 77.2K Data, 262.3K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Disassembler: Improved pathname support for emitted External() 
+statements. This change adds full pathname support for external names 
+that have been resolved internally by the inclusion of additional ACPI 
+tables (via the iASL -e option). Without this change, the disassembler 
+can emit multiple externals for the same object, or it become confused 
+when the Scope() operator is used on an external object. Overall, greatly 
+improves the ability to actually recompile the emitted ASL code when 
+objects a referenced across multiple ACPI tables. Reported by Michael 
+Tsirkin (mst@redhat.com).
+
+Tests/ASLTS: Updated functional control suite to execute with no errors. 
+David Box. Fixed several errors related to the testing of the interpreter 
+slack mode. Lv Zheng.
+
+iASL: Added support to detect names that are declared within a control 
+method, but are unused (these are temporary names that are only valid 
+during the time the method is executing). A remark is issued for these 
+cases. ACPICA BZ 1022.
+
+iASL: Added full support for the DBG2 table. Adds full disassembler, 
+table compiler, and template generator support for the DBG2 table (Debug 
+Port 2 table).
+
+iASL: Added full support for the PCCT table, update the table definition. 
+Updates the PCCT table definition in the actbl3.h header and adds table 
+compiler and template generator support.
+
+iASL: Added an option to emit only error messages (no warnings/remarks). 
+The -ve option will enable only error messages, warnings and remarks are 
+suppressed. This can simplify debugging when only the errors are 
+important, such as when an ACPI table is disassembled and there are many 
+warnings and remarks -- but only the actual errors are of real interest.
+
+Example ACPICA code (source/tools/examples): Updated the example code so 
+that it builds to an actual working program, not just example code. Added 
+ACPI tables and execution of an example control method in the DSDT. Added 
+makefile support for Unix generation.
+
+
+----------------------------------------
+15 November 2013. Summary of changes for version 20131115:
+
+This release is available at https://acpica.org/downloads
+
+
+1) ACPICA kernel-resident subsystem:
+
+Resource Manager: Fixed loop termination for the "get AML length" 
+function. The loop previously had an error termination on a NULL resource 
+pointer, which can never happen since the loop simply increments a valid 
+resource pointer. This fix changes the loop to terminate with an error on 
+an invalid end-of-buffer condition. The problem can be seen as an 
+infinite loop by callers to AcpiSetCurrentResources with an invalid or 
+corrupted resource descriptor, or a resource descriptor that is missing 
+an END_TAG descriptor. Reported by Dan Carpenter 
+<dan.carpenter@oracle.com>. Lv Zheng, Bob Moore.
+
+Table unload and ACPICA termination: Delete all attached data objects 
+during namespace node deletion. This fix updates namespace node deletion 
+to delete the entire list of attached objects (attached via 
+AcpiAttachObject) instead of just one of the attached items. ACPICA BZ 
+1024. Tomasz Nowicki (tomasz.nowicki@linaro.org).
+
+ACPICA termination: Added support to delete all objects attached to the 
+root namespace node. This fix deletes any and all objects that have been 
+attached to the root node via AcpiAttachData. Previously, none of these 
+objects were deleted. Reported by Tomasz Nowicki. ACPICA BZ 1026.
+
+Debug output: Do not emit the function nesting level for the in-kernel 
+build. The nesting level is really only useful during a single-thread 
+execution. Therefore, only enable this output for the AcpiExec utility. 
+Also, only emit the thread ID when executing under AcpiExec (Context 
+switches are still always detected and a message is emitted). ACPICA BZ 
+972.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  95.9K Code, 27.0K Data, 122.9K Total
+    Debug Version:     185.1K Code, 77.2K Data, 262.3K Total
+  Previous Release:
+    Non-Debug Version:  95.8K Code, 27.0K Data, 122.8K Total
+    Debug Version:     185.2K Code, 77.2K Data, 262.4K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+AcpiExec/Unix-OSL: Use <termios.h> instead of <termio.h>. This is the 
+correct portable POSIX header for terminal control functions.
+
+Disassembler: Fixed control method invocation issues related to the use 
+of the CondRefOf() operator. The problem is seen in the disassembly where 
+control method invocations may not be disassembled properly if the 
+control method name has been used previously as an argument to CondRefOf. 
+The solution is to not attempt to emit an external declaration for the 
+CondRefOf target (it is not necessary in the first place). This prevents 
+disassembler object type confusion. ACPICA BZ 988.
+
+Unix Makefiles: Added an option to disable compiler optimizations and the 
+_FORTIFY_SOURCE flag. Some older compilers have problems compiling ACPICA 
+with optimizations (reportedly, gcc 4.4 for example). This change adds a 
+command line option for make (NOOPT) that disables all compiler 
+optimizations and the _FORTIFY_SOURCE compiler flag. The default 
+optimization is -O2 with the _FORTIFY_SOURCE flag specified. ACPICA BZ 
+1034. Lv Zheng, Bob Moore.
+
+Tests/ASLTS: Added options to specify individual test cases and modes. 
+This allows testers running aslts.sh to optionally specify individual 
+test modes and test cases. Also added an option to disable the forced 
+generation of the ACPICA tools from source if desired. Lv Zheng.
+
+----------------------------------------
+27 September 2013. Summary of changes for version 20130927:
+
+This release is available at https://acpica.org/downloads
+
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed a problem with store operations to reference objects. This change 
+fixes a problem where a Store operation to an ArgX object that contained 
+a 
+reference to a field object did not complete the automatic dereference 
+and 
+then write to the actual field object. Instead, the object type of the 
+field object was inadvertently changed to match the type of the source 
+operand. The new behavior will actually write to the field object (buffer 
+field or field unit), thus matching the correct ACPI-defined behavior.
+
+Implemented support to allow the host to redefine individual OSL 
+prototypes. This change enables the host to redefine OSL prototypes found 
+in the acpiosxf.h file. This allows the host to implement OSL interfaces 
+with a macro or inlined function. Further, it allows the host to add any 
+additional required modifiers such as __iomem, __init, __exit, etc., as 
+necessary on a per-interface basis. Enables maximum flexibility for the 
+OSL interfaces. Lv Zheng.
+
+Hardcoded the access width for the FADT-defined reset register. The ACPI 
+specification requires the reset register width to be 8 bits. ACPICA now 
+hardcodes the width to 8 and ignores the FADT width value. This provides 
+compatibility with other ACPI implementations that have allowed BIOS code 
+with bad register width values to go unnoticed. Matthew Garett, Bob 
+Moore, 
+Lv Zheng.
+
+Changed the position/use of the ACPI_PRINTF_LIKE macro. This macro is 
+used 
+in the OSL header (acpiosxf). The change modifies the position of this 
+macro in each instance where it is used (AcpiDebugPrint, etc.) to avoid 
+build issues if the OSL defines the implementation of the interface to be 
+an inline stub function. Lv Zheng.
+
+Deployed a new macro ACPI_EXPORT_SYMBOL_INIT for the main ACPICA 
+initialization interfaces. This change adds a new macro for the main init 
+and terminate external interfaces in order to support hosts that require 
+additional or different processing for these functions. Changed from 
+ACPI_EXPORT_SYMBOL to ACPI_EXPORT_SYMBOL_INIT for these functions. Lv 
+Zheng, Bob Moore.
+
+Cleaned up the memory allocation macros for configurability. In the 
+common 
+case, the ACPI_ALLOCATE and related macros now resolve directly to their 
+respective AcpiOs* OSL interfaces. Two options:
+1) The ACPI_ALLOCATE_ZEROED macro uses a simple local implementation by 
+default, unless overridden by the USE_NATIVE_ALLOCATE_ZEROED define.
+2) For AcpiExec (and for debugging), the macros can optionally be 
+resolved 
+to the local ACPICA interfaces that track each allocation (local tracking 
+is used to immediately detect memory leaks).
+Lv Zheng.
+
+Simplified the configuration for ACPI_REDUCED_HARDWARE. Allows the kernel 
+to predefine this macro to either TRUE or FALSE during the system build.
+
+Replaced __FUNCTION_ with __func__ in the gcc-specific header.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  95.8K Code, 27.0K Data, 122.8K Total
+    Debug Version:     185.2K Code, 77.2K Data, 262.4K Total
+  Previous Release:
+    Non-Debug Version:  96.7K Code, 27.1K Data, 123.9K Total
+    Debug Version:     184.4K Code, 76.8K Data, 261.2K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Implemented wildcard support for the -e option. This simplifies use 
+when there are many SSDTs that must be included to resolve external 
+method 
+declarations. ACPICA BZ 1041. Example:
+    iasl -e ssdt*.dat -d dsdt.dat
+
+AcpiExec: Add history/line-editing for Unix/Linux systems. This change 
+adds a portable module that implements full history and limited line 
+editing for Unix and Linux systems. It does not use readline() due to 
+portability issues. Instead it uses the POSIX termio interface to put the 
+terminal in raw input mode so that the various special keys can be 
+trapped 
+(such as up/down-arrow for history support and left/right-arrow for line 
+editing). Uses the existing debugger history mechanism. ACPICA BZ 1036.
+
+AcpiXtract: Add support to handle (ignore) "empty" lines containing only 
+one or more spaces. This provides compatible with early or different 
+versions of the AcpiDump utility. ACPICA BZ 1044.
+
+AcpiDump: Do not ignore tables that contain only an ACPI table header. 
+Apparently, some BIOSs create SSDTs that contain an ACPI table header but 
+no other data. This change adds support to dump these tables. Any tables 
+shorter than the length of an ACPI table header remain in error (an error 
+message is emitted). Reported by Yi Li.
+
+Debugger: Echo actual command along with the "unknown command" message.
+
+----------------------------------------
+23 August 2013. Summary of changes for version 20130823:
+
+1) ACPICA kernel-resident subsystem:
+
+Implemented support for host-installed System Control Interrupt (SCI) 
+handlers. Certain ACPI functionality requires the host to handle raw 
+SCIs. For example, the "SCI Doorbell" that is defined for memory power 
+state support requires the host device driver to handle SCIs to examine 
+if the doorbell has been activated. Multiple SCI handlers can be 
+installed to allow for future expansion. New external interfaces are 
+AcpiInstallSciHandler, AcpiRemoveSciHandler; see the ACPICA reference for 
+details. Lv Zheng, Bob Moore. ACPICA BZ 1032.
+
+Operation region support: Never locally free the handler "context" 
+pointer. This change removes some dangerous code that attempts to free 
+the handler context pointer in some (rare) circumstances. The owner of 
+the handler owns this pointer and the ACPICA code should never touch it. 
+Although not seen to be an issue in any kernel, it did show up as a 
+problem (fault) under AcpiExec. Also, set the internal storage field for 
+the context pointer to zero when the region is deactivated, simply for 
+sanity. David Box. ACPICA BZ 1039.
+
+AcpiRead: On error, do not modify the return value target location. If an 
+error happens in the middle of a split 32/32 64-bit I/O operation, do not 
+modify the target of the return value pointer. Makes the code consistent 
+with the rest of ACPICA. Bjorn Helgaas.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  96.7K Code, 27.1K Data, 123.9K Total
+    Debug Version:     184.4K Code, 76.8K Data, 261.2K Total
+  Previous Release:
+    Non-Debug Version:  96.2K Code, 27.1K Data, 123.3K Total
+    Debug Version:     185.4K Code, 77.1K Data, 262.5K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+AcpiDump: Implemented several new features and fixed some problems:
+1) Added support to dump the RSDP, RSDT, and XSDT tables.
+2) Added support for multiple table instances (SSDT, UEFI).
+3) Added option to dump "customized" (overridden) tables (-c).
+4) Fixed a problem where some table filenames were improperly 
+constructed.
+5) Improved some error messages, removed some unnecessary messages.
+
+iASL: Implemented additional support for disassembly of ACPI tables that 
+contain invocations of external control methods. The -fe<file> option 
+allows the import of a file that specifies the external methods along 
+with the required number of arguments for each -- allowing for the 
+correct disassembly of the table. This is a workaround for a limitation 
+of AML code where the disassembler often cannot determine the number of 
+arguments required for an external control method and generates incorrect 
+ASL code. See the iASL reference for details. ACPICA BZ 1030.
+
+Debugger: Implemented a new command (paths) that displays the full 
+pathnames (namepaths) and object types of all objects in the namespace. 
+This is an alternative to the namespace command.
+
+Debugger: Implemented a new command (sci) that invokes the SCI dispatch 
+mechanism and any installed handlers.
+
+iASL: Fixed a possible segfault for "too many parent prefixes" condition. 
+This can occur if there are too many parent prefixes in a namepath (for 
+example, ^^^^^^PCI0.ECRD). ACPICA BZ 1035.
+
+Application OSLs: Set the return value for the PCI read functions. These 
+functions simply return AE_OK, but should set the return value to zero 
+also. This change implements this. ACPICA BZ 1038.
+
+Debugger: Prevent possible command line buffer overflow. Increase the 
+size of a couple of the debugger line buffers, and ensure that overflow 
+cannot happen. ACPICA BZ 1037.
+
+iASL: Changed to abort immediately on serious errors during the parsing 
+phase. Due to the nature of ASL, there is no point in attempting to 
+compile these types of errors, and they typically end up causing a 
+cascade of hundreds of errors which obscure the original problem.
+
+----------------------------------------
+25 July 2013. Summary of changes for version 20130725:
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed a problem with the DerefOf operator where references to FieldUnits 
+and BufferFields incorrectly returned the parent object, not the actual 
+value of the object. After this change, a dereference of a FieldUnit 
+reference results in a read operation on the field to get the value, and 
+likewise, the appropriate BufferField value is extracted from the target 
+buffer.
+
+Fixed a problem where the _WAK method could cause a fault under these 
+circumstances: 1) Interpreter slack mode was not enabled, and 2) the _WAK 
+method returned no value. The problem is rarely seen because most kernels 
+run ACPICA in slack mode.
+
+For the DerefOf operator, a fatal error now results if an attempt is made 
+to dereference a reference (created by the Index operator) to a NULL 
+package element. Provides compatibility with other ACPI implementations, 
+and this behavior will be added to a future version of the ACPI 
+specification.
+
+The ACPI Power Management Timer (defined in the FADT) is now optional. 
+This provides compatibility with other ACPI implementations and will 
+appear in the next version of the ACPI specification. If there is no PM 
+Timer on the platform, AcpiGetTimer returns AE_SUPPORT. An address of 
+zero in the FADT indicates no PM timer.
+
+Implemented a new interface for _OSI support, AcpiUpdateInterfaces. This 
+allows the host to globally enable/disable all vendor strings, all 
+feature strings, or both. Intended to be primarily used for debugging 
+purposes only. Lv Zheng.
+
+Expose the collected _OSI data to the host via a global variable. This 
+data tracks the highest level vendor ID that has been invoked by the BIOS 
+so that the host (and potentially ACPICA itself) can change behaviors 
+based upon the age of the BIOS.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  96.2K Code, 27.1K Data, 123.3K Total
+    Debug Version:     184.4K Code, 76.8K Data, 261.2K Total
+  Previous Release:
+    Non-Debug Version:  95.9K Code, 26.9K Data, 122.8K Total
+    Debug Version:     184.1K Code, 76.7K Data, 260.8K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Created the following enhancements for the -so option (create 
+offset table):
+1)Add offsets for the last nameseg in each namepath for every supported 
+object type
+2)Add support for Processor, Device, Thermal Zone, and Scope objects
+3)Add the actual AML opcode for the parent object of every supported 
+object type
+4)Add support for the ZERO/ONE/ONES AML opcodes for integer objects
+
+Disassembler: Emit all unresolved external symbols in a single block. 
+These are external references to control methods that could not be 
+resolved, and thus, the disassembler had to make a guess at the number of 
+arguments to parse.
+
+iASL: The argument to the -T option (create table template) is now 
+optional. If not specified, the default table is a DSDT, typically the 
+most common case.
+
+----------------------------------------
+26 June 2013. Summary of changes for version 20130626:
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed an issue with runtime repair of the _CST object. Null or invalid 
+elements were not always removed properly. Lv Zheng. 
+
+Removed an arbitrary restriction of 256 GPEs per GPE block (such as the 
+FADT-defined GPE0 and GPE1). For GPE0, GPE1, and each GPE Block Device, 
+the maximum number of GPEs is 1016. Use of multiple GPE block devices 
+makes the system-wide number of GPEs essentially unlimited.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  95.9K Code, 26.9K Data, 122.8K Total
+    Debug Version:     184.1K Code, 76.7K Data, 260.8K Total
+  Previous Release:
+    Non-Debug Version:  96.0K Code, 27.0K Data, 123.0K Total
+    Debug Version:     184.1K Code, 76.8K Data, 260.9K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Portable AcpiDump: Implemented full support for the Linux and FreeBSD 
+hosts. Now supports Linux, FreeBSD, and Windows.
+
+Disassembler: Added some missing types for the HEST and EINJ tables: "Set 
+Error Type With Address", "CMCI", "MCE", and "Flush Cacheline".
+
+iASL/Preprocessor: Implemented full support for nested 
+#if/#else/#elif/#endif blocks. Allows arbitrary depth of nested blocks.
+
+Disassembler: Expanded maximum output string length to 64K. Was 256 bytes 
+max. The original purpose of this constraint was to limit the amount of 
+debug output. However, the string function in question (UtPrintString) is 
+now used for the disassembler also, where 256 bytes is insufficient. 
+Reported by RehabMan@GitHub.
+
+iASL/DataTables: Fixed some problems and issues with compilation of DMAR 
+tables. ACPICA BZ 999. Lv Zheng.
+
+iASL: Fixed a couple of error exit issues that could result in a "Could 
+not delete <file>" message during ASL compilation.
+
+AcpiDump: Allow "FADT" and "MADT" as valid table signatures, even though 
+the actual signatures for these tables are "FACP" and "APIC", 
+respectively.
+
+AcpiDump: Added support for multiple UEFI tables. Only SSDT and UEFI 
+tables are allowed to have multiple instances.
+
+----------------------------------------
+17 May 2013. Summary of changes for version 20130517:
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed a regression introduced in version 20130328 for _INI methods. This 
+change fixes a problem introduced in 20130328 where _INI methods are no 
+longer executed properly because of a memory block that was not 
+initialized correctly. ACPICA BZ 1016. Tomasz Nowicki 
+<tomasz.nowicki@linaro.org>.
+
+Fixed a possible problem with the new extended sleep registers in the 
+ACPI 
+5.0 FADT. Do not use these registers (even if populated) unless the HW-
+reduced bit is set in the FADT (as per the ACPI specification). ACPICA BZ 
+1020. Lv Zheng.
+
+Implemented return value repair code for _CST predefined objects: Sort 
+the 
+list and detect/remove invalid entries. ACPICA BZ 890. Lv Zheng.
+
+Implemented a debug-only option to disable loading of SSDTs from the 
+RSDT/XSDT during ACPICA initialization. This can be useful for debugging 
+ACPI problems on some machines. Set AcpiGbl_DisableSsdtTableLoad in 
+acglobal.h - ACPICA BZ 1005. Lv Zheng.
+
+Fixed some issues in the ACPICA initialization and termination code: 
+Tomasz Nowicki <tomasz.nowicki@linaro.org>
+1) Clear events initialized flag upon event component termination. ACPICA 
+BZ 1013.
+2) Fixed a possible memory leak in GPE init error path. ACPICA BZ 1018. 
+3) Delete global lock pending lock during termination. ACPICA BZ 1012.
+4) Clear debug buffer global on termination to prevent possible multiple 
+delete. ACPICA BZ 1010.
+
+Standardized all switch() blocks across the entire source base. After 
+many 
+years, different formatting for switch() had crept in. This change makes 
+the formatting of every switch block identical. ACPICA BZ 997. Chao Guan.
+
+Split some files to enhance ACPICA modularity and configurability:
+1) Split buffer dump routines into utilities/utbuffer.c
+2) Split internal error message routines into utilities/uterror.c
+3) Split table print utilities into tables/tbprint.c
+4) Split iASL command-line option processing into asloptions.c
+
+Makefile enhancements:
+1) Support for all new files above.
+2) Abort make on errors from any subcomponent. Chao Guan.
+3) Add build support for Apple Mac OS X. Liang Qi.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  96.0K Code, 27.0K Data, 123.0K Total
+    Debug Version:     184.1K Code, 76.8K Data, 260.9K Total
+  Previous Release:
+    Non-Debug Version:  95.6K Code, 26.8K Data, 122.4K Total
+    Debug Version:     183.5K Code, 76.6K Data, 260.1K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+New utility: Implemented an easily portable version of the acpidump 
+utility to extract ACPI tables from the system (or a file) in an ASCII 
+hex 
+dump format. The top-level code implements the various command line 
+options, file I/O, and table dump routines. To port to a new host, only 
+three functions need to be implemented to get tables -- since this 
+functionality is OS-dependent. See the tools/acpidump/apmain.c module and 
+the ACPICA reference for porting instructions. ACPICA BZ 859. Notes:
+1) The Windows version obtains the ACPI tables from the Registry.
+2) The Linux version is under development.
+3) Other hosts - If an OS-dependent module is submitted, it will be 
+distributed with ACPICA.
+
+iASL: Fixed a regression for -D preprocessor option (define symbol). A 
+restructuring/change to the initialization sequence caused this option to 
+no longer work properly.
+
+iASL: Implemented a mechanism to disable specific warnings and remarks. 
+Adds a new command line option, "-vw <messageid> as well as "#pragma 
+disable <messageid>". ACPICA BZ 989. Chao Guan, Bob Moore.
+
+iASL: Fix for too-strict package object validation. The package object 
+validation for return values from the predefined names is a bit too 
+strict, it does not allow names references within the package (which will 
+be resolved at runtime.) These types of references cannot be validated at 
+compile time. This change ignores named references within package objects 
+for names that return or define static packages.
+
+Debugger: Fixed the 80-character command line limitation for the History 
+command. Now allows lines of arbitrary length. ACPICA BZ 1000. Chao Guan.
+
+iASL: Added control method and package support for the -so option 
+(generates AML offset table for BIOS support.)
+
+iASL: issue a remark if a non-serialized method creates named objects. If 
+a thread blocks within the method for any reason, and another thread 
+enters the method, the method will fail because an attempt will be made 
+to 
+create the same (named) object twice. In this case, issue a remark that 
+the method should be marked serialized. NOTE: may become a warning later. 
+ACPICA BZ 909.
+
+----------------------------------------
+18 April 2013. Summary of changes for version 20130418:
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed a possible buffer overrun during some rare but specific field unit 
+read operations. This overrun can only happen if the DSDT version is 1 -- 
+meaning that all AML integers are 32 bits -- and the field length is 
+between 33 and 55 bits long. During the read, an internal buffer object 
+is 
+created for the field unit because the field is larger than an integer 
+(32 
+bits). However, in this case, the buffer will be incorrectly written 
+beyond the end because the buffer length is less than the internal 
+minimum 
+of 64 bits (8 bytes) long. The buffer will be either 5, 6, or 7 bytes 
+long, but a full 8 bytes will be written.
+
+Updated the Embedded Controller "orphan" _REG method support. This refers 
+to _REG methods under the EC device that have no corresponding operation 
+region. This is allowed by the ACPI specification. This update removes a 
+dependency on the existence an ECDT table. It will execute an orphan _REG 
+method as long as the operation region handler for the EC is installed at 
+the EC device node and not the namespace root. Rui Zhang (original 
+update), Bob Moore (update/integrate).
+
+Implemented run-time argument typechecking for all predefined ACPI names 
+(_STA, _BIF, etc.) This change performs object typechecking on all 
+incoming arguments for all predefined names executed via 
+AcpiEvaluateObject. This ensures that ACPI-related device drivers are 
+passing correct object types as well as the correct number of arguments 
+(therefore identifying any issues immediately). Also, the ASL/namespace 
+definition of the predefined name is checked against the ACPI 
+specification for the proper argument count. Adds one new file, 
+nsarguments.c
+
+Changed an exception code for the ASL UnLoad() operator. Changed the 
+exception code for the case where the input DdbHandle is invalid, from 
+AE_BAD_PARAMETER to the more appropriate AE_AML_OPERAND_TYPE.
+
+Unix/Linux makefiles: Removed the use of the -O2 optimization flag in the 
+global makefile. The use of this flag causes compiler errors on earlier 
+versions of GCC, so it has been removed for compatibility.
+
+Miscellaneous cleanup:
+1) Removed some unused/obsolete macros
+2) Fixed a possible memory leak in the _OSI support
+3) Removed an unused variable in the predefined name support
+4) Windows OSL: remove obsolete reference to a memory list field
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Current Release:
+    Non-Debug Version:  95.2K Code, 26.4K Data, 121.6K Total
+    Debug Version:     183.0K Code, 76.0K Data, 259.0K Total
+  Previous Release:
+    Non-Debug Version:  95.6K Code, 26.8K Data, 122.4K Total
+    Debug Version:     183.5K Code, 76.6K Data, 260.1K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+AcpiExec: Added installation of a handler for the SystemCMOS address 
+space. This prevents control method abort if a method accesses this 
+space.
+
+AcpiExec: Added support for multiple EC devices, and now install EC 
+operation region handler(s) at the actual EC device instead of the 
+namespace root. This reflects the typical behavior of host operating 
+systems.
+
+AcpiExec: Updated to ensure that all operation region handlers are 
+installed before the _REG methods are executed. This prevents a _REG 
+method from aborting if it accesses an address space has no handler. 
+AcpiExec installs a handler for every possible address space.
+
+Debugger: Enhanced the "handlers" command to display non-root handlers. 
+This change enhances the handlers command to display handlers associated 
+with individual devices throughout the namespace, in addition to the 
+currently supported display of handlers associated with the root 
+namespace 
+node.
+
+ASL Test Suite: Several test suite errors have been identified and 
+resolved, reducing the total error count during execution. Chao Guan.
+
+----------------------------------------
+28 March 2013. Summary of changes for version 20130328:
+
+1) ACPICA kernel-resident subsystem:
+
+Fixed several possible race conditions with the internal object reference 
+counting mechanism. Some of the external ACPICA interfaces update object 
+reference counts without holding the interpreter or namespace lock. This 
+change adds a spinlock to protect reference count updates on the internal 
+ACPICA objects. Reported by and with assistance from Andriy Gapon 
+(avg@FreeBSD.org).
+
+FADT support: Removed an extraneous warning for very large GPE register 
+sets. This change removes a size mismatch warning if the legacy length 
+field for a GPE register set is larger than the 64-bit GAS structure can 
+accommodate. GPE register sets can be larger than the 255-bit width 
+limitation of the GAS structure. Linn Crosetto (linn@hp.com).
+
+_OSI Support: handle any errors from AcpiOsAcquireMutex. Check for error 
+return from this interface. Handles a possible timeout case if 
+ACPI_WAIT_FOREVER is modified by the host to be a value less than 
+"forever". Jung-uk Kim.
+
+Predefined name support: Add allowed/required argument type information 
+to 
+the master predefined info table. This change adds the infrastructure to 
+enable typechecking on incoming arguments for all predefined 
+methods/objects. It does not actually contain the code that will fully 
+utilize this information, this is still under development. Also condenses 
+some duplicate code for the predefined names into a new module, 
+utilities/utpredef.c
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  95.0K Code, 25.9K Data, 120.9K Total
+    Debug Version:     182.9K Code, 75.6K Data, 258.5K Total
+  Current Release:
+    Non-Debug Version:  95.2K Code, 26.4K Data, 121.6K Total
+    Debug Version:     183.0K Code, 76.0K Data, 259.0K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Implemented a new option to simplify the development of ACPI-
+related 
+BIOS code. Adds support for a new "offset table" output file. The -so 
+option will create a C table containing the AML table offsets of various 
+named objects in the namespace so that BIOS code can modify them easily 
+at 
+boot time. This can simplify BIOS runtime code by eliminating expensive 
+searches for "magic values", enhancing boot times and adding greater 
+reliability. With assistance from Lee Hamel.
+
+iASL: Allow additional predefined names to return zero-length packages. 
+Now, all predefined names that are defined by the ACPI specification to 
+return a "variable-length package of packages" are allowed to return a 
+zero length top-level package. This allows the BIOS to tell the host that 
+the requested feature is not supported, and supports existing BIOS/ASL 
+code and practices.
+
+iASL: Changed the "result not used" warning to an error. This is the case 
+where an ASL operator is effectively a NOOP because the result of the 
+operation is not stored anywhere. For example:
+    Add (4, Local0)
+There is no target (missing 3rd argument), nor is the function return 
+value used. This is potentially a very serious problem -- since the code 
+was probably intended to do something, but for whatever reason, the value 
+was not stored. Therefore, this issue has been upgraded from a warning to 
+an error.
+
+AcpiHelp: Added allowable/required argument types to the predefined names 
+info display. This feature utilizes the recent update to the predefined 
+names table (above).
+
+----------------------------------------
+14 February 2013. Summary of changes for version 20130214:
+
+1) ACPICA Kernel-resident Subsystem:
+
+Fixed a possible regression on some hosts: Reinstated the safe return 
+macros (return_ACPI_STATUS, etc.) that ensure that the argument is 
+evaluated only once. Although these macros are not needed for the ACPICA 
+code itself, they are often used by ACPI-related host device drivers 
+where 
+the safe feature may be necessary.
+
+Fixed several issues related to the ACPI 5.0 reduced hardware support 
+(SOC): Now ensure that if the platform declares itself as hardware-
+reduced 
+via the FADT, the following functions become NOOPs (and always return 
+AE_OK) because ACPI is always enabled by definition on these machines:
+  AcpiEnable
+  AcpiDisable
+  AcpiHwGetMode
+  AcpiHwSetMode
+
+Dynamic Object Repair: Implemented additional runtime repairs for 
+predefined name return values. Both of these repairs can simplify code in 
+the related device drivers that invoke these methods:
+1) For the _STR and _MLS names, automatically repair/convert an ASCII 
+string to a Unicode buffer. 
+2) For the _CRS, _PRS, and _DMA names, return a resource descriptor with 
+a 
+lone end tag descriptor in the following cases: A Return(0) was executed, 
+a null buffer was returned, or no object at all was returned (non-slack 
+mode only). Adds a new file, nsconvert.c
+ACPICA BZ 998. Bob Moore, Lv Zheng.
+
+Resource Manager: Added additional code to prevent possible infinite 
+loops 
+while traversing corrupted or ill-formed resource template buffers. Check 
+for zero-length resource descriptors in all code that loops through 
+resource templates (the length field is used to index through the 
+template). This change also hardens the external AcpiWalkResources and 
+AcpiWalkResourceBuffer interfaces.
+
+Local Cache Manager: Enhanced the main data structure to eliminate an 
+unnecessary mechanism to access the next object in the list. Actually 
+provides a small performance enhancement for hosts that use the local 
+ACPICA cache manager. Jung-uk Kim.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  94.5K Code, 25.4K Data, 119.9K Total
+    Debug Version:     182.3K Code, 75.0K Data, 257.3K Total
+  Current Release:
+    Non-Debug Version:  95.0K Code, 25.9K Data, 120.9K Total
+    Debug Version:     182.9K Code, 75.6K Data, 258.5K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL/Disassembler: Fixed several issues with the definition of the ACPI 
+5.0 RASF table (RAS Feature Table). This change incorporates late changes 
+that were made to the ACPI 5.0 specification.
+
+iASL/Disassembler: Added full support for the following new ACPI tables:
+  1) The MTMR table (MID Timer Table)
+  2) The VRTC table (Virtual Real Time Clock Table).
+Includes header file, disassembler, table compiler, and template support 
+for both tables.
+
+iASL: Implemented compile-time validation of package objects returned by 
+predefined names. This new feature validates static package objects 
+returned by the various predefined names defined to return packages. Both 
+object types and package lengths are validated, for both parent packages 
+and sub-packages, if any. The code is similar in structure and behavior 
+to 
+the runtime repair mechanism within the AML interpreter and uses the 
+existing predefined name information table. Adds a new file, aslprepkg.c. 
+ACPICA BZ 938.
+
+iASL: Implemented auto-detection of binary ACPI tables for disassembly. 
+This feature detects a binary file with a valid ACPI table header and 
+invokes the disassembler automatically. Eliminates the need to 
+specifically invoke the disassembler with the -d option. ACPICA BZ 862.
+
+iASL/Disassembler: Added several warnings for the case where there are 
+unresolved control methods during the disassembly. This can potentially 
+cause errors when the output file is compiled, because the disassembler 
+assumes zero method arguments in these cases (it cannot determine the 
+actual number of arguments without resolution/definition of the method).
+
+Debugger: Added support to display all resources with a single command. 
+Invocation of the resources command with no arguments will now display 
+all 
+resources within the current namespace.
+
+AcpiHelp: Added descriptive text for each ACPICA exception code displayed 
+via the -e option.
+
+----------------------------------------
+17 January 2013. Summary of changes for version 20130117:
+
+1) ACPICA Kernel-resident Subsystem:
+
+Updated the AcpiGetSleepTypeData interface: Allow the \_Sx methods to 
+return either 1 or 2 integers. Although the ACPI spec defines the \_Sx 
+objects to return a package containing one integer, most BIOS code 
+returns 
+two integers and the previous code reflects that. However, we also need 
+to 
+support BIOS code that actually implements to the ACPI spec, and this 
+change reflects this.
+
+Fixed two issues with the ACPI_DEBUG_PRINT macros:
+1) Added the ACPI_DO_WHILE macro to the main DEBUG_PRINT helper macro for 
+C compilers that require this support.
+2) Renamed the internal ACPI_DEBUG macro to ACPI_DO_DEBUG_PRINT since 
+ACPI_DEBUG is already used by many of the various hosts.
+
+Updated all ACPICA copyrights and signons to 2013. Added the 2013 
+copyright to all module headers and signons, including the standard Linux 
+header. This affects virtually every file in the ACPICA core subsystem, 
+iASL compiler, all ACPICA utilities, and the test suites.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  94.5K Code, 25.5K Data, 120.0K Total
+    Debug Version:     182.2K Code, 74.9K Data, 257.1K Total
+  Current Release:
+    Non-Debug Version:  94.5K Code, 25.4K Data, 119.9K Total
+    Debug Version:     182.3K Code, 75.0K Data, 257.3K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Generic Unix OSL: Use a buffer to eliminate multiple vfprintf()s and 
+prevent a possible fault on some hosts. Some C libraries modify the arg 
+pointer parameter to vfprintf making it difficult to call it twice in the 
+AcpiOsVprintf function. Use a local buffer to workaround this issue. This 
+does not affect the Windows OSL since the Win C library does not modify 
+the arg pointer. Chao Guan, Bob Moore.
+
+iASL: Fixed a possible infinite loop when the maximum error count is 
+reached. If an output file other than the .AML file is specified (such as 
+a listing file), and the maximum number of errors is reached, do not 
+attempt to flush data to the output file(s) as the compiler is aborting. 
+This can cause an infinite loop as the max error count code essentially 
+keeps calling itself.
+
+iASL/Disassembler: Added an option (-in) to ignore NOOP 
+opcodes/operators. 
+Implemented for both the compiler and the disassembler. Often, the NOOP 
+opcode is used as padding for packages that are changed dynamically by 
+the 
+BIOS. When disassembled and recompiled, these NOOPs will cause syntax 
+errors. This option causes the disassembler to ignore all NOOP opcodes 
+(0xA3), and it also causes the compiler to ignore all ASL source code 
+NOOP 
+statements as well.
+
+Debugger: Enhanced the Sleep command to execute all sleep states. This 
+change allows Sleep to be invoked with no arguments and causes the 
+debugger to execute all of the sleep states, 0-5, automatically.
+
+----------------------------------------
+20 December 2012. Summary of changes for version 20121220:
+
+1) ACPICA Kernel-resident Subsystem:
+
+Implemented a new interface, AcpiWalkResourceBuffer. This interface is an 
+alternate entry point for AcpiWalkResources and improves the usability of 
+the resource manager by accepting as input a buffer containing the output 
+of either a _CRS, _PRS, or _AEI method. The key functionality is that the 
+input buffer is not deleted by this interface so that it can be used by 
+the host later. See the ACPICA reference for details.
+
+Interpreter: Add a warning if a 64-bit constant appears in a 32-bit table 
+(DSDT version < 2). The constant will be truncated and this warning 
+reflects that behavior.
+
+Resource Manager: Add support for the new ACPI 5.0 wake bit in the IRQ, 
+ExtendedInterrupt, and GpioInt descriptors. This change adds support to 
+both get and set the new wake bit in these descriptors, separately from 
+the existing share bit. Reported by Aaron Lu.
+
+Interpreter: Fix Store() when an implicit conversion is not possible. For 
+example, in the cases such as a store of a string to an existing package 
+object, implement the store as a CopyObject(). This is a small departure 
+from the ACPI specification which states that the control method should 
+be 
+aborted in this case. However, the ASLTS suite depends on this behavior.
+
+Performance improvement for the various FUNCTION_TRACE and DEBUG_PRINT 
+macros: check if debug output is currently enabled as soon as possible to 
+minimize performance impact if debug is in fact not enabled.
+
+Source code restructuring: Cleanup to improve modularity. The following 
+new files have been added: dbconvert.c, evhandler.c, nsprepkg.c, 
+psopinfo.c, psobject.c, rsdumpinfo.c, utstring.c, and utownerid.c. 
+Associated makefiles and project files have been updated.
+
+Changed an exception code for LoadTable operator. For the case where one 
+of the input strings is too long, change the returned exception code from 
+AE_BAD_PARAMETER to AE_AML_STRING_LIMIT.
+
+Fixed a possible memory leak in dispatcher error path. On error, delete 
+the mutex object created during method mutex creation. Reported by 
+tim.gardner@canonical.com.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  94.3K Code, 25.3K Data, 119.6K Total
+    Debug Version:     175.5K Code, 74.5K Data, 250.0K Total
+  Current Release:
+    Non-Debug Version:  94.5K Code, 25.5K Data, 120.0K Total
+    Debug Version:     182.2K Code, 74.9K Data, 257.1K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Disallow a method call as argument to the ObjectType ASL operator. 
+This change tracks an errata to the ACPI 5.0 document. The AML grammar 
+will not allow the interpreter to differentiate between a method and a 
+method invocation when these are used as an argument to the ObjectType 
+operator. The ACPI specification change is to disallow a method 
+invocation 
+(UserTerm) for the ObjectType operator.
+
+Finish support for the TPM2 and CSRT tables in the headers, table 
+compiler, and disassembler.
+
+Unix user-space OSL: Fix a problem with WaitSemaphore where the timeout 
+always expires immediately if the semaphore is not available. The 
+original 
+code was using a relative-time timeout, but sem_timedwait requires the 
+use 
+of an absolute time.
+
+iASL: Added a remark if the Timer() operator is used within a 32-bit 
+table. This operator returns a 64-bit time value that will be truncated 
+within a 32-bit table.
+
+iASL Source code restructuring: Cleanup to improve modularity. The 
+following new files have been added: aslhex.c, aslxref.c, aslnamesp.c, 
+aslmethod.c, and aslfileio.c. Associated makefiles and project files have 
+been updated.
+
+
+----------------------------------------
+14 November 2012. Summary of changes for version 20121114:
+
+1) ACPICA Kernel-resident Subsystem:
+
+Implemented a performance enhancement for ACPI/AML Package objects. This 
+change greatly increases the performance of Package objects within the 
+interpreter. It changes the processing of reference counts for packages 
+by 
+optimizing for the most common case where the package sub-objects are 
+either Integers, Strings, or Buffers. Increases the overall performance 
+of 
+the ASLTS test suite by 1.5X (Increases the Slack Mode performance by 
+2X.) 
+Chao Guan. ACPICA BZ 943.
+
+Implemented and deployed common macros to extract flag bits from resource 
+descriptors. Improves readability and maintainability of the code. Fixes 
+a 
+problem with the UART serial bus descriptor for the number of data bits 
+flags (was incorrectly 2 bits, should be 3).
+
+Enhanced the ACPI_GETx and ACPI_SETx macros. Improved the implementation 
+of the macros and changed the SETx macros to the style of (destination, 
+source). Also added ACPI_CASTx companion macros. Lv Zheng.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  93.9K Code, 25.2K Data, 119.1K Total
+    Debug Version:     175.5K Code, 74.5K Data, 250.0K Total
+  Current Release:
+    Non-Debug Version:  94.3K Code, 25.3K Data, 119.6K Total
+    Debug Version:     175.5K Code, 74.5K Data, 250.0K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Disassembler: Added the new ACPI 5.0 interrupt sharing flags. This change 
+adds the ShareAndWake and ExclusiveAndWake flags which were added to the 
+Irq, Interrupt, and Gpio resource descriptors in ACPI 5.0. ACPICA BZ 986.
+
+Disassembler: Fixed a problem with external declaration generation. Fixes 
+a problem where an incorrect pathname could be generated for an external 
+declaration if the original reference to the object includes leading 
+carats (^). ACPICA BZ 984.
+
+Debugger: Completed a major update for the Disassemble<method> command. 
+This command was out-of-date and did not properly disassemble control 
+methods that had any reasonable complexity. This fix brings the command 
+up 
+to the same level as the rest of the disassembler. Adds one new file, 
+dmdeferred.c, which is existing code that is now common with the main 
+disassembler and the debugger disassemble command. ACPICA MZ 978.
+
+iASL: Moved the parser entry prototype to avoid a duplicate declaration. 
+Newer versions of Bison emit this prototype, so moved the prototype out 
+of 
+the iASL header to where it is actually used in order to avoid a 
+duplicate 
+declaration.
+
+iASL/Tools: Standardized use of the stream I/O functions:
+  1) Ensure check for I/O error after every fopen/fread/fwrite
+  2) Ensure proper order of size/count arguments for fread/fwrite
+  3) Use test of (Actual != Requested) after all fwrite, and most fread
+  4) Standardize I/O error messages
+Improves reliability and maintainability of the code. Bob Moore, Lv 
+Zheng. 
+ACPICA BZ 981.
+
+Disassembler: Prevent duplicate External() statements. During generation 
+of external statements, detect similar pathnames that are actually 
+duplicates such as these:
+  External (\ABCD)
+  External (ABCD)
+Remove all leading '\' characters from pathnames during the external 
+statement generation so that duplicates will be detected and tossed. 
+ACPICA BZ 985.
+
+Tools: Replace low-level I/O with stream I/O functions. Replace 
+open/read/write/close with the stream I/O equivalents 
+fopen/fread/fwrite/fclose for portability and performance. Lv Zheng, Bob 
+Moore.
+
+AcpiBin: Fix for the dump-to-hex function. Now correctly output the table 
+name header so that AcpiXtract recognizes the output file/table.
+
+iASL: Remove obsolete -2 option flag. Originally intended to force the 
+compiler/disassembler into an ACPI 2.0 mode, this was never implemented 
+and the entire concept is now obsolete.
+
+----------------------------------------
+18 October 2012. Summary of changes for version 20121018:
+
+
+1) ACPICA Kernel-resident Subsystem:
+
+Updated support for the ACPI 5.0 MPST table. Fixes some problems 
+introduced by late changes to the table as it was added to the ACPI 5.0 
+specification. Includes header, disassembler, and data table compiler 
+support as well as a new version of the MPST template.
+
+AcpiGetObjectInfo: Enhanced the device object support to include the ACPI 
+5.0 _SUB method. Now calls _SUB in addition to the other PNP-related ID 
+methods: _HID, _CID, and _UID.
+
+Changed ACPI_DEVICE_ID to ACPI_PNP_DEVICE_ID. Also changed 
+ACPI_DEVICE_ID_LIST to ACPI_PNP_DEVICE_ID_LIST. These changes prevent 
+name collisions on hosts that reserve the *_DEVICE_ID (or *DeviceId) 
+names for their various drivers. Affects the AcpiGetObjectInfo external 
+interface, and other internal interfaces as well.
+
+Added and deployed a new macro for ACPI_NAME management: ACPI_MOVE_NAME. 
+This macro resolves to a simple 32-bit move of the 4-character ACPI_NAME 
+on machines that support non-aligned transfers. Optimizes for this case 
+rather than using a strncpy. With assistance from Zheng Lv.
+
+Resource Manager: Small fix for buffer size calculation. Fixed a one byte 
+error in the output buffer calculation. Feng Tang. ACPICA BZ 849.
+
+Added a new debug print message for AML mutex objects that are force-
+released. At control method termination, any currently acquired mutex 
+objects are force-released. Adds a new debug-only message for each one 
+that is released.
+
+Audited/updated all ACPICA return macros and the function debug depth 
+counter: 1) Ensure that all functions that use the various TRACE macros 
+also use the appropriate ACPICA return macros. 2) Ensure that all normal 
+return statements surround the return expression (value) with parens to 
+ensure consistency across the ACPICA code base. Guan Chao, Tang Feng, 
+Zheng Lv, Bob Moore. ACPICA Bugzilla 972.
+
+Global source code changes/maintenance: All extra lines at the start and 
+end of each source file have been removed for consistency. Also, within 
+comments, all new sentences start with a single space instead of a double 
+space, again for consistency across the code base.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a much larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  93.7K Code, 25.3K Data, 119.0K Total
+    Debug Version:     175.0K Code, 74.4K Data, 249.4K Total
+  Current Release:
+    Non-Debug Version:  93.9K Code, 25.2K Data, 119.1K Total
+    Debug Version:     175.5K Code, 74.5K Data, 250.0K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+AcpiExec: Improved the algorithm used for memory leak/corruption 
+detection. Added some intelligence to the code that maintains the global 
+list of allocated memory. The list is now ordered by allocated memory 
+address, significantly improving performance. When running AcpiExec on 
+the ASLTS test suite, speed improvements of 3X to 5X are seen, depending 
+on the platform and/or the environment. Note, this performance 
+enhancement affects the AcpiExec utility only, not the kernel-resident 
+ACPICA code.
+
+Enhanced error reporting for invalid AML opcodes and bad ACPI_NAMEs. For 
+the disassembler, dump the 48 bytes surrounding the invalid opcode. Fix 
+incorrect table offset reported for invalid opcodes. Report the original 
+32-bit value for bad ACPI_NAMEs (as well as the repaired name.)
+
+Disassembler: Enhanced the -vt option to emit the binary table data in 
+hex format to assist with debugging.
+
+Fixed a potential filename buffer overflow in osunixdir.c. Increased the 
+size of file structure. Colin Ian King.
+
+----------------------------------------
+13 September 2012. Summary of changes for version 20120913:
+
+
+1) ACPICA Kernel-resident Subsystem:
+
+ACPI 5.0: Added two new notify types for the Hardware Error Notification 
+Structure within the Hardware Error Source Table (HEST) table -- CMCI(5) 
+and 
+MCE(6).
+ 
+Table Manager: Merged/removed duplicate code in the root table resize 
+functions. One function is external, the other is internal. Lv Zheng, 
+ACPICA 
+BZ 846.
+
+Makefiles: Completely removed the obsolete "Linux" makefiles under 
+acpica/generate/linux. These makefiles are obsolete and have been 
+replaced 
+by 
+the generic unix makefiles under acpica/generate/unix.
+
+Makefiles: Ensure that binary files always copied properly. Minor rule 
+change 
+to ensure that the final binary output files are always copied up to the 
+appropriate binary directory (bin32 or bin64.)
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug 
+version of the code includes the debug output trace mechanism and has a 
+much 
+larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  93.8K Code, 25.3K Data, 119.1K Total
+    Debug Version:     175.7K Code, 74.8K Data, 250.5K Total
+  Current Release:
+    Non-Debug Version:  93.7K Code, 25.3K Data, 119.0K Total
+    Debug Version:     175.0K Code, 74.4K Data, 249.4K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Disassembler: Fixed a possible fault during the disassembly of resource 
+descriptors when a second parse is required because of the invocation of 
+external control methods within the table. With assistance from 
+adq@lidskialf.net. ACPICA BZ 976.
+
+iASL: Fixed a namepath optimization problem. An error can occur if the 
+parse 
+node that contains the namepath to be optimized does not have a parent 
+node 
+that is a named object. This change fixes the problem.
+
+iASL: Fixed a regression where the AML file is not deleted on errors. The 
+AML 
+output file should be deleted if there are any errors during the 
+compiler. 
+The 
+only exception is if the -f (force output) option is used. ACPICA BZ 974.
+
+iASL: Added a feature to automatically increase internal line buffer 
+sizes. 
+Via realloc(), automatically increase the internal line buffer sizes as 
+necessary to support very long source code lines. The current version of 
+the 
+preprocessor requires a buffer long enough to contain full source code 
+lines. 
+This change increases the line buffer(s) if the input lines go beyond the 
+current buffer size. This eliminates errors that occurred when a source 
+code 
+line was longer than the buffer.
+
+iASL: Fixed a problem with constant folding in method declarations. The 
+SyncLevel term is a ByteConstExpr, and incorrect code would be generated 
+if a 
+Type3 opcode was used.
+
+Debugger: Improved command help support. For incorrect argument count, 
+display 
+full help for the command. For help command itself, allow an argument to 
+specify a command.
+
+Test Suites: Several bug fixes for the ASLTS suite reduces the number of 
+errors during execution of the suite. Guan Chao.
+
+----------------------------------------
+16 August 2012. Summary of changes for version 20120816:
+
+
+1) ACPICA Kernel-resident Subsystem:
+
+Removed all use of the deprecated _GTS and _BFS predefined methods. The 
+_GTS 
+(Going To Sleep) and _BFS (Back From Sleep) methods are essentially 
+deprecated and will probably be removed from the ACPI specification. 
+Windows 
+does not invoke them, and reportedly never will. The final nail in the 
+coffin 
+is that the ACPI specification states that these methods must be run with 
+interrupts off, which is not going to happen in a kernel interpreter. 
+Note: 
+Linux has removed all use of the methods also. It was discovered that 
+invoking these functions caused failures on some machines, probably 
+because 
+they were never tested since Windows does not call them. Affects two 
+external 
+interfaces, AcpiEnterSleepState and AcpiLeaveSleepStatePrep. Tang Feng. 
+ACPICA BZ 969.
+
+Implemented support for complex bit-packed buffers returned from the _PLD 
+(Physical Location of Device) predefined method. Adds a new external 
+interface, AcpiDecodePldBuffer that parses the buffer into a more usable 
+C 
+structure. Note: C Bitfields cannot be used for this type of predefined 
+structure since the memory layout of individual bitfields is not defined 
+by 
+the C language. In addition, there are endian concerns where a compiler 
+will 
+change the bitfield ordering based on the machine type. The new ACPICA 
+interface eliminates these issues, and should be called after _PLD is 
+executed. ACPICA BZ 954.
+
+Implemented a change to allow a scope change to root (via "Scope (\)") 
+during 
+execution of module-level ASL code (code that is executed at table load 
+time.) Lin Ming.
+
+Added the Windows8/Server2012 string for the _OSI method. This change 
+adds 
+a 
+new _OSI string, "Windows 2012" for both Windows 8 and Windows Server 
+2012.
+
+Added header support for the new ACPI tables DBG2 (Debug Port Table Type 
+2) 
+and CSRT (Core System Resource Table).
+
+Added struct header support for the _FDE, _GRT, _GTM, and _SRT predefined 
+names. This simplifies access to the buffers returned by these predefined 
+names. Adds a new file, include/acbuffer.h. ACPICA BZ 956.
+
+GPE support: Removed an extraneous parameter from the various low-level 
+internal GPE functions. Tang Feng.
+
+Removed the linux makefiles from the unix packages. The generate/linux 
+makefiles are obsolete and have been removed from the unix tarball 
+release 
+packages. The replacement makefiles are under generate/unix, and there is 
+a 
+top-level makefile under the main acpica directory. ACPICA BZ 967, 912.
+
+Updates for Unix makefiles:
+1) Add -D_FORTIFY_SOURCE=2 for gcc generation. Arjan van de Ven.
+2) Update linker flags (move to end of command line) for AcpiExec 
+utility. 
+Guan Chao.
+
+Split ACPICA initialization functions to new file, utxfinit.c. Split from 
+utxface.c to improve modularity and reduce file size.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a 
+much larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  93.5K Code, 25.3K Data, 118.8K Total
+    Debug Version:     173.7K Code, 74.0K Data, 247.7K Total
+  Current Release:
+    Non-Debug Version:  93.8K Code, 25.3K Data, 119.1K Total
+    Debug Version:     175.7K Code, 74.8K Data, 250.5K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Fixed a problem with constant folding for fixed-length constant 
+expressions. The constant-folding code was not being invoked for constant 
+expressions that allow the use of type 3/4/5 opcodes to generate 
+constants 
+for expressions such as ByteConstExpr, WordConstExpr, etc. This could 
+result 
+in the generation of invalid AML bytecode. ACPICA BZ 970.
+
+iASL: Fixed a generation issue on newer versions of Bison. Newer versions 
+apparently automatically emit some of the necessary externals. This 
+change 
+handles these versions in order to eliminate generation warnings.
+
+Disassembler: Added support to decode the DBG2 and CSRT ACPI tables.
+
+Disassembler: Add support to decode _PLD buffers. The decoded buffer 
+appears 
+within comments in the output file.
+
+Debugger: Fixed a regression with the "Threads" command where 
+AE_BAD_PARAMETER was always returned.
+
+----------------------------------------
+11 July 2012. Summary of changes for version 20120711:
+
+1) ACPICA Kernel-resident Subsystem:
+
+Fixed a possible fault in the return package object repair code. Fixes a 
+problem that can occur when a lone package object is wrapped with an 
+outer 
+package object in order to force conformance to the ACPI specification. 
+Can 
+affect these predefined names: _ALR, _MLS, _PSS, _TRT, _TSS, _PRT, _HPX, 
+_DLM, 
+_CSD, _PSD, _TSD.
+
+Removed code to disable/enable bus master arbitration (ARB_DIS bit in the 
+PM2_CNT register) in the ACPICA sleep/wake interfaces. Management of the 
+ARB_DIS bit must be implemented in the host-dependent C3 processor power 
+state 
+support. Note, ARB_DIS is obsolete and only applies to older chipsets, 
+both 
+Intel and other vendors. (for Intel: ICH4-M and earlier)
+
+This change removes the code to disable/enable bus master arbitration 
+during 
+suspend/resume. Use of the ARB_DIS bit in the optional PM2_CNT register 
+causes 
+resume problems on some machines. The change has been in use for over 
+seven 
+years within Linux.
+
+Implemented two new external interfaces to support host-directed dynamic 
+ACPI 
+table load and unload. They are intended to simplify the host 
+implementation 
+of hot-plug support:
+  AcpiLoadTable: Load an SSDT from a buffer into the namespace.
+  AcpiUnloadParentTable: Unload an SSDT via a named object owned by the 
+table.
+See the ACPICA reference for additional details. Adds one new file, 
+components/tables/tbxfload.c
+
+Implemented and deployed two new interfaces for errors and warnings that 
+are 
+known to be caused by BIOS/firmware issues:
+  AcpiBiosError: Prints "ACPI Firmware Error" message.
+  AcpiBiosWarning: Prints "ACPI Firmware Warning" message.
+Deployed these new interfaces in the ACPICA Table Manager code for ACPI 
+table 
+and FADT errors. Additional deployment to be completed as appropriate in 
+the 
+future. The associated conditional macros are ACPI_BIOS_ERROR and 
+ACPI_BIOS_WARNING. See the ACPICA reference for additional details. 
+ACPICA 
+BZ 
+843.
+
+Implicit notify support: ensure that no memory allocation occurs within a 
+critical region. This fix moves a memory allocation outside of the time 
+that a 
+spinlock is held. Fixes issues on systems that do not allow this 
+behavior. 
+Jung-uk Kim.
+
+Split exception code utilities and tables into a new file, 
+utilities/utexcep.c
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug 
+version of the code includes the debug output trace mechanism and has a 
+much 
+larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  93.1K Code, 25.1K Data, 118.2K Total
+    Debug Version:     172.9K Code, 73.6K Data, 246.5K Total
+  Current Release:
+    Non-Debug Version:  93.5K Code, 25.3K Data, 118.8K Total
+    Debug Version:     173.7K Code, 74.0K Data, 247.7K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Fixed a parser problem for hosts where EOF is defined as -1 instead 
+of 
+0. Jung-uk Kim.
+
+Debugger: Enhanced the "tables" command to emit additional information 
+about 
+the current set of ACPI tables, including the owner ID and flags decode.
+
+Debugger: Reimplemented the "unload" command to use the new 
+AcpiUnloadParentTable external interface. This command was disable 
+previously 
+due to need for an unload interface.
+
+AcpiHelp: Added a new option to decode ACPICA exception codes. The -e 
+option 
+will decode 16-bit hex status codes (ACPI_STATUS) to name strings.
+
+----------------------------------------
+20 June 2012. Summary of changes for version 20120620:
+
+
+1) ACPICA Kernel-resident Subsystem:
+
+Implemented support to expand the "implicit notify" feature to allow 
+multiple 
+devices to be notified by a single GPE. This feature automatically 
+generates a 
+runtime device notification in the absence of a BIOS-provided GPE control 
+method (_Lxx/_Exx) or a host-installed handler for the GPE. Implicit 
+notify is 
+provided by ACPICA for Windows compatibility, and is a workaround for 
+BIOS 
+AML 
+code errors. See the description of the AcpiSetupGpeForWake interface in 
+the 
+APCICA reference. Bob Moore, Rafael Wysocki. ACPICA BZ 918.
+
+Changed some comments and internal function names to simplify and ensure 
+correctness of the Linux code translation. No functional changes.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug 
+version of the code includes the debug output trace mechanism and has a 
+much 
+larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  93.0K Code, 25.1K Data, 118.1K Total
+    Debug Version:     172.7K Code, 73.6K Data, 246.3K Total
+  Current Release:
+    Non-Debug Version:  93.1K Code, 25.1K Data, 118.2K Total
+    Debug Version:     172.9K Code, 73.6K Data, 246.5K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+Disassembler: Added support to emit short, commented descriptions for the 
+ACPI 
+predefined names in order to improve the readability of the disassembled 
+output. ACPICA BZ 959. Changes include:
+  1) Emit descriptions for all standard predefined names (_INI, _STA, 
+_PRW, 
+etc.)
+  2) Emit generic descriptions for the special names (_Exx, _Qxx, etc.)
+  3) Emit descriptions for the resource descriptor names (_MIN, _LEN, 
+etc.)
+
+AcpiSrc: Fixed several long-standing Linux code translation issues. 
+Argument 
+descriptions in function headers are now translated properly to lower 
+case 
+and 
+underscores. ACPICA BZ 961. Also fixes translation problems such as 
+these: 
+(old -> new)
+  i_aSL -> iASL
+  00-7_f -> 00-7F
+  16_k -> 16K
+  local_fADT -> local_FADT
+  execute_oSI -> execute_OSI
+
+iASL: Fixed a problem where null bytes were inadvertently emitted into 
+some 
+listing files.
+
+iASL: Added the existing debug options to the standard help screen. There 
+are 
+no longer two different help screens. ACPICA BZ 957.
+
+AcpiHelp: Fixed some typos in the various predefined name descriptions. 
+Also 
+expand some of the descriptions where appropriate.
+
+iASL: Fixed the -ot option (display compile times/statistics). Was not 
+working 
+properly for standard output; only worked for the debug file case.
+
+----------------------------------------
+18 May 2012. Summary of changes for version 20120518:
+
+
+1) ACPICA Core Subsystem:
+
+Added a new OSL interface, AcpiOsWaitEventsComplete. This interface is 
+defined 
+to block until asynchronous events such as notifies and GPEs have 
+completed. 
+Within ACPICA, it is only called before a notify or GPE handler is 
+removed/uninstalled. It also may be useful for the host OS within related 
+drivers such as the Embedded Controller driver. See the ACPICA reference 
+for 
+additional information. ACPICA BZ 868.
+
+ACPI Tables: Added a new error message for a possible overflow failure 
+during 
+the conversion of FADT 32-bit legacy register addresses to internal 
+common 
+64-
+bit GAS structure representation. The GAS has a one-byte "bit length" 
+field, 
+thus limiting the register length to 255 bits. ACPICA BZ 953.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug 
+version of the code includes the debug output trace mechanism and has a 
+much 
+larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  92.9K Code, 25.0K Data, 117.9K Total
+    Debug Version:     172.6K Code, 73.4K Data, 246.0K Total
+  Current Release:
+    Non-Debug Version:  93.0K Code, 25.1K Data, 118.1K Total
+    Debug Version:     172.7K Code, 73.6K Data, 246.3K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Added the ACPI 5.0 "PCC" keyword for use in the Register() ASL 
+macro. 
+This keyword was added late in the ACPI 5.0 release cycle and was not 
+implemented until now.
+
+Disassembler: Added support for Operation Region externals. Adds missing 
+support for operation regions that are defined in another table, and 
+referenced locally via a Field or BankField ASL operator. Now generates 
+the 
+correct External statement.
+
+Disassembler: Several additional fixes for the External() statement 
+generation 
+related to some ASL operators. Also, order the External() statements 
+alphabetically in the disassembler output. Fixes the External() 
+generation 
+for 
+the Create* field, Alias, and Scope operators:
+ 1) Create* buffer field operators - fix type mismatch warning on 
+disassembly
+ 2) Alias - implement missing External support
+ 3) Scope - fix to make sure all necessary externals are emitted.
+
+iASL: Improved pathname support. For include files, merge the prefix 
+pathname 
+with the file pathname and eliminate unnecessary components. Convert 
+backslashes in all pathnames to forward slashes, for readability. Include 
+file 
+pathname changes affect both #include and Include() type operators.
+
+iASL/DTC/Preprocessor: Gracefully handle early EOF. Handle an EOF at the 
+end 
+of a valid line by inserting a newline and then returning the EOF during 
+the 
+next call to GetNextLine. Prevents the line from being ignored due to EOF 
+condition.
+
+iASL: Implemented some changes to enhance the IDE support (-vi option.) 
+Error 
+and Warning messages are now correctly recognized for both the source 
+code 
+browser and the global error and warning counts.
+
+----------------------------------------
+20 April 2012. Summary of changes for version 20120420:
+
+
+1) ACPICA Core Subsystem:
+
+Implemented support for multiple notify handlers. This change adds 
+support 
+to 
+allow multiple system and device notify handlers on Device, Thermal Zone, 
+and 
+Processor objects. This can simplify the host OS notification 
+implementation. 
+Also re-worked and restructured the entire notify support code to 
+simplify 
+handler installation, handler removal, notify event queuing, and notify 
+dispatch to handler(s). Note: there can still only be two global notify 
+handlers - one for system notifies and one for device notifies. There are 
+no 
+changes to the existing handler install/remove interfaces. Lin Ming, Bob 
+Moore, Rafael Wysocki.
+
+Fixed a regression in the package repair code where the object reference 
+count was calculated incorrectly. Regression was introduced in the commit 
+"Support to add Package wrappers".
+
+Fixed a couple possible memory leaks in the AML parser, in the error 
+recovery 
+path. Jesper Juhl, Lin Ming.
+
+Example Code and Data Size: These are the sizes for the OS-independent 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug version of the code includes the debug output trace mechanism and 
+has a 
+much larger code and data size.
+
+  Previous Release:
+    Non-Debug Version:  92.9K Code, 25.0K Data, 117.9K Total
+    Debug Version:     172.5K Code, 73.2K Data, 245.7K Total
+  Current Release:
+    Non-Debug Version:  92.9K Code, 25.0K Data, 117.9K Total
+    Debug Version:     172.6K Code, 73.4K Data, 246.0K Total
+
+
+2) iASL Compiler/Disassembler and Tools:
+
+iASL: Fixed a problem with the resource descriptor support where the 
+length 
+of the StartDependentFn and StartDependentFnNoPrio descriptors were not 
+included in cumulative descriptor offset, resulting in incorrect values 
+for 
+resource tags within resource descriptors appearing after a 
+StartDependent* 
+descriptor. Reported by Petr Vandrovec. ACPICA BZ 949.
+
+iASL and Preprocessor: Implemented full support for the #line directive 
+to 
+correctly track original source file line numbers through the .i 
+preprocessor 
+output file - for error and warning messages.
+
+iASL: Expand the allowable byte constants for address space IDs. 
+Previously, 
+the allowable range was 0x80-0xFF (user-defined spaces), now the range is 
+0x0A-0xFF to allow for custom and new IDs without changing the compiler.
+
+iASL: Add option to treat all warnings as errors (-we). ACPICA BZ 948.
+
+iASL: Add option to completely disable the preprocessor (-Pn).
+
+iASL: Now emit all error/warning messages to standard error (stderr) by 
+default (instead of the previous stdout).
+
+ASL Test Suite (ASLTS): Reduce iASL warnings due to use of Switch(). 
+Update 
+for resource descriptor offset fix above. Update/cleanup error output 
+routines. Enable and send iASL errors/warnings to an error logfile 
+(error.txt). Send all other iASL output to a logfile (compiler.txt). 
+Fixed 
+several extraneous "unrecognized operator" messages.
+
 ----------------------------------------
 20 March 2012. Summary of changes for version 20120320:
 
-This release is available at www.acpica.org/downloads.
-The ACPI 5.0 specification is available at www.acpi.info.
 
 1) ACPICA Core Subsystem:
 
 Enhanced the sleep/wake interfaces to optionally execute the _GTS method 
-(Going To Sleep) and the _BFS method (Back From Sleep). Windows apparently 
+(Going To Sleep) and the _BFS method (Back From Sleep). Windows 
+apparently 
 does not execute these methods, and therefore these methods are often 
 untested. It has been seen on some systems where the execution of these 
-methods causes errors and also prevents the machine from entering S5. It is 
-therefore suggested that host operating systems do not execute these methods 
-by default. In the future, perhaps these methods can be optionally executed 
-based on the age of the system and/or what is the newest version of Windows 
-that the BIOS asks for via _OSI. Changed interfaces: AcpiEnterSleepState and 
+methods causes errors and also prevents the machine from entering S5. It 
+is 
+therefore suggested that host operating systems do not execute these 
+methods 
+by default. In the future, perhaps these methods can be optionally 
+executed 
+based on the age of the system and/or what is the newest version of 
+Windows 
+that the BIOS asks for via _OSI. Changed interfaces: AcpiEnterSleepState 
+and 
 AcpileaveSleepStatePrep. See the ACPICA reference and Linux BZ 13041. Lin 
 Ming.
 
-Fixed a problem where the length of the local/common FADT was set too early. 
+Fixed a problem where the length of the local/common FADT was set too 
+early. 
 The local FADT table length cannot be set to the common length until the 
-original length has been examined. There is code that checks the table length 
-and sets various fields appropriately. This can affect older machines with 
-early FADT versions. For example, this can cause inadvertent writes to the 
+original length has been examined. There is code that checks the table 
+length 
+and sets various fields appropriately. This can affect older machines 
+with 
+early FADT versions. For example, this can cause inadvertent writes to 
+the 
 CST_CNT register. Julian Anastasov.
 
-Fixed a mapping issue related to a physical table override. Use the deferred 
-mapping mechanism for tables loaded via the physical override OSL interface. 
-This allows for early mapping before the virtual memory manager is available. 
+Fixed a mapping issue related to a physical table override. Use the 
+deferred 
+mapping mechanism for tables loaded via the physical override OSL 
+interface. 
+This allows for early mapping before the virtual memory manager is 
+available. 
 Thomas Renninger, Bob Moore.
 
-Enhanced the automatic return-object repair code: Repair a common problem with 
-predefined methods that are defined to return a variable-length Package of 
-sub-objects. If there is only one sub-object, some BIOS ASL code mistakenly 
-simply returns the single object instead of a Package with one sub-object. 
-This new support will repair this error by wrapping a Package object around 
-the original object, creating the correct and expected Package with one sub-
-object. Names that can be repaired in this manner include: _ALR, _CSD, _HPX, 
-_MLS, _PLD, _PRT, _PSS, _TRT, _TSS, _BCL, _DOD, _FIX, and _Sx. ACPICA BZ 939.
+Enhanced the automatic return-object repair code: Repair a common problem 
+with 
+predefined methods that are defined to return a variable-length Package 
+of 
+sub-objects. If there is only one sub-object, some BIOS ASL code 
+mistakenly 
+simply returns the single object instead of a Package with one sub-
+object. 
+This new support will repair this error by wrapping a Package object 
+around 
+the original object, creating the correct and expected Package with one 
+sub-
+object. Names that can be repaired in this manner include: _ALR, _CSD, 
+_HPX, 
+_MLS, _PLD, _PRT, _PSS, _TRT, _TSS, _BCL, _DOD, _FIX, and _Sx. ACPICA BZ 
+939.
 
 Changed the exception code returned for invalid ACPI paths passed as 
 parameters to external interfaces such as AcpiEvaluateObject. Was 
 AE_BAD_PARAMETER, now is the more sensible AE_BAD_PATHNAME.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
-acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The debug 
-version of the code includes the debug output trace mechanism and has a much 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug 
+version of the code includes the debug output trace mechanism and has a 
+much 
 larger code and data size.
 
   Previous Release:
@@ -58,11 +3745,15 @@ larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Added the infrastructure and initial implementation of a integrated C-
-like preprocessor. This will simplify BIOS development process by eliminating 
-the need for a separate preprocessing step during builds. On Windows, it also 
+iASL: Added the infrastructure and initial implementation of a integrated 
+C-
+like preprocessor. This will simplify BIOS development process by 
+eliminating 
+the need for a separate preprocessing step during builds. On Windows, it 
+also 
 eliminates the need to install a separate C compiler. ACPICA BZ 761. Some 
-features including full #define() macro support are still under development. 
+features including full #define() macro support are still under 
+development. 
 These preprocessor directives are supported:
     #define
     #elif
@@ -81,11 +3772,14 @@ In addition, these new command line options are supported:
     -li         Create preprocessed output file (*.i)
     -P          Preprocess only and create preprocessor output file (*.i)
 
-Table Compiler: Fixed a problem where the equals operator within an expression 
+Table Compiler: Fixed a problem where the equals operator within an 
+expression 
 did not work properly.
 
-Updated iASL to use the current versions of Bison/Flex. Updated the Windows 
-project file to invoke these tools from the standard location. ACPICA BZ 904. 
+Updated iASL to use the current versions of Bison/Flex. Updated the 
+Windows 
+project file to invoke these tools from the standard location. ACPICA BZ 
+904. 
 Versions supported:
     Flex for Windows:  V2.5.4
     Bison for Windows: V2.4.1
@@ -93,8 +3787,6 @@ Versions supported:
 ----------------------------------------
 15 February 2012. Summary of changes for version 20120215:
 
-This release is available at www.acpica.org/downloads.
-The ACPI 5.0 specification is available at www.acpi.info.
 
 1) ACPICA Core Subsystem:
 
@@ -103,25 +3795,34 @@ described below (a - e).
 
 a) The AcpiLeaveSleepState has been split into two interfaces, similar to 
 AcpiEnterSleepStatePrep and AcpiEnterSleepState. The new interface is 
-AcpiLeaveSleepStatePrep. This allows the host to perform actions between the 
-time the _BFS method is called and the _WAK method is called. NOTE: all hosts 
-must update their wake/resume code or else sleep/wake will not work properly. 
+AcpiLeaveSleepStatePrep. This allows the host to perform actions between 
+the 
+time the _BFS method is called and the _WAK method is called. NOTE: all 
+hosts 
+must update their wake/resume code or else sleep/wake will not work 
+properly. 
 Rafael Wysocki.
 
-b) In AcpiLeaveSleepState, now enable all runtime GPEs before calling the _WAK 
-method. Some machines require that the GPEs are enabled before the _WAK method 
+b) In AcpiLeaveSleepState, now enable all runtime GPEs before calling the 
+_WAK 
+method. Some machines require that the GPEs are enabled before the _WAK 
+method 
 is executed. Thomas Renninger.
 
-c) In AcpiLeaveSleepState, now always clear the WAK_STS (wake status) bit. 
-Some BIOS code assumes that WAK_STS will be cleared on resume and use it to 
+c) In AcpiLeaveSleepState, now always clear the WAK_STS (wake status) 
+bit. 
+Some BIOS code assumes that WAK_STS will be cleared on resume and use it 
+to 
 determine whether the system is rebooting or resuming. Matthew Garrett.
 
-d) Move the invocations of _GTS (Going To Sleep) and _BFS (Back From Sleep) to 
+d) Move the invocations of _GTS (Going To Sleep) and _BFS (Back From 
+Sleep) to 
 match the ACPI specification requirement. Rafael Wysocki.
 
 e) Implemented full support for the ACPI 5.0 SleepStatus and SleepControl 
 registers within the V5 FADT. This support adds two new files: 
-hardware/hwesleep.c implements the support for the new registers. Moved all 
+hardware/hwesleep.c implements the support for the new registers. Moved 
+all 
 sleep/wake external interfaces to hardware/hwxfsleep.c.
 
 
@@ -129,18 +3830,24 @@ Added a new OSL interface for ACPI table overrides,
 AcpiOsPhysicalTableOverride. This interface allows the host to override a 
 table via a physical address, instead of the logical address required by 
 AcpiOsTableOverride. This simplifies the host implementation. Initial 
-implementation by Thomas Renninger. The ACPICA implementation creates a single 
+implementation by Thomas Renninger. The ACPICA implementation creates a 
+single 
 shared function for table overrides that attempts both a logical and a 
 physical override.
 
 Expanded the OSL memory read/write interfaces to 64-bit data 
 (AcpiOsReadMemory, AcpiOsWriteMemory.) This enables full 64-bit memory 
-transfer support for GAS register structures passed to AcpiRead and AcpiWrite.
-
-Implemented the ACPI_REDUCED_HARDWARE option to allow the creation of a custom 
-build of ACPICA that supports only the ACPI 5.0 reduced hardware (SoC) model. 
-See the ACPICA reference for details. ACPICA BZ 942. This option removes about 
-10% of the code and 5% of the static data, and the following hardware ACPI 
+transfer support for GAS register structures passed to AcpiRead and 
+AcpiWrite.
+
+Implemented the ACPI_REDUCED_HARDWARE option to allow the creation of a 
+custom 
+build of ACPICA that supports only the ACPI 5.0 reduced hardware (SoC) 
+model. 
+See the ACPICA reference for details. ACPICA BZ 942. This option removes 
+about 
+10% of the code and 5% of the static data, and the following hardware 
+ACPI 
 features become unavailable:
     PM Event and Control registers
     SCI interrupt (and handler)
@@ -150,19 +3857,25 @@ features become unavailable:
     ACPI PM timer
     FACS table (Waking vectors and Global Lock)
 
-Updated the unix tarball directory structure to match the ACPICA git source 
+Updated the unix tarball directory structure to match the ACPICA git 
+source 
 tree. This ensures that the generic unix makefiles work properly (in 
-generate/unix).  Also updated the Linux makefiles to match. ACPICA BZ 867.
+generate/unix).  Also updated the Linux makefiles to match. ACPICA BZ 
+867.
 
-Updated the return value of the _REV predefined method to integer value 5 to 
+Updated the return value of the _REV predefined method to integer value 5 
+to 
 reflect ACPI 5.0 support.
 
-Moved the external ACPI PM timer interface prototypes to the public acpixf.h 
+Moved the external ACPI PM timer interface prototypes to the public 
+acpixf.h 
 file where they belong.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
-acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The debug 
-version of the code includes the debug output trace mechanism and has a much 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug 
+version of the code includes the debug output trace mechanism and has a 
+much 
 larger code and data size.
 
   Previous Release:
@@ -185,31 +3898,40 @@ specification.
 ----------------------------------------
 11 January 2012. Summary of changes for version 20120111:
 
-This release is available at www.acpica.org/downloads.
-The ACPI 5.0 specification is available at www.acpi.info.
 
 1) ACPICA Core Subsystem:
 
-Implemented a new mechanism to allow host device drivers to check for address 
-range conflicts with ACPI Operation Regions. Both SystemMemory and SystemIO 
-address spaces are supported. A new external interface, AcpiCheckAddressRange, 
-allows drivers to check an address range against the ACPI namespace. See the 
+Implemented a new mechanism to allow host device drivers to check for 
+address 
+range conflicts with ACPI Operation Regions. Both SystemMemory and 
+SystemIO 
+address spaces are supported. A new external interface, 
+AcpiCheckAddressRange, 
+allows drivers to check an address range against the ACPI namespace. See 
+the 
 ACPICA reference for additional details. Adds one new file, 
 utilities/utaddress.c. Lin Ming, Bob Moore.
 
-Fixed several issues with the ACPI 5.0 FADT support: Add the sleep Control and 
+Fixed several issues with the ACPI 5.0 FADT support: Add the sleep 
+Control 
+and 
 Status registers, update the ACPI 5.0 flags, and update internal data 
-structures to handle an FADT larger than 256 bytes. The size of the ACPI 5.0 
+structures to handle an FADT larger than 256 bytes. The size of the ACPI 
+5.0 
 FADT is 268 bytes.
 
-Updated all ACPICA copyrights and signons to 2012. Added the 2012 copyright to 
+Updated all ACPICA copyrights and signons to 2012. Added the 2012 
+copyright to 
 all module headers and signons, including the standard Linux header. This 
-affects virtually every file in the ACPICA core subsystem, iASL compiler, and 
+affects virtually every file in the ACPICA core subsystem, iASL compiler, 
+and 
 all ACPICA utilities.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
-acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The debug 
-version of the code includes the debug output trace mechanism and has a much 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug 
+version of the code includes the debug output trace mechanism and has a 
+much 
 larger code and data size.
 
   Previous Release:
@@ -224,13 +3946,18 @@ larger code and data size.
 
 Disassembler: fixed a problem with the automatic resource tag generation 
 support. Fixes a problem where the resource tags are inadvertently not 
-constructed if the table being disassembled contains external references to 
-control methods. Moved the actual construction of the tags to after the final 
-namespace is constructed (after 2nd parse is invoked due to external control 
+constructed if the table being disassembled contains external references 
+to 
+control methods. Moved the actual construction of the tags to after the 
+final 
+namespace is constructed (after 2nd parse is invoked due to external 
+control 
 method references.) ACPICA BZ 941.
 
-Table Compiler: Make all "generic" operators caseless. These are the operators 
-like UINT8, String, etc. Making these caseless improves ease-of-use. ACPICA BZ 
+Table Compiler: Make all "generic" operators caseless. These are the 
+operators 
+like UINT8, String, etc. Making these caseless improves ease-of-use. 
+ACPICA BZ 
 934.
 
 ----------------------------------------
@@ -244,9 +3971,12 @@ summarized below.
 Reduced Hardware Support:
 -------------------------
 
-This support allows for ACPI systems without the usual ACPI hardware. This 
-support is enabled by a flag in the revision 5 FADT. If it is set, ACPICA will 
-not attempt to initialize or use any of the usual ACPI hardware. Note, when 
+This support allows for ACPI systems without the usual ACPI hardware. 
+This 
+support is enabled by a flag in the revision 5 FADT. If it is set, ACPICA 
+will 
+not attempt to initialize or use any of the usual ACPI hardware. Note, 
+when 
 this flag is set, all of the following ACPI hardware is assumed to be not 
 present and is not initialized or accessed:
 
@@ -262,7 +3992,8 @@ ACPI Tables:
 ------------
 
 All new tables and updates to existing tables are fully supported in the 
-ACPICA headers (for use by device drivers), the disassembler, and the iASL 
+ACPICA headers (for use by device drivers), the disassembler, and the 
+iASL 
 Data Table Compiler. ACPI 5.0 defines these new tables:
 
     BGRT        /* Boot Graphics Resource Table */
@@ -278,7 +4009,8 @@ Operation Regions/SpaceIDs:
 ---------------------------
 
 All new operation regions are fully supported by the iASL compiler, the 
-disassembler, and the ACPICA runtime code (for dispatch to region handlers.) 
+disassembler, and the ACPICA runtime code (for dispatch to region 
+handlers.) 
 The new operation region Space IDs are:
 
     GeneralPurposeIo
@@ -287,8 +4019,11 @@ The new operation region Space IDs are:
 Resource Descriptors:
 ---------------------
 
-All new ASL resource descriptors are fully supported by the iASL compiler, the 
-ASL/AML disassembler, and the ACPICA runtime Resource Manager code (including 
+All new ASL resource descriptors are fully supported by the iASL 
+compiler, 
+the 
+ASL/AML disassembler, and the ACPICA runtime Resource Manager code 
+(including 
 all new predefined resource tags). New descriptors are:
 
     FixedDma
@@ -301,23 +4036,31 @@ all new predefined resource tags). New descriptors are:
 ASL/AML Operators, New and Modified:
 ------------------------------------
 
-One new operator is added, the Connection operator, which is used to associate 
-a GeneralPurposeIo or GenericSerialBus resource descriptor with individual 
-field objects within an operation region. Several new protocols are associated 
+One new operator is added, the Connection operator, which is used to 
+associate 
+a GeneralPurposeIo or GenericSerialBus resource descriptor with 
+individual 
+field objects within an operation region. Several new protocols are 
+associated 
 with the AccessAs operator. All are fully supported by the iASL compiler, 
 disassembler, and runtime ACPICA AML interpreter:
 
-    Connection                      // Declare Field Connection attributes
+    Connection                      // Declare Field Connection 
+attributes
     AccessAs: AttribBytes (n)           // Read/Write N-Bytes Protocol
-    AccessAs: AttribRawBytes (n)        // Raw Read/Write N-Bytes Protocol
+    AccessAs: AttribRawBytes (n)        // Raw Read/Write N-Bytes 
+Protocol
     AccessAs: AttribRawProcessBytes (n) // Raw Process Call Protocol
-    RawDataBuffer                       // Data type for Vendor Data fields
+    RawDataBuffer                       // Data type for Vendor Data 
+fields
 
 Predefined ASL/AML Objects:
 ---------------------------
 
-All new predefined objects/control-methods are supported by the iASL compiler 
-and the ACPICA runtime validation/repair (arguments and return values.) New 
+All new predefined objects/control-methods are supported by the iASL 
+compiler 
+and the ACPICA runtime validation/repair (arguments and return values.) 
+New 
 predefined names include the following:
 
 Standard Predefined Names (Objects or Control Methods):
@@ -338,25 +4081,34 @@ ACPICA External Interfaces:
 Several new interfaces have been defined for use by ACPI-related device 
 drivers and other host OS services:
 
-AcpiAcquireMutex and AcpiReleaseMutex: These interfaces allow the host OS to 
+AcpiAcquireMutex and AcpiReleaseMutex: These interfaces allow the host OS 
+to 
 acquire and release AML mutexes that are defined in the DSDT/SSDT tables 
-provided by the BIOS. They are intended to be used in conjunction with the 
+provided by the BIOS. They are intended to be used in conjunction with 
+the 
 ACPI 5.0 _DLM (Device Lock Method) in order to provide transaction-level 
 mutual exclusion with the AML code/interpreter.
 
-AcpiGetEventResources: Returns the (formatted) resource descriptors as defined 
-by the ACPI 5.0 _AEI object (ACPI Event Information).  This object provides 
-resource descriptors associated with hardware-reduced platform events, similar 
+AcpiGetEventResources: Returns the (formatted) resource descriptors as 
+defined 
+by the ACPI 5.0 _AEI object (ACPI Event Information).  This object 
+provides 
+resource descriptors associated with hardware-reduced platform events, 
+similar 
 to the AcpiGetCurrentResources interface.
 
 Operation Region Handlers: For General Purpose IO and Generic Serial Bus 
-operation regions, information about the Connection() object and any optional 
+operation regions, information about the Connection() object and any 
+optional 
 length information is passed to the region handler within the Context 
 parameter.
 
-AcpiBufferToResource: This interface converts a raw AML buffer containing a 
-resource template or resource descriptor to the ACPI_RESOURCE internal format 
-suitable for use by device drivers. Can be used by an operation region handler 
+AcpiBufferToResource: This interface converts a raw AML buffer containing 
+a 
+resource template or resource descriptor to the ACPI_RESOURCE internal 
+format 
+suitable for use by device drivers. Can be used by an operation region 
+handler 
 to convert the Connection() buffer object into a ACPI_RESOURCE.
 
 Miscellaneous/Tools/TestSuites: 
@@ -370,7 +4122,8 @@ Fully updated documentation (ACPICA and iASL reference documents.)
 ACPI Table Definition Language:
 -------------------------------
 
-Support for this language was implemented and released as a subsystem of the 
+Support for this language was implemented and released as a subsystem of 
+the 
 iASL compiler in 2010. (See the iASL compiler User Guide.)
 
 
@@ -379,11 +4132,15 @@ Non-ACPI 5.0 changes for this release:
 
 1) ACPICA Core Subsystem:
 
-Fix a problem with operation region declarations where a failure can occur if 
+Fix a problem with operation region declarations where a failure can 
+occur 
+if 
 the region name and an argument that evaluates to an object (such as the 
-region address) are in different namespace scopes. Lin Ming, ACPICA BZ 937.
+region address) are in different namespace scopes. Lin Ming, ACPICA BZ 
+937.
 
-Do not abort an ACPI table load if an invalid space ID is found within. This 
+Do not abort an ACPI table load if an invalid space ID is found within. 
+This 
 will be caught later if the offending method is executed. ACPICA BZ 925.
 
 Fixed an issue with the FFixedHW space ID where the ID was not always 
@@ -392,15 +4149,18 @@ recognized properly (Both ACPICA and iASL). ACPICA BZ 926.
 Fixed a problem with the 32-bit generation of the unix-specific OSL 
 (osunixxf.c). Lin Ming, ACPICA BZ 936.
 
-Several changes made to enable generation with the GCC 4.6 compiler. ACPICA BZ 
+Several changes made to enable generation with the GCC 4.6 compiler. 
+ACPICA BZ 
 935.
 
-New error messages: Unsupported I/O requests (not 8/16/32 bit), and Index/Bank 
+New error messages: Unsupported I/O requests (not 8/16/32 bit), and 
+Index/Bank 
 field registers out-of-range.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Implemented the __PATH__ operator, which returns the full pathname of 
+iASL: Implemented the __PATH__ operator, which returns the full pathname 
+of 
 the current source file.
 
 AcpiHelp: Automatically display expanded keyword information for all ASL 
@@ -412,24 +4172,30 @@ buffers.
 Added a new master script to generate and execute the ASLTS test suite. 
 Automatically handles 32- and 64-bit generation. See tests/aslts.sh
 
-iASL: Fix problem with listing generation during processing of the Switch() 
+iASL: Fix problem with listing generation during processing of the 
+Switch() 
 operator where AML listing was disabled until the entire Switch block was 
 completed.
 
 iASL: Improve support for semicolon statement terminators. Fix "invalid 
-character" message for some cases when the semicolon is used. Semicolons are 
+character" message for some cases when the semicolon is used. Semicolons 
+are 
 now allowed after every <Term> grammar element. ACPICA BZ 927.
 
-iASL: Fixed some possible aliasing warnings during generation. ACPICA BZ 923.
+iASL: Fixed some possible aliasing warnings during generation. ACPICA BZ 
+923.
 
-Disassembler: Fix problem with disassembly of the DataTableRegion operator 
-where an inadvertent "Unhandled deferred opcode" message could be generated.
+Disassembler: Fix problem with disassembly of the DataTableRegion 
+operator 
+where an inadvertent "Unhandled deferred opcode" message could be 
+generated.
 
 3) Example Code and Data Size
 
 These are the sizes for the OS-independent acpica.lib produced by the 
 Microsoft Visual C++ 9.0 32-bit compiler. The debug version of the code 
-includes the debug output trace mechanism and has a much larger code and data 
+includes the debug output trace mechanism and has a much larger code and 
+data 
 size.
 
   Previous Release:
@@ -444,56 +4210,78 @@ size.
 
 0) ACPI 5.0 News:
 
-Support for ACPI 5.0 in ACPICA has been underway for several months and will 
+Support for ACPI 5.0 in ACPICA has been underway for several months and 
+will 
 be released at the same time that ACPI 5.0 is officially released.
 
-The ACPI 5.0 specification is on track for release in the next few months.
+The ACPI 5.0 specification is on track for release in the next few 
+months.
  
 1) ACPICA Core Subsystem:
 
 Fixed a problem where the maximum sleep time for the Sleep() operator was 
-intended to be limited to two seconds, but was inadvertently limited to 20 
+intended to be limited to two seconds, but was inadvertently limited to 
+20 
 seconds instead.
 
-Linux and Unix makefiles: Added header file dependencies to ensure correct 
-generation of ACPICA core code and utilities. Also simplified the makefiles 
-considerably through the use of the vpath variable to specify search paths. 
+Linux and Unix makefiles: Added header file dependencies to ensure 
+correct 
+generation of ACPICA core code and utilities. Also simplified the 
+makefiles 
+considerably through the use of the vpath variable to specify search 
+paths. 
 ACPICA BZ 924.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Implemented support to check the access length for all fields created to 
-access named Resource Descriptor fields. For example, if a resource field is 
-defined to be two bits, a warning is issued if a CreateXxxxField() is used 
-with an incorrect bit length. This is implemented for all current resource 
+iASL: Implemented support to check the access length for all fields 
+created to 
+access named Resource Descriptor fields. For example, if a resource field 
+is 
+defined to be two bits, a warning is issued if a CreateXxxxField() is 
+used 
+with an incorrect bit length. This is implemented for all current 
+resource 
 descriptor names. ACPICA BZ 930.
   
-Disassembler: Fixed a byte ordering problem with the output of 24-bit and 56-
+Disassembler: Fixed a byte ordering problem with the output of 24-bit and 
+56-
 bit integers.
 
 iASL: Fixed a couple of issues associated with variable-length package 
-objects. 1) properly handle constants like One, Ones, Zero -- do not make a 
-VAR_PACKAGE when these are used as a package length. 2) Allow the VAR_PACKAGE 
-opcode (in addition to PACKAGE) when validating object types for predefined 
+objects. 1) properly handle constants like One, Ones, Zero -- do not make 
+a 
+VAR_PACKAGE when these are used as a package length. 2) Allow the 
+VAR_PACKAGE 
+opcode (in addition to PACKAGE) when validating object types for 
+predefined 
 names.
 
-iASL: Emit statistics for all output files (instead of just the ASL input and 
+iASL: Emit statistics for all output files (instead of just the ASL input 
+and 
 AML output). Includes listings, hex files, etc.
 
-iASL: Added -G option to the table compiler to allow the compilation of custom 
-ACPI tables. The only part of a table that is required is the standard 36-byte 
+iASL: Added -G option to the table compiler to allow the compilation of 
+custom 
+ACPI tables. The only part of a table that is required is the standard 
+36-
+byte 
 ACPI header.
 
-AcpiXtract: Ported to the standard ACPICA environment (with ACPICA headers), 
-which also adds correct 64-bit support. Also, now all output filenames are 
+AcpiXtract: Ported to the standard ACPICA environment (with ACPICA 
+headers), 
+which also adds correct 64-bit support. Also, now all output filenames 
+are 
 completely lower case.
 
 AcpiExec: Ignore any non-AML tables (tables other than DSDT or SSDT) when 
 loading table files. A warning is issued for any such tables. The only 
-exception is an FADT. This also fixes a possible fault when attempting to load 
+exception is an FADT. This also fixes a possible fault when attempting to 
+load 
 non-AML tables. ACPICA BZ 932.
 
-AcpiHelp: Added the AccessAs and Offset operators. Fixed a problem where a 
+AcpiHelp: Added the AccessAs and Offset operators. Fixed a problem where 
+a 
 missing table terminator could cause a fault when using the -p option.
 
 AcpiSrc: Fixed a possible divide-by-zero fault when generating file 
@@ -503,7 +4291,8 @@ statistics.
 
 These are the sizes for the OS-independent acpica.lib produced by the 
 Microsoft Visual C++ 9.0 32-bit compiler. The debug version of the code 
-includes the debug output trace mechanism and has a much larger code and data 
+includes the debug output trace mechanism and has a much larger code and 
+data 
 size.
 
   Previous Release (VC 9.0):
@@ -519,20 +4308,32 @@ size.
 
 1) ACPI CA Core Subsystem:
 
-Updated the predefined name repair mechanism to not attempt repair of a _TSS 
-return object if a _PSS object is present. We can only sort the _TSS return 
-package if there is no _PSS within the same scope. This is because if _PSS is 
-present, the ACPI specification dictates that the _TSS Power Dissipation field 
-is to be ignored, and therefore some BIOSs leave garbage values in the _TSS 
-Power field(s). In this case, it is best to just return the _TSS package as-
+Updated the predefined name repair mechanism to not attempt repair of a 
+_TSS 
+return object if a _PSS object is present. We can only sort the _TSS 
+return 
+package if there is no _PSS within the same scope. This is because if 
+_PSS 
+is 
+present, the ACPI specification dictates that the _TSS Power Dissipation 
+field 
+is to be ignored, and therefore some BIOSs leave garbage values in the 
+_TSS 
+Power field(s). In this case, it is best to just return the _TSS package 
+as-
 is. Reported by, and fixed with assistance from Fenghua Yu.
 
-Added an option to globally disable the control method return value validation 
-and repair. This runtime option can be used to disable return value repair if 
-this is causing a problem on a particular machine. Also added an option to 
+Added an option to globally disable the control method return value 
+validation 
+and repair. This runtime option can be used to disable return value 
+repair 
+if 
+this is causing a problem on a particular machine. Also added an option 
+to 
 AcpiExec (-dr) to set this disable flag.
 
-All makefiles and project files: Major changes to improve generation of ACPICA 
+All makefiles and project files: Major changes to improve generation of 
+ACPICA 
 tools. ACPICA BZ 912:
     Reduce default optimization levels to improve compatibility
     For Linux, add strict-aliasing=0 for gcc 4
@@ -540,13 +4341,17 @@ tools. ACPICA BZ 912:
     Cleanup multithread library support
     Improve usage messages
 
-Linux-specific header: update handling of THREAD_ID and pthread. For the 32-
-bit case, improve casting to eliminate possible warnings, especially with the 
+Linux-specific header: update handling of THREAD_ID and pthread. For the 
+32-
+bit case, improve casting to eliminate possible warnings, especially with 
+the 
 acpica tools.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
-acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The debug 
-version of the code includes the debug output trace mechanism and has a much 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug 
+version of the code includes the debug output trace mechanism and has a 
+much 
 larger code and data size.
 
   Previous Release (VC 9.0):
@@ -558,27 +4363,37 @@ larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-With this release, a new utility named "acpihelp" has been added to the ACPICA 
-package. This utility summarizes the ACPI specification chapters for the ASL 
+With this release, a new utility named "acpihelp" has been added to the 
+ACPICA 
+package. This utility summarizes the ACPI specification chapters for the 
+ASL 
 and AML languages. It generates under Linux/Unix as well as Windows, and 
 provides the following functionality:
     Find/display ASL operator(s) -- with description and syntax.
     Find/display ASL keyword(s) -- with exact spelling and descriptions.
     Find/display ACPI predefined name(s) -- with description, number
         of arguments, and the return value data type.
-    Find/display AML opcode name(s) -- with opcode, arguments, and grammar.
-    Decode/display AML opcode -- with opcode name, arguments, and grammar.
-
-Service Layers: Make multi-thread support configurable. Conditionally compile 
-the multi-thread support so that threading libraries will not be linked if not 
+    Find/display AML opcode name(s) -- with opcode, arguments, and 
+grammar.
+    Decode/display AML opcode -- with opcode name, arguments, and 
+grammar.
+
+Service Layers: Make multi-thread support configurable. Conditionally 
+compile 
+the multi-thread support so that threading libraries will not be linked 
+if 
+not 
 necessary. The only tool that requires multi-thread support is AcpiExec.
 
-iASL: Update yyerrror/AslCompilerError for "const" errors. Newer versions of 
+iASL: Update yyerrror/AslCompilerError for "const" errors. Newer versions 
+of 
 Bison appear to want the interface to yyerror to be a const char * (or at 
-least this is a problem when generating iASL on some systems.) ACPICA BZ 923 
+least this is a problem when generating iASL on some systems.) ACPICA BZ 
+923 
 Pierre Lejeune.
 
-Tools: Fix for systems where O_BINARY is not defined. Only used for Windows 
+Tools: Fix for systems where O_BINARY is not defined. Only used for 
+Windows 
 versions of the tools.
 
 ----------------------------------------
@@ -586,7 +4401,8 @@ versions of the tools.
 
 1) ACPI CA Core Subsystem:
 
-ASL Load() operator: Reinstate most restrictions on the incoming ACPI table 
+ASL Load() operator: Reinstate most restrictions on the incoming ACPI 
+table 
 signature. Now, only allow SSDT, OEMx, and a null signature. History:
     1) Originally, we checked the table signature for "SSDT" or "PSDT".
        (PSDT is now obsolete.)
@@ -598,12 +4414,16 @@ signature. Now, only allow SSDT, OEMx, and a null signature. History:
        interpreter errors and kernel faults. So now, we once again allow
        only SSDT, OEMx, and now, also a null signature. (05/2011).
 
-Added the missing _TDL predefined name to the global name list in order to 
-enable validation. Affects both the core ACPICA code and the iASL compiler.
+Added the missing _TDL predefined name to the global name list in order 
+to 
+enable validation. Affects both the core ACPICA code and the iASL 
+compiler.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
-acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The debug 
-version of the code includes the debug output trace mechanism and has a much 
+acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
+debug 
+version of the code includes the debug output trace mechanism and has a 
+much 
 larger code and data size.
 
   Previous Release (VC 9.0):
@@ -615,20 +4435,28 @@ larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Debugger/AcpiExec: Implemented support for "complex" method arguments on the 
-debugger command line. This adds support beyond simple integers -- including 
+Debugger/AcpiExec: Implemented support for "complex" method arguments on 
+the 
+debugger command line. This adds support beyond simple integers -- 
+including 
 Strings, Buffers, and Packages. Includes support for nested packages. 
-Increased the default command line buffer size to accommodate these arguments. 
+Increased the default command line buffer size to accommodate these 
+arguments. 
 See the ACPICA reference for details and syntax. ACPICA BZ 917.
  
-Debugger/AcpiExec: Implemented support for "default" method arguments for the 
-Execute/Debug command. Now, the debugger will always invoke a control method 
-with the required number of arguments -- even if the command line specifies 
-none or insufficient arguments. It uses default integer values for any missing 
+Debugger/AcpiExec: Implemented support for "default" method arguments for 
+the 
+Execute/Debug command. Now, the debugger will always invoke a control 
+method 
+with the required number of arguments -- even if the command line 
+specifies 
+none or insufficient arguments. It uses default integer values for any 
+missing 
 arguments. Also fixes a bug where only six method arguments maximum were 
 supported instead of the required seven.
 
-Debugger/AcpiExec: Add a maximum buffer length parameter to AcpiOsGetLine and 
+Debugger/AcpiExec: Add a maximum buffer length parameter to AcpiOsGetLine 
+and 
 also return status in order to prevent buffer overruns. See the ACPICA 
 reference for details and syntax. ACPICA BZ 921
 
@@ -636,7 +4464,8 @@ iASL: Cleaned up support for Berkeley yacc. A general cleanup of code and
 makefiles to simplify support for the two different but similar parser 
 generators, bison and yacc.
 
-Updated the generic unix makefile for gcc 4. The default gcc version is now 
+Updated the generic unix makefile for gcc 4. The default gcc version is 
+now 
 expected to be 4 or greater, since options specific to gcc 4 are used.
 
 ----------------------------------------
@@ -644,36 +4473,47 @@ expected to be 4 or greater, since options specific to gcc 4 are used.
 
 1) ACPI CA Core Subsystem:
 
-Implemented support to execute a so-called "orphan" _REG method under the EC 
-device. This change will force the execution of a _REG method underneath the 
+Implemented support to execute a so-called "orphan" _REG method under the 
+EC 
+device. This change will force the execution of a _REG method underneath 
+the 
 EC 
 device even if there is no corresponding operation region of type 
 EmbeddedControl. Fixes a problem seen on some machines and apparently is 
 compatible with Windows behavior. ACPICA BZ 875.
 
-Added more predefined methods that are eligible for automatic NULL package 
-element removal. This change adds another group of predefined names to the 
+Added more predefined methods that are eligible for automatic NULL 
+package 
+element removal. This change adds another group of predefined names to 
+the 
 list 
 of names that can be repaired by having NULL package elements dynamically 
-removed. This group are those methods that return a single variable-length 
-package containing simple data types such as integers, buffers, strings. This 
-includes: _ALx, _BCL, _CID,_ DOD, _EDL, _FIX, _PCL, _PLD, _PMD, _PRx, _PSL, 
+removed. This group are those methods that return a single variable-
+length 
+package containing simple data types such as integers, buffers, strings. 
+This 
+includes: _ALx, _BCL, _CID,_ DOD, _EDL, _FIX, _PCL, _PLD, _PMD, _PRx, 
+_PSL, 
 _Sx, 
 and _TZD. ACPICA BZ 914.
 
 Split and segregated all internal global lock functions to a new file, 
 evglock.c.
 
-Updated internal address SpaceID for DataTable regions. Moved this internal 
+Updated internal address SpaceID for DataTable regions. Moved this 
+internal 
 space 
-id in preparation for ACPI 5.0 changes that will include some new space IDs. 
+id in preparation for ACPI 5.0 changes that will include some new space 
+IDs. 
 This 
 change should not affect user/host code.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib 
-produced by the Microsoft Visual C++ 9.0 32-bit compiler. The debug version of 
-the code includes the debug output trace mechanism and has a much larger code 
+produced by the Microsoft Visual C++ 9.0 32-bit compiler. The debug 
+version of 
+the code includes the debug output trace mechanism and has a much larger 
+code 
 and 
 data size.
 
@@ -686,51 +4526,71 @@ data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL/DTC: Major update for new grammar features. Allow generic data types in 
-custom ACPI tables. Field names are now optional. Any line can be split to 
-multiple lines using the continuation char (\). Large buffers now use line-
+iASL/DTC: Major update for new grammar features. Allow generic data types 
+in 
+custom ACPI tables. Field names are now optional. Any line can be split 
+to 
+multiple lines using the continuation char (\). Large buffers now use 
+line-
 continuation character(s) and no colon on the continuation lines. See the 
 grammar 
-update in the iASL compiler reference. ACPI BZ 910,911. Lin Ming, Bob Moore.
+update in the iASL compiler reference. ACPI BZ 910,911. Lin Ming, Bob 
+Moore.
 
-iASL: Mark ASL "Return()" and the simple "Return" as "Null" return statements. 
-Since the parser stuffs a "zero" as the return value for these statements (due 
+iASL: Mark ASL "Return()" and the simple "Return" as "Null" return 
+statements. 
+Since the parser stuffs a "zero" as the return value for these statements 
+(due 
 to 
-the underlying AML grammar), they were seen as "return with value" by the iASL 
-semantic checking. They are now seen correctly as "null" return statements.
-
-iASL: Check if a_REG declaration has a corresponding Operation Region. Adds a 
-check for each _REG to ensure that there is in fact a corresponding operation 
+the underlying AML grammar), they were seen as "return with value" by the 
+iASL 
+semantic checking. They are now seen correctly as "null" return 
+statements.
+
+iASL: Check if a_REG declaration has a corresponding Operation Region. 
+Adds a 
+check for each _REG to ensure that there is in fact a corresponding 
+operation 
 region declaration in the same scope. If not, the _REG method is not very 
 useful 
 since it probably won't be executed. ACPICA BZ 915.
 
-iASL/DTC: Finish support for expression evaluation. Added a new expression 
+iASL/DTC: Finish support for expression evaluation. Added a new 
+expression 
 parser 
 that implements c-style operator precedence and parenthesization. ACPICA 
 bugzilla 
 908.
 
-Disassembler/DTC: Remove support for () and <> style comments in data tables. 
+Disassembler/DTC: Remove support for () and <> style comments in data 
+tables. 
 Now 
-that DTC has full expression support, we don't want to have comment strings 
+that DTC has full expression support, we don't want to have comment 
+strings 
 that 
-start with a parentheses or a less-than symbol. Now, only the standard /* and 
+start with a parentheses or a less-than symbol. Now, only the standard /* 
+and 
 // 
 comments are supported, as well as the bracket [] comments.
 
 AcpiXtract: Fix for RSDP and dynamic SSDT extraction. These tables have 
 "unusual" 
-headers in the acpidump file. Update the header validation to support these 
-tables. Problem introduced in previous AcpiXtract version in the change to 
+headers in the acpidump file. Update the header validation to support 
+these 
+tables. Problem introduced in previous AcpiXtract version in the change 
+to 
 support "wrong checksum" error messages emitted by acpidump utility.
 
-iASL: Add a * option to generate all template files (as a synonym for ALL) as 
+iASL: Add a * option to generate all template files (as a synonym for 
+ALL) 
+as 
 in 
 "iasl -T *" or "iasl -T ALL".
 
-iASL/DTC: Do not abort compiler on fatal errors. We do not want to completely 
-abort the compiler on "fatal" errors, simply should abort the current compile. 
+iASL/DTC: Do not abort compiler on fatal errors. We do not want to 
+completely 
+abort the compiler on "fatal" errors, simply should abort the current 
+compile. 
 This allows multiple compiles with a single (possibly wildcard) compiler 
 invocation.
 
@@ -739,20 +4599,28 @@ invocation.
 
 1) ACPI CA Core Subsystem:
 
-Fixed a problem caused by a _PRW method appearing at the namespace root scope 
-during the setup of wake GPEs. A fault could occur if a _PRW directly under 
+Fixed a problem caused by a _PRW method appearing at the namespace root 
+scope 
+during the setup of wake GPEs. A fault could occur if a _PRW directly 
+under 
 the 
 root object was passed to the AcpiSetupGpeForWake interface. Lin Ming.
 
-Implemented support for "spurious" Global Lock interrupts. On some systems, a 
-global lock interrupt can occur without the pending flag being set. Upon a GL 
-interrupt, we now ensure that a thread is actually waiting for the lock before 
+Implemented support for "spurious" Global Lock interrupts. On some 
+systems, a 
+global lock interrupt can occur without the pending flag being set. Upon 
+a 
+GL 
+interrupt, we now ensure that a thread is actually waiting for the lock 
+before 
 signaling GL availability. Rafael Wysocki, Bob Moore.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib 
-produced by the Microsoft Visual C++ 9.0 32-bit compiler. The debug version of 
-the code includes the debug output trace mechanism and has a much larger code 
+produced by the Microsoft Visual C++ 9.0 32-bit compiler. The debug 
+version of 
+the code includes the debug output trace mechanism and has a much larger 
+code 
 and 
 data size.
 
@@ -765,51 +4633,67 @@ data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Implemented full support for the "SLIC" ACPI table. Includes support in the 
-header files, disassembler, table compiler, and template generator. Bob Moore, 
+Implemented full support for the "SLIC" ACPI table. Includes support in 
+the 
+header files, disassembler, table compiler, and template generator. Bob 
+Moore, 
 Lin Ming.
 
-AcpiXtract: Correctly handle embedded comments and messages from AcpiDump. 
-Apparently some or all versions of acpidump will occasionally emit a comment 
+AcpiXtract: Correctly handle embedded comments and messages from 
+AcpiDump. 
+Apparently some or all versions of acpidump will occasionally emit a 
+comment 
 like 
 "Wrong checksum", etc., into the dump file. This was causing problems for 
 AcpiXtract. ACPICA BZ 905.
 
-iASL: Fix the Linux makefile by removing an inadvertent double file inclusion. 
+iASL: Fix the Linux makefile by removing an inadvertent double file 
+inclusion. 
 ACPICA BZ 913.
 
 AcpiExec: Update installation of operation region handlers. Install one 
 handler 
-for a user-defined address space. This is used by the ASL test suite (ASLTS).
+for a user-defined address space. This is used by the ASL test suite 
+(ASLTS).
 
 ----------------------------------------
 11 February 2011. Summary of changes for version 20110211:
 
 1) ACPI CA Core Subsystem:
 
-Added a mechanism to defer _REG methods for some early-installed handlers. 
-Most user handlers should be installed before call to AcpiEnableSubsystem. 
+Added a mechanism to defer _REG methods for some early-installed 
+handlers. 
+Most user handlers should be installed before call to 
+AcpiEnableSubsystem. 
 However, Event handlers and region handlers should be installed after 
-AcpiInitializeObjects. Override handlers for the "default" regions should be 
+AcpiInitializeObjects. Override handlers for the "default" regions should 
+be 
 installed early, however. This change executes all _REG methods for the 
 default regions (Memory/IO/PCI/DataTable) simultaneously to prevent any 
 chicken/egg issues between them. ACPICA BZ 848.
 
-Implemented an optimization for GPE detection. This optimization will simply 
+Implemented an optimization for GPE detection. This optimization will 
+simply 
 ignore GPE registers that contain no enabled GPEs -- there is no need to 
 read the register since this information is available internally. This 
-becomes more important on machines with a large GPE space. ACPICA bugzilla 
+becomes more important on machines with a large GPE space. ACPICA 
+bugzilla 
 884. Lin Ming. Suggestion from Joe Liu.
 
-Removed all use of the highly unreliable FADT revision field. The revision 
-number in the FADT has been found to be completely unreliable and cannot be 
-trusted. Only the actual table length can be used to infer the version. This 
-change updates the ACPICA core and the disassembler so that both no longer 
+Removed all use of the highly unreliable FADT revision field. The 
+revision 
+number in the FADT has been found to be completely unreliable and cannot 
+be 
+trusted. Only the actual table length can be used to infer the version. 
+This 
+change updates the ACPICA core and the disassembler so that both no 
+longer 
 even look at the FADT version and instead depend solely upon the FADT 
 length.
 
 Fix an unresolved name issue for the no-debug and no-error-message source 
-generation cases. The _AcpiModuleName was left undefined in these cases, but 
+generation cases. The _AcpiModuleName was left undefined in these cases, 
+but 
 it is actually needed as a parameter to some interfaces. Define 
 _AcpiModuleName as a null string in these cases. ACPICA Bugzilla 888.
 
@@ -822,7 +4706,8 @@ Split several large files (makefiles and project files updated)
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release (VC 9.0):
@@ -838,32 +4723,42 @@ iASL: Implemented the predefined macros __LINE__, __FILE__, and __DATE__.
 These are useful C-style macros with the standard definitions. ACPICA 
 bugzilla 898.
 
-iASL/DTC: Added support for integer expressions and labels. Support for full 
-expressions for all integer fields in all ACPI tables. Support for labels in 
+iASL/DTC: Added support for integer expressions and labels. Support for 
+full 
+expressions for all integer fields in all ACPI tables. Support for labels 
+in 
 "generic" portions of tables such as UEFI. See the iASL reference manual.
 
 Debugger: Added a command to display the status of global handlers. The 
 "handlers" command will display op region, fixed event, and miscellaneous 
-global handlers. installation status -- and for op regions, whether default 
+global handlers. installation status -- and for op regions, whether 
+default 
 or user-installed handler will be used.
 
-iASL: Warn if reserved method incorrectly returns a value. Many predefined 
-names are defined such that they do not return a value. If implemented as a 
+iASL: Warn if reserved method incorrectly returns a value. Many 
+predefined 
+names are defined such that they do not return a value. If implemented as 
+a 
 method, issue a warning if such a name explicitly returns a value. ACPICA 
 Bugzilla 855.
 
-iASL: Added detection of GPE method name conflicts. Detects a conflict where 
-there are two GPE methods of the form _Lxy and _Exy in the same scope. (For 
+iASL: Added detection of GPE method name conflicts. Detects a conflict 
+where 
+there are two GPE methods of the form _Lxy and _Exy in the same scope. 
+(For 
 example, _L1D and _E1D in the same scope.) ACPICA bugzilla 848.
 
 iASL/DTC: Fixed a couple input scanner issues with comments and line 
-numbers. Comment remover could get confused and miss a comment ending. Fixed 
+numbers. Comment remover could get confused and miss a comment ending. 
+Fixed 
 a problem with line counter maintenance.
 
-iASL/DTC: Reduced the severity of some errors from fatal to error. There is 
+iASL/DTC: Reduced the severity of some errors from fatal to error. There 
+is 
 no need to abort on simple errors within a field definition.
 
-Debugger: Simplified the output of the help command. All help output now in 
+Debugger: Simplified the output of the help command. All help output now 
+in 
 a single screen, instead of help subcommands. ACPICA Bugzilla 897.
 
 ----------------------------------------
@@ -871,18 +4766,24 @@ a single screen, instead of help subcommands. ACPICA Bugzilla 897.
 
 1) ACPI CA Core Subsystem:
 
-Fixed a race condition between method execution and namespace walks that can 
+Fixed a race condition between method execution and namespace walks that 
+can 
 possibly cause a fault. The problem was apparently introduced in version 
-20100528 as a result of a performance optimization that reduces the number of 
+20100528 as a result of a performance optimization that reduces the 
+number 
+of 
 namespace walks upon method exit by using the delete_namespace_subtree 
-function instead of the delete_namespace_by_owner function used previously. 
+function instead of the delete_namespace_by_owner function used 
+previously. 
 Bug is a missing namespace lock in the delete_namespace_subtree function. 
 dana.myers@oracle.com
 
 Fixed several issues and a possible fault with the automatic "serialized" 
-method support. History: This support changes a method to "serialized" on the 
+method support. History: This support changes a method to "serialized" on 
+the 
 fly if the method generates an AE_ALREADY_EXISTS error, indicating the 
-possibility that it cannot handle reentrancy. This fix repairs a couple of 
+possibility that it cannot handle reentrancy. This fix repairs a couple 
+of 
 issues seen in the field, especially on machines with many cores:
 
     1) Delete method children only upon the exit of the last thread,
@@ -896,29 +4797,36 @@ issues seen in the field, especially on machines with many cores:
 
     Lin Ming, Bob Moore. Reported by dana.myers@oracle.com.
 
-Debugger: Now lock the namespace for duration of a namespace dump. Prevents 
+Debugger: Now lock the namespace for duration of a namespace dump. 
+Prevents 
 issues if the namespace is changing dynamically underneath the debugger. 
 Especially affects temporary namespace nodes, since the debugger displays 
 these also.
 
 Updated the ordering of include files. The ACPICA headers should appear 
-before any compiler-specific headers (stdio.h, etc.) so that acenv.h can set 
-any necessary compiler-specific defines, etc. Affects the ACPI-related tools 
+before any compiler-specific headers (stdio.h, etc.) so that acenv.h can 
+set 
+any necessary compiler-specific defines, etc. Affects the ACPI-related 
+tools 
 and utilities.
 
-Updated all ACPICA copyrights and signons to 2011. Added the 2011 copyright 
-to all module headers and signons, including the Linux header. This affects 
+Updated all ACPICA copyrights and signons to 2011. Added the 2011 
+copyright 
+to all module headers and signons, including the Linux header. This 
+affects 
 virtually every file in the ACPICA core subsystem, iASL compiler, and all 
 utilities.
 
 Added project files for MS Visual Studio 2008 (VC++ 9.0). The original 
-project files for VC++ 6.0 are now obsolete. New project files can be found 
+project files for VC++ 6.0 are now obsolete. New project files can be 
+found 
 under acpica/generate/msvc9. See acpica/generate/msvc9/readme.txt for 
 details.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 9.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release (VC 6.0):
@@ -930,11 +4838,14 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Added generic data types to the Data Table compiler. Add "generic" data 
-types such as UINT32, String, Unicode, etc., to simplify the generation of 
+iASL: Added generic data types to the Data Table compiler. Add "generic" 
+data 
+types such as UINT32, String, Unicode, etc., to simplify the generation 
+of 
 platform-defined tables such as UEFI. Lin Ming.
 
-iASL: Added listing support for the Data Table Compiler. Adds listing support 
+iASL: Added listing support for the Data Table Compiler. Adds listing 
+support 
 (-l) to display actual binary output for each line of input code.
 
 ----------------------------------------
@@ -942,10 +4853,12 @@ iASL: Added listing support for the Data Table Compiler. Adds listing support
 
 1) ACPI CA Core Subsystem:
 
-Completed the major overhaul of the GPE support code that was begun in July 
+Completed the major overhaul of the GPE support code that was begun in 
+July 
 2010. Major features include: removal of _PRW execution in ACPICA (host 
 executes _PRWs anyway), cleanup of "wake" GPE interfaces and processing, 
-changes to existing interfaces, simplification of GPE handler operation, and 
+changes to existing interfaces, simplification of GPE handler operation, 
+and 
 a handful of new interfaces:
 
     AcpiUpdateAllGpes
@@ -955,24 +4868,33 @@ a handful of new interfaces:
     One new file, evxfgpe.c to consolidate all external GPE interfaces.
 
 See the ACPICA Programmer Reference for full details and programming 
-information. See the new section 4.4 "General Purpose Event (GPE) Support" 
-for a full overview, and section 8.7 "ACPI General Purpose Event Management" 
-for programming details. ACPICA BZ 858,870,877. Matthew Garrett, Lin Ming, 
+information. See the new section 4.4 "General Purpose Event (GPE) 
+Support" 
+for a full overview, and section 8.7 "ACPI General Purpose Event 
+Management" 
+for programming details. ACPICA BZ 858,870,877. Matthew Garrett, Lin 
+Ming, 
 Bob Moore, Rafael Wysocki.
 
-Implemented a new GPE feature for Windows compatibility, the "Implicit Wake 
-GPE Notify". This feature will automatically issue a Notify(2) on a device 
+Implemented a new GPE feature for Windows compatibility, the "Implicit 
+Wake 
+GPE Notify". This feature will automatically issue a Notify(2) on a 
+device 
 when a Wake GPE is received if there is no corresponding GPE method or 
 handler. ACPICA BZ 870.
 
-Fixed a problem with the Scope() operator during table parse and load phase. 
-During load phase (table load or method execution), the scope operator should 
-not enter the target into the namespace. Instead, it should open a new scope 
+Fixed a problem with the Scope() operator during table parse and load 
+phase. 
+During load phase (table load or method execution), the scope operator 
+should 
+not enter the target into the namespace. Instead, it should open a new 
+scope 
 at the target location. Linux BZ 19462, ACPICA BZ 882.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -984,27 +4906,35 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Relax the alphanumeric restriction on _CID strings. These strings are 
-"bus-specific" per the ACPI specification, and therefore any characters are 
-acceptable. The only checks that can be performed are for a null string and 
+iASL: Relax the alphanumeric restriction on _CID strings. These strings 
+are 
+"bus-specific" per the ACPI specification, and therefore any characters 
+are 
+acceptable. The only checks that can be performed are for a null string 
+and 
 perhaps for a leading asterisk. ACPICA BZ 886.
 
 iASL: Fixed a problem where a syntax error that caused a premature EOF 
 condition on the source file emitted a very confusing error message. The 
 premature EOF is now detected correctly. ACPICA BZ 891.
 
-Disassembler: Decode the AccessSize within a Generic Address Structure (byte 
+Disassembler: Decode the AccessSize within a Generic Address Structure 
+(byte 
 access, word access, etc.) Note, this field does not allow arbitrary bit 
 access, the size is encoded as 1=byte, 2=word, 3=dword, and 4=qword.
 
-New: AcpiNames utility - Example namespace dump utility. Shows an example of 
+New: AcpiNames utility - Example namespace dump utility. Shows an example 
+of 
 ACPICA configuration for a minimal namespace dump utility. Uses table and 
-namespace managers, but no AML interpreter. Does not add any functionality 
+namespace managers, but no AML interpreter. Does not add any 
+functionality 
 over AcpiExec, it is a subset of AcpiExec. The purpose is to show how to 
 partition and configure ACPICA. ACPICA BZ 883.
 
-AML Debugger: Increased the debugger buffer size for method return objects. 
-Was 4K, increased to 16K. Also enhanced error messages for debugger method 
+AML Debugger: Increased the debugger buffer size for method return 
+objects. 
+Was 4K, increased to 16K. Also enhanced error messages for debugger 
+method 
 execution, including the buffer overflow case.
 
 ----------------------------------------
@@ -1012,26 +4942,34 @@ execution, including the buffer overflow case.
 
 1) ACPI CA Core Subsystem:
 
-Added support to clear the PCIEXP_WAKE event. When clearing ACPI events, now 
+Added support to clear the PCIEXP_WAKE event. When clearing ACPI events, 
+now 
 clear the PCIEXP_WAKE_STS bit in the ACPI PM1 Status Register, via 
 HwClearAcpiStatus. Original change from Colin King. ACPICA BZ 880.
 
-Changed the type of the predefined namespace object _TZ from ThermalZone to 
-Device. This was found to be confusing to the host software that processes 
-the various thermal zones, since _TZ is not really a ThermalZone. However, a 
+Changed the type of the predefined namespace object _TZ from ThermalZone 
+to 
+Device. This was found to be confusing to the host software that 
+processes 
+the various thermal zones, since _TZ is not really a ThermalZone. 
+However, 
+a 
 Notify() can still be performed on it. ACPICA BZ 876. Suggestion from Rui 
 Zhang.
 
 Added Windows Vista SP2 to the list of supported _OSI strings. The actual 
 string is "Windows 2006 SP2".
 
-Eliminated duplicate code in AcpiUtExecute* functions. Now that the nsrepair 
+Eliminated duplicate code in AcpiUtExecute* functions. Now that the 
+nsrepair 
 code automatically repairs _HID-related strings, this type of code is no 
-longer needed in Execute_HID, Execute_CID, and Execute_UID. ACPICA BZ 878.
+longer needed in Execute_HID, Execute_CID, and Execute_UID. ACPICA BZ 
+878.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1043,24 +4981,33 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Implemented additional compile-time validation for _HID strings. The 
-non-hex prefix (such as "PNP" or "ACPI") must be uppercase, and the length of 
-the string must be exactly seven or eight characters. For both _HID and _CID 
+iASL: Implemented additional compile-time validation for _HID strings. 
+The 
+non-hex prefix (such as "PNP" or "ACPI") must be uppercase, and the 
+length 
+of 
+the string must be exactly seven or eight characters. For both _HID and 
+_CID 
 strings, all characters must be alphanumeric. ACPICA BZ 874.
 
 iASL: Allow certain "null" resource descriptors. Some BIOS code creates 
-descriptors that are mostly or all zeros, with the expectation that they will 
-be filled in at runtime. iASL now allows this as long as there is a "resource 
+descriptors that are mostly or all zeros, with the expectation that they 
+will 
+be filled in at runtime. iASL now allows this as long as there is a 
+"resource 
 tag" (name) associated with the descriptor, which gives the ASL a handle 
 needed to modify the descriptor. ACPICA BZ 873.
 
-Added single-thread support to the generic Unix application OSL. Primarily 
-for iASL support, this change removes the use of semaphores in the single-
+Added single-thread support to the generic Unix application OSL. 
+Primarily 
+for iASL support, this change removes the use of semaphores in the 
+single-
 threaded ACPICA tools/applications - increasing performance. The 
 _MULTI_THREADED option was replaced by the (reverse) ACPI_SINGLE_THREADED 
 option. ACPICA BZ 879.
 
-AcpiExec: several fixes for the 64-bit version. Adds XSDT support and support 
+AcpiExec: several fixes for the 64-bit version. Adds XSDT support and 
+support 
 for 64-bit DSDT/FACS addresses in the FADT. Lin Ming.
 
 iASL: Moved all compiler messages to a new file, aslmessages.h.
@@ -1070,7 +5017,8 @@ iASL: Moved all compiler messages to a new file, aslmessages.h.
 
 1) ACPI CA Core Subsystem:
 
-Removed the AcpiOsDerivePciId OSL interface. The various host implementations 
+Removed the AcpiOsDerivePciId OSL interface. The various host 
+implementations 
 of this function were not OS-dependent and are now obsolete and can be 
 removed from all host OSLs. This function has been replaced by 
 AcpiHwDerivePciId, which is now part of the ACPICA core code. 
@@ -1080,33 +5028,44 @@ module, hwpci.c. ACPICA BZ 857.
 Implemented a dynamic repair for _HID and _CID strings. The following 
 problems are now repaired at runtime: 1) Remove a leading asterisk in the 
 string, and 2) the entire string is uppercased. Both repairs are in 
-accordance with the ACPI specification and will simplify host driver code. 
+accordance with the ACPI specification and will simplify host driver 
+code. 
 ACPICA BZ 871.
 
 The ACPI_THREAD_ID type is no longer configurable, internally it is now 
-always UINT64. This simplifies the ACPICA code, especially any printf output. 
+always UINT64. This simplifies the ACPICA code, especially any printf 
+output. 
 UINT64 is the only common data type for all thread_id types across all 
-operating systems. It is now up to the host OSL to cast the native thread_id 
-type to UINT64 before returning the value to ACPICA (via AcpiOsGetThreadId). 
+operating systems. It is now up to the host OSL to cast the native 
+thread_id 
+type to UINT64 before returning the value to ACPICA (via 
+AcpiOsGetThreadId). 
 Lin Ming, Bob Moore.
 
-Added the ACPI_INLINE type to enhance the ACPICA configuration. The "inline" 
-keyword is not standard across compilers, and this type allows inline to be 
+Added the ACPI_INLINE type to enhance the ACPICA configuration. The 
+"inline" 
+keyword is not standard across compilers, and this type allows inline to 
+be 
 configured on a per-compiler basis. Lin Ming.
 
-Made the system global AcpiGbl_SystemAwakeAndRunning publically available. 
-Added an extern for this boolean in acpixf.h. Some hosts utilize this value 
+Made the system global AcpiGbl_SystemAwakeAndRunning publically 
+available. 
+Added an extern for this boolean in acpixf.h. Some hosts utilize this 
+value 
 during suspend/restore operations. ACPICA BZ 869.
 
-All code that implements error/warning messages with the "ACPI:" prefix has 
+All code that implements error/warning messages with the "ACPI:" prefix 
+has 
 been moved to a new module, utxferror.c.
 
-The UINT64_OVERLAY was moved to utmath.c, which is the only module where it 
+The UINT64_OVERLAY was moved to utmath.c, which is the only module where 
+it 
 is used. ACPICA BZ 829. Lin Ming, Bob Moore.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1118,13 +5077,17 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL/Disassembler: Write ACPI errors to stderr instead of the output file. 
-This keeps the output files free of random error messages that may originate 
-from within the namespace/interpreter code. Used this opportunity to merge 
+iASL/Disassembler: Write ACPI errors to stderr instead of the output 
+file. 
+This keeps the output files free of random error messages that may 
+originate 
+from within the namespace/interpreter code. Used this opportunity to 
+merge 
 all ACPI:-style messages into a single new module, utxferror.c. ACPICA BZ 
 866. Lin Ming, Bob Moore.
 
-Tools: update some printfs for ansi warnings on size_t. Handle width change 
+Tools: update some printfs for ansi warnings on size_t. Handle width 
+change 
 of size_t on 32-bit versus 64-bit generations. Lin Ming.
 
 ----------------------------------------
@@ -1132,11 +5095,16 @@ of size_t on 32-bit versus 64-bit generations. Lin Ming.
 
 1) ACPI CA Core Subsystem:
 
-Designed and implemented a new host interface to the _OSI support code. This 
-will allow the host to dynamically add or remove multiple _OSI strings, as 
-well as install an optional handler that is called for each _OSI invocation. 
-Also added a new AML debugger command, 'osi' to display and modify the global 
-_OSI string table, and test support in the AcpiExec utility. See the ACPICA 
+Designed and implemented a new host interface to the _OSI support code. 
+This 
+will allow the host to dynamically add or remove multiple _OSI strings, 
+as 
+well as install an optional handler that is called for each _OSI 
+invocation. 
+Also added a new AML debugger command, 'osi' to display and modify the 
+global 
+_OSI string table, and test support in the AcpiExec utility. See the 
+ACPICA 
 reference manual for full details. Lin Ming, Bob Moore. ACPICA BZ 836.
 New Functions:
     AcpiInstallInterface - Add an _OSI string.
@@ -1148,28 +5116,37 @@ New Files:
     source/components/utilities/utosi.c
 
 Re-introduced the support to enable multi-byte transfers for Embedded 
-Controller (EC) operation regions. A reported problem was found to be a bug 
-in the host OS, not in the multi-byte support. Previously, the maximum data 
-size passed to the EC operation region handler was a single byte. There are 
-often EC Fields larger than one byte that need to be transferred, and it is 
-useful for the EC driver to lock these as a single transaction. This change 
+Controller (EC) operation regions. A reported problem was found to be a 
+bug 
+in the host OS, not in the multi-byte support. Previously, the maximum 
+data 
+size passed to the EC operation region handler was a single byte. There 
+are 
+often EC Fields larger than one byte that need to be transferred, and it 
+is 
+useful for the EC driver to lock these as a single transaction. This 
+change 
 enables single transfers larger than 8 bits. This effectively changes the 
 access to the EC space from ByteAcc to AnyAcc, and will probably require 
-changes to the host OS Embedded Controller driver to enable 16/32/64/256-bit 
+changes to the host OS Embedded Controller driver to enable 16/32/64/256-
+bit 
 transfers in addition to 8-bit transfers. Alexey Starikovskiy, Lin Ming.
 
 Fixed a problem with the prototype for AcpiOsReadPciConfiguration. The 
 prototype in acpiosxf.h had the output value pointer as a (void *).
 It should be a (UINT64 *). This may affect some host OSL code.
 
-Fixed a couple problems with the recently modified Linux makefiles for iASL 
+Fixed a couple problems with the recently modified Linux makefiles for 
+iASL 
 and AcpiExec. These new makefiles place the generated object files in the 
-local directory so that there can be no collisions between the files that are 
+local directory so that there can be no collisions between the files that 
+are 
 shared between them that are compiled with different options.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1181,13 +5158,17 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL/Disassembler: Added a new option (-da, "disassemble all") to load the 
+iASL/Disassembler: Added a new option (-da, "disassemble all") to load 
+the 
 namespace from and disassemble an entire group of AML files. Useful for 
-loading all of the AML tables for a given machine (DSDT, SSDT1...SSDTn) and 
+loading all of the AML tables for a given machine (DSDT, SSDT1...SSDTn) 
+and 
 disassembling with one simple command. ACPICA BZ 865. Lin Ming.
 
-iASL: Allow multiple invocations of -e option. This change allows multiple 
-uses of -e on the command line: "-e ssdt1.dat -e ssdt2.dat". ACPICA BZ 834. 
+iASL: Allow multiple invocations of -e option. This change allows 
+multiple 
+uses of -e on the command line: "-e ssdt1.dat -e ssdt2.dat". ACPICA BZ 
+834. 
 Lin Ming.
 
 ----------------------------------------
@@ -1196,9 +5177,12 @@ Lin Ming.
 1) ACPI CA Core Subsystem:
 
 Implemented several updates to the recently added GPE reference count 
-support. The model for "wake" GPEs is changing to give the host OS complete 
-control of these GPEs. Eventually, the ACPICA core will not execute any _PRW 
-methods, since the host already must execute them. Also, additional changes 
+support. The model for "wake" GPEs is changing to give the host OS 
+complete 
+control of these GPEs. Eventually, the ACPICA core will not execute any 
+_PRW 
+methods, since the host already must execute them. Also, additional 
+changes 
 were made to help ensure that the reference counts are kept in proper 
 synchronization with reality. Rafael J. Wysocki.
 
@@ -1207,28 +5191,38 @@ synchronization with reality. Rafael J. Wysocki.
 3) Do not inadvertently enable GPEs when writing GPE registers.
 4) Remove the internal wake reference counter and add new AcpiGpeWakeup 
 interface. This interface will set or clear individual GPEs for wakeup.
-5) Remove GpeType argument from AcpiEnable and AcpiDisable. These interfaces 
+5) Remove GpeType argument from AcpiEnable and AcpiDisable. These 
+interfaces 
 are now used for "runtime" GPEs only.
 
-Changed the behavior of the GPE install/remove handler interfaces. The GPE is 
-no longer disabled during this process, as it was found to cause problems on 
+Changed the behavior of the GPE install/remove handler interfaces. The 
+GPE 
+is 
+no longer disabled during this process, as it was found to cause problems 
+on 
 some machines. Rafael J. Wysocki.
 
 Reverted a change introduced in version 20100528 to enable Embedded 
-Controller multi-byte transfers. This change was found to cause problems with 
+Controller multi-byte transfers. This change was found to cause problems 
+with 
 Index Fields and possibly Bank Fields. It will be reintroduced when these 
 problems have been resolved.
 
-Fixed a problem with references to Alias objects within Package Objects. A 
+Fixed a problem with references to Alias objects within Package Objects. 
+A 
 reference to an Alias within the definition of a Package was not always 
-resolved properly. Aliases to objects like Processors, Thermal zones, etc. 
-were resolved to the actual object instead of a reference to the object as it 
+resolved properly. Aliases to objects like Processors, Thermal zones, 
+etc. 
+were resolved to the actual object instead of a reference to the object 
+as 
+it 
 should be. Package objects are only allowed to contain integer, string, 
 buffer, package, and reference objects. Redhat bugzilla 608648.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1241,14 +5235,17 @@ much larger code and data size.
 2) iASL Compiler/Disassembler and Tools:
 
 iASL: Implemented a new compiler subsystem to allow definition and 
-compilation of the non-AML ACPI tables such as FADT, MADT, SRAT, etc. These 
+compilation of the non-AML ACPI tables such as FADT, MADT, SRAT, etc. 
+These 
 are called "ACPI Data Tables", and the new compiler is the "Data Table 
 Compiler". This compiler is intended to simplify the existing error-prone 
 process of creating these tables for the BIOS, as well as allowing the 
-disassembly, modification, recompilation, and override of existing ACPI data 
+disassembly, modification, recompilation, and override of existing ACPI 
+data 
 tables. See the iASL User Guide for detailed information.
 
-iASL: Implemented a new Template Generator option in support of the new Data 
+iASL: Implemented a new Template Generator option in support of the new 
+Data 
 Table Compiler. This option will create examples of all known ACPI tables 
 that can be used as the basis for table development. See the iASL 
 documentation and the -T option.
@@ -1261,7 +5258,8 @@ object files in the local directory so that there can be no collisions
 between the shared files between them that are generated with different 
 options.
 
-Added support for Mac OS X in the Unix OSL used for iASL and AcpiExec. Use 
+Added support for Mac OS X in the Unix OSL used for iASL and AcpiExec. 
+Use 
 the #define __APPLE__ to enable this support.
 
 ----------------------------------------
@@ -1272,37 +5270,58 @@ available at www.acpi.info. This is primarily an errata release.
 
 1) ACPI CA Core Subsystem:
 
-Undefined ACPI tables: We are looking for the definitions for the following 
+Undefined ACPI tables: We are looking for the definitions for the 
+following 
 ACPI tables that have been seen in the field: ATKG, IEIT, GSCI.
 
-Implemented support to enable multi-byte transfers for Embedded Controller 
-(EC) operation regions. Previously, the maximum data size passed to the EC 
-operation region handler was a single byte. There are often EC Fields larger 
-than one byte that need to be transferred, and it is useful for the EC driver 
-to lock these as a single transaction. This change enables single transfers 
-larger than 8 bits. This effectively changes the access to the EC space from 
-ByteAcc to AnyAcc, and will probably require changes to the host OS Embedded 
-Controller driver to enable 16/32/64/256-bit transfers in addition to 8-bit 
+Implemented support to enable multi-byte transfers for Embedded 
+Controller 
+(EC) operation regions. Previously, the maximum data size passed to the 
+EC 
+operation region handler was a single byte. There are often EC Fields 
+larger 
+than one byte that need to be transferred, and it is useful for the EC 
+driver 
+to lock these as a single transaction. This change enables single 
+transfers 
+larger than 8 bits. This effectively changes the access to the EC space 
+from 
+ByteAcc to AnyAcc, and will probably require changes to the host OS 
+Embedded 
+Controller driver to enable 16/32/64/256-bit transfers in addition to 8-
+bit 
 transfers. Alexey Starikovskiy, Lin Ming
 
-Implemented a performance enhancement for namespace search and access. This 
-change enhances the performance of namespace searches and walks by adding a 
-backpointer to the parent in each namespace node. On large namespaces, this 
-change can improve overall ACPI performance by up to 9X. Adding a pointer to 
-each namespace node increases the overall size of the internal namespace by 
+Implemented a performance enhancement for namespace search and access. 
+This 
+change enhances the performance of namespace searches and walks by adding 
+a 
+backpointer to the parent in each namespace node. On large namespaces, 
+this 
+change can improve overall ACPI performance by up to 9X. Adding a pointer 
+to 
+each namespace node increases the overall size of the internal namespace 
+by 
 about 5%, since each namespace entry usually consists of both a namespace 
 node and an ACPI operand object. However, this is the first growth of the 
 namespace in ten years. ACPICA bugzilla 817. Alexey Starikovskiy.
 
-Implemented a performance optimization that reduces the number of namespace 
-walks. On control method exit, only walk the namespace if the method is known 
-to have created namespace objects outside of its local scope. Previously, the 
-entire namespace was traversed on each control method exit. This change can 
-improve overall ACPI performance by up to 3X. Alexey Starikovskiy, Bob Moore.
+Implemented a performance optimization that reduces the number of 
+namespace 
+walks. On control method exit, only walk the namespace if the method is 
+known 
+to have created namespace objects outside of its local scope. Previously, 
+the 
+entire namespace was traversed on each control method exit. This change 
+can 
+improve overall ACPI performance by up to 3X. Alexey Starikovskiy, Bob 
+Moore.
 
-Added support to truncate I/O addresses to 16 bits for Windows compatibility. 
+Added support to truncate I/O addresses to 16 bits for Windows 
+compatibility. 
 Some ASL code has been seen in the field that inadvertently has bits set 
-above bit 15. This feature is optional and is enabled if the BIOS requests 
+above bit 15. This feature is optional and is enabled if the BIOS 
+requests 
 any Windows OSI strings. It can also be enabled by the host OS. Matthew 
 Garrett, Bob Moore.
 
@@ -1311,22 +5330,28 @@ prevent accidental deep sleeps, limit the maximum time that Sleep() will
 actually sleep. Configurable, the default maximum is two seconds. ACPICA 
 bugzilla 854.
 
-Added run-time validation support for the _WDG and_WED Microsoft predefined 
-methods. These objects are defined by "Windows Instrumentation", and are not 
+Added run-time validation support for the _WDG and_WED Microsoft 
+predefined 
+methods. These objects are defined by "Windows Instrumentation", and are 
+not 
 part of the ACPI spec. ACPICA BZ 860.
 
 Expanded all statistic counters used during namespace and device 
-initialization from 16 to 32 bits in order to support very large namespaces.
+initialization from 16 to 32 bits in order to support very large 
+namespaces.
 
-Replaced all instances of %d in printf format specifiers with %u since nearly 
+Replaced all instances of %d in printf format specifiers with %u since 
+nearly 
 all integers in ACPICA are unsigned.
 
-Fixed the exception namestring for AE_WAKE_ONLY_GPE. Was incorrectly returned 
+Fixed the exception namestring for AE_WAKE_ONLY_GPE. Was incorrectly 
+returned 
 as AE_NO_HANDLER.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1339,7 +5364,8 @@ much larger code and data size.
 2) iASL Compiler/Disassembler and Tools:
 
 iASL: Added compiler support for the _WDG and_WED Microsoft predefined 
-methods. These objects are defined by "Windows Instrumentation", and are not 
+methods. These objects are defined by "Windows Instrumentation", and are 
+not 
 part of the ACPI spec. ACPICA BZ 860.
 
 AcpiExec: added option to disable the memory tracking mechanism. The -dt 
@@ -1355,29 +5381,38 @@ AcpiExec: Restructured the command line options into -d (disable) and -e
 1) ACPI CA Core Subsystem:
 
 Implemented GPE support for dynamically loaded ACPI tables. For all GPEs, 
-including FADT-based and GPE Block Devices, execute any _PRW methods in the 
+including FADT-based and GPE Block Devices, execute any _PRW methods in 
+the 
 new table, and process any _Lxx/_Exx GPE methods in the new table. Any 
 runtime GPE that is referenced by an _Lxx/_Exx method in the new table is 
 immediately enabled. Handles the FADT-defined GPEs as well as GPE Block 
 Devices. Provides compatibility with other ACPI implementations. Two new 
-files added, evgpeinit.c and evgpeutil.c. ACPICA BZ 833. Lin Ming, Bob Moore.
-
-Fixed a regression introduced in version 20100331 within the table manager 
-where initial table loading could fail. This was introduced in the fix for 
-AcpiReallocateRootTable. Also, renamed some of fields in the table manager 
+files added, evgpeinit.c and evgpeutil.c. ACPICA BZ 833. Lin Ming, Bob 
+Moore.
+
+Fixed a regression introduced in version 20100331 within the table 
+manager 
+where initial table loading could fail. This was introduced in the fix 
+for 
+AcpiReallocateRootTable. Also, renamed some of fields in the table 
+manager 
 data structures to clarify their meaning and use.
 
 Fixed a possible allocation overrun during internal object copy in 
-AcpiUtCopySimpleObject. The original code did not correctly handle the case 
-where the object to be copied was a namespace node. Lin Ming. ACPICA BZ 847.
+AcpiUtCopySimpleObject. The original code did not correctly handle the 
+case 
+where the object to be copied was a namespace node. Lin Ming. ACPICA BZ 
+847.
 
 Updated the allocation dump routine, AcpiUtDumpAllocation and fixed a 
-possible access beyond end-of-allocation. Also, now fully validate descriptor 
+possible access beyond end-of-allocation. Also, now fully validate 
+descriptor 
 (size and type) before output. Lin Ming, Bob Moore. ACPICA BZ 847
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1390,25 +5425,35 @@ much larger code and data size.
 2) iASL Compiler/Disassembler and Tools:
 
 iASL: Implemented Min/Max/Len/Gran validation for address resource 
-descriptors. This change implements validation for the address fields that 
+descriptors. This change implements validation for the address fields 
+that 
 are common to all address-type resource descriptors. These checks are 
 implemented: Checks for valid Min/Max, length within the Min/Max window, 
-valid granularity, Min/Max a multiple of granularity, and _MIF/_MAF as per 
-table 6-40 in the ACPI 4.0a specification. Also split the large aslrestype1.c 
+valid granularity, Min/Max a multiple of granularity, and _MIF/_MAF as 
+per 
+table 6-40 in the ACPI 4.0a specification. Also split the large 
+aslrestype1.c 
 and aslrestype2.c files into five new files. ACPICA BZ 840.
 
-iASL: Added support for the _Wxx predefined names. This support was missing 
+iASL: Added support for the _Wxx predefined names. This support was 
+missing 
 and these names were not recognized by the compiler as valid predefined 
 names. ACPICA BZ 851.
 
-iASL: Added an error for all predefined names that are defined to return no 
-value and thus must be implemented as Control Methods. These include all of 
+iASL: Added an error for all predefined names that are defined to return 
+no 
+value and thus must be implemented as Control Methods. These include all 
+of 
 the _Lxx, _Exx, _Wxx, and _Qxx names, as well as some other miscellaneous 
 names such as _DIS, _INI, _IRC, _OFF, _ON, and _PSx. ACPICA BZ 850, 856.
 
-iASL: Implemented the -ts option to emit hex AML data in ASL format, as an 
-ASL Buffer. Allows ACPI tables to be easily included within ASL files, to be 
-dynamically loaded via the Load() operator. Also cleaned up output for the -
+iASL: Implemented the -ts option to emit hex AML data in ASL format, as 
+an 
+ASL Buffer. Allows ACPI tables to be easily included within ASL files, to 
+be 
+dynamically loaded via the Load() operator. Also cleaned up output for 
+the 
+-
 ta and -tc options. ACPICA BZ 853.
 
 Tests: Added a new file with examples of extended iASL error checking. 
@@ -1420,14 +5465,19 @@ Available at tests/misc/badcode.asl.
 
 1) ACPI CA Core Subsystem:
 
-Completed a major update for the GPE support in order to improve support for 
-shared GPEs and to simplify both host OS and ACPICA code. Added a reference 
-count mechanism to support shared GPEs that require multiple device drivers. 
+Completed a major update for the GPE support in order to improve support 
+for 
+shared GPEs and to simplify both host OS and ACPICA code. Added a 
+reference 
+count mechanism to support shared GPEs that require multiple device 
+drivers. 
 Several external interfaces have changed. One external interface has been 
 removed. One new external interface was added. Most of the GPE external 
 interfaces now use the GPE spinlock instead of the events mutex (and the 
-Flags parameter for many GPE interfaces has been removed.) See the updated 
-ACPICA Programmer Reference for details. Matthew Garrett, Bob Moore, Rafael 
+Flags parameter for many GPE interfaces has been removed.) See the 
+updated 
+ACPICA Programmer Reference for details. Matthew Garrett, Bob Moore, 
+Rafael 
 Wysocki. ACPICA BZ 831.
 
 Changed:
@@ -1437,32 +5487,44 @@ Removed:
 New:
     AcpiSetGpe
 
-Implemented write support for DataTable operation regions. These regions are 
-defined via the DataTableRegion() operator. Previously, only read support was 
-implemented. The ACPI specification allows DataTableRegions to be read/write, 
+Implemented write support for DataTable operation regions. These regions 
+are 
+defined via the DataTableRegion() operator. Previously, only read support 
+was 
+implemented. The ACPI specification allows DataTableRegions to be 
+read/write, 
 however.
 
 Implemented a new subsystem option to force a copy of the DSDT to local 
-memory. Optionally copy the entire DSDT to local memory (instead of simply 
-mapping it.) There are some (albeit very rare) BIOSs that corrupt or replace 
-the original DSDT, creating the need for this option. Default is FALSE, do 
+memory. Optionally copy the entire DSDT to local memory (instead of 
+simply 
+mapping it.) There are some (albeit very rare) BIOSs that corrupt or 
+replace 
+the original DSDT, creating the need for this option. Default is FALSE, 
+do 
 not copy the DSDT.
 
 Implemented detection of a corrupted or replaced DSDT. This change adds 
-support to detect a DSDT that has been corrupted and/or replaced from outside 
-the OS (by firmware). This is typically catastrophic for the system, but has 
+support to detect a DSDT that has been corrupted and/or replaced from 
+outside 
+the OS (by firmware). This is typically catastrophic for the system, but 
+has 
 been seen on some machines. Once this problem has been detected, the DSDT 
 copy option can be enabled via system configuration. Lin Ming, Bob Moore.
 
-Fixed two problems with AcpiReallocateRootTable during the root table copy. 
+Fixed two problems with AcpiReallocateRootTable during the root table 
+copy. 
 When copying the root table to the new allocation, the length used was 
-incorrect. The new size was used instead of the current table size, meaning 
-too much data was copied. Also, the count of available slots for ACPI tables 
+incorrect. The new size was used instead of the current table size, 
+meaning 
+too much data was copied. Also, the count of available slots for ACPI 
+tables 
 was not set correctly. Alexey Starikovskiy, Bob Moore.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1478,16 +5540,20 @@ iASL: Implement limited typechecking for values returned from predefined
 control methods. The type of any returned static (unnamed) object is now 
 validated. For example, Return(1). ACPICA BZ 786.
 
-iASL: Fixed a predefined name object verification regression. Fixes a problem 
+iASL: Fixed a predefined name object verification regression. Fixes a 
+problem 
 introduced in version 20100304. An error is incorrectly generated if a 
 predefined name is declared as a static named object with a value defined 
 using the keywords "Zero", "One", or "Ones". Lin Ming.
 
-iASL: Added Windows 7 support for the -g option (get local ACPI tables) by 
+iASL: Added Windows 7 support for the -g option (get local ACPI tables) 
+by 
 reducing the requested registry access rights. ACPICA BZ 842.
 
-Disassembler: fixed a possible fault when generating External() statements. 
-Introduced in commit ae7d6fd: Properly handle externals with parent-prefix 
+Disassembler: fixed a possible fault when generating External() 
+statements. 
+Introduced in commit ae7d6fd: Properly handle externals with parent-
+prefix 
 (carat). Fixes a string length allocation calculation. Lin Ming.
 
 ----------------------------------------
@@ -1497,32 +5563,42 @@ Introduced in commit ae7d6fd: Properly handle externals with parent-prefix
 
 Fixed a possible problem with the AML Mutex handling function 
 AcpiExReleaseMutex where the function could fault under the very rare 
-condition when the interpreter has blocked, the interpreter lock is released, 
+condition when the interpreter has blocked, the interpreter lock is 
+released, 
 the interpreter is then reentered via the same thread, and attempts to 
-acquire an AML mutex that was previously acquired. FreeBSD report 140979. Lin 
+acquire an AML mutex that was previously acquired. FreeBSD report 140979. 
+Lin 
 Ming.
 
 Implemented additional configuration support for the AML "Debug Object". 
 Output from the debug object can now be enabled via a global variable, 
-AcpiGbl_EnableAmlDebugObject. This will assist with remote machine debugging. 
-This debug output is now available in the release version of ACPICA instead 
-of just the debug version. Also, the entire debug output module can now be 
+AcpiGbl_EnableAmlDebugObject. This will assist with remote machine 
+debugging. 
+This debug output is now available in the release version of ACPICA 
+instead 
+of just the debug version. Also, the entire debug output module can now 
+be 
 configured out of the ACPICA build if desired. One new file added, 
 executer/exdebug.c. Lin Ming, Bob Moore.
 
 Added header support for the ACPI MCHI table (Management Controller Host 
-Interface Table). This table was added in ACPI 4.0, but the defining document 
+Interface Table). This table was added in ACPI 4.0, but the defining 
+document 
 has only recently become available.
 
-Standardized output of integer values for ACPICA warnings/errors. Always use 
-0x prefix for hex output, always use %u for unsigned integer decimal output. 
-Affects ACPI_INFO, ACPI_ERROR, ACPI_EXCEPTION, and ACPI_WARNING (about 400 
+Standardized output of integer values for ACPICA warnings/errors. Always 
+use 
+0x prefix for hex output, always use %u for unsigned integer decimal 
+output. 
+Affects ACPI_INFO, ACPI_ERROR, ACPI_EXCEPTION, and ACPI_WARNING (about 
+400 
 invocations.) These invocations were converted from the original 
 ACPI_DEBUG_PRINT invocations and were not consistent. ACPICA BZ 835.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1537,7 +5613,8 @@ much larger code and data size.
 iASL: Implemented typechecking support for static (non-control method) 
 predefined named objects that are declared with the Name() operator. For 
 example, the type of this object is now validated to be of type Integer: 
-Name(_BBN, 1). This change migrates the compiler to using the core predefined 
+Name(_BBN, 1). This change migrates the compiler to using the core 
+predefined 
 name table instead of maintaining a local version. Added a new file, 
 aslpredef.c. ACPICA BZ 832.
 
@@ -1552,34 +5629,50 @@ Added the 2010 copyright to all module headers and signons. This affects
 virtually every file in the ACPICA core subsystem, the iASL compiler, the 
 tools/utilities, and the test suites.
 
-Implemented a change to the AcpiGetDevices interface to eliminate unnecessary 
+Implemented a change to the AcpiGetDevices interface to eliminate 
+unnecessary 
 invocations of the _STA method. In the case where a specific _HID is 
 requested, do not run _STA until a _HID match is found. This eliminates 
-potentially dozens of _STA calls during a search for a particular device/HID, 
+potentially dozens of _STA calls during a search for a particular 
+device/HID, 
 which in turn can improve boot times. ACPICA BZ 828. Lin Ming.
 
-Implemented an additional repair for predefined method return values. Attempt 
-to repair unexpected NULL elements within returned Package objects. Create an 
-Integer of value zero, a NULL String, or a zero-length Buffer as appropriate. 
+Implemented an additional repair for predefined method return values. 
+Attempt 
+to repair unexpected NULL elements within returned Package objects. 
+Create 
+an 
+Integer of value zero, a NULL String, or a zero-length Buffer as 
+appropriate. 
 ACPICA BZ 818. Lin Ming, Bob Moore.
 
-Removed the obsolete ACPI_INTEGER data type. This type was introduced as the 
-code was migrated from ACPI 1.0 (with 32-bit AML integers) to ACPI 2.0 (with 
-64-bit AML integers). It is now obsolete and this change removes it from the 
-ACPICA code base, replaced by UINT64. The original typedef has been retained 
-for now for compatibility with existing device driver code. ACPICA BZ 824.
+Removed the obsolete ACPI_INTEGER data type. This type was introduced as 
+the 
+code was migrated from ACPI 1.0 (with 32-bit AML integers) to ACPI 2.0 
+(with 
+64-bit AML integers). It is now obsolete and this change removes it from 
+the 
+ACPICA code base, replaced by UINT64. The original typedef has been 
+retained 
+for now for compatibility with existing device driver code. ACPICA BZ 
+824.
 
-Removed the unused UINT32_STRUCT type, and the obsolete Integer64 field in 
+Removed the unused UINT32_STRUCT type, and the obsolete Integer64 field 
+in 
 the parse tree object.
 
-Added additional warning options for the gcc-4 generation. Updated the source 
-accordingly. This includes some code restructuring to eliminate unreachable 
-code, elimination of some gotos, elimination of unused return values, some 
+Added additional warning options for the gcc-4 generation. Updated the 
+source 
+accordingly. This includes some code restructuring to eliminate 
+unreachable 
+code, elimination of some gotos, elimination of unused return values, 
+some 
 additional casting, and removal of redundant declarations.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1598,47 +5691,72 @@ No functional changes for this release.
 
 1) ACPI CA Core Subsystem:
 
-Enhanced automatic data type conversions for predefined name repairs. This 
-change expands the automatic repairs/conversions for predefined name return 
-values to make Integers, Strings, and Buffers fully interchangeable. Also, a 
-Buffer can be converted to a Package of Integers if necessary. The nsrepair.c 
+Enhanced automatic data type conversions for predefined name repairs. 
+This 
+change expands the automatic repairs/conversions for predefined name 
+return 
+values to make Integers, Strings, and Buffers fully interchangeable. 
+Also, 
+a 
+Buffer can be converted to a Package of Integers if necessary. The 
+nsrepair.c 
 module was completely restructured. Lin Ming, Bob Moore.
 
-Implemented automatic removal of null package elements during predefined name 
+Implemented automatic removal of null package elements during predefined 
+name 
 repairs. This change will automatically remove embedded and trailing NULL 
-package elements from returned package objects that are defined to contain a 
-variable number of sub-packages. The driver is then presented with a package 
+package elements from returned package objects that are defined to 
+contain 
+a 
+variable number of sub-packages. The driver is then presented with a 
+package 
 with no null elements to deal with. ACPICA BZ 819.
 
 Implemented a repair for the predefined _FDE and _GTM names. The expected 
-return value for both names is a Buffer of 5 DWORDs. This repair fixes two 
-possible problems (both seen in the field), where a package of integers is 
-returned, or a buffer of BYTEs is returned. With assistance from Jung-uk Kim.
-
-Implemented additional module-level code support. This change will properly 
-execute module-level code that is not at the root of the namespace (under a 
-Device object, etc.). Now executes the code within the current scope instead 
+return value for both names is a Buffer of 5 DWORDs. This repair fixes 
+two 
+possible problems (both seen in the field), where a package of integers 
+is 
+returned, or a buffer of BYTEs is returned. With assistance from Jung-uk 
+Kim.
+
+Implemented additional module-level code support. This change will 
+properly 
+execute module-level code that is not at the root of the namespace (under 
+a 
+Device object, etc.). Now executes the code within the current scope 
+instead 
 of the root. ACPICA BZ 762. Lin Ming.
 
-Fixed possible mutex acquisition errors when running _REG methods. Fixes a 
-problem where mutex errors can occur when running a _REG method that is in 
-the same scope as a method-defined operation region or an operation region 
-under a module-level IF block. This type of code is rare, so the problem has 
+Fixed possible mutex acquisition errors when running _REG methods. Fixes 
+a 
+problem where mutex errors can occur when running a _REG method that is 
+in 
+the same scope as a method-defined operation region or an operation 
+region 
+under a module-level IF block. This type of code is rare, so the problem 
+has 
 not been seen before. ACPICA BZ 826. Lin Ming, Bob Moore.
 
-Fixed a possible memory leak during module-level code execution. An object 
+Fixed a possible memory leak during module-level code execution. An 
+object 
 could be leaked for each block of executed module-level code if the 
-interpreter slack mode is enabled This change deletes any implicitly returned 
+interpreter slack mode is enabled This change deletes any implicitly 
+returned 
 object from the module-level code block. Lin Ming.
 
-Removed messages for successful predefined repair(s). The repair mechanism 
-was considered too wordy. Now, messages are only unconditionally emitted if 
+Removed messages for successful predefined repair(s). The repair 
+mechanism 
+was considered too wordy. Now, messages are only unconditionally emitted 
+if 
 the return object cannot be repaired. Existing messages for successful 
-repairs were converted to ACPI_DEBUG_PRINT messages for now. ACPICA BZ 827.
+repairs were converted to ACPI_DEBUG_PRINT messages for now. ACPICA BZ 
+827.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1650,12 +5768,14 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Fixed a regression introduced in 20091112 where intermediate .SRC files 
+iASL: Fixed a regression introduced in 20091112 where intermediate .SRC 
+files 
 were no longer automatically removed at the termination of the compile.
 
 acpiexec: Implemented the -f option to specify default region fill value. 
 This option specifies the value used to initialize buffers that simulate 
-operation regions. Default value is zero. Useful for debugging problems that 
+operation regions. Default value is zero. Useful for debugging problems 
+that 
 depend on a specific initial value for a region or field.
 
 ----------------------------------------
@@ -1665,43 +5785,58 @@ depend on a specific initial value for a region or field.
 
 Implemented a post-order callback to AcpiWalkNamespace. The existing 
 interface only has a pre-order callback. This change adds an additional 
-parameter for a post-order callback which will be more useful for bus scans. 
+parameter for a post-order callback which will be more useful for bus 
+scans. 
 ACPICA BZ 779. Lin Ming. Updated the ACPICA Programmer Reference.
 
 Modified the behavior of the operation region memory mapping cache for 
-SystemMemory. Ensure that the memory mappings created for operation regions 
+SystemMemory. Ensure that the memory mappings created for operation 
+regions 
 do not cross 4K page boundaries. Crossing a page boundary while mapping 
-regions can cause kernel warnings on some hosts if the pages have different 
-attributes. Such regions are probably BIOS bugs, and this is the workaround. 
+regions can cause kernel warnings on some hosts if the pages have 
+different 
+attributes. Such regions are probably BIOS bugs, and this is the 
+workaround. 
 Linux BZ 14445. Lin Ming.
 
 Implemented an automatic repair for predefined methods that must return 
-sorted lists. This change will repair (by sorting) packages returned by _ALR, 
-_PSS, and _TSS. Drivers can now assume that the packages are correctly sorted 
+sorted lists. This change will repair (by sorting) packages returned by 
+_ALR, 
+_PSS, and _TSS. Drivers can now assume that the packages are correctly 
+sorted 
 and do not contain NULL package elements. Adds one new file, 
 namespace/nsrepair2.c. ACPICA BZ 784. Lin Ming, Bob Moore.
 
-Fixed a possible fault during predefined name validation if a return Package 
+Fixed a possible fault during predefined name validation if a return 
+Package 
 object contains NULL elements. Also adds a warning if a NULL element is 
-followed by any non-null elements. ACPICA BZ 813, 814. Future enhancement may 
+followed by any non-null elements. ACPICA BZ 813, 814. Future enhancement 
+may 
 include repair or removal of all such NULL elements where possible.
 
-Implemented additional module-level executable AML code support. This change 
+Implemented additional module-level executable AML code support. This 
+change 
 will execute module-level code that is not at the root of the namespace 
-(under a Device object, etc.) at table load time. Module-level executable AML 
+(under a Device object, etc.) at table load time. Module-level executable 
+AML 
 code has been illegal since ACPI 2.0. ACPICA BZ 762. Lin Ming.
 
-Implemented a new internal function to create Integer objects. This function 
+Implemented a new internal function to create Integer objects. This 
+function 
 simplifies miscellaneous object creation code. ACPICA BZ 823.
 
-Reduced the severity of predefined repair messages, Warning to Info. Since 
-the object was successfully repaired, a warning is too severe. Reduced to an 
-info message for now. These messages may eventually be changed to debug-only. 
+Reduced the severity of predefined repair messages, Warning to Info. 
+Since 
+the object was successfully repaired, a warning is too severe. Reduced to 
+an 
+info message for now. These messages may eventually be changed to debug-
+only. 
 ACPICA BZ 812.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1713,20 +5848,26 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Implemented Switch() with While(1) so that Break works correctly. This 
-change correctly implements the Switch operator with a surrounding While(1) 
+iASL: Implemented Switch() with While(1) so that Break works correctly. 
+This 
+change correctly implements the Switch operator with a surrounding 
+While(1) 
 so that the Break operator works as expected. ACPICA BZ 461. Lin Ming.
 
-iASL: Added a message if a package initializer list is shorter than package 
-length. Adds a new remark for a Package() declaration if an initializer list 
+iASL: Added a message if a package initializer list is shorter than 
+package 
+length. Adds a new remark for a Package() declaration if an initializer 
+list 
 exists, but is shorter than the declared length of the package. Although 
 technically legal, this is probably a coding error and it is seen in the 
 field. ACPICA BZ 815. Lin Ming, Bob Moore.
 
-iASL: Fixed a problem where the compiler could fault after the maximum number 
+iASL: Fixed a problem where the compiler could fault after the maximum 
+number 
 of errors was reached (200).
 
-acpixtract: Fixed a possible warning for pointer cast if the compiler warning 
+acpixtract: Fixed a possible warning for pointer cast if the compiler 
+warning 
 level set very high.
 
 ----------------------------------------
@@ -1734,9 +5875,12 @@ level set very high.
 
 1) ACPI CA Core Subsystem:
 
-Fixed a problem where an Operation Region _REG method could be executed more 
-than once. If a custom address space handler is installed by the host before 
-the "initialize operation regions" phase of the ACPICA initialization, any 
+Fixed a problem where an Operation Region _REG method could be executed 
+more 
+than once. If a custom address space handler is installed by the host 
+before 
+the "initialize operation regions" phase of the ACPICA initialization, 
+any 
 _REG methods for that address space could be executed twice. This change 
 fixes the problem. ACPICA BZ 427. Lin Ming.
 
@@ -1746,20 +5890,24 @@ operand object was leaked. Lin Ming.
 
 Implemented a run-time repair for the _MAT predefined method. If the _MAT 
 return value is defined as a Field object in the AML, and the field
-size is less than or equal to the default width of an integer (32 or 64),_MAT 
+size is less than or equal to the default width of an integer (32 or 
+64),_MAT 
 can incorrectly return an Integer instead of a Buffer. ACPICA now 
 automatically repairs this problem. ACPICA BZ 810.
 
-Implemented a run-time repair for the _BIF and _BIX predefined methods. The 
+Implemented a run-time repair for the _BIF and _BIX predefined methods. 
+The 
 "OEM Information" field is often incorrectly returned as an Integer with 
-value zero if the field is not supported by the platform. This is due to an 
+value zero if the field is not supported by the platform. This is due to 
+an 
 ambiguity in the ACPI specification. The field should always be a string. 
 ACPICA now automatically repairs this problem by returning a NULL string 
 within the returned Package. ACPICA BZ 807.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1772,7 +5920,8 @@ much larger code and data size.
 2) iASL Compiler/Disassembler and Tools:
 
 Disassembler: Fixed a problem where references to external symbols that 
-contained one or more parent-prefixes (carats) were not handled correctly, 
+contained one or more parent-prefixes (carats) were not handled 
+correctly, 
 possibly causing a fault. ACPICA BZ 806. Lin Ming.
 
 Disassembler: Restructured the code so that all functions that handle 
@@ -1795,26 +5944,36 @@ files.
 
 For Windows Vista compatibility, added the automatic execution of an _INI 
 method located at the namespace root (\_INI). This method is executed at 
-table load time. This support is in addition to the automatic execution of 
+table load time. This support is in addition to the automatic execution 
+of 
 \_SB._INI. Lin Ming.
 
-Fixed a possible memory leak in the interpreter for AML package objects if 
-the package initializer list is longer than the defined size of the package. 
-This apparently can only happen if the BIOS changes the package size on the 
+Fixed a possible memory leak in the interpreter for AML package objects 
+if 
+the package initializer list is longer than the defined size of the 
+package. 
+This apparently can only happen if the BIOS changes the package size on 
+the 
 fly (seen in a _PSS object), as ASL compilers do not allow this. The 
-interpreter will truncate the package to the defined size (and issue an error 
-message), but previously could leave the extra objects undeleted if they were 
-pre-created during the argument processing (such is the case if the package 
+interpreter will truncate the package to the defined size (and issue an 
+error 
+message), but previously could leave the extra objects undeleted if they 
+were 
+pre-created during the argument processing (such is the case if the 
+package 
 consists of a number of sub-packages as in the _PSS.) ACPICA BZ 805.
 
 Fixed a problem seen when a Buffer or String is stored to itself via ASL. 
-This has been reported in the field. Previously, ACPICA would zero out the 
+This has been reported in the field. Previously, ACPICA would zero out 
+the 
 buffer/string. Now, the operation is treated as a noop. Provides Windows 
 compatibility. ACPICA BZ 803. Lin Ming.
 
 Removed an extraneous error message for ASL constructs of the form 
-Store(LocalX,LocalX) when LocalX is uninitialized. These curious statements 
-are seen in many BIOSs and are once again treated as NOOPs and no error is 
+Store(LocalX,LocalX) when LocalX is uninitialized. These curious 
+statements 
+are seen in many BIOSs and are once again treated as NOOPs and no error 
+is 
 emitted when they are encountered. ACPICA BZ 785.
 
 Fixed an extraneous warning message if a _DSM reserved method returns a 
@@ -1823,7 +5982,8 @@ return type cannot be performed. ACPICA BZ 802.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1839,9 +5999,11 @@ iASL: Fixed a problem with the use of the Alias operator and Resource
 Templates. The correct alias is now constructed and no error is emitted. 
 ACPICA BZ 738.
 
-iASL: Implemented the -I option to specify additional search directories for 
+iASL: Implemented the -I option to specify additional search directories 
+for 
 include files. Allows multiple additional search paths for include files. 
-Directories are searched in the order specified on the command line (after 
+Directories are searched in the order specified on the command line 
+(after 
 the local directory is searched.) ACPICA BZ 800.
 
 iASL: Fixed a problem where the full pathname for include files was not 
@@ -1851,12 +6013,15 @@ properly. ACPICA BZ 765.
 iASL: Implemented the -@ option to specify a Windows-style response file 
 containing additional command line options. ACPICA BZ 801.
 
-AcpiExec: Added support to load multiple AML files simultaneously (such as a 
+AcpiExec: Added support to load multiple AML files simultaneously (such 
+as 
+a 
 DSDT and multiple SSDTs). Also added support for wildcards within the AML 
 pathname. These features allow all machine tables to be easily loaded and 
 debugged together. ACPICA BZ 804.
 
-Disassembler: Added missing support for disassembly of HEST table Error Bank 
+Disassembler: Added missing support for disassembly of HEST table Error 
+Bank 
 subtables. 
 
 ----------------------------------------
@@ -1867,54 +6032,75 @@ The ACPI 4.0 implementation for ACPICA is complete with this release.
 1) ACPI CA Core Subsystem:
 
 ACPI 4.0: Added header file support for all new and changed ACPI tables. 
-Completely new tables are: IBFT, IVRS, MSCT, and WAET. Tables that are new 
-for ACPI 4.0, but have previously been supported in ACPICA are: CPEP, BERT, 
-EINJ, ERST, and HEST. Other newly supported tables are: UEFI and WDAT. There 
+Completely new tables are: IBFT, IVRS, MSCT, and WAET. Tables that are 
+new 
+for ACPI 4.0, but have previously been supported in ACPICA are: CPEP, 
+BERT, 
+EINJ, ERST, and HEST. Other newly supported tables are: UEFI and WDAT. 
+There 
 have been some ACPI 4.0 changes to other existing tables. Split the large 
 actbl1.h header into the existing actbl2.h header. ACPICA BZ 774.
 
-ACPI 4.0: Implemented predefined name validation for all new names. There are 
-31 new names in ACPI 4.0. The predefined validation module was split into two 
+ACPI 4.0: Implemented predefined name validation for all new names. There 
+are 
+31 new names in ACPI 4.0. The predefined validation module was split into 
+two 
 files. The new file is namespace/nsrepair.c. ACPICA BZ 770.
 
 Implemented support for so-called "module-level executable code". This is 
-executable AML code that exists outside of any control method and is intended 
-to be executed at table load time. Although illegal since ACPI 2.0, this type 
-of code still exists and is apparently still being created. Blocks of this 
-code are now detected and executed as intended. Currently, the code blocks 
+executable AML code that exists outside of any control method and is 
+intended 
+to be executed at table load time. Although illegal since ACPI 2.0, this 
+type 
+of code still exists and is apparently still being created. Blocks of 
+this 
+code are now detected and executed as intended. Currently, the code 
+blocks 
 must exist under either an If, Else, or While construct; these are the 
 typical cases seen in the field. ACPICA BZ 762. Lin Ming.
 
 Implemented an automatic dynamic repair for predefined names that return 
-nested Package objects. This applies to predefined names that are defined to 
+nested Package objects. This applies to predefined names that are defined 
+to 
 return a variable-length Package of sub-packages. If the number of sub-
-packages is one, BIOS code is occasionally seen that creates a simple single 
+packages is one, BIOS code is occasionally seen that creates a simple 
+single 
 package with no sub-packages. This code attempts to fix the problem by 
-wrapping a new package object around the existing package. These methods can 
-be repaired: _ALR, _CSD, _HPX, _MLS, _PRT, _PSS, _TRT, and _TSS. ACPICA BZ 
+wrapping a new package object around the existing package. These methods 
+can 
+be repaired: _ALR, _CSD, _HPX, _MLS, _PRT, _PSS, _TRT, and _TSS. ACPICA 
+BZ 
 790.
 
-Fixed a regression introduced in 20090625 for the AcpiGetDevices interface. 
-The _HID/_CID matching was broken and no longer matched IDs correctly. ACPICA 
+Fixed a regression introduced in 20090625 for the AcpiGetDevices 
+interface. 
+The _HID/_CID matching was broken and no longer matched IDs correctly. 
+ACPICA 
 BZ 793.
 
 Fixed a problem with AcpiReset where the reset would silently fail if the 
-register was one of the protected I/O ports. AcpiReset now bypasses the port 
-validation mechanism. This may eventually be driven into the AcpiRead/Write 
+register was one of the protected I/O ports. AcpiReset now bypasses the 
+port 
+validation mechanism. This may eventually be driven into the 
+AcpiRead/Write 
 interfaces.
 
 Fixed a regression related to the recent update of the AcpiRead/Write 
-interfaces. A sleep/suspend could fail if the optional PM2 Control register 
+interfaces. A sleep/suspend could fail if the optional PM2 Control 
+register 
 does not exist during an attempt to write the Bus Master Arbitration bit. 
-(However, some hosts already delete the code that writes this bit, and the 
+(However, some hosts already delete the code that writes this bit, and 
+the 
 code may in fact be obsolete at this date.) ACPICA BZ 799.
 
-Fixed a problem where AcpiTerminate could fault if inadvertently called twice 
+Fixed a problem where AcpiTerminate could fault if inadvertently called 
+twice 
 in succession. ACPICA BZ 795.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -1939,55 +6125,74 @@ continue for the next few releases.
 1) ACPI CA Core Subsystem:
 
 ACPI 4.0: Implemented interpreter support for the IPMI operation region 
-address space. Includes support for bi-directional data buffers and an IPMI 
-address space handler (to be installed by an IPMI device driver.) ACPICA BZ 
+address space. Includes support for bi-directional data buffers and an 
+IPMI 
+address space handler (to be installed by an IPMI device driver.) ACPICA 
+BZ 
 773. Lin Ming.
 
-ACPI 4.0: Added changes for existing ACPI tables - FACS and SRAT. Includes 
+ACPI 4.0: Added changes for existing ACPI tables - FACS and SRAT. 
+Includes 
 support in both the header files and the disassembler.
 
 Completed a major update for the AcpiGetObjectInfo external interface. 
 Changes include:
  - Support for variable, unlimited length HID, UID, and CID strings.
- - Support Processor objects the same as Devices (HID,UID,CID,ADR,STA, etc.)
+ - Support Processor objects the same as Devices (HID,UID,CID,ADR,STA, 
+etc.)
  - Call the _SxW power methods on behalf of a device object.
  - Determine if a device is a PCI root bridge.
  - Change the ACPI_BUFFER parameter to ACPI_DEVICE_INFO.
-These changes will require an update to all callers of this interface. See 
-the updated ACPICA Programmer Reference for details. One new source file has 
+These changes will require an update to all callers of this interface. 
+See 
+the updated ACPICA Programmer Reference for details. One new source file 
+has 
 been added - utilities/utids.c. ACPICA BZ 368, 780.
 
 Updated the AcpiRead and AcpiWrite external interfaces to support 64-bit 
-transfers. The Value parameter has been extended from 32 bits to 64 bits in 
-order to support new ACPI 4.0 tables. These changes will require an update to 
+transfers. The Value parameter has been extended from 32 bits to 64 bits 
+in 
+order to support new ACPI 4.0 tables. These changes will require an 
+update 
+to 
 all callers of these interfaces. See the ACPICA Programmer Reference for 
 details. ACPICA BZ 768.
 
-Fixed several problems with AcpiAttachData. The handler was not invoked when 
-the host node was deleted. The data sub-object was not automatically deleted 
-when the host node was deleted. The interface to the handler had an unused 
+Fixed several problems with AcpiAttachData. The handler was not invoked 
+when 
+the host node was deleted. The data sub-object was not automatically 
+deleted 
+when the host node was deleted. The interface to the handler had an 
+unused 
 parameter, this was removed. ACPICA BZ 778.
 
 Enhanced the function that dumps ACPI table headers. All non-printable 
-characters in the string fields are now replaced with '?' (Signature, OemId, 
+characters in the string fields are now replaced with '?' (Signature, 
+OemId, 
 OemTableId, and CompilerId.) ACPI tables with non-printable characters in 
 these fields are occasionally seen in the field. ACPICA BZ 788.
 
 Fixed a problem with predefined method repair code where the code that 
-attempts to repair/convert an object of incorrect type is only executed on 
-the first time the predefined method is called. The mechanism that disables 
+attempts to repair/convert an object of incorrect type is only executed 
+on 
+the first time the predefined method is called. The mechanism that 
+disables 
 warnings on subsequent calls was interfering with the repair mechanism. 
 ACPICA BZ 781.
 
-Fixed a possible memory leak in the predefined validation/repair code when a 
+Fixed a possible memory leak in the predefined validation/repair code 
+when 
+a 
 buffer is automatically converted to an expected string object.
 
-Removed obsolete 16-bit files from the distribution and from the current git 
+Removed obsolete 16-bit files from the distribution and from the current 
+git 
 tree head. ACPICA BZ 776.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2010,8 +6215,11 @@ predefined names and control methods (31 total). ACPICA BZ 769.
 
 1) ACPI CA Core Subsystem:
 
-Disabled the preservation of the SCI enable bit in the PM1 control register. 
-The SCI enable bit (bit 0, SCI_EN) is defined by the ACPI specification to be 
+Disabled the preservation of the SCI enable bit in the PM1 control 
+register. 
+The SCI enable bit (bit 0, SCI_EN) is defined by the ACPI specification 
+to 
+be 
 a "preserved" bit - "OSPM always preserves this bit position", section 
 4.7.3.2.1. However, some machines fail if this bit is in fact preserved 
 because the bit needs to be explicitly set by the OS as a workaround. No 
@@ -2022,45 +6230,61 @@ Fixed a problem in AcpiRsGetPciRoutingTableLength where an invalid or
 incorrectly formed _PRT package could cause a fault. Added validation to 
 ensure that each package element is actually a sub-package.
 
-Implemented a new interface to install or override a single control method, 
-AcpiInstallMethod. This interface is useful when debugging in order to repair 
-an existing method or to install a missing method without having to override 
+Implemented a new interface to install or override a single control 
+method, 
+AcpiInstallMethod. This interface is useful when debugging in order to 
+repair 
+an existing method or to install a missing method without having to 
+override 
 the entire ACPI table. See the ACPICA Programmer Reference for use and 
 examples. Lin Ming, Bob Moore.
 
 Fixed several reference count issues with the DdbHandle object that is 
-created from a Load or LoadTable operator. Prevent premature deletion of the 
-object. Also, mark the object as invalid once the table has been unloaded. 
-This is needed because the handle itself may not be deleted after the table 
+created from a Load or LoadTable operator. Prevent premature deletion of 
+the 
+object. Also, mark the object as invalid once the table has been 
+unloaded. 
+This is needed because the handle itself may not be deleted after the 
+table 
 unload, depending on whether it has been stored in a named object by the 
 caller. Lin Ming.
 
 Fixed a problem with Mutex Sync Levels. Fixed a problem where if multiple 
-mutexes of the same sync level are acquired but then not released in strict 
-opposite order, the internally maintained Current Sync Level becomes confused 
+mutexes of the same sync level are acquired but then not released in 
+strict 
+opposite order, the internally maintained Current Sync Level becomes 
+confused 
 and can cause subsequent execution errors. ACPICA BZ 471.
 
 Changed the allowable release order for ASL mutex objects. The ACPI 4.0 
-specification has been changed to make the SyncLevel for mutex objects more 
-useful. When releasing a mutex, the SyncLevel of the mutex must now be the 
-same as the current sync level. This makes more sense than the previous rule 
+specification has been changed to make the SyncLevel for mutex objects 
+more 
+useful. When releasing a mutex, the SyncLevel of the mutex must now be 
+the 
+same as the current sync level. This makes more sense than the previous 
+rule 
 (SyncLevel less than or equal). This change updates the code to match the 
 specification.
 
-Fixed a problem with the local version of the AcpiOsPurgeCache function. The 
+Fixed a problem with the local version of the AcpiOsPurgeCache function. 
+The 
 (local) cache must be locked during all cache object deletions. Andrew 
 Baumann.
 
-Updated the Load operator to use operation region interfaces. This replaces 
-direct memory mapping with region access calls. Now, all region accesses go 
+Updated the Load operator to use operation region interfaces. This 
+replaces 
+direct memory mapping with region access calls. Now, all region accesses 
+go 
 through the installed region handler as they should.
 
-Simplified and optimized the NsGetNextNode function. Reduced parameter count 
+Simplified and optimized the NsGetNextNode function. Reduced parameter 
+count 
 and reduced code for this frequently used function.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2072,8 +6296,10 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Disassembler: Fixed some issues with DMAR, HEST, MADT tables. Some problems 
-with sub-table disassembly and handling invalid sub-tables. Attempt recovery 
+Disassembler: Fixed some issues with DMAR, HEST, MADT tables. Some 
+problems 
+with sub-table disassembly and handling invalid sub-tables. Attempt 
+recovery 
 after an invalid sub-table ID.
 
 ----------------------------------------
@@ -2081,14 +6307,18 @@ after an invalid sub-table ID.
 
 1) ACPI CA Core Subsystem:
 
-Fixed a compatibility issue with the recently released I/O port protection 
+Fixed a compatibility issue with the recently released I/O port 
+protection 
 mechanism. For windows compatibility, 1) On a port protection violation, 
-simply ignore the request and do not return an exception (allow the control 
+simply ignore the request and do not return an exception (allow the 
+control 
 method to continue execution.) 2) If only part of the request overlaps a 
-protected port, read/write the individual ports that are not protected. Linux 
+protected port, read/write the individual ports that are not protected. 
+Linux 
 BZ 13036. Lin Ming
 
-Enhanced the execution of the ASL/AML BreakPoint operator so that it actually 
+Enhanced the execution of the ASL/AML BreakPoint operator so that it 
+actually 
 breaks into the AML debugger if the debugger is present. This matches the 
 ACPI-defined behavior.
 
@@ -2098,15 +6328,19 @@ pointer with no warnings. Also fixes several warnings in printf-like
 statements for the 64-bit build when the type is configured as a pointer. 
 ACPICA BZ 766, 767.
 
-Fixed a number of possible warnings when compiling with gcc 4+ (depending on 
-warning options.) Examples include printf formats, aliasing, unused globals, 
+Fixed a number of possible warnings when compiling with gcc 4+ (depending 
+on 
+warning options.) Examples include printf formats, aliasing, unused 
+globals, 
 missing prototypes, missing switch default statements, use of non-ANSI 
-library functions, use of non-ANSI constructs. See generate/unix/Makefile for 
+library functions, use of non-ANSI constructs. See generate/unix/Makefile 
+for 
 a list of warning options used with gcc 3 and 4. ACPICA BZ 735.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2118,28 +6352,38 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Fixed a generation warning from Bison 2.3 and fixed several warnings on 
+iASL: Fixed a generation warning from Bison 2.3 and fixed several 
+warnings 
+on 
 the 64-bit build.
 
-iASL: Fixed a problem where the Unix/Linux versions of the compiler could not 
+iASL: Fixed a problem where the Unix/Linux versions of the compiler could 
+not 
 correctly digest Windows/DOS formatted files (with CR/LF).
 
 iASL: Added a new option for "quiet mode" (-va) that produces only the 
 compilation summary, not individual errors and warnings. Useful for large 
 batch compilations.
 
-AcpiExec: Implemented a new option (-z) to enable a forced semaphore/mutex 
-timeout that can be used to detect hang conditions during execution of AML 
-code (includes both internal semaphores and AML-defined mutexes and events.)
+AcpiExec: Implemented a new option (-z) to enable a forced 
+semaphore/mutex 
+timeout that can be used to detect hang conditions during execution of 
+AML 
+code (includes both internal semaphores and AML-defined mutexes and 
+events.)
 
 Added new makefiles for the generation of acpica in a generic unix-like 
-environment. These makefiles are intended to generate the acpica tools and 
+environment. These makefiles are intended to generate the acpica tools 
+and 
 utilities from the original acpica git source tree structure.
 
 Test Suites: Updated and cleaned up the documentation files. Updated the 
-copyrights to 2009, affecting all source files. Use the new version of iASL 
-with quiet mode. Increased the number of available semaphores in the Windows 
-OSL, allowing the aslts to execute fully on Windows. For the Unix OSL, added 
+copyrights to 2009, affecting all source files. Use the new version of 
+iASL 
+with quiet mode. Increased the number of available semaphores in the 
+Windows 
+OSL, allowing the aslts to execute fully on Windows. For the Unix OSL, 
+added 
 an alternate implementation of the semaphore timeout to allow aslts to 
 execute fully on Cygwin.
 
@@ -2148,25 +6392,37 @@ execute fully on Cygwin.
 
 1) ACPI CA Core Subsystem:
 
-Fixed a possible race condition between AcpiWalkNamespace and dynamic table 
-unloads. Added a reader/writer locking mechanism to allow multiple concurrent 
-namespace walks (readers), but block a dynamic table unload until it can gain 
-exclusive write access to the namespace. This fixes a problem where a table 
-unload could (possibly catastrophically) delete the portion of the namespace 
-that is currently being examined by a walk. Adds a new file, utlock.c, that 
+Fixed a possible race condition between AcpiWalkNamespace and dynamic 
+table 
+unloads. Added a reader/writer locking mechanism to allow multiple 
+concurrent 
+namespace walks (readers), but block a dynamic table unload until it can 
+gain 
+exclusive write access to the namespace. This fixes a problem where a 
+table 
+unload could (possibly catastrophically) delete the portion of the 
+namespace 
+that is currently being examined by a walk. Adds a new file, utlock.c, 
+that 
 implements the reader/writer lock mechanism. ACPICA BZ 749.
 
-Fixed a regression introduced in version 20090220 where a change to the FADT 
-handling could cause the ACPICA subsystem to access non-existent I/O ports.
+Fixed a regression introduced in version 20090220 where a change to the 
+FADT 
+handling could cause the ACPICA subsystem to access non-existent I/O 
+ports.
 
-Modified the handling of FADT register and table (FACS/DSDT) addresses. The 
+Modified the handling of FADT register and table (FACS/DSDT) addresses. 
+The 
 FADT can contain both 32-bit and 64-bit versions of these addresses. 
-Previously, the 64-bit versions were favored, meaning that if both 32 and 64 
+Previously, the 64-bit versions were favored, meaning that if both 32 and 
+64 
 versions were valid, but not equal, the 64-bit version was used. This was 
-found to cause some machines to fail. Now, in this case, the 32-bit version 
+found to cause some machines to fail. Now, in this case, the 32-bit 
+version 
 is used instead. This now matches the Windows behavior.
 
-Implemented a new mechanism to protect certain I/O ports. Provides Microsoft 
+Implemented a new mechanism to protect certain I/O ports. Provides 
+Microsoft 
 compatibility and protects the standard PC I/O ports from access via AML 
 code. Adds a new file, hwvalid.c
 
@@ -2174,30 +6430,40 @@ Fixed a possible extraneous warning message from the FADT support. The
 message warns of a 32/64 length mismatch between the legacy and GAS 
 definitions for a register.
 
-Removed the obsolete AcpiOsValidateAddress OSL interface. This interface is 
-made obsolete by the port protection mechanism above. It was previously used 
-to validate the entire address range of an operation region, which could be 
+Removed the obsolete AcpiOsValidateAddress OSL interface. This interface 
+is 
+made obsolete by the port protection mechanism above. It was previously 
+used 
+to validate the entire address range of an operation region, which could 
+be 
 incorrect if the range included illegal ports, but fields within the 
 operation region did not actually access those ports. Validation is now 
 performed on a per-field basis instead of the entire region.
 
 Modified the handling of the PM1 Status Register ignored bit (bit 11.) 
-Ignored bits must be "preserved" according to the ACPI spec. Usually, this 
-means a read/modify/write when writing to the register. However, for status 
-registers, writing a one means clear the event. Writing a zero means preserve 
-the event (do not clear.) This behavior is clarified in the ACPI 4.0 spec, 
+Ignored bits must be "preserved" according to the ACPI spec. Usually, 
+this 
+means a read/modify/write when writing to the register. However, for 
+status 
+registers, writing a one means clear the event. Writing a zero means 
+preserve 
+the event (do not clear.) This behavior is clarified in the ACPI 4.0 
+spec, 
 and the ACPICA code now simply always writes a zero to the ignored bit.
 
-Modified the handling of ignored bits for the PM1 A/B Control Registers. As 
+Modified the handling of ignored bits for the PM1 A/B Control Registers. 
+As 
 per the ACPI specification, for the control registers, preserve 
-(read/modify/write) all bits that are defined as either reserved or ignored.
+(read/modify/write) all bits that are defined as either reserved or 
+ignored.
 
 Updated the handling of write-only bits in the PM1 A/B Control Registers. 
 When reading the register, zero the write-only bits as per the ACPI spec. 
 ACPICA BZ 443. Lin Ming.
 
 Removed "Linux" from the list of supported _OSI strings. Linux no longer 
-wants to reply true to this request. The Windows strings are the only paths 
+wants to reply true to this request. The Windows strings are the only 
+paths 
 through the AML that are tested and known to work properly.
 
   Previous Release:
@@ -2209,7 +6475,8 @@ through the AML that are tested and known to work properly.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Acpiexec: Split the large aeexec.c file into two new files, aehandlers.c and 
+Acpiexec: Split the large aeexec.c file into two new files, aehandlers.c 
+and 
 aetables.c
 
 ----------------------------------------
@@ -2217,51 +6484,77 @@ aetables.c
 
 1) ACPI CA Core Subsystem:
 
-Optimized the ACPI register locking. Removed locking for reads from the ACPI 
-bit registers in PM1 Status, Enable, Control, and PM2 Control. The lock is 
+Optimized the ACPI register locking. Removed locking for reads from the 
+ACPI 
+bit registers in PM1 Status, Enable, Control, and PM2 Control. The lock 
+is 
 not required when reading the single-bit registers. The 
-AcpiGetRegisterUnlocked function is no longer needed and has been removed. 
-This will improve performance for reads on these registers. ACPICA BZ 760.
+AcpiGetRegisterUnlocked function is no longer needed and has been 
+removed. 
+This will improve performance for reads on these registers. ACPICA BZ 
+760.
 
 Fixed the parameter validation for AcpiRead/Write. Now return 
-AE_BAD_PARAMETER if the input register pointer is null, and AE_BAD_ADDRESS if 
-the register has an address of zero. Previously, these cases simply returned 
-AE_OK. For optional registers such as PM1B status/enable/control, the caller 
+AE_BAD_PARAMETER if the input register pointer is null, and 
+AE_BAD_ADDRESS 
+if 
+the register has an address of zero. Previously, these cases simply 
+returned 
+AE_OK. For optional registers such as PM1B status/enable/control, the 
+caller 
 should check for a valid register address before calling. ACPICA BZ 748.
 
 Renamed the external ACPI bit register access functions. Renamed 
 AcpiGetRegister and AcpiSetRegister to clarify the purpose of these 
-functions. The new names are AcpiReadBitRegister and AcpiWriteBitRegister. 
-Also, restructured the code for these functions by simplifying the code path 
+functions. The new names are AcpiReadBitRegister and 
+AcpiWriteBitRegister. 
+Also, restructured the code for these functions by simplifying the code 
+path 
 and condensing duplicate code to reduce code size.
 
 Added new functions to transparently handle the possibly split PM1 A/B 
-registers. AcpiHwReadMultiple and AcpiHwWriteMultiple. These two functions 
-now handle the split registers for PM1 Status, Enable, and Control. ACPICA BZ 
+registers. AcpiHwReadMultiple and AcpiHwWriteMultiple. These two 
+functions 
+now handle the split registers for PM1 Status, Enable, and Control. 
+ACPICA 
+BZ 
 746.
 
-Added a function to handle the PM1 control registers, AcpiHwWritePm1Control. 
-This function writes both of the PM1 control registers (A/B). These registers 
-are different than the PM1 A/B status and enable registers in that different 
-values can be written to the A/B registers. Most notably, the SLP_TYP bits 
-can be different, as per the values returned from the _Sx predefined methods.
-
-Removed an extra register write within AcpiHwClearAcpiStatus. This function 
-was writing an optional PM1B status register twice. The existing call to the 
-low-level AcpiHwRegisterWrite automatically handles a possibly split PM1 A/B 
+Added a function to handle the PM1 control registers, 
+AcpiHwWritePm1Control. 
+This function writes both of the PM1 control registers (A/B). These 
+registers 
+are different than the PM1 A/B status and enable registers in that 
+different 
+values can be written to the A/B registers. Most notably, the SLP_TYP 
+bits 
+can be different, as per the values returned from the _Sx predefined 
+methods.
+
+Removed an extra register write within AcpiHwClearAcpiStatus. This 
+function 
+was writing an optional PM1B status register twice. The existing call to 
+the 
+low-level AcpiHwRegisterWrite automatically handles a possibly split PM1 
+A/B 
 register. ACPICA BZ 751.
 
-Split out the PM1 Status registers from the FADT. Added new globals for these 
+Split out the PM1 Status registers from the FADT. Added new globals for 
+these 
 registers (A/B), similar to the way the PM1 Enable registers are handled. 
-Instead of overloading the FADT Event Register blocks. This makes the code 
+Instead of overloading the FADT Event Register blocks. This makes the 
+code 
 clearer and less prone to error.
 
-Fixed the warning message for when the platform contains too many ACPI tables 
-for the default size of the global root table data structure. The calculation 
+Fixed the warning message for when the platform contains too many ACPI 
+tables 
+for the default size of the global root table data structure. The 
+calculation 
 for the truncation value was incorrect.
 
 Removed the ACPI_GET_OBJECT_TYPE macro. Removed all instances of this 
-obsolete macro, since it is now a simple reference to ->common.type. There 
+obsolete macro, since it is now a simple reference to ->common.type. 
+There 
 were about 150 invocations of the macro across 41 files. ACPICA BZ 755.
 
 Removed the redundant ACPI_BITREG_SLEEP_TYPE_B. This type is the same as 
@@ -2272,13 +6565,16 @@ Conditionally compile the AcpiSetFirmwareWakingVector64 function. This
 function is only needed on 64-bit host operating systems and is thus not 
 included for 32-bit hosts.
 
-Debug output: print the input and result for invocations of the _OSI reserved 
-control method via the ACPI_LV_INFO debug level. Also, reduced some of the 
+Debug output: print the input and result for invocations of the _OSI 
+reserved 
+control method via the ACPI_LV_INFO debug level. Also, reduced some of 
+the 
 verbosity of this debug level. Len Brown.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2302,21 +6598,28 @@ Added the 2009 copyright to all module headers and signons. This affects
 virtually every file in the ACPICA core subsystem, the iASL compiler, and 
 the tools/utilities.
 
-Implemented a change to allow the host to override any ACPI table, including 
-dynamically loaded tables. Previously, only the DSDT could be replaced by the 
-host. With this change, the AcpiOsTableOverride interface is called for each 
-table found in the RSDT/XSDT during ACPICA initialization, and also whenever 
+Implemented a change to allow the host to override any ACPI table, 
+including 
+dynamically loaded tables. Previously, only the DSDT could be replaced by 
+the 
+host. With this change, the AcpiOsTableOverride interface is called for 
+each 
+table found in the RSDT/XSDT during ACPICA initialization, and also 
+whenever 
 a table is dynamically loaded via the AML Load operator.
 
 Updated FADT flag definitions, especially the Boot Architecture flags.
 
-Debugger: For the Find command, automatically pad the input ACPI name with 
-underscores if the name is shorter than 4 characters. This enables a match 
+Debugger: For the Find command, automatically pad the input ACPI name 
+with 
+underscores if the name is shorter than 4 characters. This enables a 
+match 
 with the actual namespace entry which is itself padded with underscores.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2330,11 +6633,13 @@ much larger code and data size.
 
 Fix build error under Bison-2.4.
 
-Dissasembler: Enhanced FADT support. Added decoding of the Boot Architecture 
+Dissasembler: Enhanced FADT support. Added decoding of the Boot 
+Architecture 
 flags. Now decode all flags, regardless of the FADT version. Flag output 
 includes the FADT version which first defined each flag.
 
-The iASL -g option now dumps the RSDT to a file (in addition to the FADT and 
+The iASL -g option now dumps the RSDT to a file (in addition to the FADT 
+and 
 DSDT). Windows only.
 
 ----------------------------------------
@@ -2342,7 +6647,8 @@ DSDT). Windows only.
 
 1) ACPI CA Core Subsystem:
 
-The ACPICA Programmer Reference has been completely updated and revamped for 
+The ACPICA Programmer Reference has been completely updated and revamped 
+for 
 this release. This includes updates to the external interfaces, OSL 
 interfaces, the overview sections, and the debugger reference.
 
@@ -2356,31 +6662,38 @@ AcpiGbl_CurrentGpeCount - Tracks the current number of available GPEs.
 AcpiRead - Low-level read ACPI register (was HwLowLevelRead.)
 AcpiWrite - Low-level write ACPI register (was HwLowLevelWrite.)
 
-Most of the public ACPI hardware-related interfaces have been moved to a new 
+Most of the public ACPI hardware-related interfaces have been moved to a 
+new 
 file, components/hardware/hwxface.c
 
 Enhanced the FADT parsing and low-level ACPI register access: The ACPI 
 register lengths within the FADT are now used, and the low level ACPI 
 register access no longer hardcodes the ACPI register lengths. Given that 
-there may be some risk in actually trusting the FADT register lengths, a run-
-time option was added to fall back to the default hardcoded lengths if the 
+there may be some risk in actually trusting the FADT register lengths, a 
+run-
+time option was added to fall back to the default hardcoded lengths if 
+the 
 FADT proves to contain incorrect values - UseDefaultRegisterWidths. This 
-option is set to true for now, and a warning is issued if a suspicious FADT 
+option is set to true for now, and a warning is issued if a suspicious 
+FADT 
 register length is overridden with the default value.
 
-Fixed a reference count issue in NsRepairObject. This problem was introduced 
+Fixed a reference count issue in NsRepairObject. This problem was 
+introduced 
 in version 20081031 as part of a fix to repair Buffer objects within 
 Packages. Lin Ming.
 
 Added semaphore support to the Linux/Unix application OS-services layer 
 (OSL). ACPICA BZ 448. Lin Ming.
 
-Added the ACPI_MUTEX_TYPE configuration option to select whether mutexes will 
+Added the ACPI_MUTEX_TYPE configuration option to select whether mutexes 
+will 
 be implemented in the OSL, or will binary semaphores be used instead.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2392,88 +6705,124 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Completed the '-e' option to include additional ACPI tables in order to 
-aid with disassembly and External statement generation. ACPICA BZ 742. Lin 
+iASL: Completed the '-e' option to include additional ACPI tables in 
+order 
+to 
+aid with disassembly and External statement generation. ACPICA BZ 742. 
+Lin 
 Ming.
 
 iASL: Removed the "named object in while loop" error. The compiler cannot 
 determine how many times a loop will execute. ACPICA BZ 730.
 
-Disassembler: Implemented support for FADT revision 2 (MS extension). ACPICA 
+Disassembler: Implemented support for FADT revision 2 (MS extension). 
+ACPICA 
 BZ 743.
 
-Disassembler: Updates for several ACPI data tables (HEST, EINJ, and MCFG).
+Disassembler: Updates for several ACPI data tables (HEST, EINJ, and 
+MCFG).
 
 ----------------------------------------
 31 October 2008. Summary of changes for version 20081031:
 
 1) ACPI CA Core Subsystem:
 
-Restructured the ACPICA header files into public/private. acpi.h now includes 
-only the "public" acpica headers. All other acpica headers are "private" and 
-should not be included by acpica users. One new file, accommon.h is used to 
-include the commonly used private headers for acpica code generation. Future 
+Restructured the ACPICA header files into public/private. acpi.h now 
+includes 
+only the "public" acpica headers. All other acpica headers are "private" 
+and 
+should not be included by acpica users. One new file, accommon.h is used 
+to 
+include the commonly used private headers for acpica code generation. 
+Future 
 plans include moving all private headers to a new subdirectory.
 
 Implemented an automatic Buffer->String return value conversion for 
-predefined ACPI methods. For these methods (such as _BIF), added automatic 
-conversion for return objects that are required to be a String, but a Buffer 
-was found instead. This can happen when reading string battery data from an 
-operation region, because it used to be difficult to convert the data from 
-buffer to string from within the ASL. Ensures that the host OS is provided 
+predefined ACPI methods. For these methods (such as _BIF), added 
+automatic 
+conversion for return objects that are required to be a String, but a 
+Buffer 
+was found instead. This can happen when reading string battery data from 
+an 
+operation region, because it used to be difficult to convert the data 
+from 
+buffer to string from within the ASL. Ensures that the host OS is 
+provided 
 with a valid null-terminated string. Linux BZ 11822.
 
-Updated the FACS waking vector interfaces. Split AcpiSetFirmwareWakingVector 
-into two: one for the 32-bit vector, another for the 64-bit vector. This is 
-required because the host OS must setup the wake much differently for each 
-vector (real vs. protected mode, etc.) and the interface itself should not be 
-deciding which vector to use. Also, eliminated the GetFirmwareWakingVector 
-interface, as it served no purpose (only the firmware reads the vector, OS 
+Updated the FACS waking vector interfaces. Split 
+AcpiSetFirmwareWakingVector 
+into two: one for the 32-bit vector, another for the 64-bit vector. This 
+is 
+required because the host OS must setup the wake much differently for 
+each 
+vector (real vs. protected mode, etc.) and the interface itself should 
+not 
+be 
+deciding which vector to use. Also, eliminated the 
+GetFirmwareWakingVector 
+interface, as it served no purpose (only the firmware reads the vector, 
+OS 
 only writes the vector.) ACPICA BZ 731.
 
-Implemented a mechanism to escape infinite AML While() loops. Added a loop 
-counter to force exit from AML While loops if the count becomes too large. 
+Implemented a mechanism to escape infinite AML While() loops. Added a 
+loop 
+counter to force exit from AML While loops if the count becomes too 
+large. 
 This can occur in poorly written AML when the hardware does not respond 
-within a while loop and the loop does not implement a timeout. The maximum 
-loop count is configurable. A new exception code is returned when a loop is 
+within a while loop and the loop does not implement a timeout. The 
+maximum 
+loop count is configurable. A new exception code is returned when a loop 
+is 
 broken, AE_AML_INFINITE_LOOP. Alexey Starikovskiy, Bob Moore.
 
 Optimized the execution of AML While loops. Previously, a control state 
 object was allocated and freed for each execution of the loop. The 
-optimization is to simply reuse the control state for each iteration. This 
+optimization is to simply reuse the control state for each iteration. 
+This 
 speeds up the raw loop execution time by about 5%.
 
-Enhanced the implicit return mechanism. For Windows compatibility, return an 
-implicit integer of value zero for methods that contain no executable code. 
+Enhanced the implicit return mechanism. For Windows compatibility, return 
+an 
+implicit integer of value zero for methods that contain no executable 
+code. 
 Such methods are seen in the field as stubs (presumably), and can cause 
 drivers to fail if they expect a return value. Lin Ming.
 
 Allow multiple backslashes as root prefixes in namepaths. In a fully 
-qualified namepath, allow multiple backslash prefixes. This can happen (and 
+qualified namepath, allow multiple backslash prefixes. This can happen 
+(and 
 is seen in the field) because of the use of a double-backslash in strings 
-(since backslash is the escape character) causing confusion. ACPICA BZ 739 
+(since backslash is the escape character) causing confusion. ACPICA BZ 
+739 
 Lin Ming.
 
 Emit a warning if two different FACS or DSDT tables are discovered in the 
-FADT. Checks if there are two valid but different addresses for the FACS and 
+FADT. Checks if there are two valid but different addresses for the FACS 
+and 
 DSDT within the FADT (mismatch between the 32-bit and 64-bit fields.)
 
-Consolidated the method argument count validation code. Merged the code that 
+Consolidated the method argument count validation code. Merged the code 
+that 
 validates control method argument counts into the predefined validation 
-module. Eliminates possible multiple warnings for incorrect argument counts.
+module. Eliminates possible multiple warnings for incorrect argument 
+counts.
 
 Implemented ACPICA example code. Includes code for ACPICA initialization, 
 handler installation, and calling a control method. Available at 
 source/tools/examples.
 
-Added a global pointer for FACS table to simplify internal FACS access. Use 
-the global pointer instead of using AcpiGetTableByIndex for each FACS access. 
+Added a global pointer for FACS table to simplify internal FACS access. 
+Use 
+the global pointer instead of using AcpiGetTableByIndex for each FACS 
+access. 
 This simplifies the code for the Global Lock and the Firmware Waking 
 Vector(s).
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2485,14 +6834,20 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-iASL: Improved disassembly of external method calls. Added the -e option to 
-allow the inclusion of additional ACPI tables to help with the disassembly of 
+iASL: Improved disassembly of external method calls. Added the -e option 
+to 
+allow the inclusion of additional ACPI tables to help with the 
+disassembly 
+of 
 method invocations and the generation of external declarations during the 
 disassembly. Certain external method invocations cannot be disassembled 
-properly without the actual declaration of the method. Use the -e option to 
-include the table where the external method(s) are actually declared. Most 
+properly without the actual declaration of the method. Use the -e option 
+to 
+include the table where the external method(s) are actually declared. 
+Most 
 useful for disassembling SSDTs that make method calls back to the master 
-DSDT. Lin Ming. Example: To disassemble an SSDT with calls to DSDT:  iasl -d 
+DSDT. Lin Ming. Example: To disassemble an SSDT with calls to DSDT:  iasl 
+-d 
 -e dsdt.aml ssdt1.aml
 
 iASL: Fix to allow references to aliases within ASL namepaths. Fixes a 
@@ -2505,46 +6860,61 @@ references from the Alias operator itself. ACPICA BZ 738.
 
 1) ACPI CA Core Subsystem:
 
-Designed and implemented a mechanism to validate predefined ACPI methods and 
-objects. This code validates the predefined ACPI objects (objects whose names 
+Designed and implemented a mechanism to validate predefined ACPI methods 
+and 
+objects. This code validates the predefined ACPI objects (objects whose 
+names 
 start with underscore) that appear in the namespace, at the time they are 
 evaluated. The argument count and the type of the returned object are 
-validated against the ACPI specification. The purpose of this validation is 
-to detect problems with the BIOS-implemented predefined ACPI objects before 
-the results are returned to the ACPI-related drivers. Future enhancements may 
+validated against the ACPI specification. The purpose of this validation 
+is 
+to detect problems with the BIOS-implemented predefined ACPI objects 
+before 
+the results are returned to the ACPI-related drivers. Future enhancements 
+may 
 include actual repair of incorrect return objects where possible. Two new 
 files are nspredef.c and acpredef.h.
 
-Fixed a fault in the AML parser if a memory allocation fails during the Op 
+Fixed a fault in the AML parser if a memory allocation fails during the 
+Op 
 completion routine AcpiPsCompleteThisOp. Lin Ming. ACPICA BZ 492.
 
-Fixed an issue with implicit return compatibility. This change improves the 
-implicit return mechanism to be more compatible with the MS interpreter. Lin 
+Fixed an issue with implicit return compatibility. This change improves 
+the 
+implicit return mechanism to be more compatible with the MS interpreter. 
+Lin 
 Ming, ACPICA BZ 349.
 
-Implemented support for zero-length buffer-to-string conversions. Allow zero 
-length strings during interpreter buffer-to-string conversions. For example, 
+Implemented support for zero-length buffer-to-string conversions. Allow 
+zero 
+length strings during interpreter buffer-to-string conversions. For 
+example, 
 during the ToDecimalString and ToHexString operators, as well as implicit 
 conversions. Fiodor Suietov, ACPICA BZ 585.
 
 Fixed two possible memory leaks in the error exit paths of 
-AcpiUtUpdateObjectReference and AcpiUtWalkPackageTree. These functions are 
+AcpiUtUpdateObjectReference and AcpiUtWalkPackageTree. These functions 
+are 
 similar in that they use a stack of state objects in order to eliminate 
 recursion. The stack must be fully unwound and deallocated if an error 
 occurs. Lin Ming. ACPICA BZ 383.
 
-Removed the unused ACPI_BITREG_WAKE_ENABLE definition and entry in the global 
+Removed the unused ACPI_BITREG_WAKE_ENABLE definition and entry in the 
+global 
 ACPI register table. This bit does not exist and is unused. Lin Ming, Bob 
 Moore ACPICA BZ 442.
 
 Removed the obsolete version number in module headers. Removed the 
-"$Revision" number that appeared in each module header. This version number 
-was useful under SourceSafe and CVS, but has no meaning under git. It is not 
+"$Revision" number that appeared in each module header. This version 
+number 
+was useful under SourceSafe and CVS, but has no meaning under git. It is 
+not 
 only incorrect, it could also be misleading.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2560,43 +6930,57 @@ much larger code and data size.
 1) ACPI CA Core Subsystem:
 
 Completed a major cleanup of the internal ACPI_OPERAND_OBJECT of type 
-Reference. Changes include the elimination of cheating on the Object field 
+Reference. Changes include the elimination of cheating on the Object 
+field 
 for the DdbHandle subtype, addition of a reference class field to 
-differentiate the various reference types (instead of an AML opcode), and the 
+differentiate the various reference types (instead of an AML opcode), and 
+the 
 cleanup of debug output for this object. Lin Ming, Bob Moore. BZ 723
 
 Reduce an error to a warning for an incorrect method argument count. 
 Previously aborted with an error if too few arguments were passed to a 
-control method via the external ACPICA interface. Now issue a warning instead 
-and continue. Handles the case where the method inadvertently declares too 
-many arguments, but does not actually use the extra ones. Applies mainly to 
+control method via the external ACPICA interface. Now issue a warning 
+instead 
+and continue. Handles the case where the method inadvertently declares 
+too 
+many arguments, but does not actually use the extra ones. Applies mainly 
+to 
 the predefined methods. Lin Ming. Linux BZ 11032.
 
-Disallow the evaluation of named object types with no intrinsic value. Return 
-AE_TYPE for objects that have no value and therefore evaluation is undefined: 
-Device, Event, Mutex, Region, Thermal, and Scope. Previously, evaluation of 
-these types were allowed, but an exception would be generated at some point 
+Disallow the evaluation of named object types with no intrinsic value. 
+Return 
+AE_TYPE for objects that have no value and therefore evaluation is 
+undefined: 
+Device, Event, Mutex, Region, Thermal, and Scope. Previously, evaluation 
+of 
+these types were allowed, but an exception would be generated at some 
+point 
 during the evaluation. Now, the error is generated up front.
 
 Fixed a possible memory leak in the AcpiNsGetExternalPathname function 
 (nsnames.c). Fixes a leak in the error exit path.
 
-Removed the obsolete debug levels ACPI_DB_WARN and ACPI_DB_ERROR. These debug 
-levels were made obsolete by the ACPI_WARNING, ACPI_ERROR, and ACPI_EXCEPTION 
+Removed the obsolete debug levels ACPI_DB_WARN and ACPI_DB_ERROR. These 
+debug 
+levels were made obsolete by the ACPI_WARNING, ACPI_ERROR, and 
+ACPI_EXCEPTION 
 interfaces. Also added ACPI_DB_EVENTS to correspond with the existing 
 ACPI_LV_EVENTS.
 
 Removed obsolete and/or unused exception codes from the acexcep.h header. 
-There is the possibility that certain device drivers may be affected if they 
+There is the possibility that certain device drivers may be affected if 
+they 
 use any of these exceptions.
 
-The ACPICA documentation has been added to the public git source tree, under 
+The ACPICA documentation has been added to the public git source tree, 
+under 
 acpica/documents. Included are the ACPICA programmer reference, the iASL 
 compiler reference, and the changes.txt release logfile.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2612,14 +6996,18 @@ Allow multiple argument counts for the predefined _SCP method. ACPI 3.0
 defines _SCP with 3 arguments. Previous versions defined it with only 1 
 argument. iASL now allows both definitions.
 
-iASL/disassembler: avoid infinite loop on bad ACPI tables. Check for zero-
+iASL/disassembler: avoid infinite loop on bad ACPI tables. Check for 
+zero-
 length subtables when disassembling ACPI tables. Also fixed a couple of 
-errors where a full 16-bit table type field was not extracted from the input 
+errors where a full 16-bit table type field was not extracted from the 
+input 
 properly.
 
 acpisrc: Improve comment counting mechanism for generating source code 
-statistics. Count first and last lines of multi-line comments as whitespace, 
-not comment lines. Handle Linux legal header in addition to standard acpica 
+statistics. Count first and last lines of multi-line comments as 
+whitespace, 
+not comment lines. Handle Linux legal header in addition to standard 
+acpica 
 header.
 
 ----------------------------------------
@@ -2629,41 +7017,57 @@ header.
 1) ACPI CA Core Subsystem:
 
 Fix a possible deadlock in the GPE dispatch. Remove call to 
-AcpiHwDisableAllGpes during wake in AcpiEvGpeDispatch. This call will attempt 
-to acquire the GPE lock but can deadlock since the GPE lock is already held 
-at dispatch time. This code was introduced in version 20060831 as a response 
+AcpiHwDisableAllGpes during wake in AcpiEvGpeDispatch. This call will 
+attempt 
+to acquire the GPE lock but can deadlock since the GPE lock is already 
+held 
+at dispatch time. This code was introduced in version 20060831 as a 
+response 
 to Linux BZ 6881 and has since been removed from Linux.
 
-Add a function to dereference returned reference objects. Examines the return 
-object from a call to AcpiEvaluateObject. Any Index or RefOf references are 
-automatically dereferenced in an attempt to return something useful (these 
-reference types cannot be converted into an external ACPI_OBJECT.) Provides 
+Add a function to dereference returned reference objects. Examines the 
+return 
+object from a call to AcpiEvaluateObject. Any Index or RefOf references 
+are 
+automatically dereferenced in an attempt to return something useful 
+(these 
+reference types cannot be converted into an external ACPI_OBJECT.) 
+Provides 
 MS compatibility. Lin Ming, Bob Moore. Linux BZ 11105
 
 x2APIC support: changes for MADT and SRAT ACPI tables. There are 2 new 
 subtables for the MADT and one new subtable for the SRAT. Includes 
-disassembler and AcpiSrc support. Data from the Intel 64 Architecture x2APIC 
+disassembler and AcpiSrc support. Data from the Intel 64 Architecture 
+x2APIC 
 Specification, June 2008.
 
-Additional error checking for pathname utilities. Add error check after all 
+Additional error checking for pathname utilities. Add error check after 
+all 
 calls to AcpiNsGetPathnameLength. Add status return from 
-AcpiNsBuildExternalPath and check after all calls. Add parameter validation 
+AcpiNsBuildExternalPath and check after all calls. Add parameter 
+validation 
 to AcpiUtInitializeBuffer. Reported by and initial patch by Ingo Molnar.
 
-Return status from the global init function AcpiUtGlobalInitialize. This is 
-used by both the kernel subsystem and the utilities such as iASL compiler. 
-The function could possibly fail when the caches are initialized. Yang Yi.
+Return status from the global init function AcpiUtGlobalInitialize. This 
+is 
+used by both the kernel subsystem and the utilities such as iASL 
+compiler. 
+The function could possibly fail when the caches are initialized. Yang 
+Yi.
 
 Add a function to decode reference object types to strings. Created for 
 improved error messages. 
 
-Improve object conversion error messages. Better error messages during object 
-conversion from internal to the external ACPI_OBJECT. Used for external calls 
+Improve object conversion error messages. Better error messages during 
+object 
+conversion from internal to the external ACPI_OBJECT. Used for external 
+calls 
 to AcpiEvaluateObject.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2675,9 +7079,12 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Debugger: fix a possible hang when evaluating non-methods. Fixes a problem 
-introduced in version 20080701. If the object being evaluated (via execute 
-command) is not a method, the debugger can hang while trying to obtain non-
+Debugger: fix a possible hang when evaluating non-methods. Fixes a 
+problem 
+introduced in version 20080701. If the object being evaluated (via 
+execute 
+command) is not a method, the debugger can hang while trying to obtain 
+non-
 existent parameters.
 
 iASL: relax error for using reserved "_T_x" identifiers. These names can 
@@ -2685,16 +7092,24 @@ appear in a disassembled ASL file if they were emitted by the original
 compiler. Instead of issuing an error or warning and forcing the user to 
 manually change these names, issue a remark instead.
 
-iASL: error if named object created in while loop. Emit an error if any named 
-object is created within a While loop. If allowed, this code will generate a 
-run-time error on the second iteration of the loop when an attempt is made to 
+iASL: error if named object created in while loop. Emit an error if any 
+named 
+object is created within a While loop. If allowed, this code will 
+generate 
+a 
+run-time error on the second iteration of the loop when an attempt is 
+made 
+to 
 create the same named object twice. ACPICA bugzilla 730.
 
-iASL: Support absolute pathnames for include files. Add support for absolute 
-pathnames within the Include operator. previously, only relative pathnames 
+iASL: Support absolute pathnames for include files. Add support for 
+absolute 
+pathnames within the Include operator. previously, only relative 
+pathnames 
 were supported.
 
-iASL: Enforce minimum 1 interrupt in interrupt macro and Resource Descriptor. 
+iASL: Enforce minimum 1 interrupt in interrupt macro and Resource 
+Descriptor. 
 The ACPI spec requires one interrupt minimum. BZ 423
 
 iASL: Handle a missing ResourceSource arg, with a present SourceIndex. 
@@ -2702,13 +7117,16 @@ Handles the case for the Interrupt Resource Descriptor where
 the ResourceSource argument is omitted but ResourceSourceIndex
 is present. Now leave room for the Index. BZ 426
 
-iASL: Prevent error message if CondRefOf target does not exist. Fixes cases 
+iASL: Prevent error message if CondRefOf target does not exist. Fixes 
+cases 
 where an error message is emitted if the target does not exist. BZ 516
 
 iASL: Fix broken -g option (get Windows ACPI tables). Fixes the -g option 
-(get ACPI tables on Windows). This was apparently broken in version 20070919.
+(get ACPI tables on Windows). This was apparently broken in version 
+20070919.
 
-AcpiXtract: Handle EOF while extracting data. Correctly handle the case where 
+AcpiXtract: Handle EOF while extracting data. Correctly handle the case 
+where 
 the EOF happens immediately after the last table in the input file. Print 
 completion message. Previously, no message was displayed in this case.
 
@@ -2723,9 +7141,12 @@ source tree.
 1) ACPI CA Core Subsystem:
 
 Implemented a "careful" GPE disable in AcpiEvDisableGpe, only modify one 
-enable bit. Now performs a read-change-write of the enable register instead 
-of simply writing out the cached enable mask. This will prevent inadvertent 
-enabling of GPEs if a rogue GPE is received during initialization (before GPE 
+enable bit. Now performs a read-change-write of the enable register 
+instead 
+of simply writing out the cached enable mask. This will prevent 
+inadvertent 
+enabling of GPEs if a rogue GPE is received during initialization (before 
+GPE 
 handlers are installed.)
 
 Implemented a copy for dynamically loaded tables. Previously, dynamically 
@@ -2735,32 +7156,42 @@ OpRegion case, added checksum verify. Use the table length from the table
 header, not the region length. For the Buffer case, use the table length 
 also. Dennis Noordsij, Bob Moore. BZ 10734
 
-Fixed a problem where the same ACPI table could not be dynamically loaded and 
-unloaded more than once. Without this change, a table cannot be loaded again 
+Fixed a problem where the same ACPI table could not be dynamically loaded 
+and 
+unloaded more than once. Without this change, a table cannot be loaded 
+again 
 once it has been loaded/unloaded one time. The current mechanism does not 
-unregister a table upon an unload. During a load, if the same table is found, 
+unregister a table upon an unload. During a load, if the same table is 
+found, 
 this no longer returns an exception. BZ 722
 
 Fixed a problem where the wrong descriptor length was calculated for the 
-EndTag descriptor in 64-bit mode. The "minimal" descriptors such as EndTag 
+EndTag descriptor in 64-bit mode. The "minimal" descriptors such as 
+EndTag 
 are calculated as 12 bytes long, but the actual length in the internal 
-descriptor is 16 because of the round-up to 8 on the 64-bit build. Reported 
+descriptor is 16 because of the round-up to 8 on the 64-bit build. 
+Reported 
 by Linn Crosetto. BZ 728
 
-Fixed a possible memory leak in the Unload operator. The DdbHandle returned 
-by Load() did not have its reference count decremented during unload, leading 
+Fixed a possible memory leak in the Unload operator. The DdbHandle 
+returned 
+by Load() did not have its reference count decremented during unload, 
+leading 
 to a memory leak. Lin Ming. BZ 727
 
 Fixed a possible memory leak when deleting thermal/processor objects. Any 
 associated notify handlers (and objects) were not being deleted. Fiodor 
 Suietov. BZ 506
 
-Fixed the ordering of the ASCII names in the global mutex table to match the 
-actual mutex IDs. Used by AcpiUtGetMutexName, a function used for debug only. 
+Fixed the ordering of the ASCII names in the global mutex table to match 
+the 
+actual mutex IDs. Used by AcpiUtGetMutexName, a function used for debug 
+only. 
 Vegard Nossum. BZ 726
 
 Enhanced the AcpiGetObjectInfo interface to return the number of required 
-arguments if the object is a control method. Added this call to the debugger 
+arguments if the object is a control method. Added this call to the 
+debugger 
 so the proper number of default arguments are passed to a method. This 
 prevents a warning when executing methods from AcpiExec.
 
@@ -2771,7 +7202,8 @@ Fixed an extraneous warning from exconfig.c on the 64-bit build.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2786,20 +7218,28 @@ much larger code and data size.
 iASL: Added two missing ACPI reserved names. Added _MTP and _ASZ, both 
 resource descriptor names.
 
-iASL: Detect invalid ASCII characters in input (windows version). Removed the 
+iASL: Detect invalid ASCII characters in input (windows version). Removed 
+the 
 "-CF" flag from the flex compile, enables correct detection of non-ASCII 
 characters in the input. BZ 441
 
-iASL: Eliminate warning when result of LoadTable is not used. Eliminate the 
+iASL: Eliminate warning when result of LoadTable is not used. Eliminate 
+the 
 "result of operation not used" warning when the DDB handle returned from 
 LoadTable is not used. The warning is not needed. BZ 590
 
-AcpiExec: Add support for dynamic table load/unload. Now calls _CFG method to 
-pass address of table to the AML. Added option to disable OpRegion simulation 
-to allow creation of an OpRegion with a real address that was passed to _CFG. 
-All of this allows testing of the Load and Unload operators from AcpiExec.
-
-Debugger: update tables command for unloaded tables. Handle unloaded tables 
+AcpiExec: Add support for dynamic table load/unload. Now calls _CFG 
+method 
+to 
+pass address of table to the AML. Added option to disable OpRegion 
+simulation 
+to allow creation of an OpRegion with a real address that was passed to 
+_CFG. 
+All of this allows testing of the Load and Unload operators from 
+AcpiExec.
+
+Debugger: update tables command for unloaded tables. Handle unloaded 
+tables 
 and use the standard table header output routine.
 
 ----------------------------------------
@@ -2807,49 +7247,64 @@ and use the standard table header output routine.
 
 1) ACPI CA Core Subsystem:
 
-Implemented a workaround for reversed _PRT entries. A significant number of 
+Implemented a workaround for reversed _PRT entries. A significant number 
+of 
 BIOSs erroneously reverse the _PRT SourceName and the SourceIndex. This 
-change dynamically detects and repairs this problem. Provides compatibility 
+change dynamically detects and repairs this problem. Provides 
+compatibility 
 with MS ACPI. BZ 6859
 
 Simplified the internal ACPI hardware interfaces to eliminate the locking 
 flag parameter from Register Read/Write. Added a new external interface, 
 AcpiGetRegisterUnlocked.
 
-Fixed a problem where the invocation of a GPE control method could hang. This 
+Fixed a problem where the invocation of a GPE control method could hang. 
+This 
 was a regression introduced in 20080514. The new method argument count 
 validation mechanism can enter an infinite loop when a GPE method is 
-dispatched. Problem fixed by removing the obsolete code that passed GPE block 
-information to the notify handler via the control method parameter pointer.
+dispatched. Problem fixed by removing the obsolete code that passed GPE 
+block 
+information to the notify handler via the control method parameter 
+pointer.
 
-Fixed a problem where the _SST execution status was incorrectly returned to 
-the caller of AcpiEnterSleepStatePrep. This was a regression introduced in 
+Fixed a problem where the _SST execution status was incorrectly returned 
+to 
+the caller of AcpiEnterSleepStatePrep. This was a regression introduced 
+in 
 20080514. _SST is optional and a NOT_FOUND exception should never be 
 returned. BZ 716
 
-Fixed a problem where a deleted object could be accessed from within the AML 
-parser. This was a regression introduced in version 20080123 as a fix for the 
+Fixed a problem where a deleted object could be accessed from within the 
+AML 
+parser. This was a regression introduced in version 20080123 as a fix for 
+the 
 Unload operator. Lin Ming. BZ 10669
 
-Cleaned up the debug operand dump mechanism. Eliminated unnecessary operands 
+Cleaned up the debug operand dump mechanism. Eliminated unnecessary 
+operands 
 and eliminated the use of a negative index in a loop. Operands are now 
-displayed in the correct order, not backwards. This also fixes a regression 
+displayed in the correct order, not backwards. This also fixes a 
+regression 
 introduced in 20080514 on 64-bit systems where the elimination of 
-ACPI_NATIVE_UINT caused the negative index to go large and positive. BZ 715
+ACPI_NATIVE_UINT caused the negative index to go large and positive. BZ 
+715
 
-Fixed a possible memory leak in EvPciConfigRegionSetup where the error exit 
+Fixed a possible memory leak in EvPciConfigRegionSetup where the error 
+exit 
 path did not delete a locally allocated structure.
 
 Updated definitions for the DMAR and SRAT tables to synchronize with the 
 current specifications. Includes disassembler support.
 
 Fixed a problem in the mutex debug code (in utmutex.c) where an incorrect 
-loop termination value was used. Loop terminated on iteration early, missing 
+loop termination value was used. Loop terminated on iteration early, 
+missing 
 one mutex. Linn Crosetto
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2875,39 +7330,54 @@ Disassembler: Added support for DMAR and SRAT table definition changes.
 
 Fixed a problem where GPEs were enabled too early during the ACPICA 
 initialization. This could lead to "handler not installed" errors on some 
-machines. Moved GPE enable until after _REG/_STA/_INI methods are run. This 
-ensures that all operation regions and devices throughout the namespace have 
+machines. Moved GPE enable until after _REG/_STA/_INI methods are run. 
+This 
+ensures that all operation regions and devices throughout the namespace 
+have 
 been initialized before GPEs are enabled. Alexey Starikovskiy, BZ 9916.
 
 Implemented a change to the enter sleep code. Moved execution of the _GTS 
-method to just before setting sleep enable bit. The execution was moved from 
+method to just before setting sleep enable bit. The execution was moved 
+from 
 AcpiEnterSleepStatePrep to AcpiEnterSleepState. _GTS is now executed 
 immediately before the SLP_EN bit is set, as per the ACPI specification. 
 Luming Yu, BZ 1653.
 
-Implemented a fix to disable unknown GPEs (2nd version). Now always disable 
+Implemented a fix to disable unknown GPEs (2nd version). Now always 
+disable 
 the GPE, even if ACPICA thinks that that it is already disabled. It is 
-possible that the AML or some other code has enabled the GPE unbeknownst to 
+possible that the AML or some other code has enabled the GPE unbeknownst 
+to 
 the ACPICA code.
 
-Fixed a problem with the Field operator where zero-length fields would return 
-an AE_AML_NO_OPERAND exception during table load. Fix enables zero-length ASL 
+Fixed a problem with the Field operator where zero-length fields would 
+return 
+an AE_AML_NO_OPERAND exception during table load. Fix enables zero-length 
+ASL 
 field declarations in Field(), BankField(), and IndexField(). BZ 10606.
 
-Implemented a fix for the Load operator, now load the table at the namespace 
-root. This reverts a change introduced in version 20071019. The table is now 
+Implemented a fix for the Load operator, now load the table at the 
+namespace 
+root. This reverts a change introduced in version 20071019. The table is 
+now 
 loaded at the namespace root even though this goes against the ACPI 
-specification. This provides compatibility with other ACPI implementations. 
-The ACPI specification will be updated to reflect this in ACPI 4.0. Lin Ming.
+specification. This provides compatibility with other ACPI 
+implementations. 
+The ACPI specification will be updated to reflect this in ACPI 4.0. Lin 
+Ming.
 
-Fixed a problem where ACPICA would not Load() tables with unusual signatures. 
+Fixed a problem where ACPICA would not Load() tables with unusual 
+signatures. 
 Now ignore ACPI table signature for Load() operator. Only "SSDT" is 
 acceptable to the ACPI spec, but tables are seen with OEMx and null sigs. 
-Therefore, signature validation is worthless. Apparently MS ACPI accepts such 
+Therefore, signature validation is worthless. Apparently MS ACPI accepts 
+such 
 signatures, ACPICA must be compatible. BZ 10454.
 
-Fixed a possible negative array index in AcpiUtValidateException. Added NULL 
-fields to the exception string arrays to eliminate a -1 subtraction on the 
+Fixed a possible negative array index in AcpiUtValidateException. Added 
+NULL 
+fields to the exception string arrays to eliminate a -1 subtraction on 
+the 
 SubStatus field.
 
 Updated the debug tracking macros to reduce overall code and data size. 
@@ -2915,13 +7385,19 @@ Changed ACPI_MODULE_NAME and ACPI_FUNCTION_NAME to use arrays of strings
 instead of pointers to static strings. Jan Beulich and Bob Moore.
 
 Implemented argument count checking in control method invocation via 
-AcpiEvaluateObject. Now emit an error if too few arguments, warning if too 
-many. This applies only to extern programmatic control method execution, not 
+AcpiEvaluateObject. Now emit an error if too few arguments, warning if 
+too 
+many. This applies only to extern programmatic control method execution, 
+not 
 method-to-method calls within the AML. Lin Ming.
 
-Eliminated the ACPI_NATIVE_UINT type across all ACPICA code. This type is no 
-longer needed, especially with the removal of 16-bit support. It was replaced 
-mostly with UINT32, but also ACPI_SIZE where a type that changes 32/64 bit on 
+Eliminated the ACPI_NATIVE_UINT type across all ACPICA code. This type is 
+no 
+longer needed, especially with the removal of 16-bit support. It was 
+replaced 
+mostly with UINT32, but also ACPI_SIZE where a type that changes 32/64 
+bit 
+on 
 32/64-bit platforms is required.
 
 Added the C const qualifier for appropriate string constants -- mostly 
@@ -2929,7 +7405,8 @@ MODULE_NAME and printf format strings. Jan Beulich.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has a 
+debug version of the code includes the debug output trace mechanism and 
+has a 
 much larger code and data size.
 
   Previous Release:
@@ -2941,8 +7418,10 @@ much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Implemented ACPI table revision ID validation in the disassembler. Zero is 
-always invalid. For DSDTs, the ID controls the interpreter integer width. 1 
+Implemented ACPI table revision ID validation in the disassembler. Zero 
+is 
+always invalid. For DSDTs, the ID controls the interpreter integer width. 
+1 
 means 32-bit and this is unusual. 2 or greater is 64-bit.
 
 ----------------------------------------
@@ -2951,54 +7430,75 @@ means 32-bit and this is unusual. 2 or greater is 64-bit.
 1) ACPI CA Core Subsystem:
 
 Implemented an additional change to the GPE support in order to suppress 
-spurious or stray GPEs. The AcpiEvDisableGpe function will now permanently 
-disable incoming GPEs that are neither enabled nor disabled -- meaning that 
-the GPE is unknown to the system. This should prevent future interrupt floods 
+spurious or stray GPEs. The AcpiEvDisableGpe function will now 
+permanently 
+disable incoming GPEs that are neither enabled nor disabled -- meaning 
+that 
+the GPE is unknown to the system. This should prevent future interrupt 
+floods 
 from that GPE. BZ 6217 (Zhang Rui)
 
 Fixed a problem where NULL package elements were not returned to the 
 AcpiEvaluateObject interface correctly. The element was simply ignored 
-instead of returning a NULL ACPI_OBJECT package element, potentially causing 
-a buffer overflow and/or confusing the caller who expected a fixed number of 
+instead of returning a NULL ACPI_OBJECT package element, potentially 
+causing 
+a buffer overflow and/or confusing the caller who expected a fixed number 
+of 
 elements. BZ 10132 (Lin Ming, Bob Moore)
 
-Fixed a problem with the CreateField, CreateXXXField (Bit, Byte, Word, Dword, 
-Qword), Field, BankField, and IndexField operators when invoked from inside 
-an executing control method. In this case, these operators created namespace 
+Fixed a problem with the CreateField, CreateXXXField (Bit, Byte, Word, 
+Dword, 
+Qword), Field, BankField, and IndexField operators when invoked from 
+inside 
+an executing control method. In this case, these operators created 
+namespace 
 nodes that were incorrectly left marked as permanent nodes instead of 
 temporary nodes. This could cause a problem if there is race condition 
-between an exiting control method and a running namespace walk. (Reported by 
+between an exiting control method and a running namespace walk. (Reported 
+by 
 Linn Crosetto)
 
 Fixed a problem where the CreateField and CreateXXXField operators would 
-incorrectly allow duplicate names (the name of the field) with no exception 
+incorrectly allow duplicate names (the name of the field) with no 
+exception 
 generated.
 
-Implemented several changes for Notify handling. Added support for new Notify 
+Implemented several changes for Notify handling. Added support for new 
+Notify 
 values (ACPI 2.0+) and improved the Notify debug output. Notify on 
-PowerResource objects is no longer allowed, as per the ACPI specification. 
+PowerResource objects is no longer allowed, as per the ACPI 
+specification. 
 (Bob Moore, Zhang Rui)
 
-All Reference Objects returned via the AcpiEvaluateObject interface are now 
-marked as type "REFERENCE" instead of "ANY". The type ANY is now reserved for 
-NULL objects - either NULL package elements or unresolved named references.
+All Reference Objects returned via the AcpiEvaluateObject interface are 
+now 
+marked as type "REFERENCE" instead of "ANY". The type ANY is now reserved 
+for 
+NULL objects - either NULL package elements or unresolved named 
+references.
 
-Fixed a problem where an extraneous debug message was produced for package 
+Fixed a problem where an extraneous debug message was produced for 
+package 
 objects (when debugging enabled). The message "Package List length larger 
-than NumElements count" is now produced in the correct case, and is now an 
+than NumElements count" is now produced in the correct case, and is now 
+an 
 error message rather than a debug message. Added a debug message for the 
-opposite case, where NumElements is larger than the Package List (the package 
+opposite case, where NumElements is larger than the Package List (the 
+package 
 will be padded out with NULL elements as per the ACPI spec.)
 
-Implemented several improvements for the output of the ASL "Debug" object to 
+Implemented several improvements for the output of the ASL "Debug" object 
+to 
 clarify and keep all data for a given object on one output line.
 
-Fixed two size calculation issues with the variable-length Start Dependent 
+Fixed two size calculation issues with the variable-length Start 
+Dependent 
 resource descriptor.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3010,38 +7510,51 @@ a much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Fixed a problem with the use of the Switch operator where execution of the 
+Fixed a problem with the use of the Switch operator where execution of 
+the 
 containing method by multiple concurrent threads could cause an 
 AE_ALREADY_EXISTS exception. This is caused by the fact that there is no 
 actual Switch opcode, it must be simulated with local named temporary 
-variables and if/else pairs. The solution chosen was to mark any method that 
-uses Switch as Serialized, thus preventing multiple thread entries. BZ 469.
+variables and if/else pairs. The solution chosen was to mark any method 
+that 
+uses Switch as Serialized, thus preventing multiple thread entries. BZ 
+469.
 
 ----------------------------------------
 13 February 2008. Summary of changes for version 20080213:
 
 1) ACPI CA Core Subsystem:
 
-Implemented another MS compatibility design change for GPE/Notify handling. 
-GPEs are now cleared/enabled asynchronously to allow all pending notifies to 
+Implemented another MS compatibility design change for GPE/Notify 
+handling. 
+GPEs are now cleared/enabled asynchronously to allow all pending notifies 
+to 
 complete first. It is expected that the OSL will queue the enable request 
-behind all pending notify requests (may require changes to the local host OSL 
+behind all pending notify requests (may require changes to the local host 
+OSL 
 in AcpiOsExecute). Alexey Starikovskiy.
 
 Fixed a problem where buffer and package objects passed as arguments to a 
-control method via the external AcpiEvaluateObject interface could cause an 
+control method via the external AcpiEvaluateObject interface could cause 
+an 
 AE_AML_INTERNAL exception depending on the order and type of operators 
 executed by the target control method.
 
 Fixed a problem where resource descriptor size optimization could cause a 
-problem when a _CRS resource template is passed to a _SRS method. The _SRS 
+problem when a _CRS resource template is passed to a _SRS method. The 
+_SRS 
 resource template must use the same descriptors (with the same size) as 
-returned from _CRS. This change affects the following resource descriptors: 
-IRQ / IRQNoFlags and StartDependendentFn / StartDependentFnNoPri. (BZ 9487)
-
-Fixed a problem where a CopyObject to RegionField, BankField, and IndexField 
-objects did not perform an implicit conversion as it should. These types must 
-retain their initial type permanently as per the ACPI specification. However, 
+returned from _CRS. This change affects the following resource 
+descriptors: 
+IRQ / IRQNoFlags and StartDependendentFn / StartDependentFnNoPri. (BZ 
+9487)
+
+Fixed a problem where a CopyObject to RegionField, BankField, and 
+IndexField 
+objects did not perform an implicit conversion as it should. These types 
+must 
+retain their initial type permanently as per the ACPI specification. 
+However, 
 a CopyObject to all other object types should not perform an implicit 
 conversion, as per the ACPI specification. (Lin Ming, Bob Moore) BZ 388
 
@@ -3049,7 +7562,8 @@ Fixed a problem with the AcpiGetDevices interface where the mechanism to
 match device CIDs did not examine the entire list of available CIDs, but 
 instead aborted on the first non-matching CID. Andrew Patterson.
 
-Fixed a regression introduced in version 20071114. The ACPI_HIDWORD macro was 
+Fixed a regression introduced in version 20071114. The ACPI_HIDWORD macro 
+was 
 inadvertently changed to return a 16-bit value instead of a 32-bit value, 
 truncating the upper dword of a 64-bit value. This macro is only used to 
 display debug output, so no incorrect calculations were made. Also, 
@@ -3061,7 +7575,8 @@ statement.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3087,39 +7602,56 @@ Added the 2008 copyright to all module headers and signons. This affects
 virtually every file in the ACPICA core subsystem, the iASL compiler, and 
 the tools/utilities.
 
-Fixed a problem with the SizeOf operator when used with Package and Buffer 
-objects. These objects have deferred execution for some arguments, and the 
-execution is now completed before the SizeOf is executed. This problem caused 
-unexpected AE_PACKAGE_LIMIT errors on some systems (Lin Ming, Bob Moore) BZ 
+Fixed a problem with the SizeOf operator when used with Package and 
+Buffer 
+objects. These objects have deferred execution for some arguments, and 
+the 
+execution is now completed before the SizeOf is executed. This problem 
+caused 
+unexpected AE_PACKAGE_LIMIT errors on some systems (Lin Ming, Bob Moore) 
+BZ 
 9558
 
-Implemented an enhancement to the interpreter "slack mode". In the absence of 
-an explicit return or an implicitly returned object from the last executed 
-opcode, a control method will now implicitly return an integer of value 0 for 
+Implemented an enhancement to the interpreter "slack mode". In the 
+absence 
+of 
+an explicit return or an implicitly returned object from the last 
+executed 
+opcode, a control method will now implicitly return an integer of value 0 
+for 
 Microsoft compatibility. (Lin Ming) BZ 392
 
-Fixed a problem with the Load operator where an exception was not returned in 
+Fixed a problem with the Load operator where an exception was not 
+returned 
+in 
 the case where the table is already loaded. (Lin Ming) BZ 463
 
-Implemented support for the use of DDBHandles as an Indexed Reference, as per 
+Implemented support for the use of DDBHandles as an Indexed Reference, as 
+per 
 the ACPI spec. (Lin Ming) BZ 486
 
-Implemented support for UserTerm (Method invocation) for the Unload operator 
+Implemented support for UserTerm (Method invocation) for the Unload 
+operator 
 as per the ACPI spec. (Lin Ming) BZ 580
 
-Fixed a problem with the LoadTable operator where the OemId and OemTableId 
-input strings could cause unexpected failures if they were shorter than the 
+Fixed a problem with the LoadTable operator where the OemId and 
+OemTableId 
+input strings could cause unexpected failures if they were shorter than 
+the 
 maximum lengths allowed. (Lin Ming, Bob Moore) BZ 576
 
-Implemented support for UserTerm (Method invocation) for the Unload operator 
+Implemented support for UserTerm (Method invocation) for the Unload 
+operator 
 as per the ACPI spec. (Lin Ming) BZ 580
 
-Implemented header file support for new ACPI tables - BERT, ERST, EINJ, HEST, 
+Implemented header file support for new ACPI tables - BERT, ERST, EINJ, 
+HEST, 
 IBFT, UEFI, WDAT. Disassembler support is forthcoming.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3131,25 +7663,32 @@ a much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Implemented support in the disassembler for checksum validation on incoming 
-binary DSDTs and SSDTs. If incorrect, a message is displayed within the table 
+Implemented support in the disassembler for checksum validation on 
+incoming 
+binary DSDTs and SSDTs. If incorrect, a message is displayed within the 
+table 
 header dump at the start of the disassembly.
 
-Implemented additional debugging information in the namespace listing file 
-created during compilation. In addition to the namespace hierarchy, the full 
+Implemented additional debugging information in the namespace listing 
+file 
+created during compilation. In addition to the namespace hierarchy, the 
+full 
 pathname to each namespace object is displayed.
 
-Fixed a problem with the disassembler where invalid ACPI tables could cause 
+Fixed a problem with the disassembler where invalid ACPI tables could 
+cause 
 faults or infinite loops.
 
 Fixed an unexpected parse error when using the optional "parameter types" 
 list in a control method declaration. (Lin Ming) BZ 397
 
-Fixed a problem where two External declarations with the same name did not 
+Fixed a problem where two External declarations with the same name did 
+not 
 cause an error (Lin Ming) BZ 509
 
 Implemented support for full TermArgs (adding Argx, Localx and method 
-invocation) for the ParameterData parameter to the LoadTable operator. (Lin 
+invocation) for the ParameterData parameter to the LoadTable operator. 
+(Lin 
 Ming) BZ 583,587
 
 ----------------------------------------
@@ -3159,33 +7698,44 @@ Ming) BZ 583,587
 
 Implemented full support for deferred execution for the TermArg string 
 arguments for DataTableRegion. This enables forward references and full 
-operand resolution for the three string arguments. Similar to OperationRegion 
+operand resolution for the three string arguments. Similar to 
+OperationRegion 
 deferred argument execution.) Lin Ming. BZ 430
 
-Implemented full argument resolution support for the BankValue argument to 
-BankField. Previously, only constants were supported, now any TermArg may be 
+Implemented full argument resolution support for the BankValue argument 
+to 
+BankField. Previously, only constants were supported, now any TermArg may 
+be 
 used. Lin Ming BZ 387, 393
 
 Fixed a problem with AcpiGetDevices where the search of a branch of the 
 device tree could be terminated prematurely. In accordance with the ACPI 
-specification, the search down the current branch is terminated if a device 
-is both not present and not functional (instead of just not present.) Yakui 
+specification, the search down the current branch is terminated if a 
+device 
+is both not present and not functional (instead of just not present.) 
+Yakui 
 Zhao.
 
-Fixed a problem where "unknown" GPEs could be allowed to fire repeatedly if 
-the underlying AML code changed the GPE enable registers. Now, any unknown 
-incoming GPE (no _Lxx/_Exx method and not the EC GPE) is immediately disabled 
+Fixed a problem where "unknown" GPEs could be allowed to fire repeatedly 
+if 
+the underlying AML code changed the GPE enable registers. Now, any 
+unknown 
+incoming GPE (no _Lxx/_Exx method and not the EC GPE) is immediately 
+disabled 
 instead of simply ignored. Rui Zhang.
 
-Fixed a problem with Index Fields where the Index register was incorrectly 
+Fixed a problem with Index Fields where the Index register was 
+incorrectly 
 limited to a maximum of 32 bits. Now any size may be used.
 
-Fixed a couple memory leaks associated with "implicit return" objects when 
+Fixed a couple memory leaks associated with "implicit return" objects 
+when 
 the AML Interpreter slack mode is enabled. Lin Ming BZ 349
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3202,37 +7752,49 @@ a much larger code and data size.
 
 Implemented event counters for each of the Fixed Events, the ACPI SCI 
 (interrupt) itself, and control methods executed. Named 
-AcpiFixedEventCount[], AcpiSciCount, and AcpiMethodCount respectively. These 
+AcpiFixedEventCount[], AcpiSciCount, and AcpiMethodCount respectively. 
+These 
 should be useful for debugging and statistics.
 
 Implemented a new external interface, AcpiGetStatistics, to retrieve the 
 contents of the various event counters. Returns the current values for 
 AcpiSciCount, AcpiGpeCount, the AcpiFixedEventCount array, and 
-AcpiMethodCount. The interface can be expanded in the future if new counters 
-are added. Device drivers should use this interface rather than access the 
+AcpiMethodCount. The interface can be expanded in the future if new 
+counters 
+are added. Device drivers should use this interface rather than access 
+the 
 counters directly.
 
-Fixed a problem with the FromBCD and ToBCD operators. With some compilers, 
-the ShortDivide function worked incorrectly, causing problems with the BCD 
+Fixed a problem with the FromBCD and ToBCD operators. With some 
+compilers, 
+the ShortDivide function worked incorrectly, causing problems with the 
+BCD 
 functions with large input values. A truncation from 64-bit to 32-bit 
 inadvertently occurred. Internal BZ 435. Lin Ming
 
-Fixed a problem with Index references passed as method arguments. References 
-passed as arguments to control methods were dereferenced immediately (before 
-control was passed to the called method). The references are now correctly 
+Fixed a problem with Index references passed as method arguments. 
+References 
+passed as arguments to control methods were dereferenced immediately 
+(before 
+control was passed to the called method). The references are now 
+correctly 
 passed directly to the called method. BZ 5389. Lin Ming
 
-Fixed a problem with CopyObject used in conjunction with the Index operator. 
-The reference was incorrectly dereferenced before the copy. The reference is 
+Fixed a problem with CopyObject used in conjunction with the Index 
+operator. 
+The reference was incorrectly dereferenced before the copy. The reference 
+is 
 now correctly copied. BZ 5391. Lin Ming
 
-Fixed a problem with Control Method references within Package objects. These 
+Fixed a problem with Control Method references within Package objects. 
+These 
 references are now correctly generated. This completes the package 
 construction overhaul that began in version 20071019.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3249,9 +7811,11 @@ The AcpiExec utility now installs handlers for all of the predefined
 Operation Region types. New types supported are: PCI_Config, CMOS, and 
 PCIBARTarget.
 
-Fixed a problem with the 64-bit version of AcpiExec where the extended (64-
+Fixed a problem with the 64-bit version of AcpiExec where the extended 
+(64-
 bit) address fields for the DSDT and FACS within the FADT were not being 
-used, causing truncation of the upper 32-bits of these addresses. Lin Ming 
+used, causing truncation of the upper 32-bits of these addresses. Lin 
+Ming 
 and Bob Moore
 
 ----------------------------------------
@@ -3260,14 +7824,18 @@ and Bob Moore
 1) ACPI CA Core Subsystem:
 
 Fixed a problem with the Alias operator when the target of the alias is a 
-named ASL operator that opens a new scope -- Scope, Device, PowerResource, 
+named ASL operator that opens a new scope -- Scope, Device, 
+PowerResource, 
 Processor, and ThermalZone. In these cases, any children of the original 
-operator could not be accessed via the alias, potentially causing unexpected 
+operator could not be accessed via the alias, potentially causing 
+unexpected 
 AE_NOT_FOUND exceptions. (BZ 9067)
 
 Fixed a problem with the Package operator where all named references were 
-created as object references and left otherwise unresolved. According to the 
-ACPI specification, a Package can only contain Data Objects or references to 
+created as object references and left otherwise unresolved. According to 
+the 
+ACPI specification, a Package can only contain Data Objects or references 
+to 
 control methods. The implication is that named references to Data Objects 
 (Integer, Buffer, String, Package, BufferField, Field) should be resolved 
 immediately upon package creation. This is the approach taken with this 
@@ -3276,11 +7844,13 @@ etc.) are all now properly created as reference objects. (BZ 5328)
 
 Reverted a change to Notify handling that was introduced in version 
 20070508. This version changed the Notify handling from asynchronous to 
-fully synchronous (Device driver Notify handling with respect to the Notify 
+fully synchronous (Device driver Notify handling with respect to the 
+Notify 
 ASL operator). It was found that this change caused more problems than it 
 solved and was removed by most users.
 
-Fixed a problem with the Increment and Decrement operators where the type of 
+Fixed a problem with the Increment and Decrement operators where the type 
+of 
 the target object could be unexpectedly and incorrectly changed. (BZ 353) 
 Lin Ming.
 
@@ -3291,19 +7861,24 @@ loaded into the root or current scope. Lin Ming.
 Fixed a problem with the Load operator when loading a table from a buffer 
 object. The input buffer was prematurely zeroed and/or deleted. (BZ 577)
 
-Fixed a problem with the Debug object where a store of a DdbHandle reference 
+Fixed a problem with the Debug object where a store of a DdbHandle 
+reference 
 object to the Debug object could cause a fault.
 
-Added a table checksum verification for the Load operator, in the case where 
+Added a table checksum verification for the Load operator, in the case 
+where 
 the load is from a buffer. (BZ 578).
 
-Implemented additional parameter validation for the LoadTable operator. The 
-length of the input strings SignatureString, OemIdString, and OemTableId are 
+Implemented additional parameter validation for the LoadTable operator. 
+The 
+length of the input strings SignatureString, OemIdString, and OemTableId 
+are 
 now checked for maximum lengths. (BZ 582) Lin Ming.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3326,7 +7901,8 @@ version 20070917.)
 1) ACPI CA Core Subsystem:
 
 Designed and implemented new external interfaces to install and remove 
-handlers for ACPI table-related events. Current events that are defined are 
+handlers for ACPI table-related events. Current events that are defined 
+are 
 LOAD and UNLOAD. These interfaces allow the host to track ACPI tables as 
 they are dynamically loaded and unloaded. See AcpiInstallTableHandler and 
 AcpiRemoveTableHandler. (Lin Ming and Bob Moore)
@@ -3341,7 +7917,8 @@ referenced from within the same control method (Lin Ming) BZ 341
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3354,22 +7931,30 @@ a much larger code and data size.
 
 2) iASL Compiler/Disassembler:
 
-Implemented support to allow multiple files to be compiled/disassembled in a 
-single invocation. This includes command line wildcard support for both the 
+Implemented support to allow multiple files to be compiled/disassembled 
+in 
+a 
+single invocation. This includes command line wildcard support for both 
+the 
 Windows and Unix versions of the compiler. This feature simplifies the 
-disassembly and compilation of multiple ACPI tables in a single directory.
+disassembly and compilation of multiple ACPI tables in a single 
+directory.
 
 ----------------------------------------
 08 May 2007. Summary of changes for version 20070508:
 
 1) ACPI CA Core Subsystem:
 
-Implemented a Microsoft compatibility design change for the handling of the 
+Implemented a Microsoft compatibility design change for the handling of 
+the 
 Notify AML operator. Previously, notify handlers were dispatched and 
 executed completely asynchronously in a deferred thread. The new design 
-still executes the notify handlers in a different thread, but the original 
-thread that executed the Notify() now waits at a synchronization point for 
-the notify handler to complete. Some machines depend on a synchronous Notify 
+still executes the notify handlers in a different thread, but the 
+original 
+thread that executed the Notify() now waits at a synchronization point 
+for 
+the notify handler to complete. Some machines depend on a synchronous 
+Notify 
 operator in order to operate correctly.
 
 Implemented support to allow Package objects to be passed as method 
@@ -3378,15 +7963,21 @@ would return the AE_NOT_IMPLEMENTED exception. This feature had not been
 implemented since there were no reserved control methods that required it 
 until recently.
 
-Fixed a problem with the internal FADT conversion where ACPI 1.0 FADTs that 
+Fixed a problem with the internal FADT conversion where ACPI 1.0 FADTs 
+that 
 contained invalid non-zero values in reserved fields could cause later 
-failures because these fields have meaning in later revisions of the FADT. 
-For incoming ACPI 1.0 FADTs, these fields are now always zeroed. (The fields 
+failures because these fields have meaning in later revisions of the 
+FADT. 
+For incoming ACPI 1.0 FADTs, these fields are now always zeroed. (The 
+fields 
 are: Preferred_PM_Profile, PSTATE_CNT, CST_CNT, and IAPC_BOOT_FLAGS.)
 
-Fixed a problem where the Global Lock handle was not properly updated if a 
-thread that acquired the Global Lock via executing AML code then attempted 
-to acquire the lock via the AcpiAcquireGlobalLock interface. Reported by Joe 
+Fixed a problem where the Global Lock handle was not properly updated if 
+a 
+thread that acquired the Global Lock via executing AML code then 
+attempted 
+to acquire the lock via the AcpiAcquireGlobalLock interface. Reported by 
+Joe 
 Liu.
 
 Fixed a problem in AcpiEvDeleteGpeXrupt where the global interrupt list 
@@ -3395,7 +7986,8 @@ list. Reported by Linn Crosetto.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3413,46 +8005,61 @@ a much larger code and data size.
 Implemented a change to the order of interpretation and evaluation of AML 
 operand objects within the AML interpreter. The interpreter now evaluates 
 operands in the order that they appear in the AML stream (and the 
-corresponding ASL code), instead of in the reverse order (after the entire 
-operand list has been parsed). The previous behavior caused several subtle 
+corresponding ASL code), instead of in the reverse order (after the 
+entire 
+operand list has been parsed). The previous behavior caused several 
+subtle 
 incompatibilities with the Microsoft AML interpreter as well as being 
 somewhat non-intuitive. BZ 7871, local BZ 263. Valery Podrezov.
 
-Implemented a change to the ACPI Global Lock support. All interfaces to the 
+Implemented a change to the ACPI Global Lock support. All interfaces to 
+the 
 global lock now allow the same thread to acquire the lock multiple times. 
-This affects the AcpiAcquireGlobalLock external interface to the global lock 
+This affects the AcpiAcquireGlobalLock external interface to the global 
+lock 
 as well as the internal use of the global lock to support AML fields -- a 
-control method that is holding the global lock can now simultaneously access 
-AML fields that require global lock protection. Previously, in both cases, 
-this would have resulted in an AE_ALREADY_ACQUIRED exception. The change to 
+control method that is holding the global lock can now simultaneously 
+access 
+AML fields that require global lock protection. Previously, in both 
+cases, 
+this would have resulted in an AE_ALREADY_ACQUIRED exception. The change 
+to 
 AcpiAcquireGlobalLock is of special interest to drivers for the Embedded 
-Controller. There is no change to the behavior of the AML Acquire operator, 
+Controller. There is no change to the behavior of the AML Acquire 
+operator, 
 as this can already be used to acquire a mutex multiple times by the same 
 thread. BZ 8066. With assistance from Alexey Starikovskiy.
 
 Fixed a problem where invalid objects could be referenced in the AML 
-Interpreter after error conditions. During operand evaluation, ensure that 
+Interpreter after error conditions. During operand evaluation, ensure 
+that 
 the internal "Return Object" field is cleared on error and only valid 
-pointers are stored there. Caused occasional access to deleted objects that 
+pointers are stored there. Caused occasional access to deleted objects 
+that 
 resulted in "large reference count" warning messages. Valery Podrezov.
 
-Fixed a problem where an AE_STACK_OVERFLOW internal exception could occur on 
+Fixed a problem where an AE_STACK_OVERFLOW internal exception could occur 
+on 
 deeply nested control method invocations. BZ 7873, local BZ 487. Valery 
 Podrezov.
 
 Fixed an internal problem with the handling of result objects on the 
 interpreter result stack. BZ 7872. Valery Podrezov.
 
-Removed obsolete code that handled the case where AML_NAME_OP is the target 
+Removed obsolete code that handled the case where AML_NAME_OP is the 
+target 
 of a reference (Reference.Opcode). This code was no longer necessary. BZ 
 7874. Valery Podrezov.
 
-Removed obsolete ACPI_NO_INTEGER64_SUPPORT from two header files. This was a 
+Removed obsolete ACPI_NO_INTEGER64_SUPPORT from two header files. This 
+was 
+a 
 remnant from the previously discontinued 16-bit support.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3472,12 +8079,14 @@ virtually every file in the ACPICA core subsystem, the iASL compiler, and
 the utilities.
 
 Implemented a fix for an incorrect parameter passed to AcpiTbDeleteTable 
-during a table load. A bad pointer was passed in the case where the DSDT is 
+during a table load. A bad pointer was passed in the case where the DSDT 
+is 
 overridden, causing a fault in this case.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3492,9 +8101,11 @@ a much larger code and data size.
 
 1) ACPI CA Core Subsystem:
 
-Support for 16-bit ACPICA has been completely removed since it is no longer 
+Support for 16-bit ACPICA has been completely removed since it is no 
+longer 
 necessary and it clutters the code. All 16-bit macros, types, and 
-conditional compiles have been removed, cleaning up and simplifying the code 
+conditional compiles have been removed, cleaning up and simplifying the 
+code 
 across the entire subsystem. DOS support is no longer needed since the 
 bootable Linux firmware kit is now available.
 
@@ -3503,17 +8114,22 @@ enable a clean subsystem restart, via the implementation of the
 AcpiEvRemoveGlobalLockHandler function. (With assistance from Joel Bretz, 
 HP)
 
-Implemented enhancements to the multithreading support within the debugger 
-to enable improved multithreading debugging and evaluation of the subsystem. 
+Implemented enhancements to the multithreading support within the 
+debugger 
+to enable improved multithreading debugging and evaluation of the 
+subsystem. 
 (Valery Podrezov)
 
-Debugger: Enhanced the Statistics/Memory command to emit the total (maximum) 
-memory used during the execution, as well as the maximum memory consumed by 
+Debugger: Enhanced the Statistics/Memory command to emit the total 
+(maximum) 
+memory used during the execution, as well as the maximum memory consumed 
+by 
 each of the various object types. (Valery Podrezov)
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3534,30 +8150,36 @@ statistics upon subsystem/program termination. (Valery Podrezov)
 
 1) ACPI CA Core Subsystem:
 
-Optimized the Load ASL operator in the case where the source operand is an 
+Optimized the Load ASL operator in the case where the source operand is 
+an 
 operation region. Simply map the operation region memory, instead of 
 performing a bytewise read. (Region must be of type SystemMemory, see 
 below.)
 
 Fixed the Load ASL operator for the case where the source operand is a 
-region field. A buffer object is also allowed as the source operand. BZ 480
+region field. A buffer object is also allowed as the source operand. BZ 
+480
 
-Fixed a problem where the Load ASL operator allowed the source operand to be 
+Fixed a problem where the Load ASL operator allowed the source operand to 
+be 
 an operation region of any type. It is now restricted to regions of type 
 SystemMemory, as per the ACPI specification. BZ 481
 
 Additional cleanup and optimizations for the new Table Manager code.
 
-AcpiEnable will now fail if all of the required ACPI tables are not loaded 
+AcpiEnable will now fail if all of the required ACPI tables are not 
+loaded 
 (FADT, FACS, DSDT). BZ 477
 
-Added #pragma pack(8/4) to acobject.h to ensure that the structures in this 
+Added #pragma pack(8/4) to acobject.h to ensure that the structures in 
+this 
 header are always compiled as aligned. The ACPI_OPERAND_OBJECT has been 
 manually optimized to be aligned and will not work if it is byte-packed. 
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3588,33 +8210,41 @@ interpreter performance by ~25%, reduces code size, and reduces CPU stack
 use. (Valery Podrezov + interpreter changes in version 20051202 that 
 eliminated namespace loading during the pass one parse.)
 
-Implemented _CID support for PCI Root Bridge detection. If the _HID does not 
-match the predefined PCI Root Bridge IDs, the _CID list (if present) is now 
+Implemented _CID support for PCI Root Bridge detection. If the _HID does 
+not 
+match the predefined PCI Root Bridge IDs, the _CID list (if present) is 
+now 
 obtained and also checked for an ID match.
 
-Implemented additional support for the PCI _ADR execution: upsearch until a 
+Implemented additional support for the PCI _ADR execution: upsearch until 
+a 
 device scope is found before executing _ADR. This allows PCI_Config 
-operation regions to be declared locally within control methods underneath 
+operation regions to be declared locally within control methods 
+underneath 
 PCI device objects.
 
 Fixed a problem with a possible race condition between threads executing 
 AcpiWalkNamespace and the AML interpreter. This condition was removed by 
-modifying AcpiWalkNamespace to (by default) ignore all temporary namespace 
+modifying AcpiWalkNamespace to (by default) ignore all temporary 
+namespace 
 entries created during any concurrent control method execution. An 
 additional namespace race condition is known to exist between 
 AcpiWalkNamespace and the Load/Unload ASL operators and is still under 
 investigation.
 
 Restructured the AML ParseLoop function, breaking it into several 
-subfunctions in order to reduce CPU stack use and improve maintainability. 
+subfunctions in order to reduce CPU stack use and improve 
+maintainability. 
 (Mikhail Kouzmich)
 
-AcpiGetHandle: Fix for parameter validation to detect invalid combinations 
+AcpiGetHandle: Fix for parameter validation to detect invalid 
+combinations 
 of prefix handle and pathname. BZ 478
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3626,7 +8256,8 @@ a much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Ported the -g option (get local ACPI tables) to the new ACPICA Table Manager 
+Ported the -g option (get local ACPI tables) to the new ACPICA Table 
+Manager 
 to restore original behavior.
 
 ----------------------------------------
@@ -3640,15 +8271,18 @@ level indication flag is not needed.
 
 Fixed a problem with the Global Lock where the lock could appear to be 
 obtained before it is actually obtained. The global lock semaphore was 
-inadvertently created with one unit instead of zero units. (BZ 464) Fiodor 
+inadvertently created with one unit instead of zero units. (BZ 464) 
+Fiodor 
 Suietov.
 
-Fixed a possible memory leak and fault in AcpiExResolveObjectToValue during 
+Fixed a possible memory leak and fault in AcpiExResolveObjectToValue 
+during 
 a read from a buffer or region field. (BZ 458) Fiodor Suietov.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3661,20 +8295,25 @@ a much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Fixed a compilation problem with the pre-defined Resource Descriptor field 
-names where an "object does not exist" error could be incorrectly generated 
+Fixed a compilation problem with the pre-defined Resource Descriptor 
+field 
+names where an "object does not exist" error could be incorrectly 
+generated 
 if the parent ResourceTemplate pathname places the template within a 
 different namespace scope than the current scope. (BZ 7212)
 
-Fixed a problem where the compiler could hang after syntax errors detected 
+Fixed a problem where the compiler could hang after syntax errors 
+detected 
 in an ElseIf construct. (BZ 453)
 
 Fixed a problem with the AmlFilename parameter to the DefinitionBlock() 
-operator. An incorrect output filename was produced when this parameter was 
+operator. An incorrect output filename was produced when this parameter 
+was 
 a null string (""). Now, the original input filename is used as the AML 
 output filename, with an ".aml" extension.
 
-Implemented a generic batch command mode for the AcpiExec utility (execute 
+Implemented a generic batch command mode for the AcpiExec utility 
+(execute 
 any AML debugger command) (Valery Podrezov).
 
 ----------------------------------------
@@ -3684,15 +8323,18 @@ any AML debugger command) (Valery Podrezov).
 
 Enhanced the implementation of the "serialized mode" of the interpreter 
 (enabled via the AcpiGbl_AllMethodsSerialized flag.) When this mode is 
-specified, instead of creating a serialization semaphore per control method, 
+specified, instead of creating a serialization semaphore per control 
+method, 
 the interpreter lock is simply no longer released before a blocking 
 operation during control method execution. This effectively makes the AML 
 Interpreter single-threaded. The overhead of a semaphore per-method is 
 eliminated.
 
-Fixed a regression where an error was no longer emitted if a control method 
+Fixed a regression where an error was no longer emitted if a control 
+method 
 attempts to create 2 objects of the same name. This once again returns 
-AE_ALREADY_EXISTS. When this exception occurs, it invokes the mechanism that 
+AE_ALREADY_EXISTS. When this exception occurs, it invokes the mechanism 
+that 
 will dynamically serialize the control method to possible prevent future 
 errors. (BZ 440)
 
@@ -3703,13 +8345,18 @@ Moved all FADT-related functions to a new file, tbfadt.c. Eliminated the
 AcpiHwInitialize function - the FADT registers are now validated when the 
 table is loaded.
 
-Added two new warnings during FADT verification - 1) if the FADT is larger 
-than the largest known FADT version, and 2) if there is a mismatch between a 
-32-bit block address and the 64-bit X counterpart (when both are non-zero.)
+Added two new warnings during FADT verification - 1) if the FADT is 
+larger 
+than the largest known FADT version, and 2) if there is a mismatch 
+between 
+a 
+32-bit block address and the 64-bit X counterpart (when both are non-
+zero.)
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3722,8 +8369,10 @@ a much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Fixed a problem with the implementation of the Switch() operator where the 
-temporary variable was declared too close to the actual Switch, instead of 
+Fixed a problem with the implementation of the Switch() operator where 
+the 
+temporary variable was declared too close to the actual Switch, instead 
+of 
 at method level. This could cause a problem if the Switch() operator is 
 within a while loop, causing an error on the second iteration. (BZ 460)
 
@@ -3733,17 +8382,20 @@ operator. Now, ignore it and continue.
 Disassembly of an FADT now verifies the input FADT and reports any errors 
 found. Fix for proper disassembly of full-sized (ACPI 2.0) FADTs.
 
-Disassembly of raw data buffers with byte initialization data now prefixes 
+Disassembly of raw data buffers with byte initialization data now 
+prefixes 
 each output line with the current buffer offset.
 
 Disassembly of ASF! table now includes all variable-length data fields at 
 the end of some of the subtables.
 
 The disassembler now emits a comment if a buffer appears to be a 
-ResourceTemplate, but cannot be disassembled as such because the EndTag does 
+ResourceTemplate, but cannot be disassembled as such because the EndTag 
+does 
 not appear at the very end of the buffer.
 
-AcpiExec - Added the "-t" command line option to enable the serialized mode 
+AcpiExec - Added the "-t" command line option to enable the serialized 
+mode 
 of the AML interpreter.
 
 ----------------------------------------
@@ -3759,11 +8411,13 @@ Miscellaneous fixes for the Table Manager:
 - Additional parameter validation for AcpiGetTable, AcpiGetTableHeader, 
 AcpiGetTableByIndex
 
-Change for GPE support: when a "wake" GPE is received, all wake GPEs are now 
+Change for GPE support: when a "wake" GPE is received, all wake GPEs are 
+now 
 immediately disabled to prevent the waking GPE from firing again and to 
 prevent other wake GPEs from interrupting the wake process.
 
-Added the AcpiGpeCount global that tracks the number of processed GPEs, to 
+Added the AcpiGpeCount global that tracks the number of processed GPEs, 
+to 
 be used for debugging systems with a large number of ACPI interrupts.
 
 Implemented support for the "DMAR" ACPI table (DMA Redirection Table) in 
@@ -3771,7 +8425,8 @@ both the ACPICA headers and the disassembler.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3792,62 +8447,79 @@ Disassembler support for the DMAR ACPI table.
 1) ACPI CA Core Subsystem:
 
 The Table Manager component has been completely redesigned and 
-reimplemented. The new design is much simpler, and reduces the overall code 
-and data size of the kernel-resident ACPICA by approximately 5%. Also, it is 
+reimplemented. The new design is much simpler, and reduces the overall 
+code 
+and data size of the kernel-resident ACPICA by approximately 5%. Also, it 
+is 
 now possible to obtain the ACPI tables very early during kernel 
 initialization, even before dynamic memory management is initialized. 
 (Alexey Starikovskiy, Fiodor Suietov, Bob Moore)
 
 Obsolete ACPICA interfaces:
 
-- AcpiGetFirmwareTable: Use AcpiGetTable instead (works at early kernel init 
+- AcpiGetFirmwareTable: Use AcpiGetTable instead (works at early kernel 
+init 
 time).
 - AcpiLoadTable: Not needed.
 - AcpiUnloadTable: Not needed.
 
 New ACPICA interfaces:
 
-- AcpiInitializeTables: Must be called before the table manager can be used.
+- AcpiInitializeTables: Must be called before the table manager can be 
+used.
 - AcpiReallocateRootTable: Used to transfer the root table to dynamically 
 allocated memory after it becomes available.
-- AcpiGetTableByIndex: Allows the host to easily enumerate all ACPI tables 
+- AcpiGetTableByIndex: Allows the host to easily enumerate all ACPI 
+tables 
 in the RSDT/XSDT.
 
 Other ACPICA changes:
 
-- AcpiGetTableHeader returns the actual mapped table header, not a copy. Use 
+- AcpiGetTableHeader returns the actual mapped table header, not a copy. 
+Use 
 AcpiOsUnmapMemory to free this mapping.
 - AcpiGetTable returns the actual mapped table. The mapping is managed 
 internally and must not be deleted by the caller. Use of this interface 
 causes no additional dynamic memory allocation.
-- AcpiFindRootPointer: Support for physical addressing has been eliminated, 
+- AcpiFindRootPointer: Support for physical addressing has been 
+eliminated, 
 it appeared to be unused.
 - The interface to AcpiOsMapMemory has changed to be consistent with the 
 other allocation interfaces.
-- The interface to AcpiOsGetRootPointer has changed to eliminate unnecessary 
+- The interface to AcpiOsGetRootPointer has changed to eliminate 
+unnecessary 
 parameters.
-- ACPI_PHYSICAL_ADDRESS is now 32 bits on 32-bit platforms, 64 bits on 64-
+- ACPI_PHYSICAL_ADDRESS is now 32 bits on 32-bit platforms, 64 bits on 
+64-
 bit platforms. Was previously 64 bits on all platforms.
-- The interface to the ACPI Global Lock acquire/release macros have changed 
+- The interface to the ACPI Global Lock acquire/release macros have 
+changed 
 slightly since ACPICA no longer keeps a local copy of the FACS with a 
 constructed pointer to the actual global lock.
 
 Porting to the new table manager:
 
 - AcpiInitializeTables: Must be called once, and can be called anytime 
-during the OS initialization process. It allows the host to specify an area 
+during the OS initialization process. It allows the host to specify an 
+area 
 of memory to be used to store the internal version of the RSDT/XSDT (root 
-table). This allows the host to access ACPI tables before memory management 
+table). This allows the host to access ACPI tables before memory 
+management 
 is initialized and running.
-- AcpiReallocateRootTable: Can be called after memory management is running 
+- AcpiReallocateRootTable: Can be called after memory management is 
+running 
 to copy the root table to a dynamically allocated array, freeing up the 
 scratch memory specified in the call to AcpiInitializeTables.
 - AcpiSubsystemInitialize: This existing interface is independent of the 
-Table Manager, and does not have to be called before the Table Manager can 
+Table Manager, and does not have to be called before the Table Manager 
+can 
 be used, it only must be called before the rest of ACPICA can be used.
-- ACPI Tables: Some changes have been made to the names and structure of the 
-actbl.h and actbl1.h header files and may require changes to existing code. 
-For example, bitfields have been completely removed because of their lack of 
+- ACPI Tables: Some changes have been made to the names and structure of 
+the 
+actbl.h and actbl1.h header files and may require changes to existing 
+code. 
+For example, bitfields have been completely removed because of their lack 
+of 
 portability across C compilers.
 - Update interfaces to the Global Lock acquire/release macros if local 
 versions are used. (see acwin.h)
@@ -3858,7 +8530,8 @@ New files: tbfind.c
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3880,43 +8553,56 @@ No changes for this release.
 
 The full source code for the ASL test suite used to validate the iASL 
 compiler and the ACPICA core subsystem is being released with the ACPICA 
-source for the first time. The source is contained in a separate package and 
-consists of over 1100 files that exercise all ASL/AML operators. The package 
-should appear on the Intel/ACPI web site shortly. (Valery Podrezov, Fiodor 
+source for the first time. The source is contained in a separate package 
+and 
+consists of over 1100 files that exercise all ASL/AML operators. The 
+package 
+should appear on the Intel/ACPI web site shortly. (Valery Podrezov, 
+Fiodor 
 Suietov)
 
 Completed a new design and implementation for support of the ACPI Global 
 Lock. On the OS side, the global lock is now treated as a standard AML 
 mutex. Previously, multiple OS threads could "acquire" the global lock 
-simultaneously. However, this could cause the BIOS to be starved out of the 
+simultaneously. However, this could cause the BIOS to be starved out of 
+the 
 lock - especially in cases such as the Embedded Controller driver where 
 there is a tight coupling between the OS and the BIOS.
 
 Implemented an optimization for the ACPI Global Lock interrupt mechanism. 
 The Global Lock interrupt handler no longer queues the execution of a 
-separate thread to signal the global lock semaphore. Instead, the semaphore 
+separate thread to signal the global lock semaphore. Instead, the 
+semaphore 
 is signaled directly from the interrupt handler.
 
 Implemented support within the AML interpreter for package objects that 
-contain a larger AML length (package list length) than the package element 
+contain a larger AML length (package list length) than the package 
+element 
 count. In this case, the length of the package is truncated to match the 
-package element count. Some BIOS code apparently modifies the package length 
-on the fly, and this change supports this behavior. Provides compatibility 
+package element count. Some BIOS code apparently modifies the package 
+length 
+on the fly, and this change supports this behavior. Provides 
+compatibility 
 with the MS AML interpreter. (With assistance from Fiodor Suietov)
 
-Implemented a temporary fix for the BankValue parameter of a Bank Field to 
+Implemented a temporary fix for the BankValue parameter of a Bank Field 
+to 
 support all constant values, now including the Zero and One opcodes. 
-Evaluation of this parameter must eventually be converted to a full TermArg 
-evaluation. A not-implemented error is now returned (temporarily) for non-
+Evaluation of this parameter must eventually be converted to a full 
+TermArg 
+evaluation. A not-implemented error is now returned (temporarily) for 
+non-
 constant values for this parameter.
 
 Fixed problem reports (Fiodor Suietov) integrated:
-- Fix for premature object deletion after CopyObject on Operation Region (BZ 
+- Fix for premature object deletion after CopyObject on Operation Region 
+(BZ 
 350)
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -3942,18 +8628,22 @@ structures - even though the hardware itself may support misaligned
 transfers. Some of the debug data structures are packed by default to 
 minimize size.
 
-Added an error message for the case where AcpiOsGetThreadId() returns zero. 
+Added an error message for the case where AcpiOsGetThreadId() returns 
+zero. 
 A non-zero value is required by the core ACPICA code to ensure the proper 
 operation of AML mutexes and recursive control methods.
 
 The DSDT is now the only ACPI table that determines whether the AML 
-interpreter is in 32-bit or 64-bit mode. Not really a functional change, but 
-the hooks for per-table 32/64 switching have been removed from the code. A 
+interpreter is in 32-bit or 64-bit mode. Not really a functional change, 
+but 
+the hooks for per-table 32/64 switching have been removed from the code. 
+A 
 clarification to the ACPI specification is forthcoming in ACPI 3.0B.
 
 Fixed a possible leak of an OwnerID in the error path of 
 AcpiTbInitTableDescriptor (tbinstal.c), and migrated all table OwnerID 
-deletion to a single place in AcpiTbUninstallTable to correct possible leaks 
+deletion to a single place in AcpiTbUninstallTable to correct possible 
+leaks 
 when using the AcpiTbDeleteTablesByType interface (with assistance from 
 Lance Ortiz.)
 
@@ -3961,7 +8651,8 @@ Fixed a problem with Serialized control methods where the semaphore
 associated with the method could be over-signaled after multiple method 
 invocations.
 
-Fixed two issues with the locking of the internal namespace data structure. 
+Fixed two issues with the locking of the internal namespace data 
+structure. 
 Both the Unload() operator and AcpiUnloadTable interface now lock the 
 namespace during the namespace deletion associated with the table unload 
 (with assistance from Linn Crosetto.)
@@ -3972,19 +8663,23 @@ Fixed problem reports (Valery Podrezov) integrated:
 Fixed problem reports (Fiodor Suietov) integrated:
 - Incomplete cleanup branches in AcpiTbGetTableRsdt (BZ 369)
 - On Address Space handler deletion, needless deactivation call (BZ 374)
-- AcpiRemoveAddressSpaceHandler: validate Device handle parameter (BZ 375)
-- Possible memory leak, Notify sub-objects of Processor, Power, ThermalZone 
+- AcpiRemoveAddressSpaceHandler: validate Device handle parameter (BZ 
+375)
+- Possible memory leak, Notify sub-objects of Processor, Power, 
+ThermalZone 
 (BZ 376)
 - AcpiRemoveAddressSpaceHandler: validate Handler parameter (BZ 378)
 - Minimum Length of RSDT should be validated (BZ 379)
 - AcpiRemoveNotifyHandler: return AE_NOT_EXIST if Processor Obj has no 
 Handler (BZ (380)
-- AcpiUnloadTable: return AE_NOT_EXIST if no table of specified type loaded 
+- AcpiUnloadTable: return AE_NOT_EXIST if no table of specified type 
+loaded 
 (BZ 381)
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -4010,39 +8705,53 @@ Implemented a new ACPI_SPINLOCK type for the OSL lock interfaces. This
 allows the type to be customized to the host OS for improved efficiency 
 (since a spinlock is usually a very small object.)
 
-Implemented support for "ignored" bits in the ACPI registers. According to 
+Implemented support for "ignored" bits in the ACPI registers. According 
+to 
 the ACPI specification, these bits should be preserved when writing the 
-registers via a read/modify/write cycle. There are 3 bits preserved in this 
+registers via a read/modify/write cycle. There are 3 bits preserved in 
+this 
 manner: PM1_CONTROL[0] (SCI_EN), PM1_CONTROL[9], and PM1_STATUS[11].
 
-Implemented the initial deployment of new OSL mutex interfaces. Since some 
+Implemented the initial deployment of new OSL mutex interfaces. Since 
+some 
 host operating systems have separate mutex and semaphore objects, this 
 feature was requested. The base code now uses mutexes (and the new mutex 
 interfaces) wherever a binary semaphore was used previously. However, for 
-the current release, the mutex interfaces are defined as macros to map them 
-to the existing semaphore interfaces. Therefore, no OSL changes are required 
+the current release, the mutex interfaces are defined as macros to map 
+them 
+to the existing semaphore interfaces. Therefore, no OSL changes are 
+required 
 at this time. (See acpiosxf.h)
 
 Fixed several problems with the support for the control method SyncLevel 
-parameter. The SyncLevel now works according to the ACPI specification and 
-in concert with the Mutex SyncLevel parameter, since the current SyncLevel 
-is a property of the executing thread. Mutual exclusion for control methods 
+parameter. The SyncLevel now works according to the ACPI specification 
+and 
+in concert with the Mutex SyncLevel parameter, since the current 
+SyncLevel 
+is a property of the executing thread. Mutual exclusion for control 
+methods 
 is now implemented with a mutex instead of a semaphore.
 
 Fixed three instances of the use of the C shift operator in the bitfield 
-support code (exfldio.c) to avoid the use of a shift value larger than the 
-target data width. The behavior of C compilers is undefined in this case and 
-can cause unpredictable results, and therefore the case must be detected and 
+support code (exfldio.c) to avoid the use of a shift value larger than 
+the 
+target data width. The behavior of C compilers is undefined in this case 
+and 
+can cause unpredictable results, and therefore the case must be detected 
+and 
 avoided. (Fiodor Suietov)
 
 Added an info message whenever an SSDT or OEM table is loaded dynamically 
-via the Load() or LoadTable() ASL operators. This should improve debugging 
-capability since it will show exactly what tables have been loaded (beyond 
+via the Load() or LoadTable() ASL operators. This should improve 
+debugging 
+capability since it will show exactly what tables have been loaded 
+(beyond 
 the tables present in the RSDT/XSDT.)
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -4062,19 +8771,24 @@ No changes for this release.
 
 1) ACPI CA Core Subsystem:
 
-Converted the locking mutex used for the ACPI hardware to a spinlock. This 
+Converted the locking mutex used for the ACPI hardware to a spinlock. 
+This 
 change should eliminate all problems caused by attempting to acquire a 
 semaphore at interrupt level, and it means that all ACPICA external 
-interfaces that directly access the ACPI hardware can be safely called from 
-interrupt level. OSL code that implements the semaphore interfaces should be 
+interfaces that directly access the ACPI hardware can be safely called 
+from 
+interrupt level. OSL code that implements the semaphore interfaces should 
+be 
 able to eliminate any workarounds for being called at interrupt level.
 
 Fixed a regression introduced in 20060526 where the ACPI device 
-initialization could be prematurely aborted with an AE_NOT_FOUND if a device 
+initialization could be prematurely aborted with an AE_NOT_FOUND if a 
+device 
 did not have an optional _INI method.
 
 Fixed an IndexField issue where a write to the Data Register should be 
-limited in size to the AccessSize (width) of the IndexField itself. (BZ 433, 
+limited in size to the AccessSize (width) of the IndexField itself. (BZ 
+433, 
 Fiodor Suietov)
 
 Fixed problem reports (Valery Podrezov) integrated:
@@ -4088,7 +8802,8 @@ used.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -4116,17 +8831,21 @@ Suietov)
 1) ACPI CA Core Subsystem:
 
 Restructured, flattened, and simplified the internal interfaces for 
-namespace object evaluation - resulting in smaller code, less CPU stack use, 
+namespace object evaluation - resulting in smaller code, less CPU stack 
+use, 
 and fewer interfaces. (With assistance from Mikhail Kouzmich)
 
-Fixed a problem with the CopyObject operator where the first parameter was 
-not typed correctly for the parser, interpreter, compiler, and disassembler. 
+Fixed a problem with the CopyObject operator where the first parameter 
+was 
+not typed correctly for the parser, interpreter, compiler, and 
+disassembler. 
 Caused various errors and unexpected behavior.
 
 Fixed a problem where a ShiftLeft or ShiftRight of more than 64 bits 
 produced incorrect results with some C compilers. Since the behavior of C 
 compilers when the shift value is larger than the datatype width is 
-apparently not well defined, the interpreter now detects this condition and 
+apparently not well defined, the interpreter now detects this condition 
+and 
 simply returns zero as expected in all such cases. (BZ 395)
 
 Fixed problem reports (Valery Podrezov) integrated:
@@ -4134,21 +8853,25 @@ Fixed problem reports (Valery Podrezov) integrated:
 - Allow interpreter to handle nested method declarations (BZ 5361)
 
 Fixed problem reports (Fiodor Suietov) integrated:
-- AcpiTerminate doesn't free debug memory allocation list objects (BZ 355)
-- After Core Subsystem shutdown, AcpiSubsystemStatus returns AE_OK (BZ 356)
+- AcpiTerminate doesn't free debug memory allocation list objects (BZ 
+355)
+- After Core Subsystem shutdown, AcpiSubsystemStatus returns AE_OK (BZ 
+356)
 - AcpiOsUnmapMemory for RSDP can be invoked inconsistently (BZ 357)
 - Resource Manager should return AE_TYPE for non-device objects (BZ 358)
 - Incomplete cleanup branch in AcpiNsEvaluateRelative (BZ 359)
 - Use AcpiOsFree instead of ACPI_FREE in AcpiRsSetSrsMethodData (BZ 360)
 - Incomplete cleanup branch in AcpiPsParseAml (BZ 361)
 - Incomplete cleanup branch in AcpiDsDeleteWalkState (BZ 362)
-- AcpiGetTableHeader returns AE_NO_ACPI_TABLES until DSDT is loaded (BZ 365)
+- AcpiGetTableHeader returns AE_NO_ACPI_TABLES until DSDT is loaded (BZ 
+365)
 - Status of the Global Initialization Handler call not used (BZ 366)
 - Incorrect object parameter to Global Initialization Handler (BZ 367)
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -4164,7 +8887,8 @@ a much larger code and data size.
 Modified the parser to allow the names IO, DMA, and IRQ to be used as 
 namespace identifiers with no collision with existing resource descriptor 
 macro names. This provides compatibility with other ASL compilers and is 
-most useful for disassembly/recompilation of existing tables without parse 
+most useful for disassembly/recompilation of existing tables without 
+parse 
 errors. (With assistance from Thomas Renninger)
 
 Disassembler: fixed an incorrect disassembly problem with the 
@@ -4177,27 +8901,37 @@ disassembly of some Alias operators.
 1) ACPI CA Core Subsystem:
 
 Replaced the AcpiOsQueueForExecution interface with a new interface named 
-AcpiOsExecute. The major difference is that the new interface does not have 
-a Priority parameter, this appeared to be useless and has been replaced by a 
+AcpiOsExecute. The major difference is that the new interface does not 
+have 
+a Priority parameter, this appeared to be useless and has been replaced 
+by 
+a 
 Type parameter. The Type tells the host what type of execution is being 
 requested, such as global lock handler, notify handler, GPE handler, etc. 
-This allows the host to queue and execute the request as appropriate for the 
-request type, possibly using different work queues and different priorities 
+This allows the host to queue and execute the request as appropriate for 
+the 
+request type, possibly using different work queues and different 
+priorities 
 for the various request types. This enables fixes for multithreading 
-deadlock problems such as BZ #5534, and will require changes to all existing 
+deadlock problems such as BZ #5534, and will require changes to all 
+existing 
 OS interface layers. (Alexey Starikovskiy and Bob Moore)
 
-Fixed a possible memory leak associated with the support for the so-called 
+Fixed a possible memory leak associated with the support for the so-
+called 
 "implicit return" ACPI extension. Reported by FreeBSD, BZ #6514. (Fiodor 
 Suietov)
 
 Fixed a problem with the Load() operator where a table load from an 
-operation region could overwrite an internal table buffer by up to 7 bytes 
-and cause alignment faults on IPF systems. (With assistance from Luming Yu)
+operation region could overwrite an internal table buffer by up to 7 
+bytes 
+and cause alignment faults on IPF systems. (With assistance from Luming 
+Yu)
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -4211,16 +8945,22 @@ a much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Disassembler: Implemented support to cross reference the internal namespace 
-and automatically generate ASL External() statements for symbols not defined 
+Disassembler: Implemented support to cross reference the internal 
+namespace 
+and automatically generate ASL External() statements for symbols not 
+defined 
 within the current table being disassembled. This will simplify the 
-disassembly and recompilation of interdependent tables such as SSDTs since 
+disassembly and recompilation of interdependent tables such as SSDTs 
+since 
 these statements will no longer have to be added manually.
 
 Disassembler: Implemented experimental support to automatically detect 
-invocations of external control methods and generate appropriate External() 
-statements. This is problematic because the AML cannot be correctly parsed 
-until the number of arguments for each control method is known. Currently, 
+invocations of external control methods and generate appropriate 
+External() 
+statements. This is problematic because the AML cannot be correctly 
+parsed 
+until the number of arguments for each control method is known. 
+Currently, 
 standalone method invocations and invocations as the source operand of a 
 Store() statement are supported.
 
@@ -4236,9 +8976,11 @@ more readable and likely closer to the original ASL source.
 
 Removed a device initialization optimization introduced in 20051216 where 
 the _STA method was not run unless an _INI was also present for the same 
-device. This optimization could cause problems because it could allow _INI 
+device. This optimization could cause problems because it could allow 
+_INI 
 methods to be run within a not-present device subtree. (If a not-present 
-device had no _INI, _STA would not be run, the not-present status would not 
+device had no _INI, _STA would not be run, the not-present status would 
+not 
 be discovered, and the children of the device would be incorrectly 
 traversed.)
 
@@ -4248,7 +8990,8 @@ Selectively running _STA can significantly improve boot time on large
 machines (with assistance from Len Brown.)
 
 Implemented support for the device initialization case where the returned 
-_STA flags indicate a device not-present but functioning. In this case, _INI 
+_STA flags indicate a device not-present but functioning. In this case, 
+_INI 
 is not run, but the device children are examined for presence, as per the 
 ACPI specification.
 
@@ -4261,7 +9004,8 @@ Defined and deployed a new OSL interface, AcpiOsValidateAddress. This
 interface is called during the creation of all AML operation regions, and 
 allows the host OS to exert control over what addresses it will allow the 
 AML code to access. Operation Regions whose addresses are disallowed will 
-cause a runtime exception when they are actually accessed (will not affect 
+cause a runtime exception when they are actually accessed (will not 
+affect 
 or abort table loading.) See oswinxf or osunixxf for an example 
 implementation.
 
@@ -4271,22 +9015,27 @@ interface/behavior strings for the _OSI predefined control method as
 appropriate (with assistance from Bjorn Helgaas.) See oswinxf or osunixxf 
 for an example implementation.
 
-Restructured and corrected various problems in the exception handling code 
+Restructured and corrected various problems in the exception handling 
+code 
 paths within DsCallControlMethod and DsTerminateControlMethod in dsmethod 
 (with assistance from Takayoshi Kochi.)
 
-Modified the Linux source converter to ignore quoted string literals while 
-converting identifiers from mixed to lower case. This will correct problems 
+Modified the Linux source converter to ignore quoted string literals 
+while 
+converting identifiers from mixed to lower case. This will correct 
+problems 
 with the disassembler and other areas where such strings must not be 
 modified.
 
 The ACPI_FUNCTION_* macros no longer require quotes around the function 
-name. This allows the Linux source converter to convert the names, now that 
+name. This allows the Linux source converter to convert the names, now 
+that 
 the converter ignores quoted strings.
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -4300,21 +9049,28 @@ a much larger code and data size.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Implemented 3 new warnings for iASL, and implemented multiple warning levels 
+Implemented 3 new warnings for iASL, and implemented multiple warning 
+levels 
 (w2 flag).
 
-1) Ignored timeouts: If the TimeoutValue parameter to Wait or Acquire is not 
+1) Ignored timeouts: If the TimeoutValue parameter to Wait or Acquire is 
+not 
 WAIT_FOREVER (0xFFFF) and the code does not examine the return value to 
 check for the possible timeout, a warning is issued.
 
-2) Useless operators: If an ASL operator does not specify an optional target 
+2) Useless operators: If an ASL operator does not specify an optional 
+target 
 operand and it also does not use the function return value from the 
-operator, a warning is issued since the operator effectively does nothing.
+operator, a warning is issued since the operator effectively does 
+nothing.
 
 3) Unreferenced objects: If a namespace object is created, but never 
-referenced, a warning is issued. This is a warning level 2 since there are 
-cases where this is ok, such as when a secondary table is loaded that uses 
-the unreferenced objects. Even so, care is taken to only flag objects that 
+referenced, a warning is issued. This is a warning level 2 since there 
+are 
+cases where this is ok, such as when a secondary table is loaded that 
+uses 
+the unreferenced objects. Even so, care is taken to only flag objects 
+that 
 don't look like they will ever be used. For example, the reserved methods 
 (starting with an underscore) are usually not referenced because it is 
 expected that the OS will invoke them.
@@ -4325,19 +9081,24 @@ expected that the OS will invoke them.
 1) ACPI CA Core Subsystem:
 
 Implemented header file support for the following additional ACPI tables: 
-ASF!, BOOT, CPEP, DBGP, MCFG, SPCR, SPMI, TCPA, and WDRT. With this support, 
-all current and known ACPI tables are now defined in the ACPICA headers and 
+ASF!, BOOT, CPEP, DBGP, MCFG, SPCR, SPMI, TCPA, and WDRT. With this 
+support, 
+all current and known ACPI tables are now defined in the ACPICA headers 
+and 
 are available for use by device drivers and other software.
 
 Implemented support to allow tables that contain ACPI names with invalid 
 characters to be loaded. Previously, this would cause the table load to 
 fail, but since there are several known cases of such tables on existing 
-machines, this change was made to enable ACPI support for them. Also, this 
+machines, this change was made to enable ACPI support for them. Also, 
+this 
 matches the behavior of the Microsoft ACPI implementation.
 
-Fixed a couple regressions introduced during the memory optimization in the 
+Fixed a couple regressions introduced during the memory optimization in 
+the 
 20060317 release. The namespace node definition required additional 
-reorganization and an internal datatype that had been changed to 8-bit was 
+reorganization and an internal datatype that had been changed to 8-bit 
+was 
 restored to 32-bit. (Valery Podrezov)
 
 Fixed a problem where a null pointer passed to AcpiUtDeleteGenericState 
@@ -4346,20 +9107,25 @@ null pointers are now trapped and ignored, matching the behavior of the
 previous implementation before the deployment of AcpiOsReleaseObject.
 (Valery Podrezov, Fiodor Suietov)
 
-Fixed a memory mapping leak during the deletion of a SystemMemory operation 
+Fixed a memory mapping leak during the deletion of a SystemMemory 
+operation 
 region where a cached memory mapping was not deleted. This became a 
-noticeable problem for operation regions that are defined within frequently 
+noticeable problem for operation regions that are defined within 
+frequently 
 used control methods. (Dana Meyers)
 
 Reorganized the ACPI table header files into two main files: one for the 
-ACPI tables consumed by the ACPICA core, and another for the miscellaneous 
-ACPI tables that are consumed by the drivers and other software. The various 
+ACPI tables consumed by the ACPICA core, and another for the 
+miscellaneous 
+ACPI tables that are consumed by the drivers and other software. The 
+various 
 FADT definitions were merged into one common section and three different 
 tables (ACPI 1.0, 1.0+, and 2.0)
 
 Example Code and Data Size: These are the sizes for the OS-independent 
 acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. The 
-debug version of the code includes the debug output trace mechanism and has 
+debug version of the code includes the debug output trace mechanism and 
+has 
 a much larger code and data size.
 
   Previous Release:
@@ -4374,16 +9140,19 @@ a much larger code and data size.
 
 Disassembler: Implemented support to decode and format all non-AML ACPI 
 tables (tables other than DSDTs and SSDTs.) This includes the new tables 
-added to the ACPICA headers, therefore all current and known ACPI tables are 
+added to the ACPICA headers, therefore all current and known ACPI tables 
+are 
 supported.
 
 Disassembler: The change to allow ACPI names with invalid characters also 
-enables the disassembly of such tables. Invalid characters within names are 
+enables the disassembly of such tables. Invalid characters within names 
+are 
 changed to '*' to make the name printable; the iASL compiler will still 
 generate an error for such names, however, since this is an invalid ACPI 
 character.
 
-Implemented an option for AcpiXtract (-a) to extract all tables found in the 
+Implemented an option for AcpiXtract (-a) to extract all tables found in 
+the 
 input file. The default invocation extracts only the DSDTs and SSDTs.
 
 Fixed a couple of gcc generation issues for iASL and AcpiExec and added a 
@@ -4396,20 +9165,25 @@ makefile for the AcpiXtract utility.
 
 Implemented the use of a cache object for all internal namespace nodes. 
 Since there are about 1000 static nodes in a typical system, this will 
-decrease memory use for cache implementations that minimize per-allocation 
+decrease memory use for cache implementations that minimize per-
+allocation 
 overhead (such as a slab allocator.)
 
-Removed the reference count mechanism for internal namespace nodes, since it 
+Removed the reference count mechanism for internal namespace nodes, since 
+it 
 was deemed unnecessary. This reduces the size of each namespace node by 
-about 5%-10% on all platforms. Nodes are now 20 bytes for the 32-bit case, 
+about 5%-10% on all platforms. Nodes are now 20 bytes for the 32-bit 
+case, 
 and 32 bytes for the 64-bit case.
 
-Optimized several internal data structures to reduce object size on 64-bit 
+Optimized several internal data structures to reduce object size on 64-
+bit 
 platforms by packing data within the 64-bit alignment. This includes the 
 frequently used ACPI_OPERAND_OBJECT, of which there can be ~1000 static 
 instances corresponding to the namespace objects.
 
-Added two new strings for the predefined _OSI method: "Windows 2001.1 SP1" 
+Added two new strings for the predefined _OSI method: "Windows 2001.1 
+SP1" 
 and "Windows 2006".
 
 Split the allocation tracking mechanism out to a separate file, from 
@@ -4417,13 +9191,17 @@ utalloc.c to uttrack.c. This mechanism appears to be only useful for
 application-level code. Kernels may wish to not include uttrack.c in 
 distributions.
 
-Removed all remnants of the obsolete ACPI_REPORT_* macros and the associated 
+Removed all remnants of the obsolete ACPI_REPORT_* macros and the 
+associated 
 code. (These macros have been replaced by the ACPI_ERROR and ACPI_WARNING 
 macros.)
 
-Code and Data Size: These are the sizes for the acpica.lib produced by the 
-Microsoft Visual C++ 6.0 32-bit compiler. The values do not include any ACPI 
-driver or OSPM code. The debug version of the code includes the debug output 
+Code and Data Size: These are the sizes for the acpica.lib produced by 
+the 
+Microsoft Visual C++ 6.0 32-bit compiler. The values do not include any 
+ACPI 
+driver or OSPM code. The debug version of the code includes the debug 
+output 
 trace mechanism and has a much larger code and data size. Note that these 
 values will vary depending on the efficiency of the compiler and the 
 compiler options used during generation.
@@ -4438,7 +9216,8 @@ compiler options used during generation.
 
 2) iASL Compiler/Disassembler and Tools:
 
-Implemented an ANSI C version of the acpixtract utility. This version will 
+Implemented an ANSI C version of the acpixtract utility. This version 
+will 
 automatically extract the DSDT and all SSDTs from the input acpidump text 
 file and dump the binary output to separate files. It can also display a 
 summary of the input file including the headers for each table found and 
@@ -4451,32 +9230,41 @@ source/tools/acpixtract)
 1) ACPI CA Core Subsystem:
 
 Tagged all external interfaces to the subsystem with the new 
-ACPI_EXPORT_SYMBOL macro. This macro can be defined as necessary to assist 
+ACPI_EXPORT_SYMBOL macro. This macro can be defined as necessary to 
+assist 
 kernel integration. For Linux, the macro resolves to the EXPORT_SYMBOL 
 macro. The default definition is NULL.
 
-Added the ACPI_THREAD_ID type for the return value from AcpiOsGetThreadId. 
+Added the ACPI_THREAD_ID type for the return value from 
+AcpiOsGetThreadId. 
 This allows the host to define this as necessary to simplify kernel 
 integration. The default definition is ACPI_NATIVE_UINT.
 
-Fixed two interpreter problems related to error processing, the deletion of 
+Fixed two interpreter problems related to error processing, the deletion 
+of 
 objects, and placing invalid pointers onto the internal operator result 
 stack. BZ 6028, 6151 (Valery Podrezov)
 
-Increased the reference count threshold where a warning is emitted for large 
-reference counts in order to eliminate unnecessary warnings on systems with 
+Increased the reference count threshold where a warning is emitted for 
+large 
+reference counts in order to eliminate unnecessary warnings on systems 
+with 
 large namespaces (especially 64-bit.) Increased the value from 0x400 to 
 0x800.
 
-Due to universal disagreement as to the meaning of the 'c' in the calloc() 
+Due to universal disagreement as to the meaning of the 'c' in the 
+calloc() 
 function, the ACPI_MEM_CALLOCATE macro has been renamed to 
 ACPI_ALLOCATE_ZEROED so that the purpose of the interface is 'clear'. 
 ACPI_MEM_ALLOCATE and ACPI_MEM_FREE are renamed to ACPI_ALLOCATE and 
 ACPI_FREE.
 
-Code and Data Size: These are the sizes for the acpica.lib produced by the 
-Microsoft Visual C++ 6.0 32-bit compiler. The values do not include any ACPI 
-driver or OSPM code. The debug version of the code includes the debug output 
+Code and Data Size: These are the sizes for the acpica.lib produced by 
+the 
+Microsoft Visual C++ 6.0 32-bit compiler. The values do not include any 
+ACPI 
+driver or OSPM code. The debug version of the code includes the debug 
+output 
 trace mechanism and has a much larger code and data size. Note that these 
 values will vary depending on the efficiency of the compiler and the 
 compiler options used during generation.
@@ -4492,23 +9280,30 @@ compiler options used during generation.
 2) iASL Compiler/Disassembler:
 
 Disassembler: implemented support for symbolic resource descriptor 
-references. If a CreateXxxxField operator references a fixed offset within a 
-resource descriptor, a name is assigned to the descriptor and the offset is 
+references. If a CreateXxxxField operator references a fixed offset 
+within 
+a 
+resource descriptor, a name is assigned to the descriptor and the offset 
+is 
 translated to the appropriate resource tag and pathname. The addition of 
 this support brings the disassembled code very close to the original ASL 
-source code and helps eliminate run-time errors when the disassembled code 
+source code and helps eliminate run-time errors when the disassembled 
+code 
 is modified (and recompiled) in such a way as to invalidate the original 
 fixed offsets.
 
-Implemented support for a Descriptor Name as the last parameter to the ASL 
+Implemented support for a Descriptor Name as the last parameter to the 
+ASL 
 Register() macro. This parameter was inadvertently left out of the ACPI 
 specification, and will be added for ACPI 3.0b.
 
 Fixed a problem where the use of the "_OSI" string (versus the full path 
 "\_OSI") caused an internal compiler error. ("No back ptr to op")
 
-Fixed a problem with the error message that occurs when an invalid string is 
-used for a _HID object (such as one with an embedded asterisk: "*PNP010A".) 
+Fixed a problem with the error message that occurs when an invalid string 
+is 
+used for a _HID object (such as one with an embedded asterisk: 
+"*PNP010A".) 
 The correct message is now displayed.
 
 ----------------------------------------
@@ -4516,9 +9311,12 @@ The correct message is now displayed.
 
 1) ACPI CA Core Subsystem:
 
-Implemented a change to the IndexField support to match the behavior of the 
-Microsoft AML interpreter. The value written to the Index register is now a 
-byte offset, no longer an index based upon the width of the Data register. 
+Implemented a change to the IndexField support to match the behavior of 
+the 
+Microsoft AML interpreter. The value written to the Index register is now 
+a 
+byte offset, no longer an index based upon the width of the Data 
+register. 
 This should fix IndexField problems seen on some machines where the Data 
 register is not exactly one byte wide. The ACPI specification will be 
 clarified on this point.
@@ -4528,12 +9326,16 @@ internal descriptor buffer due to size miscalculation: VendorShort,
 VendorLong, and Interrupt. This was noticed on IA64 machines, but could 
 affect all platforms.
 
-Fixed a problem where individual resource descriptors were misaligned within 
+Fixed a problem where individual resource descriptors were misaligned 
+within 
 the internal buffer, causing alignment faults on IA64 platforms.
 
-Code and Data Size: These are the sizes for the acpica.lib produced by the 
-Microsoft Visual C++ 6.0 32-bit compiler. The values do not include any ACPI 
-driver or OSPM code. The debug version of the code includes the debug output 
+Code and Data Size: These are the sizes for the acpica.lib produced by 
+the 
+Microsoft Visual C++ 6.0 32-bit compiler. The values do not include any 
+ACPI 
+driver or OSPM code. The debug version of the code includes the debug 
+output 
 trace mechanism and has a much larger code and data size. Note that these 
 values will vary depending on the efficiency of the compiler and the 
 compiler options used during generation.
@@ -4564,36 +9366,47 @@ Removed a couple of extraneous ACPI_ERROR messages that appeared during
 normal execution. These became apparent after the conversion from 
 ACPI_DEBUG_PRINT.
 
-Fixed a problem where the CreateField operator could hang if the BitIndex or 
+Fixed a problem where the CreateField operator could hang if the BitIndex 
+or 
 NumBits parameter referred to a named object. (Valery Podrezov, BZ 5359)
 
 Fixed a problem where a DeRefOf operation on a buffer object incorrectly 
 failed with an exception. This also fixes a couple of related RefOf and 
 DeRefOf issues. (Valery Podrezov, BZ 5360/5392/5387)
 
-Fixed a problem where the AE_BUFFER_LIMIT exception was returned instead of 
-AE_STRING_LIMIT on an out-of-bounds Index() operation. (Valery Podrezov, BZ 
+Fixed a problem where the AE_BUFFER_LIMIT exception was returned instead 
+of 
+AE_STRING_LIMIT on an out-of-bounds Index() operation. (Valery Podrezov, 
+BZ 
 5480)
 
-Implemented a memory cleanup at the end of the execution of each iteration 
-of an AML While() loop, preventing the accumulation of outstanding objects. 
+Implemented a memory cleanup at the end of the execution of each 
+iteration 
+of an AML While() loop, preventing the accumulation of outstanding 
+objects. 
 (Valery Podrezov, BZ 5427)
 
-Eliminated a chunk of duplicate code in the object resolution code. (Valery 
+Eliminated a chunk of duplicate code in the object resolution code. 
+(Valery 
 Podrezov, BZ 5336)
 
 Fixed several warnings during the 64-bit code generation.
 
-The AcpiSrc source code conversion tool now inserts one line of whitespace 
-after an if() statement that is followed immediately by a comment, improving 
+The AcpiSrc source code conversion tool now inserts one line of 
+whitespace 
+after an if() statement that is followed immediately by a comment, 
+improving 
 readability of the Linux code.
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -4606,7 +9419,8 @@ of the compiler and the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Fixed a problem with the disassembly of a BankField operator with a complex 
+Fixed a problem with the disassembly of a BankField operator with a 
+complex 
 expression for the BankValue parameter.
 
 ----------------------------------------
@@ -4614,11 +9428,14 @@ expression for the BankValue parameter.
 
 1) ACPI CA Core Subsystem:
 
-Implemented support in the Resource Manager to allow unresolved namestring 
-references within resource package objects for the _PRT method. This support 
+Implemented support in the Resource Manager to allow unresolved 
+namestring 
+references within resource package objects for the _PRT method. This 
+support 
 is in addition to the previously implemented unresolved reference support 
 within the AML parser. If the interpreter slack mode is enabled, these 
-unresolved references will be passed through to the caller as a NULL package 
+unresolved references will be passed through to the caller as a NULL 
+package 
 entry.
 
 Implemented and deployed new macros and functions for error and warning 
@@ -4628,16 +9445,19 @@ ACPI_WARNING, and ACPI_INFO replace the ACPI_REPORT_* macros. The older
 macros remain defined to allow ACPI drivers time to migrate to the new 
 macros.
 
-Implemented the ACPI_CPU_FLAGS type to simplify host OS integration of the 
+Implemented the ACPI_CPU_FLAGS type to simplify host OS integration of 
+the 
 Acquire/Release Lock OSL interfaces.
 
 Fixed a problem where Alias ASL operators are sometimes not correctly 
 resolved, in both the interpreter and the iASL compiler.
 
-Fixed several problems with the implementation of the ConcatenateResTemplate 
+Fixed several problems with the implementation of the 
+ConcatenateResTemplate 
 ASL operator. As per the ACPI specification, zero length buffers are now 
 treated as a single EndTag. One-length buffers always cause a fatal 
-exception. Non-zero length buffers that do not end with a full 2-byte EndTag 
+exception. Non-zero length buffers that do not end with a full 2-byte 
+EndTag 
 cause a fatal exception.
 
 Fixed a possible structure overwrite in the AcpiGetObjectInfo external 
@@ -4645,10 +9465,13 @@ interface. (With assistance from Thomas Renninger)
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -4661,7 +9484,8 @@ of the compiler and the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Fixed an internal error that was generated for any forward references to ASL 
+Fixed an internal error that was generated for any forward references to 
+ASL 
 Alias objects.
 
 ----------------------------------------
@@ -4673,18 +9497,24 @@ Added 2006 copyright to all module headers and signons. This affects
 virtually every file in the ACPICA core subsystem, iASL compiler, and the 
 utilities.
  
-Enhanced the ACPICA error reporting in order to simplify user migration to 
+Enhanced the ACPICA error reporting in order to simplify user migration 
+to 
 the non-debug version of ACPICA. Replaced all instances of the 
-ACPI_DEBUG_PRINT macro invoked at the ACPI_DB_ERROR and ACPI_DB_WARN debug 
+ACPI_DEBUG_PRINT macro invoked at the ACPI_DB_ERROR and ACPI_DB_WARN 
+debug 
 levels with the ACPI_REPORT_ERROR and ACPI_REPORT_WARNING macros, 
-respectively. This preserves all error and warning messages in the non-debug 
+respectively. This preserves all error and warning messages in the non-
+debug 
 version of the ACPICA code (this has been referred to as the "debug lite" 
 option.) Over 200 cases were converted to create a total of over 380 
-error/warning messages across the ACPICA code. This increases the code and 
-data size of the default non-debug version of the code somewhat (about 13K), 
+error/warning messages across the ACPICA code. This increases the code 
+and 
+data size of the default non-debug version of the code somewhat (about 
+13K), 
 but all error/warning reporting may be disabled if desired (and code 
 eliminated) by specifying the ACPI_NO_ERROR_MESSAGES compile-time 
-configuration option. The size of the debug version of ACPICA remains about 
+configuration option. The size of the debug version of ACPICA remains 
+about 
 the same.
 
 Fixed a memory leak within the AML Debugger "Set" command. One object was 
@@ -4692,10 +9522,13 @@ not properly deleted for every successful invocation of the command.
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -4709,7 +9542,8 @@ of the compiler and the compiler options used during generation.
 2) iASL Compiler/Disassembler:
 
 The compiler now officially supports the ACPI 3.0a specification that was 
-released on December 30, 2005. (Specification is available at www.acpi.info)
+released on December 30, 2005. (Specification is available at 
+www.acpi.info)
 
 ----------------------------------------
 16 December 2005. Summary of changes for version 20051216:
@@ -4719,18 +9553,25 @@ released on December 30, 2005. (Specification is available at www.acpi.info)
 Implemented optional support to allow unresolved names within ASL Package 
 objects. A null object is inserted in the package when a named reference 
 cannot be located in the current namespace. Enabled via the interpreter 
-slack flag, this should eliminate AE_NOT_FOUND exceptions seen on machines 
+slack flag, this should eliminate AE_NOT_FOUND exceptions seen on 
+machines 
 that contain such code.
 
-Implemented an optimization to the initialization sequence that can improve 
-boot time. During ACPI device initialization, the _STA method is now run if 
-and only if the _INI method exists. The _STA method is used to determine if 
-the device is present; An _INI can only be run if _STA returns present, but 
+Implemented an optimization to the initialization sequence that can 
+improve 
+boot time. During ACPI device initialization, the _STA method is now run 
+if 
+and only if the _INI method exists. The _STA method is used to determine 
+if 
+the device is present; An _INI can only be run if _STA returns present, 
+but 
 it is a waste of time to run the _STA method if the _INI does not exist. 
 (Prototype and assistance from Dong Wei)
 
-Implemented use of the C99 uintptr_t for the pointer casting macros if it is 
-available in the current compiler. Otherwise, the default (void *) cast is 
+Implemented use of the C99 uintptr_t for the pointer casting macros if it 
+is 
+available in the current compiler. Otherwise, the default (void *) cast 
+is 
 used as before.
 
 Fixed some possible memory leaks found within the execution path of the 
@@ -4744,7 +9585,8 @@ Moved resource descriptor string constants that are used by both the AML
 disassembler and AML debugger to the common utilities directory so that 
 these components are independent.
 
-Implemented support in the AcpiExec utility (-e switch) to globally ignore 
+Implemented support in the AcpiExec utility (-e switch) to globally 
+ignore 
 exceptions during control method execution (method is not aborted.)
 
 Added the rsinfo.c source file to the AcpiExec makefile for Linux/Unix 
@@ -4752,10 +9594,13 @@ generation.
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -4768,7 +9613,8 @@ of the compiler and the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Fixed a problem where a CPU stack overflow fault could occur if a recursive 
+Fixed a problem where a CPU stack overflow fault could occur if a 
+recursive 
 method call was made from within a Return statement.
 
 ----------------------------------------
@@ -4778,18 +9624,25 @@ method call was made from within a Return statement.
 
 Modified the parsing of control methods to no longer create namespace 
 objects during the first pass of the parse. Objects are now created only 
-during the execute phase, at the moment the namespace creation operator is 
-encountered in the AML (Name, OperationRegion, CreateByteField, etc.) This 
+during the execute phase, at the moment the namespace creation operator 
+is 
+encountered in the AML (Name, OperationRegion, CreateByteField, etc.) 
+This 
 should eliminate ALREADY_EXISTS exceptions seen on some machines where 
-reentrant control methods are protected by an AML mutex. The mutex will now 
-correctly block multiple threads from attempting to create the same object 
+reentrant control methods are protected by an AML mutex. The mutex will 
+now 
+correctly block multiple threads from attempting to create the same 
+object 
 more than once.
 
 Increased the number of available Owner Ids for namespace object tracking 
-from 32 to 255. This should eliminate the OWNER_ID_LIMIT exceptions seen on 
-some machines with a large number of ACPI tables (either static or dynamic).
+from 32 to 255. This should eliminate the OWNER_ID_LIMIT exceptions seen 
+on 
+some machines with a large number of ACPI tables (either static or 
+dynamic).
 
-Fixed a problem with the AcpiExec utility where a fault could occur when the 
+Fixed a problem with the AcpiExec utility where a fault could occur when 
+the 
 -b switch (batch mode) is used.
 
 Enhanced the namespace dump routine to output the owner ID for each 
@@ -4797,10 +9650,13 @@ namespace object.
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -4813,8 +9669,10 @@ of the compiler and the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Fixed a parse error during compilation of certain Switch/Case constructs. To 
-simplify the parse, the grammar now allows for multiple Default statements 
+Fixed a parse error during compilation of certain Switch/Case constructs. 
+To 
+simplify the parse, the grammar now allows for multiple Default 
+statements 
 and this error is now detected and flagged during the analysis phase.
 
 Disassembler: The disassembly now includes the contents of the original 
@@ -4827,32 +9685,43 @@ name and version of the original ASL compiler.
 1) ACPI CA Core Subsystem:
 
 Fixed a problem in the AML parser where the method thread count could be 
-decremented below zero if any errors occurred during the method parse phase. 
-This should eliminate AE_AML_METHOD_LIMIT exceptions seen on some machines. 
+decremented below zero if any errors occurred during the method parse 
+phase. 
+This should eliminate AE_AML_METHOD_LIMIT exceptions seen on some 
+machines. 
 This also fixed a related regression with the mechanism that detects and 
 corrects methods that cannot properly handle reentrancy (related to the 
 deployment of the new OwnerId mechanism.)
 
 Eliminated the pre-parsing of control methods (to detect errors) during 
-table load. Related to the problem above, this was causing unwind issues if 
-any errors occurred during the parse, and it seemed to be overkill. A table 
+table load. Related to the problem above, this was causing unwind issues 
+if 
+any errors occurred during the parse, and it seemed to be overkill. A 
+table 
 load should not be aborted if there are problems with any single control 
 method, thus rendering this feature rather pointless.
 
-Fixed a problem with the new table-driven resource manager where an internal 
+Fixed a problem with the new table-driven resource manager where an 
+internal 
 buffer overflow could occur for small resource templates.
 
-Implemented a new external interface, AcpiGetVendorResource. This interface 
-will find and return a vendor-defined resource descriptor within a _CRS or 
-_PRS method via an ACPI 3.0 UUID match. With assistance from Bjorn Helgaas.
+Implemented a new external interface, AcpiGetVendorResource. This 
+interface 
+will find and return a vendor-defined resource descriptor within a _CRS 
+or 
+_PRS method via an ACPI 3.0 UUID match. With assistance from Bjorn 
+Helgaas.
 
 Removed the length limit (200) on string objects as per the upcoming ACPI 
-3.0A specification. This affects the following areas of the interpreter: 1) 
-any implicit conversion of a Buffer to a String, 2) a String object result 
+3.0A specification. This affects the following areas of the interpreter: 
+1) 
+any implicit conversion of a Buffer to a String, 2) a String object 
+result 
 of the ASL Concatentate operator, 3) the String object result of the ASL 
 ToString operator.
 
-Fixed a problem in the Windows OS interface layer (OSL) where a WAIT_FOREVER 
+Fixed a problem in the Windows OS interface layer (OSL) where a 
+WAIT_FOREVER 
 on a semaphore object would incorrectly timeout. This allows the 
 multithreading features of the AcpiExec utility to work properly under 
 Windows.
@@ -4862,10 +9731,13 @@ the recently added file named "utresrc.c".
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -4879,15 +9751,18 @@ of the compiler and the compiler options used during generation.
 2) iASL Compiler/Disassembler:
 
 Removed the limit (200) on string objects as per the upcoming ACPI 3.0A 
-specification. For the iASL compiler, this means that string literals within 
+specification. For the iASL compiler, this means that string literals 
+within 
 the source ASL can be of any length. 
 
 Enhanced the listing output to dump the AML code for resource descriptors 
-immediately after the ASL code for each descriptor, instead of in a block at 
+immediately after the ASL code for each descriptor, instead of in a block 
+at 
 the end of the entire resource template.
 
 Enhanced the compiler debug output to dump the entire original parse tree 
-constructed during the parse phase, before any transforms are applied to the 
+constructed during the parse phase, before any transforms are applied to 
+the 
 tree. The transformed tree is dumped also.
 
 ----------------------------------------
@@ -4895,34 +9770,45 @@ tree. The transformed tree is dumped also.
 
 1) ACPI CA Core Subsystem:
 
-Modified the subsystem initialization sequence to improve GPE support. The 
-GPE initialization has been split into two parts in order to defer execution 
-of the _PRW methods (Power Resources for Wake) until after the hardware is 
+Modified the subsystem initialization sequence to improve GPE support. 
+The 
+GPE initialization has been split into two parts in order to defer 
+execution 
+of the _PRW methods (Power Resources for Wake) until after the hardware 
+is 
 fully initialized and the SCI handler is installed. This allows the _PRW 
-methods to access fields protected by the Global Lock. This will fix systems 
+methods to access fields protected by the Global Lock. This will fix 
+systems 
 where a NO_GLOBAL_LOCK exception has been seen during initialization.
 
-Converted the ACPI internal object disassemble and display code within the 
+Converted the ACPI internal object disassemble and display code within 
+the 
 AML debugger to fully table-driven operation, reducing code size and 
 increasing maintainability.
 
-Fixed a regression with the ConcatenateResTemplate() ASL operator introduced 
+Fixed a regression with the ConcatenateResTemplate() ASL operator 
+introduced 
 in the 20051021 release.
 
 Implemented support for "local" internal ACPI object types within the 
 debugger "Object" command and the AcpiWalkNamespace external interfaces. 
-These local types include RegionFields, BankFields, IndexFields, Alias, and 
+These local types include RegionFields, BankFields, IndexFields, Alias, 
+and 
 reference objects.
 
-Moved common AML resource handling code into a new file, "utresrc.c". This 
+Moved common AML resource handling code into a new file, "utresrc.c". 
+This 
 code is shared by both the Resource Manager and the AML Debugger.
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -4935,20 +9821,26 @@ of the compiler and the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Fixed a problem with very large initializer lists (more than 4000 elements) 
+Fixed a problem with very large initializer lists (more than 4000 
+elements) 
 for both Buffer and Package objects where the parse stack could overflow.
 
-Enhanced the pre-compile source code scan for non-ASCII characters to ignore 
-characters within comment fields. The scan is now always performed and is no 
+Enhanced the pre-compile source code scan for non-ASCII characters to 
+ignore 
+characters within comment fields. The scan is now always performed and is 
+no 
 longer optional, detecting invalid characters within a source file 
 immediately rather than during the parse phase or later.
 
-Enhanced the ASL grammar definition to force early reductions on all list-
+Enhanced the ASL grammar definition to force early reductions on all 
+list-
 style grammar elements so that the overall parse stack usage is greatly 
-reduced. This should improve performance and reduce the possibility of parse 
+reduced. This should improve performance and reduce the possibility of 
+parse 
 stack overflow.
 
-Eliminated all reduce/reduce conflicts in the iASL parser generation. Also, 
+Eliminated all reduce/reduce conflicts in the iASL parser generation. 
+Also, 
 with the addition of a %expected statement, the compiler generates from 
 source with no warnings.
 
@@ -4968,27 +9860,34 @@ hardware support for non-aligned transfers.
 Completed conversion of the Resource Manager to nearly full table-driven 
 operation. Specifically, the resource conversion code (convert AML to 
 internal format and the reverse) and the debug code to dump internal 
-resource descriptors are fully table-driven, reducing code and data size and 
+resource descriptors are fully table-driven, reducing code and data size 
+and 
 improving maintainability.
 
-The OSL interfaces for Acquire and Release Lock now use a 64-bit flag word 
-on 64-bit processors instead of a fixed 32-bit word. (With assistance from 
+The OSL interfaces for Acquire and Release Lock now use a 64-bit flag 
+word 
+on 64-bit processors instead of a fixed 32-bit word. (With assistance 
+from 
 Alexey Starikovskiy)
 
 Implemented support within the resource conversion code for the Type-
 Specific byte within the various ACPI 3.0 *WordSpace macros.
 
-Fixed some issues within the resource conversion code for the type-specific 
+Fixed some issues within the resource conversion code for the type-
+specific 
 flags for both Memory and I/O address resource descriptors. For Memory, 
 implemented support for the MTP and TTP flags. For I/O, split the TRS and 
 TTP flags into two separate fields.
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -5002,23 +9901,29 @@ of the compiler and the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Relaxed a compiler restriction that disallowed a ResourceIndex byte if the 
+Relaxed a compiler restriction that disallowed a ResourceIndex byte if 
+the 
 corresponding ResourceSource string was not also present in a resource 
 descriptor declaration. This restriction caused problems with existing 
-AML/ASL code that includes the Index byte without the string. When such AML 
+AML/ASL code that includes the Index byte without the string. When such 
+AML 
 was disassembled, it could not be compiled without modification. Further, 
-the modified code created a resource template with a different size than the 
-original, breaking code that used fixed offsets into the resource template 
+the modified code created a resource template with a different size than 
+the 
+original, breaking code that used fixed offsets into the resource 
+template 
 buffer.
 
-Removed a recent feature of the disassembler to ignore a lone ResourceIndex 
+Removed a recent feature of the disassembler to ignore a lone 
+ResourceIndex 
 byte. This byte is now emitted if present so that the exact AML can be 
 reproduced when the disassembled code is recompiled.
 
 Improved comments and text alignment for the resource descriptor code 
 emitted by the disassembler.
 
-Implemented disassembler support for the ACPI 3.0 AccessSize field within a 
+Implemented disassembler support for the ACPI 3.0 AccessSize field within 
+a 
 Register() resource descriptor.
 
 ----------------------------------------
@@ -5027,10 +9932,13 @@ Register() resource descriptor.
 1) ACPI CA Core Subsystem:
 
 Completed a major overhaul of the Resource Manager code - specifically, 
-optimizations in the area of the AML/internal resource conversion code. The 
-code has been optimized to simplify and eliminate duplicated code, CPU stack 
+optimizations in the area of the AML/internal resource conversion code. 
+The 
+code has been optimized to simplify and eliminate duplicated code, CPU 
+stack 
 use has been decreased by optimizing function parameters and local 
-variables, and naming conventions across the manager have been standardized 
+variables, and naming conventions across the manager have been 
+standardized 
 for clarity and ease of maintenance (this includes function, parameter, 
 variable, and struct/typedef names.) The update may force changes in some 
 driver code, depending on how resources are handled by the host OS.
@@ -5040,15 +9948,20 @@ single location for clarity and ease of maintenance. One new file was
 created, named "rsinfo.c".
 
 The ACPI return macros (return_ACPI_STATUS, etc.) have been modified to 
-guarantee that the argument is not evaluated twice, making them less prone 
+guarantee that the argument is not evaluated twice, making them less 
+prone 
 to macro side-effects. However, since there exists the possibility of 
-additional stack use if a particular compiler cannot optimize them (such as 
-in the debug generation case), the original macros are optionally available.  
+additional stack use if a particular compiler cannot optimize them (such 
+as 
+in the debug generation case), the original macros are optionally 
+available.  
 Note that some invocations of the return_VALUE macro may now cause size 
-mismatch warnings; the return_UINT8 and return_UINT32 macros are provided to 
+mismatch warnings; the return_UINT8 and return_UINT32 macros are provided 
+to 
 eliminate these. (From Randy Dunlap)
 
-Implemented a new mechanism to enable debug tracing for individual control 
+Implemented a new mechanism to enable debug tracing for individual 
+control 
 methods. A new external interface, AcpiDebugTrace, is provided to enable 
 this mechanism. The intent is to allow the host OS to easily enable and 
 disable tracing for problematic control methods. This interface can be 
@@ -5061,10 +9974,13 @@ the behavior of AcpiUtAllocate.
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -5086,11 +10002,13 @@ buffer is zero. Previously, this was a warning.
 1) ACPI CA Core Subsystem:
 
 Fixed a problem within the Resource Manager where support for the Generic 
-Register descriptor was not fully implemented. This descriptor is now fully 
+Register descriptor was not fully implemented. This descriptor is now 
+fully 
 recognized, parsed, disassembled, and displayed.
 
 Completely restructured the Resource Manager code to utilize table-driven 
-dispatch and lookup, eliminating many of the large switch() statements. This 
+dispatch and lookup, eliminating many of the large switch() statements. 
+This 
 reduces overall subsystem code size and code complexity. Affects the 
 resource parsing and construction, disassembly, and debug dump output.
 
@@ -5102,10 +10020,13 @@ optional ACPI_MUTEX_DEBUG code to fail compilation if specified.
 
 Code and Data Size: The current and previous library sizes for the core 
 subsystem are shown below. These are the code and data sizes for the 
-acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. These 
-values do not include any ACPI driver or OSPM code. The debug version of the 
+acpica.lib produced by the Microsoft Visual C++ 6.0 32-bit compiler. 
+These 
+values do not include any ACPI driver or OSPM code. The debug version of 
+the 
 code includes the debug output trace mechanism and has a much larger code 
-and data size. Note that these values will vary depending on the efficiency 
+and data size. Note that these values will vary depending on the 
+efficiency 
 of the compiler and the compiler options used during generation.
 
   Previous Release:
@@ -5118,12 +10039,14 @@ of the compiler and the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Updated the disassembler to automatically insert an EndDependentFn() macro 
+Updated the disassembler to automatically insert an EndDependentFn() 
+macro 
 into the ASL stream if this macro is missing in the original AML code, 
 simplifying compilation of the resulting ASL module.
 
 Fixed a problem in the disassembler where a disassembled ResourceSource 
-string (within a large resource descriptor) was not surrounded by quotes and 
+string (within a large resource descriptor) was not surrounded by quotes 
+and 
 not followed by a comma, causing errors when the resulting ASL module was 
 compiled. Also, escape sequences within a ResourceSource string are now 
 handled correctly (especially "\\")
@@ -5140,15 +10063,18 @@ messages seen on some systems. Recursive method invocation depth is
 currently limited to 255. (Alexey Starikovskiy)
 
 Completely eliminated all vestiges of support for the "module-level 
-executable code" until this support is fully implemented and debugged. This 
+executable code" until this support is fully implemented and debugged. 
+This 
 should eliminate the NO_RETURN_VALUE exceptions seen during table load on 
 some systems that invoke this support.
 
-Fixed a problem within the resource manager code where the transaction flags 
+Fixed a problem within the resource manager code where the transaction 
+flags 
 for a 64-bit address descriptor were handled incorrectly in the type-
 specific flag byte.
 
-Consolidated duplicate code within the address descriptor resource manager 
+Consolidated duplicate code within the address descriptor resource 
+manager 
 code, reducing overall subsystem code size.
 
 Fixed a fault when using the AML debugger "disassemble" command to 
@@ -5160,9 +10086,12 @@ release package.
 Code and Data Size: The current and previous core subsystem library sizes 
 are shown below. These are the code and data sizes for the acpica.lib 
 produced by the Microsoft Visual C++ 6.0 compiler. These values do not 
-include any ACPI driver or OSPM code. The debug version of the code includes 
-the debug output trace mechanism and has a much larger code and data size. 
-Note that these values will vary depending on the efficiency of the compiler 
+include any ACPI driver or OSPM code. The debug version of the code 
+includes 
+the debug output trace mechanism and has a much larger code and data 
+size. 
+Note that these values will vary depending on the efficiency of the 
+compiler 
 and the compiler options used during generation.
 
   Previous Release:
@@ -5175,11 +10104,13 @@ and the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Implemented an error check for illegal duplicate values in the interrupt and 
+Implemented an error check for illegal duplicate values in the interrupt 
+and 
 dma lists for the following ASL macros: Dma(), Irq(), IrqNoFlags(), and 
 Interrupt().
 
-Implemented error checking for the Irq() and IrqNoFlags() macros to detect 
+Implemented error checking for the Irq() and IrqNoFlags() macros to 
+detect 
 too many values in the interrupt list (16 max) and invalid values in the 
 list (range 0 - 15)
 
@@ -5196,20 +10127,26 @@ resource descriptor has already been used within the current scope.
  
 1) ACPI CA Core Subsystem:
  
-Implemented a full bytewise compare to determine if a table load request is 
-attempting to load a duplicate table. The compare is performed if the table 
+Implemented a full bytewise compare to determine if a table load request 
+is 
+attempting to load a duplicate table. The compare is performed if the 
+table 
 signatures and table lengths match. This will allow different tables with 
-the same OEM Table ID and revision to be loaded - probably against the ACPI 
+the same OEM Table ID and revision to be loaded - probably against the 
+ACPI 
 specification, but discovered in the field nonetheless.
  
 Added the changes.txt logfile to each of the zipped release packages.
  
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
  
   Previous Release:
@@ -5226,7 +10163,8 @@ Fixed a problem where incorrect AML code could be generated for Package
 objects if optimization is disabled (via the -oa switch).
  
 Fixed a problem with where incorrect AML code is generated for variable-
-length packages when the package length is not specified and the number of 
+length packages when the package length is not specified and the number 
+of 
 initializer values is greater than 255.
  
 
@@ -5235,37 +10173,48 @@ initializer values is greater than 255.
 
 1) ACPI CA Core Subsystem:
 
-Implemented support to ignore an attempt to install/load a particular ACPI 
+Implemented support to ignore an attempt to install/load a particular 
+ACPI 
 table more than once. Apparently there exists BIOS code that repeatedly 
 attempts to load the same SSDT upon certain events. With assistance from 
 Venkatesh Pallipadi.
 
 Restructured the main interface to the AML parser in order to correctly 
-handle all exceptional conditions. This will prevent leakage of the OwnerId 
-resource and should eliminate the AE_OWNER_ID_LIMIT exceptions seen on some 
+handle all exceptional conditions. This will prevent leakage of the 
+OwnerId 
+resource and should eliminate the AE_OWNER_ID_LIMIT exceptions seen on 
+some 
 machines. With assistance from Alexey Starikovskiy.
 
-Support for "module level code" has been disabled in this version due to a 
-number of issues that have appeared on various machines. The support can be 
+Support for "module level code" has been disabled in this version due to 
+a 
+number of issues that have appeared on various machines. The support can 
+be 
 enabled by defining ACPI_ENABLE_MODULE_LEVEL_CODE during subsystem 
-compilation. When the issues are fully resolved, the code will be enabled by 
+compilation. When the issues are fully resolved, the code will be enabled 
+by 
 default again.
 
 Modified the internal functions for debug print support to define the 
-FunctionName parameter as a (const char *) for compatibility with compiler 
+FunctionName parameter as a (const char *) for compatibility with 
+compiler 
 built-in macros such as __FUNCTION__, etc.
 
 Linted the entire ACPICA source tree for both 32-bit and 64-bit.
 
-Implemented support to display an object count summary for the AML Debugger 
+Implemented support to display an object count summary for the AML 
+Debugger 
 commands Object and Methods.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5279,7 +10228,8 @@ the compiler options used during generation.
 2) iASL Compiler/Disassembler:
 
 Fixed a regression that appeared in the 20050708 version of the compiler 
-where an error message was inadvertently emitted for invocations of the _OSI 
+where an error message was inadvertently emitted for invocations of the 
+_OSI 
 reserved control method.
 
 ----------------------------------------
@@ -5291,45 +10241,60 @@ The use of the CPU stack in the debug version of the subsystem has been
 considerably reduced. Previously, a debug structure was declared in every 
 function that used the debug macros. This structure has been removed in 
 favor of declaring the individual elements as parameters to the debug 
-functions. This reduces the cumulative stack use during nested execution of 
-ACPI function calls at the cost of a small increase in the code size of the 
-debug version of the subsystem. With assistance from Alexey Starikovskiy and 
+functions. This reduces the cumulative stack use during nested execution 
+of 
+ACPI function calls at the cost of a small increase in the code size of 
+the 
+debug version of the subsystem. With assistance from Alexey Starikovskiy 
+and 
 Len Brown.
 
 Added the ACPI_GET_FUNCTION_NAME macro to enable the compiler-dependent 
 headers to define a macro that will return the current function name at 
-runtime (such as __FUNCTION__ or _func_, etc.) The function name is used by 
+runtime (such as __FUNCTION__ or _func_, etc.) The function name is used 
+by 
 the debug trace output. If ACPI_GET_FUNCTION_NAME is not defined in the 
-compiler-dependent header, the function name is saved on the CPU stack (one 
+compiler-dependent header, the function name is saved on the CPU stack 
+(one 
 pointer per function.) This mechanism is used because apparently there 
-exists no standard ANSI-C defined macro that that returns the function name.
+exists no standard ANSI-C defined macro that that returns the function 
+name.
 
 Redesigned and reimplemented the "Owner ID" mechanism used to track 
 namespace objects created/deleted by ACPI tables and control method 
-execution. A bitmap is now used to allocate and free the IDs, thus solving 
-the wraparound problem present in the previous implementation. The size of 
+execution. A bitmap is now used to allocate and free the IDs, thus 
+solving 
+the wraparound problem present in the previous implementation. The size 
+of 
 the namespace node descriptor was reduced by 2 bytes as a result (Alexey 
 Starikovskiy).
 
-Removed the UINT32_BIT and UINT16_BIT types that were used for the bitfield 
+Removed the UINT32_BIT and UINT16_BIT types that were used for the 
+bitfield 
 flag definitions within the headers for the predefined ACPI tables. These 
-have been replaced by UINT8_BIT in order to increase the code portability of 
+have been replaced by UINT8_BIT in order to increase the code portability 
+of 
 the subsystem. If the use of UINT8 remains a problem, we may be forced to 
 eliminate bitfields entirely because of a lack of portability.
 
-Enhanced the performance of the AcpiUtUpdateObjectReference procedure. This 
-is a frequently used function and this improvement increases the performance 
+Enhanced the performance of the AcpiUtUpdateObjectReference procedure. 
+This 
+is a frequently used function and this improvement increases the 
+performance 
 of the entire subsystem (Alexey Starikovskiy).
 
 Fixed several possible memory leaks and the inverse - premature object 
 deletion (Alexey Starikovskiy).
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5345,7 +10310,8 @@ the compiler options used during generation.
 1) ACPI CA Core Subsystem:
 
 Modified the new OSL cache interfaces to use ACPI_CACHE_T as the type for 
-the host-defined cache object. This allows the OSL implementation to define 
+the host-defined cache object. This allows the OSL implementation to 
+define 
 and type this object in any manner desired, simplifying the OSL 
 implementation. For example, ACPI_CACHE_T is defined as kmem_cache_t for 
 Linux, and should be defined in the OS-specific header file for other 
@@ -5357,21 +10323,28 @@ change was made for performance reasons, since this is the purpose of the
 interface in the first place. AcpiOsAcquireObject is now similar to the 
 AcpiOsAllocate interface.
 
-Implemented a new AML debugger command named Businfo. This command displays 
-information about all devices that have an associate _PRT object. The _ADR, 
+Implemented a new AML debugger command named Businfo. This command 
+displays 
+information about all devices that have an associate _PRT object. The 
+_ADR, 
 _HID, _UID, and _CID are displayed for these devices.
 
-Modified the initialization sequence in AcpiInitializeSubsystem to call the 
-OSL interface AcpiOslInitialize first, before any local initialization. This 
+Modified the initialization sequence in AcpiInitializeSubsystem to call 
+the 
+OSL interface AcpiOslInitialize first, before any local initialization. 
+This 
 change was required because the global initialization now calls OSL 
 interfaces.
 
-Enhanced the Dump command to display the entire contents of Package objects 
+Enhanced the Dump command to display the entire contents of Package 
+objects 
 (including all sub-objects and their values.) 
 
 Restructured the code base to split some files because of size and/or 
-because the code logically belonged in a separate file. New files are listed 
-below. All makefiles and project files included in the ACPI CA release have 
+because the code logically belonged in a separate file. New files are 
+listed 
+below. All makefiles and project files included in the ACPI CA release 
+have 
 been updated.
     utilities/utcache.c           /* Local cache interfaces */
     utilities/utmutex.c           /* Local mutex support */
@@ -5379,11 +10352,14 @@ been updated.
     interpreter/parser/psloop.c   /* Main AML parse loop */
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5396,7 +10372,8 @@ the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Fixed a regression introduced in version 20050513 where the use of a Package 
+Fixed a regression introduced in version 20050513 where the use of a 
+Package 
 object within a Case() statement caused a compile time exception. The 
 original behavior has been restored (a Match() operator is emitted.)
 
@@ -5405,10 +10382,13 @@ original behavior has been restored (a Match() operator is emitted.)
 
 1) ACPI CA Core Subsystem:
 
-Moved the object cache operations into the OS interface layer (OSL) to allow 
+Moved the object cache operations into the OS interface layer (OSL) to 
+allow 
 the host OS to handle these operations if desired (for example, the Linux 
-OSL will invoke the slab allocator). This support is optional; the compile 
-time define ACPI_USE_LOCAL_CACHE may be used to utilize the original cache 
+OSL will invoke the slab allocator). This support is optional; the 
+compile 
+time define ACPI_USE_LOCAL_CACHE may be used to utilize the original 
+cache 
 code in the ACPI CA core. The new OSL interfaces are shown below. See 
 utalloc.c for an example implementation, and acpiosxf.h for the exact 
 interface definitions. With assistance from Alexey Starikovskiy.
@@ -5418,44 +10398,59 @@ interface definitions. With assistance from Alexey Starikovskiy.
     AcpiOsAcquireObject
     AcpiOsReleaseObject
 
-Modified the interfaces to AcpiOsAcquireLock and AcpiOsReleaseLock to return 
+Modified the interfaces to AcpiOsAcquireLock and AcpiOsReleaseLock to 
+return 
 and restore a flags parameter. This fits better with many OS lock models. 
 Note: the current execution state (interrupt handler or not) is no longer 
-passed to these interfaces. If necessary, the OSL must determine this state 
+passed to these interfaces. If necessary, the OSL must determine this 
+state 
 by itself, a simple and fast operation. With assistance from Alexey 
 Starikovskiy.
 
 Fixed a problem in the ACPI table handling where a valid XSDT was assumed 
-present if the revision of the RSDP was 2 or greater. According to the ACPI 
+present if the revision of the RSDP was 2 or greater. According to the 
+ACPI 
 specification, the XSDT is optional in all cases, and the table manager 
 therefore now checks for both an RSDP >=2 and a valid XSDT pointer. 
-Otherwise, the RSDT pointer is used. Some ACPI 2.0 compliant BIOSs contain 
+Otherwise, the RSDT pointer is used. Some ACPI 2.0 compliant BIOSs 
+contain 
 only the RSDT.
 
-Fixed an interpreter problem with the Mid() operator in the case of an input 
-string where the resulting output string is of zero length. It now correctly 
+Fixed an interpreter problem with the Mid() operator in the case of an 
+input 
+string where the resulting output string is of zero length. It now 
+correctly 
 returns a valid, null terminated string object instead of a string object 
 with a null pointer.
 
-Fixed a problem with the control method argument handling to allow a store 
-to an Arg object that already contains an object of type Device. The Device 
+Fixed a problem with the control method argument handling to allow a 
+store 
+to an Arg object that already contains an object of type Device. The 
+Device 
 object is now correctly overwritten. Previously, an error was returned.
 
 
-Enhanced the debugger Find command to emit object values in addition to the 
-found object pathnames. The output format is the same as the dump namespace 
+Enhanced the debugger Find command to emit object values in addition to 
+the 
+found object pathnames. The output format is the same as the dump 
+namespace 
 command.
 
-Enhanced the debugger Set command. It now has the ability to set the value 
-of any Named integer object in the namespace (Previously, only method locals 
+Enhanced the debugger Set command. It now has the ability to set the 
+value 
+of any Named integer object in the namespace (Previously, only method 
+locals 
 and args could be set.)
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5468,15 +10463,18 @@ the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Fixed a regression in the disassembler where if/else/while constructs were 
+Fixed a regression in the disassembler where if/else/while constructs 
+were 
 output incorrectly. This problem was introduced in the previous release 
 (20050526). This problem also affected the single-step disassembly in the 
 debugger.
 
-Fixed a problem where compiling the reserved _OSI method would randomly (but 
+Fixed a problem where compiling the reserved _OSI method would randomly 
+(but 
 rarely) produce compile errors.
 
-Enhanced the disassembler to emit compilable code in the face of incorrect 
+Enhanced the disassembler to emit compilable code in the face of 
+incorrect 
 AML resource descriptors. If the optional ResourceSourceIndex is present, 
 but the ResourceSource is not, do not emit the ResourceSourceIndex in the 
 disassembly. Otherwise, the resulting code cannot be compiled without 
@@ -5488,17 +10486,23 @@ errors.
 1) ACPI CA Core Subsystem:
 
 Implemented support to execute Type 1 and Type 2 AML opcodes appearing at 
-the module level (not within a control method.) These opcodes are executed 
-exactly once at the time the table is loaded. This type of code was legal up 
-until the release of ACPI 2.0B (2002) and is now supported within ACPI CA in 
-order to provide backwards compatibility with earlier BIOS implementations. 
+the module level (not within a control method.) These opcodes are 
+executed 
+exactly once at the time the table is loaded. This type of code was legal 
+up 
+until the release of ACPI 2.0B (2002) and is now supported within ACPI CA 
+in 
+order to provide backwards compatibility with earlier BIOS 
+implementations. 
 This eliminates the "Encountered executable code at module level" warning 
 that was previously generated upon detection of such code.
 
 Fixed a problem in the interpreter where an AE_NOT_FOUND exception could 
 inadvertently be generated during the lookup of namespace objects in the 
-second pass parse of ACPI tables and control methods. It appears that this 
-problem could occur during the resolution of forward references to namespace 
+second pass parse of ACPI tables and control methods. It appears that 
+this 
+problem could occur during the resolution of forward references to 
+namespace 
 objects.
 
 Added the ACPI_MUTEX_DEBUG #ifdef to the AcpiUtReleaseMutex function, 
@@ -5511,15 +10515,19 @@ Implemented a handful of miscellaneous fixes for possible memory leaks on
 error conditions and error handling control paths. These fixes were 
 suggested by FreeBSD and the Coverity Prevent source code analysis tool.
 
-Added a check for a null RSDT pointer in AcpiGetFirmwareTable (tbxfroot.c) 
+Added a check for a null RSDT pointer in AcpiGetFirmwareTable 
+(tbxfroot.c) 
 to prevent a fault in this error case.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5534,21 +10542,28 @@ the compiler options used during generation.
 
 Implemented support to allow Type 1 and Type 2 ASL operators to appear at 
 the module level (not within a control method.) These operators will be 
-executed once at the time the table is loaded. This type of code was legal 
+executed once at the time the table is loaded. This type of code was 
+legal 
 up until the release of ACPI 2.0B (2002) and is now supported by the iASL 
-compiler in order to provide backwards compatibility with earlier BIOS ASL 
+compiler in order to provide backwards compatibility with earlier BIOS 
+ASL 
 code.
 
 The ACPI integer width (specified via the table revision ID or the -r 
-override, 32 or 64 bits) is now used internally during compile-time constant 
+override, 32 or 64 bits) is now used internally during compile-time 
+constant 
 folding to ensure that constants are truncated to 32 bits if necessary. 
-Previously, the revision ID value was only emitted in the AML table header.
+Previously, the revision ID value was only emitted in the AML table 
+header.
 
-An error message is now generated for the Mutex and Method operators if the 
+An error message is now generated for the Mutex and Method operators if 
+the 
 SyncLevel parameter is outside the legal range of 0 through 15.
 
-Fixed a problem with the Method operator ParameterTypes list handling (ACPI 
-3.0). Previously, more than 2 types or 2 arguments generated a syntax error.  
+Fixed a problem with the Method operator ParameterTypes list handling 
+(ACPI 
+3.0). Previously, more than 2 types or 2 arguments generated a syntax 
+error.  
 The actual underlying implementation of method argument typechecking is 
 still under development, however.
 
@@ -5557,39 +10572,50 @@ still under development, however.
 
 1) ACPI CA Core Subsystem:
 
-Implemented support for PCI Express root bridges -- added support for device 
+Implemented support for PCI Express root bridges -- added support for 
+device 
 PNP0A08 in the root bridge search within AcpiEvPciConfigRegionSetup.
 
-The interpreter now automatically truncates incoming 64-bit constants to 32 
-bits if currently executing out of a 32-bit ACPI table (Revision < 2). This 
+The interpreter now automatically truncates incoming 64-bit constants to 
+32 
+bits if currently executing out of a 32-bit ACPI table (Revision < 2). 
+This 
 also affects the iASL compiler constant folding. (Note: as per below, the 
 iASL compiler no longer allows 64-bit constants within 32-bit tables.)
 
 Fixed a problem where string and buffer objects with "static" pointers 
 (pointers to initialization data within an ACPI table) were not handled 
-consistently. The internal object copy operation now always copies the data 
+consistently. The internal object copy operation now always copies the 
+data 
 to a newly allocated buffer, regardless of whether the source object is 
 static or not.
 
 Fixed a problem with the FromBCD operator where an implicit result 
-conversion was improperly performed while storing the result to the target 
+conversion was improperly performed while storing the result to the 
+target 
 operand. Since this is an "explicit conversion" operator, the implicit 
 conversion should never be performed on the output.
 
 Fixed a problem with the CopyObject operator where a copy to an existing 
-named object did not always completely overwrite the existing object stored 
-at name. Specifically, a buffer-to-buffer copy did not delete the existing 
+named object did not always completely overwrite the existing object 
+stored 
+at name. Specifically, a buffer-to-buffer copy did not delete the 
+existing 
 buffer.
 
-Replaced "InterruptLevel" with "InterruptNumber" in all GPE interfaces and 
+Replaced "InterruptLevel" with "InterruptNumber" in all GPE interfaces 
+and 
 structs for consistency.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5602,17 +10628,21 @@ the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-The compiler now emits a warning if an attempt is made to generate a 64-bit 
-integer constant from within a 32-bit ACPI table (Revision < 2). The integer 
+The compiler now emits a warning if an attempt is made to generate a 64-
+bit 
+integer constant from within a 32-bit ACPI table (Revision < 2). The 
+integer 
 is truncated to 32 bits.
 
 Fixed a problem with large package objects: if the static length of the 
 package is greater than 255, the "variable length package" opcode is 
 emitted. Previously, this caused an error. This requires an update to the 
-ACPI spec, since it currently (incorrectly) states that packages larger than 
+ACPI spec, since it currently (incorrectly) states that packages larger 
+than 
 255 elements are not allowed.
 
-The disassembler now correctly handles variable length packages and packages 
+The disassembler now correctly handles variable length packages and 
+packages 
 larger than 255 elements.
 
 ----------------------------------------
@@ -5624,31 +10654,41 @@ Fixed three cases in the interpreter where an "index" argument to an ASL
 function was still (internally) 32 bits instead of the required 64 bits. 
 This was the Index argument to the Index, Mid, and Match operators.
 
-The "strupr" function is now permanently local (AcpiUtStrupr), since this is 
+The "strupr" function is now permanently local (AcpiUtStrupr), since this 
+is 
 not a POSIX-defined function and not present in most kernel-level C 
-libraries. All references to the C library strupr function have been removed 
+libraries. All references to the C library strupr function have been 
+removed 
 from the headers.
 
-Completed the deployment of static functions/prototypes. All prototypes with 
-the static attribute have been moved from the headers to the owning C file.
+Completed the deployment of static functions/prototypes. All prototypes 
+with 
+the static attribute have been moved from the headers to the owning C 
+file.
 
 Implemented an extract option (-e) for the AcpiBin utility (AML binary 
-utility). This option allows the utility to extract individual ACPI tables 
+utility). This option allows the utility to extract individual ACPI 
+tables 
 from the output of AcpiDmp. It provides the same functionality of the 
 acpixtract.pl perl script without the worry of setting the correct perl 
-options. AcpiBin runs on Windows and has not yet been generated/validated in 
+options. AcpiBin runs on Windows and has not yet been generated/validated 
+in 
 the Linux/Unix environment (but should be soon).
  
 Updated and fixed the table dump option for AcpiBin (-d). This option 
-converts a single ACPI table to a hex/ascii file, similar to the output of 
+converts a single ACPI table to a hex/ascii file, similar to the output 
+of 
 AcpiDmp.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5661,8 +10701,10 @@ the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Disassembler fix: Added a check to ensure that the table length found in the 
-ACPI table header within the input file is not longer than the actual input 
+Disassembler fix: Added a check to ensure that the table length found in 
+the 
+ACPI table header within the input file is not longer than the actual 
+input 
 file size. This indicates some kind of file or table corruption.
 
 ----------------------------------------
@@ -5670,24 +10712,28 @@ file size. This indicates some kind of file or table corruption.
 
 1) ACPI CA Core Subsystem:
 
-An error is now generated if an attempt is made to create a Buffer Field of 
+An error is now generated if an attempt is made to create a Buffer Field 
+of 
 length zero (A CreateField with a length operand of zero.)
 
-The interpreter now issues a warning whenever executable code at the module 
+The interpreter now issues a warning whenever executable code at the 
+module 
 level is detected during ACPI table load. This will give some idea of the 
 prevalence of this type of code.
 
 Implemented support for references to named objects (other than control 
 methods) within package objects.
 
-Enhanced package object output for the debug object. Package objects are now 
+Enhanced package object output for the debug object. Package objects are 
+now 
 completely dumped, showing all elements.
 
 Enhanced miscellaneous object output for the debug object. Any object can 
 now be written to the debug object (for example, a device object can be 
 written, and the type of the object will be displayed.)
 
-The "static" qualifier has been added to all local functions across both the 
+The "static" qualifier has been added to all local functions across both 
+the 
 core subsystem and the iASL compiler.
 
 The number of "long" lines (> 80 chars) within the source has been 
@@ -5701,11 +10747,14 @@ Two new header files have been added, acopcode.h and acnames.h.
 Removed several obsolete functions that were no longer used.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5720,10 +10769,12 @@ the compiler options used during generation.
 2) iASL Compiler/Disassembler:
 
 Fixed a problem with the resource descriptor generation/support. For the 
-ResourceSourceIndex and the ResourceSource fields, both must be present, or 
+ResourceSourceIndex and the ResourceSource fields, both must be present, 
+or 
 both must be not present - can't have one without the other.
 
-The compiler now returns non-zero from the main procedure if any errors have 
+The compiler now returns non-zero from the main procedure if any errors 
+have 
 occurred during the compilation.
 
 
@@ -5732,56 +10783,74 @@ occurred during the compilation.
 
 1) ACPI CA Core Subsystem:
 
-The string-to-buffer implicit conversion code has been modified again after 
-a change to the ACPI specification.  In order to match the behavior of the 
-other major ACPI implementation, the target buffer is no longer truncated if 
+The string-to-buffer implicit conversion code has been modified again 
+after 
+a change to the ACPI specification.  In order to match the behavior of 
+the 
+other major ACPI implementation, the target buffer is no longer truncated 
+if 
 the source string is smaller than an existing target buffer. This change 
 requires an update to the ACPI spec, and should eliminate the recent 
 AE_AML_BUFFER_LIMIT issues.
 
-The "implicit return" support was rewritten to a new algorithm that solves 
-the general case. Rather than attempt to determine when a method is about to 
-exit, the result of every ASL operator is saved momentarily until the very 
+The "implicit return" support was rewritten to a new algorithm that 
+solves 
+the general case. Rather than attempt to determine when a method is about 
+to 
+exit, the result of every ASL operator is saved momentarily until the 
+very 
 next ASL operator is executed. Therefore, no matter how the method exits, 
 there will always be a saved implicit return value. This feature is only 
-enabled with the AcpiGbl_EnableInterpreterSlack flag, and should eliminate 
+enabled with the AcpiGbl_EnableInterpreterSlack flag, and should 
+eliminate 
 AE_AML_NO_RETURN_VALUE errors when enabled.
 
-Implemented implicit conversion support for the predicate (operand) of the 
-If, Else, and While operators. String and Buffer arguments are automatically 
+Implemented implicit conversion support for the predicate (operand) of 
+the 
+If, Else, and While operators. String and Buffer arguments are 
+automatically 
 converted to Integers.
 
 Changed the string-to-integer conversion behavior to match the new ACPI 
 errata: "If no integer object exists, a new integer is created. The ASCII 
 string is interpreted as a hexadecimal constant. Each string character is 
 interpreted as a hexadecimal value ('0'-'9', 'A'-'F', 'a', 'f'), starting 
-with the first character as the most significant digit, and ending with the 
-first non-hexadecimal character or end-of-string." This means that the first 
+with the first character as the most significant digit, and ending with 
+the 
+first non-hexadecimal character or end-of-string." This means that the 
+first 
 non-hex character terminates the conversion and this is the code that was 
 changed.
 
-Fixed a problem where the ObjectType operator would fail (fault) when used 
+Fixed a problem where the ObjectType operator would fail (fault) when 
+used 
 on an Index of a Package which pointed to a null package element. The 
 operator now properly returns zero (Uninitialized) in this case.
 
 Fixed a problem where the While operator used excessive memory by not 
-properly popping the result stack during execution. There was no memory leak 
+properly popping the result stack during execution. There was no memory 
+leak 
 after execution, however. (Code provided by Valery Podrezov.)
 
-Fixed a problem where references to control methods within Package objects 
+Fixed a problem where references to control methods within Package 
+objects 
 caused the method to be invoked, instead of producing a reference object 
 pointing to the method.
 
-Restructured and simplified the pswalk.c module (AcpiPsDeleteParseTree) to 
+Restructured and simplified the pswalk.c module (AcpiPsDeleteParseTree) 
+to 
 improve performance and reduce code size. (Code provided by Alexey 
 Starikovskiy.)
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5795,25 +10864,29 @@ the compiler options used during generation.
 2) iASL Compiler/Disassembler:
 
 Fixed a problem with the Return operator with no arguments. Since the AML 
-grammar for the byte encoding requires an operand for the Return opcode, the 
+grammar for the byte encoding requires an operand for the Return opcode, 
+the 
 compiler now emits a Return(Zero) for this case.  An ACPI specification 
 update has been written for this case.
 
 For tables other than the DSDT, namepath optimization is automatically 
-disabled. This is because SSDTs can be loaded anywhere in the namespace, the 
+disabled. This is because SSDTs can be loaded anywhere in the namespace, 
+the 
 compiler has no knowledge of where, and thus cannot optimize namepaths.
 
 Added "ProcessorObj" to the ObjectTypeKeyword list. This object type was 
 inadvertently omitted from the ACPI specification, and will require an 
 update to the spec.
 
-The source file scan for ASCII characters is now optional (-a). This change 
+The source file scan for ASCII characters is now optional (-a). This 
+change 
 was made because some vendors place non-ascii characters within comments. 
 However, the scan is simply a brute-force byte compare to ensure all 
 characters in the file are in the range 0x00 to 0x7F.
 
 Fixed a problem with the CondRefOf operator where the compiler was 
-inappropriately checking for the existence of the target. Since the point of 
+inappropriately checking for the existence of the target. Since the point 
+of 
 the operator is to check for the existence of the target at run-time, the 
 compiler no longer checks for the target existence.
 
@@ -5821,17 +10894,22 @@ Fixed a problem where errors generated from the internal AML interpreter
 during constant folding were not handled properly, causing a fault.
 
 Fixed a problem with overly aggressive range checking for the Stall 
-operator. The valid range (max 255) is now only checked if the operand is of 
+operator. The valid range (max 255) is now only checked if the operand is 
+of 
 type Integer. All other operand types cannot be statically checked.
 
-Fixed a problem where control method references within the RefOf, DeRefOf, 
-and ObjectType operators were not treated properly. They are now treated as 
+Fixed a problem where control method references within the RefOf, 
+DeRefOf, 
+and ObjectType operators were not treated properly. They are now treated 
+as 
 actual references, not method invocations.
 
-Fixed and enhanced the "list namespace" option (-ln). This option was broken 
+Fixed and enhanced the "list namespace" option (-ln). This option was 
+broken 
 a number of releases ago.
 
-Improved error handling for the Field, IndexField, and BankField operators. 
+Improved error handling for the Field, IndexField, and BankField 
+operators. 
 The compiler now cleanly reports and recovers from errors in the field 
 component (FieldUnit) list.
 
@@ -5846,20 +10924,24 @@ Disassembler - Comments in output now use "//" instead of "/*"
 1) ACPI CA Core Subsystem:
 
 Fixed a problem where the result of an Index() operator (an object 
-reference) must increment the reference count on the target object for the 
+reference) must increment the reference count on the target object for 
+the 
 life of the object reference.
 
 Implemented AML Interpreter and Debugger support for the new ACPI 3.0 
-Extended Address (IO, Memory, Space), QwordSpace, DwordSpace, and WordSpace 
+Extended Address (IO, Memory, Space), QwordSpace, DwordSpace, and 
+WordSpace 
 resource descriptors.
 
 Implemented support in the _OSI method for the ACPI 3.0 "Extended Address 
-Space Descriptor" string, indicating interpreter support for the descriptors 
+Space Descriptor" string, indicating interpreter support for the 
+descriptors 
 above.
 
 Implemented header support for the new ACPI 3.0 FADT flag bits.
 
-Implemented header support for the new ACPI 3.0 PCI Express bits for the PM1 
+Implemented header support for the new ACPI 3.0 PCI Express bits for the 
+PM1 
 status/enable registers.
 
 Updated header support for the MADT processor local Apic struct and MADT 
@@ -5867,15 +10949,19 @@ platform interrupt source struct for new ACPI 3.0 fields.
 
 Implemented header support for the SRAT and SLIT ACPI tables.
 
-Implemented the -s switch in AcpiExec to enable the "InterpreterSlack" flag 
+Implemented the -s switch in AcpiExec to enable the "InterpreterSlack" 
+flag 
 at runtime.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5888,15 +10974,18 @@ the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Fixed a problem with the internal 64-bit String-to-integer conversion with 
+Fixed a problem with the internal 64-bit String-to-integer conversion 
+with 
 strings less than two characters long.
 
 Fixed a problem with constant folding where the result of the Index() 
-operator can not be considered a constant. This means that Index() cannot be 
+operator can not be considered a constant. This means that Index() cannot 
+be 
 a type3 opcode and this will require an update to the ACPI specification.
 
 Disassembler: Implemented support for the TTP, MTP, and TRS resource 
-descriptor fields. These fields were inadvertently ignored and not output in 
+descriptor fields. These fields were inadvertently ignored and not output 
+in 
 the disassembly of the resource descriptor.
 
 
@@ -5906,29 +10995,40 @@ the disassembly of the resource descriptor.
 1) ACPI CA Core Subsystem:
 
 Implemented ACPI 3.0 support for implicit conversion within the Match() 
-operator. MatchObjects can now be of type integer, buffer, or string instead 
-of just type integer.  Package elements are implicitly converted to the type 
+operator. MatchObjects can now be of type integer, buffer, or string 
+instead 
+of just type integer.  Package elements are implicitly converted to the 
+type 
 of the MatchObject. This change aligns the behavior of Match() with the 
-behavior of the other logical operators (LLess(), etc.) It also requires an 
+behavior of the other logical operators (LLess(), etc.) It also requires 
+an 
 errata change to the ACPI specification as this support was intended for 
 ACPI 3.0, but was inadvertently omitted.
 
-Fixed a problem with the internal implicit "to buffer" conversion. Strings 
-that are converted to buffers will cause buffer truncation if the string is 
-smaller than the target buffer. Integers that are converted to buffers will 
+Fixed a problem with the internal implicit "to buffer" conversion. 
+Strings 
+that are converted to buffers will cause buffer truncation if the string 
+is 
+smaller than the target buffer. Integers that are converted to buffers 
+will 
 not cause buffer truncation, only zero extension (both as per the ACPI 
 spec.) The problem was introduced when code was added to truncate the 
-buffer, but this should not be performed in all cases, only the string case.
+buffer, but this should not be performed in all cases, only the string 
+case.
 
-Fixed a problem with the Buffer and Package operators where the interpreter 
+Fixed a problem with the Buffer and Package operators where the 
+interpreter 
 would get confused if two such operators were used as operands to an ASL 
 operator (such as LLess(Buffer(1){0},Buffer(1){1}). The internal result 
-stack was not being popped after the execution of these operators, resulting 
+stack was not being popped after the execution of these operators, 
+resulting 
 in an AE_NO_RETURN_VALUE exception.
 
 Fixed a problem with constructs of the form Store(Index(...),...). The 
-reference object returned from Index was inadvertently resolved to an actual 
-value. This problem was introduced in version 20050114 when the behavior of 
+reference object returned from Index was inadvertently resolved to an 
+actual 
+value. This problem was introduced in version 20050114 when the behavior 
+of 
 Store() was modified to restrict the object types that can be used as the 
 source operand (to match the ACPI specification.)
 
@@ -5939,11 +11039,14 @@ Added a fix to aclinux.h to allow generation of AcpiExec on Linux.
 Updated the AcpiSrc utility to add the FADT_DESCRIPTOR_REV2_MINUS struct.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -5975,35 +11078,49 @@ Acquire() operation on _GL.
 
 The local object cache is now optional, and is disabled by default. Both 
 AcpiExec and the iASL compiler enable the cache because they run in user 
-mode and this enhances their performance. #define ACPI_ENABLE_OBJECT_CACHE 
+mode and this enhances their performance. #define 
+ACPI_ENABLE_OBJECT_CACHE 
 to enable the local cache.
 
-Fixed an issue in the internal function AcpiUtEvaluateObject concerning the 
-optional "implicit return" support where an error was returned if no return 
-object was expected, but one was implicitly returned. AE_OK is now returned 
+Fixed an issue in the internal function AcpiUtEvaluateObject concerning 
+the 
+optional "implicit return" support where an error was returned if no 
+return 
+object was expected, but one was implicitly returned. AE_OK is now 
+returned 
 in this case and the implicitly returned object is deleted. 
-AcpiUtEvaluateObject is only occasionally used, and only to execute reserved 
+AcpiUtEvaluateObject is only occasionally used, and only to execute 
+reserved 
 methods such as _STA and _INI where the return type is known up front.
 
-Fixed a few issues with the internal convert-to-integer code. It now returns 
+Fixed a few issues with the internal convert-to-integer code. It now 
+returns 
 an error if an attempt is made to convert a null string, a string of only 
-blanks/tabs, or a zero-length buffer. This affects both implicit conversion 
+blanks/tabs, or a zero-length buffer. This affects both implicit 
+conversion 
 and explicit conversion via the ToInteger() operator.
 
-The internal debug code in AcpiUtAcquireMutex has been commented out. It is 
-not needed for normal operation and should increase the performance of the 
-entire subsystem. The code remains in case it is needed for debug purposes 
+The internal debug code in AcpiUtAcquireMutex has been commented out. It 
+is 
+not needed for normal operation and should increase the performance of 
+the 
+entire subsystem. The code remains in case it is needed for debug 
+purposes 
 again.
 
-The AcpiExec source and makefile are included in the Unix/Linux package for 
+The AcpiExec source and makefile are included in the Unix/Linux package 
+for 
 the first time.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6015,24 +11132,32 @@ the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Switch/Case support: A warning is now issued if the type of the Switch value 
+Switch/Case support: A warning is now issued if the type of the Switch 
+value 
 cannot be determined at compile time. For example, Switch(Arg0) will 
-generate the warning, and the type is assumed to be an integer. As per the 
-ACPI spec, use a construct such as Switch(ToInteger(Arg0)) to eliminate the 
+generate the warning, and the type is assumed to be an integer. As per 
+the 
+ACPI spec, use a construct such as Switch(ToInteger(Arg0)) to eliminate 
+the 
 warning.
 
 Switch/Case support: Implemented support for buffer and string objects as 
 the switch value.  This is an ACPI 3.0 feature, now that LEqual supports 
 buffers and strings.
 
-Switch/Case support: The emitted code for the LEqual() comparisons now uses 
-the switch value as the first operand, not the second. The case value is now 
+Switch/Case support: The emitted code for the LEqual() comparisons now 
+uses 
+the switch value as the first operand, not the second. The case value is 
+now 
 the second operand, and this allows the case value to be implicitly 
 converted to the type of the switch value, not the other way around.
 
-Switch/Case support: Temporary variables are now emitted immediately within 
-the control method, not at the global level. This means that there are now 
-36 temps available per-method, not 36 temps per-module as was the case with 
+Switch/Case support: Temporary variables are now emitted immediately 
+within 
+the control method, not at the global level. This means that there are 
+now 
+36 temps available per-method, not 36 temps per-module as was the case 
+with 
 the earlier implementation (_T_0 through _T_9 and _T_A through _T_Z.)
 
 ----------------------------------------
@@ -6044,51 +11169,66 @@ the core subsystem, iASL compiler, and the utilities.
 1) ACPI CA Core Subsystem:
 
 Fixed an issue with the String-to-Buffer conversion code where the string 
-null terminator was not included in the buffer after conversion, but there 
-is existing ASL that assumes the string null terminator is included. This is 
+null terminator was not included in the buffer after conversion, but 
+there 
+is existing ASL that assumes the string null terminator is included. This 
+is 
 the root of the ACPI_AML_BUFFER_LIMIT regression. This problem was 
 introduced in the previous version when the code was updated to correctly 
-set the converted buffer size as per the ACPI specification. The ACPI spec 
-is ambiguous and will be updated to specify that the null terminator must be 
+set the converted buffer size as per the ACPI specification. The ACPI 
+spec 
+is ambiguous and will be updated to specify that the null terminator must 
+be 
 included in the converted buffer. This also affects the ToBuffer() ASL 
 operator.
 
 Fixed a problem with the Mid() ASL/AML operator where it did not work 
-correctly on Buffer objects. Newly created sub-buffers were not being marked 
+correctly on Buffer objects. Newly created sub-buffers were not being 
+marked 
 as initialized.
 
 
 Fixed a problem in AcpiTbFindTable where incorrect string compares were 
-performed on the OemId and OemTableId table header fields.  These fields are 
+performed on the OemId and OemTableId table header fields.  These fields 
+are 
 not null terminated, so strncmp is now used instead of strcmp.
 
 Implemented a restriction on the Store() ASL/AML operator to align the 
-behavior with the ACPI specification.  Previously, any object could be used 
-as the source operand.  Now, the only objects that may be used are Integers, 
+behavior with the ACPI specification.  Previously, any object could be 
+used 
+as the source operand.  Now, the only objects that may be used are 
+Integers, 
 Buffers, Strings, Packages, Object References, and DDB Handles.  If 
 necessary, the original behavior can be restored by enabling the 
 EnableInterpreterSlack flag.
 
-Enhanced the optional "implicit return" support to allow an implicit return 
+Enhanced the optional "implicit return" support to allow an implicit 
+return 
 value from methods that are invoked externally via the AcpiEvaluateObject 
 interface.  This enables implicit returns from the _STA and _INI methods, 
 for example.
 
-Changed the Revision() ASL/AML operator to return the current version of the 
-AML interpreter, in the YYYYMMDD format. Previously, it incorrectly returned 
+Changed the Revision() ASL/AML operator to return the current version of 
+the 
+AML interpreter, in the YYYYMMDD format. Previously, it incorrectly 
+returned 
 the supported ACPI version (This is the function of the _REV method).
 
-Updated the _REV predefined method to return the currently supported version 
+Updated the _REV predefined method to return the currently supported 
+version 
 of ACPI, now 3.
 
 Implemented batch mode option for the AcpiExec utility (-b).
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6106,23 +11246,29 @@ ACPI CA core subsystem.
 
 1) ACPI CA Core Subsystem:
 
-Fixed a problem in the ToDecimalString operator where the resulting string 
+Fixed a problem in the ToDecimalString operator where the resulting 
+string 
 length was incorrectly calculated. The length is now calculated exactly, 
 eliminating incorrect AE_STRING_LIMIT exceptions.
 
-Fixed a problem in the ToHexString operator to allow a maximum 200 character 
+Fixed a problem in the ToHexString operator to allow a maximum 200 
+character 
 string to be produced.
 
-Fixed a problem in the internal string-to-buffer and buffer-to-buffer copy 
+Fixed a problem in the internal string-to-buffer and buffer-to-buffer 
+copy 
 routine where the length of the resulting buffer was not truncated to the 
 new size (if the target buffer already existed).
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6139,7 +11285,8 @@ Implemented the new ACPI 3.0 resource template macros - DWordSpace,
 ExtendedIO, ExtendedMemory, ExtendedSpace, QWordSpace, and WordSpace. 
 Includes support in the disassembler.
 
-Implemented support for the new (ACPI 3.0) parameter to the Register macro, 
+Implemented support for the new (ACPI 3.0) parameter to the Register 
+macro, 
 AccessSize.
 
 Fixed a problem where the _HE resource name for the Interrupt macro was 
@@ -6152,29 +11299,34 @@ incorrect AML code was generated if the offset within the resource buffer
 was 0 or 1.  The optimizer shortened the AML code to a single byte opcode 
 but did not update the surrounding package lengths.
 
-Changes to the Dma macro:  All channels within the channel list must be in 
+Changes to the Dma macro:  All channels within the channel list must be 
+in 
 the range 0-7.  Maximum 8 channels can be specified. BusMaster operand is 
 optional (default is BusMaster).
 
 Implemented check for maximum 7 data bytes for the VendorShort macro.
 
-The ReadWrite parameter is now optional for the Memory32 and similar macros.
+The ReadWrite parameter is now optional for the Memory32 and similar 
+macros.
 
 ----------------------------------------
 03 December 2004.  Summary of changes for version 20041203:
 
 1) ACPI CA Core Subsystem:
 
-The low-level field insertion/extraction code (exfldio) has been completely 
+The low-level field insertion/extraction code (exfldio) has been 
+completely 
 rewritten to eliminate unnecessary complexity, bugs, and boundary 
 conditions.
 
-Fixed a problem in the ToInteger, ToBuffer, ToHexString, and ToDecimalString 
+Fixed a problem in the ToInteger, ToBuffer, ToHexString, and 
+ToDecimalString 
 operators where the input operand could be inadvertently deleted if no 
 conversion was necessary (e.g., if the input to ToInteger was an Integer 
 object.)
 
-Fixed a problem with the ToDecimalString and ToHexString where an incorrect 
+Fixed a problem with the ToDecimalString and ToHexString where an 
+incorrect 
 exception code was returned if the resulting string would be > 200 chars.  
 AE_STRING_LIMIT is now returned.
 
@@ -6185,11 +11337,14 @@ Fixed a problem in oswinxf (used by AcpiExec and iASL) to allow > 128
 semaphores to be allocated.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6205,7 +11360,8 @@ the compiler options used during generation.
 Fixed typechecking for the ObjectType and SizeOf operators.  Problem was 
 recently introduced in 20041119.
 
-Fixed a problem with the ToUUID macro where the upper nybble of each buffer 
+Fixed a problem with the ToUUID macro where the upper nybble of each 
+buffer 
 byte was inadvertently set to zero.
 
 ----------------------------------------
@@ -6213,31 +11369,42 @@ byte was inadvertently set to zero.
 
 1) ACPI CA Core Subsystem:
 
-Fixed a problem in the internal ConvertToInteger routine where new integers 
-were not truncated to 32 bits for 32-bit ACPI tables. This routine converts 
+Fixed a problem in the internal ConvertToInteger routine where new 
+integers 
+were not truncated to 32 bits for 32-bit ACPI tables. This routine 
+converts 
 buffers and strings to integers.
 
-Implemented support to store a value to an Index() on a String object. This 
+Implemented support to store a value to an Index() on a String object. 
+This 
 is an ACPI 2.0 feature that had not yet been implemented.
 
-Implemented new behavior for storing objects to individual package elements 
-(via the Index() operator). The previous behavior was to invoke the implicit 
+Implemented new behavior for storing objects to individual package 
+elements 
+(via the Index() operator). The previous behavior was to invoke the 
+implicit 
 conversion rules if an object was already present at the index.  The new 
-behavior is to simply delete any existing object and directly store the new 
-object. Although the ACPI specification seems unclear on this subject, other 
+behavior is to simply delete any existing object and directly store the 
+new 
+object. Although the ACPI specification seems unclear on this subject, 
+other 
 ACPI implementations behave in this manner.  (This is the root of the 
 AE_BAD_HEX_CONSTANT issue.)
 
-Modified the RSDP memory scan mechanism to support the extended checksum for 
+Modified the RSDP memory scan mechanism to support the extended checksum 
+for 
 ACPI 2.0 (and above) RSDPs. Note that the search continues until a valid 
 RSDP signature is found with a valid checksum.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6257,30 +11424,38 @@ Fixed a missing semicolon in the aslcompiler.y file.
 
 1) ACPI CA Core Subsystem:
 
-Implemented support for FADT revision 2.  This was an interim table (between 
+Implemented support for FADT revision 2.  This was an interim table 
+(between 
 ACPI 1.0 and ACPI 2.0) that adds support for the FADT reset register.
 
 Implemented optional support to allow uninitialized LocalX and ArgX 
-variables in a control method.  The variables are initialized to an Integer 
+variables in a control method.  The variables are initialized to an 
+Integer 
 object with a value of zero.  This support is enabled by setting the 
 AcpiGbl_EnableInterpreterSlack flag to TRUE.
 
-Implemented support for Integer objects for the SizeOf operator.  Either 4 
-or 8 is returned, depending on the current integer size (32-bit or 64-bit, 
+Implemented support for Integer objects for the SizeOf operator.  Either 
+4 
+or 8 is returned, depending on the current integer size (32-bit or 64-
+bit, 
 depending on the parent table revision).
 
-Fixed a problem in the implementation of the SizeOf and ObjectType operators 
+Fixed a problem in the implementation of the SizeOf and ObjectType 
+operators 
 where the operand was resolved to a value too early, causing incorrect 
 return values for some objects.
 
 Fixed some possible memory leaks during exceptional conditions.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6322,8 +11497,10 @@ the number of bug fixes in the next few months.
 
 1) ACPI CA Core Subsystem:
 
-Fixed two alignment issues on 64-bit platforms - within debug statements in 
-AcpiEvGpeDetect and AcpiEvCreateGpeBlock. Removed references to the Address 
+Fixed two alignment issues on 64-bit platforms - within debug statements 
+in 
+AcpiEvGpeDetect and AcpiEvCreateGpeBlock. Removed references to the 
+Address 
 field within the non-aligned ACPI generic address structure.
 
 Fixed a problem in the Increment and Decrement operators where incorrect 
@@ -6331,14 +11508,18 @@ operand resolution could result in the inadvertent modification of the
 original integer when the integer is passed into another method as an 
 argument and the arg is then incremented/decremented.
 
-Fixed a problem in the FromBCD operator where the upper 32-bits of a 64-bit 
+Fixed a problem in the FromBCD operator where the upper 32-bits of a 64-
+bit 
 BCD number were truncated during conversion.
 
-Fixed a problem in the ToDecimal operator where the length of the resulting 
-string could be set incorrectly too long if the input operand was a Buffer 
+Fixed a problem in the ToDecimal operator where the length of the 
+resulting 
+string could be set incorrectly too long if the input operand was a 
+Buffer 
 object.
 
-Fixed a problem in the Logical operators (LLess, etc.) where a NULL byte (0) 
+Fixed a problem in the Logical operators (LLess, etc.) where a NULL byte 
+(0) 
 within a buffer would prematurely terminate a compare between buffer 
 objects.
 
@@ -6346,11 +11527,14 @@ Added a check for string overflow (>200 characters as per the ACPI
 specification) during the Concatenate operator with two string operands.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6367,11 +11551,14 @@ the compiler options used during generation.
 Allow the use of the ObjectType operator on uninitialized Locals and Args 
 (returns 0 as per the ACPI specification).
 
-Fixed a problem where the compiler would fault if there was a syntax error 
+Fixed a problem where the compiler would fault if there was a syntax 
+error 
 in the FieldName of all of the various CreateXXXField operators.
 
-Disallow the use of lower case letters within the EISAID macro, as per the 
-ACPI specification.  All EISAID strings must be of the form "UUUNNNN" Where 
+Disallow the use of lower case letters within the EISAID macro, as per 
+the 
+ACPI specification.  All EISAID strings must be of the form "UUUNNNN" 
+Where 
 U is an uppercase letter and N is a hex digit.
 
 
@@ -6384,41 +11571,52 @@ Implemented support for the ACPI 3.0 Timer operator. This ASL function
 implements a 64-bit timer with 100 nanosecond granularity.
 
 Defined a new OSL interface, AcpiOsGetTimer. This interface is used to 
-implement the ACPI 3.0 Timer operator.  This allows the host OS to implement 
-the timer with the best clock available. Also, it keeps the core subsystem 
+implement the ACPI 3.0 Timer operator.  This allows the host OS to 
+implement 
+the timer with the best clock available. Also, it keeps the core 
+subsystem 
 out of the clock handling business, since the host OS (usually) performs 
 this function.
 
 Fixed an alignment issue on 64-bit platforms. The HwLowLevelRead(Write) 
 functions use a 64-bit address which is part of the packed ACPI Generic 
-Address Structure. Since the structure is non-aligned, the alignment macros 
+Address Structure. Since the structure is non-aligned, the alignment 
+macros 
 are now used to extract the address to a local variable before use.
 
-Fixed a problem where the ToInteger operator assumed all input strings were 
-hexadecimal. The operator now handles both decimal strings and hex strings 
+Fixed a problem where the ToInteger operator assumed all input strings 
+were 
+hexadecimal. The operator now handles both decimal strings and hex 
+strings 
 (prefixed with "0x").
 
 Fixed a problem where the string length in the string object created as a 
 result of the internal ConvertToString procedure could be incorrect. This 
-potentially affected all implicit conversions and also the ToDecimalString 
+potentially affected all implicit conversions and also the 
+ToDecimalString 
 and ToHexString operators.
 
 Fixed two problems in the ToString operator. If the length parameter was 
 zero, an incorrect string object was created and the value of the input 
 length parameter was inadvertently changed from zero to Ones.
 
-Fixed a problem where the optional ResourceSource string in the ExtendedIRQ 
+Fixed a problem where the optional ResourceSource string in the 
+ExtendedIRQ 
 resource macro was ignored.
 
-Simplified the interfaces to the internal division functions, reducing code 
+Simplified the interfaces to the internal division functions, reducing 
+code 
 size and complexity.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6433,11 +11631,13 @@ the compiler options used during generation.
 
 Implemented support for the ACPI 3.0 Timer operator.
 
-Fixed a problem where the Default() operator was inadvertently ignored in a 
+Fixed a problem where the Default() operator was inadvertently ignored in 
+a 
 Switch/Case block.  This was a problem in the translation of the Switch 
 statement to If...Else pairs.
 
-Added support to allow a standalone Return operator, with no parentheses (or 
+Added support to allow a standalone Return operator, with no parentheses 
+(or 
 operands).
 
 Fixed a problem with code generation for the ElseIf operator where the 
@@ -6449,12 +11649,16 @@ loss of some code.
 
 1) ACPI CA Core Subsystem:
 
-Fixed a problem with the implementation of the LNot() operator where "Ones" 
-was not returned for the TRUE case. Changed the code to return Ones instead 
-of (!Arg) which was usually 1. This change affects iASL constant folding for 
+Fixed a problem with the implementation of the LNot() operator where 
+"Ones" 
+was not returned for the TRUE case. Changed the code to return Ones 
+instead 
+of (!Arg) which was usually 1. This change affects iASL constant folding 
+for 
 this operator also.
 
-Fixed a problem in AcpiUtInitializeBuffer where an existing buffer was not 
+Fixed a problem in AcpiUtInitializeBuffer where an existing buffer was 
+not 
 initialized properly -- Now zero the entire buffer in this case where the 
 buffer already exists.
 
@@ -6463,19 +11667,24 @@ Milliseconds) to simply (ACPI_INTEGER Milliseconds). This simplifies all
 related code considerably. This will require changes/updates to all OS 
 interface layers (OSLs.)
 
-Implemented a new external interface, AcpiInstallExceptionHandler, to allow 
-a system exception handler to be installed. This handler is invoked upon any 
+Implemented a new external interface, AcpiInstallExceptionHandler, to 
+allow 
+a system exception handler to be installed. This handler is invoked upon 
+any 
 run-time exception that occurs during control method execution.
 
 Added support for the DSDT in AcpiTbFindTable. This allows the 
 DataTableRegion() operator to access the local copy of the DSDT.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below. These are the code and data sizes for the acpica.lib produced 
+shown below. These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code. The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size. Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size. 
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6489,16 +11698,20 @@ the compiler options used during generation.
 2) iASL Compiler/Disassembler:
 
 Fixed a problem with constant folding and the LNot operator. LNot was 
-returning 1 in the TRUE case, not Ones as per the ACPI specification. This 
+returning 1 in the TRUE case, not Ones as per the ACPI specification. 
+This 
 could result in the generation of an incorrect folded/reduced constant.
 
 End-Of-File is now allowed within a "//"-style comment.  A parse error no 
-longer occurs if such a comment is at the very end of the input ASL source 
+longer occurs if such a comment is at the very end of the input ASL 
+source 
 file.
 
 Implemented the "-r" option to override the Revision in the table header. 
-The initial use of this option will be to simplify the evaluation of the AML 
-interpreter by allowing a single ASL source module to be compiled for either 
+The initial use of this option will be to simplify the evaluation of the 
+AML 
+interpreter by allowing a single ASL source module to be compiled for 
+either 
 32-bit or 64-bit integers.
 
 
@@ -6508,41 +11721,55 @@ interpreter by allowing a single ASL source module to be compiled for either
 1) ACPI CA Core Subsystem:
 
 - Implemented support for implicit object conversion in the non-numeric 
-logical operators (LEqual, LGreater, LGreaterEqual, LLess, LLessEqual, and 
+logical operators (LEqual, LGreater, LGreaterEqual, LLess, LLessEqual, 
+and 
 LNotEqual.)  Any combination of Integers/Strings/Buffers may now be used; 
-the second operand is implicitly converted on the fly to match the type of 
+the second operand is implicitly converted on the fly to match the type 
+of 
 the first operand.  For example:
 
     LEqual (Source1, Source2)
 
-Source1 and Source2 must each evaluate to an integer, a string, or a buffer. 
-The data type of Source1 dictates the required type of Source2. Source2 is 
+Source1 and Source2 must each evaluate to an integer, a string, or a 
+buffer. 
+The data type of Source1 dictates the required type of Source2. Source2 
+is 
 implicitly converted if necessary to match the type of Source1.
 
-- Updated and corrected the behavior of the string conversion support.  The 
+- Updated and corrected the behavior of the string conversion support.  
+The 
 rules concerning conversion of buffers to strings (according to the ACPI 
 specification) are as follows:
 
 ToDecimalString - explicit byte-wise conversion of buffer to string of 
-decimal values (0-255) separated by commas. ToHexString - explicit byte-wise 
+decimal values (0-255) separated by commas. ToHexString - explicit byte-
+wise 
 conversion of buffer to string of hex values (0-FF) separated by commas. 
-ToString - explicit byte-wise conversion of buffer to string.  Byte-by-byte 
-copy with no transform except NULL terminated. Any other implicit buffer-to-
-string conversion - byte-wise conversion of buffer to string of hex values 
+ToString - explicit byte-wise conversion of buffer to string.  Byte-by-
+byte 
+copy with no transform except NULL terminated. Any other implicit buffer-
+to-
+string conversion - byte-wise conversion of buffer to string of hex 
+values 
 (0-FF) separated by spaces.
 
 - Fixed typo in definition of AcpiGbl_EnableInterpreterSlack.
 
-- Fixed a problem in AcpiNsGetPathnameLength where the returned length was 
+- Fixed a problem in AcpiNsGetPathnameLength where the returned length 
+was 
 one byte too short in the case of a node in the root scope.  This could 
 cause a fault during debug output.
 
-- Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+- Code and Data Size: Current and previous core subsystem library sizes 
+are 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6564,25 +11791,33 @@ the compiler options used during generation.
 1) ACPI CA Core Subsystem:
 
 Designed and implemented support within the AML interpreter for the so-
-called "implicit return".  This support returns the result of the last ASL 
+called "implicit return".  This support returns the result of the last 
+ASL 
 operation within a control method, in the absence of an explicit Return() 
 operator.  A few machines depend on this behavior, even though it is not 
-explicitly supported by the ASL language.  It is optional support that can 
+explicitly supported by the ASL language.  It is optional support that 
+can 
 be enabled at runtime via the AcpiGbl_EnableInterpreterSlack flag.
 
-Removed support for the PCI_Config address space from the internal low level 
+Removed support for the PCI_Config address space from the internal low 
+level 
 hardware interfaces (AcpiHwLowLevelRead and AcpiHwLowLevelWrite).  This 
-support was not used internally, and would not work correctly anyway because 
+support was not used internally, and would not work correctly anyway 
+because 
 the PCI bus number and segment number were not supported.  There are 
-separate interfaces for PCI configuration space access because of the unique 
+separate interfaces for PCI configuration space access because of the 
+unique 
 interface.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6605,30 +11840,39 @@ generation.  This problem was introduced in the 20040715 release.
 
 1) ACPI CA Core Subsystem:
 
-Restructured the internal HW GPE interfaces to pass/track the current state 
+Restructured the internal HW GPE interfaces to pass/track the current 
+state 
 of interrupts (enabled/disabled) in order to avoid possible deadlock and 
 increase flexibility of the interfaces.
 
-Implemented a "lexicographical compare" for String and Buffer objects within 
-the logical operators -- LGreater, LLess, LGreaterEqual, and LLessEqual -- 
-as per further clarification to the ACPI specification.  Behavior is similar 
+Implemented a "lexicographical compare" for String and Buffer objects 
+within 
+the logical operators -- LGreater, LLess, LGreaterEqual, and LLessEqual -
+- 
+as per further clarification to the ACPI specification.  Behavior is 
+similar 
 to C library "strcmp".
 
 Completed a major reduction in CPU stack use for the AcpiGetFirmwareTable 
 external function.  In the 32-bit non-debug case, the stack use has been 
 reduced from 168 bytes to 32 bytes.
 
-Deployed a new run-time configuration flag, AcpiGbl_EnableInterpreterSlack, 
+Deployed a new run-time configuration flag, 
+AcpiGbl_EnableInterpreterSlack, 
 whose purpose is to allow the AML interpreter to forgive certain bad AML 
 constructs.  Default setting is FALSE.
 
-Implemented the first use of AcpiGbl_EnableInterpreterSlack in the Field IO 
-support code.  If enabled, it allows field access to go beyond the end of a 
-region definition if the field is within the region length rounded up to the 
+Implemented the first use of AcpiGbl_EnableInterpreterSlack in the Field 
+IO 
+support code.  If enabled, it allows field access to go beyond the end of 
+a 
+region definition if the field is within the region length rounded up to 
+the 
 next access width boundary (a common coding error.)
 
 Renamed OSD_HANDLER to ACPI_OSD_HANDLER, and OSD_EXECUTION_CALLBACK to 
-ACPI_OSD_EXEC_CALLBACK for consistency with other ACPI symbols.  Also, these 
+ACPI_OSD_EXEC_CALLBACK for consistency with other ACPI symbols.  Also, 
+these 
 symbols are lowercased by the latest version of the AcpiSrc tool.
 
 The prototypes for the PCI interfaces in acpiosxf.h have been updated to 
@@ -6636,11 +11880,14 @@ rename "Register" to simply "Reg" to prevent certain compilers from
 complaining.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6655,11 +11902,13 @@ the compiler options used during generation.
 
 Implemented full support for Package objects within the Case() operator.  
 Note: The Break() operator is currently not supported within Case blocks 
-(TermLists) as there is some question about backward compatibility with ACPI 
+(TermLists) as there is some question about backward compatibility with 
+ACPI 
 1.0 interpreters.
 
 
-Fixed a problem where complex terms were not supported properly within the 
+Fixed a problem where complex terms were not supported properly within 
+the 
 Switch() operator.
 
 Eliminated extraneous warning for compiler-emitted reserved names of the 
@@ -6674,22 +11923,27 @@ within the DefinitionBlock operator.
 
 1) ACPI CA Core Subsystem:
 
-Implemented support for Buffer and String objects (as per ACPI 2.0) for the 
+Implemented support for Buffer and String objects (as per ACPI 2.0) for 
+the 
 following ASL operators:  LEqual, LGreater, LLess, LGreaterEqual, and 
 LLessEqual.
 
 All directory names in the entire source package are lower case, as they 
 were in earlier releases.
 
-Implemented "Disassemble" command in the AML debugger that will disassemble 
+Implemented "Disassemble" command in the AML debugger that will 
+disassemble 
 a single control method.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6703,7 +11957,8 @@ the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Implemented support for Buffer and String objects (as per ACPI 2.0) for the 
+Implemented support for Buffer and String objects (as per ACPI 2.0) for 
+the 
 following ASL operators:  LEqual, LGreater, LLess, LGreaterEqual, and 
 LLessEqual.
 
@@ -6713,14 +11968,17 @@ were in earlier releases.
 Fixed a fault when using the -g or -d<nofilename> options if the FADT was 
 not found.
 
-Fixed an issue with the Windows version of the compiler where later versions 
+Fixed an issue with the Windows version of the compiler where later 
+versions 
 of Windows place the FADT in the registry under the name "FADT" and not 
 "FACP" as earlier versions did.  This applies when using the -g or -
 d<nofilename> options.  The compiler now looks for both strings as 
 necessary.
 
-Fixed a problem with compiler namepath optimization where a namepath within 
-the Scope() operator could not be optimized if the namepath was a subpath of 
+Fixed a problem with compiler namepath optimization where a namepath 
+within 
+the Scope() operator could not be optimized if the namepath was a subpath 
+of 
 the current scope path.
 
 ----------------------------------------
@@ -6728,11 +11986,15 @@ the current scope path.
 
 1) ACPI CA Core Subsystem:
 
-Completed a new design and implementation for EBDA (Extended BIOS Data Area) 
-support in the RSDP scan code.  The original code improperly scanned for the 
-EBDA by simply scanning from memory location 0 to 0x400.  The correct method 
+Completed a new design and implementation for EBDA (Extended BIOS Data 
+Area) 
+support in the RSDP scan code.  The original code improperly scanned for 
+the 
+EBDA by simply scanning from memory location 0 to 0x400.  The correct 
+method 
 is to first obtain the EBDA pointer from within the BIOS data area, then 
-scan 1K of memory starting at the EBDA pointer.  There appear to be few if 
+scan 1K of memory starting at the EBDA pointer.  There appear to be few 
+if 
 any machines that place the RSDP in the EBDA, however.
 
 Integrated a fix for a possible fault during evaluation of BufferField 
@@ -6747,11 +12009,14 @@ Rolled in a couple of changes to the FreeBSD-specific header.
 
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6764,7 +12029,8 @@ the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-Fixed a generation warning produced by some overly-verbose compilers for a 
+Fixed a generation warning produced by some overly-verbose compilers for 
+a 
 64-bit constant.
 
 ----------------------------------------
@@ -6778,18 +12044,22 @@ during and after GPE method execution.  Result of 04/27 changes.
 Removed extra "clear all GPEs" when sleeping/waking.
 
 Removed AcpiHwEnableGpe and AcpiHwDisableGpe, replaced by the single 
-AcpiHwWriteGpeEnableReg. Changed a couple of calls to the functions above to 
+AcpiHwWriteGpeEnableReg. Changed a couple of calls to the functions above 
+to 
 the new AcpiEv* calls as appropriate.
 
-ACPI_OS_NAME was removed from the OS-specific headers.  The default name is 
-now "Microsoft Windows NT" for maximum compatibility.  However this can be 
+ACPI_OS_NAME was removed from the OS-specific headers.  The default name 
+is 
+now "Microsoft Windows NT" for maximum compatibility.  However this can 
+be 
 changed by modifying the acconfig.h file.
 
 Allow a single invocation of AcpiInstallNotifyHandler for a handler that 
 traps both types of notifies (System, Device).  Use ACPI_ALL_NOTIFY flag. 
 
 Run _INI methods on ThermalZone objects.  This is against the ACPI 
-specification, but there is apparently ASL code in the field that has these 
+specification, but there is apparently ASL code in the field that has 
+these 
 _INI methods, and apparently "other" AML interpreters execute them.
 
 Performed a full 16/32/64 bit lint that resulted in some small changes.
@@ -6797,11 +12067,14 @@ Performed a full 16/32/64 bit lint that resulted in some small changes.
 Added a sleep simulation command to the AML debugger to test sleep code. 
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6817,26 +12090,36 @@ the compiler options used during generation.
 1) ACPI CA Core Subsystem:
 
 Completed a major overhaul of the GPE handling within ACPI CA.  There are 
-now three types of GPEs:  wake-only, runtime-only, and combination wake/run.  
+now three types of GPEs:  wake-only, runtime-only, and combination 
+wake/run.  
 The only GPEs allowed to be combination wake/run are for button-style 
-devices such as a control-method power button, control-method sleep button, 
-or a notebook lid switch.  GPEs that have an _Lxx or _Exx method and are not 
+devices such as a control-method power button, control-method sleep 
+button, 
+or a notebook lid switch.  GPEs that have an _Lxx or _Exx method and are 
+not 
 referenced by any _PRW methods are marked for "runtime" and hardware 
-enabled.  Any GPE that is referenced by a _PRW method is marked for "wake" 
+enabled.  Any GPE that is referenced by a _PRW method is marked for 
+"wake" 
 (and disabled at runtime).  However, at sleep time, only those GPEs that 
-have been specifically enabled for wake via the AcpiEnableGpe interface will 
+have been specifically enabled for wake via the AcpiEnableGpe interface 
+will 
 actually be hardware enabled.
 
-A new external interface has been added, AcpiSetGpeType(), that is meant to 
-be used by device drivers to force a GPE to a particular type.  It will be 
+A new external interface has been added, AcpiSetGpeType(), that is meant 
+to 
+be used by device drivers to force a GPE to a particular type.  It will 
+be 
 especially useful for the drivers for the button devices mentioned above.
 
 Completed restructuring of the ACPI CA initialization sequence so that 
-default operation region handlers are installed before GPEs are initialized 
-and the _PRW methods are executed.  This will prevent errors when the _PRW 
+default operation region handlers are installed before GPEs are 
+initialized 
+and the _PRW methods are executed.  This will prevent errors when the 
+_PRW 
 methods attempt to access system memory or I/O space.
 
-GPE enable/disable no longer reads the GPE enable register.  We now keep the 
+GPE enable/disable no longer reads the GPE enable register.  We now keep 
+the 
 enable info for runtime and wake separate and in the GPE_EVENT_INFO.  We 
 thus no longer depend on the hardware to maintain these bits.
 
@@ -6846,12 +12129,16 @@ for state S5.
 Improved the AML debugger output for displaying the GPE blocks and their 
 current status.
 
-Added new strings for the _OSI method, of the form "Windows 2001 SPx" where 
+Added new strings for the _OSI method, of the form "Windows 2001 SPx" 
+where 
 x = 0,1,2,3,4.
 
-Fixed a problem where the physical address was incorrectly calculated when 
-the Load() operator was used to directly load from an Operation Region (vs. 
-loading from a Field object.)  Also added check for minimum table length for 
+Fixed a problem where the physical address was incorrectly calculated 
+when 
+the Load() operator was used to directly load from an Operation Region 
+(vs. 
+loading from a Field object.)  Also added check for minimum table length 
+for 
 this case.
 
 Fix for multiple mutex acquisition.  Restore original thread SyncLevel on 
@@ -6864,21 +12151,27 @@ Shrunk the ACPI_GPE_EVENT_INFO structure by 40%.  There is one such
 structure for each GPE in the system, so the size of this structure is 
 important.
 
-CPU stack requirement reduction:  Cleaned up the method execution and object 
+CPU stack requirement reduction:  Cleaned up the method execution and 
+object 
 evaluation paths so that now a parameter structure is passed, instead of 
 copying the various method parameters over and over again.
 
 In evregion.c:  Correctly exit and reenter the interpreter region if and 
-only if dispatching an operation region request to a user-installed handler.  
+only if dispatching an operation region request to a user-installed 
+handler.  
 Do not exit/reenter when dispatching to a default handler (e.g., default 
 system memory or I/O handlers)
 
 
-Notes for updating drivers for the new GPE support.  The following changes 
-must be made to ACPI-related device drivers that are attached to one or more 
-GPEs: (This information will be added to the ACPI CA Programmer Reference.)
+Notes for updating drivers for the new GPE support.  The following 
+changes 
+must be made to ACPI-related device drivers that are attached to one or 
+more 
+GPEs: (This information will be added to the ACPI CA Programmer 
+Reference.)
 
-1) AcpiInstallGpeHandler no longer automatically enables the GPE, you must 
+1) AcpiInstallGpeHandler no longer automatically enables the GPE, you 
+must 
 explicitly call AcpiEnableGpe.
 2) There is a new interface called AcpiSetGpeType. This should be called 
 before enabling the GPE.  Also, this interface will automatically disable 
@@ -6899,18 +12192,24 @@ If _PRW exists: /* This is a control-method button */
     AcpiSetGpeType (GpeDevice, GpeNum, ACPI_GPE_TYPE_WAKE_RUN);
     AcpiEnableGpe (GpeDevice, GpeNum, ACPI_NOT_ISR);
 
-For all other devices that have _PRWs, we automatically set the GPE type to 
-ACPI_GPE_TYPE_WAKE, but the GPE is NOT automatically (wake) enabled.  This 
-must be done on a selective basis, usually requiring some kind of user app 
+For all other devices that have _PRWs, we automatically set the GPE type 
+to 
+ACPI_GPE_TYPE_WAKE, but the GPE is NOT automatically (wake) enabled.  
+This 
+must be done on a selective basis, usually requiring some kind of user 
+app 
 to allow the user to pick the wake devices.
 
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6930,7 +12229,8 @@ the compiler options used during generation.
 
 Fixed an interpreter problem where an indirect store through an ArgX 
 parameter was incorrectly applying the "implicit conversion rules" during 
-the store.  From the ACPI specification: "If the target is a method local or 
+the store.  From the ACPI specification: "If the target is a method local 
+or 
 argument (LocalX or ArgX), no conversion is performed and the result is 
 stored directly to the target".  The new behavior is to disable implicit 
 conversion during ALL stores to an ArgX.
@@ -6939,16 +12239,20 @@ Changed the behavior of the _PRW method scan to ignore any and all errors
 returned by a given _PRW.  This prevents the scan from aborting from the 
 failure of any single _PRW.
 
-Moved the runtime configuration parameters from the global init procedure to 
+Moved the runtime configuration parameters from the global init procedure 
+to 
 static variables in acglobal.h.  This will allow the host to override the 
 default values easily.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -6961,16 +12265,20 @@ the compiler options used during generation.
 
 2) iASL Compiler/Disassembler:
 
-iASL now fully disassembles SSDTs.  However, External() statements are not 
+iASL now fully disassembles SSDTs.  However, External() statements are 
+not 
 generated automatically for unresolved symbols at this time.  This is a 
 planned feature for future implementation.
 
-Fixed a scoping problem in the disassembler that occurs when the type of the 
+Fixed a scoping problem in the disassembler that occurs when the type of 
+the 
 target of a Scope() operator is overridden.  This problem caused an 
 incorrectly nested internal namespace to be constructed.
 
-Any warnings or errors that are emitted during disassembly are now commented 
-out automatically so that the resulting file can be recompiled without any 
+Any warnings or errors that are emitted during disassembly are now 
+commented 
+out automatically so that the resulting file can be recompiled without 
+any 
 hand editing.
 
 ----------------------------------------
@@ -6981,8 +12289,10 @@ hand editing.
 Implemented support for "wake" GPEs via interaction between GPEs and the 
 _PRW methods.  Every GPE that is pointed to by one or more _PRWs is 
 identified as a WAKE GPE and by default will no longer be enabled at 
-runtime.  Previously, we were blindly enabling all GPEs with a corresponding 
-_Lxx or _Exx method - but most of these turn out to be WAKE GPEs anyway.  We 
+runtime.  Previously, we were blindly enabling all GPEs with a 
+corresponding 
+_Lxx or _Exx method - but most of these turn out to be WAKE GPEs anyway.  
+We 
 believe this has been the cause of thousands of "spurious" GPEs on some 
 systems.
 
@@ -6994,14 +12304,17 @@ properly.  The proper scope within the namespace was not initialized
 (transferred to the target of the aliased method) before executing the 
 target method.
 
-Fixed a potential race condition on internal object deletion on the return 
+Fixed a potential race condition on internal object deletion on the 
+return 
 object in AcpiEvaluateObject. 
 
 Integrated a fix for resource descriptors where both _MEM and _MTP were 
 being extracted instead of just _MEM.  (i.e. bitmask was incorrectly too 
 wide, 0x0F instead of 0x03.)
 
-Added a special case for ACPI_ROOT_OBJECT in AcpiUtGetNodeName, preventing a 
+Added a special case for ACPI_ROOT_OBJECT in AcpiUtGetNodeName, 
+preventing 
+a 
 fault in some cases.
 
 Updated Notify() values for debug statements in evmisc.c
@@ -7009,11 +12322,14 @@ Updated Notify() values for debug statements in evmisc.c
 Return proper status from AcpiUtMutexInitialize, not just simply AE_OK.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -7034,21 +12350,27 @@ method execution did not abort cleanly.  For example, objects created and
 installed in the namespace were not deleted.  This caused all subsequent 
 invocations of the method to return the AE_ALREADY_EXISTS exception.
 
-Implemented a mechanism to force a control method to "Serialized" execution 
+Implemented a mechanism to force a control method to "Serialized" 
+execution 
 if the method attempts to create namespace objects. (The root of the 
 AE_ALREADY_EXISTS problem.)
 
 Implemented support for the predefined _OSI "internal" control method.  
-Initial supported strings are "Linux", "Windows 2000", "Windows 2001", and 
-"Windows 2001.1", and can be easily upgraded for new strings as necessary.  
+Initial supported strings are "Linux", "Windows 2000", "Windows 2001", 
+and 
+"Windows 2001.1", and can be easily upgraded for new strings as 
+necessary.  
 This feature will allow "other" operating systems to execute the fully 
 tested, "Windows" code path through the ASL code
 
 Global Lock Support:  Now allows multiple acquires and releases with any 
-internal thread.  Removed concept of "owning thread" for this special mutex.
+internal thread.  Removed concept of "owning thread" for this special 
+mutex.
 
-Fixed two functions that were inappropriately declaring large objects on the 
-CPU stack:  PsParseLoop, NsEvaluateRelative.  Reduces the stack usage during 
+Fixed two functions that were inappropriately declaring large objects on 
+the 
+CPU stack:  PsParseLoop, NsEvaluateRelative.  Reduces the stack usage 
+during 
 method execution considerably.
 
 Fixed a problem in the ACPI 2.0 FACS descriptor (actbl2.h) where the 
@@ -7057,16 +12379,21 @@ S4Bios_f field was incorrectly defined as UINT32 instead of UINT32_BIT.
 Fixed a problem where AcpiEvGpeDetect would fault if there were no GPEs 
 defined on the machine.
 
-Implemented two runtime options:  One to force all control method execution 
-to "Serialized" to mimic Windows behavior, another to disable _OSI support 
+Implemented two runtime options:  One to force all control method 
+execution 
+to "Serialized" to mimic Windows behavior, another to disable _OSI 
+support 
 if it causes problems on a given machine.
 
 Code and Data Size: Current and previous core subsystem library sizes are 
-shown below.  These are the code and data sizes for the acpica.lib produced 
+shown below.  These are the code and data sizes for the acpica.lib 
+produced 
 by the Microsoft Visual C++ 6.0 compiler, and these values do not include 
 any ACPI driver or OSPM code.  The debug version of the code includes the 
-debug output trace mechanism and has a much larger code and data size.  Note 
-that these values will vary depending on the efficiency of the compiler and 
+debug output trace mechanism and has a much larger code and data size.  
+Note 
+that these values will vary depending on the efficiency of the compiler 
+and 
 the compiler options used during generation.
 
   Previous Release:
@@ -7101,7 +12428,8 @@ structures to the beginning of the file.
 
 After wake, clear GPE status register(s) before enabling GPEs.
 
-After wake, clear/enable power button.  (Perhaps we should clear/enable all 
+After wake, clear/enable power button.  (Perhaps we should clear/enable 
+all 
 fixed events upon wake.)
 
 Fixed a couple of possible memory leaks in the Namespace manager.
@@ -7121,15 +12449,18 @@ Fixed a problem where a store of an object into an indexed package could
 fail if the store occurs within a different method than the method that 
 created the package.
 
-Fixed a problem where the ToDecimal operator could return incorrect results.
+Fixed a problem where the ToDecimal operator could return incorrect 
+results.
 
-Fixed a problem where the CopyObject operator could fail on some of the more 
+Fixed a problem where the CopyObject operator could fail on some of the 
+more 
 obscure objects (e.g., Reference objects.)
 
 Improved the output of the Debug object to display buffer, package, and 
 index objects.
 
-Fixed a problem where constructs of the form "RefOf (ArgX)" did not return 
+Fixed a problem where constructs of the form "RefOf (ArgX)" did not 
+return 
 the expected result.
 
 Added permanent ACPI_REPORT_ERROR macros for all instances of the 
@@ -7146,7 +12477,8 @@ functional changes, however.
 
 1) ACPI CA Core Subsystem:
 
-Improved error messages when there is a problem finding one or more of the 
+Improved error messages when there is a problem finding one or more of 
+the 
 required base ACPI tables
 
 Reintroduced the definition of APIC_HEADER in actbl.h
@@ -7157,7 +12489,8 @@ Removed extraneous reference to NewObj in dsmthdat.c
 
 2) iASL compiler
 
-Fixed a problem introduced in December that disabled the correct disassembly 
+Fixed a problem introduced in December that disabled the correct 
+disassembly 
 of Resource Templates
 
 
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbcmds.c b/usr/src/uts/intel/io/acpica/debugger/dbcmds.c
deleted file mode 100644
index 459cd916ee..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbcmds.c
+++ /dev/null
@@ -1,1079 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbcmds - Miscellaneous debug commands and output routines
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acevents.h"
-#include "acdebug.h"
-#include "acnamesp.h"
-#include "acresrc.h"
-#include "actables.h"
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbcmds")
-
-
-/* Local prototypes */
-
-static void
-AcpiDmCompareAmlResources (
-    UINT8                   *Aml1Buffer,
-    ACPI_RSDESC_SIZE        Aml1BufferLength,
-    UINT8                   *Aml2Buffer,
-    ACPI_RSDESC_SIZE        Aml2BufferLength);
-
-static ACPI_STATUS
-AcpiDmTestResourceConversion (
-    ACPI_NAMESPACE_NODE     *Node,
-    char                    *Name);
-
-static ACPI_STATUS
-AcpiDbResourceCallback (
-    ACPI_RESOURCE           *Resource,
-    void                    *Context);
-
-static ACPI_STATUS
-AcpiDbDeviceResources (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbConvertToNode
- *
- * PARAMETERS:  InString        - String to convert
- *
- * RETURN:      Pointer to a NS node
- *
- * DESCRIPTION: Convert a string to a valid NS pointer.  Handles numeric or
- *              alpha strings.
- *
- ******************************************************************************/
-
-ACPI_NAMESPACE_NODE *
-AcpiDbConvertToNode (
-    char                    *InString)
-{
-    ACPI_NAMESPACE_NODE     *Node;
-
-
-    if ((*InString >= 0x30) && (*InString <= 0x39))
-    {
-        /* Numeric argument, convert */
-
-        Node = ACPI_TO_POINTER (ACPI_STRTOUL (InString, NULL, 16));
-        if (!AcpiOsReadable (Node, sizeof (ACPI_NAMESPACE_NODE)))
-        {
-            AcpiOsPrintf ("Address %p is invalid in this address space\n",
-                Node);
-            return (NULL);
-        }
-
-        /* Make sure pointer is valid NS node */
-
-        if (ACPI_GET_DESCRIPTOR_TYPE (Node) != ACPI_DESC_TYPE_NAMED)
-        {
-            AcpiOsPrintf ("Address %p is not a valid NS node [%s]\n",
-                    Node, AcpiUtGetDescriptorName (Node));
-            return (NULL);
-        }
-    }
-    else
-    {
-        /* Alpha argument */
-        /* The parameter is a name string that must be resolved to a
-         * Named obj
-         */
-        Node = AcpiDbLocalNsLookup (InString);
-        if (!Node)
-        {
-            Node = AcpiGbl_RootNode;
-        }
-    }
-
-    return (Node);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSleep
- *
- * PARAMETERS:  ObjectArg       - Desired sleep state (0-5)
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Simulate a sleep/wake sequence
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbSleep (
-    char                    *ObjectArg)
-{
-    ACPI_STATUS             Status;
-    UINT8                   SleepState;
-
-
-    ACPI_FUNCTION_TRACE (AcpiDbSleep);
-
-
-    SleepState = (UINT8) ACPI_STRTOUL (ObjectArg, NULL, 0);
-
-    AcpiOsPrintf ("**** Prepare to sleep ****\n");
-    Status = AcpiEnterSleepStatePrep (SleepState);
-    if (ACPI_FAILURE (Status))
-    {
-        goto ErrorExit;
-    }
-
-    AcpiOsPrintf ("**** Going to sleep ****\n");
-    Status = AcpiEnterSleepState (SleepState, ACPI_NO_OPTIONAL_METHODS);
-    if (ACPI_FAILURE (Status))
-    {
-        goto ErrorExit;
-    }
-
-    AcpiOsPrintf ("**** Prepare to return from sleep ****\n");
-    Status = AcpiLeaveSleepStatePrep (SleepState, ACPI_NO_OPTIONAL_METHODS);
-    if (ACPI_FAILURE (Status))
-    {
-        goto ErrorExit;
-    }
-
-    AcpiOsPrintf ("**** Returning from sleep ****\n");
-    Status = AcpiLeaveSleepState (SleepState);
-    if (ACPI_FAILURE (Status))
-    {
-        goto ErrorExit;
-    }
-
-    return (Status);
-
-
-ErrorExit:
-
-    ACPI_EXCEPTION ((AE_INFO, Status, "During sleep test"));
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayLocks
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display information about internal mutexes.
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayLocks (
-    void)
-{
-    UINT32                  i;
-
-
-    for (i = 0; i < ACPI_MAX_MUTEX; i++)
-    {
-        AcpiOsPrintf ("%26s : %s\n", AcpiUtGetMutexName (i),
-            AcpiGbl_MutexInfo[i].ThreadId == ACPI_MUTEX_NOT_ACQUIRED
-                ? "Locked" : "Unlocked");
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayTableInfo
- *
- * PARAMETERS:  TableArg        - String with name of table to be displayed
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display information about loaded tables.  Current
- *              implementation displays all loaded tables.
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayTableInfo (
-    char                    *TableArg)
-{
-    UINT32                  i;
-    ACPI_TABLE_DESC         *TableDesc;
-    ACPI_STATUS             Status;
-
-
-    /* Walk the entire root table list */
-
-    for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; i++)
-    {
-        TableDesc = &AcpiGbl_RootTableList.Tables[i];
-        AcpiOsPrintf ("%u ", i);
-
-        /* Make sure that the table is mapped */
-
-        Status = AcpiTbVerifyTable (TableDesc);
-        if (ACPI_FAILURE (Status))
-        {
-            return;
-        }
-
-        /* Dump the table header */
-
-        if (TableDesc->Pointer)
-        {
-            AcpiTbPrintTableHeader (TableDesc->Address, TableDesc->Pointer);
-        }
-        else
-        {
-            /* If the pointer is null, the table has been unloaded */
-
-            ACPI_INFO ((AE_INFO, "%4.4s - Table has been unloaded",
-                TableDesc->Signature.Ascii));
-        }
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbUnloadAcpiTable
- *
- * PARAMETERS:  TableArg        - Name of the table to be unloaded
- *              InstanceArg     - Which instance of the table to unload (if
- *                                there are multiple tables of the same type)
- *
- * RETURN:      Nonde
- *
- * DESCRIPTION: Unload an ACPI table.
- *              Instance is not implemented
- *
- ******************************************************************************/
-
-void
-AcpiDbUnloadAcpiTable (
-    char                    *TableArg,
-    char                    *InstanceArg)
-{
-/* TBD: Need to reimplement for new data structures */
-
-#if 0
-    UINT32                  i;
-    ACPI_STATUS             Status;
-
-
-    /* Search all tables for the target type */
-
-    for (i = 0; i < (ACPI_TABLE_ID_MAX+1); i++)
-    {
-        if (!ACPI_STRNCMP (TableArg, AcpiGbl_TableData[i].Signature,
-                AcpiGbl_TableData[i].SigLength))
-        {
-            /* Found the table, unload it */
-
-            Status = AcpiUnloadTable (i);
-            if (ACPI_SUCCESS (Status))
-            {
-                AcpiOsPrintf ("[%s] unloaded and uninstalled\n", TableArg);
-            }
-            else
-            {
-                AcpiOsPrintf ("%s, while unloading [%s]\n",
-                    AcpiFormatException (Status), TableArg);
-            }
-
-            return;
-        }
-    }
-
-    AcpiOsPrintf ("Unknown table type [%s]\n", TableArg);
-#endif
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSendNotify
- *
- * PARAMETERS:  Name            - Name of ACPI object to send the notify to
- *              Value           - Value of the notify to send.
- *
- * RETURN:      None
- *
- * DESCRIPTION: Send an ACPI notification.  The value specified is sent to the
- *              named object as an ACPI notify.
- *
- ******************************************************************************/
-
-void
-AcpiDbSendNotify (
-    char                    *Name,
-    UINT32                  Value)
-{
-    ACPI_NAMESPACE_NODE     *Node;
-    ACPI_STATUS             Status;
-
-
-    /* Translate name to an Named object */
-
-    Node = AcpiDbConvertToNode (Name);
-    if (!Node)
-    {
-        return;
-    }
-
-    /* Dispatch the notify if legal */
-
-    if (AcpiEvIsNotifyObject (Node))
-    {
-        Status = AcpiEvQueueNotifyRequest (Node, Value);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Could not queue notify\n");
-        }
-    }
-    else
-    {
-        AcpiOsPrintf ("Named object [%4.4s] Type %s, must be Device/Thermal/Processor type\n",
-            AcpiUtGetNodeName (Node), AcpiUtGetTypeName (Node->Type));
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayInterfaces
- *
- * PARAMETERS:  ActionArg           - Null, "install", or "remove"
- *              InterfaceNameArg    - Name for install/remove options
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display or modify the global _OSI interface list
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayInterfaces (
-    char                    *ActionArg,
-    char                    *InterfaceNameArg)
-{
-    ACPI_INTERFACE_INFO     *NextInterface;
-    char                    *SubString;
-    ACPI_STATUS             Status;
-
-
-    /* If no arguments, just display current interface list */
-
-    if (!ActionArg)
-    {
-        (void) AcpiOsAcquireMutex (AcpiGbl_OsiMutex,
-                    ACPI_WAIT_FOREVER);
-
-        NextInterface = AcpiGbl_SupportedInterfaces;
-
-        while (NextInterface)
-        {
-            if (!(NextInterface->Flags & ACPI_OSI_INVALID))
-            {
-                AcpiOsPrintf ("%s\n", NextInterface->Name);
-            }
-            NextInterface = NextInterface->Next;
-        }
-
-        AcpiOsReleaseMutex (AcpiGbl_OsiMutex);
-        return;
-    }
-
-    /* If ActionArg exists, so must InterfaceNameArg */
-
-    if (!InterfaceNameArg)
-    {
-        AcpiOsPrintf ("Missing Interface Name argument\n");
-        return;
-    }
-
-    /* Uppercase the action for match below */
-
-    AcpiUtStrupr (ActionArg);
-
-    /* Install - install an interface */
-
-    SubString = ACPI_STRSTR ("INSTALL", ActionArg);
-    if (SubString)
-    {
-        Status = AcpiInstallInterface (InterfaceNameArg);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("%s, while installing \"%s\"\n",
-                AcpiFormatException (Status), InterfaceNameArg);
-        }
-        return;
-    }
-
-    /* Remove - remove an interface */
-
-    SubString = ACPI_STRSTR ("REMOVE", ActionArg);
-    if (SubString)
-    {
-        Status = AcpiRemoveInterface (InterfaceNameArg);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("%s, while removing \"%s\"\n",
-                AcpiFormatException (Status), InterfaceNameArg);
-        }
-        return;
-    }
-
-    /* Invalid ActionArg */
-
-    AcpiOsPrintf ("Invalid action argument: %s\n", ActionArg);
-    return;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayTemplate
- *
- * PARAMETERS:  BufferArg           - Buffer name or addrss
- *
- * RETURN:      None
- *
- * DESCRIPTION: Dump a buffer that contains a resource template
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayTemplate (
-    char                    *BufferArg)
-{
-    ACPI_NAMESPACE_NODE     *Node;
-    ACPI_STATUS             Status;
-    ACPI_BUFFER             ReturnObj;
-
-
-    /* Translate BufferArg to an Named object */
-
-    Node = AcpiDbConvertToNode (BufferArg);
-    if (!Node || (Node == AcpiGbl_RootNode))
-    {
-        AcpiOsPrintf ("Invalid argument: %s\n", BufferArg);
-        return;
-    }
-
-    /* We must have a buffer object */
-
-    if (Node->Type != ACPI_TYPE_BUFFER)
-    {
-        AcpiOsPrintf ("Not a Buffer object, cannot be a template: %s\n",
-            BufferArg);
-        return;
-    }
-
-    ReturnObj.Length = ACPI_DEBUG_BUFFER_SIZE;
-    ReturnObj.Pointer = AcpiGbl_DbBuffer;
-
-    /* Attempt to convert the raw buffer to a resource list */
-
-    Status = AcpiRsCreateResourceList (Node->Object, &ReturnObj);
-
-    AcpiDbSetOutputDestination (ACPI_DB_REDIRECTABLE_OUTPUT);
-    AcpiDbgLevel |= ACPI_LV_RESOURCES;
-
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could not convert Buffer to a resource list: %s, %s\n",
-            BufferArg, AcpiFormatException (Status));
-        goto DumpBuffer;
-    }
-
-    /* Now we can dump the resource list */
-
-    AcpiRsDumpResourceList (ACPI_CAST_PTR (ACPI_RESOURCE,
-        ReturnObj.Pointer));
-
-DumpBuffer:
-    AcpiOsPrintf ("\nRaw data buffer:\n");
-    AcpiUtDumpBuffer ((UINT8 *) Node->Object->Buffer.Pointer,
-        Node->Object->Buffer.Length,
-        DB_BYTE_DISPLAY, ACPI_UINT32_MAX);
-
-    AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-    return;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDmCompareAmlResources
- *
- * PARAMETERS:  Aml1Buffer          - Contains first resource list
- *              Aml1BufferLength    - Length of first resource list
- *              Aml2Buffer          - Contains second resource list
- *              Aml2BufferLength    - Length of second resource list
- *
- * RETURN:      None
- *
- * DESCRIPTION: Compare two AML resource lists, descriptor by descriptor (in
- *              order to isolate a miscompare to an individual resource)
- *
- ******************************************************************************/
-
-static void
-AcpiDmCompareAmlResources (
-    UINT8                   *Aml1Buffer,
-    ACPI_RSDESC_SIZE        Aml1BufferLength,
-    UINT8                   *Aml2Buffer,
-    ACPI_RSDESC_SIZE        Aml2BufferLength)
-{
-    UINT8                   *Aml1;
-    UINT8                   *Aml2;
-    UINT8                   *Aml1End;
-    UINT8                   *Aml2End;
-    ACPI_RSDESC_SIZE        Aml1Length;
-    ACPI_RSDESC_SIZE        Aml2Length;
-    ACPI_RSDESC_SIZE        Offset = 0;
-    UINT8                   ResourceType;
-    UINT32                  Count = 0;
-    UINT32                  i;
-
-
-    /* Compare overall buffer sizes (may be different due to size rounding) */
-
-    if (Aml1BufferLength != Aml2BufferLength)
-    {
-        AcpiOsPrintf (
-            "**** Buffer length mismatch in converted AML: Original %X, New %X ****\n",
-            Aml1BufferLength, Aml2BufferLength);
-    }
-
-    Aml1 = Aml1Buffer;
-    Aml2 = Aml2Buffer;
-    Aml1End = Aml1Buffer + Aml1BufferLength;
-    Aml2End = Aml2Buffer + Aml2BufferLength;
-
-    /* Walk the descriptor lists, comparing each descriptor */
-
-    while ((Aml1 < Aml1End) && (Aml2 < Aml2End))
-    {
-        /* Get the lengths of each descriptor */
-
-        Aml1Length = AcpiUtGetDescriptorLength (Aml1);
-        Aml2Length = AcpiUtGetDescriptorLength (Aml2);
-        ResourceType = AcpiUtGetResourceType (Aml1);
-
-        /* Check for descriptor length match */
-
-        if (Aml1Length != Aml2Length)
-        {
-            AcpiOsPrintf (
-                "**** Length mismatch in descriptor [%.2X] type %2.2X, Offset %8.8X Len1 %X, Len2 %X ****\n",
-                Count, ResourceType, Offset, Aml1Length, Aml2Length);
-        }
-
-        /* Check for descriptor byte match */
-
-        else if (ACPI_MEMCMP (Aml1, Aml2, Aml1Length))
-        {
-            AcpiOsPrintf (
-                "**** Data mismatch in descriptor [%.2X] type %2.2X, Offset %8.8X ****\n",
-                Count, ResourceType, Offset);
-
-            for (i = 0; i < Aml1Length; i++)
-            {
-                if (Aml1[i] != Aml2[i])
-                {
-                    AcpiOsPrintf ("Mismatch at byte offset %.2X: is %2.2X, should be %2.2X\n",
-                        i, Aml2[i], Aml1[i]);
-                }
-            }
-        }
-
-        /* Exit on EndTag descriptor */
-
-        if (ResourceType == ACPI_RESOURCE_NAME_END_TAG)
-        {
-            return;
-        }
-
-        /* Point to next descriptor in each buffer */
-
-        Count++;
-        Offset += Aml1Length;
-        Aml1 += Aml1Length;
-        Aml2 += Aml2Length;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDmTestResourceConversion
- *
- * PARAMETERS:  Node            - Parent device node
- *              Name            - resource method name (_CRS)
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Compare the original AML with a conversion of the AML to
- *              internal resource list, then back to AML.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDmTestResourceConversion (
-    ACPI_NAMESPACE_NODE     *Node,
-    char                    *Name)
-{
-    ACPI_STATUS             Status;
-    ACPI_BUFFER             ReturnObj;
-    ACPI_BUFFER             ResourceObj;
-    ACPI_BUFFER             NewAml;
-    ACPI_OBJECT             *OriginalAml;
-
-
-    AcpiOsPrintf ("Resource Conversion Comparison:\n");
-
-    NewAml.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-    ReturnObj.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-    ResourceObj.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-
-    /* Get the original _CRS AML resource template */
-
-    Status = AcpiEvaluateObject (Node, Name, NULL, &ReturnObj);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could not obtain %s: %s\n",
-            Name, AcpiFormatException (Status));
-        return (Status);
-    }
-
-    /* Get the AML resource template, converted to internal resource structs */
-
-    Status = AcpiGetCurrentResources (Node, &ResourceObj);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("AcpiGetCurrentResources failed: %s\n",
-            AcpiFormatException (Status));
-        goto Exit1;
-    }
-
-    /* Convert internal resource list to external AML resource template */
-
-    Status = AcpiRsCreateAmlResources (ResourceObj.Pointer, &NewAml);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("AcpiRsCreateAmlResources failed: %s\n",
-            AcpiFormatException (Status));
-        goto Exit2;
-    }
-
-    /* Compare original AML to the newly created AML resource list */
-
-    OriginalAml = ReturnObj.Pointer;
-
-    AcpiDmCompareAmlResources (
-        OriginalAml->Buffer.Pointer, (ACPI_RSDESC_SIZE) OriginalAml->Buffer.Length,
-        NewAml.Pointer, (ACPI_RSDESC_SIZE) NewAml.Length);
-
-    /* Cleanup and exit */
-
-    ACPI_FREE (NewAml.Pointer);
-Exit2:
-    ACPI_FREE (ResourceObj.Pointer);
-Exit1:
-    ACPI_FREE (ReturnObj.Pointer);
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbResourceCallback
- *
- * PARAMETERS:  ACPI_WALK_RESOURCE_CALLBACK
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Simple callback to exercise AcpiWalkResources
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbResourceCallback (
-    ACPI_RESOURCE           *Resource,
-    void                    *Context)
-{
-
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDeviceResources
- *
- * PARAMETERS:  ACPI_WALK_CALLBACK
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Display the _PRT/_CRS/_PRS resources for a device object.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbDeviceResources (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_NAMESPACE_NODE     *Node;
-    ACPI_NAMESPACE_NODE     *PrtNode = NULL;
-    ACPI_NAMESPACE_NODE     *CrsNode = NULL;
-    ACPI_NAMESPACE_NODE     *PrsNode = NULL;
-    ACPI_NAMESPACE_NODE     *AeiNode = NULL;
-    char                    *ParentPath;
-    ACPI_BUFFER             ReturnObj;
-    ACPI_STATUS             Status;
-
-
-    Node = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, ObjHandle);
-    ParentPath = AcpiNsGetExternalPathname (Node);
-    if (!ParentPath)
-    {
-        return (AE_NO_MEMORY);
-    }
-
-    /* Get handles to the resource methods for this device */
-
-    (void) AcpiGetHandle (Node, METHOD_NAME__PRT, ACPI_CAST_PTR (ACPI_HANDLE, &PrtNode));
-    (void) AcpiGetHandle (Node, METHOD_NAME__CRS, ACPI_CAST_PTR (ACPI_HANDLE, &CrsNode));
-    (void) AcpiGetHandle (Node, METHOD_NAME__PRS, ACPI_CAST_PTR (ACPI_HANDLE, &PrsNode));
-    (void) AcpiGetHandle (Node, METHOD_NAME__AEI, ACPI_CAST_PTR (ACPI_HANDLE, &AeiNode));
-    if (!PrtNode && !CrsNode && !PrsNode && !AeiNode)
-    {
-        goto Cleanup;   /* Nothing to do */
-    }
-
-    AcpiOsPrintf ("\nDevice: %s\n", ParentPath);
-
-    /* Prepare for a return object of arbitrary size */
-
-    ReturnObj.Pointer = AcpiGbl_DbBuffer;
-    ReturnObj.Length  = ACPI_DEBUG_BUFFER_SIZE;
-
-
-    /* _PRT */
-
-    if (PrtNode)
-    {
-        AcpiOsPrintf ("Evaluating _PRT\n");
-
-        Status = AcpiEvaluateObject (PrtNode, NULL, NULL, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Could not evaluate _PRT: %s\n",
-                AcpiFormatException (Status));
-            goto GetCrs;
-        }
-
-        ReturnObj.Pointer = AcpiGbl_DbBuffer;
-        ReturnObj.Length  = ACPI_DEBUG_BUFFER_SIZE;
-
-        Status = AcpiGetIrqRoutingTable (Node, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("GetIrqRoutingTable failed: %s\n",
-                AcpiFormatException (Status));
-            goto GetCrs;
-        }
-
-        AcpiRsDumpIrqList (ACPI_CAST_PTR (UINT8, AcpiGbl_DbBuffer));
-    }
-
-
-    /* _CRS */
-
-GetCrs:
-    if (CrsNode)
-    {
-        AcpiOsPrintf ("Evaluating _CRS\n");
-
-        ReturnObj.Pointer = AcpiGbl_DbBuffer;
-        ReturnObj.Length  = ACPI_DEBUG_BUFFER_SIZE;
-
-        Status = AcpiEvaluateObject (CrsNode, NULL, NULL, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Could not evaluate _CRS: %s\n",
-                AcpiFormatException (Status));
-            goto GetPrs;
-        }
-
-        /* This code is here to exercise the AcpiWalkResources interface */
-
-        Status = AcpiWalkResources (Node, METHOD_NAME__CRS,
-            AcpiDbResourceCallback, NULL);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("AcpiWalkResources failed: %s\n",
-                AcpiFormatException (Status));
-            goto GetPrs;
-        }
-
-        /* Get the _CRS resource list */
-
-        ReturnObj.Pointer = AcpiGbl_DbBuffer;
-        ReturnObj.Length  = ACPI_DEBUG_BUFFER_SIZE;
-
-        Status = AcpiGetCurrentResources (Node, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("AcpiGetCurrentResources failed: %s\n",
-                AcpiFormatException (Status));
-            goto GetPrs;
-        }
-
-        /* Dump the _CRS resource list */
-
-        AcpiRsDumpResourceList (ACPI_CAST_PTR (ACPI_RESOURCE,
-            ReturnObj.Pointer));
-
-        /*
-         * Perform comparison of original AML to newly created AML. This tests both
-         * the AML->Resource conversion and the Resource->Aml conversion.
-         */
-        Status = AcpiDmTestResourceConversion (Node, METHOD_NAME__CRS);
-
-        /* Execute _SRS with the resource list */
-
-        Status = AcpiSetCurrentResources (Node, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("AcpiSetCurrentResources failed: %s\n",
-                AcpiFormatException (Status));
-            goto GetPrs;
-        }
-    }
-
-
-    /* _PRS */
-
-GetPrs:
-    if (PrsNode)
-    {
-        AcpiOsPrintf ("Evaluating _PRS\n");
-
-        ReturnObj.Pointer = AcpiGbl_DbBuffer;
-        ReturnObj.Length  = ACPI_DEBUG_BUFFER_SIZE;
-
-        Status = AcpiEvaluateObject (PrsNode, NULL, NULL, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Could not evaluate _PRS: %s\n",
-                AcpiFormatException (Status));
-            goto GetAei;
-        }
-
-        ReturnObj.Pointer = AcpiGbl_DbBuffer;
-        ReturnObj.Length  = ACPI_DEBUG_BUFFER_SIZE;
-
-        Status = AcpiGetPossibleResources (Node, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("AcpiGetPossibleResources failed: %s\n",
-                AcpiFormatException (Status));
-            goto GetAei;
-        }
-
-        AcpiRsDumpResourceList (ACPI_CAST_PTR (ACPI_RESOURCE, AcpiGbl_DbBuffer));
-    }
-
-
-    /* _AEI */
-
-GetAei:
-    if (AeiNode)
-    {
-        AcpiOsPrintf ("Evaluating _AEI\n");
-
-        ReturnObj.Pointer = AcpiGbl_DbBuffer;
-        ReturnObj.Length  = ACPI_DEBUG_BUFFER_SIZE;
-
-        Status = AcpiEvaluateObject (AeiNode, NULL, NULL, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Could not evaluate _AEI: %s\n",
-                AcpiFormatException (Status));
-            goto Cleanup;
-        }
-
-        ReturnObj.Pointer = AcpiGbl_DbBuffer;
-        ReturnObj.Length  = ACPI_DEBUG_BUFFER_SIZE;
-
-        Status = AcpiGetEventResources (Node, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("AcpiGetEventResources failed: %s\n",
-                AcpiFormatException (Status));
-            goto Cleanup;
-        }
-
-        AcpiRsDumpResourceList (ACPI_CAST_PTR (ACPI_RESOURCE, AcpiGbl_DbBuffer));
-    }
-
-
-Cleanup:
-    ACPI_FREE (ParentPath);
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayResources
- *
- * PARAMETERS:  ObjectArg       - String object name or object pointer.
- *                                "*" means "display resources for all devices"
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display the resource objects associated with a device.
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayResources (
-    char                    *ObjectArg)
-{
-    ACPI_NAMESPACE_NODE     *Node;
-
-
-    AcpiDbSetOutputDestination (ACPI_DB_REDIRECTABLE_OUTPUT);
-    AcpiDbgLevel |= ACPI_LV_RESOURCES;
-
-    /* Asterisk means "display resources for all devices" */
-
-    if (!ACPI_STRCMP (ObjectArg, "*"))
-    {
-        (void) AcpiWalkNamespace (ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
-                    ACPI_UINT32_MAX, AcpiDbDeviceResources, NULL, NULL, NULL);
-    }
-    else
-    {
-        /* Convert string to object pointer */
-
-        Node = AcpiDbConvertToNode (ObjectArg);
-        if (Node)
-        {
-            if (Node->Type != ACPI_TYPE_DEVICE)
-            {
-                AcpiOsPrintf ("%4.4s: Name is not a device object (%s)\n",
-                    Node->Name.Ascii, AcpiUtGetTypeName (Node->Type));
-            }
-            else
-            {
-                (void) AcpiDbDeviceResources (Node, 0, NULL, NULL);
-            }
-        }
-    }
-
-    AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-}
-
-
-#if (!ACPI_REDUCED_HARDWARE)
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbGenerateGpe
- *
- * PARAMETERS:  GpeArg          - Raw GPE number, ascii string
- *              BlockArg        - GPE block number, ascii string
- *                                0 or 1 for FADT GPE blocks
- *
- * RETURN:      None
- *
- * DESCRIPTION: Generate a GPE
- *
- ******************************************************************************/
-
-void
-AcpiDbGenerateGpe (
-    char                    *GpeArg,
-    char                    *BlockArg)
-{
-    UINT32                  BlockNumber;
-    UINT32                  GpeNumber;
-    ACPI_GPE_EVENT_INFO     *GpeEventInfo;
-
-
-    GpeNumber   = ACPI_STRTOUL (GpeArg, NULL, 0);
-    BlockNumber = ACPI_STRTOUL (BlockArg, NULL, 0);
-
-
-    GpeEventInfo = AcpiEvGetGpeEventInfo (ACPI_TO_POINTER (BlockNumber),
-        GpeNumber);
-    if (!GpeEventInfo)
-    {
-        AcpiOsPrintf ("Invalid GPE\n");
-        return;
-    }
-
-    (void) AcpiEvGpeDispatch (NULL, GpeEventInfo, GpeNumber);
-}
-#endif /* !ACPI_REDUCED_HARDWARE */
-
-#endif /* ACPI_DEBUGGER */
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbdisply.c b/usr/src/uts/intel/io/acpica/debugger/dbdisply.c
deleted file mode 100644
index 7facc8dd08..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbdisply.c
+++ /dev/null
@@ -1,1057 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbdisply - debug display commands
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "amlcode.h"
-#include "acdispat.h"
-#include "acnamesp.h"
-#include "acparser.h"
-#include "acinterp.h"
-#include "acdebug.h"
-#include "acdisasm.h"
-
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbdisply")
-
-/* Local prototypes */
-
-static void
-AcpiDbDumpParserDescriptor (
-    ACPI_PARSE_OBJECT       *Op);
-
-static void *
-AcpiDbGetPointer (
-    void                    *Target);
-
-
-/*
- * System handler information.
- * Used for Handlers command, in AcpiDbDisplayHandlers.
- */
-#define ACPI_PREDEFINED_PREFIX          "%25s (%.2X) : "
-#define ACPI_HANDLER_NAME_STRING               "%30s : "
-#define ACPI_HANDLER_PRESENT_STRING                    "%-9s (%p)\n"
-#define ACPI_HANDLER_NOT_PRESENT_STRING                "%-9s\n"
-
-/* All predefined Address Space IDs */
-
-static ACPI_ADR_SPACE_TYPE  AcpiGbl_SpaceIdList[] =
-{
-    ACPI_ADR_SPACE_SYSTEM_MEMORY,
-    ACPI_ADR_SPACE_SYSTEM_IO,
-    ACPI_ADR_SPACE_PCI_CONFIG,
-    ACPI_ADR_SPACE_EC,
-    ACPI_ADR_SPACE_SMBUS,
-    ACPI_ADR_SPACE_CMOS,
-    ACPI_ADR_SPACE_PCI_BAR_TARGET,
-    ACPI_ADR_SPACE_IPMI,
-    ACPI_ADR_SPACE_GPIO,
-    ACPI_ADR_SPACE_GSBUS,
-    ACPI_ADR_SPACE_DATA_TABLE,
-    ACPI_ADR_SPACE_FIXED_HARDWARE
-};
-
-/* Global handler information */
-
-typedef struct acpi_handler_info
-{
-    void                    *Handler;
-    char                    *Name;
-
-} ACPI_HANDLER_INFO;
-
-static ACPI_HANDLER_INFO    AcpiGbl_HandlerList[] =
-{
-    {&AcpiGbl_GlobalNotify[0].Handler,  "System Notifications"},
-    {&AcpiGbl_GlobalNotify[1].Handler,  "Device Notifications"},
-    {&AcpiGbl_TableHandler,             "ACPI Table Events"},
-    {&AcpiGbl_ExceptionHandler,         "Control Method Exceptions"},
-    {&AcpiGbl_InterfaceHandler,         "OSI Invocations"}
-};
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbGetPointer
- *
- * PARAMETERS:  Target          - Pointer to string to be converted
- *
- * RETURN:      Converted pointer
- *
- * DESCRIPTION: Convert an ascii pointer value to a real value
- *
- ******************************************************************************/
-
-static void *
-AcpiDbGetPointer (
-    void                    *Target)
-{
-    void                    *ObjPtr;
-
-
-    ObjPtr = ACPI_TO_POINTER (ACPI_STRTOUL (Target, NULL, 16));
-    return (ObjPtr);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDumpParserDescriptor
- *
- * PARAMETERS:  Op              - A parser Op descriptor
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display a formatted parser object
- *
- ******************************************************************************/
-
-static void
-AcpiDbDumpParserDescriptor (
-    ACPI_PARSE_OBJECT       *Op)
-{
-    const ACPI_OPCODE_INFO  *Info;
-
-
-    Info = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
-
-    AcpiOsPrintf ("Parser Op Descriptor:\n");
-    AcpiOsPrintf ("%20.20s : %4.4X\n", "Opcode", Op->Common.AmlOpcode);
-
-    ACPI_DEBUG_ONLY_MEMBERS (AcpiOsPrintf ("%20.20s : %s\n", "Opcode Name",
-        Info->Name));
-
-    AcpiOsPrintf ("%20.20s : %p\n", "Value/ArgList", Op->Common.Value.Arg);
-    AcpiOsPrintf ("%20.20s : %p\n", "Parent", Op->Common.Parent);
-    AcpiOsPrintf ("%20.20s : %p\n", "NextOp", Op->Common.Next);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDecodeAndDisplayObject
- *
- * PARAMETERS:  Target          - String with object to be displayed.  Names
- *                                and hex pointers are supported.
- *              OutputType      - Byte, Word, Dword, or Qword (B|W|D|Q)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display a formatted ACPI object
- *
- ******************************************************************************/
-
-void
-AcpiDbDecodeAndDisplayObject (
-    char                    *Target,
-    char                    *OutputType)
-{
-    void                    *ObjPtr;
-    ACPI_NAMESPACE_NODE     *Node;
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    UINT32                  Display = DB_BYTE_DISPLAY;
-    char                    Buffer[80];
-    ACPI_BUFFER             RetBuf;
-    ACPI_STATUS             Status;
-    UINT32                  Size;
-
-
-    if (!Target)
-    {
-        return;
-    }
-
-    /* Decode the output type */
-
-    if (OutputType)
-    {
-        AcpiUtStrupr (OutputType);
-        if (OutputType[0] == 'W')
-        {
-            Display = DB_WORD_DISPLAY;
-        }
-        else if (OutputType[0] == 'D')
-        {
-            Display = DB_DWORD_DISPLAY;
-        }
-        else if (OutputType[0] == 'Q')
-        {
-            Display = DB_QWORD_DISPLAY;
-        }
-    }
-
-    RetBuf.Length = sizeof (Buffer);
-    RetBuf.Pointer = Buffer;
-
-    /* Differentiate between a number and a name */
-
-    if ((Target[0] >= 0x30) && (Target[0] <= 0x39))
-    {
-        ObjPtr = AcpiDbGetPointer (Target);
-        if (!AcpiOsReadable (ObjPtr, 16))
-        {
-            AcpiOsPrintf ("Address %p is invalid in this address space\n",
-                ObjPtr);
-            return;
-        }
-
-        /* Decode the object type */
-
-        switch (ACPI_GET_DESCRIPTOR_TYPE (ObjPtr))
-        {
-        case ACPI_DESC_TYPE_NAMED:
-
-            /* This is a namespace Node */
-
-            if (!AcpiOsReadable (ObjPtr, sizeof (ACPI_NAMESPACE_NODE)))
-            {
-                AcpiOsPrintf (
-                    "Cannot read entire Named object at address %p\n", ObjPtr);
-                return;
-            }
-
-            Node = ObjPtr;
-            goto DumpNode;
-
-
-        case ACPI_DESC_TYPE_OPERAND:
-
-            /* This is a ACPI OPERAND OBJECT */
-
-            if (!AcpiOsReadable (ObjPtr, sizeof (ACPI_OPERAND_OBJECT)))
-            {
-                AcpiOsPrintf ("Cannot read entire ACPI object at address %p\n",
-                    ObjPtr);
-                return;
-            }
-
-            AcpiUtDumpBuffer (ObjPtr, sizeof (ACPI_OPERAND_OBJECT), Display,
-                ACPI_UINT32_MAX);
-            AcpiExDumpObjectDescriptor (ObjPtr, 1);
-            break;
-
-
-        case ACPI_DESC_TYPE_PARSER:
-
-            /* This is a Parser Op object */
-
-            if (!AcpiOsReadable (ObjPtr, sizeof (ACPI_PARSE_OBJECT)))
-            {
-                AcpiOsPrintf (
-                    "Cannot read entire Parser object at address %p\n", ObjPtr);
-                return;
-            }
-
-            AcpiUtDumpBuffer (ObjPtr, sizeof (ACPI_PARSE_OBJECT), Display,
-                ACPI_UINT32_MAX);
-            AcpiDbDumpParserDescriptor ((ACPI_PARSE_OBJECT *) ObjPtr);
-            break;
-
-
-        default:
-
-            /* Is not a recognizeable object */
-
-            Size = 16;
-            if (AcpiOsReadable (ObjPtr, 64))
-            {
-                Size = 64;
-            }
-
-            /* Just dump some memory */
-
-            AcpiUtDumpBuffer (ObjPtr, Size, Display, ACPI_UINT32_MAX);
-            break;
-        }
-
-        return;
-    }
-
-    /* The parameter is a name string that must be resolved to a Named obj */
-
-    Node = AcpiDbLocalNsLookup (Target);
-    if (!Node)
-    {
-        return;
-    }
-
-
-DumpNode:
-    /* Now dump the NS node */
-
-    Status = AcpiGetName (Node, ACPI_FULL_PATHNAME, &RetBuf);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could not convert name to pathname\n");
-    }
-
-    else
-    {
-        AcpiOsPrintf ("Object (%p) Pathname:  %s\n",
-            Node, (char *) RetBuf.Pointer);
-    }
-
-    if (!AcpiOsReadable (Node, sizeof (ACPI_NAMESPACE_NODE)))
-    {
-        AcpiOsPrintf ("Invalid Named object at address %p\n", Node);
-        return;
-    }
-
-    AcpiUtDumpBuffer ((void *) Node, sizeof (ACPI_NAMESPACE_NODE),
-        Display, ACPI_UINT32_MAX);
-    AcpiExDumpNamespaceNode (Node, 1);
-
-    ObjDesc = AcpiNsGetAttachedObject (Node);
-    if (ObjDesc)
-    {
-        AcpiOsPrintf ("\nAttached Object (%p):\n", ObjDesc);
-        if (!AcpiOsReadable (ObjDesc, sizeof (ACPI_OPERAND_OBJECT)))
-        {
-            AcpiOsPrintf ("Invalid internal ACPI Object at address %p\n",
-                ObjDesc);
-            return;
-        }
-
-        AcpiUtDumpBuffer ((void *) ObjDesc, sizeof (ACPI_OPERAND_OBJECT),
-            Display, ACPI_UINT32_MAX);
-        AcpiExDumpObjectDescriptor (ObjDesc, 1);
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayMethodInfo
- *
- * PARAMETERS:  StartOp         - Root of the control method parse tree
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display information about the current method
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayMethodInfo (
-    ACPI_PARSE_OBJECT       *StartOp)
-{
-    ACPI_WALK_STATE         *WalkState;
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_NAMESPACE_NODE     *Node;
-    ACPI_PARSE_OBJECT       *RootOp;
-    ACPI_PARSE_OBJECT       *Op;
-    const ACPI_OPCODE_INFO  *OpInfo;
-    UINT32                  NumOps = 0;
-    UINT32                  NumOperands = 0;
-    UINT32                  NumOperators = 0;
-    UINT32                  NumRemainingOps = 0;
-    UINT32                  NumRemainingOperands = 0;
-    UINT32                  NumRemainingOperators = 0;
-    BOOLEAN                 CountRemaining = FALSE;
-
-
-    WalkState = AcpiDsGetCurrentWalkState (AcpiGbl_CurrentWalkList);
-    if (!WalkState)
-    {
-        AcpiOsPrintf ("There is no method currently executing\n");
-        return;
-    }
-
-    ObjDesc = WalkState->MethodDesc;
-    Node    = WalkState->MethodNode;
-
-    AcpiOsPrintf ("Currently executing control method is [%4.4s]\n",
-            AcpiUtGetNodeName (Node));
-    AcpiOsPrintf ("%X Arguments, SyncLevel = %X\n",
-            (UINT32) ObjDesc->Method.ParamCount,
-            (UINT32) ObjDesc->Method.SyncLevel);
-
-
-    RootOp = StartOp;
-    while (RootOp->Common.Parent)
-    {
-        RootOp = RootOp->Common.Parent;
-    }
-
-    Op = RootOp;
-
-    while (Op)
-    {
-        if (Op == StartOp)
-        {
-            CountRemaining = TRUE;
-        }
-
-        NumOps++;
-        if (CountRemaining)
-        {
-            NumRemainingOps++;
-        }
-
-        /* Decode the opcode */
-
-        OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
-        switch (OpInfo->Class)
-        {
-        case AML_CLASS_ARGUMENT:
-            if (CountRemaining)
-            {
-                NumRemainingOperands++;
-            }
-
-            NumOperands++;
-            break;
-
-        case AML_CLASS_UNKNOWN:
-            /* Bad opcode or ASCII character */
-
-            continue;
-
-        default:
-            if (CountRemaining)
-            {
-                NumRemainingOperators++;
-            }
-
-            NumOperators++;
-            break;
-        }
-
-        Op = AcpiPsGetDepthNext (StartOp, Op);
-    }
-
-    AcpiOsPrintf (
-        "Method contains:       %X AML Opcodes - %X Operators, %X Operands\n",
-        NumOps, NumOperators, NumOperands);
-
-    AcpiOsPrintf (
-        "Remaining to execute:  %X AML Opcodes - %X Operators, %X Operands\n",
-        NumRemainingOps, NumRemainingOperators, NumRemainingOperands);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayLocals
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display all locals for the currently running control method
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayLocals (
-    void)
-{
-    ACPI_WALK_STATE         *WalkState;
-
-
-    WalkState = AcpiDsGetCurrentWalkState (AcpiGbl_CurrentWalkList);
-    if (!WalkState)
-    {
-        AcpiOsPrintf ("There is no method currently executing\n");
-        return;
-    }
-
-    AcpiDmDisplayLocals (WalkState);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayArguments
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display all arguments for the currently running control method
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayArguments (
-    void)
-{
-    ACPI_WALK_STATE         *WalkState;
-
-
-    WalkState = AcpiDsGetCurrentWalkState (AcpiGbl_CurrentWalkList);
-    if (!WalkState)
-    {
-        AcpiOsPrintf ("There is no method currently executing\n");
-        return;
-    }
-
-    AcpiDmDisplayArguments (WalkState);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayResults
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display current contents of a method result stack
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayResults (
-    void)
-{
-    UINT32                  i;
-    ACPI_WALK_STATE         *WalkState;
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    UINT32                  ResultCount = 0;
-    ACPI_NAMESPACE_NODE     *Node;
-    ACPI_GENERIC_STATE      *Frame;
-    UINT32                  Index; /* Index onto current frame */
-
-
-    WalkState = AcpiDsGetCurrentWalkState (AcpiGbl_CurrentWalkList);
-    if (!WalkState)
-    {
-        AcpiOsPrintf ("There is no method currently executing\n");
-        return;
-    }
-
-    ObjDesc = WalkState->MethodDesc;
-    Node    = WalkState->MethodNode;
-
-    if (WalkState->Results)
-    {
-        ResultCount = WalkState->ResultCount;
-    }
-
-    AcpiOsPrintf ("Method [%4.4s] has %X stacked result objects\n",
-            AcpiUtGetNodeName (Node), ResultCount);
-
-    /* From the top element of result stack */
-
-    Frame = WalkState->Results;
-    Index = (ResultCount - 1) % ACPI_RESULTS_FRAME_OBJ_NUM;
-
-    for (i = 0; i < ResultCount; i++)
-    {
-        ObjDesc = Frame->Results.ObjDesc[Index];
-        AcpiOsPrintf ("Result%u: ", i);
-        AcpiDmDisplayInternalObject (ObjDesc, WalkState);
-        if (Index == 0)
-        {
-            Frame = Frame->Results.Next;
-            Index = ACPI_RESULTS_FRAME_OBJ_NUM;
-        }
-        Index--;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayCallingTree
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display current calling tree of nested control methods
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayCallingTree (
-    void)
-{
-    ACPI_WALK_STATE         *WalkState;
-    ACPI_NAMESPACE_NODE     *Node;
-
-
-    WalkState = AcpiDsGetCurrentWalkState (AcpiGbl_CurrentWalkList);
-    if (!WalkState)
-    {
-        AcpiOsPrintf ("There is no method currently executing\n");
-        return;
-    }
-
-    Node = WalkState->MethodNode;
-    AcpiOsPrintf ("Current Control Method Call Tree\n");
-
-    while (WalkState)
-    {
-        Node = WalkState->MethodNode;
-
-        AcpiOsPrintf ("    [%4.4s]\n", AcpiUtGetNodeName (Node));
-
-        WalkState = WalkState->Next;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayObjectType
- *
- * PARAMETERS:  ObjectArg       - User entered NS node handle
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display type of an arbitrary NS node
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayObjectType (
-    char                    *ObjectArg)
-{
-    ACPI_HANDLE             Handle;
-    ACPI_DEVICE_INFO        *Info;
-    ACPI_STATUS             Status;
-    UINT32                  i;
-
-
-    Handle = ACPI_TO_POINTER (ACPI_STRTOUL (ObjectArg, NULL, 16));
-
-    Status = AcpiGetObjectInfo (Handle, &Info);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could not get object info, %s\n",
-            AcpiFormatException (Status));
-        return;
-    }
-
-    AcpiOsPrintf ("ADR: %8.8X%8.8X, STA: %8.8X, Flags: %X\n",
-        ACPI_FORMAT_UINT64 (Info->Address),
-        Info->CurrentStatus, Info->Flags);
-
-    AcpiOsPrintf ("S1D-%2.2X S2D-%2.2X S3D-%2.2X S4D-%2.2X\n",
-        Info->HighestDstates[0], Info->HighestDstates[1],
-        Info->HighestDstates[2], Info->HighestDstates[3]);
-
-    AcpiOsPrintf ("S0W-%2.2X S1W-%2.2X S2W-%2.2X S3W-%2.2X S4W-%2.2X\n",
-        Info->LowestDstates[0], Info->LowestDstates[1],
-        Info->LowestDstates[2], Info->LowestDstates[3],
-        Info->LowestDstates[4]);
-
-    if (Info->Valid & ACPI_VALID_HID)
-    {
-        AcpiOsPrintf ("HID: %s\n", Info->HardwareId.String);
-    }
-    if (Info->Valid & ACPI_VALID_UID)
-    {
-        AcpiOsPrintf ("UID: %s\n", Info->UniqueId.String);
-    }
-    if (Info->Valid & ACPI_VALID_CID)
-    {
-        for (i = 0; i < Info->CompatibleIdList.Count; i++)
-        {
-            AcpiOsPrintf ("CID %u: %s\n", i,
-                Info->CompatibleIdList.Ids[i].String);
-        }
-    }
-
-    ACPI_FREE (Info);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayResultObject
- *
- * PARAMETERS:  ObjDesc         - Object to be displayed
- *              WalkState       - Current walk state
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display the result of an AML opcode
- *
- * Note: Curently only displays the result object if we are single stepping.
- * However, this output may be useful in other contexts and could be enabled
- * to do so if needed.
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayResultObject (
-    ACPI_OPERAND_OBJECT     *ObjDesc,
-    ACPI_WALK_STATE         *WalkState)
-{
-
-    /* Only display if single stepping */
-
-    if (!AcpiGbl_CmSingleStep)
-    {
-        return;
-    }
-
-    AcpiOsPrintf ("ResultObj: ");
-    AcpiDmDisplayInternalObject (ObjDesc, WalkState);
-    AcpiOsPrintf ("\n");
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayArgumentObject
- *
- * PARAMETERS:  ObjDesc         - Object to be displayed
- *              WalkState       - Current walk state
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display the result of an AML opcode
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayArgumentObject (
-    ACPI_OPERAND_OBJECT     *ObjDesc,
-    ACPI_WALK_STATE         *WalkState)
-{
-
-    if (!AcpiGbl_CmSingleStep)
-    {
-        return;
-    }
-
-    AcpiOsPrintf ("ArgObj:    ");
-    AcpiDmDisplayInternalObject (ObjDesc, WalkState);
-}
-
-
-#if (!ACPI_REDUCED_HARDWARE)
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayGpes
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display the current GPE structures
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayGpes (
-    void)
-{
-    ACPI_GPE_BLOCK_INFO     *GpeBlock;
-    ACPI_GPE_XRUPT_INFO     *GpeXruptInfo;
-    ACPI_GPE_EVENT_INFO     *GpeEventInfo;
-    ACPI_GPE_REGISTER_INFO  *GpeRegisterInfo;
-    char                    *GpeType;
-    UINT32                  GpeIndex;
-    UINT32                  Block = 0;
-    UINT32                  i;
-    UINT32                  j;
-    char                    Buffer[80];
-    ACPI_BUFFER             RetBuf;
-    ACPI_STATUS             Status;
-
-
-    RetBuf.Length = sizeof (Buffer);
-    RetBuf.Pointer = Buffer;
-
-    Block = 0;
-
-    /* Walk the GPE lists */
-
-    GpeXruptInfo = AcpiGbl_GpeXruptListHead;
-    while (GpeXruptInfo)
-    {
-        GpeBlock = GpeXruptInfo->GpeBlockListHead;
-        while (GpeBlock)
-        {
-            Status = AcpiGetName (GpeBlock->Node, ACPI_FULL_PATHNAME, &RetBuf);
-            if (ACPI_FAILURE (Status))
-            {
-                AcpiOsPrintf ("Could not convert name to pathname\n");
-            }
-
-            if (GpeBlock->Node == AcpiGbl_FadtGpeDevice)
-            {
-                GpeType = "FADT-defined GPE block";
-            }
-            else
-            {
-                GpeType = "GPE Block Device";
-            }
-
-            AcpiOsPrintf ("\nBlock %u - Info %p  DeviceNode %p [%s] - %s\n",
-                Block, GpeBlock, GpeBlock->Node, Buffer, GpeType);
-
-            AcpiOsPrintf ("    Registers:    %u (%u GPEs)\n",
-                GpeBlock->RegisterCount, GpeBlock->GpeCount);
-
-            AcpiOsPrintf ("    GPE range:    0x%X to 0x%X on interrupt %u\n",
-                GpeBlock->BlockBaseNumber,
-                GpeBlock->BlockBaseNumber + (GpeBlock->GpeCount - 1),
-                GpeXruptInfo->InterruptNumber);
-
-            AcpiOsPrintf (
-                "    RegisterInfo: %p  Status %8.8X%8.8X Enable %8.8X%8.8X\n",
-                GpeBlock->RegisterInfo,
-                ACPI_FORMAT_UINT64 (GpeBlock->RegisterInfo->StatusAddress.Address),
-                ACPI_FORMAT_UINT64 (GpeBlock->RegisterInfo->EnableAddress.Address));
-
-            AcpiOsPrintf ("    EventInfo:    %p\n", GpeBlock->EventInfo);
-
-            /* Examine each GPE Register within the block */
-
-            for (i = 0; i < GpeBlock->RegisterCount; i++)
-            {
-                GpeRegisterInfo = &GpeBlock->RegisterInfo[i];
-
-                AcpiOsPrintf (
-                    "    Reg %u: (GPE %.2X-%.2X)  RunEnable %2.2X WakeEnable %2.2X"
-                    " Status %8.8X%8.8X Enable %8.8X%8.8X\n",
-                    i, GpeRegisterInfo->BaseGpeNumber,
-                    GpeRegisterInfo->BaseGpeNumber + (ACPI_GPE_REGISTER_WIDTH - 1),
-                    GpeRegisterInfo->EnableForRun,
-                    GpeRegisterInfo->EnableForWake,
-                    ACPI_FORMAT_UINT64 (GpeRegisterInfo->StatusAddress.Address),
-                    ACPI_FORMAT_UINT64 (GpeRegisterInfo->EnableAddress.Address));
-
-                /* Now look at the individual GPEs in this byte register */
-
-                for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++)
-                {
-                    GpeIndex = (i * ACPI_GPE_REGISTER_WIDTH) + j;
-                    GpeEventInfo = &GpeBlock->EventInfo[GpeIndex];
-
-                    if ((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) ==
-                        ACPI_GPE_DISPATCH_NONE)
-                    {
-                        /* This GPE is not used (no method or handler), ignore it */
-
-                        continue;
-                    }
-
-                    AcpiOsPrintf (
-                        "        GPE %.2X: %p  RunRefs %2.2X Flags %2.2X (",
-                        GpeBlock->BlockBaseNumber + GpeIndex, GpeEventInfo,
-                        GpeEventInfo->RuntimeCount, GpeEventInfo->Flags);
-
-                    /* Decode the flags byte */
-
-                    if (GpeEventInfo->Flags & ACPI_GPE_LEVEL_TRIGGERED)
-                    {
-                        AcpiOsPrintf ("Level, ");
-                    }
-                    else
-                    {
-                        AcpiOsPrintf ("Edge,  ");
-                    }
-
-                    if (GpeEventInfo->Flags & ACPI_GPE_CAN_WAKE)
-                    {
-                        AcpiOsPrintf ("CanWake, ");
-                    }
-                    else
-                    {
-                        AcpiOsPrintf ("RunOnly, ");
-                    }
-
-                    switch (GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK)
-                    {
-                    case ACPI_GPE_DISPATCH_NONE:
-                        AcpiOsPrintf ("NotUsed");
-                        break;
-                    case ACPI_GPE_DISPATCH_METHOD:
-                        AcpiOsPrintf ("Method");
-                        break;
-                    case ACPI_GPE_DISPATCH_HANDLER:
-                        AcpiOsPrintf ("Handler");
-                        break;
-                    case ACPI_GPE_DISPATCH_NOTIFY:
-                        AcpiOsPrintf ("Notify");
-                        break;
-                    default:
-                        AcpiOsPrintf ("UNKNOWN: %X",
-                            GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK);
-                        break;
-                    }
-
-                    AcpiOsPrintf (")\n");
-                }
-            }
-            Block++;
-            GpeBlock = GpeBlock->Next;
-        }
-        GpeXruptInfo = GpeXruptInfo->Next;
-    }
-}
-#endif /* !ACPI_REDUCED_HARDWARE */
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayHandlers
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display the currently installed global handlers
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayHandlers (
-    void)
-{
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_OPERAND_OBJECT     *HandlerObj;
-    ACPI_ADR_SPACE_TYPE     SpaceId;
-    UINT32                  i;
-
-
-    /* Operation region handlers */
-
-    AcpiOsPrintf ("\nOperation Region Handlers:\n");
-
-    ObjDesc = AcpiNsGetAttachedObject (AcpiGbl_RootNode);
-    if (ObjDesc)
-    {
-        for (i = 0; i < ACPI_ARRAY_LENGTH (AcpiGbl_SpaceIdList); i++)
-        {
-            SpaceId = AcpiGbl_SpaceIdList[i];
-            HandlerObj = ObjDesc->Device.Handler;
-
-            AcpiOsPrintf (ACPI_PREDEFINED_PREFIX,
-                AcpiUtGetRegionName ((UINT8) SpaceId), SpaceId);
-
-            while (HandlerObj)
-            {
-                if (AcpiGbl_SpaceIdList[i] == HandlerObj->AddressSpace.SpaceId)
-                {
-                    AcpiOsPrintf (ACPI_HANDLER_PRESENT_STRING,
-                        (HandlerObj->AddressSpace.HandlerFlags &
-                            ACPI_ADDR_HANDLER_DEFAULT_INSTALLED) ? "Default" : "User",
-                        HandlerObj->AddressSpace.Handler);
-                    goto FoundHandler;
-                }
-
-                HandlerObj = HandlerObj->AddressSpace.Next;
-            }
-
-            /* There is no handler for this SpaceId */
-
-            AcpiOsPrintf ("None\n");
-
-        FoundHandler:;
-        }
-
-        /* Find all handlers for user-defined SpaceIDs */
-
-        HandlerObj = ObjDesc->Device.Handler;
-        while (HandlerObj)
-        {
-            if (HandlerObj->AddressSpace.SpaceId >= ACPI_USER_REGION_BEGIN)
-            {
-                AcpiOsPrintf (ACPI_PREDEFINED_PREFIX,
-                    "User-defined ID", HandlerObj->AddressSpace.SpaceId);
-                AcpiOsPrintf (ACPI_HANDLER_PRESENT_STRING,
-                    (HandlerObj->AddressSpace.HandlerFlags &
-                        ACPI_ADDR_HANDLER_DEFAULT_INSTALLED) ? "Default" : "User",
-                    HandlerObj->AddressSpace.Handler);
-            }
-
-            HandlerObj = HandlerObj->AddressSpace.Next;
-        }
-    }
-
-#if (!ACPI_REDUCED_HARDWARE)
-
-    /* Fixed event handlers */
-
-    AcpiOsPrintf ("\nFixed Event Handlers:\n");
-
-    for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++)
-    {
-        AcpiOsPrintf (ACPI_PREDEFINED_PREFIX, AcpiUtGetEventName (i), i);
-        if (AcpiGbl_FixedEventHandlers[i].Handler)
-        {
-            AcpiOsPrintf (ACPI_HANDLER_PRESENT_STRING, "User",
-                AcpiGbl_FixedEventHandlers[i].Handler);
-        }
-        else
-        {
-            AcpiOsPrintf (ACPI_HANDLER_NOT_PRESENT_STRING, "None");
-        }
-    }
-
-#endif /* !ACPI_REDUCED_HARDWARE */
-
-    /* Miscellaneous global handlers */
-
-    AcpiOsPrintf ("\nMiscellaneous Global Handlers:\n");
-
-    for (i = 0; i < ACPI_ARRAY_LENGTH (AcpiGbl_HandlerList); i++)
-    {
-        AcpiOsPrintf (ACPI_HANDLER_NAME_STRING, AcpiGbl_HandlerList[i].Name);
-        if (AcpiGbl_HandlerList[i].Handler)
-        {
-            AcpiOsPrintf (ACPI_HANDLER_PRESENT_STRING, "User",
-                AcpiGbl_HandlerList[i].Handler);
-        }
-        else
-        {
-            AcpiOsPrintf (ACPI_HANDLER_NOT_PRESENT_STRING, "None");
-        }
-    }
-}
-
-#endif /* ACPI_DEBUGGER */
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbexec.c b/usr/src/uts/intel/io/acpica/debugger/dbexec.c
deleted file mode 100644
index 7818c9ddbe..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbexec.c
+++ /dev/null
@@ -1,1105 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbexec - debugger control method execution
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acdebug.h"
-#include "acnamesp.h"
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbexec")
-
-
-static ACPI_DB_METHOD_INFO          AcpiGbl_DbMethodInfo;
-#define DB_DEFAULT_PKG_ELEMENTS     33
-
-/* Local prototypes */
-
-static ACPI_STATUS
-AcpiDbExecuteMethod (
-    ACPI_DB_METHOD_INFO     *Info,
-    ACPI_BUFFER             *ReturnObj);
-
-static void
-AcpiDbExecuteSetup (
-    ACPI_DB_METHOD_INFO     *Info);
-
-static UINT32
-AcpiDbGetOutstandingAllocations (
-    void);
-
-static void ACPI_SYSTEM_XFACE
-AcpiDbMethodThread (
-    void                    *Context);
-
-static ACPI_STATUS
-AcpiDbExecutionWalk (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-static ACPI_STATUS
-AcpiDbHexCharToValue (
-    int                     HexChar,
-    UINT8                   *ReturnValue);
-
-static ACPI_STATUS
-AcpiDbConvertToPackage (
-    char                    *String,
-    ACPI_OBJECT             *Object);
-
-static ACPI_STATUS
-AcpiDbConvertToObject (
-    ACPI_OBJECT_TYPE        Type,
-    char                    *String,
-    ACPI_OBJECT             *Object);
-
-static void
-AcpiDbDeleteObjects (
-    UINT32                  Count,
-    ACPI_OBJECT             *Objects);
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbHexCharToValue
- *
- * PARAMETERS:  HexChar             - Ascii Hex digit, 0-9|a-f|A-F
- *              ReturnValue         - Where the converted value is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Convert a single hex character to a 4-bit number (0-16).
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbHexCharToValue (
-    int                     HexChar,
-    UINT8                   *ReturnValue)
-{
-    UINT8                   Value;
-
-
-    /* Digit must be ascii [0-9a-fA-F] */
-
-    if (!ACPI_IS_XDIGIT (HexChar))
-    {
-        return (AE_BAD_HEX_CONSTANT);
-    }
-
-    if (HexChar <= 0x39)
-    {
-        Value = (UINT8) (HexChar - 0x30);
-    }
-    else
-    {
-        Value = (UINT8) (ACPI_TOUPPER (HexChar) - 0x37);
-    }
-
-    *ReturnValue = Value;
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbHexByteToBinary
- *
- * PARAMETERS:  HexByte             - Double hex digit (0x00 - 0xFF) in format:
- *                                    HiByte then LoByte.
- *              ReturnValue         - Where the converted value is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Convert two hex characters to an 8 bit number (0 - 255).
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbHexByteToBinary (
-    char                    *HexByte,
-    UINT8                   *ReturnValue)
-{
-    UINT8                   Local0;
-    UINT8                   Local1;
-    ACPI_STATUS             Status;
-
-
-    /* High byte */
-
-    Status = AcpiDbHexCharToValue (HexByte[0], &Local0);
-    if (ACPI_FAILURE (Status))
-    {
-        return (Status);
-    }
-
-    /* Low byte */
-
-    Status = AcpiDbHexCharToValue (HexByte[1], &Local1);
-    if (ACPI_FAILURE (Status))
-    {
-        return (Status);
-    }
-
-    *ReturnValue = (UINT8) ((Local0 << 4) | Local1);
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbConvertToBuffer
- *
- * PARAMETERS:  String              - Input string to be converted
- *              Object              - Where the buffer object is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Convert a string to a buffer object. String is treated a list
- *              of buffer elements, each separated by a space or comma.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbConvertToBuffer (
-    char                    *String,
-    ACPI_OBJECT             *Object)
-{
-    UINT32                  i;
-    UINT32                  j;
-    UINT32                  Length;
-    UINT8                   *Buffer;
-    ACPI_STATUS             Status;
-
-
-    /* Generate the final buffer length */
-
-    for (i = 0, Length = 0; String[i];)
-    {
-        i+=2;
-        Length++;
-
-        while (String[i] &&
-              ((String[i] == ',') || (String[i] == ' ')))
-        {
-            i++;
-        }
-    }
-
-    Buffer = ACPI_ALLOCATE (Length);
-    if (!Buffer)
-    {
-        return (AE_NO_MEMORY);
-    }
-
-    /* Convert the command line bytes to the buffer */
-
-    for (i = 0, j = 0; String[i];)
-    {
-        Status = AcpiDbHexByteToBinary (&String[i], &Buffer[j]);
-        if (ACPI_FAILURE (Status))
-        {
-            ACPI_FREE (Buffer);
-            return (Status);
-        }
-
-        j++;
-        i+=2;
-        while (String[i] &&
-              ((String[i] == ',') || (String[i] == ' ')))
-        {
-            i++;
-        }
-    }
-
-    Object->Type = ACPI_TYPE_BUFFER;
-    Object->Buffer.Pointer = Buffer;
-    Object->Buffer.Length = Length;
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbConvertToPackage
- *
- * PARAMETERS:  String              - Input string to be converted
- *              Object              - Where the package object is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Convert a string to a package object. Handles nested packages
- *              via recursion with AcpiDbConvertToObject.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbConvertToPackage (
-    char                    *String,
-    ACPI_OBJECT             *Object)
-{
-    char                    *This;
-    char                    *Next;
-    UINT32                  i;
-    ACPI_OBJECT_TYPE        Type;
-    ACPI_OBJECT             *Elements;
-    ACPI_STATUS             Status;
-
-
-    Elements = ACPI_ALLOCATE_ZEROED (
-        DB_DEFAULT_PKG_ELEMENTS * sizeof (ACPI_OBJECT));
-
-    This = String;
-    for (i = 0; i < (DB_DEFAULT_PKG_ELEMENTS - 1); i++)
-    {
-        This = AcpiDbGetNextToken (This, &Next, &Type);
-        if (!This)
-        {
-            break;
-        }
-
-        /* Recursive call to convert each package element */
-
-        Status = AcpiDbConvertToObject (Type, This, &Elements[i]);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiDbDeleteObjects (i + 1, Elements);
-            ACPI_FREE (Elements);
-            return (Status);
-        }
-
-        This = Next;
-    }
-
-    Object->Type = ACPI_TYPE_PACKAGE;
-    Object->Package.Count = i;
-    Object->Package.Elements = Elements;
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbConvertToObject
- *
- * PARAMETERS:  Type                - Object type as determined by parser
- *              String              - Input string to be converted
- *              Object              - Where the new object is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Convert a typed and tokenized string to an ACPI_OBJECT. Typing:
- *              1) String objects were surrounded by quotes.
- *              2) Buffer objects were surrounded by parentheses.
- *              3) Package objects were surrounded by brackets "[]".
- *              4) All standalone tokens are treated as integers.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbConvertToObject (
-    ACPI_OBJECT_TYPE        Type,
-    char                    *String,
-    ACPI_OBJECT             *Object)
-{
-    ACPI_STATUS             Status = AE_OK;
-
-
-    switch (Type)
-    {
-    case ACPI_TYPE_STRING:
-        Object->Type = ACPI_TYPE_STRING;
-        Object->String.Pointer = String;
-        Object->String.Length = (UINT32) ACPI_STRLEN (String);
-        break;
-
-    case ACPI_TYPE_BUFFER:
-        Status = AcpiDbConvertToBuffer (String, Object);
-        break;
-
-    case ACPI_TYPE_PACKAGE:
-        Status = AcpiDbConvertToPackage (String, Object);
-        break;
-
-    default:
-        Object->Type = ACPI_TYPE_INTEGER;
-        Status = AcpiUtStrtoul64 (String, 16, &Object->Integer.Value);
-        break;
-    }
-
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDeleteObjects
- *
- * PARAMETERS:  Count               - Count of objects in the list
- *              Objects             - Array of ACPI_OBJECTs to be deleted
- *
- * RETURN:      None
- *
- * DESCRIPTION: Delete a list of ACPI_OBJECTS. Handles packages and nested
- *              packages via recursion.
- *
- ******************************************************************************/
-
-static void
-AcpiDbDeleteObjects (
-    UINT32                  Count,
-    ACPI_OBJECT             *Objects)
-{
-    UINT32                  i;
-
-
-    for (i = 0; i < Count; i++)
-    {
-        switch (Objects[i].Type)
-        {
-        case ACPI_TYPE_BUFFER:
-            ACPI_FREE (Objects[i].Buffer.Pointer);
-            break;
-
-        case ACPI_TYPE_PACKAGE:
-
-            /* Recursive call to delete package elements */
-
-            AcpiDbDeleteObjects (Objects[i].Package.Count,
-                Objects[i].Package.Elements);
-
-            /* Free the elements array */
-
-            ACPI_FREE (Objects[i].Package.Elements);
-            break;
-
-        default:
-            break;
-        }
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbExecuteMethod
- *
- * PARAMETERS:  Info            - Valid info segment
- *              ReturnObj       - Where to put return object
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Execute a control method.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbExecuteMethod (
-    ACPI_DB_METHOD_INFO     *Info,
-    ACPI_BUFFER             *ReturnObj)
-{
-    ACPI_STATUS             Status;
-    ACPI_OBJECT_LIST        ParamObjects;
-    ACPI_OBJECT             Params[ACPI_METHOD_NUM_ARGS];
-    ACPI_HANDLE             Handle;
-    ACPI_DEVICE_INFO        *ObjInfo;
-    UINT32                  i;
-
-
-    ACPI_FUNCTION_TRACE (DbExecuteMethod);
-
-
-    if (AcpiGbl_DbOutputToFile && !AcpiDbgLevel)
-    {
-        AcpiOsPrintf ("Warning: debug output is not enabled!\n");
-    }
-
-    /* Get the NS node, determines existence also */
-
-    Status = AcpiGetHandle (NULL, Info->Pathname, &Handle);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Get the object info for number of method parameters */
-
-    Status = AcpiGetObjectInfo (Handle, &ObjInfo);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    ParamObjects.Pointer = NULL;
-    ParamObjects.Count   = 0;
-
-    if (ObjInfo->Type == ACPI_TYPE_METHOD)
-    {
-        /* Are there arguments to the method? */
-
-        i = 0;
-        if (Info->Args && Info->Args[0])
-        {
-            /* Get arguments passed on the command line */
-
-            for (; Info->Args[i] &&
-                (i < ACPI_METHOD_NUM_ARGS) &&
-                (i < ObjInfo->ParamCount);
-                i++)
-            {
-                /* Convert input string (token) to an actual ACPI_OBJECT */
-
-                Status = AcpiDbConvertToObject (Info->Types[i],
-                    Info->Args[i], &Params[i]);
-                if (ACPI_FAILURE (Status))
-                {
-                    ACPI_EXCEPTION ((AE_INFO, Status,
-                        "While parsing method arguments"));
-                    goto Cleanup;
-                }
-            }
-        }
-
-        /* Create additional "default" parameters as needed */
-
-        if (i < ObjInfo->ParamCount)
-        {
-            AcpiOsPrintf ("Adding %u arguments containing default values\n",
-                ObjInfo->ParamCount - i);
-
-            for (; i < ObjInfo->ParamCount; i++)
-            {
-                switch (i)
-                {
-                case 0:
-
-                    Params[0].Type           = ACPI_TYPE_INTEGER;
-                    Params[0].Integer.Value  = 0x01020304;
-                    break;
-
-                case 1:
-
-                    Params[1].Type           = ACPI_TYPE_STRING;
-                    Params[1].String.Length  = 12;
-                    Params[1].String.Pointer = "AML Debugger";
-                    break;
-
-                default:
-
-                    Params[i].Type           = ACPI_TYPE_INTEGER;
-                    Params[i].Integer.Value  = i * (UINT64) 0x1000;
-                    break;
-                }
-            }
-        }
-
-        ParamObjects.Count = ObjInfo->ParamCount;
-        ParamObjects.Pointer = Params;
-    }
-
-    /* Prepare for a return object of arbitrary size */
-
-    ReturnObj->Pointer = AcpiGbl_DbBuffer;
-    ReturnObj->Length  = ACPI_DEBUG_BUFFER_SIZE;
-
-    /* Do the actual method execution */
-
-    AcpiGbl_MethodExecuting = TRUE;
-    Status = AcpiEvaluateObject (NULL,
-        Info->Pathname, &ParamObjects, ReturnObj);
-
-    AcpiGbl_CmSingleStep = FALSE;
-    AcpiGbl_MethodExecuting = FALSE;
-
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_EXCEPTION ((AE_INFO, Status,
-            "while executing %s from debugger", Info->Pathname));
-
-        if (Status == AE_BUFFER_OVERFLOW)
-        {
-            ACPI_ERROR ((AE_INFO,
-                "Possible overflow of internal debugger buffer (size 0x%X needed 0x%X)",
-                ACPI_DEBUG_BUFFER_SIZE, (UINT32) ReturnObj->Length));
-        }
-    }
-
-Cleanup:
-    AcpiDbDeleteObjects (ObjInfo->ParamCount, Params);
-    ACPI_FREE (ObjInfo);
-
-    return_ACPI_STATUS (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbExecuteSetup
- *
- * PARAMETERS:  Info            - Valid method info
- *
- * RETURN:      None
- *
- * DESCRIPTION: Setup info segment prior to method execution
- *
- ******************************************************************************/
-
-static void
-AcpiDbExecuteSetup (
-    ACPI_DB_METHOD_INFO     *Info)
-{
-
-    /* Catenate the current scope to the supplied name */
-
-    Info->Pathname[0] = 0;
-    if ((Info->Name[0] != '\\') &&
-        (Info->Name[0] != '/'))
-    {
-        ACPI_STRCAT (Info->Pathname, AcpiGbl_DbScopeBuf);
-    }
-
-    ACPI_STRCAT (Info->Pathname, Info->Name);
-    AcpiDbPrepNamestring (Info->Pathname);
-
-    AcpiDbSetOutputDestination (ACPI_DB_DUPLICATE_OUTPUT);
-    AcpiOsPrintf ("Executing %s\n", Info->Pathname);
-
-    if (Info->Flags & EX_SINGLE_STEP)
-    {
-        AcpiGbl_CmSingleStep = TRUE;
-        AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-    }
-
-    else
-    {
-        /* No single step, allow redirection to a file */
-
-        AcpiDbSetOutputDestination (ACPI_DB_REDIRECTABLE_OUTPUT);
-    }
-}
-
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-UINT32
-AcpiDbGetCacheInfo (
-    ACPI_MEMORY_LIST        *Cache)
-{
-
-    return (Cache->TotalAllocated - Cache->TotalFreed - Cache->CurrentDepth);
-}
-#endif
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbGetOutstandingAllocations
- *
- * PARAMETERS:  None
- *
- * RETURN:      Current global allocation count minus cache entries
- *
- * DESCRIPTION: Determine the current number of "outstanding" allocations --
- *              those allocations that have not been freed and also are not
- *              in one of the various object caches.
- *
- ******************************************************************************/
-
-static UINT32
-AcpiDbGetOutstandingAllocations (
-    void)
-{
-    UINT32                  Outstanding = 0;
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-
-    Outstanding += AcpiDbGetCacheInfo (AcpiGbl_StateCache);
-    Outstanding += AcpiDbGetCacheInfo (AcpiGbl_PsNodeCache);
-    Outstanding += AcpiDbGetCacheInfo (AcpiGbl_PsNodeExtCache);
-    Outstanding += AcpiDbGetCacheInfo (AcpiGbl_OperandCache);
-#endif
-
-    return (Outstanding);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbExecutionWalk
- *
- * PARAMETERS:  WALK_CALLBACK
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Execute a control method.  Name is relative to the current
- *              scope.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbExecutionWalk (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_NAMESPACE_NODE     *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
-    ACPI_BUFFER             ReturnObj;
-    ACPI_STATUS             Status;
-
-
-    ObjDesc = AcpiNsGetAttachedObject (Node);
-    if (ObjDesc->Method.ParamCount)
-    {
-        return (AE_OK);
-    }
-
-    ReturnObj.Pointer = NULL;
-    ReturnObj.Length = ACPI_ALLOCATE_BUFFER;
-
-    AcpiNsPrintNodePathname (Node, "Execute");
-
-    /* Do the actual method execution */
-
-    AcpiOsPrintf ("\n");
-    AcpiGbl_MethodExecuting = TRUE;
-
-    Status = AcpiEvaluateObject (Node, NULL, NULL, &ReturnObj);
-
-    AcpiOsPrintf ("[%4.4s] returned %s\n", AcpiUtGetNodeName (Node),
-            AcpiFormatException (Status));
-    AcpiGbl_MethodExecuting = FALSE;
-
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbExecute
- *
- * PARAMETERS:  Name                - Name of method to execute
- *              Args                - Parameters to the method
- *              Flags               - single step/no single step
- *
- * RETURN:      None
- *
- * DESCRIPTION: Execute a control method.  Name is relative to the current
- *              scope.
- *
- ******************************************************************************/
-
-void
-AcpiDbExecute (
-    char                    *Name,
-    char                    **Args,
-    ACPI_OBJECT_TYPE        *Types,
-    UINT32                  Flags)
-{
-    ACPI_STATUS             Status;
-    ACPI_BUFFER             ReturnObj;
-    char                    *NameString;
-
-
-#ifdef ACPI_DEBUG_OUTPUT
-    UINT32                  PreviousAllocations;
-    UINT32                  Allocations;
-
-
-    /* Memory allocation tracking */
-
-    PreviousAllocations = AcpiDbGetOutstandingAllocations ();
-#endif
-
-    if (*Name == '*')
-    {
-        (void) AcpiWalkNamespace (ACPI_TYPE_METHOD, ACPI_ROOT_OBJECT,
-                    ACPI_UINT32_MAX, AcpiDbExecutionWalk, NULL, NULL, NULL);
-        return;
-    }
-    else
-    {
-        NameString = ACPI_ALLOCATE (ACPI_STRLEN (Name) + 1);
-        if (!NameString)
-        {
-            return;
-        }
-
-        ACPI_MEMSET (&AcpiGbl_DbMethodInfo, 0, sizeof (ACPI_DB_METHOD_INFO));
-
-        ACPI_STRCPY (NameString, Name);
-        AcpiUtStrupr (NameString);
-        AcpiGbl_DbMethodInfo.Name = NameString;
-        AcpiGbl_DbMethodInfo.Args = Args;
-        AcpiGbl_DbMethodInfo.Types = Types;
-        AcpiGbl_DbMethodInfo.Flags = Flags;
-
-        ReturnObj.Pointer = NULL;
-        ReturnObj.Length = ACPI_ALLOCATE_BUFFER;
-
-        AcpiDbExecuteSetup (&AcpiGbl_DbMethodInfo);
-        Status = AcpiDbExecuteMethod (&AcpiGbl_DbMethodInfo, &ReturnObj);
-        ACPI_FREE (NameString);
-    }
-
-    /*
-     * Allow any handlers in separate threads to complete.
-     * (Such as Notify handlers invoked from AML executed above).
-     */
-    AcpiOsSleep ((UINT64) 10);
-
-
-#ifdef ACPI_DEBUG_OUTPUT
-
-    /* Memory allocation tracking */
-
-    Allocations = AcpiDbGetOutstandingAllocations () - PreviousAllocations;
-
-    AcpiDbSetOutputDestination (ACPI_DB_DUPLICATE_OUTPUT);
-
-    if (Allocations > 0)
-    {
-        AcpiOsPrintf ("Outstanding: 0x%X allocations after execution\n",
-                        Allocations);
-    }
-#endif
-
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Execution of %s failed with status %s\n",
-            AcpiGbl_DbMethodInfo.Pathname, AcpiFormatException (Status));
-    }
-    else
-    {
-        /* Display a return object, if any */
-
-        if (ReturnObj.Length)
-        {
-            AcpiOsPrintf ("Execution of %s returned object %p Buflen %X\n",
-                AcpiGbl_DbMethodInfo.Pathname, ReturnObj.Pointer,
-                (UINT32) ReturnObj.Length);
-            AcpiDbDumpExternalObject (ReturnObj.Pointer, 1);
-        }
-        else
-        {
-            AcpiOsPrintf ("No return object from execution of %s\n",
-                AcpiGbl_DbMethodInfo.Pathname);
-        }
-    }
-
-    AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbMethodThread
- *
- * PARAMETERS:  Context             - Execution info segment
- *
- * RETURN:      None
- *
- * DESCRIPTION: Debugger execute thread.  Waits for a command line, then
- *              simply dispatches it.
- *
- ******************************************************************************/
-
-static void ACPI_SYSTEM_XFACE
-AcpiDbMethodThread (
-    void                    *Context)
-{
-    ACPI_STATUS             Status;
-    ACPI_DB_METHOD_INFO     *Info = Context;
-    ACPI_DB_METHOD_INFO     LocalInfo;
-    UINT32                  i;
-    UINT8                   Allow;
-    ACPI_BUFFER             ReturnObj;
-
-
-    /*
-     * AcpiGbl_DbMethodInfo.Arguments will be passed as method arguments.
-     * Prevent AcpiGbl_DbMethodInfo from being modified by multiple threads
-     * concurrently.
-     *
-     * Note: The arguments we are passing are used by the ASL test suite
-     * (aslts). Do not change them without updating the tests.
-     */
-    (void) AcpiOsWaitSemaphore (Info->InfoGate, 1, ACPI_WAIT_FOREVER);
-
-    if (Info->InitArgs)
-    {
-        AcpiDbUInt32ToHexString (Info->NumCreated, Info->IndexOfThreadStr);
-        AcpiDbUInt32ToHexString ((UINT32) AcpiOsGetThreadId (), Info->IdOfThreadStr);
-    }
-
-    if (Info->Threads && (Info->NumCreated < Info->NumThreads))
-    {
-        Info->Threads[Info->NumCreated++] = AcpiOsGetThreadId();
-    }
-
-    LocalInfo = *Info;
-    LocalInfo.Args = LocalInfo.Arguments;
-    LocalInfo.Arguments[0] = LocalInfo.NumThreadsStr;
-    LocalInfo.Arguments[1] = LocalInfo.IdOfThreadStr;
-    LocalInfo.Arguments[2] = LocalInfo.IndexOfThreadStr;
-    LocalInfo.Arguments[3] = NULL;
-
-    LocalInfo.Types = LocalInfo.ArgTypes;
-
-    (void) AcpiOsSignalSemaphore (Info->InfoGate, 1);
-
-    for (i = 0; i < Info->NumLoops; i++)
-    {
-        Status = AcpiDbExecuteMethod (&LocalInfo, &ReturnObj);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("%s During execution of %s at iteration %X\n",
-                AcpiFormatException (Status), Info->Pathname, i);
-            if (Status == AE_ABORT_METHOD)
-            {
-                break;
-            }
-        }
-
-#if 0
-        if ((i % 100) == 0)
-        {
-            AcpiOsPrintf ("%u executions, Thread 0x%x\n", i, AcpiOsGetThreadId ());
-        }
-
-        if (ReturnObj.Length)
-        {
-            AcpiOsPrintf ("Execution of %s returned object %p Buflen %X\n",
-                Info->Pathname, ReturnObj.Pointer, (UINT32) ReturnObj.Length);
-            AcpiDbDumpExternalObject (ReturnObj.Pointer, 1);
-        }
-#endif
-    }
-
-    /* Signal our completion */
-
-    Allow = 0;
-    (void) AcpiOsWaitSemaphore (Info->ThreadCompleteGate, 1, ACPI_WAIT_FOREVER);
-    Info->NumCompleted++;
-
-    if (Info->NumCompleted == Info->NumThreads)
-    {
-        /* Do signal for main thread once only */
-        Allow = 1;
-    }
-
-    (void) AcpiOsSignalSemaphore (Info->ThreadCompleteGate, 1);
-
-    if (Allow)
-    {
-        Status = AcpiOsSignalSemaphore (Info->MainThreadGate, 1);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Could not signal debugger thread sync semaphore, %s\n",
-                AcpiFormatException (Status));
-        }
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbCreateExecutionThreads
- *
- * PARAMETERS:  NumThreadsArg           - Number of threads to create
- *              NumLoopsArg             - Loop count for the thread(s)
- *              MethodNameArg           - Control method to execute
- *
- * RETURN:      None
- *
- * DESCRIPTION: Create threads to execute method(s)
- *
- ******************************************************************************/
-
-void
-AcpiDbCreateExecutionThreads (
-    char                    *NumThreadsArg,
-    char                    *NumLoopsArg,
-    char                    *MethodNameArg)
-{
-    ACPI_STATUS             Status;
-    UINT32                  NumThreads;
-    UINT32                  NumLoops;
-    UINT32                  i;
-    UINT32                  Size;
-    ACPI_MUTEX              MainThreadGate;
-    ACPI_MUTEX              ThreadCompleteGate;
-    ACPI_MUTEX              InfoGate;
-
-
-    /* Get the arguments */
-
-    NumThreads = ACPI_STRTOUL (NumThreadsArg, NULL, 0);
-    NumLoops   = ACPI_STRTOUL (NumLoopsArg, NULL, 0);
-
-    if (!NumThreads || !NumLoops)
-    {
-        AcpiOsPrintf ("Bad argument: Threads %X, Loops %X\n",
-            NumThreads, NumLoops);
-        return;
-    }
-
-    /*
-     * Create the semaphore for synchronization of
-     * the created threads with the main thread.
-     */
-    Status = AcpiOsCreateSemaphore (1, 0, &MainThreadGate);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could not create semaphore for synchronization with the main thread, %s\n",
-            AcpiFormatException (Status));
-        return;
-    }
-
-    /*
-     * Create the semaphore for synchronization
-     * between the created threads.
-     */
-    Status = AcpiOsCreateSemaphore (1, 1, &ThreadCompleteGate);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could not create semaphore for synchronization between the created threads, %s\n",
-            AcpiFormatException (Status));
-        (void) AcpiOsDeleteSemaphore (MainThreadGate);
-        return;
-    }
-
-    Status = AcpiOsCreateSemaphore (1, 1, &InfoGate);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could not create semaphore for synchronization of AcpiGbl_DbMethodInfo, %s\n",
-            AcpiFormatException (Status));
-        (void) AcpiOsDeleteSemaphore (ThreadCompleteGate);
-        (void) AcpiOsDeleteSemaphore (MainThreadGate);
-        return;
-    }
-
-    ACPI_MEMSET (&AcpiGbl_DbMethodInfo, 0, sizeof (ACPI_DB_METHOD_INFO));
-
-    /* Array to store IDs of threads */
-
-    AcpiGbl_DbMethodInfo.NumThreads = NumThreads;
-    Size = sizeof (ACPI_THREAD_ID) * AcpiGbl_DbMethodInfo.NumThreads;
-    AcpiGbl_DbMethodInfo.Threads = AcpiOsAllocate (Size);
-    if (AcpiGbl_DbMethodInfo.Threads == NULL)
-    {
-        AcpiOsPrintf ("No memory for thread IDs array\n");
-        (void) AcpiOsDeleteSemaphore (MainThreadGate);
-        (void) AcpiOsDeleteSemaphore (ThreadCompleteGate);
-        (void) AcpiOsDeleteSemaphore (InfoGate);
-        return;
-    }
-    ACPI_MEMSET (AcpiGbl_DbMethodInfo.Threads, 0, Size);
-
-    /* Setup the context to be passed to each thread */
-
-    AcpiGbl_DbMethodInfo.Name = MethodNameArg;
-    AcpiGbl_DbMethodInfo.Flags = 0;
-    AcpiGbl_DbMethodInfo.NumLoops = NumLoops;
-    AcpiGbl_DbMethodInfo.MainThreadGate = MainThreadGate;
-    AcpiGbl_DbMethodInfo.ThreadCompleteGate = ThreadCompleteGate;
-    AcpiGbl_DbMethodInfo.InfoGate = InfoGate;
-
-    /* Init arguments to be passed to method */
-
-    AcpiGbl_DbMethodInfo.InitArgs = 1;
-    AcpiGbl_DbMethodInfo.Args = AcpiGbl_DbMethodInfo.Arguments;
-    AcpiGbl_DbMethodInfo.Arguments[0] = AcpiGbl_DbMethodInfo.NumThreadsStr;
-    AcpiGbl_DbMethodInfo.Arguments[1] = AcpiGbl_DbMethodInfo.IdOfThreadStr;
-    AcpiGbl_DbMethodInfo.Arguments[2] = AcpiGbl_DbMethodInfo.IndexOfThreadStr;
-    AcpiGbl_DbMethodInfo.Arguments[3] = NULL;
-
-    AcpiGbl_DbMethodInfo.Types = AcpiGbl_DbMethodInfo.ArgTypes;
-    AcpiGbl_DbMethodInfo.ArgTypes[0] = ACPI_TYPE_INTEGER;
-    AcpiGbl_DbMethodInfo.ArgTypes[1] = ACPI_TYPE_INTEGER;
-    AcpiGbl_DbMethodInfo.ArgTypes[2] = ACPI_TYPE_INTEGER;
-
-    AcpiDbUInt32ToHexString (NumThreads, AcpiGbl_DbMethodInfo.NumThreadsStr);
-
-    AcpiDbExecuteSetup (&AcpiGbl_DbMethodInfo);
-
-    /* Create the threads */
-
-    AcpiOsPrintf ("Creating %X threads to execute %X times each\n",
-        NumThreads, NumLoops);
-
-    for (i = 0; i < (NumThreads); i++)
-    {
-        Status = AcpiOsExecute (OSL_DEBUGGER_THREAD, AcpiDbMethodThread,
-            &AcpiGbl_DbMethodInfo);
-        if (ACPI_FAILURE (Status))
-        {
-            break;
-        }
-    }
-
-    /* Wait for all threads to complete */
-
-    (void) AcpiOsWaitSemaphore (MainThreadGate, 1, ACPI_WAIT_FOREVER);
-
-    AcpiDbSetOutputDestination (ACPI_DB_DUPLICATE_OUTPUT);
-    AcpiOsPrintf ("All threads (%X) have completed\n", NumThreads);
-    AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-
-    /* Cleanup and exit */
-
-    (void) AcpiOsDeleteSemaphore (MainThreadGate);
-    (void) AcpiOsDeleteSemaphore (ThreadCompleteGate);
-    (void) AcpiOsDeleteSemaphore (InfoGate);
-
-    AcpiOsFree (AcpiGbl_DbMethodInfo.Threads);
-    AcpiGbl_DbMethodInfo.Threads = NULL;
-}
-
-#endif /* ACPI_DEBUGGER */
-
-
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbfileio.c b/usr/src/uts/intel/io/acpica/debugger/dbfileio.c
deleted file mode 100644
index ef9b7fef53..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbfileio.c
+++ /dev/null
@@ -1,578 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbfileio - Debugger file I/O commands. These can't usually
- *              be used when running the debugger in Ring 0 (Kernel mode)
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acdebug.h"
-
-#ifdef ACPI_APPLICATION
-#include "actables.h"
-#endif
-
-#if (defined ACPI_DEBUGGER || defined ACPI_DISASSEMBLER)
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbfileio")
-
-/*
- * NOTE: this is here for lack of a better place. It is used in all
- * flavors of the debugger, need LCD file
- */
-#ifdef ACPI_APPLICATION
-#include <stdio.h>
-FILE                        *AcpiGbl_DebugFile = NULL;
-#endif
-
-
-#ifdef ACPI_DEBUGGER
-
-/* Local prototypes */
-
-#ifdef ACPI_APPLICATION
-
-static ACPI_STATUS
-AcpiDbCheckTextModeCorruption (
-    UINT8                   *Table,
-    UINT32                  TableLength,
-    UINT32                  FileLength);
-
-#endif
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbCloseDebugFile
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: If open, close the current debug output file
- *
- ******************************************************************************/
-
-void
-AcpiDbCloseDebugFile (
-    void)
-{
-
-#ifdef ACPI_APPLICATION
-
-    if (AcpiGbl_DebugFile)
-    {
-       fclose (AcpiGbl_DebugFile);
-       AcpiGbl_DebugFile = NULL;
-       AcpiGbl_DbOutputToFile = FALSE;
-       AcpiOsPrintf ("Debug output file %s closed\n", AcpiGbl_DbDebugFilename);
-    }
-#endif
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbOpenDebugFile
- *
- * PARAMETERS:  Name                - Filename to open
- *
- * RETURN:      None
- *
- * DESCRIPTION: Open a file where debug output will be directed.
- *
- ******************************************************************************/
-
-void
-AcpiDbOpenDebugFile (
-    char                    *Name)
-{
-
-#ifdef ACPI_APPLICATION
-
-    AcpiDbCloseDebugFile ();
-    AcpiGbl_DebugFile = fopen (Name, "w+");
-    if (AcpiGbl_DebugFile)
-    {
-        AcpiOsPrintf ("Debug output file %s opened\n", Name);
-        ACPI_STRCPY (AcpiGbl_DbDebugFilename, Name);
-        AcpiGbl_DbOutputToFile = TRUE;
-    }
-    else
-    {
-        AcpiOsPrintf ("Could not open debug file %s\n", Name);
-    }
-
-#endif
-}
-#endif
-
-
-#ifdef ACPI_APPLICATION
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbCheckTextModeCorruption
- *
- * PARAMETERS:  Table           - Table buffer
- *              TableLength     - Length of table from the table header
- *              FileLength      - Length of the file that contains the table
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Check table for text mode file corruption where all linefeed
- *              characters (LF) have been replaced by carriage return linefeed
- *              pairs (CR/LF).
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbCheckTextModeCorruption (
-    UINT8                   *Table,
-    UINT32                  TableLength,
-    UINT32                  FileLength)
-{
-    UINT32                  i;
-    UINT32                  Pairs = 0;
-
-
-    if (TableLength != FileLength)
-    {
-        ACPI_WARNING ((AE_INFO,
-            "File length (0x%X) is not the same as the table length (0x%X)",
-            FileLength, TableLength));
-    }
-
-    /* Scan entire table to determine if each LF has been prefixed with a CR */
-
-    for (i = 1; i < FileLength; i++)
-    {
-        if (Table[i] == 0x0A)
-        {
-            if (Table[i - 1] != 0x0D)
-            {
-                /* The LF does not have a preceding CR, table not corrupted */
-
-                return (AE_OK);
-            }
-            else
-            {
-                /* Found a CR/LF pair */
-
-                Pairs++;
-            }
-            i++;
-        }
-    }
-
-    if (!Pairs)
-    {
-        return (AE_OK);
-    }
-
-    /*
-     * Entire table scanned, each CR is part of a CR/LF pair --
-     * meaning that the table was treated as a text file somewhere.
-     *
-     * NOTE: We can't "fix" the table, because any existing CR/LF pairs in the
-     * original table are left untouched by the text conversion process --
-     * meaning that we cannot simply replace CR/LF pairs with LFs.
-     */
-    AcpiOsPrintf ("Table has been corrupted by text mode conversion\n");
-    AcpiOsPrintf ("All LFs (%u) were changed to CR/LF pairs\n", Pairs);
-    AcpiOsPrintf ("Table cannot be repaired!\n");
-    return (AE_BAD_VALUE);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbReadTable
- *
- * PARAMETERS:  fp              - File that contains table
- *              Table           - Return value, buffer with table
- *              TableLength     - Return value, length of table
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Load the DSDT from the file pointer
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbReadTable (
-    FILE                    *fp,
-    ACPI_TABLE_HEADER       **Table,
-    UINT32                  *TableLength)
-{
-    ACPI_TABLE_HEADER       TableHeader;
-    UINT32                  Actual;
-    ACPI_STATUS             Status;
-    UINT32                  FileSize;
-    BOOLEAN                 StandardHeader = TRUE;
-
-
-    /* Get the file size */
-
-    fseek (fp, 0, SEEK_END);
-    FileSize = (UINT32) ftell (fp);
-    fseek (fp, 0, SEEK_SET);
-
-    if (FileSize < 4)
-    {
-        return (AE_BAD_HEADER);
-    }
-
-    /* Read the signature */
-
-    if (fread (&TableHeader, 1, 4, fp) != 4)
-    {
-        AcpiOsPrintf ("Could not read the table signature\n");
-        return (AE_BAD_HEADER);
-    }
-
-    fseek (fp, 0, SEEK_SET);
-
-    /* The RSDT, FACS and S3PT tables do not have standard ACPI headers */
-
-    if (ACPI_COMPARE_NAME (TableHeader.Signature, "RSD ") ||
-        ACPI_COMPARE_NAME (TableHeader.Signature, "FACS") ||
-        ACPI_COMPARE_NAME (TableHeader.Signature, "S3PT"))
-    {
-        *TableLength = FileSize;
-        StandardHeader = FALSE;
-    }
-    else
-    {
-        /* Read the table header */
-
-        if (fread (&TableHeader, 1, sizeof (TableHeader), fp) !=
-                sizeof (ACPI_TABLE_HEADER))
-        {
-            AcpiOsPrintf ("Could not read the table header\n");
-            return (AE_BAD_HEADER);
-        }
-
-#if 0
-        /* Validate the table header/length */
-
-        Status = AcpiTbValidateTableHeader (&TableHeader);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Table header is invalid!\n");
-            return (Status);
-        }
-#endif
-
-        /* File size must be at least as long as the Header-specified length */
-
-        if (TableHeader.Length > FileSize)
-        {
-            AcpiOsPrintf (
-                "TableHeader length [0x%X] greater than the input file size [0x%X]\n",
-                TableHeader.Length, FileSize);
-            return (AE_BAD_HEADER);
-        }
-
-#ifdef ACPI_OBSOLETE_CODE
-        /* We only support a limited number of table types */
-
-        if (ACPI_STRNCMP ((char *) TableHeader.Signature, DSDT_SIG, 4) &&
-            ACPI_STRNCMP ((char *) TableHeader.Signature, PSDT_SIG, 4) &&
-            ACPI_STRNCMP ((char *) TableHeader.Signature, SSDT_SIG, 4))
-        {
-            AcpiOsPrintf ("Table signature [%4.4s] is invalid or not supported\n",
-                (char *) TableHeader.Signature);
-            ACPI_DUMP_BUFFER (&TableHeader, sizeof (ACPI_TABLE_HEADER));
-            return (AE_ERROR);
-        }
-#endif
-
-        *TableLength = TableHeader.Length;
-    }
-
-    /* Allocate a buffer for the table */
-
-    *Table = AcpiOsAllocate ((size_t) FileSize);
-    if (!*Table)
-    {
-        AcpiOsPrintf (
-            "Could not allocate memory for ACPI table %4.4s (size=0x%X)\n",
-            TableHeader.Signature, *TableLength);
-        return (AE_NO_MEMORY);
-    }
-
-    /* Get the rest of the table */
-
-    fseek (fp, 0, SEEK_SET);
-    Actual = fread (*Table, 1, (size_t) FileSize, fp);
-    if (Actual == FileSize)
-    {
-        if (StandardHeader)
-        {
-            /* Now validate the checksum */
-
-            Status = AcpiTbVerifyChecksum ((void *) *Table,
-                        ACPI_CAST_PTR (ACPI_TABLE_HEADER, *Table)->Length);
-
-            if (Status == AE_BAD_CHECKSUM)
-            {
-                Status = AcpiDbCheckTextModeCorruption ((UINT8 *) *Table,
-                            FileSize, (*Table)->Length);
-                return (Status);
-            }
-        }
-        return (AE_OK);
-    }
-
-    if (Actual > 0)
-    {
-        AcpiOsPrintf ("Warning - reading table, asked for %X got %X\n",
-            FileSize, Actual);
-        return (AE_OK);
-    }
-
-    AcpiOsPrintf ("Error - could not read the table file\n");
-    AcpiOsFree (*Table);
-    *Table = NULL;
-    *TableLength = 0;
-
-    return (AE_ERROR);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AeLocalLoadTable
- *
- * PARAMETERS:  Table           - pointer to a buffer containing the entire
- *                                table to be loaded
- *
- * RETURN:      Status
- *
- * DESCRIPTION: This function is called to load a table from the caller's
- *              buffer. The buffer must contain an entire ACPI Table including
- *              a valid header. The header fields will be verified, and if it
- *              is determined that the table is invalid, the call will fail.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AeLocalLoadTable (
-    ACPI_TABLE_HEADER       *Table)
-{
-    ACPI_STATUS             Status = AE_OK;
-/*    ACPI_TABLE_DESC         TableInfo; */
-
-
-    ACPI_FUNCTION_TRACE (AeLocalLoadTable);
-#if 0
-
-
-    if (!Table)
-    {
-        return_ACPI_STATUS (AE_BAD_PARAMETER);
-    }
-
-    TableInfo.Pointer = Table;
-    Status = AcpiTbRecognizeTable (&TableInfo, ACPI_TABLE_ALL);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Install the new table into the local data structures */
-
-    Status = AcpiTbInstallTable (&TableInfo);
-    if (ACPI_FAILURE (Status))
-    {
-        if (Status == AE_ALREADY_EXISTS)
-        {
-            /* Table already exists, no error */
-
-            Status = AE_OK;
-        }
-
-        /* Free table allocated by AcpiTbGetTable */
-
-        AcpiTbDeleteSingleTable (&TableInfo);
-        return_ACPI_STATUS (Status);
-    }
-
-#if (!defined (ACPI_NO_METHOD_EXECUTION) && !defined (ACPI_CONSTANT_EVAL_ONLY))
-
-    Status = AcpiNsLoadTable (TableInfo.InstalledDesc, AcpiGbl_RootNode);
-    if (ACPI_FAILURE (Status))
-    {
-        /* Uninstall table and free the buffer */
-
-        AcpiTbDeleteTablesByType (ACPI_TABLE_ID_DSDT);
-        return_ACPI_STATUS (Status);
-    }
-#endif
-#endif
-
-    return_ACPI_STATUS (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbReadTableFromFile
- *
- * PARAMETERS:  Filename         - File where table is located
- *              Table            - Where a pointer to the table is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Get an ACPI table from a file
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbReadTableFromFile (
-    char                    *Filename,
-    ACPI_TABLE_HEADER       **Table)
-{
-    FILE                    *fp;
-    UINT32                  TableLength;
-    ACPI_STATUS             Status;
-
-
-    /* Open the file */
-
-    fp = fopen (Filename, "rb");
-    if (!fp)
-    {
-        AcpiOsPrintf ("Could not open input file %s\n", Filename);
-        return (AE_ERROR);
-    }
-
-    /* Get the entire file */
-
-    fprintf (stderr, "Loading Acpi table from file %s\n", Filename);
-    Status = AcpiDbReadTable (fp, Table, &TableLength);
-    fclose(fp);
-
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could not get table from the file\n");
-        return (Status);
-    }
-
-    return (AE_OK);
- }
-#endif
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbGetTableFromFile
- *
- * PARAMETERS:  Filename        - File where table is located
- *              ReturnTable     - Where a pointer to the table is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Load an ACPI table from a file
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbGetTableFromFile (
-    char                    *Filename,
-    ACPI_TABLE_HEADER       **ReturnTable)
-{
-#ifdef ACPI_APPLICATION
-    ACPI_STATUS             Status;
-    ACPI_TABLE_HEADER       *Table;
-    BOOLEAN                 IsAmlTable = TRUE;
-
-
-    Status = AcpiDbReadTableFromFile (Filename, &Table);
-    if (ACPI_FAILURE (Status))
-    {
-        return (Status);
-    }
-
-#ifdef ACPI_DATA_TABLE_DISASSEMBLY
-    IsAmlTable = AcpiUtIsAmlTable (Table);
-#endif
-
-    if (IsAmlTable)
-    {
-        /* Attempt to recognize and install the table */
-
-        Status = AeLocalLoadTable (Table);
-        if (ACPI_FAILURE (Status))
-        {
-            if (Status == AE_ALREADY_EXISTS)
-            {
-                AcpiOsPrintf ("Table %4.4s is already installed\n",
-                    Table->Signature);
-            }
-            else
-            {
-                AcpiOsPrintf ("Could not install table, %s\n",
-                    AcpiFormatException (Status));
-            }
-
-            return (Status);
-        }
-
-        fprintf (stderr,
-            "Acpi table [%4.4s] successfully installed and loaded\n",
-            Table->Signature);
-    }
-
-    AcpiGbl_AcpiHardwarePresent = FALSE;
-    if (ReturnTable)
-    {
-        *ReturnTable = Table;
-    }
-
-
-#endif  /* ACPI_APPLICATION */
-    return (AE_OK);
-}
-
-#endif  /* ACPI_DEBUGGER */
-
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbhistry.c b/usr/src/uts/intel/io/acpica/debugger/dbhistry.c
deleted file mode 100644
index 536b69cdfa..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbhistry.c
+++ /dev/null
@@ -1,220 +0,0 @@
-/******************************************************************************
- *
- * Module Name: dbhistry - debugger HISTORY command
- *
- *****************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acdebug.h"
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbhistry")
-
-
-#define HI_NO_HISTORY       0
-#define HI_RECORD_HISTORY   1
-#define HISTORY_SIZE        20
-
-
-typedef struct HistoryInfo
-{
-    char                    Command[80];
-    UINT32                  CmdNum;
-
-} HISTORY_INFO;
-
-
-static HISTORY_INFO         AcpiGbl_HistoryBuffer[HISTORY_SIZE];
-static UINT16               AcpiGbl_LoHistory = 0;
-static UINT16               AcpiGbl_NumHistory = 0;
-static UINT16               AcpiGbl_NextHistoryIndex = 0;
-static UINT32               AcpiGbl_NextCmdNum = 1;
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbAddToHistory
- *
- * PARAMETERS:  CommandLine     - Command to add
- *
- * RETURN:      None
- *
- * DESCRIPTION: Add a command line to the history buffer.
- *
- ******************************************************************************/
-
-void
-AcpiDbAddToHistory (
-    char                    *CommandLine)
-{
-
-    /* Put command into the next available slot */
-
-    ACPI_STRCPY (AcpiGbl_HistoryBuffer[AcpiGbl_NextHistoryIndex].Command,
-        CommandLine);
-
-    AcpiGbl_HistoryBuffer[AcpiGbl_NextHistoryIndex].CmdNum = AcpiGbl_NextCmdNum;
-
-    /* Adjust indexes */
-
-    if ((AcpiGbl_NumHistory == HISTORY_SIZE) &&
-        (AcpiGbl_NextHistoryIndex == AcpiGbl_LoHistory))
-    {
-        AcpiGbl_LoHistory++;
-        if (AcpiGbl_LoHistory >= HISTORY_SIZE)
-        {
-            AcpiGbl_LoHistory = 0;
-        }
-    }
-
-    AcpiGbl_NextHistoryIndex++;
-    if (AcpiGbl_NextHistoryIndex >= HISTORY_SIZE)
-    {
-        AcpiGbl_NextHistoryIndex = 0;
-    }
-
-    AcpiGbl_NextCmdNum++;
-    if (AcpiGbl_NumHistory < HISTORY_SIZE)
-    {
-        AcpiGbl_NumHistory++;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayHistory
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display the contents of the history buffer
- *
- ******************************************************************************/
-
-void
-AcpiDbDisplayHistory (
-    void)
-{
-    UINT32                  i;
-    UINT16                  HistoryIndex;
-
-
-    HistoryIndex = AcpiGbl_LoHistory;
-
-    /* Dump entire history buffer */
-
-    for (i = 0; i < AcpiGbl_NumHistory; i++)
-    {
-        AcpiOsPrintf ("%ld  %s\n", AcpiGbl_HistoryBuffer[HistoryIndex].CmdNum,
-                                   AcpiGbl_HistoryBuffer[HistoryIndex].Command);
-
-        HistoryIndex++;
-        if (HistoryIndex >= HISTORY_SIZE)
-        {
-            HistoryIndex = 0;
-        }
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbGetFromHistory
- *
- * PARAMETERS:  CommandNumArg           - String containing the number of the
- *                                        command to be retrieved
- *
- * RETURN:      Pointer to the retrieved command. Null on error.
- *
- * DESCRIPTION: Get a command from the history buffer
- *
- ******************************************************************************/
-
-char *
-AcpiDbGetFromHistory (
-    char                    *CommandNumArg)
-{
-    UINT32                  i;
-    UINT16                  HistoryIndex;
-    UINT32                  CmdNum;
-
-
-    if (CommandNumArg == NULL)
-    {
-        CmdNum = AcpiGbl_NextCmdNum - 1;
-    }
-
-    else
-    {
-        CmdNum = ACPI_STRTOUL (CommandNumArg, NULL, 0);
-    }
-
-    /* Search history buffer */
-
-    HistoryIndex = AcpiGbl_LoHistory;
-    for (i = 0; i < AcpiGbl_NumHistory; i++)
-    {
-        if (AcpiGbl_HistoryBuffer[HistoryIndex].CmdNum == CmdNum)
-        {
-            /* Found the commnad, return it */
-
-            return (AcpiGbl_HistoryBuffer[HistoryIndex].Command);
-        }
-
-
-        HistoryIndex++;
-        if (HistoryIndex >= HISTORY_SIZE)
-        {
-            HistoryIndex = 0;
-        }
-    }
-
-    AcpiOsPrintf ("Invalid history number: %u\n", HistoryIndex);
-    return (NULL);
-}
-
-#endif /* ACPI_DEBUGGER */
-
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbinput.c b/usr/src/uts/intel/io/acpica/debugger/dbinput.c
deleted file mode 100644
index 0ae313934b..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbinput.c
+++ /dev/null
@@ -1,1091 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbinput - user front-end to the AML debugger
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acdebug.h"
-
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbinput")
-
-/* Local prototypes */
-
-static UINT32
-AcpiDbGetLine (
-    char                    *InputBuffer);
-
-static UINT32
-AcpiDbMatchCommand (
-    char                    *UserCommand);
-
-static void
-AcpiDbSingleThread (
-    void);
-
-static void
-AcpiDbDisplayHelp (
-    void);
-
-
-/*
- * Top-level debugger commands.
- *
- * This list of commands must match the string table below it
- */
-enum AcpiExDebuggerCommands
-{
-    CMD_NOT_FOUND = 0,
-    CMD_NULL,
-    CMD_ALLOCATIONS,
-    CMD_ARGS,
-    CMD_ARGUMENTS,
-    CMD_BATCH,
-    CMD_BREAKPOINT,
-    CMD_BUSINFO,
-    CMD_CALL,
-    CMD_CLOSE,
-    CMD_DEBUG,
-    CMD_DISASSEMBLE,
-    CMD_DUMP,
-    CMD_ENABLEACPI,
-    CMD_EVENT,
-    CMD_EXECUTE,
-    CMD_EXIT,
-    CMD_FIND,
-    CMD_GO,
-    CMD_GPE,
-    CMD_GPES,
-    CMD_HANDLERS,
-    CMD_HELP,
-    CMD_HELP2,
-    CMD_HISTORY,
-    CMD_HISTORY_EXE,
-    CMD_HISTORY_LAST,
-    CMD_INFORMATION,
-    CMD_INTEGRITY,
-    CMD_INTO,
-    CMD_LEVEL,
-    CMD_LIST,
-    CMD_LOAD,
-    CMD_LOCALS,
-    CMD_LOCKS,
-    CMD_METHODS,
-    CMD_NAMESPACE,
-    CMD_NOTIFY,
-    CMD_OBJECT,
-    CMD_OPEN,
-    CMD_OSI,
-    CMD_OWNER,
-    CMD_PREDEFINED,
-    CMD_PREFIX,
-    CMD_QUIT,
-    CMD_REFERENCES,
-    CMD_RESOURCES,
-    CMD_RESULTS,
-    CMD_SET,
-    CMD_SLEEP,
-    CMD_STATS,
-    CMD_STOP,
-    CMD_TABLES,
-    CMD_TEMPLATE,
-    CMD_TERMINATE,
-    CMD_THREADS,
-    CMD_TRACE,
-    CMD_TREE,
-    CMD_TYPE,
-    CMD_UNLOAD
-};
-
-#define CMD_FIRST_VALID     2
-
-
-/* Second parameter is the required argument count */
-
-static const COMMAND_INFO       AcpiGbl_DbCommands[] =
-{
-    {"<NOT FOUND>",  0},
-    {"<NULL>",       0},
-    {"ALLOCATIONS",  0},
-    {"ARGS",         0},
-    {"ARGUMENTS",    0},
-    {"BATCH",        0},
-    {"BREAKPOINT",   1},
-    {"BUSINFO",      0},
-    {"CALL",         0},
-    {"CLOSE",        0},
-    {"DEBUG",        1},
-    {"DISASSEMBLE",  1},
-    {"DUMP",         1},
-    {"ENABLEACPI",   0},
-    {"EVENT",        1},
-    {"EXECUTE",      1},
-    {"EXIT",         0},
-    {"FIND",         1},
-    {"GO",           0},
-    {"GPE",          2},
-    {"GPES",         0},
-    {"HANDLERS",     0},
-    {"HELP",         0},
-    {"?",            0},
-    {"HISTORY",      0},
-    {"!",            1},
-    {"!!",           0},
-    {"INFORMATION",  0},
-    {"INTEGRITY",    0},
-    {"INTO",         0},
-    {"LEVEL",        0},
-    {"LIST",         0},
-    {"LOAD",         1},
-    {"LOCALS",       0},
-    {"LOCKS",        0},
-    {"METHODS",      0},
-    {"NAMESPACE",    0},
-    {"NOTIFY",       2},
-    {"OBJECT",       1},
-    {"OPEN",         1},
-    {"OSI",          0},
-    {"OWNER",        1},
-    {"PREDEFINED",   0},
-    {"PREFIX",       0},
-    {"QUIT",         0},
-    {"REFERENCES",   1},
-    {"RESOURCES",    1},
-    {"RESULTS",      0},
-    {"SET",          3},
-    {"SLEEP",        1},
-    {"STATS",        0},
-    {"STOP",         0},
-    {"TABLES",       0},
-    {"TEMPLATE",     1},
-    {"TERMINATE",    0},
-    {"THREADS",      3},
-    {"TRACE",        1},
-    {"TREE",         0},
-    {"TYPE",         1},
-    {"UNLOAD",       1},
-    {NULL,           0}
-};
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayHelp
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print a usage message.
- *
- ******************************************************************************/
-
-static void
-AcpiDbDisplayHelp (
-    void)
-{
-
-    AcpiOsPrintf ("\nGeneral-Purpose Commands:\n");
-    AcpiOsPrintf ("  Allocations                         Display list of current memory allocations\n");
-    AcpiOsPrintf ("  Dump <Address>|<Namepath>\n");
-    AcpiOsPrintf ("       [Byte|Word|Dword|Qword]        Display ACPI objects or memory\n");
-    AcpiOsPrintf ("  EnableAcpi                          Enable ACPI (hardware) mode\n");
-    AcpiOsPrintf ("  Handlers                            Info about global handlers\n");
-    AcpiOsPrintf ("  Help                                This help screen\n");
-    AcpiOsPrintf ("  History                             Display command history buffer\n");
-    AcpiOsPrintf ("  Level [<DebugLevel>] [console]      Get/Set debug level for file or console\n");
-    AcpiOsPrintf ("  Locks                               Current status of internal mutexes\n");
-    AcpiOsPrintf ("  Osi [Install|Remove <name>]         Display or modify global _OSI list\n");
-    AcpiOsPrintf ("  Quit or Exit                        Exit this command\n");
-    AcpiOsPrintf ("  Stats [Allocations|Memory|Misc|\n");
-    AcpiOsPrintf ("        Objects|Sizes|Stack|Tables]   Display namespace and memory statistics\n");
-    AcpiOsPrintf ("     Allocations                      Display list of current memory allocations\n");
-    AcpiOsPrintf ("     Memory                           Dump internal memory lists\n");
-    AcpiOsPrintf ("     Misc                             Namespace search and mutex stats\n");
-    AcpiOsPrintf ("     Objects                          Summary of namespace objects\n");
-    AcpiOsPrintf ("     Sizes                            Sizes for each of the internal objects\n");
-    AcpiOsPrintf ("     Stack                            Display CPU stack usage\n");
-    AcpiOsPrintf ("     Tables                           Info about current ACPI table(s)\n");
-    AcpiOsPrintf ("  Tables                              Display info about loaded ACPI tables\n");
-    AcpiOsPrintf ("  Unload <TableSig> [Instance]        Unload an ACPI table\n");
-    AcpiOsPrintf ("  ! <CommandNumber>                   Execute command from history buffer\n");
-    AcpiOsPrintf ("  !!                                  Execute last command again\n");
-
-    AcpiOsPrintf ("\nNamespace Access Commands:\n");
-    AcpiOsPrintf ("  Businfo                             Display system bus info\n");
-    AcpiOsPrintf ("  Disassemble <Method>                Disassemble a control method\n");
-    AcpiOsPrintf ("  Event <F|G> <Value>                 Generate AcpiEvent (Fixed/GPE)\n");
-    AcpiOsPrintf ("  Find <AcpiName>  (? is wildcard)    Find ACPI name(s) with wildcards\n");
-    AcpiOsPrintf ("  Gpe <GpeNum> <GpeBlock>             Simulate a GPE\n");
-    AcpiOsPrintf ("  Gpes                                Display info on all GPEs\n");
-    AcpiOsPrintf ("  Integrity                           Validate namespace integrity\n");
-    AcpiOsPrintf ("  Methods                             Display list of loaded control methods\n");
-    AcpiOsPrintf ("  Namespace [Object] [Depth]          Display loaded namespace tree/subtree\n");
-    AcpiOsPrintf ("  Notify <Object> <Value>             Send a notification on Object\n");
-    AcpiOsPrintf ("  Objects <ObjectType>                Display all objects of the given type\n");
-    AcpiOsPrintf ("  Owner <OwnerId> [Depth]             Display loaded namespace by object owner\n");
-    AcpiOsPrintf ("  Predefined                          Check all predefined names\n");
-    AcpiOsPrintf ("  Prefix [<NamePath>]                 Set or Get current execution prefix\n");
-    AcpiOsPrintf ("  References <Addr>                   Find all references to object at addr\n");
-    AcpiOsPrintf ("  Resources <DeviceName | *>          Display Device resources (* = all devices)\n");
-    AcpiOsPrintf ("  Set N <NamedObject> <Value>         Set value for named integer\n");
-    AcpiOsPrintf ("  Sleep <SleepState>                  Simulate sleep/wake sequence\n");
-    AcpiOsPrintf ("  Template <Object>                   Format/dump a Buffer/ResourceTemplate\n");
-    AcpiOsPrintf ("  Terminate                           Delete namespace and all internal objects\n");
-    AcpiOsPrintf ("  Type <Object>                       Display object type\n");
-
-    AcpiOsPrintf ("\nControl Method Execution Commands:\n");
-    AcpiOsPrintf ("  Arguments (or Args)                 Display method arguments\n");
-    AcpiOsPrintf ("  Breakpoint <AmlOffset>              Set an AML execution breakpoint\n");
-    AcpiOsPrintf ("  Call                                Run to next control method invocation\n");
-    AcpiOsPrintf ("  Debug <Namepath> [Arguments]        Single Step a control method\n");
-    AcpiOsPrintf ("  Execute <Namepath> [Arguments]      Execute control method\n");
-    AcpiOsPrintf ("     Hex Integer                      Integer method argument\n");
-    AcpiOsPrintf ("     \"Ascii String\"                   String method argument\n");
-    AcpiOsPrintf ("     (Byte List)                      Buffer method argument\n");
-    AcpiOsPrintf ("     [Package Element List]           Package method argument\n");
-    AcpiOsPrintf ("  Go                                  Allow method to run to completion\n");
-    AcpiOsPrintf ("  Information                         Display info about the current method\n");
-    AcpiOsPrintf ("  Into                                Step into (not over) a method call\n");
-    AcpiOsPrintf ("  List [# of Aml Opcodes]             Display method ASL statements\n");
-    AcpiOsPrintf ("  Locals                              Display method local variables\n");
-    AcpiOsPrintf ("  Results                             Display method result stack\n");
-    AcpiOsPrintf ("  Set <A|L> <#> <Value>               Set method data (Arguments/Locals)\n");
-    AcpiOsPrintf ("  Stop                                Terminate control method\n");
-    AcpiOsPrintf ("  Thread <Threads><Loops><NamePath>   Spawn threads to execute method(s)\n");
-    AcpiOsPrintf ("  Trace <method name>                 Trace method execution\n");
-    AcpiOsPrintf ("  Tree                                Display control method calling tree\n");
-    AcpiOsPrintf ("  <Enter>                             Single step next AML opcode (over calls)\n");
-
-    AcpiOsPrintf ("\nFile I/O Commands:\n");
-    AcpiOsPrintf ("  Close                               Close debug output file\n");
-    AcpiOsPrintf ("  Load <Input Filename>               Load ACPI table from a file\n");
-    AcpiOsPrintf ("  Open <Output Filename>              Open a file for debug output\n");
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbGetNextToken
- *
- * PARAMETERS:  String          - Command buffer
- *              Next            - Return value, end of next token
- *
- * RETURN:      Pointer to the start of the next token.
- *
- * DESCRIPTION: Command line parsing.  Get the next token on the command line
- *
- ******************************************************************************/
-
-char *
-AcpiDbGetNextToken (
-    char                    *String,
-    char                    **Next,
-    ACPI_OBJECT_TYPE        *ReturnType)
-{
-    char                    *Start;
-    UINT32                  Depth;
-    ACPI_OBJECT_TYPE        Type = ACPI_TYPE_INTEGER;
-
-
-    /* At end of buffer? */
-
-    if (!String || !(*String))
-    {
-        return (NULL);
-    }
-
-    /* Remove any spaces at the beginning */
-
-    if (*String == ' ')
-    {
-        while (*String && (*String == ' '))
-        {
-            String++;
-        }
-
-        if (!(*String))
-        {
-            return (NULL);
-        }
-    }
-
-    switch (*String)
-    {
-    case '"':
-
-        /* This is a quoted string, scan until closing quote */
-
-        String++;
-        Start = String;
-        Type = ACPI_TYPE_STRING;
-
-        /* Find end of string */
-
-        while (*String && (*String != '"'))
-        {
-            String++;
-        }
-        break;
-
-    case '(':
-
-        /* This is the start of a buffer, scan until closing paren */
-
-        String++;
-        Start = String;
-        Type = ACPI_TYPE_BUFFER;
-
-        /* Find end of buffer */
-
-        while (*String && (*String != ')'))
-        {
-            String++;
-        }
-        break;
-
-    case '[':
-
-        /* This is the start of a package, scan until closing bracket */
-
-        String++;
-        Depth = 1;
-        Start = String;
-        Type = ACPI_TYPE_PACKAGE;
-
-        /* Find end of package (closing bracket) */
-
-        while (*String)
-        {
-            /* Handle String package elements */
-
-            if (*String == '"')
-            {
-                /* Find end of string */
-
-                String++;
-                while (*String && (*String != '"'))
-                {
-                    String++;
-                }
-                if (!(*String))
-                {
-                    break;
-                }
-            }
-            else if (*String == '[')
-            {
-                Depth++;         /* A nested package declaration */
-            }
-            else if (*String == ']')
-            {
-                Depth--;
-                if (Depth == 0) /* Found final package closing bracket */
-                {
-                    break;
-                }
-            }
-
-            String++;
-        }
-        break;
-
-    default:
-
-        Start = String;
-
-        /* Find end of token */
-
-        while (*String && (*String != ' '))
-        {
-            String++;
-        }
-        break;
-    }
-
-    if (!(*String))
-    {
-        *Next = NULL;
-    }
-    else
-    {
-        *String = 0;
-        *Next = String + 1;
-    }
-
-    *ReturnType = Type;
-    return (Start);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbGetLine
- *
- * PARAMETERS:  InputBuffer         - Command line buffer
- *
- * RETURN:      Count of arguments to the command
- *
- * DESCRIPTION: Get the next command line from the user.  Gets entire line
- *              up to the next newline
- *
- ******************************************************************************/
-
-static UINT32
-AcpiDbGetLine (
-    char                    *InputBuffer)
-{
-    UINT32                  i;
-    UINT32                  Count;
-    char                    *Next;
-    char                    *This;
-
-
-    ACPI_STRCPY (AcpiGbl_DbParsedBuf, InputBuffer);
-
-    This = AcpiGbl_DbParsedBuf;
-    for (i = 0; i < ACPI_DEBUGGER_MAX_ARGS; i++)
-    {
-        AcpiGbl_DbArgs[i] = AcpiDbGetNextToken (This, &Next,
-            &AcpiGbl_DbArgTypes[i]);
-        if (!AcpiGbl_DbArgs[i])
-        {
-            break;
-        }
-
-        This = Next;
-    }
-
-    /* Uppercase the actual command */
-
-    if (AcpiGbl_DbArgs[0])
-    {
-        AcpiUtStrupr (AcpiGbl_DbArgs[0]);
-    }
-
-    Count = i;
-    if (Count)
-    {
-        Count--;  /* Number of args only */
-    }
-
-    return (Count);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbMatchCommand
- *
- * PARAMETERS:  UserCommand             - User command line
- *
- * RETURN:      Index into command array, -1 if not found
- *
- * DESCRIPTION: Search command array for a command match
- *
- ******************************************************************************/
-
-static UINT32
-AcpiDbMatchCommand (
-    char                    *UserCommand)
-{
-    UINT32                  i;
-
-
-    if (!UserCommand || UserCommand[0] == 0)
-    {
-        return (CMD_NULL);
-    }
-
-    for (i = CMD_FIRST_VALID; AcpiGbl_DbCommands[i].Name; i++)
-    {
-        if (ACPI_STRSTR (AcpiGbl_DbCommands[i].Name, UserCommand) ==
-                         AcpiGbl_DbCommands[i].Name)
-        {
-            return (i);
-        }
-    }
-
-    /* Command not recognized */
-
-    return (CMD_NOT_FOUND);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbCommandDispatch
- *
- * PARAMETERS:  InputBuffer         - Command line buffer
- *              WalkState           - Current walk
- *              Op                  - Current (executing) parse op
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Command dispatcher.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbCommandDispatch (
-    char                    *InputBuffer,
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       *Op)
-{
-    UINT32                  Temp;
-    UINT32                  CommandIndex;
-    UINT32                  ParamCount;
-    char                    *CommandLine;
-    ACPI_STATUS             Status = AE_CTRL_TRUE;
-
-
-    /* If AcpiTerminate has been called, terminate this thread */
-
-    if (AcpiGbl_DbTerminateThreads)
-    {
-        return (AE_CTRL_TERMINATE);
-    }
-
-    ParamCount = AcpiDbGetLine (InputBuffer);
-    CommandIndex = AcpiDbMatchCommand (AcpiGbl_DbArgs[0]);
-    Temp = 0;
-
-    /* Verify that we have the minimum number of params */
-
-    if (ParamCount < AcpiGbl_DbCommands[CommandIndex].MinArgs)
-    {
-        AcpiOsPrintf ("%u parameters entered, [%s] requires %u parameters\n",
-            ParamCount, AcpiGbl_DbCommands[CommandIndex].Name,
-            AcpiGbl_DbCommands[CommandIndex].MinArgs);
-
-        return (AE_CTRL_TRUE);
-    }
-
-    /* Decode and dispatch the command */
-
-    switch (CommandIndex)
-    {
-    case CMD_NULL:
-        if (Op)
-        {
-            return (AE_OK);
-        }
-        break;
-
-    case CMD_ALLOCATIONS:
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-        AcpiUtDumpAllocations ((UINT32) -1, NULL);
-#endif
-        break;
-
-    case CMD_ARGS:
-    case CMD_ARGUMENTS:
-        AcpiDbDisplayArguments ();
-        break;
-
-    case CMD_BATCH:
-        AcpiDbBatchExecute (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_BREAKPOINT:
-        AcpiDbSetMethodBreakpoint (AcpiGbl_DbArgs[1], WalkState, Op);
-        break;
-
-    case CMD_BUSINFO:
-        AcpiDbGetBusInfo ();
-        break;
-
-    case CMD_CALL:
-        AcpiDbSetMethodCallBreakpoint (Op);
-        Status = AE_OK;
-        break;
-
-    case CMD_CLOSE:
-        AcpiDbCloseDebugFile ();
-        break;
-
-    case CMD_DEBUG:
-        AcpiDbExecute (AcpiGbl_DbArgs[1],
-            &AcpiGbl_DbArgs[2], &AcpiGbl_DbArgTypes[2], EX_SINGLE_STEP);
-        break;
-
-    case CMD_DISASSEMBLE:
-        (void) AcpiDbDisassembleMethod (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_DUMP:
-        AcpiDbDecodeAndDisplayObject (AcpiGbl_DbArgs[1], AcpiGbl_DbArgs[2]);
-        break;
-
-    case CMD_ENABLEACPI:
-#if (!ACPI_REDUCED_HARDWARE)
-
-        Status = AcpiEnable();
-        if (ACPI_FAILURE(Status))
-        {
-            AcpiOsPrintf("AcpiEnable failed (Status=%X)\n", Status);
-            return (Status);
-        }
-#endif /* !ACPI_REDUCED_HARDWARE */
-        break;
-
-    case CMD_EVENT:
-        AcpiOsPrintf ("Event command not implemented\n");
-        break;
-
-    case CMD_EXECUTE:
-        AcpiDbExecute (AcpiGbl_DbArgs[1],
-            &AcpiGbl_DbArgs[2], &AcpiGbl_DbArgTypes[2], EX_NO_SINGLE_STEP);
-        break;
-
-    case CMD_FIND:
-        Status = AcpiDbFindNameInNamespace (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_GO:
-        AcpiGbl_CmSingleStep = FALSE;
-        return (AE_OK);
-
-    case CMD_GPE:
-        AcpiDbGenerateGpe (AcpiGbl_DbArgs[1], AcpiGbl_DbArgs[2]);
-        break;
-
-    case CMD_GPES:
-        AcpiDbDisplayGpes ();
-        break;
-
-    case CMD_HANDLERS:
-        AcpiDbDisplayHandlers ();
-        break;
-
-    case CMD_HELP:
-    case CMD_HELP2:
-        AcpiDbDisplayHelp ();
-        break;
-
-    case CMD_HISTORY:
-        AcpiDbDisplayHistory ();
-        break;
-
-    case CMD_HISTORY_EXE:
-        CommandLine = AcpiDbGetFromHistory (AcpiGbl_DbArgs[1]);
-        if (!CommandLine)
-        {
-            return (AE_CTRL_TRUE);
-        }
-
-        Status = AcpiDbCommandDispatch (CommandLine, WalkState, Op);
-        return (Status);
-
-    case CMD_HISTORY_LAST:
-        CommandLine = AcpiDbGetFromHistory (NULL);
-        if (!CommandLine)
-        {
-            return (AE_CTRL_TRUE);
-        }
-
-        Status = AcpiDbCommandDispatch (CommandLine, WalkState, Op);
-        return (Status);
-
-    case CMD_INFORMATION:
-        AcpiDbDisplayMethodInfo (Op);
-        break;
-
-    case CMD_INTEGRITY:
-        AcpiDbCheckIntegrity ();
-        break;
-
-    case CMD_INTO:
-        if (Op)
-        {
-            AcpiGbl_CmSingleStep = TRUE;
-            return (AE_OK);
-        }
-        break;
-
-    case CMD_LEVEL:
-        if (ParamCount == 0)
-        {
-            AcpiOsPrintf ("Current debug level for file output is:    %8.8lX\n",
-                AcpiGbl_DbDebugLevel);
-            AcpiOsPrintf ("Current debug level for console output is: %8.8lX\n",
-                AcpiGbl_DbConsoleDebugLevel);
-        }
-        else if (ParamCount == 2)
-        {
-            Temp = AcpiGbl_DbConsoleDebugLevel;
-            AcpiGbl_DbConsoleDebugLevel = ACPI_STRTOUL (AcpiGbl_DbArgs[1],
-                                            NULL, 16);
-            AcpiOsPrintf (
-                "Debug Level for console output was %8.8lX, now %8.8lX\n",
-                Temp, AcpiGbl_DbConsoleDebugLevel);
-        }
-        else
-        {
-            Temp = AcpiGbl_DbDebugLevel;
-            AcpiGbl_DbDebugLevel = ACPI_STRTOUL (AcpiGbl_DbArgs[1], NULL, 16);
-            AcpiOsPrintf (
-                "Debug Level for file output was %8.8lX, now %8.8lX\n",
-                Temp, AcpiGbl_DbDebugLevel);
-        }
-        break;
-
-    case CMD_LIST:
-        AcpiDbDisassembleAml (AcpiGbl_DbArgs[1], Op);
-        break;
-
-    case CMD_LOAD:
-        Status = AcpiDbGetTableFromFile (AcpiGbl_DbArgs[1], NULL);
-        break;
-
-    case CMD_LOCKS:
-        AcpiDbDisplayLocks ();
-        break;
-
-    case CMD_LOCALS:
-        AcpiDbDisplayLocals ();
-        break;
-
-    case CMD_METHODS:
-        Status = AcpiDbDisplayObjects ("METHOD", AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_NAMESPACE:
-        AcpiDbDumpNamespace (AcpiGbl_DbArgs[1], AcpiGbl_DbArgs[2]);
-        break;
-
-    case CMD_NOTIFY:
-        Temp = ACPI_STRTOUL (AcpiGbl_DbArgs[2], NULL, 0);
-        AcpiDbSendNotify (AcpiGbl_DbArgs[1], Temp);
-        break;
-
-    case CMD_OBJECT:
-        AcpiUtStrupr (AcpiGbl_DbArgs[1]);
-        Status = AcpiDbDisplayObjects (AcpiGbl_DbArgs[1], AcpiGbl_DbArgs[2]);
-        break;
-
-    case CMD_OPEN:
-        AcpiDbOpenDebugFile (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_OSI:
-        AcpiDbDisplayInterfaces (AcpiGbl_DbArgs[1], AcpiGbl_DbArgs[2]);
-        break;
-
-    case CMD_OWNER:
-        AcpiDbDumpNamespaceByOwner (AcpiGbl_DbArgs[1], AcpiGbl_DbArgs[2]);
-        break;
-
-    case CMD_PREDEFINED:
-        AcpiDbCheckPredefinedNames ();
-        break;
-
-    case CMD_PREFIX:
-        AcpiDbSetScope (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_REFERENCES:
-        AcpiDbFindReferences (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_RESOURCES:
-        AcpiDbDisplayResources (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_RESULTS:
-        AcpiDbDisplayResults ();
-        break;
-
-    case CMD_SET:
-        AcpiDbSetMethodData (AcpiGbl_DbArgs[1], AcpiGbl_DbArgs[2],
-            AcpiGbl_DbArgs[3]);
-        break;
-
-    case CMD_SLEEP:
-        Status = AcpiDbSleep (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_STATS:
-        Status = AcpiDbDisplayStatistics (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_STOP:
-        return (AE_NOT_IMPLEMENTED);
-
-    case CMD_TABLES:
-        AcpiDbDisplayTableInfo (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_TEMPLATE:
-        AcpiDbDisplayTemplate (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_TERMINATE:
-        AcpiDbSetOutputDestination (ACPI_DB_REDIRECTABLE_OUTPUT);
-        AcpiUtSubsystemShutdown ();
-
-        /*
-         * TBD: [Restructure] Need some way to re-initialize without
-         * re-creating the semaphores!
-         */
-
-        /*  AcpiInitialize (NULL);  */
-        break;
-
-    case CMD_THREADS:
-        AcpiDbCreateExecutionThreads (AcpiGbl_DbArgs[1], AcpiGbl_DbArgs[2],
-            AcpiGbl_DbArgs[3]);
-        break;
-
-    case CMD_TRACE:
-        (void) AcpiDebugTrace (AcpiGbl_DbArgs[1],0,0,1);
-        break;
-
-    case CMD_TREE:
-        AcpiDbDisplayCallingTree ();
-        break;
-
-    case CMD_TYPE:
-        AcpiDbDisplayObjectType (AcpiGbl_DbArgs[1]);
-        break;
-
-    case CMD_UNLOAD:
-        AcpiDbUnloadAcpiTable (AcpiGbl_DbArgs[1], AcpiGbl_DbArgs[2]);
-        break;
-
-    case CMD_EXIT:
-    case CMD_QUIT:
-        if (Op)
-        {
-            AcpiOsPrintf ("Method execution terminated\n");
-            return (AE_CTRL_TERMINATE);
-        }
-
-        if (!AcpiGbl_DbOutputToFile)
-        {
-            AcpiDbgLevel = ACPI_DEBUG_DEFAULT;
-        }
-
-        AcpiDbCloseDebugFile ();
-        AcpiGbl_DbTerminateThreads = TRUE;
-        return (AE_CTRL_TERMINATE);
-
-    case CMD_NOT_FOUND:
-    default:
-        AcpiOsPrintf ("Unknown Command\n");
-        return (AE_CTRL_TRUE);
-    }
-
-    if (ACPI_SUCCESS (Status))
-    {
-        Status = AE_CTRL_TRUE;
-    }
-
-    /* Add all commands that come here to the history buffer */
-
-    AcpiDbAddToHistory (InputBuffer);
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbExecuteThread
- *
- * PARAMETERS:  Context         - Not used
- *
- * RETURN:      None
- *
- * DESCRIPTION: Debugger execute thread.  Waits for a command line, then
- *              simply dispatches it.
- *
- ******************************************************************************/
-
-void ACPI_SYSTEM_XFACE
-AcpiDbExecuteThread (
-    void                    *Context)
-{
-    ACPI_STATUS             Status = AE_OK;
-    ACPI_STATUS             MStatus;
-
-
-    while (Status != AE_CTRL_TERMINATE)
-    {
-        AcpiGbl_MethodExecuting = FALSE;
-        AcpiGbl_StepToNextCall = FALSE;
-
-        MStatus = AcpiUtAcquireMutex (ACPI_MTX_DEBUG_CMD_READY);
-        if (ACPI_FAILURE (MStatus))
-        {
-            return;
-        }
-
-        Status = AcpiDbCommandDispatch (AcpiGbl_DbLineBuf, NULL, NULL);
-
-        MStatus = AcpiUtReleaseMutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
-        if (ACPI_FAILURE (MStatus))
-        {
-            return;
-        }
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSingleThread
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Debugger execute thread.  Waits for a command line, then
- *              simply dispatches it.
- *
- ******************************************************************************/
-
-static void
-AcpiDbSingleThread (
-    void)
-{
-
-    AcpiGbl_MethodExecuting = FALSE;
-    AcpiGbl_StepToNextCall = FALSE;
-
-    (void) AcpiDbCommandDispatch (AcpiGbl_DbLineBuf, NULL, NULL);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbUserCommands
- *
- * PARAMETERS:  Prompt              - User prompt (depends on mode)
- *              Op                  - Current executing parse op
- *
- * RETURN:      None
- *
- * DESCRIPTION: Command line execution for the AML debugger.  Commands are
- *              matched and dispatched here.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbUserCommands (
-    char                    Prompt,
-    ACPI_PARSE_OBJECT       *Op)
-{
-    ACPI_STATUS             Status = AE_OK;
-
-
-    /* TBD: [Restructure] Need a separate command line buffer for step mode */
-
-    while (!AcpiGbl_DbTerminateThreads)
-    {
-        /* Force output to console until a command is entered */
-
-        AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-
-        /* Different prompt if method is executing */
-
-        if (!AcpiGbl_MethodExecuting)
-        {
-            AcpiOsPrintf ("%1c ", ACPI_DEBUGGER_COMMAND_PROMPT);
-        }
-        else
-        {
-            AcpiOsPrintf ("%1c ", ACPI_DEBUGGER_EXECUTE_PROMPT);
-        }
-
-        /* Get the user input line */
-
-        Status = AcpiOsGetLine (AcpiGbl_DbLineBuf,
-            ACPI_DB_LINE_BUFFER_SIZE, NULL);
-        if (ACPI_FAILURE (Status))
-        {
-            ACPI_EXCEPTION ((AE_INFO, Status, "While parsing command line"));
-            return (Status);
-        }
-
-        /* Check for single or multithreaded debug */
-
-        if (AcpiGbl_DebuggerConfiguration & DEBUGGER_MULTI_THREADED)
-        {
-            /*
-             * Signal the debug thread that we have a command to execute,
-             * and wait for the command to complete.
-             */
-            Status = AcpiUtReleaseMutex (ACPI_MTX_DEBUG_CMD_READY);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-
-            Status = AcpiUtAcquireMutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-        }
-        else
-        {
-            /* Just call to the command line interpreter */
-
-            AcpiDbSingleThread ();
-        }
-    }
-
-    /*
-     * Only this thread (the original thread) should actually terminate the
-     * subsystem, because all the semaphores are deleted during termination
-     */
-    Status = AcpiTerminate ();
-    return (Status);
-}
-
-#endif  /* ACPI_DEBUGGER */
-
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbmethod.c b/usr/src/uts/intel/io/acpica/debugger/dbmethod.c
deleted file mode 100644
index 0d45d68150..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbmethod.c
+++ /dev/null
@@ -1,525 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbmethod - Debug commands for control methods
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acdispat.h"
-#include "acnamesp.h"
-#include "acdebug.h"
-#include "acdisasm.h"
-#include "acparser.h"
-
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbmethod")
-
-
-/* Local prototypes */
-
-static ACPI_STATUS
-AcpiDbWalkForExecute (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSetMethodBreakpoint
- *
- * PARAMETERS:  Location            - AML offset of breakpoint
- *              WalkState           - Current walk info
- *              Op                  - Current Op (from parse walk)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Set a breakpoint in a control method at the specified
- *              AML offset
- *
- ******************************************************************************/
-
-void
-AcpiDbSetMethodBreakpoint (
-    char                    *Location,
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       *Op)
-{
-    UINT32                  Address;
-
-
-    if (!Op)
-    {
-        AcpiOsPrintf ("There is no method currently executing\n");
-        return;
-    }
-
-    /* Get and verify the breakpoint address */
-
-    Address = ACPI_STRTOUL (Location, NULL, 16);
-    if (Address <= Op->Common.AmlOffset)
-    {
-        AcpiOsPrintf ("Breakpoint %X is beyond current address %X\n",
-            Address, Op->Common.AmlOffset);
-    }
-
-    /* Save breakpoint in current walk */
-
-    WalkState->UserBreakpoint = Address;
-    AcpiOsPrintf ("Breakpoint set at AML offset %X\n", Address);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSetMethodCallBreakpoint
- *
- * PARAMETERS:  Op                  - Current Op (from parse walk)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Set a breakpoint in a control method at the specified
- *              AML offset
- *
- ******************************************************************************/
-
-void
-AcpiDbSetMethodCallBreakpoint (
-    ACPI_PARSE_OBJECT       *Op)
-{
-
-
-    if (!Op)
-    {
-        AcpiOsPrintf ("There is no method currently executing\n");
-        return;
-    }
-
-    AcpiGbl_StepToNextCall = TRUE;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSetMethodData
- *
- * PARAMETERS:  TypeArg         - L for local, A for argument
- *              IndexArg        - which one
- *              ValueArg        - Value to set.
- *
- * RETURN:      None
- *
- * DESCRIPTION: Set a local or argument for the running control method.
- *              NOTE: only object supported is Number.
- *
- ******************************************************************************/
-
-void
-AcpiDbSetMethodData (
-    char                    *TypeArg,
-    char                    *IndexArg,
-    char                    *ValueArg)
-{
-    char                    Type;
-    UINT32                  Index;
-    UINT32                  Value;
-    ACPI_WALK_STATE         *WalkState;
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_STATUS             Status;
-    ACPI_NAMESPACE_NODE     *Node;
-
-
-    /* Validate TypeArg */
-
-    AcpiUtStrupr (TypeArg);
-    Type = TypeArg[0];
-    if ((Type != 'L') &&
-        (Type != 'A') &&
-        (Type != 'N'))
-    {
-        AcpiOsPrintf ("Invalid SET operand: %s\n", TypeArg);
-        return;
-    }
-
-    Value = ACPI_STRTOUL (ValueArg, NULL, 16);
-
-    if (Type == 'N')
-    {
-        Node = AcpiDbConvertToNode (IndexArg);
-        if (Node->Type != ACPI_TYPE_INTEGER)
-        {
-            AcpiOsPrintf ("Can only set Integer nodes\n");
-            return;
-        }
-        ObjDesc = Node->Object;
-        ObjDesc->Integer.Value = Value;
-        return;
-    }
-
-    /* Get the index and value */
-
-    Index = ACPI_STRTOUL (IndexArg, NULL, 16);
-
-    WalkState = AcpiDsGetCurrentWalkState (AcpiGbl_CurrentWalkList);
-    if (!WalkState)
-    {
-        AcpiOsPrintf ("There is no method currently executing\n");
-        return;
-    }
-
-    /* Create and initialize the new object */
-
-    ObjDesc = AcpiUtCreateIntegerObject ((UINT64) Value);
-    if (!ObjDesc)
-    {
-        AcpiOsPrintf ("Could not create an internal object\n");
-        return;
-    }
-
-    /* Store the new object into the target */
-
-    switch (Type)
-    {
-    case 'A':
-
-        /* Set a method argument */
-
-        if (Index > ACPI_METHOD_MAX_ARG)
-        {
-            AcpiOsPrintf ("Arg%u - Invalid argument name\n", Index);
-            goto Cleanup;
-        }
-
-        Status = AcpiDsStoreObjectToLocal (ACPI_REFCLASS_ARG, Index, ObjDesc,
-                    WalkState);
-        if (ACPI_FAILURE (Status))
-        {
-            goto Cleanup;
-        }
-
-        ObjDesc = WalkState->Arguments[Index].Object;
-
-        AcpiOsPrintf ("Arg%u: ", Index);
-        AcpiDmDisplayInternalObject (ObjDesc, WalkState);
-        break;
-
-    case 'L':
-
-        /* Set a method local */
-
-        if (Index > ACPI_METHOD_MAX_LOCAL)
-        {
-            AcpiOsPrintf ("Local%u - Invalid local variable name\n", Index);
-            goto Cleanup;
-        }
-
-        Status = AcpiDsStoreObjectToLocal (ACPI_REFCLASS_LOCAL, Index, ObjDesc,
-                    WalkState);
-        if (ACPI_FAILURE (Status))
-        {
-            goto Cleanup;
-        }
-
-        ObjDesc = WalkState->LocalVariables[Index].Object;
-
-        AcpiOsPrintf ("Local%u: ", Index);
-        AcpiDmDisplayInternalObject (ObjDesc, WalkState);
-        break;
-
-    default:
-        break;
-    }
-
-Cleanup:
-    AcpiUtRemoveReference (ObjDesc);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisassembleAml
- *
- * PARAMETERS:  Statements          - Number of statements to disassemble
- *              Op                  - Current Op (from parse walk)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display disassembled AML (ASL) starting from Op for the number
- *              of statements specified.
- *
- ******************************************************************************/
-
-void
-AcpiDbDisassembleAml (
-    char                    *Statements,
-    ACPI_PARSE_OBJECT       *Op)
-{
-    UINT32                  NumStatements = 8;
-
-
-    if (!Op)
-    {
-        AcpiOsPrintf ("There is no method currently executing\n");
-        return;
-    }
-
-    if (Statements)
-    {
-        NumStatements = ACPI_STRTOUL (Statements, NULL, 0);
-    }
-
-    AcpiDmDisassemble (NULL, Op, NumStatements);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisassembleMethod
- *
- * PARAMETERS:  Name            - Name of control method
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display disassembled AML (ASL) starting from Op for the number
- *              of statements specified.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbDisassembleMethod (
-    char                    *Name)
-{
-    ACPI_STATUS             Status;
-    ACPI_PARSE_OBJECT       *Op;
-    ACPI_WALK_STATE         *WalkState;
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_NAMESPACE_NODE     *Method;
-
-
-    Method = AcpiDbConvertToNode (Name);
-    if (!Method)
-    {
-        return (AE_BAD_PARAMETER);
-    }
-
-    ObjDesc = Method->Object;
-
-    Op = AcpiPsCreateScopeOp ();
-    if (!Op)
-    {
-        return (AE_NO_MEMORY);
-    }
-
-    /* Create and initialize a new walk state */
-
-    WalkState = AcpiDsCreateWalkState (0, Op, NULL, NULL);
-    if (!WalkState)
-    {
-        return (AE_NO_MEMORY);
-    }
-
-    Status = AcpiDsInitAmlWalk (WalkState, Op, NULL,
-                    ObjDesc->Method.AmlStart,
-                    ObjDesc->Method.AmlLength, NULL, ACPI_IMODE_LOAD_PASS1);
-    if (ACPI_FAILURE (Status))
-    {
-        return (Status);
-    }
-
-    /* Parse the AML */
-
-    WalkState->ParseFlags &= ~ACPI_PARSE_DELETE_TREE;
-    WalkState->ParseFlags |= ACPI_PARSE_DISASSEMBLE;
-    Status = AcpiPsParseAml (WalkState);
-
-    AcpiDmDisassemble (NULL, Op, 0);
-    AcpiPsDeleteParseTree (Op);
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbWalkForExecute
- *
- * PARAMETERS:  Callback from WalkNamespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Batch execution module. Currently only executes predefined
- *              ACPI names.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbWalkForExecute (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_NAMESPACE_NODE     *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
-    ACPI_EXECUTE_WALK       *Info = (ACPI_EXECUTE_WALK *) Context;
-    ACPI_BUFFER             ReturnObj;
-    ACPI_STATUS             Status;
-    char                    *Pathname;
-    UINT32                  i;
-    ACPI_DEVICE_INFO        *ObjInfo;
-    ACPI_OBJECT_LIST        ParamObjects;
-    ACPI_OBJECT             Params[ACPI_METHOD_NUM_ARGS];
-    const ACPI_PREDEFINED_INFO *Predefined;
-
-
-    Predefined = AcpiNsCheckForPredefinedName (Node);
-    if (!Predefined)
-    {
-        return (AE_OK);
-    }
-
-    if (Node->Type == ACPI_TYPE_LOCAL_SCOPE)
-    {
-        return (AE_OK);
-    }
-
-    Pathname = AcpiNsGetExternalPathname (Node);
-    if (!Pathname)
-    {
-        return (AE_OK);
-    }
-
-    /* Get the object info for number of method parameters */
-
-    Status = AcpiGetObjectInfo (ObjHandle, &ObjInfo);
-    if (ACPI_FAILURE (Status))
-    {
-        return (Status);
-    }
-
-    ParamObjects.Pointer = NULL;
-    ParamObjects.Count   = 0;
-
-    if (ObjInfo->Type == ACPI_TYPE_METHOD)
-    {
-        /* Setup default parameters */
-
-        for (i = 0; i < ObjInfo->ParamCount; i++)
-        {
-            Params[i].Type           = ACPI_TYPE_INTEGER;
-            Params[i].Integer.Value  = 1;
-        }
-
-        ParamObjects.Pointer     = Params;
-        ParamObjects.Count       = ObjInfo->ParamCount;
-    }
-
-    ACPI_FREE (ObjInfo);
-    ReturnObj.Pointer = NULL;
-    ReturnObj.Length = ACPI_ALLOCATE_BUFFER;
-
-    /* Do the actual method execution */
-
-    AcpiGbl_MethodExecuting = TRUE;
-
-    Status = AcpiEvaluateObject (Node, NULL, &ParamObjects, &ReturnObj);
-
-    AcpiOsPrintf ("%-32s returned %s\n", Pathname, AcpiFormatException (Status));
-    AcpiGbl_MethodExecuting = FALSE;
-    ACPI_FREE (Pathname);
-
-    /* Ignore status from method execution */
-
-    Status = AE_OK;
-
-    /* Update count, check if we have executed enough methods */
-
-    Info->Count++;
-    if (Info->Count >= Info->MaxCount)
-    {
-        Status = AE_CTRL_TERMINATE;
-    }
-
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbBatchExecute
- *
- * PARAMETERS:  CountArg            - Max number of methods to execute
- *
- * RETURN:      None
- *
- * DESCRIPTION: Namespace batch execution. Execute predefined names in the
- *              namespace, up to the max count, if specified.
- *
- ******************************************************************************/
-
-void
-AcpiDbBatchExecute (
-    char                    *CountArg)
-{
-    ACPI_EXECUTE_WALK       Info;
-
-
-    Info.Count = 0;
-    Info.MaxCount = ACPI_UINT32_MAX;
-
-    if (CountArg)
-    {
-        Info.MaxCount = ACPI_STRTOUL (CountArg, NULL, 0);
-    }
-
-
-    /* Search all nodes in namespace */
-
-    (void) AcpiWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-                AcpiDbWalkForExecute, NULL, (void *) &Info, NULL);
-
-    AcpiOsPrintf ("Executed %u predefined names in the namespace\n", Info.Count);
-}
-
-#endif /* ACPI_DEBUGGER */
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbnames.c b/usr/src/uts/intel/io/acpica/debugger/dbnames.c
deleted file mode 100644
index be326c5390..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbnames.c
+++ /dev/null
@@ -1,934 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbnames - Debugger commands for the acpi namespace
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acnamesp.h"
-#include "acdebug.h"
-
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbnames")
-
-
-/* Local prototypes */
-
-static ACPI_STATUS
-AcpiDbWalkAndMatchName (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-static ACPI_STATUS
-AcpiDbWalkForPredefinedNames (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-static ACPI_STATUS
-AcpiDbWalkForSpecificObjects (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-static ACPI_STATUS
-AcpiDbIntegrityWalk (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-static ACPI_STATUS
-AcpiDbWalkForReferences (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-static ACPI_STATUS
-AcpiDbBusWalk (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-/*
- * Arguments for the Objects command
- * These object types map directly to the ACPI_TYPES
- */
-static ARGUMENT_INFO        AcpiDbObjectTypes [] =
-{
-    {"ANY"},
-    {"INTEGERS"},
-    {"STRINGS"},
-    {"BUFFERS"},
-    {"PACKAGES"},
-    {"FIELDS"},
-    {"DEVICES"},
-    {"EVENTS"},
-    {"METHODS"},
-    {"MUTEXES"},
-    {"REGIONS"},
-    {"POWERRESOURCES"},
-    {"PROCESSORS"},
-    {"THERMALZONES"},
-    {"BUFFERFIELDS"},
-    {"DDBHANDLES"},
-    {"DEBUG"},
-    {"REGIONFIELDS"},
-    {"BANKFIELDS"},
-    {"INDEXFIELDS"},
-    {"REFERENCES"},
-    {"ALIAS"},
-    {NULL}           /* Must be null terminated */
-};
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSetScope
- *
- * PARAMETERS:  Name                - New scope path
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Set the "current scope" as maintained by this utility.
- *              The scope is used as a prefix to ACPI paths.
- *
- ******************************************************************************/
-
-void
-AcpiDbSetScope (
-    char                    *Name)
-{
-    ACPI_STATUS             Status;
-    ACPI_NAMESPACE_NODE     *Node;
-
-
-    if (!Name || Name[0] == 0)
-    {
-        AcpiOsPrintf ("Current scope: %s\n", AcpiGbl_DbScopeBuf);
-        return;
-    }
-
-    AcpiDbPrepNamestring (Name);
-
-    if (Name[0] == '\\')
-    {
-        /* Validate new scope from the root */
-
-        Status = AcpiNsGetNode (AcpiGbl_RootNode, Name, ACPI_NS_NO_UPSEARCH,
-                    &Node);
-        if (ACPI_FAILURE (Status))
-        {
-            goto ErrorExit;
-        }
-
-        ACPI_STRCPY (AcpiGbl_DbScopeBuf, Name);
-        ACPI_STRCAT (AcpiGbl_DbScopeBuf, "\\");
-    }
-    else
-    {
-        /* Validate new scope relative to old scope */
-
-        Status = AcpiNsGetNode (AcpiGbl_DbScopeNode, Name, ACPI_NS_NO_UPSEARCH,
-                    &Node);
-        if (ACPI_FAILURE (Status))
-        {
-            goto ErrorExit;
-        }
-
-        ACPI_STRCAT (AcpiGbl_DbScopeBuf, Name);
-        ACPI_STRCAT (AcpiGbl_DbScopeBuf, "\\");
-    }
-
-    AcpiGbl_DbScopeNode = Node;
-    AcpiOsPrintf ("New scope: %s\n", AcpiGbl_DbScopeBuf);
-    return;
-
-ErrorExit:
-
-    AcpiOsPrintf ("Could not attach scope: %s, %s\n",
-        Name, AcpiFormatException (Status));
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDumpNamespace
- *
- * PARAMETERS:  StartArg        - Node to begin namespace dump
- *              DepthArg        - Maximum tree depth to be dumped
- *
- * RETURN:      None
- *
- * DESCRIPTION: Dump entire namespace or a subtree.  Each node is displayed
- *              with type and other information.
- *
- ******************************************************************************/
-
-void
-AcpiDbDumpNamespace (
-    char                    *StartArg,
-    char                    *DepthArg)
-{
-    ACPI_HANDLE             SubtreeEntry = AcpiGbl_RootNode;
-    UINT32                  MaxDepth = ACPI_UINT32_MAX;
-
-
-    /* No argument given, just start at the root and dump entire namespace */
-
-    if (StartArg)
-    {
-        SubtreeEntry = AcpiDbConvertToNode (StartArg);
-        if (!SubtreeEntry)
-        {
-            return;
-        }
-
-        /* Now we can check for the depth argument */
-
-        if (DepthArg)
-        {
-            MaxDepth = ACPI_STRTOUL (DepthArg, NULL, 0);
-        }
-    }
-
-    AcpiDbSetOutputDestination (ACPI_DB_DUPLICATE_OUTPUT);
-    AcpiOsPrintf ("ACPI Namespace (from %4.4s (%p) subtree):\n",
-        ((ACPI_NAMESPACE_NODE *) SubtreeEntry)->Name.Ascii, SubtreeEntry);
-
-    /* Display the subtree */
-
-    AcpiDbSetOutputDestination (ACPI_DB_REDIRECTABLE_OUTPUT);
-    AcpiNsDumpObjects (ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY, MaxDepth,
-        ACPI_OWNER_ID_MAX, SubtreeEntry);
-    AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDumpNamespaceByOwner
- *
- * PARAMETERS:  OwnerArg        - Owner ID whose nodes will be displayed
- *              DepthArg        - Maximum tree depth to be dumped
- *
- * RETURN:      None
- *
- * DESCRIPTION: Dump elements of the namespace that are owned by the OwnerId.
- *
- ******************************************************************************/
-
-void
-AcpiDbDumpNamespaceByOwner (
-    char                    *OwnerArg,
-    char                    *DepthArg)
-{
-    ACPI_HANDLE             SubtreeEntry = AcpiGbl_RootNode;
-    UINT32                  MaxDepth = ACPI_UINT32_MAX;
-    ACPI_OWNER_ID           OwnerId;
-
-
-    OwnerId = (ACPI_OWNER_ID) ACPI_STRTOUL (OwnerArg, NULL, 0);
-
-    /* Now we can check for the depth argument */
-
-    if (DepthArg)
-    {
-        MaxDepth = ACPI_STRTOUL (DepthArg, NULL, 0);
-    }
-
-    AcpiDbSetOutputDestination (ACPI_DB_DUPLICATE_OUTPUT);
-    AcpiOsPrintf ("ACPI Namespace by owner %X:\n", OwnerId);
-
-    /* Display the subtree */
-
-    AcpiDbSetOutputDestination (ACPI_DB_REDIRECTABLE_OUTPUT);
-    AcpiNsDumpObjects (ACPI_TYPE_ANY, ACPI_DISPLAY_SUMMARY, MaxDepth, OwnerId,
-        SubtreeEntry);
-    AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbWalkAndMatchName
- *
- * PARAMETERS:  Callback from WalkNamespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Find a particular name/names within the namespace.  Wildcards
- *              are supported -- '?' matches any character.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbWalkAndMatchName (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_STATUS             Status;
-    char                    *RequestedName = (char *) Context;
-    UINT32                  i;
-    ACPI_BUFFER             Buffer;
-    ACPI_WALK_INFO          Info;
-
-
-    /* Check for a name match */
-
-    for (i = 0; i < 4; i++)
-    {
-        /* Wildcard support */
-
-        if ((RequestedName[i] != '?') &&
-            (RequestedName[i] != ((ACPI_NAMESPACE_NODE *) ObjHandle)->Name.Ascii[i]))
-        {
-            /* No match, just exit */
-
-            return (AE_OK);
-        }
-    }
-
-    /* Get the full pathname to this object */
-
-    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-    Status = AcpiNsHandleToPathname (ObjHandle, &Buffer);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could Not get pathname for object %p\n", ObjHandle);
-    }
-    else
-    {
-        Info.OwnerId = ACPI_OWNER_ID_MAX;
-        Info.DebugLevel = ACPI_UINT32_MAX;
-        Info.DisplayType = ACPI_DISPLAY_SUMMARY | ACPI_DISPLAY_SHORT;
-
-        AcpiOsPrintf ("%32s", (char *) Buffer.Pointer);
-        (void) AcpiNsDumpOneObject (ObjHandle, NestingLevel, &Info, NULL);
-        ACPI_FREE (Buffer.Pointer);
-    }
-
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbFindNameInNamespace
- *
- * PARAMETERS:  NameArg         - The 4-character ACPI name to find.
- *                                wildcards are supported.
- *
- * RETURN:      None
- *
- * DESCRIPTION: Search the namespace for a given name (with wildcards)
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbFindNameInNamespace (
-    char                    *NameArg)
-{
-    char                    AcpiName[5] = "____";
-    char                    *AcpiNamePtr = AcpiName;
-
-
-    if (ACPI_STRLEN (NameArg) > 4)
-    {
-        AcpiOsPrintf ("Name must be no longer than 4 characters\n");
-        return (AE_OK);
-    }
-
-    /* Pad out name with underscores as necessary to create a 4-char name */
-
-    AcpiUtStrupr (NameArg);
-    while (*NameArg)
-    {
-        *AcpiNamePtr = *NameArg;
-        AcpiNamePtr++;
-        NameArg++;
-    }
-
-    /* Walk the namespace from the root */
-
-    (void) AcpiWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-                        AcpiDbWalkAndMatchName, NULL, AcpiName, NULL);
-
-    AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbWalkForPredefinedNames
- *
- * PARAMETERS:  Callback from WalkNamespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Detect and display predefined ACPI names (names that start with
- *              an underscore)
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbWalkForPredefinedNames (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_NAMESPACE_NODE         *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
-    UINT32                      *Count = (UINT32 *) Context;
-    const ACPI_PREDEFINED_INFO  *Predefined;
-    const ACPI_PREDEFINED_INFO  *Package = NULL;
-    char                        *Pathname;
-
-
-    Predefined = AcpiNsCheckForPredefinedName (Node);
-    if (!Predefined)
-    {
-        return (AE_OK);
-    }
-
-    Pathname = AcpiNsGetExternalPathname (Node);
-    if (!Pathname)
-    {
-        return (AE_OK);
-    }
-
-    /* If method returns a package, the info is in the next table entry */
-
-    if (Predefined->Info.ExpectedBtypes & ACPI_BTYPE_PACKAGE)
-    {
-        Package = Predefined + 1;
-    }
-
-    AcpiOsPrintf ("%-32s arg %X ret %2.2X", Pathname,
-        Predefined->Info.ParamCount, Predefined->Info.ExpectedBtypes);
-
-    if (Package)
-    {
-        AcpiOsPrintf (" PkgType %2.2X ObjType %2.2X Count %2.2X",
-            Package->RetInfo.Type, Package->RetInfo.ObjectType1,
-            Package->RetInfo.Count1);
-    }
-
-    AcpiOsPrintf("\n");
-
-    AcpiNsCheckParameterCount (Pathname, Node, ACPI_UINT32_MAX, Predefined);
-    ACPI_FREE (Pathname);
-    (*Count)++;
-
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbCheckPredefinedNames
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Validate all predefined names in the namespace
- *
- ******************************************************************************/
-
-void
-AcpiDbCheckPredefinedNames (
-    void)
-{
-    UINT32                  Count = 0;
-
-
-    /* Search all nodes in namespace */
-
-    (void) AcpiWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-                AcpiDbWalkForPredefinedNames, NULL, (void *) &Count, NULL);
-
-    AcpiOsPrintf ("Found %u predefined names in the namespace\n", Count);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbWalkForSpecificObjects
- *
- * PARAMETERS:  Callback from WalkNamespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Display short info about objects in the namespace
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbWalkForSpecificObjects (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_WALK_INFO          *Info = (ACPI_WALK_INFO *) Context;
-    ACPI_BUFFER             Buffer;
-    ACPI_STATUS             Status;
-
-
-    Info->Count++;
-
-    /* Get and display the full pathname to this object */
-
-    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-    Status = AcpiNsHandleToPathname (ObjHandle, &Buffer);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could Not get pathname for object %p\n", ObjHandle);
-        return (AE_OK);
-    }
-
-    AcpiOsPrintf ("%32s", (char *) Buffer.Pointer);
-    ACPI_FREE (Buffer.Pointer);
-
-    /* Dump short info about the object */
-
-    (void) AcpiNsDumpOneObject (ObjHandle, NestingLevel, Info, NULL);
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayObjects
- *
- * PARAMETERS:  ObjTypeArg          - Type of object to display
- *              DisplayCountArg     - Max depth to display
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display objects in the namespace of the requested type
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbDisplayObjects (
-    char                    *ObjTypeArg,
-    char                    *DisplayCountArg)
-{
-    ACPI_WALK_INFO          Info;
-    ACPI_OBJECT_TYPE        Type;
-
-
-    /* Get the object type */
-
-    Type = AcpiDbMatchArgument (ObjTypeArg, AcpiDbObjectTypes);
-    if (Type == ACPI_TYPE_NOT_FOUND)
-    {
-        AcpiOsPrintf ("Invalid or unsupported argument\n");
-        return (AE_OK);
-    }
-
-    AcpiDbSetOutputDestination (ACPI_DB_DUPLICATE_OUTPUT);
-    AcpiOsPrintf (
-        "Objects of type [%s] defined in the current ACPI Namespace:\n",
-        AcpiUtGetTypeName (Type));
-
-    AcpiDbSetOutputDestination (ACPI_DB_REDIRECTABLE_OUTPUT);
-
-    Info.Count = 0;
-    Info.OwnerId = ACPI_OWNER_ID_MAX;
-    Info.DebugLevel = ACPI_UINT32_MAX;
-    Info.DisplayType = ACPI_DISPLAY_SUMMARY | ACPI_DISPLAY_SHORT;
-
-    /* Walk the namespace from the root */
-
-    (void) AcpiWalkNamespace (Type, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-                AcpiDbWalkForSpecificObjects, NULL, (void *) &Info, NULL);
-
-    AcpiOsPrintf (
-        "\nFound %u objects of type [%s] in the current ACPI Namespace\n",
-        Info.Count, AcpiUtGetTypeName (Type));
-
-    AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbIntegrityWalk
- *
- * PARAMETERS:  Callback from WalkNamespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Examine one NS node for valid values.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbIntegrityWalk (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_INTEGRITY_INFO     *Info = (ACPI_INTEGRITY_INFO *) Context;
-    ACPI_NAMESPACE_NODE     *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
-    ACPI_OPERAND_OBJECT     *Object;
-    BOOLEAN                 Alias = TRUE;
-
-
-    Info->Nodes++;
-
-    /* Verify the NS node, and dereference aliases */
-
-    while (Alias)
-    {
-        if (ACPI_GET_DESCRIPTOR_TYPE (Node) != ACPI_DESC_TYPE_NAMED)
-        {
-            AcpiOsPrintf ("Invalid Descriptor Type for Node %p [%s] - is %2.2X should be %2.2X\n",
-                Node, AcpiUtGetDescriptorName (Node), ACPI_GET_DESCRIPTOR_TYPE (Node),
-                ACPI_DESC_TYPE_NAMED);
-            return (AE_OK);
-        }
-
-        if ((Node->Type == ACPI_TYPE_LOCAL_ALIAS)  ||
-            (Node->Type == ACPI_TYPE_LOCAL_METHOD_ALIAS))
-        {
-            Node = (ACPI_NAMESPACE_NODE *) Node->Object;
-        }
-        else
-        {
-            Alias = FALSE;
-        }
-    }
-
-    if (Node->Type > ACPI_TYPE_LOCAL_MAX)
-    {
-        AcpiOsPrintf ("Invalid Object Type for Node %p, Type = %X\n",
-            Node, Node->Type);
-        return (AE_OK);
-    }
-
-    if (!AcpiUtValidAcpiName (Node->Name.Integer))
-    {
-        AcpiOsPrintf ("Invalid AcpiName for Node %p\n", Node);
-        return (AE_OK);
-    }
-
-    Object = AcpiNsGetAttachedObject (Node);
-    if (Object)
-    {
-        Info->Objects++;
-        if (ACPI_GET_DESCRIPTOR_TYPE (Object) != ACPI_DESC_TYPE_OPERAND)
-        {
-            AcpiOsPrintf ("Invalid Descriptor Type for Object %p [%s]\n",
-                Object, AcpiUtGetDescriptorName (Object));
-        }
-    }
-
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbCheckIntegrity
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Check entire namespace for data structure integrity
- *
- ******************************************************************************/
-
-void
-AcpiDbCheckIntegrity (
-    void)
-{
-    ACPI_INTEGRITY_INFO     Info = {0,0};
-
-    /* Search all nodes in namespace */
-
-    (void) AcpiWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-                    AcpiDbIntegrityWalk, NULL, (void *) &Info, NULL);
-
-    AcpiOsPrintf ("Verified %u namespace nodes with %u Objects\n",
-        Info.Nodes, Info.Objects);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbWalkForReferences
- *
- * PARAMETERS:  Callback from WalkNamespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Check if this namespace object refers to the target object
- *              that is passed in as the context value.
- *
- * Note: Currently doesn't check subobjects within the Node's object
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbWalkForReferences (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_OPERAND_OBJECT     *ObjDesc = (ACPI_OPERAND_OBJECT  *) Context;
-    ACPI_NAMESPACE_NODE     *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
-
-
-    /* Check for match against the namespace node itself */
-
-    if (Node == (void *) ObjDesc)
-    {
-        AcpiOsPrintf ("Object is a Node [%4.4s]\n",
-            AcpiUtGetNodeName (Node));
-    }
-
-    /* Check for match against the object attached to the node */
-
-    if (AcpiNsGetAttachedObject (Node) == ObjDesc)
-    {
-        AcpiOsPrintf ("Reference at Node->Object %p [%4.4s]\n",
-            Node, AcpiUtGetNodeName (Node));
-    }
-
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbFindReferences
- *
- * PARAMETERS:  ObjectArg       - String with hex value of the object
- *
- * RETURN:      None
- *
- * DESCRIPTION: Search namespace for all references to the input object
- *
- ******************************************************************************/
-
-void
-AcpiDbFindReferences (
-    char                    *ObjectArg)
-{
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-
-
-    /* Convert string to object pointer */
-
-    ObjDesc = ACPI_TO_POINTER (ACPI_STRTOUL (ObjectArg, NULL, 16));
-
-    /* Search all nodes in namespace */
-
-    (void) AcpiWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-                    AcpiDbWalkForReferences, NULL, (void *) ObjDesc, NULL);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbBusWalk
- *
- * PARAMETERS:  Callback from WalkNamespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Display info about device objects that have a corresponding
- *              _PRT method.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbBusWalk (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_NAMESPACE_NODE     *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
-    ACPI_STATUS             Status;
-    ACPI_BUFFER             Buffer;
-    ACPI_NAMESPACE_NODE     *TempNode;
-    ACPI_DEVICE_INFO        *Info;
-    UINT32                  i;
-
-
-    if ((Node->Type != ACPI_TYPE_DEVICE) &&
-        (Node->Type != ACPI_TYPE_PROCESSOR))
-    {
-        return (AE_OK);
-    }
-
-    /* Exit if there is no _PRT under this device */
-
-    Status = AcpiGetHandle (Node, METHOD_NAME__PRT,
-                ACPI_CAST_PTR (ACPI_HANDLE, &TempNode));
-    if (ACPI_FAILURE (Status))
-    {
-        return (AE_OK);
-    }
-
-    /* Get the full path to this device object */
-
-    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-    Status = AcpiNsHandleToPathname (ObjHandle, &Buffer);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could Not get pathname for object %p\n", ObjHandle);
-        return (AE_OK);
-    }
-
-    Status = AcpiGetObjectInfo (ObjHandle, &Info);
-    if (ACPI_FAILURE (Status))
-    {
-        return (AE_OK);
-    }
-
-    /* Display the full path */
-
-    AcpiOsPrintf ("%-32s Type %X", (char *) Buffer.Pointer, Node->Type);
-    ACPI_FREE (Buffer.Pointer);
-
-    if (Info->Flags & ACPI_PCI_ROOT_BRIDGE)
-    {
-        AcpiOsPrintf ("  - Is PCI Root Bridge");
-    }
-    AcpiOsPrintf ("\n");
-
-    /* _PRT info */
-
-    AcpiOsPrintf ("_PRT: %p\n", TempNode);
-
-    /* Dump _ADR, _HID, _UID, _CID */
-
-    if (Info->Valid & ACPI_VALID_ADR)
-    {
-        AcpiOsPrintf ("_ADR: %8.8X%8.8X\n", ACPI_FORMAT_UINT64 (Info->Address));
-    }
-    else
-    {
-        AcpiOsPrintf ("_ADR: <Not Present>\n");
-    }
-
-    if (Info->Valid & ACPI_VALID_HID)
-    {
-        AcpiOsPrintf ("_HID: %s\n", Info->HardwareId.String);
-    }
-    else
-    {
-        AcpiOsPrintf ("_HID: <Not Present>\n");
-    }
-
-    if (Info->Valid & ACPI_VALID_UID)
-    {
-        AcpiOsPrintf ("_UID: %s\n", Info->UniqueId.String);
-    }
-    else
-    {
-        AcpiOsPrintf ("_UID: <Not Present>\n");
-    }
-
-    if (Info->Valid & ACPI_VALID_CID)
-    {
-        for (i = 0; i < Info->CompatibleIdList.Count; i++)
-        {
-            AcpiOsPrintf ("_CID: %s\n",
-                Info->CompatibleIdList.Ids[i].String);
-        }
-    }
-    else
-    {
-        AcpiOsPrintf ("_CID: <Not Present>\n");
-    }
-
-    ACPI_FREE (Info);
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbGetBusInfo
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display info about system busses.
- *
- ******************************************************************************/
-
-void
-AcpiDbGetBusInfo (
-    void)
-{
-    /* Search all nodes in namespace */
-
-    (void) AcpiWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
-                    AcpiDbBusWalk, NULL, NULL, NULL);
-}
-
-#endif /* ACPI_DEBUGGER */
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbstats.c b/usr/src/uts/intel/io/acpica/debugger/dbstats.c
deleted file mode 100644
index fcc4998ede..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbstats.c
+++ /dev/null
@@ -1,561 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbstats - Generation and display of ACPI table statistics
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acdebug.h"
-#include "acnamesp.h"
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbstats")
-
-/* Local prototypes */
-
-static void
-AcpiDbCountNamespaceObjects (
-    void);
-
-static void
-AcpiDbEnumerateObject (
-    ACPI_OPERAND_OBJECT     *ObjDesc);
-
-static ACPI_STATUS
-AcpiDbClassifyOneObject (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue);
-
-#if defined ACPI_DBG_TRACK_ALLOCATIONS || defined ACPI_USE_LOCAL_CACHE
-static void
-AcpiDbListInfo (
-    ACPI_MEMORY_LIST        *List);
-#endif
-
-
-/*
- * Statistics subcommands
- */
-static ARGUMENT_INFO        AcpiDbStatTypes [] =
-{
-    {"ALLOCATIONS"},
-    {"OBJECTS"},
-    {"MEMORY"},
-    {"MISC"},
-    {"TABLES"},
-    {"SIZES"},
-    {"STACK"},
-    {NULL}           /* Must be null terminated */
-};
-
-#define CMD_STAT_ALLOCATIONS     0
-#define CMD_STAT_OBJECTS         1
-#define CMD_STAT_MEMORY          2
-#define CMD_STAT_MISC            3
-#define CMD_STAT_TABLES          4
-#define CMD_STAT_SIZES           5
-#define CMD_STAT_STACK           6
-
-
-#if defined ACPI_DBG_TRACK_ALLOCATIONS || defined ACPI_USE_LOCAL_CACHE
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbListInfo
- *
- * PARAMETERS:  List            - Memory list/cache to be displayed
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display information about the input memory list or cache.
- *
- ******************************************************************************/
-
-static void
-AcpiDbListInfo (
-    ACPI_MEMORY_LIST        *List)
-{
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-    UINT32                  Outstanding;
-#endif
-
-    AcpiOsPrintf ("\n%s\n", List->ListName);
-
-    /* MaxDepth > 0 indicates a cache object */
-
-    if (List->MaxDepth > 0)
-    {
-        AcpiOsPrintf (
-            "    Cache: [Depth    MaxD Avail  Size]                %8.2X %8.2X %8.2X %8.2X\n",
-            List->CurrentDepth,
-            List->MaxDepth,
-            List->MaxDepth - List->CurrentDepth,
-            (List->CurrentDepth * List->ObjectSize));
-    }
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-    if (List->MaxDepth > 0)
-    {
-        AcpiOsPrintf (
-            "    Cache: [Requests Hits Misses ObjSize]             %8.2X %8.2X %8.2X %8.2X\n",
-            List->Requests,
-            List->Hits,
-            List->Requests - List->Hits,
-            List->ObjectSize);
-    }
-
-    Outstanding = AcpiDbGetCacheInfo (List);
-
-    if (List->ObjectSize)
-    {
-        AcpiOsPrintf (
-            "    Mem:   [Alloc    Free Max    CurSize Outstanding] %8.2X %8.2X %8.2X %8.2X %8.2X\n",
-            List->TotalAllocated,
-            List->TotalFreed,
-            List->MaxOccupied,
-            Outstanding * List->ObjectSize,
-            Outstanding);
-    }
-    else
-    {
-        AcpiOsPrintf (
-            "    Mem:   [Alloc Free Max CurSize Outstanding Total] %8.2X %8.2X %8.2X %8.2X %8.2X %8.2X\n",
-            List->TotalAllocated,
-            List->TotalFreed,
-            List->MaxOccupied,
-            List->CurrentTotalSize,
-            Outstanding,
-            List->TotalSize);
-    }
-#endif
-}
-#endif
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbEnumerateObject
- *
- * PARAMETERS:  ObjDesc             - Object to be counted
- *
- * RETURN:      None
- *
- * DESCRIPTION: Add this object to the global counts, by object type.
- *              Limited recursion handles subobjects and packages, and this
- *              is probably acceptable within the AML debugger only.
- *
- ******************************************************************************/
-
-static void
-AcpiDbEnumerateObject (
-    ACPI_OPERAND_OBJECT     *ObjDesc)
-{
-    UINT32                  i;
-
-
-    if (!ObjDesc)
-    {
-        return;
-    }
-
-    /* Enumerate this object first */
-
-    AcpiGbl_NumObjects++;
-
-    if (ObjDesc->Common.Type > ACPI_TYPE_NS_NODE_MAX)
-    {
-        AcpiGbl_ObjTypeCountMisc++;
-    }
-    else
-    {
-        AcpiGbl_ObjTypeCount [ObjDesc->Common.Type]++;
-    }
-
-    /* Count the sub-objects */
-
-    switch (ObjDesc->Common.Type)
-    {
-    case ACPI_TYPE_PACKAGE:
-
-        for (i = 0; i < ObjDesc->Package.Count; i++)
-        {
-            AcpiDbEnumerateObject (ObjDesc->Package.Elements[i]);
-        }
-        break;
-
-    case ACPI_TYPE_DEVICE:
-
-        AcpiDbEnumerateObject (ObjDesc->Device.NotifyList[0]);
-        AcpiDbEnumerateObject (ObjDesc->Device.NotifyList[1]);
-        AcpiDbEnumerateObject (ObjDesc->Device.Handler);
-        break;
-
-    case ACPI_TYPE_BUFFER_FIELD:
-
-        if (AcpiNsGetSecondaryObject (ObjDesc))
-        {
-            AcpiGbl_ObjTypeCount [ACPI_TYPE_BUFFER_FIELD]++;
-        }
-        break;
-
-    case ACPI_TYPE_REGION:
-
-        AcpiGbl_ObjTypeCount [ACPI_TYPE_LOCAL_REGION_FIELD ]++;
-        AcpiDbEnumerateObject (ObjDesc->Region.Handler);
-        break;
-
-    case ACPI_TYPE_POWER:
-
-        AcpiDbEnumerateObject (ObjDesc->PowerResource.NotifyList[0]);
-        AcpiDbEnumerateObject (ObjDesc->PowerResource.NotifyList[1]);
-        break;
-
-    case ACPI_TYPE_PROCESSOR:
-
-        AcpiDbEnumerateObject (ObjDesc->Processor.NotifyList[0]);
-        AcpiDbEnumerateObject (ObjDesc->Processor.NotifyList[1]);
-        AcpiDbEnumerateObject (ObjDesc->Processor.Handler);
-        break;
-
-    case ACPI_TYPE_THERMAL:
-
-        AcpiDbEnumerateObject (ObjDesc->ThermalZone.NotifyList[0]);
-        AcpiDbEnumerateObject (ObjDesc->ThermalZone.NotifyList[1]);
-        AcpiDbEnumerateObject (ObjDesc->ThermalZone.Handler);
-        break;
-
-    default:
-        break;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbClassifyOneObject
- *
- * PARAMETERS:  Callback for WalkNamespace
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Enumerate both the object descriptor (including subobjects) and
- *              the parent namespace node.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbClassifyOneObject (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  NestingLevel,
-    void                    *Context,
-    void                    **ReturnValue)
-{
-    ACPI_NAMESPACE_NODE     *Node;
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    UINT32                  Type;
-
-
-    AcpiGbl_NumNodes++;
-
-    Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
-    ObjDesc = AcpiNsGetAttachedObject (Node);
-
-    AcpiDbEnumerateObject (ObjDesc);
-
-    Type = Node->Type;
-    if (Type > ACPI_TYPE_NS_NODE_MAX)
-    {
-        AcpiGbl_NodeTypeCountMisc++;
-    }
-    else
-    {
-        AcpiGbl_NodeTypeCount [Type]++;
-    }
-
-    return AE_OK;
-
-
-#ifdef ACPI_FUTURE_IMPLEMENTATION
-
-    /* TBD: These need to be counted during the initial parsing phase */
-
-    if (AcpiPsIsNamedOp (Op->Opcode))
-    {
-        NumNodes++;
-    }
-
-    if (IsMethod)
-    {
-        NumMethodElements++;
-    }
-
-    NumGrammarElements++;
-    Op = AcpiPsGetDepthNext (Root, Op);
-
-    SizeOfParseTree   = (NumGrammarElements - NumMethodElements) *
-                            (UINT32) sizeof (ACPI_PARSE_OBJECT);
-    SizeOfMethodTrees = NumMethodElements * (UINT32) sizeof (ACPI_PARSE_OBJECT);
-    SizeOfNodeEntries = NumNodes * (UINT32) sizeof (ACPI_NAMESPACE_NODE);
-    SizeOfAcpiObjects = NumNodes * (UINT32) sizeof (ACPI_OPERAND_OBJECT);
-#endif
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbCountNamespaceObjects
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Count and classify the entire namespace, including all
- *              namespace nodes and attached objects.
- *
- ******************************************************************************/
-
-static void
-AcpiDbCountNamespaceObjects (
-    void)
-{
-    UINT32                  i;
-
-
-    AcpiGbl_NumNodes = 0;
-    AcpiGbl_NumObjects = 0;
-
-    AcpiGbl_ObjTypeCountMisc = 0;
-    for (i = 0; i < (ACPI_TYPE_NS_NODE_MAX -1); i++)
-    {
-        AcpiGbl_ObjTypeCount [i] = 0;
-        AcpiGbl_NodeTypeCount [i] = 0;
-    }
-
-    (void) AcpiNsWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
-                ACPI_UINT32_MAX, FALSE, AcpiDbClassifyOneObject, NULL, NULL, NULL);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDisplayStatistics
- *
- * PARAMETERS:  TypeArg         - Subcommand
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Display various statistics
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbDisplayStatistics (
-    char                    *TypeArg)
-{
-    UINT32                  i;
-    UINT32                  Temp;
-
-
-    if (!TypeArg)
-    {
-        AcpiOsPrintf ("The following subcommands are available:\n    ALLOCATIONS, OBJECTS, MEMORY, MISC, SIZES, TABLES\n");
-        return (AE_OK);
-    }
-
-    AcpiUtStrupr (TypeArg);
-    Temp = AcpiDbMatchArgument (TypeArg, AcpiDbStatTypes);
-    if (Temp == (UINT32) -1)
-    {
-        AcpiOsPrintf ("Invalid or unsupported argument\n");
-        return (AE_OK);
-    }
-
-
-    switch (Temp)
-    {
-    case CMD_STAT_ALLOCATIONS:
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-        AcpiUtDumpAllocationInfo ();
-#endif
-        break;
-
-    case CMD_STAT_TABLES:
-
-        AcpiOsPrintf ("ACPI Table Information (not implemented):\n\n");
-        break;
-
-    case CMD_STAT_OBJECTS:
-
-        AcpiDbCountNamespaceObjects ();
-
-        AcpiOsPrintf ("\nObjects defined in the current namespace:\n\n");
-
-        AcpiOsPrintf ("%16.16s %10.10s %10.10s\n",
-            "ACPI_TYPE", "NODES", "OBJECTS");
-
-        for (i = 0; i < ACPI_TYPE_NS_NODE_MAX; i++)
-        {
-            AcpiOsPrintf ("%16.16s % 10ld% 10ld\n", AcpiUtGetTypeName (i),
-                AcpiGbl_NodeTypeCount [i], AcpiGbl_ObjTypeCount [i]);
-        }
-        AcpiOsPrintf ("%16.16s % 10ld% 10ld\n", "Misc/Unknown",
-            AcpiGbl_NodeTypeCountMisc, AcpiGbl_ObjTypeCountMisc);
-
-        AcpiOsPrintf ("%16.16s % 10ld% 10ld\n", "TOTALS:",
-            AcpiGbl_NumNodes, AcpiGbl_NumObjects);
-        break;
-
-    case CMD_STAT_MEMORY:
-
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-        AcpiOsPrintf ("\n----Object Statistics (all in hex)---------\n");
-
-        AcpiDbListInfo (AcpiGbl_GlobalList);
-        AcpiDbListInfo (AcpiGbl_NsNodeList);
-#endif
-
-#ifdef ACPI_USE_LOCAL_CACHE
-        AcpiOsPrintf ("\n----Cache Statistics (all in hex)---------\n");
-        AcpiDbListInfo (AcpiGbl_OperandCache);
-        AcpiDbListInfo (AcpiGbl_PsNodeCache);
-        AcpiDbListInfo (AcpiGbl_PsNodeExtCache);
-        AcpiDbListInfo (AcpiGbl_StateCache);
-#endif
-
-        break;
-
-    case CMD_STAT_MISC:
-
-        AcpiOsPrintf ("\nMiscellaneous Statistics:\n\n");
-        AcpiOsPrintf ("Calls to AcpiPsFind:..  ........% 7ld\n",
-            AcpiGbl_PsFindCount);
-        AcpiOsPrintf ("Calls to AcpiNsLookup:..........% 7ld\n",
-            AcpiGbl_NsLookupCount);
-
-        AcpiOsPrintf ("\n");
-
-        AcpiOsPrintf ("Mutex usage:\n\n");
-        for (i = 0; i < ACPI_NUM_MUTEX; i++)
-        {
-            AcpiOsPrintf ("%-28s:       % 7ld\n",
-                AcpiUtGetMutexName (i), AcpiGbl_MutexInfo[i].UseCount);
-        }
-        break;
-
-
-    case CMD_STAT_SIZES:
-
-        AcpiOsPrintf ("\nInternal object sizes:\n\n");
-
-        AcpiOsPrintf ("Common           %3d\n", sizeof (ACPI_OBJECT_COMMON));
-        AcpiOsPrintf ("Number           %3d\n", sizeof (ACPI_OBJECT_INTEGER));
-        AcpiOsPrintf ("String           %3d\n", sizeof (ACPI_OBJECT_STRING));
-        AcpiOsPrintf ("Buffer           %3d\n", sizeof (ACPI_OBJECT_BUFFER));
-        AcpiOsPrintf ("Package          %3d\n", sizeof (ACPI_OBJECT_PACKAGE));
-        AcpiOsPrintf ("BufferField      %3d\n", sizeof (ACPI_OBJECT_BUFFER_FIELD));
-        AcpiOsPrintf ("Device           %3d\n", sizeof (ACPI_OBJECT_DEVICE));
-        AcpiOsPrintf ("Event            %3d\n", sizeof (ACPI_OBJECT_EVENT));
-        AcpiOsPrintf ("Method           %3d\n", sizeof (ACPI_OBJECT_METHOD));
-        AcpiOsPrintf ("Mutex            %3d\n", sizeof (ACPI_OBJECT_MUTEX));
-        AcpiOsPrintf ("Region           %3d\n", sizeof (ACPI_OBJECT_REGION));
-        AcpiOsPrintf ("PowerResource    %3d\n", sizeof (ACPI_OBJECT_POWER_RESOURCE));
-        AcpiOsPrintf ("Processor        %3d\n", sizeof (ACPI_OBJECT_PROCESSOR));
-        AcpiOsPrintf ("ThermalZone      %3d\n", sizeof (ACPI_OBJECT_THERMAL_ZONE));
-        AcpiOsPrintf ("RegionField      %3d\n", sizeof (ACPI_OBJECT_REGION_FIELD));
-        AcpiOsPrintf ("BankField        %3d\n", sizeof (ACPI_OBJECT_BANK_FIELD));
-        AcpiOsPrintf ("IndexField       %3d\n", sizeof (ACPI_OBJECT_INDEX_FIELD));
-        AcpiOsPrintf ("Reference        %3d\n", sizeof (ACPI_OBJECT_REFERENCE));
-        AcpiOsPrintf ("Notify           %3d\n", sizeof (ACPI_OBJECT_NOTIFY_HANDLER));
-        AcpiOsPrintf ("AddressSpace     %3d\n", sizeof (ACPI_OBJECT_ADDR_HANDLER));
-        AcpiOsPrintf ("Extra            %3d\n", sizeof (ACPI_OBJECT_EXTRA));
-        AcpiOsPrintf ("Data             %3d\n", sizeof (ACPI_OBJECT_DATA));
-
-        AcpiOsPrintf ("\n");
-
-        AcpiOsPrintf ("ParseObject      %3d\n", sizeof (ACPI_PARSE_OBJ_COMMON));
-        AcpiOsPrintf ("ParseObjectNamed %3d\n", sizeof (ACPI_PARSE_OBJ_NAMED));
-        AcpiOsPrintf ("ParseObjectAsl   %3d\n", sizeof (ACPI_PARSE_OBJ_ASL));
-        AcpiOsPrintf ("OperandObject    %3d\n", sizeof (ACPI_OPERAND_OBJECT));
-        AcpiOsPrintf ("NamespaceNode    %3d\n", sizeof (ACPI_NAMESPACE_NODE));
-        AcpiOsPrintf ("AcpiObject       %3d\n", sizeof (ACPI_OBJECT));
-
-        AcpiOsPrintf ("\n");
-
-        AcpiOsPrintf ("Generic State    %3d\n", sizeof (ACPI_GENERIC_STATE));
-        AcpiOsPrintf ("Common State     %3d\n", sizeof (ACPI_COMMON_STATE));
-        AcpiOsPrintf ("Control State    %3d\n", sizeof (ACPI_CONTROL_STATE));
-        AcpiOsPrintf ("Update State     %3d\n", sizeof (ACPI_UPDATE_STATE));
-        AcpiOsPrintf ("Scope State      %3d\n", sizeof (ACPI_SCOPE_STATE));
-        AcpiOsPrintf ("Parse Scope      %3d\n", sizeof (ACPI_PSCOPE_STATE));
-        AcpiOsPrintf ("Package State    %3d\n", sizeof (ACPI_PKG_STATE));
-        AcpiOsPrintf ("Thread State     %3d\n", sizeof (ACPI_THREAD_STATE));
-        AcpiOsPrintf ("Result Values    %3d\n", sizeof (ACPI_RESULT_VALUES));
-        AcpiOsPrintf ("Notify Info      %3d\n", sizeof (ACPI_NOTIFY_INFO));
-        break;
-
-
-    case CMD_STAT_STACK:
-#if defined(ACPI_DEBUG_OUTPUT)
-
-        Temp = (UINT32) ACPI_PTR_DIFF (AcpiGbl_EntryStackPointer, AcpiGbl_LowestStackPointer);
-
-        AcpiOsPrintf ("\nSubsystem Stack Usage:\n\n");
-        AcpiOsPrintf ("Entry Stack Pointer          %p\n", AcpiGbl_EntryStackPointer);
-        AcpiOsPrintf ("Lowest Stack Pointer         %p\n", AcpiGbl_LowestStackPointer);
-        AcpiOsPrintf ("Stack Use                    %X (%u)\n", Temp, Temp);
-        AcpiOsPrintf ("Deepest Procedure Nesting    %u\n", AcpiGbl_DeepestNesting);
-#endif
-        break;
-
-    default:
-        break;
-    }
-
-    AcpiOsPrintf ("\n");
-    return (AE_OK);
-}
-
-#endif /* ACPI_DEBUGGER  */
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbutils.c b/usr/src/uts/intel/io/acpica/debugger/dbutils.c
deleted file mode 100644
index cf29b225de..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbutils.c
+++ /dev/null
@@ -1,523 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbutils - AML debugger utilities
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acnamesp.h"
-#include "acdebug.h"
-#include "acdisasm.h"
-
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbutils")
-
-/* Local prototypes */
-
-#ifdef ACPI_OBSOLETE_FUNCTIONS
-ACPI_STATUS
-AcpiDbSecondPassParse (
-    ACPI_PARSE_OBJECT       *Root);
-
-void
-AcpiDbDumpBuffer (
-    UINT32                  Address);
-#endif
-
-static char                 *Converter = "0123456789ABCDEF";
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbMatchArgument
- *
- * PARAMETERS:  UserArgument            - User command line
- *              Arguments               - Array of commands to match against
- *
- * RETURN:      Index into command array or ACPI_TYPE_NOT_FOUND if not found
- *
- * DESCRIPTION: Search command array for a command match
- *
- ******************************************************************************/
-
-ACPI_OBJECT_TYPE
-AcpiDbMatchArgument (
-    char                    *UserArgument,
-    ARGUMENT_INFO           *Arguments)
-{
-    UINT32                  i;
-
-
-    if (!UserArgument || UserArgument[0] == 0)
-    {
-        return (ACPI_TYPE_NOT_FOUND);
-    }
-
-    for (i = 0; Arguments[i].Name; i++)
-    {
-        if (ACPI_STRSTR (Arguments[i].Name, UserArgument) == Arguments[i].Name)
-        {
-            return (i);
-        }
-    }
-
-    /* Argument not recognized */
-
-    return (ACPI_TYPE_NOT_FOUND);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSetOutputDestination
- *
- * PARAMETERS:  OutputFlags         - Current flags word
- *
- * RETURN:      None
- *
- * DESCRIPTION: Set the current destination for debugger output.  Also sets
- *              the debug output level accordingly.
- *
- ******************************************************************************/
-
-void
-AcpiDbSetOutputDestination (
-    UINT32                  OutputFlags)
-{
-
-    AcpiGbl_DbOutputFlags = (UINT8) OutputFlags;
-
-    if ((OutputFlags & ACPI_DB_REDIRECTABLE_OUTPUT) && AcpiGbl_DbOutputToFile)
-    {
-        AcpiDbgLevel = AcpiGbl_DbDebugLevel;
-    }
-    else
-    {
-        AcpiDbgLevel = AcpiGbl_DbConsoleDebugLevel;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDumpExternalObject
- *
- * PARAMETERS:  ObjDesc         - External ACPI object to dump
- *              Level           - Nesting level.
- *
- * RETURN:      None
- *
- * DESCRIPTION: Dump the contents of an ACPI external object
- *
- ******************************************************************************/
-
-void
-AcpiDbDumpExternalObject (
-    ACPI_OBJECT             *ObjDesc,
-    UINT32                  Level)
-{
-    UINT32                  i;
-
-
-    if (!ObjDesc)
-    {
-        AcpiOsPrintf ("[Null Object]\n");
-        return;
-    }
-
-    for (i = 0; i < Level; i++)
-    {
-        AcpiOsPrintf ("  ");
-    }
-
-    switch (ObjDesc->Type)
-    {
-    case ACPI_TYPE_ANY:
-
-        AcpiOsPrintf ("[Null Object] (Type=0)\n");
-        break;
-
-
-    case ACPI_TYPE_INTEGER:
-
-        AcpiOsPrintf ("[Integer] = %8.8X%8.8X\n",
-                    ACPI_FORMAT_UINT64 (ObjDesc->Integer.Value));
-        break;
-
-
-    case ACPI_TYPE_STRING:
-
-        AcpiOsPrintf ("[String] Length %.2X = ", ObjDesc->String.Length);
-        AcpiUtPrintString (ObjDesc->String.Pointer, ACPI_UINT8_MAX);
-        AcpiOsPrintf ("\n");
-        break;
-
-
-    case ACPI_TYPE_BUFFER:
-
-        AcpiOsPrintf ("[Buffer] Length %.2X = ", ObjDesc->Buffer.Length);
-        if (ObjDesc->Buffer.Length)
-        {
-            if (ObjDesc->Buffer.Length > 16)
-            {
-                AcpiOsPrintf ("\n");
-            }
-            AcpiUtDumpBuffer (ACPI_CAST_PTR (UINT8, ObjDesc->Buffer.Pointer),
-                    ObjDesc->Buffer.Length, DB_BYTE_DISPLAY, _COMPONENT);
-        }
-        else
-        {
-            AcpiOsPrintf ("\n");
-        }
-        break;
-
-
-    case ACPI_TYPE_PACKAGE:
-
-        AcpiOsPrintf ("[Package] Contains %u Elements:\n",
-                ObjDesc->Package.Count);
-
-        for (i = 0; i < ObjDesc->Package.Count; i++)
-        {
-            AcpiDbDumpExternalObject (&ObjDesc->Package.Elements[i], Level+1);
-        }
-        break;
-
-
-    case ACPI_TYPE_LOCAL_REFERENCE:
-
-        AcpiOsPrintf ("[Object Reference] = ");
-        AcpiDmDisplayInternalObject (ObjDesc->Reference.Handle, NULL);
-        break;
-
-
-    case ACPI_TYPE_PROCESSOR:
-
-        AcpiOsPrintf ("[Processor]\n");
-        break;
-
-
-    case ACPI_TYPE_POWER:
-
-        AcpiOsPrintf ("[Power Resource]\n");
-        break;
-
-
-    default:
-
-        AcpiOsPrintf ("[Unknown Type] %X\n", ObjDesc->Type);
-        break;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbPrepNamestring
- *
- * PARAMETERS:  Name            - String to prepare
- *
- * RETURN:      None
- *
- * DESCRIPTION: Translate all forward slashes and dots to backslashes.
- *
- ******************************************************************************/
-
-void
-AcpiDbPrepNamestring (
-    char                    *Name)
-{
-
-    if (!Name)
-    {
-        return;
-    }
-
-    AcpiUtStrupr (Name);
-
-    /* Convert a leading forward slash to a backslash */
-
-    if (*Name == '/')
-    {
-        *Name = '\\';
-    }
-
-    /* Ignore a leading backslash, this is the root prefix */
-
-    if (*Name == '\\')
-    {
-        Name++;
-    }
-
-    /* Convert all slash path separators to dots */
-
-    while (*Name)
-    {
-        if ((*Name == '/') ||
-            (*Name == '\\'))
-        {
-            *Name = '.';
-        }
-
-        Name++;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbLocalNsLookup
- *
- * PARAMETERS:  Name            - Name to lookup
- *
- * RETURN:      Pointer to a namespace node, null on failure
- *
- * DESCRIPTION: Lookup a name in the ACPI namespace
- *
- * Note: Currently begins search from the root.  Could be enhanced to use
- * the current prefix (scope) node as the search beginning point.
- *
- ******************************************************************************/
-
-ACPI_NAMESPACE_NODE *
-AcpiDbLocalNsLookup (
-    char                    *Name)
-{
-    char                    *InternalPath;
-    ACPI_STATUS             Status;
-    ACPI_NAMESPACE_NODE     *Node = NULL;
-
-
-    AcpiDbPrepNamestring (Name);
-
-    /* Build an internal namestring */
-
-    Status = AcpiNsInternalizeName (Name, &InternalPath);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Invalid namestring: %s\n", Name);
-        return (NULL);
-    }
-
-    /*
-     * Lookup the name.
-     * (Uses root node as the search starting point)
-     */
-    Status = AcpiNsLookup (NULL, InternalPath, ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-                    ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE, NULL, &Node);
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiOsPrintf ("Could not locate name: %s, %s\n",
-                Name, AcpiFormatException (Status));
-    }
-
-    ACPI_FREE (InternalPath);
-    return (Node);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbUInt32ToHexString
- *
- * PARAMETERS:  Value           - The value to be converted to string
- *              Buffer          - Buffer for result (not less than 11 bytes)
- *
- * RETURN:      None
- *
- * DESCRIPTION: Convert the unsigned 32-bit value to the hexadecimal image
- *
- * NOTE: It is the caller's responsibility to ensure that the length of buffer
- *       is sufficient.
- *
- ******************************************************************************/
-
-void
-AcpiDbUInt32ToHexString (
-    UINT32                  Value,
-    char                    *Buffer)
-{
-    int                     i;
-
-
-    if (Value == 0)
-    {
-        ACPI_STRCPY (Buffer, "0");
-        return;
-    }
-
-    Buffer[8] = '\0';
-
-    for (i = 7; i >= 0; i--)
-    {
-        Buffer[i] = Converter [Value & 0x0F];
-        Value = Value >> 4;
-    }
-}
-
-
-#ifdef ACPI_OBSOLETE_FUNCTIONS
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSecondPassParse
- *
- * PARAMETERS:  Root            - Root of the parse tree
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Second pass parse of the ACPI tables.  We need to wait until
- *              second pass to parse the control methods
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbSecondPassParse (
-    ACPI_PARSE_OBJECT       *Root)
-{
-    ACPI_PARSE_OBJECT       *Op = Root;
-    ACPI_PARSE_OBJECT       *Method;
-    ACPI_PARSE_OBJECT       *SearchOp;
-    ACPI_PARSE_OBJECT       *StartOp;
-    ACPI_STATUS             Status = AE_OK;
-    UINT32                  BaseAmlOffset;
-    ACPI_WALK_STATE         *WalkState;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    AcpiOsPrintf ("Pass two parse ....\n");
-
-    while (Op)
-    {
-        if (Op->Common.AmlOpcode == AML_METHOD_OP)
-        {
-            Method = Op;
-
-            /* Create a new walk state for the parse */
-
-            WalkState = AcpiDsCreateWalkState (0, NULL, NULL, NULL);
-            if (!WalkState)
-            {
-                return (AE_NO_MEMORY);
-            }
-
-            /* Init the Walk State */
-
-            WalkState->ParserState.Aml          =
-            WalkState->ParserState.AmlStart     = Method->Named.Data;
-            WalkState->ParserState.AmlEnd       =
-            WalkState->ParserState.PkgEnd       = Method->Named.Data +
-                                                  Method->Named.Length;
-            WalkState->ParserState.StartScope   = Op;
-
-            WalkState->DescendingCallback       = AcpiDsLoad1BeginOp;
-            WalkState->AscendingCallback        = AcpiDsLoad1EndOp;
-
-            /* Perform the AML parse */
-
-            Status = AcpiPsParseAml (WalkState);
-
-            BaseAmlOffset = (Method->Common.Value.Arg)->Common.AmlOffset + 1;
-            StartOp = (Method->Common.Value.Arg)->Common.Next;
-            SearchOp = StartOp;
-
-            while (SearchOp)
-            {
-                SearchOp->Common.AmlOffset += BaseAmlOffset;
-                SearchOp = AcpiPsGetDepthNext (StartOp, SearchOp);
-            }
-        }
-
-        if (Op->Common.AmlOpcode == AML_REGION_OP)
-        {
-            /* TBD: [Investigate] this isn't quite the right thing to do! */
-            /*
-             *
-             * Method = (ACPI_DEFERRED_OP *) Op;
-             * Status = AcpiPsParseAml (Op, Method->Body, Method->BodyLength);
-             */
-        }
-
-        if (ACPI_FAILURE (Status))
-        {
-            break;
-        }
-
-        Op = AcpiPsGetDepthNext (Root, Op);
-    }
-
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbDumpBuffer
- *
- * PARAMETERS:  Address             - Pointer to the buffer
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print a portion of a buffer
- *
- ******************************************************************************/
-
-void
-AcpiDbDumpBuffer (
-    UINT32                  Address)
-{
-
-    AcpiOsPrintf ("\nLocation %X:\n", Address);
-
-    AcpiDbgLevel |= ACPI_LV_TABLES;
-    AcpiUtDumpBuffer (ACPI_TO_POINTER (Address), 64, DB_BYTE_DISPLAY,
-            ACPI_UINT32_MAX);
-}
-#endif
-
-#endif /* ACPI_DEBUGGER */
-
-
diff --git a/usr/src/uts/intel/io/acpica/debugger/dbxface.c b/usr/src/uts/intel/io/acpica/debugger/dbxface.c
deleted file mode 100644
index cd30273434..0000000000
--- a/usr/src/uts/intel/io/acpica/debugger/dbxface.c
+++ /dev/null
@@ -1,536 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dbxface - AML Debugger external interfaces
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "amlcode.h"
-#include "acdebug.h"
-#include "acdisasm.h"
-
-
-#ifdef ACPI_DEBUGGER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dbxface")
-
-
-/* Local prototypes */
-
-static ACPI_STATUS
-AcpiDbStartCommand (
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       *Op);
-
-#ifdef ACPI_OBSOLETE_FUNCTIONS
-void
-AcpiDbMethodEnd (
-    ACPI_WALK_STATE         *WalkState);
-#endif
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbStartCommand
- *
- * PARAMETERS:  WalkState       - Current walk
- *              Op              - Current executing Op, from AML interpreter
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Enter debugger command loop
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiDbStartCommand (
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       *Op)
-{
-    ACPI_STATUS             Status;
-
-
-    /* TBD: [Investigate] are there namespace locking issues here? */
-
-    /* AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE); */
-
-    /* Go into the command loop and await next user command */
-
-
-    AcpiGbl_MethodExecuting = TRUE;
-    Status = AE_CTRL_TRUE;
-    while (Status == AE_CTRL_TRUE)
-    {
-        if (AcpiGbl_DebuggerConfiguration == DEBUGGER_MULTI_THREADED)
-        {
-            /* Handshake with the front-end that gets user command lines */
-
-            Status = AcpiUtReleaseMutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-            Status = AcpiUtAcquireMutex (ACPI_MTX_DEBUG_CMD_READY);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-        }
-        else
-        {
-            /* Single threaded, we must get a command line ourselves */
-
-            /* Force output to console until a command is entered */
-
-            AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);
-
-            /* Different prompt if method is executing */
-
-            if (!AcpiGbl_MethodExecuting)
-            {
-                AcpiOsPrintf ("%1c ", ACPI_DEBUGGER_COMMAND_PROMPT);
-            }
-            else
-            {
-                AcpiOsPrintf ("%1c ", ACPI_DEBUGGER_EXECUTE_PROMPT);
-            }
-
-            /* Get the user input line */
-
-            Status = AcpiOsGetLine (AcpiGbl_DbLineBuf,
-                ACPI_DB_LINE_BUFFER_SIZE, NULL);
-            if (ACPI_FAILURE (Status))
-            {
-                ACPI_EXCEPTION ((AE_INFO, Status, "While parsing command line"));
-                return (Status);
-            }
-        }
-
-        Status = AcpiDbCommandDispatch (AcpiGbl_DbLineBuf, WalkState, Op);
-    }
-
-    /* AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE); */
-
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbSingleStep
- *
- * PARAMETERS:  WalkState       - Current walk
- *              Op              - Current executing op (from aml interpreter)
- *              OpcodeClass     - Class of the current AML Opcode
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Called just before execution of an AML opcode.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbSingleStep (
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       *Op,
-    UINT32                  OpcodeClass)
-{
-    ACPI_PARSE_OBJECT       *Next;
-    ACPI_STATUS             Status = AE_OK;
-    UINT32                  OriginalDebugLevel;
-    ACPI_PARSE_OBJECT       *DisplayOp;
-    ACPI_PARSE_OBJECT       *ParentOp;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    /* Check the abort flag */
-
-    if (AcpiGbl_AbortMethod)
-    {
-        AcpiGbl_AbortMethod = FALSE;
-        return (AE_ABORT_METHOD);
-    }
-
-    /* Check for single-step breakpoint */
-
-    if (WalkState->MethodBreakpoint &&
-       (WalkState->MethodBreakpoint <= Op->Common.AmlOffset))
-    {
-        /* Check if the breakpoint has been reached or passed */
-        /* Hit the breakpoint, resume single step, reset breakpoint */
-
-        AcpiOsPrintf ("***Break*** at AML offset %X\n", Op->Common.AmlOffset);
-        AcpiGbl_CmSingleStep = TRUE;
-        AcpiGbl_StepToNextCall = FALSE;
-        WalkState->MethodBreakpoint = 0;
-    }
-
-    /* Check for user breakpoint (Must be on exact Aml offset) */
-
-    else if (WalkState->UserBreakpoint &&
-            (WalkState->UserBreakpoint == Op->Common.AmlOffset))
-    {
-        AcpiOsPrintf ("***UserBreakpoint*** at AML offset %X\n",
-            Op->Common.AmlOffset);
-        AcpiGbl_CmSingleStep = TRUE;
-        AcpiGbl_StepToNextCall = FALSE;
-        WalkState->MethodBreakpoint = 0;
-    }
-
-    /*
-     * Check if this is an opcode that we are interested in --
-     * namely, opcodes that have arguments
-     */
-    if (Op->Common.AmlOpcode == AML_INT_NAMEDFIELD_OP)
-    {
-        return (AE_OK);
-    }
-
-    switch (OpcodeClass)
-    {
-    case AML_CLASS_UNKNOWN:
-    case AML_CLASS_ARGUMENT:    /* constants, literals, etc.  do nothing */
-        return (AE_OK);
-
-    default:
-        /* All other opcodes -- continue */
-        break;
-    }
-
-    /*
-     * Under certain debug conditions, display this opcode and its operands
-     */
-    if ((AcpiGbl_DbOutputToFile)            ||
-        (AcpiGbl_CmSingleStep)              ||
-        (AcpiDbgLevel & ACPI_LV_PARSE))
-    {
-        if ((AcpiGbl_DbOutputToFile)        ||
-            (AcpiDbgLevel & ACPI_LV_PARSE))
-        {
-            AcpiOsPrintf ("\n[AmlDebug] Next AML Opcode to execute:\n");
-        }
-
-        /*
-         * Display this op (and only this op - zero out the NEXT field
-         * temporarily, and disable parser trace output for the duration of
-         * the display because we don't want the extraneous debug output)
-         */
-        OriginalDebugLevel = AcpiDbgLevel;
-        AcpiDbgLevel &= ~(ACPI_LV_PARSE | ACPI_LV_FUNCTIONS);
-        Next = Op->Common.Next;
-        Op->Common.Next = NULL;
-
-
-        DisplayOp = Op;
-        ParentOp = Op->Common.Parent;
-        if (ParentOp)
-        {
-            if ((WalkState->ControlState) &&
-                (WalkState->ControlState->Common.State ==
-                    ACPI_CONTROL_PREDICATE_EXECUTING))
-            {
-                /*
-                 * We are executing the predicate of an IF or WHILE statement
-                 * Search upwards for the containing IF or WHILE so that the
-                 * entire predicate can be displayed.
-                 */
-                while (ParentOp)
-                {
-                    if ((ParentOp->Common.AmlOpcode == AML_IF_OP) ||
-                        (ParentOp->Common.AmlOpcode == AML_WHILE_OP))
-                    {
-                        DisplayOp = ParentOp;
-                        break;
-                    }
-                    ParentOp = ParentOp->Common.Parent;
-                }
-            }
-            else
-            {
-                while (ParentOp)
-                {
-                    if ((ParentOp->Common.AmlOpcode == AML_IF_OP)     ||
-                        (ParentOp->Common.AmlOpcode == AML_ELSE_OP)   ||
-                        (ParentOp->Common.AmlOpcode == AML_SCOPE_OP)  ||
-                        (ParentOp->Common.AmlOpcode == AML_METHOD_OP) ||
-                        (ParentOp->Common.AmlOpcode == AML_WHILE_OP))
-                    {
-                        break;
-                    }
-                    DisplayOp = ParentOp;
-                    ParentOp = ParentOp->Common.Parent;
-                }
-            }
-        }
-
-        /* Now we can display it */
-
-        AcpiDmDisassemble (WalkState, DisplayOp, ACPI_UINT32_MAX);
-
-        if ((Op->Common.AmlOpcode == AML_IF_OP) ||
-            (Op->Common.AmlOpcode == AML_WHILE_OP))
-        {
-            if (WalkState->ControlState->Common.Value)
-            {
-                AcpiOsPrintf ("Predicate = [True], IF block was executed\n");
-            }
-            else
-            {
-                AcpiOsPrintf ("Predicate = [False], Skipping IF block\n");
-            }
-        }
-        else if (Op->Common.AmlOpcode == AML_ELSE_OP)
-        {
-            AcpiOsPrintf ("Predicate = [False], ELSE block was executed\n");
-        }
-
-        /* Restore everything */
-
-        Op->Common.Next = Next;
-        AcpiOsPrintf ("\n");
-        if ((AcpiGbl_DbOutputToFile)        ||
-            (AcpiDbgLevel & ACPI_LV_PARSE))
-        {
-            AcpiOsPrintf ("\n");
-        }
-        AcpiDbgLevel = OriginalDebugLevel;
-    }
-
-    /* If we are not single stepping, just continue executing the method */
-
-    if (!AcpiGbl_CmSingleStep)
-    {
-        return (AE_OK);
-    }
-
-    /*
-     * If we are executing a step-to-call command,
-     * Check if this is a method call.
-     */
-    if (AcpiGbl_StepToNextCall)
-    {
-        if (Op->Common.AmlOpcode != AML_INT_METHODCALL_OP)
-        {
-            /* Not a method call, just keep executing */
-
-            return (AE_OK);
-        }
-
-        /* Found a method call, stop executing */
-
-        AcpiGbl_StepToNextCall = FALSE;
-    }
-
-    /*
-     * If the next opcode is a method call, we will "step over" it
-     * by default.
-     */
-    if (Op->Common.AmlOpcode == AML_INT_METHODCALL_OP)
-    {
-        /* Force no more single stepping while executing called method */
-
-        AcpiGbl_CmSingleStep = FALSE;
-
-        /*
-         * Set the breakpoint on/before the call, it will stop execution
-         * as soon as we return
-         */
-        WalkState->MethodBreakpoint = 1;  /* Must be non-zero! */
-    }
-
-
-    Status = AcpiDbStartCommand (WalkState, Op);
-
-    /* User commands complete, continue execution of the interrupted method */
-
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbInitialize
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Init and start debugger
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiDbInitialize (
-    void)
-{
-    ACPI_STATUS             Status;
-
-
-    /* Init globals */
-
-    AcpiGbl_DbBuffer            = NULL;
-    AcpiGbl_DbFilename          = NULL;
-    AcpiGbl_DbOutputToFile      = FALSE;
-
-    AcpiGbl_DbDebugLevel        = ACPI_LV_VERBOSITY2;
-    AcpiGbl_DbConsoleDebugLevel = ACPI_NORMAL_DEFAULT | ACPI_LV_TABLES;
-    AcpiGbl_DbOutputFlags       = ACPI_DB_CONSOLE_OUTPUT;
-
-    AcpiGbl_DbOpt_tables        = FALSE;
-    AcpiGbl_DbOpt_disasm        = FALSE;
-    AcpiGbl_DbOpt_stats         = FALSE;
-    AcpiGbl_DbOpt_verbose       = TRUE;
-    AcpiGbl_DbOpt_ini_methods   = TRUE;
-
-    AcpiGbl_DbBuffer = AcpiOsAllocate (ACPI_DEBUG_BUFFER_SIZE);
-    if (!AcpiGbl_DbBuffer)
-    {
-        return (AE_NO_MEMORY);
-    }
-    ACPI_MEMSET (AcpiGbl_DbBuffer, 0, ACPI_DEBUG_BUFFER_SIZE);
-
-    /* Initial scope is the root */
-
-    AcpiGbl_DbScopeBuf [0] = '\\';
-    AcpiGbl_DbScopeBuf [1] =  0;
-    AcpiGbl_DbScopeNode = AcpiGbl_RootNode;
-
-    /*
-     * If configured for multi-thread support, the debug executor runs in
-     * a separate thread so that the front end can be in another address
-     * space, environment, or even another machine.
-     */
-    if (AcpiGbl_DebuggerConfiguration & DEBUGGER_MULTI_THREADED)
-    {
-        /* These were created with one unit, grab it */
-
-        Status = AcpiUtAcquireMutex (ACPI_MTX_DEBUG_CMD_COMPLETE);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Could not get debugger mutex\n");
-            return (Status);
-        }
-
-        Status = AcpiUtAcquireMutex (ACPI_MTX_DEBUG_CMD_READY);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Could not get debugger mutex\n");
-            return (Status);
-        }
-
-        /* Create the debug execution thread to execute commands */
-
-        Status = AcpiOsExecute (OSL_DEBUGGER_THREAD, AcpiDbExecuteThread, NULL);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("Could not start debugger thread\n");
-            return (Status);
-        }
-    }
-
-    if (!AcpiGbl_DbOpt_verbose)
-    {
-        AcpiGbl_DbOpt_disasm = TRUE;
-        AcpiGbl_DbOpt_stats = FALSE;
-    }
-
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbTerminate
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Stop debugger
- *
- ******************************************************************************/
-
-void
-AcpiDbTerminate (
-    void)
-{
-
-    if (AcpiGbl_DbBuffer)
-    {
-        AcpiOsFree (AcpiGbl_DbBuffer);
-    }
-}
-
-
-#ifdef ACPI_OBSOLETE_FUNCTIONS
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDbMethodEnd
- *
- * PARAMETERS:  WalkState       - Current walk
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Called at method termination
- *
- ******************************************************************************/
-
-void
-AcpiDbMethodEnd (
-    ACPI_WALK_STATE         *WalkState)
-{
-
-    if (!AcpiGbl_CmSingleStep)
-    {
-        return;
-    }
-
-    AcpiOsPrintf ("<Method Terminating>\n");
-
-    AcpiDbStartCommand (WalkState, NULL);
-}
-#endif
-
-#endif /* ACPI_DEBUGGER */
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmbuffer.c b/usr/src/uts/intel/io/acpica/disassembler/dmbuffer.c
index 9f49f92e47..923a4850d4 100644
--- a/usr/src/uts/intel/io/acpica/disassembler/dmbuffer.c
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmbuffer.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,29 +41,46 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
+#include "acutils.h"
 #include "acdisasm.h"
 #include "acparser.h"
 #include "amlcode.h"
+#include "acinterp.h"
 
 
-#ifdef ACPI_DISASSEMBLER
-
 #define _COMPONENT          ACPI_CA_DEBUGGER
         ACPI_MODULE_NAME    ("dmbuffer")
 
 /* Local prototypes */
 
+static void
+AcpiDmUuid (
+    ACPI_PARSE_OBJECT       *Op);
+
 static void
 AcpiDmUnicode (
     ACPI_PARSE_OBJECT       *Op);
 
 static void
-AcpiDmIsEisaIdElement (
+AcpiDmGetHardwareIdType (
     ACPI_PARSE_OBJECT       *Op);
 
+static void
+AcpiDmPldBuffer (
+    UINT32                  Level,
+    UINT8                   *ByteData,
+    UINT32                  ByteCount);
+
+static const char *
+AcpiDmFindNameByIndex (
+    UINT64                  Index,
+    const char              **List);
+
+
+#define ACPI_BUFFER_BYTES_PER_LINE      8
+
 
 /*******************************************************************************
  *
@@ -87,6 +104,9 @@ AcpiDmDisasmByteList (
     UINT32                  ByteCount)
 {
     UINT32                  i;
+    UINT32                  j;
+    UINT32                  CurrentIndex;
+    UINT8                   BufChar;
 
 
     if (!ByteCount)
@@ -94,39 +114,68 @@ AcpiDmDisasmByteList (
         return;
     }
 
-    /* Dump the byte list */
-
-    for (i = 0; i < ByteCount; i++)
+    for (i = 0; i < ByteCount; i += ACPI_BUFFER_BYTES_PER_LINE)
     {
-        /* New line every 8 bytes */
+        /* Line indent and offset prefix for each new line */
 
-        if (((i % 8) == 0) && (i < ByteCount))
+        AcpiDmIndent (Level);
+        if (ByteCount > ACPI_BUFFER_BYTES_PER_LINE)
         {
-            if (i > 0)
+            AcpiOsPrintf ("/* %04X */ ", i);
+        }
+
+        /* Dump the actual hex values */
+
+        for (j = 0; j < ACPI_BUFFER_BYTES_PER_LINE; j++)
+        {
+            CurrentIndex = i + j;
+            if (CurrentIndex >= ByteCount)
             {
-                AcpiOsPrintf ("\n");
+                /* Dump fill spaces */
+
+                AcpiOsPrintf ("      ");
+                continue;
             }
 
-            AcpiDmIndent (Level);
-            if (ByteCount > 8)
+            AcpiOsPrintf (" 0x%2.2X", ByteData[CurrentIndex]);
+
+            /* Add comma if there are more bytes to display */
+
+            if (CurrentIndex < (ByteCount - 1))
+            {
+                AcpiOsPrintf (",");
+            }
+            else
             {
-                AcpiOsPrintf ("/* %04X */  ", i);
+                AcpiOsPrintf (" ");
             }
         }
 
-        AcpiOsPrintf (" 0x%2.2X", (UINT32) ByteData[i]);
+        /* Dump the ASCII equivalents within a comment */
 
-        /* Add comma if there are more bytes to display */
-
-        if (i < (ByteCount -1))
+        AcpiOsPrintf ("  /* ");
+        for (j = 0; j < ACPI_BUFFER_BYTES_PER_LINE; j++)
         {
-            AcpiOsPrintf (",");
+            CurrentIndex = i + j;
+            if (CurrentIndex >= ByteCount)
+            {
+                break;
+            }
+
+            BufChar = ByteData[CurrentIndex];
+            if (isprint (BufChar))
+            {
+                AcpiOsPrintf ("%c", BufChar);
+            }
+            else
+            {
+                AcpiOsPrintf (".");
+            }
         }
-    }
 
-    if (Level)
-    {
-        AcpiOsPrintf ("\n");
+        /* Finished with this line */
+
+        AcpiOsPrintf (" */\n");
     }
 }
 
@@ -165,24 +214,36 @@ AcpiDmByteList (
     {
     case ACPI_DASM_RESOURCE:
 
-        AcpiDmResourceTemplate (Info, Op->Common.Parent, ByteData, ByteCount);
+        AcpiDmResourceTemplate (
+            Info, Op->Common.Parent, ByteData, ByteCount);
         break;
 
     case ACPI_DASM_STRING:
 
         AcpiDmIndent (Info->Level);
-        AcpiUtPrintString ((char *) ByteData, ACPI_UINT8_MAX);
+        AcpiUtPrintString ((char *) ByteData, ACPI_UINT16_MAX);
         AcpiOsPrintf ("\n");
         break;
 
+    case ACPI_DASM_UUID:
+
+        AcpiDmUuid (Op);
+        break;
+
     case ACPI_DASM_UNICODE:
 
         AcpiDmUnicode (Op);
         break;
 
+    case ACPI_DASM_PLD_METHOD:
+#if 0
+        AcpiDmDisasmByteList (Info->Level, ByteData, ByteCount);
+#endif
+        AcpiDmPldBuffer (Info->Level, ByteData, ByteCount);
+        break;
+
     case ACPI_DASM_BUFFER:
     default:
-
         /*
          * Not a resource, string, or unicode string.
          * Just dump the buffer
@@ -193,6 +254,139 @@ AcpiDmByteList (
 }
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmIsUuidBuffer
+ *
+ * PARAMETERS:  Op              - Buffer Object to be examined
+ *
+ * RETURN:      TRUE if buffer contains a UUID
+ *
+ * DESCRIPTION: Determine if a buffer Op contains a UUID
+ *
+ * To help determine whether the buffer is a UUID versus a raw data buffer,
+ * there a are a couple bytes we can look at:
+ *
+ *    xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
+ *
+ * The variant covered by the UUID specification is indicated by the two most
+ * significant bits of N being 1 0 (i.e., the hexadecimal N will always be
+ * 8, 9, A, or B).
+ *
+ * The variant covered by the UUID specification has five versions. For this
+ * variant, the four bits of M indicates the UUID version (i.e., the
+ * hexadecimal M will be either 1, 2, 3, 4, or 5).
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AcpiDmIsUuidBuffer (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    UINT8                   *ByteData;
+    UINT32                  ByteCount;
+    ACPI_PARSE_OBJECT       *SizeOp;
+    ACPI_PARSE_OBJECT       *NextOp;
+
+
+    /* Buffer size is the buffer argument */
+
+    SizeOp = Op->Common.Value.Arg;
+
+    /* Next, the initializer byte list to examine */
+
+    NextOp = SizeOp->Common.Next;
+    if (!NextOp)
+    {
+        return (FALSE);
+    }
+
+    /* Extract the byte list info */
+
+    ByteData = NextOp->Named.Data;
+    ByteCount = (UINT32) NextOp->Common.Value.Integer;
+
+    /* Byte count must be exactly 16 */
+
+    if (ByteCount != UUID_BUFFER_LENGTH)
+    {
+        return (FALSE);
+    }
+
+    /* Check for valid "M" and "N" values (see function header above) */
+
+    if (((ByteData[7] & 0xF0) == 0x00) || /* M={1,2,3,4,5} */
+        ((ByteData[7] & 0xF0) > 0x50)  ||
+        ((ByteData[8] & 0xF0) < 0x80)  || /* N={8,9,A,B} */
+        ((ByteData[8] & 0xF0) > 0xB0))
+    {
+        return (FALSE);
+    }
+
+    /* Ignore the Size argument in the disassembly of this buffer op */
+
+    SizeOp->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmUuid
+ *
+ * PARAMETERS:  Op              - Byte List op containing a UUID
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump a buffer containing a UUID as a standard ASCII string.
+ *
+ * Output Format:
+ * In its canonical form, the UUID is represented by a string containing 32
+ * lowercase hexadecimal digits, displayed in 5 groups separated by hyphens.
+ * The complete form is 8-4-4-4-12 for a total of 36 characters (32
+ * alphanumeric characters representing hex digits and 4 hyphens). In bytes,
+ * 4-2-2-2-6. Example:
+ *
+ *    ToUUID ("107ededd-d381-4fd7-8da9-08e9a6c79644")
+ *
+ ******************************************************************************/
+
+static void
+AcpiDmUuid (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    UINT8                   *Data;
+    const char              *Description;
+
+
+    Data = ACPI_CAST_PTR (UINT8, Op->Named.Data);
+
+    /* Emit the 36-byte UUID string in the proper format/order */
+
+    AcpiOsPrintf (
+        "\"%2.2x%2.2x%2.2x%2.2x-"
+        "%2.2x%2.2x-"
+        "%2.2x%2.2x-"
+        "%2.2x%2.2x-"
+        "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\")",
+        Data[3], Data[2], Data[1], Data[0],
+        Data[5], Data[4],
+        Data[7], Data[6],
+        Data[8], Data[9],
+        Data[10], Data[11], Data[12], Data[13], Data[14], Data[15]);
+
+#ifdef ACPI_APPLICATION
+    /* Dump the UUID description string if available */
+
+    Description = AcpiAhMatchUuid (Data);
+    if (Description)
+    {
+        AcpiOsPrintf (" /* %s */", Description);
+    }
+#endif
+}
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiDmIsUnicodeBuffer
@@ -247,11 +441,12 @@ AcpiDmIsUnicodeBuffer (
         return (FALSE);
     }
 
-    /* For each word, 1st byte must be ascii, 2nd byte must be zero */
+    /* For each word, 1st byte must be ascii (1-0x7F), 2nd byte must be zero */
 
     for (i = 0; i < (ByteCount - 2); i += 2)
     {
-        if ((!ACPI_IS_PRINT (ByteData[i])) ||
+        if ((ByteData[i] == 0) ||
+            (ByteData[i] > 0x7F) ||
             (ByteData[(ACPI_SIZE) i + 1] != 0))
         {
             return (FALSE);
@@ -320,7 +515,7 @@ AcpiDmIsStringBuffer (
          * they will be handled in the string output routine
          */
 
-        if (!ACPI_IS_PRINT (ByteData[i]))
+        if (!isprint (ByteData[i]))
         {
             return (FALSE);
         }
@@ -330,6 +525,237 @@ AcpiDmIsStringBuffer (
 }
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmIsPldBuffer
+ *
+ * PARAMETERS:  Op                  - Buffer Object to be examined
+ *
+ * RETURN:      TRUE if buffer contains a ASCII string, FALSE otherwise
+ *
+ * DESCRIPTION: Determine if a buffer Op contains a _PLD structure
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AcpiDmIsPldBuffer (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_PARSE_OBJECT       *SizeOp;
+    ACPI_PARSE_OBJECT       *ParentOp;
+
+
+    /* Buffer size is the buffer argument */
+
+    SizeOp = Op->Common.Value.Arg;
+
+    ParentOp = Op->Common.Parent;
+    if (!ParentOp)
+    {
+        return (FALSE);
+    }
+
+    /* Check for form: Name(_PLD, Buffer() {}). Not legal, however */
+
+    if (ParentOp->Common.AmlOpcode == AML_NAME_OP)
+    {
+        Node = ParentOp->Common.Node;
+
+        if (ACPI_COMPARE_NAME (Node->Name.Ascii, METHOD_NAME__PLD))
+        {
+            /* Ignore the Size argument in the disassembly of this buffer op */
+
+            SizeOp->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
+            return (TRUE);
+        }
+
+        return (FALSE);
+    }
+
+    /* Check for proper form: Name(_PLD, Package() {Buffer() {}}) */
+
+    if (ParentOp->Common.AmlOpcode == AML_PACKAGE_OP)
+    {
+        ParentOp = ParentOp->Common.Parent;
+        if (!ParentOp)
+        {
+            return (FALSE);
+        }
+
+        if (ParentOp->Common.AmlOpcode == AML_NAME_OP)
+        {
+            Node = ParentOp->Common.Node;
+
+            if (ACPI_COMPARE_NAME (Node->Name.Ascii, METHOD_NAME__PLD))
+            {
+                /* Ignore the Size argument in the disassembly of this buffer op */
+
+                SizeOp->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
+                return (TRUE);
+            }
+        }
+    }
+
+    return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmFindNameByIndex
+ *
+ * PARAMETERS:  Index               - Index of array to check
+ *              List                - Array to reference
+ *
+ * RETURN:      String from List or empty string
+ *
+ * DESCRIPTION: Finds and returns the char string located at the given index
+ *              position in List.
+ *
+ ******************************************************************************/
+
+static const char *
+AcpiDmFindNameByIndex (
+    UINT64                  Index,
+    const char              **List)
+{
+    const char              *NameString;
+    UINT32                  i;
+
+
+    /* Bounds check */
+
+    NameString = List[0];
+    i = 0;
+
+    while (NameString)
+    {
+        i++;
+        NameString = List[i];
+    }
+
+    if (Index >= i)
+    {
+        /* TBD: Add error msg */
+
+        return ("");
+    }
+
+    return (List[Index]);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmPldBuffer
+ *
+ * PARAMETERS:  Level               - Current source code indentation level
+ *              ByteData            - Pointer to the byte list
+ *              ByteCount           - Length of the byte list
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump and format the contents of a _PLD buffer object
+ *
+ ******************************************************************************/
+
+#define ACPI_PLD_OUTPUT08   "%*.s%-22s = 0x%X,\n", ACPI_MUL_4 (Level), " "
+#define ACPI_PLD_OUTPUT08P  "%*.s%-22s = 0x%X)\n", ACPI_MUL_4 (Level), " "
+#define ACPI_PLD_OUTPUT16   "%*.s%-22s = 0x%X,\n", ACPI_MUL_4 (Level), " "
+#define ACPI_PLD_OUTPUT16P  "%*.s%-22s = 0x%X)\n", ACPI_MUL_4 (Level), " "
+#define ACPI_PLD_OUTPUT24   "%*.s%-22s = 0x%X,\n", ACPI_MUL_4 (Level), " "
+#define ACPI_PLD_OUTPUTSTR  "%*.s%-22s = \"%s\",\n", ACPI_MUL_4 (Level), " "
+
+static void
+AcpiDmPldBuffer (
+    UINT32                  Level,
+    UINT8                   *ByteData,
+    UINT32                  ByteCount)
+{
+    ACPI_PLD_INFO           *PldInfo;
+    ACPI_STATUS             Status;
+
+
+    /* Check for valid byte count */
+
+    if (ByteCount < ACPI_PLD_REV1_BUFFER_SIZE)
+    {
+        return;
+    }
+
+    /* Convert _PLD buffer to local _PLD struct */
+
+    Status = AcpiDecodePldBuffer (ByteData, ByteCount, &PldInfo);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    AcpiOsPrintf ("\n");
+
+    /* First 32-bit dword */
+
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Revision", PldInfo->Revision);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_IgnoreColor", PldInfo->IgnoreColor);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Red", PldInfo->Red);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Green", PldInfo->Green);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Blue", PldInfo->Blue);
+
+    /* Second 32-bit dword */
+
+    AcpiOsPrintf (ACPI_PLD_OUTPUT16,  "PLD_Width", PldInfo->Width);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT16,  "PLD_Height", PldInfo->Height);
+
+    /* Third 32-bit dword */
+
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_UserVisible", PldInfo->UserVisible);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Dock", PldInfo->Dock);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Lid", PldInfo->Lid);
+    AcpiOsPrintf (ACPI_PLD_OUTPUTSTR, "PLD_Panel",
+        AcpiDmFindNameByIndex(PldInfo->Panel, AcpiGbl_PldPanelList));
+
+    AcpiOsPrintf (ACPI_PLD_OUTPUTSTR, "PLD_VerticalPosition",
+        AcpiDmFindNameByIndex(PldInfo->VerticalPosition, AcpiGbl_PldVerticalPositionList));
+
+    AcpiOsPrintf (ACPI_PLD_OUTPUTSTR, "PLD_HorizontalPosition",
+        AcpiDmFindNameByIndex(PldInfo->HorizontalPosition, AcpiGbl_PldHorizontalPositionList));
+
+    AcpiOsPrintf (ACPI_PLD_OUTPUTSTR, "PLD_Shape",
+        AcpiDmFindNameByIndex(PldInfo->Shape, AcpiGbl_PldShapeList));
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_GroupOrientation", PldInfo->GroupOrientation);
+
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_GroupToken", PldInfo->GroupToken);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_GroupPosition", PldInfo->GroupPosition);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Bay", PldInfo->Bay);
+
+    /* Fourth 32-bit dword */
+
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Ejectable", PldInfo->Ejectable);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_EjectRequired", PldInfo->OspmEjectRequired);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_CabinetNumber", PldInfo->CabinetNumber);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_CardCageNumber", PldInfo->CardCageNumber);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Reference", PldInfo->Reference);
+    AcpiOsPrintf (ACPI_PLD_OUTPUT08,  "PLD_Rotation", PldInfo->Rotation);
+
+    if (ByteCount >= ACPI_PLD_REV2_BUFFER_SIZE)
+    {
+        AcpiOsPrintf (ACPI_PLD_OUTPUT08, "PLD_Order", PldInfo->Order);
+
+        /* Fifth 32-bit dword */
+
+        AcpiOsPrintf (ACPI_PLD_OUTPUT16,  "PLD_VerticalOffset", PldInfo->VerticalOffset);
+        AcpiOsPrintf (ACPI_PLD_OUTPUT16P, "PLD_HorizontalOffset", PldInfo->HorizontalOffset);
+    }
+    else /* Rev 1 buffer */
+    {
+        AcpiOsPrintf (ACPI_PLD_OUTPUT08P, "PLD_Order", PldInfo->Order);
+    }
+
+    ACPI_FREE (PldInfo);
+}
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiDmUnicode
@@ -338,7 +764,7 @@ AcpiDmIsStringBuffer (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Dump Unicode string as a standard ASCII string.  (Remove
+ * DESCRIPTION: Dump Unicode string as a standard ASCII string. (Remove
  *              the extra zero bytes).
  *
  ******************************************************************************/
@@ -350,6 +776,7 @@ AcpiDmUnicode (
     UINT16                  *WordData;
     UINT32                  WordCount;
     UINT32                  i;
+    int                     OutputValue;
 
 
     /* Extract the buffer info as a WORD buffer */
@@ -357,14 +784,28 @@ AcpiDmUnicode (
     WordData = ACPI_CAST_PTR (UINT16, Op->Named.Data);
     WordCount = ACPI_DIV_2 (((UINT32) Op->Common.Value.Integer));
 
-
-    AcpiOsPrintf ("\"");
-
     /* Write every other byte as an ASCII character */
 
+    AcpiOsPrintf ("\"");
     for (i = 0; i < (WordCount - 1); i++)
     {
-        AcpiOsPrintf ("%c", (int) WordData[i]);
+        OutputValue = (int) WordData[i];
+
+        /* Handle values that must be escaped */
+
+        if ((OutputValue == '\"') ||
+            (OutputValue == '\\'))
+        {
+            AcpiOsPrintf ("\\%c", OutputValue);
+        }
+        else if (!isprint (OutputValue))
+        {
+            AcpiOsPrintf ("\\x%2.2X", OutputValue);
+        }
+        else
+        {
+            AcpiOsPrintf ("%c", OutputValue);
+        }
     }
 
     AcpiOsPrintf ("\")");
@@ -373,19 +814,20 @@ AcpiDmUnicode (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiDmIsEisaIdElement
+ * FUNCTION:    AcpiDmGetHardwareIdType
  *
  * PARAMETERS:  Op              - Op to be examined
  *
  * RETURN:      None
  *
- * DESCRIPTION: Determine if an Op (argument to _HID or _CID) can be converted
- *              to an EISA ID.
+ * DESCRIPTION: Determine the type of the argument to a _HID or _CID
+ *              1) Strings are allowed
+ *              2) If Integer, determine if it is a valid EISAID
  *
  ******************************************************************************/
 
 static void
-AcpiDmIsEisaIdElement (
+AcpiDmGetHardwareIdType (
     ACPI_PARSE_OBJECT       *Op)
 {
     UINT32                  BigEndianId;
@@ -393,55 +835,66 @@ AcpiDmIsEisaIdElement (
     UINT32                  i;
 
 
-    /* The parameter must be either a word or a dword */
-
-    if ((Op->Common.AmlOpcode != AML_DWORD_OP) &&
-        (Op->Common.AmlOpcode != AML_WORD_OP))
+    switch (Op->Common.AmlOpcode)
     {
-        return;
-    }
+    case AML_STRING_OP:
+
+        /* Mark this string as an _HID/_CID string */
 
-    /* Swap from little-endian to big-endian to simplify conversion */
+        Op->Common.DisasmOpcode = ACPI_DASM_HID_STRING;
+        break;
 
-    BigEndianId = AcpiUtDwordByteSwap ((UINT32) Op->Common.Value.Integer);
+    case AML_WORD_OP:
+    case AML_DWORD_OP:
 
-    /* Create the 3 leading ASCII letters */
+        /* Determine if a Word/Dword is a valid encoded EISAID */
 
-    Prefix[0] = ((BigEndianId >> 26) & 0x1F) + 0x40;
-    Prefix[1] = ((BigEndianId >> 21) & 0x1F) + 0x40;
-    Prefix[2] = ((BigEndianId >> 16) & 0x1F) + 0x40;
+        /* Swap from little-endian to big-endian to simplify conversion */
 
-    /* Verify that all 3 are ascii and alpha */
+        BigEndianId = AcpiUtDwordByteSwap ((UINT32) Op->Common.Value.Integer);
 
-    for (i = 0; i < 3; i++)
-    {
-        if (!ACPI_IS_ASCII (Prefix[i]) ||
-            !ACPI_IS_ALPHA (Prefix[i]))
+        /* Create the 3 leading ASCII letters */
+
+        Prefix[0] = ((BigEndianId >> 26) & 0x1F) + 0x40;
+        Prefix[1] = ((BigEndianId >> 21) & 0x1F) + 0x40;
+        Prefix[2] = ((BigEndianId >> 16) & 0x1F) + 0x40;
+
+        /* Verify that all 3 are ascii and alpha */
+
+        for (i = 0; i < 3; i++)
         {
-            return;
+            if (!ACPI_IS_ASCII (Prefix[i]) ||
+                !isalpha (Prefix[i]))
+            {
+                return;
+            }
         }
-    }
 
-    /* OK - mark this node as convertable to an EISA ID */
+        /* Mark this node as convertable to an EISA ID string */
+
+        Op->Common.DisasmOpcode = ACPI_DASM_EISAID;
+        break;
 
-    Op->Common.DisasmOpcode = ACPI_DASM_EISAID;
+    default:
+        break;
+    }
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiDmIsEisaId
+ * FUNCTION:    AcpiDmCheckForHardwareId
  *
  * PARAMETERS:  Op              - Op to be examined
  *
  * RETURN:      None
  *
- * DESCRIPTION: Determine if a Name() Op can be converted to an EisaId.
+ * DESCRIPTION: Determine if a Name() Op is a _HID/_CID.
  *
  ******************************************************************************/
 
 void
-AcpiDmIsEisaId (
+AcpiDmCheckForHardwareId (
     ACPI_PARSE_OBJECT       *Op)
 {
     UINT32                  Name;
@@ -466,7 +919,7 @@ AcpiDmIsEisaId (
 
     if (ACPI_COMPARE_NAME (&Name, METHOD_NAME__HID))
     {
-        AcpiDmIsEisaIdElement (NextOp);
+        AcpiDmGetHardwareIdType (NextOp);
         return;
     }
 
@@ -481,20 +934,24 @@ AcpiDmIsEisaId (
 
     if (NextOp->Common.AmlOpcode != AML_PACKAGE_OP)
     {
-        AcpiDmIsEisaIdElement (NextOp);
+        AcpiDmGetHardwareIdType (NextOp);
         return;
     }
 
-    /* _CID with Package: get the package length */
+    /* _CID with Package: get the package length, check all elements */
 
     NextOp = AcpiPsGetDepthNext (NULL, NextOp);
+    if (!NextOp)
+    {
+        return;
+    }
 
     /* Don't need to use the length, just walk the peer list */
 
     NextOp = NextOp->Common.Next;
     while (NextOp)
     {
-        AcpiDmIsEisaIdElement (NextOp);
+        AcpiDmGetHardwareIdType (NextOp);
         NextOp = NextOp->Common.Next;
     }
 }
@@ -502,41 +959,36 @@ AcpiDmIsEisaId (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiDmEisaId
+ * FUNCTION:    AcpiDmDecompressEisaId
  *
  * PARAMETERS:  EncodedId       - Raw encoded EISA ID.
  *
  * RETURN:      None
  *
- * DESCRIPTION: Convert an encoded EISAID back to the original ASCII String.
+ * DESCRIPTION: Convert an encoded EISAID back to the original ASCII String
+ *              and emit the correct ASL statement. If the ID is known, emit
+ *              a description of the ID as a comment.
  *
  ******************************************************************************/
 
 void
-AcpiDmEisaId (
+AcpiDmDecompressEisaId (
     UINT32                  EncodedId)
 {
-    UINT32                  BigEndianId;
+    char                    IdBuffer[ACPI_EISAID_STRING_SIZE];
+    const AH_DEVICE_ID      *Info;
 
 
-    /* Swap from little-endian to big-endian to simplify conversion */
+    /* Convert EISAID to a string an emit the statement */
 
-    BigEndianId = AcpiUtDwordByteSwap (EncodedId);
+    AcpiExEisaIdToString (IdBuffer, EncodedId);
+    AcpiOsPrintf ("EisaId (\"%s\")", IdBuffer);
 
+    /* If we know about the ID, emit the description */
 
-    /* Split to form "AAANNNN" string */
-
-    AcpiOsPrintf ("EisaId (\"%c%c%c%4.4X\")",
-
-        /* Three Alpha characters (AAA), 5 bits each */
-
-        (int) ((BigEndianId >> 26) & 0x1F) + 0x40,
-        (int) ((BigEndianId >> 21) & 0x1F) + 0x40,
-        (int) ((BigEndianId >> 16) & 0x1F) + 0x40,
-
-        /* Numeric part (NNNN) is simply the lower 16 bits */
-
-        (UINT32) (BigEndianId & 0xFFFF));
+    Info = AcpiAhMatchHardwareId (IdBuffer);
+    if (Info)
+    {
+        AcpiOsPrintf (" /* %s */", Info->Description);
+    }
 }
-
-#endif
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmcstyle.c b/usr/src/uts/intel/io/acpica/disassembler/dmcstyle.c
new file mode 100644
index 0000000000..2f61dea208
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmcstyle.c
@@ -0,0 +1,877 @@
+/*******************************************************************************
+ *
+ * Module Name: dmcstyle - Support for C-style operator disassembly
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdebug.h"
+
+
+#define _COMPONENT          ACPI_CA_DEBUGGER
+        ACPI_MODULE_NAME    ("dmcstyle")
+
+
+/* Local prototypes */
+
+static char *
+AcpiDmGetCompoundSymbol (
+   UINT16                   AslOpcode);
+
+static void
+AcpiDmPromoteTarget (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *Target);
+
+static BOOLEAN
+AcpiDmIsValidTarget (
+    ACPI_PARSE_OBJECT       *Op);
+
+static BOOLEAN
+AcpiDmIsTargetAnOperand (
+    ACPI_PARSE_OBJECT       *Target,
+    ACPI_PARSE_OBJECT       *Operand,
+    BOOLEAN                 TopLevel);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmCheckForSymbolicOpcode
+ *
+ * PARAMETERS:  Op                  - Current parse object
+ *              Walk                - Current parse tree walk info
+ *
+ * RETURN:      TRUE if opcode can be converted to symbolic, FALSE otherwise
+ *
+ * DESCRIPTION: This is the main code that implements disassembly of AML code
+ *              to C-style operators. Called during descending phase of the
+ *              parse tree walk.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AcpiDmCheckForSymbolicOpcode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_OP_WALK_INFO       *Info)
+{
+    char                    *OperatorSymbol = NULL;
+    ACPI_PARSE_OBJECT       *Child1;
+    ACPI_PARSE_OBJECT       *Child2;
+    ACPI_PARSE_OBJECT       *Target;
+
+
+    /* Exit immediately if ASL+ not enabled */
+
+    if (!AcpiGbl_CstyleDisassembly)
+    {
+        return (FALSE);
+    }
+
+    /* Get the first operand */
+
+    Child1 = AcpiPsGetArg (Op, 0);
+    if (!Child1)
+    {
+        return (FALSE);
+    }
+
+    /* Get the second operand */
+
+    Child2 = Child1->Common.Next;
+
+    /* Setup the operator string for this opcode */
+
+    switch (Op->Common.AmlOpcode)
+    {
+    case AML_ADD_OP:
+        OperatorSymbol = " + ";
+        break;
+
+    case AML_SUBTRACT_OP:
+        OperatorSymbol = " - ";
+        break;
+
+    case AML_MULTIPLY_OP:
+        OperatorSymbol = " * ";
+        break;
+
+    case AML_DIVIDE_OP:
+        OperatorSymbol = " / ";
+        break;
+
+    case AML_MOD_OP:
+        OperatorSymbol = " % ";
+        break;
+
+    case AML_SHIFT_LEFT_OP:
+        OperatorSymbol = " << ";
+        break;
+
+    case AML_SHIFT_RIGHT_OP:
+        OperatorSymbol = " >> ";
+        break;
+
+    case AML_BIT_AND_OP:
+        OperatorSymbol = " & ";
+        break;
+
+    case AML_BIT_OR_OP:
+        OperatorSymbol = " | ";
+        break;
+
+    case AML_BIT_XOR_OP:
+        OperatorSymbol = " ^ ";
+        break;
+
+    /* Logical operators, no target */
+
+    case AML_LAND_OP:
+        OperatorSymbol = " && ";
+        break;
+
+    case AML_LEQUAL_OP:
+        OperatorSymbol = " == ";
+        break;
+
+    case AML_LGREATER_OP:
+        OperatorSymbol = " > ";
+        break;
+
+    case AML_LLESS_OP:
+        OperatorSymbol = " < ";
+        break;
+
+    case AML_LOR_OP:
+        OperatorSymbol = " || ";
+        break;
+
+    case AML_LNOT_OP:
+        /*
+         * Check for the LNOT sub-opcodes. These correspond to
+         * LNotEqual, LLessEqual, and LGreaterEqual. There are
+         * no actual AML opcodes for these operators.
+         */
+        switch (Child1->Common.AmlOpcode)
+        {
+        case AML_LEQUAL_OP:
+            OperatorSymbol = " != ";
+            break;
+
+        case AML_LGREATER_OP:
+            OperatorSymbol = " <= ";
+            break;
+
+        case AML_LLESS_OP:
+            OperatorSymbol = " >= ";
+            break;
+
+        default:
+
+            /* Unary LNOT case, emit "!" immediately */
+
+            AcpiOsPrintf ("!");
+            return (TRUE);
+        }
+
+        Child1->Common.DisasmOpcode = ACPI_DASM_LNOT_SUFFIX;
+        Op->Common.DisasmOpcode = ACPI_DASM_LNOT_PREFIX;
+        Op->Common.DisasmFlags |= ACPI_PARSEOP_COMPOUND_ASSIGNMENT;
+
+        /* Save symbol string in the next child (not peer) */
+
+        Child2 = AcpiPsGetArg (Child1, 0);
+        if (!Child2)
+        {
+            return (FALSE);
+        }
+
+        Child2->Common.OperatorSymbol = OperatorSymbol;
+        return (TRUE);
+
+    case AML_INDEX_OP:
+        /*
+         * Check for constant source operand. Note: although technically
+         * legal syntax, the iASL compiler does not support this with
+         * the symbolic operators for Index(). It doesn't make sense to
+         * use Index() with a constant anyway.
+         */
+        if ((Child1->Common.AmlOpcode == AML_STRING_OP)  ||
+            (Child1->Common.AmlOpcode == AML_BUFFER_OP)  ||
+            (Child1->Common.AmlOpcode == AML_PACKAGE_OP) ||
+            (Child1->Common.AmlOpcode == AML_VAR_PACKAGE_OP))
+        {
+            Op->Common.DisasmFlags |= ACPI_PARSEOP_CLOSING_PAREN;
+            return (FALSE);
+        }
+
+        /* Index operator is [] */
+
+        Child1->Common.OperatorSymbol = " [";
+        Child2->Common.OperatorSymbol = "]";
+        break;
+
+    /* Unary operators */
+
+    case AML_DECREMENT_OP:
+        OperatorSymbol = "--";
+        break;
+
+    case AML_INCREMENT_OP:
+        OperatorSymbol = "++";
+        break;
+
+    case AML_BIT_NOT_OP:
+    case AML_STORE_OP:
+        OperatorSymbol = NULL;
+        break;
+
+    default:
+        return (FALSE);
+    }
+
+    if (Child1->Common.DisasmOpcode == ACPI_DASM_LNOT_SUFFIX)
+    {
+        return (TRUE);
+    }
+
+    /*
+     * This is the key to how the disassembly of the C-style operators
+     * works. We save the operator symbol in the first child, thus
+     * deferring symbol output until after the first operand has been
+     * emitted.
+     */
+    if (!Child1->Common.OperatorSymbol)
+    {
+        Child1->Common.OperatorSymbol = OperatorSymbol;
+    }
+
+    /*
+     * Check for a valid target as the 3rd (or sometimes 2nd) operand
+     *
+     * Compound assignment operator support:
+     * Attempt to optimize constructs of the form:
+     *      Add (Local1, 0xFF, Local1)
+     * to:
+     *      Local1 += 0xFF
+     *
+     * Only the math operators and Store() have a target.
+     * Logicals have no target.
+     */
+    switch (Op->Common.AmlOpcode)
+    {
+    case AML_ADD_OP:
+    case AML_SUBTRACT_OP:
+    case AML_MULTIPLY_OP:
+    case AML_DIVIDE_OP:
+    case AML_MOD_OP:
+    case AML_SHIFT_LEFT_OP:
+    case AML_SHIFT_RIGHT_OP:
+    case AML_BIT_AND_OP:
+    case AML_BIT_OR_OP:
+    case AML_BIT_XOR_OP:
+
+        /* Target is 3rd operand */
+
+        Target = Child2->Common.Next;
+        if (Op->Common.AmlOpcode == AML_DIVIDE_OP)
+        {
+            /*
+             * Divide has an extra target operand (Remainder).
+             * If this extra target is specified, it cannot be converted
+             * to a C-style operator
+             */
+            if (AcpiDmIsValidTarget (Target))
+            {
+                Child1->Common.OperatorSymbol = NULL;
+                return (FALSE);
+            }
+
+            Target->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
+            Target = Target->Common.Next;
+        }
+
+        /* Parser should ensure there is at least a placeholder target */
+
+        if (!Target)
+        {
+            return (FALSE);
+        }
+
+        if (!AcpiDmIsValidTarget (Target))
+        {
+            /* Not a valid target (placeholder only, from parser) */
+            break;
+        }
+
+        /*
+         * Promote the target up to the first child in the parse
+         * tree. This is done because the target will be output
+         * first, in the form:
+         *     <Target> = Operands...
+         */
+        AcpiDmPromoteTarget (Op, Target);
+
+        /* Check operands for conversion to a "Compound Assignment" */
+
+        switch (Op->Common.AmlOpcode)
+        {
+            /* Commutative operators */
+
+        case AML_ADD_OP:
+        case AML_MULTIPLY_OP:
+        case AML_BIT_AND_OP:
+        case AML_BIT_OR_OP:
+        case AML_BIT_XOR_OP:
+            /*
+             * For the commutative operators, we can convert to a
+             * compound statement only if at least one (either) operand
+             * is the same as the target.
+             *
+             *      Add (A, B, A) --> A += B
+             *      Add (B, A, A) --> A += B
+             *      Add (B, C, A) --> A = (B + C)
+             */
+            if ((AcpiDmIsTargetAnOperand (Target, Child1, TRUE)) ||
+                (AcpiDmIsTargetAnOperand (Target, Child2, TRUE)))
+            {
+                Target->Common.OperatorSymbol =
+                    AcpiDmGetCompoundSymbol (Op->Common.AmlOpcode);
+
+                /* Convert operator to compound assignment */
+
+                Op->Common.DisasmFlags |= ACPI_PARSEOP_COMPOUND_ASSIGNMENT;
+                Child1->Common.OperatorSymbol = NULL;
+                return (TRUE);
+            }
+            break;
+
+            /* Non-commutative operators */
+
+        case AML_SUBTRACT_OP:
+        case AML_DIVIDE_OP:
+        case AML_MOD_OP:
+        case AML_SHIFT_LEFT_OP:
+        case AML_SHIFT_RIGHT_OP:
+            /*
+             * For the non-commutative operators, we can convert to a
+             * compound statement only if the target is the same as the
+             * first operand.
+             *
+             *      Subtract (A, B, A) --> A -= B
+             *      Subtract (B, A, A) --> A = (B - A)
+             */
+            if ((AcpiDmIsTargetAnOperand (Target, Child1, TRUE)))
+            {
+                Target->Common.OperatorSymbol =
+                    AcpiDmGetCompoundSymbol (Op->Common.AmlOpcode);
+
+                /* Convert operator to compound assignment */
+
+                Op->Common.DisasmFlags |= ACPI_PARSEOP_COMPOUND_ASSIGNMENT;
+                Child1->Common.OperatorSymbol = NULL;
+                return (TRUE);
+            }
+            break;
+
+        default:
+            break;
+        }
+
+        /*
+         * If we are within a C-style expression, emit an extra open
+         * paren. Implemented by examining the parent op.
+         */
+        switch (Op->Common.Parent->Common.AmlOpcode)
+        {
+        case AML_ADD_OP:
+        case AML_SUBTRACT_OP:
+        case AML_MULTIPLY_OP:
+        case AML_DIVIDE_OP:
+        case AML_MOD_OP:
+        case AML_SHIFT_LEFT_OP:
+        case AML_SHIFT_RIGHT_OP:
+        case AML_BIT_AND_OP:
+        case AML_BIT_OR_OP:
+        case AML_BIT_XOR_OP:
+        case AML_LAND_OP:
+        case AML_LEQUAL_OP:
+        case AML_LGREATER_OP:
+        case AML_LLESS_OP:
+        case AML_LOR_OP:
+
+            Op->Common.DisasmFlags |= ACPI_PARSEOP_ASSIGNMENT;
+            AcpiOsPrintf ("(");
+            break;
+
+        default:
+            break;
+        }
+
+        /* Normal output for ASL/AML operators with a target operand */
+
+        Target->Common.OperatorSymbol = " = (";
+        return (TRUE);
+
+    /* Binary operators, no parens */
+
+    case AML_DECREMENT_OP:
+    case AML_INCREMENT_OP:
+        return (TRUE);
+
+    case AML_INDEX_OP:
+
+        /* Target is optional, 3rd operand */
+
+        Target = Child2->Common.Next;
+        if (AcpiDmIsValidTarget (Target))
+        {
+            AcpiDmPromoteTarget (Op, Target);
+
+            if (!Target->Common.OperatorSymbol)
+            {
+                Target->Common.OperatorSymbol = " = ";
+            }
+        }
+        return (TRUE);
+
+    case AML_STORE_OP:
+        /*
+         * Target is the 2nd operand.
+         * We know the target is valid, it is not optional.
+         * In the parse tree, simply swap the target with the
+         * source so that the target is processed first.
+         */
+        Target = Child1->Common.Next;
+        if (!Target)
+        {
+            return (FALSE);
+        }
+
+        AcpiDmPromoteTarget (Op, Target);
+        if (!Target->Common.OperatorSymbol)
+        {
+            Target->Common.OperatorSymbol = " = ";
+        }
+        return (TRUE);
+
+    case AML_BIT_NOT_OP:
+
+        /* Target is optional, 2nd operand */
+
+        Target = Child1->Common.Next;
+        if (!Target)
+        {
+            return (FALSE);
+        }
+
+        if (AcpiDmIsValidTarget (Target))
+        {
+            /* Valid target, not a placeholder */
+
+            AcpiDmPromoteTarget (Op, Target);
+            Target->Common.OperatorSymbol = " = ~";
+        }
+        else
+        {
+            /* No target. Emit this prefix operator immediately */
+
+            AcpiOsPrintf ("~");
+        }
+        return (TRUE);
+
+    default:
+        break;
+    }
+
+    /*
+     * Nodes marked with ACPI_PARSEOP_PARAMLIST don't need a parens
+     * output here. We also need to check the parent to see if this op
+     * is part of a compound test (!=, >=, <=).
+     */
+    if ((Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST) ||
+       ((Op->Common.Parent->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST) &&
+        (Op->Common.DisasmOpcode == ACPI_DASM_LNOT_SUFFIX)))
+    {
+        /* Do Nothing. Paren already generated */
+        return (TRUE);
+    }
+
+    /* All other operators, emit an open paren */
+
+    AcpiOsPrintf ("(");
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmCloseOperator
+ *
+ * PARAMETERS:  Op                  - Current parse object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Closes an operator by adding a closing parentheses if and
+ *              when necessary. Called during ascending phase of the
+ *              parse tree walk.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmCloseOperator (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    BOOLEAN                 IsCStyleOp = FALSE;
+
+    /* Always emit paren if ASL+ disassembly disabled */
+
+    if (!AcpiGbl_CstyleDisassembly)
+    {
+        AcpiOsPrintf (")");
+        return;
+    }
+
+    /* Check if we need to add an additional closing paren */
+
+    switch (Op->Common.AmlOpcode)
+    {
+    case AML_ADD_OP:
+    case AML_SUBTRACT_OP:
+    case AML_MULTIPLY_OP:
+    case AML_DIVIDE_OP:
+    case AML_MOD_OP:
+    case AML_SHIFT_LEFT_OP:
+    case AML_SHIFT_RIGHT_OP:
+    case AML_BIT_AND_OP:
+    case AML_BIT_OR_OP:
+    case AML_BIT_XOR_OP:
+    case AML_LAND_OP:
+    case AML_LEQUAL_OP:
+    case AML_LGREATER_OP:
+    case AML_LLESS_OP:
+    case AML_LOR_OP:
+
+        /* Emit paren only if this is not a compound assignment */
+
+        if (Op->Common.DisasmFlags & ACPI_PARSEOP_COMPOUND_ASSIGNMENT)
+        {
+            return;
+        }
+
+        /* Emit extra close paren for assignment within an expression */
+
+        if (Op->Common.DisasmFlags & ACPI_PARSEOP_ASSIGNMENT)
+        {
+            AcpiOsPrintf (")");
+        }
+
+        IsCStyleOp = TRUE;
+        break;
+
+    case AML_INDEX_OP:
+
+        /* This is case for unsupported Index() source constants */
+
+        if (Op->Common.DisasmFlags & ACPI_PARSEOP_CLOSING_PAREN)
+        {
+            AcpiOsPrintf (")");
+        }
+        return;
+
+    /* No need for parens for these */
+
+    case AML_DECREMENT_OP:
+    case AML_INCREMENT_OP:
+    case AML_LNOT_OP:
+    case AML_BIT_NOT_OP:
+    case AML_STORE_OP:
+        return;
+
+    default:
+
+        /* Always emit paren for non-ASL+ operators */
+        break;
+    }
+
+    /*
+     * Nodes marked with ACPI_PARSEOP_PARAMLIST don't need a parens
+     * output here. We also need to check the parent to see if this op
+     * is part of a compound test (!=, >=, <=).
+     */
+    if (IsCStyleOp &&
+       ((Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST) ||
+       ((Op->Common.Parent->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST) &&
+        (Op->Common.DisasmOpcode == ACPI_DASM_LNOT_SUFFIX))))
+    {
+        return;
+    }
+
+    AcpiOsPrintf (")");
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmGetCompoundSymbol
+ *
+ * PARAMETERS:  AslOpcode
+ *
+ * RETURN:      String containing the compound assignment symbol
+ *
+ * DESCRIPTION: Detect opcodes that can be converted to compound assignment,
+ *              return the appropriate operator string.
+ *
+ ******************************************************************************/
+
+static char *
+AcpiDmGetCompoundSymbol (
+   UINT16                   AmlOpcode)
+{
+    char                    *Symbol;
+
+
+    switch (AmlOpcode)
+    {
+    case AML_ADD_OP:
+        Symbol = " += ";
+        break;
+
+    case AML_SUBTRACT_OP:
+        Symbol = " -= ";
+        break;
+
+    case AML_MULTIPLY_OP:
+        Symbol = " *= ";
+        break;
+
+    case AML_DIVIDE_OP:
+        Symbol = " /= ";
+        break;
+
+    case AML_MOD_OP:
+        Symbol = " %= ";
+        break;
+
+    case AML_SHIFT_LEFT_OP:
+        Symbol = " <<= ";
+        break;
+
+    case AML_SHIFT_RIGHT_OP:
+        Symbol = " >>= ";
+        break;
+
+    case AML_BIT_AND_OP:
+        Symbol = " &= ";
+        break;
+
+    case AML_BIT_OR_OP:
+        Symbol = " |= ";
+        break;
+
+    case AML_BIT_XOR_OP:
+        Symbol = " ^= ";
+        break;
+
+    default:
+
+        /* No operator string for all other opcodes */
+
+        return (NULL);
+    }
+
+    return (Symbol);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmPromoteTarget
+ *
+ * PARAMETERS:  Op                  - Operator parse object
+ *              Target              - Target associate with the Op
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Transform the parse tree by moving the target up to the first
+ *              child of the Op.
+ *
+ ******************************************************************************/
+
+static void
+AcpiDmPromoteTarget (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_PARSE_OBJECT       *Target)
+{
+    ACPI_PARSE_OBJECT       *Child;
+
+
+    /* Link target directly to the Op as first child */
+
+    Child = Op->Common.Value.Arg;
+    Op->Common.Value.Arg = Target;
+    Target->Common.Next = Child;
+
+    /* Find the last peer, it is linked to the target. Unlink it. */
+
+    while (Child->Common.Next != Target)
+    {
+        Child = Child->Common.Next;
+    }
+
+    Child->Common.Next = NULL;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmIsValidTarget
+ *
+ * PARAMETERS:  Target              - Target Op from the parse tree
+ *
+ * RETURN:      TRUE if the Target is real. FALSE if it is just a placeholder
+ *              Op that was inserted by the parser.
+ *
+ * DESCRIPTION: Determine if a Target Op is a placeholder Op or a real Target.
+ *              In other words, determine if the optional target is used or
+ *              not. Note: If Target is NULL, something is seriously wrong,
+ *              probably with the parse tree.
+ *
+ ******************************************************************************/
+
+static BOOLEAN
+AcpiDmIsValidTarget (
+    ACPI_PARSE_OBJECT       *Target)
+{
+
+    if (!Target)
+    {
+        return (FALSE);
+    }
+
+    if ((Target->Common.AmlOpcode == AML_INT_NAMEPATH_OP) &&
+        (Target->Common.Value.Arg == NULL))
+    {
+        return (FALSE);
+    }
+
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmIsTargetAnOperand
+ *
+ * PARAMETERS:  Target              - Target associated with the expression
+ *              Operand             - An operand associated with expression
+ *
+ * RETURN:      TRUE if expression can be converted to a compound assignment.
+ *              FALSE otherwise.
+ *
+ * DESCRIPTION: Determine if the Target duplicates the operand, in order to
+ *              detect if the expression can be converted to a compound
+ *              assigment. (+=, *=, etc.)
+ *
+ ******************************************************************************/
+
+static BOOLEAN
+AcpiDmIsTargetAnOperand (
+    ACPI_PARSE_OBJECT       *Target,
+    ACPI_PARSE_OBJECT       *Operand,
+    BOOLEAN                 TopLevel)
+{
+    const ACPI_OPCODE_INFO  *OpInfo;
+    BOOLEAN                 Same;
+
+
+    /*
+     * Opcodes must match. Note: ignoring the difference between nameseg
+     * and namepath for now. May be needed later.
+     */
+    if (Target->Common.AmlOpcode != Operand->Common.AmlOpcode)
+    {
+        return (FALSE);
+    }
+
+    /* Nodes should match, even if they are NULL */
+
+    if (Target->Common.Node != Operand->Common.Node)
+    {
+        return (FALSE);
+    }
+
+    /* Determine if a child exists */
+
+    OpInfo = AcpiPsGetOpcodeInfo (Operand->Common.AmlOpcode);
+    if (OpInfo->Flags & AML_HAS_ARGS)
+    {
+        Same = AcpiDmIsTargetAnOperand (Target->Common.Value.Arg,
+            Operand->Common.Value.Arg, FALSE);
+        if (!Same)
+        {
+            return (FALSE);
+        }
+    }
+
+    /* Check the next peer, as long as we are not at the top level */
+
+    if ((!TopLevel) &&
+         Target->Common.Next)
+    {
+        Same = AcpiDmIsTargetAnOperand (Target->Common.Next,
+            Operand->Common.Next, FALSE);
+        if (!Same)
+        {
+            return (FALSE);
+        }
+    }
+
+    /* Supress the duplicate operand at the top-level */
+
+    if (TopLevel)
+    {
+        Operand->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
+    }
+    return (TRUE);
+}
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmdeferred.c b/usr/src/uts/intel/io/acpica/disassembler/dmdeferred.c
new file mode 100644
index 0000000000..387980b893
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmdeferred.c
@@ -0,0 +1,264 @@
+/******************************************************************************
+ *
+ * Module Name: dmdeferred - Disassembly of deferred AML opcodes
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acdispat.h"
+#include "amlcode.h"
+#include "acdisasm.h"
+#include "acparser.h"
+
+#define _COMPONENT          ACPI_CA_DISASSEMBLER
+        ACPI_MODULE_NAME    ("dmdeferred")
+
+
+/* Local prototypes */
+
+static ACPI_STATUS
+AcpiDmDeferredParse (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT8                   *Aml,
+    UINT32                  AmlLength);
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiDmParseDeferredOps
+ *
+ * PARAMETERS:  Root                - Root of the parse tree
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse the deferred opcodes (Methods, regions, etc.)
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiDmParseDeferredOps (
+    ACPI_PARSE_OBJECT       *Root)
+{
+    const ACPI_OPCODE_INFO  *OpInfo;
+    ACPI_PARSE_OBJECT       *Op = Root;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    /* Traverse the entire parse tree */
+
+    while (Op)
+    {
+        OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+        if (!(OpInfo->Flags & AML_DEFER))
+        {
+            Op = AcpiPsGetDepthNext (Root, Op);
+            continue;
+        }
+
+        /* Now we know we have a deferred opcode */
+
+        switch (Op->Common.AmlOpcode)
+        {
+        case AML_METHOD_OP:
+        case AML_BUFFER_OP:
+        case AML_PACKAGE_OP:
+        case AML_VAR_PACKAGE_OP:
+
+            Status = AcpiDmDeferredParse (
+                Op, Op->Named.Data, Op->Named.Length);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+            break;
+
+        /* We don't need to do anything for these deferred opcodes */
+
+        case AML_REGION_OP:
+        case AML_DATA_REGION_OP:
+        case AML_CREATE_QWORD_FIELD_OP:
+        case AML_CREATE_DWORD_FIELD_OP:
+        case AML_CREATE_WORD_FIELD_OP:
+        case AML_CREATE_BYTE_FIELD_OP:
+        case AML_CREATE_BIT_FIELD_OP:
+        case AML_CREATE_FIELD_OP:
+        case AML_BANK_FIELD_OP:
+
+            break;
+
+        default:
+
+            ACPI_ERROR ((AE_INFO, "Unhandled deferred AML opcode [0x%.4X]",
+                 Op->Common.AmlOpcode));
+            break;
+        }
+
+        Op = AcpiPsGetDepthNext (Root, Op);
+    }
+
+    return (AE_OK);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDeferredParse
+ *
+ * PARAMETERS:  Op                  - Root Op of the deferred opcode
+ *              Aml                 - Pointer to the raw AML
+ *              AmlLength           - Length of the AML
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse one deferred opcode
+ *              (Methods, operation regions, etc.)
+ *
+ *****************************************************************************/
+
+static ACPI_STATUS
+AcpiDmDeferredParse (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT8                   *Aml,
+    UINT32                  AmlLength)
+{
+    ACPI_WALK_STATE         *WalkState;
+    ACPI_STATUS             Status;
+    ACPI_PARSE_OBJECT       *SearchOp;
+    ACPI_PARSE_OBJECT       *StartOp;
+    ACPI_PARSE_OBJECT       *NewRootOp;
+    ACPI_PARSE_OBJECT       *ExtraOp;
+
+
+    ACPI_FUNCTION_TRACE (DmDeferredParse);
+
+
+    if (!Aml || !AmlLength)
+    {
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Parsing deferred opcode %s [%4.4s]\n",
+        Op->Common.AmlOpName, (char *) &Op->Named.Name));
+
+    /* Need a new walk state to parse the AML */
+
+    WalkState = AcpiDsCreateWalkState (0, Op, NULL, NULL);
+    if (!WalkState)
+    {
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    Status = AcpiDsInitAmlWalk (WalkState, Op, NULL, Aml,
+        AmlLength, NULL, ACPI_IMODE_LOAD_PASS1);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Parse the AML for this deferred opcode */
+
+    WalkState->ParseFlags &= ~ACPI_PARSE_DELETE_TREE;
+    WalkState->ParseFlags |= ACPI_PARSE_DISASSEMBLE;
+    Status = AcpiPsParseAml (WalkState);
+
+    StartOp = (Op->Common.Value.Arg)->Common.Next;
+    SearchOp = StartOp;
+    while (SearchOp)
+    {
+        SearchOp = AcpiPsGetDepthNext (StartOp, SearchOp);
+    }
+
+    /*
+     * For Buffer and Package opcodes, link the newly parsed subtree
+     * into the main parse tree
+     */
+    switch (Op->Common.AmlOpcode)
+    {
+    case AML_BUFFER_OP:
+    case AML_PACKAGE_OP:
+    case AML_VAR_PACKAGE_OP:
+
+        switch (Op->Common.AmlOpcode)
+        {
+        case AML_PACKAGE_OP:
+
+            ExtraOp = Op->Common.Value.Arg;
+            NewRootOp = ExtraOp->Common.Next;
+            ACPI_FREE (ExtraOp);
+            break;
+
+        case AML_VAR_PACKAGE_OP:
+        case AML_BUFFER_OP:
+        default:
+
+            NewRootOp = Op->Common.Value.Arg;
+            break;
+        }
+
+        Op->Common.Value.Arg = NewRootOp->Common.Value.Arg;
+
+        /* Must point all parents to the main tree */
+
+        StartOp = Op;
+        SearchOp = StartOp;
+        while (SearchOp)
+        {
+            if (SearchOp->Common.Parent == NewRootOp)
+            {
+                SearchOp->Common.Parent = Op;
+            }
+
+            SearchOp = AcpiPsGetDepthNext (StartOp, SearchOp);
+        }
+
+        ACPI_FREE (NewRootOp);
+        break;
+
+    default:
+
+        break;
+    }
+
+    return_ACPI_STATUS (AE_OK);
+}
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmnames.c b/usr/src/uts/intel/io/acpica/disassembler/dmnames.c
index 92e67c2e0a..89cfb2e985 100644
--- a/usr/src/uts/intel/io/acpica/disassembler/dmnames.c
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmnames.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,17 +41,13 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
-#include "acparser.h"
 #include "amlcode.h"
 #include "acnamesp.h"
 #include "acdisasm.h"
 
 
-#ifdef ACPI_DISASSEMBLER
-
 #define _COMPONENT          ACPI_CA_DEBUGGER
         ACPI_MODULE_NAME    ("dmnames")
 
@@ -128,7 +124,7 @@ AcpiDmDumpName (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Diplay the pathname associated with a named object.  Two
+ * DESCRIPTION: Diplay the pathname associated with a named object. Two
  *              versions. One searches the parse tree (for parser-only
  *              applications suchas AcpiDump), and the other searches the
  *              ACPI namespace (the parse tree is probably deleted)
@@ -159,15 +155,15 @@ AcpiPsDisplayObjectPathname (
         /* Node not defined in this scope, look it up */
 
         Status = AcpiNsLookup (WalkState->ScopeInfo, Op->Common.Value.String,
-                    ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
-                    WalkState, &(Node));
+            ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+            WalkState, &(Node));
 
         if (ACPI_FAILURE (Status))
         {
             /*
-             * We can't get the pathname since the object
-             * is not in the namespace.  This can happen during single
-             * stepping where a dynamic named object is *about* to be created.
+             * We can't get the pathname since the object is not in the
+             * namespace. This can happen during single stepping
+             * where a dynamic named object is *about* to be created.
              */
             AcpiOsPrintf ("  [Path not found]");
             goto Exit;
@@ -181,7 +177,7 @@ AcpiPsDisplayObjectPathname (
     /* Convert NamedDesc/handle to a full pathname */
 
     Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-    Status = AcpiNsHandleToPathname (Node, &Buffer);
+    Status = AcpiNsHandleToPathname (Node, &Buffer, FALSE);
     if (ACPI_FAILURE (Status))
     {
         AcpiOsPrintf ("****Could not get pathname****)");
@@ -226,7 +222,8 @@ AcpiDmNamestring (
 
     /* Handle all Scope Prefix operators */
 
-    while (AcpiPsIsPrefixChar (ACPI_GET8 (Name)))
+    while (ACPI_IS_ROOT_PREFIX (ACPI_GET8 (Name)) ||
+           ACPI_IS_PARENT_PREFIX (ACPI_GET8 (Name)))
     {
         /* Append prefix character */
 
@@ -237,20 +234,24 @@ AcpiDmNamestring (
     switch (ACPI_GET8 (Name))
     {
     case 0:
+
         SegCount = 0;
         break;
 
     case AML_DUAL_NAME_PREFIX:
+
         SegCount = 2;
         Name++;
         break;
 
     case AML_MULTI_NAME_PREFIX_OP:
+
         SegCount = (UINT32) ACPI_GET8 (Name + 1);
         Name += 2;
         break;
 
     default:
+
         SegCount = 1;
         break;
     }
@@ -268,6 +269,7 @@ AcpiDmNamestring (
 
             AcpiOsPrintf (".");
         }
+
         Name += ACPI_NAME_SIZE;
     }
 }
@@ -323,7 +325,7 @@ AcpiDmDisplayPath (
 
         if ((NamePath) &&
             (NamePath->Common.Value.String) &&
-            (NamePath->Common.Value.String[0] == '\\'))
+            (ACPI_IS_ROOT_PREFIX (NamePath->Common.Value.String[0])))
         {
             AcpiDmNamestring (NamePath->Common.Value.String);
             return;
@@ -331,7 +333,6 @@ AcpiDmDisplayPath (
     }
 
     Prev = NULL;            /* Start with Root Node */
-
     while (Prev != Op)
     {
         /* Search upwards in the tree to find scope with "prev" as its parent */
@@ -389,6 +390,7 @@ AcpiDmDisplayPath (
                 DoDot = TRUE;
             }
         }
+
         Prev = Search;
     }
 }
@@ -411,6 +413,8 @@ AcpiDmValidateName (
     char                    *Name,
     ACPI_PARSE_OBJECT       *Op)
 {
+    ACPI_PARSE_OBJECT       *TargetOp;
+
 
     if ((!Name) ||
         (!Op->Common.Parent))
@@ -424,9 +428,6 @@ AcpiDmValidateName (
             " /**** Name not found or not accessible from this scope ****/ ");
     }
 
-    ACPI_PARSE_OBJECT       *TargetOp;
-
-
     if ((!Name) ||
         (!Op->Common.Parent))
     {
@@ -437,9 +438,9 @@ AcpiDmValidateName (
     if (!TargetOp)
     {
         /*
-         * Didn't find the name in the parse tree.  This may be
+         * Didn't find the name in the parse tree. This may be
          * a problem, or it may simply be one of the predefined names
-         * (such as _OS_).  Rather than worry about looking up all
+         * (such as _OS_). Rather than worry about looking up all
          * the predefined names, just display the name as given
          */
         AcpiOsPrintf (
@@ -447,7 +448,3 @@ AcpiDmValidateName (
     }
 }
 #endif
-
-#endif
-
-
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmobject.c b/usr/src/uts/intel/io/acpica/disassembler/dmobject.c
deleted file mode 100644
index cb515e9427..0000000000
--- a/usr/src/uts/intel/io/acpica/disassembler/dmobject.c
+++ /dev/null
@@ -1,589 +0,0 @@
-/*******************************************************************************
- *
- * Module Name: dmobject - ACPI object decode and display
- *
- ******************************************************************************/
-
-/*
- * Copyright (C) 2000 - 2012, Intel Corp.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include "acpi.h"
-#include "accommon.h"
-#include "acnamesp.h"
-#include "acdisasm.h"
-
-
-#ifdef ACPI_DISASSEMBLER
-
-#define _COMPONENT          ACPI_CA_DEBUGGER
-        ACPI_MODULE_NAME    ("dmnames")
-
-/* Local prototypes */
-
-static void
-AcpiDmDecodeNode (
-    ACPI_NAMESPACE_NODE     *Node);
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDmDumpMethodInfo
- *
- * PARAMETERS:  Status          - Method execution status
- *              WalkState       - Current state of the parse tree walk
- *              Op              - Executing parse op
- *
- * RETURN:      None
- *
- * DESCRIPTION: Called when a method has been aborted because of an error.
- *              Dumps the method execution stack, and the method locals/args,
- *              and disassembles the AML opcode that failed.
- *
- ******************************************************************************/
-
-void
-AcpiDmDumpMethodInfo (
-    ACPI_STATUS             Status,
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       *Op)
-{
-    ACPI_PARSE_OBJECT       *Next;
-    ACPI_THREAD_STATE       *Thread;
-    ACPI_WALK_STATE         *NextWalkState;
-    ACPI_NAMESPACE_NODE     *PreviousMethod = NULL;
-
-
-    /* Ignore control codes, they are not errors */
-
-    if ((Status & AE_CODE_MASK) == AE_CODE_CONTROL)
-    {
-        return;
-    }
-
-    /* We may be executing a deferred opcode */
-
-    if (WalkState->DeferredNode)
-    {
-        AcpiOsPrintf ("Executing subtree for Buffer/Package/Region\n");
-        return;
-    }
-
-    /*
-     * If there is no Thread, we are not actually executing a method.
-     * This can happen when the iASL compiler calls the interpreter
-     * to perform constant folding.
-     */
-    Thread = WalkState->Thread;
-    if (!Thread)
-    {
-        return;
-    }
-
-    /* Display exception and method name */
-
-    AcpiOsPrintf ("\n**** Exception %s during execution of method ",
-        AcpiFormatException (Status));
-    AcpiNsPrintNodePathname (WalkState->MethodNode, NULL);
-
-    /* Display stack of executing methods */
-
-    AcpiOsPrintf ("\n\nMethod Execution Stack:\n");
-    NextWalkState = Thread->WalkStateList;
-
-    /* Walk list of linked walk states */
-
-    while (NextWalkState)
-    {
-        AcpiOsPrintf ("    Method [%4.4s] executing: ",
-                AcpiUtGetNodeName (NextWalkState->MethodNode));
-
-        /* First method is the currently executing method */
-
-        if (NextWalkState == WalkState)
-        {
-            if (Op)
-            {
-                /* Display currently executing ASL statement */
-
-                Next = Op->Common.Next;
-                Op->Common.Next = NULL;
-
-                AcpiDmDisassemble (NextWalkState, Op, ACPI_UINT32_MAX);
-                Op->Common.Next = Next;
-            }
-        }
-        else
-        {
-            /*
-             * This method has called another method
-             * NOTE: the method call parse subtree is already deleted at this
-             * point, so we cannot disassemble the method invocation.
-             */
-            AcpiOsPrintf ("Call to method ");
-            AcpiNsPrintNodePathname (PreviousMethod, NULL);
-        }
-
-        PreviousMethod = NextWalkState->MethodNode;
-        NextWalkState = NextWalkState->Next;
-        AcpiOsPrintf ("\n");
-    }
-
-    /* Display the method locals and arguments */
-
-    AcpiOsPrintf ("\n");
-    AcpiDmDisplayLocals (WalkState);
-    AcpiOsPrintf ("\n");
-    AcpiDmDisplayArguments (WalkState);
-    AcpiOsPrintf ("\n");
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDmDecodeInternalObject
- *
- * PARAMETERS:  ObjDesc         - Object to be displayed
- *
- * RETURN:      None
- *
- * DESCRIPTION: Short display of an internal object.  Numbers/Strings/Buffers.
- *
- ******************************************************************************/
-
-void
-AcpiDmDecodeInternalObject (
-    ACPI_OPERAND_OBJECT     *ObjDesc)
-{
-    UINT32                  i;
-
-
-    if (!ObjDesc)
-    {
-        AcpiOsPrintf (" Uninitialized");
-        return;
-    }
-
-    if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) != ACPI_DESC_TYPE_OPERAND)
-    {
-        AcpiOsPrintf (" %p [%s]", ObjDesc, AcpiUtGetDescriptorName (ObjDesc));
-        return;
-    }
-
-    AcpiOsPrintf (" %s", AcpiUtGetObjectTypeName (ObjDesc));
-
-    switch (ObjDesc->Common.Type)
-    {
-    case ACPI_TYPE_INTEGER:
-
-        AcpiOsPrintf (" %8.8X%8.8X",
-                ACPI_FORMAT_UINT64 (ObjDesc->Integer.Value));
-        break;
-
-
-    case ACPI_TYPE_STRING:
-
-        AcpiOsPrintf ("(%u) \"%.24s",
-                ObjDesc->String.Length, ObjDesc->String.Pointer);
-
-        if (ObjDesc->String.Length > 24)
-        {
-            AcpiOsPrintf ("...");
-        }
-        else
-        {
-            AcpiOsPrintf ("\"");
-        }
-        break;
-
-
-    case ACPI_TYPE_BUFFER:
-
-        AcpiOsPrintf ("(%u)", ObjDesc->Buffer.Length);
-        for (i = 0; (i < 8) && (i < ObjDesc->Buffer.Length); i++)
-        {
-            AcpiOsPrintf (" %2.2X", ObjDesc->Buffer.Pointer[i]);
-        }
-        break;
-
-
-    default:
-
-        AcpiOsPrintf (" %p", ObjDesc);
-        break;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDmDecodeNode
- *
- * PARAMETERS:  Node        - Object to be displayed
- *
- * RETURN:      None
- *
- * DESCRIPTION: Short display of a namespace node
- *
- ******************************************************************************/
-
-static void
-AcpiDmDecodeNode (
-    ACPI_NAMESPACE_NODE     *Node)
-{
-
-    AcpiOsPrintf ("<Node>            Name %4.4s",
-            AcpiUtGetNodeName (Node));
-
-    if (Node->Flags & ANOBJ_METHOD_ARG)
-    {
-        AcpiOsPrintf (" [Method Arg]");
-    }
-    if (Node->Flags & ANOBJ_METHOD_LOCAL)
-    {
-        AcpiOsPrintf (" [Method Local]");
-    }
-
-    switch (Node->Type)
-    {
-    /* These types have no attached object */
-
-    case ACPI_TYPE_DEVICE:
-        AcpiOsPrintf (" Device");
-        break;
-
-    case ACPI_TYPE_THERMAL:
-        AcpiOsPrintf (" Thermal Zone");
-        break;
-
-    default:
-        AcpiDmDecodeInternalObject (AcpiNsGetAttachedObject (Node));
-        break;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDmDisplayInternalObject
- *
- * PARAMETERS:  ObjDesc         - Object to be displayed
- *              WalkState       - Current walk state
- *
- * RETURN:      None
- *
- * DESCRIPTION: Short display of an internal object
- *
- ******************************************************************************/
-
-void
-AcpiDmDisplayInternalObject (
-    ACPI_OPERAND_OBJECT     *ObjDesc,
-    ACPI_WALK_STATE         *WalkState)
-{
-    UINT8                   Type;
-
-
-    AcpiOsPrintf ("%p ", ObjDesc);
-
-    if (!ObjDesc)
-    {
-        AcpiOsPrintf ("<Null Object>\n");
-        return;
-    }
-
-    /* Decode the object type */
-
-    switch (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc))
-    {
-    case ACPI_DESC_TYPE_PARSER:
-
-        AcpiOsPrintf ("<Parser>  ");
-        break;
-
-
-    case ACPI_DESC_TYPE_NAMED:
-
-        AcpiDmDecodeNode ((ACPI_NAMESPACE_NODE *) ObjDesc);
-        break;
-
-
-    case ACPI_DESC_TYPE_OPERAND:
-
-        Type = ObjDesc->Common.Type;
-        if (Type > ACPI_TYPE_LOCAL_MAX)
-        {
-            AcpiOsPrintf (" Type %X [Invalid Type]", (UINT32) Type);
-            return;
-        }
-
-        /* Decode the ACPI object type */
-
-        switch (ObjDesc->Common.Type)
-        {
-        case ACPI_TYPE_LOCAL_REFERENCE:
-
-            AcpiOsPrintf ("[%s] ", AcpiUtGetReferenceName (ObjDesc));
-
-            /* Decode the refererence */
-
-            switch (ObjDesc->Reference.Class)
-            {
-            case ACPI_REFCLASS_LOCAL:
-
-                AcpiOsPrintf ("%X ", ObjDesc->Reference.Value);
-                if (WalkState)
-                {
-                    ObjDesc = WalkState->LocalVariables
-                                [ObjDesc->Reference.Value].Object;
-                    AcpiOsPrintf ("%p", ObjDesc);
-                    AcpiDmDecodeInternalObject (ObjDesc);
-                }
-                break;
-
-
-            case ACPI_REFCLASS_ARG:
-
-                AcpiOsPrintf ("%X ", ObjDesc->Reference.Value);
-                if (WalkState)
-                {
-                    ObjDesc = WalkState->Arguments
-                                [ObjDesc->Reference.Value].Object;
-                    AcpiOsPrintf ("%p", ObjDesc);
-                    AcpiDmDecodeInternalObject (ObjDesc);
-                }
-                break;
-
-
-            case ACPI_REFCLASS_INDEX:
-
-                switch (ObjDesc->Reference.TargetType)
-                {
-                case ACPI_TYPE_BUFFER_FIELD:
-
-                    AcpiOsPrintf ("%p", ObjDesc->Reference.Object);
-                    AcpiDmDecodeInternalObject (ObjDesc->Reference.Object);
-                    break;
-
-                case ACPI_TYPE_PACKAGE:
-
-                    AcpiOsPrintf ("%p", ObjDesc->Reference.Where);
-                    if (!ObjDesc->Reference.Where)
-                    {
-                        AcpiOsPrintf (" Uninitialized WHERE pointer");
-                    }
-                    else
-                    {
-                        AcpiDmDecodeInternalObject (
-                            *(ObjDesc->Reference.Where));
-                    }
-                    break;
-
-                default:
-
-                    AcpiOsPrintf ("Unknown index target type");
-                    break;
-                }
-                break;
-
-
-            case ACPI_REFCLASS_REFOF:
-
-                if (!ObjDesc->Reference.Object)
-                {
-                    AcpiOsPrintf ("Uninitialized reference subobject pointer");
-                    break;
-                }
-
-                /* Reference can be to a Node or an Operand object */
-
-                switch (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc->Reference.Object))
-                {
-                case ACPI_DESC_TYPE_NAMED:
-                    AcpiDmDecodeNode (ObjDesc->Reference.Object);
-                    break;
-
-                case ACPI_DESC_TYPE_OPERAND:
-                    AcpiDmDecodeInternalObject (ObjDesc->Reference.Object);
-                    break;
-
-                default:
-                    break;
-                }
-                break;
-
-
-            case ACPI_REFCLASS_NAME:
-
-                AcpiDmDecodeNode (ObjDesc->Reference.Node);
-                break;
-
-
-            case ACPI_REFCLASS_DEBUG:
-            case ACPI_REFCLASS_TABLE:
-
-                AcpiOsPrintf ("\n");
-                break;
-
-
-            default:    /* Unknown reference class */
-
-                AcpiOsPrintf ("%2.2X\n", ObjDesc->Reference.Class);
-                break;
-            }
-            break;
-
-
-        default:
-
-            AcpiOsPrintf ("<Obj>            ");
-            AcpiDmDecodeInternalObject (ObjDesc);
-            break;
-        }
-        break;
-
-
-    default:
-
-        AcpiOsPrintf ("<Not a valid ACPI Object Descriptor> [%s]",
-            AcpiUtGetDescriptorName (ObjDesc));
-        break;
-    }
-
-    AcpiOsPrintf ("\n");
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDmDisplayLocals
- *
- * PARAMETERS:  WalkState       - State for current method
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display all locals for the currently running control method
- *
- ******************************************************************************/
-
-void
-AcpiDmDisplayLocals (
-    ACPI_WALK_STATE         *WalkState)
-{
-    UINT32                  i;
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_NAMESPACE_NODE     *Node;
-
-
-    ObjDesc = WalkState->MethodDesc;
-    Node    = WalkState->MethodNode;
-    if (!Node)
-    {
-        AcpiOsPrintf (
-            "No method node (Executing subtree for buffer or opregion)\n");
-        return;
-    }
-
-    if (Node->Type != ACPI_TYPE_METHOD)
-    {
-        AcpiOsPrintf ("Executing subtree for Buffer/Package/Region\n");
-        return;
-    }
-
-    AcpiOsPrintf ("Local Variables for method [%4.4s]:\n",
-            AcpiUtGetNodeName (Node));
-
-    for (i = 0; i < ACPI_METHOD_NUM_LOCALS; i++)
-    {
-        ObjDesc = WalkState->LocalVariables[i].Object;
-        AcpiOsPrintf ("    Local%X: ", i);
-        AcpiDmDisplayInternalObject (ObjDesc, WalkState);
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiDmDisplayArguments
- *
- * PARAMETERS:  WalkState       - State for current method
- *
- * RETURN:      None
- *
- * DESCRIPTION: Display all arguments for the currently running control method
- *
- ******************************************************************************/
-
-void
-AcpiDmDisplayArguments (
-    ACPI_WALK_STATE         *WalkState)
-{
-    UINT32                  i;
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_NAMESPACE_NODE     *Node;
-
-
-    ObjDesc = WalkState->MethodDesc;
-    Node    = WalkState->MethodNode;
-    if (!Node)
-    {
-        AcpiOsPrintf (
-            "No method node (Executing subtree for buffer or opregion)\n");
-        return;
-    }
-
-    if (Node->Type != ACPI_TYPE_METHOD)
-    {
-        AcpiOsPrintf ("Executing subtree for Buffer/Package/Region\n");
-        return;
-    }
-
-    AcpiOsPrintf (
-        "Arguments for Method [%4.4s]:  (%X arguments defined, max concurrency = %X)\n",
-        AcpiUtGetNodeName (Node), ObjDesc->Method.ParamCount, ObjDesc->Method.SyncLevel);
-
-    for (i = 0; i < ACPI_METHOD_NUM_ARGS; i++)
-    {
-        ObjDesc = WalkState->Arguments[i].Object;
-        AcpiOsPrintf ("    Arg%u:   ", i);
-        AcpiDmDisplayInternalObject (ObjDesc, WalkState);
-    }
-}
-
-#endif
-
-
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmopcode.c b/usr/src/uts/intel/io/acpica/disassembler/dmopcode.c
index 6d2c3e1ecf..7ca171cbbb 100644
--- a/usr/src/uts/intel/io/acpica/disassembler/dmopcode.c
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmopcode.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -45,19 +45,395 @@
 #include "accommon.h"
 #include "acparser.h"
 #include "amlcode.h"
-#include "acdisasm.h"
+#include "acinterp.h"
+#include "acnamesp.h"
+#include "acdebug.h"
 
-#ifdef ACPI_DISASSEMBLER
 
 #define _COMPONENT          ACPI_CA_DEBUGGER
         ACPI_MODULE_NAME    ("dmopcode")
 
+
 /* Local prototypes */
 
 static void
 AcpiDmMatchKeyword (
     ACPI_PARSE_OBJECT       *Op);
 
+static void
+AcpiDmConvertToElseIf (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmDisplayTargetPathname
+ *
+ * PARAMETERS:  Op              - Parse object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: For AML opcodes that have a target operand, display the full
+ *              pathname for the target, in a comment field. Handles Return()
+ *              statements also.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmDisplayTargetPathname (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_PARSE_OBJECT       *PrevOp = NULL;
+    char                    *Pathname;
+    const ACPI_OPCODE_INFO  *OpInfo;
+
+
+    if (Op->Common.AmlOpcode == AML_RETURN_OP)
+    {
+        PrevOp = Op->Asl.Value.Arg;
+    }
+    else
+    {
+        OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+        if (!(OpInfo->Flags & AML_HAS_TARGET))
+        {
+            return;
+        }
+
+        /* Target is the last Op in the arg list */
+
+        NextOp = Op->Asl.Value.Arg;
+        while (NextOp)
+        {
+            PrevOp = NextOp;
+            NextOp = PrevOp->Asl.Next;
+        }
+    }
+
+    if (!PrevOp)
+    {
+        return;
+    }
+
+    /* We must have a namepath AML opcode */
+
+    if (PrevOp->Asl.AmlOpcode != AML_INT_NAMEPATH_OP)
+    {
+        return;
+    }
+
+    /* A null string is the "no target specified" case */
+
+    if (!PrevOp->Asl.Value.String)
+    {
+        return;
+    }
+
+    /* No node means "unresolved external reference" */
+
+    if (!PrevOp->Asl.Node)
+    {
+        AcpiOsPrintf (" /* External reference */");
+        return;
+    }
+
+    /* Ignore if path is already from the root */
+
+    if (*PrevOp->Asl.Value.String == '\\')
+    {
+        return;
+    }
+
+    /* Now: we can get the full pathname */
+
+    Pathname = AcpiNsGetExternalPathname (PrevOp->Asl.Node);
+    if (!Pathname)
+    {
+        return;
+    }
+
+    AcpiOsPrintf (" /* %s */", Pathname);
+    ACPI_FREE (Pathname);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmNotifyDescription
+ *
+ * PARAMETERS:  Op              - Name() parse object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit a description comment for the value associated with a
+ *              Notify() operator.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmNotifyDescription (
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_NAMESPACE_NODE     *Node;
+    UINT8                   NotifyValue;
+    UINT8                   Type = ACPI_TYPE_ANY;
+
+
+    /* The notify value is the second argument */
+
+    NextOp = Op->Asl.Value.Arg;
+    NextOp = NextOp->Asl.Next;
+
+    switch (NextOp->Common.AmlOpcode)
+    {
+    case AML_ZERO_OP:
+    case AML_ONE_OP:
+
+        NotifyValue = (UINT8) NextOp->Common.AmlOpcode;
+        break;
+
+    case AML_BYTE_OP:
+
+        NotifyValue = (UINT8) NextOp->Asl.Value.Integer;
+        break;
+
+    default:
+        return;
+    }
+
+    /*
+     * Attempt to get the namespace node so we can determine the object type.
+     * Some notify values are dependent on the object type (Device, Thermal,
+     * or Processor).
+     */
+    Node = Op->Asl.Node;
+    if (Node)
+    {
+        Type = Node->Type;
+    }
+
+    AcpiOsPrintf (" // %s", AcpiUtGetNotifyName (NotifyValue, Type));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmPredefinedDescription
+ *
+ * PARAMETERS:  Op              - Name() parse object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit a description comment for a predefined ACPI name.
+ *              Used for iASL compiler only.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmPredefinedDescription (
+    ACPI_PARSE_OBJECT       *Op)
+{
+#ifdef ACPI_ASL_COMPILER
+    const AH_PREDEFINED_NAME    *Info;
+    char                        *NameString;
+    int                         LastCharIsDigit;
+    int                         LastCharsAreHex;
+
+
+    if (!Op)
+    {
+        return;
+    }
+
+    /* Ensure that the comment field is emitted only once */
+
+    if (Op->Common.DisasmFlags & ACPI_PARSEOP_PREDEFINED_CHECKED)
+    {
+        return;
+    }
+    Op->Common.DisasmFlags |= ACPI_PARSEOP_PREDEFINED_CHECKED;
+
+    /* Predefined name must start with an underscore */
+
+    NameString = ACPI_CAST_PTR (char, &Op->Named.Name);
+    if (NameString[0] != '_')
+    {
+        return;
+    }
+
+    /*
+     * Check for the special ACPI names:
+     * _ACd, _ALd, _EJd, _Exx, _Lxx, _Qxx, _Wxx, _T_a
+     * (where d=decimal_digit, x=hex_digit, a=anything)
+     *
+     * Convert these to the generic name for table lookup.
+     * Note: NameString is guaranteed to be upper case here.
+     */
+    LastCharIsDigit =
+        (isdigit ((int) NameString[3]));    /* d */
+    LastCharsAreHex =
+        (isxdigit ((int) NameString[2]) &&  /* xx */
+         isxdigit ((int) NameString[3]));
+
+    switch (NameString[1])
+    {
+    case 'A':
+
+        if ((NameString[2] == 'C') && (LastCharIsDigit))
+        {
+            NameString = "_ACx";
+        }
+        else if ((NameString[2] == 'L') && (LastCharIsDigit))
+        {
+            NameString = "_ALx";
+        }
+        break;
+
+    case 'E':
+
+        if ((NameString[2] == 'J') && (LastCharIsDigit))
+        {
+            NameString = "_EJx";
+        }
+        else if (LastCharsAreHex)
+        {
+            NameString = "_Exx";
+        }
+        break;
+
+    case 'L':
+
+        if (LastCharsAreHex)
+        {
+            NameString = "_Lxx";
+        }
+        break;
+
+    case 'Q':
+
+        if (LastCharsAreHex)
+        {
+            NameString = "_Qxx";
+        }
+        break;
+
+    case 'T':
+
+        if (NameString[2] == '_')
+        {
+            NameString = "_T_x";
+        }
+        break;
+
+    case 'W':
+
+        if (LastCharsAreHex)
+        {
+            NameString = "_Wxx";
+        }
+        break;
+
+    default:
+
+        break;
+    }
+
+    /* Match the name in the info table */
+
+    Info = AcpiAhMatchPredefinedName (NameString);
+    if (Info)
+    {
+        AcpiOsPrintf ("  // %4.4s: %s",
+            NameString, ACPI_CAST_PTR (char, Info->Description));
+    }
+
+#endif
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmFieldPredefinedDescription
+ *
+ * PARAMETERS:  Op              - Parse object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Emit a description comment for a resource descriptor tag
+ *              (which is a predefined ACPI name.) Used for iASL compiler only.
+ *
+ ******************************************************************************/
+
+void
+AcpiDmFieldPredefinedDescription (
+    ACPI_PARSE_OBJECT       *Op)
+{
+#ifdef ACPI_ASL_COMPILER
+    ACPI_PARSE_OBJECT       *IndexOp;
+    char                    *Tag;
+    const ACPI_OPCODE_INFO  *OpInfo;
+    const AH_PREDEFINED_NAME *Info;
+
+
+    if (!Op)
+    {
+        return;
+    }
+
+    /* Ensure that the comment field is emitted only once */
+
+    if (Op->Common.DisasmFlags & ACPI_PARSEOP_PREDEFINED_CHECKED)
+    {
+        return;
+    }
+    Op->Common.DisasmFlags |= ACPI_PARSEOP_PREDEFINED_CHECKED;
+
+    /*
+     * Op must be one of the Create* operators: CreateField, CreateBitField,
+     * CreateByteField, CreateWordField, CreateDwordField, CreateQwordField
+     */
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+    if (!(OpInfo->Flags & AML_CREATE))
+    {
+        return;
+    }
+
+    /* Second argument is the Index argument */
+
+    IndexOp = Op->Common.Value.Arg;
+    IndexOp = IndexOp->Common.Next;
+
+    /* Index argument must be a namepath */
+
+    if (IndexOp->Common.AmlOpcode != AML_INT_NAMEPATH_OP)
+    {
+        return;
+    }
+
+    /* Major cheat: We previously put the Tag ptr in the Node field */
+
+    Tag = ACPI_CAST_PTR (char, IndexOp->Common.Node);
+    if (!Tag)
+    {
+        return;
+    }
+
+    /* Match the name in the info table */
+
+    Info = AcpiAhMatchPredefinedName (Tag);
+    if (Info)
+    {
+        AcpiOsPrintf ("  // %4.4s: %s", Tag,
+            ACPI_CAST_PTR (char, Info->Description));
+    }
+
+#endif
+    return;
+}
+
 
 /*******************************************************************************
  *
@@ -195,7 +571,6 @@ AcpiDmRegionFlags (
     ACPI_PARSE_OBJECT       *Op)
 {
 
-
     /* The next Op contains the SpaceId */
 
     Op = AcpiPsGetDepthNext (NULL, Op);
@@ -265,15 +640,14 @@ AcpiDmMatchKeyword (
     ACPI_PARSE_OBJECT       *Op)
 {
 
-
     if (((UINT32) Op->Common.Value.Integer) > ACPI_MAX_MATCH_OPCODE)
     {
         AcpiOsPrintf ("/* Unknown Match Keyword encoding */");
     }
     else
     {
-        AcpiOsPrintf ("%s", ACPI_CAST_PTR (char,
-            AcpiGbl_MatchOps[(ACPI_SIZE) Op->Common.Value.Integer]));
+        AcpiOsPrintf ("%s",
+            AcpiGbl_MatchOps[(ACPI_SIZE) Op->Common.Value.Integer]);
     }
 }
 
@@ -304,6 +678,7 @@ AcpiDmDisassembleOneOp (
     ACPI_PARSE_OBJECT       *Child;
     ACPI_STATUS             Status;
     UINT8                   *Aml;
+    const AH_DEVICE_ID      *IdInfo;
 
 
     if (!Op)
@@ -312,6 +687,11 @@ AcpiDmDisassembleOneOp (
         return;
     }
 
+    if (Op->Common.DisasmFlags & ACPI_PARSEOP_ELSEIF)
+    {
+        return; /* ElseIf macro was already emitted */
+    }
+
     switch (Op->Common.DisasmOpcode)
     {
     case ACPI_DASM_MATCHOP:
@@ -320,23 +700,28 @@ AcpiDmDisassembleOneOp (
         return;
 
     case ACPI_DASM_LNOT_SUFFIX:
-        switch (Op->Common.AmlOpcode)
+
+        if (!AcpiGbl_CstyleDisassembly)
         {
-        case AML_LEQUAL_OP:
-            AcpiOsPrintf ("LNotEqual");
-            break;
+            switch (Op->Common.AmlOpcode)
+            {
+            case AML_LEQUAL_OP:
+                AcpiOsPrintf ("LNotEqual");
+                break;
 
-        case AML_LGREATER_OP:
-            AcpiOsPrintf ("LLessEqual");
-            break;
+            case AML_LGREATER_OP:
+                AcpiOsPrintf ("LLessEqual");
+                break;
 
-        case AML_LLESS_OP:
-            AcpiOsPrintf ("LGreaterEqual");
-            break;
+            case AML_LLESS_OP:
+                AcpiOsPrintf ("LGreaterEqual");
+                break;
 
-        default:
-            break;
+            default:
+                break;
+            }
         }
+
         Op->Common.DisasmOpcode = 0;
         Op->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
         return;
@@ -345,7 +730,6 @@ AcpiDmDisassembleOneOp (
         break;
     }
 
-
     OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
 
     /* The op and arguments */
@@ -373,12 +757,11 @@ AcpiDmDisassembleOneOp (
         AcpiOsPrintf ("0x%2.2X", (UINT32) Op->Common.Value.Integer);
         break;
 
-
     case AML_WORD_OP:
 
         if (Op->Common.DisasmOpcode == ACPI_DASM_EISAID)
         {
-            AcpiDmEisaId ((UINT32) Op->Common.Value.Integer);
+            AcpiDmDecompressEisaId ((UINT32) Op->Common.Value.Integer);
         }
         else
         {
@@ -386,12 +769,11 @@ AcpiDmDisassembleOneOp (
         }
         break;
 
-
     case AML_DWORD_OP:
 
         if (Op->Common.DisasmOpcode == ACPI_DASM_EISAID)
         {
-            AcpiDmEisaId ((UINT32) Op->Common.Value.Integer);
+            AcpiDmDecompressEisaId ((UINT32) Op->Common.Value.Integer);
         }
         else
         {
@@ -399,24 +781,33 @@ AcpiDmDisassembleOneOp (
         }
         break;
 
-
     case AML_QWORD_OP:
 
         AcpiOsPrintf ("0x%8.8X%8.8X",
             ACPI_FORMAT_UINT64 (Op->Common.Value.Integer));
         break;
 
-
     case AML_STRING_OP:
 
-        AcpiUtPrintString (Op->Common.Value.String, ACPI_UINT8_MAX);
-        break;
+        AcpiUtPrintString (Op->Common.Value.String, ACPI_UINT16_MAX);
 
+        /* For _HID/_CID strings, attempt to output a descriptive comment */
 
-    case AML_BUFFER_OP:
+        if (Op->Common.DisasmOpcode == ACPI_DASM_HID_STRING)
+        {
+            /* If we know about the ID, emit the description */
 
+            IdInfo = AcpiAhMatchHardwareId (Op->Common.Value.String);
+            if (IdInfo)
+            {
+                AcpiOsPrintf (" /* %s */", IdInfo->Description);
+            }
+        }
+        break;
+
+    case AML_BUFFER_OP:
         /*
-         * Determine the type of buffer.  We can have one of the following:
+         * Determine the type of buffer. We can have one of the following:
          *
          * 1) ResourceTemplate containing Resource Descriptors.
          * 2) Unicode String buffer
@@ -429,7 +820,7 @@ AcpiDmDisassembleOneOp (
          */
         if (!AcpiGbl_NoResourceDisassembly)
         {
-            Status = AcpiDmIsResourceTemplate (Op);
+            Status = AcpiDmIsResourceTemplate (WalkState, Op);
             if (ACPI_SUCCESS (Status))
             {
                 Op->Common.DisasmOpcode = ACPI_DASM_RESOURCE;
@@ -438,11 +829,18 @@ AcpiDmDisassembleOneOp (
             }
             else if (Status == AE_AML_NO_RESOURCE_END_TAG)
             {
-                AcpiOsPrintf ("/**** Is ResourceTemplate, but EndTag not at buffer end ****/ ");
+                AcpiOsPrintf (
+                    "/**** Is ResourceTemplate, "
+                    "but EndTag not at buffer end ****/ ");
             }
         }
 
-        if (AcpiDmIsUnicodeBuffer (Op))
+        if (AcpiDmIsUuidBuffer (Op))
+        {
+            Op->Common.DisasmOpcode = ACPI_DASM_UUID;
+            AcpiOsPrintf ("ToUUID (");
+        }
+        else if (AcpiDmIsUnicodeBuffer (Op))
         {
             Op->Common.DisasmOpcode = ACPI_DASM_UNICODE;
             AcpiOsPrintf ("Unicode (");
@@ -452,33 +850,23 @@ AcpiDmDisassembleOneOp (
             Op->Common.DisasmOpcode = ACPI_DASM_STRING;
             AcpiOsPrintf ("Buffer");
         }
-        else
-        {
-            Op->Common.DisasmOpcode = ACPI_DASM_BUFFER;
-            AcpiOsPrintf ("Buffer");
-        }
-        break;
-
-
-    case AML_INT_STATICSTRING_OP:
-
-        if (Op->Common.Value.String)
+        else if (AcpiDmIsPldBuffer (Op))
         {
-            AcpiOsPrintf ("%s", Op->Common.Value.String);
+            Op->Common.DisasmOpcode = ACPI_DASM_PLD_METHOD;
+            AcpiOsPrintf ("ToPLD (");
         }
         else
         {
-            AcpiOsPrintf ("\"<NULL STATIC STRING PTR>\"");
+            Op->Common.DisasmOpcode = ACPI_DASM_BUFFER;
+            AcpiOsPrintf ("Buffer");
         }
         break;
 
-
     case AML_INT_NAMEPATH_OP:
 
         AcpiDmNamestring (Op->Common.Value.Name);
         break;
 
-
     case AML_INT_NAMEDFIELD_OP:
 
         Length = AcpiDmDumpName (Op->Named.Name);
@@ -489,7 +877,6 @@ AcpiDmDisassembleOneOp (
         Info->BitOffset += (UINT32) Op->Common.Value.Integer;
         break;
 
-
     case AML_INT_RESERVEDFIELD_OP:
 
         /* Offset() -- Must account for previous offsets */
@@ -509,7 +896,6 @@ AcpiDmDisassembleOneOp (
         AcpiDmCommaIfFieldMember (Op);
         break;
 
-
     case AML_INT_ACCESSFIELD_OP:
     case AML_INT_EXTACCESSFIELD_OP:
 
@@ -520,16 +906,15 @@ AcpiDmDisassembleOneOp (
 
         if (Op->Common.AmlOpcode == AML_INT_EXTACCESSFIELD_OP)
         {
-            AcpiOsPrintf (" (0x%2.2X)", (unsigned) ((Op->Common.Value.Integer >> 16) & 0xFF));
+            AcpiOsPrintf (" (0x%2.2X)", (unsigned)
+                ((Op->Common.Value.Integer >> 16) & 0xFF));
         }
 
         AcpiOsPrintf (")");
         AcpiDmCommaIfFieldMember (Op);
         break;
 
-
     case AML_INT_CONNECTION_OP:
-
         /*
          * Two types of Connection() - one with a buffer object, the
          * other with a namestring that points to a buffer object.
@@ -545,7 +930,9 @@ AcpiDmDisassembleOneOp (
             Length = (UINT32) Child->Common.Value.Integer;
 
             Info->Level += 1;
+            Info->MappingOp = Op;
             Op->Common.DisasmOpcode = ACPI_DASM_RESOURCE;
+
             AcpiDmResourceTemplate (Info, Op->Common.Parent, Aml, Length);
 
             Info->Level -= 1;
@@ -569,7 +956,6 @@ AcpiDmDisassembleOneOp (
         AcpiDmByteList (Info, Op);
         break;
 
-
     case AML_INT_METHODCALL_OP:
 
         Op = AcpiPsGetDepthNext (NULL, Op);
@@ -578,6 +964,23 @@ AcpiDmDisassembleOneOp (
         AcpiDmNamestring (Op->Common.Value.Name);
         break;
 
+    case AML_ELSE_OP:
+
+        AcpiDmConvertToElseIf (Op);
+        break;
+
+    case AML_EXTERNAL_OP:
+
+        if (AcpiGbl_DmEmitExternalOpcodes)
+        {
+            AcpiOsPrintf ("/* Opcode 0x15 */ ");
+
+            /* Fallthrough */
+        }
+        else
+        {
+            break;
+        }
 
     default:
 
@@ -593,7 +996,7 @@ AcpiDmDisassembleOneOp (
             (WalkState->Results) &&
             (WalkState->ResultCount))
         {
-            AcpiDmDecodeInternalObject (
+            AcpiDbDecodeInternalObject (
                 WalkState->Results->Results.ObjDesc [
                     (WalkState->ResultCount - 1) %
                         ACPI_RESULTS_FRAME_OBJ_NUM]);
@@ -604,4 +1007,118 @@ AcpiDmDisassembleOneOp (
     }
 }
 
-#endif  /* ACPI_DISASSEMBLER */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDmConvertToElseIf
+ *
+ * PARAMETERS:  OriginalElseOp          - ELSE Object to be examined
+ *
+ * RETURN:      None. Emits either an "Else" or an "ElseIf" ASL operator.
+ *
+ * DESCRIPTION: Detect and convert an If..Else..If sequence to If..ElseIf
+ *
+ * EXAMPLE:
+ *
+ * This If..Else..If nested sequence:
+ *
+ *        If (Arg0 == 1)
+ *        {
+ *            Local0 = 4
+ *        }
+ *        Else
+ *        {
+ *            If (Arg0 == 2)
+ *            {
+ *                Local0 = 5
+ *            }
+ *        }
+ *
+ * Is converted to this simpler If..ElseIf sequence:
+ *
+ *        If (Arg0 == 1)
+ *        {
+ *            Local0 = 4
+ *        }
+ *        ElseIf (Arg0 == 2)
+ *        {
+ *            Local0 = 5
+ *        }
+ *
+ * NOTE: There is no actual ElseIf AML opcode. ElseIf is essentially an ASL
+ * macro that emits an Else opcode followed by an If opcode. This function
+ * reverses these AML sequences back to an ElseIf macro where possible. This
+ * can make the disassembled ASL code simpler and more like the original code.
+ *
+ ******************************************************************************/
+
+static void
+AcpiDmConvertToElseIf (
+    ACPI_PARSE_OBJECT       *OriginalElseOp)
+{
+    ACPI_PARSE_OBJECT       *IfOp;
+    ACPI_PARSE_OBJECT       *ElseOp;
+
+
+    /*
+     * To be able to perform the conversion, two conditions must be satisfied:
+     * 1) The first child of the Else must be an If statement.
+     * 2) The If block can only be followed by an Else block and these must
+     *    be the only blocks under the original Else.
+     */
+    IfOp = OriginalElseOp->Common.Value.Arg;
+    if (!IfOp ||
+        (IfOp->Common.AmlOpcode != AML_IF_OP) ||
+        (IfOp->Asl.Next && (IfOp->Asl.Next->Common.AmlOpcode != AML_ELSE_OP)))
+    {
+        /* Not an Else..If sequence, cannot convert to ElseIf */
+
+        AcpiOsPrintf ("%s", "Else");
+        return;
+    }
+
+    /* Emit ElseIf, mark the IF as now an ELSEIF */
+
+    AcpiOsPrintf ("%s", "ElseIf");
+    IfOp->Common.DisasmFlags |= ACPI_PARSEOP_ELSEIF;
+
+    /* The IF parent will now be the same as the original ELSE parent */
+
+    IfOp->Common.Parent = OriginalElseOp->Common.Parent;
+
+    /*
+     * Update the NEXT pointers to restructure the parse tree, essentially
+     * promoting an If..Else block up to the same level as the original
+     * Else.
+     *
+     * Check if the IF has a corresponding ELSE peer
+     */
+    ElseOp = IfOp->Common.Next;
+    if (ElseOp &&
+        (ElseOp->Common.AmlOpcode == AML_ELSE_OP))
+    {
+        /* If an ELSE matches the IF, promote it also */
+
+        ElseOp->Common.Parent = OriginalElseOp->Common.Parent;
+        ElseOp->Common.Next = OriginalElseOp->Common.Next;
+    }
+    else
+    {
+        /* Otherwise, set the IF NEXT to the original ELSE NEXT */
+
+        IfOp->Common.Next = OriginalElseOp->Common.Next;
+    }
+
+    /* Detach the child IF block from the original ELSE */
+
+    OriginalElseOp->Common.Value.Arg = NULL;
+
+    /* Ignore the original ELSE from now on */
+
+    OriginalElseOp->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
+    OriginalElseOp->Common.DisasmOpcode = ACPI_DASM_LNOT_PREFIX;
+
+    /* Insert IF (now ELSEIF) as next peer of the original ELSE */
+
+    OriginalElseOp->Common.Next = IfOp;
+}
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmresrc.c b/usr/src/uts/intel/io/acpica/disassembler/dmresrc.c
index 9c07bf7e94..a486f1d892 100644
--- a/usr/src/uts/intel/io/acpica/disassembler/dmresrc.c
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmresrc.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,13 +41,11 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "amlcode.h"
 #include "acdisasm.h"
 
-#ifdef ACPI_DISASSEMBLER
 
 #define _COMPONENT          ACPI_CA_DEBUGGER
         ACPI_MODULE_NAME    ("dbresrc")
@@ -147,7 +145,7 @@ AcpiDmDescriptorName (
 void
 AcpiDmDumpInteger8 (
     UINT8                   Value,
-    char                    *Name)
+    const char              *Name)
 {
     AcpiOsPrintf ("0x%2.2X,               // %s\n", Value, Name);
 }
@@ -155,7 +153,7 @@ AcpiDmDumpInteger8 (
 void
 AcpiDmDumpInteger16 (
     UINT16                  Value,
-    char                    *Name)
+    const char              *Name)
 {
     AcpiOsPrintf ("0x%4.4X,             // %s\n", Value, Name);
 }
@@ -163,7 +161,7 @@ AcpiDmDumpInteger16 (
 void
 AcpiDmDumpInteger32 (
     UINT32                  Value,
-    char                    *Name)
+    const char              *Name)
 {
     AcpiOsPrintf ("0x%8.8X,         // %s\n", Value, Name);
 }
@@ -171,7 +169,7 @@ AcpiDmDumpInteger32 (
 void
 AcpiDmDumpInteger64 (
     UINT64                  Value,
-    char                    *Name)
+    const char              *Name)
 {
     AcpiOsPrintf ("0x%8.8X%8.8X, // %s\n", ACPI_FORMAT_UINT64 (Value), Name);
 }
@@ -214,6 +212,7 @@ AcpiDmBitList (
             {
                 AcpiOsPrintf (",");
             }
+
             Previous = TRUE;
             AcpiOsPrintf ("%u", i);
         }
@@ -260,6 +259,11 @@ AcpiDmResourceTemplate (
     ACPI_NAMESPACE_NODE     *Node;
 
 
+    if (Op->Asl.AmlOpcode != AML_FIELD_OP)
+    {
+        Info->MappingOp = Op;
+    }
+
     Level = Info->Level;
     ResourceName = ACPI_DEFAULT_RESNAME;
     Node = Op->Common.Node;
@@ -279,10 +283,11 @@ AcpiDmResourceTemplate (
 
         /* Validate the Resource Type and Resource Length */
 
-        Status = AcpiUtValidateResource (Aml, &ResourceIndex);
+        Status = AcpiUtValidateResource (NULL, Aml, &ResourceIndex);
         if (ACPI_FAILURE (Status))
         {
-            AcpiOsPrintf ("/*** Could not validate Resource, type (%X) %s***/\n",
+            AcpiOsPrintf (
+                "/*** Could not validate Resource, type (%X) %s***/\n",
                 ResourceType, AcpiFormatException (Status));
             return;
         }
@@ -328,15 +333,17 @@ AcpiDmResourceTemplate (
 
                 /* Go ahead and insert EndDependentFn() */
 
-                AcpiDmEndDependentDescriptor (Aml, ResourceLength, Level);
+                AcpiDmEndDependentDescriptor (Info, Aml, ResourceLength, Level);
 
                 AcpiDmIndent (Level);
                 AcpiOsPrintf (
-                    "/*** Disassembler: inserted missing EndDependentFn () ***/\n");
+                    "/*** Disassembler: inserted "
+                    "missing EndDependentFn () ***/\n");
             }
             return;
 
         default:
+
             break;
         }
 
@@ -349,7 +356,7 @@ AcpiDmResourceTemplate (
         }
 
         AcpiGbl_DmResourceDispatch [ResourceIndex] (
-            Aml, ResourceLength, Level);
+            Info, Aml, ResourceLength, Level);
 
         /* Descriptor post-processing */
 
@@ -366,17 +373,19 @@ AcpiDmResourceTemplate (
  *
  * FUNCTION:    AcpiDmIsResourceTemplate
  *
- * PARAMETERS:  Op          - Buffer Op to be examined
+ * PARAMETERS:  WalkState           - Current walk info
+ *              Op                  - Buffer Op to be examined
  *
  * RETURN:      Status. AE_OK if valid template
  *
  * DESCRIPTION: Walk a byte list to determine if it consists of a valid set
- *              of resource descriptors.  Nothing is output.
+ *              of resource descriptors. Nothing is output.
  *
  ******************************************************************************/
 
 ACPI_STATUS
 AcpiDmIsResourceTemplate (
+    ACPI_WALK_STATE         *WalkState,
     ACPI_PARSE_OBJECT       *Op)
 {
     ACPI_STATUS             Status;
@@ -396,6 +405,12 @@ AcpiDmIsResourceTemplate (
     /* Get the ByteData list and length */
 
     NextOp = Op->Common.Value.Arg;
+    if (!NextOp)
+    {
+        AcpiOsPrintf ("NULL byte list in buffer\n");
+        return (AE_TYPE);
+    }
+
     NextOp = NextOp->Common.Next;
     if (!NextOp)
     {
@@ -407,7 +422,8 @@ AcpiDmIsResourceTemplate (
 
     /* Walk the byte list, abort on any invalid descriptor type or length */
 
-    Status = AcpiUtWalkAmlResources (Aml, Length, NULL, &EndAml);
+    Status = AcpiUtWalkAmlResources (WalkState, Aml, Length,
+        NULL, ACPI_CAST_INDIRECT_PTR (void, &EndAml));
     if (ACPI_FAILURE (Status))
     {
         return (AE_TYPE);
@@ -430,5 +446,3 @@ AcpiDmIsResourceTemplate (
      */
     return (AE_OK);
 }
-
-#endif
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmresrcl.c b/usr/src/uts/intel/io/acpica/disassembler/dmresrcl.c
index ed78b31c70..52fd3356b8 100644
--- a/usr/src/uts/intel/io/acpica/disassembler/dmresrcl.c
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmresrcl.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,21 +41,18 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdisasm.h"
 
 
-#ifdef ACPI_DISASSEMBLER
-
 #define _COMPONENT          ACPI_CA_DEBUGGER
         ACPI_MODULE_NAME    ("dbresrcl")
 
 
 /* Common names for address and memory descriptors */
 
-static char                 *AcpiDmAddressNames[] =
+static const char           *AcpiDmAddressNames[] =
 {
     "Granularity",
     "Range Minimum",
@@ -64,7 +61,7 @@ static char                 *AcpiDmAddressNames[] =
     "Length"
 };
 
-static char                 *AcpiDmMemoryNames[] =
+static const char           *AcpiDmMemoryNames[] =
 {
     "Range Minimum",
     "Range Maximum",
@@ -153,16 +150,19 @@ AcpiDmMemoryFields (
         switch (Type)
         {
         case 16:
+
             AcpiDmDumpInteger16 (ACPI_CAST_PTR (UINT16, Source)[i],
                 AcpiDmMemoryNames[i]);
             break;
 
         case 32:
+
             AcpiDmDumpInteger32 (ACPI_CAST_PTR (UINT32, Source)[i],
                 AcpiDmMemoryNames[i]);
             break;
 
         default:
+
             return;
         }
     }
@@ -201,21 +201,25 @@ AcpiDmAddressFields (
         switch (Type)
         {
         case 16:
+
             AcpiDmDumpInteger16 (ACPI_CAST_PTR (UINT16, Source)[i],
                 AcpiDmAddressNames[i]);
             break;
 
         case 32:
+
             AcpiDmDumpInteger32 (ACPI_CAST_PTR (UINT32, Source)[i],
                 AcpiDmAddressNames[i]);
             break;
 
         case 64:
+
             AcpiDmDumpInteger64 (ACPI_CAST_PTR (UINT64, Source)[i],
                 AcpiDmAddressNames[i]);
             break;
 
         default:
+
             return;
         }
     }
@@ -242,22 +246,27 @@ AcpiDmAddressPrefix (
     switch (Type)
     {
     case ACPI_RESOURCE_TYPE_ADDRESS16:
+
         AcpiOsPrintf ("Word");
         break;
 
     case ACPI_RESOURCE_TYPE_ADDRESS32:
+
         AcpiOsPrintf ("DWord");
         break;
 
     case ACPI_RESOURCE_TYPE_ADDRESS64:
+
         AcpiOsPrintf ("QWord");
         break;
 
     case ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64:
+
         AcpiOsPrintf ("Extended");
         break;
 
     default:
+
         return;
     }
 }
@@ -298,7 +307,8 @@ AcpiDmAddressCommon (
 
     if ((ResourceType > 2) && (ResourceType < 0xC0))
     {
-        AcpiOsPrintf ("/**** Invalid Resource Type: 0x%X ****/", ResourceType);
+        AcpiOsPrintf (
+            "/**** Invalid Resource Type: 0x%X ****/", ResourceType);
         return;
     }
 
@@ -318,7 +328,8 @@ AcpiDmAddressCommon (
 
     /* This is either a Memory, IO, or BusNumber descriptor (0,1,2) */
 
-    AcpiOsPrintf ("%s (", AcpiGbl_WordDecode [ResourceType & 0x3]);
+    AcpiOsPrintf ("%s (",
+        AcpiGbl_WordDecode [ACPI_GET_2BIT_FLAG (ResourceType)]);
 
     /* Decode the general and type-specific flags */
 
@@ -331,7 +342,8 @@ AcpiDmAddressCommon (
         AcpiDmIoFlags (Flags);
         if (ResourceType == ACPI_IO_RANGE)
         {
-            AcpiOsPrintf (" %s,", AcpiGbl_RngDecode [SpecificFlags & 0x3]);
+            AcpiOsPrintf (" %s,",
+                AcpiGbl_RngDecode [ACPI_GET_2BIT_FLAG (SpecificFlags)]);
         }
     }
 }
@@ -383,10 +395,10 @@ AcpiDmSpaceFlags (
 {
 
     AcpiOsPrintf ("%s, %s, %s, %s,",
-        AcpiGbl_ConsumeDecode [(Flags & 1)],
-        AcpiGbl_DecDecode [(Flags & 0x2) >> 1],
-        AcpiGbl_MinDecode [(Flags & 0x4) >> 2],
-        AcpiGbl_MaxDecode [(Flags & 0x8) >> 3]);
+        AcpiGbl_ConsumeDecode [ACPI_GET_1BIT_FLAG (Flags)],
+        AcpiGbl_DecDecode [ACPI_EXTRACT_1BIT_FLAG (Flags, 1)],
+        AcpiGbl_MinDecode [ACPI_EXTRACT_1BIT_FLAG (Flags, 2)],
+        AcpiGbl_MaxDecode [ACPI_EXTRACT_1BIT_FLAG (Flags, 3)]);
 }
 
 
@@ -407,10 +419,10 @@ AcpiDmIoFlags (
         UINT8               Flags)
 {
     AcpiOsPrintf ("%s, %s, %s, %s,",
-        AcpiGbl_ConsumeDecode [(Flags & 1)],
-        AcpiGbl_MinDecode [(Flags & 0x4) >> 2],
-        AcpiGbl_MaxDecode [(Flags & 0x8) >> 3],
-        AcpiGbl_DecDecode [(Flags & 0x2) >> 1]);
+        AcpiGbl_ConsumeDecode [ACPI_GET_1BIT_FLAG (Flags)],
+        AcpiGbl_MinDecode [ACPI_EXTRACT_1BIT_FLAG (Flags, 2)],
+        AcpiGbl_MaxDecode [ACPI_EXTRACT_1BIT_FLAG (Flags, 3)],
+        AcpiGbl_DecDecode [ACPI_EXTRACT_1BIT_FLAG (Flags, 1)]);
 }
 
 
@@ -432,14 +444,14 @@ AcpiDmIoFlags2 (
 {
 
     AcpiOsPrintf (", %s",
-        AcpiGbl_TtpDecode [(SpecificFlags & 0x10) >> 4]);
+        AcpiGbl_TtpDecode [ACPI_EXTRACT_1BIT_FLAG (SpecificFlags, 4)]);
 
     /* TRS is only used if TTP is TypeTranslation */
 
     if (SpecificFlags & 0x10)
     {
         AcpiOsPrintf (", %s",
-            AcpiGbl_TrsDecode [(SpecificFlags & 0x20) >> 5]);
+            AcpiGbl_TrsDecode [ACPI_EXTRACT_1BIT_FLAG (SpecificFlags, 5)]);
     }
 }
 
@@ -464,12 +476,12 @@ AcpiDmMemoryFlags (
 {
 
     AcpiOsPrintf ("%s, %s, %s, %s, %s, %s,",
-        AcpiGbl_ConsumeDecode [(Flags & 1)],
-        AcpiGbl_DecDecode [(Flags & 0x2) >> 1],
-        AcpiGbl_MinDecode [(Flags & 0x4) >> 2],
-        AcpiGbl_MaxDecode [(Flags & 0x8) >> 3],
-        AcpiGbl_MemDecode [(SpecificFlags & 0x6) >> 1],
-        AcpiGbl_RwDecode [(SpecificFlags & 0x1)]);
+        AcpiGbl_ConsumeDecode [ACPI_GET_1BIT_FLAG (Flags)],
+        AcpiGbl_DecDecode [ACPI_EXTRACT_1BIT_FLAG (Flags, 1)],
+        AcpiGbl_MinDecode [ACPI_EXTRACT_1BIT_FLAG (Flags, 2)],
+        AcpiGbl_MaxDecode [ACPI_EXTRACT_1BIT_FLAG (Flags, 3)],
+        AcpiGbl_MemDecode [ACPI_EXTRACT_2BIT_FLAG (SpecificFlags, 1)],
+        AcpiGbl_RwDecode [ACPI_GET_1BIT_FLAG (SpecificFlags)]);
 }
 
 
@@ -491,8 +503,8 @@ AcpiDmMemoryFlags2 (
 {
 
     AcpiOsPrintf (", %s, %s",
-        AcpiGbl_MtpDecode [(SpecificFlags & 0x18) >> 3],
-        AcpiGbl_TtpDecode [(SpecificFlags & 0x20) >> 5]);
+        AcpiGbl_MtpDecode [ACPI_EXTRACT_2BIT_FLAG (SpecificFlags, 3)],
+        AcpiGbl_TtpDecode [ACPI_EXTRACT_1BIT_FLAG (SpecificFlags, 5)]);
 }
 
 
@@ -553,7 +565,7 @@ AcpiDmResourceSource (
     if (TotalLength > (MinimumTotalLength + 1))
     {
         AcpiOsPrintf (" ");
-        AcpiUtPrintString ((char *) &AmlResourceSource[1], ACPI_UINT8_MAX);
+        AcpiUtPrintString ((char *) &AmlResourceSource[1], ACPI_UINT16_MAX);
     }
 
     AcpiOsPrintf (", ");
@@ -564,7 +576,8 @@ AcpiDmResourceSource (
  *
  * FUNCTION:    AcpiDmWordDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -576,6 +589,7 @@ AcpiDmResourceSource (
 
 void
 AcpiDmWordDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -609,7 +623,8 @@ AcpiDmWordDescriptor (
  *
  * FUNCTION:    AcpiDmDwordDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -621,6 +636,7 @@ AcpiDmWordDescriptor (
 
 void
 AcpiDmDwordDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -654,7 +670,8 @@ AcpiDmDwordDescriptor (
  *
  * FUNCTION:    AcpiDmQwordDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -666,6 +683,7 @@ AcpiDmDwordDescriptor (
 
 void
 AcpiDmQwordDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -699,7 +717,8 @@ AcpiDmQwordDescriptor (
  *
  * FUNCTION:    AcpiDmExtendedDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -711,6 +730,7 @@ AcpiDmQwordDescriptor (
 
 void
 AcpiDmExtendedDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -718,7 +738,8 @@ AcpiDmExtendedDescriptor (
 
     /* Dump resource name and flags */
 
-    AcpiDmAddressCommon (Resource, ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64, Level);
+    AcpiDmAddressCommon (
+        Resource, ACPI_RESOURCE_TYPE_EXTENDED_ADDRESS64, Level);
 
     /* Dump the 5 contiguous QWORD values */
 
@@ -746,7 +767,8 @@ AcpiDmExtendedDescriptor (
  *
  * FUNCTION:    AcpiDmMemory24Descriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -758,6 +780,7 @@ AcpiDmExtendedDescriptor (
 
 void
 AcpiDmMemory24Descriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -767,7 +790,7 @@ AcpiDmMemory24Descriptor (
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("Memory24 (%s,\n",
-        AcpiGbl_RwDecode [Resource->Memory24.Flags & 1]);
+        AcpiGbl_RwDecode [ACPI_GET_1BIT_FLAG (Resource->Memory24.Flags)]);
 
     /* Dump the 4 contiguous WORD values */
 
@@ -785,7 +808,8 @@ AcpiDmMemory24Descriptor (
  *
  * FUNCTION:    AcpiDmMemory32Descriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -797,6 +821,7 @@ AcpiDmMemory24Descriptor (
 
 void
 AcpiDmMemory32Descriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -806,7 +831,7 @@ AcpiDmMemory32Descriptor (
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("Memory32 (%s,\n",
-        AcpiGbl_RwDecode [Resource->Memory32.Flags & 1]);
+        AcpiGbl_RwDecode [ACPI_GET_1BIT_FLAG (Resource->Memory32.Flags)]);
 
     /* Dump the 4 contiguous DWORD values */
 
@@ -824,7 +849,8 @@ AcpiDmMemory32Descriptor (
  *
  * FUNCTION:    AcpiDmFixedMemory32Descriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -836,6 +862,7 @@ AcpiDmMemory32Descriptor (
 
 void
 AcpiDmFixedMemory32Descriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -845,13 +872,15 @@ AcpiDmFixedMemory32Descriptor (
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("Memory32Fixed (%s,\n",
-        AcpiGbl_RwDecode [Resource->FixedMemory32.Flags & 1]);
+        AcpiGbl_RwDecode [ACPI_GET_1BIT_FLAG (Resource->FixedMemory32.Flags)]);
 
     AcpiDmIndent (Level + 1);
-    AcpiDmDumpInteger32 (Resource->FixedMemory32.Address, "Address Base");
+    AcpiDmDumpInteger32 (Resource->FixedMemory32.Address,
+        "Address Base");
 
     AcpiDmIndent (Level + 1);
-    AcpiDmDumpInteger32 (Resource->FixedMemory32.AddressLength, "Address Length");
+    AcpiDmDumpInteger32 (Resource->FixedMemory32.AddressLength,
+        "Address Length");
 
     /* Insert a descriptor name */
 
@@ -865,7 +894,8 @@ AcpiDmFixedMemory32Descriptor (
  *
  * FUNCTION:    AcpiDmGenericRegisterDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -877,6 +907,7 @@ AcpiDmFixedMemory32Descriptor (
 
 void
 AcpiDmGenericRegisterDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -921,7 +952,8 @@ AcpiDmGenericRegisterDescriptor (
  *
  * FUNCTION:    AcpiDmInterruptDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -933,6 +965,7 @@ AcpiDmGenericRegisterDescriptor (
 
 void
 AcpiDmInterruptDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -942,10 +975,10 @@ AcpiDmInterruptDescriptor (
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("Interrupt (%s, %s, %s, %s, ",
-        AcpiGbl_ConsumeDecode [(Resource->ExtendedIrq.Flags & 1)],
-        AcpiGbl_HeDecode [(Resource->ExtendedIrq.Flags >> 1) & 1],
-        AcpiGbl_LlDecode [(Resource->ExtendedIrq.Flags >> 2) & 1],
-        AcpiGbl_ShrDecode [(Resource->ExtendedIrq.Flags >> 3) & 1]);
+        AcpiGbl_ConsumeDecode [ACPI_GET_1BIT_FLAG (Resource->ExtendedIrq.Flags)],
+        AcpiGbl_HeDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->ExtendedIrq.Flags, 1)],
+        AcpiGbl_LlDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->ExtendedIrq.Flags, 2)],
+        AcpiGbl_ShrDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->ExtendedIrq.Flags, 3)]);
 
     /*
      * The ResourceSource fields are optional and appear after the interrupt
@@ -995,7 +1028,7 @@ AcpiDmInterruptDescriptor (
 
 void
 AcpiDmVendorCommon (
-    char                    *Name,
+    const char              *Name,
     UINT8                   *ByteData,
     UINT32                  Length,
     UINT32                  Level)
@@ -1027,7 +1060,8 @@ AcpiDmVendorCommon (
  *
  * FUNCTION:    AcpiDmVendorLargeDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -1039,6 +1073,7 @@ AcpiDmVendorCommon (
 
 void
 AcpiDmVendorLargeDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -1048,5 +1083,3 @@ AcpiDmVendorLargeDescriptor (
         ACPI_ADD_PTR (UINT8, Resource, sizeof (AML_RESOURCE_LARGE_HEADER)),
         Length, Level);
 }
-
-#endif
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmresrcl2.c b/usr/src/uts/intel/io/acpica/disassembler/dmresrcl2.c
index e79307ee72..2e3273113c 100644
--- a/usr/src/uts/intel/io/acpica/disassembler/dmresrcl2.c
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmresrcl2.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,14 +41,11 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdisasm.h"
 
 
-#ifdef ACPI_DISASSEMBLER
-
 #define _COMPONENT          ACPI_CA_DEBUGGER
         ACPI_MODULE_NAME    ("dbresrcl2")
 
@@ -56,24 +53,28 @@
 
 static void
 AcpiDmI2cSerialBusDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 static void
 AcpiDmSpiSerialBusDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 static void
 AcpiDmUartSerialBusDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 static void
 AcpiDmGpioCommon (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Level);
 
@@ -151,6 +152,7 @@ AcpiDmDumpRawDataBuffer (
 
             AcpiOsPrintf (", ");
         }
+
         AcpiOsPrintf ("\n");
         AcpiDmIndent (Level + 2);
 
@@ -168,7 +170,8 @@ Finish:
  *
  * FUNCTION:    AcpiDmGpioCommon
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Level               - Current source code indentation level
  *
  * RETURN:      None
@@ -179,12 +182,14 @@ Finish:
 
 static void
 AcpiDmGpioCommon (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Level)
 {
-    UINT32                  PinCount;
     UINT16                  *PinList;
     UINT8                   *VendorData;
+    char                    *DeviceName = NULL;
+    UINT32                  PinCount;
     UINT32                  i;
 
 
@@ -193,15 +198,15 @@ AcpiDmGpioCommon (
     AcpiDmIndent (Level + 1);
     if (Resource->Gpio.ResSourceOffset)
     {
-        AcpiUtPrintString (
-            ACPI_ADD_PTR (char, Resource, Resource->Gpio.ResSourceOffset),
-            ACPI_UINT8_MAX);
+        DeviceName = ACPI_ADD_PTR (char,
+            Resource, Resource->Gpio.ResSourceOffset),
+        AcpiUtPrintString (DeviceName, ACPI_UINT16_MAX);
     }
 
     AcpiOsPrintf (", ");
     AcpiOsPrintf ("0x%2.2X, ", Resource->Gpio.ResSourceIndex);
     AcpiOsPrintf ("%s, ",
-        AcpiGbl_ConsumeDecode [(Resource->Gpio.Flags & 1)]);
+        AcpiGbl_ConsumeDecode [ACPI_GET_1BIT_FLAG (Resource->Gpio.Flags)]);
 
     /* Insert a descriptor name */
 
@@ -238,11 +243,17 @@ AcpiDmGpioCommon (
     for (i = 0; i < PinCount; i++)
     {
         AcpiDmIndent (Level + 2);
-        AcpiOsPrintf ("0x%4.4X%s\n", PinList[i], ((i + 1) < PinCount) ? "," : "");
+        AcpiOsPrintf ("0x%4.4X%s\n", PinList[i],
+            ((i + 1) < PinCount) ? "," : "");
     }
 
     AcpiDmIndent (Level + 1);
     AcpiOsPrintf ("}\n");
+
+#ifdef ACPI_APPLICATION
+    MpSaveGpioInfo (Info->MappingOp, Resource,
+        PinCount, PinList, DeviceName);
+#endif
 }
 
 
@@ -250,7 +261,8 @@ AcpiDmGpioCommon (
  *
  * FUNCTION:    AcpiDmGpioIntDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -262,6 +274,7 @@ AcpiDmGpioCommon (
 
 static void
 AcpiDmGpioIntDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -273,9 +286,9 @@ AcpiDmGpioIntDescriptor (
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("GpioInt (%s, %s, %s, ",
-        AcpiGbl_HeDecode [(Resource->Gpio.IntFlags & 1)],
-        AcpiGbl_LlDecode [(Resource->Gpio.IntFlags >> 1) & 1],
-        AcpiGbl_ShrDecode [(Resource->Gpio.IntFlags >> 3) & 1]);
+        AcpiGbl_HeDecode [ACPI_GET_1BIT_FLAG (Resource->Gpio.IntFlags)],
+        AcpiGbl_LlDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->Gpio.IntFlags, 1)],
+        AcpiGbl_ShrDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->Gpio.IntFlags, 3)]);
 
     /* PinConfig, DebounceTimeout */
 
@@ -292,7 +305,7 @@ AcpiDmGpioIntDescriptor (
 
     /* Dump the GpioInt/GpioIo common portion of the descriptor */
 
-    AcpiDmGpioCommon (Resource, Level);
+    AcpiDmGpioCommon (Info, Resource, Level);
 }
 
 
@@ -300,18 +313,20 @@ AcpiDmGpioIntDescriptor (
  *
  * FUNCTION:    AcpiDmGpioIoDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
  * RETURN:      None
  *
- * DESCRIPTION: Decode a GPIO Interrupt descriptor
+ * DESCRIPTION: Decode a GPIO I/O descriptor
  *
  ******************************************************************************/
 
 static void
 AcpiDmGpioIoDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -323,7 +338,7 @@ AcpiDmGpioIoDescriptor (
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("GpioIo (%s, ",
-        AcpiGbl_ShrDecode [(Resource->Gpio.IntFlags >> 3) & 1]);
+        AcpiGbl_ShrDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->Gpio.IntFlags, 3)]);
 
     if (Resource->Gpio.PinConfig <= 3)
     {
@@ -340,11 +355,11 @@ AcpiDmGpioIoDescriptor (
     AcpiOsPrintf ("0x%4.4X, ", Resource->Gpio.DebounceTimeout);
     AcpiOsPrintf ("0x%4.4X, ", Resource->Gpio.DriveStrength);
     AcpiOsPrintf ("%s,\n",
-        AcpiGbl_IorDecode [Resource->Gpio.IntFlags & 3]);
+        AcpiGbl_IorDecode [ACPI_GET_2BIT_FLAG (Resource->Gpio.IntFlags)]);
 
     /* Dump the GpioInt/GpioIo common portion of the descriptor */
 
-    AcpiDmGpioCommon (Resource, Level);
+    AcpiDmGpioCommon (Info, Resource, Level);
 }
 
 
@@ -352,7 +367,8 @@ AcpiDmGpioIoDescriptor (
  *
  * FUNCTION:    AcpiDmGpioDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -364,6 +380,7 @@ AcpiDmGpioIoDescriptor (
 
 void
 AcpiDmGpioDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -376,14 +393,17 @@ AcpiDmGpioDescriptor (
     switch (ConnectionType)
     {
     case AML_RESOURCE_GPIO_TYPE_INT:
-        AcpiDmGpioIntDescriptor (Resource, Length, Level);
+
+        AcpiDmGpioIntDescriptor (Info, Resource, Length, Level);
         break;
 
     case AML_RESOURCE_GPIO_TYPE_IO:
-        AcpiDmGpioIoDescriptor (Resource, Length, Level);
+
+        AcpiDmGpioIoDescriptor (Info, Resource, Length, Level);
         break;
 
     default:
+
         AcpiOsPrintf ("Unknown GPIO type\n");
         break;
     }
@@ -443,6 +463,7 @@ AcpiDmDumpSerialBusVendorData (
         break;
 
     default:
+
         return;
     }
 
@@ -456,7 +477,8 @@ AcpiDmDumpSerialBusVendorData (
  *
  * FUNCTION:    AcpiDmI2cSerialBusDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -468,33 +490,34 @@ AcpiDmDumpSerialBusVendorData (
 
 static void
 AcpiDmI2cSerialBusDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
 {
     UINT32                  ResourceSourceOffset;
+    char                    *DeviceName;
 
 
     /* SlaveAddress, SlaveMode, ConnectionSpeed, AddressingMode */
 
     AcpiDmIndent (Level);
-    AcpiOsPrintf ("I2cSerialBus (0x%4.4X, %s, 0x%8.8X,\n",
+    AcpiOsPrintf ("I2cSerialBusV2 (0x%4.4X, %s, 0x%8.8X,\n",
         Resource->I2cSerialBus.SlaveAddress,
-        AcpiGbl_SmDecode [(Resource->I2cSerialBus.Flags & 1)],
+        AcpiGbl_SmDecode [ACPI_GET_1BIT_FLAG (Resource->I2cSerialBus.Flags)],
         Resource->I2cSerialBus.ConnectionSpeed);
 
     AcpiDmIndent (Level + 1);
     AcpiOsPrintf ("%s, ",
-        AcpiGbl_AmDecode [(Resource->I2cSerialBus.TypeSpecificFlags & 1)]);
+        AcpiGbl_AmDecode [ACPI_GET_1BIT_FLAG (Resource->I2cSerialBus.TypeSpecificFlags)]);
 
     /* ResourceSource is a required field */
 
     ResourceSourceOffset = sizeof (AML_RESOURCE_COMMON_SERIALBUS) +
         Resource->CommonSerialBus.TypeDataLength;
 
-    AcpiUtPrintString (
-        ACPI_ADD_PTR (char, Resource, ResourceSourceOffset),
-        ACPI_UINT8_MAX);
+    DeviceName = ACPI_ADD_PTR (char, Resource, ResourceSourceOffset),
+    AcpiUtPrintString (DeviceName, ACPI_UINT16_MAX);
 
     /* ResourceSourceIndex, ResourceUsage */
 
@@ -503,18 +526,26 @@ AcpiDmI2cSerialBusDescriptor (
     AcpiOsPrintf ("0x%2.2X, ", Resource->I2cSerialBus.ResSourceIndex);
 
     AcpiOsPrintf ("%s, ",
-        AcpiGbl_ConsumeDecode [(Resource->I2cSerialBus.Flags >> 1) & 1]);
+        AcpiGbl_ConsumeDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->I2cSerialBus.Flags, 1)]);
 
     /* Insert a descriptor name */
 
     AcpiDmDescriptorName ();
-    AcpiOsPrintf (",\n");
+
+    /* Share */
+
+    AcpiOsPrintf (", %s,\n",
+        AcpiGbl_ShrDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->I2cSerialBus.Flags, 2)]);
 
     /* Dump the vendor data */
 
     AcpiDmIndent (Level + 1);
     AcpiDmDumpSerialBusVendorData (Resource, Level);
     AcpiOsPrintf (")\n");
+
+#ifdef ACPI_APPLICATION
+    MpSaveSerialInfo (Info->MappingOp, Resource, DeviceName);
+#endif
 }
 
 
@@ -522,7 +553,8 @@ AcpiDmI2cSerialBusDescriptor (
  *
  * FUNCTION:    AcpiDmSpiSerialBusDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -534,42 +566,43 @@ AcpiDmI2cSerialBusDescriptor (
 
 static void
 AcpiDmSpiSerialBusDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
 {
     UINT32                  ResourceSourceOffset;
+    char                    *DeviceName;
 
 
     /* DeviceSelection, DeviceSelectionPolarity, WireMode, DataBitLength */
 
     AcpiDmIndent (Level);
-    AcpiOsPrintf ("SpiSerialBus (0x%4.4X, %s, %s, 0x%2.2X,\n",
+    AcpiOsPrintf ("SpiSerialBusV2 (0x%4.4X, %s, %s, 0x%2.2X,\n",
         Resource->SpiSerialBus.DeviceSelection,
-        AcpiGbl_DpDecode [(Resource->SpiSerialBus.TypeSpecificFlags >> 1) & 1],
-        AcpiGbl_WmDecode [(Resource->SpiSerialBus.TypeSpecificFlags & 1)],
+        AcpiGbl_DpDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->SpiSerialBus.TypeSpecificFlags, 1)],
+        AcpiGbl_WmDecode [ACPI_GET_1BIT_FLAG (Resource->SpiSerialBus.TypeSpecificFlags)],
         Resource->SpiSerialBus.DataBitLength);
 
     /* SlaveMode, ConnectionSpeed, ClockPolarity, ClockPhase */
 
     AcpiDmIndent (Level + 1);
     AcpiOsPrintf ("%s, 0x%8.8X, %s,\n",
-        AcpiGbl_SmDecode [(Resource->SpiSerialBus.Flags & 1)],
+        AcpiGbl_SmDecode [ACPI_GET_1BIT_FLAG (Resource->SpiSerialBus.Flags)],
         Resource->SpiSerialBus.ConnectionSpeed,
-        AcpiGbl_CpoDecode [(Resource->SpiSerialBus.ClockPolarity & 1)]);
+        AcpiGbl_CpoDecode [ACPI_GET_1BIT_FLAG (Resource->SpiSerialBus.ClockPolarity)]);
 
     AcpiDmIndent (Level + 1);
     AcpiOsPrintf ("%s, ",
-        AcpiGbl_CphDecode [(Resource->SpiSerialBus.ClockPhase & 1)]);
+        AcpiGbl_CphDecode [ACPI_GET_1BIT_FLAG (Resource->SpiSerialBus.ClockPhase)]);
 
     /* ResourceSource is a required field */
 
     ResourceSourceOffset = sizeof (AML_RESOURCE_COMMON_SERIALBUS) +
         Resource->CommonSerialBus.TypeDataLength;
 
-    AcpiUtPrintString (
-        ACPI_ADD_PTR (char, Resource, ResourceSourceOffset),
-        ACPI_UINT8_MAX);
+    DeviceName = ACPI_ADD_PTR (char, Resource, ResourceSourceOffset),
+    AcpiUtPrintString (DeviceName, ACPI_UINT16_MAX);
 
     /* ResourceSourceIndex, ResourceUsage */
 
@@ -578,18 +611,26 @@ AcpiDmSpiSerialBusDescriptor (
     AcpiOsPrintf ("0x%2.2X, ", Resource->SpiSerialBus.ResSourceIndex);
 
     AcpiOsPrintf ("%s, ",
-        AcpiGbl_ConsumeDecode [(Resource->SpiSerialBus.Flags >> 1) & 1]);
+        AcpiGbl_ConsumeDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->SpiSerialBus.Flags, 1)]);
 
     /* Insert a descriptor name */
 
     AcpiDmDescriptorName ();
-    AcpiOsPrintf (",\n");
+
+    /* Share */
+
+    AcpiOsPrintf (", %s,\n",
+        AcpiGbl_ShrDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->SpiSerialBus.Flags, 2)]);
 
     /* Dump the vendor data */
 
     AcpiDmIndent (Level + 1);
     AcpiDmDumpSerialBusVendorData (Resource, Level);
     AcpiOsPrintf (")\n");
+
+#ifdef ACPI_APPLICATION
+    MpSaveSerialInfo (Info->MappingOp, Resource, DeviceName);
+#endif
 }
 
 
@@ -597,7 +638,8 @@ AcpiDmSpiSerialBusDescriptor (
  *
  * FUNCTION:    AcpiDmUartSerialBusDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -609,29 +651,31 @@ AcpiDmSpiSerialBusDescriptor (
 
 static void
 AcpiDmUartSerialBusDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
 {
     UINT32                  ResourceSourceOffset;
+    char                    *DeviceName;
 
 
     /* ConnectionSpeed, BitsPerByte, StopBits */
 
     AcpiDmIndent (Level);
-    AcpiOsPrintf ("UartSerialBus (0x%8.8X, %s, %s,\n",
+    AcpiOsPrintf ("UartSerialBusV2 (0x%8.8X, %s, %s,\n",
         Resource->UartSerialBus.DefaultBaudRate,
-        AcpiGbl_BpbDecode [(Resource->UartSerialBus.TypeSpecificFlags >> 4) & 3],
-        AcpiGbl_SbDecode [(Resource->UartSerialBus.TypeSpecificFlags >> 2) & 3]);
+        AcpiGbl_BpbDecode [ACPI_EXTRACT_3BIT_FLAG (Resource->UartSerialBus.TypeSpecificFlags, 4)],
+        AcpiGbl_SbDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->UartSerialBus.TypeSpecificFlags, 2)]);
 
     /* LinesInUse, IsBigEndian, Parity, FlowControl */
 
     AcpiDmIndent (Level + 1);
     AcpiOsPrintf ("0x%2.2X, %s, %s, %s,\n",
         Resource->UartSerialBus.LinesEnabled,
-        AcpiGbl_EdDecode [(Resource->UartSerialBus.TypeSpecificFlags >> 7) & 1],
-        AcpiGbl_PtDecode [Resource->UartSerialBus.Parity & 7],
-        AcpiGbl_FcDecode [Resource->UartSerialBus.TypeSpecificFlags & 3]);
+        AcpiGbl_EdDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->UartSerialBus.TypeSpecificFlags, 7)],
+        AcpiGbl_PtDecode [ACPI_GET_3BIT_FLAG (Resource->UartSerialBus.Parity)],
+        AcpiGbl_FcDecode [ACPI_GET_2BIT_FLAG (Resource->UartSerialBus.TypeSpecificFlags)]);
 
     /* ReceiveBufferSize, TransmitBufferSize */
 
@@ -645,9 +689,8 @@ AcpiDmUartSerialBusDescriptor (
     ResourceSourceOffset = sizeof (AML_RESOURCE_COMMON_SERIALBUS) +
         Resource->CommonSerialBus.TypeDataLength;
 
-    AcpiUtPrintString (
-        ACPI_ADD_PTR (char, Resource, ResourceSourceOffset),
-        ACPI_UINT8_MAX);
+    DeviceName = ACPI_ADD_PTR (char, Resource, ResourceSourceOffset),
+    AcpiUtPrintString (DeviceName, ACPI_UINT16_MAX);
 
     /* ResourceSourceIndex, ResourceUsage */
 
@@ -656,18 +699,26 @@ AcpiDmUartSerialBusDescriptor (
     AcpiOsPrintf ("0x%2.2X, ", Resource->UartSerialBus.ResSourceIndex);
 
     AcpiOsPrintf ("%s, ",
-        AcpiGbl_ConsumeDecode [(Resource->UartSerialBus.Flags >> 1) & 1]);
+        AcpiGbl_ConsumeDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->UartSerialBus.Flags, 1)]);
 
     /* Insert a descriptor name */
 
     AcpiDmDescriptorName ();
-    AcpiOsPrintf (",\n");
+
+    /* Share */
+
+    AcpiOsPrintf (", %s,\n",
+        AcpiGbl_ShrDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->UartSerialBus.Flags, 2)]);
 
     /* Dump the vendor data */
 
     AcpiDmIndent (Level + 1);
     AcpiDmDumpSerialBusVendorData (Resource, Level);
     AcpiOsPrintf (")\n");
+
+#ifdef ACPI_APPLICATION
+    MpSaveSerialInfo (Info->MappingOp, Resource, DeviceName);
+#endif
 }
 
 
@@ -675,7 +726,8 @@ AcpiDmUartSerialBusDescriptor (
  *
  * FUNCTION:    AcpiDmSerialBusDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -687,14 +739,12 @@ AcpiDmUartSerialBusDescriptor (
 
 void
 AcpiDmSerialBusDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
 {
 
     SerialBusResourceDispatch [Resource->CommonSerialBus.Type] (
-        Resource, Length, Level);
+        Info, Resource, Length, Level);
 }
-
-#endif
-
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmresrcs.c b/usr/src/uts/intel/io/acpica/disassembler/dmresrcs.c
index 32759d991b..c601f36492 100644
--- a/usr/src/uts/intel/io/acpica/disassembler/dmresrcs.c
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmresrcs.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,14 +41,11 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdisasm.h"
 
 
-#ifdef ACPI_DISASSEMBLER
-
 #define _COMPONENT          ACPI_CA_DEBUGGER
         ACPI_MODULE_NAME    ("dbresrcs")
 
@@ -57,7 +54,8 @@
  *
  * FUNCTION:    AcpiDmIrqDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -69,6 +67,7 @@
 
 void
 AcpiDmIrqDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -76,16 +75,16 @@ AcpiDmIrqDescriptor (
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("%s (",
-        AcpiGbl_IrqDecode [Length & 1]);
+        AcpiGbl_IrqDecode [ACPI_GET_1BIT_FLAG (Length)]);
 
     /* Decode flags byte if present */
 
     if (Length & 1)
     {
         AcpiOsPrintf ("%s, %s, %s, ",
-            AcpiGbl_HeDecode [Resource->Irq.Flags & 1],
-            AcpiGbl_LlDecode [(Resource->Irq.Flags >> 3) & 1],
-            AcpiGbl_ShrDecode [(Resource->Irq.Flags >> 4) & 1]);
+            AcpiGbl_HeDecode [ACPI_GET_1BIT_FLAG (Resource->Irq.Flags)],
+            AcpiGbl_LlDecode [ACPI_EXTRACT_1BIT_FLAG (Resource->Irq.Flags, 3)],
+            AcpiGbl_ShrDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->Irq.Flags, 4)]);
     }
 
     /* Insert a descriptor name */
@@ -102,7 +101,8 @@ AcpiDmIrqDescriptor (
  *
  * FUNCTION:    AcpiDmDmaDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -114,6 +114,7 @@ AcpiDmIrqDescriptor (
 
 void
 AcpiDmDmaDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -121,9 +122,9 @@ AcpiDmDmaDescriptor (
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("DMA (%s, %s, %s, ",
-        AcpiGbl_TypDecode [(Resource->Dma.Flags >> 5) & 3],
-        AcpiGbl_BmDecode  [(Resource->Dma.Flags >> 2) & 1],
-        AcpiGbl_SizDecode [(Resource->Dma.Flags >> 0) & 3]);
+        AcpiGbl_TypDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->Dma.Flags, 5)],
+        AcpiGbl_BmDecode  [ACPI_EXTRACT_1BIT_FLAG (Resource->Dma.Flags, 2)],
+        AcpiGbl_SizDecode [ACPI_GET_2BIT_FLAG (Resource->Dma.Flags)]);
 
     /* Insert a descriptor name */
 
@@ -139,7 +140,8 @@ AcpiDmDmaDescriptor (
  *
  * FUNCTION:    AcpiDmFixedDmaDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -151,6 +153,7 @@ AcpiDmDmaDescriptor (
 
 void
 AcpiDmFixedDmaDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -168,7 +171,8 @@ AcpiDmFixedDmaDescriptor (
     }
     else
     {
-        AcpiOsPrintf ("%X /* INVALID DMA WIDTH */, ", Resource->FixedDma.Width);
+        AcpiOsPrintf ("%X /* INVALID DMA WIDTH */, ",
+            Resource->FixedDma.Width);
     }
 
     /* Insert a descriptor name */
@@ -182,7 +186,8 @@ AcpiDmFixedDmaDescriptor (
  *
  * FUNCTION:    AcpiDmIoDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -194,6 +199,7 @@ AcpiDmFixedDmaDescriptor (
 
 void
 AcpiDmIoDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -201,7 +207,7 @@ AcpiDmIoDescriptor (
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("IO (%s,\n",
-        AcpiGbl_IoDecode [(Resource->Io.Flags & 1)]);
+        AcpiGbl_IoDecode [ACPI_GET_1BIT_FLAG (Resource->Io.Flags)]);
 
     AcpiDmIndent (Level + 1);
     AcpiDmDumpInteger16 (Resource->Io.Minimum, "Range Minimum");
@@ -227,7 +233,8 @@ AcpiDmIoDescriptor (
  *
  * FUNCTION:    AcpiDmFixedIoDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -239,6 +246,7 @@ AcpiDmIoDescriptor (
 
 void
 AcpiDmFixedIoDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -265,7 +273,8 @@ AcpiDmFixedIoDescriptor (
  *
  * FUNCTION:    AcpiDmStartDependentDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -277,6 +286,7 @@ AcpiDmFixedIoDescriptor (
 
 void
 AcpiDmStartDependentDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -287,8 +297,8 @@ AcpiDmStartDependentDescriptor (
     if (Length & 1)
     {
         AcpiOsPrintf ("StartDependentFn (0x%2.2X, 0x%2.2X)\n",
-            (UINT32) Resource->StartDpf.Flags & 3,
-            (UINT32) (Resource->StartDpf.Flags >> 2) & 3);
+            (UINT32) ACPI_GET_2BIT_FLAG (Resource->StartDpf.Flags),
+            (UINT32) ACPI_EXTRACT_2BIT_FLAG (Resource->StartDpf.Flags, 2));
     }
     else
     {
@@ -304,7 +314,8 @@ AcpiDmStartDependentDescriptor (
  *
  * FUNCTION:    AcpiDmEndDependentDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -316,6 +327,7 @@ AcpiDmStartDependentDescriptor (
 
 void
 AcpiDmEndDependentDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -332,7 +344,8 @@ AcpiDmEndDependentDescriptor (
  *
  * FUNCTION:    AcpiDmVendorSmallDescriptor
  *
- * PARAMETERS:  Resource            - Pointer to the resource descriptor
+ * PARAMETERS:  Info                - Extra resource info
+ *              Resource            - Pointer to the resource descriptor
  *              Length              - Length of the descriptor in bytes
  *              Level               - Current source code indentation level
  *
@@ -344,6 +357,7 @@ AcpiDmEndDependentDescriptor (
 
 void
 AcpiDmVendorSmallDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level)
@@ -353,6 +367,3 @@ AcpiDmVendorSmallDescriptor (
         ACPI_ADD_PTR (UINT8, Resource, sizeof (AML_RESOURCE_SMALL_HEADER)),
         Length, Level);
 }
-
-#endif
-
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmutils.c b/usr/src/uts/intel/io/acpica/disassembler/dmutils.c
index ce3443ec3f..02717bc6ad 100644
--- a/usr/src/uts/intel/io/acpica/disassembler/dmutils.c
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmutils.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "amlcode.h"
@@ -51,7 +50,6 @@
 #include <acnamesp.h>
 #endif
 
-#ifdef ACPI_DISASSEMBLER
 
 #define _COMPONENT          ACPI_CA_DEBUGGER
         ACPI_MODULE_NAME    ("dmutils")
@@ -229,7 +227,7 @@ AcpiDmIndent (
         return;
     }
 
-    AcpiOsPrintf ("%*.s", ACPI_MUL_4 (Level), " ");
+    AcpiOsPrintf ("%*.s", (Level * 4), " ");
 }
 
 
@@ -252,11 +250,18 @@ AcpiDmCommaIfListMember (
 
     if (!Op->Common.Next)
     {
-        return FALSE;
+        return (FALSE);
     }
 
     if (AcpiDmListType (Op->Common.Parent) & BLOCK_COMMA_LIST)
     {
+        /* Exit if Target has been marked IGNORE */
+
+        if (Op->Common.Next->Common.DisasmFlags & ACPI_PARSEOP_IGNORE)
+        {
+            return (FALSE);
+        }
+
         /* Check for a NULL target operand */
 
         if ((Op->Common.Next->Common.AmlOpcode == AML_INT_NAMEPATH_OP) &&
@@ -264,28 +269,34 @@ AcpiDmCommaIfListMember (
         {
             /*
              * To handle the Divide() case where there are two optional
-             * targets, look ahead one more op.  If null, this null target
-             * is the one and only target -- no comma needed.  Otherwise,
+             * targets, look ahead one more op. If null, this null target
+             * is the one and only target -- no comma needed. Otherwise,
              * we need a comma to prepare for the next target.
              */
             if (!Op->Common.Next->Common.Next)
             {
-                return FALSE;
+                return (FALSE);
             }
         }
 
-        if ((Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST) &&
-            (!(Op->Common.Next->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST)))
+        if ((Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST) &&
+            (!(Op->Common.Next->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST)))
         {
-            return FALSE;
+            return (FALSE);
+        }
+
+        /* Emit comma only if this is not a C-style operator */
+
+        if (!Op->Common.OperatorSymbol)
+        {
+            AcpiOsPrintf (", ");
         }
 
-        AcpiOsPrintf (", ");
         return (TRUE);
     }
 
-    else if ((Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST) &&
-             (Op->Common.Next->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST))
+    else if ((Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST) &&
+             (Op->Common.Next->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST))
     {
         AcpiOsPrintf (", ");
         return (TRUE);
@@ -317,5 +328,3 @@ AcpiDmCommaIfFieldMember (
         AcpiOsPrintf (", ");
     }
 }
-
-#endif
diff --git a/usr/src/uts/intel/io/acpica/disassembler/dmwalk.c b/usr/src/uts/intel/io/acpica/disassembler/dmwalk.c
index dd3ee00255..3c953f5465 100644
--- a/usr/src/uts/intel/io/acpica/disassembler/dmwalk.c
+++ b/usr/src/uts/intel/io/acpica/disassembler/dmwalk.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,17 +41,13 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
 #include "amlcode.h"
-#include "acdisasm.h"
 #include "acdebug.h"
 
 
-#ifdef ACPI_DISASSEMBLER
-
 #define _COMPONENT          ACPI_CA_DEBUGGER
         ACPI_MODULE_NAME    ("dmwalk")
 
@@ -98,7 +94,7 @@ AcpiDmBlockType (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Disassemble parser object and its children.  This is the
+ * DESCRIPTION: Disassemble parser object and its children. This is the
  *              main entry point of the disassembler.
  *
  ******************************************************************************/
@@ -118,10 +114,11 @@ AcpiDmDisassemble (
         return;
     }
 
-    Info.Flags = 0;
-    Info.Level = 0;
-    Info.Count = 0;
+    memset (&Info, 0, sizeof (ACPI_OP_WALK_INFO));
     Info.WalkState = WalkState;
+    Info.StartAml = Op->Common.Aml - sizeof (ACPI_TABLE_HEADER);
+    Info.AmlOffset = Op->Common.Aml - Info.StartAml;
+
     AcpiDmWalkParseTree (Op, AcpiDmDescendingOp, AcpiDmAscendingOp, &Info);
     return;
 }
@@ -285,7 +282,9 @@ AcpiDmBlockType (
 
     case AML_BUFFER_OP:
 
-        if (Op->Common.DisasmOpcode == ACPI_DASM_UNICODE)
+        if ((Op->Common.DisasmOpcode == ACPI_DASM_UNICODE) ||
+            (Op->Common.DisasmOpcode == ACPI_DASM_UUID) ||
+            (Op->Common.DisasmOpcode == ACPI_DASM_PLD_METHOD))
         {
             return (BLOCK_NONE);
         }
@@ -301,6 +300,19 @@ AcpiDmBlockType (
 
         return (BLOCK_PAREN);
 
+    case AML_INT_METHODCALL_OP:
+
+        if (Op->Common.Parent &&
+            ((Op->Common.Parent->Common.AmlOpcode == AML_PACKAGE_OP) ||
+             (Op->Common.Parent->Common.AmlOpcode == AML_VAR_PACKAGE_OP)))
+        {
+            /* This is a reference to a method, not an invocation */
+
+            return (BLOCK_NONE);
+        }
+
+        /*lint -fallthrough */
+
     default:
 
         OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
@@ -398,7 +410,43 @@ AcpiDmDescendingOp (
     const ACPI_OPCODE_INFO  *OpInfo;
     UINT32                  Name;
     ACPI_PARSE_OBJECT       *NextOp;
+    ACPI_PARSE_OBJECT       *NextOp2;
+    UINT32                  AmlOffset;
+
+
+    OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+
+    /* Listing support to dump the AML code after the ASL statement */
+
+    if (AcpiGbl_DmOpt_Listing)
+    {
+        /* We only care about these classes of objects */
+
+        if ((OpInfo->Class == AML_CLASS_NAMED_OBJECT) ||
+            (OpInfo->Class == AML_CLASS_CONTROL) ||
+            (OpInfo->Class == AML_CLASS_CREATE) ||
+            ((OpInfo->Class == AML_CLASS_EXECUTE) && (!Op->Common.Next)))
+        {
+            if (AcpiGbl_DmOpt_Listing && Info->PreviousAml)
+            {
+                /* Dump the AML byte code for the previous Op */
+
+                if (Op->Common.Aml > Info->PreviousAml)
+                {
+                    AcpiOsPrintf ("\n");
+                    AcpiUtDumpBuffer (
+                        (Info->StartAml + Info->AmlOffset),
+                        (Op->Common.Aml - Info->PreviousAml),
+                        DB_BYTE_DISPLAY, Info->AmlOffset);
+                    AcpiOsPrintf ("\n");
+                }
+
+                Info->AmlOffset = (Op->Common.Aml - Info->StartAml);
+            }
 
+            Info->PreviousAml = Op->Common.Aml;
+        }
+    }
 
     if (Op->Common.DisasmFlags & ACPI_PARSEOP_IGNORE)
     {
@@ -407,6 +455,38 @@ AcpiDmDescendingOp (
         return (AE_CTRL_DEPTH);
     }
 
+    if (Op->Common.AmlOpcode == AML_IF_OP)
+    {
+        NextOp = AcpiPsGetDepthNext (NULL, Op);
+        if (NextOp)
+        {
+            NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMETER_LIST;
+
+            /* Don't emit the actual embedded externals unless asked */
+
+            if (!AcpiGbl_DmEmitExternalOpcodes)
+            {
+                /*
+                 * A Zero predicate indicates the possibility of one or more
+                 * External() opcodes within the If() block.
+                 */
+                if (NextOp->Common.AmlOpcode == AML_ZERO_OP)
+                {
+                    NextOp2 = NextOp->Common.Next;
+
+                    if (NextOp2 &&
+                        (NextOp2->Common.AmlOpcode == AML_EXTERNAL_OP))
+                    {
+                        /* Ignore the If 0 block and all children */
+
+                        Op->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
+                        return (AE_CTRL_DEPTH);
+                    }
+                }
+            }
+        }
+    }
+
     /* Level 0 is at the Definition Block level */
 
     if (Level == 0)
@@ -415,10 +495,15 @@ AcpiDmDescendingOp (
 
         if (Info->WalkState)
         {
-            VERBOSE_PRINT ((DB_FULL_OP_INFO,
-                (Info->WalkState->MethodNode ?
-                    Info->WalkState->MethodNode->Name.Ascii : "   "),
-                Op->Common.AmlOffset, (UINT32) Op->Common.AmlOpcode));
+            AmlOffset = (UINT32) ACPI_PTR_DIFF (Op->Common.Aml,
+                Info->WalkState->ParserState.AmlStart);
+            if (AcpiGbl_DmOpt_Verbose)
+            {
+                AcpiOsPrintf (DB_FULL_OP_INFO,
+                    (Info->WalkState->MethodNode ?
+                        Info->WalkState->MethodNode->Name.Ascii : "   "),
+                    AmlOffset, (UINT32) Op->Common.AmlOpcode);
+            }
         }
 
         if (Op->Common.AmlOpcode == AML_SCOPE_OP)
@@ -434,16 +519,41 @@ AcpiDmDescendingOp (
         }
     }
     else if ((AcpiDmBlockType (Op->Common.Parent) & BLOCK_BRACE) &&
-             (!(Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST)) &&
-             (Op->Common.AmlOpcode != AML_INT_BYTELIST_OP))
+         (!(Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST)) &&
+         (!(Op->Common.DisasmFlags & ACPI_PARSEOP_ELSEIF)) &&
+         (Op->Common.AmlOpcode != AML_INT_BYTELIST_OP))
     {
+        /*
+         * This is a first-level element of a term list,
+         * indent a new line
+         */
+        switch (Op->Common.AmlOpcode)
+        {
+        case AML_NOOP_OP:
             /*
-             * This is a first-level element of a term list,
-             * indent a new line
+             * Optionally just ignore this opcode. Some tables use
+             * NoOp opcodes for "padding" out packages that the BIOS
+             * changes dynamically. This can leave hundreds or
+             * thousands of NoOp opcodes that if disassembled,
+             * cannot be compiled because they are syntactically
+             * incorrect.
              */
+            if (AcpiGbl_IgnoreNoopOperator)
+            {
+                Op->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
+                return (AE_OK);
+            }
+
+            /* Fallthrough */
+
+        default:
+
             AcpiDmIndent (Level);
-            Info->LastLevel = Level;
-            Info->Count = 0;
+            break;
+        }
+
+        Info->LastLevel = Level;
+        Info->Count = 0;
     }
 
     /*
@@ -453,13 +563,20 @@ AcpiDmDescendingOp (
      * keep track of the current column.
      */
     Info->Count++;
-    if (Info->Count /*+Info->LastLevel*/ > 10)
+    if (Info->Count /* +Info->LastLevel */ > 12)
     {
         Info->Count = 0;
         AcpiOsPrintf ("\n");
         AcpiDmIndent (Info->LastLevel + 1);
     }
 
+    /* If ASL+ is enabled, check for a C-style operator */
+
+    if (AcpiDmCheckForSymbolicOpcode (Op, Info))
+    {
+        return (AE_OK);
+    }
+
     /* Print the opcode name */
 
     AcpiDmDisassembleOneOp (NULL, Info, Op);
@@ -478,8 +595,6 @@ AcpiDmDescendingOp (
 
     /* Start the opcode argument list if necessary */
 
-    OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
-
     if ((OpInfo->Flags & AML_HAS_ARGS) ||
         (Op->Common.AmlOpcode == AML_EVENT_OP))
     {
@@ -519,7 +634,7 @@ AcpiDmDescendingOp (
 
                 if (Op->Common.AmlOpcode != AML_INT_NAMEDFIELD_OP)
                 {
-                    if (AcpiGbl_DbOpt_verbose)
+                    if (AcpiGbl_DmOpt_Verbose)
                     {
                         (void) AcpiPsDisplayObjectPathname (NULL, Op);
                     }
@@ -533,66 +648,63 @@ AcpiDmDescendingOp (
 
                 AcpiDmMethodFlags (Op);
                 AcpiOsPrintf (")");
-                break;
 
+                /* Emit description comment for Method() with a predefined ACPI name */
+
+                AcpiDmPredefinedDescription (Op);
+                break;
 
             case AML_NAME_OP:
 
                 /* Check for _HID and related EISAID() */
 
-                AcpiDmIsEisaId (Op);
+                AcpiDmCheckForHardwareId (Op);
                 AcpiOsPrintf (", ");
                 break;
 
-
             case AML_REGION_OP:
 
                 AcpiDmRegionFlags (Op);
                 break;
 
-
             case AML_POWER_RES_OP:
 
                 /* Mark the next two Ops as part of the parameter list */
 
                 AcpiOsPrintf (", ");
                 NextOp = AcpiPsGetDepthNext (NULL, Op);
-                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMLIST;
+                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMETER_LIST;
 
                 NextOp = NextOp->Common.Next;
-                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMLIST;
+                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMETER_LIST;
                 return (AE_OK);
 
-
             case AML_PROCESSOR_OP:
 
                 /* Mark the next three Ops as part of the parameter list */
 
                 AcpiOsPrintf (", ");
                 NextOp = AcpiPsGetDepthNext (NULL, Op);
-                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMLIST;
+                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMETER_LIST;
 
                 NextOp = NextOp->Common.Next;
-                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMLIST;
+                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMETER_LIST;
 
                 NextOp = NextOp->Common.Next;
-                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMLIST;
+                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMETER_LIST;
                 return (AE_OK);
 
-
             case AML_MUTEX_OP:
             case AML_DATA_REGION_OP:
 
                 AcpiOsPrintf (", ");
                 return (AE_OK);
 
-
             case AML_EVENT_OP:
             case AML_ALIAS_OP:
 
                 return (AE_OK);
 
-
             case AML_SCOPE_OP:
             case AML_DEVICE_OP:
             case AML_THERMAL_ZONE_OP:
@@ -600,10 +712,10 @@ AcpiDmDescendingOp (
                 AcpiOsPrintf (")");
                 break;
 
-
             default:
 
-                AcpiOsPrintf ("*** Unhandled named opcode %X\n", Op->Common.AmlOpcode);
+                AcpiOsPrintf ("*** Unhandled named opcode %X\n",
+                    Op->Common.AmlOpcode);
                 break;
             }
         }
@@ -638,13 +750,14 @@ AcpiDmDescendingOp (
                  * Bank Value. This is a TermArg in the middle of the parameter
                  * list, must handle it here.
                  *
-                 * Disassemble the TermArg parse tree. ACPI_PARSEOP_PARAMLIST
+                 * Disassemble the TermArg parse tree. ACPI_PARSEOP_PARAMETER_LIST
                  * eliminates newline in the output.
                  */
                 NextOp = NextOp->Common.Next;
 
-                Info->Flags = ACPI_PARSEOP_PARAMLIST;
-                AcpiDmWalkParseTree (NextOp, AcpiDmDescendingOp, AcpiDmAscendingOp, Info);
+                Info->Flags = ACPI_PARSEOP_PARAMETER_LIST;
+                AcpiDmWalkParseTree (NextOp, AcpiDmDescendingOp,
+                    AcpiDmAscendingOp, Info);
                 Info->Flags = 0;
                 Info->Level = Level;
 
@@ -670,7 +783,6 @@ AcpiDmDescendingOp (
             AcpiDmFieldFlags (NextOp);
             break;
 
-
         case AML_BUFFER_OP:
 
             /* The next op is the size parameter */
@@ -686,12 +798,18 @@ AcpiDmDescendingOp (
             if (Op->Common.DisasmOpcode == ACPI_DASM_RESOURCE)
             {
                 /*
-                 * We have a resource list.  Don't need to output
-                 * the buffer size Op.  Open up a new block
+                 * We have a resource list. Don't need to output
+                 * the buffer size Op. Open up a new block
                  */
                 NextOp->Common.DisasmFlags |= ACPI_PARSEOP_IGNORE;
                 NextOp = NextOp->Common.Next;
-                AcpiOsPrintf (")\n");
+                AcpiOsPrintf (")");
+
+                /* Emit description comment for Name() with a predefined ACPI name */
+
+                AcpiDmPredefinedDescription (Op->Asl.Parent);
+
+                AcpiOsPrintf ("\n");
                 AcpiDmIndent (Info->Level);
                 AcpiOsPrintf ("{\n");
                 return (AE_OK);
@@ -699,12 +817,11 @@ AcpiDmDescendingOp (
 
             /* Normal Buffer, mark size as in the parameter list */
 
-            NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMLIST;
+            NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMETER_LIST;
             return (AE_OK);
 
-
-        case AML_VAR_PACKAGE_OP:
         case AML_IF_OP:
+        case AML_VAR_PACKAGE_OP:
         case AML_WHILE_OP:
 
             /* The next op is the size or predicate parameter */
@@ -712,29 +829,26 @@ AcpiDmDescendingOp (
             NextOp = AcpiPsGetDepthNext (NULL, Op);
             if (NextOp)
             {
-                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMLIST;
+                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMETER_LIST;
             }
             return (AE_OK);
 
-
         case AML_PACKAGE_OP:
 
-            /* The next op is the size or predicate parameter */
+            /* The next op is the size parameter */
 
             NextOp = AcpiPsGetDepthNext (NULL, Op);
             if (NextOp)
             {
-                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMLIST;
+                NextOp->Common.DisasmFlags |= ACPI_PARSEOP_PARAMETER_LIST;
             }
             return (AE_OK);
 
-
         case AML_MATCH_OP:
 
             AcpiDmMatchOp (Op);
             break;
 
-
         default:
 
             break;
@@ -761,7 +875,7 @@ AcpiDmDescendingOp (
  * RETURN:      Status
  *
  * DESCRIPTION: Second visitation of a parse object, during ascent of parse
- *              tree.  Close out any parameter lists and complete the opcode.
+ *              tree. Close out any parameter lists and complete the opcode.
  *
  ******************************************************************************/
 
@@ -772,6 +886,7 @@ AcpiDmAscendingOp (
     void                    *Context)
 {
     ACPI_OP_WALK_INFO       *Info = Context;
+    ACPI_PARSE_OBJECT       *ParentOp;
 
 
     if (Op->Common.DisasmFlags & ACPI_PARSEOP_IGNORE)
@@ -793,23 +908,45 @@ AcpiDmAscendingOp (
     {
     case BLOCK_PAREN:
 
-        /* Completed an op that has arguments, add closing paren */
+        /* Completed an op that has arguments, add closing paren if needed */
+
+        AcpiDmCloseOperator (Op);
+
+        if (Op->Common.AmlOpcode == AML_NAME_OP)
+        {
+            /* Emit description comment for Name() with a predefined ACPI name */
+
+            AcpiDmPredefinedDescription (Op);
+        }
+        else
+        {
+            /* For Create* operators, attempt to emit resource tag description */
+
+            AcpiDmFieldPredefinedDescription (Op);
+        }
+
+        /* Decode Notify() values */
+
+        if (Op->Common.AmlOpcode == AML_NOTIFY_OP)
+        {
+            AcpiDmNotifyDescription (Op);
+        }
 
-        AcpiOsPrintf (")");
+        AcpiDmDisplayTargetPathname (Op);
 
         /* Could be a nested operator, check if comma required */
 
         if (!AcpiDmCommaIfListMember (Op))
         {
             if ((AcpiDmBlockType (Op->Common.Parent) & BLOCK_BRACE) &&
-                     (!(Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST)) &&
-                     (Op->Common.AmlOpcode != AML_INT_BYTELIST_OP))
+                 (!(Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST)) &&
+                 (Op->Common.AmlOpcode != AML_INT_BYTELIST_OP))
             {
                 /*
                  * This is a first-level element of a term list
                  * start a new line
                  */
-                if (!(Info->Flags & ACPI_PARSEOP_PARAMLIST))
+                if (!(Info->Flags & ACPI_PARSEOP_PARAMETER_LIST))
                 {
                     AcpiOsPrintf ("\n");
                 }
@@ -817,7 +954,6 @@ AcpiDmAscendingOp (
         }
         break;
 
-
     case BLOCK_BRACE:
     case (BLOCK_BRACE | BLOCK_PAREN):
 
@@ -857,7 +993,6 @@ AcpiDmAscendingOp (
         }
         break;
 
-
     case BLOCK_NONE:
     default:
 
@@ -866,8 +1001,8 @@ AcpiDmAscendingOp (
         if (!AcpiDmCommaIfListMember (Op))
         {
             if ((AcpiDmBlockType (Op->Common.Parent) & BLOCK_BRACE) &&
-                     (!(Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST)) &&
-                     (Op->Common.AmlOpcode != AML_INT_BYTELIST_OP))
+                 (!(Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST)) &&
+                 (Op->Common.AmlOpcode != AML_INT_BYTELIST_OP))
             {
                 /*
                  * This is a first-level element of a term list
@@ -883,7 +1018,7 @@ AcpiDmAscendingOp (
             case AML_PACKAGE_OP:
             case AML_VAR_PACKAGE_OP:
 
-                if (!(Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST))
+                if (!(Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST))
                 {
                     AcpiOsPrintf ("\n");
                 }
@@ -897,28 +1032,47 @@ AcpiDmAscendingOp (
         break;
     }
 
-    if (Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST)
+    if (Op->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST)
     {
         if ((Op->Common.Next) &&
-            (Op->Common.Next->Common.DisasmFlags & ACPI_PARSEOP_PARAMLIST))
+            (Op->Common.Next->Common.DisasmFlags & ACPI_PARSEOP_PARAMETER_LIST))
         {
             return (AE_OK);
         }
 
+        /*
+         * The parent Op is guaranteed to be valid because of the flag
+         * ACPI_PARSEOP_PARAMETER_LIST -- which means that this op is part of
+         * a parameter list and thus has a valid parent.
+         */
+        ParentOp = Op->Common.Parent;
+
         /*
          * Just completed a parameter node for something like "Buffer (param)".
          * Close the paren and open up the term list block with a brace
          */
         if (Op->Common.Next)
         {
-            AcpiOsPrintf (")\n");
+            AcpiOsPrintf (")");
+
+            /*
+             * Emit a description comment for a Name() operator that is a
+             * predefined ACPI name. Must check the grandparent.
+             */
+            ParentOp = ParentOp->Common.Parent;
+            if (ParentOp &&
+                (ParentOp->Asl.AmlOpcode == AML_NAME_OP))
+            {
+                AcpiDmPredefinedDescription (ParentOp);
+            }
+
+            AcpiOsPrintf ("\n");
             AcpiDmIndent (Level - 1);
             AcpiOsPrintf ("{\n");
         }
         else
         {
-            Op->Common.Parent->Common.DisasmFlags |=
-                                    ACPI_PARSEOP_EMPTY_TERMLIST;
+            ParentOp->Common.DisasmFlags |= ACPI_PARSEOP_EMPTY_TERMLIST;
             AcpiOsPrintf (") {");
         }
     }
@@ -928,8 +1082,19 @@ AcpiDmAscendingOp (
     {
         Info->Level++;
     }
-    return (AE_OK);
-}
 
+    /*
+     * For ASL+, check for and emit a C-style symbol. If valid, the
+     * symbol string has been deferred until after the first operand
+     */
+    if (AcpiGbl_CstyleDisassembly)
+    {
+        if (Op->Asl.OperatorSymbol)
+        {
+            AcpiOsPrintf ("%s", Op->Asl.OperatorSymbol);
+            Op->Asl.OperatorSymbol = NULL;
+        }
+    }
 
-#endif  /* ACPI_DISASSEMBLER */
+    return (AE_OK);
+}
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsargs.c b/usr/src/uts/intel/io/acpica/dispatcher/dsargs.c
index ea0d7bee88..5e5e93b4ec 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dsargs.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dsargs.c
@@ -6,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +42,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSARGS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -96,7 +94,7 @@ AcpiDsExecuteArguments (
 
     /* Allocate a new parser op to be the root of the parsed tree */
 
-    Op = AcpiPsAllocOp (AML_INT_EVAL_SUBTREE_OP);
+    Op = AcpiPsAllocOp (AML_INT_EVAL_SUBTREE_OP, AmlStart);
     if (!Op)
     {
         return_ACPI_STATUS (AE_NO_MEMORY);
@@ -116,7 +114,7 @@ AcpiDsExecuteArguments (
     }
 
     Status = AcpiDsInitAmlWalk (WalkState, Op, NULL, AmlStart,
-                    AmlLength, NULL, ACPI_IMODE_LOAD_PASS1);
+        AmlLength, NULL, ACPI_IMODE_LOAD_PASS1);
     if (ACPI_FAILURE (Status))
     {
         AcpiDsDeleteWalkState (WalkState);
@@ -143,7 +141,7 @@ AcpiDsExecuteArguments (
 
     /* Evaluate the deferred arguments */
 
-    Op = AcpiPsAllocOp (AML_INT_EVAL_SUBTREE_OP);
+    Op = AcpiPsAllocOp (AML_INT_EVAL_SUBTREE_OP, AmlStart);
     if (!Op)
     {
         return_ACPI_STATUS (AE_NO_MEMORY);
@@ -163,7 +161,7 @@ AcpiDsExecuteArguments (
     /* Execute the opcode and arguments */
 
     Status = AcpiDsInitAmlWalk (WalkState, Op, NULL, AmlStart,
-                    AmlLength, NULL, ACPI_IMODE_EXECUTE);
+        AmlLength, NULL, ACPI_IMODE_EXECUTE);
     if (ACPI_FAILURE (Status))
     {
         AcpiDsDeleteWalkState (WalkState);
@@ -216,8 +214,8 @@ AcpiDsGetBufferFieldArguments (
     ExtraDesc = AcpiNsGetSecondaryObject (ObjDesc);
     Node = ObjDesc->BufferField.Node;
 
-    ACPI_DEBUG_EXEC (AcpiUtDisplayInitPathname (ACPI_TYPE_BUFFER_FIELD,
-        Node, NULL));
+    ACPI_DEBUG_EXEC (AcpiUtDisplayInitPathname (
+        ACPI_TYPE_BUFFER_FIELD, Node, NULL));
 
     ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] BufferField Arg Init\n",
         AcpiUtGetNodeName (Node)));
@@ -225,7 +223,7 @@ AcpiDsGetBufferFieldArguments (
     /* Execute the AML code for the TermArg arguments */
 
     Status = AcpiDsExecuteArguments (Node, Node->Parent,
-                ExtraDesc->Extra.AmlLength, ExtraDesc->Extra.AmlStart);
+        ExtraDesc->Extra.AmlLength, ExtraDesc->Extra.AmlStart);
     return_ACPI_STATUS (Status);
 }
 
@@ -265,8 +263,8 @@ AcpiDsGetBankFieldArguments (
     ExtraDesc = AcpiNsGetSecondaryObject (ObjDesc);
     Node = ObjDesc->BankField.Node;
 
-    ACPI_DEBUG_EXEC (AcpiUtDisplayInitPathname (ACPI_TYPE_LOCAL_BANK_FIELD,
-        Node, NULL));
+    ACPI_DEBUG_EXEC (AcpiUtDisplayInitPathname (
+        ACPI_TYPE_LOCAL_BANK_FIELD, Node, NULL));
 
     ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] BankField Arg Init\n",
         AcpiUtGetNodeName (Node)));
@@ -274,7 +272,7 @@ AcpiDsGetBankFieldArguments (
     /* Execute the AML code for the TermArg arguments */
 
     Status = AcpiDsExecuteArguments (Node, Node->Parent,
-                ExtraDesc->Extra.AmlLength, ExtraDesc->Extra.AmlStart);
+        ExtraDesc->Extra.AmlLength, ExtraDesc->Extra.AmlStart);
     return_ACPI_STATUS (Status);
 }
 
@@ -314,7 +312,8 @@ AcpiDsGetBufferArguments (
     if (!Node)
     {
         ACPI_ERROR ((AE_INFO,
-            "No pointer back to namespace node in buffer object %p", ObjDesc));
+            "No pointer back to namespace node in buffer object %p",
+            ObjDesc));
         return_ACPI_STATUS (AE_AML_INTERNAL);
     }
 
@@ -323,7 +322,7 @@ AcpiDsGetBufferArguments (
     /* Execute the AML code for the TermArg arguments */
 
     Status = AcpiDsExecuteArguments (Node, Node,
-                ObjDesc->Buffer.AmlLength, ObjDesc->Buffer.AmlStart);
+        ObjDesc->Buffer.AmlLength, ObjDesc->Buffer.AmlStart);
     return_ACPI_STATUS (Status);
 }
 
@@ -372,7 +371,7 @@ AcpiDsGetPackageArguments (
     /* Execute the AML code for the TermArg arguments */
 
     Status = AcpiDsExecuteArguments (Node, Node,
-                ObjDesc->Package.AmlLength, ObjDesc->Package.AmlStart);
+        ObjDesc->Package.AmlLength, ObjDesc->Package.AmlStart);
     return_ACPI_STATUS (Status);
 }
 
@@ -417,22 +416,23 @@ AcpiDsGetRegionArguments (
 
     Node = ObjDesc->Region.Node;
 
-    ACPI_DEBUG_EXEC (AcpiUtDisplayInitPathname (ACPI_TYPE_REGION, Node, NULL));
+    ACPI_DEBUG_EXEC (AcpiUtDisplayInitPathname (
+        ACPI_TYPE_REGION, Node, NULL));
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[%4.4s] OpRegion Arg Init at AML %p\n",
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+        "[%4.4s] OpRegion Arg Init at AML %p\n",
         AcpiUtGetNodeName (Node), ExtraDesc->Extra.AmlStart));
 
     /* Execute the argument AML */
 
     Status = AcpiDsExecuteArguments (Node, ExtraDesc->Extra.ScopeNode,
-                ExtraDesc->Extra.AmlLength, ExtraDesc->Extra.AmlStart);
+        ExtraDesc->Extra.AmlLength, ExtraDesc->Extra.AmlStart);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
     }
 
     Status = AcpiUtAddAddressRange (ObjDesc->Region.SpaceId,
-                 ObjDesc->Region.Address, ObjDesc->Region.Length,
-                 Node);
+        ObjDesc->Region.Address, ObjDesc->Region.Length, Node);
     return_ACPI_STATUS (Status);
 }
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dscontrol.c b/usr/src/uts/intel/io/acpica/dispatcher/dscontrol.c
index 5c5c51a573..d60361921b 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dscontrol.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dscontrol.c
@@ -6,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,13 +42,12 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSCONTROL_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "amlcode.h"
 #include "acdispat.h"
 #include "acinterp.h"
+#include "acdebug.h"
 
 #define _COMPONENT          ACPI_DISPATCHER
         ACPI_MODULE_NAME    ("dscontrol")
@@ -86,7 +85,6 @@ AcpiDsExecBeginControlOp (
     switch (Op->Common.AmlOpcode)
     {
     case AML_WHILE_OP:
-
         /*
          * If this is an additional iteration of a while loop, continue.
          * There is no need to allocate a new control state.
@@ -107,7 +105,6 @@ AcpiDsExecBeginControlOp (
         /*lint -fallthrough */
 
     case AML_IF_OP:
-
         /*
          * IF/WHILE: Create a new control state to manage these
          * constructs. We need to manage these as a stack, in order
@@ -123,9 +120,12 @@ AcpiDsExecBeginControlOp (
          * Save a pointer to the predicate for multiple executions
          * of a loop
          */
-        ControlState->Control.AmlPredicateStart = WalkState->ParserState.Aml - 1;
-        ControlState->Control.PackageEnd = WalkState->ParserState.PkgEnd;
-        ControlState->Control.Opcode = Op->Common.AmlOpcode;
+        ControlState->Control.AmlPredicateStart =
+            WalkState->ParserState.Aml - 1;
+        ControlState->Control.PackageEnd =
+            WalkState->ParserState.PkgEnd;
+        ControlState->Control.Opcode =
+            Op->Common.AmlOpcode;
 
 
         /* Push the control state on this walk's control stack */
@@ -150,6 +150,7 @@ AcpiDsExecBeginControlOp (
         break;
 
     default:
+
         break;
     }
 
@@ -204,12 +205,10 @@ AcpiDsExecEndControlOp (
         AcpiUtDeleteGenericState (ControlState);
         break;
 
-
     case AML_ELSE_OP:
 
         break;
 
-
     case AML_WHILE_OP:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[WHILE_OP] Op=%p\n", Op));
@@ -226,7 +225,7 @@ AcpiDsExecEndControlOp (
              * loop does not implement a timeout.
              */
             ControlState->Control.LoopCount++;
-            if (ControlState->Control.LoopCount > ACPI_MAX_LOOP_ITERATIONS)
+            if (ControlState->Control.LoopCount > AcpiGbl_MaxLoopIterations)
             {
                 Status = AE_AML_INFINITE_LOOP;
                 break;
@@ -237,7 +236,8 @@ AcpiDsExecEndControlOp (
              * another time
              */
             Status = AE_CTRL_PENDING;
-            WalkState->AmlLastWhile = ControlState->Control.AmlPredicateStart;
+            WalkState->AmlLastWhile =
+                ControlState->Control.AmlPredicateStart;
             break;
         }
 
@@ -252,7 +252,6 @@ AcpiDsExecEndControlOp (
         AcpiUtDeleteGenericState (ControlState);
         break;
 
-
     case AML_RETURN_OP:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
@@ -282,7 +281,8 @@ AcpiDsExecEndControlOp (
              * an arg or local), resolve it now because it may
              * cease to exist at the end of the method.
              */
-            Status = AcpiExResolveToValue (&WalkState->Operands [0], WalkState);
+            Status = AcpiExResolveToValue (
+                &WalkState->Operands [0], WalkState);
             if (ACPI_FAILURE (Status))
             {
                 return (Status);
@@ -290,7 +290,7 @@ AcpiDsExecEndControlOp (
 
             /*
              * Get the return value and save as the last result
-             * value.  This is the only place where WalkState->ReturnDesc
+             * value. This is the only place where WalkState->ReturnDesc
              * is set to anything other than zero!
              */
             WalkState->ReturnDesc = WalkState->Operands[0];
@@ -311,11 +311,15 @@ AcpiDsExecEndControlOp (
              * Allow references created by the Index operator to return
              * unchanged.
              */
-            if ((ACPI_GET_DESCRIPTOR_TYPE (WalkState->Results->Results.ObjDesc[0]) == ACPI_DESC_TYPE_OPERAND) &&
-                ((WalkState->Results->Results.ObjDesc [0])->Common.Type == ACPI_TYPE_LOCAL_REFERENCE) &&
-                ((WalkState->Results->Results.ObjDesc [0])->Reference.Class != ACPI_REFCLASS_INDEX))
+            if ((ACPI_GET_DESCRIPTOR_TYPE (WalkState->Results->Results.ObjDesc[0]) ==
+                    ACPI_DESC_TYPE_OPERAND) &&
+                ((WalkState->Results->Results.ObjDesc [0])->Common.Type ==
+                    ACPI_TYPE_LOCAL_REFERENCE) &&
+                ((WalkState->Results->Results.ObjDesc [0])->Reference.Class !=
+                    ACPI_REFCLASS_INDEX))
             {
-                Status = AcpiExResolveToValue (&WalkState->Results->Results.ObjDesc [0], WalkState);
+                Status = AcpiExResolveToValue (
+                    &WalkState->Results->Results.ObjDesc [0], WalkState);
                 if (ACPI_FAILURE (Status))
                 {
                     return (Status);
@@ -333,9 +337,9 @@ AcpiDsExecEndControlOp (
                 AcpiUtRemoveReference (WalkState->Operands [0]);
             }
 
-            WalkState->Operands [0]     = NULL;
-            WalkState->NumOperands      = 0;
-            WalkState->ReturnDesc       = NULL;
+            WalkState->Operands[0] = NULL;
+            WalkState->NumOperands = 0;
+            WalkState->ReturnDesc = NULL;
         }
 
 
@@ -348,36 +352,27 @@ AcpiDsExecEndControlOp (
         Status = AE_CTRL_TERMINATE;
         break;
 
-
     case AML_NOOP_OP:
 
         /* Just do nothing! */
-        break;
 
+        break;
 
     case AML_BREAK_POINT_OP:
 
-        /*
-         * Set the single-step flag. This will cause the debugger (if present)
-         * to break to the console within the AML debugger at the start of the
-         * next AML instruction.
-         */
-        ACPI_DEBUGGER_EXEC (
-            AcpiGbl_CmSingleStep = TRUE);
-        ACPI_DEBUGGER_EXEC (
-            AcpiOsPrintf ("**break** Executed AML BreakPoint opcode\n"));
+#ifdef ACPI_DEBUGGER
+        AcpiDbSignalBreakPoint (WalkState);
 
         /* Call to the OSL in case OS wants a piece of the action */
 
         Status = AcpiOsSignal (ACPI_SIGNAL_BREAKPOINT,
-                    "Executed AML Breakpoint opcode");
+            "Executed AML Breakpoint opcode");
+#endif
         break;
 
-
     case AML_BREAK_OP:
     case AML_CONTINUE_OP: /* ACPI 2.0 */
 
-
         /* Pop and delete control states until we find a while */
 
         while (WalkState->ControlState &&
@@ -396,7 +391,8 @@ AcpiDsExecEndControlOp (
 
         /* Was: WalkState->AmlLastWhile = WalkState->ControlState->Control.AmlPredicateStart; */
 
-        WalkState->AmlLastWhile = WalkState->ControlState->Control.PackageEnd;
+        WalkState->AmlLastWhile =
+            WalkState->ControlState->Control.PackageEnd;
 
         /* Return status depending on opcode */
 
@@ -410,7 +406,6 @@ AcpiDsExecEndControlOp (
         }
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown control opcode=0x%X Op=%p",
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsdebug.c b/usr/src/uts/intel/io/acpica/dispatcher/dsdebug.c
new file mode 100644
index 0000000000..adeb448c42
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dsdebug.c
@@ -0,0 +1,250 @@
+/******************************************************************************
+ *
+ * Module Name: dsdebug - Parser/Interpreter interface - debugging
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acdispat.h"
+#include "acnamesp.h"
+#include "acdisasm.h"
+#include "acinterp.h"
+
+
+#define _COMPONENT          ACPI_DISPATCHER
+        ACPI_MODULE_NAME    ("dsdebug")
+
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+
+/* Local prototypes */
+
+static void
+AcpiDsPrintNodePathname (
+    ACPI_NAMESPACE_NODE     *Node,
+    const char              *Message);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDsPrintNodePathname
+ *
+ * PARAMETERS:  Node            - Object
+ *              Message         - Prefix message
+ *
+ * DESCRIPTION: Print an object's full namespace pathname
+ *              Manages allocation/freeing of a pathname buffer
+ *
+ ******************************************************************************/
+
+static void
+AcpiDsPrintNodePathname (
+    ACPI_NAMESPACE_NODE     *Node,
+    const char              *Message)
+{
+    ACPI_BUFFER             Buffer;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (DsPrintNodePathname);
+
+    if (!Node)
+    {
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DISPATCH, "[NULL NAME]"));
+        return_VOID;
+    }
+
+    /* Convert handle to full pathname and print it (with supplied message) */
+
+    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
+
+    Status = AcpiNsHandleToPathname (Node, &Buffer, TRUE);
+    if (ACPI_SUCCESS (Status))
+    {
+        if (Message)
+        {
+            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DISPATCH, "%s ", Message));
+        }
+
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DISPATCH, "[%s] (Node %p)",
+            (char *) Buffer.Pointer, Node));
+        ACPI_FREE (Buffer.Pointer);
+    }
+
+    return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDsDumpMethodStack
+ *
+ * PARAMETERS:  Status          - Method execution status
+ *              WalkState       - Current state of the parse tree walk
+ *              Op              - Executing parse op
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Called when a method has been aborted because of an error.
+ *              Dumps the method execution stack.
+ *
+ ******************************************************************************/
+
+void
+AcpiDsDumpMethodStack (
+    ACPI_STATUS             Status,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       *Op)
+{
+    ACPI_PARSE_OBJECT       *Next;
+    ACPI_THREAD_STATE       *Thread;
+    ACPI_WALK_STATE         *NextWalkState;
+    ACPI_NAMESPACE_NODE     *PreviousMethod = NULL;
+    ACPI_OPERAND_OBJECT     *MethodDesc;
+
+
+    ACPI_FUNCTION_TRACE (DsDumpMethodStack);
+
+    /* Ignore control codes, they are not errors */
+
+    if ((Status & AE_CODE_MASK) == AE_CODE_CONTROL)
+    {
+        return_VOID;
+    }
+
+    /* We may be executing a deferred opcode */
+
+    if (WalkState->DeferredNode)
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+            "Executing subtree for Buffer/Package/Region\n"));
+        return_VOID;
+    }
+
+    /*
+     * If there is no Thread, we are not actually executing a method.
+     * This can happen when the iASL compiler calls the interpreter
+     * to perform constant folding.
+     */
+    Thread = WalkState->Thread;
+    if (!Thread)
+    {
+        return_VOID;
+    }
+
+    /* Display exception and method name */
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+        "\n**** Exception %s during execution of method ",
+        AcpiFormatException (Status)));
+
+    AcpiDsPrintNodePathname (WalkState->MethodNode, NULL);
+
+    /* Display stack of executing methods */
+
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DISPATCH,
+        "\n\nMethod Execution Stack:\n"));
+    NextWalkState = Thread->WalkStateList;
+
+    /* Walk list of linked walk states */
+
+    while (NextWalkState)
+    {
+        MethodDesc = NextWalkState->MethodDesc;
+        if (MethodDesc)
+        {
+            AcpiExStopTraceMethod (
+                (ACPI_NAMESPACE_NODE *) MethodDesc->Method.Node,
+                MethodDesc, WalkState);
+        }
+
+        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+            "    Method [%4.4s] executing: ",
+            AcpiUtGetNodeName (NextWalkState->MethodNode)));
+
+        /* First method is the currently executing method */
+
+        if (NextWalkState == WalkState)
+        {
+            if (Op)
+            {
+                /* Display currently executing ASL statement */
+
+                Next = Op->Common.Next;
+                Op->Common.Next = NULL;
+
+#ifdef ACPI_DISASSEMBLER
+                AcpiDmDisassemble (NextWalkState, Op, ACPI_UINT32_MAX);
+#endif
+                Op->Common.Next = Next;
+            }
+        }
+        else
+        {
+            /*
+             * This method has called another method
+             * NOTE: the method call parse subtree is already deleted at
+             * this point, so we cannot disassemble the method invocation.
+             */
+            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DISPATCH, "Call to method "));
+            AcpiDsPrintNodePathname (PreviousMethod, NULL);
+        }
+
+        PreviousMethod = NextWalkState->MethodNode;
+        NextWalkState = NextWalkState->Next;
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_DISPATCH, "\n"));
+    }
+
+    return_VOID;
+}
+
+#else
+
+void
+AcpiDsDumpMethodStack (
+    ACPI_STATUS             Status,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       *Op)
+{
+    return;
+}
+
+#endif
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsfield.c b/usr/src/uts/intel/io/acpica/dispatcher/dsfield.c
index 1c3c523720..2516c131dc 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dsfield.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dsfield.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSFIELD_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "amlcode.h"
@@ -57,6 +55,18 @@
 
 /* Local prototypes */
 
+#ifdef ACPI_ASL_COMPILER
+#include "acdisasm.h"
+
+static ACPI_STATUS
+AcpiDsCreateExternalRegion (
+    ACPI_STATUS             LookupStatus,
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Path,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_NAMESPACE_NODE     **Node);
+#endif
+
 static ACPI_STATUS
 AcpiDsGetFieldNames (
     ACPI_CREATE_FIELD_INFO  *Info,
@@ -64,6 +74,70 @@ AcpiDsGetFieldNames (
     ACPI_PARSE_OBJECT       *Arg);
 
 
+#ifdef ACPI_ASL_COMPILER
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDsCreateExternalRegion (iASL Disassembler only)
+ *
+ * PARAMETERS:  LookupStatus    - Status from NsLookup operation
+ *              Op              - Op containing the Field definition and args
+ *              Path            - Pathname of the region
+ *  `           WalkState       - Current method state
+ *              Node            - Where the new region node is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Add region to the external list if NOT_FOUND. Create a new
+ *              region node/object.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDsCreateExternalRegion (
+    ACPI_STATUS             LookupStatus,
+    ACPI_PARSE_OBJECT       *Op,
+    char                    *Path,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_NAMESPACE_NODE     **Node)
+{
+    ACPI_STATUS             Status;
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+
+
+    if (LookupStatus != AE_NOT_FOUND)
+    {
+        return (LookupStatus);
+    }
+
+    /*
+     * Table disassembly:
+     * OperationRegion not found. Generate an External for it, and
+     * insert the name into the namespace.
+     */
+    AcpiDmAddOpToExternalList (Op, Path, ACPI_TYPE_REGION, 0, 0);
+
+    Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ACPI_TYPE_REGION,
+       ACPI_IMODE_LOAD_PASS1, ACPI_NS_SEARCH_PARENT, WalkState, Node);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* Must create and install a region object for the new node */
+
+    ObjDesc = AcpiUtCreateInternalObject (ACPI_TYPE_REGION);
+    if (!ObjDesc)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    ObjDesc->Region.Node = *Node;
+    Status = AcpiNsAttachObject (*Node, ObjDesc, ACPI_TYPE_REGION);
+    return (Status);
+}
+#endif
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiDsCreateBufferField
@@ -77,8 +151,8 @@ AcpiDsGetFieldNames (
  *              CreateBitFieldOp,
  *              CreateByteFieldOp,
  *              CreateWordFieldOp,
- *              CreateDWordFieldOp,
- *              CreateQWordFieldOp,
+ *              CreateDwordFieldOp,
+ *              CreateQwordFieldOp,
  *              CreateFieldOp       (all of which define a field in a buffer)
  *
  ******************************************************************************/
@@ -137,7 +211,7 @@ AcpiDsCreateBufferField (
         /* Creating new namespace node, should not already exist */
 
         Flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE |
-                ACPI_NS_ERROR_IF_FOUND;
+            ACPI_NS_ERROR_IF_FOUND;
 
         /*
          * Mark node temporary if we are executing a normal control
@@ -151,9 +225,9 @@ AcpiDsCreateBufferField (
 
         /* Enter the NameString into the namespace */
 
-        Status = AcpiNsLookup (WalkState->ScopeInfo, Arg->Common.Value.String,
-                    ACPI_TYPE_ANY, ACPI_IMODE_LOAD_PASS1,
-                    Flags, WalkState, &Node);
+        Status = AcpiNsLookup (WalkState->ScopeInfo,
+            Arg->Common.Value.String, ACPI_TYPE_ANY,
+            ACPI_IMODE_LOAD_PASS1, Flags, WalkState, &Node);
         if (ACPI_FAILURE (Status))
         {
             ACPI_ERROR_NAMESPACE (Arg->Common.Value.String, Status);
@@ -194,13 +268,13 @@ AcpiDsCreateBufferField (
     }
 
     /*
-     * Remember location in AML stream of the field unit opcode and operands --
-     * since the buffer and index operands must be evaluated.
+     * Remember location in AML stream of the field unit opcode and operands
+     * -- since the buffer and index operands must be evaluated.
      */
-    SecondDesc                  = ObjDesc->Common.NextObject;
-    SecondDesc->Extra.AmlStart  = Op->Named.Data;
+    SecondDesc = ObjDesc->Common.NextObject;
+    SecondDesc->Extra.AmlStart = Op->Named.Data;
     SecondDesc->Extra.AmlLength = Op->Named.Length;
-    ObjDesc->BufferField.Node   = Node;
+    ObjDesc->BufferField.Node = Node;
 
     /* Attach constructed field descriptors to parent node */
 
@@ -230,7 +304,7 @@ Cleanup:
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Process all named fields in a field declaration.  Names are
+ * DESCRIPTION: Process all named fields in a field declaration. Names are
  *              entered into the namespace.
  *
  ******************************************************************************/
@@ -268,8 +342,8 @@ AcpiDsGetFieldNames (
         {
         case AML_INT_RESERVEDFIELD_OP:
 
-            Position = (UINT64) Info->FieldBitPosition
-                        + (UINT64) Arg->Common.Value.Size;
+            Position = (UINT64) Info->FieldBitPosition +
+                (UINT64) Arg->Common.Value.Size;
 
             if (Position > ACPI_UINT32_MAX)
             {
@@ -302,11 +376,13 @@ AcpiDsGetFieldNames (
 
             /* AccessAttribute (AttribQuick, AttribByte, etc.) */
 
-            Info->Attribute = (UINT8) ((Arg->Common.Value.Integer >> 8) & 0xFF);
+            Info->Attribute = (UINT8)
+                ((Arg->Common.Value.Integer >> 8) & 0xFF);
 
             /* AccessLength (for serial/buffer protocols) */
 
-            Info->AccessLength = (UINT8) ((Arg->Common.Value.Integer >> 16) & 0xFF);
+            Info->AccessLength = (UINT8)
+                ((Arg->Common.Value.Integer >> 16) & 0xFF);
             break;
 
         case AML_INT_CONNECTION_OP:
@@ -316,6 +392,7 @@ AcpiDsGetFieldNames (
              */
             Info->ResourceBuffer = NULL;
             Info->ConnectionNode = NULL;
+            Info->PinNumberIndex = 0;
 
             /*
              * A Connection() is either an actual resource descriptor (buffer)
@@ -332,9 +409,9 @@ AcpiDsGetFieldNames (
                 /* Lookup the Connection() namepath, it should already exist */
 
                 Status = AcpiNsLookup (WalkState->ScopeInfo,
-                            Child->Common.Value.Name, ACPI_TYPE_ANY,
-                            ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
-                            WalkState, &Info->ConnectionNode);
+                    Child->Common.Value.Name, ACPI_TYPE_ANY,
+                    ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
+                    WalkState, &Info->ConnectionNode);
                 if (ACPI_FAILURE (Status))
                 {
                     ACPI_ERROR_NAMESPACE (Child->Common.Value.Name, Status);
@@ -348,9 +425,9 @@ AcpiDsGetFieldNames (
             /* Lookup the name, it should already exist */
 
             Status = AcpiNsLookup (WalkState->ScopeInfo,
-                        (char *) &Arg->Named.Name, Info->FieldType,
-                        ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
-                        WalkState, &Info->FieldNode);
+                (char *) &Arg->Named.Name, Info->FieldType,
+                ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
+                WalkState, &Info->FieldNode);
             if (ACPI_FAILURE (Status))
             {
                 ACPI_ERROR_NAMESPACE ((char *) &Arg->Named.Name, Status);
@@ -379,8 +456,8 @@ AcpiDsGetFieldNames (
 
             /* Keep track of bit position for the next field */
 
-            Position = (UINT64) Info->FieldBitPosition
-                        + (UINT64) Arg->Common.Value.Size;
+            Position = (UINT64) Info->FieldBitPosition +
+                (UINT64) Arg->Common.Value.Size;
 
             if (Position > ACPI_UINT32_MAX)
             {
@@ -391,12 +468,14 @@ AcpiDsGetFieldNames (
             }
 
             Info->FieldBitPosition += Info->FieldBitLength;
+            Info->PinNumberIndex++; /* Index relative to previous Connection() */
             break;
 
         default:
 
             ACPI_ERROR ((AE_INFO,
-                "Invalid opcode in field list: 0x%X", Arg->Common.AmlOpcode));
+                "Invalid opcode in field list: 0x%X",
+                Arg->Common.AmlOpcode));
             return_ACPI_STATUS (AE_AML_BAD_OPCODE);
         }
 
@@ -438,11 +517,16 @@ AcpiDsCreateField (
     /* First arg is the name of the parent OpRegion (must already exist) */
 
     Arg = Op->Common.Value.Arg;
+
     if (!RegionNode)
     {
         Status = AcpiNsLookup (WalkState->ScopeInfo, Arg->Common.Value.Name,
-                        ACPI_TYPE_REGION, ACPI_IMODE_EXECUTE,
-                        ACPI_NS_SEARCH_PARENT, WalkState, &RegionNode);
+            ACPI_TYPE_REGION, ACPI_IMODE_EXECUTE,
+            ACPI_NS_SEARCH_PARENT, WalkState, &RegionNode);
+#ifdef ACPI_ASL_COMPILER
+        Status = AcpiDsCreateExternalRegion (Status, Arg,
+            Arg->Common.Value.Name, WalkState, &RegionNode);
+#endif
         if (ACPI_FAILURE (Status))
         {
             ACPI_ERROR_NAMESPACE (Arg->Common.Value.Name, Status);
@@ -450,7 +534,7 @@ AcpiDsCreateField (
         }
     }
 
-    ACPI_MEMSET (&Info, 0, sizeof (ACPI_CREATE_FIELD_INFO));
+    memset (&Info, 0, sizeof (ACPI_CREATE_FIELD_INFO));
 
     /* Second arg is the field flags */
 
@@ -519,28 +603,32 @@ AcpiDsInitFieldObjects (
     switch (WalkState->Opcode)
     {
     case AML_FIELD_OP:
+
         Arg = AcpiPsGetArg (Op, 2);
         Type = ACPI_TYPE_LOCAL_REGION_FIELD;
         break;
 
     case AML_BANK_FIELD_OP:
+
         Arg = AcpiPsGetArg (Op, 4);
         Type = ACPI_TYPE_LOCAL_BANK_FIELD;
         break;
 
     case AML_INDEX_FIELD_OP:
+
         Arg = AcpiPsGetArg (Op, 3);
         Type = ACPI_TYPE_LOCAL_INDEX_FIELD;
         break;
 
     default:
+
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
     /* Creating new namespace node(s), should not already exist */
 
     Flags = ACPI_NS_NO_UPSEARCH | ACPI_NS_DONT_OPEN_SCOPE |
-            ACPI_NS_ERROR_IF_FOUND;
+        ACPI_NS_ERROR_IF_FOUND;
 
     /*
      * Mark node(s) temporary if we are executing a normal control
@@ -565,8 +653,8 @@ AcpiDsInitFieldObjects (
         if (Arg->Common.AmlOpcode == AML_INT_NAMEDFIELD_OP)
         {
             Status = AcpiNsLookup (WalkState->ScopeInfo,
-                        (char *) &Arg->Named.Name, Type, ACPI_IMODE_LOAD_PASS1,
-                        Flags, WalkState, &Node);
+                (char *) &Arg->Named.Name, Type, ACPI_IMODE_LOAD_PASS1,
+                Flags, WalkState, &Node);
             if (ACPI_FAILURE (Status))
             {
                 ACPI_ERROR_NAMESPACE ((char *) &Arg->Named.Name, Status);
@@ -626,8 +714,12 @@ AcpiDsCreateBankField (
     if (!RegionNode)
     {
         Status = AcpiNsLookup (WalkState->ScopeInfo, Arg->Common.Value.Name,
-                        ACPI_TYPE_REGION, ACPI_IMODE_EXECUTE,
-                        ACPI_NS_SEARCH_PARENT, WalkState, &RegionNode);
+            ACPI_TYPE_REGION, ACPI_IMODE_EXECUTE,
+            ACPI_NS_SEARCH_PARENT, WalkState, &RegionNode);
+#ifdef ACPI_ASL_COMPILER
+        Status = AcpiDsCreateExternalRegion (Status, Arg,
+            Arg->Common.Value.Name, WalkState, &RegionNode);
+#endif
         if (ACPI_FAILURE (Status))
         {
             ACPI_ERROR_NAMESPACE (Arg->Common.Value.Name, Status);
@@ -639,8 +731,8 @@ AcpiDsCreateBankField (
 
     Arg = Arg->Common.Next;
     Status = AcpiNsLookup (WalkState->ScopeInfo, Arg->Common.Value.String,
-                    ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-                    ACPI_NS_SEARCH_PARENT, WalkState, &Info.RegisterNode);
+        ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+        ACPI_NS_SEARCH_PARENT, WalkState, &Info.RegisterNode);
     if (ACPI_FAILURE (Status))
     {
         ACPI_ERROR_NAMESPACE (Arg->Common.Value.String, Status);
@@ -666,11 +758,12 @@ AcpiDsCreateBankField (
 
     /*
      * Use Info.DataRegisterNode to store BankField Op
-     * It's safe because DataRegisterNode will never be used when create bank field
-     * We store AmlStart and AmlLength in the BankField Op for late evaluation
-     * Used in AcpiExPrepFieldValue(Info)
+     * It's safe because DataRegisterNode will never be used when create
+     * bank field \we store AmlStart and AmlLength in the BankField Op for
+     * late evaluation. Used in AcpiExPrepFieldValue(Info)
      *
-     * TBD: Or, should we add a field in ACPI_CREATE_FIELD_INFO, like "void *ParentOp"?
+     * TBD: Or, should we add a field in ACPI_CREATE_FIELD_INFO, like
+     * "void *ParentOp"?
      */
     Info.DataRegisterNode = (ACPI_NAMESPACE_NODE*) Op;
 
@@ -711,8 +804,8 @@ AcpiDsCreateIndexField (
 
     Arg = Op->Common.Value.Arg;
     Status = AcpiNsLookup (WalkState->ScopeInfo, Arg->Common.Value.String,
-                    ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-                    ACPI_NS_SEARCH_PARENT, WalkState, &Info.RegisterNode);
+        ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+        ACPI_NS_SEARCH_PARENT, WalkState, &Info.RegisterNode);
     if (ACPI_FAILURE (Status))
     {
         ACPI_ERROR_NAMESPACE (Arg->Common.Value.String, Status);
@@ -723,8 +816,8 @@ AcpiDsCreateIndexField (
 
     Arg = Arg->Common.Next;
     Status = AcpiNsLookup (WalkState->ScopeInfo, Arg->Common.Value.String,
-                    ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-                    ACPI_NS_SEARCH_PARENT, WalkState, &Info.DataRegisterNode);
+        ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+        ACPI_NS_SEARCH_PARENT, WalkState, &Info.DataRegisterNode);
     if (ACPI_FAILURE (Status))
     {
         ACPI_ERROR_NAMESPACE (Arg->Common.Value.String, Status);
@@ -744,5 +837,3 @@ AcpiDsCreateIndexField (
     Status = AcpiDsGetFieldNames (&Info, WalkState, Arg->Common.Next);
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsinit.c b/usr/src/uts/intel/io/acpica/dispatcher/dsinit.c
index 1c7ad88492..74e974da03 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dsinit.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dsinit.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSINIT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdispat.h"
@@ -52,6 +50,7 @@
 #define _COMPONENT          ACPI_DISPATCHER
         ACPI_MODULE_NAME    ("dsinit")
 
+
 /* Local prototypes */
 
 static ACPI_STATUS
@@ -73,7 +72,7 @@ AcpiDsInitOneObject (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Callback from AcpiWalkNamespace.  Invoked for every object
+ * DESCRIPTION: Callback from AcpiWalkNamespace. Invoked for every object
  *              within the namespace.
  *
  *              Currently, the only objects that require initialization are:
@@ -91,8 +90,8 @@ AcpiDsInitOneObject (
 {
     ACPI_INIT_WALK_INFO     *Info = (ACPI_INIT_WALK_INFO *) Context;
     ACPI_NAMESPACE_NODE     *Node = (ACPI_NAMESPACE_NODE *) ObjHandle;
-    ACPI_OBJECT_TYPE        Type;
     ACPI_STATUS             Status;
+    ACPI_OPERAND_OBJECT     *ObjDesc;
 
 
     ACPI_FUNCTION_ENTRY ();
@@ -111,9 +110,7 @@ AcpiDsInitOneObject (
 
     /* And even then, we are only interested in a few object types */
 
-    Type = AcpiNsGetType (ObjHandle);
-
-    switch (Type)
+    switch (AcpiNsGetType (ObjHandle))
     {
     case ACPI_TYPE_REGION:
 
@@ -128,20 +125,55 @@ AcpiDsInitOneObject (
         Info->OpRegionCount++;
         break;
 
-
     case ACPI_TYPE_METHOD:
-
+        /*
+         * Auto-serialization support. We will examine each method that is
+         * NotSerialized to determine if it creates any Named objects. If
+         * it does, it will be marked serialized to prevent problems if
+         * the method is entered by two or more threads and an attempt is
+         * made to create the same named object twice -- which results in
+         * an AE_ALREADY_EXISTS exception and method abort.
+         */
         Info->MethodCount++;
-        break;
+        ObjDesc = AcpiNsGetAttachedObject (Node);
+        if (!ObjDesc)
+        {
+            break;
+        }
+
+        /* Ignore if already serialized */
+
+        if (ObjDesc->Method.InfoFlags & ACPI_METHOD_SERIALIZED)
+        {
+            Info->SerialMethodCount++;
+            break;
+        }
+
+        if (AcpiGbl_AutoSerializeMethods)
+        {
+            /* Parse/scan method and serialize it if necessary */
 
+            AcpiDsAutoSerializeMethod (Node, ObjDesc);
+            if (ObjDesc->Method.InfoFlags & ACPI_METHOD_SERIALIZED)
+            {
+                /* Method was just converted to Serialized */
+
+                Info->SerialMethodCount++;
+                Info->SerializedMethodCount++;
+                break;
+            }
+        }
+
+        Info->NonSerialMethodCount++;
+        break;
 
     case ACPI_TYPE_DEVICE:
 
         Info->DeviceCount++;
         break;
 
-
     default:
+
         break;
     }
 
@@ -189,11 +221,10 @@ AcpiDsInitializeObjects (
 
     ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
         "**** Starting initialization of namespace objects ****\n"));
-    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "Parsing all Control Methods:"));
 
     /* Set all init info to zero */
 
-    ACPI_MEMSET (&Info, 0, sizeof (ACPI_INIT_WALK_INFO));
+    memset (&Info, 0, sizeof (ACPI_INIT_WALK_INFO));
 
     Info.OwnerId = OwnerId;
     Info.TableIndex = TableIndex;
@@ -211,7 +242,7 @@ AcpiDsInitializeObjects (
      * the namespace reader lock.
      */
     Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, StartNode, ACPI_UINT32_MAX,
-                ACPI_NS_WALK_UNLOCK, AcpiDsInitOneObject, NULL, &Info, NULL);
+        ACPI_NS_WALK_UNLOCK, AcpiDsInitOneObject, NULL, &Info, NULL);
     if (ACPI_FAILURE (Status))
     {
         ACPI_EXCEPTION ((AE_INFO, Status, "During WalkNamespace"));
@@ -224,15 +255,26 @@ AcpiDsInitializeObjects (
         return_ACPI_STATUS (Status);
     }
 
+    /* DSDT is always the first AML table */
+
+    if (ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_DSDT))
+    {
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+            "\nInitializing Namespace objects:\n"));
+    }
+
+    /* Summary of objects initialized */
+
     ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
-        "\nTable [%4.4s](id %4.4X) - %u Objects with %u Devices %u Methods %u Regions\n",
-        Table->Signature, OwnerId, Info.ObjectCount,
-        Info.DeviceCount, Info.MethodCount, Info.OpRegionCount));
+        "Table [%4.4s: %-8.8s] (id %.2X) - %4u Objects with %3u Devices, "
+        "%3u Regions, %4u Methods (%u/%u/%u Serial/Non/Cvt)\n",
+        Table->Signature, Table->OemTableId, OwnerId, Info.ObjectCount,
+        Info.DeviceCount,Info.OpRegionCount, Info.MethodCount,
+        Info.SerialMethodCount, Info.NonSerialMethodCount,
+        Info.SerializedMethodCount));
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-        "%u Methods, %u Regions\n", Info.MethodCount, Info.OpRegionCount));
+    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "%u Methods, %u Regions\n",
+        Info.MethodCount, Info.OpRegionCount));
 
     return_ACPI_STATUS (AE_OK);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsmethod.c b/usr/src/uts/intel/io/acpica/dispatcher/dsmethod.c
index 670382ac9b..334dadcac6 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dsmethod.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dsmethod.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,14 +41,14 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSMETHOD_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdispat.h"
 #include "acinterp.h"
 #include "acnamesp.h"
-#include "acdisasm.h"
+#include "acparser.h"
+#include "amlcode.h"
+#include "acdebug.h"
 
 
 #define _COMPONENT          ACPI_DISPATCHER
@@ -56,11 +56,153 @@
 
 /* Local prototypes */
 
+static ACPI_STATUS
+AcpiDsDetectNamedOpcodes (
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       **OutOp);
+
 static ACPI_STATUS
 AcpiDsCreateMethodMutex (
     ACPI_OPERAND_OBJECT     *MethodDesc);
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDsAutoSerializeMethod
+ *
+ * PARAMETERS:  Node                        - Namespace Node of the method
+ *              ObjDesc                     - Method object attached to node
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse a control method AML to scan for control methods that
+ *              need serialization due to the creation of named objects.
+ *
+ * NOTE: It is a bit of overkill to mark all such methods serialized, since
+ * there is only a problem if the method actually blocks during execution.
+ * A blocking operation is, for example, a Sleep() operation, or any access
+ * to an operation region. However, it is probably not possible to easily
+ * detect whether a method will block or not, so we simply mark all suspicious
+ * methods as serialized.
+ *
+ * NOTE2: This code is essentially a generic routine for parsing a single
+ * control method.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiDsAutoSerializeMethod (
+    ACPI_NAMESPACE_NODE     *Node,
+    ACPI_OPERAND_OBJECT     *ObjDesc)
+{
+    ACPI_STATUS             Status;
+    ACPI_PARSE_OBJECT       *Op = NULL;
+    ACPI_WALK_STATE         *WalkState;
+
+
+    ACPI_FUNCTION_TRACE_PTR (DsAutoSerializeMethod, Node);
+
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+        "Method auto-serialization parse [%4.4s] %p\n",
+        AcpiUtGetNodeName (Node), Node));
+
+    /* Create/Init a root op for the method parse tree */
+
+    Op = AcpiPsAllocOp (AML_METHOD_OP, ObjDesc->Method.AmlStart);
+    if (!Op)
+    {
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    AcpiPsSetName (Op, Node->Name.Integer);
+    Op->Common.Node = Node;
+
+    /* Create and initialize a new walk state */
+
+    WalkState = AcpiDsCreateWalkState (Node->OwnerId, NULL, NULL, NULL);
+    if (!WalkState)
+    {
+        AcpiPsFreeOp (Op);
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    Status = AcpiDsInitAmlWalk (WalkState, Op, Node,
+        ObjDesc->Method.AmlStart, ObjDesc->Method.AmlLength, NULL, 0);
+    if (ACPI_FAILURE (Status))
+    {
+        AcpiDsDeleteWalkState (WalkState);
+        AcpiPsFreeOp (Op);
+        return_ACPI_STATUS (Status);
+    }
+
+    WalkState->DescendingCallback = AcpiDsDetectNamedOpcodes;
+
+    /* Parse the method, scan for creation of named objects */
+
+    Status = AcpiPsParseAml (WalkState);
+
+    AcpiPsDeleteParseTree (Op);
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDsDetectNamedOpcodes
+ *
+ * PARAMETERS:  WalkState       - Current state of the parse tree walk
+ *              OutOp           - Unused, required for parser interface
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Descending callback used during the loading of ACPI tables.
+ *              Currently used to detect methods that must be marked serialized
+ *              in order to avoid problems with the creation of named objects.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiDsDetectNamedOpcodes (
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       **OutOp)
+{
+
+    ACPI_FUNCTION_NAME (AcpiDsDetectNamedOpcodes);
+
+
+    /* We are only interested in opcodes that create a new name */
+
+    if (!(WalkState->OpInfo->Flags & (AML_NAMED | AML_CREATE | AML_FIELD)))
+    {
+        return (AE_OK);
+    }
+
+    /*
+     * At this point, we know we have a Named object opcode.
+     * Mark the method as serialized. Later code will create a mutex for
+     * this method to enforce serialization.
+     *
+     * Note, ACPI_METHOD_IGNORE_SYNC_LEVEL flag means that we will ignore the
+     * Sync Level mechanism for this method, even though it is now serialized.
+     * Otherwise, there can be conflicts with existing ASL code that actually
+     * uses sync levels.
+     */
+    WalkState->MethodDesc->Method.SyncLevel = 0;
+    WalkState->MethodDesc->Method.InfoFlags |=
+        (ACPI_METHOD_SERIALIZED | ACPI_METHOD_IGNORE_SYNC_LEVEL);
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+        "Method serialized [%4.4s] %p - [%s] (%4.4X)\n",
+        WalkState->MethodNode->Name.Ascii, WalkState->MethodNode,
+        WalkState->OpInfo->Name, WalkState->Opcode));
+
+    /* Abort the parse, no need to examine this method any further */
+
+    return (AE_CTRL_TERMINATE);
+}
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiDsMethodError
@@ -71,7 +213,7 @@ AcpiDsCreateMethodMutex (
  * RETURN:      Status
  *
  * DESCRIPTION: Called on method error. Invoke the global exception handler if
- *              present, dump the method data if the disassembler is configured
+ *              present, dump the method data if the debugger is configured
  *
  *              Note: Allows the exception handler to change the status code
  *
@@ -82,6 +224,9 @@ AcpiDsMethodError (
     ACPI_STATUS             Status,
     ACPI_WALK_STATE         *WalkState)
 {
+    UINT32                  AmlOffset;
+
+
     ACPI_FUNCTION_ENTRY ();
 
 
@@ -105,23 +250,28 @@ AcpiDsMethodError (
          * Handler can map the exception code to anything it wants, including
          * AE_OK, in which case the executing method will not be aborted.
          */
+        AmlOffset = (UINT32) ACPI_PTR_DIFF (WalkState->Aml,
+            WalkState->ParserState.AmlStart);
+
         Status = AcpiGbl_ExceptionHandler (Status,
-                    WalkState->MethodNode ?
-                        WalkState->MethodNode->Name.Integer : 0,
-                    WalkState->Opcode, WalkState->AmlOffset, NULL);
+            WalkState->MethodNode ?
+                WalkState->MethodNode->Name.Integer : 0,
+            WalkState->Opcode, AmlOffset, NULL);
         AcpiExEnterInterpreter ();
     }
 
     AcpiDsClearImplicitReturn (WalkState);
 
-#ifdef ACPI_DISASSEMBLER
     if (ACPI_FAILURE (Status))
     {
-        /* Display method locals/args if disassembler is present */
+        AcpiDsDumpMethodStack (Status, WalkState, WalkState->Op);
 
-        AcpiDmDumpMethodInfo (Status, WalkState, WalkState->Op);
-    }
+        /* Display method locals/args if debugger is present */
+
+#ifdef ACPI_DEBUGGER
+        AcpiDbDumpMethodInfo (Status, WalkState);
 #endif
+    }
 
     return (Status);
 }
@@ -163,6 +313,7 @@ AcpiDsCreateMethodMutex (
     Status = AcpiOsCreateMutex (&MutexDesc->Mutex.OsMutex);
     if (ACPI_FAILURE (Status))
     {
+        AcpiUtDeleteObjectDesc (MutexDesc);
         return_ACPI_STATUS (Status);
     }
 
@@ -183,7 +334,7 @@ AcpiDsCreateMethodMutex (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Prepare a method for execution.  Parses the method if necessary,
+ * DESCRIPTION: Prepare a method for execution. Parses the method if necessary,
  *              increments the thread count, and waits at the method semaphore
  *              for clearance to execute.
  *
@@ -206,6 +357,8 @@ AcpiDsBeginMethodExecution (
         return_ACPI_STATUS (AE_NULL_ENTRY);
     }
 
+    AcpiExStartTraceMethod (MethodNode, ObjDesc, WalkState);
+
     /* Prevent wraparound of thread count */
 
     if (ObjDesc->Method.ThreadCount == ACPI_UINT8_MAX)
@@ -237,15 +390,22 @@ AcpiDsBeginMethodExecution (
         /*
          * The CurrentSyncLevel (per-thread) must be less than or equal to
          * the sync level of the method. This mechanism provides some
-         * deadlock prevention
+         * deadlock prevention.
+         *
+         * If the method was auto-serialized, we just ignore the sync level
+         * mechanism, because auto-serialization of methods can interfere
+         * with ASL code that actually uses sync levels.
          *
          * Top-level method invocation has no walk state at this point
          */
         if (WalkState &&
-            (WalkState->Thread->CurrentSyncLevel > ObjDesc->Method.Mutex->Mutex.SyncLevel))
+            (!(ObjDesc->Method.InfoFlags & ACPI_METHOD_IGNORE_SYNC_LEVEL)) &&
+            (WalkState->Thread->CurrentSyncLevel >
+                ObjDesc->Method.Mutex->Mutex.SyncLevel))
         {
             ACPI_ERROR ((AE_INFO,
-                "Cannot acquire Mutex for method [%4.4s], current SyncLevel is too large (%u)",
+                "Cannot acquire Mutex for method [%4.4s]"
+                ", current SyncLevel is too large (%u)",
                 AcpiUtGetNodeName (MethodNode),
                 WalkState->Thread->CurrentSyncLevel));
 
@@ -258,14 +418,15 @@ AcpiDsBeginMethodExecution (
          */
         if (!WalkState ||
             !ObjDesc->Method.Mutex->Mutex.ThreadId ||
-            (WalkState->Thread->ThreadId != ObjDesc->Method.Mutex->Mutex.ThreadId))
+            (WalkState->Thread->ThreadId !=
+                ObjDesc->Method.Mutex->Mutex.ThreadId))
         {
             /*
              * Acquire the method mutex. This releases the interpreter if we
              * block (and reacquires it before it returns)
              */
-            Status = AcpiExSystemWaitMutex (ObjDesc->Method.Mutex->Mutex.OsMutex,
-                        ACPI_WAIT_FOREVER);
+            Status = AcpiExSystemWaitMutex (
+                ObjDesc->Method.Mutex->Mutex.OsMutex, ACPI_WAIT_FOREVER);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -278,13 +439,30 @@ AcpiDsBeginMethodExecution (
                 ObjDesc->Method.Mutex->Mutex.OriginalSyncLevel =
                     WalkState->Thread->CurrentSyncLevel;
 
-                ObjDesc->Method.Mutex->Mutex.ThreadId = WalkState->Thread->ThreadId;
-                WalkState->Thread->CurrentSyncLevel = ObjDesc->Method.SyncLevel;
+                ObjDesc->Method.Mutex->Mutex.ThreadId =
+                    WalkState->Thread->ThreadId;
+
+                /*
+                 * Update the current SyncLevel only if this is not an auto-
+                 * serialized method. In the auto case, we have to ignore
+                 * the sync level for the method mutex (created for the
+                 * auto-serialization) because we have no idea of what the
+                 * sync level should be. Therefore, just ignore it.
+                 */
+                if (!(ObjDesc->Method.InfoFlags &
+                    ACPI_METHOD_IGNORE_SYNC_LEVEL))
+                {
+                    WalkState->Thread->CurrentSyncLevel =
+                        ObjDesc->Method.SyncLevel;
+                }
             }
             else
             {
                 ObjDesc->Method.Mutex->Mutex.OriginalSyncLevel =
                     ObjDesc->Method.Mutex->Mutex.SyncLevel;
+
+                ObjDesc->Method.Mutex->Mutex.ThreadId =
+                    AcpiOsGetThreadId ();
             }
         }
 
@@ -357,7 +535,8 @@ AcpiDsCallControlMethod (
 
     ACPI_FUNCTION_TRACE_PTR (DsCallControlMethod, ThisWalkState);
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Calling method %p, currentstate=%p\n",
+    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+        "Calling method %p, currentstate=%p\n",
         ThisWalkState->PrevOp, ThisWalkState));
 
     /*
@@ -377,8 +556,8 @@ AcpiDsCallControlMethod (
 
     /* Init for new method, possibly wait on method mutex */
 
-    Status = AcpiDsBeginMethodExecution (MethodNode, ObjDesc,
-                ThisWalkState);
+    Status = AcpiDsBeginMethodExecution (
+        MethodNode, ObjDesc, ThisWalkState);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -386,8 +565,8 @@ AcpiDsCallControlMethod (
 
     /* Begin method parse/execution. Create a new walk state */
 
-    NextWalkState = AcpiDsCreateWalkState (ObjDesc->Method.OwnerId,
-                        NULL, ObjDesc, Thread);
+    NextWalkState = AcpiDsCreateWalkState (
+        ObjDesc->Method.OwnerId, NULL, ObjDesc, Thread);
     if (!NextWalkState)
     {
         Status = AE_NO_MEMORY;
@@ -409,14 +588,15 @@ AcpiDsCallControlMethod (
     Info = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_EVALUATE_INFO));
     if (!Info)
     {
-        return_ACPI_STATUS (AE_NO_MEMORY);
+        Status = AE_NO_MEMORY;
+        goto Cleanup;
     }
 
     Info->Parameters = &ThisWalkState->Operands[0];
 
     Status = AcpiDsInitAmlWalk (NextWalkState, NULL, MethodNode,
-                ObjDesc->Method.AmlStart, ObjDesc->Method.AmlLength,
-                Info, ACPI_IMODE_EXECUTE);
+        ObjDesc->Method.AmlStart, ObjDesc->Method.AmlLength,
+        Info, ACPI_IMODE_EXECUTE);
 
     ACPI_FREE (Info);
     if (ACPI_FAILURE (Status))
@@ -461,10 +641,7 @@ Cleanup:
     /* On error, we must terminate the method properly */
 
     AcpiDsTerminateControlMethod (ObjDesc, NextWalkState);
-    if (NextWalkState)
-    {
-        AcpiDsDeleteWalkState (NextWalkState);
-    }
+    AcpiDsDeleteWalkState (NextWalkState);
 
     return_ACPI_STATUS (Status);
 }
@@ -480,7 +657,7 @@ Cleanup:
  * RETURN:      Status
  *
  * DESCRIPTION: Restart a method that was preempted by another (nested) method
- *              invocation.  Handle the return value (if any) from the callee.
+ *              invocation. Handle the return value (if any) from the callee.
  *
  ******************************************************************************/
 
@@ -570,7 +747,7 @@ AcpiDsRestartControlMethod (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Terminate a control method.  Delete everything that the method
+ * DESCRIPTION: Terminate a control method. Delete everything that the method
  *              created, delete all locals and arguments, and delete the parse
  *              tree if requested.
  *
@@ -614,7 +791,8 @@ AcpiDsTerminateControlMethod (
                 WalkState->Thread->CurrentSyncLevel =
                     MethodDesc->Method.Mutex->Mutex.OriginalSyncLevel;
 
-                AcpiOsReleaseMutex (MethodDesc->Method.Mutex->Mutex.OsMutex);
+                AcpiOsReleaseMutex (
+                    MethodDesc->Method.Mutex->Mutex.OsMutex);
                 MethodDesc->Method.Mutex->Mutex.ThreadId = 0;
             }
         }
@@ -644,7 +822,8 @@ AcpiDsTerminateControlMethod (
             if (MethodDesc->Method.InfoFlags & ACPI_METHOD_MODIFIED_NAMESPACE)
             {
                 AcpiNsDeleteNamespaceByOwner (MethodDesc->Method.OwnerId);
-                MethodDesc->Method.InfoFlags &= ~ACPI_METHOD_MODIFIED_NAMESPACE;
+                MethodDesc->Method.InfoFlags &=
+                    ~ACPI_METHOD_MODIFIED_NAMESPACE;
             }
         }
     }
@@ -691,8 +870,9 @@ AcpiDsTerminateControlMethod (
         {
             if (WalkState)
             {
-                ACPI_INFO ((AE_INFO,
-                    "Marking method %4.4s as Serialized because of AE_ALREADY_EXISTS error",
+                ACPI_INFO ((
+                    "Marking method %4.4s as Serialized "
+                    "because of AE_ALREADY_EXISTS error",
                     WalkState->MethodNode->Name.Ascii));
             }
 
@@ -707,8 +887,11 @@ AcpiDsTerminateControlMethod (
              * marking the method permanently as Serialized when the last
              * thread exits here.
              */
-            MethodDesc->Method.InfoFlags &= ~ACPI_METHOD_SERIALIZED_PENDING;
-            MethodDesc->Method.InfoFlags |= ACPI_METHOD_SERIALIZED;
+            MethodDesc->Method.InfoFlags &=
+                ~ACPI_METHOD_SERIALIZED_PENDING;
+
+            MethodDesc->Method.InfoFlags |=
+                (ACPI_METHOD_SERIALIZED | ACPI_METHOD_IGNORE_SYNC_LEVEL);
             MethodDesc->Method.SyncLevel = 0;
         }
 
@@ -720,7 +903,8 @@ AcpiDsTerminateControlMethod (
         }
     }
 
+    AcpiExStopTraceMethod ((ACPI_NAMESPACE_NODE *) MethodDesc->Method.Node,
+        MethodDesc, WalkState);
+
     return_VOID;
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsmthdat.c b/usr/src/uts/intel/io/acpica/dispatcher/dsmthdat.c
index b4509e7710..32f9850a72 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dsmthdat.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dsmthdat.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSMTHDAT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdispat.h"
@@ -86,7 +84,7 @@ AcpiDsMethodDataGetType (
  * RETURN:      Status
  *
  * DESCRIPTION: Initialize the data structures that hold the method's arguments
- *              and locals.  The data struct is an array of namespace nodes for
+ *              and locals. The data struct is an array of namespace nodes for
  *              each - this allows RefOf and DeRefOf to work properly for these
  *              special data types.
  *
@@ -112,7 +110,9 @@ AcpiDsMethodDataInit (
 
     for (i = 0; i < ACPI_METHOD_NUM_ARGS; i++)
     {
-        ACPI_MOVE_32_TO_32 (&WalkState->Arguments[i].Name, NAMEOF_ARG_NTE);
+        ACPI_MOVE_32_TO_32 (&WalkState->Arguments[i].Name,
+            NAMEOF_ARG_NTE);
+
         WalkState->Arguments[i].Name.Integer |= (i << 24);
         WalkState->Arguments[i].DescriptorType = ACPI_DESC_TYPE_NAMED;
         WalkState->Arguments[i].Type = ACPI_TYPE_ANY;
@@ -123,7 +123,8 @@ AcpiDsMethodDataInit (
 
     for (i = 0; i < ACPI_METHOD_NUM_LOCALS; i++)
     {
-        ACPI_MOVE_32_TO_32 (&WalkState->LocalVariables[i].Name, NAMEOF_LOCAL_NTE);
+        ACPI_MOVE_32_TO_32 (&WalkState->LocalVariables[i].Name,
+            NAMEOF_LOCAL_NTE);
 
         WalkState->LocalVariables[i].Name.Integer |= (i << 24);
         WalkState->LocalVariables[i].DescriptorType = ACPI_DESC_TYPE_NAMED;
@@ -143,7 +144,7 @@ AcpiDsMethodDataInit (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Delete method locals and arguments.  Arguments are only
+ * DESCRIPTION: Delete method locals and arguments. Arguments are only
  *              deleted if this method was called from another method.
  *
  ******************************************************************************/
@@ -165,7 +166,7 @@ AcpiDsMethodDataDeleteAll (
         if (WalkState->LocalVariables[Index].Object)
         {
             ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Deleting Local%u=%p\n",
-                    Index, WalkState->LocalVariables[Index].Object));
+                Index, WalkState->LocalVariables[Index].Object));
 
             /* Detach object (if present) and remove a reference */
 
@@ -180,7 +181,7 @@ AcpiDsMethodDataDeleteAll (
         if (WalkState->Arguments[Index].Object)
         {
             ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Deleting Arg%u=%p\n",
-                    Index, WalkState->Arguments[Index].Object));
+                Index, WalkState->Arguments[Index].Object));
 
             /* Detach object (if present) and remove a reference */
 
@@ -202,7 +203,7 @@ AcpiDsMethodDataDeleteAll (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Initialize arguments for a method.  The parameter list is a list
+ * DESCRIPTION: Initialize arguments for a method. The parameter list is a list
  *              of ACPI operand objects, either null terminated or whose length
  *              is defined by MaxParamCount.
  *
@@ -223,7 +224,8 @@ AcpiDsMethodDataInitArgs (
 
     if (!Params)
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "No param list passed to method\n"));
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "No parameter list passed to method\n"));
         return_ACPI_STATUS (AE_OK);
     }
 
@@ -238,8 +240,8 @@ AcpiDsMethodDataInitArgs (
          * Store the argument in the method/walk descriptor.
          * Do not copy the arg in order to implement call by reference
          */
-        Status = AcpiDsMethodDataSetValue (ACPI_REFCLASS_ARG, Index,
-                    Params[Index], WalkState);
+        Status = AcpiDsMethodDataSetValue (
+            ACPI_REFCLASS_ARG, Index, Params[Index], WalkState);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -315,6 +317,7 @@ AcpiDsMethodDataGetNode (
         break;
 
     default:
+
         ACPI_ERROR ((AE_INFO, "Type %u is invalid", Type));
         return_ACPI_STATUS (AE_TYPE);
     }
@@ -443,7 +446,7 @@ AcpiDsMethodDataGetValue (
          * This means that either 1) The expected argument was
          * not passed to the method, or 2) A local variable
          * was referenced by the method (via the ASL)
-         * before it was initialized.  Either case is an error.
+         * before it was initialized. Either case is an error.
          */
 
         /* If slack enabled, init the LocalX/ArgX to an Integer of value zero */
@@ -472,7 +475,6 @@ AcpiDsMethodDataGetValue (
             return_ACPI_STATUS (AE_AML_UNINITIALIZED_ARG);
 
         case ACPI_REFCLASS_LOCAL:
-
             /*
              * No error message for this case, will be trapped again later to
              * detect and ignore cases of Store(LocalX,LocalX)
@@ -508,7 +510,7 @@ AcpiDsMethodDataGetValue (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Delete the entry at Opcode:Index.  Inserts
+ * DESCRIPTION: Delete the entry at Opcode:Index. Inserts
  *              a null into the stack slot after the object is deleted.
  *
  ******************************************************************************/
@@ -573,7 +575,7 @@ AcpiDsMethodDataDeleteValue (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Store a value in an Arg or Local.  The ObjDesc is installed
+ * DESCRIPTION: Store a value in an Arg or Local. The ObjDesc is installed
  *              as the new value for the Arg or Local and the reference count
  *              for ObjDesc is incremented.
  *
@@ -621,7 +623,7 @@ AcpiDsStoreObjectToLocal (
 
     /*
      * If the reference count on the object is more than one, we must
-     * take a copy of the object before we store.  A reference count
+     * take a copy of the object before we store. A reference count
      * of exactly 1 means that the object was just created during the
      * evaluation of an expression, and we can safely use it since it
      * is not used anywhere else.
@@ -629,7 +631,8 @@ AcpiDsStoreObjectToLocal (
     NewObjDesc = ObjDesc;
     if (ObjDesc->Common.ReferenceCount > 1)
     {
-        Status = AcpiUtCopyIobjectToIobject (ObjDesc, &NewObjDesc, WalkState);
+        Status = AcpiUtCopyIobjectToIobject (
+            ObjDesc, &NewObjDesc, WalkState);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -666,13 +669,16 @@ AcpiDsStoreObjectToLocal (
              * If we have a valid reference object that came from RefOf(),
              * do the indirect store
              */
-            if ((ACPI_GET_DESCRIPTOR_TYPE (CurrentObjDesc) == ACPI_DESC_TYPE_OPERAND) &&
-                (CurrentObjDesc->Common.Type == ACPI_TYPE_LOCAL_REFERENCE) &&
-                (CurrentObjDesc->Reference.Class == ACPI_REFCLASS_REFOF))
+            if ((ACPI_GET_DESCRIPTOR_TYPE (CurrentObjDesc) ==
+                    ACPI_DESC_TYPE_OPERAND) &&
+                (CurrentObjDesc->Common.Type ==
+                    ACPI_TYPE_LOCAL_REFERENCE) &&
+                (CurrentObjDesc->Reference.Class ==
+                    ACPI_REFCLASS_REFOF))
             {
                 ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-                        "Arg (%p) is an ObjRef(Node), storing in node %p\n",
-                        NewObjDesc, CurrentObjDesc));
+                    "Arg (%p) is an ObjRef(Node), storing in node %p\n",
+                    NewObjDesc, CurrentObjDesc));
 
                 /*
                  * Store this object to the Node (perform the indirect store)
@@ -680,8 +686,8 @@ AcpiDsStoreObjectToLocal (
                  * specification rules on storing to Locals/Args.
                  */
                 Status = AcpiExStoreObjectToNode (NewObjDesc,
-                            CurrentObjDesc->Reference.Object, WalkState,
-                            ACPI_NO_IMPLICIT_CONVERSION);
+                    CurrentObjDesc->Reference.Object, WalkState,
+                    ACPI_NO_IMPLICIT_CONVERSION);
 
                 /* Remove local reference if we copied the object above */
 
@@ -689,6 +695,7 @@ AcpiDsStoreObjectToLocal (
                 {
                     AcpiUtRemoveReference (NewObjDesc);
                 }
+
                 return_ACPI_STATUS (Status);
             }
         }
@@ -768,5 +775,3 @@ AcpiDsMethodDataGetType (
     return_VALUE (Object->Type);
 }
 #endif
-
-
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsobject.c b/usr/src/uts/intel/io/acpica/dispatcher/dsobject.c
index b3567766a2..3f7b540580 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dsobject.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dsobject.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSOBJECT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -104,10 +102,10 @@ AcpiDsBuildInternalObject (
         if (!Op->Common.Node)
         {
             Status = AcpiNsLookup (WalkState->ScopeInfo,
-                        Op->Common.Value.String,
-                        ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-                        ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL,
-                        ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE, &(Op->Common.Node)));
+                Op->Common.Value.String,
+                ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+                ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL,
+                ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE, &(Op->Common.Node)));
             if (ACPI_FAILURE (Status))
             {
                 /* Check if we are resolving a named reference within a package */
@@ -163,8 +161,8 @@ AcpiDsBuildInternalObject (
             ObjDesc = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Op->Common.Node);
 
             Status = AcpiExResolveNodeToValue (
-                        ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE, &ObjDesc),
-                        WalkState);
+                ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE, &ObjDesc),
+                WalkState);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -224,14 +222,14 @@ AcpiDsBuildInternalObject (
     /* Create and init a new internal ACPI object */
 
     ObjDesc = AcpiUtCreateInternalObject (
-                (AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode))->ObjectType);
+        (AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode))->ObjectType);
     if (!ObjDesc)
     {
         return_ACPI_STATUS (AE_NO_MEMORY);
     }
 
-    Status = AcpiDsInitObjectFromOp (WalkState, Op, Op->Common.AmlOpcode,
-                &ObjDesc);
+    Status = AcpiDsInitObjectFromOp (
+        WalkState, Op, Op->Common.AmlOpcode, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         AcpiUtRemoveReference (ObjDesc);
@@ -296,7 +294,7 @@ AcpiDsBuildInternalBufferObj (
 
     /*
      * Second arg is the buffer data (optional) ByteList can be either
-     * individual bytes or a string initializer.  In either case, a
+     * individual bytes or a string initializer. In either case, a
      * ByteList appears in the AML.
      */
     Arg = Op->Common.Value.Arg;         /* skip first arg */
@@ -338,8 +336,8 @@ AcpiDsBuildInternalBufferObj (
     }
     else
     {
-        ObjDesc->Buffer.Pointer = ACPI_ALLOCATE_ZEROED (
-                                        ObjDesc->Buffer.Length);
+        ObjDesc->Buffer.Pointer =
+            ACPI_ALLOCATE_ZEROED (ObjDesc->Buffer.Length);
         if (!ObjDesc->Buffer.Pointer)
         {
             AcpiUtDeleteObjectDesc (ObjDesc);
@@ -350,8 +348,8 @@ AcpiDsBuildInternalBufferObj (
 
         if (ByteList)
         {
-            ACPI_MEMCPY (ObjDesc->Buffer.Pointer, ByteList->Named.Data,
-                         ByteListLength);
+            memcpy (ObjDesc->Buffer.Pointer, ByteList->Named.Data,
+                ByteListLength);
         }
     }
 
@@ -470,8 +468,8 @@ AcpiDsBuildInternalPackageObj (
                  * invocation, so we special case it here
                  */
                 Arg->Common.AmlOpcode = AML_INT_NAMEPATH_OP;
-                Status = AcpiDsBuildInternalObject (WalkState, Arg,
-                            &ObjDesc->Package.Elements[i]);
+                Status = AcpiDsBuildInternalObject (
+                    WalkState, Arg, &ObjDesc->Package.Elements[i]);
             }
             else
             {
@@ -483,8 +481,8 @@ AcpiDsBuildInternalPackageObj (
         }
         else
         {
-            Status = AcpiDsBuildInternalObject (WalkState, Arg,
-                        &ObjDesc->Package.Elements[i]);
+            Status = AcpiDsBuildInternalObject (
+                WalkState, Arg, &ObjDesc->Package.Elements[i]);
         }
 
         if (*ObjDescPtr)
@@ -540,8 +538,9 @@ AcpiDsBuildInternalPackageObj (
             Arg = Arg->Common.Next;
         }
 
-        ACPI_INFO ((AE_INFO,
-            "Actual Package length (%u) is larger than NumElements field (%u), truncated\n",
+        ACPI_INFO ((
+            "Actual Package length (%u) is larger than "
+            "NumElements field (%u), truncated",
             i, ElementCount));
     }
     else if (i < ElementCount)
@@ -551,7 +550,8 @@ AcpiDsBuildInternalPackageObj (
          * Note: this is not an error, the package is padded out with NULLs.
          */
         ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-            "Package List length (%u) smaller than NumElements count (%u), padded with null elements\n",
+            "Package List length (%u) smaller than NumElements "
+            "count (%u), padded with null elements\n",
             i, ElementCount));
     }
 
@@ -590,7 +590,7 @@ AcpiDsCreateNode (
 
     /*
      * Because of the execution pass through the non-control-method
-     * parts of the table, we can arrive here twice.  Only init
+     * parts of the table, we can arrive here twice. Only init
      * the named object node the first time through
      */
     if (AcpiNsGetAttachedObject (Node))
@@ -607,8 +607,8 @@ AcpiDsCreateNode (
 
     /* Build an internal object for the argument(s) */
 
-    Status = AcpiDsBuildInternalObject (WalkState, Op->Common.Value.Arg,
-                &ObjDesc);
+    Status = AcpiDsBuildInternalObject (
+        WalkState, Op->Common.Value.Arg, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -643,7 +643,7 @@ AcpiDsCreateNode (
  * RETURN:      Status
  *
  * DESCRIPTION: Initialize a namespace object from a parser Op and its
- *              associated arguments.  The namespace object is a more compact
+ *              associated arguments. The namespace object is a more compact
  *              representation of the Op and its arguments.
  *
  ******************************************************************************/
@@ -677,29 +677,25 @@ AcpiDsInitObjectFromOp (
     switch (ObjDesc->Common.Type)
     {
     case ACPI_TYPE_BUFFER:
-
         /*
          * Defer evaluation of Buffer TermArg operand
          */
-        ObjDesc->Buffer.Node      = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE,
-                                        WalkState->Operands[0]);
-        ObjDesc->Buffer.AmlStart  = Op->Named.Data;
+        ObjDesc->Buffer.Node = ACPI_CAST_PTR (
+            ACPI_NAMESPACE_NODE, WalkState->Operands[0]);
+        ObjDesc->Buffer.AmlStart = Op->Named.Data;
         ObjDesc->Buffer.AmlLength = Op->Named.Length;
         break;
 
-
     case ACPI_TYPE_PACKAGE:
-
         /*
          * Defer evaluation of Package TermArg operand
          */
-        ObjDesc->Package.Node      = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE,
-                                        WalkState->Operands[0]);
-        ObjDesc->Package.AmlStart  = Op->Named.Data;
+        ObjDesc->Package.Node = ACPI_CAST_PTR (
+            ACPI_NAMESPACE_NODE, WalkState->Operands[0]);
+        ObjDesc->Package.AmlStart = Op->Named.Data;
         ObjDesc->Package.AmlLength = Op->Named.Length;
         break;
 
-
     case ACPI_TYPE_INTEGER:
 
         switch (OpInfo->Type)
@@ -734,7 +730,7 @@ AcpiDsInitObjectFromOp (
                 /* Truncate value if we are executing from a 32-bit ACPI table */
 
 #ifndef ACPI_NO_METHOD_EXECUTION
-                AcpiExTruncateFor32bitTable (ObjDesc);
+                (void) AcpiExTruncateFor32bitTable (ObjDesc);
 #endif
                 break;
 
@@ -752,17 +748,25 @@ AcpiDsInitObjectFromOp (
             }
             break;
 
-
         case AML_TYPE_LITERAL:
 
             ObjDesc->Integer.Value = Op->Common.Value.Integer;
+
 #ifndef ACPI_NO_METHOD_EXECUTION
-            AcpiExTruncateFor32bitTable (ObjDesc);
+            if (AcpiExTruncateFor32bitTable (ObjDesc))
+            {
+                /* Warn if we found a 64-bit constant in a 32-bit table */
+
+                ACPI_WARNING ((AE_INFO,
+                    "Truncated 64-bit constant found in 32-bit table: %8.8X%8.8X => %8.8X",
+                    ACPI_FORMAT_UINT64 (Op->Common.Value.Integer),
+                    (UINT32) ObjDesc->Integer.Value));
+            }
 #endif
             break;
 
-
         default:
+
             ACPI_ERROR ((AE_INFO, "Unknown Integer type 0x%X",
                 OpInfo->Type));
             Status = AE_AML_OPERAND_TYPE;
@@ -770,11 +774,10 @@ AcpiDsInitObjectFromOp (
         }
         break;
 
-
     case ACPI_TYPE_STRING:
 
         ObjDesc->String.Pointer = Op->Common.Value.String;
-        ObjDesc->String.Length = (UINT32) ACPI_STRLEN (Op->Common.Value.String);
+        ObjDesc->String.Length = (UINT32) strlen (Op->Common.Value.String);
 
         /*
          * The string is contained in the ACPI table, don't ever try
@@ -783,11 +786,9 @@ AcpiDsInitObjectFromOp (
         ObjDesc->Common.Flags |= AOPOBJ_STATIC_POINTER;
         break;
 
-
     case ACPI_TYPE_METHOD:
         break;
 
-
     case ACPI_TYPE_LOCAL_REFERENCE:
 
         switch (OpInfo->Type)
@@ -801,13 +802,12 @@ AcpiDsInitObjectFromOp (
 
 #ifndef ACPI_NO_METHOD_EXECUTION
             Status = AcpiDsMethodDataGetNode (ACPI_REFCLASS_LOCAL,
-                        ObjDesc->Reference.Value, WalkState,
-                        ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE,
-                            &ObjDesc->Reference.Object));
+                ObjDesc->Reference.Value, WalkState,
+                ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE,
+                    &ObjDesc->Reference.Object));
 #endif
             break;
 
-
         case AML_TYPE_METHOD_ARGUMENT:
 
             /* Arg ID (0-6) is (AML opcode - base AML_ARG_OP) */
@@ -817,9 +817,9 @@ AcpiDsInitObjectFromOp (
 
 #ifndef ACPI_NO_METHOD_EXECUTION
             Status = AcpiDsMethodDataGetNode (ACPI_REFCLASS_ARG,
-                        ObjDesc->Reference.Value, WalkState,
-                        ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE,
-                            &ObjDesc->Reference.Object));
+                ObjDesc->Reference.Value, WalkState,
+                ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE,
+                    &ObjDesc->Reference.Object));
 #endif
             break;
 
@@ -851,7 +851,6 @@ AcpiDsInitObjectFromOp (
         }
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unimplemented data type: 0x%X",
@@ -863,5 +862,3 @@ AcpiDsInitObjectFromOp (
 
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsopcode.c b/usr/src/uts/intel/io/acpica/dispatcher/dsopcode.c
index 7569236f2e..1c6b342570 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dsopcode.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dsopcode.c
@@ -1,11 +1,11 @@
 /******************************************************************************
  *
- * Module Name: dsopcode - Dispatcher suport for regions and fields
+ * Module Name: dsopcode - Dispatcher support for regions and fields
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSOPCODE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -261,8 +259,8 @@ AcpiDsInitBufferField (
      * For FieldFlags, use LOCK_RULE = 0 (NO_LOCK),
      * UPDATE_RULE = 0 (UPDATE_PRESERVE)
      */
-    Status = AcpiExPrepCommonFieldObject (ObjDesc, FieldFlags, 0,
-                                            BitOffset, BitCount);
+    Status = AcpiExPrepCommonFieldObject (
+        ObjDesc, FieldFlags, 0, BitOffset, BitCount);
     if (ACPI_FAILURE (Status))
     {
         goto Cleanup;
@@ -359,8 +357,8 @@ AcpiDsEvalBufferFieldOperands (
 
     /* Resolve the operands */
 
-    Status = AcpiExResolveOperands (Op->Common.AmlOpcode,
-                    ACPI_WALK_OPERANDS, WalkState);
+    Status = AcpiExResolveOperands (
+        Op->Common.AmlOpcode, ACPI_WALK_OPERANDS, WalkState);
     if (ACPI_FAILURE (Status))
     {
         ACPI_ERROR ((AE_INFO, "(%s) bad operand(s), status 0x%X",
@@ -376,16 +374,16 @@ AcpiDsEvalBufferFieldOperands (
         /* NOTE: Slightly different operands for this opcode */
 
         Status = AcpiDsInitBufferField (Op->Common.AmlOpcode, ObjDesc,
-                    WalkState->Operands[0], WalkState->Operands[1],
-                    WalkState->Operands[2], WalkState->Operands[3]);
+            WalkState->Operands[0], WalkState->Operands[1],
+            WalkState->Operands[2], WalkState->Operands[3]);
     }
     else
     {
         /* All other, CreateXxxField opcodes */
 
         Status = AcpiDsInitBufferField (Op->Common.AmlOpcode, ObjDesc,
-                    WalkState->Operands[0], WalkState->Operands[1],
-                                      NULL, WalkState->Operands[2]);
+            WalkState->Operands[0], WalkState->Operands[1],
+            NULL, WalkState->Operands[2]);
     }
 
     return_ACPI_STATUS (Status);
@@ -445,8 +443,8 @@ AcpiDsEvalRegionOperands (
 
     /* Resolve the length and address operands to numbers */
 
-    Status = AcpiExResolveOperands (Op->Common.AmlOpcode,
-                ACPI_WALK_OPERANDS, WalkState);
+    Status = AcpiExResolveOperands (
+        Op->Common.AmlOpcode, ACPI_WALK_OPERANDS, WalkState);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -474,18 +472,16 @@ AcpiDsEvalRegionOperands (
     OperandDesc = WalkState->Operands[WalkState->NumOperands - 2];
 
     ObjDesc->Region.Address = (ACPI_PHYSICAL_ADDRESS)
-                                OperandDesc->Integer.Value;
+        OperandDesc->Integer.Value;
     AcpiUtRemoveReference (OperandDesc);
 
     ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "RgnObj %p Addr %8.8X%8.8X Len %X\n",
-        ObjDesc,
-        ACPI_FORMAT_NATIVE_UINT (ObjDesc->Region.Address),
+        ObjDesc, ACPI_FORMAT_UINT64 (ObjDesc->Region.Address),
         ObjDesc->Region.Length));
 
     /* Now the address and length are valid for this opregion */
 
     ObjDesc->Region.Flags |= AOPOBJ_DATA_VALID;
-
     return_ACPI_STATUS (Status);
 }
 
@@ -515,26 +511,26 @@ AcpiDsEvalTableRegionOperands (
     ACPI_OPERAND_OBJECT     **Operand;
     ACPI_NAMESPACE_NODE     *Node;
     ACPI_PARSE_OBJECT       *NextOp;
-    UINT32                  TableIndex;
     ACPI_TABLE_HEADER       *Table;
+    UINT32                  TableIndex;
 
 
     ACPI_FUNCTION_TRACE_PTR (DsEvalTableRegionOperands, Op);
 
 
     /*
-     * This is where we evaluate the SignatureString and OemIDString
-     * and OemTableIDString of the DataTableRegion declaration
+     * This is where we evaluate the Signature string, OemId string,
+     * and OemTableId string of the Data Table Region declaration
      */
     Node =  Op->Common.Node;
 
-    /* NextOp points to SignatureString op */
+    /* NextOp points to Signature string op */
 
     NextOp = Op->Common.Value.Arg;
 
     /*
-     * Evaluate/create the SignatureString and OemIDString
-     * and OemTableIDString operands
+     * Evaluate/create the Signature string, OemId string,
+     * and OemTableId string operands
      */
     Status = AcpiDsCreateOperands (WalkState, NextOp);
     if (ACPI_FAILURE (Status))
@@ -542,57 +538,67 @@ AcpiDsEvalTableRegionOperands (
         return_ACPI_STATUS (Status);
     }
 
+    Operand = &WalkState->Operands[0];
+
     /*
-     * Resolve the SignatureString and OemIDString
-     * and OemTableIDString operands
+     * Resolve the Signature string, OemId string,
+     * and OemTableId string operands
      */
-    Status = AcpiExResolveOperands (Op->Common.AmlOpcode,
-                ACPI_WALK_OPERANDS, WalkState);
+    Status = AcpiExResolveOperands (
+        Op->Common.AmlOpcode, ACPI_WALK_OPERANDS, WalkState);
     if (ACPI_FAILURE (Status))
     {
-        return_ACPI_STATUS (Status);
+        goto Cleanup;
     }
 
-    Operand = &WalkState->Operands[0];
-
     /* Find the ACPI table */
 
-    Status = AcpiTbFindTable (Operand[0]->String.Pointer,
-                Operand[1]->String.Pointer, Operand[2]->String.Pointer,
-                &TableIndex);
+    Status = AcpiTbFindTable (
+        Operand[0]->String.Pointer,
+        Operand[1]->String.Pointer,
+        Operand[2]->String.Pointer, &TableIndex);
     if (ACPI_FAILURE (Status))
     {
-        return_ACPI_STATUS (Status);
+        if (Status == AE_NOT_FOUND)
+        {
+            ACPI_ERROR ((AE_INFO,
+                "ACPI Table [%4.4s] OEM:(%s, %s) not found in RSDT/XSDT",
+                Operand[0]->String.Pointer,
+                Operand[1]->String.Pointer,
+                Operand[2]->String.Pointer));
+        }
+        goto Cleanup;
     }
 
-    AcpiUtRemoveReference (Operand[0]);
-    AcpiUtRemoveReference (Operand[1]);
-    AcpiUtRemoveReference (Operand[2]);
-
     Status = AcpiGetTableByIndex (TableIndex, &Table);
     if (ACPI_FAILURE (Status))
     {
-        return_ACPI_STATUS (Status);
+        goto Cleanup;
     }
 
     ObjDesc = AcpiNsGetAttachedObject (Node);
     if (!ObjDesc)
     {
-        return_ACPI_STATUS (AE_NOT_EXIST);
+        Status = AE_NOT_EXIST;
+        goto Cleanup;
     }
 
-    ObjDesc->Region.Address = (ACPI_PHYSICAL_ADDRESS) ACPI_TO_INTEGER (Table);
+    ObjDesc->Region.Address = ACPI_PTR_TO_PHYSADDR (Table);
     ObjDesc->Region.Length = Table->Length;
 
     ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "RgnObj %p Addr %8.8X%8.8X Len %X\n",
-        ObjDesc,
-        ACPI_FORMAT_NATIVE_UINT (ObjDesc->Region.Address),
+        ObjDesc, ACPI_FORMAT_UINT64 (ObjDesc->Region.Address),
         ObjDesc->Region.Length));
 
     /* Now the address and length are valid for this opregion */
 
     ObjDesc->Region.Flags |= AOPOBJ_DATA_VALID;
 
+Cleanup:
+    AcpiUtRemoveReference (Operand[0]);
+    AcpiUtRemoveReference (Operand[1]);
+    AcpiUtRemoveReference (Operand[2]);
+
     return_ACPI_STATUS (Status);
 }
 
@@ -641,8 +647,8 @@ AcpiDsEvalDataObjectOperands (
     }
 
     Status = AcpiExResolveOperands (WalkState->Opcode,
-                    &(WalkState->Operands [WalkState->NumOperands -1]),
-                    WalkState);
+        &(WalkState->Operands [WalkState->NumOperands -1]),
+        WalkState);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -670,16 +676,19 @@ AcpiDsEvalDataObjectOperands (
     {
     case AML_BUFFER_OP:
 
-        Status = AcpiDsBuildInternalBufferObj (WalkState, Op, Length, &ObjDesc);
+        Status = AcpiDsBuildInternalBufferObj (
+            WalkState, Op, Length, &ObjDesc);
         break;
 
     case AML_PACKAGE_OP:
     case AML_VAR_PACKAGE_OP:
 
-        Status = AcpiDsBuildInternalPackageObj (WalkState, Op, Length, &ObjDesc);
+        Status = AcpiDsBuildInternalPackageObj (
+            WalkState, Op, Length, &ObjDesc);
         break;
 
     default:
+
         return_ACPI_STATUS (AE_AML_BAD_OPCODE);
     }
 
@@ -806,4 +815,3 @@ AcpiDsEvalBankFieldOperands (
     AcpiUtRemoveReference (OperandDesc);
     return_ACPI_STATUS (Status);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dsutils.c b/usr/src/uts/intel/io/acpica/dispatcher/dsutils.c
index 66431aad53..e294c836e0 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dsutils.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dsutils.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSUTILS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -64,7 +62,7 @@
  *
  * RETURN:      None.
  *
- * DESCRIPTION: Clear and remove a reference on an implicit return value.  Used
+ * DESCRIPTION: Clear and remove a reference on an implicit return value. Used
  *              to delete "stale" return values (if enabled, the return value
  *              from every operator is saved at least momentarily, in case the
  *              parent method exits.)
@@ -117,7 +115,7 @@ AcpiDsClearImplicitReturn (
  *
  * DESCRIPTION: Implements the optional "implicit return".  We save the result
  *              of every ASL operator and control method invocation in case the
- *              parent method exit.  Before storing a new return value, we
+ *              parent method exit. Before storing a new return value, we
  *              delete the previous return value.
  *
  ******************************************************************************/
@@ -142,9 +140,9 @@ AcpiDsDoImplicitReturn (
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-            "Result %p will be implicitly returned; Prev=%p\n",
-            ReturnDesc,
-            WalkState->ImplicitReturnObj));
+        "Result %p will be implicitly returned; Prev=%p\n",
+        ReturnDesc,
+        WalkState->ImplicitReturnObj));
 
     /*
      * Delete any "stale" implicit return value first. However, in
@@ -220,7 +218,7 @@ AcpiDsIsResultUsed (
      *
      * If there is no parent, or the parent is a ScopeOp, we are executing
      * at the method level. An executing method typically has no parent,
-     * since each method is parsed separately.  A method invoked externally
+     * since each method is parsed separately. A method invoked externally
      * via ExecuteControlMethod has a ScopeOp as the parent.
      */
     if ((!Op->Common.Parent) ||
@@ -245,7 +243,7 @@ AcpiDsIsResultUsed (
     }
 
     /*
-     * Decide what to do with the result based on the parent.  If
+     * Decide what to do with the result based on the parent. If
      * the parent opcode will not use the result, delete the object.
      * Otherwise leave it as is, it will be deleted when it is used
      * as an operand later.
@@ -264,12 +262,12 @@ AcpiDsIsResultUsed (
 
         case AML_IF_OP:
         case AML_WHILE_OP:
-
             /*
              * If we are executing the predicate AND this is the predicate op,
              * we will use the return value
              */
-            if ((WalkState->ControlState->Common.State == ACPI_CONTROL_PREDICATE_EXECUTING) &&
+            if ((WalkState->ControlState->Common.State ==
+                    ACPI_CONTROL_PREDICATE_EXECUTING) &&
                 (WalkState->ControlState->Control.PredicateOp == Op))
             {
                 goto ResultUsed;
@@ -277,7 +275,9 @@ AcpiDsIsResultUsed (
             break;
 
         default:
+
             /* Ignore other control opcodes */
+
             break;
         }
 
@@ -285,16 +285,13 @@ AcpiDsIsResultUsed (
 
         goto ResultNotUsed;
 
-
     case AML_CLASS_CREATE:
-
         /*
          * These opcodes allow TermArg(s) as operands and therefore
-         * the operands can be method calls.  The result is used.
+         * the operands can be method calls. The result is used.
          */
         goto ResultUsed;
 
-
     case AML_CLASS_NAMED_OBJECT:
 
         if ((Op->Common.Parent->Common.AmlOpcode == AML_REGION_OP)       ||
@@ -307,16 +304,14 @@ AcpiDsIsResultUsed (
         {
             /*
              * These opcodes allow TermArg(s) as operands and therefore
-             * the operands can be method calls.  The result is used.
+             * the operands can be method calls. The result is used.
              */
             goto ResultUsed;
         }
 
         goto ResultNotUsed;
 
-
     default:
-
         /*
          * In all other cases. the parent will actually use the return
          * object, so keep it.
@@ -354,9 +349,9 @@ ResultNotUsed:
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Used after interpretation of an opcode.  If there is an internal
+ * DESCRIPTION: Used after interpretation of an opcode. If there is an internal
  *              result descriptor, check if the parent opcode will actually use
- *              this result.  If not, delete the result now so that it will
+ *              this result. If not, delete the result now so that it will
  *              not become orphaned.
  *
  ******************************************************************************/
@@ -408,7 +403,7 @@ AcpiDsDeleteResultIfNotUsed (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Resolve all operands to their values.  Used to prepare
+ * DESCRIPTION: Resolve all operands to their values. Used to prepare
  *              arguments to a control method invocation (a call from one
  *              method to another.)
  *
@@ -427,7 +422,7 @@ AcpiDsResolveOperands (
 
     /*
      * Attempt to resolve each of the valid operands
-     * Method arguments are passed by reference, not by value.  This means
+     * Method arguments are passed by reference, not by value. This means
      * that the actual objects are passed, not copies of the objects.
      */
     for (i = 0; i < WalkState->NumOperands; i++)
@@ -494,7 +489,7 @@ AcpiDsClearOperands (
  * RETURN:      Status
  *
  * DESCRIPTION: Translate a parse tree object that is an argument to an AML
- *              opcode to the equivalent interpreter object.  This may include
+ *              opcode to the equivalent interpreter object. This may include
  *              looking up a name or entering a new name into the internal
  *              namespace.
  *
@@ -529,8 +524,8 @@ AcpiDsCreateOperand (
 
         /* Get the entire name string from the AML stream */
 
-        Status = AcpiExGetNameString (ACPI_TYPE_ANY, Arg->Common.Value.Buffer,
-                        &NameString, &NameLength);
+        Status = AcpiExGetNameString (ACPI_TYPE_ANY,
+            Arg->Common.Value.Buffer, &NameString, &NameLength);
 
         if (ACPI_FAILURE (Status))
         {
@@ -540,20 +535,21 @@ AcpiDsCreateOperand (
         /* All prefixes have been handled, and the name is in NameString */
 
         /*
-         * Special handling for BufferField declarations.  This is a deferred
+         * Special handling for BufferField declarations. This is a deferred
          * opcode that unfortunately defines the field name as the last
-         * parameter instead of the first.  We get here when we are performing
+         * parameter instead of the first. We get here when we are performing
          * the deferred execution, so the actual name of the field is already
-         * in the namespace.  We don't want to attempt to look it up again
+         * in the namespace. We don't want to attempt to look it up again
          * because we may be executing in a different scope than where the
          * actual opcode exists.
          */
         if ((WalkState->DeferredNode) &&
             (WalkState->DeferredNode->Type == ACPI_TYPE_BUFFER_FIELD) &&
-            (ArgIndex == (UINT32) ((WalkState->Opcode == AML_CREATE_FIELD_OP) ? 3 : 2)))
+            (ArgIndex == (UINT32)
+                ((WalkState->Opcode == AML_CREATE_FIELD_OP) ? 3 : 2)))
         {
             ObjDesc = ACPI_CAST_PTR (
-                        ACPI_OPERAND_OBJECT, WalkState->DeferredNode);
+                ACPI_OPERAND_OBJECT, WalkState->DeferredNode);
             Status = AE_OK;
         }
         else    /* All other opcodes */
@@ -566,6 +562,7 @@ AcpiDsCreateOperand (
              */
             ParentOp = Arg->Common.Parent;
             OpInfo = AcpiPsGetOpcodeInfo (ParentOp->Common.AmlOpcode);
+
             if ((OpInfo->Flags & AML_NSNODE) &&
                 (ParentOp->Common.AmlOpcode != AML_INT_METHODCALL_OP) &&
                 (ParentOp->Common.AmlOpcode != AML_REGION_OP) &&
@@ -583,10 +580,9 @@ AcpiDsCreateOperand (
             }
 
             Status = AcpiNsLookup (WalkState->ScopeInfo, NameString,
-                        ACPI_TYPE_ANY, InterpreterMode,
-                        ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
-                        WalkState,
-                        ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE, &ObjDesc));
+                ACPI_TYPE_ANY, InterpreterMode,
+                ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, WalkState,
+                ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE, &ObjDesc));
             /*
              * The only case where we pass through (ignore) a NOT_FOUND
              * error is for the CondRefOf opcode.
@@ -602,9 +598,20 @@ AcpiDsCreateOperand (
                      * object to the root
                      */
                     ObjDesc = ACPI_CAST_PTR (
-                                ACPI_OPERAND_OBJECT, AcpiGbl_RootNode);
+                        ACPI_OPERAND_OBJECT, AcpiGbl_RootNode);
                     Status = AE_OK;
                 }
+                else if (ParentOp->Common.AmlOpcode == AML_EXTERNAL_OP)
+                {
+                    /*
+                     * This opcode should never appear here. It is used only
+                     * by AML disassemblers and is surrounded by an If(0)
+                     * by the ASL compiler.
+                     *
+                     * Therefore, if we see it here, it is a serious error.
+                     */
+                    Status = AE_AML_BAD_OPCODE;
+                }
                 else
                 {
                     /*
@@ -639,7 +646,10 @@ AcpiDsCreateOperand (
         {
             return_ACPI_STATUS (Status);
         }
-        ACPI_DEBUGGER_EXEC (AcpiDbDisplayArgumentObject (ObjDesc, WalkState));
+
+#ifdef ACPI_DEBUGGER
+        AcpiDbDisplayArgumentObject (ObjDesc, WalkState);
+#endif
     }
     else
     {
@@ -651,8 +661,8 @@ AcpiDsCreateOperand (
             /*
              * If the name is null, this means that this is an
              * optional result parameter that was not specified
-             * in the original ASL.  Create a Zero Constant for a
-             * placeholder.  (Store to a constant is a Noop.)
+             * in the original ASL. Create a Zero Constant for a
+             * placeholder. (Store to a constant is a Noop.)
              */
             Opcode = AML_ZERO_OP;       /* Has no arguments! */
 
@@ -672,13 +682,16 @@ AcpiDsCreateOperand (
             return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
         }
 
-        if ((OpInfo->Flags & AML_HAS_RETVAL) || (Arg->Common.Flags & ACPI_PARSEOP_IN_STACK))
+        if ((OpInfo->Flags & AML_HAS_RETVAL) ||
+            (Arg->Common.Flags & ACPI_PARSEOP_IN_STACK))
         {
             ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
                 "Argument previously created, already stacked\n"));
 
-            ACPI_DEBUGGER_EXEC (AcpiDbDisplayArgumentObject (
-                WalkState->Operands [WalkState->NumOperands - 1], WalkState));
+#ifdef ACPI_DEBUGGER
+            AcpiDbDisplayArgumentObject (
+                WalkState->Operands [WalkState->NumOperands - 1], WalkState);
+#endif
 
             /*
              * Use value that was already previously returned
@@ -709,7 +722,7 @@ AcpiDsCreateOperand (
             /* Initialize the new object */
 
             Status = AcpiDsInitObjectFromOp (
-                        WalkState, Arg, Opcode, &ObjDesc);
+                WalkState, Arg, Opcode, &ObjDesc);
             if (ACPI_FAILURE (Status))
             {
                 AcpiUtDeleteObjectDesc (ObjDesc);
@@ -725,7 +738,9 @@ AcpiDsCreateOperand (
             return_ACPI_STATUS (Status);
         }
 
-        ACPI_DEBUGGER_EXEC (AcpiDbDisplayArgumentObject (ObjDesc, WalkState));
+#ifdef ACPI_DEBUGGER
+        AcpiDbDisplayArgumentObject (ObjDesc, WalkState);
+#endif
     }
 
     return_ACPI_STATUS (AE_OK);
@@ -783,16 +798,16 @@ AcpiDsCreateOperands (
         Index++;
     }
 
-    Index--;
+    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+        "NumOperands %d, ArgCount %d, Index %d\n",
+        WalkState->NumOperands, ArgCount, Index));
 
-    /* It is the appropriate order to get objects from the Result stack */
+    /* Create the interpreter arguments, in reverse order */
 
+    Index--;
     for (i = 0; i < ArgCount; i++)
     {
         Arg = Arguments[Index];
-
-        /* Force the filling of the operand stack in inverse order */
-
         WalkState->OperandIndex = (UINT8) Index;
 
         Status = AcpiDsCreateOperand (WalkState, Arg, Index);
@@ -801,10 +816,10 @@ AcpiDsCreateOperands (
             goto Cleanup;
         }
 
+        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+            "Created Arg #%u (%p) %u args total\n",
+            Index, Arg, ArgCount));
         Index--;
-
-        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Arg #%u (%p) done, Arg1=%p\n",
-            Index, Arg, FirstArg));
     }
 
     return_ACPI_STATUS (Status);
@@ -895,7 +910,8 @@ AcpiDsEvaluateNamePath (
 
         AcpiUtRemoveReference (*Operand);
 
-        Status = AcpiUtCopyIobjectToIobject (*Operand, &NewObjDesc, WalkState);
+        Status = AcpiUtCopyIobjectToIobject (
+            *Operand, &NewObjDesc, WalkState);
         if (ACPI_FAILURE (Status))
         {
             goto Exit;
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswexec.c b/usr/src/uts/intel/io/acpica/dispatcher/dswexec.c
index 5732855bbe..8408ebf2f6 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dswexec.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dswexec.c
@@ -6,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +42,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSWEXEC_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -164,7 +162,7 @@ AcpiDsGetPredicateValue (
 
     /* Truncate the predicate to 32-bits if necessary */
 
-    AcpiExTruncateFor32bitTable (LocalObjDesc);
+    (void) AcpiExTruncateFor32bitTable (LocalObjDesc);
 
     /*
      * Save the result of the predicate evaluation on
@@ -191,12 +189,15 @@ AcpiDsGetPredicateValue (
 
 Cleanup:
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Completed a predicate eval=%X Op=%p\n",
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+        "Completed a predicate eval=%X Op=%p\n",
         WalkState->ControlState->Common.Value, WalkState->Op));
 
-     /* Break to debugger to display result */
+#ifdef ACPI_DEBUGGER
+    /* Break to debugger to display result */
 
-    ACPI_DEBUGGER_EXEC (AcpiDbDisplayResultObject (LocalObjDesc, WalkState));
+    AcpiDbDisplayResultObject (LocalObjDesc, WalkState);
+#endif
 
     /*
      * Delete the predicate result object (we know that
@@ -223,7 +224,7 @@ Cleanup:
  * RETURN:      Status
  *
  * DESCRIPTION: Descending callback used during the execution of control
- *              methods.  This is where most operators and operands are
+ *              methods. This is where most operators and operands are
  *              dispatched to the interpreter.
  *
  ****************************************************************************/
@@ -288,10 +289,12 @@ AcpiDsExecBeginOp (
         (WalkState->ControlState->Common.State ==
             ACPI_CONTROL_CONDITIONAL_EXECUTING))
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Exec predicate Op=%p State=%p\n",
-                        Op, WalkState));
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "Exec predicate Op=%p State=%p\n",
+            Op, WalkState));
 
-        WalkState->ControlState->Common.State = ACPI_CONTROL_PREDICATE_EXECUTING;
+        WalkState->ControlState->Common.State =
+            ACPI_CONTROL_PREDICATE_EXECUTING;
 
         /* Save start of predicate */
 
@@ -318,14 +321,13 @@ AcpiDsExecBeginOp (
         Status = AcpiDsExecBeginControlOp (WalkState, Op);
         break;
 
-
     case AML_CLASS_NAMED_OBJECT:
 
         if (WalkState->WalkType & ACPI_WALK_METHOD)
         {
             /*
              * Found a named object declaration during method execution;
-             * we must enter this object into the namespace.  The created
+             * we must enter this object into the namespace. The created
              * object is temporary and will be deleted upon completion of
              * the execution of this method.
              *
@@ -340,8 +342,8 @@ AcpiDsExecBeginOp (
             }
             else
             {
-                Status = AcpiDsScopeStackPush (Op->Named.Node,
-                            Op->Named.Node->Type, WalkState);
+                Status = AcpiDsScopeStackPush (
+                    Op->Named.Node, Op->Named.Node->Type, WalkState);
                 if (ACPI_FAILURE (Status))
                 {
                     return_ACPI_STATUS (Status);
@@ -350,14 +352,13 @@ AcpiDsExecBeginOp (
         }
         break;
 
-
     case AML_CLASS_EXECUTE:
     case AML_CLASS_CREATE:
 
         break;
 
-
     default:
+
         break;
     }
 
@@ -381,7 +382,7 @@ ErrorExit:
  * RETURN:      Status
  *
  * DESCRIPTION: Ascending callback used during the execution of control
- *              methods.  The only thing we really need to do here is to
+ *              methods. The only thing we really need to do here is to
  *              notice the beginning of IF, ELSE, and WHILE blocks.
  *
  ****************************************************************************/
@@ -401,8 +402,8 @@ AcpiDsExecEndOp (
     ACPI_FUNCTION_TRACE_PTR (DsExecEndOp, WalkState);
 
 
-    Op      = WalkState->Op;
-    OpType  = WalkState->OpInfo->Type;
+    Op = WalkState->Op;
+    OpType = WalkState->OpInfo->Type;
     OpClass = WalkState->OpInfo->Class;
 
     if (OpClass == AML_CLASS_UNKNOWN)
@@ -420,10 +421,15 @@ AcpiDsExecEndOp (
     WalkState->ReturnDesc = NULL;
     WalkState->ResultObj = NULL;
 
+#ifdef ACPI_DEBUGGER
     /* Call debugger for single step support (DEBUG build only) */
 
-    ACPI_DEBUGGER_EXEC (Status = AcpiDbSingleStep (WalkState, Op, OpClass));
-    ACPI_DEBUGGER_EXEC (if (ACPI_FAILURE (Status)) {return_ACPI_STATUS (Status);});
+    Status = AcpiDbSingleStep (WalkState, Op, OpClass);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+#endif
 
     /* Decode the Opcode Class */
 
@@ -441,7 +447,6 @@ AcpiDsExecEndOp (
         }
         break;
 
-
     case AML_CLASS_EXECUTE:     /* Most operators with arguments */
 
         /* Build resolved operand stack */
@@ -461,15 +466,15 @@ AcpiDsExecEndOp (
             /* Resolve all operands */
 
             Status = AcpiExResolveOperands (WalkState->Opcode,
-                        &(WalkState->Operands [WalkState->NumOperands -1]),
-                        WalkState);
+                &(WalkState->Operands [WalkState->NumOperands -1]),
+                WalkState);
         }
 
         if (ACPI_SUCCESS (Status))
         {
             /*
              * Dispatch the request to the appropriate interpreter handler
-             * routine.  There is one routine per opcode "type" based upon the
+             * routine. There is one routine per opcode "type" based upon the
              * number of opcode arguments and return type.
              */
             Status = AcpiGbl_OpTypeDispatch[OpType] (WalkState);
@@ -514,7 +519,6 @@ AcpiDsExecEndOp (
         }
         break;
 
-
     default:
 
         switch (OpType)
@@ -527,9 +531,7 @@ AcpiDsExecEndOp (
 
             break;
 
-
         case AML_TYPE_METHOD_CALL:
-
             /*
              * If the method is referenced from within a package
              * declaration, it is not a invocation of the method, just
@@ -542,12 +544,14 @@ AcpiDsExecEndOp (
                 ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
                     "Method Reference in a Package, Op=%p\n", Op));
 
-                Op->Common.Node = (ACPI_NAMESPACE_NODE *) Op->Asl.Value.Arg->Asl.Node;
+                Op->Common.Node = (ACPI_NAMESPACE_NODE *)
+                    Op->Asl.Value.Arg->Asl.Node;
                 AcpiUtAddReference (Op->Asl.Value.Arg->Asl.Node->Object);
                 return_ACPI_STATUS (AE_OK);
             }
 
-            ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Method invocation, Op=%p\n", Op));
+            ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
+                "Method invocation, Op=%p\n", Op));
 
             /*
              * (AML_METHODCALL) Op->Asl.Value.Arg->Asl.Node contains
@@ -596,7 +600,6 @@ AcpiDsExecEndOp (
              */
             return_ACPI_STATUS (Status);
 
-
         case AML_TYPE_CREATE_FIELD:
 
             ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
@@ -620,17 +623,16 @@ AcpiDsExecEndOp (
             switch (Op->Common.Parent->Common.AmlOpcode)
             {
             case AML_NAME_OP:
-
                 /*
                  * Put the Node on the object stack (Contains the ACPI Name
                  * of this object)
                  */
-                WalkState->Operands[0] = (void *) Op->Common.Parent->Common.Node;
+                WalkState->Operands[0] = (void *)
+                    Op->Common.Parent->Common.Node;
                 WalkState->NumOperands = 1;
 
                 Status = AcpiDsCreateNode (WalkState,
-                            Op->Common.Parent->Common.Node,
-                            Op->Common.Parent);
+                    Op->Common.Parent->Common.Node, Op->Common.Parent);
                 if (ACPI_FAILURE (Status))
                 {
                     break;
@@ -642,7 +644,7 @@ AcpiDsExecEndOp (
             case AML_INT_EVAL_SUBTREE_OP:
 
                 Status = AcpiDsEvalDataObjectOperands (WalkState, Op,
-                            AcpiNsGetAttachedObject (Op->Common.Parent->Common.Node));
+                    AcpiNsGetAttachedObject (Op->Common.Parent->Common.Node));
                 break;
 
             default:
@@ -661,7 +663,6 @@ AcpiDsExecEndOp (
             }
             break;
 
-
         case AML_TYPE_NAMED_FIELD:
         case AML_TYPE_NAMED_COMPLEX:
         case AML_TYPE_NAMED_SIMPLE:
@@ -708,14 +709,12 @@ AcpiDsExecEndOp (
             }
             break;
 
-
         case AML_TYPE_UNDEFINED:
 
             ACPI_ERROR ((AE_INFO,
                 "Undefined opcode type Op=%p", Op));
             return_ACPI_STATUS (AE_NOT_IMPLEMENTED);
 
-
         case AML_TYPE_BOGUS:
 
             ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
@@ -723,11 +722,11 @@ AcpiDsExecEndOp (
                 WalkState->Opcode, Op));
             break;
 
-
         default:
 
             ACPI_ERROR ((AE_INFO,
-                "Unimplemented opcode, class=0x%X type=0x%X Opcode=-0x%X Op=%p",
+                "Unimplemented opcode, class=0x%X "
+                "type=0x%X Opcode=0x%X Op=%p",
                 OpClass, OpType, Op->Common.AmlOpcode, Op));
 
             Status = AE_NOT_IMPLEMENTED;
@@ -739,7 +738,7 @@ AcpiDsExecEndOp (
      * ACPI 2.0 support for 64-bit integers: Truncate numeric
      * result value if we are executing from a 32-bit ACPI table
      */
-    AcpiExTruncateFor32bitTable (WalkState->ResultObj);
+    (void) AcpiExTruncateFor32bitTable (WalkState->ResultObj);
 
     /*
      * Check if we just completed the evaluation of a
@@ -760,10 +759,11 @@ Cleanup:
 
     if (WalkState->ResultObj)
     {
+#ifdef ACPI_DEBUGGER
         /* Break to debugger to display result */
 
-        ACPI_DEBUGGER_EXEC (AcpiDbDisplayResultObject (WalkState->ResultObj,
-                                WalkState));
+        AcpiDbDisplayResultObject (WalkState->ResultObj,WalkState);
+#endif
 
         /*
          * Delete the result op if and only if:
@@ -793,5 +793,3 @@ Cleanup:
     WalkState->NumOperands = 0;
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswload.c b/usr/src/uts/intel/io/acpica/dispatcher/dswload.c
index d40f911f41..db55661208 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dswload.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dswload.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSWLOAD_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -80,7 +78,21 @@ AcpiDsInitCallbacks (
 
     switch (PassNumber)
     {
+    case 0:
+
+        /* Parse only - caller will setup callbacks */
+
+        WalkState->ParseFlags         = ACPI_PARSE_LOAD_PASS1 |
+                                        ACPI_PARSE_DELETE_TREE |
+                                        ACPI_PARSE_DISASSEMBLE;
+        WalkState->DescendingCallback = NULL;
+        WalkState->AscendingCallback  = NULL;
+        break;
+
     case 1:
+
+        /* Load pass 1 */
+
         WalkState->ParseFlags         = ACPI_PARSE_LOAD_PASS1 |
                                         ACPI_PARSE_DELETE_TREE;
         WalkState->DescendingCallback = AcpiDsLoad1BeginOp;
@@ -88,6 +100,9 @@ AcpiDsInitCallbacks (
         break;
 
     case 2:
+
+        /* Load pass 2 */
+
         WalkState->ParseFlags         = ACPI_PARSE_LOAD_PASS1 |
                                         ACPI_PARSE_DELETE_TREE;
         WalkState->DescendingCallback = AcpiDsLoad2BeginOp;
@@ -95,6 +110,9 @@ AcpiDsInitCallbacks (
         break;
 
     case 3:
+
+        /* Execution pass */
+
 #ifndef ACPI_NO_METHOD_EXECUTION
         WalkState->ParseFlags        |= ACPI_PARSE_EXECUTE  |
                                         ACPI_PARSE_DELETE_TREE;
@@ -104,6 +122,7 @@ AcpiDsInitCallbacks (
         break;
 
     default:
+
         return (AE_BAD_PARAMETER);
     }
 
@@ -169,19 +188,19 @@ AcpiDsLoad1BeginOp (
     ObjectType = WalkState->OpInfo->ObjectType;
 
     ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-        "State=%p Op=%p [%s]\n", WalkState, Op, AcpiUtGetTypeName (ObjectType)));
+        "State=%p Op=%p [%s]\n", WalkState, Op,
+        AcpiUtGetTypeName (ObjectType)));
 
     switch (WalkState->Opcode)
     {
     case AML_SCOPE_OP:
-
         /*
          * The target name of the Scope() operator must exist at this point so
          * that we can actually open the scope to enter new names underneath it.
          * Allow search-to-root for single namesegs.
          */
         Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ObjectType,
-                        ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, WalkState, &(Node));
+            ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, WalkState, &(Node));
 #ifdef ACPI_ASL_COMPILER
         if (Status == AE_NOT_FOUND)
         {
@@ -190,10 +209,10 @@ AcpiDsLoad1BeginOp (
              * Target of Scope() not found. Generate an External for it, and
              * insert the name into the namespace.
              */
-            AcpiDmAddToExternalList (Op, Path, ACPI_TYPE_DEVICE, 0);
+            AcpiDmAddOpToExternalList (Op, Path, ACPI_TYPE_DEVICE, 0, 0);
             Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ObjectType,
-                       ACPI_IMODE_LOAD_PASS1, ACPI_NS_SEARCH_PARENT,
-                       WalkState, &Node);
+               ACPI_IMODE_LOAD_PASS1, ACPI_NS_SEARCH_PARENT,
+               WalkState, &Node);
         }
 #endif
         if (ACPI_FAILURE (Status))
@@ -221,7 +240,6 @@ AcpiDsLoad1BeginOp (
         case ACPI_TYPE_INTEGER:
         case ACPI_TYPE_STRING:
         case ACPI_TYPE_BUFFER:
-
             /*
              * These types we will allow, but we will change the type.
              * This enables some existing code of the form:
@@ -241,6 +259,19 @@ AcpiDsLoad1BeginOp (
             WalkState->ScopeInfo->Common.Value = ACPI_TYPE_ANY;
             break;
 
+        case ACPI_TYPE_METHOD:
+            /*
+             * Allow scope change to root during execution of module-level
+             * code. Root is typed METHOD during this time.
+             */
+            if ((Node == AcpiGbl_RootNode) &&
+                (WalkState->ParseFlags & ACPI_PARSE_MODULE_LEVEL))
+            {
+                break;
+            }
+
+            /*lint -fallthrough */
+
         default:
 
             /* All other types are an error */
@@ -254,7 +285,6 @@ AcpiDsLoad1BeginOp (
         }
         break;
 
-
     default:
         /*
          * For all other named opcodes, we will enter the name into
@@ -296,15 +326,24 @@ AcpiDsLoad1BeginOp (
         if ((WalkState->Opcode != AML_SCOPE_OP) &&
             (!(WalkState->ParseFlags & ACPI_PARSE_DEFERRED_OP)))
         {
-            Flags |= ACPI_NS_ERROR_IF_FOUND;
-            ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[%s] Cannot already exist\n",
+            if (WalkState->NamespaceOverride)
+            {
+                Flags |= ACPI_NS_OVERRIDE_IF_FOUND;
+                ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[%s] Override allowed\n",
                     AcpiUtGetTypeName (ObjectType)));
+            }
+            else
+            {
+                Flags |= ACPI_NS_ERROR_IF_FOUND;
+                ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "[%s] Cannot already exist\n",
+                    AcpiUtGetTypeName (ObjectType)));
+            }
         }
         else
         {
             ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
                 "[%s] Both Find or Create allowed\n",
-                    AcpiUtGetTypeName (ObjectType)));
+                AcpiUtGetTypeName (ObjectType)));
         }
 
         /*
@@ -314,7 +353,7 @@ AcpiDsLoad1BeginOp (
          * parse tree later.
          */
         Status = AcpiNsLookup (WalkState->ScopeInfo, Path, ObjectType,
-                        ACPI_IMODE_LOAD_PASS1, Flags, WalkState, &Node);
+            ACPI_IMODE_LOAD_PASS1, Flags, WalkState, &Node);
         if (ACPI_FAILURE (Status))
         {
             if (Status == AE_ALREADY_EXISTS)
@@ -334,7 +373,8 @@ AcpiDsLoad1BeginOp (
 
                     if (AcpiNsOpensScope (ObjectType))
                     {
-                        Status = AcpiDsScopeStackPush (Node, ObjectType, WalkState);
+                        Status = AcpiDsScopeStackPush (
+                            Node, ObjectType, WalkState);
                         if (ACPI_FAILURE (Status))
                         {
                             return_ACPI_STATUS (Status);
@@ -360,7 +400,7 @@ AcpiDsLoad1BeginOp (
     {
         /* Create a new op */
 
-        Op = AcpiPsAllocOp (WalkState->Opcode);
+        Op = AcpiPsAllocOp (WalkState->Opcode, WalkState->Aml);
         if (!Op)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
@@ -456,8 +496,9 @@ AcpiDsLoad1EndOp (
         if (Op->Common.AmlOpcode == AML_REGION_OP)
         {
             Status = AcpiExCreateRegion (Op->Named.Data, Op->Named.Length,
-                        (ACPI_ADR_SPACE_TYPE) ((Op->Common.Value.Arg)->Common.Value.Integer),
-                        WalkState);
+                (ACPI_ADR_SPACE_TYPE)
+                    ((Op->Common.Value.Arg)->Common.Value.Integer),
+                WalkState);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -466,7 +507,7 @@ AcpiDsLoad1EndOp (
         else if (Op->Common.AmlOpcode == AML_DATA_REGION_OP)
         {
             Status = AcpiExCreateRegion (Op->Named.Data, Op->Named.Length,
-                        ACPI_ADR_SPACE_DATA_TABLE, WalkState);
+                ACPI_ADR_SPACE_DATA_TABLE, WalkState);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -518,11 +559,12 @@ AcpiDsLoad1EndOp (
                 WalkState->Operands[0] = ACPI_CAST_PTR (void, Op->Named.Node);
                 WalkState->NumOperands = 1;
 
-                Status = AcpiDsCreateOperands (WalkState, Op->Common.Value.Arg);
+                Status = AcpiDsCreateOperands (
+                    WalkState, Op->Common.Value.Arg);
                 if (ACPI_SUCCESS (Status))
                 {
                     Status = AcpiExCreateMethod (Op->Named.Data,
-                                        Op->Named.Length, WalkState);
+                        Op->Named.Length, WalkState);
                 }
 
                 WalkState->Operands[0] = NULL;
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswload2.c b/usr/src/uts/intel/io/acpica/dispatcher/dswload2.c
index 27e3176209..2c099ef0f0 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dswload2.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dswload2.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSWLOAD2_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -161,8 +159,8 @@ AcpiDsLoad2BeginOp (
          * for use later.
          */
         Status = AcpiNsLookup (WalkState->ScopeInfo, BufferPtr, ObjectType,
-                        ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
-                        WalkState, &(Node));
+            ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+            WalkState, &(Node));
         break;
 
     case AML_SCOPE_OP:
@@ -187,8 +185,8 @@ AcpiDsLoad2BeginOp (
              * for use later.
              */
             Status = AcpiNsLookup (WalkState->ScopeInfo, BufferPtr, ObjectType,
-                        ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
-                        WalkState, &(Node));
+                ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT,
+                WalkState, &(Node));
             if (ACPI_FAILURE (Status))
             {
 #ifdef ACPI_ASL_COMPILER
@@ -236,13 +234,27 @@ AcpiDsLoad2BeginOp (
              */
             ACPI_WARNING ((AE_INFO,
                 "Type override - [%4.4s] had invalid type (%s) "
-                "for Scope operator, changed to type ANY\n",
+                "for Scope operator, changed to type ANY",
                 AcpiUtGetNodeName (Node), AcpiUtGetTypeName (Node->Type)));
 
             Node->Type = ACPI_TYPE_ANY;
             WalkState->ScopeInfo->Common.Value = ACPI_TYPE_ANY;
             break;
 
+        case ACPI_TYPE_METHOD:
+
+            /*
+             * Allow scope change to root during execution of module-level
+             * code. Root is typed METHOD during this time.
+             */
+            if ((Node == AcpiGbl_RootNode) &&
+                (WalkState->ParseFlags & ACPI_PARSE_MODULE_LEVEL))
+            {
+                break;
+            }
+
+            /*lint -fallthrough */
+
         default:
 
             /* All other types are an error */
@@ -252,7 +264,7 @@ AcpiDsLoad2BeginOp (
                 "Scope operator [%4.4s] (Cannot override)",
                 AcpiUtGetTypeName (Node->Type), AcpiUtGetNodeName (Node)));
 
-            return (AE_AML_OPERAND_TYPE);
+            return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
         }
         break;
 
@@ -311,7 +323,7 @@ AcpiDsLoad2BeginOp (
         /* Add new entry or lookup existing entry */
 
         Status = AcpiNsLookup (WalkState->ScopeInfo, BufferPtr, ObjectType,
-                    ACPI_IMODE_LOAD_PASS2, Flags, WalkState, &Node);
+            ACPI_IMODE_LOAD_PASS2, Flags, WalkState, &Node);
 
         if (ACPI_SUCCESS (Status) && (Flags & ACPI_NS_TEMPORARY))
         {
@@ -332,7 +344,7 @@ AcpiDsLoad2BeginOp (
     {
         /* Create a new op */
 
-        Op = AcpiPsAllocOp (WalkState->Opcode);
+        Op = AcpiPsAllocOp (WalkState->Opcode, WalkState->Aml);
         if (!Op)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
@@ -389,7 +401,7 @@ AcpiDsLoad2EndOp (
 
     Op = WalkState->Op;
     ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, "Opcode [%s] Op %p State %p\n",
-            WalkState->OpInfo->Name, Op, WalkState));
+        WalkState->OpInfo->Name, Op, WalkState));
 
     /* Check if opcode had an associated namespace object */
 
@@ -482,7 +494,6 @@ AcpiDsLoad2EndOp (
         Status = AcpiDsCreateBufferField (Op, WalkState);
         break;
 
-
      case AML_TYPE_NAMED_FIELD:
         /*
          * If we are executing a method, initialize the field
@@ -496,8 +507,8 @@ AcpiDsLoad2EndOp (
         {
         case AML_INDEX_FIELD_OP:
 
-            Status = AcpiDsCreateIndexField (Op, (ACPI_HANDLE) Arg->Common.Node,
-                        WalkState);
+            Status = AcpiDsCreateIndexField (
+                Op, (ACPI_HANDLE) Arg->Common.Node, WalkState);
             break;
 
         case AML_BANK_FIELD_OP:
@@ -511,12 +522,12 @@ AcpiDsLoad2EndOp (
             break;
 
         default:
+
             /* All NAMED_FIELD opcodes must be handled above */
             break;
         }
         break;
 
-
      case AML_TYPE_NAMED_SIMPLE:
 
         Status = AcpiDsCreateOperands (WalkState, Arg);
@@ -547,13 +558,13 @@ AcpiDsLoad2EndOp (
             Status = AcpiExCreateEvent (WalkState);
             break;
 
-
         case AML_ALIAS_OP:
 
             Status = AcpiExCreateAlias (WalkState);
             break;
 
         default:
+
             /* Unknown opcode */
 
             Status = AE_OK;
@@ -582,7 +593,7 @@ AcpiDsLoad2EndOp (
             if (Op->Common.AmlOpcode == AML_REGION_OP)
             {
                 RegionSpace = (ACPI_ADR_SPACE_TYPE)
-                      ((Op->Common.Value.Arg)->Common.Value.Integer);
+                    ((Op->Common.Value.Arg)->Common.Value.Integer);
             }
             else
             {
@@ -607,18 +618,18 @@ AcpiDsLoad2EndOp (
                  * Executing a method: initialize the region and unlock
                  * the interpreter
                  */
-                Status = AcpiExCreateRegion (Op->Named.Data, Op->Named.Length,
-                            RegionSpace, WalkState);
+                Status = AcpiExCreateRegion (Op->Named.Data,
+                    Op->Named.Length, RegionSpace, WalkState);
                 if (ACPI_FAILURE (Status))
                 {
-                    return (Status);
+                    return_ACPI_STATUS (Status);
                 }
 
                 AcpiExExitInterpreter ();
             }
 
-            Status = AcpiEvInitializeRegion (AcpiNsGetAttachedObject (Node),
-                        FALSE);
+            Status = AcpiEvInitializeRegion (
+                AcpiNsGetAttachedObject (Node), FALSE);
             if (WalkState->MethodNode)
             {
                 AcpiExEnterInterpreter ();
@@ -638,13 +649,11 @@ AcpiDsLoad2EndOp (
             }
             break;
 
-
         case AML_NAME_OP:
 
             Status = AcpiDsCreateNode (WalkState, Node, Op);
             break;
 
-
         case AML_METHOD_OP:
             /*
              * MethodOp PkgLength NameString MethodFlags TermList
@@ -663,12 +672,14 @@ AcpiDsLoad2EndOp (
                 WalkState->Operands[0] = ACPI_CAST_PTR (void, Op->Named.Node);
                 WalkState->NumOperands = 1;
 
-                Status = AcpiDsCreateOperands (WalkState, Op->Common.Value.Arg);
+                Status = AcpiDsCreateOperands (
+                    WalkState, Op->Common.Value.Arg);
                 if (ACPI_SUCCESS (Status))
                 {
-                    Status = AcpiExCreateMethod (Op->Named.Data,
-                                        Op->Named.Length, WalkState);
+                    Status = AcpiExCreateMethod (
+                        Op->Named.Data, Op->Named.Length, WalkState);
                 }
+
                 WalkState->Operands[0] = NULL;
                 WalkState->NumOperands = 0;
 
@@ -682,18 +693,17 @@ AcpiDsLoad2EndOp (
 #endif /* ACPI_NO_METHOD_EXECUTION */
 
         default:
+
             /* All NAMED_COMPLEX opcodes must be handled above */
             break;
         }
         break;
 
-
     case AML_CLASS_INTERNAL:
 
         /* case AML_INT_NAMEPATH_OP: */
         break;
 
-
     case AML_CLASS_METHOD_CALL:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
@@ -704,9 +714,9 @@ AcpiDsLoad2EndOp (
          * Lookup the method name and save the Node
          */
         Status = AcpiNsLookup (WalkState->ScopeInfo, Arg->Common.Value.String,
-                        ACPI_TYPE_ANY, ACPI_IMODE_LOAD_PASS2,
-                        ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
-                        WalkState, &(NewNode));
+            ACPI_TYPE_ANY, ACPI_IMODE_LOAD_PASS2,
+            ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,
+            WalkState, &(NewNode));
         if (ACPI_SUCCESS (Status))
         {
             /*
@@ -733,6 +743,7 @@ AcpiDsLoad2EndOp (
 
 
     default:
+
         break;
     }
 
@@ -744,4 +755,3 @@ Cleanup:
     WalkState->NumOperands = 0;
     return_ACPI_STATUS (Status);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswscope.c b/usr/src/uts/intel/io/acpica/dispatcher/dswscope.c
index a59fdc9dca..a2497cfa33 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dswscope.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dswscope.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __DSWSCOPE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdispat.h"
@@ -84,6 +82,7 @@ AcpiDsScopeStackClear (
         ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
             "Popped object type (%s)\n",
             AcpiUtGetTypeName (ScopeInfo->Common.Value)));
+
         AcpiUtDeleteGenericState (ScopeInfo);
     }
 }
@@ -235,5 +234,3 @@ AcpiDsScopeStackPop (
     AcpiUtDeleteGenericState (ScopeInfo);
     return_ACPI_STATUS (AE_OK);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/dispatcher/dswstate.c b/usr/src/uts/intel/io/acpica/dispatcher/dswstate.c
index dd11a18130..f56f393aa7 100644
--- a/usr/src/uts/intel/io/acpica/dispatcher/dswstate.c
+++ b/usr/src/uts/intel/io/acpica/dispatcher/dswstate.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __DSWSTATE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -302,8 +299,8 @@ AcpiDsResultStackPop (
 
     if (WalkState->Results == NULL)
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Result stack underflow - State=%p\n",
-            WalkState));
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "Result stack underflow - State=%p\n", WalkState));
         return (AE_AML_NO_OPERAND);
     }
 
@@ -385,7 +382,7 @@ AcpiDsObjStackPush (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Pop this walk's object stack.  Objects on the stack are NOT
+ * DESCRIPTION: Pop this walk's object stack. Objects on the stack are NOT
  *              deleted by this routine.
  *
  ******************************************************************************/
@@ -549,7 +546,7 @@ AcpiDsPushWalkState (
  * RETURN:      A WalkState object popped from the thread's stack
  *
  * DESCRIPTION: Remove and return the walkstate object that is at the head of
- *              the walk stack for the given walk list.  NULL indicates that
+ *              the walk stack for the given walk list. NULL indicates that
  *              the list is empty.
  *
  ******************************************************************************/
@@ -594,7 +591,7 @@ AcpiDsPopWalkState (
  *
  * RETURN:      Pointer to the new walk state.
  *
- * DESCRIPTION: Allocate and initialize a new walk state.  The current walk
+ * DESCRIPTION: Allocate and initialize a new walk state. The current walk
  *              state is set to this new state.
  *
  ******************************************************************************/
@@ -710,7 +707,8 @@ AcpiDsInitAmlWalk (
 
         /* Push start scope on scope stack and make it current  */
 
-        Status = AcpiDsScopeStackPush (MethodNode, ACPI_TYPE_METHOD, WalkState);
+        Status = AcpiDsScopeStackPush (
+            MethodNode, ACPI_TYPE_METHOD, WalkState);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -730,7 +728,7 @@ AcpiDsInitAmlWalk (
         /*
          * Setup the current scope.
          * Find a Named Op that has a namespace node associated with it.
-         * search upwards from this Op.  Current scope is the first
+         * search upwards from this Op. Current scope is the first
          * Op with a namespace node.
          */
         ExtraOp = ParserState->StartOp;
@@ -753,7 +751,7 @@ AcpiDsInitAmlWalk (
             /* Push start scope on scope stack and make it current  */
 
             Status = AcpiDsScopeStackPush (ParserState->StartNode,
-                            ParserState->StartNode->Type, WalkState);
+                ParserState->StartNode->Type, WalkState);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -790,14 +788,14 @@ AcpiDsDeleteWalkState (
 
     if (!WalkState)
     {
-        return;
+        return_VOID;
     }
 
     if (WalkState->DescriptorType != ACPI_DESC_TYPE_WALK)
     {
         ACPI_ERROR ((AE_INFO, "%p is not a valid walk state",
             WalkState));
-        return;
+        return_VOID;
     }
 
     /* There should not be any open scopes */
@@ -842,5 +840,3 @@ AcpiDsDeleteWalkState (
     ACPI_FREE (WalkState);
     return_VOID;
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/events/evevent.c b/usr/src/uts/intel/io/acpica/events/evevent.c
index b5a7acde72..98b3da506b 100644
--- a/usr/src/uts/intel/io/acpica/events/evevent.c
+++ b/usr/src/uts/intel/io/acpica/events/evevent.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -203,8 +203,8 @@ AcpiEvFixedEventInitialize (
         if (AcpiGbl_FixedEventInfo[i].EnableRegisterId != 0xFF)
         {
             Status = AcpiWriteBitRegister (
-                        AcpiGbl_FixedEventInfo[i].EnableRegisterId,
-                        ACPI_DISABLE_EVENT);
+                AcpiGbl_FixedEventInfo[i].EnableRegisterId,
+                ACPI_DISABLE_EVENT);
             if (ACPI_FAILURE (Status))
             {
                 return (Status);
@@ -291,6 +291,8 @@ AcpiEvFixedEventDetect (
  *
  * DESCRIPTION: Clears the status bit for the requested event, calls the
  *              handler that previously registered for the event.
+ *              NOTE: If there is no handler for the event, the event is
+ *              disabled to prevent further interrupts.
  *
  ******************************************************************************/
 
@@ -305,22 +307,22 @@ AcpiEvFixedEventDispatch (
     /* Clear the status bit */
 
     (void) AcpiWriteBitRegister (
-            AcpiGbl_FixedEventInfo[Event].StatusRegisterId,
-            ACPI_CLEAR_STATUS);
+        AcpiGbl_FixedEventInfo[Event].StatusRegisterId,
+        ACPI_CLEAR_STATUS);
 
     /*
-     * Make sure we've got a handler. If not, report an error. The event is
-     * disabled to prevent further interrupts.
+     * Make sure that a handler exists. If not, report an error
+     * and disable the event to prevent further interrupts.
      */
-    if (NULL == AcpiGbl_FixedEventHandlers[Event].Handler)
+    if (!AcpiGbl_FixedEventHandlers[Event].Handler)
     {
         (void) AcpiWriteBitRegister (
-                AcpiGbl_FixedEventInfo[Event].EnableRegisterId,
-                ACPI_DISABLE_EVENT);
+            AcpiGbl_FixedEventInfo[Event].EnableRegisterId,
+            ACPI_DISABLE_EVENT);
 
         ACPI_ERROR ((AE_INFO,
-            "No installed handler for fixed event [0x%08X]",
-            Event));
+            "No installed handler for fixed event - %s (%u), disabling",
+            AcpiUtGetEventName (Event), Event));
 
         return (ACPI_INTERRUPT_NOT_HANDLED);
     }
@@ -328,9 +330,7 @@ AcpiEvFixedEventDispatch (
     /* Invoke the Fixed Event handler */
 
     return ((AcpiGbl_FixedEventHandlers[Event].Handler)(
-                AcpiGbl_FixedEventHandlers[Event].Context));
+        AcpiGbl_FixedEventHandlers[Event].Context));
 }
 
 #endif /* !ACPI_REDUCED_HARDWARE */
-
-
diff --git a/usr/src/uts/intel/io/acpica/events/evglock.c b/usr/src/uts/intel/io/acpica/events/evglock.c
index f40d129508..caafa977bc 100644
--- a/usr/src/uts/intel/io/acpica/events/evglock.c
+++ b/usr/src/uts/intel/io/acpica/events/evglock.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -90,7 +90,7 @@ AcpiEvInitGlobalLockHandler (
     /* Attempt installation of the global lock handler */
 
     Status = AcpiInstallFixedEventHandler (ACPI_EVENT_GLOBAL,
-                AcpiEvGlobalLockHandler, NULL);
+        AcpiEvGlobalLockHandler, NULL);
 
     /*
      * If the global lock does not exist on this platform, the attempt to
@@ -140,10 +140,12 @@ AcpiEvRemoveGlobalLockHandler (
 
     ACPI_FUNCTION_TRACE (EvRemoveGlobalLockHandler);
 
+
     AcpiGbl_GlobalLockPresent = FALSE;
     Status = AcpiRemoveFixedEventHandler (ACPI_EVENT_GLOBAL,
-                AcpiEvGlobalLockHandler);
+        AcpiEvGlobalLockHandler);
 
+    AcpiOsDeleteLock (AcpiGbl_GlobalLockPendingLock);
     return_ACPI_STATUS (Status);
 }
 
@@ -301,8 +303,8 @@ AcpiEvAcquireGlobalLock (
          * Wait for handshake with the global lock interrupt handler.
          * This interface releases the interpreter if we must wait.
          */
-        Status = AcpiExSystemWaitSemaphore (AcpiGbl_GlobalLockSemaphore,
-                    ACPI_WAIT_FOREVER);
+        Status = AcpiExSystemWaitSemaphore (
+            AcpiGbl_GlobalLockSemaphore, ACPI_WAIT_FOREVER);
 
         Flags = AcpiOsAcquireLock (AcpiGbl_GlobalLockPendingLock);
 
@@ -360,7 +362,7 @@ AcpiEvReleaseGlobalLock (
         if (Pending)
         {
             Status = AcpiWriteBitRegister (
-                        ACPI_BITREG_GLOBAL_LOCK_RELEASE, ACPI_ENABLE_EVENT);
+                ACPI_BITREG_GLOBAL_LOCK_RELEASE, ACPI_ENABLE_EVENT);
         }
 
         ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Released hardware Global Lock\n"));
diff --git a/usr/src/uts/intel/io/acpica/events/evgpe.c b/usr/src/uts/intel/io/acpica/events/evgpe.c
index a3781a55c6..d683bfdfaa 100644
--- a/usr/src/uts/intel/io/acpica/events/evgpe.c
+++ b/usr/src/uts/intel/io/acpica/events/evgpe.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -92,7 +92,7 @@ AcpiEvUpdateGpeEnableMask (
         return_ACPI_STATUS (AE_NOT_EXIST);
     }
 
-    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo, GpeRegisterInfo);
+    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo);
 
     /* Clear the run bit up front */
 
@@ -105,6 +105,7 @@ AcpiEvUpdateGpeEnableMask (
         ACPI_SET_BIT (GpeRegisterInfo->EnableForRun, (UINT8) RegisterBit);
     }
 
+    GpeRegisterInfo->EnableMask = GpeRegisterInfo->EnableForRun;
     return_ACPI_STATUS (AE_OK);
 }
 
@@ -131,18 +132,6 @@ AcpiEvEnableGpe (
     ACPI_FUNCTION_TRACE (EvEnableGpe);
 
 
-    /*
-     * We will only allow a GPE to be enabled if it has either an associated
-     * method (_Lxx/_Exx) or a handler, or is using the implicit notify
-     * feature. Otherwise, the GPE will be immediately disabled by
-     * AcpiEvGpeDispatch the first time it fires.
-     */
-    if ((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) ==
-        ACPI_GPE_DISPATCH_NONE)
-    {
-        return_ACPI_STATUS (AE_NO_HANDLER);
-    }
-
     /* Clear the GPE (of stale events) */
 
     Status = AcpiHwClearGpe (GpeEventInfo);
@@ -338,7 +327,7 @@ AcpiEvGetGpeEventInfo (
         for (i = 0; i < ACPI_MAX_GPE_BLOCKS; i++)
         {
             GpeInfo = AcpiEvLowGetGpeInfo (GpeNumber,
-                        AcpiGbl_GpeFadtBlocks[i]);
+                AcpiGbl_GpeFadtBlocks[i]);
             if (GpeInfo)
             {
                 return (GpeInfo);
@@ -383,7 +372,11 @@ AcpiEvGpeDetect (
 {
     ACPI_STATUS             Status;
     ACPI_GPE_BLOCK_INFO     *GpeBlock;
+    ACPI_NAMESPACE_NODE     *GpeDevice;
     ACPI_GPE_REGISTER_INFO  *GpeRegisterInfo;
+    ACPI_GPE_EVENT_INFO     *GpeEventInfo;
+    UINT32                  GpeNumber;
+    ACPI_GPE_HANDLER_INFO   *GpeHandlerInfo;
     UINT32                  IntStatus = ACPI_INTERRUPT_NOT_HANDLED;
     UINT8                   EnabledStatusByte;
     UINT32                  StatusReg;
@@ -414,6 +407,8 @@ AcpiEvGpeDetect (
     GpeBlock = GpeXruptList->GpeBlockListHead;
     while (GpeBlock)
     {
+        GpeDevice = GpeBlock->Node;
+
         /*
          * Read all of the 8-bit GPE status and enable registers in this GPE
          * block, saving all of them. Find all currently active GP events.
@@ -431,6 +426,13 @@ AcpiEvGpeDetect (
             if (!(GpeRegisterInfo->EnableForRun |
                   GpeRegisterInfo->EnableForWake))
             {
+                ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
+                    "Ignore disabled registers for GPE %02X-%02X: "
+                    "RunEnable=%02X, WakeEnable=%02X\n",
+                    GpeRegisterInfo->BaseGpeNumber,
+                    GpeRegisterInfo->BaseGpeNumber + (ACPI_GPE_REGISTER_WIDTH - 1),
+                    GpeRegisterInfo->EnableForRun,
+                    GpeRegisterInfo->EnableForWake));
                 continue;
             }
 
@@ -451,8 +453,13 @@ AcpiEvGpeDetect (
             }
 
             ACPI_DEBUG_PRINT ((ACPI_DB_INTERRUPTS,
-                "Read GPE Register at GPE%02X: Status=%02X, Enable=%02X\n",
-                GpeRegisterInfo->BaseGpeNumber, StatusReg, EnableReg));
+                "Read registers for GPE %02X-%02X: Status=%02X, Enable=%02X, "
+                "RunEnable=%02X, WakeEnable=%02X\n",
+                GpeRegisterInfo->BaseGpeNumber,
+                GpeRegisterInfo->BaseGpeNumber + (ACPI_GPE_REGISTER_WIDTH - 1),
+                StatusReg, EnableReg,
+                GpeRegisterInfo->EnableForRun,
+                GpeRegisterInfo->EnableForWake));
 
             /* Check if there is anything active at all in this register */
 
@@ -470,16 +477,55 @@ AcpiEvGpeDetect (
             {
                 /* Examine one GPE bit */
 
+                GpeEventInfo = &GpeBlock->EventInfo[((ACPI_SIZE) i *
+                    ACPI_GPE_REGISTER_WIDTH) + j];
+                GpeNumber = j + GpeRegisterInfo->BaseGpeNumber;
+
                 if (EnabledStatusByte & (1 << j))
                 {
-                    /*
-                     * Found an active GPE. Dispatch the event to a handler
-                     * or method.
-                     */
-                    IntStatus |= AcpiEvGpeDispatch (GpeBlock->Node,
-                        &GpeBlock->EventInfo[((ACPI_SIZE) i *
-                            ACPI_GPE_REGISTER_WIDTH) + j],
-                        j + GpeRegisterInfo->BaseGpeNumber);
+                    /* Invoke global event handler if present */
+
+                    AcpiGpeCount++;
+                    if (AcpiGbl_GlobalEventHandler)
+                    {
+                        AcpiGbl_GlobalEventHandler (ACPI_EVENT_TYPE_GPE,
+                            GpeDevice, GpeNumber,
+                            AcpiGbl_GlobalEventHandlerContext);
+                    }
+
+                    /* Found an active GPE */
+
+                    if (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+                        ACPI_GPE_DISPATCH_RAW_HANDLER)
+                    {
+                        /* Dispatch the event to a raw handler */
+
+                        GpeHandlerInfo = GpeEventInfo->Dispatch.Handler;
+
+                        /*
+                         * There is no protection around the namespace node
+                         * and the GPE handler to ensure a safe destruction
+                         * because:
+                         * 1. The namespace node is expected to always
+                         *    exist after loading a table.
+                         * 2. The GPE handler is expected to be flushed by
+                         *    AcpiOsWaitEventsComplete() before the
+                         *    destruction.
+                         */
+                        AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
+                        IntStatus |= GpeHandlerInfo->Address (
+                            GpeDevice, GpeNumber, GpeHandlerInfo->Context);
+                        Flags = AcpiOsAcquireLock (AcpiGbl_GpeLock);
+                    }
+                    else
+                    {
+                        /*
+                         * Dispatch the event to a standard handler or
+                         * method.
+                         */
+                        IntStatus |= AcpiEvGpeDispatch (GpeDevice,
+                            GpeEventInfo, GpeNumber);
+                    }
                 }
             }
         }
@@ -515,57 +561,19 @@ AcpiEvAsynchExecuteGpeMethod (
     void                    *Context)
 {
     ACPI_GPE_EVENT_INFO     *GpeEventInfo = Context;
-    ACPI_STATUS             Status;
-    ACPI_GPE_EVENT_INFO     *LocalGpeEventInfo;
+    ACPI_STATUS             Status = AE_OK;
     ACPI_EVALUATE_INFO      *Info;
+    ACPI_GPE_NOTIFY_INFO    *Notify;
 
 
     ACPI_FUNCTION_TRACE (EvAsynchExecuteGpeMethod);
 
 
-    /* Allocate a local GPE block */
-
-    LocalGpeEventInfo = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_GPE_EVENT_INFO));
-    if (!LocalGpeEventInfo)
-    {
-        ACPI_EXCEPTION ((AE_INFO, AE_NO_MEMORY,
-            "while handling a GPE"));
-        return_VOID;
-    }
-
-    Status = AcpiUtAcquireMutex (ACPI_MTX_EVENTS);
-    if (ACPI_FAILURE (Status))
-    {
-        return_VOID;
-    }
-
-    /* Must revalidate the GpeNumber/GpeBlock */
-
-    if (!AcpiEvValidGpeEvent (GpeEventInfo))
-    {
-        Status = AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
-        return_VOID;
-    }
-
-    /*
-     * Take a snapshot of the GPE info for this level - we copy the info to
-     * prevent a race condition with RemoveHandler/RemoveBlock.
-     */
-    ACPI_MEMCPY (LocalGpeEventInfo, GpeEventInfo,
-        sizeof (ACPI_GPE_EVENT_INFO));
-
-    Status = AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
-    if (ACPI_FAILURE (Status))
-    {
-        return_VOID;
-    }
-
     /* Do the correct dispatch - normal method or implicit notify */
 
-    switch (LocalGpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK)
+    switch (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags))
     {
     case ACPI_GPE_DISPATCH_NOTIFY:
-
         /*
          * Implicit notify.
          * Dispatch a DEVICE_WAKE notify to the appropriate handler.
@@ -573,10 +581,18 @@ AcpiEvAsynchExecuteGpeMethod (
          * completes. The notify handlers are NOT invoked synchronously
          * from this thread -- because handlers may in turn run other
          * control methods.
+         *
+         * June 2012: Expand implicit notify mechanism to support
+         * notifies on multiple device objects.
          */
-        Status = AcpiEvQueueNotifyRequest (
-                    LocalGpeEventInfo->Dispatch.DeviceNode,
-                    ACPI_NOTIFY_DEVICE_WAKE);
+        Notify = GpeEventInfo->Dispatch.NotifyList;
+        while (ACPI_SUCCESS (Status) && Notify)
+        {
+            Status = AcpiEvQueueNotifyRequest (
+                Notify->DeviceNode, ACPI_NOTIFY_DEVICE_WAKE);
+
+            Notify = Notify->Next;
+        }
         break;
 
     case ACPI_GPE_DISPATCH_METHOD:
@@ -594,7 +610,7 @@ AcpiEvAsynchExecuteGpeMethod (
              * Invoke the GPE Method (_Lxx, _Exx) i.e., evaluate the
              * _Lxx/_Exx control method that corresponds to this GPE
              */
-            Info->PrefixNode = LocalGpeEventInfo->Dispatch.MethodNode;
+            Info->PrefixNode = GpeEventInfo->Dispatch.MethodNode;
             Info->Flags = ACPI_IGNORE_RETURN_VALUE;
 
             Status = AcpiNsEvaluate (Info);
@@ -605,23 +621,26 @@ AcpiEvAsynchExecuteGpeMethod (
         {
             ACPI_EXCEPTION ((AE_INFO, Status,
                 "while evaluating GPE method [%4.4s]",
-                AcpiUtGetNodeName (LocalGpeEventInfo->Dispatch.MethodNode)));
+                AcpiUtGetNodeName (GpeEventInfo->Dispatch.MethodNode)));
         }
-
         break;
 
     default:
-        return_VOID; /* Should never happen */
+
+        goto ErrorExit; /* Should never happen */
     }
 
     /* Defer enabling of GPE until all notify handlers are done */
 
     Status = AcpiOsExecute (OSL_NOTIFY_HANDLER,
-                AcpiEvAsynchEnableGpe, LocalGpeEventInfo);
-    if (ACPI_FAILURE (Status))
+        AcpiEvAsynchEnableGpe, GpeEventInfo);
+    if (ACPI_SUCCESS (Status))
     {
-        ACPI_FREE (LocalGpeEventInfo);
+        return_VOID;
     }
+
+ErrorExit:
+    AcpiEvAsynchEnableGpe (GpeEventInfo);
     return_VOID;
 }
 
@@ -645,11 +664,13 @@ AcpiEvAsynchEnableGpe (
     void                    *Context)
 {
     ACPI_GPE_EVENT_INFO     *GpeEventInfo = Context;
+    ACPI_CPU_FLAGS          Flags;
 
 
+    Flags = AcpiOsAcquireLock (AcpiGbl_GpeLock);
     (void) AcpiEvFinishGpe (GpeEventInfo);
+    AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
 
-    ACPI_FREE (GpeEventInfo);
     return;
 }
 
@@ -690,7 +711,7 @@ AcpiEvFinishGpe (
 
     /*
      * Enable this GPE, conditionally. This means that the GPE will
-     * only be physically enabled if the EnableForRun bit is set
+     * only be physically enabled if the EnableMask bit is set
      * in the EventInfo.
      */
     (void) AcpiHwLowSetGpe (GpeEventInfo, ACPI_GPE_CONDITIONAL_ENABLE);
@@ -728,13 +749,21 @@ AcpiEvGpeDispatch (
     ACPI_FUNCTION_TRACE (EvGpeDispatch);
 
 
-    /* Invoke global event handler if present */
-
-    AcpiGpeCount++;
-    if (AcpiGbl_GlobalEventHandler)
+    /*
+     * Always disable the GPE so that it does not keep firing before
+     * any asynchronous activity completes (either from the execution
+     * of a GPE method or an asynchronous GPE handler.)
+     *
+     * If there is no handler or method to run, just disable the
+     * GPE and leave it disabled permanently to prevent further such
+     * pointless events from firing.
+     */
+    Status = AcpiHwLowSetGpe (GpeEventInfo, ACPI_GPE_DISABLE);
+    if (ACPI_FAILURE (Status))
     {
-        AcpiGbl_GlobalEventHandler (ACPI_EVENT_TYPE_GPE, GpeDevice,
-             GpeNumber, AcpiGbl_GlobalEventHandlerContext);
+        ACPI_EXCEPTION ((AE_INFO, Status,
+            "Unable to disable GPE %02X", GpeNumber));
+        return_UINT32 (ACPI_INTERRUPT_NOT_HANDLED);
     }
 
     /*
@@ -748,28 +777,13 @@ AcpiEvGpeDispatch (
         if (ACPI_FAILURE (Status))
         {
             ACPI_EXCEPTION ((AE_INFO, Status,
-                "Unable to clear GPE%02X", GpeNumber));
+                "Unable to clear GPE %02X", GpeNumber));
+            (void) AcpiHwLowSetGpe (
+                GpeEventInfo, ACPI_GPE_CONDITIONAL_ENABLE);
             return_UINT32 (ACPI_INTERRUPT_NOT_HANDLED);
         }
     }
 
-    /*
-     * Always disable the GPE so that it does not keep firing before
-     * any asynchronous activity completes (either from the execution
-     * of a GPE method or an asynchronous GPE handler.)
-     *
-     * If there is no handler or method to run, just disable the
-     * GPE and leave it disabled permanently to prevent further such
-     * pointless events from firing.
-     */
-    Status = AcpiHwLowSetGpe (GpeEventInfo, ACPI_GPE_DISABLE);
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_EXCEPTION ((AE_INFO, Status,
-            "Unable to disable GPE%02X", GpeNumber));
-        return_UINT32 (ACPI_INTERRUPT_NOT_HANDLED);
-    }
-
     /*
      * Dispatch the GPE to either an installed handler or the control
      * method associated with this GPE (_Lxx or _Exx). If a handler
@@ -777,7 +791,7 @@ AcpiEvGpeDispatch (
      * If there is neither a handler nor a method, leave the GPE
      * disabled.
      */
-    switch (GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK)
+    switch (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags))
     {
     case ACPI_GPE_DISPATCH_HANDLER:
 
@@ -797,30 +811,28 @@ AcpiEvGpeDispatch (
 
     case ACPI_GPE_DISPATCH_METHOD:
     case ACPI_GPE_DISPATCH_NOTIFY:
-
         /*
          * Execute the method associated with the GPE
          * NOTE: Level-triggered GPEs are cleared after the method completes.
          */
         Status = AcpiOsExecute (OSL_GPE_HANDLER,
-                    AcpiEvAsynchExecuteGpeMethod, GpeEventInfo);
+            AcpiEvAsynchExecuteGpeMethod, GpeEventInfo);
         if (ACPI_FAILURE (Status))
         {
             ACPI_EXCEPTION ((AE_INFO, Status,
-                "Unable to queue handler for GPE%02X - event disabled",
+                "Unable to queue handler for GPE %02X - event disabled",
                 GpeNumber));
         }
         break;
 
     default:
-
         /*
          * No handler or method to run!
          * 03/2010: This case should no longer be possible. We will not allow
          * a GPE to be enabled if it has no handler or method.
          */
         ACPI_ERROR ((AE_INFO,
-            "No handler or method for GPE%02X, disabling event",
+            "No handler or method for GPE %02X, disabling event",
             GpeNumber));
         break;
     }
diff --git a/usr/src/uts/intel/io/acpica/events/evgpeblk.c b/usr/src/uts/intel/io/acpica/events/evgpeblk.c
index c281855c2c..2e1d354d15 100644
--- a/usr/src/uts/intel/io/acpica/events/evgpeblk.c
+++ b/usr/src/uts/intel/io/acpica/events/evgpeblk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -97,10 +97,9 @@ AcpiEvInstallGpeBlock (
         return_ACPI_STATUS (Status);
     }
 
-    GpeXruptBlock = AcpiEvGetGpeXruptBlock (InterruptNumber);
-    if (!GpeXruptBlock)
+    Status = AcpiEvGetGpeXruptBlock (InterruptNumber, &GpeXruptBlock);
+    if (ACPI_FAILURE (Status))
     {
-        Status = AE_NO_MEMORY;
         goto UnlockAndExit;
     }
 
@@ -128,7 +127,7 @@ AcpiEvInstallGpeBlock (
 
 
 UnlockAndExit:
-    Status = AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
+    (void) AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
     return_ACPI_STATUS (Status);
 }
 
@@ -194,6 +193,7 @@ AcpiEvDeleteGpeBlock (
         {
             GpeBlock->Next->Previous = GpeBlock->Previous;
         }
+
         AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
     }
 
@@ -242,8 +242,8 @@ AcpiEvCreateGpeInfoBlocks (
     /* Allocate the GPE register information block */
 
     GpeRegisterInfo = ACPI_ALLOCATE_ZEROED (
-                        (ACPI_SIZE) GpeBlock->RegisterCount *
-                        sizeof (ACPI_GPE_REGISTER_INFO));
+        (ACPI_SIZE) GpeBlock->RegisterCount *
+        sizeof (ACPI_GPE_REGISTER_INFO));
     if (!GpeRegisterInfo)
     {
         ACPI_ERROR ((AE_INFO,
@@ -256,7 +256,7 @@ AcpiEvCreateGpeInfoBlocks (
      * per register. Initialization to zeros is sufficient.
      */
     GpeEventInfo = ACPI_ALLOCATE_ZEROED ((ACPI_SIZE) GpeBlock->GpeCount *
-                    sizeof (ACPI_GPE_EVENT_INFO));
+        sizeof (ACPI_GPE_EVENT_INFO));
     if (!GpeEventInfo)
     {
         ACPI_ERROR ((AE_INFO,
@@ -268,7 +268,7 @@ AcpiEvCreateGpeInfoBlocks (
     /* Save the new Info arrays in the GPE block */
 
     GpeBlock->RegisterInfo = GpeRegisterInfo;
-    GpeBlock->EventInfo    = GpeEventInfo;
+    GpeBlock->EventInfo = GpeEventInfo;
 
     /*
      * Initialize the GPE Register and Event structures. A goal of these
@@ -277,23 +277,23 @@ AcpiEvCreateGpeInfoBlocks (
      * first half, and the enable registers occupy the second half.
      */
     ThisRegister = GpeRegisterInfo;
-    ThisEvent    = GpeEventInfo;
+    ThisEvent = GpeEventInfo;
 
     for (i = 0; i < GpeBlock->RegisterCount; i++)
     {
         /* Init the RegisterInfo for this GPE register (8 GPEs) */
 
-        ThisRegister->BaseGpeNumber = (UINT8) (GpeBlock->BlockBaseNumber +
-                                             (i * ACPI_GPE_REGISTER_WIDTH));
+        ThisRegister->BaseGpeNumber = (UINT16)
+            (GpeBlock->BlockBaseNumber + (i * ACPI_GPE_REGISTER_WIDTH));
 
         ThisRegister->StatusAddress.Address =
-            GpeBlock->BlockAddress.Address + i;
+            GpeBlock->Address + i;
 
         ThisRegister->EnableAddress.Address =
-            GpeBlock->BlockAddress.Address + i + GpeBlock->RegisterCount;
+            GpeBlock->Address + i + GpeBlock->RegisterCount;
 
-        ThisRegister->StatusAddress.SpaceId   = GpeBlock->BlockAddress.SpaceId;
-        ThisRegister->EnableAddress.SpaceId   = GpeBlock->BlockAddress.SpaceId;
+        ThisRegister->StatusAddress.SpaceId   = GpeBlock->SpaceId;
+        ThisRegister->EnableAddress.SpaceId   = GpeBlock->SpaceId;
         ThisRegister->StatusAddress.BitWidth  = ACPI_GPE_REGISTER_WIDTH;
         ThisRegister->EnableAddress.BitWidth  = ACPI_GPE_REGISTER_WIDTH;
         ThisRegister->StatusAddress.BitOffset = 0;
@@ -366,9 +366,10 @@ ErrorExit:
 ACPI_STATUS
 AcpiEvCreateGpeBlock (
     ACPI_NAMESPACE_NODE     *GpeDevice,
-    ACPI_GENERIC_ADDRESS    *GpeBlockAddress,
+    UINT64                  Address,
+    UINT8                   SpaceId,
     UINT32                  RegisterCount,
-    UINT8                   GpeBlockBaseNumber,
+    UINT16                  GpeBlockBaseNumber,
     UINT32                  InterruptNumber,
     ACPI_GPE_BLOCK_INFO     **ReturnGpeBlock)
 {
@@ -395,15 +396,14 @@ AcpiEvCreateGpeBlock (
 
     /* Initialize the new GPE block */
 
+    GpeBlock->Address = Address;
+    GpeBlock->SpaceId = SpaceId;
     GpeBlock->Node = GpeDevice;
     GpeBlock->GpeCount = (UINT16) (RegisterCount * ACPI_GPE_REGISTER_WIDTH);
     GpeBlock->Initialized = FALSE;
     GpeBlock->RegisterCount = RegisterCount;
     GpeBlock->BlockBaseNumber = GpeBlockBaseNumber;
 
-    ACPI_MEMCPY (&GpeBlock->BlockAddress, GpeBlockAddress,
-        sizeof (ACPI_GENERIC_ADDRESS));
-
     /*
      * Create the RegisterInfo and EventInfo sub-structures
      * Note: disables and clears all GPEs in the block
@@ -420,6 +420,8 @@ AcpiEvCreateGpeBlock (
     Status = AcpiEvInstallGpeBlock (GpeBlock, InterruptNumber);
     if (ACPI_FAILURE (Status))
     {
+        ACPI_FREE (GpeBlock->RegisterInfo);
+        ACPI_FREE (GpeBlock->EventInfo);
         ACPI_FREE (GpeBlock);
         return_ACPI_STATUS (Status);
     }
@@ -433,8 +435,8 @@ AcpiEvCreateGpeBlock (
     WalkInfo.ExecuteByOwnerId = FALSE;
 
     Status = AcpiNsWalkNamespace (ACPI_TYPE_METHOD, GpeDevice,
-                ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
-                AcpiEvMatchGpeMethod, NULL, &WalkInfo, NULL);
+        ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
+        AcpiEvMatchGpeMethod, NULL, &WalkInfo, NULL);
 
     /* Return the new block */
 
@@ -443,12 +445,12 @@ AcpiEvCreateGpeBlock (
         (*ReturnGpeBlock) = GpeBlock;
     }
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
-        "GPE %02X to %02X [%4.4s] %u regs on int 0x%X\n",
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+        "    Initialized GPE %02X to %02X [%4.4s] %u regs on interrupt 0x%X%s\n",
         (UINT32) GpeBlock->BlockBaseNumber,
         (UINT32) (GpeBlock->BlockBaseNumber + (GpeBlock->GpeCount - 1)),
-        GpeDevice->Name.Ascii, GpeBlock->RegisterCount,
-        InterruptNumber));
+        GpeDevice->Name.Ascii, GpeBlock->RegisterCount, InterruptNumber,
+        InterruptNumber == AcpiGbl_FADT.SciInterrupt ? " (SCI)" : ""));
 
     /* Update global count of currently available GPEs */
 
@@ -517,8 +519,9 @@ AcpiEvInitializeGpeBlock (
              * Ignore GPEs that have no corresponding _Lxx/_Exx method
              * and GPEs that are used to wake the system
              */
-            if (((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) == ACPI_GPE_DISPATCH_NONE) ||
-                ((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) == ACPI_GPE_DISPATCH_HANDLER) ||
+            if ((ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) == ACPI_GPE_DISPATCH_NONE) ||
+                (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) == ACPI_GPE_DISPATCH_HANDLER) ||
+                (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) == ACPI_GPE_DISPATCH_RAW_HANDLER) ||
                 (GpeEventInfo->Flags & ACPI_GPE_CAN_WAKE))
             {
                 continue;
@@ -539,8 +542,10 @@ AcpiEvInitializeGpeBlock (
 
     if (GpeEnabledCount)
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
-            "Enabled %u GPEs in this block\n", GpeEnabledCount));
+        ACPI_INFO ((
+            "Enabled %u GPEs in block %02X to %02X", GpeEnabledCount,
+            (UINT32) GpeBlock->BlockBaseNumber,
+            (UINT32) (GpeBlock->BlockBaseNumber + (GpeBlock->GpeCount - 1))));
     }
 
     GpeBlock->Initialized = TRUE;
diff --git a/usr/src/uts/intel/io/acpica/events/evgpeinit.c b/usr/src/uts/intel/io/acpica/events/evgpeinit.c
index f8962e947f..8e2fd34023 100644
--- a/usr/src/uts/intel/io/acpica/events/evgpeinit.c
+++ b/usr/src/uts/intel/io/acpica/events/evgpeinit.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acevents.h"
@@ -94,6 +93,9 @@ AcpiEvGpeInitialize (
     ACPI_FUNCTION_TRACE (EvGpeInitialize);
 
 
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+        "Initializing General Purpose Events (GPEs):\n"));
+
     Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
     if (ACPI_FAILURE (Status))
     {
@@ -131,14 +133,15 @@ AcpiEvGpeInitialize (
         /* GPE block 0 exists (has both length and address > 0) */
 
         RegisterCount0 = (UINT16) (AcpiGbl_FADT.Gpe0BlockLength / 2);
-
         GpeNumberMax = (RegisterCount0 * ACPI_GPE_REGISTER_WIDTH) - 1;
 
         /* Install GPE Block 0 */
 
         Status = AcpiEvCreateGpeBlock (AcpiGbl_FadtGpeDevice,
-                    &AcpiGbl_FADT.XGpe0Block, RegisterCount0, 0,
-                    AcpiGbl_FADT.SciInterrupt, &AcpiGbl_GpeFadtBlocks[0]);
+            AcpiGbl_FADT.XGpe0Block.Address,
+            AcpiGbl_FADT.XGpe0Block.SpaceId,
+            RegisterCount0, 0,
+            AcpiGbl_FADT.SciInterrupt, &AcpiGbl_GpeFadtBlocks[0]);
 
         if (ACPI_FAILURE (Status))
         {
@@ -175,9 +178,11 @@ AcpiEvGpeInitialize (
             /* Install GPE Block 1 */
 
             Status = AcpiEvCreateGpeBlock (AcpiGbl_FadtGpeDevice,
-                        &AcpiGbl_FADT.XGpe1Block, RegisterCount1,
-                        AcpiGbl_FADT.Gpe1Base,
-                        AcpiGbl_FADT.SciInterrupt, &AcpiGbl_GpeFadtBlocks[1]);
+                AcpiGbl_FADT.XGpe1Block.Address,
+                AcpiGbl_FADT.XGpe1Block.SpaceId,
+                RegisterCount1,
+                AcpiGbl_FADT.Gpe1Base,
+                AcpiGbl_FADT.SciInterrupt, &AcpiGbl_GpeFadtBlocks[1]);
 
             if (ACPI_FAILURE (Status))
             {
@@ -190,7 +195,7 @@ AcpiEvGpeInitialize (
              * space. However, GPE0 always starts at GPE number zero.
              */
             GpeNumberMax = AcpiGbl_FADT.Gpe1Base +
-                            ((RegisterCount1 * ACPI_GPE_REGISTER_WIDTH) - 1);
+                ((RegisterCount1 * ACPI_GPE_REGISTER_WIDTH) - 1);
         }
     }
 
@@ -206,16 +211,6 @@ AcpiEvGpeInitialize (
         goto Cleanup;
     }
 
-    /* Check for Max GPE number out-of-range */
-
-    if (GpeNumberMax > ACPI_GPE_MAX)
-    {
-        ACPI_ERROR ((AE_INFO,
-            "Maximum GPE number from FADT is too large: 0x%X",
-            GpeNumberMax));
-        Status = AE_BAD_VALUE;
-        goto Cleanup;
-    }
 
 Cleanup:
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
@@ -280,9 +275,9 @@ AcpiEvUpdateGpes (
             WalkInfo.GpeDevice = GpeBlock->Node;
 
             Status = AcpiNsWalkNamespace (ACPI_TYPE_METHOD,
-                        WalkInfo.GpeDevice, ACPI_UINT32_MAX,
-                        ACPI_NS_WALK_NO_UNLOCK, AcpiEvMatchGpeMethod,
-                        NULL, &WalkInfo, NULL);
+                WalkInfo.GpeDevice, ACPI_UINT32_MAX,
+                ACPI_NS_WALK_NO_UNLOCK, AcpiEvMatchGpeMethod,
+                NULL, &WalkInfo, NULL);
             if (ACPI_FAILURE (Status))
             {
                 ACPI_EXCEPTION ((AE_INFO, Status,
@@ -297,7 +292,7 @@ AcpiEvUpdateGpes (
 
     if (WalkInfo.Count)
     {
-        ACPI_INFO ((AE_INFO, "Enabled %u new GPEs", WalkInfo.Count));
+        ACPI_INFO (("Enabled %u new GPEs", WalkInfo.Count));
     }
 
     (void) AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
@@ -379,14 +374,17 @@ AcpiEvMatchGpeMethod (
     switch (Name[1])
     {
     case 'L':
+
         Type = ACPI_GPE_LEVEL_TRIGGERED;
         break;
 
     case 'E':
+
         Type = ACPI_GPE_EDGE_TRIGGERED;
         break;
 
     default:
+
         /* Unknown method type, just ignore it */
 
         ACPI_DEBUG_PRINT ((ACPI_DB_LOAD,
@@ -397,7 +395,7 @@ AcpiEvMatchGpeMethod (
 
     /* 4) The last two characters of the name are the hex GPE Number */
 
-    GpeNumber = ACPI_STRTOUL (&Name[2], NULL, 16);
+    GpeNumber = strtoul (&Name[2], NULL, 16);
     if (GpeNumber == ACPI_UINT32_MAX)
     {
         /* Conversion failed; invalid method, just ignore it */
@@ -421,16 +419,18 @@ AcpiEvMatchGpeMethod (
         return_ACPI_STATUS (AE_OK);
     }
 
-    if ((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) ==
-            ACPI_GPE_DISPATCH_HANDLER)
+    if ((ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+            ACPI_GPE_DISPATCH_HANDLER) ||
+        (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+            ACPI_GPE_DISPATCH_RAW_HANDLER))
     {
         /* If there is already a handler, ignore this GPE method */
 
         return_ACPI_STATUS (AE_OK);
     }
 
-    if ((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) ==
-            ACPI_GPE_DISPATCH_METHOD)
+    if (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+        ACPI_GPE_DISPATCH_METHOD)
     {
         /*
          * If there is already a method, ignore this method. But check
@@ -445,6 +445,10 @@ AcpiEvMatchGpeMethod (
         return_ACPI_STATUS (AE_OK);
     }
 
+    /* Disable the GPE in case it's been enabled already. */
+
+    (void) AcpiHwLowSetGpe (GpeEventInfo, ACPI_GPE_DISABLE);
+
     /*
      * Add the GPE information from above to the GpeEventInfo block for
      * use during dispatch of this GPE.
diff --git a/usr/src/uts/intel/io/acpica/events/evgpeutil.c b/usr/src/uts/intel/io/acpica/events/evgpeutil.c
index 70580cd853..ff4b1cddc6 100644
--- a/usr/src/uts/intel/io/acpica/events/evgpeutil.c
+++ b/usr/src/uts/intel/io/acpica/events/evgpeutil.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -113,60 +113,6 @@ UnlockAndExit:
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiEvValidGpeEvent
- *
- * PARAMETERS:  GpeEventInfo                - Info for this GPE
- *
- * RETURN:      TRUE if the GpeEvent is valid
- *
- * DESCRIPTION: Validate a GPE event. DO NOT CALL FROM INTERRUPT LEVEL.
- *              Should be called only when the GPE lists are semaphore locked
- *              and not subject to change.
- *
- ******************************************************************************/
-
-BOOLEAN
-AcpiEvValidGpeEvent (
-    ACPI_GPE_EVENT_INFO     *GpeEventInfo)
-{
-    ACPI_GPE_XRUPT_INFO     *GpeXruptBlock;
-    ACPI_GPE_BLOCK_INFO     *GpeBlock;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    /* No need for spin lock since we are not changing any list elements */
-
-    /* Walk the GPE interrupt levels */
-
-    GpeXruptBlock = AcpiGbl_GpeXruptListHead;
-    while (GpeXruptBlock)
-    {
-        GpeBlock = GpeXruptBlock->GpeBlockListHead;
-
-        /* Walk the GPE blocks on this interrupt level */
-
-        while (GpeBlock)
-        {
-            if ((&GpeBlock->EventInfo[0] <= GpeEventInfo) &&
-                (&GpeBlock->EventInfo[GpeBlock->GpeCount] > GpeEventInfo))
-            {
-                return (TRUE);
-            }
-
-            GpeBlock = GpeBlock->Next;
-        }
-
-        GpeXruptBlock = GpeXruptBlock->Next;
-    }
-
-    return (FALSE);
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiEvGetGpeDevice
@@ -216,9 +162,10 @@ AcpiEvGetGpeDevice (
  *
  * FUNCTION:    AcpiEvGetGpeXruptBlock
  *
- * PARAMETERS:  InterruptNumber      - Interrupt for a GPE block
+ * PARAMETERS:  InterruptNumber             - Interrupt for a GPE block
+ *              GpeXruptBlock               - Where the block is returned
  *
- * RETURN:      A GPE interrupt block
+ * RETURN:      Status
  *
  * DESCRIPTION: Get or Create a GPE interrupt block. There is one interrupt
  *              block per unique interrupt level used for GPEs. Should be
@@ -227,9 +174,10 @@ AcpiEvGetGpeDevice (
  *
  ******************************************************************************/
 
-ACPI_GPE_XRUPT_INFO *
+ACPI_STATUS
 AcpiEvGetGpeXruptBlock (
-    UINT32                  InterruptNumber)
+    UINT32                  InterruptNumber,
+    ACPI_GPE_XRUPT_INFO     **GpeXruptBlock)
 {
     ACPI_GPE_XRUPT_INFO     *NextGpeXrupt;
     ACPI_GPE_XRUPT_INFO     *GpeXrupt;
@@ -247,7 +195,8 @@ AcpiEvGetGpeXruptBlock (
     {
         if (NextGpeXrupt->InterruptNumber == InterruptNumber)
         {
-            return_PTR (NextGpeXrupt);
+            *GpeXruptBlock = NextGpeXrupt;
+            return_ACPI_STATUS (AE_OK);
         }
 
         NextGpeXrupt = NextGpeXrupt->Next;
@@ -258,7 +207,7 @@ AcpiEvGetGpeXruptBlock (
     GpeXrupt = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_GPE_XRUPT_INFO));
     if (!GpeXrupt)
     {
-        return_PTR (NULL);
+        return_ACPI_STATUS (AE_NO_MEMORY);
     }
 
     GpeXrupt->InterruptNumber = InterruptNumber;
@@ -281,6 +230,7 @@ AcpiEvGetGpeXruptBlock (
     {
         AcpiGbl_GpeXruptListHead = GpeXrupt;
     }
+
     AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
 
     /* Install new interrupt handler if not SCI_INT */
@@ -288,17 +238,18 @@ AcpiEvGetGpeXruptBlock (
     if (InterruptNumber != AcpiGbl_FADT.SciInterrupt)
     {
         Status = AcpiOsInstallInterruptHandler (InterruptNumber,
-                    AcpiEvGpeXruptHandler, GpeXrupt);
+            AcpiEvGpeXruptHandler, GpeXrupt);
         if (ACPI_FAILURE (Status))
         {
-            ACPI_ERROR ((AE_INFO,
+            ACPI_EXCEPTION ((AE_INFO, Status,
                 "Could not install GPE interrupt handler at level 0x%X",
                 InterruptNumber));
-            return_PTR (NULL);
+            return_ACPI_STATUS (Status);
         }
     }
 
-    return_PTR (GpeXrupt);
+    *GpeXruptBlock = GpeXrupt;
+    return_ACPI_STATUS (AE_OK);
 }
 
 
@@ -337,7 +288,7 @@ AcpiEvDeleteGpeXrupt (
     /* Disable this interrupt */
 
     Status = AcpiOsRemoveInterruptHandler (
-                GpeXrupt->InterruptNumber, AcpiEvGpeXruptHandler);
+        GpeXrupt->InterruptNumber, AcpiEvGpeXruptHandler);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -391,6 +342,8 @@ AcpiEvDeleteGpeHandlers (
     void                    *Context)
 {
     ACPI_GPE_EVENT_INFO     *GpeEventInfo;
+    ACPI_GPE_NOTIFY_INFO    *Notify;
+    ACPI_GPE_NOTIFY_INFO    *Next;
     UINT32                  i;
     UINT32                  j;
 
@@ -409,13 +362,33 @@ AcpiEvDeleteGpeHandlers (
             GpeEventInfo = &GpeBlock->EventInfo[((ACPI_SIZE) i *
                 ACPI_GPE_REGISTER_WIDTH) + j];
 
-            if ((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) ==
-                    ACPI_GPE_DISPATCH_HANDLER)
+            if ((ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+                    ACPI_GPE_DISPATCH_HANDLER) ||
+                (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+                    ACPI_GPE_DISPATCH_RAW_HANDLER))
             {
+                /* Delete an installed handler block */
+
                 ACPI_FREE (GpeEventInfo->Dispatch.Handler);
                 GpeEventInfo->Dispatch.Handler = NULL;
                 GpeEventInfo->Flags &= ~ACPI_GPE_DISPATCH_MASK;
             }
+            else if (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+                ACPI_GPE_DISPATCH_NOTIFY)
+            {
+                /* Delete the implicit notification device list */
+
+                Notify = GpeEventInfo->Dispatch.NotifyList;
+                while (Notify)
+                {
+                    Next = Notify->Next;
+                    ACPI_FREE (Notify);
+                    Notify = Next;
+                }
+
+                GpeEventInfo->Dispatch.NotifyList = NULL;
+                GpeEventInfo->Flags &= ~ACPI_GPE_DISPATCH_MASK;
+            }
         }
     }
 
diff --git a/usr/src/uts/intel/io/acpica/events/evhandler.c b/usr/src/uts/intel/io/acpica/events/evhandler.c
new file mode 100644
index 0000000000..d63cad8d2d
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/events/evhandler.c
@@ -0,0 +1,606 @@
+/******************************************************************************
+ *
+ * Module Name: evhandler - Support for Address Space handlers
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+#include "acinterp.h"
+
+#define _COMPONENT          ACPI_EVENTS
+        ACPI_MODULE_NAME    ("evhandler")
+
+
+/* Local prototypes */
+
+static ACPI_STATUS
+AcpiEvInstallHandler (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue);
+
+
+/* These are the address spaces that will get default handlers */
+
+UINT8        AcpiGbl_DefaultAddressSpaces[ACPI_NUM_DEFAULT_SPACES] =
+{
+    ACPI_ADR_SPACE_SYSTEM_MEMORY,
+    ACPI_ADR_SPACE_SYSTEM_IO,
+    ACPI_ADR_SPACE_PCI_CONFIG,
+    ACPI_ADR_SPACE_DATA_TABLE
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiEvInstallRegionHandlers
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Installs the core subsystem default address space handlers.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiEvInstallRegionHandlers (
+    void)
+{
+    ACPI_STATUS             Status;
+    UINT32                  i;
+
+
+    ACPI_FUNCTION_TRACE (EvInstallRegionHandlers);
+
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /*
+     * All address spaces (PCI Config, EC, SMBus) are scope dependent and
+     * registration must occur for a specific device.
+     *
+     * In the case of the system memory and IO address spaces there is
+     * currently no device associated with the address space. For these we
+     * use the root.
+     *
+     * We install the default PCI config space handler at the root so that
+     * this space is immediately available even though the we have not
+     * enumerated all the PCI Root Buses yet. This is to conform to the ACPI
+     * specification which states that the PCI config space must be always
+     * available -- even though we are nowhere near ready to find the PCI root
+     * buses at this point.
+     *
+     * NOTE: We ignore AE_ALREADY_EXISTS because this means that a handler
+     * has already been installed (via AcpiInstallAddressSpaceHandler).
+     * Similar for AE_SAME_HANDLER.
+     */
+    for (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++)
+    {
+        Status = AcpiEvInstallSpaceHandler (AcpiGbl_RootNode,
+            AcpiGbl_DefaultAddressSpaces[i],
+            ACPI_DEFAULT_HANDLER, NULL, NULL);
+        switch (Status)
+        {
+        case AE_OK:
+        case AE_SAME_HANDLER:
+        case AE_ALREADY_EXISTS:
+
+            /* These exceptions are all OK */
+
+            Status = AE_OK;
+            break;
+
+        default:
+
+            goto UnlockAndExit;
+        }
+    }
+
+UnlockAndExit:
+    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiEvHasDefaultHandler
+ *
+ * PARAMETERS:  Node                - Namespace node for the device
+ *              SpaceId             - The address space ID
+ *
+ * RETURN:      TRUE if default handler is installed, FALSE otherwise
+ *
+ * DESCRIPTION: Check if the default handler is installed for the requested
+ *              space ID.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AcpiEvHasDefaultHandler (
+    ACPI_NAMESPACE_NODE     *Node,
+    ACPI_ADR_SPACE_TYPE     SpaceId)
+{
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_OPERAND_OBJECT     *HandlerObj;
+
+
+    /* Must have an existing internal object */
+
+    ObjDesc = AcpiNsGetAttachedObject (Node);
+    if (ObjDesc)
+    {
+        HandlerObj = ObjDesc->CommonNotify.Handler;
+
+        /* Walk the linked list of handlers for this object */
+
+        while (HandlerObj)
+        {
+            if (HandlerObj->AddressSpace.SpaceId == SpaceId)
+            {
+                if (HandlerObj->AddressSpace.HandlerFlags &
+                    ACPI_ADDR_HANDLER_DEFAULT_INSTALLED)
+                {
+                    return (TRUE);
+                }
+            }
+
+            HandlerObj = HandlerObj->AddressSpace.Next;
+        }
+    }
+
+    return (FALSE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiEvInstallHandler
+ *
+ * PARAMETERS:  WalkNamespace callback
+ *
+ * DESCRIPTION: This routine installs an address handler into objects that are
+ *              of type Region or Device.
+ *
+ *              If the Object is a Device, and the device has a handler of
+ *              the same type then the search is terminated in that branch.
+ *
+ *              This is because the existing handler is closer in proximity
+ *              to any more regions than the one we are trying to install.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiEvInstallHandler (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue)
+{
+    ACPI_OPERAND_OBJECT     *HandlerObj;
+    ACPI_OPERAND_OBJECT     *NextHandlerObj;
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_NAME (EvInstallHandler);
+
+
+    HandlerObj = (ACPI_OPERAND_OBJECT  *) Context;
+
+    /* Parameter validation */
+
+    if (!HandlerObj)
+    {
+        return (AE_OK);
+    }
+
+    /* Convert and validate the device handle */
+
+    Node = AcpiNsValidateHandle (ObjHandle);
+    if (!Node)
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+    /*
+     * We only care about regions and objects that are allowed to have
+     * address space handlers
+     */
+    if ((Node->Type != ACPI_TYPE_DEVICE) &&
+        (Node->Type != ACPI_TYPE_REGION) &&
+        (Node != AcpiGbl_RootNode))
+    {
+        return (AE_OK);
+    }
+
+    /* Check for an existing internal object */
+
+    ObjDesc = AcpiNsGetAttachedObject (Node);
+    if (!ObjDesc)
+    {
+        /* No object, just exit */
+
+        return (AE_OK);
+    }
+
+    /* Devices are handled different than regions */
+
+    if (ObjDesc->Common.Type == ACPI_TYPE_DEVICE)
+    {
+        /* Check if this Device already has a handler for this address space */
+
+        NextHandlerObj = AcpiEvFindRegionHandler (
+            HandlerObj->AddressSpace.SpaceId, ObjDesc->CommonNotify.Handler);
+        if (NextHandlerObj)
+        {
+            /* Found a handler, is it for the same address space? */
+
+            ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
+                "Found handler for region [%s] in device %p(%p) handler %p\n",
+                AcpiUtGetRegionName (HandlerObj->AddressSpace.SpaceId),
+                ObjDesc, NextHandlerObj, HandlerObj));
+
+            /*
+             * Since the object we found it on was a device, then it means
+             * that someone has already installed a handler for the branch
+             * of the namespace from this device on. Just bail out telling
+             * the walk routine to not traverse this branch. This preserves
+             * the scoping rule for handlers.
+             */
+            return (AE_CTRL_DEPTH);
+        }
+
+        /*
+         * As long as the device didn't have a handler for this space we
+         * don't care about it. We just ignore it and proceed.
+         */
+        return (AE_OK);
+    }
+
+    /* Object is a Region */
+
+    if (ObjDesc->Region.SpaceId != HandlerObj->AddressSpace.SpaceId)
+    {
+        /* This region is for a different address space, just ignore it */
+
+        return (AE_OK);
+    }
+
+    /*
+     * Now we have a region and it is for the handler's address space type.
+     *
+     * First disconnect region for any previous handler (if any)
+     */
+    AcpiEvDetachRegion (ObjDesc, FALSE);
+
+    /* Connect the region to the new handler */
+
+    Status = AcpiEvAttachRegion (HandlerObj, ObjDesc, FALSE);
+    return (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiEvFindRegionHandler
+ *
+ * PARAMETERS:  SpaceId         - The address space ID
+ *              HandlerObj      - Head of the handler object list
+ *
+ * RETURN:      Matching handler object. NULL if space ID not matched
+ *
+ * DESCRIPTION: Search a handler object list for a match on the address
+ *              space ID.
+ *
+ ******************************************************************************/
+
+ACPI_OPERAND_OBJECT *
+AcpiEvFindRegionHandler (
+    ACPI_ADR_SPACE_TYPE     SpaceId,
+    ACPI_OPERAND_OBJECT     *HandlerObj)
+{
+
+    /* Walk the handler list for this device */
+
+    while (HandlerObj)
+    {
+        /* Same SpaceId indicates a handler is installed */
+
+        if (HandlerObj->AddressSpace.SpaceId == SpaceId)
+        {
+            return (HandlerObj);
+        }
+
+        /* Next handler object */
+
+        HandlerObj = HandlerObj->AddressSpace.Next;
+    }
+
+    return (NULL);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiEvInstallSpaceHandler
+ *
+ * PARAMETERS:  Node            - Namespace node for the device
+ *              SpaceId         - The address space ID
+ *              Handler         - Address of the handler
+ *              Setup           - Address of the setup function
+ *              Context         - Value passed to the handler on each access
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for all OpRegions of a given SpaceId.
+ *              Assumes namespace is locked
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiEvInstallSpaceHandler (
+    ACPI_NAMESPACE_NODE     *Node,
+    ACPI_ADR_SPACE_TYPE     SpaceId,
+    ACPI_ADR_SPACE_HANDLER  Handler,
+    ACPI_ADR_SPACE_SETUP    Setup,
+    void                    *Context)
+{
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_OPERAND_OBJECT     *HandlerObj;
+    ACPI_STATUS             Status = AE_OK;
+    ACPI_OBJECT_TYPE        Type;
+    UINT8                   Flags = 0;
+
+
+    ACPI_FUNCTION_TRACE (EvInstallSpaceHandler);
+
+
+    /*
+     * This registration is valid for only the types below and the root.
+     * The root node is where the default handlers get installed.
+     */
+    if ((Node->Type != ACPI_TYPE_DEVICE)     &&
+        (Node->Type != ACPI_TYPE_PROCESSOR)  &&
+        (Node->Type != ACPI_TYPE_THERMAL)    &&
+        (Node != AcpiGbl_RootNode))
+    {
+        Status = AE_BAD_PARAMETER;
+        goto UnlockAndExit;
+    }
+
+    if (Handler == ACPI_DEFAULT_HANDLER)
+    {
+        Flags = ACPI_ADDR_HANDLER_DEFAULT_INSTALLED;
+
+        switch (SpaceId)
+        {
+        case ACPI_ADR_SPACE_SYSTEM_MEMORY:
+
+            Handler = AcpiExSystemMemorySpaceHandler;
+            Setup   = AcpiEvSystemMemoryRegionSetup;
+            break;
+
+        case ACPI_ADR_SPACE_SYSTEM_IO:
+
+            Handler = AcpiExSystemIoSpaceHandler;
+            Setup   = AcpiEvIoSpaceRegionSetup;
+            break;
+
+        case ACPI_ADR_SPACE_PCI_CONFIG:
+
+            Handler = AcpiExPciConfigSpaceHandler;
+            Setup   = AcpiEvPciConfigRegionSetup;
+            break;
+
+        case ACPI_ADR_SPACE_CMOS:
+
+            Handler = AcpiExCmosSpaceHandler;
+            Setup   = AcpiEvCmosRegionSetup;
+            break;
+
+        case ACPI_ADR_SPACE_PCI_BAR_TARGET:
+
+            Handler = AcpiExPciBarSpaceHandler;
+            Setup   = AcpiEvPciBarRegionSetup;
+            break;
+
+        case ACPI_ADR_SPACE_DATA_TABLE:
+
+            Handler = AcpiExDataTableSpaceHandler;
+            Setup   = NULL;
+            break;
+
+        default:
+
+            Status = AE_BAD_PARAMETER;
+            goto UnlockAndExit;
+        }
+    }
+
+    /* If the caller hasn't specified a setup routine, use the default */
+
+    if (!Setup)
+    {
+        Setup = AcpiEvDefaultRegionSetup;
+    }
+
+    /* Check for an existing internal object */
+
+    ObjDesc = AcpiNsGetAttachedObject (Node);
+    if (ObjDesc)
+    {
+        /*
+         * The attached device object already exists. Now make sure
+         * the handler is not already installed.
+         */
+        HandlerObj = AcpiEvFindRegionHandler (SpaceId,
+            ObjDesc->CommonNotify.Handler);
+
+        if (HandlerObj)
+        {
+            if (HandlerObj->AddressSpace.Handler == Handler)
+            {
+                /*
+                 * It is (relatively) OK to attempt to install the SAME
+                 * handler twice. This can easily happen with the
+                 * PCI_Config space.
+                 */
+                Status = AE_SAME_HANDLER;
+                goto UnlockAndExit;
+            }
+            else
+            {
+                /* A handler is already installed */
+
+                Status = AE_ALREADY_EXISTS;
+            }
+
+            goto UnlockAndExit;
+        }
+    }
+    else
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
+            "Creating object on Device %p while installing handler\n",
+            Node));
+
+        /* ObjDesc does not exist, create one */
+
+        if (Node->Type == ACPI_TYPE_ANY)
+        {
+            Type = ACPI_TYPE_DEVICE;
+        }
+        else
+        {
+            Type = Node->Type;
+        }
+
+        ObjDesc = AcpiUtCreateInternalObject (Type);
+        if (!ObjDesc)
+        {
+            Status = AE_NO_MEMORY;
+            goto UnlockAndExit;
+        }
+
+        /* Init new descriptor */
+
+        ObjDesc->Common.Type = (UINT8) Type;
+
+        /* Attach the new object to the Node */
+
+        Status = AcpiNsAttachObject (Node, ObjDesc, Type);
+
+        /* Remove local reference to the object */
+
+        AcpiUtRemoveReference (ObjDesc);
+
+        if (ACPI_FAILURE (Status))
+        {
+            goto UnlockAndExit;
+        }
+    }
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
+        "Installing address handler for region %s(%X) "
+        "on Device %4.4s %p(%p)\n",
+        AcpiUtGetRegionName (SpaceId), SpaceId,
+        AcpiUtGetNodeName (Node), Node, ObjDesc));
+
+    /*
+     * Install the handler
+     *
+     * At this point there is no existing handler. Just allocate the object
+     * for the handler and link it into the list.
+     */
+    HandlerObj = AcpiUtCreateInternalObject (ACPI_TYPE_LOCAL_ADDRESS_HANDLER);
+    if (!HandlerObj)
+    {
+        Status = AE_NO_MEMORY;
+        goto UnlockAndExit;
+    }
+
+    /* Init handler obj */
+
+    HandlerObj->AddressSpace.SpaceId = (UINT8) SpaceId;
+    HandlerObj->AddressSpace.HandlerFlags = Flags;
+    HandlerObj->AddressSpace.RegionList = NULL;
+    HandlerObj->AddressSpace.Node = Node;
+    HandlerObj->AddressSpace.Handler = Handler;
+    HandlerObj->AddressSpace.Context = Context;
+    HandlerObj->AddressSpace.Setup = Setup;
+
+    /* Install at head of Device.AddressSpace list */
+
+    HandlerObj->AddressSpace.Next = ObjDesc->CommonNotify.Handler;
+
+    /*
+     * The Device object is the first reference on the HandlerObj.
+     * Each region that uses the handler adds a reference.
+     */
+    ObjDesc->CommonNotify.Handler = HandlerObj;
+
+    /*
+     * Walk the namespace finding all of the regions this handler will
+     * manage.
+     *
+     * Start at the device and search the branch toward the leaf nodes
+     * until either the leaf is encountered or a device is detected that
+     * has an address handler of the same type.
+     *
+     * In either case, back up and search down the remainder of the branch
+     */
+    Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, Node,
+        ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
+        AcpiEvInstallHandler, NULL, HandlerObj, NULL);
+
+UnlockAndExit:
+    return_ACPI_STATUS (Status);
+}
diff --git a/usr/src/uts/intel/io/acpica/events/evmisc.c b/usr/src/uts/intel/io/acpica/events/evmisc.c
index 68f751aca3..30fc6f0c28 100644
--- a/usr/src/uts/intel/io/acpica/events/evmisc.c
+++ b/usr/src/uts/intel/io/acpica/events/evmisc.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -75,6 +75,7 @@ BOOLEAN
 AcpiEvIsNotifyObject (
     ACPI_NAMESPACE_NODE     *Node)
 {
+
     switch (Node->Type)
     {
     case ACPI_TYPE_DEVICE:
@@ -86,6 +87,7 @@ AcpiEvIsNotifyObject (
         return (TRUE);
 
     default:
+
         return (FALSE);
     }
 }
@@ -180,10 +182,10 @@ AcpiEvQueueNotifyRequest (
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
         "Dispatching Notify on [%4.4s] (%s) Value 0x%2.2X (%s) Node %p\n",
         AcpiUtGetNodeName (Node), AcpiUtGetTypeName (Node->Type),
-        NotifyValue, AcpiUtGetNotifyName (NotifyValue), Node));
+        NotifyValue, AcpiUtGetNotifyName (NotifyValue, ACPI_TYPE_ANY), Node));
 
-    Status = AcpiOsExecute (OSL_NOTIFY_HANDLER, AcpiEvNotifyDispatch,
-        Info);
+    Status = AcpiOsExecute (OSL_NOTIFY_HANDLER,
+        AcpiEvNotifyDispatch, Info);
     if (ACPI_FAILURE (Status))
     {
         AcpiUtDeleteGenericState (Info);
@@ -291,21 +293,23 @@ AcpiEvTerminate (
 
         Status = AcpiEvWalkGpeList (AcpiHwDisableGpeBlock, NULL);
 
-        /* Remove SCI handler */
-
-        Status = AcpiEvRemoveSciHandler ();
-        if (ACPI_FAILURE(Status))
-        {
-            ACPI_ERROR ((AE_INFO,
-                "Could not remove SCI handler"));
-        }
-
         Status = AcpiEvRemoveGlobalLockHandler ();
         if (ACPI_FAILURE(Status))
         {
             ACPI_ERROR ((AE_INFO,
                 "Could not remove Global Lock handler"));
         }
+
+        AcpiGbl_EventsInitialized = FALSE;
+    }
+
+    /* Remove SCI handlers */
+
+    Status = AcpiEvRemoveAllSciHandlers ();
+    if (ACPI_FAILURE(Status))
+    {
+        ACPI_ERROR ((AE_INFO,
+            "Could not remove SCI handler"));
     }
 
     /* Deallocate all handler objects installed within GPE info structs */
diff --git a/usr/src/uts/intel/io/acpica/events/evregion.c b/usr/src/uts/intel/io/acpica/events/evregion.c
index 8c1a8ebbae..673d44d191 100644
--- a/usr/src/uts/intel/io/acpica/events/evregion.c
+++ b/usr/src/uts/intel/io/acpica/events/evregion.c
@@ -1,11 +1,11 @@
 /******************************************************************************
  *
- * Module Name: evregion - ACPI AddressSpace (OpRegion) handler dispatch
+ * Module Name: evregion - Operation Region support
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EVREGION_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acevents.h"
@@ -54,16 +51,13 @@
         ACPI_MODULE_NAME    ("evregion")
 
 
-/* Local prototypes */
+extern UINT8        AcpiGbl_DefaultAddressSpaces[];
 
-static BOOLEAN
-AcpiEvHasDefaultHandler (
-    ACPI_NAMESPACE_NODE     *Node,
-    ACPI_ADR_SPACE_TYPE     SpaceId);
+/* Local prototypes */
 
 static void
 AcpiEvOrphanEcRegMethod (
-    void);
+    ACPI_NAMESPACE_NODE     *EcDeviceNode);
 
 static ACPI_STATUS
 AcpiEvRegRun (
@@ -72,152 +66,6 @@ AcpiEvRegRun (
     void                    *Context,
     void                    **ReturnValue);
 
-static ACPI_STATUS
-AcpiEvInstallHandler (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  Level,
-    void                    *Context,
-    void                    **ReturnValue);
-
-/* These are the address spaces that will get default handlers */
-
-#define ACPI_NUM_DEFAULT_SPACES     4
-
-static UINT8        AcpiGbl_DefaultAddressSpaces[ACPI_NUM_DEFAULT_SPACES] =
-{
-    ACPI_ADR_SPACE_SYSTEM_MEMORY,
-    ACPI_ADR_SPACE_SYSTEM_IO,
-    ACPI_ADR_SPACE_PCI_CONFIG,
-    ACPI_ADR_SPACE_DATA_TABLE
-};
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiEvInstallRegionHandlers
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Installs the core subsystem default address space handlers.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiEvInstallRegionHandlers (
-    void)
-{
-    ACPI_STATUS             Status;
-    UINT32                  i;
-
-
-    ACPI_FUNCTION_TRACE (EvInstallRegionHandlers);
-
-
-    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /*
-     * All address spaces (PCI Config, EC, SMBus) are scope dependent and
-     * registration must occur for a specific device.
-     *
-     * In the case of the system memory and IO address spaces there is
-     * currently no device associated with the address space. For these we
-     * use the root.
-     *
-     * We install the default PCI config space handler at the root so that
-     * this space is immediately available even though the we have not
-     * enumerated all the PCI Root Buses yet. This is to conform to the ACPI
-     * specification which states that the PCI config space must be always
-     * available -- even though we are nowhere near ready to find the PCI root
-     * buses at this point.
-     *
-     * NOTE: We ignore AE_ALREADY_EXISTS because this means that a handler
-     * has already been installed (via AcpiInstallAddressSpaceHandler).
-     * Similar for AE_SAME_HANDLER.
-     */
-    for (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++)
-    {
-        Status = AcpiEvInstallSpaceHandler (AcpiGbl_RootNode,
-                    AcpiGbl_DefaultAddressSpaces[i],
-                    ACPI_DEFAULT_HANDLER, NULL, NULL);
-        switch (Status)
-        {
-        case AE_OK:
-        case AE_SAME_HANDLER:
-        case AE_ALREADY_EXISTS:
-
-            /* These exceptions are all OK */
-
-            Status = AE_OK;
-            break;
-
-        default:
-
-            goto UnlockAndExit;
-        }
-    }
-
-UnlockAndExit:
-    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
-    return_ACPI_STATUS (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiEvHasDefaultHandler
- *
- * PARAMETERS:  Node                - Namespace node for the device
- *              SpaceId             - The address space ID
- *
- * RETURN:      TRUE if default handler is installed, FALSE otherwise
- *
- * DESCRIPTION: Check if the default handler is installed for the requested
- *              space ID.
- *
- ******************************************************************************/
-
-static BOOLEAN
-AcpiEvHasDefaultHandler (
-    ACPI_NAMESPACE_NODE     *Node,
-    ACPI_ADR_SPACE_TYPE     SpaceId)
-{
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_OPERAND_OBJECT     *HandlerObj;
-
-
-    /* Must have an existing internal object */
-
-    ObjDesc = AcpiNsGetAttachedObject (Node);
-    if (ObjDesc)
-    {
-        HandlerObj = ObjDesc->Device.Handler;
-
-        /* Walk the linked list of handlers for this object */
-
-        while (HandlerObj)
-        {
-            if (HandlerObj->AddressSpace.SpaceId == SpaceId)
-            {
-                if (HandlerObj->AddressSpace.HandlerFlags &
-                        ACPI_ADDR_HANDLER_DEFAULT_INSTALLED)
-                {
-                    return (TRUE);
-                }
-            }
-
-            HandlerObj = HandlerObj->AddressSpace.Next;
-        }
-    }
-
-    return (FALSE);
-}
-
 
 /*******************************************************************************
  *
@@ -261,112 +109,16 @@ AcpiEvInitializeOpRegions (
         if (AcpiEvHasDefaultHandler (AcpiGbl_RootNode,
                AcpiGbl_DefaultAddressSpaces[i]))
         {
-            Status = AcpiEvExecuteRegMethods (AcpiGbl_RootNode,
-                        AcpiGbl_DefaultAddressSpaces[i]);
+            AcpiEvExecuteRegMethods (AcpiGbl_RootNode,
+                AcpiGbl_DefaultAddressSpaces[i], ACPI_REG_CONNECT);
         }
     }
 
-    AcpiGbl_RegMethodsExecuted = TRUE;
-
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
     return_ACPI_STATUS (Status);
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiEvExecuteRegMethod
- *
- * PARAMETERS:  RegionObj           - Region object
- *              Function            - Passed to _REG: On (1) or Off (0)
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Execute _REG method for a region
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiEvExecuteRegMethod (
-    ACPI_OPERAND_OBJECT     *RegionObj,
-    UINT32                  Function)
-{
-    ACPI_EVALUATE_INFO      *Info;
-    ACPI_OPERAND_OBJECT     *Args[3];
-    ACPI_OPERAND_OBJECT     *RegionObj2;
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_TRACE (EvExecuteRegMethod);
-
-
-    RegionObj2 = AcpiNsGetSecondaryObject (RegionObj);
-    if (!RegionObj2)
-    {
-        return_ACPI_STATUS (AE_NOT_EXIST);
-    }
-
-    if (RegionObj2->Extra.Method_REG == NULL)
-    {
-        return_ACPI_STATUS (AE_OK);
-    }
-
-    /* Allocate and initialize the evaluation information block */
-
-    Info = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_EVALUATE_INFO));
-    if (!Info)
-    {
-        return_ACPI_STATUS (AE_NO_MEMORY);
-    }
-
-    Info->PrefixNode = RegionObj2->Extra.Method_REG;
-    Info->Pathname = NULL;
-    Info->Parameters = Args;
-    Info->Flags = ACPI_IGNORE_RETURN_VALUE;
-
-    /*
-     * The _REG method has two arguments:
-     *
-     * Arg0 - Integer:
-     *  Operation region space ID Same value as RegionObj->Region.SpaceId
-     *
-     * Arg1 - Integer:
-     *  connection status 1 for connecting the handler, 0 for disconnecting
-     *  the handler (Passed as a parameter)
-     */
-    Args[0] = AcpiUtCreateIntegerObject ((UINT64) RegionObj->Region.SpaceId);
-    if (!Args[0])
-    {
-        Status = AE_NO_MEMORY;
-        goto Cleanup1;
-    }
-
-    Args[1] = AcpiUtCreateIntegerObject ((UINT64) Function);
-    if (!Args[1])
-    {
-        Status = AE_NO_MEMORY;
-        goto Cleanup2;
-    }
-
-    Args[2] = NULL; /* Terminate list */
-
-    /* Execute the method, no return value */
-
-    ACPI_DEBUG_EXEC (
-        AcpiUtDisplayInitPathname (ACPI_TYPE_METHOD, Info->PrefixNode, NULL));
-
-    Status = AcpiNsEvaluate (Info);
-    AcpiUtRemoveReference (Args[1]);
-
-Cleanup2:
-    AcpiUtRemoveReference (Args[0]);
-
-Cleanup1:
-    ACPI_FREE (Info);
-    return_ACPI_STATUS (Status);
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiEvAddressSpaceDispatch
@@ -384,6 +136,12 @@ Cleanup1:
  * DESCRIPTION: Dispatch an address space or operation region access to
  *              a previously installed handler.
  *
+ * NOTE: During early initialization, we always install the default region
+ * handlers for Memory, I/O and PCI_Config. This ensures that these operation
+ * region address spaces are always available as per the ACPI specification.
+ * This is especially needed in order to support the execution of
+ * module-level AML code during loading of the ACPI tables.
+ *
  ******************************************************************************/
 
 ACPI_STATUS
@@ -402,6 +160,7 @@ AcpiEvAddressSpaceDispatch (
     ACPI_OPERAND_OBJECT     *RegionObj2;
     void                    *RegionContext = NULL;
     ACPI_CONNECTION_INFO    *Context;
+    ACPI_PHYSICAL_ADDRESS   Address;
 
 
     ACPI_FUNCTION_TRACE (EvAddressSpaceDispatch);
@@ -455,7 +214,7 @@ AcpiEvAddressSpaceDispatch (
         AcpiExExitInterpreter ();
 
         Status = RegionSetup (RegionObj, ACPI_REGION_ACTIVATE,
-                    Context, &RegionContext);
+            Context, &RegionContext);
 
         /* Re-enter the interpreter */
 
@@ -477,18 +236,12 @@ AcpiEvAddressSpaceDispatch (
         {
             RegionObj->Region.Flags |= AOPOBJ_SETUP_COMPLETE;
 
-            if (RegionObj2->Extra.RegionContext)
-            {
-                /* The handler for this region was already installed */
-
-                ACPI_FREE (RegionContext);
-            }
-            else
+            /*
+             * Save the returned context for use in all accesses to
+             * the handler for this particular region
+             */
+            if (!(RegionObj2->Extra.RegionContext))
             {
-                /*
-                 * Save the returned context for use in all accesses to
-                 * this particular region
-                 */
                 RegionObj2->Extra.RegionContext = RegionContext;
             }
         }
@@ -497,24 +250,33 @@ AcpiEvAddressSpaceDispatch (
     /* We have everything we need, we can invoke the address space handler */
 
     Handler = HandlerDesc->AddressSpace.Handler;
-
-    ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
-        "Handler %p (@%p) Address %8.8X%8.8X [%s]\n",
-        &RegionObj->Region.Handler->AddressSpace, Handler,
-        ACPI_FORMAT_NATIVE_UINT (RegionObj->Region.Address + RegionOffset),
-        AcpiUtGetRegionName (RegionObj->Region.SpaceId)));
-
+    Address = (RegionObj->Region.Address + RegionOffset);
 
     /*
      * Special handling for GenericSerialBus and GeneralPurposeIo:
      * There are three extra parameters that must be passed to the
      * handler via the context:
-     *   1) Connection buffer, a resource template from Connection() op.
-     *   2) Length of the above buffer.
-     *   3) Actual access length from the AccessAs() op.
+     *   1) Connection buffer, a resource template from Connection() op
+     *   2) Length of the above buffer
+     *   3) Actual access length from the AccessAs() op
+     *
+     * In addition, for GeneralPurposeIo, the Address and BitWidth fields
+     * are defined as follows:
+     *   1) Address is the pin number index of the field (bit offset from
+     *      the previous Connection)
+     *   2) BitWidth is the actual bit length of the field (number of pins)
      */
-    if (((RegionObj->Region.SpaceId == ACPI_ADR_SPACE_GSBUS) ||
-            (RegionObj->Region.SpaceId == ACPI_ADR_SPACE_GPIO)) &&
+    if ((RegionObj->Region.SpaceId == ACPI_ADR_SPACE_GSBUS) &&
+        Context &&
+        FieldObj)
+    {
+        /* Get the Connection (ResourceTemplate) buffer */
+
+        Context->Connection = FieldObj->Field.ResourceBuffer;
+        Context->Length = FieldObj->Field.ResourceLength;
+        Context->AccessLength = FieldObj->Field.AccessLength;
+    }
+    if ((RegionObj->Region.SpaceId == ACPI_ADR_SPACE_GPIO) &&
         Context &&
         FieldObj)
     {
@@ -523,10 +285,18 @@ AcpiEvAddressSpaceDispatch (
         Context->Connection = FieldObj->Field.ResourceBuffer;
         Context->Length = FieldObj->Field.ResourceLength;
         Context->AccessLength = FieldObj->Field.AccessLength;
+        Address = FieldObj->Field.PinNumberIndex;
+        BitWidth = FieldObj->Field.BitLength;
     }
 
+    ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
+        "Handler %p (@%p) Address %8.8X%8.8X [%s]\n",
+        &RegionObj->Region.Handler->AddressSpace, Handler,
+        ACPI_FORMAT_UINT64 (Address),
+        AcpiUtGetRegionName (RegionObj->Region.SpaceId)));
+
     if (!(HandlerDesc->AddressSpace.HandlerFlags &
-            ACPI_ADDR_HANDLER_DEFAULT_INSTALLED))
+        ACPI_ADDR_HANDLER_DEFAULT_INSTALLED))
     {
         /*
          * For handlers other than the default (supplied) handlers, we must
@@ -538,9 +308,8 @@ AcpiEvAddressSpaceDispatch (
 
     /* Call the handler */
 
-    Status = Handler (Function,
-        (RegionObj->Region.Address + RegionOffset), BitWidth, Value,
-        Context, RegionObj2->Extra.RegionContext);
+    Status = Handler (Function, Address, BitWidth, Value, Context,
+        RegionObj2->Extra.RegionContext);
 
     if (ACPI_FAILURE (Status))
     {
@@ -549,13 +318,13 @@ AcpiEvAddressSpaceDispatch (
     }
 
     if (!(HandlerDesc->AddressSpace.HandlerFlags &
-            ACPI_ADDR_HANDLER_DEFAULT_INSTALLED))
+        ACPI_ADDR_HANDLER_DEFAULT_INSTALLED))
     {
         /*
          * We just returned from a non-default handler, we must re-enter the
          * interpreter
          */
-       AcpiExEnterInterpreter ();
+        AcpiExEnterInterpreter ();
     }
 
     return_ACPI_STATUS (Status);
@@ -577,12 +346,13 @@ AcpiEvAddressSpaceDispatch (
  ******************************************************************************/
 
 void
-AcpiEvDetachRegion(
+AcpiEvDetachRegion (
     ACPI_OPERAND_OBJECT     *RegionObj,
     BOOLEAN                 AcpiNsIsLocked)
 {
     ACPI_OPERAND_OBJECT     *HandlerObj;
     ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_OPERAND_OBJECT     *StartDesc;
     ACPI_OPERAND_OBJECT     **LastObjPtr;
     ACPI_ADR_SPACE_SETUP    RegionSetup;
     void                    **RegionContext;
@@ -613,6 +383,7 @@ AcpiEvDetachRegion(
     /* Find this region in the handler's list */
 
     ObjDesc = HandlerObj->AddressSpace.RegionList;
+    StartDesc = ObjDesc;
     LastObjPtr = &HandlerObj->AddressSpace.RegionList;
 
     while (ObjDesc)
@@ -667,6 +438,15 @@ AcpiEvDetachRegion(
                 Status = RegionSetup (RegionObj, ACPI_REGION_DEACTIVATE,
                     HandlerObj->AddressSpace.Context, RegionContext);
 
+                /*
+                 * RegionContext should have been released by the deactivate
+                 * operation. We don't need access to it anymore here.
+                 */
+                if (RegionContext)
+                {
+                    *RegionContext = NULL;
+                }
+
                 /* Init routine may fail, Just ignore errors */
 
                 if (ACPI_FAILURE (Status))
@@ -698,6 +478,16 @@ AcpiEvDetachRegion(
 
         LastObjPtr = &ObjDesc->Region.Next;
         ObjDesc = ObjDesc->Region.Next;
+
+        /* Prevent infinite loop if list is corrupted */
+
+        if (ObjDesc == StartDesc)
+        {
+            ACPI_ERROR ((AE_INFO,
+                "Circular handler list in region object %p",
+                RegionObj));
+            return_VOID;
+        }
     }
 
     /* If we get here, the region was not in the handler's region list */
@@ -735,6 +525,13 @@ AcpiEvAttachRegion (
     ACPI_FUNCTION_TRACE (EvAttachRegion);
 
 
+    /* Install the region's handler */
+
+    if (RegionObj->Region.Handler)
+    {
+        return_ACPI_STATUS (AE_ALREADY_EXISTS);
+    }
+
     ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
         "Adding Region [%4.4s] %p to address handler %p [%s]\n",
         AcpiUtGetNodeName (RegionObj->Region.Node),
@@ -745,14 +542,6 @@ AcpiEvAttachRegion (
 
     RegionObj->Region.Next = HandlerObj->AddressSpace.RegionList;
     HandlerObj->AddressSpace.RegionList = RegionObj;
-
-    /* Install the region's handler */
-
-    if (RegionObj->Region.Handler)
-    {
-        return_ACPI_STATUS (AE_ALREADY_EXISTS);
-    }
-
     RegionObj->Region.Handler = HandlerObj;
     AcpiUtAddReference (HandlerObj);
 
@@ -762,377 +551,144 @@ AcpiEvAttachRegion (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiEvInstallHandler
- *
- * PARAMETERS:  WalkNamespace callback
+ * FUNCTION:    AcpiEvExecuteRegMethod
  *
- * DESCRIPTION: This routine installs an address handler into objects that are
- *              of type Region or Device.
+ * PARAMETERS:  RegionObj           - Region object
+ *              Function            - Passed to _REG: On (1) or Off (0)
  *
- *              If the Object is a Device, and the device has a handler of
- *              the same type then the search is terminated in that branch.
+ * RETURN:      Status
  *
- *              This is because the existing handler is closer in proximity
- *              to any more regions than the one we are trying to install.
+ * DESCRIPTION: Execute _REG method for a region
  *
  ******************************************************************************/
 
-static ACPI_STATUS
-AcpiEvInstallHandler (
-    ACPI_HANDLE             ObjHandle,
-    UINT32                  Level,
-    void                    *Context,
-    void                    **ReturnValue)
+ACPI_STATUS
+AcpiEvExecuteRegMethod (
+    ACPI_OPERAND_OBJECT     *RegionObj,
+    UINT32                  Function)
 {
-    ACPI_OPERAND_OBJECT     *HandlerObj;
-    ACPI_OPERAND_OBJECT     *NextHandlerObj;
-    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_EVALUATE_INFO      *Info;
+    ACPI_OPERAND_OBJECT     *Args[3];
+    ACPI_OPERAND_OBJECT     *RegionObj2;
+    const ACPI_NAME         *RegNamePtr = ACPI_CAST_PTR (ACPI_NAME, METHOD_NAME__REG);
+    ACPI_NAMESPACE_NODE     *MethodNode;
     ACPI_NAMESPACE_NODE     *Node;
     ACPI_STATUS             Status;
 
 
-    ACPI_FUNCTION_NAME (EvInstallHandler);
-
-
-    HandlerObj = (ACPI_OPERAND_OBJECT  *) Context;
+    ACPI_FUNCTION_TRACE (EvExecuteRegMethod);
 
-    /* Parameter validation */
 
-    if (!HandlerObj)
+    if (!AcpiGbl_NamespaceInitialized ||
+        RegionObj->Region.Handler == NULL)
     {
-        return (AE_OK);
+        return_ACPI_STATUS (AE_OK);
     }
 
-    /* Convert and validate the device handle */
-
-    Node = AcpiNsValidateHandle (ObjHandle);
-    if (!Node)
+    RegionObj2 = AcpiNsGetSecondaryObject (RegionObj);
+    if (!RegionObj2)
     {
-        return (AE_BAD_PARAMETER);
+        return_ACPI_STATUS (AE_NOT_EXIST);
     }
 
     /*
-     * We only care about regions and objects that are allowed to have
-     * address space handlers
+     * Find any "_REG" method associated with this region definition.
+     * The method should always be updated as this function may be
+     * invoked after a namespace change.
      */
-    if ((Node->Type != ACPI_TYPE_DEVICE) &&
-        (Node->Type != ACPI_TYPE_REGION) &&
-        (Node != AcpiGbl_RootNode))
+    Node = RegionObj->Region.Node->Parent;
+    Status = AcpiNsSearchOneScope (
+        *RegNamePtr, Node, ACPI_TYPE_METHOD, &MethodNode);
+    if (ACPI_SUCCESS (Status))
     {
-        return (AE_OK);
+        /*
+         * The _REG method is optional and there can be only one per
+         * region definition. This will be executed when the handler is
+         * attached or removed.
+         */
+        RegionObj2->Extra.Method_REG = MethodNode;
     }
-
-    /* Check for an existing internal object */
-
-    ObjDesc = AcpiNsGetAttachedObject (Node);
-    if (!ObjDesc)
+    if (RegionObj2->Extra.Method_REG == NULL)
     {
-        /* No object, just exit */
-
-        return (AE_OK);
+        return_ACPI_STATUS (AE_OK);
     }
 
-    /* Devices are handled different than regions */
+    /* _REG(DISCONNECT) should be paired with _REG(CONNECT) */
 
-    if (ObjDesc->Common.Type == ACPI_TYPE_DEVICE)
+    if ((Function == ACPI_REG_CONNECT &&
+        RegionObj->Common.Flags & AOPOBJ_REG_CONNECTED) ||
+        (Function == ACPI_REG_DISCONNECT &&
+         !(RegionObj->Common.Flags & AOPOBJ_REG_CONNECTED)))
     {
-        /* Check if this Device already has a handler for this address space */
-
-        NextHandlerObj = ObjDesc->Device.Handler;
-        while (NextHandlerObj)
-        {
-            /* Found a handler, is it for the same address space? */
-
-            if (NextHandlerObj->AddressSpace.SpaceId ==
-                    HandlerObj->AddressSpace.SpaceId)
-            {
-                ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
-                    "Found handler for region [%s] in device %p(%p) "
-                    "handler %p\n",
-                    AcpiUtGetRegionName (HandlerObj->AddressSpace.SpaceId),
-                    ObjDesc, NextHandlerObj, HandlerObj));
-
-                /*
-                 * Since the object we found it on was a device, then it
-                 * means that someone has already installed a handler for
-                 * the branch of the namespace from this device on. Just
-                 * bail out telling the walk routine to not traverse this
-                 * branch. This preserves the scoping rule for handlers.
-                 */
-                return (AE_CTRL_DEPTH);
-            }
-
-            /* Walk the linked list of handlers attached to this device */
-
-            NextHandlerObj = NextHandlerObj->AddressSpace.Next;
-        }
-
-        /*
-         * As long as the device didn't have a handler for this space we
-         * don't care about it. We just ignore it and proceed.
-         */
-        return (AE_OK);
+        return_ACPI_STATUS (AE_OK);
     }
 
-    /* Object is a Region */
+    /* Allocate and initialize the evaluation information block */
 
-    if (ObjDesc->Region.SpaceId != HandlerObj->AddressSpace.SpaceId)
+    Info = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_EVALUATE_INFO));
+    if (!Info)
     {
-        /* This region is for a different address space, just ignore it */
-
-        return (AE_OK);
+        return_ACPI_STATUS (AE_NO_MEMORY);
     }
 
-    /*
-     * Now we have a region and it is for the handler's address space type.
-     *
-     * First disconnect region for any previous handler (if any)
-     */
-    AcpiEvDetachRegion (ObjDesc, FALSE);
-
-    /* Connect the region to the new handler */
-
-    Status = AcpiEvAttachRegion (HandlerObj, ObjDesc, FALSE);
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiEvInstallSpaceHandler
- *
- * PARAMETERS:  Node            - Namespace node for the device
- *              SpaceId         - The address space ID
- *              Handler         - Address of the handler
- *              Setup           - Address of the setup function
- *              Context         - Value passed to the handler on each access
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Install a handler for all OpRegions of a given SpaceId.
- *              Assumes namespace is locked
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiEvInstallSpaceHandler (
-    ACPI_NAMESPACE_NODE     *Node,
-    ACPI_ADR_SPACE_TYPE     SpaceId,
-    ACPI_ADR_SPACE_HANDLER  Handler,
-    ACPI_ADR_SPACE_SETUP    Setup,
-    void                    *Context)
-{
-    ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_OPERAND_OBJECT     *HandlerObj;
-    ACPI_STATUS             Status;
-    ACPI_OBJECT_TYPE        Type;
-    UINT8                  Flags = 0;
-
-
-    ACPI_FUNCTION_TRACE (EvInstallSpaceHandler);
-
+    Info->PrefixNode = RegionObj2->Extra.Method_REG;
+    Info->RelativePathname = NULL;
+    Info->Parameters = Args;
+    Info->Flags = ACPI_IGNORE_RETURN_VALUE;
 
     /*
-     * This registration is valid for only the types below and the root. This
-     * is where the default handlers get placed.
+     * The _REG method has two arguments:
+     *
+     * Arg0 - Integer:
+     *  Operation region space ID Same value as RegionObj->Region.SpaceId
+     *
+     * Arg1 - Integer:
+     *  connection status 1 for connecting the handler, 0 for disconnecting
+     *  the handler (Passed as a parameter)
      */
-    if ((Node->Type != ACPI_TYPE_DEVICE)     &&
-        (Node->Type != ACPI_TYPE_PROCESSOR)  &&
-        (Node->Type != ACPI_TYPE_THERMAL)    &&
-        (Node != AcpiGbl_RootNode))
-    {
-        Status = AE_BAD_PARAMETER;
-        goto UnlockAndExit;
-    }
-
-    if (Handler == ACPI_DEFAULT_HANDLER)
+    Args[0] = AcpiUtCreateIntegerObject ((UINT64) RegionObj->Region.SpaceId);
+    if (!Args[0])
     {
-        Flags = ACPI_ADDR_HANDLER_DEFAULT_INSTALLED;
-
-        switch (SpaceId)
-        {
-        case ACPI_ADR_SPACE_SYSTEM_MEMORY:
-            Handler = AcpiExSystemMemorySpaceHandler;
-            Setup   = AcpiEvSystemMemoryRegionSetup;
-            break;
-
-        case ACPI_ADR_SPACE_SYSTEM_IO:
-            Handler = AcpiExSystemIoSpaceHandler;
-            Setup   = AcpiEvIoSpaceRegionSetup;
-            break;
-
-        case ACPI_ADR_SPACE_PCI_CONFIG:
-            Handler = AcpiExPciConfigSpaceHandler;
-            Setup   = AcpiEvPciConfigRegionSetup;
-            break;
-
-        case ACPI_ADR_SPACE_CMOS:
-            Handler = AcpiExCmosSpaceHandler;
-            Setup   = AcpiEvCmosRegionSetup;
-            break;
-
-        case ACPI_ADR_SPACE_PCI_BAR_TARGET:
-            Handler = AcpiExPciBarSpaceHandler;
-            Setup   = AcpiEvPciBarRegionSetup;
-            break;
-
-        case ACPI_ADR_SPACE_DATA_TABLE:
-            Handler = AcpiExDataTableSpaceHandler;
-            Setup   = NULL;
-            break;
-
-        default:
-            Status = AE_BAD_PARAMETER;
-            goto UnlockAndExit;
-        }
+        Status = AE_NO_MEMORY;
+        goto Cleanup1;
     }
 
-    /* If the caller hasn't specified a setup routine, use the default */
-
-    if (!Setup)
+    Args[1] = AcpiUtCreateIntegerObject ((UINT64) Function);
+    if (!Args[1])
     {
-        Setup = AcpiEvDefaultRegionSetup;
+        Status = AE_NO_MEMORY;
+        goto Cleanup2;
     }
 
-    /* Check for an existing internal object */
-
-    ObjDesc = AcpiNsGetAttachedObject (Node);
-    if (ObjDesc)
-    {
-        /*
-         * The attached device object already exists. Make sure the handler
-         * is not already installed.
-         */
-        HandlerObj = ObjDesc->Device.Handler;
-
-        /* Walk the handler list for this device */
-
-        while (HandlerObj)
-        {
-            /* Same SpaceId indicates a handler already installed */
+    Args[2] = NULL; /* Terminate list */
 
-            if (HandlerObj->AddressSpace.SpaceId == SpaceId)
-            {
-                if (HandlerObj->AddressSpace.Handler == Handler)
-                {
-                    /*
-                     * It is (relatively) OK to attempt to install the SAME
-                     * handler twice. This can easily happen with the
-                     * PCI_Config space.
-                     */
-                    Status = AE_SAME_HANDLER;
-                    goto UnlockAndExit;
-                }
-                else
-                {
-                    /* A handler is already installed */
+    /* Execute the method, no return value */
 
-                    Status = AE_ALREADY_EXISTS;
-                }
-                goto UnlockAndExit;
-            }
+    ACPI_DEBUG_EXEC (
+        AcpiUtDisplayInitPathname (ACPI_TYPE_METHOD, Info->PrefixNode, NULL));
 
-            /* Walk the linked list of handlers */
+    Status = AcpiNsEvaluate (Info);
+    AcpiUtRemoveReference (Args[1]);
 
-            HandlerObj = HandlerObj->AddressSpace.Next;
-        }
-    }
-    else
+    if (ACPI_FAILURE (Status))
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
-            "Creating object on Device %p while installing handler\n", Node));
-
-        /* ObjDesc does not exist, create one */
-
-        if (Node->Type == ACPI_TYPE_ANY)
-        {
-            Type = ACPI_TYPE_DEVICE;
-        }
-        else
-        {
-            Type = Node->Type;
-        }
-
-        ObjDesc = AcpiUtCreateInternalObject (Type);
-        if (!ObjDesc)
-        {
-            Status = AE_NO_MEMORY;
-            goto UnlockAndExit;
-        }
-
-        /* Init new descriptor */
-
-        ObjDesc->Common.Type = (UINT8) Type;
-
-        /* Attach the new object to the Node */
-
-        Status = AcpiNsAttachObject (Node, ObjDesc, Type);
-
-        /* Remove local reference to the object */
-
-        AcpiUtRemoveReference (ObjDesc);
-
-        if (ACPI_FAILURE (Status))
-        {
-            goto UnlockAndExit;
-        }
+        goto Cleanup2;
     }
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
-        "Installing address handler for region %s(%X) on Device %4.4s %p(%p)\n",
-        AcpiUtGetRegionName (SpaceId), SpaceId,
-        AcpiUtGetNodeName (Node), Node, ObjDesc));
-
-    /*
-     * Install the handler
-     *
-     * At this point there is no existing handler. Just allocate the object
-     * for the handler and link it into the list.
-     */
-    HandlerObj = AcpiUtCreateInternalObject (ACPI_TYPE_LOCAL_ADDRESS_HANDLER);
-    if (!HandlerObj)
+    if (Function == ACPI_REG_CONNECT)
     {
-        Status = AE_NO_MEMORY;
-        goto UnlockAndExit;
+        RegionObj->Common.Flags |= AOPOBJ_REG_CONNECTED;
+    }
+    else
+    {
+        RegionObj->Common.Flags &= ~AOPOBJ_REG_CONNECTED;
     }
 
-    /* Init handler obj */
-
-    HandlerObj->AddressSpace.SpaceId = (UINT8) SpaceId;
-    HandlerObj->AddressSpace.HandlerFlags = Flags;
-    HandlerObj->AddressSpace.RegionList = NULL;
-    HandlerObj->AddressSpace.Node = Node;
-    HandlerObj->AddressSpace.Handler = Handler;
-    HandlerObj->AddressSpace.Context = Context;
-    HandlerObj->AddressSpace.Setup  = Setup;
-
-    /* Install at head of Device.AddressSpace list */
-
-    HandlerObj->AddressSpace.Next = ObjDesc->Device.Handler;
-
-    /*
-     * The Device object is the first reference on the HandlerObj.
-     * Each region that uses the handler adds a reference.
-     */
-    ObjDesc->Device.Handler = HandlerObj;
-
-    /*
-     * Walk the namespace finding all of the regions this
-     * handler will manage.
-     *
-     * Start at the device and search the branch toward
-     * the leaf nodes until either the leaf is encountered or
-     * a device is detected that has an address handler of the
-     * same type.
-     *
-     * In either case, back up and search down the remainder
-     * of the branch
-     */
-    Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, Node, ACPI_UINT32_MAX,
-                ACPI_NS_WALK_UNLOCK, AcpiEvInstallHandler, NULL,
-                HandlerObj, NULL);
+Cleanup2:
+    AcpiUtRemoveReference (Args[0]);
 
-UnlockAndExit:
+Cleanup1:
+    ACPI_FREE (Info);
     return_ACPI_STATUS (Status);
 }
 
@@ -1143,24 +699,33 @@ UnlockAndExit:
  *
  * PARAMETERS:  Node            - Namespace node for the device
  *              SpaceId         - The address space ID
+ *              Function        - Passed to _REG: On (1) or Off (0)
  *
- * RETURN:      Status
+ * RETURN:      None
  *
  * DESCRIPTION: Run all _REG methods for the input Space ID;
  *              Note: assumes namespace is locked, or system init time.
  *
  ******************************************************************************/
 
-ACPI_STATUS
+void
 AcpiEvExecuteRegMethods (
     ACPI_NAMESPACE_NODE     *Node,
-    ACPI_ADR_SPACE_TYPE     SpaceId)
+    ACPI_ADR_SPACE_TYPE     SpaceId,
+    UINT32                  Function)
 {
-    ACPI_STATUS             Status;
+    ACPI_REG_WALK_INFO      Info;
 
 
     ACPI_FUNCTION_TRACE (EvExecuteRegMethods);
 
+    Info.SpaceId = SpaceId;
+    Info.Function = Function;
+    Info.RegRunCount = 0;
+
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_NAMES,
+        "    Running _REG methods for SpaceId %s\n",
+        AcpiUtGetRegionName (Info.SpaceId)));
 
     /*
      * Run all _REG methods for all Operation Regions for this space ID. This
@@ -1168,18 +733,21 @@ AcpiEvExecuteRegMethods (
      * regions and _REG methods. (i.e. handlers must be installed for all
      * regions of this Space ID before we can run any _REG methods)
      */
-    Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, Node, ACPI_UINT32_MAX,
-                ACPI_NS_WALK_UNLOCK, AcpiEvRegRun, NULL,
-                &SpaceId, NULL);
+    (void) AcpiNsWalkNamespace (ACPI_TYPE_ANY, Node, ACPI_UINT32_MAX,
+        ACPI_NS_WALK_UNLOCK, AcpiEvRegRun, NULL, &Info, NULL);
 
     /* Special case for EC: handle "orphan" _REG methods with no region */
 
     if (SpaceId == ACPI_ADR_SPACE_EC)
     {
-        AcpiEvOrphanEcRegMethod ();
+        AcpiEvOrphanEcRegMethod (Node);
     }
 
-    return_ACPI_STATUS (Status);
+    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_NAMES,
+        "    Executed %u _REG methods for SpaceId %s\n",
+        Info.RegRunCount, AcpiUtGetRegionName (Info.SpaceId)));
+
+    return_VOID;
 }
 
 
@@ -1202,11 +770,11 @@ AcpiEvRegRun (
 {
     ACPI_OPERAND_OBJECT     *ObjDesc;
     ACPI_NAMESPACE_NODE     *Node;
-    ACPI_ADR_SPACE_TYPE     SpaceId;
     ACPI_STATUS             Status;
+    ACPI_REG_WALK_INFO      *Info;
 
 
-    SpaceId = *ACPI_CAST_PTR (ACPI_ADR_SPACE_TYPE, Context);
+    Info = ACPI_CAST_PTR (ACPI_REG_WALK_INFO, Context);
 
     /* Convert and validate the device handle */
 
@@ -1238,14 +806,15 @@ AcpiEvRegRun (
 
     /* Object is a Region */
 
-    if (ObjDesc->Region.SpaceId != SpaceId)
+    if (ObjDesc->Region.SpaceId != Info->SpaceId)
     {
         /* This region is for a different address space, just ignore it */
 
         return (AE_OK);
     }
 
-    Status = AcpiEvExecuteRegMethod (ObjDesc, ACPI_REG_CONNECT);
+    Info->RegRunCount++;
+    Status = AcpiEvExecuteRegMethod (ObjDesc, Info->Function);
     return (Status);
 }
 
@@ -1254,7 +823,7 @@ AcpiEvRegRun (
  *
  * FUNCTION:    AcpiEvOrphanEcRegMethod
  *
- * PARAMETERS:  None
+ * PARAMETERS:  EcDeviceNode        - Namespace node for an EC device
  *
  * RETURN:      None
  *
@@ -1266,41 +835,30 @@ AcpiEvRegRun (
  *              detected by providing a _REG method object underneath the
  *              Embedded Controller device."
  *
- *              To quickly access the EC device, we use the EC_ID that appears
- *              within the ECDT. Otherwise, we would need to perform a time-
- *              consuming namespace walk, executing _HID methods to find the
- *              EC device.
+ *              To quickly access the EC device, we use the EcDeviceNode used
+ *              during EC handler installation. Otherwise, we would need to
+ *              perform a time consuming namespace walk, executing _HID
+ *              methods to find the EC device.
+ *
+ *  MUTEX:      Assumes the namespace is locked
  *
  ******************************************************************************/
 
 static void
 AcpiEvOrphanEcRegMethod (
-    void)
+    ACPI_NAMESPACE_NODE     *EcDeviceNode)
 {
-    ACPI_TABLE_ECDT         *Table;
+    ACPI_HANDLE             RegMethod;
+    ACPI_NAMESPACE_NODE     *NextNode;
     ACPI_STATUS             Status;
     ACPI_OBJECT_LIST        Args;
     ACPI_OBJECT             Objects[2];
-    ACPI_NAMESPACE_NODE     *EcDeviceNode;
-    ACPI_NAMESPACE_NODE     *RegMethod;
-    ACPI_NAMESPACE_NODE     *NextNode;
 
 
     ACPI_FUNCTION_TRACE (EvOrphanEcRegMethod);
 
 
-    /* Get the ECDT (if present in system) */
-
-    Status = AcpiGetTable (ACPI_SIG_ECDT, 0,
-        ACPI_CAST_INDIRECT_PTR (ACPI_TABLE_HEADER, &Table));
-    if (ACPI_FAILURE (Status))
-    {
-        return_VOID;
-    }
-
-    /* We need a valid EC_ID string */
-
-    if (!(*Table->Id))
+    if (!EcDeviceNode)
     {
         return_VOID;
     }
@@ -1309,23 +867,12 @@ AcpiEvOrphanEcRegMethod (
 
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
 
-    /* Get a handle to the EC device referenced in the ECDT */
-
-    Status = AcpiGetHandle (NULL,
-        ACPI_CAST_PTR (char, Table->Id),
-        ACPI_CAST_PTR (ACPI_HANDLE, &EcDeviceNode));
-    if (ACPI_FAILURE (Status))
-    {
-        goto Exit;
-    }
-
     /* Get a handle to a _REG method immediately under the EC device */
 
-    Status = AcpiGetHandle (EcDeviceNode,
-        METHOD_NAME__REG, ACPI_CAST_PTR (ACPI_HANDLE, &RegMethod));
+    Status = AcpiGetHandle (EcDeviceNode, METHOD_NAME__REG, &RegMethod);
     if (ACPI_FAILURE (Status))
     {
-        goto Exit;
+        goto Exit; /* There is no _REG method present */
     }
 
     /*
@@ -1333,7 +880,7 @@ AcpiEvOrphanEcRegMethod (
      * this scope with the Embedded Controller space ID. Otherwise, it
      * will already have been executed. Note, this allows for Regions
      * with other space IDs to be present; but the code below will then
-     * execute the _REG method with the EC space ID argument.
+     * execute the _REG method with the EmbeddedControl SpaceID argument.
      */
     NextNode = AcpiNsGetNextNode (EcDeviceNode, NULL);
     while (NextNode)
@@ -1342,12 +889,13 @@ AcpiEvOrphanEcRegMethod (
             (NextNode->Object) &&
             (NextNode->Object->Region.SpaceId == ACPI_ADR_SPACE_EC))
         {
-            goto Exit; /* Do not execute _REG */
+            goto Exit; /* Do not execute the _REG */
         }
+
         NextNode = AcpiNsGetNextNode (EcDeviceNode, NextNode);
     }
 
-    /* Evaluate the _REG(EC,Connect) method */
+    /* Evaluate the _REG(EmbeddedControl,Connect) method */
 
     Args.Count = 2;
     Args.Pointer = Objects;
diff --git a/usr/src/uts/intel/io/acpica/events/evrgnini.c b/usr/src/uts/intel/io/acpica/events/evrgnini.c
index 92946b5aaa..a9e6be0391 100644
--- a/usr/src/uts/intel/io/acpica/events/evrgnini.c
+++ b/usr/src/uts/intel/io/acpica/events/evrgnini.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EVRGNINI_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acevents.h"
@@ -251,9 +248,9 @@ AcpiEvPciConfigRegionSetup (
                 /* Install a handler for this PCI root bridge */
 
                 Status = AcpiInstallAddressSpaceHandler (
-                            (ACPI_HANDLE) PciRootNode,
-                            ACPI_ADR_SPACE_PCI_CONFIG,
-                            ACPI_DEFAULT_HANDLER, NULL, NULL);
+                    (ACPI_HANDLE) PciRootNode,
+                    ACPI_ADR_SPACE_PCI_CONFIG,
+                    ACPI_DEFAULT_HANDLER, NULL, NULL);
                 if (ACPI_FAILURE (Status))
                 {
                     if (Status == AE_SAME_HANDLER)
@@ -327,7 +324,7 @@ AcpiEvPciConfigRegionSetup (
      * contained in the parent's scope.
      */
     Status = AcpiUtEvaluateNumericObject (METHOD_NAME__ADR,
-                PciDeviceNode, &PciValue);
+        PciDeviceNode, &PciValue);
 
     /*
      * The default is zero, and since the allocation above zeroed the data,
@@ -342,7 +339,7 @@ AcpiEvPciConfigRegionSetup (
     /* The PCI segment number comes from the _SEG method */
 
     Status = AcpiUtEvaluateNumericObject (METHOD_NAME__SEG,
-                PciRootNode, &PciValue);
+        PciRootNode, &PciValue);
     if (ACPI_SUCCESS (Status))
     {
         PciId->Segment = ACPI_LOWORD (PciValue);
@@ -351,7 +348,7 @@ AcpiEvPciConfigRegionSetup (
     /* The PCI bus number comes from the _BBN method */
 
     Status = AcpiUtEvaluateNumericObject (METHOD_NAME__BBN,
-                PciRootNode, &PciValue);
+        PciRootNode, &PciValue);
     if (ACPI_SUCCESS (Status))
     {
         PciId->Bus = ACPI_LOWORD (PciValue);
@@ -389,8 +386,8 @@ AcpiEvIsPciRootBridge (
     ACPI_NAMESPACE_NODE     *Node)
 {
     ACPI_STATUS             Status;
-    ACPI_DEVICE_ID          *Hid;
-    ACPI_DEVICE_ID_LIST     *Cid;
+    ACPI_PNP_DEVICE_ID      *Hid;
+    ACPI_PNP_DEVICE_ID_LIST *Cid;
     UINT32                  i;
     BOOLEAN                 Match;
 
@@ -570,9 +567,6 @@ AcpiEvInitializeRegion (
     ACPI_ADR_SPACE_TYPE     SpaceId;
     ACPI_NAMESPACE_NODE     *Node;
     ACPI_STATUS             Status;
-    ACPI_NAMESPACE_NODE     *MethodNode;
-    ACPI_NAME               *RegNamePtr = (ACPI_NAME *) METHOD_NAME__REG;
-    ACPI_OPERAND_OBJECT     *RegionObj2;
 
 
     ACPI_FUNCTION_TRACE_U32 (EvInitializeRegion, AcpiNsLocked);
@@ -588,39 +582,14 @@ AcpiEvInitializeRegion (
         return_ACPI_STATUS (AE_OK);
     }
 
-    RegionObj2 = AcpiNsGetSecondaryObject (RegionObj);
-    if (!RegionObj2)
-    {
-        return_ACPI_STATUS (AE_NOT_EXIST);
-    }
+    RegionObj->Common.Flags |= AOPOBJ_OBJECT_INITIALIZED;
 
     Node = RegionObj->Region.Node->Parent;
     SpaceId = RegionObj->Region.SpaceId;
 
-    /* Setup defaults */
-
-    RegionObj->Region.Handler = NULL;
-    RegionObj2->Extra.Method_REG = NULL;
-    RegionObj->Common.Flags &= ~(AOPOBJ_SETUP_COMPLETE);
-    RegionObj->Common.Flags |= AOPOBJ_OBJECT_INITIALIZED;
-
-    /* Find any "_REG" method associated with this region definition */
-
-    Status = AcpiNsSearchOneScope (
-                *RegNamePtr, Node, ACPI_TYPE_METHOD, &MethodNode);
-    if (ACPI_SUCCESS (Status))
-    {
-        /*
-         * The _REG method is optional and there can be only one per region
-         * definition. This will be executed when the handler is attached
-         * or removed
-         */
-        RegionObj2->Extra.Method_REG = MethodNode;
-    }
-
     /*
      * The following loop depends upon the root Node having no parent
-     * ie: AcpiGbl_RootNode->ParentEntry being set to NULL
+     * ie: AcpiGbl_RootNode->Parent being set to NULL
      */
     while (Node)
     {
@@ -635,18 +604,10 @@ AcpiEvInitializeRegion (
             switch (Node->Type)
             {
             case ACPI_TYPE_DEVICE:
-
-                HandlerObj = ObjDesc->Device.Handler;
-                break;
-
             case ACPI_TYPE_PROCESSOR:
-
-                HandlerObj = ObjDesc->Processor.Handler;
-                break;
-
             case ACPI_TYPE_THERMAL:
 
-                HandlerObj = ObjDesc->ThermalZone.Handler;
+                HandlerObj = ObjDesc->CommonNotify.Handler;
                 break;
 
             case ACPI_TYPE_METHOD:
@@ -664,55 +625,49 @@ AcpiEvInitializeRegion (
                 break;
 
             default:
+
                 /* Ignore other objects */
+
                 break;
             }
 
-            while (HandlerObj)
+            HandlerObj = AcpiEvFindRegionHandler (SpaceId, HandlerObj);
+            if (HandlerObj)
             {
-                /* Is this handler of the correct type? */
-
-                if (HandlerObj->AddressSpace.SpaceId == SpaceId)
-                {
-                    /* Found correct handler */
+                /* Found correct handler */
 
-                    ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
-                        "Found handler %p for region %p in obj %p\n",
-                        HandlerObj, RegionObj, ObjDesc));
+                ACPI_DEBUG_PRINT ((ACPI_DB_OPREGION,
+                    "Found handler %p for region %p in obj %p\n",
+                    HandlerObj, RegionObj, ObjDesc));
 
-                    Status = AcpiEvAttachRegion (HandlerObj, RegionObj,
-                                AcpiNsLocked);
+                Status = AcpiEvAttachRegion (HandlerObj, RegionObj,
+                    AcpiNsLocked);
 
-                    /*
-                     * Tell all users that this region is usable by
-                     * running the _REG method
-                     */
-                    if (AcpiNsLocked)
+                /*
+                 * Tell all users that this region is usable by
+                 * running the _REG method
+                 */
+                if (AcpiNsLocked)
+                {
+                    Status = AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+                    if (ACPI_FAILURE (Status))
                     {
-                        Status = AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
-                        if (ACPI_FAILURE (Status))
-                        {
-                            return_ACPI_STATUS (Status);
-                        }
+                        return_ACPI_STATUS (Status);
                     }
+                }
 
-                    Status = AcpiEvExecuteRegMethod (RegionObj, ACPI_REG_CONNECT);
+                Status = AcpiEvExecuteRegMethod (RegionObj, ACPI_REG_CONNECT);
 
-                    if (AcpiNsLocked)
+                if (AcpiNsLocked)
+                {
+                    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
+                    if (ACPI_FAILURE (Status))
                     {
-                        Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
-                        if (ACPI_FAILURE (Status))
-                        {
-                            return_ACPI_STATUS (Status);
-                        }
+                        return_ACPI_STATUS (Status);
                     }
-
-                    return_ACPI_STATUS (AE_OK);
                 }
 
-                /* Try next handler in the list */
-
-                HandlerObj = HandlerObj->AddressSpace.Next;
+                return_ACPI_STATUS (AE_OK);
             }
         }
 
@@ -729,4 +684,3 @@ AcpiEvInitializeRegion (
 
     return_ACPI_STATUS (AE_NOT_EXIST);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/events/evsci.c b/usr/src/uts/intel/io/acpica/events/evsci.c
index c47cccc8db..c35cba702d 100644
--- a/usr/src/uts/intel/io/acpica/events/evsci.c
+++ b/usr/src/uts/intel/io/acpica/events/evsci.c
@@ -6,7 +6,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -59,6 +59,57 @@ AcpiEvSciXruptHandler (
     void                    *Context);
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiEvSciDispatch
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status code indicates whether interrupt was handled.
+ *
+ * DESCRIPTION: Dispatch the SCI to all host-installed SCI handlers.
+ *
+ ******************************************************************************/
+
+UINT32
+AcpiEvSciDispatch (
+    void)
+{
+    ACPI_SCI_HANDLER_INFO   *SciHandler;
+    ACPI_CPU_FLAGS          Flags;
+    UINT32                  IntStatus = ACPI_INTERRUPT_NOT_HANDLED;
+
+
+    ACPI_FUNCTION_NAME (EvSciDispatch);
+
+
+    /* Are there any host-installed SCI handlers? */
+
+    if (!AcpiGbl_SciHandlerList)
+    {
+        return (IntStatus);
+    }
+
+    Flags = AcpiOsAcquireLock (AcpiGbl_GpeLock);
+
+    /* Invoke all host-installed SCI handlers */
+
+    SciHandler = AcpiGbl_SciHandlerList;
+    while (SciHandler)
+    {
+        /* Invoke the installed handler (at interrupt level) */
+
+        IntStatus |= SciHandler->Address (
+            SciHandler->Context);
+
+        SciHandler = SciHandler->Next;
+    }
+
+    AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
+    return (IntStatus);
+}
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiEvSciXruptHandler
@@ -84,7 +135,7 @@ AcpiEvSciXruptHandler (
 
 
     /*
-     * We are guaranteed by the ACPI CA initialization/shutdown code that
+     * We are guaranteed by the ACPICA initialization/shutdown code that
      * if this interrupt handler is installed, ACPI is enabled.
      */
 
@@ -100,6 +151,10 @@ AcpiEvSciXruptHandler (
      */
     InterruptHandled |= AcpiEvGpeDetect (GpeXruptList);
 
+    /* Invoke all host-installed SCI handlers */
+
+    InterruptHandled |= AcpiEvSciDispatch ();
+
     AcpiSciCount++;
     return_UINT32 (InterruptHandled);
 }
@@ -129,14 +184,13 @@ AcpiEvGpeXruptHandler (
 
 
     /*
-     * We are guaranteed by the ACPI CA initialization/shutdown code that
+     * We are guaranteed by the ACPICA initialization/shutdown code that
      * if this interrupt handler is installed, ACPI is enabled.
      */
 
     /* GPEs: Check for and dispatch any GPEs that have occurred */
 
     InterruptHandled |= AcpiEvGpeDetect (GpeXruptList);
-
     return_UINT32 (InterruptHandled);
 }
 
@@ -164,22 +218,22 @@ AcpiEvInstallSciHandler (
 
 
     Status = AcpiOsInstallInterruptHandler ((UINT32) AcpiGbl_FADT.SciInterrupt,
-                AcpiEvSciXruptHandler, AcpiGbl_GpeXruptListHead);
+        AcpiEvSciXruptHandler, AcpiGbl_GpeXruptListHead);
     return_ACPI_STATUS (Status);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    AcpiEvRemoveSciHandler
+ * FUNCTION:    AcpiEvRemoveAllSciHandlers
  *
  * PARAMETERS:  none
  *
- * RETURN:      E_OK if handler uninstalled OK, E_ERROR if handler was not
+ * RETURN:      AE_OK if handler uninstalled, AE_ERROR if handler was not
  *              installed to begin with
  *
  * DESCRIPTION: Remove the SCI interrupt handler. No further SCIs will be
- *              taken.
+ *              taken. Remove all host-installed SCI handlers.
  *
  * Note:  It doesn't seem important to disable all events or set the event
  *        enable registers to their original values. The OS should disable
@@ -189,20 +243,39 @@ AcpiEvInstallSciHandler (
  ******************************************************************************/
 
 ACPI_STATUS
-AcpiEvRemoveSciHandler (
+AcpiEvRemoveAllSciHandlers (
     void)
 {
+    ACPI_SCI_HANDLER_INFO   *SciHandler;
+    ACPI_CPU_FLAGS          Flags;
     ACPI_STATUS             Status;
 
 
-    ACPI_FUNCTION_TRACE (EvRemoveSciHandler);
+    ACPI_FUNCTION_TRACE (EvRemoveAllSciHandlers);
 
 
     /* Just let the OS remove the handler and disable the level */
 
     Status = AcpiOsRemoveInterruptHandler ((UINT32) AcpiGbl_FADT.SciInterrupt,
-                AcpiEvSciXruptHandler);
+        AcpiEvSciXruptHandler);
+
+    if (!AcpiGbl_SciHandlerList)
+    {
+        return (Status);
+    }
+
+    Flags = AcpiOsAcquireLock (AcpiGbl_GpeLock);
+
+    /* Free all host-installed SCI handlers */
+
+    while (AcpiGbl_SciHandlerList)
+    {
+        SciHandler = AcpiGbl_SciHandlerList;
+        AcpiGbl_SciHandlerList = SciHandler->Next;
+        ACPI_FREE (SciHandler);
+    }
 
+    AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
     return_ACPI_STATUS (Status);
 }
 
diff --git a/usr/src/uts/intel/io/acpica/events/evxface.c b/usr/src/uts/intel/io/acpica/events/evxface.c
index 1b709a5787..edace79649 100644
--- a/usr/src/uts/intel/io/acpica/events/evxface.c
+++ b/usr/src/uts/intel/io/acpica/events/evxface.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,7 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EVXFACE_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
@@ -53,6 +52,21 @@
 #define _COMPONENT          ACPI_EVENTS
         ACPI_MODULE_NAME    ("evxface")
 
+#if (!ACPI_REDUCED_HARDWARE)
+
+/* Local prototypes */
+
+static ACPI_STATUS
+AcpiEvInstallGpeHandler (
+    ACPI_HANDLE             GpeDevice,
+    UINT32                  GpeNumber,
+    UINT32                  Type,
+    BOOLEAN                 IsRawHandler,
+    ACPI_GPE_HANDLER        Address,
+    void                    *Context);
+
+#endif
+
 
 /*******************************************************************************
  *
@@ -265,7 +279,7 @@ AcpiRemoveNotifyHandler (
     ACPI_OPERAND_OBJECT     *ObjDesc;
     ACPI_OPERAND_OBJECT     *HandlerObj;
     ACPI_OPERAND_OBJECT     *PreviousHandlerObj;
-    ACPI_STATUS             Status;
+    ACPI_STATUS             Status = AE_OK;
     UINT32                  i;
 
 
@@ -280,18 +294,6 @@ AcpiRemoveNotifyHandler (
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
-#ifdef _UNDER_DEVELOPMENT
-    /* Make sure all deferred tasks are completed */
-
-    AcpiOsWaitEventsComplete (NULL);
-#endif
-
-    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
     /* Root Object. Global handlers are removed here */
 
     if (Device == ACPI_ROOT_OBJECT)
@@ -300,6 +302,12 @@ AcpiRemoveNotifyHandler (
         {
             if (HandlerType & (i+1))
             {
+                Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
+                if (ACPI_FAILURE (Status))
+                {
+                    return_ACPI_STATUS (Status);
+                }
+
                 if (!AcpiGbl_GlobalNotify[i].Handler ||
                     (AcpiGbl_GlobalNotify[i].Handler != Handler))
                 {
@@ -312,18 +320,23 @@ AcpiRemoveNotifyHandler (
 
                 AcpiGbl_GlobalNotify[i].Handler = NULL;
                 AcpiGbl_GlobalNotify[i].Context = NULL;
+
+                (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+
+                /* Make sure all deferred notify tasks are completed */
+
+                AcpiOsWaitEventsComplete ();
             }
         }
 
-        goto UnlockAndExit;
+        return_ACPI_STATUS (AE_OK);
     }
 
     /* All other objects: Are Notifies allowed on this object? */
 
     if (!AcpiEvIsNotifyObject (Node))
     {
-        Status = AE_TYPE;
-        goto UnlockAndExit;
+        return_ACPI_STATUS (AE_TYPE);
     }
 
     /* Must have an existing internal object */
@@ -331,8 +344,7 @@ AcpiRemoveNotifyHandler (
     ObjDesc = AcpiNsGetAttachedObject (Node);
     if (!ObjDesc)
     {
-        Status = AE_NOT_EXIST;
-        goto UnlockAndExit;
+        return_ACPI_STATUS (AE_NOT_EXIST);
     }
 
     /* Internal object exists. Find the handler and remove it */
@@ -341,6 +353,12 @@ AcpiRemoveNotifyHandler (
     {
         if (HandlerType & (i+1))
         {
+            Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
+            if (ACPI_FAILURE (Status))
+            {
+                return_ACPI_STATUS (Status);
+            }
+
             HandlerObj = ObjDesc->CommonNotify.NotifyList[i];
             PreviousHandlerObj = NULL;
 
@@ -372,10 +390,17 @@ AcpiRemoveNotifyHandler (
                     HandlerObj->Notify.Next[i];
             }
 
+            (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+
+            /* Make sure all deferred notify tasks are completed */
+
+            AcpiOsWaitEventsComplete ();
             AcpiUtRemoveReference (HandlerObj);
         }
     }
 
+    return_ACPI_STATUS (Status);
+
 
 UnlockAndExit:
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
@@ -435,6 +460,173 @@ ACPI_EXPORT_SYMBOL (AcpiInstallExceptionHandler)
 
 
 #if (!ACPI_REDUCED_HARDWARE)
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiInstallSciHandler
+ *
+ * PARAMETERS:  Address             - Address of the handler
+ *              Context             - Value passed to the handler on each SCI
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for a System Control Interrupt.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiInstallSciHandler (
+    ACPI_SCI_HANDLER        Address,
+    void                    *Context)
+{
+    ACPI_SCI_HANDLER_INFO   *NewSciHandler;
+    ACPI_SCI_HANDLER_INFO   *SciHandler;
+    ACPI_CPU_FLAGS          Flags;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (AcpiInstallSciHandler);
+
+
+    if (!Address)
+    {
+        return_ACPI_STATUS (AE_BAD_PARAMETER);
+    }
+
+    /* Allocate and init a handler object */
+
+    NewSciHandler = ACPI_ALLOCATE (sizeof (ACPI_SCI_HANDLER_INFO));
+    if (!NewSciHandler)
+    {
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    NewSciHandler->Address = Address;
+    NewSciHandler->Context = Context;
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_EVENTS);
+    if (ACPI_FAILURE (Status))
+    {
+        goto Exit;
+    }
+
+    /* Lock list during installation */
+
+    Flags = AcpiOsAcquireLock (AcpiGbl_GpeLock);
+    SciHandler = AcpiGbl_SciHandlerList;
+
+    /* Ensure handler does not already exist */
+
+    while (SciHandler)
+    {
+        if (Address == SciHandler->Address)
+        {
+            Status = AE_ALREADY_EXISTS;
+            goto UnlockAndExit;
+        }
+
+        SciHandler = SciHandler->Next;
+    }
+
+    /* Install the new handler into the global list (at head) */
+
+    NewSciHandler->Next = AcpiGbl_SciHandlerList;
+    AcpiGbl_SciHandlerList = NewSciHandler;
+
+
+UnlockAndExit:
+
+    AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
+    (void) AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
+
+Exit:
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_FREE (NewSciHandler);
+    }
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiInstallSciHandler)
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiRemoveSciHandler
+ *
+ * PARAMETERS:  Address             - Address of the handler
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Remove a handler for a System Control Interrupt.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiRemoveSciHandler (
+    ACPI_SCI_HANDLER        Address)
+{
+    ACPI_SCI_HANDLER_INFO   *PrevSciHandler;
+    ACPI_SCI_HANDLER_INFO   *NextSciHandler;
+    ACPI_CPU_FLAGS          Flags;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (AcpiRemoveSciHandler);
+
+
+    if (!Address)
+    {
+        return_ACPI_STATUS (AE_BAD_PARAMETER);
+    }
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_EVENTS);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Remove the SCI handler with lock */
+
+    Flags = AcpiOsAcquireLock (AcpiGbl_GpeLock);
+
+    PrevSciHandler = NULL;
+    NextSciHandler = AcpiGbl_SciHandlerList;
+    while (NextSciHandler)
+    {
+        if (NextSciHandler->Address == Address)
+        {
+            /* Unlink and free the SCI handler info block */
+
+            if (PrevSciHandler)
+            {
+                PrevSciHandler->Next = NextSciHandler->Next;
+            }
+            else
+            {
+                AcpiGbl_SciHandlerList = NextSciHandler->Next;
+            }
+
+            AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
+            ACPI_FREE (NextSciHandler);
+            goto UnlockAndExit;
+        }
+
+        PrevSciHandler = NextSciHandler;
+        NextSciHandler = NextSciHandler->Next;
+    }
+
+    AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
+    Status = AE_NOT_EXIST;
+
+
+UnlockAndExit:
+    (void) AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiRemoveSciHandler)
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiInstallGlobalEventHandler
@@ -536,9 +728,9 @@ AcpiInstallFixedEventHandler (
         return_ACPI_STATUS (Status);
     }
 
-    /* Don't allow two handlers. */
+    /* Do not allow multiple handlers */
 
-    if (NULL != AcpiGbl_FixedEventHandlers[Event].Handler)
+    if (AcpiGbl_FixedEventHandlers[Event].Handler)
     {
         Status = AE_ALREADY_EXISTS;
         goto Cleanup;
@@ -552,7 +744,9 @@ AcpiInstallFixedEventHandler (
     Status = AcpiEnableEvent (Event, 0);
     if (ACPI_FAILURE (Status))
     {
-        ACPI_WARNING ((AE_INFO, "Could not enable fixed event 0x%X", Event));
+        ACPI_WARNING ((AE_INFO,
+            "Could not enable fixed event - %s (%u)",
+            AcpiUtGetEventName (Event), Event));
 
         /* Remove the handler */
 
@@ -562,7 +756,8 @@ AcpiInstallFixedEventHandler (
     else
     {
         ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-            "Enabled fixed event %X, Handler=%p\n", Event, Handler));
+            "Enabled fixed event %s (%X), Handler=%p\n",
+            AcpiUtGetEventName (Event), Event, Handler));
     }
 
 
@@ -623,11 +818,14 @@ AcpiRemoveFixedEventHandler (
     if (ACPI_FAILURE (Status))
     {
         ACPI_WARNING ((AE_INFO,
-            "Could not write to fixed event enable register 0x%X", Event));
+            "Could not disable fixed event - %s (%u)",
+            AcpiUtGetEventName (Event), Event));
     }
     else
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Disabled fixed event %X\n", Event));
+        ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+            "Disabled fixed event - %s (%X)\n",
+            AcpiUtGetEventName (Event), Event));
     }
 
     (void) AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
@@ -639,27 +837,31 @@ ACPI_EXPORT_SYMBOL (AcpiRemoveFixedEventHandler)
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiInstallGpeHandler
+ * FUNCTION:    AcpiEvInstallGpeHandler
  *
  * PARAMETERS:  GpeDevice       - Namespace node for the GPE (NULL for FADT
  *                                defined GPEs)
  *              GpeNumber       - The GPE number within the GPE block
  *              Type            - Whether this GPE should be treated as an
  *                                edge- or level-triggered interrupt.
+ *              IsRawHandler    - Whether this GPE should be handled using
+ *                                the special GPE handler mode.
  *              Address         - Address of the handler
  *              Context         - Value passed to the handler on each GPE
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Install a handler for a General Purpose Event.
+ * DESCRIPTION: Internal function to install a handler for a General Purpose
+ *              Event.
  *
  ******************************************************************************/
 
-ACPI_STATUS
-AcpiInstallGpeHandler (
+static ACPI_STATUS
+AcpiEvInstallGpeHandler (
     ACPI_HANDLE             GpeDevice,
     UINT32                  GpeNumber,
     UINT32                  Type,
+    BOOLEAN                 IsRawHandler,
     ACPI_GPE_HANDLER        Address,
     void                    *Context)
 {
@@ -669,7 +871,7 @@ AcpiInstallGpeHandler (
     ACPI_CPU_FLAGS          Flags;
 
 
-    ACPI_FUNCTION_TRACE (AcpiInstallGpeHandler);
+    ACPI_FUNCTION_TRACE (EvInstallGpeHandler);
 
 
     /* Parameter validation */
@@ -707,8 +909,10 @@ AcpiInstallGpeHandler (
 
     /* Make sure that there isn't a handler there already */
 
-    if ((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) ==
-            ACPI_GPE_DISPATCH_HANDLER)
+    if ((ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+            ACPI_GPE_DISPATCH_HANDLER) ||
+        (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+            ACPI_GPE_DISPATCH_RAW_HANDLER))
     {
         Status = AE_ALREADY_EXISTS;
         goto FreeAndExit;
@@ -725,8 +929,10 @@ AcpiInstallGpeHandler (
      * automatically during initialization, in which case it has to be
      * disabled now to avoid spurious execution of the handler.
      */
-    if (((Handler->OriginalFlags & ACPI_GPE_DISPATCH_METHOD) ||
-         (Handler->OriginalFlags & ACPI_GPE_DISPATCH_NOTIFY)) &&
+    if (((ACPI_GPE_DISPATCH_TYPE (Handler->OriginalFlags) ==
+            ACPI_GPE_DISPATCH_METHOD) ||
+         (ACPI_GPE_DISPATCH_TYPE (Handler->OriginalFlags) ==
+            ACPI_GPE_DISPATCH_NOTIFY)) &&
         GpeEventInfo->RuntimeCount)
     {
         Handler->OriginallyEnabled = TRUE;
@@ -747,7 +953,8 @@ AcpiInstallGpeHandler (
     /* Setup up dispatch flags to indicate handler (vs. method/notify) */
 
     GpeEventInfo->Flags &= ~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);
-    GpeEventInfo->Flags |= (UINT8) (Type | ACPI_GPE_DISPATCH_HANDLER);
+    GpeEventInfo->Flags |= (UINT8) (Type | (IsRawHandler ?
+        ACPI_GPE_DISPATCH_RAW_HANDLER : ACPI_GPE_DISPATCH_HANDLER));
 
     AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
 
@@ -762,9 +969,89 @@ FreeAndExit:
     goto UnlockAndExit;
 }
 
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiInstallGpeHandler
+ *
+ * PARAMETERS:  GpeDevice       - Namespace node for the GPE (NULL for FADT
+ *                                defined GPEs)
+ *              GpeNumber       - The GPE number within the GPE block
+ *              Type            - Whether this GPE should be treated as an
+ *                                edge- or level-triggered interrupt.
+ *              Address         - Address of the handler
+ *              Context         - Value passed to the handler on each GPE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for a General Purpose Event.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiInstallGpeHandler (
+    ACPI_HANDLE             GpeDevice,
+    UINT32                  GpeNumber,
+    UINT32                  Type,
+    ACPI_GPE_HANDLER        Address,
+    void                    *Context)
+{
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (AcpiInstallGpeHandler);
+
+
+    Status = AcpiEvInstallGpeHandler (GpeDevice, GpeNumber, Type,
+        FALSE, Address, Context);
+
+    return_ACPI_STATUS (Status);
+}
+
 ACPI_EXPORT_SYMBOL (AcpiInstallGpeHandler)
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiInstallGpeRawHandler
+ *
+ * PARAMETERS:  GpeDevice       - Namespace node for the GPE (NULL for FADT
+ *                                defined GPEs)
+ *              GpeNumber       - The GPE number within the GPE block
+ *              Type            - Whether this GPE should be treated as an
+ *                                edge- or level-triggered interrupt.
+ *              Address         - Address of the handler
+ *              Context         - Value passed to the handler on each GPE
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Install a handler for a General Purpose Event.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiInstallGpeRawHandler (
+    ACPI_HANDLE             GpeDevice,
+    UINT32                  GpeNumber,
+    UINT32                  Type,
+    ACPI_GPE_HANDLER        Address,
+    void                    *Context)
+{
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (AcpiInstallGpeRawHandler);
+
+
+    Status = AcpiEvInstallGpeHandler (GpeDevice, GpeNumber, Type,
+        TRUE, Address, Context);
+
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiInstallGpeRawHandler)
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiRemoveGpeHandler
@@ -821,8 +1108,10 @@ AcpiRemoveGpeHandler (
 
     /* Make sure that a handler is indeed installed */
 
-    if ((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) !=
-            ACPI_GPE_DISPATCH_HANDLER)
+    if ((ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) !=
+            ACPI_GPE_DISPATCH_HANDLER) &&
+        (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) !=
+            ACPI_GPE_DISPATCH_RAW_HANDLER))
     {
         Status = AE_NOT_EXIST;
         goto UnlockAndExit;
@@ -839,6 +1128,7 @@ AcpiRemoveGpeHandler (
     /* Remove the handler */
 
     Handler = GpeEventInfo->Dispatch.Handler;
+    GpeEventInfo->Dispatch.Handler = NULL;
 
     /* Restore Method node (if any), set dispatch flags */
 
@@ -852,16 +1142,26 @@ AcpiRemoveGpeHandler (
      * enabled, it should be enabled at this point to restore the
      * post-initialization configuration.
      */
-    if ((Handler->OriginalFlags & ACPI_GPE_DISPATCH_METHOD) &&
+    if (((ACPI_GPE_DISPATCH_TYPE (Handler->OriginalFlags) ==
+            ACPI_GPE_DISPATCH_METHOD) ||
+         (ACPI_GPE_DISPATCH_TYPE (Handler->OriginalFlags) ==
+            ACPI_GPE_DISPATCH_NOTIFY)) &&
         Handler->OriginallyEnabled)
     {
         (void) AcpiEvAddGpeReference (GpeEventInfo);
     }
 
+    AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
+    (void) AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
+
+    /* Make sure all deferred GPE tasks are completed */
+
+    AcpiOsWaitEventsComplete ();
+
     /* Now we can free the handler object */
 
     ACPI_FREE (Handler);
-
+    return_ACPI_STATUS (Status);
 
 UnlockAndExit:
     AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
@@ -910,7 +1210,7 @@ AcpiAcquireGlobalLock (
     AcpiExEnterInterpreter ();
 
     Status = AcpiExAcquireMutexObject (Timeout,
-                AcpiGbl_GlobalLockMutex, AcpiOsGetThreadId ());
+        AcpiGbl_GlobalLockMutex, AcpiOsGetThreadId ());
 
     if (ACPI_SUCCESS (Status))
     {
diff --git a/usr/src/uts/intel/io/acpica/events/evxfevnt.c b/usr/src/uts/intel/io/acpica/events/evxfevnt.c
index 254214af19..9991751c67 100644
--- a/usr/src/uts/intel/io/acpica/events/evxfevnt.c
+++ b/usr/src/uts/intel/io/acpica/events/evxfevnt.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,7 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EVXFEVNT_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
@@ -77,16 +76,24 @@ AcpiEnable (
 
     /* ACPI tables must be present */
 
-    if (!AcpiTbTablesLoaded ())
+    if (AcpiGbl_FadtIndex == ACPI_INVALID_TABLE_INDEX)
     {
         return_ACPI_STATUS (AE_NO_ACPI_TABLES);
     }
 
+    /* If the Hardware Reduced flag is set, machine is always in acpi mode */
+
+    if (AcpiGbl_ReducedHardware)
+    {
+        return_ACPI_STATUS (AE_OK);
+    }
+
     /* Check current mode */
 
     if (AcpiHwGetMode() == ACPI_SYS_MODE_ACPI)
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "System is already in ACPI mode\n"));
+        ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
+            "System is already in ACPI mode\n"));
     }
     else
     {
@@ -131,6 +138,13 @@ AcpiDisable (
     ACPI_FUNCTION_TRACE (AcpiDisable);
 
 
+    /* If the Hardware Reduced flag is set, machine is always in acpi mode */
+
+    if (AcpiGbl_ReducedHardware)
+    {
+        return_ACPI_STATUS (AE_OK);
+    }
+
     if (AcpiHwGetMode() == ACPI_SYS_MODE_LEGACY)
     {
         ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
@@ -149,7 +163,8 @@ AcpiDisable (
             return_ACPI_STATUS (Status);
         }
 
-        ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "ACPI mode disabled\n"));
+        ACPI_DEBUG_PRINT ((ACPI_DB_INIT,
+            "ACPI mode disabled\n"));
     }
 
     return_ACPI_STATUS (Status);
@@ -195,8 +210,8 @@ AcpiEnableEvent (
      * register bit)
      */
     Status = AcpiWriteBitRegister (
-                AcpiGbl_FixedEventInfo[Event].EnableRegisterId,
-                ACPI_ENABLE_EVENT);
+        AcpiGbl_FixedEventInfo[Event].EnableRegisterId,
+        ACPI_ENABLE_EVENT);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -205,7 +220,7 @@ AcpiEnableEvent (
     /* Make sure that the hardware responded */
 
     Status = AcpiReadBitRegister (
-                AcpiGbl_FixedEventInfo[Event].EnableRegisterId, &Value);
+        AcpiGbl_FixedEventInfo[Event].EnableRegisterId, &Value);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -261,15 +276,15 @@ AcpiDisableEvent (
      * register bit)
      */
     Status = AcpiWriteBitRegister (
-                AcpiGbl_FixedEventInfo[Event].EnableRegisterId,
-                ACPI_DISABLE_EVENT);
+        AcpiGbl_FixedEventInfo[Event].EnableRegisterId,
+        ACPI_DISABLE_EVENT);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
     }
 
     Status = AcpiReadBitRegister (
-                AcpiGbl_FixedEventInfo[Event].EnableRegisterId, &Value);
+        AcpiGbl_FixedEventInfo[Event].EnableRegisterId, &Value);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -322,8 +337,8 @@ AcpiClearEvent (
      * register bit)
      */
     Status = AcpiWriteBitRegister (
-                AcpiGbl_FixedEventInfo[Event].StatusRegisterId,
-                ACPI_CLEAR_STATUS);
+        AcpiGbl_FixedEventInfo[Event].StatusRegisterId,
+        ACPI_CLEAR_STATUS);
 
     return_ACPI_STATUS (Status);
 }
@@ -350,7 +365,9 @@ AcpiGetEventStatus (
     UINT32                  Event,
     ACPI_EVENT_STATUS       *EventStatus)
 {
-    ACPI_STATUS             Status = AE_OK;
+    ACPI_STATUS             Status;
+    ACPI_EVENT_STATUS       LocalEventStatus = 0;
+    UINT32                  InByte;
 
 
     ACPI_FUNCTION_TRACE (AcpiGetEventStatus);
@@ -368,12 +385,44 @@ AcpiGetEventStatus (
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
-    /* Get the status of the requested fixed event */
+    /* Fixed event currently can be dispatched? */
+
+    if (AcpiGbl_FixedEventHandlers[Event].Handler)
+    {
+        LocalEventStatus |= ACPI_EVENT_FLAG_HAS_HANDLER;
+    }
+
+    /* Fixed event currently enabled? */
+
+    Status = AcpiReadBitRegister (
+        AcpiGbl_FixedEventInfo[Event].EnableRegisterId, &InByte);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    if (InByte)
+    {
+        LocalEventStatus |=
+            (ACPI_EVENT_FLAG_ENABLED | ACPI_EVENT_FLAG_ENABLE_SET);
+    }
+
+    /* Fixed event currently active? */
 
     Status = AcpiReadBitRegister (
-                AcpiGbl_FixedEventInfo[Event].StatusRegisterId, EventStatus);
+        AcpiGbl_FixedEventInfo[Event].StatusRegisterId, &InByte);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
 
-    return_ACPI_STATUS (Status);
+    if (InByte)
+    {
+        LocalEventStatus |= ACPI_EVENT_FLAG_STATUS_SET;
+    }
+
+    (*EventStatus) = LocalEventStatus;
+    return_ACPI_STATUS (AE_OK);
 }
 
 ACPI_EXPORT_SYMBOL (AcpiGetEventStatus)
diff --git a/usr/src/uts/intel/io/acpica/events/evxfgpe.c b/usr/src/uts/intel/io/acpica/events/evxfgpe.c
index c0dd88c777..1d467d9abc 100644
--- a/usr/src/uts/intel/io/acpica/events/evxfgpe.c
+++ b/usr/src/uts/intel/io/acpica/events/evxfgpe.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,7 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EVXFGPE_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
@@ -83,7 +82,7 @@ AcpiUpdateAllGpes (
     ACPI_STATUS             Status;
 
 
-    ACPI_FUNCTION_TRACE (AcpiUpdateGpes);
+    ACPI_FUNCTION_TRACE (AcpiUpdateAllGpes);
 
 
     Status = AcpiUtAcquireMutex (ACPI_MTX_EVENTS);
@@ -140,12 +139,23 @@ AcpiEnableGpe (
 
     Flags = AcpiOsAcquireLock (AcpiGbl_GpeLock);
 
-    /* Ensure that we have a valid GPE number */
-
+    /*
+     * Ensure that we have a valid GPE number and that there is some way
+     * of handling the GPE (handler or a GPE method). In other words, we
+     * won't allow a valid GPE to be enabled if there is no way to handle it.
+     */
     GpeEventInfo = AcpiEvGetGpeEventInfo (GpeDevice, GpeNumber);
     if (GpeEventInfo)
     {
-        Status = AcpiEvAddGpeReference (GpeEventInfo);
+        if (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) !=
+            ACPI_GPE_DISPATCH_NONE)
+        {
+            Status = AcpiEvAddGpeReference (GpeEventInfo);
+        }
+        else
+        {
+            Status = AE_NO_HANDLER;
+        }
     }
 
     AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
@@ -211,12 +221,21 @@ ACPI_EXPORT_SYMBOL (AcpiDisableGpe)
  * RETURN:      Status
  *
  * DESCRIPTION: Enable or disable an individual GPE. This function bypasses
- *              the reference count mechanism used in the AcpiEnableGpe and
- *              AcpiDisableGpe interfaces -- and should be used with care.
- *
- * Note: Typically used to disable a runtime GPE for short period of time,
- * then re-enable it, without disturbing the existing reference counts. This
- * is useful, for example, in the Embedded Controller (EC) driver.
+ *              the reference count mechanism used in the AcpiEnableGpe(),
+ *              AcpiDisableGpe() interfaces.
+ *              This API is typically used by the GPE raw handler mode driver
+ *              to switch between the polling mode and the interrupt mode after
+ *              the driver has enabled the GPE.
+ *              The APIs should be invoked in this order:
+ *               AcpiEnableGpe()              <- Ensure the reference count > 0
+ *               AcpiSetGpe(ACPI_GPE_DISABLE) <- Enter polling mode
+ *               AcpiSetGpe(ACPI_GPE_ENABLE)  <- Leave polling mode
+ *               AcpiDisableGpe()             <- Decrease the reference count
+ *
+ * Note: If a GPE is shared by 2 silicon components, then both the drivers
+ *       should support GPE polling mode or disabling the GPE for long period
+ *       for one driver may break the other. So use it with care since all
+ *       firmware _Lxx/_Exx handlers currently rely on the GPE interrupt mode.
  *
  ******************************************************************************/
 
@@ -250,14 +269,17 @@ AcpiSetGpe (
     switch (Action)
     {
     case ACPI_GPE_ENABLE:
-        Status = AcpiEvEnableGpe (GpeEventInfo);
+
+        Status = AcpiHwLowSetGpe (GpeEventInfo, ACPI_GPE_ENABLE);
         break;
 
     case ACPI_GPE_DISABLE:
+
         Status = AcpiHwLowSetGpe (GpeEventInfo, ACPI_GPE_DISABLE);
         break;
 
     default:
+
         Status = AE_BAD_PARAMETER;
         break;
     }
@@ -270,6 +292,60 @@ UnlockAndExit:
 ACPI_EXPORT_SYMBOL (AcpiSetGpe)
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiMarkGpeForWake
+ *
+ * PARAMETERS:  GpeDevice           - Parent GPE Device. NULL for GPE0/GPE1
+ *              GpeNumber           - GPE level within the GPE block
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Mark a GPE as having the ability to wake the system. Simply
+ *              sets the ACPI_GPE_CAN_WAKE flag.
+ *
+ * Some potential callers of AcpiSetupGpeForWake may know in advance that
+ * there won't be any notify handlers installed for device wake notifications
+ * from the given GPE (one example is a button GPE in Linux). For these cases,
+ * AcpiMarkGpeForWake should be used instead of AcpiSetupGpeForWake.
+ * This will set the ACPI_GPE_CAN_WAKE flag for the GPE without trying to
+ * setup implicit wake notification for it (since there's no handler method).
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiMarkGpeForWake (
+    ACPI_HANDLE             GpeDevice,
+    UINT32                  GpeNumber)
+{
+    ACPI_GPE_EVENT_INFO     *GpeEventInfo;
+    ACPI_STATUS             Status = AE_BAD_PARAMETER;
+    ACPI_CPU_FLAGS          Flags;
+
+
+    ACPI_FUNCTION_TRACE (AcpiMarkGpeForWake);
+
+
+    Flags = AcpiOsAcquireLock (AcpiGbl_GpeLock);
+
+    /* Ensure that we have a valid GPE number */
+
+    GpeEventInfo = AcpiEvGetGpeEventInfo (GpeDevice, GpeNumber);
+    if (GpeEventInfo)
+    {
+        /* Mark the GPE as a possible wake event */
+
+        GpeEventInfo->Flags |= ACPI_GPE_CAN_WAKE;
+        Status = AE_OK;
+    }
+
+    AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiMarkGpeForWake)
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiSetupGpeForWake
@@ -295,9 +371,11 @@ AcpiSetupGpeForWake (
     ACPI_HANDLE             GpeDevice,
     UINT32                  GpeNumber)
 {
-    ACPI_STATUS             Status = AE_BAD_PARAMETER;
+    ACPI_STATUS             Status;
     ACPI_GPE_EVENT_INFO     *GpeEventInfo;
     ACPI_NAMESPACE_NODE     *DeviceNode;
+    ACPI_GPE_NOTIFY_INFO    *Notify;
+    ACPI_GPE_NOTIFY_INFO    *NewNotify;
     ACPI_CPU_FLAGS          Flags;
 
 
@@ -333,32 +411,88 @@ AcpiSetupGpeForWake (
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
+    /*
+     * Allocate a new notify object up front, in case it is needed.
+     * Memory allocation while holding a spinlock is a big no-no
+     * on some hosts.
+     */
+    NewNotify = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_GPE_NOTIFY_INFO));
+    if (!NewNotify)
+    {
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
     Flags = AcpiOsAcquireLock (AcpiGbl_GpeLock);
 
     /* Ensure that we have a valid GPE number */
 
     GpeEventInfo = AcpiEvGetGpeEventInfo (GpeDevice, GpeNumber);
-    if (GpeEventInfo)
+    if (!GpeEventInfo)
+    {
+        Status = AE_BAD_PARAMETER;
+        goto UnlockAndExit;
+    }
+
+    /*
+     * If there is no method or handler for this GPE, then the
+     * WakeDevice will be notified whenever this GPE fires. This is
+     * known as an "implicit notify". Note: The GPE is assumed to be
+     * level-triggered (for windows compatibility).
+     */
+    if (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+        ACPI_GPE_DISPATCH_NONE)
     {
         /*
-         * If there is no method or handler for this GPE, then the
-         * WakeDevice will be notified whenever this GPE fires (aka
-         * "implicit notify") Note: The GPE is assumed to be
-         * level-triggered (for windows compatibility).
+         * This is the first device for implicit notify on this GPE.
+         * Just set the flags here, and enter the NOTIFY block below.
          */
-        if ((GpeEventInfo->Flags & ACPI_GPE_DISPATCH_MASK) ==
-                ACPI_GPE_DISPATCH_NONE)
+        GpeEventInfo->Flags =
+            (ACPI_GPE_DISPATCH_NOTIFY | ACPI_GPE_LEVEL_TRIGGERED);
+    }
+
+    /*
+     * If we already have an implicit notify on this GPE, add
+     * this device to the notify list.
+     */
+    if (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) ==
+        ACPI_GPE_DISPATCH_NOTIFY)
+    {
+        /* Ensure that the device is not already in the list */
+
+        Notify = GpeEventInfo->Dispatch.NotifyList;
+        while (Notify)
         {
-            GpeEventInfo->Flags =
-                (ACPI_GPE_DISPATCH_NOTIFY | ACPI_GPE_LEVEL_TRIGGERED);
-            GpeEventInfo->Dispatch.DeviceNode = DeviceNode;
+            if (Notify->DeviceNode == DeviceNode)
+            {
+                Status = AE_ALREADY_EXISTS;
+                goto UnlockAndExit;
+            }
+            Notify = Notify->Next;
         }
 
-        GpeEventInfo->Flags |= ACPI_GPE_CAN_WAKE;
-        Status = AE_OK;
+        /* Add this device to the notify list for this GPE */
+
+        NewNotify->DeviceNode = DeviceNode;
+        NewNotify->Next = GpeEventInfo->Dispatch.NotifyList;
+        GpeEventInfo->Dispatch.NotifyList = NewNotify;
+        NewNotify = NULL;
     }
 
+    /* Mark the GPE as a possible wake event */
+
+    GpeEventInfo->Flags |= ACPI_GPE_CAN_WAKE;
+    Status = AE_OK;
+
+
+UnlockAndExit:
     AcpiOsReleaseLock (AcpiGbl_GpeLock, Flags);
+
+    /* Delete the notify object if it was not used above */
+
+    if (NewNotify)
+    {
+        ACPI_FREE (NewNotify);
+    }
     return_ACPI_STATUS (Status);
 }
 
@@ -422,21 +556,24 @@ AcpiSetGpeWakeMask (
         goto UnlockAndExit;
     }
 
-    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo, GpeRegisterInfo);
+    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo);
 
     /* Perform the action */
 
     switch (Action)
     {
     case ACPI_GPE_ENABLE:
+
         ACPI_SET_BIT (GpeRegisterInfo->EnableForWake, (UINT8) RegisterBit);
         break;
 
     case ACPI_GPE_DISABLE:
+
         ACPI_CLEAR_BIT (GpeRegisterInfo->EnableForWake, (UINT8) RegisterBit);
         break;
 
     default:
+
         ACPI_ERROR ((AE_INFO, "%u, Invalid action", Action));
         Status = AE_BAD_PARAMETER;
         break;
@@ -674,6 +811,44 @@ AcpiEnableAllRuntimeGpes (
 ACPI_EXPORT_SYMBOL (AcpiEnableAllRuntimeGpes)
 
 
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiEnableAllWakeupGpes
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Enable all "wakeup" GPEs and disable all of the other GPEs, in
+ *              all GPE blocks.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiEnableAllWakeupGpes (
+    void)
+{
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (AcpiEnableAllWakeupGpes);
+
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_EVENTS);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    Status = AcpiHwEnableAllWakeupGpes ();
+    (void) AcpiUtReleaseMutex (ACPI_MTX_EVENTS);
+
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiEnableAllWakeupGpes)
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiInstallGpeBlock
@@ -716,7 +891,7 @@ AcpiInstallGpeBlock (
     Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
     if (ACPI_FAILURE (Status))
     {
-        return (Status);
+        return_ACPI_STATUS (Status);
     }
 
     Node = AcpiNsValidateHandle (GpeDevice);
@@ -726,12 +901,27 @@ AcpiInstallGpeBlock (
         goto UnlockAndExit;
     }
 
+    /* Validate the parent device */
+
+    if (Node->Type != ACPI_TYPE_DEVICE)
+    {
+        Status = AE_TYPE;
+        goto UnlockAndExit;
+    }
+
+    if (Node->Object)
+    {
+        Status = AE_ALREADY_EXISTS;
+        goto UnlockAndExit;
+    }
+
     /*
      * For user-installed GPE Block Devices, the GpeBlockBaseNumber
      * is always zero
      */
-    Status = AcpiEvCreateGpeBlock (Node, GpeBlockAddress, RegisterCount,
-                0, InterruptNumber, &GpeBlock);
+    Status = AcpiEvCreateGpeBlock (Node, GpeBlockAddress->Address,
+        GpeBlockAddress->SpaceId, RegisterCount,
+        0, InterruptNumber, &GpeBlock);
     if (ACPI_FAILURE (Status))
     {
         goto UnlockAndExit;
@@ -809,7 +999,7 @@ AcpiRemoveGpeBlock (
     Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
     if (ACPI_FAILURE (Status))
     {
-        return (Status);
+        return_ACPI_STATUS (Status);
     }
 
     Node = AcpiNsValidateHandle (GpeDevice);
@@ -819,6 +1009,14 @@ AcpiRemoveGpeBlock (
         goto UnlockAndExit;
     }
 
+    /* Validate the parent device */
+
+    if (Node->Type != ACPI_TYPE_DEVICE)
+    {
+        Status = AE_TYPE;
+        goto UnlockAndExit;
+    }
+
     /* Get the DeviceObject attached to the node */
 
     ObjDesc = AcpiNsGetAttachedObject (Node);
diff --git a/usr/src/uts/intel/io/acpica/events/evxfregn.c b/usr/src/uts/intel/io/acpica/events/evxfregn.c
index 493df9217d..8537640d6c 100644
--- a/usr/src/uts/intel/io/acpica/events/evxfregn.c
+++ b/usr/src/uts/intel/io/acpica/events/evxfregn.c
@@ -6,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,7 +42,7 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EVXFREGN_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
@@ -114,47 +114,16 @@ AcpiInstallAddressSpaceHandler (
 
     /* Install the handler for all Regions for this Space ID */
 
-    Status = AcpiEvInstallSpaceHandler (Node, SpaceId, Handler, Setup, Context);
+    Status = AcpiEvInstallSpaceHandler (
+        Node, SpaceId, Handler, Setup, Context);
     if (ACPI_FAILURE (Status))
     {
         goto UnlockAndExit;
     }
 
-    /*
-     * For the default SpaceIDs, (the IDs for which there are default region handlers
-     * installed) Only execute the _REG methods if the global initialization _REG
-     * methods have already been run (via AcpiInitializeObjects). In other words,
-     * we will defer the execution of the _REG methods for these SpaceIDs until
-     * execution of AcpiInitializeObjects. This is done because we need the handlers
-     * for the default spaces (mem/io/pci/table) to be installed before we can run
-     * any control methods (or _REG methods). There is known BIOS code that depends
-     * on this.
-     *
-     * For all other SpaceIDs, we can safely execute the _REG methods immediately.
-     * This means that for IDs like EmbeddedController, this function should be called
-     * only after AcpiEnableSubsystem has been called.
-     */
-    switch (SpaceId)
-    {
-    case ACPI_ADR_SPACE_SYSTEM_MEMORY:
-    case ACPI_ADR_SPACE_SYSTEM_IO:
-    case ACPI_ADR_SPACE_PCI_CONFIG:
-    case ACPI_ADR_SPACE_DATA_TABLE:
-
-        if (!AcpiGbl_RegMethodsExecuted)
-        {
-            /* We will defer execution of the _REG methods for this space */
-            goto UnlockAndExit;
-        }
-        break;
-
-    default:
-        break;
-    }
-
     /* Run all _REG methods for this address space */
 
-    Status = AcpiEvExecuteRegMethods (Node, SpaceId);
+    AcpiEvExecuteRegMethods (Node, SpaceId, ACPI_REG_CONNECT);
 
 
 UnlockAndExit:
@@ -233,8 +202,8 @@ AcpiRemoveAddressSpaceHandler (
 
     /* Find the address handler the user requested */
 
-    HandlerObj = ObjDesc->Device.Handler;
-    LastObjPtr = &ObjDesc->Device.Handler;
+    HandlerObj = ObjDesc->CommonNotify.Handler;
+    LastObjPtr = &ObjDesc->CommonNotify.Handler;
     while (HandlerObj)
     {
         /* We have a handler, see if user requested this one */
@@ -310,4 +279,3 @@ UnlockAndExit:
 }
 
 ACPI_EXPORT_SYMBOL (AcpiRemoveAddressSpaceHandler)
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exconcat.c b/usr/src/uts/intel/io/acpica/executer/exconcat.c
new file mode 100644
index 0000000000..49b279ad05
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/executer/exconcat.c
@@ -0,0 +1,460 @@
+/******************************************************************************
+ *
+ * Module Name: exconcat - Concatenate-type AML operators
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acinterp.h"
+#include "amlresrc.h"
+
+
+#define _COMPONENT          ACPI_EXECUTER
+        ACPI_MODULE_NAME    ("exconcat")
+
+/* Local Prototypes */
+
+static ACPI_STATUS
+AcpiExConvertToObjectTypeString (
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_OPERAND_OBJECT     **ResultDesc);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExDoConcatenate
+ *
+ * PARAMETERS:  Operand0            - First source object
+ *              Operand1            - Second source object
+ *              ActualReturnDesc    - Where to place the return object
+ *              WalkState           - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Concatenate two objects with the ACPI-defined conversion
+ *              rules as necessary.
+ * NOTE:
+ * Per the ACPI spec (up to 6.1), Concatenate only supports Integer,
+ * String, and Buffer objects. However, we support all objects here
+ * as an extension. This improves the usefulness of both Concatenate
+ * and the Printf/Fprintf macros. The extension returns a string
+ * describing the object type for the other objects.
+ * 02/2016.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiExDoConcatenate (
+    ACPI_OPERAND_OBJECT     *Operand0,
+    ACPI_OPERAND_OBJECT     *Operand1,
+    ACPI_OPERAND_OBJECT     **ActualReturnDesc,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_OPERAND_OBJECT     *LocalOperand0 = Operand0;
+    ACPI_OPERAND_OBJECT     *LocalOperand1 = Operand1;
+    ACPI_OPERAND_OBJECT     *TempOperand1 = NULL;
+    ACPI_OPERAND_OBJECT     *ReturnDesc;
+    char                    *Buffer;
+    ACPI_OBJECT_TYPE        Operand0Type;
+    ACPI_OBJECT_TYPE        Operand1Type;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (ExDoConcatenate);
+
+
+    /* Operand 0 preprocessing */
+
+    switch (Operand0->Common.Type)
+    {
+    case ACPI_TYPE_INTEGER:
+    case ACPI_TYPE_STRING:
+    case ACPI_TYPE_BUFFER:
+
+        Operand0Type = Operand0->Common.Type;
+        break;
+
+    default:
+
+        /* For all other types, get the "object type" string */
+
+        Status = AcpiExConvertToObjectTypeString (
+            Operand0, &LocalOperand0);
+        if (ACPI_FAILURE (Status))
+        {
+            goto Cleanup;
+        }
+
+        Operand0Type = ACPI_TYPE_STRING;
+        break;
+    }
+
+    /* Operand 1 preprocessing */
+
+    switch (Operand1->Common.Type)
+    {
+    case ACPI_TYPE_INTEGER:
+    case ACPI_TYPE_STRING:
+    case ACPI_TYPE_BUFFER:
+
+        Operand1Type = Operand1->Common.Type;
+        break;
+
+    default:
+
+        /* For all other types, get the "object type" string */
+
+        Status = AcpiExConvertToObjectTypeString (
+            Operand1, &LocalOperand1);
+        if (ACPI_FAILURE (Status))
+        {
+            goto Cleanup;
+        }
+
+        Operand1Type = ACPI_TYPE_STRING;
+        break;
+    }
+
+    /*
+     * Convert the second operand if necessary. The first operand (0)
+     * determines the type of the second operand (1) (See the Data Types
+     * section of the ACPI specification). Both object types are
+     * guaranteed to be either Integer/String/Buffer by the operand
+     * resolution mechanism.
+     */
+    switch (Operand0Type)
+    {
+    case ACPI_TYPE_INTEGER:
+
+        Status = AcpiExConvertToInteger (LocalOperand1, &TempOperand1, 16);
+        break;
+
+    case ACPI_TYPE_BUFFER:
+
+        Status = AcpiExConvertToBuffer (LocalOperand1, &TempOperand1);
+        break;
+
+    case ACPI_TYPE_STRING:
+
+        switch (Operand1Type)
+        {
+        case ACPI_TYPE_INTEGER:
+        case ACPI_TYPE_STRING:
+        case ACPI_TYPE_BUFFER:
+
+            /* Other types have already been converted to string */
+
+            Status = AcpiExConvertToString (
+                LocalOperand1, &TempOperand1, ACPI_IMPLICIT_CONVERT_HEX);
+            break;
+
+        default:
+
+            Status = AE_OK;
+            break;
+        }
+        break;
+
+    default:
+
+        ACPI_ERROR ((AE_INFO, "Invalid object type: 0x%X",
+            Operand0->Common.Type));
+        Status = AE_AML_INTERNAL;
+    }
+
+    if (ACPI_FAILURE (Status))
+    {
+        goto Cleanup;
+    }
+
+    /* Take care with any newly created operand objects */
+
+    if ((LocalOperand1 != Operand1) &&
+        (LocalOperand1 != TempOperand1))
+    {
+        AcpiUtRemoveReference (LocalOperand1);
+    }
+
+    LocalOperand1 = TempOperand1;
+
+    /*
+     * Both operands are now known to be the same object type
+     * (Both are Integer, String, or Buffer), and we can now perform
+     * the concatenation.
+     *
+     * There are three cases to handle, as per the ACPI spec:
+     *
+     * 1) Two Integers concatenated to produce a new Buffer
+     * 2) Two Strings concatenated to produce a new String
+     * 3) Two Buffers concatenated to produce a new Buffer
+     */
+    switch (Operand0Type)
+    {
+    case ACPI_TYPE_INTEGER:
+
+        /* Result of two Integers is a Buffer */
+        /* Need enough buffer space for two integers */
+
+        ReturnDesc = AcpiUtCreateBufferObject (
+            (ACPI_SIZE) ACPI_MUL_2 (AcpiGbl_IntegerByteWidth));
+        if (!ReturnDesc)
+        {
+            Status = AE_NO_MEMORY;
+            goto Cleanup;
+        }
+
+        Buffer = (char *) ReturnDesc->Buffer.Pointer;
+
+        /* Copy the first integer, LSB first */
+
+        memcpy (Buffer, &Operand0->Integer.Value,
+            AcpiGbl_IntegerByteWidth);
+
+        /* Copy the second integer (LSB first) after the first */
+
+        memcpy (Buffer + AcpiGbl_IntegerByteWidth,
+            &LocalOperand1->Integer.Value, AcpiGbl_IntegerByteWidth);
+        break;
+
+    case ACPI_TYPE_STRING:
+
+        /* Result of two Strings is a String */
+
+        ReturnDesc = AcpiUtCreateStringObject (
+            ((ACPI_SIZE) LocalOperand0->String.Length +
+            LocalOperand1->String.Length));
+        if (!ReturnDesc)
+        {
+            Status = AE_NO_MEMORY;
+            goto Cleanup;
+        }
+
+        Buffer = ReturnDesc->String.Pointer;
+
+        /* Concatenate the strings */
+
+        strcpy (Buffer, LocalOperand0->String.Pointer);
+        strcat (Buffer, LocalOperand1->String.Pointer);
+        break;
+
+    case ACPI_TYPE_BUFFER:
+
+        /* Result of two Buffers is a Buffer */
+
+        ReturnDesc = AcpiUtCreateBufferObject (
+            ((ACPI_SIZE) Operand0->Buffer.Length +
+            LocalOperand1->Buffer.Length));
+        if (!ReturnDesc)
+        {
+            Status = AE_NO_MEMORY;
+            goto Cleanup;
+        }
+
+        Buffer = (char *) ReturnDesc->Buffer.Pointer;
+
+        /* Concatenate the buffers */
+
+        memcpy (Buffer, Operand0->Buffer.Pointer,
+            Operand0->Buffer.Length);
+        memcpy (Buffer + Operand0->Buffer.Length,
+            LocalOperand1->Buffer.Pointer,
+            LocalOperand1->Buffer.Length);
+        break;
+
+    default:
+
+        /* Invalid object type, should not happen here */
+
+        ACPI_ERROR ((AE_INFO, "Invalid object type: 0x%X",
+            Operand0->Common.Type));
+        Status = AE_AML_INTERNAL;
+        goto Cleanup;
+    }
+
+    *ActualReturnDesc = ReturnDesc;
+
+Cleanup:
+    if (LocalOperand0 != Operand0)
+    {
+        AcpiUtRemoveReference (LocalOperand0);
+    }
+
+    if (LocalOperand1 != Operand1)
+    {
+        AcpiUtRemoveReference (LocalOperand1);
+    }
+
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExConvertToObjectTypeString
+ *
+ * PARAMETERS:  ObjDesc             - Object to be converted
+ *              ReturnDesc          - Where to place the return object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Convert an object of arbitrary type to a string object that
+ *              contains the namestring for the object. Used for the
+ *              concatenate operator.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiExConvertToObjectTypeString (
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_OPERAND_OBJECT     **ResultDesc)
+{
+    ACPI_OPERAND_OBJECT     *ReturnDesc;
+    const char              *TypeString;
+
+
+    TypeString = AcpiUtGetTypeName (ObjDesc->Common.Type);
+
+    ReturnDesc = AcpiUtCreateStringObject (
+        ((ACPI_SIZE) strlen (TypeString) + 9)); /* 9 For "[ Object]" */
+    if (!ReturnDesc)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    strcpy (ReturnDesc->String.Pointer, "[");
+    strcat (ReturnDesc->String.Pointer, TypeString);
+    strcat (ReturnDesc->String.Pointer, " Object]");
+
+    *ResultDesc = ReturnDesc;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExConcatTemplate
+ *
+ * PARAMETERS:  Operand0            - First source object
+ *              Operand1            - Second source object
+ *              ActualReturnDesc    - Where to place the return object
+ *              WalkState           - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Concatenate two resource templates
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiExConcatTemplate (
+    ACPI_OPERAND_OBJECT     *Operand0,
+    ACPI_OPERAND_OBJECT     *Operand1,
+    ACPI_OPERAND_OBJECT     **ActualReturnDesc,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_STATUS             Status;
+    ACPI_OPERAND_OBJECT     *ReturnDesc;
+    UINT8                   *NewBuf;
+    UINT8                   *EndTag;
+    ACPI_SIZE               Length0;
+    ACPI_SIZE               Length1;
+    ACPI_SIZE               NewLength;
+
+
+    ACPI_FUNCTION_TRACE (ExConcatTemplate);
+
+
+    /*
+     * Find the EndTag descriptor in each resource template.
+     * Note1: returned pointers point TO the EndTag, not past it.
+     * Note2: zero-length buffers are allowed; treated like one EndTag
+     */
+
+    /* Get the length of the first resource template */
+
+    Status = AcpiUtGetResourceEndTag (Operand0, &EndTag);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    Length0 = ACPI_PTR_DIFF (EndTag, Operand0->Buffer.Pointer);
+
+    /* Get the length of the second resource template */
+
+    Status = AcpiUtGetResourceEndTag (Operand1, &EndTag);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    Length1 = ACPI_PTR_DIFF (EndTag, Operand1->Buffer.Pointer);
+
+    /* Combine both lengths, minimum size will be 2 for EndTag */
+
+    NewLength = Length0 + Length1 + sizeof (AML_RESOURCE_END_TAG);
+
+    /* Create a new buffer object for the result (with one EndTag) */
+
+    ReturnDesc = AcpiUtCreateBufferObject (NewLength);
+    if (!ReturnDesc)
+    {
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    /*
+     * Copy the templates to the new buffer, 0 first, then 1 follows. One
+     * EndTag descriptor is copied from Operand1.
+     */
+    NewBuf = ReturnDesc->Buffer.Pointer;
+    memcpy (NewBuf, Operand0->Buffer.Pointer, Length0);
+    memcpy (NewBuf + Length0, Operand1->Buffer.Pointer, Length1);
+
+    /* Insert EndTag and set the checksum to zero, means "ignore checksum" */
+
+    NewBuf[NewLength - 1] = 0;
+    NewBuf[NewLength - 2] = ACPI_RESOURCE_NAME_END_TAG | 1;
+
+    /* Return the completed resource template */
+
+    *ActualReturnDesc = ReturnDesc;
+    return_ACPI_STATUS (AE_OK);
+}
diff --git a/usr/src/uts/intel/io/acpica/executer/exconfig.c b/usr/src/uts/intel/io/acpica/executer/exconfig.c
index 9e05497b9f..bb0d2bb411 100644
--- a/usr/src/uts/intel/io/acpica/executer/exconfig.c
+++ b/usr/src/uts/intel/io/acpica/executer/exconfig.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXCONFIG_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -50,6 +48,7 @@
 #include "actables.h"
 #include "acdispat.h"
 #include "acevents.h"
+#include "amlcode.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -130,7 +129,10 @@ AcpiExAddTable (
     /* Execute any module-level code that was found in the table */
 
     AcpiExExitInterpreter ();
-    AcpiNsExecModuleCodeList ();
+    if (AcpiGbl_GroupModuleLevelCode)
+    {
+        AcpiNsExecModuleCodeList ();
+    }
     AcpiExEnterInterpreter ();
 
     /*
@@ -179,20 +181,12 @@ AcpiExLoadTableOp (
     ACPI_FUNCTION_TRACE (ExLoadTableOp);
 
 
-    /* Validate lengths for the SignatureString, OEMIDString, OEMTableID */
-
-    if ((Operand[0]->String.Length > ACPI_NAME_SIZE) ||
-        (Operand[1]->String.Length > ACPI_OEM_ID_SIZE) ||
-        (Operand[2]->String.Length > ACPI_OEM_TABLE_ID_SIZE))
-    {
-        return_ACPI_STATUS (AE_BAD_PARAMETER);
-    }
-
     /* Find the ACPI table in the RSDT/XSDT */
 
-    Status = AcpiTbFindTable (Operand[0]->String.Pointer,
-                              Operand[1]->String.Pointer,
-                              Operand[2]->String.Pointer, &TableIndex);
+    Status = AcpiTbFindTable (
+        Operand[0]->String.Pointer,
+        Operand[1]->String.Pointer,
+        Operand[2]->String.Pointer, &TableIndex);
     if (ACPI_FAILURE (Status))
     {
         if (Status != AE_NOT_FOUND)
@@ -222,11 +216,11 @@ AcpiExLoadTableOp (
     if (Operand[3]->String.Length > 0)
     {
         /*
-         * Find the node referenced by the RootPathString.  This is the
+         * Find the node referenced by the RootPathString. This is the
          * location within the namespace where the table will be loaded.
          */
         Status = AcpiNsGetNode (StartNode, Operand[3]->String.Pointer,
-                    ACPI_NS_SEARCH_PARENT, &ParentNode);
+            ACPI_NS_SEARCH_PARENT, &ParentNode);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -237,8 +231,8 @@ AcpiExLoadTableOp (
 
     if (Operand[4]->String.Length > 0)
     {
-        if ((Operand[4]->String.Pointer[0] != '\\') &&
-            (Operand[4]->String.Pointer[0] != '^'))
+        if ((Operand[4]->String.Pointer[0] != AML_ROOT_PREFIX) &&
+            (Operand[4]->String.Pointer[0] != AML_PARENT_PREFIX))
         {
             /*
              * Path is not absolute, so it will be relative to the node
@@ -250,7 +244,7 @@ AcpiExLoadTableOp (
         /* Find the node referenced by the ParameterPathString */
 
         Status = AcpiNsGetNode (StartNode, Operand[4]->String.Pointer,
-                    ACPI_NS_SEARCH_PARENT, &ParameterNode);
+            ACPI_NS_SEARCH_PARENT, &ParameterNode);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -272,8 +266,7 @@ AcpiExLoadTableOp (
         /* Store the parameter data into the optional parameter object */
 
         Status = AcpiExStore (Operand[5],
-                    ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, ParameterNode),
-                    WalkState);
+            ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, ParameterNode), WalkState);
         if (ACPI_FAILURE (Status))
         {
             (void) AcpiExUnloadTable (DdbHandle);
@@ -286,7 +279,7 @@ AcpiExLoadTableOp (
     Status = AcpiGetTableByIndex (TableIndex, &Table);
     if (ACPI_SUCCESS (Status))
     {
-        ACPI_INFO ((AE_INFO, "Dynamic OEM Table Load:"));
+        ACPI_INFO (("Dynamic OEM Table Load:"));
         AcpiTbPrintTableHeader (0, Table);
     }
 
@@ -295,11 +288,11 @@ AcpiExLoadTableOp (
     if (AcpiGbl_TableHandler)
     {
         (void) AcpiGbl_TableHandler (ACPI_TABLE_EVENT_LOAD, Table,
-                    AcpiGbl_TableHandlerContext);
+            AcpiGbl_TableHandlerContext);
     }
 
     *ReturnDesc = DdbHandle;
-    return_ACPI_STATUS  (Status);
+    return_ACPI_STATUS (Status);
 }
 
 
@@ -335,7 +328,7 @@ AcpiExRegionRead (
     for (i = 0; i < Length; i++)
     {
         Status = AcpiEvAddressSpaceDispatch (ObjDesc, NULL, ACPI_READ,
-                    RegionOffset, 8, &Value);
+            RegionOffset, 8, &Value);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
@@ -378,8 +371,8 @@ AcpiExLoadOp (
     ACPI_WALK_STATE         *WalkState)
 {
     ACPI_OPERAND_OBJECT     *DdbHandle;
+    ACPI_TABLE_HEADER       *TableHeader;
     ACPI_TABLE_HEADER       *Table;
-    ACPI_TABLE_DESC         TableDesc;
     UINT32                  TableIndex;
     ACPI_STATUS             Status;
     UINT32                  Length;
@@ -388,8 +381,6 @@ AcpiExLoadOp (
     ACPI_FUNCTION_TRACE (ExLoadOp);
 
 
-    ACPI_MEMSET (&TableDesc, 0, sizeof (ACPI_TABLE_DESC));
-
     /* Source Object can be either an OpRegion or a Buffer/Field */
 
     switch (ObjDesc->Common.Type)
@@ -407,8 +398,8 @@ AcpiExLoadOp (
         }
 
         /*
-         * If the Region Address and Length have not been previously evaluated,
-         * evaluate them now and save the results.
+         * If the Region Address and Length have not been previously
+         * evaluated, evaluate them now and save the results.
          */
         if (!(ObjDesc->Common.Flags & AOPOBJ_DATA_VALID))
         {
@@ -421,16 +412,16 @@ AcpiExLoadOp (
 
         /* Get the table header first so we can get the table length */
 
-        Table = ACPI_ALLOCATE (sizeof (ACPI_TABLE_HEADER));
-        if (!Table)
+        TableHeader = ACPI_ALLOCATE (sizeof (ACPI_TABLE_HEADER));
+        if (!TableHeader)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
         }
 
         Status = AcpiExRegionRead (ObjDesc, sizeof (ACPI_TABLE_HEADER),
-                    ACPI_CAST_PTR (UINT8, Table));
-        Length = Table->Length;
-        ACPI_FREE (Table);
+            ACPI_CAST_PTR (UINT8, TableHeader));
+        Length = TableHeader->Length;
+        ACPI_FREE (TableHeader);
 
         if (ACPI_FAILURE (Status))
         {
@@ -462,8 +453,8 @@ AcpiExLoadOp (
 
         /* Allocate a buffer for the table */
 
-        TableDesc.Pointer = ACPI_ALLOCATE (Length);
-        if (!TableDesc.Pointer)
+        Table = ACPI_ALLOCATE (Length);
+        if (!Table)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
         }
@@ -471,17 +462,14 @@ AcpiExLoadOp (
         /* Read the entire table */
 
         Status = AcpiExRegionRead (ObjDesc, Length,
-                    ACPI_CAST_PTR (UINT8, TableDesc.Pointer));
+            ACPI_CAST_PTR (UINT8, Table));
         if (ACPI_FAILURE (Status))
         {
-            ACPI_FREE (TableDesc.Pointer);
+            ACPI_FREE (Table);
             return_ACPI_STATUS (Status);
         }
-
-        TableDesc.Address = ObjDesc->Region.Address;
         break;
 
-
     case ACPI_TYPE_BUFFER: /* Buffer or resolved RegionField */
 
         ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
@@ -496,8 +484,9 @@ AcpiExLoadOp (
 
         /* Get the actual table length from the table header */
 
-        Table = ACPI_CAST_PTR (ACPI_TABLE_HEADER, ObjDesc->Buffer.Pointer);
-        Length = Table->Length;
+        TableHeader = ACPI_CAST_PTR (
+            ACPI_TABLE_HEADER, ObjDesc->Buffer.Pointer);
+        Length = TableHeader->Length;
 
         /* Table cannot extend beyond the buffer */
 
@@ -511,46 +500,49 @@ AcpiExLoadOp (
         }
 
         /*
-         * Copy the table from the buffer because the buffer could be modified
-         * or even deleted in the future
+         * Copy the table from the buffer because the buffer could be
+         * modified or even deleted in the future
          */
-        TableDesc.Pointer = ACPI_ALLOCATE (Length);
-        if (!TableDesc.Pointer)
+        Table = ACPI_ALLOCATE (Length);
+        if (!Table)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
         }
 
-        ACPI_MEMCPY (TableDesc.Pointer, Table, Length);
-        TableDesc.Address = ACPI_TO_INTEGER (TableDesc.Pointer);
+        memcpy (Table, TableHeader, Length);
         break;
 
-
     default:
+
         return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
     }
 
-    /* Validate table checksum (will not get validated in TbAddTable) */
+    /* Install the new table into the local data structures */
+
+    ACPI_INFO (("Dynamic OEM Table Load:"));
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
 
-    Status = AcpiTbVerifyChecksum (TableDesc.Pointer, Length);
+    Status = AcpiTbInstallStandardTable (ACPI_PTR_TO_PHYSADDR (Table),
+        ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL, TRUE, TRUE,
+        &TableIndex);
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
     if (ACPI_FAILURE (Status))
     {
-        ACPI_FREE (TableDesc.Pointer);
+        /* Delete allocated table buffer */
+
+        ACPI_FREE (Table);
         return_ACPI_STATUS (Status);
     }
 
-    /* Complete the table descriptor */
-
-    TableDesc.Length = Length;
-    TableDesc.Flags = ACPI_TABLE_ORIGIN_ALLOCATED;
-
-    /* Install the new table into the local data structures */
-
-    Status = AcpiTbAddTable (&TableDesc, &TableIndex);
+    /*
+     * Note: Now table is "INSTALLED", it must be validated before
+     * loading.
+     */
+    Status = AcpiTbValidateTable (
+        &AcpiGbl_RootTableList.Tables[TableIndex]);
     if (ACPI_FAILURE (Status))
     {
-        /* Delete allocated table buffer */
-
-        AcpiTbDeleteTable (&TableDesc);
         return_ACPI_STATUS (Status);
     }
 
@@ -582,9 +574,6 @@ AcpiExLoadOp (
         return_ACPI_STATUS (Status);
     }
 
-    ACPI_INFO ((AE_INFO, "Dynamic OEM Table Load:"));
-    AcpiTbPrintTableHeader (0, TableDesc.Pointer);
-
     /* Remove the reference by added by AcpiExStore above */
 
     AcpiUtRemoveReference (DdbHandle);
@@ -593,8 +582,8 @@ AcpiExLoadOp (
 
     if (AcpiGbl_TableHandler)
     {
-        (void) AcpiGbl_TableHandler (ACPI_TABLE_EVENT_LOAD, TableDesc.Pointer,
-                    AcpiGbl_TableHandlerContext);
+        (void) AcpiGbl_TableHandler (ACPI_TABLE_EVENT_LOAD, Table,
+            AcpiGbl_TableHandlerContext);
     }
 
     return_ACPI_STATUS (Status);
@@ -626,6 +615,14 @@ AcpiExUnloadTable (
     ACPI_FUNCTION_TRACE (ExUnloadTable);
 
 
+    /*
+     * Temporarily emit a warning so that the ASL for the machine can be
+     * hopefully obtained. This is to say that the Unload() operator is
+     * extremely rare if not completely unused.
+     */
+    ACPI_WARNING ((AE_INFO,
+        "Received request to unload an ACPI table"));
+
     /*
      * Validate the handle
      * Although the handle is partially validated in AcpiExReconfiguration()
@@ -641,7 +638,7 @@ AcpiExUnloadTable (
         (DdbHandle->Common.Type != ACPI_TYPE_LOCAL_REFERENCE) ||
         (!(DdbHandle->Common.Flags & AOPOBJ_DATA_VALID)))
     {
-        return_ACPI_STATUS (AE_BAD_PARAMETER);
+        return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
     }
 
     /* Get the table index from the DdbHandle */
@@ -663,7 +660,7 @@ AcpiExUnloadTable (
         if (ACPI_SUCCESS (Status))
         {
             (void) AcpiGbl_TableHandler (ACPI_TABLE_EVENT_UNLOAD, Table,
-                        AcpiGbl_TableHandlerContext);
+                AcpiGbl_TableHandlerContext);
         }
     }
 
@@ -685,4 +682,3 @@ AcpiExUnloadTable (
     DdbHandle->Common.Flags &= ~AOPOBJ_DATA_VALID;
     return_ACPI_STATUS (AE_OK);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exconvrt.c b/usr/src/uts/intel/io/acpica/executer/exconvrt.c
index e79cbc96e9..ea6f82620d 100644
--- a/usr/src/uts/intel/io/acpica/executer/exconvrt.c
+++ b/usr/src/uts/intel/io/acpica/executer/exconvrt.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EXCONVRT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -114,6 +111,7 @@ AcpiExConvertToInteger (
         break;
 
     default:
+
         return_ACPI_STATUS (AE_TYPE);
     }
 
@@ -133,21 +131,20 @@ AcpiExConvertToInteger (
     switch (ObjDesc->Common.Type)
     {
     case ACPI_TYPE_STRING:
-
         /*
          * Convert string to an integer - for most cases, the string must be
          * hexadecimal as per the ACPI specification. The only exception (as
          * of ACPI 3.0) is that the ToInteger() operator allows both decimal
          * and hexadecimal strings (hex prefixed with "0x").
          */
-        Status = AcpiUtStrtoul64 ((char *) Pointer, Flags, &Result);
+        Status = AcpiUtStrtoul64 ((char *) Pointer, Flags,
+            AcpiGbl_IntegerByteWidth, &Result);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
         }
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         /* Check for zero-length buffer */
@@ -179,10 +176,10 @@ AcpiExConvertToInteger (
         }
         break;
 
-
     default:
 
         /* No other types can get here */
+
         break;
     }
 
@@ -199,7 +196,7 @@ AcpiExConvertToInteger (
 
     /* Save the Result */
 
-    AcpiExTruncateFor32bitTable (ReturnDesc);
+    (void) AcpiExTruncateFor32bitTable (ReturnDesc);
     *ResultDesc = ReturnDesc;
     return_ACPI_STATUS (AE_OK);
 }
@@ -242,7 +239,6 @@ AcpiExConvertToBuffer (
 
 
     case ACPI_TYPE_INTEGER:
-
         /*
          * Create a new Buffer object.
          * Need enough space for one integer
@@ -256,14 +252,10 @@ AcpiExConvertToBuffer (
         /* Copy the integer to the buffer, LSB first */
 
         NewBuf = ReturnDesc->Buffer.Pointer;
-        ACPI_MEMCPY (NewBuf,
-                        &ObjDesc->Integer.Value,
-                        AcpiGbl_IntegerByteWidth);
+        memcpy (NewBuf, &ObjDesc->Integer.Value, AcpiGbl_IntegerByteWidth);
         break;
 
-
     case ACPI_TYPE_STRING:
-
         /*
          * Create a new Buffer object
          * Size will be the string length
@@ -273,8 +265,8 @@ AcpiExConvertToBuffer (
          * ASL/AML code that depends on the null being transferred to the new
          * buffer.
          */
-        ReturnDesc = AcpiUtCreateBufferObject (
-                        (ACPI_SIZE) ObjDesc->String.Length + 1);
+        ReturnDesc = AcpiUtCreateBufferObject ((ACPI_SIZE)
+            ObjDesc->String.Length + 1);
         if (!ReturnDesc)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
@@ -283,12 +275,12 @@ AcpiExConvertToBuffer (
         /* Copy the string to the buffer */
 
         NewBuf = ReturnDesc->Buffer.Pointer;
-        ACPI_STRNCPY ((char *) NewBuf, (char *) ObjDesc->String.Pointer,
+        strncpy ((char *) NewBuf, (char *) ObjDesc->String.Pointer,
             ObjDesc->String.Length);
         break;
 
-
     default:
+
         return_ACPI_STATUS (AE_TYPE);
     }
 
@@ -344,15 +336,18 @@ AcpiExConvertToAscii (
         switch (DataWidth)
         {
         case 1:
+
             DecimalLength = ACPI_MAX8_DECIMAL_DIGITS;
             break;
 
         case 4:
+
             DecimalLength = ACPI_MAX32_DECIMAL_DIGITS;
             break;
 
         case 8:
         default:
+
             DecimalLength = ACPI_MAX64_DECIMAL_DIGITS;
             break;
         }
@@ -394,7 +389,8 @@ AcpiExConvertToAscii (
         {
             /* Get one hex digit, most significant digits first */
 
-            String[k] = (UINT8) AcpiUtHexToAsciiChar (Integer, ACPI_MUL_4 (j));
+            String[k] = (UINT8)
+                AcpiUtHexToAsciiChar (Integer, ACPI_MUL_4 (j));
             k++;
         }
         break;
@@ -461,7 +457,6 @@ AcpiExConvertToString (
         *ResultDesc = ObjDesc;
         return_ACPI_STATUS (AE_OK);
 
-
     case ACPI_TYPE_INTEGER:
 
         switch (Type)
@@ -496,8 +491,8 @@ AcpiExConvertToString (
 
         /* Convert integer to string */
 
-        StringLength = AcpiExConvertToAscii (ObjDesc->Integer.Value, Base,
-                            NewBuf, AcpiGbl_IntegerByteWidth);
+        StringLength = AcpiExConvertToAscii (
+            ObjDesc->Integer.Value, Base, NewBuf, AcpiGbl_IntegerByteWidth);
 
         /* Null terminate at the correct place */
 
@@ -505,7 +500,6 @@ AcpiExConvertToString (
         NewBuf [StringLength] = 0;
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         /* Setup string length, base, and separator */
@@ -587,8 +581,7 @@ AcpiExConvertToString (
         for (i = 0; i < ObjDesc->Buffer.Length; i++)
         {
             NewBuf += AcpiExConvertToAscii (
-                        (UINT64) ObjDesc->Buffer.Pointer[i], Base,
-                        NewBuf, 1);
+                (UINT64) ObjDesc->Buffer.Pointer[i], Base, NewBuf, 1);
             *NewBuf++ = Separator; /* each separated by a comma or space */
         }
 
@@ -604,6 +597,7 @@ AcpiExConvertToString (
         break;
 
     default:
+
         return_ACPI_STATUS (AE_TYPE);
     }
 
@@ -663,6 +657,7 @@ AcpiExConvertToTargetType (
             break;
 
         default:
+
             /* No conversion allowed for these types */
 
             if (DestinationType != SourceDesc->Common.Type)
@@ -676,8 +671,8 @@ AcpiExConvertToTargetType (
         }
         break;
 
-
     case ARGI_TARGETREF:
+    case ARGI_STORE_TARGET:
 
         switch (DestinationType)
         {
@@ -689,21 +684,18 @@ AcpiExConvertToTargetType (
              * These types require an Integer operand. We can convert
              * a Buffer or a String to an Integer if necessary.
              */
-            Status = AcpiExConvertToInteger (SourceDesc, ResultDesc,
-                        16);
+            Status = AcpiExConvertToInteger (SourceDesc, ResultDesc, 16);
             break;
 
-
         case ACPI_TYPE_STRING:
             /*
              * The operand must be a String. We can convert an
              * Integer or Buffer if necessary
              */
             Status = AcpiExConvertToString (SourceDesc, ResultDesc,
-                        ACPI_IMPLICIT_CONVERT_HEX);
+                ACPI_IMPLICIT_CONVERT_HEX);
             break;
 
-
         case ACPI_TYPE_BUFFER:
             /*
              * The operand must be a Buffer. We can convert an
@@ -712,24 +704,24 @@ AcpiExConvertToTargetType (
             Status = AcpiExConvertToBuffer (SourceDesc, ResultDesc);
             break;
 
-
         default:
-            ACPI_ERROR ((AE_INFO, "Bad destination type during conversion: 0x%X",
+
+            ACPI_ERROR ((AE_INFO,
+                "Bad destination type during conversion: 0x%X",
                 DestinationType));
             Status = AE_AML_INTERNAL;
             break;
         }
         break;
 
-
     case ARGI_REFERENCE:
         /*
          * CreateXxxxField cases - we are storing the field object into the name
          */
         break;
 
-
     default:
+
         ACPI_ERROR ((AE_INFO,
             "Unknown Target type ID 0x%X AmlOpcode 0x%X DestType %s",
             GET_CURRENT_ARG_TYPE (WalkState->OpInfo->RuntimeArgs),
@@ -750,5 +742,3 @@ AcpiExConvertToTargetType (
 
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/excreate.c b/usr/src/uts/intel/io/acpica/executer/excreate.c
index 888ff7d7c4..26dd872a3c 100644
--- a/usr/src/uts/intel/io/acpica/executer/excreate.c
+++ b/usr/src/uts/intel/io/acpica/executer/excreate.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXCREATE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -89,7 +87,7 @@ AcpiExCreateAlias (
     {
         /*
          * Dereference an existing alias so that we don't create a chain
-         * of aliases.  With this code, we guarantee that an alias is
+         * of aliases. With this code, we guarantee that an alias is
          * always exactly one level of indirection away from the
          * actual aliased name.
          */
@@ -99,7 +97,7 @@ AcpiExCreateAlias (
     /*
      * For objects that can never change (i.e., the NS node will
      * permanently point to the same object), we can simply attach
-     * the object to the new NS node.  For other objects (such as
+     * the object to the new NS node. For other objects (such as
      * Integers, buffers, etc.), we have to point the Alias node
      * to the original Node.
      */
@@ -113,7 +111,6 @@ AcpiExCreateAlias (
     case ACPI_TYPE_BUFFER:
     case ACPI_TYPE_PACKAGE:
     case ACPI_TYPE_BUFFER_FIELD:
-
     /*
      * These types open a new scope, so we need the NS node in order to access
      * any children.
@@ -123,7 +120,6 @@ AcpiExCreateAlias (
     case ACPI_TYPE_PROCESSOR:
     case ACPI_TYPE_THERMAL:
     case ACPI_TYPE_LOCAL_SCOPE:
-
         /*
          * The new alias has the type ALIAS and points to the original
          * NS node, not the object itself.
@@ -133,7 +129,6 @@ AcpiExCreateAlias (
         break;
 
     case ACPI_TYPE_METHOD:
-
         /*
          * Control method aliases need to be differentiated
          */
@@ -147,12 +142,12 @@ AcpiExCreateAlias (
 
         /*
          * The new alias assumes the type of the target, and it points
-         * to the same object.  The reference count of the object has an
+         * to the same object. The reference count of the object has an
          * additional reference to prevent deletion out from under either the
          * target node or the alias Node
          */
         Status = AcpiNsAttachObject (AliasNode,
-                    AcpiNsGetAttachedObject (TargetNode), TargetNode->Type);
+            AcpiNsGetAttachedObject (TargetNode), TargetNode->Type);
         break;
     }
 
@@ -197,7 +192,7 @@ AcpiExCreateEvent (
      * that the event is created in an unsignalled state
      */
     Status = AcpiOsCreateSemaphore (ACPI_NO_UNIT_LIMIT, 0,
-                &ObjDesc->Event.OsSemaphore);
+        &ObjDesc->Event.OsSemaphore);
     if (ACPI_FAILURE (Status))
     {
         goto Cleanup;
@@ -205,8 +200,9 @@ AcpiExCreateEvent (
 
     /* Attach object to the Node */
 
-    Status = AcpiNsAttachObject ((ACPI_NAMESPACE_NODE *) WalkState->Operands[0],
-                ObjDesc, ACPI_TYPE_EVENT);
+    Status = AcpiNsAttachObject (
+        (ACPI_NAMESPACE_NODE *) WalkState->Operands[0],
+        ObjDesc, ACPI_TYPE_EVENT);
 
 Cleanup:
     /*
@@ -265,7 +261,8 @@ AcpiExCreateMutex (
     ObjDesc->Mutex.SyncLevel = (UINT8) WalkState->Operands[1]->Integer.Value;
     ObjDesc->Mutex.Node = (ACPI_NAMESPACE_NODE *) WalkState->Operands[0];
 
-    Status = AcpiNsAttachObject (ObjDesc->Mutex.Node, ObjDesc, ACPI_TYPE_MUTEX);
+    Status = AcpiNsAttachObject (
+        ObjDesc->Mutex.Node, ObjDesc, ACPI_TYPE_MUTEX);
 
 
 Cleanup:
@@ -333,7 +330,8 @@ AcpiExCreateRegion (
          * a table load for this exception. Instead, if the region is
          * actually used at runtime, abort the executing method.
          */
-        ACPI_ERROR ((AE_INFO, "Invalid/unknown Address Space ID: 0x%2.2X", SpaceId));
+        ACPI_ERROR ((AE_INFO,
+            "Invalid/unknown Address Space ID: 0x%2.2X", SpaceId));
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Region Type - %s (0x%X)\n",
@@ -352,9 +350,10 @@ AcpiExCreateRegion (
      * Remember location in AML stream of address & length
      * operands since they need to be evaluated at run time.
      */
-    RegionObj2 = ObjDesc->Common.NextObject;
+    RegionObj2 = AcpiNsGetSecondaryObject (ObjDesc);
     RegionObj2->Extra.AmlStart = AmlStart;
     RegionObj2->Extra.AmlLength = AmlLength;
+    RegionObj2->Extra.Method_REG = NULL;
     if (WalkState->ScopeInfo)
     {
         RegionObj2->Extra.ScopeNode = WalkState->ScopeInfo->Scope.Node;
@@ -370,6 +369,10 @@ AcpiExCreateRegion (
     ObjDesc->Region.Address = 0;
     ObjDesc->Region.Length = 0;
     ObjDesc->Region.Node = Node;
+    ObjDesc->Region.Handler = NULL;
+    ObjDesc->Common.Flags &=
+        ~(AOPOBJ_SETUP_COMPLETE | AOPOBJ_REG_CONNECTED |
+          AOPOBJ_OBJECT_INITIALIZED);
 
     /* Install the new region object in the parent Node */
 
@@ -428,7 +431,7 @@ AcpiExCreateProcessor (
     /* Install the processor object in the parent Node */
 
     Status = AcpiNsAttachObject ((ACPI_NAMESPACE_NODE *) Operand[0],
-                    ObjDesc, ACPI_TYPE_PROCESSOR);
+        ObjDesc, ACPI_TYPE_PROCESSOR);
 
     /* Remove local reference to the object */
 
@@ -479,7 +482,7 @@ AcpiExCreatePowerResource (
     /* Install the  power resource object in the parent Node */
 
     Status = AcpiNsAttachObject ((ACPI_NAMESPACE_NODE *) Operand[0],
-                    ObjDesc, ACPI_TYPE_POWER);
+        ObjDesc, ACPI_TYPE_POWER);
 
     /* Remove local reference to the object */
 
@@ -531,13 +534,15 @@ AcpiExCreateMethod (
 
     ObjDesc->Method.AmlStart = AmlStart;
     ObjDesc->Method.AmlLength = AmlLength;
+    ObjDesc->Method.Node = Operand[0];
 
     /*
      * Disassemble the method flags. Split off the ArgCount, Serialized
      * flag, and SyncLevel for efficiency.
      */
     MethodFlags = (UINT8) Operand[1]->Integer.Value;
-    ObjDesc->Method.ParamCount = (UINT8) (MethodFlags & AML_METHOD_ARG_COUNT);
+    ObjDesc->Method.ParamCount = (UINT8)
+        (MethodFlags & AML_METHOD_ARG_COUNT);
 
     /*
      * Get the SyncLevel. If method is serialized, a mutex will be
@@ -558,7 +563,7 @@ AcpiExCreateMethod (
     /* Attach the new object to the method Node */
 
     Status = AcpiNsAttachObject ((ACPI_NAMESPACE_NODE *) Operand[0],
-                    ObjDesc, ACPI_TYPE_METHOD);
+        ObjDesc, ACPI_TYPE_METHOD);
 
     /* Remove local reference to the object */
 
@@ -570,5 +575,3 @@ Exit:
     AcpiUtRemoveReference (Operand[1]);
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exdebug.c b/usr/src/uts/intel/io/acpica/executer/exdebug.c
index 166b2af170..0832337e48 100644
--- a/usr/src/uts/intel/io/acpica/executer/exdebug.c
+++ b/usr/src/uts/intel/io/acpica/executer/exdebug.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXDEBUG_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -82,6 +80,9 @@ AcpiExDoDebugObject (
     UINT32                  Index)
 {
     UINT32                  i;
+    UINT32                  Timer;
+    ACPI_OPERAND_OBJECT     *ObjectDesc;
+    UINT32                  Value;
 
 
     ACPI_FUNCTION_TRACE_PTR (ExDoDebugObject, SourceDesc);
@@ -95,20 +96,52 @@ AcpiExDoDebugObject (
         return_VOID;
     }
 
+    /* Null string or newline -- don't emit the line header */
+
+    if (SourceDesc &&
+        (ACPI_GET_DESCRIPTOR_TYPE (SourceDesc) == ACPI_DESC_TYPE_OPERAND) &&
+        (SourceDesc->Common.Type == ACPI_TYPE_STRING))
+    {
+        if ((SourceDesc->String.Length == 0) ||
+                ((SourceDesc->String.Length == 1) &&
+                (*SourceDesc->String.Pointer == '\n')))
+        {
+            AcpiOsPrintf ("\n");
+            return_VOID;
+        }
+    }
+
     /*
      * Print line header as long as we are not in the middle of an
      * object display
      */
     if (!((Level > 0) && Index == 0))
     {
-        AcpiOsPrintf ("[ACPI Debug] %*s", Level, " ");
+        if (AcpiGbl_DisplayDebugTimer)
+        {
+            /*
+             * We will emit the current timer value (in microseconds) with each
+             * debug output. Only need the lower 26 bits. This allows for 67
+             * million microseconds or 67 seconds before rollover.
+             *
+             * Convert 100 nanosecond units to microseconds
+             */
+            Timer = ((UINT32) AcpiOsGetTimer () / 10);
+            Timer &= 0x03FFFFFF;
+
+            AcpiOsPrintf ("[ACPI Debug T=0x%8.8X] %*s", Timer, Level, " ");
+        }
+        else
+        {
+            AcpiOsPrintf ("[ACPI Debug] %*s", Level, " ");
+        }
     }
 
     /* Display the index for package output only */
 
     if (Index > 0)
     {
-       AcpiOsPrintf ("(%.2u) ", Index-1);
+       AcpiOsPrintf ("(%.2u) ", Index - 1);
     }
 
     if (!SourceDesc)
@@ -119,7 +152,13 @@ AcpiExDoDebugObject (
 
     if (ACPI_GET_DESCRIPTOR_TYPE (SourceDesc) == ACPI_DESC_TYPE_OPERAND)
     {
-        AcpiOsPrintf ("%s ", AcpiUtGetObjectTypeName (SourceDesc));
+        /* No object type prefix needed for integers and strings */
+
+        if ((SourceDesc->Common.Type != ACPI_TYPE_INTEGER) &&
+            (SourceDesc->Common.Type != ACPI_TYPE_STRING))
+        {
+            AcpiOsPrintf ("%s  ", AcpiUtGetObjectTypeName (SourceDesc));
+        }
 
         if (!AcpiUtValidInternalObject (SourceDesc))
         {
@@ -129,9 +168,9 @@ AcpiExDoDebugObject (
     }
     else if (ACPI_GET_DESCRIPTOR_TYPE (SourceDesc) == ACPI_DESC_TYPE_NAMED)
     {
-        AcpiOsPrintf ("%s: %p\n",
+        AcpiOsPrintf ("%s  (Node %p)\n",
             AcpiUtGetTypeName (((ACPI_NAMESPACE_NODE *) SourceDesc)->Type),
-            SourceDesc);
+                SourceDesc);
         return_VOID;
     }
     else
@@ -162,20 +201,19 @@ AcpiExDoDebugObject (
     case ACPI_TYPE_BUFFER:
 
         AcpiOsPrintf ("[0x%.2X]\n", (UINT32) SourceDesc->Buffer.Length);
-        AcpiUtDumpBuffer2 (SourceDesc->Buffer.Pointer,
+        AcpiUtDumpBuffer (SourceDesc->Buffer.Pointer,
             (SourceDesc->Buffer.Length < 256) ?
-                SourceDesc->Buffer.Length : 256, DB_BYTE_DISPLAY);
+                SourceDesc->Buffer.Length : 256, DB_BYTE_DISPLAY, 0);
         break;
 
     case ACPI_TYPE_STRING:
 
-        AcpiOsPrintf ("[0x%.2X] \"%s\"\n",
-            SourceDesc->String.Length, SourceDesc->String.Pointer);
+        AcpiOsPrintf ("\"%s\"\n", SourceDesc->String.Pointer);
         break;
 
     case ACPI_TYPE_PACKAGE:
 
-        AcpiOsPrintf ("[Contains 0x%.2X Elements]\n",
+        AcpiOsPrintf ("(Contains 0x%.2X Elements):\n",
             SourceDesc->Package.Count);
 
         /* Output the entire contents of the package */
@@ -183,7 +221,7 @@ AcpiExDoDebugObject (
         for (i = 0; i < SourceDesc->Package.Count; i++)
         {
             AcpiExDoDebugObject (SourceDesc->Package.Elements[i],
-                Level+4, i+1);
+                Level + 4, i + 1);
         }
         break;
 
@@ -205,9 +243,10 @@ AcpiExDoDebugObject (
             /* Case for DdbHandle */
 
             AcpiOsPrintf ("Table Index 0x%X\n", SourceDesc->Reference.Value);
-            return;
+            return_VOID;
 
         default:
+
             break;
         }
 
@@ -218,7 +257,7 @@ AcpiExDoDebugObject (
         if (SourceDesc->Reference.Node)
         {
             if (ACPI_GET_DESCRIPTOR_TYPE (SourceDesc->Reference.Node) !=
-                    ACPI_DESC_TYPE_NAMED)
+                ACPI_DESC_TYPE_NAMED)
             {
                 AcpiOsPrintf (" %p - Not a valid namespace node\n",
                     SourceDesc->Reference.Node);
@@ -241,8 +280,9 @@ AcpiExDoDebugObject (
                     break;
 
                 default:
+
                     AcpiExDoDebugObject ((SourceDesc->Reference.Node)->Object,
-                        Level+4, 0);
+                        Level + 4, 0);
                     break;
                 }
             }
@@ -250,23 +290,61 @@ AcpiExDoDebugObject (
         else if (SourceDesc->Reference.Object)
         {
             if (ACPI_GET_DESCRIPTOR_TYPE (SourceDesc->Reference.Object) ==
-                    ACPI_DESC_TYPE_NAMED)
+                ACPI_DESC_TYPE_NAMED)
             {
-                AcpiExDoDebugObject (((ACPI_NAMESPACE_NODE *)
-                    SourceDesc->Reference.Object)->Object,
-                    Level+4, 0);
+                /* Reference object is a namespace node */
+
+                AcpiExDoDebugObject (ACPI_CAST_PTR (ACPI_OPERAND_OBJECT,
+                    SourceDesc->Reference.Object),
+                    Level + 4, 0);
             }
             else
             {
-                AcpiExDoDebugObject (SourceDesc->Reference.Object,
-                    Level+4, 0);
+                ObjectDesc = SourceDesc->Reference.Object;
+                Value = SourceDesc->Reference.Value;
+
+                switch (ObjectDesc->Common.Type)
+                {
+                case ACPI_TYPE_BUFFER:
+
+                    AcpiOsPrintf ("Buffer[%u] = 0x%2.2X\n",
+                        Value, *SourceDesc->Reference.IndexPointer);
+                    break;
+
+                case ACPI_TYPE_STRING:
+
+                    AcpiOsPrintf ("String[%u] = \"%c\" (0x%2.2X)\n",
+                        Value, *SourceDesc->Reference.IndexPointer,
+                        *SourceDesc->Reference.IndexPointer);
+                    break;
+
+                case ACPI_TYPE_PACKAGE:
+
+                    AcpiOsPrintf ("Package[%u] = ", Value);
+                    if (!(*SourceDesc->Reference.Where))
+                    {
+                        AcpiOsPrintf ("[Uninitialized Package Element]\n");
+                    }
+                    else
+                    {
+                        AcpiExDoDebugObject (*SourceDesc->Reference.Where,
+                            Level+4, 0);
+                    }
+                    break;
+
+                default:
+
+                    AcpiOsPrintf ("Unknown Reference object type %X\n",
+                        ObjectDesc->Common.Type);
+                    break;
+                }
             }
         }
         break;
 
     default:
 
-        AcpiOsPrintf ("%p\n", SourceDesc);
+        AcpiOsPrintf ("(Descriptor %p)\n", SourceDesc);
         break;
     }
 
@@ -274,5 +352,3 @@ AcpiExDoDebugObject (
     return_VOID;
 }
 #endif
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exdump.c b/usr/src/uts/intel/io/acpica/executer/exdump.c
index 0943e668c1..f5d5fd03a5 100644
--- a/usr/src/uts/intel/io/acpica/executer/exdump.c
+++ b/usr/src/uts/intel/io/acpica/executer/exdump.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXDUMP_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -62,13 +60,13 @@
 
 static void
 AcpiExOutString (
-    char                    *Title,
-    char                    *Value);
+    const char              *Title,
+    const char              *Value);
 
 static void
 AcpiExOutPointer (
-    char                    *Title,
-    void                    *Value);
+    const char              *Title,
+    const void              *Value);
 
 static void
 AcpiExDumpObject (
@@ -114,13 +112,14 @@ static ACPI_EXDUMP_INFO     AcpiExDumpBuffer[5] =
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpBuffer),         NULL},
     {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Buffer.Length),                "Length"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Buffer.Pointer),               "Pointer"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Buffer.Node),                  "Parent Node"},
+    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Buffer.Node),                  "Parent Node"},
     {ACPI_EXD_BUFFER,   0,                                              NULL}
 };
 
-static ACPI_EXDUMP_INFO     AcpiExDumpPackage[5] =
+static ACPI_EXDUMP_INFO     AcpiExDumpPackage[6] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpPackage),        NULL},
+    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Package.Node),                 "Parent Node"},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Package.Flags),                "Flags"},
     {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Package.Count),                "Elements"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Package.Elements),             "Element List"},
@@ -130,9 +129,9 @@ static ACPI_EXDUMP_INFO     AcpiExDumpPackage[5] =
 static ACPI_EXDUMP_INFO     AcpiExDumpDevice[4] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpDevice),         NULL},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Device.Handler),               "Handler"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Device.NotifyList[0]),         "System Notify"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Device.NotifyList[1]),         "Device Notify"}
+    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Device.NotifyList[1]),         "Device Notify"},
+    {ACPI_EXD_HDLR_LIST,ACPI_EXD_OFFSET (Device.Handler),               "Handler"}
 };
 
 static ACPI_EXDUMP_INFO     AcpiExDumpEvent[2] =
@@ -154,33 +153,36 @@ static ACPI_EXDUMP_INFO     AcpiExDumpMethod[9] =
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Method.AmlStart),              "Aml Start"}
 };
 
-static ACPI_EXDUMP_INFO     AcpiExDumpMutex[5] =
+static ACPI_EXDUMP_INFO     AcpiExDumpMutex[6] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpMutex),          NULL},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Mutex.SyncLevel),              "Sync Level"},
+    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Mutex.OriginalSyncLevel),      "Original Sync Level"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Mutex.OwnerThread),            "Owner Thread"},
     {ACPI_EXD_UINT16,   ACPI_EXD_OFFSET (Mutex.AcquisitionDepth),       "Acquire Depth"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Mutex.OsMutex),                "OsMutex"}
 };
 
-static ACPI_EXDUMP_INFO     AcpiExDumpRegion[7] =
+static ACPI_EXDUMP_INFO     AcpiExDumpRegion[8] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpRegion),         NULL},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Region.SpaceId),               "Space Id"},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Region.Flags),                 "Flags"},
+    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Region.Node),                  "Parent Node"},
     {ACPI_EXD_ADDRESS,  ACPI_EXD_OFFSET (Region.Address),               "Address"},
     {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Region.Length),                "Length"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Region.Handler),               "Handler"},
+    {ACPI_EXD_HDLR_LIST,ACPI_EXD_OFFSET (Region.Handler),               "Handler"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Region.Next),                  "Next"}
 };
 
-static ACPI_EXDUMP_INFO     AcpiExDumpPower[5] =
+static ACPI_EXDUMP_INFO     AcpiExDumpPower[6] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpPower),          NULL},
     {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (PowerResource.SystemLevel),    "System Level"},
     {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (PowerResource.ResourceOrder),  "Resource Order"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (PowerResource.NotifyList[0]),  "System Notify"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (PowerResource.NotifyList[1]),  "Device Notify"}
+    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (PowerResource.NotifyList[1]),  "Device Notify"},
+    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (PowerResource.Handler),        "Handler"}
 };
 
 static ACPI_EXDUMP_INFO     AcpiExDumpProcessor[7] =
@@ -236,15 +238,16 @@ static ACPI_EXDUMP_INFO     AcpiExDumpIndexField[5] =
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (IndexField.DataObj),           "Data Object"}
 };
 
-static ACPI_EXDUMP_INFO     AcpiExDumpReference[8] =
+static ACPI_EXDUMP_INFO     AcpiExDumpReference[9] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpReference),       NULL},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Reference.Class),              "Class"},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Reference.TargetType),         "Target Type"},
     {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Reference.Value),              "Value"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Reference.Object),             "Object Desc"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Reference.Node),               "Node"},
+    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Reference.Node),               "Node"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Reference.Where),              "Where"},
+    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Reference.IndexPointer),       "Index Pointer"},
     {ACPI_EXD_REFERENCE,0,                                              NULL}
 };
 
@@ -252,16 +255,16 @@ static ACPI_EXDUMP_INFO     AcpiExDumpAddressHandler[6] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpAddressHandler), NULL},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (AddressSpace.SpaceId),         "Space Id"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (AddressSpace.Next),            "Next"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (AddressSpace.RegionList),      "Region List"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (AddressSpace.Node),            "Node"},
+    {ACPI_EXD_HDLR_LIST,ACPI_EXD_OFFSET (AddressSpace.Next),            "Next"},
+    {ACPI_EXD_RGN_LIST, ACPI_EXD_OFFSET (AddressSpace.RegionList),      "Region List"},
+    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (AddressSpace.Node),            "Node"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (AddressSpace.Context),         "Context"}
 };
 
 static ACPI_EXDUMP_INFO     AcpiExDumpNotify[7] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpNotify),         NULL},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Notify.Node),                  "Node"},
+    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Notify.Node),                  "Node"},
     {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Notify.HandlerType),           "Handler Type"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Notify.Handler),               "Handler"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Notify.Context),               "Context"},
@@ -269,15 +272,32 @@ static ACPI_EXDUMP_INFO     AcpiExDumpNotify[7] =
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Notify.Next[1]),               "Next Device Notify"}
 };
 
+static ACPI_EXDUMP_INFO     AcpiExDumpExtra[6] =
+{
+    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpExtra),          NULL},
+    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Extra.Method_REG),             "_REG Method"},
+    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (Extra.ScopeNode),              "Scope Node"},
+    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Extra.RegionContext),          "Region Context"},
+    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Extra.AmlStart),               "Aml Start"},
+    {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (Extra.AmlLength),              "Aml Length"}
+};
+
+static ACPI_EXDUMP_INFO     AcpiExDumpData[3] =
+{
+    {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpData),           NULL},
+    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Data.Handler),                 "Handler"},
+    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Data.Pointer),                 "Raw Data"}
+};
 
 /* Miscellaneous tables */
 
-static ACPI_EXDUMP_INFO     AcpiExDumpCommon[4] =
+static ACPI_EXDUMP_INFO     AcpiExDumpCommon[5] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpCommon),         NULL},
     {ACPI_EXD_TYPE ,    0,                                              NULL},
     {ACPI_EXD_UINT16,   ACPI_EXD_OFFSET (Common.ReferenceCount),        "Reference Count"},
-    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Common.Flags),                 "Flags"}
+    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Common.Flags),                 "Flags"},
+    {ACPI_EXD_LIST,     ACPI_EXD_OFFSET (Common.NextObject),            "Object List"}
 };
 
 static ACPI_EXDUMP_INFO     AcpiExDumpFieldCommon[7] =
@@ -288,16 +308,18 @@ static ACPI_EXDUMP_INFO     AcpiExDumpFieldCommon[7] =
     {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (CommonField.BitLength),        "Bit Length"},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (CommonField.StartFieldBitOffset),"Field Bit Offset"},
     {ACPI_EXD_UINT32,   ACPI_EXD_OFFSET (CommonField.BaseByteOffset),   "Base Byte Offset"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (CommonField.Node),             "Parent Node"}
+    {ACPI_EXD_NODE,     ACPI_EXD_OFFSET (CommonField.Node),             "Parent Node"}
 };
 
-static ACPI_EXDUMP_INFO     AcpiExDumpNode[5] =
+static ACPI_EXDUMP_INFO     AcpiExDumpNode[7] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpNode),           NULL},
     {ACPI_EXD_UINT8,    ACPI_EXD_NSOFFSET (Flags),                      "Flags"},
     {ACPI_EXD_UINT8,    ACPI_EXD_NSOFFSET (OwnerId),                    "Owner Id"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_NSOFFSET (Child),                      "Child List"},
-    {ACPI_EXD_POINTER,  ACPI_EXD_NSOFFSET (Peer),                       "Next Peer"}
+    {ACPI_EXD_LIST,     ACPI_EXD_NSOFFSET (Object),                     "Object List"},
+    {ACPI_EXD_NODE,     ACPI_EXD_NSOFFSET (Parent),                     "Parent"},
+    {ACPI_EXD_NODE,     ACPI_EXD_NSOFFSET (Child),                      "Child"},
+    {ACPI_EXD_NODE,     ACPI_EXD_NSOFFSET (Peer),                       "Peer"}
 };
 
 
@@ -332,7 +354,9 @@ static ACPI_EXDUMP_INFO     *AcpiExDumpInfo[] =
     AcpiExDumpAddressHandler,
     NULL,
     NULL,
-    NULL
+    NULL,
+    AcpiExDumpExtra,
+    AcpiExDumpData
 };
 
 
@@ -356,8 +380,12 @@ AcpiExDumpObject (
     ACPI_EXDUMP_INFO        *Info)
 {
     UINT8                   *Target;
-    char                    *Name;
+    const char              *Name;
     UINT8                   Count;
+    ACPI_OPERAND_OBJECT     *Start;
+    ACPI_OPERAND_OBJECT     *Data = NULL;
+    ACPI_OPERAND_OBJECT     *Next;
+    ACPI_NAMESPACE_NODE     *Node;
 
 
     if (!Info)
@@ -380,11 +408,13 @@ AcpiExDumpObject (
         switch (Info->Opcode)
         {
         case ACPI_EXD_INIT:
+
             break;
 
         case ACPI_EXD_TYPE:
 
-            AcpiExOutString  ("Type", AcpiUtGetObjectTypeName (ObjDesc));
+            AcpiOsPrintf ("%20s : %2.2X [%s]\n", "Type",
+                ObjDesc->Common.Type, AcpiUtGetObjectTypeName (ObjDesc));
             break;
 
         case ACPI_EXD_UINT8:
@@ -422,7 +452,8 @@ AcpiExDumpObject (
 
         case ACPI_EXD_BUFFER:
 
-            ACPI_DUMP_BUFFER (ObjDesc->Buffer.Pointer, ObjDesc->Buffer.Length);
+            ACPI_DUMP_BUFFER (
+                ObjDesc->Buffer.Pointer, ObjDesc->Buffer.Length);
             break;
 
         case ACPI_EXD_PACKAGE:
@@ -440,11 +471,129 @@ AcpiExDumpObject (
 
         case ACPI_EXD_REFERENCE:
 
-            AcpiExOutString ("Class Name",
-                ACPI_CAST_PTR (char, AcpiUtGetReferenceName (ObjDesc)));
+            AcpiExOutString ("Class Name", AcpiUtGetReferenceName (ObjDesc));
             AcpiExDumpReferenceObj (ObjDesc);
             break;
 
+        case ACPI_EXD_LIST:
+
+            Start = *ACPI_CAST_PTR (void *, Target);
+            Next = Start;
+
+            AcpiOsPrintf ("%20s : %p", Name, Next);
+            if (Next)
+            {
+                AcpiOsPrintf ("(%s %2.2X)",
+                    AcpiUtGetObjectTypeName (Next), Next->Common.Type);
+
+                while (Next->Common.NextObject)
+                {
+                    if ((Next->Common.Type == ACPI_TYPE_LOCAL_DATA) &&
+                        !Data)
+                    {
+                        Data = Next;
+                    }
+
+                    Next = Next->Common.NextObject;
+                    AcpiOsPrintf ("->%p(%s %2.2X)", Next,
+                        AcpiUtGetObjectTypeName (Next), Next->Common.Type);
+
+                    if ((Next == Start) || (Next == Data))
+                    {
+                        AcpiOsPrintf (
+                            "\n**** Error: Object list appears to be circular linked");
+                        break;
+                    }
+                }
+            }
+
+            AcpiOsPrintf ("\n");
+            break;
+
+        case ACPI_EXD_HDLR_LIST:
+
+            Start = *ACPI_CAST_PTR (void *, Target);
+            Next = Start;
+
+            AcpiOsPrintf ("%20s : %p", Name, Next);
+            if (Next)
+            {
+                AcpiOsPrintf ("(%s %2.2X)",
+                    AcpiUtGetObjectTypeName (Next),
+                    Next->AddressSpace.SpaceId);
+
+                while (Next->AddressSpace.Next)
+                {
+                    if ((Next->Common.Type == ACPI_TYPE_LOCAL_DATA) &&
+                        !Data)
+                    {
+                        Data = Next;
+                    }
+
+                    Next = Next->AddressSpace.Next;
+                    AcpiOsPrintf ("->%p(%s %2.2X)", Next,
+                        AcpiUtGetObjectTypeName (Next),
+                        Next->AddressSpace.SpaceId);
+
+                    if ((Next == Start) || (Next == Data))
+                    {
+                        AcpiOsPrintf (
+                            "\n**** Error: Handler list appears to be circular linked");
+                        break;
+                    }
+                }
+            }
+
+            AcpiOsPrintf ("\n");
+            break;
+
+        case ACPI_EXD_RGN_LIST:
+
+            Start = *ACPI_CAST_PTR (void *, Target);
+            Next = Start;
+
+            AcpiOsPrintf ("%20s : %p", Name, Next);
+            if (Next)
+            {
+                AcpiOsPrintf ("(%s %2.2X)",
+                    AcpiUtGetObjectTypeName (Next), Next->Common.Type);
+
+                while (Next->Region.Next)
+                {
+                    if ((Next->Common.Type == ACPI_TYPE_LOCAL_DATA) &&
+                        !Data)
+                    {
+                        Data = Next;
+                    }
+
+                    Next = Next->Region.Next;
+                    AcpiOsPrintf ("->%p(%s %2.2X)", Next,
+                        AcpiUtGetObjectTypeName (Next), Next->Common.Type);
+
+                    if ((Next == Start) || (Next == Data))
+                    {
+                        AcpiOsPrintf (
+                            "\n**** Error: Region list appears to be circular linked");
+                        break;
+                    }
+                }
+            }
+
+            AcpiOsPrintf ("\n");
+            break;
+
+        case ACPI_EXD_NODE:
+
+            Node = *ACPI_CAST_PTR (ACPI_NAMESPACE_NODE *, Target);
+
+            AcpiOsPrintf ("%20s : %p", Name, Node);
+            if (Node)
+            {
+                AcpiOsPrintf (" [%4.4s]", Node->Name.Ascii);
+            }
+            AcpiOsPrintf ("\n");
+            break;
+
         default:
 
             AcpiOsPrintf ("**** Invalid table opcode [%X] ****\n",
@@ -483,7 +632,9 @@ AcpiExDumpOperand (
     ACPI_FUNCTION_NAME (ExDumpOperand)
 
 
-    if (!((ACPI_LV_EXEC & AcpiDbgLevel) && (_COMPONENT & AcpiDbgLayer)))
+    /* Check if debug output enabled */
+
+    if (!ACPI_IS_DEBUG_ENABLED (ACPI_LV_EXEC, _COMPONENT))
     {
         return;
     }
@@ -530,7 +681,8 @@ AcpiExDumpOperand (
     {
     case ACPI_TYPE_LOCAL_REFERENCE:
 
-        AcpiOsPrintf ("Reference: [%s] ", AcpiUtGetReferenceName (ObjDesc));
+        AcpiOsPrintf ("Reference: [%s] ",
+            AcpiUtGetReferenceName (ObjDesc));
 
         switch (ObjDesc->Reference.Class)
         {
@@ -539,19 +691,16 @@ AcpiExDumpOperand (
             AcpiOsPrintf ("\n");
             break;
 
-
         case ACPI_REFCLASS_INDEX:
 
             AcpiOsPrintf ("%p\n", ObjDesc->Reference.Object);
             break;
 
-
         case ACPI_REFCLASS_TABLE:
 
             AcpiOsPrintf ("Table Index %X\n", ObjDesc->Reference.Value);
             break;
 
-
         case ACPI_REFCLASS_REFOF:
 
             AcpiOsPrintf ("%p [%s]\n", ObjDesc->Reference.Object,
@@ -559,20 +708,18 @@ AcpiExDumpOperand (
                     ObjDesc->Reference.Object)->Common.Type));
             break;
 
-
         case ACPI_REFCLASS_NAME:
 
-            AcpiOsPrintf ("- [%4.4s]\n", ObjDesc->Reference.Node->Name.Ascii);
+            AcpiOsPrintf ("- [%4.4s]\n",
+                ObjDesc->Reference.Node->Name.Ascii);
             break;
 
-
         case ACPI_REFCLASS_ARG:
         case ACPI_REFCLASS_LOCAL:
 
             AcpiOsPrintf ("%X\n", ObjDesc->Reference.Value);
             break;
 
-
         default:    /* Unknown reference class */
 
             AcpiOsPrintf ("%2.2X\n", ObjDesc->Reference.Class);
@@ -580,7 +727,6 @@ AcpiExDumpOperand (
         }
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         AcpiOsPrintf ("Buffer length %.2X @ %p\n",
@@ -596,20 +742,18 @@ AcpiExDumpOperand (
                 Length = 128;
             }
 
-            AcpiOsPrintf ("Buffer Contents: (displaying length 0x%.2X)\n",
-                Length);
+            AcpiOsPrintf (
+                "Buffer Contents: (displaying length 0x%.2X)\n", Length);
             ACPI_DUMP_BUFFER (ObjDesc->Buffer.Pointer, Length);
         }
         break;
 
-
     case ACPI_TYPE_INTEGER:
 
         AcpiOsPrintf ("Integer %8.8X%8.8X\n",
             ACPI_FORMAT_UINT64 (ObjDesc->Integer.Value));
         break;
 
-
     case ACPI_TYPE_PACKAGE:
 
         AcpiOsPrintf ("Package [Len %X] ElementArray %p\n",
@@ -625,12 +769,12 @@ AcpiExDumpOperand (
         {
             for (Index = 0; Index < ObjDesc->Package.Count; Index++)
             {
-                AcpiExDumpOperand (ObjDesc->Package.Elements[Index], Depth+1);
+                AcpiExDumpOperand (
+                    ObjDesc->Package.Elements[Index], Depth + 1);
             }
         }
         break;
 
-
     case ACPI_TYPE_REGION:
 
         AcpiOsPrintf ("Region %s (%X)",
@@ -648,12 +792,11 @@ AcpiExDumpOperand (
         else
         {
             AcpiOsPrintf (" base %8.8X%8.8X Length %X\n",
-                ACPI_FORMAT_NATIVE_UINT (ObjDesc->Region.Address),
+                ACPI_FORMAT_UINT64 (ObjDesc->Region.Address),
                 ObjDesc->Region.Length);
         }
         break;
 
-
     case ACPI_TYPE_STRING:
 
         AcpiOsPrintf ("String length %X @ %p ",
@@ -664,13 +807,11 @@ AcpiExDumpOperand (
         AcpiOsPrintf ("\n");
         break;
 
-
     case ACPI_TYPE_LOCAL_BANK_FIELD:
 
         AcpiOsPrintf ("BankField\n");
         break;
 
-
     case ACPI_TYPE_LOCAL_REGION_FIELD:
 
         AcpiOsPrintf ("RegionField: Bits=%X AccWidth=%X Lock=%X Update=%X at "
@@ -682,16 +823,14 @@ AcpiExDumpOperand (
             ObjDesc->Field.BaseByteOffset,
             ObjDesc->Field.StartFieldBitOffset);
 
-        AcpiExDumpOperand (ObjDesc->Field.RegionObj, Depth+1);
+        AcpiExDumpOperand (ObjDesc->Field.RegionObj, Depth + 1);
         break;
 
-
     case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
         AcpiOsPrintf ("IndexField\n");
         break;
 
-
     case ACPI_TYPE_BUFFER_FIELD:
 
         AcpiOsPrintf ("BufferField: %X bits at byte %X bit %X of\n",
@@ -704,23 +843,21 @@ AcpiExDumpOperand (
             ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "*NULL*\n"));
         }
         else if ((ObjDesc->BufferField.BufferObj)->Common.Type !=
-                    ACPI_TYPE_BUFFER)
+            ACPI_TYPE_BUFFER)
         {
             AcpiOsPrintf ("*not a Buffer*\n");
         }
         else
         {
-            AcpiExDumpOperand (ObjDesc->BufferField.BufferObj, Depth+1);
+            AcpiExDumpOperand (ObjDesc->BufferField.BufferObj, Depth + 1);
         }
         break;
 
-
     case ACPI_TYPE_EVENT:
 
         AcpiOsPrintf ("Event\n");
         break;
 
-
     case ACPI_TYPE_METHOD:
 
         AcpiOsPrintf ("Method(%X) @ %p:%X\n",
@@ -729,38 +866,33 @@ AcpiExDumpOperand (
             ObjDesc->Method.AmlLength);
         break;
 
-
     case ACPI_TYPE_MUTEX:
 
         AcpiOsPrintf ("Mutex\n");
         break;
 
-
     case ACPI_TYPE_DEVICE:
 
         AcpiOsPrintf ("Device\n");
         break;
 
-
     case ACPI_TYPE_POWER:
 
         AcpiOsPrintf ("Power\n");
         break;
 
-
     case ACPI_TYPE_PROCESSOR:
 
         AcpiOsPrintf ("Processor\n");
         break;
 
-
     case ACPI_TYPE_THERMAL:
 
         AcpiOsPrintf ("Thermal\n");
         break;
 
-
     default:
+
         /* Unknown Type */
 
         AcpiOsPrintf ("Unknown Type %X\n", ObjDesc->Common.Type);
@@ -828,7 +960,7 @@ AcpiExDumpOperands (
  * PARAMETERS:  Title               - Descriptive text
  *              Value               - Value to be displayed
  *
- * DESCRIPTION: Object dump output formatting functions.  These functions
+ * DESCRIPTION: Object dump output formatting functions. These functions
  *              reduce the number of format strings required and keeps them
  *              all in one place for easy modification.
  *
@@ -836,16 +968,16 @@ AcpiExDumpOperands (
 
 static void
 AcpiExOutString (
-    char                    *Title,
-    char                    *Value)
+    const char              *Title,
+    const char              *Value)
 {
     AcpiOsPrintf ("%20s : %s\n", Title, Value);
 }
 
 static void
 AcpiExOutPointer (
-    char                    *Title,
-    void                    *Value)
+    const char              *Title,
+    const void              *Value)
 {
     AcpiOsPrintf ("%20s : %p\n", Title, Value);
 }
@@ -873,16 +1005,17 @@ AcpiExDumpNamespaceNode (
 
     if (!Flags)
     {
-        if (!((ACPI_LV_OBJECTS & AcpiDbgLevel) && (_COMPONENT & AcpiDbgLayer)))
+        /* Check if debug output enabled */
+
+        if (!ACPI_IS_DEBUG_ENABLED (ACPI_LV_OBJECTS, _COMPONENT))
         {
             return;
         }
     }
 
     AcpiOsPrintf ("%20s : %4.4s\n", "Name", AcpiUtGetNodeName (Node));
-    AcpiExOutString  ("Type", AcpiUtGetTypeName (Node->Type));
-    AcpiExOutPointer ("Attached Object", AcpiNsGetAttachedObject (Node));
-    AcpiExOutPointer ("Parent", Node->Parent);
+    AcpiOsPrintf ("%20s : %2.2X [%s]\n", "Type",
+        Node->Type, AcpiUtGetTypeName (Node->Type));
 
     AcpiExDumpObject (ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Node),
         AcpiExDumpNode);
@@ -913,7 +1046,8 @@ AcpiExDumpReferenceObj (
     {
         AcpiOsPrintf (" %p ", ObjDesc->Reference.Node);
 
-        Status = AcpiNsHandleToPathname (ObjDesc->Reference.Node, &RetBuf);
+        Status = AcpiNsHandleToPathname (ObjDesc->Reference.Node,
+            &RetBuf, TRUE);
         if (ACPI_FAILURE (Status))
         {
             AcpiOsPrintf (" Could not convert name to pathname\n");
@@ -928,16 +1062,18 @@ AcpiExDumpReferenceObj (
     {
         if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) == ACPI_DESC_TYPE_OPERAND)
         {
-            AcpiOsPrintf (" Target: %p", ObjDesc->Reference.Object);
+            AcpiOsPrintf ("%22s %p", "Target :",
+                ObjDesc->Reference.Object);
             if (ObjDesc->Reference.Class == ACPI_REFCLASS_TABLE)
             {
-                AcpiOsPrintf (" Table Index: %X\n", ObjDesc->Reference.Value);
+                AcpiOsPrintf (" Table Index: %X\n",
+                    ObjDesc->Reference.Value);
             }
             else
             {
-                AcpiOsPrintf (" Target: %p [%s]\n", ObjDesc->Reference.Object,
+                AcpiOsPrintf (" [%s]\n",
                     AcpiUtGetTypeName (((ACPI_OPERAND_OBJECT *)
-                        ObjDesc->Reference.Object)->Common.Type));
+                    ObjDesc->Reference.Object)->Common.Type));
             }
         }
         else
@@ -1001,7 +1137,6 @@ AcpiExDumpPackageObj (
             ACPI_FORMAT_UINT64 (ObjDesc->Integer.Value));
         break;
 
-
     case ACPI_TYPE_STRING:
 
         AcpiOsPrintf ("[String]  Value: ");
@@ -1009,13 +1144,13 @@ AcpiExDumpPackageObj (
         AcpiOsPrintf ("\n");
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         AcpiOsPrintf ("[Buffer] Length %.2X = ", ObjDesc->Buffer.Length);
         if (ObjDesc->Buffer.Length)
         {
-            AcpiUtDumpBuffer (ACPI_CAST_PTR (UINT8, ObjDesc->Buffer.Pointer),
+            AcpiUtDebugDumpBuffer (
+                ACPI_CAST_PTR (UINT8, ObjDesc->Buffer.Pointer),
                 ObjDesc->Buffer.Length, DB_DWORD_DISPLAY, _COMPONENT);
         }
         else
@@ -1024,7 +1159,6 @@ AcpiExDumpPackageObj (
         }
         break;
 
-
     case ACPI_TYPE_PACKAGE:
 
         AcpiOsPrintf ("[Package] Contains %u Elements:\n",
@@ -1032,11 +1166,11 @@ AcpiExDumpPackageObj (
 
         for (i = 0; i < ObjDesc->Package.Count; i++)
         {
-            AcpiExDumpPackageObj (ObjDesc->Package.Elements[i], Level+1, i);
+            AcpiExDumpPackageObj (
+                ObjDesc->Package.Elements[i], Level + 1, i);
         }
         break;
 
-
     case ACPI_TYPE_LOCAL_REFERENCE:
 
         AcpiOsPrintf ("[Object Reference] Type [%s] %2.2X",
@@ -1045,7 +1179,6 @@ AcpiExDumpPackageObj (
         AcpiExDumpReferenceObj (ObjDesc);
         break;
 
-
     default:
 
         AcpiOsPrintf ("[Unknown Type] %X\n", ObjDesc->Common.Type);
@@ -1080,7 +1213,9 @@ AcpiExDumpObjectDescriptor (
 
     if (!Flags)
     {
-        if (!((ACPI_LV_OBJECTS & AcpiDbgLevel) && (_COMPONENT & AcpiDbgLayer)))
+        /* Check if debug output enabled */
+
+        if (!ACPI_IS_DEBUG_ENABLED (ACPI_LV_OBJECTS, _COMPONENT))
         {
             return_VOID;
         }
@@ -1093,24 +1228,30 @@ AcpiExDumpObjectDescriptor (
         AcpiOsPrintf ("\nAttached Object (%p):\n",
             ((ACPI_NAMESPACE_NODE *) ObjDesc)->Object);
 
-        AcpiExDumpObjectDescriptor (
-            ((ACPI_NAMESPACE_NODE *) ObjDesc)->Object, Flags);
-        return_VOID;
+        ObjDesc = ((ACPI_NAMESPACE_NODE *) ObjDesc)->Object;
+        goto DumpObject;
     }
 
     if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) != ACPI_DESC_TYPE_OPERAND)
     {
         AcpiOsPrintf (
-            "ExDumpObjectDescriptor: %p is not an ACPI operand object: [%s]\n",
+            "%p is not an ACPI operand object: [%s]\n",
             ObjDesc, AcpiUtGetDescriptorName (ObjDesc));
         return_VOID;
     }
 
-    if (ObjDesc->Common.Type > ACPI_TYPE_NS_NODE_MAX)
+    /* Validate the object type */
+
+    if (ObjDesc->Common.Type > ACPI_TYPE_LOCAL_MAX)
     {
+        AcpiOsPrintf ("Not a known object type: %2.2X\n",
+            ObjDesc->Common.Type);
         return_VOID;
     }
 
+
+DumpObject:
+
     /* Common Fields */
 
     AcpiExDumpObject (ObjDesc, AcpiExDumpCommon);
@@ -1118,8 +1259,24 @@ AcpiExDumpObjectDescriptor (
     /* Object-specific fields */
 
     AcpiExDumpObject (ObjDesc, AcpiExDumpInfo[ObjDesc->Common.Type]);
+
+    if (ObjDesc->Common.Type == ACPI_TYPE_REGION)
+    {
+        ObjDesc = ObjDesc->Common.NextObject;
+        if (ObjDesc->Common.Type > ACPI_TYPE_LOCAL_MAX)
+        {
+            AcpiOsPrintf (
+                "Secondary object is not a known object type: %2.2X\n",
+                ObjDesc->Common.Type);
+
+            return_VOID;
+        }
+
+        AcpiOsPrintf ("\nExtra attached Object (%p):\n", ObjDesc);
+        AcpiExDumpObject (ObjDesc, AcpiExDumpInfo[ObjDesc->Common.Type]);
+    }
+
     return_VOID;
 }
 
 #endif
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exfield.c b/usr/src/uts/intel/io/acpica/executer/exfield.c
index a682406826..208af63794 100644
--- a/usr/src/uts/intel/io/acpica/executer/exfield.c
+++ b/usr/src/uts/intel/io/acpica/executer/exfield.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,18 +41,84 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EXFIELD_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdispat.h"
 #include "acinterp.h"
+#include "amlcode.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
         ACPI_MODULE_NAME    ("exfield")
 
+/* Local prototypes */
+
+static UINT32
+AcpiExGetSerialAccessLength (
+    UINT32                  AccessorType,
+    UINT32                  AccessLength);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExGetSerialAccessLength
+ *
+ * PARAMETERS:  AccessorType    - The type of the protocol indicated by region
+ *                                field access attributes
+ *              AccessLength    - The access length of the region field
+ *
+ * RETURN:      Decoded access length
+ *
+ * DESCRIPTION: This routine returns the length of the GenericSerialBus
+ *              protocol bytes
+ *
+ ******************************************************************************/
+
+static UINT32
+AcpiExGetSerialAccessLength (
+    UINT32                  AccessorType,
+    UINT32                  AccessLength)
+{
+    UINT32                  Length;
+
+
+    switch (AccessorType)
+    {
+    case AML_FIELD_ATTRIB_QUICK:
+
+        Length = 0;
+        break;
+
+    case AML_FIELD_ATTRIB_SEND_RCV:
+    case AML_FIELD_ATTRIB_BYTE:
+
+        Length = 1;
+        break;
+
+    case AML_FIELD_ATTRIB_WORD:
+    case AML_FIELD_ATTRIB_WORD_CALL:
+
+        Length = 2;
+        break;
+
+    case AML_FIELD_ATTRIB_MULTIBYTE:
+    case AML_FIELD_ATTRIB_RAW_BYTES:
+    case AML_FIELD_ATTRIB_RAW_PROCESS:
+
+        Length = AccessLength;
+        break;
+
+    case AML_FIELD_ATTRIB_BLOCK:
+    case AML_FIELD_ATTRIB_BLOCK_CALL:
+    default:
+
+        Length = ACPI_GSBUS_BUFFER_SIZE - 2;
+        break;
+    }
+
+    return (Length);
+}
+
 
 /*******************************************************************************
  *
@@ -64,7 +130,7 @@
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Read from a named field.  Returns either an Integer or a
+ * DESCRIPTION: Read from a named field. Returns either an Integer or a
  *              Buffer, depending on the size of the field.
  *
  ******************************************************************************/
@@ -80,6 +146,7 @@ AcpiExReadDataFromField (
     ACPI_SIZE               Length;
     void                    *Buffer;
     UINT32                  Function;
+    UINT16                  AccessorType;
 
 
     ACPI_FUNCTION_TRACE_PTR (ExReadDataFromField, ObjDesc);
@@ -117,20 +184,34 @@ AcpiExReadDataFromField (
               ObjDesc->Field.RegionObj->Region.SpaceId == ACPI_ADR_SPACE_IPMI))
     {
         /*
-         * This is an SMBus, GSBus or IPMI read. We must create a buffer to hold
-         * the data and then directly access the region handler.
+         * This is an SMBus, GSBus or IPMI read. We must create a buffer to
+         * hold the data and then directly access the region handler.
          *
-         * Note: SMBus and GSBus protocol value is passed in upper 16-bits of Function
+         * Note: SMBus and GSBus protocol value is passed in upper 16-bits
+         * of Function
          */
-        if (ObjDesc->Field.RegionObj->Region.SpaceId == ACPI_ADR_SPACE_SMBUS)
+        if (ObjDesc->Field.RegionObj->Region.SpaceId ==
+            ACPI_ADR_SPACE_SMBUS)
         {
             Length = ACPI_SMBUS_BUFFER_SIZE;
             Function = ACPI_READ | (ObjDesc->Field.Attribute << 16);
         }
-        else if (ObjDesc->Field.RegionObj->Region.SpaceId == ACPI_ADR_SPACE_GSBUS)
+        else if (ObjDesc->Field.RegionObj->Region.SpaceId ==
+            ACPI_ADR_SPACE_GSBUS)
         {
-            Length = ACPI_GSBUS_BUFFER_SIZE;
-            Function = ACPI_READ | (ObjDesc->Field.Attribute << 16);
+            AccessorType = ObjDesc->Field.Attribute;
+            Length = AcpiExGetSerialAccessLength (
+                AccessorType, ObjDesc->Field.AccessLength);
+
+            /*
+             * Add additional 2 bytes for the GenericSerialBus data buffer:
+             *
+             *     Status;    (Byte 0 of the data buffer)
+             *     Length;    (Byte 1 of the data buffer)
+             *     Data[x-1]: (Bytes 2-x of the arbitrary length data buffer)
+             */
+            Length += 2;
+            Function = ACPI_READ | (AccessorType << 16);
         }
         else /* IPMI */
         {
@@ -151,8 +232,8 @@ AcpiExReadDataFromField (
         /* Call the region handler for the read */
 
         Status = AcpiExAccessRegion (ObjDesc, 0,
-                    ACPI_CAST_PTR (UINT64, BufferDesc->Buffer.Pointer),
-                    Function);
+            ACPI_CAST_PTR (UINT64, BufferDesc->Buffer.Pointer), Function);
+
         AcpiExReleaseGlobalLock (ObjDesc->CommonField.FieldFlags);
         goto Exit;
     }
@@ -161,13 +242,15 @@ AcpiExReadDataFromField (
      * Allocate a buffer for the contents of the field.
      *
      * If the field is larger than the current integer width, create
-     * a BUFFER to hold it.  Otherwise, use an INTEGER.  This allows
+     * a BUFFER to hold it. Otherwise, use an INTEGER. This allows
      * the use of arithmetic operators on the returned value if the
      * field size is equal or smaller than an Integer.
      *
      * Note: Field.length is in bits.
      */
-    Length = (ACPI_SIZE) ACPI_ROUND_BITS_UP_TO_BYTES (ObjDesc->Field.BitLength);
+    Length = (ACPI_SIZE) ACPI_ROUND_BITS_UP_TO_BYTES (
+        ObjDesc->Field.BitLength);
+
     if (Length > AcpiGbl_IntegerByteWidth)
     {
         /* Field is too large for an Integer, create a Buffer instead */
@@ -193,6 +276,40 @@ AcpiExReadDataFromField (
         Buffer = &BufferDesc->Integer.Value;
     }
 
+    if ((ObjDesc->Common.Type == ACPI_TYPE_LOCAL_REGION_FIELD) &&
+        (ObjDesc->Field.RegionObj->Region.SpaceId == ACPI_ADR_SPACE_GPIO))
+    {
+        /*
+         * For GPIO (GeneralPurposeIo), the Address will be the bit offset
+         * from the previous Connection() operator, making it effectively a
+         * pin number index. The BitLength is the length of the field, which
+         * is thus the number of pins.
+         */
+        ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+            "GPIO FieldRead [FROM]:  Pin %u Bits %u\n",
+            ObjDesc->Field.PinNumberIndex, ObjDesc->Field.BitLength));
+
+        /* Lock entire transaction if requested */
+
+        AcpiExAcquireGlobalLock (ObjDesc->CommonField.FieldFlags);
+
+        /* Perform the write */
+
+        Status = AcpiExAccessRegion (
+            ObjDesc, 0, (UINT64 *) Buffer, ACPI_READ);
+
+        AcpiExReleaseGlobalLock (ObjDesc->CommonField.FieldFlags);
+        if (ACPI_FAILURE (Status))
+        {
+            AcpiUtRemoveReference (BufferDesc);
+        }
+        else
+        {
+            *RetBufferDesc = BufferDesc;
+        }
+        return_ACPI_STATUS (Status);
+    }
+
     ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
         "FieldRead [TO]:   Obj %p, Type %X, Buf %p, ByteLen %X\n",
         ObjDesc, ObjDesc->Common.Type, Buffer, (UINT32) Length));
@@ -251,6 +368,7 @@ AcpiExWriteDataToField (
     void                    *Buffer;
     ACPI_OPERAND_OBJECT     *BufferDesc;
     UINT32                  Function;
+    UINT16                  AccessorType;
 
 
     ACPI_FUNCTION_TRACE_PTR (ExWriteDataToField, ObjDesc);
@@ -284,34 +402,50 @@ AcpiExWriteDataToField (
               ObjDesc->Field.RegionObj->Region.SpaceId == ACPI_ADR_SPACE_IPMI))
     {
         /*
-         * This is an SMBus, GSBus or IPMI write. We will bypass the entire field
-         * mechanism and handoff the buffer directly to the handler. For
-         * these address spaces, the buffer is bi-directional; on a write,
-         * return data is returned in the same buffer.
+         * This is an SMBus, GSBus or IPMI write. We will bypass the entire
+         * field mechanism and handoff the buffer directly to the handler.
+         * For these address spaces, the buffer is bi-directional; on a
+         * write, return data is returned in the same buffer.
          *
          * Source must be a buffer of sufficient size:
-         * ACPI_SMBUS_BUFFER_SIZE, ACPI_GSBUS_BUFFER_SIZE, or ACPI_IPMI_BUFFER_SIZE.
+         * ACPI_SMBUS_BUFFER_SIZE, ACPI_GSBUS_BUFFER_SIZE, or
+         * ACPI_IPMI_BUFFER_SIZE.
          *
-         * Note: SMBus and GSBus protocol type is passed in upper 16-bits of Function
+         * Note: SMBus and GSBus protocol type is passed in upper 16-bits
+         * of Function
          */
         if (SourceDesc->Common.Type != ACPI_TYPE_BUFFER)
         {
             ACPI_ERROR ((AE_INFO,
-                "SMBus/IPMI/GenericSerialBus write requires Buffer, found type %s",
+                "SMBus/IPMI/GenericSerialBus write requires "
+                "Buffer, found type %s",
                 AcpiUtGetObjectTypeName (SourceDesc)));
 
             return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
         }
 
-        if (ObjDesc->Field.RegionObj->Region.SpaceId == ACPI_ADR_SPACE_SMBUS)
+        if (ObjDesc->Field.RegionObj->Region.SpaceId ==
+            ACPI_ADR_SPACE_SMBUS)
         {
             Length = ACPI_SMBUS_BUFFER_SIZE;
             Function = ACPI_WRITE | (ObjDesc->Field.Attribute << 16);
         }
-        else if (ObjDesc->Field.RegionObj->Region.SpaceId == ACPI_ADR_SPACE_GSBUS)
+        else if (ObjDesc->Field.RegionObj->Region.SpaceId ==
+            ACPI_ADR_SPACE_GSBUS)
         {
-            Length = ACPI_GSBUS_BUFFER_SIZE;
-            Function = ACPI_WRITE | (ObjDesc->Field.Attribute << 16);
+            AccessorType = ObjDesc->Field.Attribute;
+            Length = AcpiExGetSerialAccessLength (
+                AccessorType, ObjDesc->Field.AccessLength);
+
+            /*
+             * Add additional 2 bytes for the GenericSerialBus data buffer:
+             *
+             *     Status;    (Byte 0 of the data buffer)
+             *     Length;    (Byte 1 of the data buffer)
+             *     Data[x-1]: (Bytes 2-x of the arbitrary length data buffer)
+             */
+            Length += 2;
+            Function = ACPI_WRITE | (AccessorType << 16);
         }
         else /* IPMI */
         {
@@ -322,7 +456,8 @@ AcpiExWriteDataToField (
         if (SourceDesc->Buffer.Length < Length)
         {
             ACPI_ERROR ((AE_INFO,
-                "SMBus/IPMI/GenericSerialBus write requires Buffer of length %u, found length %u",
+                "SMBus/IPMI/GenericSerialBus write requires "
+                "Buffer of length %u, found length %u",
                 Length, SourceDesc->Buffer.Length));
 
             return_ACPI_STATUS (AE_AML_BUFFER_LIMIT);
@@ -337,7 +472,7 @@ AcpiExWriteDataToField (
         }
 
         Buffer = BufferDesc->Buffer.Pointer;
-        ACPI_MEMCPY (Buffer, SourceDesc->Buffer.Pointer, Length);
+        memcpy (Buffer, SourceDesc->Buffer.Pointer, Length);
 
         /* Lock entire transaction if requested */
 
@@ -347,34 +482,73 @@ AcpiExWriteDataToField (
          * Perform the write (returns status and perhaps data in the
          * same buffer)
          */
-        Status = AcpiExAccessRegion (ObjDesc, 0,
-                    (UINT64 *) Buffer, Function);
+        Status = AcpiExAccessRegion (
+            ObjDesc, 0, (UINT64 *) Buffer, Function);
         AcpiExReleaseGlobalLock (ObjDesc->CommonField.FieldFlags);
 
         *ResultDesc = BufferDesc;
         return_ACPI_STATUS (Status);
     }
+    else if ((ObjDesc->Common.Type == ACPI_TYPE_LOCAL_REGION_FIELD) &&
+             (ObjDesc->Field.RegionObj->Region.SpaceId == ACPI_ADR_SPACE_GPIO))
+    {
+        /*
+         * For GPIO (GeneralPurposeIo), we will bypass the entire field
+         * mechanism and handoff the bit address and bit width directly to
+         * the handler. The Address will be the bit offset
+         * from the previous Connection() operator, making it effectively a
+         * pin number index. The BitLength is the length of the field, which
+         * is thus the number of pins.
+         */
+        if (SourceDesc->Common.Type != ACPI_TYPE_INTEGER)
+        {
+            return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
+        }
+
+        ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+            "GPIO FieldWrite [FROM]: (%s:%X), Val %.8X  [TO]: Pin %u Bits %u\n",
+            AcpiUtGetTypeName (SourceDesc->Common.Type),
+            SourceDesc->Common.Type, (UINT32) SourceDesc->Integer.Value,
+            ObjDesc->Field.PinNumberIndex, ObjDesc->Field.BitLength));
+
+        Buffer = &SourceDesc->Integer.Value;
+
+        /* Lock entire transaction if requested */
+
+        AcpiExAcquireGlobalLock (ObjDesc->CommonField.FieldFlags);
+
+        /* Perform the write */
+
+        Status = AcpiExAccessRegion (
+            ObjDesc, 0, (UINT64 *) Buffer, ACPI_WRITE);
+        AcpiExReleaseGlobalLock (ObjDesc->CommonField.FieldFlags);
+        return_ACPI_STATUS (Status);
+    }
 
     /* Get a pointer to the data to be written */
 
     switch (SourceDesc->Common.Type)
     {
     case ACPI_TYPE_INTEGER:
+
         Buffer = &SourceDesc->Integer.Value;
         Length = sizeof (SourceDesc->Integer.Value);
         break;
 
     case ACPI_TYPE_BUFFER:
+
         Buffer = SourceDesc->Buffer.Pointer;
         Length = SourceDesc->Buffer.Length;
         break;
 
     case ACPI_TYPE_STRING:
+
         Buffer = SourceDesc->String.Pointer;
         Length = SourceDesc->String.Length;
         break;
 
     default:
+
         return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
     }
 
@@ -402,5 +576,3 @@ AcpiExWriteDataToField (
 
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exfldio.c b/usr/src/uts/intel/io/acpica/executer/exfldio.c
index e138e9a13c..fd46a0c023 100644
--- a/usr/src/uts/intel/io/acpica/executer/exfldio.c
+++ b/usr/src/uts/intel/io/acpica/executer/exfldio.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EXFLDIO_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -86,7 +83,7 @@ AcpiExSetupRegion (
  * RETURN:      Status
  *
  * DESCRIPTION: Common processing for AcpiExExtractFromField and
- *              AcpiExInsertIntoField.  Initialize the Region if necessary and
+ *              AcpiExInsertIntoField. Initialize the Region if necessary and
  *              validate the request.
  *
  ******************************************************************************/
@@ -123,7 +120,8 @@ AcpiExSetupRegion (
 
     if (!AcpiIsValidSpaceId (SpaceId))
     {
-        ACPI_ERROR ((AE_INFO, "Invalid/unknown Address Space ID: 0x%2.2X", SpaceId));
+        ACPI_ERROR ((AE_INFO,
+            "Invalid/unknown Address Space ID: 0x%2.2X", SpaceId));
         return_ACPI_STATUS (AE_AML_INVALID_SPACE_ID);
     }
 
@@ -168,13 +166,13 @@ AcpiExSetupRegion (
 #endif
 
     /*
-     * Validate the request.  The entire request from the byte offset for a
+     * Validate the request. The entire request from the byte offset for a
      * length of one field datum (access width) must fit within the region.
      * (Region length is specified in bytes)
      */
     if (RgnDesc->Region.Length <
-            (ObjDesc->CommonField.BaseByteOffset + FieldDatumByteOffset +
-            ObjDesc->CommonField.AccessByteWidth))
+        (ObjDesc->CommonField.BaseByteOffset + FieldDatumByteOffset +
+        ObjDesc->CommonField.AccessByteWidth))
     {
         if (AcpiGbl_EnableInterpreterSlack)
         {
@@ -197,11 +195,12 @@ AcpiExSetupRegion (
         {
             /*
              * This is the case where the AccessType (AccWord, etc.) is wider
-             * than the region itself.  For example, a region of length one
+             * than the region itself. For example, a region of length one
              * byte, and a field with Dword access specified.
              */
             ACPI_ERROR ((AE_INFO,
-                "Field [%4.4s] access width (%u bytes) too large for region [%4.4s] (length %u)",
+                "Field [%4.4s] access width (%u bytes) "
+                "too large for region [%4.4s] (length %u)",
                 AcpiUtGetNodeName (ObjDesc->CommonField.Node),
                 ObjDesc->CommonField.AccessByteWidth,
                 AcpiUtGetNodeName (RgnDesc->Region.Node),
@@ -213,7 +212,8 @@ AcpiExSetupRegion (
          * exceeds region length, indicate an error
          */
         ACPI_ERROR ((AE_INFO,
-            "Field [%4.4s] Base+Offset+Width %u+%u+%u is beyond end of region [%4.4s] (length %u)",
+            "Field [%4.4s] Base+Offset+Width %u+%u+%u "
+            "is beyond end of region [%4.4s] (length %u)",
             AcpiUtGetNodeName (ObjDesc->CommonField.Node),
             ObjDesc->CommonField.BaseByteOffset,
             FieldDatumByteOffset, ObjDesc->CommonField.AccessByteWidth,
@@ -292,19 +292,19 @@ AcpiExAccessRegion (
     }
 
     ACPI_DEBUG_PRINT_RAW ((ACPI_DB_BFIELD,
-        " Region [%s:%X], Width %X, ByteBase %X, Offset %X at %p\n",
+        " Region [%s:%X], Width %X, ByteBase %X, Offset %X at %8.8X%8.8X\n",
         AcpiUtGetRegionName (RgnDesc->Region.SpaceId),
         RgnDesc->Region.SpaceId,
         ObjDesc->CommonField.AccessByteWidth,
         ObjDesc->CommonField.BaseByteOffset,
         FieldDatumByteOffset,
-        ACPI_CAST_PTR (void, (RgnDesc->Region.Address + RegionOffset))));
+        ACPI_FORMAT_UINT64 (RgnDesc->Region.Address + RegionOffset)));
 
     /* Invoke the appropriate AddressSpace/OpRegion handler */
 
     Status = AcpiEvAddressSpaceDispatch (RgnDesc, ObjDesc,
-                Function, RegionOffset,
-                ACPI_MUL_8 (ObjDesc->CommonField.AccessByteWidth), Value);
+        Function, RegionOffset,
+        ACPI_MUL_8 (ObjDesc->CommonField.AccessByteWidth), Value);
 
     if (ACPI_FAILURE (Status))
     {
@@ -339,7 +339,7 @@ AcpiExAccessRegion (
  *
  * DESCRIPTION: Check if a value is out of range of the field being written.
  *              Used to check if the values written to Index and Bank registers
- *              are out of range.  Normally, the value is simply truncated
+ *              are out of range. Normally, the value is simply truncated
  *              to fit the field, but this case is most likely a serious
  *              coding error in the ASL.
  *
@@ -392,7 +392,7 @@ AcpiExRegisterOverflow (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Read or Write a single datum of a field.  The FieldType is
+ * DESCRIPTION: Read or Write a single datum of a field. The FieldType is
  *              demultiplexed here to handle the different types of fields
  *              (BufferField, RegionField, IndexField, BankField)
  *
@@ -459,7 +459,7 @@ AcpiExFieldDatumIo (
              * Copy the data from the source buffer.
              * Length is the field width in bytes.
              */
-            ACPI_MEMCPY (Value,
+            memcpy (Value,
                 (ObjDesc->BufferField.BufferObj)->Buffer.Pointer +
                     ObjDesc->BufferField.BaseByteOffset +
                     FieldDatumByteOffset,
@@ -471,7 +471,7 @@ AcpiExFieldDatumIo (
              * Copy the data to the target buffer.
              * Length is the field width in bytes.
              */
-            ACPI_MEMCPY ((ObjDesc->BufferField.BufferObj)->Buffer.Pointer +
+            memcpy ((ObjDesc->BufferField.BufferObj)->Buffer.Pointer +
                 ObjDesc->BufferField.BaseByteOffset +
                 FieldDatumByteOffset,
                 Value, ObjDesc->CommonField.AccessByteWidth);
@@ -480,9 +480,7 @@ AcpiExFieldDatumIo (
         Status = AE_OK;
         break;
 
-
     case ACPI_TYPE_LOCAL_BANK_FIELD:
-
         /*
          * Ensure that the BankValue is not beyond the capacity of
          * the register
@@ -512,20 +510,16 @@ AcpiExFieldDatumIo (
 
         /*lint -fallthrough */
 
-
     case ACPI_TYPE_LOCAL_REGION_FIELD:
         /*
          * For simple RegionFields, we just directly access the owning
          * Operation Region.
          */
-        Status = AcpiExAccessRegion (ObjDesc, FieldDatumByteOffset, Value,
-                    ReadWrite);
+        Status = AcpiExAccessRegion (
+            ObjDesc, FieldDatumByteOffset, Value, ReadWrite);
         break;
 
-
     case ACPI_TYPE_LOCAL_INDEX_FIELD:
-
-
         /*
          * Ensure that the IndexValue is not beyond the capacity of
          * the register
@@ -545,8 +539,7 @@ AcpiExFieldDatumIo (
             FieldDatumByteOffset));
 
         Status = AcpiExInsertIntoField (ObjDesc->IndexField.IndexObj,
-                    &FieldDatumByteOffset,
-                    sizeof (FieldDatumByteOffset));
+            &FieldDatumByteOffset, sizeof (FieldDatumByteOffset));
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -559,8 +552,8 @@ AcpiExFieldDatumIo (
             ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
                 "Read from Data Register\n"));
 
-            Status = AcpiExExtractFromField (ObjDesc->IndexField.DataObj,
-                        Value, sizeof (UINT64));
+            Status = AcpiExExtractFromField (
+                ObjDesc->IndexField.DataObj, Value, sizeof (UINT64));
         }
         else
         {
@@ -570,12 +563,11 @@ AcpiExFieldDatumIo (
                 "Write to Data Register: Value %8.8X%8.8X\n",
                 ACPI_FORMAT_UINT64 (*Value)));
 
-            Status = AcpiExInsertIntoField (ObjDesc->IndexField.DataObj,
-                        Value, sizeof (UINT64));
+            Status = AcpiExInsertIntoField (
+                ObjDesc->IndexField.DataObj, Value, sizeof (UINT64));
         }
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Wrong object type in field I/O %u",
@@ -654,14 +646,14 @@ AcpiExWriteWithUpdateRule (
              * ones)  The left shift drops the bits we want to ignore.
              */
             if ((~Mask << (ACPI_MUL_8 (sizeof (Mask)) -
-                           ACPI_MUL_8 (ObjDesc->CommonField.AccessByteWidth))) != 0)
+                   ACPI_MUL_8 (ObjDesc->CommonField.AccessByteWidth))) != 0)
             {
                 /*
                  * Read the current contents of the byte/word/dword containing
                  * the field, and merge with the new field value.
                  */
-                Status = AcpiExFieldDatumIo (ObjDesc, FieldDatumByteOffset,
-                            &CurrentValue, ACPI_READ);
+                Status = AcpiExFieldDatumIo (
+                    ObjDesc, FieldDatumByteOffset, &CurrentValue, ACPI_READ);
                 if (ACPI_FAILURE (Status))
                 {
                     return_ACPI_STATUS (Status);
@@ -689,13 +681,15 @@ AcpiExWriteWithUpdateRule (
 
             ACPI_ERROR ((AE_INFO,
                 "Unknown UpdateRule value: 0x%X",
-                (ObjDesc->CommonField.FieldFlags & AML_FIELD_UPDATE_RULE_MASK)));
+                (ObjDesc->CommonField.FieldFlags &
+                    AML_FIELD_UPDATE_RULE_MASK)));
             return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
         }
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-        "Mask %8.8X%8.8X, DatumOffset %X, Width %X, Value %8.8X%8.8X, MergedValue %8.8X%8.8X\n",
+        "Mask %8.8X%8.8X, DatumOffset %X, Width %X, "
+        "Value %8.8X%8.8X, MergedValue %8.8X%8.8X\n",
         ACPI_FORMAT_UINT64 (Mask),
         FieldDatumByteOffset,
         ObjDesc->CommonField.AccessByteWidth,
@@ -704,8 +698,8 @@ AcpiExWriteWithUpdateRule (
 
     /* Write the merged value */
 
-    Status = AcpiExFieldDatumIo (ObjDesc, FieldDatumByteOffset,
-                &MergedValue, ACPI_WRITE);
+    Status = AcpiExFieldDatumIo (
+        ObjDesc, FieldDatumByteOffset, &MergedValue, ACPI_WRITE);
 
     return_ACPI_STATUS (Status);
 }
@@ -758,7 +752,7 @@ AcpiExExtractFromField (
         return_ACPI_STATUS (AE_BUFFER_OVERFLOW);
     }
 
-    ACPI_MEMSET (Buffer, 0, BufferLength);
+    memset (Buffer, 0, BufferLength);
     AccessBitWidth = ACPI_MUL_8 (ObjDesc->CommonField.AccessByteWidth);
 
     /* Handle the simple case here */
@@ -766,7 +760,18 @@ AcpiExExtractFromField (
     if ((ObjDesc->CommonField.StartFieldBitOffset == 0) &&
         (ObjDesc->CommonField.BitLength == AccessBitWidth))
     {
-        Status = AcpiExFieldDatumIo (ObjDesc, 0, Buffer, ACPI_READ);
+        if (BufferLength >= sizeof (UINT64))
+        {
+            Status = AcpiExFieldDatumIo (ObjDesc, 0, Buffer, ACPI_READ);
+        }
+        else
+        {
+            /* Use RawDatum (UINT64) to handle buffers < 64 bits */
+
+            Status = AcpiExFieldDatumIo (ObjDesc, 0, &RawDatum, ACPI_READ);
+            memcpy (Buffer, &RawDatum, BufferLength);
+        }
+
         return_ACPI_STATUS (Status);
     }
 
@@ -805,8 +810,8 @@ AcpiExExtractFromField (
         /* Get next input datum from the field */
 
         FieldOffset += ObjDesc->CommonField.AccessByteWidth;
-        Status = AcpiExFieldDatumIo (ObjDesc, FieldOffset,
-                    &RawDatum, ACPI_READ);
+        Status = AcpiExFieldDatumIo (
+            ObjDesc, FieldOffset, &RawDatum, ACPI_READ);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -834,7 +839,7 @@ AcpiExExtractFromField (
 
         /* Write merged datum to target buffer */
 
-        ACPI_MEMCPY (((char *) Buffer) + BufferOffset, &MergedDatum,
+        memcpy (((char *) Buffer) + BufferOffset, &MergedDatum,
             ACPI_MIN(ObjDesc->CommonField.AccessByteWidth,
                 BufferLength - BufferOffset));
 
@@ -852,7 +857,7 @@ AcpiExExtractFromField (
 
     /* Write the last datum to the buffer */
 
-    ACPI_MEMCPY (((char *) Buffer) + BufferOffset, &MergedDatum,
+    memcpy (((char *) Buffer) + BufferOffset, &MergedDatum,
         ACPI_MIN(ObjDesc->CommonField.AccessByteWidth,
             BufferLength - BufferOffset));
 
@@ -903,10 +908,11 @@ AcpiExInsertIntoField (
 
     NewBuffer = NULL;
     RequiredLength = ACPI_ROUND_BITS_UP_TO_BYTES (
-                        ObjDesc->CommonField.BitLength);
+        ObjDesc->CommonField.BitLength);
+
     /*
      * We must have a buffer that is at least as long as the field
-     * we are writing to.  This is because individual fields are
+     * we are writing to. This is because individual fields are
      * indivisible and partial writes are not supported -- as per
      * the ACPI specification.
      */
@@ -922,10 +928,10 @@ AcpiExInsertIntoField (
 
         /*
          * Copy the original data to the new buffer, starting
-         * at Byte zero.  All unused (upper) bytes of the
+         * at Byte zero. All unused (upper) bytes of the
          * buffer will be 0.
          */
-        ACPI_MEMCPY ((char *) NewBuffer, (char *) Buffer, BufferLength);
+        memcpy ((char *) NewBuffer, (char *) Buffer, BufferLength);
         Buffer = NewBuffer;
         BufferLength = RequiredLength;
     }
@@ -968,7 +974,7 @@ AcpiExInsertIntoField (
 
     /* Get initial Datum from the input buffer */
 
-    ACPI_MEMCPY (&RawDatum, Buffer,
+    memcpy (&RawDatum, Buffer,
         ACPI_MIN(ObjDesc->CommonField.AccessByteWidth,
             BufferLength - BufferOffset));
 
@@ -981,8 +987,8 @@ AcpiExInsertIntoField (
         /* Write merged datum to the target field */
 
         MergedDatum &= Mask;
-        Status = AcpiExWriteWithUpdateRule (ObjDesc, Mask,
-                    MergedDatum, FieldOffset);
+        Status = AcpiExWriteWithUpdateRule (
+            ObjDesc, Mask, MergedDatum, FieldOffset);
         if (ACPI_FAILURE (Status))
         {
             goto Exit;
@@ -1020,7 +1026,7 @@ AcpiExInsertIntoField (
         /* Get the next input datum from the buffer */
 
         BufferOffset += ObjDesc->CommonField.AccessByteWidth;
-        ACPI_MEMCPY (&RawDatum, ((char *) Buffer) + BufferOffset,
+        memcpy (&RawDatum, ((char *) Buffer) + BufferOffset,
             ACPI_MIN(ObjDesc->CommonField.AccessByteWidth,
                  BufferLength - BufferOffset));
 
@@ -1039,8 +1045,8 @@ AcpiExInsertIntoField (
     /* Write the last datum to the field */
 
     MergedDatum &= Mask;
-    Status = AcpiExWriteWithUpdateRule (ObjDesc,
-                Mask, MergedDatum, FieldOffset);
+    Status = AcpiExWriteWithUpdateRule (
+        ObjDesc, Mask, MergedDatum, FieldOffset);
 
 Exit:
     /* Free temporary buffer if we used one */
@@ -1051,5 +1057,3 @@ Exit:
     }
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exmisc.c b/usr/src/uts/intel/io/acpica/executer/exmisc.c
index 63114f5584..a8e5497a9d 100644
--- a/usr/src/uts/intel/io/acpica/executer/exmisc.c
+++ b/usr/src/uts/intel/io/acpica/executer/exmisc.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exmisc - ACPI AML (p-code) execution - specific opcodes
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,13 +41,10 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXMISC_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
 #include "amlcode.h"
-#include "amlresrc.h"
 
 
 #define _COMPONENT          ACPI_EXECUTER
@@ -110,22 +106,19 @@ AcpiExGetObjectReference (
 
         default:
 
-            ACPI_ERROR ((AE_INFO, "Unknown Reference Class 0x%2.2X",
+            ACPI_ERROR ((AE_INFO, "Invalid Reference Class 0x%2.2X",
                 ObjDesc->Reference.Class));
-            return_ACPI_STATUS (AE_AML_INTERNAL);
+            return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
         }
         break;
 
-
     case ACPI_DESC_TYPE_NAMED:
-
         /*
          * A named reference that has already been resolved to a Node
          */
         ReferencedObj = ObjDesc;
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Invalid descriptor type 0x%X",
@@ -154,271 +147,6 @@ AcpiExGetObjectReference (
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiExConcatTemplate
- *
- * PARAMETERS:  Operand0            - First source object
- *              Operand1            - Second source object
- *              ActualReturnDesc    - Where to place the return object
- *              WalkState           - Current walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Concatenate two resource templates
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiExConcatTemplate (
-    ACPI_OPERAND_OBJECT     *Operand0,
-    ACPI_OPERAND_OBJECT     *Operand1,
-    ACPI_OPERAND_OBJECT     **ActualReturnDesc,
-    ACPI_WALK_STATE         *WalkState)
-{
-    ACPI_STATUS             Status;
-    ACPI_OPERAND_OBJECT     *ReturnDesc;
-    UINT8                   *NewBuf;
-    UINT8                   *EndTag;
-    ACPI_SIZE               Length0;
-    ACPI_SIZE               Length1;
-    ACPI_SIZE               NewLength;
-
-
-    ACPI_FUNCTION_TRACE (ExConcatTemplate);
-
-
-    /*
-     * Find the EndTag descriptor in each resource template.
-     * Note1: returned pointers point TO the EndTag, not past it.
-     * Note2: zero-length buffers are allowed; treated like one EndTag
-     */
-
-    /* Get the length of the first resource template */
-
-    Status = AcpiUtGetResourceEndTag (Operand0, &EndTag);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    Length0 = ACPI_PTR_DIFF (EndTag, Operand0->Buffer.Pointer);
-
-    /* Get the length of the second resource template */
-
-    Status = AcpiUtGetResourceEndTag (Operand1, &EndTag);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    Length1 = ACPI_PTR_DIFF (EndTag, Operand1->Buffer.Pointer);
-
-    /* Combine both lengths, minimum size will be 2 for EndTag */
-
-    NewLength = Length0 + Length1 + sizeof (AML_RESOURCE_END_TAG);
-
-    /* Create a new buffer object for the result (with one EndTag) */
-
-    ReturnDesc = AcpiUtCreateBufferObject (NewLength);
-    if (!ReturnDesc)
-    {
-        return_ACPI_STATUS (AE_NO_MEMORY);
-    }
-
-    /*
-     * Copy the templates to the new buffer, 0 first, then 1 follows. One
-     * EndTag descriptor is copied from Operand1.
-     */
-    NewBuf = ReturnDesc->Buffer.Pointer;
-    ACPI_MEMCPY (NewBuf, Operand0->Buffer.Pointer, Length0);
-    ACPI_MEMCPY (NewBuf + Length0, Operand1->Buffer.Pointer, Length1);
-
-    /* Insert EndTag and set the checksum to zero, means "ignore checksum" */
-
-    NewBuf[NewLength - 1] = 0;
-    NewBuf[NewLength - 2] = ACPI_RESOURCE_NAME_END_TAG | 1;
-
-    /* Return the completed resource template */
-
-    *ActualReturnDesc = ReturnDesc;
-    return_ACPI_STATUS (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiExDoConcatenate
- *
- * PARAMETERS:  Operand0            - First source object
- *              Operand1            - Second source object
- *              ActualReturnDesc    - Where to place the return object
- *              WalkState           - Current walk state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Concatenate two objects OF THE SAME TYPE.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiExDoConcatenate (
-    ACPI_OPERAND_OBJECT     *Operand0,
-    ACPI_OPERAND_OBJECT     *Operand1,
-    ACPI_OPERAND_OBJECT     **ActualReturnDesc,
-    ACPI_WALK_STATE         *WalkState)
-{
-    ACPI_OPERAND_OBJECT     *LocalOperand1 = Operand1;
-    ACPI_OPERAND_OBJECT     *ReturnDesc;
-    char                    *NewBuf;
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_TRACE (ExDoConcatenate);
-
-
-    /*
-     * Convert the second operand if necessary.  The first operand
-     * determines the type of the second operand, (See the Data Types
-     * section of the ACPI specification.)  Both object types are
-     * guaranteed to be either Integer/String/Buffer by the operand
-     * resolution mechanism.
-     */
-    switch (Operand0->Common.Type)
-    {
-    case ACPI_TYPE_INTEGER:
-        Status = AcpiExConvertToInteger (Operand1, &LocalOperand1, 16);
-        break;
-
-    case ACPI_TYPE_STRING:
-        Status = AcpiExConvertToString (Operand1, &LocalOperand1,
-                    ACPI_IMPLICIT_CONVERT_HEX);
-        break;
-
-    case ACPI_TYPE_BUFFER:
-        Status = AcpiExConvertToBuffer (Operand1, &LocalOperand1);
-        break;
-
-    default:
-        ACPI_ERROR ((AE_INFO, "Invalid object type: 0x%X",
-            Operand0->Common.Type));
-        Status = AE_AML_INTERNAL;
-    }
-
-    if (ACPI_FAILURE (Status))
-    {
-        goto Cleanup;
-    }
-
-    /*
-     * Both operands are now known to be the same object type
-     * (Both are Integer, String, or Buffer), and we can now perform the
-     * concatenation.
-     */
-
-    /*
-     * There are three cases to handle:
-     *
-     * 1) Two Integers concatenated to produce a new Buffer
-     * 2) Two Strings concatenated to produce a new String
-     * 3) Two Buffers concatenated to produce a new Buffer
-     */
-    switch (Operand0->Common.Type)
-    {
-    case ACPI_TYPE_INTEGER:
-
-        /* Result of two Integers is a Buffer */
-        /* Need enough buffer space for two integers */
-
-        ReturnDesc = AcpiUtCreateBufferObject ((ACPI_SIZE)
-                            ACPI_MUL_2 (AcpiGbl_IntegerByteWidth));
-        if (!ReturnDesc)
-        {
-            Status = AE_NO_MEMORY;
-            goto Cleanup;
-        }
-
-        NewBuf = (char *) ReturnDesc->Buffer.Pointer;
-
-        /* Copy the first integer, LSB first */
-
-        ACPI_MEMCPY (NewBuf, &Operand0->Integer.Value,
-                        AcpiGbl_IntegerByteWidth);
-
-        /* Copy the second integer (LSB first) after the first */
-
-        ACPI_MEMCPY (NewBuf + AcpiGbl_IntegerByteWidth,
-                        &LocalOperand1->Integer.Value,
-                        AcpiGbl_IntegerByteWidth);
-        break;
-
-    case ACPI_TYPE_STRING:
-
-        /* Result of two Strings is a String */
-
-        ReturnDesc = AcpiUtCreateStringObject (
-                        ((ACPI_SIZE) Operand0->String.Length +
-                        LocalOperand1->String.Length));
-        if (!ReturnDesc)
-        {
-            Status = AE_NO_MEMORY;
-            goto Cleanup;
-        }
-
-        NewBuf = ReturnDesc->String.Pointer;
-
-        /* Concatenate the strings */
-
-        ACPI_STRCPY (NewBuf, Operand0->String.Pointer);
-        ACPI_STRCPY (NewBuf + Operand0->String.Length,
-                        LocalOperand1->String.Pointer);
-        break;
-
-    case ACPI_TYPE_BUFFER:
-
-        /* Result of two Buffers is a Buffer */
-
-        ReturnDesc = AcpiUtCreateBufferObject (
-                        ((ACPI_SIZE) Operand0->Buffer.Length +
-                        LocalOperand1->Buffer.Length));
-        if (!ReturnDesc)
-        {
-            Status = AE_NO_MEMORY;
-            goto Cleanup;
-        }
-
-        NewBuf = (char *) ReturnDesc->Buffer.Pointer;
-
-        /* Concatenate the buffers */
-
-        ACPI_MEMCPY (NewBuf, Operand0->Buffer.Pointer,
-                        Operand0->Buffer.Length);
-        ACPI_MEMCPY (NewBuf + Operand0->Buffer.Length,
-                        LocalOperand1->Buffer.Pointer,
-                        LocalOperand1->Buffer.Length);
-        break;
-
-    default:
-
-        /* Invalid object type, should not happen here */
-
-        ACPI_ERROR ((AE_INFO, "Invalid object type: 0x%X",
-            Operand0->Common.Type));
-        Status =AE_AML_INTERNAL;
-        goto Cleanup;
-    }
-
-    *ActualReturnDesc = ReturnDesc;
-
-Cleanup:
-    if (LocalOperand1 != Operand1)
-    {
-        AcpiUtRemoveReference (LocalOperand1);
-    }
-    return_ACPI_STATUS (Status);
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiExDoMathOp
@@ -451,37 +179,30 @@ AcpiExDoMathOp (
 
         return (Integer0 + Integer1);
 
-
     case AML_BIT_AND_OP:            /* And (Integer0, Integer1, Result) */
 
         return (Integer0 & Integer1);
 
-
     case AML_BIT_NAND_OP:           /* NAnd (Integer0, Integer1, Result) */
 
         return (~(Integer0 & Integer1));
 
-
     case AML_BIT_OR_OP:             /* Or (Integer0, Integer1, Result) */
 
         return (Integer0 | Integer1);
 
-
     case AML_BIT_NOR_OP:            /* NOr (Integer0, Integer1, Result) */
 
         return (~(Integer0 | Integer1));
 
-
     case AML_BIT_XOR_OP:            /* XOr (Integer0, Integer1, Result) */
 
         return (Integer0 ^ Integer1);
 
-
     case AML_MULTIPLY_OP:           /* Multiply (Integer0, Integer1, Result) */
 
         return (Integer0 * Integer1);
 
-
     case AML_SHIFT_LEFT_OP:         /* ShiftLeft (Operand, ShiftCount, Result)*/
 
         /*
@@ -494,7 +215,6 @@ AcpiExDoMathOp (
         }
         return (Integer0 << Integer1);
 
-
     case AML_SHIFT_RIGHT_OP:        /* ShiftRight (Operand, ShiftCount, Result) */
 
         /*
@@ -507,7 +227,6 @@ AcpiExDoMathOp (
         }
         return (Integer0 >> Integer1);
 
-
     case AML_SUBTRACT_OP:           /* Subtract (Integer0, Integer1, Result) */
 
         return (Integer0 - Integer1);
@@ -572,6 +291,7 @@ AcpiExDoLogicalNumericOp (
         break;
 
     default:
+
         Status = AE_AML_INTERNAL;
         break;
     }
@@ -630,7 +350,7 @@ AcpiExDoLogicalOp (
 
 
     /*
-     * Convert the second operand if necessary.  The first operand
+     * Convert the second operand if necessary. The first operand
      * determines the type of the second operand, (See the Data Types
      * section of the ACPI 3.0+ specification.)  Both object types are
      * guaranteed to be either Integer/String/Buffer by the operand
@@ -639,19 +359,23 @@ AcpiExDoLogicalOp (
     switch (Operand0->Common.Type)
     {
     case ACPI_TYPE_INTEGER:
+
         Status = AcpiExConvertToInteger (Operand1, &LocalOperand1, 16);
         break;
 
     case ACPI_TYPE_STRING:
-        Status = AcpiExConvertToString (Operand1, &LocalOperand1,
-                    ACPI_IMPLICIT_CONVERT_HEX);
+
+        Status = AcpiExConvertToString (
+            Operand1, &LocalOperand1, ACPI_IMPLICIT_CONVERT_HEX);
         break;
 
     case ACPI_TYPE_BUFFER:
+
         Status = AcpiExConvertToBuffer (Operand1, &LocalOperand1);
         break;
 
     default:
+
         Status = AE_AML_INTERNAL;
         break;
     }
@@ -700,6 +424,7 @@ AcpiExDoLogicalOp (
             break;
 
         default:
+
             Status = AE_AML_INTERNAL;
             break;
         }
@@ -717,9 +442,9 @@ AcpiExDoLogicalOp (
 
         /* Lexicographic compare: compare the data bytes */
 
-        Compare = ACPI_MEMCMP (Operand0->Buffer.Pointer,
-                    LocalOperand1->Buffer.Pointer,
-                    (Length0 > Length1) ? Length1 : Length0);
+        Compare = memcmp (Operand0->Buffer.Pointer,
+            LocalOperand1->Buffer.Pointer,
+            (Length0 > Length1) ? Length1 : Length0);
 
         switch (Opcode)
         {
@@ -777,6 +502,7 @@ AcpiExDoLogicalOp (
             break;
 
         default:
+
             Status = AE_AML_INTERNAL;
             break;
         }
@@ -796,5 +522,3 @@ Cleanup:
     *LogicalResult = LocalResult;
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exmutex.c b/usr/src/uts/intel/io/acpica/executer/exmutex.c
index 4c702b8baa..30e10af38c 100644
--- a/usr/src/uts/intel/io/acpica/executer/exmutex.c
+++ b/usr/src/uts/intel/io/acpica/executer/exmutex.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exmutex - ASL Mutex Acquire/Release functions
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXMUTEX_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -212,8 +209,7 @@ AcpiExAcquireMutexObject (
     }
     else
     {
-        Status = AcpiExSystemWaitMutex (ObjDesc->Mutex.OsMutex,
-                    Timeout);
+        Status = AcpiExSystemWaitMutex (ObjDesc->Mutex.OsMutex, Timeout);
     }
 
     if (ACPI_FAILURE (Status))
@@ -276,33 +272,48 @@ AcpiExAcquireMutex (
     }
 
     /*
-     * Current sync level must be less than or equal to the sync level of the
-     * mutex. This mechanism provides some deadlock prevention
+     * Current sync level must be less than or equal to the sync level
+     * of the mutex. This mechanism provides some deadlock prevention.
      */
     if (WalkState->Thread->CurrentSyncLevel > ObjDesc->Mutex.SyncLevel)
     {
         ACPI_ERROR ((AE_INFO,
-            "Cannot acquire Mutex [%4.4s], current SyncLevel is too large (%u)",
+            "Cannot acquire Mutex [%4.4s], "
+            "current SyncLevel is too large (%u)",
             AcpiUtGetNodeName (ObjDesc->Mutex.Node),
             WalkState->Thread->CurrentSyncLevel));
         return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
     }
 
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+        "Acquiring: Mutex SyncLevel %u, Thread SyncLevel %u, "
+        "Depth %u TID %p\n",
+        ObjDesc->Mutex.SyncLevel, WalkState->Thread->CurrentSyncLevel,
+        ObjDesc->Mutex.AcquisitionDepth, WalkState->Thread));
+
     Status = AcpiExAcquireMutexObject ((UINT16) TimeDesc->Integer.Value,
-                ObjDesc, WalkState->Thread->ThreadId);
+        ObjDesc, WalkState->Thread->ThreadId);
+
     if (ACPI_SUCCESS (Status) && ObjDesc->Mutex.AcquisitionDepth == 1)
     {
         /* Save Thread object, original/current sync levels */
 
         ObjDesc->Mutex.OwnerThread = WalkState->Thread;
-        ObjDesc->Mutex.OriginalSyncLevel = WalkState->Thread->CurrentSyncLevel;
-        WalkState->Thread->CurrentSyncLevel = ObjDesc->Mutex.SyncLevel;
+        ObjDesc->Mutex.OriginalSyncLevel =
+            WalkState->Thread->CurrentSyncLevel;
+        WalkState->Thread->CurrentSyncLevel =
+            ObjDesc->Mutex.SyncLevel;
 
         /* Link the mutex to the current thread for force-unlock at method exit */
 
         AcpiExLinkMutex (ObjDesc, WalkState->Thread);
     }
 
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+        "Acquired: Mutex SyncLevel %u, Thread SyncLevel %u, Depth %u\n",
+        ObjDesc->Mutex.SyncLevel, WalkState->Thread->CurrentSyncLevel,
+        ObjDesc->Mutex.AcquisitionDepth));
+
     return_ACPI_STATUS (Status);
 }
 
@@ -341,7 +352,7 @@ AcpiExReleaseMutexObject (
 
     if (ObjDesc->Mutex.AcquisitionDepth == 0)
     {
-        return (AE_NOT_ACQUIRED);
+        return_ACPI_STATUS (AE_NOT_ACQUIRED);
     }
 
     /* Match multiple Acquires with multiple Releases */
@@ -398,9 +409,9 @@ AcpiExReleaseMutex (
     ACPI_OPERAND_OBJECT     *ObjDesc,
     ACPI_WALK_STATE         *WalkState)
 {
-    ACPI_STATUS             Status = AE_OK;
     UINT8                   PreviousSyncLevel;
     ACPI_THREAD_STATE       *OwnerThread;
+    ACPI_STATUS             Status = AE_OK;
 
 
     ACPI_FUNCTION_TRACE (ExReleaseMutex);
@@ -458,7 +469,8 @@ AcpiExReleaseMutex (
     if (ObjDesc->Mutex.SyncLevel != OwnerThread->CurrentSyncLevel)
     {
         ACPI_ERROR ((AE_INFO,
-            "Cannot release Mutex [%4.4s], SyncLevel mismatch: mutex %u current %u",
+            "Cannot release Mutex [%4.4s], SyncLevel mismatch: "
+            "mutex %u current %u",
             AcpiUtGetNodeName (ObjDesc->Mutex.Node),
             ObjDesc->Mutex.SyncLevel, WalkState->Thread->CurrentSyncLevel));
         return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
@@ -472,6 +484,13 @@ AcpiExReleaseMutex (
     PreviousSyncLevel =
         OwnerThread->AcquiredMutexList->Mutex.OriginalSyncLevel;
 
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+        "Releasing: Object SyncLevel %u, Thread SyncLevel %u, "
+        "Prev SyncLevel %u, Depth %u TID %p\n",
+        ObjDesc->Mutex.SyncLevel, WalkState->Thread->CurrentSyncLevel,
+        PreviousSyncLevel, ObjDesc->Mutex.AcquisitionDepth,
+        WalkState->Thread));
+
     Status = AcpiExReleaseMutexObject (ObjDesc);
     if (ACPI_FAILURE (Status))
     {
@@ -485,6 +504,12 @@ AcpiExReleaseMutex (
         OwnerThread->CurrentSyncLevel = PreviousSyncLevel;
     }
 
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+        "Released: Object SyncLevel %u, Thread SyncLevel, %u, "
+        "Prev SyncLevel %u, Depth %u\n",
+        ObjDesc->Mutex.SyncLevel, WalkState->Thread->CurrentSyncLevel,
+        PreviousSyncLevel, ObjDesc->Mutex.AcquisitionDepth));
+
     return_ACPI_STATUS (Status);
 }
 
@@ -515,7 +540,7 @@ AcpiExReleaseAllMutexes (
     ACPI_OPERAND_OBJECT     *ObjDesc;
 
 
-    ACPI_FUNCTION_ENTRY ();
+    ACPI_FUNCTION_TRACE (ExReleaseAllMutexes);
 
 
     /* Traverse the list of owned mutexes, releasing each one */
@@ -523,11 +548,10 @@ AcpiExReleaseAllMutexes (
     while (Next)
     {
         ObjDesc = Next;
-        Next = ObjDesc->Mutex.Next;
-
-        ObjDesc->Mutex.Prev = NULL;
-        ObjDesc->Mutex.Next = NULL;
-        ObjDesc->Mutex.AcquisitionDepth = 0;
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "Mutex [%4.4s] force-release, SyncLevel %u Depth %u\n",
+            ObjDesc->Mutex.Node->Name.Ascii, ObjDesc->Mutex.SyncLevel,
+            ObjDesc->Mutex.AcquisitionDepth));
 
         /* Release the mutex, special case for Global Lock */
 
@@ -542,13 +566,20 @@ AcpiExReleaseAllMutexes (
             AcpiOsReleaseMutex (ObjDesc->Mutex.OsMutex);
         }
 
+        /* Update Thread SyncLevel (Last mutex is the important one) */
+
+        Thread->CurrentSyncLevel = ObjDesc->Mutex.OriginalSyncLevel;
+
         /* Mark mutex unowned */
 
+        Next = ObjDesc->Mutex.Next;
+
+        ObjDesc->Mutex.Prev = NULL;
+        ObjDesc->Mutex.Next = NULL;
+        ObjDesc->Mutex.AcquisitionDepth = 0;
         ObjDesc->Mutex.OwnerThread = NULL;
         ObjDesc->Mutex.ThreadId = 0;
-
-        /* Update Thread SyncLevel (Last mutex is the important one) */
-
-        Thread->CurrentSyncLevel = ObjDesc->Mutex.OriginalSyncLevel;
     }
+
+    return_VOID;
 }
diff --git a/usr/src/uts/intel/io/acpica/executer/exnames.c b/usr/src/uts/intel/io/acpica/executer/exnames.c
index c3cb6b0b4c..817a011b2c 100644
--- a/usr/src/uts/intel/io/acpica/executer/exnames.c
+++ b/usr/src/uts/intel/io/acpica/executer/exnames.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exnames - interpreter/scanner name load/execute
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXNAMES_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -73,7 +70,7 @@ AcpiExNameSegment (
  *                                    (-1)==root,  0==none
  *              NumNameSegs         - count of 4-character name segments
  *
- * RETURN:      A pointer to the allocated string segment.  This segment must
+ * RETURN:      A pointer to the allocated string segment. This segment must
  *              be deleted by the caller.
  *
  * DESCRIPTION: Allocate a buffer for a name string. Ensure allocated name
@@ -163,6 +160,7 @@ AcpiExAllocateNameString (
     return_PTR (NameString);
 }
 
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiExNameSegment
@@ -192,8 +190,8 @@ AcpiExNameSegment (
 
 
     /*
-     * If first character is a digit, then we know that we aren't looking at a
-     * valid name segment
+     * If first character is a digit, then we know that we aren't looking
+     * at a valid name segment
      */
     CharBuf[0] = *AmlAddress;
 
@@ -206,7 +204,7 @@ AcpiExNameSegment (
     ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "Bytes from stream:\n"));
 
     for (Index = 0;
-        (Index < ACPI_NAME_SIZE) && (AcpiUtValidAcpiChar (*AmlAddress, 0));
+        (Index < ACPI_NAME_SIZE) && (AcpiUtValidNameChar (*AmlAddress, 0));
         Index++)
     {
         CharBuf[Index] = *AmlAddress++;
@@ -224,7 +222,7 @@ AcpiExNameSegment (
 
         if (NameString)
         {
-            ACPI_STRCAT (NameString, CharBuf);
+            strcat (NameString, CharBuf);
             ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
                 "Appended to - %s\n", NameString));
         }
@@ -335,7 +333,6 @@ AcpiExGetNameString (
             HasPrefix = TRUE;
             break;
 
-
         case AML_PARENT_PREFIX:
 
             /* Increment past possibly multiple parent prefixes */
@@ -353,7 +350,6 @@ AcpiExGetNameString (
             HasPrefix = TRUE;
             break;
 
-
         default:
 
             /* Not a prefix character */
@@ -389,7 +385,6 @@ AcpiExGetNameString (
             }
             break;
 
-
         case AML_MULTI_NAME_PREFIX_OP:
 
             ACPI_DEBUG_PRINT ((ACPI_DB_LOAD, "MultiNamePrefix at %p\n",
@@ -400,7 +395,8 @@ AcpiExGetNameString (
             AmlAddress++;
             NumSegments = *AmlAddress;
 
-            NameString = AcpiExAllocateNameString (PrefixCount, NumSegments);
+            NameString = AcpiExAllocateNameString (
+                PrefixCount, NumSegments);
             if (!NameString)
             {
                 Status = AE_NO_MEMORY;
@@ -421,7 +417,6 @@ AcpiExGetNameString (
 
             break;
 
-
         case 0:
 
             /* NullName valid as of 8-12-98 ASL/AML Grammar Update */
@@ -444,7 +439,6 @@ AcpiExGetNameString (
 
             break;
 
-
         default:
 
             /* Name segment string */
@@ -484,5 +478,3 @@ AcpiExGetNameString (
 
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exoparg1.c b/usr/src/uts/intel/io/acpica/executer/exoparg1.c
index 9a6cd9fcab..5a45bead06 100644
--- a/usr/src/uts/intel/io/acpica/executer/exoparg1.c
+++ b/usr/src/uts/intel/io/acpica/executer/exoparg1.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exoparg1 - AML execution - opcodes with 1 argument
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXOPARG1_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -181,37 +178,31 @@ AcpiExOpcode_1A_0T_0R (
         Status = AcpiExReleaseMutex (Operand[0], WalkState);
         break;
 
-
     case AML_RESET_OP:      /*  Reset (EventObject) */
 
         Status = AcpiExSystemResetEvent (Operand[0]);
         break;
 
-
     case AML_SIGNAL_OP:     /*  Signal (EventObject) */
 
         Status = AcpiExSystemSignalEvent (Operand[0]);
         break;
 
-
     case AML_SLEEP_OP:      /*  Sleep (MsecTime) */
 
         Status = AcpiExSystemDoSleep (Operand[0]->Integer.Value);
         break;
 
-
     case AML_STALL_OP:      /*  Stall (UsecTime) */
 
         Status = AcpiExSystemDoStall ((UINT32) Operand[0]->Integer.Value);
         break;
 
-
     case AML_UNLOAD_OP:     /*  Unload (Handle) */
 
         Status = AcpiExUnloadTable (Operand[0]);
         break;
 
-
     default:                /*  Unknown opcode  */
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
@@ -331,7 +322,6 @@ AcpiExOpcode_1A_1T_1R (
             ReturnDesc->Integer.Value = ~Operand[0]->Integer.Value;
             break;
 
-
         case AML_FIND_SET_LEFT_BIT_OP:  /* FindSetLeftBit (Operand, Result) */
 
             ReturnDesc->Integer.Value = Operand[0]->Integer.Value;
@@ -341,7 +331,7 @@ AcpiExOpcode_1A_1T_1R (
              * endian unsigned value, so this boundary condition is valid.
              */
             for (Temp32 = 0; ReturnDesc->Integer.Value &&
-                             Temp32 < ACPI_INTEGER_BIT_SIZE; ++Temp32)
+                    Temp32 < ACPI_INTEGER_BIT_SIZE; ++Temp32)
             {
                 ReturnDesc->Integer.Value >>= 1;
             }
@@ -349,7 +339,6 @@ AcpiExOpcode_1A_1T_1R (
             ReturnDesc->Integer.Value = Temp32;
             break;
 
-
         case AML_FIND_SET_RIGHT_BIT_OP: /* FindSetRightBit (Operand, Result) */
 
             ReturnDesc->Integer.Value = Operand[0]->Integer.Value;
@@ -359,7 +348,7 @@ AcpiExOpcode_1A_1T_1R (
              * endian unsigned value, so this boundary condition is valid.
              */
             for (Temp32 = 0; ReturnDesc->Integer.Value &&
-                             Temp32 < ACPI_INTEGER_BIT_SIZE; ++Temp32)
+                     Temp32 < ACPI_INTEGER_BIT_SIZE; ++Temp32)
             {
                 ReturnDesc->Integer.Value <<= 1;
             }
@@ -370,9 +359,7 @@ AcpiExOpcode_1A_1T_1R (
                 Temp32 == 0 ? 0 : (ACPI_INTEGER_BIT_SIZE + 1) - Temp32;
             break;
 
-
         case AML_FROM_BCD_OP:           /* FromBcd (BCDValue, Result)  */
-
             /*
              * The 64-bit ACPI integer can hold 16 4-bit BCD characters
              * (if table is 32-bit, integer can hold 8 BCD characters)
@@ -417,7 +404,6 @@ AcpiExOpcode_1A_1T_1R (
             }
             break;
 
-
         case AML_TO_BCD_OP:             /* ToBcd (Operand, Result)  */
 
             ReturnDesc->Integer.Value = 0;
@@ -449,9 +435,7 @@ AcpiExOpcode_1A_1T_1R (
             }
             break;
 
-
         case AML_COND_REF_OF_OP:        /* CondRefOf (SourceObject, Result)  */
-
             /*
              * This op is a little strange because the internal return value is
              * different than the return value stored in the result descriptor
@@ -470,7 +454,7 @@ AcpiExOpcode_1A_1T_1R (
             /* Get the object reference, store it, and remove our reference */
 
             Status = AcpiExGetObjectReference (Operand[0],
-                        &ReturnDesc2, WalkState);
+                &ReturnDesc2, WalkState);
             if (ACPI_FAILURE (Status))
             {
                 goto Cleanup;
@@ -486,14 +470,14 @@ AcpiExOpcode_1A_1T_1R (
 
 
         default:
+
             /* No other opcodes get here */
+
             break;
         }
         break;
 
-
     case AML_STORE_OP:              /* Store (Source, Target) */
-
         /*
          * A store operand is typically a number, string, buffer or lvalue
          * Be careful about deleting the source object,
@@ -520,64 +504,62 @@ AcpiExOpcode_1A_1T_1R (
         }
         return_ACPI_STATUS (Status);
 
-
     /*
      * ACPI 2.0 Opcodes
      */
     case AML_COPY_OP:               /* Copy (Source, Target) */
 
-        Status = AcpiUtCopyIobjectToIobject (Operand[0], &ReturnDesc,
-                    WalkState);
+        Status = AcpiUtCopyIobjectToIobject (
+            Operand[0], &ReturnDesc, WalkState);
         break;
 
-
     case AML_TO_DECSTRING_OP:       /* ToDecimalString (Data, Result) */
 
-        Status = AcpiExConvertToString (Operand[0], &ReturnDesc,
-                    ACPI_EXPLICIT_CONVERT_DECIMAL);
+        Status = AcpiExConvertToString (
+            Operand[0], &ReturnDesc, ACPI_EXPLICIT_CONVERT_DECIMAL);
         if (ReturnDesc == Operand[0])
         {
             /* No conversion performed, add ref to handle return value */
+
             AcpiUtAddReference (ReturnDesc);
         }
         break;
 
-
     case AML_TO_HEXSTRING_OP:       /* ToHexString (Data, Result) */
 
-        Status = AcpiExConvertToString (Operand[0], &ReturnDesc,
-                    ACPI_EXPLICIT_CONVERT_HEX);
+        Status = AcpiExConvertToString (
+            Operand[0], &ReturnDesc, ACPI_EXPLICIT_CONVERT_HEX);
         if (ReturnDesc == Operand[0])
         {
             /* No conversion performed, add ref to handle return value */
+
             AcpiUtAddReference (ReturnDesc);
         }
         break;
 
-
     case AML_TO_BUFFER_OP:          /* ToBuffer (Data, Result) */
 
         Status = AcpiExConvertToBuffer (Operand[0], &ReturnDesc);
         if (ReturnDesc == Operand[0])
         {
             /* No conversion performed, add ref to handle return value */
+
             AcpiUtAddReference (ReturnDesc);
         }
         break;
 
-
     case AML_TO_INTEGER_OP:         /* ToInteger (Data, Result) */
 
-        Status = AcpiExConvertToInteger (Operand[0], &ReturnDesc,
-                    ACPI_ANY_BASE);
+        Status = AcpiExConvertToInteger (
+            Operand[0], &ReturnDesc, ACPI_ANY_BASE);
         if (ReturnDesc == Operand[0])
         {
             /* No conversion performed, add ref to handle return value */
+
             AcpiUtAddReference (ReturnDesc);
         }
         break;
 
-
     case AML_SHIFT_LEFT_BIT_OP:     /* ShiftLeftBit (Source, BitNum)  */
     case AML_SHIFT_RIGHT_BIT_OP:    /* ShiftRightBit (Source, BitNum) */
 
@@ -589,7 +571,6 @@ AcpiExOpcode_1A_1T_1R (
         Status = AE_SUPPORT;
         goto Cleanup;
 
-
     default:                        /* Unknown opcode */
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
@@ -668,7 +649,7 @@ AcpiExOpcode_1A_0T_1R (
         }
 
         /*
-         * Set result to ONES (TRUE) if Value == 0.  Note:
+         * Set result to ONES (TRUE) if Value == 0. Note:
          * ReturnDesc->Integer.Value is initially == 0 (FALSE) from above.
          */
         if (!Operand[0]->Integer.Value)
@@ -677,12 +658,10 @@ AcpiExOpcode_1A_0T_1R (
         }
         break;
 
-
     case AML_DECREMENT_OP:          /* Decrement (Operand)  */
     case AML_INCREMENT_OP:          /* Increment (Operand)  */
-
         /*
-         * Create a new integer.  Can't just get the base integer and
+         * Create a new integer. Can't just get the base integer and
          * increment it because it may be an Arg or Field.
          */
         ReturnDesc = AcpiUtCreateInternalObject (ACPI_TYPE_INTEGER);
@@ -727,11 +706,11 @@ AcpiExOpcode_1A_0T_1R (
          */
         if (WalkState->Opcode == AML_INCREMENT_OP)
         {
-            ReturnDesc->Integer.Value = TempDesc->Integer.Value +1;
+            ReturnDesc->Integer.Value = TempDesc->Integer.Value + 1;
         }
         else
         {
-            ReturnDesc->Integer.Value = TempDesc->Integer.Value -1;
+            ReturnDesc->Integer.Value = TempDesc->Integer.Value - 1;
         }
 
         /* Finished with this Integer object */
@@ -745,12 +724,10 @@ AcpiExOpcode_1A_0T_1R (
         Status = AcpiExStore (ReturnDesc, Operand[0], WalkState);
         break;
 
-
-    case AML_TYPE_OP:               /* ObjectType (SourceObject) */
-
+    case AML_OBJECT_TYPE_OP:            /* ObjectType (SourceObject) */
         /*
          * Note: The operand is not resolved at this point because we want to
-         * get the associated object, not its value.  For example, we don't
+         * get the associated object, not its value. For example, we don't
          * want to resolve a FieldUnit to its value, we want the actual
          * FieldUnit object.
          */
@@ -773,9 +750,7 @@ AcpiExOpcode_1A_0T_1R (
         }
         break;
 
-
     case AML_SIZE_OF_OP:            /* SizeOf (SourceObject)  */
-
         /*
          * Note: The operand is not resolved at this point because we want to
          * get the associated object, not its value.
@@ -783,8 +758,8 @@ AcpiExOpcode_1A_0T_1R (
 
         /* Get the base object */
 
-        Status = AcpiExResolveMultiple (WalkState,
-                    Operand[0], &Type, &TempDesc);
+        Status = AcpiExResolveMultiple (
+            WalkState, Operand[0], &Type, &TempDesc);
         if (ACPI_FAILURE (Status))
         {
             goto Cleanup;
@@ -792,7 +767,7 @@ AcpiExOpcode_1A_0T_1R (
 
         /*
          * The type of the base object must be integer, buffer, string, or
-         * package.  All others are not supported.
+         * package. All others are not supported.
          *
          * NOTE: Integer is not specifically supported by the ACPI spec,
          * but is supported implicitly via implicit operand conversion.
@@ -802,10 +777,12 @@ AcpiExOpcode_1A_0T_1R (
         switch (Type)
         {
         case ACPI_TYPE_INTEGER:
+
             Value = AcpiGbl_IntegerByteWidth;
             break;
 
         case ACPI_TYPE_STRING:
+
             Value = TempDesc->String.Length;
             break;
 
@@ -826,9 +803,12 @@ AcpiExOpcode_1A_0T_1R (
             break;
 
         default:
+
             ACPI_ERROR ((AE_INFO,
-                "Operand must be Buffer/Integer/String/Package - found type %s",
+                "Operand must be Buffer/Integer/String/Package"
+                " - found type %s",
                 AcpiUtGetTypeName (Type)));
+
             Status = AE_AML_OPERAND_TYPE;
             goto Cleanup;
         }
@@ -853,7 +833,8 @@ AcpiExOpcode_1A_0T_1R (
 
     case AML_REF_OF_OP:             /* RefOf (SourceObject) */
 
-        Status = AcpiExGetObjectReference (Operand[0], &ReturnDesc, WalkState);
+        Status = AcpiExGetObjectReference (
+            Operand[0], &ReturnDesc, WalkState);
         if (ACPI_FAILURE (Status))
         {
             goto Cleanup;
@@ -900,9 +881,9 @@ AcpiExOpcode_1A_0T_1R (
                     /* Set Operand[0] to the value of the local/arg */
 
                     Status = AcpiDsMethodDataGetValue (
-                                Operand[0]->Reference.Class,
-                                Operand[0]->Reference.Value,
-                                WalkState, &TempDesc);
+                        Operand[0]->Reference.Class,
+                        Operand[0]->Reference.Value,
+                        WalkState, &TempDesc);
                     if (ACPI_FAILURE (Status))
                     {
                         goto Cleanup;
@@ -933,9 +914,11 @@ AcpiExOpcode_1A_0T_1R (
                 break;
 
             case ACPI_TYPE_STRING:
+
                 break;
 
             default:
+
                 Status = AE_AML_OPERAND_TYPE;
                 goto Cleanup;
             }
@@ -954,19 +937,19 @@ AcpiExOpcode_1A_0T_1R (
                  *    Field, so we need to resolve the node to a value.
                  */
                 Status = AcpiNsGetNode (WalkState->ScopeInfo->Scope.Node,
-                            Operand[0]->String.Pointer,
-                            ACPI_NS_SEARCH_PARENT,
-                            ACPI_CAST_INDIRECT_PTR (
-                                ACPI_NAMESPACE_NODE, &ReturnDesc));
+                    Operand[0]->String.Pointer,
+                    ACPI_NS_SEARCH_PARENT,
+                    ACPI_CAST_INDIRECT_PTR (
+                        ACPI_NAMESPACE_NODE, &ReturnDesc));
                 if (ACPI_FAILURE (Status))
                 {
                     goto Cleanup;
                 }
 
                 Status = AcpiExResolveNodeToValue (
-                            ACPI_CAST_INDIRECT_PTR (
-                                ACPI_NAMESPACE_NODE, &ReturnDesc),
-                            WalkState);
+                    ACPI_CAST_INDIRECT_PTR (
+                        ACPI_NAMESPACE_NODE, &ReturnDesc),
+                    WalkState);
                 goto Cleanup;
             }
         }
@@ -982,7 +965,7 @@ AcpiExOpcode_1A_0T_1R (
              * dereferenced above.
              */
             ReturnDesc = AcpiNsGetAttachedObject (
-                            (ACPI_NAMESPACE_NODE *) Operand[0]);
+                (ACPI_NAMESPACE_NODE *) Operand[0]);
             AcpiUtAddReference (ReturnDesc);
         }
         else
@@ -994,7 +977,6 @@ AcpiExOpcode_1A_0T_1R (
             switch (Operand[0]->Reference.Class)
             {
             case ACPI_REFCLASS_INDEX:
-
                 /*
                  * The target type for the Index operator must be
                  * either a Buffer or a Package
@@ -1026,50 +1008,83 @@ AcpiExOpcode_1A_0T_1R (
                     }
                     break;
 
-
                 case ACPI_TYPE_PACKAGE:
-
                     /*
-                     * Return the referenced element of the package.  We must
+                     * Return the referenced element of the package. We must
                      * add another reference to the referenced object, however.
                      */
                     ReturnDesc = *(Operand[0]->Reference.Where);
-                    if (ReturnDesc)
+                    if (!ReturnDesc)
                     {
-                        AcpiUtAddReference (ReturnDesc);
+                        /*
+                         * Element is NULL, do not allow the dereference.
+                         * This provides compatibility with other ACPI
+                         * implementations.
+                         */
+                        return_ACPI_STATUS (AE_AML_UNINITIALIZED_ELEMENT);
                     }
-                    break;
 
+                    AcpiUtAddReference (ReturnDesc);
+                    break;
 
                 default:
 
                     ACPI_ERROR ((AE_INFO,
                         "Unknown Index TargetType 0x%X in reference object %p",
                         Operand[0]->Reference.TargetType, Operand[0]));
+
                     Status = AE_AML_OPERAND_TYPE;
                     goto Cleanup;
                 }
                 break;
 
-
             case ACPI_REFCLASS_REFOF:
 
                 ReturnDesc = Operand[0]->Reference.Object;
 
                 if (ACPI_GET_DESCRIPTOR_TYPE (ReturnDesc) ==
-                        ACPI_DESC_TYPE_NAMED)
+                    ACPI_DESC_TYPE_NAMED)
                 {
                     ReturnDesc = AcpiNsGetAttachedObject (
-                                    (ACPI_NAMESPACE_NODE *) ReturnDesc);
-                }
+                        (ACPI_NAMESPACE_NODE *) ReturnDesc);
+                    if (!ReturnDesc)
+                    {
+                        break;
+                    }
 
-                /* Add another reference to the object! */
+                   /*
+                    * June 2013:
+                    * BufferFields/FieldUnits require additional resolution
+                    */
+                    switch (ReturnDesc->Common.Type)
+                    {
+                    case ACPI_TYPE_BUFFER_FIELD:
+                    case ACPI_TYPE_LOCAL_REGION_FIELD:
+                    case ACPI_TYPE_LOCAL_BANK_FIELD:
+                    case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-                AcpiUtAddReference (ReturnDesc);
-                break;
+                        Status = AcpiExReadDataFromField (
+                            WalkState, ReturnDesc, &TempDesc);
+                        if (ACPI_FAILURE (Status))
+                        {
+                            goto Cleanup;
+                        }
+
+                        ReturnDesc = TempDesc;
+                        break;
 
+                    default:
+
+                        /* Add another reference to the object */
+
+                        AcpiUtAddReference (ReturnDesc);
+                        break;
+                    }
+                }
+                break;
 
             default:
+
                 ACPI_ERROR ((AE_INFO,
                     "Unknown class in reference(%p) - 0x%2.2X",
                     Operand[0], Operand[0]->Reference.Class));
@@ -1080,11 +1095,11 @@ AcpiExOpcode_1A_0T_1R (
         }
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
             WalkState->Opcode));
+
         Status = AE_AML_BAD_OPCODE;
         goto Cleanup;
     }
@@ -1108,4 +1123,3 @@ Cleanup:
 
     return_ACPI_STATUS (Status);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exoparg2.c b/usr/src/uts/intel/io/acpica/executer/exoparg2.c
index b76da75c49..7fe91a8181 100644
--- a/usr/src/uts/intel/io/acpica/executer/exoparg2.c
+++ b/usr/src/uts/intel/io/acpica/executer/exoparg2.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EXOPARG2_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -137,14 +134,13 @@ AcpiExOpcode_2A_0T_0R (
         /*
          * Dispatch the notify to the appropriate handler
          * NOTE: the request is queued for execution after this method
-         * completes.  The notify handlers are NOT invoked synchronously
+         * completes. The notify handlers are NOT invoked synchronously
          * from this thread -- because handlers may in turn run other
          * control methods.
          */
         Status = AcpiEvQueueNotifyRequest (Node, Value);
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
@@ -207,21 +203,22 @@ AcpiExOpcode_2A_2T_1R (
 
         /* Quotient to ReturnDesc1, remainder to ReturnDesc2 */
 
-        Status = AcpiUtDivide (Operand[0]->Integer.Value,
-                               Operand[1]->Integer.Value,
-                               &ReturnDesc1->Integer.Value,
-                               &ReturnDesc2->Integer.Value);
+        Status = AcpiUtDivide (
+            Operand[0]->Integer.Value,
+            Operand[1]->Integer.Value,
+            &ReturnDesc1->Integer.Value,
+            &ReturnDesc2->Integer.Value);
         if (ACPI_FAILURE (Status))
         {
             goto Cleanup;
         }
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
             WalkState->Opcode));
+
         Status = AE_AML_BAD_OPCODE;
         goto Cleanup;
     }
@@ -286,7 +283,7 @@ AcpiExOpcode_2A_1T_1R (
     ACPI_OPERAND_OBJECT     *ReturnDesc = NULL;
     UINT64                  Index;
     ACPI_STATUS             Status = AE_OK;
-    ACPI_SIZE               Length;
+    ACPI_SIZE               Length = 0;
 
 
     ACPI_FUNCTION_TRACE_STR (ExOpcode_2A_1T_1R,
@@ -306,9 +303,10 @@ AcpiExOpcode_2A_1T_1R (
             goto Cleanup;
         }
 
-        ReturnDesc->Integer.Value = AcpiExDoMathOp (WalkState->Opcode,
-                                                Operand[0]->Integer.Value,
-                                                Operand[1]->Integer.Value);
+        ReturnDesc->Integer.Value = AcpiExDoMathOp (
+            WalkState->Opcode,
+            Operand[0]->Integer.Value,
+            Operand[1]->Integer.Value);
         goto StoreResultToTarget;
     }
 
@@ -325,22 +323,20 @@ AcpiExOpcode_2A_1T_1R (
 
         /* ReturnDesc will contain the remainder */
 
-        Status = AcpiUtDivide (Operand[0]->Integer.Value,
-                               Operand[1]->Integer.Value,
-                               NULL,
-                               &ReturnDesc->Integer.Value);
+        Status = AcpiUtDivide (
+            Operand[0]->Integer.Value,
+            Operand[1]->Integer.Value,
+            NULL,
+            &ReturnDesc->Integer.Value);
         break;
 
-
     case AML_CONCAT_OP: /* Concatenate (Data1, Data2, Result) */
 
-        Status = AcpiExDoConcatenate (Operand[0], Operand[1],
-                    &ReturnDesc, WalkState);
+        Status = AcpiExDoConcatenate (
+            Operand[0], Operand[1], &ReturnDesc, WalkState);
         break;
 
-
     case AML_TO_STRING_OP: /* ToString (Buffer, Length, Result) (ACPI 2.0) */
-
         /*
          * Input object is guaranteed to be a buffer at this point (it may have
          * been converted.)  Copy the raw buffer data to a new object of
@@ -356,7 +352,6 @@ AcpiExOpcode_2A_1T_1R (
          * NOTE: A length of zero is ok, and will create a zero-length, null
          *       terminated string.
          */
-        Length = 0;
         while ((Length < Operand[0]->Buffer.Length) &&
                (Length < Operand[1]->Integer.Value) &&
                (Operand[0]->Buffer.Pointer[Length]))
@@ -377,20 +372,18 @@ AcpiExOpcode_2A_1T_1R (
          * Copy the raw buffer data with no transform.
          * (NULL terminated already)
          */
-        ACPI_MEMCPY (ReturnDesc->String.Pointer,
+        memcpy (ReturnDesc->String.Pointer,
             Operand[0]->Buffer.Pointer, Length);
         break;
 
-
     case AML_CONCAT_RES_OP:
 
         /* ConcatenateResTemplate (Buffer, Buffer, Result) (ACPI 2.0) */
 
-        Status = AcpiExConcatTemplate (Operand[0], Operand[1],
-                    &ReturnDesc, WalkState);
+        Status = AcpiExConcatTemplate (
+            Operand[0], Operand[1], &ReturnDesc, WalkState);
         break;
 
-
     case AML_INDEX_OP:              /* Index (Source Index Result) */
 
         /* Create the internal return object */
@@ -418,31 +411,39 @@ AcpiExOpcode_2A_1T_1R (
 
             if (Index >= Operand[0]->String.Length)
             {
+                Length = Operand[0]->String.Length;
                 Status = AE_AML_STRING_LIMIT;
             }
 
             ReturnDesc->Reference.TargetType = ACPI_TYPE_BUFFER_FIELD;
+            ReturnDesc->Reference.IndexPointer =
+                &(Operand[0]->Buffer.Pointer [Index]);
             break;
 
         case ACPI_TYPE_BUFFER:
 
             if (Index >= Operand[0]->Buffer.Length)
             {
+                Length = Operand[0]->Buffer.Length;
                 Status = AE_AML_BUFFER_LIMIT;
             }
 
             ReturnDesc->Reference.TargetType = ACPI_TYPE_BUFFER_FIELD;
+            ReturnDesc->Reference.IndexPointer =
+                &(Operand[0]->Buffer.Pointer [Index]);
             break;
 
         case ACPI_TYPE_PACKAGE:
 
             if (Index >= Operand[0]->Package.Count)
             {
+                Length = Operand[0]->Package.Count;
                 Status = AE_AML_PACKAGE_LIMIT;
             }
 
             ReturnDesc->Reference.TargetType = ACPI_TYPE_PACKAGE;
-            ReturnDesc->Reference.Where = &Operand[0]->Package.Elements [Index];
+            ReturnDesc->Reference.Where =
+                &Operand[0]->Package.Elements [Index];
             break;
 
         default:
@@ -456,8 +457,8 @@ AcpiExOpcode_2A_1T_1R (
         if (ACPI_FAILURE (Status))
         {
             ACPI_EXCEPTION ((AE_INFO, Status,
-                "Index (0x%8.8X%8.8X) is beyond end of object",
-                ACPI_FORMAT_UINT64 (Index)));
+                "Index (0x%X%8.8X) is beyond end of object (length 0x%X)",
+                ACPI_FORMAT_UINT64 (Index), (UINT32) Length));
             goto Cleanup;
         }
 
@@ -477,7 +478,6 @@ AcpiExOpcode_2A_1T_1R (
         WalkState->ResultObj = ReturnDesc;
         goto Cleanup;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
@@ -564,8 +564,8 @@ AcpiExOpcode_2A_0T_1R (
         /* LogicalOp  (Operand0, Operand1) */
 
         Status = AcpiExDoLogicalNumericOp (WalkState->Opcode,
-                        Operand[0]->Integer.Value, Operand[1]->Integer.Value,
-                        &LogicalResult);
+            Operand[0]->Integer.Value, Operand[1]->Integer.Value,
+            &LogicalResult);
         goto StoreLogicalResult;
     }
     else if (WalkState->OpInfo->Flags & AML_LOGICAL)
@@ -573,7 +573,7 @@ AcpiExOpcode_2A_0T_1R (
         /* LogicalOp  (Operand0, Operand1) */
 
         Status = AcpiExDoLogicalOp (WalkState->Opcode, Operand[0],
-                    Operand[1], &LogicalResult);
+            Operand[1], &LogicalResult);
         goto StoreLogicalResult;
     }
 
@@ -600,11 +600,11 @@ AcpiExOpcode_2A_0T_1R (
         }
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
             WalkState->Opcode));
+
         Status = AE_AML_BAD_OPCODE;
         goto Cleanup;
     }
@@ -638,5 +638,3 @@ Cleanup:
 
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exoparg3.c b/usr/src/uts/intel/io/acpica/executer/exoparg3.c
index 0edac68e60..de46a97c9c 100644
--- a/usr/src/uts/intel/io/acpica/executer/exoparg3.c
+++ b/usr/src/uts/intel/io/acpica/executer/exoparg3.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exoparg3 - AML execution - opcodes with 3 arguments
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXOPARG3_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -108,7 +105,8 @@ AcpiExOpcode_3A_0T_0R (
     case AML_FATAL_OP:          /* Fatal (FatalType  FatalCode  FatalArg) */
 
         ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-            "FatalOp: Type %X Code %X Arg %X <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
+            "FatalOp: Type %X Code %X Arg %X "
+            "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
             (UINT32) Operand[0]->Integer.Value,
             (UINT32) Operand[1]->Integer.Value,
             (UINT32) Operand[2]->Integer.Value));
@@ -116,8 +114,8 @@ AcpiExOpcode_3A_0T_0R (
         Fatal = ACPI_ALLOCATE (sizeof (ACPI_SIGNAL_FATAL_INFO));
         if (Fatal)
         {
-            Fatal->Type     = (UINT32) Operand[0]->Integer.Value;
-            Fatal->Code     = (UINT32) Operand[1]->Integer.Value;
+            Fatal->Type = (UINT32) Operand[0]->Integer.Value;
+            Fatal->Code = (UINT32) Operand[1]->Integer.Value;
             Fatal->Argument = (UINT32) Operand[2]->Integer.Value;
         }
 
@@ -128,13 +126,26 @@ AcpiExOpcode_3A_0T_0R (
         /* Might return while OS is shutting down, just continue */
 
         ACPI_FREE (Fatal);
-        break;
+        goto Cleanup;
 
+    case AML_EXTERNAL_OP:
+        /*
+         * If the interpreter sees this opcode, just ignore it. The External
+         * op is intended for use by disassemblers in order to properly
+         * disassemble control method invocations. The opcode or group of
+         * opcodes should be surrounded by an "if (0)" clause to ensure that
+         * AML interpreters never see the opcode. Thus, something is
+         * wrong if an external opcode ever gets here.
+         */
+        ACPI_ERROR ((AE_INFO, "Executed External Op"));
+        Status = AE_OK;
+        goto Cleanup;
 
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
             WalkState->Opcode));
+
         Status = AE_AML_BAD_OPCODE;
         goto Cleanup;
     }
@@ -177,13 +188,12 @@ AcpiExOpcode_3A_1T_1R (
     switch (WalkState->Opcode)
     {
     case AML_MID_OP:    /* Mid (Source[0], Index[1], Length[2], Result[3]) */
-
         /*
-         * Create the return object.  The Source operand is guaranteed to be
+         * Create the return object. The Source operand is guaranteed to be
          * either a String or a Buffer, so just use its type.
          */
         ReturnDesc = AcpiUtCreateInternalObject (
-                        (Operand[0])->Common.Type);
+            (Operand[0])->Common.Type);
         if (!ReturnDesc)
         {
             Status = AE_NO_MEMORY;
@@ -208,8 +218,8 @@ AcpiExOpcode_3A_1T_1R (
 
         else if ((Index + Length) > Operand[0]->String.Length)
         {
-            Length = (ACPI_SIZE) Operand[0]->String.Length -
-                        (ACPI_SIZE) Index;
+            Length =
+                (ACPI_SIZE) Operand[0]->String.Length - (ACPI_SIZE) Index;
         }
 
         /* Strings always have a sub-pointer, not so for buffers */
@@ -255,8 +265,8 @@ AcpiExOpcode_3A_1T_1R (
         {
             /* We have a buffer, copy the portion requested */
 
-            ACPI_MEMCPY (Buffer, Operand[0]->String.Pointer + Index,
-                         Length);
+            memcpy (Buffer,
+                Operand[0]->String.Pointer + Index, Length);
         }
 
         /* Set the length of the new String/Buffer */
@@ -269,11 +279,11 @@ AcpiExOpcode_3A_1T_1R (
         ReturnDesc->Buffer.Flags |= AOPOBJ_DATA_VALID;
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
             WalkState->Opcode));
+
         Status = AE_AML_BAD_OPCODE;
         goto Cleanup;
     }
@@ -291,14 +301,12 @@ Cleanup:
         AcpiUtRemoveReference (ReturnDesc);
         WalkState->ResultObj = NULL;
     }
-
-    /* Set the return object and exit */
-
     else
     {
+        /* Set the return object and exit */
+
         WalkState->ResultObj = ReturnDesc;
     }
+
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exoparg6.c b/usr/src/uts/intel/io/acpica/executer/exoparg6.c
index bfc6585301..2cc8f59bb0 100644
--- a/usr/src/uts/intel/io/acpica/executer/exoparg6.c
+++ b/usr/src/uts/intel/io/acpica/executer/exoparg6.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exoparg6 - AML execution - opcodes with 6 arguments
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXOPARG6_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -131,13 +128,12 @@ AcpiExDoMatch (
         break;
 
     case MATCH_MEQ:
-
         /*
          * True if equal: (P[i] == M)
          * Change to:     (M == P[i])
          */
-        Status = AcpiExDoLogicalOp (AML_LEQUAL_OP, MatchObj, PackageObj,
-                    &LogicalResult);
+        Status = AcpiExDoLogicalOp (
+            AML_LEQUAL_OP, MatchObj, PackageObj, &LogicalResult);
         if (ACPI_FAILURE (Status))
         {
             return (FALSE);
@@ -145,13 +141,12 @@ AcpiExDoMatch (
         break;
 
     case MATCH_MLE:
-
         /*
          * True if less than or equal: (P[i] <= M) (P[i] NotGreater than M)
          * Change to:                  (M >= P[i]) (M NotLess than P[i])
          */
-        Status = AcpiExDoLogicalOp (AML_LLESS_OP, MatchObj, PackageObj,
-                    &LogicalResult);
+        Status = AcpiExDoLogicalOp (
+            AML_LLESS_OP, MatchObj, PackageObj, &LogicalResult);
         if (ACPI_FAILURE (Status))
         {
             return (FALSE);
@@ -160,13 +155,12 @@ AcpiExDoMatch (
         break;
 
     case MATCH_MLT:
-
         /*
          * True if less than: (P[i] < M)
          * Change to:         (M > P[i])
          */
-        Status = AcpiExDoLogicalOp (AML_LGREATER_OP, MatchObj, PackageObj,
-                    &LogicalResult);
+        Status = AcpiExDoLogicalOp (
+            AML_LGREATER_OP, MatchObj, PackageObj, &LogicalResult);
         if (ACPI_FAILURE (Status))
         {
             return (FALSE);
@@ -174,13 +168,12 @@ AcpiExDoMatch (
         break;
 
     case MATCH_MGE:
-
         /*
          * True if greater than or equal: (P[i] >= M) (P[i] NotLess than M)
          * Change to:                     (M <= P[i]) (M NotGreater than P[i])
          */
-        Status = AcpiExDoLogicalOp (AML_LGREATER_OP, MatchObj, PackageObj,
-                    &LogicalResult);
+        Status = AcpiExDoLogicalOp (
+            AML_LGREATER_OP, MatchObj, PackageObj, &LogicalResult);
         if (ACPI_FAILURE (Status))
         {
             return (FALSE);
@@ -189,13 +182,12 @@ AcpiExDoMatch (
         break;
 
     case MATCH_MGT:
-
         /*
          * True if greater than: (P[i] > M)
          * Change to:            (M < P[i])
          */
-        Status = AcpiExDoLogicalOp (AML_LLESS_OP, MatchObj, PackageObj,
-                    &LogicalResult);
+        Status = AcpiExDoLogicalOp (
+            AML_LLESS_OP, MatchObj, PackageObj, &LogicalResult);
         if (ACPI_FAILURE (Status))
         {
             return (FALSE);
@@ -209,7 +201,7 @@ AcpiExDoMatch (
         return (FALSE);
     }
 
-    return LogicalResult;
+    return (LogicalResult);
 }
 
 
@@ -288,7 +280,7 @@ AcpiExOpcode_6A_0T_1R (
          * and the next should be examined.
          *
          * Upon finding a match, the loop will terminate via "break" at
-         * the bottom.  If it terminates "normally", MatchValue will be
+         * the bottom. If it terminates "normally", MatchValue will be
          * ACPI_UINT64_MAX (Ones) (its initial value) indicating that no
          * match was found.
          */
@@ -311,13 +303,13 @@ AcpiExOpcode_6A_0T_1R (
              * non-match.
              */
             if (!AcpiExDoMatch ((UINT32) Operand[1]->Integer.Value,
-                                ThisElement, Operand[2]))
+                    ThisElement, Operand[2]))
             {
                 continue;
             }
 
             if (!AcpiExDoMatch ((UINT32) Operand[3]->Integer.Value,
-                                ThisElement, Operand[4]))
+                    ThisElement, Operand[4]))
             {
                 continue;
             }
@@ -329,17 +321,16 @@ AcpiExOpcode_6A_0T_1R (
         }
         break;
 
-
     case AML_LOAD_TABLE_OP:
 
         Status = AcpiExLoadTableOp (WalkState, &ReturnDesc);
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown AML opcode 0x%X",
             WalkState->Opcode));
+
         Status = AE_AML_BAD_OPCODE;
         goto Cleanup;
     }
diff --git a/usr/src/uts/intel/io/acpica/executer/exprep.c b/usr/src/uts/intel/io/acpica/executer/exprep.c
index 9ec78275bd..51f2714ab0 100644
--- a/usr/src/uts/intel/io/acpica/executer/exprep.c
+++ b/usr/src/uts/intel/io/acpica/executer/exprep.c
@@ -1,12 +1,11 @@
-
 /******************************************************************************
  *
- * Module Name: exprep - ACPI AML (p-code) execution - field prep utilities
+ * Module Name: exprep - ACPI AML field prep utilities
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXPREP_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -72,6 +69,7 @@ AcpiExGenerateAccess (
     UINT32                  FieldBitLength,
     UINT32                  RegionLength);
 
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiExGenerateAccess
@@ -87,8 +85,8 @@ AcpiExGenerateAccess (
  *              AnyAcc keyword.
  *
  * NOTE: Need to have the RegionLength in order to check for boundary
- *       conditions (end-of-region).  However, the RegionLength is a deferred
- *       operation.  Therefore, to complete this implementation, the generation
+ *       conditions (end-of-region). However, the RegionLength is a deferred
+ *       operation. Therefore, to complete this implementation, the generation
  *       of this access width must be deferred until the region length has
  *       been evaluated.
  *
@@ -116,10 +114,13 @@ AcpiExGenerateAccess (
 
     /* Round Field start offset and length to "minimal" byte boundaries */
 
-    FieldByteOffset    = ACPI_DIV_8 (ACPI_ROUND_DOWN (FieldBitOffset, 8));
-    FieldByteEndOffset = ACPI_DIV_8 (ACPI_ROUND_UP   (FieldBitLength +
-                                                      FieldBitOffset, 8));
-    FieldByteLength    = FieldByteEndOffset - FieldByteOffset;
+    FieldByteOffset = ACPI_DIV_8 (
+        ACPI_ROUND_DOWN (FieldBitOffset, 8));
+
+    FieldByteEndOffset = ACPI_DIV_8 (
+        ACPI_ROUND_UP (FieldBitLength + FieldBitOffset, 8));
+
+    FieldByteLength = FieldByteEndOffset - FieldByteOffset;
 
     ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
         "Bit length %u, Bit offset %u\n",
@@ -144,7 +145,8 @@ AcpiExGenerateAccess (
          *    are done. (This does not optimize for the perfectly aligned
          *    case yet).
          */
-        if (ACPI_ROUND_UP (FieldByteEndOffset, AccessByteWidth) <= RegionLength)
+        if (ACPI_ROUND_UP (FieldByteEndOffset, AccessByteWidth) <=
+            RegionLength)
         {
             FieldStartOffset =
                 ACPI_ROUND_DOWN (FieldByteOffset, AccessByteWidth) /
@@ -168,7 +170,8 @@ AcpiExGenerateAccess (
             if (Accesses <= 1)
             {
                 ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-                    "Entire field can be accessed with one operation of size %u\n",
+                    "Entire field can be accessed "
+                    "with one operation of size %u\n",
                     AccessByteWidth));
                 return_VALUE (AccessByteWidth);
             }
@@ -179,14 +182,15 @@ AcpiExGenerateAccess (
              */
             if (Accesses < MinimumAccesses)
             {
-                MinimumAccesses    = Accesses;
+                MinimumAccesses = Accesses;
                 MinimumAccessWidth = AccessByteWidth;
             }
         }
         else
         {
             ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-                "AccessWidth %u end is NOT within region\n", AccessByteWidth));
+                "AccessWidth %u end is NOT within region\n",
+                AccessByteWidth));
             if (AccessByteWidth == 1)
             {
                 ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
@@ -214,6 +218,7 @@ AcpiExGenerateAccess (
      */
     ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
         "Cannot access field in one operation, using width 8\n"));
+
     return_VALUE (8);
 }
 #endif /* ACPI_UNDER_DEVELOPMENT */
@@ -268,31 +273,37 @@ AcpiExDecodeFieldAccess (
 
     case AML_FIELD_ACCESS_BYTE:
     case AML_FIELD_ACCESS_BUFFER:   /* ACPI 2.0 (SMBus Buffer) */
+
         ByteAlignment = 1;
         BitLength     = 8;
         break;
 
     case AML_FIELD_ACCESS_WORD:
+
         ByteAlignment = 2;
         BitLength     = 16;
         break;
 
     case AML_FIELD_ACCESS_DWORD:
+
         ByteAlignment = 4;
         BitLength     = 32;
         break;
 
     case AML_FIELD_ACCESS_QWORD:    /* ACPI 2.0 */
+
         ByteAlignment = 8;
         BitLength     = 64;
         break;
 
     default:
+
         /* Invalid field access type */
 
         ACPI_ERROR ((AE_INFO,
             "Unknown field access type 0x%X",
             Access));
+
         return_UINT32 (0);
     }
 
@@ -326,7 +337,7 @@ AcpiExDecodeFieldAccess (
  * RETURN:      Status
  *
  * DESCRIPTION: Initialize the areas of the field object that are common
- *              to the various types of fields.  Note: This is very "sensitive"
+ *              to the various types of fields. Note: This is very "sensitive"
  *              code because we are solving the general case for field
  *              alignment.
  *
@@ -358,13 +369,13 @@ AcpiExPrepCommonFieldObject (
     ObjDesc->CommonField.BitLength  = FieldBitLength;
 
     /*
-     * Decode the access type so we can compute offsets.  The access type gives
+     * Decode the access type so we can compute offsets. The access type gives
      * two pieces of information - the width of each field access and the
      * necessary ByteAlignment (address granularity) of the access.
      *
      * For AnyAcc, the AccessBitWidth is the largest width that is both
      * necessary and possible in an attempt to access the whole field in one
-     * I/O operation.  However, for AnyAcc, the ByteAlignment is always one
+     * I/O operation. However, for AnyAcc, the ByteAlignment is always one
      * byte.
      *
      * For all Buffer Fields, the ByteAlignment is always one byte.
@@ -372,8 +383,8 @@ AcpiExPrepCommonFieldObject (
      * For all other access types (Byte, Word, Dword, Qword), the Bitwidth is
      * the same (equivalent) as the ByteAlignment.
      */
-    AccessBitWidth = AcpiExDecodeFieldAccess (ObjDesc, FieldFlags,
-                        &ByteAlignment);
+    AccessBitWidth = AcpiExDecodeFieldAccess (
+        ObjDesc, FieldFlags, &ByteAlignment);
     if (!AccessBitWidth)
     {
         return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
@@ -386,7 +397,7 @@ AcpiExPrepCommonFieldObject (
 
     /*
      * BaseByteOffset is the address of the start of the field within the
-     * region.  It is the byte address of the first *datum* (field-width data
+     * region. It is the byte address of the first *datum* (field-width data
      * unit) of the field. (i.e., the first datum that contains at least the
      * first *bit* of the field.)
      *
@@ -418,8 +429,8 @@ AcpiExPrepCommonFieldObject (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Construct an ACPI_OPERAND_OBJECT of type DefField and
- *              connect it to the parent Node.
+ * DESCRIPTION: Construct an object of type ACPI_OPERAND_OBJECT with a
+ *              subtype of DefField and connect it to the parent Node.
  *
  ******************************************************************************/
 
@@ -469,8 +480,8 @@ AcpiExPrepFieldValue (
 
     ObjDesc->CommonField.Node = Info->FieldNode;
     Status = AcpiExPrepCommonFieldObject (ObjDesc,
-                Info->FieldFlags, Info->Attribute,
-                Info->FieldBitPosition, Info->FieldBitLength);
+        Info->FieldFlags, Info->Attribute,
+        Info->FieldBitPosition, Info->FieldBitLength);
     if (ACPI_FAILURE (Status))
     {
         AcpiUtDeleteObjectDesc (ObjDesc);
@@ -502,8 +513,10 @@ AcpiExPrepFieldValue (
                 }
             }
 
-            ObjDesc->Field.ResourceBuffer = SecondDesc->Buffer.Pointer;
-            ObjDesc->Field.ResourceLength = (UINT16) SecondDesc->Buffer.Length;
+            ObjDesc->Field.ResourceBuffer =
+                SecondDesc->Buffer.Pointer;
+            ObjDesc->Field.ResourceLength =
+                (UINT16) SecondDesc->Buffer.Length;
         }
         else if (Info->ResourceBuffer)
         {
@@ -511,6 +524,8 @@ AcpiExPrepFieldValue (
             ObjDesc->Field.ResourceLength = Info->ResourceLength;
         }
 
+        ObjDesc->Field.PinNumberIndex = Info->PinNumberIndex;
+
         /* Allow full data read from EC address space */
 
         if ((ObjDesc->Field.RegionObj->Region.SpaceId == ACPI_ADR_SPACE_EC) &&
@@ -523,7 +538,8 @@ AcpiExPrepFieldValue (
 
             if (AccessByteWidth < 256)
             {
-                ObjDesc->CommonField.AccessByteWidth = (UINT8) AccessByteWidth;
+                ObjDesc->CommonField.AccessByteWidth =
+                    (UINT8) AccessByteWidth;
             }
         }
 
@@ -533,11 +549,12 @@ AcpiExPrepFieldValue (
 
         ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
             "RegionField: BitOff %X, Off %X, Gran %X, Region %p\n",
-            ObjDesc->Field.StartFieldBitOffset, ObjDesc->Field.BaseByteOffset,
-            ObjDesc->Field.AccessByteWidth, ObjDesc->Field.RegionObj));
+            ObjDesc->Field.StartFieldBitOffset,
+            ObjDesc->Field.BaseByteOffset,
+            ObjDesc->Field.AccessByteWidth,
+            ObjDesc->Field.RegionObj));
         break;
 
-
     case ACPI_TYPE_LOCAL_BANK_FIELD:
 
         ObjDesc->BankField.Value = Info->BankValue;
@@ -572,7 +589,6 @@ AcpiExPrepFieldValue (
 
         break;
 
-
     case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
         /* Get the Index and Data registers */
@@ -616,7 +632,8 @@ AcpiExPrepFieldValue (
             ObjDesc->IndexField.AccessByteWidth);
 
         ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
-            "IndexField: BitOff %X, Off %X, Value %X, Gran %X, Index %p, Data %p\n",
+            "IndexField: BitOff %X, Off %X, Value %X, "
+            "Gran %X, Index %p, Data %p\n",
             ObjDesc->IndexField.StartFieldBitOffset,
             ObjDesc->IndexField.BaseByteOffset,
             ObjDesc->IndexField.Value,
@@ -626,7 +643,9 @@ AcpiExPrepFieldValue (
         break;
 
     default:
+
         /* No other types should get here */
+
         break;
     }
 
@@ -634,10 +653,11 @@ AcpiExPrepFieldValue (
      * Store the constructed descriptor (ObjDesc) into the parent Node,
      * preserving the current type of that NamedObj.
      */
-    Status = AcpiNsAttachObject (Info->FieldNode, ObjDesc,
-                AcpiNsGetType (Info->FieldNode));
+    Status = AcpiNsAttachObject (
+        Info->FieldNode, ObjDesc, AcpiNsGetType (Info->FieldNode));
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD, "Set NamedObj %p [%4.4s], ObjDesc %p\n",
+    ACPI_DEBUG_PRINT ((ACPI_DB_BFIELD,
+        "Set NamedObj %p [%4.4s], ObjDesc %p\n",
         Info->FieldNode, AcpiUtGetNodeName (Info->FieldNode), ObjDesc));
 
     /* Remove local reference to the object */
@@ -645,4 +665,3 @@ AcpiExPrepFieldValue (
     AcpiUtRemoveReference (ObjDesc);
     return_ACPI_STATUS (Status);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exregion.c b/usr/src/uts/intel/io/acpica/executer/exregion.c
index 8a40250794..58d3a0c24b 100644
--- a/usr/src/uts/intel/io/acpica/executer/exregion.c
+++ b/usr/src/uts/intel/io/acpica/executer/exregion.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exregion - ACPI default OpRegion (address space) handlers
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __EXREGION_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -100,22 +96,27 @@ AcpiExSystemMemorySpaceHandler (
     switch (BitWidth)
     {
     case 8:
+
         Length = 1;
         break;
 
     case 16:
+
         Length = 2;
         break;
 
     case 32:
+
         Length = 4;
         break;
 
     case 64:
+
         Length = 8;
         break;
 
     default:
+
         ACPI_ERROR ((AE_INFO, "Invalid SystemMemory width %u",
             BitWidth));
         return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
@@ -174,8 +175,8 @@ AcpiExSystemMemorySpaceHandler (
          * one page, which is similar to the original code that used a 4k
          * maximum window.
          */
-        PageBoundaryMapLength =
-            ACPI_ROUND_UP (Address, ACPI_DEFAULT_PAGE_SIZE) - Address;
+        PageBoundaryMapLength = (ACPI_SIZE)
+            (ACPI_ROUND_UP (Address, ACPI_DEFAULT_PAGE_SIZE) - Address);
         if (PageBoundaryMapLength == 0)
         {
             PageBoundaryMapLength = ACPI_DEFAULT_PAGE_SIZE;
@@ -188,13 +189,12 @@ AcpiExSystemMemorySpaceHandler (
 
         /* Create a new mapping starting at the address given */
 
-        MemInfo->MappedLogicalAddress = AcpiOsMapMemory (
-            (ACPI_PHYSICAL_ADDRESS) Address, MapLength);
+        MemInfo->MappedLogicalAddress = AcpiOsMapMemory (Address, MapLength);
         if (!MemInfo->MappedLogicalAddress)
         {
             ACPI_ERROR ((AE_INFO,
                 "Could not map memory at 0x%8.8X%8.8X, size %u",
-                ACPI_FORMAT_NATIVE_UINT (Address), (UINT32) MapLength));
+                ACPI_FORMAT_UINT64 (Address), (UINT32) MapLength));
             MemInfo->MappedLength = 0;
             return_ACPI_STATUS (AE_NO_MEMORY);
         }
@@ -214,13 +214,13 @@ AcpiExSystemMemorySpaceHandler (
 
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
         "System-Memory (width %u) R/W %u Address=%8.8X%8.8X\n",
-        BitWidth, Function, ACPI_FORMAT_NATIVE_UINT (Address)));
+        BitWidth, Function, ACPI_FORMAT_UINT64 (Address)));
 
     /*
      * Perform the memory read or write
      *
      * Note: For machines that do not support non-aligned transfers, the target
-     * address was checked for alignment above.  We do not attempt to break the
+     * address was checked for alignment above. We do not attempt to break the
      * transfer up into smaller (byte-size) chunks because the AML specifically
      * asked for a transfer width that the hardware may require.
      */
@@ -232,23 +232,29 @@ AcpiExSystemMemorySpaceHandler (
         switch (BitWidth)
         {
         case 8:
+
             *Value = (UINT64) ACPI_GET8 (LogicalAddrPtr);
             break;
 
         case 16:
+
             *Value = (UINT64) ACPI_GET16 (LogicalAddrPtr);
             break;
 
         case 32:
+
             *Value = (UINT64) ACPI_GET32 (LogicalAddrPtr);
             break;
 
         case 64:
+
             *Value = (UINT64) ACPI_GET64 (LogicalAddrPtr);
             break;
 
         default:
+
             /* BitWidth was already validated */
+
             break;
         }
         break;
@@ -258,28 +264,35 @@ AcpiExSystemMemorySpaceHandler (
         switch (BitWidth)
         {
         case 8:
-            ACPI_SET8 (LogicalAddrPtr) = (UINT8) *Value;
+
+            ACPI_SET8 (LogicalAddrPtr, *Value);
             break;
 
         case 16:
-            ACPI_SET16 (LogicalAddrPtr) = (UINT16) *Value;
+
+            ACPI_SET16 (LogicalAddrPtr, *Value);
             break;
 
         case 32:
-            ACPI_SET32 ( LogicalAddrPtr) = (UINT32) *Value;
+
+            ACPI_SET32 (LogicalAddrPtr, *Value);
             break;
 
         case 64:
-            ACPI_SET64 (LogicalAddrPtr) = (UINT64) *Value;
+
+            ACPI_SET64 (LogicalAddrPtr, *Value);
             break;
 
         default:
+
             /* BitWidth was already validated */
+
             break;
         }
         break;
 
     default:
+
         Status = AE_BAD_PARAMETER;
         break;
     }
@@ -324,7 +337,7 @@ AcpiExSystemIoSpaceHandler (
 
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
         "System-IO (width %u) R/W %u Address=%8.8X%8.8X\n",
-        BitWidth, Function, ACPI_FORMAT_NATIVE_UINT (Address)));
+        BitWidth, Function, ACPI_FORMAT_UINT64 (Address)));
 
     /* Decode the function parameter */
 
@@ -344,6 +357,7 @@ AcpiExSystemIoSpaceHandler (
         break;
 
     default:
+
         Status = AE_BAD_PARAMETER;
         break;
     }
@@ -403,7 +417,8 @@ AcpiExPciConfigSpaceHandler (
     PciRegister = (UINT16) (UINT32) Address;
 
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-        "Pci-Config %u (%u) Seg(%04x) Bus(%04x) Dev(%04x) Func(%04x) Reg(%04x)\n",
+        "Pci-Config %u (%u) Seg(%04x) Bus(%04x) "
+        "Dev(%04x) Func(%04x) Reg(%04x)\n",
         Function, BitWidth, PciId->Segment, PciId->Bus, PciId->Device,
         PciId->Function, PciRegister));
 
@@ -412,14 +427,14 @@ AcpiExPciConfigSpaceHandler (
     case ACPI_READ:
 
         *Value = 0;
-        Status = AcpiOsReadPciConfiguration (PciId, PciRegister,
-                    Value, BitWidth);
+        Status = AcpiOsReadPciConfiguration (
+            PciId, PciRegister, Value, BitWidth);
         break;
 
     case ACPI_WRITE:
 
-        Status = AcpiOsWritePciConfiguration (PciId, PciRegister,
-                    *Value, BitWidth);
+        Status = AcpiOsWritePciConfiguration (
+            PciId, PciRegister, *Value, BitWidth);
         break;
 
     default:
@@ -544,13 +559,13 @@ AcpiExDataTableSpaceHandler (
     {
     case ACPI_READ:
 
-        ACPI_MEMCPY (ACPI_CAST_PTR (char, Value), ACPI_PHYSADDR_TO_PTR (Address),
+        memcpy (ACPI_CAST_PTR (char, Value), ACPI_PHYSADDR_TO_PTR (Address),
             ACPI_DIV_8 (BitWidth));
         break;
 
     case ACPI_WRITE:
 
-        ACPI_MEMCPY (ACPI_PHYSADDR_TO_PTR (Address), ACPI_CAST_PTR (char, Value),
+        memcpy (ACPI_PHYSADDR_TO_PTR (Address), ACPI_CAST_PTR (char, Value),
             ACPI_DIV_8 (BitWidth));
         break;
 
@@ -561,5 +576,3 @@ AcpiExDataTableSpaceHandler (
 
     return_ACPI_STATUS (AE_OK);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exresnte.c b/usr/src/uts/intel/io/acpica/executer/exresnte.c
index 03962edf97..9a85450de9 100644
--- a/usr/src/uts/intel/io/acpica/executer/exresnte.c
+++ b/usr/src/uts/intel/io/acpica/executer/exresnte.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exresnte - AML Interpreter object resolution
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXRESNTE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdispat.h"
@@ -62,8 +59,8 @@
  * PARAMETERS:  ObjectPtr       - Pointer to a location that contains
  *                                a pointer to a NS node, and will receive a
  *                                pointer to the resolved object.
- *              WalkState       - Current state.  Valid only if executing AML
- *                                code.  NULL if simply resolving an object
+ *              WalkState       - Current state. Valid only if executing AML
+ *                                code. NULL if simply resolving an object
  *
  * RETURN:      Status
  *
@@ -71,7 +68,7 @@
  *
  * Note: for some of the data types, the pointer attached to the Node
  * can be either a pointer to an actual internal object or a pointer into the
- * AML stream itself.  These types are currently:
+ * AML stream itself. These types are currently:
  *
  *      ACPI_TYPE_INTEGER
  *      ACPI_TYPE_STRING
@@ -98,12 +95,12 @@ AcpiExResolveNodeToValue (
 
 
     /*
-     * The stack pointer points to a ACPI_NAMESPACE_NODE (Node).  Get the
+     * The stack pointer points to a ACPI_NAMESPACE_NODE (Node). Get the
      * object that is attached to the Node.
      */
-    Node       = *ObjectPtr;
+    Node = *ObjectPtr;
     SourceDesc = AcpiNsGetAttachedObject (Node);
-    EntryType  = AcpiNsGetType ((ACPI_HANDLE) Node);
+    EntryType = AcpiNsGetType ((ACPI_HANDLE) Node);
 
     ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Entry=%p SourceDesc=%p [%s]\n",
          Node, SourceDesc, AcpiUtGetTypeName (EntryType)));
@@ -113,15 +110,15 @@ AcpiExResolveNodeToValue (
     {
         /* There is always exactly one level of indirection */
 
-        Node       = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Node->Object);
+        Node = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Node->Object);
         SourceDesc = AcpiNsGetAttachedObject (Node);
-        EntryType  = AcpiNsGetType ((ACPI_HANDLE) Node);
+        EntryType = AcpiNsGetType ((ACPI_HANDLE) Node);
         *ObjectPtr = Node;
     }
 
     /*
      * Several object types require no further processing:
-     * 1) Device/Thermal objects don't have a "real" subobject, return the Node
+     * 1) Device/Thermal objects don't have a "real" subobject, return Node
      * 2) Method locals and arguments have a pseudo-Node
      * 3) 10/2007: Added method type to assist with Package construction.
      */
@@ -135,9 +132,9 @@ AcpiExResolveNodeToValue (
 
     if (!SourceDesc)
     {
-        ACPI_ERROR ((AE_INFO, "No object attached to node %p",
-            Node));
-        return_ACPI_STATUS (AE_AML_NO_OPERAND);
+        ACPI_ERROR ((AE_INFO, "No object attached to node [%4.4s] %p",
+            Node->Name.Ascii, Node));
+        return_ACPI_STATUS (AE_AML_UNINITIALIZED_NODE);
     }
 
     /*
@@ -165,7 +162,6 @@ AcpiExResolveNodeToValue (
         }
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         if (SourceDesc->Common.Type != ACPI_TYPE_BUFFER)
@@ -185,7 +181,6 @@ AcpiExResolveNodeToValue (
         }
         break;
 
-
     case ACPI_TYPE_STRING:
 
         if (SourceDesc->Common.Type != ACPI_TYPE_STRING)
@@ -201,7 +196,6 @@ AcpiExResolveNodeToValue (
         AcpiUtAddReference (ObjDesc);
         break;
 
-
     case ACPI_TYPE_INTEGER:
 
         if (SourceDesc->Common.Type != ACPI_TYPE_INTEGER)
@@ -217,7 +211,6 @@ AcpiExResolveNodeToValue (
         AcpiUtAddReference (ObjDesc);
         break;
 
-
     case ACPI_TYPE_BUFFER_FIELD:
     case ACPI_TYPE_LOCAL_REGION_FIELD:
     case ACPI_TYPE_LOCAL_BANK_FIELD:
@@ -253,7 +246,6 @@ AcpiExResolveNodeToValue (
 
         return_ACPI_STATUS (AE_AML_OPERAND_TYPE);  /* Cannot be AE_TYPE */
 
-
     case ACPI_TYPE_LOCAL_REFERENCE:
 
         switch (SourceDesc->Reference.Class)
@@ -269,6 +261,7 @@ AcpiExResolveNodeToValue (
             break;
 
         default:
+
             /* No named references are allowed here */
 
             ACPI_ERROR ((AE_INFO,
@@ -279,7 +272,6 @@ AcpiExResolveNodeToValue (
         }
         break;
 
-
     default:
 
         /* Default case is for unknown types */
@@ -298,5 +290,3 @@ AcpiExResolveNodeToValue (
     *ObjectPtr = (void *) ObjDesc;
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exresolv.c b/usr/src/uts/intel/io/acpica/executer/exresolv.c
index e92fb2468e..4b6202f4fb 100644
--- a/usr/src/uts/intel/io/acpica/executer/exresolv.c
+++ b/usr/src/uts/intel/io/acpica/executer/exresolv.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exresolv - AML Interpreter object resolution
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXRESOLV_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "amlcode.h"
@@ -122,8 +119,8 @@ AcpiExResolveToValue (
     if (ACPI_GET_DESCRIPTOR_TYPE (*StackPtr) == ACPI_DESC_TYPE_NAMED)
     {
         Status = AcpiExResolveNodeToValue (
-                        ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE, StackPtr),
-                        WalkState);
+            ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE, StackPtr),
+            WalkState);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -165,7 +162,7 @@ AcpiExResolveObjectToValue (
 
     StackDesc = *StackPtr;
 
-    /* This is an ACPI_OPERAND_OBJECT  */
+    /* This is an object of type ACPI_OPERAND_OBJECT */
 
     switch (StackDesc->Common.Type)
     {
@@ -177,13 +174,12 @@ AcpiExResolveObjectToValue (
         {
         case ACPI_REFCLASS_LOCAL:
         case ACPI_REFCLASS_ARG:
-
             /*
              * Get the local from the method's state info
              * Note: this increments the local's object reference count
              */
             Status = AcpiDsMethodDataGetValue (RefType,
-                            StackDesc->Reference.Value, WalkState, &ObjDesc);
+                StackDesc->Reference.Value, WalkState, &ObjDesc);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -200,7 +196,6 @@ AcpiExResolveObjectToValue (
             *StackPtr = ObjDesc;
             break;
 
-
         case ACPI_REFCLASS_INDEX:
 
             switch (StackDesc->Reference.TargetType)
@@ -210,7 +205,6 @@ AcpiExResolveObjectToValue (
                 /* Just return - do not dereference */
                 break;
 
-
             case ACPI_TYPE_PACKAGE:
 
                 /* If method call or CopyObject - do not dereference */
@@ -231,7 +225,6 @@ AcpiExResolveObjectToValue (
                      * (i.e., dereference the package index)
                      * Delete the ref object, increment the returned object
                      */
-                    AcpiUtRemoveReference (StackDesc);
                     AcpiUtAddReference (ObjDesc);
                     *StackPtr = ObjDesc;
                 }
@@ -242,13 +235,13 @@ AcpiExResolveObjectToValue (
                      * the package, can't dereference it
                      */
                     ACPI_ERROR ((AE_INFO,
-                        "Attempt to dereference an Index to NULL package element Idx=%p",
+                        "Attempt to dereference an Index to "
+                        "NULL package element Idx=%p",
                         StackDesc));
                     Status = AE_AML_UNINITIALIZED_ELEMENT;
                 }
                 break;
 
-
             default:
 
                 /* Invalid reference object */
@@ -261,7 +254,6 @@ AcpiExResolveObjectToValue (
             }
             break;
 
-
         case ACPI_REFCLASS_REFOF:
         case ACPI_REFCLASS_DEBUG:
         case ACPI_REFCLASS_TABLE:
@@ -295,31 +287,30 @@ AcpiExResolveObjectToValue (
         default:
 
             ACPI_ERROR ((AE_INFO,
-                "Unknown Reference type 0x%X in %p", RefType, StackDesc));
+                "Unknown Reference type 0x%X in %p",
+                RefType, StackDesc));
             Status = AE_AML_INTERNAL;
             break;
         }
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         Status = AcpiDsGetBufferArguments (StackDesc);
         break;
 
-
     case ACPI_TYPE_PACKAGE:
 
         Status = AcpiDsGetPackageArguments (StackDesc);
         break;
 
-
     case ACPI_TYPE_BUFFER_FIELD:
     case ACPI_TYPE_LOCAL_REGION_FIELD:
     case ACPI_TYPE_LOCAL_BANK_FIELD:
     case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "FieldRead SourceDesc=%p Type=%X\n",
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "FieldRead SourceDesc=%p Type=%X\n",
             StackDesc, StackDesc->Common.Type));
 
         Status = AcpiExReadDataFromField (WalkState, StackDesc, &ObjDesc);
@@ -331,6 +322,7 @@ AcpiExResolveObjectToValue (
         break;
 
     default:
+
         break;
     }
 
@@ -349,7 +341,7 @@ AcpiExResolveObjectToValue (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Return the base object and type.  Traverse a reference list if
+ * DESCRIPTION: Return the base object and type. Traverse a reference list if
  *              necessary to get to the base object.
  *
  ******************************************************************************/
@@ -361,8 +353,8 @@ AcpiExResolveMultiple (
     ACPI_OBJECT_TYPE        *ReturnType,
     ACPI_OPERAND_OBJECT     **ReturnDesc)
 {
-    ACPI_OPERAND_OBJECT     *ObjDesc = (void *) Operand;
-    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_OPERAND_OBJECT     *ObjDesc = ACPI_CAST_PTR (void, Operand);
+    ACPI_NAMESPACE_NODE     *Node = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Operand);
     ACPI_OBJECT_TYPE        Type;
     ACPI_STATUS             Status;
 
@@ -375,19 +367,30 @@ AcpiExResolveMultiple (
     switch (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc))
     {
     case ACPI_DESC_TYPE_OPERAND:
+
         Type = ObjDesc->Common.Type;
         break;
 
     case ACPI_DESC_TYPE_NAMED:
+
         Type = ((ACPI_NAMESPACE_NODE *) ObjDesc)->Type;
-        ObjDesc = AcpiNsGetAttachedObject ((ACPI_NAMESPACE_NODE *) ObjDesc);
+        ObjDesc = AcpiNsGetAttachedObject (Node);
 
         /* If we had an Alias node, use the attached object for type info */
 
         if (Type == ACPI_TYPE_LOCAL_ALIAS)
         {
             Type = ((ACPI_NAMESPACE_NODE *) ObjDesc)->Type;
-            ObjDesc = AcpiNsGetAttachedObject ((ACPI_NAMESPACE_NODE *) ObjDesc);
+            ObjDesc = AcpiNsGetAttachedObject (
+                (ACPI_NAMESPACE_NODE *) ObjDesc);
+        }
+
+        if (!ObjDesc)
+        {
+            ACPI_ERROR ((AE_INFO,
+                "[%4.4s] Node is unresolved or uninitialized",
+                AcpiUtGetNodeName (Node)));
+            return_ACPI_STATUS (AE_AML_UNINITIALIZED_NODE);
         }
         break;
 
@@ -455,7 +458,6 @@ AcpiExResolveMultiple (
             }
             break;
 
-
         case ACPI_REFCLASS_INDEX:
 
             /* Get the type of this reference (index into another object) */
@@ -483,20 +485,18 @@ AcpiExResolveMultiple (
             }
             break;
 
-
         case ACPI_REFCLASS_TABLE:
 
             Type = ACPI_TYPE_DDB_HANDLE;
             goto Exit;
 
-
         case ACPI_REFCLASS_LOCAL:
         case ACPI_REFCLASS_ARG:
 
             if (ReturnDesc)
             {
                 Status = AcpiDsMethodDataGetValue (ObjDesc->Reference.Class,
-                            ObjDesc->Reference.Value, WalkState, &ObjDesc);
+                    ObjDesc->Reference.Value, WalkState, &ObjDesc);
                 if (ACPI_FAILURE (Status))
                 {
                     return_ACPI_STATUS (Status);
@@ -506,7 +506,7 @@ AcpiExResolveMultiple (
             else
             {
                 Status = AcpiDsMethodDataGetNode (ObjDesc->Reference.Class,
-                            ObjDesc->Reference.Value, WalkState, &Node);
+                    ObjDesc->Reference.Value, WalkState, &Node);
                 if (ACPI_FAILURE (Status))
                 {
                     return_ACPI_STATUS (Status);
@@ -521,7 +521,6 @@ AcpiExResolveMultiple (
             }
             break;
 
-
         case ACPI_REFCLASS_DEBUG:
 
             /* The Debug Object is of type "DebugObject" */
@@ -529,11 +528,11 @@ AcpiExResolveMultiple (
             Type = ACPI_TYPE_DEBUG_OBJECT;
             goto Exit;
 
-
         default:
 
             ACPI_ERROR ((AE_INFO,
-                "Unknown Reference Class 0x%2.2X", ObjDesc->Reference.Class));
+                "Unknown Reference Class 0x%2.2X",
+                ObjDesc->Reference.Class));
             return_ACPI_STATUS (AE_AML_INTERNAL);
         }
     }
@@ -565,7 +564,9 @@ Exit:
         break;
 
     default:
+
         /* No change to Type required */
+
         break;
     }
 
@@ -576,5 +577,3 @@ Exit:
     }
     return_ACPI_STATUS (AE_OK);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exresop.c b/usr/src/uts/intel/io/acpica/executer/exresop.c
index 1bcba69033..32ceb6f021 100644
--- a/usr/src/uts/intel/io/acpica/executer/exresop.c
+++ b/usr/src/uts/intel/io/acpica/executer/exresop.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exresop - AML Interpreter operand/object resolution
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXRESOP_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "amlcode.h"
@@ -98,11 +95,12 @@ AcpiExCheckObjectType (
     {
         /*
          * Allow the AML "Constant" opcodes (Zero, One, etc.) to be reference
-         * objects and thus allow them to be targets.  (As per the ACPI
+         * objects and thus allow them to be targets. (As per the ACPI
          * specification, a store to a constant is a noop.)
          */
         if ((ThisType == ACPI_TYPE_INTEGER) &&
-            (((ACPI_OPERAND_OBJECT *) Object)->Common.Flags & AOPOBJ_AML_CONSTANT))
+            (((ACPI_OPERAND_OBJECT *) Object)->Common.Flags &
+                AOPOBJ_AML_CONSTANT))
         {
             return (AE_OK);
         }
@@ -219,13 +217,13 @@ AcpiExResolveOperands (
              */
             if (ObjectType == ACPI_TYPE_LOCAL_ALIAS)
             {
-                ObjDesc = AcpiNsGetAttachedObject ((ACPI_NAMESPACE_NODE *) ObjDesc);
+                ObjDesc = AcpiNsGetAttachedObject (
+                    (ACPI_NAMESPACE_NODE *) ObjDesc);
                 *StackPtr = ObjDesc;
                 ObjectType = ((ACPI_NAMESPACE_NODE *) ObjDesc)->Type;
             }
             break;
 
-
         case ACPI_DESC_TYPE_OPERAND:
 
             /* ACPI internal object */
@@ -278,7 +276,6 @@ AcpiExResolveOperands (
             }
             break;
 
-
         default:
 
             /* Invalid descriptor */
@@ -302,7 +299,8 @@ AcpiExResolveOperands (
         {
         case ARGI_REF_OR_STRING:        /* Can be a String or Reference */
 
-            if ((ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) == ACPI_DESC_TYPE_OPERAND) &&
+            if ((ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) ==
+                ACPI_DESC_TYPE_OPERAND) &&
                 (ObjDesc->Common.Type == ACPI_TYPE_STRING))
             {
                 /*
@@ -325,6 +323,7 @@ AcpiExResolveOperands (
         case ARGI_TARGETREF:     /* Allows implicit conversion rules before store */
         case ARGI_FIXED_TARGET:  /* No implicit conversion before store to target */
         case ARGI_SIMPLE_TARGET: /* Name, Local, or Arg - no implicit conversion  */
+        case ARGI_STORE_TARGET:
 
             /*
              * Need an operand of type ACPI_TYPE_LOCAL_REFERENCE
@@ -335,17 +334,15 @@ AcpiExResolveOperands (
                 goto NextOperand;
             }
 
-            Status = AcpiExCheckObjectType (ACPI_TYPE_LOCAL_REFERENCE,
-                            ObjectType, ObjDesc);
+            Status = AcpiExCheckObjectType (
+                ACPI_TYPE_LOCAL_REFERENCE, ObjectType, ObjDesc);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
             }
             goto NextOperand;
 
-
         case ARGI_DATAREFOBJ:  /* Store operator only */
-
             /*
              * We don't want to resolve IndexOp reference objects during
              * a store because this would be an implicit DeRefOf operation.
@@ -361,7 +358,9 @@ AcpiExResolveOperands (
             break;
 
         default:
+
             /* All cases covered above */
+
             break;
         }
 
@@ -454,9 +453,7 @@ AcpiExResolveOperands (
             }
             goto NextOperand;
 
-
         case ARGI_BUFFER:
-
             /*
              * Need an operand of type ACPI_TYPE_BUFFER,
              * But we can implicitly convert from a STRING or INTEGER
@@ -483,16 +480,14 @@ AcpiExResolveOperands (
             }
             goto NextOperand;
 
-
         case ARGI_STRING:
-
             /*
              * Need an operand of type ACPI_TYPE_STRING,
              * But we can implicitly convert from a BUFFER or INTEGER
              * Aka - "Implicit Source Operand Conversion"
              */
-            Status = AcpiExConvertToString (ObjDesc, StackPtr,
-                        ACPI_IMPLICIT_CONVERT_HEX);
+            Status = AcpiExConvertToString (
+                ObjDesc, StackPtr, ACPI_IMPLICIT_CONVERT_HEX);
             if (ACPI_FAILURE (Status))
             {
                 if (Status == AE_TYPE)
@@ -513,7 +508,6 @@ AcpiExResolveOperands (
             }
             goto NextOperand;
 
-
         case ARGI_COMPUTEDATA:
 
             /* Need an operand of type INTEGER, STRING or BUFFER */
@@ -536,7 +530,6 @@ AcpiExResolveOperands (
             }
             goto NextOperand;
 
-
         case ARGI_BUFFER_OR_STRING:
 
             /* Need an operand of type STRING or BUFFER */
@@ -574,7 +567,6 @@ AcpiExResolveOperands (
             }
             goto NextOperand;
 
-
         case ARGI_DATAOBJECT:
             /*
              * ARGI_DATAOBJECT is only used by the SizeOf operator.
@@ -594,6 +586,7 @@ AcpiExResolveOperands (
                 break;
 
             default:
+
                 ACPI_ERROR ((AE_INFO,
                     "Needed [Buffer/String/Package/Reference], found [%s] %p",
                     AcpiUtGetObjectTypeName (ObjDesc), ObjDesc));
@@ -602,7 +595,6 @@ AcpiExResolveOperands (
             }
             goto NextOperand;
 
-
         case ARGI_COMPLEXOBJ:
 
             /* Need a buffer or package or (ACPI 2.0) String */
@@ -617,6 +609,7 @@ AcpiExResolveOperands (
                 break;
 
             default:
+
                 ACPI_ERROR ((AE_INFO,
                     "Needed [Buffer/String/Package], found [%s] %p",
                     AcpiUtGetObjectTypeName (ObjDesc), ObjDesc));
@@ -625,11 +618,12 @@ AcpiExResolveOperands (
             }
             goto NextOperand;
 
-
         case ARGI_REGION_OR_BUFFER: /* Used by Load() only */
 
-            /* Need an operand of type REGION or a BUFFER (which could be a resolved region field) */
-
+            /*
+             * Need an operand of type REGION or a BUFFER
+             * (which could be a resolved region field)
+             */
             switch (ObjDesc->Common.Type)
             {
             case ACPI_TYPE_BUFFER:
@@ -639,6 +633,7 @@ AcpiExResolveOperands (
                 break;
 
             default:
+
                 ACPI_ERROR ((AE_INFO,
                     "Needed [Region/Buffer], found [%s] %p",
                     AcpiUtGetObjectTypeName (ObjDesc), ObjDesc));
@@ -647,7 +642,6 @@ AcpiExResolveOperands (
             }
             goto NextOperand;
 
-
         case ARGI_DATAREFOBJ:
 
             /* Used by the Store() operator only */
@@ -673,9 +667,9 @@ AcpiExResolveOperands (
                 if (AcpiGbl_EnableInterpreterSlack)
                 {
                     /*
-                     * Enable original behavior of Store(), allowing any and all
-                     * objects as the source operand.  The ACPI spec does not
-                     * allow this, however.
+                     * Enable original behavior of Store(), allowing any
+                     * and all objects as the source operand. The ACPI
+                     * spec does not allow this, however.
                      */
                     break;
                 }
@@ -688,14 +682,14 @@ AcpiExResolveOperands (
                 }
 
                 ACPI_ERROR ((AE_INFO,
-                    "Needed Integer/Buffer/String/Package/Ref/Ddb], found [%s] %p",
+                    "Needed Integer/Buffer/String/Package/Ref/Ddb]"
+                    ", found [%s] %p",
                     AcpiUtGetObjectTypeName (ObjDesc), ObjDesc));
 
                 return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
             }
             goto NextOperand;
 
-
         default:
 
             /* Unknown type */
@@ -711,8 +705,8 @@ AcpiExResolveOperands (
          * Make sure that the original object was resolved to the
          * required object type (Simple cases only).
          */
-        Status = AcpiExCheckObjectType (TypeNeeded,
-                        (*StackPtr)->Common.Type, *StackPtr);
+        Status = AcpiExCheckObjectType (
+            TypeNeeded, (*StackPtr)->Common.Type, *StackPtr);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -734,5 +728,3 @@ NextOperand:
 
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exstore.c b/usr/src/uts/intel/io/acpica/executer/exstore.c
index 656b649478..cb18c036c5 100644
--- a/usr/src/uts/intel/io/acpica/executer/exstore.c
+++ b/usr/src/uts/intel/io/acpica/executer/exstore.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXSTORE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdispat.h"
@@ -62,21 +60,27 @@ AcpiExStoreObjectToIndex (
     ACPI_OPERAND_OBJECT     *DestDesc,
     ACPI_WALK_STATE         *WalkState);
 
+static ACPI_STATUS
+AcpiExStoreDirectToNode (
+    ACPI_OPERAND_OBJECT     *SourceDesc,
+    ACPI_NAMESPACE_NODE     *Node,
+    ACPI_WALK_STATE         *WalkState);
+
 
 /*******************************************************************************
  *
  * FUNCTION:    AcpiExStore
  *
  * PARAMETERS:  *SourceDesc         - Value to be stored
- *              *DestDesc           - Where to store it.  Must be an NS node
- *                                    or an ACPI_OPERAND_OBJECT of type
+ *              *DestDesc           - Where to store it. Must be an NS node
+ *                                    or ACPI_OPERAND_OBJECT of type
  *                                    Reference;
  *              WalkState           - Current walk state
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Store the value described by SourceDesc into the location
- *              described by DestDesc.  Called by various interpreter
+ *              described by DestDesc. Called by various interpreter
  *              functions to store the result of an operation into
  *              the destination operand -- not just simply the actual "Store"
  *              ASL operator.
@@ -113,8 +117,8 @@ AcpiExStore (
          * Storing an object into a Named node.
          */
         Status = AcpiExStoreObjectToNode (SourceDesc,
-                    (ACPI_NAMESPACE_NODE *) DestDesc, WalkState,
-                    ACPI_IMPLICIT_CONVERSION);
+            (ACPI_NAMESPACE_NODE *) DestDesc, WalkState,
+            ACPI_IMPLICIT_CONVERSION);
 
         return_ACPI_STATUS (Status);
     }
@@ -124,6 +128,7 @@ AcpiExStore (
     switch (DestDesc->Common.Type)
     {
     case ACPI_TYPE_LOCAL_REFERENCE:
+
         break;
 
     case ACPI_TYPE_INTEGER:
@@ -142,7 +147,7 @@ AcpiExStore (
         /* Destination is not a Reference object */
 
         ACPI_ERROR ((AE_INFO,
-            "Target is not a Reference or Constant object - %s [%p]",
+            "Target is not a Reference or Constant object - [%s] %p",
             AcpiUtGetObjectTypeName (DestDesc), DestDesc));
 
         return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
@@ -163,11 +168,10 @@ AcpiExStore (
         /* Storing an object into a Name "container" */
 
         Status = AcpiExStoreObjectToNode (SourceDesc,
-                    RefDesc->Reference.Object,
-                    WalkState, ACPI_IMPLICIT_CONVERSION);
+            RefDesc->Reference.Object,
+            WalkState, ACPI_IMPLICIT_CONVERSION);
         break;
 
-
     case ACPI_REFCLASS_INDEX:
 
         /* Storing to an Index (pointer into a packager or buffer) */
@@ -175,31 +179,27 @@ AcpiExStore (
         Status = AcpiExStoreObjectToIndex (SourceDesc, RefDesc, WalkState);
         break;
 
-
     case ACPI_REFCLASS_LOCAL:
     case ACPI_REFCLASS_ARG:
 
         /* Store to a method local/arg  */
 
         Status = AcpiDsStoreObjectToLocal (RefDesc->Reference.Class,
-                    RefDesc->Reference.Value, SourceDesc, WalkState);
+            RefDesc->Reference.Value, SourceDesc, WalkState);
         break;
 
-
     case ACPI_REFCLASS_DEBUG:
-
         /*
          * Storing to the Debug object causes the value stored to be
          * displayed and otherwise has no effect -- see ACPI Specification
          */
         ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "**** Write to Debug Object: Object %p %s ****:\n\n",
+            "**** Write to Debug Object: Object %p [%s] ****:\n\n",
             SourceDesc, AcpiUtGetObjectTypeName (SourceDesc)));
 
         ACPI_DEBUG_OBJECT (SourceDesc, 0, 0);
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Unknown Reference Class 0x%2.2X",
@@ -274,7 +274,8 @@ AcpiExStoreObjectToIndex (
         {
             /* Normal object, copy it */
 
-            Status = AcpiUtCopyIobjectToIobject (SourceDesc, &NewDesc, WalkState);
+            Status = AcpiUtCopyIobjectToIobject (
+                SourceDesc, &NewDesc, WalkState);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -308,9 +309,7 @@ AcpiExStoreObjectToIndex (
 
         break;
 
-
     case ACPI_TYPE_BUFFER_FIELD:
-
         /*
          * Store into a Buffer or String (not actually a real BufferField)
          * at a location defined by an Index.
@@ -358,7 +357,7 @@ AcpiExStoreObjectToIndex (
             /* All other types are invalid */
 
             ACPI_ERROR ((AE_INFO,
-                "Source must be Integer/Buffer/String type, not %s",
+                "Source must be type [Integer/Buffer/String], found [%s]",
                 AcpiUtGetObjectTypeName (SourceDesc)));
             return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
         }
@@ -368,11 +367,10 @@ AcpiExStoreObjectToIndex (
         ObjDesc->Buffer.Pointer[IndexDesc->Reference.Value] = Value;
         break;
 
-
     default:
         ACPI_ERROR ((AE_INFO,
-            "Target is not a Package or BufferField"));
-        Status = AE_AML_OPERAND_TYPE;
+            "Target is not of type [Package/BufferField]"));
+        Status = AE_AML_TARGET_TYPE;
         break;
     }
 
@@ -393,16 +391,20 @@ AcpiExStoreObjectToIndex (
  *
  * DESCRIPTION: Store the object to the named object.
  *
- *              The Assignment of an object to a named object is handled here
- *              The value passed in will replace the current value (if any)
- *              with the input value.
+ * The assignment of an object to a named object is handled here.
+ * The value passed in will replace the current value (if any)
+ * with the input value.
  *
- *              When storing into an object the data is converted to the
- *              target object type then stored in the object.  This means
- *              that the target object type (for an initialized target) will
- *              not be changed by a store operation.
+ * When storing into an object the data is converted to the
+ * target object type then stored in the object. This means
+ * that the target object type (for an initialized target) will
+ * not be changed by a store operation. A CopyObject can change
+ * the target type, however.
  *
- *              Assumes parameters are already validated.
+ * The ImplicitConversion flag is set to NO/FALSE only when
+ * storing to an ArgX -- as per the rules of the ACPI spec.
+ *
+ * Assumes parameters are already validated.
  *
  ******************************************************************************/
 
@@ -427,9 +429,75 @@ AcpiExStoreObjectToNode (
     TargetType = AcpiNsGetType (Node);
     TargetDesc = AcpiNsGetAttachedObject (Node);
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Storing %p(%s) into node %p(%s)\n",
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Storing %p [%s] to node %p [%s]\n",
         SourceDesc, AcpiUtGetObjectTypeName (SourceDesc),
-              Node, AcpiUtGetTypeName (TargetType)));
+        Node, AcpiUtGetTypeName (TargetType)));
+
+    /* Only limited target types possible for everything except CopyObject */
+
+    if (WalkState->Opcode != AML_COPY_OP)
+    {
+        /*
+         * Only CopyObject allows all object types to be overwritten. For
+         * TargetRef(s), there are restrictions on the object types that
+         * are allowed.
+         *
+         * Allowable operations/typing for Store:
+         *
+         * 1) Simple Store
+         *      Integer     --> Integer (Named/Local/Arg)
+         *      String      --> String  (Named/Local/Arg)
+         *      Buffer      --> Buffer  (Named/Local/Arg)
+         *      Package     --> Package (Named/Local/Arg)
+         *
+         * 2) Store with implicit conversion
+         *      Integer     --> String or Buffer  (Named)
+         *      String      --> Integer or Buffer (Named)
+         *      Buffer      --> Integer or String (Named)
+         */
+        switch (TargetType)
+        {
+        case ACPI_TYPE_PACKAGE:
+            /*
+             * Here, can only store a package to an existing package.
+             * Storing a package to a Local/Arg is OK, and handled
+             * elsewhere.
+             */
+            if (WalkState->Opcode == AML_STORE_OP)
+            {
+                if (SourceDesc->Common.Type != ACPI_TYPE_PACKAGE)
+                {
+                    ACPI_ERROR ((AE_INFO,
+                        "Cannot assign type [%s] to [Package] "
+                        "(source must be type Pkg)",
+                        AcpiUtGetObjectTypeName (SourceDesc)));
+
+                    return_ACPI_STATUS (AE_AML_TARGET_TYPE);
+                }
+                break;
+            }
+
+        /* Fallthrough */
+
+        case ACPI_TYPE_DEVICE:
+        case ACPI_TYPE_EVENT:
+        case ACPI_TYPE_MUTEX:
+        case ACPI_TYPE_REGION:
+        case ACPI_TYPE_POWER:
+        case ACPI_TYPE_PROCESSOR:
+        case ACPI_TYPE_THERMAL:
+
+            ACPI_ERROR ((AE_INFO,
+                "Target must be [Buffer/Integer/String/Reference]"
+                ", found [%s] (%4.4s)",
+                AcpiUtGetTypeName (Node->Type), Node->Name.Ascii));
+
+            return_ACPI_STATUS (AE_AML_TARGET_TYPE);
+
+        default:
+            break;
+        }
+    }
 
     /*
      * Resolve the source object to an actual value
@@ -441,51 +509,34 @@ AcpiExStoreObjectToNode (
         return_ACPI_STATUS (Status);
     }
 
-    /* If no implicit conversion, drop into the default case below */
-
-    if ((!ImplicitConversion) ||
-          ((WalkState->Opcode == AML_COPY_OP) &&
-           (TargetType != ACPI_TYPE_LOCAL_REGION_FIELD) &&
-           (TargetType != ACPI_TYPE_LOCAL_BANK_FIELD) &&
-           (TargetType != ACPI_TYPE_LOCAL_INDEX_FIELD)))
-    {
-        /*
-         * Force execution of default (no implicit conversion). Note:
-         * CopyObject does not perform an implicit conversion, as per the ACPI
-         * spec -- except in case of region/bank/index fields -- because these
-         * objects must retain their original type permanently.
-         */
-        TargetType = ACPI_TYPE_ANY;
-    }
-
     /* Do the actual store operation */
 
     switch (TargetType)
     {
-    case ACPI_TYPE_BUFFER_FIELD:
-    case ACPI_TYPE_LOCAL_REGION_FIELD:
-    case ACPI_TYPE_LOCAL_BANK_FIELD:
-    case ACPI_TYPE_LOCAL_INDEX_FIELD:
-
-        /* For fields, copy the source data to the target field. */
-
-        Status = AcpiExWriteDataToField (SourceDesc, TargetDesc,
-                    &WalkState->ResultObj);
-        break;
-
-
+        /*
+         * The simple data types all support implicit source operand
+         * conversion before the store.
+         */
     case ACPI_TYPE_INTEGER:
     case ACPI_TYPE_STRING:
     case ACPI_TYPE_BUFFER:
 
-        /*
-         * These target types are all of type Integer/String/Buffer, and
-         * therefore support implicit conversion before the store.
-         *
-         * Copy and/or convert the source object to a new target object
-         */
+        if ((WalkState->Opcode == AML_COPY_OP) ||
+            !ImplicitConversion)
+        {
+            /*
+             * However, CopyObject and Stores to ArgX do not perform
+             * an implicit conversion, as per the ACPI specification.
+             * A direct store is performed instead.
+             */
+            Status = AcpiExStoreDirectToNode (SourceDesc, Node, WalkState);
+            break;
+        }
+
+        /* Store with implicit source operand conversion support */
+
         Status = AcpiExStoreObjectToObject (SourceDesc, TargetDesc,
-                    &NewDesc, WalkState);
+            &NewDesc, WalkState);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -498,30 +549,44 @@ AcpiExStoreObjectToNode (
              * the Name's type to that of the value being stored in it.
              * SourceDesc reference count is incremented by AttachObject.
              *
-             * Note: This may change the type of the node if an explicit store
-             * has been performed such that the node/object type has been
-             * changed.
+             * Note: This may change the type of the node if an explicit
+             * store has been performed such that the node/object type
+             * has been changed.
              */
-            Status = AcpiNsAttachObject (Node, NewDesc, NewDesc->Common.Type);
+            Status = AcpiNsAttachObject (
+                Node, NewDesc, NewDesc->Common.Type);
 
             ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-                "Store %s into %s via Convert/Attach\n",
+                "Store type [%s] into [%s] via Convert/Attach\n",
                 AcpiUtGetObjectTypeName (SourceDesc),
                 AcpiUtGetObjectTypeName (NewDesc)));
         }
         break;
 
+    case ACPI_TYPE_BUFFER_FIELD:
+    case ACPI_TYPE_LOCAL_REGION_FIELD:
+    case ACPI_TYPE_LOCAL_BANK_FIELD:
+    case ACPI_TYPE_LOCAL_INDEX_FIELD:
+        /*
+         * For all fields, always write the source data to the target
+         * field. Any required implicit source operand conversion is
+         * performed in the function below as necessary. Note, field
+         * objects must retain their original type permanently.
+         */
+        Status = AcpiExWriteDataToField (SourceDesc, TargetDesc,
+            &WalkState->ResultObj);
+        break;
 
     default:
-
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "Storing %s (%p) directly into node (%p) with no implicit conversion\n",
-            AcpiUtGetObjectTypeName (SourceDesc), SourceDesc, Node));
-
-        /* No conversions for all other types.  Just attach the source object */
-
-        Status = AcpiNsAttachObject (Node, SourceDesc,
-                    SourceDesc->Common.Type);
+        /*
+         * CopyObject operator: No conversions for all other types.
+         * Instead, directly store a copy of the source object.
+         *
+         * This is the ACPI spec-defined behavior for the CopyObject
+         * operator. (Note, for this default case, all normal
+         * Store/Target operations exited above with an error).
+         */
+        Status = AcpiExStoreDirectToNode (SourceDesc, Node, WalkState);
         break;
     }
 
@@ -529,3 +594,51 @@ AcpiExStoreObjectToNode (
 }
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExStoreDirectToNode
+ *
+ * PARAMETERS:  SourceDesc              - Value to be stored
+ *              Node                    - Named object to receive the value
+ *              WalkState               - Current walk state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: "Store" an object directly to a node. This involves a copy
+ *              and an attach.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiExStoreDirectToNode (
+    ACPI_OPERAND_OBJECT     *SourceDesc,
+    ACPI_NAMESPACE_NODE     *Node,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_STATUS             Status;
+    ACPI_OPERAND_OBJECT     *NewDesc;
+
+
+    ACPI_FUNCTION_TRACE (ExStoreDirectToNode);
+
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+        "Storing [%s] (%p) directly into node [%s] (%p)"
+        " with no implicit conversion\n",
+        AcpiUtGetObjectTypeName (SourceDesc), SourceDesc,
+        AcpiUtGetTypeName (Node->Type), Node));
+
+    /* Copy the source object to a new object */
+
+    Status = AcpiUtCopyIobjectToIobject (SourceDesc, &NewDesc, WalkState);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Attach the new object to the node */
+
+    Status = AcpiNsAttachObject (Node, NewDesc, NewDesc->Common.Type);
+    AcpiUtRemoveReference (NewDesc);
+    return_ACPI_STATUS (Status);
+}
diff --git a/usr/src/uts/intel/io/acpica/executer/exstoren.c b/usr/src/uts/intel/io/acpica/executer/exstoren.c
index 464d6b1065..7a69927b12 100644
--- a/usr/src/uts/intel/io/acpica/executer/exstoren.c
+++ b/usr/src/uts/intel/io/acpica/executer/exstoren.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exstoren - AML Interpreter object store support,
@@ -7,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -43,8 +42,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXSTOREN_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -65,7 +62,7 @@
  *
  * RETURN:      Status, resolved object in SourceDescPtr.
  *
- * DESCRIPTION: Resolve an object.  If the object is a reference, dereference
+ * DESCRIPTION: Resolve an object. If the object is a reference, dereference
  *              it and return the actual object in the SourceDescPtr.
  *
  ******************************************************************************/
@@ -95,14 +92,12 @@ AcpiExResolveObject (
          * These cases all require only Integers or values that
          * can be converted to Integers (Strings or Buffers)
          */
-
     case ACPI_TYPE_INTEGER:
     case ACPI_TYPE_STRING:
     case ACPI_TYPE_BUFFER:
-
         /*
          * Stores into a Field/Region or into a Integer/Buffer/String
-         * are all essentially the same.  This case handles the
+         * are all essentially the same. This case handles the
          * "interchangeable" types Integer, String, and Buffer.
          */
         if (SourceDesc->Common.Type == ACPI_TYPE_LOCAL_REFERENCE)
@@ -129,22 +124,21 @@ AcpiExResolveObject (
             (SourceDesc->Common.Type != ACPI_TYPE_BUFFER)     &&
             (SourceDesc->Common.Type != ACPI_TYPE_STRING)     &&
             !((SourceDesc->Common.Type == ACPI_TYPE_LOCAL_REFERENCE) &&
-                    (SourceDesc->Reference.Class== ACPI_REFCLASS_TABLE)))
+                (SourceDesc->Reference.Class== ACPI_REFCLASS_TABLE)))
         {
             /* Conversion successful but still not a valid type */
 
             ACPI_ERROR ((AE_INFO,
-                "Cannot assign type %s to %s (must be type Int/Str/Buf)",
+                "Cannot assign type [%s] to [%s] (must be type Int/Str/Buf)",
                 AcpiUtGetObjectTypeName (SourceDesc),
                 AcpiUtGetTypeName (TargetType)));
+
             Status = AE_AML_OPERAND_TYPE;
         }
         break;
 
-
     case ACPI_TYPE_LOCAL_ALIAS:
     case ACPI_TYPE_LOCAL_METHOD_ALIAS:
-
         /*
          * All aliases should have been resolved earlier, during the
          * operand resolution phase.
@@ -153,10 +147,8 @@ AcpiExResolveObject (
         Status = AE_AML_INTERNAL;
         break;
 
-
     case ACPI_TYPE_PACKAGE:
     default:
-
         /*
          * All other types than Alias and the various Fields come here,
          * including the untyped case - ACPI_TYPE_ANY.
@@ -179,7 +171,7 @@ AcpiExResolveObject (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: "Store" an object to another object.  This may include
+ * DESCRIPTION: "Store" an object to another object. This may include
  *              converting the source type to the target type (implicit
  *              conversion), and a copy of the value of the source to
  *              the target.
@@ -190,14 +182,14 @@ AcpiExResolveObject (
  *              with the input value.
  *
  *              When storing into an object the data is converted to the
- *              target object type then stored in the object.  This means
+ *              target object type then stored in the object. This means
  *              that the target object type (for an initialized target) will
  *              not be changed by a store operation.
  *
  *              This module allows destination types of Number, String,
  *              Buffer, and Package.
  *
- *              Assumes parameters are already validated.  NOTE: SourceDesc
+ *              Assumes parameters are already validated. NOTE: SourceDesc
  *              resolution (from a reference object) must be performed by
  *              the caller if necessary.
  *
@@ -241,7 +233,7 @@ AcpiExStoreObjectToObject (
          * converted object.
          */
         Status = AcpiExConvertToTargetType (DestDesc->Common.Type,
-                        SourceDesc, &ActualSrcDesc, WalkState);
+            SourceDesc, &ActualSrcDesc, WalkState);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -270,7 +262,7 @@ AcpiExStoreObjectToObject (
 
         /* Truncate value if we are executing from a 32-bit ACPI table */
 
-        AcpiExTruncateFor32bitTable (DestDesc);
+        (void) AcpiExTruncateFor32bitTable (DestDesc);
         break;
 
     case ACPI_TYPE_STRING:
@@ -293,7 +285,7 @@ AcpiExStoreObjectToObject (
         /*
          * All other types come here.
          */
-        ACPI_WARNING ((AE_INFO, "Store into type %s not implemented",
+        ACPI_WARNING ((AE_INFO, "Store into type [%s] not implemented",
             AcpiUtGetObjectTypeName (DestDesc)));
 
         Status = AE_NOT_IMPLEMENTED;
@@ -310,5 +302,3 @@ AcpiExStoreObjectToObject (
     *NewDesc = DestDesc;
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exstorob.c b/usr/src/uts/intel/io/acpica/executer/exstorob.c
index e74d5b3485..8418fb85a2 100644
--- a/usr/src/uts/intel/io/acpica/executer/exstorob.c
+++ b/usr/src/uts/intel/io/acpica/executer/exstorob.c
@@ -1,12 +1,11 @@
-
 /******************************************************************************
  *
- * Module Name: exstorob - AML Interpreter object store support, store to object
+ * Module Name: exstorob - AML object store support, store to object
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXSTOROB_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -112,13 +109,13 @@ AcpiExStoreBufferToBuffer (
     {
         /* Clear existing buffer and copy in the new one */
 
-        ACPI_MEMSET (TargetDesc->Buffer.Pointer, 0, TargetDesc->Buffer.Length);
-        ACPI_MEMCPY (TargetDesc->Buffer.Pointer, Buffer, Length);
+        memset (TargetDesc->Buffer.Pointer, 0, TargetDesc->Buffer.Length);
+        memcpy (TargetDesc->Buffer.Pointer, Buffer, Length);
 
 #ifdef ACPI_OBSOLETE_BEHAVIOR
         /*
          * NOTE: ACPI versions up to 3.0 specified that the buffer must be
-         * truncated if the string is smaller than the buffer.  However, "other"
+         * truncated if the string is smaller than the buffer. However, "other"
          * implementations of ACPI never did this and thus became the defacto
          * standard. ACPI 3.0A changes this behavior such that the buffer
          * is no longer truncated.
@@ -127,7 +124,7 @@ AcpiExStoreBufferToBuffer (
         /*
          * OBSOLETE BEHAVIOR:
          * If the original source was a string, we must truncate the buffer,
-         * according to the ACPI spec.  Integer-to-Buffer and Buffer-to-Buffer
+         * according to the ACPI spec. Integer-to-Buffer and Buffer-to-Buffer
          * copy must not truncate the original buffer.
          */
         if (OriginalSrcType == ACPI_TYPE_STRING)
@@ -142,7 +139,7 @@ AcpiExStoreBufferToBuffer (
     {
         /* Truncate the source, copy only what will fit */
 
-        ACPI_MEMCPY (TargetDesc->Buffer.Pointer, Buffer,
+        memcpy (TargetDesc->Buffer.Pointer, Buffer,
             TargetDesc->Buffer.Length);
 
         ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
@@ -206,9 +203,9 @@ AcpiExStoreStringToString (
          * String will fit in existing non-static buffer.
          * Clear old string and copy in the new one
          */
-        ACPI_MEMSET (TargetDesc->String.Pointer, 0,
+        memset (TargetDesc->String.Pointer, 0,
             (ACPI_SIZE) TargetDesc->String.Length + 1);
-        ACPI_MEMCPY (TargetDesc->String.Pointer, Buffer, Length);
+        memcpy (TargetDesc->String.Pointer, Buffer, Length);
     }
     else
     {
@@ -224,15 +221,16 @@ AcpiExStoreStringToString (
             ACPI_FREE (TargetDesc->String.Pointer);
         }
 
-        TargetDesc->String.Pointer = ACPI_ALLOCATE_ZEROED (
-                                        (ACPI_SIZE) Length + 1);
+        TargetDesc->String.Pointer =
+            ACPI_ALLOCATE_ZEROED ((ACPI_SIZE) Length + 1);
+
         if (!TargetDesc->String.Pointer)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
         }
 
         TargetDesc->Common.Flags &= ~AOPOBJ_STATIC_POINTER;
-        ACPI_MEMCPY (TargetDesc->String.Pointer, Buffer, Length);
+        memcpy (TargetDesc->String.Pointer, Buffer, Length);
     }
 
     /* Set the new target length */
@@ -240,5 +238,3 @@ AcpiExStoreStringToString (
     TargetDesc->String.Length = Length;
     return_ACPI_STATUS (AE_OK);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/executer/exsystem.c b/usr/src/uts/intel/io/acpica/executer/exsystem.c
index 37f5b234a3..a215e8012d 100644
--- a/usr/src/uts/intel/io/acpica/executer/exsystem.c
+++ b/usr/src/uts/intel/io/acpica/executer/exsystem.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exsystem - Interface to OS services
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXSYSTEM_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -62,7 +59,7 @@
  * RETURN:      Status
  *
  * DESCRIPTION: Implements a semaphore wait with a check to see if the
- *              semaphore is available immediately.  If it is not, the
+ *              semaphore is available immediately. If it is not, the
  *              interpreter is released before waiting.
  *
  ******************************************************************************/
@@ -88,8 +85,7 @@ AcpiExSystemWaitSemaphore (
     {
         /* We must wait, so unlock the interpreter */
 
-        AcpiExRelinquishInterpreter ();
-
+        AcpiExExitInterpreter ();
         Status = AcpiOsWaitSemaphore (Semaphore, 1, Timeout);
 
         ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
@@ -98,7 +94,7 @@ AcpiExSystemWaitSemaphore (
 
         /* Reacquire the interpreter */
 
-       AcpiExReacquireInterpreter ();
+        AcpiExEnterInterpreter ();
     }
 
     return_ACPI_STATUS (Status);
@@ -115,7 +111,7 @@ AcpiExSystemWaitSemaphore (
  * RETURN:      Status
  *
  * DESCRIPTION: Implements a mutex wait with a check to see if the
- *              mutex is available immediately.  If it is not, the
+ *              mutex is available immediately. If it is not, the
  *              interpreter is released before waiting.
  *
  ******************************************************************************/
@@ -141,8 +137,7 @@ AcpiExSystemWaitMutex (
     {
         /* We must wait, so unlock the interpreter */
 
-        AcpiExRelinquishInterpreter ();
-
+        AcpiExExitInterpreter ();
         Status = AcpiOsAcquireMutex (Mutex, Timeout);
 
         ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
@@ -151,7 +146,7 @@ AcpiExSystemWaitMutex (
 
         /* Reacquire the interpreter */
 
-        AcpiExReacquireInterpreter ();
+        AcpiExEnterInterpreter ();
     }
 
     return_ACPI_STATUS (Status);
@@ -170,7 +165,7 @@ AcpiExSystemWaitMutex (
  * DESCRIPTION: Suspend running thread for specified amount of time.
  *              Note: ACPI specification requires that Stall() does not
  *              relinquish the processor, and delays longer than 100 usec
- *              should use Sleep() instead.  We allow stalls up to 255 usec
+ *              should use Sleep() instead. We allow stalls up to 255 usec
  *              for compatibility with other interpreters and existing BIOSs.
  *
  ******************************************************************************/
@@ -193,8 +188,8 @@ AcpiExSystemDoStall (
          * (ACPI specifies 100 usec as max, but this gives some slack in
          * order to support existing BIOSs)
          */
-        ACPI_ERROR ((AE_INFO, "Time parameter is too large (%u)",
-            HowLong));
+        ACPI_ERROR ((AE_INFO,
+            "Time parameter is too large (%u)", HowLong));
         Status = AE_AML_OPERAND_VALUE;
     }
     else
@@ -228,7 +223,7 @@ AcpiExSystemDoSleep (
 
     /* Since this thread will sleep, we must release the interpreter */
 
-    AcpiExRelinquishInterpreter ();
+    AcpiExExitInterpreter ();
 
     /*
      * For compatibility with other ACPI implementations and to prevent
@@ -243,7 +238,7 @@ AcpiExSystemDoSleep (
 
     /* And now we must get the interpreter again */
 
-    AcpiExReacquireInterpreter ();
+    AcpiExEnterInterpreter ();
     return (AE_OK);
 }
 
@@ -290,7 +285,7 @@ AcpiExSystemSignalEvent (
  * RETURN:      Status
  *
  * DESCRIPTION: Provides an access point to perform synchronization operations
- *              within the AML.  This operation is a request to wait for an
+ *              within the AML. This operation is a request to wait for an
  *              event.
  *
  ******************************************************************************/
@@ -309,7 +304,7 @@ AcpiExSystemWaitEvent (
     if (ObjDesc)
     {
         Status = AcpiExSystemWaitSemaphore (ObjDesc->Event.OsSemaphore,
-                    (UINT16) TimeDesc->Integer.Value);
+            (UINT16) TimeDesc->Integer.Value);
     }
 
     return_ACPI_STATUS (Status);
@@ -352,4 +347,3 @@ AcpiExSystemResetEvent (
 
     return (Status);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/executer/extrace.c b/usr/src/uts/intel/io/acpica/executer/extrace.c
new file mode 100644
index 0000000000..6f8a707ae4
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/executer/extrace.c
@@ -0,0 +1,427 @@
+/******************************************************************************
+ *
+ * Module Name: extrace - Support for interpreter execution tracing
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acinterp.h"
+
+
+#define _COMPONENT          ACPI_EXECUTER
+        ACPI_MODULE_NAME    ("extrace")
+
+
+static ACPI_OPERAND_OBJECT  *AcpiGbl_TraceMethodObject = NULL;
+
+/* Local prototypes */
+
+#ifdef ACPI_DEBUG_OUTPUT
+static const char *
+AcpiExGetTraceEventName (
+    ACPI_TRACE_EVENT_TYPE   Type);
+#endif
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExInterpreterTraceEnabled
+ *
+ * PARAMETERS:  Name                - Whether method name should be matched,
+ *                                    this should be checked before starting
+ *                                    the tracer
+ *
+ * RETURN:      TRUE if interpreter trace is enabled.
+ *
+ * DESCRIPTION: Check whether interpreter trace is enabled
+ *
+ ******************************************************************************/
+
+static BOOLEAN
+AcpiExInterpreterTraceEnabled (
+    char                    *Name)
+{
+
+    /* Check if tracing is enabled */
+
+    if (!(AcpiGbl_TraceFlags & ACPI_TRACE_ENABLED))
+    {
+        return (FALSE);
+    }
+
+    /*
+     * Check if tracing is filtered:
+     *
+     * 1. If the tracer is started, AcpiGbl_TraceMethodObject should have
+     *    been filled by the trace starter
+     * 2. If the tracer is not started, AcpiGbl_TraceMethodName should be
+     *    matched if it is specified
+     * 3. If the tracer is oneshot style, AcpiGbl_TraceMethodName should
+     *    not be cleared by the trace stopper during the first match
+     */
+    if (AcpiGbl_TraceMethodObject)
+    {
+        return (TRUE);
+    }
+
+    if (Name &&
+        (AcpiGbl_TraceMethodName &&
+         strcmp (AcpiGbl_TraceMethodName, Name)))
+    {
+        return (FALSE);
+    }
+
+    if ((AcpiGbl_TraceFlags & ACPI_TRACE_ONESHOT) &&
+        !AcpiGbl_TraceMethodName)
+    {
+        return (FALSE);
+    }
+
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExGetTraceEventName
+ *
+ * PARAMETERS:  Type            - Trace event type
+ *
+ * RETURN:      Trace event name.
+ *
+ * DESCRIPTION: Used to obtain the full trace event name.
+ *
+ ******************************************************************************/
+
+#ifdef ACPI_DEBUG_OUTPUT
+
+static const char *
+AcpiExGetTraceEventName (
+    ACPI_TRACE_EVENT_TYPE   Type)
+{
+
+    switch (Type)
+    {
+    case ACPI_TRACE_AML_METHOD:
+
+        return "Method";
+
+    case ACPI_TRACE_AML_OPCODE:
+
+        return "Opcode";
+
+    case ACPI_TRACE_AML_REGION:
+
+        return "Region";
+
+    default:
+
+        return "";
+    }
+}
+
+#endif
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExTracePoint
+ *
+ * PARAMETERS:  Type                - Trace event type
+ *              Begin               - TRUE if before execution
+ *              Aml                 - Executed AML address
+ *              Pathname            - Object path
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Internal interpreter execution trace.
+ *
+ ******************************************************************************/
+
+void
+AcpiExTracePoint (
+    ACPI_TRACE_EVENT_TYPE   Type,
+    BOOLEAN                 Begin,
+    UINT8                   *Aml,
+    char                    *Pathname)
+{
+
+    ACPI_FUNCTION_NAME (ExTracePoint);
+
+
+    if (Pathname)
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_TRACE_POINT,
+            "%s %s [0x%p:%s] execution.\n",
+            AcpiExGetTraceEventName (Type), Begin ? "Begin" : "End",
+            Aml, Pathname));
+    }
+    else
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_TRACE_POINT,
+            "%s %s [0x%p] execution.\n",
+            AcpiExGetTraceEventName (Type), Begin ? "Begin" : "End",
+            Aml));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExStartTraceMethod
+ *
+ * PARAMETERS:  MethodNode          - Node of the method
+ *              ObjDesc             - The method object
+ *              WalkState           - current state, NULL if not yet executing
+ *                                    a method.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Start control method execution trace
+ *
+ ******************************************************************************/
+
+void
+AcpiExStartTraceMethod (
+    ACPI_NAMESPACE_NODE     *MethodNode,
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_STATUS             Status;
+    char                    *Pathname = NULL;
+    BOOLEAN                 Enabled = FALSE;
+
+
+    ACPI_FUNCTION_NAME (ExStartTraceMethod);
+
+
+    if (MethodNode)
+    {
+        Pathname = AcpiNsGetNormalizedPathname (MethodNode, TRUE);
+    }
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
+    if (ACPI_FAILURE (Status))
+    {
+        goto Exit;
+    }
+
+    Enabled = AcpiExInterpreterTraceEnabled (Pathname);
+    if (Enabled && !AcpiGbl_TraceMethodObject)
+    {
+        AcpiGbl_TraceMethodObject = ObjDesc;
+        AcpiGbl_OriginalDbgLevel = AcpiDbgLevel;
+        AcpiGbl_OriginalDbgLayer = AcpiDbgLayer;
+        AcpiDbgLevel = ACPI_TRACE_LEVEL_ALL;
+        AcpiDbgLayer = ACPI_TRACE_LAYER_ALL;
+
+        if (AcpiGbl_TraceDbgLevel)
+        {
+            AcpiDbgLevel = AcpiGbl_TraceDbgLevel;
+        }
+
+        if (AcpiGbl_TraceDbgLayer)
+        {
+            AcpiDbgLayer = AcpiGbl_TraceDbgLayer;
+        }
+    }
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+
+Exit:
+    if (Enabled)
+    {
+        ACPI_TRACE_POINT (ACPI_TRACE_AML_METHOD, TRUE,
+            ObjDesc ? ObjDesc->Method.AmlStart : NULL, Pathname);
+    }
+
+    if (Pathname)
+    {
+        ACPI_FREE (Pathname);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExStopTraceMethod
+ *
+ * PARAMETERS:  MethodNode          - Node of the method
+ *              ObjDesc             - The method object
+ *              WalkState           - current state, NULL if not yet executing
+ *                                    a method.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Stop control method execution trace
+ *
+ ******************************************************************************/
+
+void
+AcpiExStopTraceMethod (
+    ACPI_NAMESPACE_NODE     *MethodNode,
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_WALK_STATE         *WalkState)
+{
+    ACPI_STATUS             Status;
+    char                    *Pathname = NULL;
+    BOOLEAN                 Enabled;
+
+
+    ACPI_FUNCTION_NAME (ExStopTraceMethod);
+
+
+    if (MethodNode)
+    {
+        Pathname = AcpiNsGetNormalizedPathname (MethodNode, TRUE);
+    }
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
+    if (ACPI_FAILURE (Status))
+    {
+        goto ExitPath;
+    }
+
+    Enabled = AcpiExInterpreterTraceEnabled (NULL);
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+
+    if (Enabled)
+    {
+        ACPI_TRACE_POINT (ACPI_TRACE_AML_METHOD, FALSE,
+            ObjDesc ? ObjDesc->Method.AmlStart : NULL, Pathname);
+    }
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
+    if (ACPI_FAILURE (Status))
+    {
+        goto ExitPath;
+    }
+
+    /* Check whether the tracer should be stopped */
+
+    if (AcpiGbl_TraceMethodObject == ObjDesc)
+    {
+        /* Disable further tracing if type is one-shot */
+
+        if (AcpiGbl_TraceFlags & ACPI_TRACE_ONESHOT)
+        {
+            AcpiGbl_TraceMethodName = NULL;
+        }
+
+        AcpiDbgLevel = AcpiGbl_OriginalDbgLevel;
+        AcpiDbgLayer = AcpiGbl_OriginalDbgLayer;
+        AcpiGbl_TraceMethodObject = NULL;
+    }
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+
+ExitPath:
+    if (Pathname)
+    {
+        ACPI_FREE (Pathname);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExStartTraceOpcode
+ *
+ * PARAMETERS:  Op                  - The parser opcode object
+ *              WalkState           - current state, NULL if not yet executing
+ *                                    a method.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Start opcode execution trace
+ *
+ ******************************************************************************/
+
+void
+AcpiExStartTraceOpcode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+{
+
+    ACPI_FUNCTION_NAME (ExStartTraceOpcode);
+
+
+    if (AcpiExInterpreterTraceEnabled (NULL) &&
+        (AcpiGbl_TraceFlags & ACPI_TRACE_OPCODE))
+    {
+        ACPI_TRACE_POINT (ACPI_TRACE_AML_OPCODE, TRUE,
+            Op->Common.Aml, Op->Common.AmlOpName);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExStopTraceOpcode
+ *
+ * PARAMETERS:  Op                  - The parser opcode object
+ *              WalkState           - current state, NULL if not yet executing
+ *                                    a method.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Stop opcode execution trace
+ *
+ ******************************************************************************/
+
+void
+AcpiExStopTraceOpcode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState)
+{
+
+    ACPI_FUNCTION_NAME (ExStopTraceOpcode);
+
+
+    if (AcpiExInterpreterTraceEnabled (NULL) &&
+        (AcpiGbl_TraceFlags & ACPI_TRACE_OPCODE))
+    {
+        ACPI_TRACE_POINT (ACPI_TRACE_AML_OPCODE, FALSE,
+            Op->Common.Aml, Op->Common.AmlOpName);
+    }
+}
diff --git a/usr/src/uts/intel/io/acpica/executer/exutils.c b/usr/src/uts/intel/io/acpica/executer/exutils.c
index b5eca064a2..4843a20891 100644
--- a/usr/src/uts/intel/io/acpica/executer/exutils.c
+++ b/usr/src/uts/intel/io/acpica/executer/exutils.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: exutils - interpreter/scanner utilities
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,17 +41,15 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __EXUTILS_C__
-
 /*
  * DEFINE_AML_GLOBALS is tested in amlcode.h
  * to determine whether certain global names should be "defined" or only
- * "declared" in the current compilation.  This enhances maintainability
+ * "declared" in the current compilation. This enhances maintainability
  * by enabling a single header file to embody all knowledge of the names
  * in question.
  *
  * Exactly one module of any executable should #define DEFINE_GLOBALS
- * before #including the header files which use this convention.  The
+ * before #including the header files which use this convention. The
  * names in question will be defined and initialized in that module,
  * and declared as extern in all other modules which #include those
  * header files.
@@ -111,42 +108,6 @@ AcpiExEnterInterpreter (
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiExReacquireInterpreter
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Reacquire the interpreter execution region from within the
- *              interpreter code. Failure to enter the interpreter region is a
- *              fatal system error. Used in  conjuction with
- *              RelinquishInterpreter
- *
- ******************************************************************************/
-
-void
-AcpiExReacquireInterpreter (
-    void)
-{
-    ACPI_FUNCTION_TRACE (ExReacquireInterpreter);
-
-
-    /*
-     * If the global serialized flag is set, do not release the interpreter,
-     * since it was not actually released by AcpiExRelinquishInterpreter.
-     * This forces the interpreter to be single threaded.
-     */
-    if (!AcpiGbl_AllMethodsSerialized)
-    {
-        AcpiExEnterInterpreter ();
-    }
-
-    return_VOID;
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiExExitInterpreter
@@ -157,7 +118,16 @@ AcpiExReacquireInterpreter (
  *
  * DESCRIPTION: Exit the interpreter execution region. This is the top level
  *              routine used to exit the interpreter when all processing has
- *              been completed.
+ *              been completed, or when the method blocks.
+ *
+ * Cases where the interpreter is unlocked internally:
+ *      1) Method will be blocked on a Sleep() AML opcode
+ *      2) Method will be blocked on an Acquire() AML opcode
+ *      3) Method will be blocked on a Wait() AML opcode
+ *      4) Method will be blocked to acquire the global lock
+ *      5) Method will be blocked waiting to execute a serialized control
+ *          method that is currently executing
+ *      6) About to invoke a user-installed opregion handler
  *
  ******************************************************************************/
 
@@ -181,63 +151,20 @@ AcpiExExitInterpreter (
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiExRelinquishInterpreter
- *
- * PARAMETERS:  None
- *
- * RETURN:      None
- *
- * DESCRIPTION: Exit the interpreter execution region, from within the
- *              interpreter - before attempting an operation that will possibly
- *              block the running thread.
- *
- * Cases where the interpreter is unlocked internally
- *      1) Method to be blocked on a Sleep() AML opcode
- *      2) Method to be blocked on an Acquire() AML opcode
- *      3) Method to be blocked on a Wait() AML opcode
- *      4) Method to be blocked to acquire the global lock
- *      5) Method to be blocked waiting to execute a serialized control method
- *          that is currently executing
- *      6) About to invoke a user-installed opregion handler
- *
- ******************************************************************************/
-
-void
-AcpiExRelinquishInterpreter (
-    void)
-{
-    ACPI_FUNCTION_TRACE (ExRelinquishInterpreter);
-
-
-    /*
-     * If the global serialized flag is set, do not release the interpreter.
-     * This forces the interpreter to be single threaded.
-     */
-    if (!AcpiGbl_AllMethodsSerialized)
-    {
-        AcpiExExitInterpreter ();
-    }
-
-    return_VOID;
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiExTruncateFor32bitTable
  *
  * PARAMETERS:  ObjDesc         - Object to be truncated
  *
- * RETURN:      none
+ * RETURN:      TRUE if a truncation was performed, FALSE otherwise.
  *
  * DESCRIPTION: Truncate an ACPI Integer to 32 bits if the execution mode is
  *              32-bit, as determined by the revision of the DSDT.
  *
  ******************************************************************************/
 
-void
+BOOLEAN
 AcpiExTruncateFor32bitTable (
     ACPI_OPERAND_OBJECT     *ObjDesc)
 {
@@ -247,23 +174,27 @@ AcpiExTruncateFor32bitTable (
 
     /*
      * Object must be a valid number and we must be executing
-     * a control method. NS node could be there for AML_INT_NAMEPATH_OP.
+     * a control method. Object could be NS node for AML_INT_NAMEPATH_OP.
      */
     if ((!ObjDesc) ||
         (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) != ACPI_DESC_TYPE_OPERAND) ||
         (ObjDesc->Common.Type != ACPI_TYPE_INTEGER))
     {
-        return;
+        return (FALSE);
     }
 
-    if (AcpiGbl_IntegerByteWidth == 4)
+    if ((AcpiGbl_IntegerByteWidth == 4) &&
+        (ObjDesc->Integer.Value > (UINT64) ACPI_UINT32_MAX))
     {
         /*
-         * We are running a method that exists in a 32-bit ACPI table.
-         * Truncate the value to 32 bits by zeroing out the upper 32-bit field
+         * We are executing in a 32-bit ACPI table. Truncate
+         * the value to 32 bits by zeroing out the upper 32-bit field
          */
         ObjDesc->Integer.Value &= (UINT64) ACPI_UINT32_MAX;
+        return (TRUE);
     }
+
+    return (FALSE);
 }
 
 
@@ -301,7 +232,7 @@ AcpiExAcquireGlobalLock (
     /* Attempt to get the global lock, wait forever */
 
     Status = AcpiExAcquireMutexObject (ACPI_WAIT_FOREVER,
-                AcpiGbl_GlobalLockMutex, AcpiOsGetThreadId ());
+        AcpiGbl_GlobalLockMutex, AcpiOsGetThreadId ());
 
     if (ACPI_FAILURE (Status))
     {
@@ -410,8 +341,8 @@ AcpiExDigitsNeeded (
  *
  * FUNCTION:    AcpiExEisaIdToString
  *
- * PARAMETERS:  CompressedId    - EISAID to be converted
- *              OutString       - Where to put the converted string (8 bytes)
+ * PARAMETERS:  OutString       - Where to put the converted string (8 bytes)
+ *              CompressedId    - EISAID to be converted
  *
  * RETURN:      None
  *
@@ -438,7 +369,8 @@ AcpiExEisaIdToString (
     if (CompressedId > ACPI_UINT32_MAX)
     {
         ACPI_WARNING ((AE_INFO,
-            "Expected EISAID is larger than 32 bits: 0x%8.8X%8.8X, truncating",
+            "Expected EISAID is larger than 32 bits: "
+            "0x%8.8X%8.8X, truncating",
             ACPI_FORMAT_UINT64 (CompressedId)));
     }
 
@@ -468,7 +400,7 @@ AcpiExEisaIdToString (
  *                                possible 64-bit integer.
  *              Value           - Value to be converted
  *
- * RETURN:      None, string
+ * RETURN:      Converted string in OutString
  *
  * DESCRIPTION: Convert a 64-bit integer to decimal string representation.
  *              Assumes string buffer is large enough to hold the string. The
@@ -500,13 +432,50 @@ AcpiExIntegerToString (
 }
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiExPciClsToString
+ *
+ * PARAMETERS:  OutString       - Where to put the converted string (7 bytes)
+ *              ClassCode       - PCI class code to be converted (3 bytes)
+ *
+ * RETURN:      Converted string in OutString
+ *
+ * DESCRIPTION: Convert 3-bytes PCI class code to string representation.
+ *              Return buffer must be large enough to hold the string. The
+ *              string returned is always exactly of length
+ *              ACPI_PCICLS_STRING_SIZE (includes null terminator).
+ *
+ ******************************************************************************/
+
+void
+AcpiExPciClsToString (
+    char                    *OutString,
+    UINT8                   ClassCode[3])
+{
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    /* All 3 bytes are hexadecimal */
+
+    OutString[0] = AcpiUtHexToAsciiChar ((UINT64) ClassCode[0], 4);
+    OutString[1] = AcpiUtHexToAsciiChar ((UINT64) ClassCode[0], 0);
+    OutString[2] = AcpiUtHexToAsciiChar ((UINT64) ClassCode[1], 4);
+    OutString[3] = AcpiUtHexToAsciiChar ((UINT64) ClassCode[1], 0);
+    OutString[4] = AcpiUtHexToAsciiChar ((UINT64) ClassCode[2], 4);
+    OutString[5] = AcpiUtHexToAsciiChar ((UINT64) ClassCode[2], 0);
+    OutString[6] = 0;
+}
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiIsValidSpaceId
  *
  * PARAMETERS:  SpaceId             - ID to be validated
  *
- * RETURN:      TRUE if valid/supported ID.
+ * RETURN:      TRUE if SpaceId is a valid/supported ID.
  *
  * DESCRIPTION: Validate an operation region SpaceID.
  *
@@ -528,5 +497,4 @@ AcpiIsValidSpaceId (
     return (TRUE);
 }
 
-
 #endif
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwacpi.c b/usr/src/uts/intel/io/acpica/hardware/hwacpi.c
index d9f16ef9d7..73512128d5 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwacpi.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwacpi.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: hwacpi - ACPI Hardware Initialization/Mode Interface
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __HWACPI_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -76,6 +73,14 @@ AcpiHwSetMode (
 
     ACPI_FUNCTION_TRACE (HwSetMode);
 
+
+    /* If the Hardware Reduced flag is set, machine is always in acpi mode */
+
+    if (AcpiGbl_ReducedHardware)
+    {
+        return_ACPI_STATUS (AE_OK);
+    }
+
     /*
      * ACPI 2.0 clarified that if SMI_CMD in FADT is zero,
      * system does not support mode transition.
@@ -108,23 +113,23 @@ AcpiHwSetMode (
         /* BIOS should have disabled ALL fixed and GP events */
 
         Status = AcpiHwWritePort (AcpiGbl_FADT.SmiCommand,
-                        (UINT32) AcpiGbl_FADT.AcpiEnable, 8);
+            (UINT32) AcpiGbl_FADT.AcpiEnable, 8);
         ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Attempting to enable ACPI mode\n"));
         break;
 
     case ACPI_SYS_MODE_LEGACY:
-
         /*
          * BIOS should clear all fixed status bits and restore fixed event
          * enable bits to default
          */
         Status = AcpiHwWritePort (AcpiGbl_FADT.SmiCommand,
-                    (UINT32) AcpiGbl_FADT.AcpiDisable, 8);
+            (UINT32) AcpiGbl_FADT.AcpiDisable, 8);
         ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-                    "Attempting to enable Legacy (non-ACPI) mode\n"));
+            "Attempting to enable Legacy (non-ACPI) mode\n"));
         break;
 
     default:
+
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
@@ -142,13 +147,13 @@ AcpiHwSetMode (
     Retry = 3000;
     while (Retry)
     {
-        if (AcpiHwGetMode() == Mode)
+        if (AcpiHwGetMode () == Mode)
         {
-            ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Mode %X successfully enabled\n",
-                Mode));
+            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+                "Mode %X successfully enabled\n", Mode));
             return_ACPI_STATUS (AE_OK);
         }
-        AcpiOsStall(1000);
+        AcpiOsStall (ACPI_USEC_PER_MSEC);
         Retry--;
     }
 
@@ -165,7 +170,7 @@ AcpiHwSetMode (
  *
  * RETURN:      SYS_MODE_ACPI or SYS_MODE_LEGACY
  *
- * DESCRIPTION: Return current operating state of system.  Determined by
+ * DESCRIPTION: Return current operating state of system. Determined by
  *              querying the SCI_EN bit.
  *
  ******************************************************************************/
@@ -181,6 +186,13 @@ AcpiHwGetMode (
     ACPI_FUNCTION_TRACE (HwGetMode);
 
 
+    /* If the Hardware Reduced flag is set, machine is always in acpi mode */
+
+    if (AcpiGbl_ReducedHardware)
+    {
+        return_UINT32 (ACPI_SYS_MODE_ACPI);
+    }
+
     /*
      * ACPI 2.0 clarified that if SMI_CMD in FADT is zero,
      * system does not support mode transition.
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwesleep.c b/usr/src/uts/intel/io/acpica/hardware/hwesleep.c
index 1587af019c..de914df853 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwesleep.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwesleep.c
@@ -6,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -99,7 +99,6 @@ AcpiHwExecuteSleepMethod (
  * FUNCTION:    AcpiHwExtendedSleep
  *
  * PARAMETERS:  SleepState          - Which sleep state to enter
- *              Flags               - ACPI_EXECUTE_GTS to run optional method
  *
  * RETURN:      Status
  *
@@ -111,8 +110,7 @@ AcpiHwExecuteSleepMethod (
 
 ACPI_STATUS
 AcpiHwExtendedSleep (
-    UINT8                   SleepState,
-    UINT8                   Flags)
+    UINT8                   SleepState)
 {
     ACPI_STATUS             Status;
     UINT8                   SleepTypeValue;
@@ -132,7 +130,8 @@ AcpiHwExtendedSleep (
 
     /* Clear wake status (WAK_STS) */
 
-    Status = AcpiWrite ((UINT64) ACPI_X_WAKE_STATUS, &AcpiGbl_FADT.SleepStatus);
+    Status = AcpiWrite ((UINT64) ACPI_X_WAKE_STATUS,
+        &AcpiGbl_FADT.SleepStatus);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -140,13 +139,6 @@ AcpiHwExtendedSleep (
 
     AcpiGbl_SystemAwakeAndRunning = FALSE;
 
-    /* Optionally execute _GTS (Going To Sleep) */
-
-    if (Flags & ACPI_EXECUTE_GTS)
-    {
-        AcpiHwExecuteSleepMethod (METHOD_PATHNAME__GTS, SleepState);
-    }
-
     /* Flush caches, as per ACPI specification */
 
     ACPI_FLUSH_CPU_CACHE ();
@@ -191,7 +183,6 @@ AcpiHwExtendedSleep (
  * FUNCTION:    AcpiHwExtendedWakePrep
  *
  * PARAMETERS:  SleepState          - Which sleep state we just exited
- *              Flags               - ACPI_EXECUTE_BFS to run optional method
  *
  * RETURN:      Status
  *
@@ -202,8 +193,7 @@ AcpiHwExtendedSleep (
 
 ACPI_STATUS
 AcpiHwExtendedWakePrep (
-    UINT8                   SleepState,
-    UINT8                   Flags)
+    UINT8                   SleepState)
 {
     ACPI_STATUS             Status;
     UINT8                   SleepTypeValue;
@@ -213,7 +203,7 @@ AcpiHwExtendedWakePrep (
 
 
     Status = AcpiGetSleepTypeData (ACPI_STATE_S0,
-                    &AcpiGbl_SleepTypeA, &AcpiGbl_SleepTypeB);
+        &AcpiGbl_SleepTypeA, &AcpiGbl_SleepTypeB);
     if (ACPI_SUCCESS (Status))
     {
         SleepTypeValue = ((AcpiGbl_SleepTypeA << ACPI_X_SLEEP_TYPE_POSITION) &
@@ -223,12 +213,6 @@ AcpiHwExtendedWakePrep (
             &AcpiGbl_FADT.SleepControl);
     }
 
-    /* Optionally execute _BFS (Back From Sleep) */
-
-    if (Flags & ACPI_EXECUTE_BFS)
-    {
-        AcpiHwExecuteSleepMethod (METHOD_PATHNAME__BFS, SleepState);
-    }
     return_ACPI_STATUS (AE_OK);
 }
 
@@ -238,7 +222,6 @@ AcpiHwExtendedWakePrep (
  * FUNCTION:    AcpiHwExtendedWake
  *
  * PARAMETERS:  SleepState          - Which sleep state we just exited
- *              Flags               - Reserved, set to zero
  *
  * RETURN:      Status
  *
@@ -249,8 +232,7 @@ AcpiHwExtendedWakePrep (
 
 ACPI_STATUS
 AcpiHwExtendedWake (
-    UINT8                   SleepState,
-    UINT8                   Flags)
+    UINT8                   SleepState)
 {
     ACPI_FUNCTION_TRACE (HwExtendedWake);
 
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwgpe.c b/usr/src/uts/intel/io/acpica/hardware/hwgpe.c
index c94f17be26..3dbf10ba0a 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwgpe.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwgpe.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: hwgpe - Low level GPE enable/disable/clear functions
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -59,13 +58,17 @@ AcpiHwEnableWakeupGpeBlock (
     ACPI_GPE_BLOCK_INFO     *GpeBlock,
     void                    *Context);
 
+static ACPI_STATUS
+AcpiHwGpeEnableWrite (
+    UINT8                   EnableMask,
+    ACPI_GPE_REGISTER_INFO  *GpeRegisterInfo);
+
 
 /******************************************************************************
  *
  * FUNCTION:    AcpiHwGetGpeRegisterBit
  *
  * PARAMETERS:  GpeEventInfo        - Info block for the GPE
- *              GpeRegisterInfo     - Info block for the GPE register
  *
  * RETURN:      Register mask with a one in the GPE bit position
  *
@@ -76,12 +79,11 @@ AcpiHwEnableWakeupGpeBlock (
 
 UINT32
 AcpiHwGetGpeRegisterBit (
-    ACPI_GPE_EVENT_INFO     *GpeEventInfo,
-    ACPI_GPE_REGISTER_INFO  *GpeRegisterInfo)
+    ACPI_GPE_EVENT_INFO     *GpeEventInfo)
 {
 
     return ((UINT32) 1 <<
-        (GpeEventInfo->GpeNumber - GpeRegisterInfo->BaseGpeNumber));
+        (GpeEventInfo->GpeNumber - GpeEventInfo->RegisterInfo->BaseGpeNumber));
 }
 
 
@@ -95,6 +97,8 @@ AcpiHwGetGpeRegisterBit (
  * RETURN:      Status
  *
  * DESCRIPTION: Enable or disable a single GPE in the parent enable register.
+ *              The EnableMask field of the involved GPE register must be
+ *              updated by the caller if necessary.
  *
  ******************************************************************************/
 
@@ -130,14 +134,14 @@ AcpiHwLowSetGpe (
 
     /* Set or clear just the bit that corresponds to this GPE */
 
-    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo, GpeRegisterInfo);
+    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo);
     switch (Action)
     {
     case ACPI_GPE_CONDITIONAL_ENABLE:
 
-        /* Only enable if the EnableForRun bit is set */
+        /* Only enable if the corresponding EnableMask bit is set */
 
-        if (!(RegisterBit & GpeRegisterInfo->EnableForRun))
+        if (!(RegisterBit & GpeRegisterInfo->EnableMask))
         {
             return (AE_BAD_PARAMETER);
         }
@@ -145,15 +149,18 @@ AcpiHwLowSetGpe (
         /*lint -fallthrough */
 
     case ACPI_GPE_ENABLE:
+
         ACPI_SET_BIT (EnableMask, RegisterBit);
         break;
 
     case ACPI_GPE_DISABLE:
+
         ACPI_CLEAR_BIT (EnableMask, RegisterBit);
         break;
 
     default:
-        ACPI_ERROR ((AE_INFO, "Invalid GPE Action, %u\n", Action));
+
+        ACPI_ERROR ((AE_INFO, "Invalid GPE Action, %u", Action));
         return (AE_BAD_PARAMETER);
     }
 
@@ -199,11 +206,9 @@ AcpiHwClearGpe (
      * Write a one to the appropriate bit in the status register to
      * clear this GPE.
      */
-    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo, GpeRegisterInfo);
-
-    Status = AcpiHwWrite (RegisterBit,
-                    &GpeRegisterInfo->StatusAddress);
+    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo);
 
+    Status = AcpiHwWrite (RegisterBit, &GpeRegisterInfo->StatusAddress);
     return (Status);
 }
 
@@ -241,13 +246,21 @@ AcpiHwGetGpeStatus (
         return (AE_BAD_PARAMETER);
     }
 
+    /* GPE currently handled? */
+
+    if (ACPI_GPE_DISPATCH_TYPE (GpeEventInfo->Flags) !=
+        ACPI_GPE_DISPATCH_NONE)
+    {
+        LocalEventStatus |= ACPI_EVENT_FLAG_HAS_HANDLER;
+    }
+
     /* Get the info block for the entire GPE register */
 
     GpeRegisterInfo = GpeEventInfo->RegisterInfo;
 
     /* Get the register bitmask for this GPE */
 
-    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo, GpeRegisterInfo);
+    RegisterBit = AcpiHwGetGpeRegisterBit (GpeEventInfo);
 
     /* GPE currently enabled? (enabled for runtime?) */
 
@@ -263,6 +276,19 @@ AcpiHwGetGpeStatus (
         LocalEventStatus |= ACPI_EVENT_FLAG_WAKE_ENABLED;
     }
 
+    /* GPE currently enabled (enable bit == 1)? */
+
+    Status = AcpiHwRead (&InByte, &GpeRegisterInfo->EnableAddress);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    if (RegisterBit & InByte)
+    {
+        LocalEventStatus |= ACPI_EVENT_FLAG_ENABLE_SET;
+    }
+
     /* GPE currently active (status bit == 1)? */
 
     Status = AcpiHwRead (&InByte, &GpeRegisterInfo->StatusAddress);
@@ -273,7 +299,7 @@ AcpiHwGetGpeStatus (
 
     if (RegisterBit & InByte)
     {
-        LocalEventStatus |= ACPI_EVENT_FLAG_SET;
+        LocalEventStatus |= ACPI_EVENT_FLAG_STATUS_SET;
     }
 
     /* Set return value */
@@ -283,6 +309,34 @@ AcpiHwGetGpeStatus (
 }
 
 
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiHwGpeEnableWrite
+ *
+ * PARAMETERS:  EnableMask          - Bit mask to write to the GPE register
+ *              GpeRegisterInfo     - Gpe Register info
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Write the enable mask byte to the given GPE register.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiHwGpeEnableWrite (
+    UINT8                   EnableMask,
+    ACPI_GPE_REGISTER_INFO  *GpeRegisterInfo)
+{
+    ACPI_STATUS             Status;
+
+
+    GpeRegisterInfo->EnableMask = EnableMask;
+
+    Status = AcpiHwWrite (EnableMask, &GpeRegisterInfo->EnableAddress);
+    return (Status);
+}
+
+
 /******************************************************************************
  *
  * FUNCTION:    AcpiHwDisableGpeBlock
@@ -312,7 +366,7 @@ AcpiHwDisableGpeBlock (
     {
         /* Disable all GPEs in this register */
 
-        Status = AcpiHwWrite (0x00, &GpeBlock->RegisterInfo[i].EnableAddress);
+        Status = AcpiHwGpeEnableWrite (0x00, &GpeBlock->RegisterInfo[i]);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
@@ -385,6 +439,7 @@ AcpiHwEnableRuntimeGpeBlock (
 {
     UINT32                  i;
     ACPI_STATUS             Status;
+    ACPI_GPE_REGISTER_INFO  *GpeRegisterInfo;
 
 
     /* NOTE: assumes that all GPEs are currently disabled */
@@ -393,15 +448,16 @@ AcpiHwEnableRuntimeGpeBlock (
 
     for (i = 0; i < GpeBlock->RegisterCount; i++)
     {
-        if (!GpeBlock->RegisterInfo[i].EnableForRun)
+        GpeRegisterInfo = &GpeBlock->RegisterInfo[i];
+        if (!GpeRegisterInfo->EnableForRun)
         {
             continue;
         }
 
         /* Enable all "runtime" GPEs in this register */
 
-        Status = AcpiHwWrite (GpeBlock->RegisterInfo[i].EnableForRun,
-                    &GpeBlock->RegisterInfo[i].EnableAddress);
+        Status = AcpiHwGpeEnableWrite (GpeRegisterInfo->EnableForRun,
+            GpeRegisterInfo);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
@@ -434,21 +490,21 @@ AcpiHwEnableWakeupGpeBlock (
 {
     UINT32                  i;
     ACPI_STATUS             Status;
+    ACPI_GPE_REGISTER_INFO  *GpeRegisterInfo;
 
 
     /* Examine each GPE Register within the block */
 
     for (i = 0; i < GpeBlock->RegisterCount; i++)
     {
-        if (!GpeBlock->RegisterInfo[i].EnableForWake)
-        {
-            continue;
-        }
-
-        /* Enable all "wake" GPEs in this register */
-
-        Status = AcpiHwWrite (GpeBlock->RegisterInfo[i].EnableForWake,
-                    &GpeBlock->RegisterInfo[i].EnableAddress);
+        GpeRegisterInfo = &GpeBlock->RegisterInfo[i];
+
+        /*
+         * Enable all "wake" GPEs in this register and disable the
+         * remaining ones.
+         */
+        Status = AcpiHwGpeEnableWrite (GpeRegisterInfo->EnableForWake,
+            GpeRegisterInfo);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwpci.c b/usr/src/uts/intel/io/acpica/hardware/hwpci.c
index 065e42d95e..c2b707122d 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwpci.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwpci.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __HWPCI_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -142,7 +140,7 @@ AcpiHwDerivePciId (
     ACPI_HANDLE             PciRegion)
 {
     ACPI_STATUS             Status;
-    ACPI_PCI_DEVICE         *ListHead = NULL;
+    ACPI_PCI_DEVICE         *ListHead;
 
 
     ACPI_FUNCTION_TRACE (HwDerivePciId);
@@ -161,11 +159,12 @@ AcpiHwDerivePciId (
         /* Walk the list, updating the PCI device/function/bus numbers */
 
         Status = AcpiHwProcessPciList (PciId, ListHead);
-    }
 
-    /* Always delete the list */
+        /* Delete the list */
+
+        AcpiHwDeletePciList (ListHead);
+    }
 
-    AcpiHwDeletePciList (ListHead);
     return_ACPI_STATUS (Status);
 }
 
@@ -199,7 +198,6 @@ AcpiHwBuildPciList (
     ACPI_HANDLE             ParentDevice;
     ACPI_STATUS             Status;
     ACPI_PCI_DEVICE         *ListElement;
-    ACPI_PCI_DEVICE         *ListHead = NULL;
 
 
     /*
@@ -207,12 +205,16 @@ AcpiHwBuildPciList (
      * a list of device nodes. Loop will exit when either the PCI device is
      * found, or the root of the namespace is reached.
      */
+    *ReturnListHead = NULL;
     CurrentDevice = PciRegion;
     while (1)
     {
         Status = AcpiGetParent (CurrentDevice, &ParentDevice);
         if (ACPI_FAILURE (Status))
         {
+            /* Must delete the list before exit */
+
+            AcpiHwDeletePciList (*ReturnListHead);
             return (Status);
         }
 
@@ -220,21 +222,23 @@ AcpiHwBuildPciList (
 
         if (ParentDevice == RootPciDevice)
         {
-            *ReturnListHead = ListHead;
             return (AE_OK);
         }
 
         ListElement = ACPI_ALLOCATE (sizeof (ACPI_PCI_DEVICE));
         if (!ListElement)
         {
+            /* Must delete the list before exit */
+
+            AcpiHwDeletePciList (*ReturnListHead);
             return (AE_NO_MEMORY);
         }
 
         /* Put new element at the head of the list */
 
-        ListElement->Next = ListHead;
+        ListElement->Next = *ReturnListHead;
         ListElement->Device = ParentDevice;
-        ListHead = ListElement;
+        *ReturnListHead = ListElement;
 
         CurrentDevice = ParentDevice;
     }
@@ -292,7 +296,7 @@ AcpiHwProcessPciList (
             &BusNumber, &IsBridge);
         if (ACPI_FAILURE (Status))
         {
-            return_ACPI_STATUS (Status);
+            return (Status);
         }
 
         Info = Info->Next;
@@ -304,7 +308,7 @@ AcpiHwProcessPciList (
         PciId->Segment, PciId->Bus, PciId->Device, PciId->Function,
         Status, BusNumber, IsBridge));
 
-    return_ACPI_STATUS (AE_OK);
+    return (AE_OK);
 }
 
 
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwregs.c b/usr/src/uts/intel/io/acpica/hardware/hwregs.c
index 6d89883179..bc85c96b55 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwregs.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwregs.c
@@ -1,4 +1,3 @@
-
 /*******************************************************************************
  *
  * Module Name: hwregs - Read/write access functions for the various ACPI
@@ -7,7 +6,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -43,8 +42,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __HWREGS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acevents.h"
@@ -71,6 +68,7 @@ AcpiHwWriteMultiple (
 
 #endif /* !ACPI_REDUCED_HARDWARE */
 
+
 /******************************************************************************
  *
  * FUNCTION:    AcpiHwValidateRegister
@@ -199,14 +197,14 @@ AcpiHwRead (
     if (Reg->SpaceId == ACPI_ADR_SPACE_SYSTEM_MEMORY)
     {
         Status = AcpiOsReadMemory ((ACPI_PHYSICAL_ADDRESS)
-                    Address, &Value64, Reg->BitWidth);
+            Address, &Value64, Reg->BitWidth);
 
         *Value = (UINT32) Value64;
     }
     else /* ACPI_ADR_SPACE_SYSTEM_IO, validated earlier */
     {
         Status = AcpiHwReadPort ((ACPI_IO_ADDRESS)
-                    Address, Value, Reg->BitWidth);
+            Address, Value, Reg->BitWidth);
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_IO,
@@ -260,12 +258,12 @@ AcpiHwWrite (
     if (Reg->SpaceId == ACPI_ADR_SPACE_SYSTEM_MEMORY)
     {
         Status = AcpiOsWriteMemory ((ACPI_PHYSICAL_ADDRESS)
-                    Address, (UINT64) Value, Reg->BitWidth);
+            Address, (UINT64) Value, Reg->BitWidth);
     }
     else /* ACPI_ADR_SPACE_SYSTEM_IO, validated earlier */
     {
         Status = AcpiHwWritePort ((ACPI_IO_ADDRESS)
-                    Address, Value, Reg->BitWidth);
+            Address, Value, Reg->BitWidth);
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_IO,
@@ -310,18 +308,20 @@ AcpiHwClearAcpiStatus (
     /* Clear the fixed events in PM1 A/B */
 
     Status = AcpiHwRegisterWrite (ACPI_REGISTER_PM1_STATUS,
-                ACPI_BITMASK_ALL_FIXED_STATUS);
+        ACPI_BITMASK_ALL_FIXED_STATUS);
+
+    AcpiOsReleaseLock (AcpiGbl_HardwareLock, LockFlags);
+
     if (ACPI_FAILURE (Status))
     {
-        goto UnlockAndExit;
+        goto Exit;
     }
 
     /* Clear the GPE Bits in all GPE registers in all GPE blocks */
 
     Status = AcpiEvWalkGpeList (AcpiHwClearGpeBlock, NULL);
 
-UnlockAndExit:
-    AcpiOsReleaseLock (AcpiGbl_HardwareLock, LockFlags);
+Exit:
     return_ACPI_STATUS (Status);
 }
 
@@ -427,24 +427,22 @@ AcpiHwRegisterRead (
     case ACPI_REGISTER_PM1_STATUS:           /* PM1 A/B: 16-bit access each */
 
         Status = AcpiHwReadMultiple (&Value,
-                    &AcpiGbl_XPm1aStatus,
-                    &AcpiGbl_XPm1bStatus);
+            &AcpiGbl_XPm1aStatus,
+            &AcpiGbl_XPm1bStatus);
         break;
 
-
     case ACPI_REGISTER_PM1_ENABLE:           /* PM1 A/B: 16-bit access each */
 
         Status = AcpiHwReadMultiple (&Value,
-                    &AcpiGbl_XPm1aEnable,
-                    &AcpiGbl_XPm1bEnable);
+            &AcpiGbl_XPm1aEnable,
+            &AcpiGbl_XPm1bEnable);
         break;
 
-
     case ACPI_REGISTER_PM1_CONTROL:          /* PM1 A/B: 16-bit access each */
 
         Status = AcpiHwReadMultiple (&Value,
-                    &AcpiGbl_FADT.XPm1aControlBlock,
-                    &AcpiGbl_FADT.XPm1bControlBlock);
+            &AcpiGbl_FADT.XPm1aControlBlock,
+            &AcpiGbl_FADT.XPm1bControlBlock);
 
         /*
          * Zero the write-only bits. From the ACPI specification, "Hardware
@@ -454,26 +452,23 @@ AcpiHwRegisterRead (
         Value &= ~ACPI_PM1_CONTROL_WRITEONLY_BITS;
         break;
 
-
     case ACPI_REGISTER_PM2_CONTROL:          /* 8-bit access */
 
         Status = AcpiHwRead (&Value, &AcpiGbl_FADT.XPm2ControlBlock);
         break;
 
-
     case ACPI_REGISTER_PM_TIMER:             /* 32-bit access */
 
         Status = AcpiHwRead (&Value, &AcpiGbl_FADT.XPmTimerBlock);
         break;
 
-
     case ACPI_REGISTER_SMI_COMMAND_BLOCK:    /* 8-bit access */
 
         Status = AcpiHwReadPort (AcpiGbl_FADT.SmiCommand, &Value, 8);
         break;
 
-
     default:
+
         ACPI_ERROR ((AE_INFO, "Unknown Register ID: 0x%X",
             RegisterId));
         Status = AE_BAD_PARAMETER;
@@ -543,28 +538,25 @@ AcpiHwRegisterWrite (
         Value &= ~ACPI_PM1_STATUS_PRESERVED_BITS;
 
         Status = AcpiHwWriteMultiple (Value,
-                    &AcpiGbl_XPm1aStatus,
-                    &AcpiGbl_XPm1bStatus);
+            &AcpiGbl_XPm1aStatus,
+            &AcpiGbl_XPm1bStatus);
         break;
 
-
     case ACPI_REGISTER_PM1_ENABLE:           /* PM1 A/B: 16-bit access each */
 
         Status = AcpiHwWriteMultiple (Value,
-                    &AcpiGbl_XPm1aEnable,
-                    &AcpiGbl_XPm1bEnable);
+            &AcpiGbl_XPm1aEnable,
+            &AcpiGbl_XPm1bEnable);
         break;
 
-
     case ACPI_REGISTER_PM1_CONTROL:          /* PM1 A/B: 16-bit access each */
-
         /*
          * Perform a read first to preserve certain bits (per ACPI spec)
          * Note: This includes SCI_EN, we never want to change this bit
          */
         Status = AcpiHwReadMultiple (&ReadValue,
-                    &AcpiGbl_FADT.XPm1aControlBlock,
-                    &AcpiGbl_FADT.XPm1bControlBlock);
+            &AcpiGbl_FADT.XPm1aControlBlock,
+            &AcpiGbl_FADT.XPm1bControlBlock);
         if (ACPI_FAILURE (Status))
         {
             goto Exit;
@@ -577,13 +569,11 @@ AcpiHwRegisterWrite (
         /* Now we can write the data */
 
         Status = AcpiHwWriteMultiple (Value,
-                    &AcpiGbl_FADT.XPm1aControlBlock,
-                    &AcpiGbl_FADT.XPm1bControlBlock);
+            &AcpiGbl_FADT.XPm1aControlBlock,
+            &AcpiGbl_FADT.XPm1bControlBlock);
         break;
 
-
     case ACPI_REGISTER_PM2_CONTROL:          /* 8-bit access */
-
         /*
          * For control registers, all reserved bits must be preserved,
          * as per the ACPI spec.
@@ -601,13 +591,11 @@ AcpiHwRegisterWrite (
         Status = AcpiHwWrite (Value, &AcpiGbl_FADT.XPm2ControlBlock);
         break;
 
-
     case ACPI_REGISTER_PM_TIMER:             /* 32-bit access */
 
         Status = AcpiHwWrite (Value, &AcpiGbl_FADT.XPmTimerBlock);
         break;
 
-
     case ACPI_REGISTER_SMI_COMMAND_BLOCK:    /* 8-bit access */
 
         /* SMI_CMD is currently always in IO space */
@@ -615,8 +603,8 @@ AcpiHwRegisterWrite (
         Status = AcpiHwWritePort (AcpiGbl_FADT.SmiCommand, Value, 8);
         break;
 
-
     default:
+
         ACPI_ERROR ((AE_INFO, "Unknown Register ID: 0x%X",
             RegisterId));
         Status = AE_BAD_PARAMETER;
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwsleep.c b/usr/src/uts/intel/io/acpica/hardware/hwsleep.c
index 1953ff846e..13cf255137 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwsleep.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwsleep.c
@@ -6,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -55,7 +55,6 @@
  * FUNCTION:    AcpiHwLegacySleep
  *
  * PARAMETERS:  SleepState          - Which sleep state to enter
- *              Flags               - ACPI_EXECUTE_GTS to run optional method
  *
  * RETURN:      Status
  *
@@ -66,8 +65,7 @@
 
 ACPI_STATUS
 AcpiHwLegacySleep (
-    UINT8                   SleepState,
-    UINT8                   Flags)
+    UINT8                   SleepState)
 {
     ACPI_BIT_REGISTER_INFO  *SleepTypeRegInfo;
     ACPI_BIT_REGISTER_INFO  *SleepEnableRegInfo;
@@ -85,7 +83,8 @@ AcpiHwLegacySleep (
 
     /* Clear wake status */
 
-    Status = AcpiWriteBitRegister (ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);
+    Status = AcpiWriteBitRegister (ACPI_BITREG_WAKE_STATUS,
+        ACPI_CLEAR_STATUS);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -99,20 +98,6 @@ AcpiHwLegacySleep (
         return_ACPI_STATUS (Status);
     }
 
-    if (SleepState != ACPI_STATE_S5)
-    {
-        /*
-         * Disable BM arbitration. This feature is contained within an
-         * optional register (PM2 Control), so ignore a BAD_ADDRESS
-         * exception.
-         */
-        Status = AcpiWriteBitRegister (ACPI_BITREG_ARB_DISABLE, 1);
-        if (ACPI_FAILURE (Status) && (Status != AE_BAD_ADDRESS))
-        {
-            return_ACPI_STATUS (Status);
-        }
-    }
-
     /*
      * 1) Disable/Clear all GPEs
      * 2) Enable all wakeup GPEs
@@ -130,17 +115,10 @@ AcpiHwLegacySleep (
         return_ACPI_STATUS (Status);
     }
 
-    /* Optionally execute _GTS (Going To Sleep) */
-
-    if (Flags & ACPI_EXECUTE_GTS)
-    {
-        AcpiHwExecuteSleepMethod (METHOD_PATHNAME__GTS, SleepState);
-    }
-
     /* Get current value of PM1A control */
 
     Status = AcpiHwRegisterRead (ACPI_REGISTER_PM1_CONTROL,
-                &Pm1aControl);
+        &Pm1aControl);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -151,7 +129,7 @@ AcpiHwLegacySleep (
     /* Clear the SLP_EN and SLP_TYP fields */
 
     Pm1aControl &= ~(SleepTypeRegInfo->AccessBitMask |
-                     SleepEnableRegInfo->AccessBitMask);
+         SleepEnableRegInfo->AccessBitMask);
     Pm1bControl = Pm1aControl;
 
     /* Insert the SLP_TYP bits */
@@ -202,10 +180,10 @@ AcpiHwLegacySleep (
          * to still read the right value. Ideally, this block would go
          * away entirely.
          */
-        AcpiOsStall (10000000);
+        AcpiOsStall (10 * ACPI_USEC_PER_SEC);
 
         Status = AcpiHwRegisterWrite (ACPI_REGISTER_PM1_CONTROL,
-                    SleepEnableRegInfo->AccessBitMask);
+            SleepEnableRegInfo->AccessBitMask);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -233,7 +211,6 @@ AcpiHwLegacySleep (
  * FUNCTION:    AcpiHwLegacyWakePrep
  *
  * PARAMETERS:  SleepState          - Which sleep state we just exited
- *              Flags               - ACPI_EXECUTE_BFS to run optional method
  *
  * RETURN:      Status
  *
@@ -245,8 +222,7 @@ AcpiHwLegacySleep (
 
 ACPI_STATUS
 AcpiHwLegacyWakePrep (
-    UINT8                   SleepState,
-    UINT8                   Flags)
+    UINT8                   SleepState)
 {
     ACPI_STATUS             Status;
     ACPI_BIT_REGISTER_INFO  *SleepTypeRegInfo;
@@ -263,7 +239,7 @@ AcpiHwLegacyWakePrep (
      * by some machines.
      */
     Status = AcpiGetSleepTypeData (ACPI_STATE_S0,
-                    &AcpiGbl_SleepTypeA, &AcpiGbl_SleepTypeB);
+        &AcpiGbl_SleepTypeA, &AcpiGbl_SleepTypeB);
     if (ACPI_SUCCESS (Status))
     {
         SleepTypeRegInfo =
@@ -274,7 +250,7 @@ AcpiHwLegacyWakePrep (
         /* Get current value of PM1A control */
 
         Status = AcpiHwRegisterRead (ACPI_REGISTER_PM1_CONTROL,
-                    &Pm1aControl);
+            &Pm1aControl);
         if (ACPI_SUCCESS (Status))
         {
             /* Clear the SLP_EN and SLP_TYP fields */
@@ -296,12 +272,6 @@ AcpiHwLegacyWakePrep (
         }
     }
 
-    /* Optionally execute _BFS (Back From Sleep) */
-
-    if (Flags & ACPI_EXECUTE_BFS)
-    {
-        AcpiHwExecuteSleepMethod (METHOD_PATHNAME__BFS, SleepState);
-    }
     return_ACPI_STATUS (Status);
 }
 
@@ -311,7 +281,6 @@ AcpiHwLegacyWakePrep (
  * FUNCTION:    AcpiHwLegacyWake
  *
  * PARAMETERS:  SleepState          - Which sleep state we just exited
- *              Flags               - Reserved, set to zero
  *
  * RETURN:      Status
  *
@@ -322,8 +291,7 @@ AcpiHwLegacyWakePrep (
 
 ACPI_STATUS
 AcpiHwLegacyWake (
-    UINT8                   SleepState,
-    UINT8                   Flags)
+    UINT8                   SleepState)
 {
     ACPI_STATUS             Status;
 
@@ -367,7 +335,8 @@ AcpiHwLegacyWake (
      * and use it to determine whether the system is rebooting or
      * resuming. Clear WAK_STS for compatibility.
      */
-    (void) AcpiWriteBitRegister (ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);
+    (void) AcpiWriteBitRegister (ACPI_BITREG_WAKE_STATUS,
+        ACPI_CLEAR_STATUS);
     AcpiGbl_SystemAwakeAndRunning = TRUE;
 
     /* Enable power button */
@@ -380,17 +349,6 @@ AcpiHwLegacyWake (
             AcpiGbl_FixedEventInfo[ACPI_EVENT_POWER_BUTTON].StatusRegisterId,
             ACPI_CLEAR_STATUS);
 
-    /*
-     * Enable BM arbitration. This feature is contained within an
-     * optional register (PM2 Control), so ignore a BAD_ADDRESS
-     * exception.
-     */
-    Status = AcpiWriteBitRegister (ACPI_BITREG_ARB_DISABLE, 0);
-    if (ACPI_FAILURE (Status) && (Status != AE_BAD_ADDRESS))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
     AcpiHwExecuteSleepMethod (METHOD_PATHNAME__SST, ACPI_SST_WORKING);
     return_ACPI_STATUS (Status);
 }
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwtimer.c b/usr/src/uts/intel/io/acpica/hardware/hwtimer.c
index 15dc58f0bf..64b2a8aaf5 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwtimer.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwtimer.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Name: hwtimer.c - ACPI Power Management Timer Interface
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,6 +41,8 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
+#define EXPORT_ACPI_INTERFACES
+
 #include "acpi.h"
 #include "accommon.h"
 
@@ -116,8 +117,14 @@ AcpiGetTimer (
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
-    Status = AcpiHwRead (Ticks, &AcpiGbl_FADT.XPmTimerBlock);
+    /* ACPI 5.0A: PM Timer is optional */
+
+    if (!AcpiGbl_FADT.XPmTimerBlock.Address)
+    {
+        return_ACPI_STATUS (AE_SUPPORT);
+    }
 
+    Status = AcpiHwRead (Ticks, &AcpiGbl_FADT.XPmTimerBlock);
     return_ACPI_STATUS (Status);
 }
 
@@ -144,7 +151,7 @@ ACPI_EXPORT_SYMBOL (AcpiGetTimer)
  *              a versatile and accurate timer.
  *
  *              Note that this function accommodates only a single timer
- *              rollover.  Thus for 24-bit timers, this function should only
+ *              rollover. Thus for 24-bit timers, this function should only
  *              be used for calculating durations less than ~4.6 seconds
  *              (~20 minutes for 32-bit timers) -- calculations below:
  *
@@ -172,6 +179,13 @@ AcpiGetTimerDuration (
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
+    /* ACPI 5.0A: PM Timer is optional */
+
+    if (!AcpiGbl_FADT.XPmTimerBlock.Address)
+    {
+        return_ACPI_STATUS (AE_SUPPORT);
+    }
+
     /*
      * Compute Tick Delta:
      * Handle (max one) timer rollovers on 24-bit versus 32-bit timers.
@@ -204,10 +218,11 @@ AcpiGetTimerDuration (
     /*
      * Compute Duration (Requires a 64-bit multiply and divide):
      *
-     * TimeElapsed = (DeltaTicks * 1000000) / PM_TIMER_FREQUENCY;
+     * TimeElapsed (microseconds) =
+     *  (DeltaTicks * ACPI_USEC_PER_SEC) / ACPI_PM_TIMER_FREQUENCY;
      */
-    Status = AcpiUtShortDivide (((UINT64) DeltaTicks) * 1000000,
-                PM_TIMER_FREQUENCY, &Quotient, NULL);
+    Status = AcpiUtShortDivide (((UINT64) DeltaTicks) * ACPI_USEC_PER_SEC,
+                ACPI_PM_TIMER_FREQUENCY, &Quotient, NULL);
 
     *TimeElapsed = (UINT32) Quotient;
     return_ACPI_STATUS (Status);
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwvalid.c b/usr/src/uts/intel/io/acpica/hardware/hwvalid.c
index 4462434bbf..64507d0418 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwvalid.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwvalid.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: hwvalid - I/O request validation
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __HWVALID_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -158,8 +155,8 @@ AcpiHwValidateIoRequest (
     ByteWidth = ACPI_DIV_8 (BitWidth);
     LastAddress = Address + ByteWidth - 1;
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Address %p LastAddress %p Length %X",
-        ACPI_CAST_PTR (void, Address), ACPI_CAST_PTR (void, LastAddress),
+    ACPI_DEBUG_PRINT ((ACPI_DB_IO, "Address %8.8X%8.8X LastAddress %8.8X%8.8X Length %X",
+        ACPI_FORMAT_UINT64 (Address), ACPI_FORMAT_UINT64 (LastAddress),
         ByteWidth));
 
     /* Maximum 16-bit address in I/O space */
@@ -167,8 +164,8 @@ AcpiHwValidateIoRequest (
     if (LastAddress > ACPI_UINT16_MAX)
     {
         ACPI_ERROR ((AE_INFO,
-            "Illegal I/O port address/length above 64K: %p/0x%X",
-            ACPI_CAST_PTR (void, Address), ByteWidth));
+            "Illegal I/O port address/length above 64K: %8.8X%8.8X/0x%X",
+            ACPI_FORMAT_UINT64 (Address), ByteWidth));
         return_ACPI_STATUS (AE_LIMIT);
     }
 
@@ -199,8 +196,8 @@ AcpiHwValidateIoRequest (
             if (AcpiGbl_OsiData >= PortInfo->OsiDependency)
             {
                 ACPI_DEBUG_PRINT ((ACPI_DB_IO,
-                    "Denied AML access to port 0x%p/%X (%s 0x%.4X-0x%.4X)",
-                    ACPI_CAST_PTR (void, Address), ByteWidth, PortInfo->Name,
+                    "Denied AML access to port 0x%8.8X%8.8X/%X (%s 0x%.4X-0x%.4X)",
+                    ACPI_FORMAT_UINT64 (Address), ByteWidth, PortInfo->Name,
                     PortInfo->Start, PortInfo->End));
 
                 return_ACPI_STATUS (AE_AML_ILLEGAL_ADDRESS);
@@ -364,5 +361,3 @@ AcpiHwWritePort (
 
     return (AE_OK);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwxface.c b/usr/src/uts/intel/io/acpica/hardware/hwxface.c
index 3fec9b566f..f5d4fca6b9 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwxface.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwxface.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: hwxface - Public ACPICA hardware interfaces
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,6 +41,8 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
+#define EXPORT_ACPI_INTERFACES
+
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -91,9 +92,15 @@ AcpiReset (
          * For I/O space, write directly to the OSL. This bypasses the port
          * validation mechanism, which may block a valid write to the reset
          * register.
+         *
+         * NOTE:
+         * The ACPI spec requires the reset register width to be 8, so we
+         * hardcode it here and ignore the FADT value. This maintains
+         * compatibility with other ACPI implementations that have allowed
+         * BIOS code with bad register width values to go unnoticed.
          */
         Status = AcpiOsWritePort ((ACPI_IO_ADDRESS) ResetReg->Address,
-                    AcpiGbl_FADT.ResetValue, ResetReg->BitWidth);
+            AcpiGbl_FADT.ResetValue, ACPI_RESET_REGISTER_WIDTH);
     }
     else
     {
@@ -132,7 +139,8 @@ AcpiRead (
     UINT64                  *ReturnValue,
     ACPI_GENERIC_ADDRESS    *Reg)
 {
-    UINT32                  Value;
+    UINT32                  ValueLo;
+    UINT32                  ValueHi;
     UINT32                  Width;
     UINT64                  Address;
     ACPI_STATUS             Status;
@@ -154,19 +162,14 @@ AcpiRead (
         return (Status);
     }
 
-    /* Initialize entire 64-bit return value to zero */
-
-    *ReturnValue = 0;
-    Value = 0;
-
     /*
-     * Two address spaces supported: Memory or IO. PCI_Config is
+     * Two address spaces supported: Memory or I/O. PCI_Config is
      * not supported here because the GAS structure is insufficient
      */
     if (Reg->SpaceId == ACPI_ADR_SPACE_SYSTEM_MEMORY)
     {
         Status = AcpiOsReadMemory ((ACPI_PHYSICAL_ADDRESS)
-                    Address, ReturnValue, Reg->BitWidth);
+            Address, ReturnValue, Reg->BitWidth);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
@@ -174,6 +177,9 @@ AcpiRead (
     }
     else /* ACPI_ADR_SPACE_SYSTEM_IO, validated earlier */
     {
+        ValueLo = 0;
+        ValueHi = 0;
+
         Width = Reg->BitWidth;
         if (Width == 64)
         {
@@ -181,25 +187,27 @@ AcpiRead (
         }
 
         Status = AcpiHwReadPort ((ACPI_IO_ADDRESS)
-                    Address, &Value, Width);
+            Address, &ValueLo, Width);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
         }
-        *ReturnValue = Value;
 
         if (Reg->BitWidth == 64)
         {
             /* Read the top 32 bits */
 
             Status = AcpiHwReadPort ((ACPI_IO_ADDRESS)
-                        (Address + 4), &Value, 32);
+                (Address + 4), &ValueHi, 32);
             if (ACPI_FAILURE (Status))
             {
                 return (Status);
             }
-            *ReturnValue |= ((UINT64) Value << 32);
         }
+
+        /* Set the return value only if status is AE_OK */
+
+        *ReturnValue = (ValueLo | ((UINT64) ValueHi << 32));
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_IO,
@@ -208,7 +216,7 @@ AcpiRead (
         ACPI_FORMAT_UINT64 (Address),
         AcpiUtGetRegionName (Reg->SpaceId)));
 
-    return (Status);
+    return (AE_OK);
 }
 
 ACPI_EXPORT_SYMBOL (AcpiRead)
@@ -255,7 +263,7 @@ AcpiWrite (
     if (Reg->SpaceId == ACPI_ADR_SPACE_SYSTEM_MEMORY)
     {
         Status = AcpiOsWriteMemory ((ACPI_PHYSICAL_ADDRESS)
-                    Address, Value, Reg->BitWidth);
+            Address, Value, Reg->BitWidth);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
@@ -270,7 +278,7 @@ AcpiWrite (
         }
 
         Status = AcpiHwWritePort ((ACPI_IO_ADDRESS)
-                    Address, ACPI_LODWORD (Value), Width);
+            Address, ACPI_LODWORD (Value), Width);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
@@ -279,7 +287,7 @@ AcpiWrite (
         if (Reg->BitWidth == 64)
         {
             Status = AcpiHwWritePort ((ACPI_IO_ADDRESS)
-                        (Address + 4), ACPI_HIDWORD (Value), 32);
+                (Address + 4), ACPI_HIDWORD (Value), 32);
             if (ACPI_FAILURE (Status))
             {
                 return (Status);
@@ -350,7 +358,7 @@ AcpiReadBitRegister (
     /* Read the entire parent register */
 
     Status = AcpiHwRegisterRead (BitRegInfo->ParentRegister,
-                &RegisterValue);
+        &RegisterValue);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -359,7 +367,7 @@ AcpiReadBitRegister (
     /* Normalize the value that was read, mask off other bits */
 
     Value = ((RegisterValue & BitRegInfo->AccessBitMask)
-                >> BitRegInfo->BitPosition);
+        >> BitRegInfo->BitPosition);
 
     ACPI_DEBUG_PRINT ((ACPI_DB_IO,
         "BitReg %X, ParentReg %X, Actual %8.8X, ReturnValue %8.8X\n",
@@ -378,7 +386,7 @@ ACPI_EXPORT_SYMBOL (AcpiReadBitRegister)
  *
  * PARAMETERS:  RegisterId      - ID of ACPI Bit Register to access
  *              Value           - Value to write to the register, in bit
- *                                position zero. The bit is automaticallly
+ *                                position zero. The bit is automatically
  *                                shifted to the correct position.
  *
  * RETURN:      Status
@@ -431,7 +439,7 @@ AcpiWriteBitRegister (
          * interested in
          */
         Status = AcpiHwRegisterRead (BitRegInfo->ParentRegister,
-                    &RegisterValue);
+            &RegisterValue);
         if (ACPI_FAILURE (Status))
         {
             goto UnlockAndExit;
@@ -445,7 +453,7 @@ AcpiWriteBitRegister (
             BitRegInfo->AccessBitMask, Value);
 
         Status = AcpiHwRegisterWrite (BitRegInfo->ParentRegister,
-                    RegisterValue);
+            RegisterValue);
     }
     else
     {
@@ -465,7 +473,7 @@ AcpiWriteBitRegister (
         if (RegisterValue)
         {
             Status = AcpiHwRegisterWrite (ACPI_REGISTER_PM1_STATUS,
-                        RegisterValue);
+                RegisterValue);
         }
     }
 
@@ -493,10 +501,33 @@ ACPI_EXPORT_SYMBOL (AcpiWriteBitRegister)
  *              *SleepTypeA         - Where SLP_TYPa is returned
  *              *SleepTypeB         - Where SLP_TYPb is returned
  *
- * RETURN:      Status - ACPI status
+ * RETURN:      Status
  *
- * DESCRIPTION: Obtain the SLP_TYPa and SLP_TYPb values for the requested sleep
- *              state.
+ * DESCRIPTION: Obtain the SLP_TYPa and SLP_TYPb values for the requested
+ *              sleep state via the appropriate \_Sx object.
+ *
+ *  The sleep state package returned from the corresponding \_Sx_ object
+ *  must contain at least one integer.
+ *
+ *  March 2005:
+ *  Added support for a package that contains two integers. This
+ *  goes against the ACPI specification which defines this object as a
+ *  package with one encoded DWORD integer. However, existing practice
+ *  by many BIOS vendors is to return a package with 2 or more integer
+ *  elements, at least one per sleep type (A/B).
+ *
+ *  January 2013:
+ *  Therefore, we must be prepared to accept a package with either a
+ *  single integer or multiple integers.
+ *
+ *  The single integer DWORD format is as follows:
+ *      BYTE 0 - Value for the PM1A SLP_TYP register
+ *      BYTE 1 - Value for the PM1B SLP_TYP register
+ *      BYTE 2-3 - Reserved
+ *
+ *  The dual integer format is as follows:
+ *      Integer 0 - Value for the PM1A SLP_TYP register
+ *      Integer 1 - Value for the PM1A SLP_TYP register
  *
  ******************************************************************************/
 
@@ -506,8 +537,9 @@ AcpiGetSleepTypeData (
     UINT8                   *SleepTypeA,
     UINT8                   *SleepTypeB)
 {
-    ACPI_STATUS             Status = AE_OK;
+    ACPI_STATUS             Status;
     ACPI_EVALUATE_INFO      *Info;
+    ACPI_OPERAND_OBJECT     **Elements;
 
 
     ACPI_FUNCTION_TRACE (AcpiGetSleepTypeData);
@@ -516,8 +548,7 @@ AcpiGetSleepTypeData (
     /* Validate parameters */
 
     if ((SleepState > ACPI_S_STATES_MAX) ||
-        !SleepTypeA ||
-        !SleepTypeB)
+        !SleepTypeA || !SleepTypeB)
     {
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
@@ -530,18 +561,23 @@ AcpiGetSleepTypeData (
         return_ACPI_STATUS (AE_NO_MEMORY);
     }
 
-    Info->Pathname = ACPI_CAST_PTR (char, AcpiGbl_SleepStateNames[SleepState]);
-
-    /* Evaluate the namespace object containing the values for this state */
+    /*
+     * Evaluate the \_Sx namespace object containing the register values
+     * for this state
+     */
+    Info->RelativePathname = AcpiGbl_SleepStateNames[SleepState];
 
     Status = AcpiNsEvaluate (Info);
     if (ACPI_FAILURE (Status))
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "%s while evaluating SleepState [%s]\n",
-            AcpiFormatException (Status), Info->Pathname));
+        if (Status == AE_NOT_FOUND)
+        {
+            /* The _Sx states are optional, ignore NOT_FOUND */
 
-        goto Cleanup;
+            goto FinalCleanup;
+        }
+
+        goto WarningCleanup;
     }
 
     /* Must have a return object */
@@ -549,67 +585,76 @@ AcpiGetSleepTypeData (
     if (!Info->ReturnObject)
     {
         ACPI_ERROR ((AE_INFO, "No Sleep State object returned from [%s]",
-            Info->Pathname));
-        Status = AE_NOT_EXIST;
+            Info->RelativePathname));
+        Status = AE_AML_NO_RETURN_VALUE;
+        goto WarningCleanup;
     }
 
-    /* It must be of type Package */
+    /* Return object must be of type Package */
 
-    else if (Info->ReturnObject->Common.Type != ACPI_TYPE_PACKAGE)
+    if (Info->ReturnObject->Common.Type != ACPI_TYPE_PACKAGE)
     {
         ACPI_ERROR ((AE_INFO, "Sleep State return object is not a Package"));
         Status = AE_AML_OPERAND_TYPE;
+        goto ReturnValueCleanup;
     }
 
     /*
-     * The package must have at least two elements. NOTE (March 2005): This
-     * goes against the current ACPI spec which defines this object as a
-     * package with one encoded DWORD element. However, existing practice
-     * by BIOS vendors seems to be to have 2 or more elements, at least
-     * one per sleep type (A/B).
+     * Any warnings about the package length or the object types have
+     * already been issued by the predefined name module -- there is no
+     * need to repeat them here.
      */
-    else if (Info->ReturnObject->Package.Count < 2)
+    Elements = Info->ReturnObject->Package.Elements;
+    switch (Info->ReturnObject->Package.Count)
     {
-        ACPI_ERROR ((AE_INFO,
-            "Sleep State return package does not have at least two elements"));
-        Status = AE_AML_NO_OPERAND;
-    }
+    case 0:
 
-    /* The first two elements must both be of type Integer */
+        Status = AE_AML_PACKAGE_LIMIT;
+        break;
 
-    else if (((Info->ReturnObject->Package.Elements[0])->Common.Type
-                != ACPI_TYPE_INTEGER) ||
-             ((Info->ReturnObject->Package.Elements[1])->Common.Type
-                != ACPI_TYPE_INTEGER))
-    {
-        ACPI_ERROR ((AE_INFO,
-            "Sleep State return package elements are not both Integers "
-            "(%s, %s)",
-            AcpiUtGetObjectTypeName (Info->ReturnObject->Package.Elements[0]),
-            AcpiUtGetObjectTypeName (Info->ReturnObject->Package.Elements[1])));
-        Status = AE_AML_OPERAND_TYPE;
-    }
-    else
-    {
-        /* Valid _Sx_ package size, type, and value */
+    case 1:
+
+        if (Elements[0]->Common.Type != ACPI_TYPE_INTEGER)
+        {
+            Status = AE_AML_OPERAND_TYPE;
+            break;
+        }
 
-        *SleepTypeA = (UINT8)
-            (Info->ReturnObject->Package.Elements[0])->Integer.Value;
-        *SleepTypeB = (UINT8)
-            (Info->ReturnObject->Package.Elements[1])->Integer.Value;
+        /* A valid _Sx_ package with one integer */
+
+        *SleepTypeA = (UINT8) Elements[0]->Integer.Value;
+        *SleepTypeB = (UINT8) (Elements[0]->Integer.Value >> 8);
+        break;
+
+    case 2:
+    default:
+
+        if ((Elements[0]->Common.Type != ACPI_TYPE_INTEGER) ||
+            (Elements[1]->Common.Type != ACPI_TYPE_INTEGER))
+        {
+            Status = AE_AML_OPERAND_TYPE;
+            break;
+        }
+
+        /* A valid _Sx_ package with two integers */
+
+        *SleepTypeA = (UINT8) Elements[0]->Integer.Value;
+        *SleepTypeB = (UINT8) Elements[1]->Integer.Value;
+        break;
     }
 
+ReturnValueCleanup:
+    AcpiUtRemoveReference (Info->ReturnObject);
+
+WarningCleanup:
     if (ACPI_FAILURE (Status))
     {
         ACPI_EXCEPTION ((AE_INFO, Status,
-            "While evaluating SleepState [%s], bad Sleep object %p type %s",
-            Info->Pathname, Info->ReturnObject,
-            AcpiUtGetObjectTypeName (Info->ReturnObject)));
+            "While evaluating Sleep State [%s]",
+            Info->RelativePathname));
     }
 
-    AcpiUtRemoveReference (Info->ReturnObject);
-
-Cleanup:
+FinalCleanup:
     ACPI_FREE (Info);
     return_ACPI_STATUS (Status);
 }
diff --git a/usr/src/uts/intel/io/acpica/hardware/hwxfsleep.c b/usr/src/uts/intel/io/acpica/hardware/hwxfsleep.c
index b7cbbc813e..7a0eaf5061 100644
--- a/usr/src/uts/intel/io/acpica/hardware/hwxfsleep.c
+++ b/usr/src/uts/intel/io/acpica/hardware/hwxfsleep.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,6 +41,8 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
+#define EXPORT_ACPI_INTERFACES
+
 #include "acpi.h"
 #include "accommon.h"
 
@@ -49,10 +51,17 @@
 
 /* Local prototypes */
 
+#if (!ACPI_REDUCED_HARDWARE)
+static ACPI_STATUS
+AcpiHwSetFirmwareWakingVector (
+    ACPI_TABLE_FACS         *Facs,
+    ACPI_PHYSICAL_ADDRESS   PhysicalAddress,
+    ACPI_PHYSICAL_ADDRESS   PhysicalAddress64);
+#endif
+
 static ACPI_STATUS
 AcpiHwSleepDispatch (
     UINT8                   SleepState,
-    UINT8                   Flags,
     UINT32                  FunctionId);
 
 /*
@@ -76,87 +85,100 @@ static ACPI_SLEEP_FUNCTIONS         AcpiSleepDispatch[] =
 /*
  * These functions are removed for the ACPI_REDUCED_HARDWARE case:
  *      AcpiSetFirmwareWakingVector
- *      AcpiSetFirmwareWakingVector64
  *      AcpiEnterSleepStateS4bios
  */
 
 #if (!ACPI_REDUCED_HARDWARE)
 /*******************************************************************************
  *
- * FUNCTION:    AcpiSetFirmwareWakingVector
+ * FUNCTION:    AcpiHwSetFirmwareWakingVector
  *
- * PARAMETERS:  PhysicalAddress     - 32-bit physical address of ACPI real mode
- *                                    entry point.
+ * PARAMETERS:  Facs                - Pointer to FACS table
+ *              PhysicalAddress     - 32-bit physical address of ACPI real mode
+ *                                    entry point
+ *              PhysicalAddress64   - 64-bit physical address of ACPI protected
+ *                                    mode entry point
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Sets the 32-bit FirmwareWakingVector field of the FACS
+ * DESCRIPTION: Sets the FirmwareWakingVector fields of the FACS
  *
  ******************************************************************************/
 
-ACPI_STATUS
-AcpiSetFirmwareWakingVector (
-    UINT32                  PhysicalAddress)
+static ACPI_STATUS
+AcpiHwSetFirmwareWakingVector (
+    ACPI_TABLE_FACS         *Facs,
+    ACPI_PHYSICAL_ADDRESS   PhysicalAddress,
+    ACPI_PHYSICAL_ADDRESS   PhysicalAddress64)
 {
-    ACPI_FUNCTION_TRACE (AcpiSetFirmwareWakingVector);
+    ACPI_FUNCTION_TRACE (AcpiHwSetFirmwareWakingVector);
 
 
-    /* Set the 32-bit vector */
+    /*
+     * According to the ACPI specification 2.0c and later, the 64-bit
+     * waking vector should be cleared and the 32-bit waking vector should
+     * be used, unless we want the wake-up code to be called by the BIOS in
+     * Protected Mode. Some systems (for example HP dv5-1004nr) are known
+     * to fail to resume if the 64-bit vector is used.
+     */
 
-    AcpiGbl_FACS->FirmwareWakingVector = PhysicalAddress;
+    /* Set the 32-bit vector */
 
-    /* Clear the 64-bit vector if it exists */
+    Facs->FirmwareWakingVector = (UINT32) PhysicalAddress;
 
-    if ((AcpiGbl_FACS->Length > 32) && (AcpiGbl_FACS->Version >= 1))
+    if (Facs->Length > 32)
     {
-        AcpiGbl_FACS->XFirmwareWakingVector = 0;
+        if (Facs->Version >= 1)
+        {
+            /* Set the 64-bit vector */
+
+            Facs->XFirmwareWakingVector = PhysicalAddress64;
+        }
+        else
+        {
+            /* Clear the 64-bit vector if it exists */
+
+            Facs->XFirmwareWakingVector = 0;
+        }
     }
 
     return_ACPI_STATUS (AE_OK);
 }
 
-ACPI_EXPORT_SYMBOL (AcpiSetFirmwareWakingVector)
-
 
-#if ACPI_MACHINE_WIDTH == 64
 /*******************************************************************************
  *
- * FUNCTION:    AcpiSetFirmwareWakingVector64
+ * FUNCTION:    AcpiSetFirmwareWakingVector
  *
- * PARAMETERS:  PhysicalAddress     - 64-bit physical address of ACPI protected
- *                                    mode entry point.
+ * PARAMETERS:  PhysicalAddress     - 32-bit physical address of ACPI real mode
+ *                                    entry point
+ *              PhysicalAddress64   - 64-bit physical address of ACPI protected
+ *                                    mode entry point
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Sets the 64-bit X_FirmwareWakingVector field of the FACS, if
- *              it exists in the table. This function is intended for use with
- *              64-bit host operating systems.
+ * DESCRIPTION: Sets the FirmwareWakingVector fields of the FACS
  *
  ******************************************************************************/
 
 ACPI_STATUS
-AcpiSetFirmwareWakingVector64 (
-    UINT64                  PhysicalAddress)
+AcpiSetFirmwareWakingVector (
+    ACPI_PHYSICAL_ADDRESS   PhysicalAddress,
+    ACPI_PHYSICAL_ADDRESS   PhysicalAddress64)
 {
-    ACPI_FUNCTION_TRACE (AcpiSetFirmwareWakingVector64);
 
+    ACPI_FUNCTION_TRACE (AcpiSetFirmwareWakingVector);
 
-    /* Determine if the 64-bit vector actually exists */
-
-    if ((AcpiGbl_FACS->Length <= 32) || (AcpiGbl_FACS->Version < 1))
+    if (AcpiGbl_FACS)
     {
-        return_ACPI_STATUS (AE_NOT_EXIST);
+        (void) AcpiHwSetFirmwareWakingVector (AcpiGbl_FACS,
+            PhysicalAddress, PhysicalAddress64);
     }
 
-    /* Clear 32-bit vector, set the 64-bit X_ vector */
-
-    AcpiGbl_FACS->FirmwareWakingVector = 0;
-    AcpiGbl_FACS->XFirmwareWakingVector = PhysicalAddress;
     return_ACPI_STATUS (AE_OK);
 }
 
-ACPI_EXPORT_SYMBOL (AcpiSetFirmwareWakingVector64)
-#endif
+ACPI_EXPORT_SYMBOL (AcpiSetFirmwareWakingVector)
 
 
 /*******************************************************************************
@@ -217,15 +239,16 @@ AcpiEnterSleepStateS4bios (
     ACPI_FLUSH_CPU_CACHE ();
 
     Status = AcpiHwWritePort (AcpiGbl_FADT.SmiCommand,
-                (UINT32) AcpiGbl_FADT.S4BiosRequest, 8);
+        (UINT32) AcpiGbl_FADT.S4BiosRequest, 8);
 
     do {
-        AcpiOsStall(1000);
+        AcpiOsStall (ACPI_USEC_PER_MSEC);
         Status = AcpiReadBitRegister (ACPI_BITREG_WAKE_STATUS, &InValue);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
         }
+
     } while (!InValue);
 
     return_ACPI_STATUS (AE_OK);
@@ -253,7 +276,6 @@ ACPI_EXPORT_SYMBOL (AcpiEnterSleepStateS4bios)
 static ACPI_STATUS
 AcpiHwSleepDispatch (
     UINT8                   SleepState,
-    UINT8                   Flags,
     UINT32                  FunctionId)
 {
     ACPI_STATUS             Status;
@@ -261,21 +283,22 @@ AcpiHwSleepDispatch (
 
 
 #if (!ACPI_REDUCED_HARDWARE)
-
     /*
      * If the Hardware Reduced flag is set (from the FADT), we must
-     * use the extended sleep registers
+     * use the extended sleep registers (FADT). Note: As per the ACPI
+     * specification, these extended registers are to be used for HW-reduced
+     * platforms only. They are not general-purpose replacements for the
+     * legacy PM register sleep support.
      */
-    if (AcpiGbl_ReducedHardware ||
-        AcpiGbl_FADT.SleepControl.Address)
+    if (AcpiGbl_ReducedHardware)
     {
-        Status = SleepFunctions->ExtendedFunction (SleepState, Flags);
+        Status = SleepFunctions->ExtendedFunction (SleepState);
     }
     else
     {
         /* Legacy sleep */
 
-        Status = SleepFunctions->LegacyFunction (SleepState, Flags);
+        Status = SleepFunctions->LegacyFunction (SleepState);
     }
 
     return (Status);
@@ -285,7 +308,7 @@ AcpiHwSleepDispatch (
      * For the case where reduced-hardware-only code is being generated,
      * we know that only the extended sleep registers are available
      */
-    Status = SleepFunctions->ExtendedFunction (SleepState, Flags);
+    Status = SleepFunctions->ExtendedFunction (SleepState);
     return (Status);
 
 #endif /* !ACPI_REDUCED_HARDWARE */
@@ -321,7 +344,7 @@ AcpiEnterSleepStatePrep (
 
 
     Status = AcpiGetSleepTypeData (SleepState,
-                    &AcpiGbl_SleepTypeA, &AcpiGbl_SleepTypeB);
+        &AcpiGbl_SleepTypeA, &AcpiGbl_SleepTypeB);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -345,20 +368,24 @@ AcpiEnterSleepStatePrep (
     switch (SleepState)
     {
     case ACPI_STATE_S0:
+
         SstValue = ACPI_SST_WORKING;
         break;
 
     case ACPI_STATE_S1:
     case ACPI_STATE_S2:
     case ACPI_STATE_S3:
+
         SstValue = ACPI_SST_SLEEPING;
         break;
 
     case ACPI_STATE_S4:
+
         SstValue = ACPI_SST_SLEEP_CONTEXT;
         break;
 
     default:
+
         SstValue = ACPI_SST_INDICATOR_OFF; /* Default is off */
         break;
     }
@@ -379,7 +406,6 @@ ACPI_EXPORT_SYMBOL (AcpiEnterSleepStatePrep)
  * FUNCTION:    AcpiEnterSleepState
  *
  * PARAMETERS:  SleepState          - Which sleep state to enter
- *              Flags               - ACPI_EXECUTE_GTS to run optional method
  *
  * RETURN:      Status
  *
@@ -390,8 +416,7 @@ ACPI_EXPORT_SYMBOL (AcpiEnterSleepStatePrep)
 
 ACPI_STATUS
 AcpiEnterSleepState (
-    UINT8                   SleepState,
-    UINT8                   Flags)
+    UINT8                   SleepState)
 {
     ACPI_STATUS             Status;
 
@@ -407,7 +432,7 @@ AcpiEnterSleepState (
         return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
     }
 
-    Status = AcpiHwSleepDispatch (SleepState, Flags, ACPI_SLEEP_FUNCTION_ID);
+    Status = AcpiHwSleepDispatch (SleepState, ACPI_SLEEP_FUNCTION_ID);
     return_ACPI_STATUS (Status);
 }
 
@@ -419,7 +444,6 @@ ACPI_EXPORT_SYMBOL (AcpiEnterSleepState)
  * FUNCTION:    AcpiLeaveSleepStatePrep
  *
  * PARAMETERS:  SleepState          - Which sleep state we are exiting
- *              Flags               - ACPI_EXECUTE_BFS to run optional method
  *
  * RETURN:      Status
  *
@@ -432,8 +456,7 @@ ACPI_EXPORT_SYMBOL (AcpiEnterSleepState)
 
 ACPI_STATUS
 AcpiLeaveSleepStatePrep (
-    UINT8                   SleepState,
-    UINT8                   Flags)
+    UINT8                   SleepState)
 {
     ACPI_STATUS             Status;
 
@@ -441,7 +464,7 @@ AcpiLeaveSleepStatePrep (
     ACPI_FUNCTION_TRACE (AcpiLeaveSleepStatePrep);
 
 
-    Status = AcpiHwSleepDispatch (SleepState, Flags, ACPI_WAKE_PREP_FUNCTION_ID);
+    Status = AcpiHwSleepDispatch (SleepState, ACPI_WAKE_PREP_FUNCTION_ID);
     return_ACPI_STATUS (Status);
 }
 
@@ -471,7 +494,7 @@ AcpiLeaveSleepState (
     ACPI_FUNCTION_TRACE (AcpiLeaveSleepState);
 
 
-    Status = AcpiHwSleepDispatch (SleepState, 0, ACPI_WAKE_FUNCTION_ID);
+    Status = AcpiHwSleepDispatch (SleepState, ACPI_WAKE_FUNCTION_ID);
     return_ACPI_STATUS (Status);
 }
 
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsaccess.c b/usr/src/uts/intel/io/acpica/namespace/nsaccess.c
index 9dfa76fb08..eb6fed6230 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsaccess.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsaccess.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSACCESS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "amlcode.h"
@@ -113,20 +111,20 @@ AcpiNsRootInitialize (
     {
         /* _OSI is optional for now, will be permanent later */
 
-        if (!ACPI_STRCMP (InitVal->Name, "_OSI") && !AcpiGbl_CreateOsiMethod)
+        if (!strcmp (InitVal->Name, "_OSI") && !AcpiGbl_CreateOsiMethod)
         {
             continue;
         }
 
-        Status = AcpiNsLookup (NULL, InitVal->Name, InitVal->Type,
-                        ACPI_IMODE_LOAD_PASS2, ACPI_NS_NO_UPSEARCH,
-                        NULL, &NewNode);
-
-        if (ACPI_FAILURE (Status) || (!NewNode)) /* Must be on same line for code converter */
+        Status = AcpiNsLookup (NULL, ACPI_CAST_PTR (char, InitVal->Name),
+            InitVal->Type, ACPI_IMODE_LOAD_PASS2, ACPI_NS_NO_UPSEARCH,
+            NULL, &NewNode);
+        if (ACPI_FAILURE (Status))
         {
             ACPI_EXCEPTION ((AE_INFO, Status,
                 "Could not create predefined name %s",
                 InitVal->Name));
+            continue;
         }
 
         /*
@@ -167,6 +165,7 @@ AcpiNsRootInitialize (
             switch (InitVal->Type)
             {
             case ACPI_TYPE_METHOD:
+
                 ObjDesc->Method.ParamCount = (UINT8) ACPI_TO_INTEGER (Val);
                 ObjDesc->Common.Flags |= AOPOBJ_DATA_VALID;
 
@@ -188,17 +187,15 @@ AcpiNsRootInitialize (
                 ObjDesc->Integer.Value = ACPI_TO_INTEGER (Val);
                 break;
 
-
             case ACPI_TYPE_STRING:
 
                 /* Build an object around the static string */
 
-                ObjDesc->String.Length = (UINT32) ACPI_STRLEN (Val);
+                ObjDesc->String.Length = (UINT32) strlen (Val);
                 ObjDesc->String.Pointer = Val;
                 ObjDesc->Common.Flags |= AOPOBJ_STATIC_POINTER;
                 break;
 
-
             case ACPI_TYPE_MUTEX:
 
                 ObjDesc->Mutex.Node = NewNode;
@@ -215,14 +212,14 @@ AcpiNsRootInitialize (
 
                 /* Special case for ACPI Global Lock */
 
-                if (ACPI_STRCMP (InitVal->Name, "_GL_") == 0)
+                if (strcmp (InitVal->Name, "_GL_") == 0)
                 {
                     AcpiGbl_GlobalLockMutex = ObjDesc;
 
                     /* Create additional counting semaphore for global lock */
 
                     Status = AcpiOsCreateSemaphore (
-                                1, 0, &AcpiGbl_GlobalLockSemaphore);
+                        1, 0, &AcpiGbl_GlobalLockSemaphore);
                     if (ACPI_FAILURE (Status))
                     {
                         AcpiUtRemoveReference (ObjDesc);
@@ -231,7 +228,6 @@ AcpiNsRootInitialize (
                 }
                 break;
 
-
             default:
 
                 ACPI_ERROR ((AE_INFO, "Unsupported initial type value 0x%X",
@@ -244,7 +240,7 @@ AcpiNsRootInitialize (
             /* Store pointer to value descriptor in the Node */
 
             Status = AcpiNsAttachObject (NewNode, ObjDesc,
-                        ObjDesc->Common.Type);
+                ObjDesc->Common.Type);
 
             /* Remove local reference to the object */
 
@@ -261,7 +257,7 @@ UnlockAndExit:
     if (ACPI_SUCCESS (Status))
     {
         Status = AcpiNsGetNode (NULL, "\\_GPE", ACPI_NS_NO_UPSEARCH,
-                    &AcpiGbl_FadtGpeDevice);
+            &AcpiGbl_FadtGpeDevice);
     }
 
     return_ACPI_STATUS (Status);
@@ -323,7 +319,9 @@ AcpiNsLookup (
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
-    LocalFlags = Flags & ~(ACPI_NS_ERROR_IF_FOUND | ACPI_NS_SEARCH_PARENT);
+    LocalFlags = Flags &
+        ~(ACPI_NS_ERROR_IF_FOUND | ACPI_NS_OVERRIDE_IF_FOUND |
+          ACPI_NS_SEARCH_PARENT);
     *ReturnNode = ACPI_ENTRY_NOT_FOUND;
     AcpiGbl_NsLookupCount++;
 
@@ -450,8 +448,8 @@ AcpiNsLookup (
                     /* Current scope has no parent scope */
 
                     ACPI_ERROR ((AE_INFO,
-                        "ACPI path has too many parent prefixes (^) "
-                        "- reached beyond root node"));
+                        "%s: Path has too many parent prefixes (^) "
+                        "- reached beyond root node", Pathname));
                     return_ACPI_STATUS (AE_NOT_FOUND);
                 }
             }
@@ -575,6 +573,13 @@ AcpiNsLookup (
             {
                 LocalFlags |= ACPI_NS_ERROR_IF_FOUND;
             }
+
+            /* Set override flag according to caller */
+
+            if (Flags & ACPI_NS_OVERRIDE_IF_FOUND)
+            {
+                LocalFlags |= ACPI_NS_OVERRIDE_IF_FOUND;
+            }
         }
 
         /* Extract one ACPI name from the front of the pathname */
@@ -584,7 +589,7 @@ AcpiNsLookup (
         /* Try to find the single (4 character) ACPI name */
 
         Status = AcpiNsSearchAndEnter (SimpleName, WalkState, CurrentNode,
-                    InterpreterMode, ThisSearchType, LocalFlags, &ThisNode);
+            InterpreterMode, ThisSearchType, LocalFlags, &ThisNode);
         if (ACPI_FAILURE (Status))
         {
             if (Status == AE_NOT_FOUND)
@@ -697,4 +702,3 @@ AcpiNsLookup (
     *ReturnNode = ThisNode;
     return_ACPI_STATUS (AE_OK);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsalloc.c b/usr/src/uts/intel/io/acpica/namespace/nsalloc.c
index c7e83e0eb4..72a974f5b4 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsalloc.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsalloc.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __NSALLOC_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -88,7 +85,7 @@ AcpiNsCreateNode (
 
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
         Temp = AcpiGbl_NsNodeList->TotalAllocated -
-                AcpiGbl_NsNodeList->TotalFreed;
+            AcpiGbl_NsNodeList->TotalFreed;
         if (Temp > AcpiGbl_NsNodeList->MaxOccupied)
         {
             AcpiGbl_NsNodeList->MaxOccupied = Temp;
@@ -121,6 +118,7 @@ AcpiNsDeleteNode (
     ACPI_NAMESPACE_NODE     *Node)
 {
     ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_OPERAND_OBJECT     *NextDesc;
 
 
     ACPI_FUNCTION_NAME (NsDeleteNode);
@@ -131,12 +129,13 @@ AcpiNsDeleteNode (
     AcpiNsDetachObject (Node);
 
     /*
-     * Delete an attached data object if present (an object that was created
-     * and attached via AcpiAttachData). Note: After any normal object is
-     * detached above, the only possible remaining object is a data object.
+     * Delete an attached data object list if present (objects that were
+     * attached via AcpiAttachData). Note: After any normal object is
+     * detached above, the only possible remaining object(s) are data
+     * objects, in a linked list.
      */
     ObjDesc = Node->Object;
-    if (ObjDesc &&
+    while (ObjDesc &&
         (ObjDesc->Common.Type == ACPI_TYPE_LOCAL_DATA))
     {
         /* Invoke the attached data deletion handler if present */
@@ -146,7 +145,16 @@ AcpiNsDeleteNode (
             ObjDesc->Data.Handler (Node, ObjDesc->Data.Pointer);
         }
 
+        NextDesc = ObjDesc->Common.NextObject;
         AcpiUtRemoveReference (ObjDesc);
+        ObjDesc = NextDesc;
+    }
+
+    /* Special case for the statically allocated root node */
+
+    if (Node == AcpiGbl_RootNode)
+    {
+        return;
     }
 
     /* Now we can delete the node */
@@ -269,7 +277,8 @@ AcpiNsInstallNode (
              * modified the namespace. This is used for cleanup when the
              * method exits.
              */
-            WalkState->MethodDesc->Method.InfoFlags |= ACPI_METHOD_MODIFIED_NAMESPACE;
+            WalkState->MethodDesc->Method.InfoFlags |=
+                ACPI_METHOD_MODIFIED_NAMESPACE;
         }
     }
 
@@ -376,7 +385,7 @@ AcpiNsDeleteChildren (
  *
  * RETURN:      None.
  *
- * DESCRIPTION: Delete a subtree of the namespace.  This includes all objects
+ * DESCRIPTION: Delete a subtree of the namespace. This includes all objects
  *              stored within the subtree.
  *
  ******************************************************************************/
@@ -472,7 +481,7 @@ AcpiNsDeleteNamespaceSubtree (
  * RETURN:      Status
  *
  * DESCRIPTION: Delete entries within the namespace that are owned by a
- *              specific ID.  Used to delete entire ACPI tables.  All
+ *              specific ID. Used to delete entire ACPI tables. All
  *              reference counts are updated.
  *
  * MUTEX:       Locks namespace during deletion walk.
@@ -584,5 +593,3 @@ AcpiNsDeleteNamespaceByOwner (
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
     return_VOID;
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsarguments.c b/usr/src/uts/intel/io/acpica/namespace/nsarguments.c
new file mode 100644
index 0000000000..1483e8121b
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/namespace/nsarguments.c
@@ -0,0 +1,305 @@
+/******************************************************************************
+ *
+ * Module Name: nsarguments - Validation of args for ACPI predefined methods
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acpredef.h"
+
+
+#define _COMPONENT          ACPI_NAMESPACE
+        ACPI_MODULE_NAME    ("nsarguments")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsCheckArgumentTypes
+ *
+ * PARAMETERS:  Info            - Method execution information block
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check the incoming argument count and all argument types
+ *              against the argument type list for a predefined name.
+ *
+ ******************************************************************************/
+
+void
+AcpiNsCheckArgumentTypes (
+    ACPI_EVALUATE_INFO          *Info)
+{
+    UINT16                      ArgTypeList;
+    UINT8                       ArgCount;
+    UINT8                       ArgType;
+    UINT8                       UserArgType;
+    UINT32                      i;
+
+
+    /* If not a predefined name, cannot typecheck args */
+
+    if (!Info->Predefined)
+    {
+        return;
+    }
+
+    ArgTypeList = Info->Predefined->Info.ArgumentList;
+    ArgCount = METHOD_GET_ARG_COUNT (ArgTypeList);
+
+    /* Typecheck all arguments */
+
+    for (i = 0; ((i < ArgCount) && (i < Info->ParamCount)); i++)
+    {
+        ArgType = METHOD_GET_NEXT_TYPE (ArgTypeList);
+        UserArgType = Info->Parameters[i]->Common.Type;
+
+        if (UserArgType != ArgType)
+        {
+            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,
+                "Argument #%u type mismatch - "
+                "Found [%s], ACPI requires [%s]", (i + 1),
+                AcpiUtGetTypeName (UserArgType),
+                AcpiUtGetTypeName (ArgType)));
+        }
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsCheckAcpiCompliance
+ *
+ * PARAMETERS:  Pathname        - Full pathname to the node (for error msgs)
+ *              Node            - Namespace node for the method/object
+ *              Predefined      - Pointer to entry in predefined name table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check that the declared parameter count (in ASL/AML) for a
+ *              predefined name is what is expected (matches what is defined in
+ *              the ACPI specification for this predefined name.)
+ *
+ ******************************************************************************/
+
+void
+AcpiNsCheckAcpiCompliance (
+    char                        *Pathname,
+    ACPI_NAMESPACE_NODE         *Node,
+    const ACPI_PREDEFINED_INFO  *Predefined)
+{
+    UINT32                      AmlParamCount;
+    UINT32                      RequiredParamCount;
+
+
+    if (!Predefined)
+    {
+        return;
+    }
+
+    /* Get the ACPI-required arg count from the predefined info table */
+
+    RequiredParamCount =
+        METHOD_GET_ARG_COUNT (Predefined->Info.ArgumentList);
+
+    /*
+     * If this object is not a control method, we can check if the ACPI
+     * spec requires that it be a method.
+     */
+    if (Node->Type != ACPI_TYPE_METHOD)
+    {
+        if (RequiredParamCount > 0)
+        {
+            /* Object requires args, must be implemented as a method */
+
+            ACPI_BIOS_ERROR_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+                "Object (%s) must be a control method with %u arguments",
+                AcpiUtGetTypeName (Node->Type), RequiredParamCount));
+        }
+        else if (!RequiredParamCount && !Predefined->Info.ExpectedBtypes)
+        {
+            /* Object requires no args and no return value, must be a method */
+
+            ACPI_BIOS_ERROR_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+                "Object (%s) must be a control method "
+                "with no arguments and no return value",
+                AcpiUtGetTypeName (Node->Type)));
+        }
+
+        return;
+    }
+
+    /*
+     * This is a control method.
+     * Check that the ASL/AML-defined parameter count for this method
+     * matches the ACPI-required parameter count
+     *
+     * Some methods are allowed to have a "minimum" number of args (_SCP)
+     * because their definition in ACPI has changed over time.
+     *
+     * Note: These are BIOS errors in the declaration of the object
+     */
+    AmlParamCount = Node->Object->Method.ParamCount;
+
+    if (AmlParamCount < RequiredParamCount)
+    {
+        ACPI_BIOS_ERROR_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+            "Insufficient arguments - "
+            "ASL declared %u, ACPI requires %u",
+            AmlParamCount, RequiredParamCount));
+    }
+    else if ((AmlParamCount > RequiredParamCount) &&
+        !(Predefined->Info.ArgumentList & ARG_COUNT_IS_MINIMUM))
+    {
+        ACPI_BIOS_ERROR_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+            "Excess arguments - "
+            "ASL declared %u, ACPI requires %u",
+            AmlParamCount, RequiredParamCount));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsCheckArgumentCount
+ *
+ * PARAMETERS:  Pathname        - Full pathname to the node (for error msgs)
+ *              Node            - Namespace node for the method/object
+ *              UserParamCount  - Number of args passed in by the caller
+ *              Predefined      - Pointer to entry in predefined name table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Check that incoming argument count matches the declared
+ *              parameter count (in the ASL/AML) for an object.
+ *
+ ******************************************************************************/
+
+void
+AcpiNsCheckArgumentCount (
+    char                        *Pathname,
+    ACPI_NAMESPACE_NODE         *Node,
+    UINT32                      UserParamCount,
+    const ACPI_PREDEFINED_INFO  *Predefined)
+{
+    UINT32                      AmlParamCount;
+    UINT32                      RequiredParamCount;
+
+
+    if (!Predefined)
+    {
+        /*
+         * Not a predefined name. Check the incoming user argument count
+         * against the count that is specified in the method/object.
+         */
+        if (Node->Type != ACPI_TYPE_METHOD)
+        {
+            if (UserParamCount)
+            {
+                ACPI_INFO_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+                    "%u arguments were passed to a non-method ACPI object (%s)",
+                    UserParamCount, AcpiUtGetTypeName (Node->Type)));
+            }
+
+            return;
+        }
+
+        /*
+         * This is a control method. Check the parameter count.
+         * We can only check the incoming argument count against the
+         * argument count declared for the method in the ASL/AML.
+         *
+         * Emit a message if too few or too many arguments have been passed
+         * by the caller.
+         *
+         * Note: Too many arguments will not cause the method to
+         * fail. However, the method will fail if there are too few
+         * arguments and the method attempts to use one of the missing ones.
+         */
+        AmlParamCount = Node->Object->Method.ParamCount;
+
+        if (UserParamCount < AmlParamCount)
+        {
+            ACPI_WARN_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+                "Insufficient arguments - "
+                "Caller passed %u, method requires %u",
+                UserParamCount, AmlParamCount));
+        }
+        else if (UserParamCount > AmlParamCount)
+        {
+            ACPI_INFO_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+                "Excess arguments - "
+                "Caller passed %u, method requires %u",
+                UserParamCount, AmlParamCount));
+        }
+
+        return;
+    }
+
+    /*
+     * This is a predefined name. Validate the user-supplied parameter
+     * count against the ACPI specification. We don't validate against
+     * the method itself because what is important here is that the
+     * caller is in conformance with the spec. (The arg count for the
+     * method was checked against the ACPI spec earlier.)
+     *
+     * Some methods are allowed to have a "minimum" number of args (_SCP)
+     * because their definition in ACPI has changed over time.
+     */
+    RequiredParamCount =
+        METHOD_GET_ARG_COUNT (Predefined->Info.ArgumentList);
+
+    if (UserParamCount < RequiredParamCount)
+    {
+        ACPI_WARN_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+            "Insufficient arguments - "
+            "Caller passed %u, ACPI requires %u",
+            UserParamCount, RequiredParamCount));
+    }
+    else if ((UserParamCount > RequiredParamCount) &&
+        !(Predefined->Info.ArgumentList & ARG_COUNT_IS_MINIMUM))
+    {
+        ACPI_INFO_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+            "Excess arguments - "
+            "Caller passed %u, ACPI requires %u",
+            UserParamCount, RequiredParamCount));
+    }
+}
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsconvert.c b/usr/src/uts/intel/io/acpica/namespace/nsconvert.c
new file mode 100644
index 0000000000..2fa182eddc
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/namespace/nsconvert.c
@@ -0,0 +1,566 @@
+/******************************************************************************
+ *
+ * Module Name: nsconvert - Object conversions for objects returned by
+ *                          predefined methods
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acinterp.h"
+#include "acpredef.h"
+#include "amlresrc.h"
+
+#define _COMPONENT          ACPI_NAMESPACE
+        ACPI_MODULE_NAME    ("nsconvert")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsConvertToInteger
+ *
+ * PARAMETERS:  OriginalObject      - Object to be converted
+ *              ReturnObject        - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful.
+ *
+ * DESCRIPTION: Attempt to convert a String/Buffer object to an Integer.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiNsConvertToInteger (
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject)
+{
+    ACPI_OPERAND_OBJECT     *NewObject;
+    ACPI_STATUS             Status;
+    UINT64                  Value = 0;
+    UINT32                  i;
+
+
+    switch (OriginalObject->Common.Type)
+    {
+    case ACPI_TYPE_STRING:
+
+        /* String-to-Integer conversion */
+
+        Status = AcpiUtStrtoul64 (OriginalObject->String.Pointer,
+            ACPI_ANY_BASE, AcpiGbl_IntegerByteWidth, &Value);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+        break;
+
+    case ACPI_TYPE_BUFFER:
+
+        /* Buffer-to-Integer conversion. Max buffer size is 64 bits. */
+
+        if (OriginalObject->Buffer.Length > 8)
+        {
+            return (AE_AML_OPERAND_TYPE);
+        }
+
+        /* Extract each buffer byte to create the integer */
+
+        for (i = 0; i < OriginalObject->Buffer.Length; i++)
+        {
+            Value |= ((UINT64)
+                OriginalObject->Buffer.Pointer[i] << (i * 8));
+        }
+        break;
+
+    default:
+
+        return (AE_AML_OPERAND_TYPE);
+    }
+
+    NewObject = AcpiUtCreateIntegerObject (Value);
+    if (!NewObject)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    *ReturnObject = NewObject;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsConvertToString
+ *
+ * PARAMETERS:  OriginalObject      - Object to be converted
+ *              ReturnObject        - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful.
+ *
+ * DESCRIPTION: Attempt to convert a Integer/Buffer object to a String.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiNsConvertToString (
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject)
+{
+    ACPI_OPERAND_OBJECT     *NewObject;
+    ACPI_SIZE               Length;
+    ACPI_STATUS             Status;
+
+
+    switch (OriginalObject->Common.Type)
+    {
+    case ACPI_TYPE_INTEGER:
+        /*
+         * Integer-to-String conversion. Commonly, convert
+         * an integer of value 0 to a NULL string. The last element of
+         * _BIF and _BIX packages occasionally need this fix.
+         */
+        if (OriginalObject->Integer.Value == 0)
+        {
+            /* Allocate a new NULL string object */
+
+            NewObject = AcpiUtCreateStringObject (0);
+            if (!NewObject)
+            {
+                return (AE_NO_MEMORY);
+            }
+        }
+        else
+        {
+            Status = AcpiExConvertToString (OriginalObject,
+                &NewObject, ACPI_IMPLICIT_CONVERT_HEX);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+        }
+        break;
+
+    case ACPI_TYPE_BUFFER:
+        /*
+         * Buffer-to-String conversion. Use a ToString
+         * conversion, no transform performed on the buffer data. The best
+         * example of this is the _BIF method, where the string data from
+         * the battery is often (incorrectly) returned as buffer object(s).
+         */
+        Length = 0;
+        while ((Length < OriginalObject->Buffer.Length) &&
+                (OriginalObject->Buffer.Pointer[Length]))
+        {
+            Length++;
+        }
+
+        /* Allocate a new string object */
+
+        NewObject = AcpiUtCreateStringObject (Length);
+        if (!NewObject)
+        {
+            return (AE_NO_MEMORY);
+        }
+
+        /*
+         * Copy the raw buffer data with no transform. String is already NULL
+         * terminated at Length+1.
+         */
+        memcpy (NewObject->String.Pointer,
+            OriginalObject->Buffer.Pointer, Length);
+        break;
+
+    default:
+
+        return (AE_AML_OPERAND_TYPE);
+    }
+
+    *ReturnObject = NewObject;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsConvertToBuffer
+ *
+ * PARAMETERS:  OriginalObject      - Object to be converted
+ *              ReturnObject        - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful.
+ *
+ * DESCRIPTION: Attempt to convert a Integer/String/Package object to a Buffer.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiNsConvertToBuffer (
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject)
+{
+    ACPI_OPERAND_OBJECT     *NewObject;
+    ACPI_STATUS             Status;
+    ACPI_OPERAND_OBJECT     **Elements;
+    UINT32                  *DwordBuffer;
+    UINT32                  Count;
+    UINT32                  i;
+
+
+    switch (OriginalObject->Common.Type)
+    {
+    case ACPI_TYPE_INTEGER:
+        /*
+         * Integer-to-Buffer conversion.
+         * Convert the Integer to a packed-byte buffer. _MAT and other
+         * objects need this sometimes, if a read has been performed on a
+         * Field object that is less than or equal to the global integer
+         * size (32 or 64 bits).
+         */
+        Status = AcpiExConvertToBuffer (OriginalObject, &NewObject);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+        break;
+
+    case ACPI_TYPE_STRING:
+
+        /* String-to-Buffer conversion. Simple data copy */
+
+        NewObject = AcpiUtCreateBufferObject
+            (OriginalObject->String.Length);
+        if (!NewObject)
+        {
+            return (AE_NO_MEMORY);
+        }
+
+        memcpy (NewObject->Buffer.Pointer,
+            OriginalObject->String.Pointer, OriginalObject->String.Length);
+        break;
+
+    case ACPI_TYPE_PACKAGE:
+        /*
+         * This case is often seen for predefined names that must return a
+         * Buffer object with multiple DWORD integers within. For example,
+         * _FDE and _GTM. The Package can be converted to a Buffer.
+         */
+
+        /* All elements of the Package must be integers */
+
+        Elements = OriginalObject->Package.Elements;
+        Count = OriginalObject->Package.Count;
+
+        for (i = 0; i < Count; i++)
+        {
+            if ((!*Elements) ||
+                ((*Elements)->Common.Type != ACPI_TYPE_INTEGER))
+            {
+                return (AE_AML_OPERAND_TYPE);
+            }
+            Elements++;
+        }
+
+        /* Create the new buffer object to replace the Package */
+
+        NewObject = AcpiUtCreateBufferObject (ACPI_MUL_4 (Count));
+        if (!NewObject)
+        {
+            return (AE_NO_MEMORY);
+        }
+
+        /* Copy the package elements (integers) to the buffer as DWORDs */
+
+        Elements = OriginalObject->Package.Elements;
+        DwordBuffer = ACPI_CAST_PTR (UINT32, NewObject->Buffer.Pointer);
+
+        for (i = 0; i < Count; i++)
+        {
+            *DwordBuffer = (UINT32) (*Elements)->Integer.Value;
+            DwordBuffer++;
+            Elements++;
+        }
+        break;
+
+    default:
+
+        return (AE_AML_OPERAND_TYPE);
+    }
+
+    *ReturnObject = NewObject;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsConvertToUnicode
+ *
+ * PARAMETERS:  Scope               - Namespace node for the method/object
+ *              OriginalObject      - ASCII String Object to be converted
+ *              ReturnObject        - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful.
+ *
+ * DESCRIPTION: Attempt to convert a String object to a Unicode string Buffer.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiNsConvertToUnicode (
+    ACPI_NAMESPACE_NODE     *Scope,
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject)
+{
+    ACPI_OPERAND_OBJECT     *NewObject;
+    char                    *AsciiString;
+    UINT16                  *UnicodeBuffer;
+    UINT32                  UnicodeLength;
+    UINT32                  i;
+
+
+    if (!OriginalObject)
+    {
+        return (AE_OK);
+    }
+
+    /* If a Buffer was returned, it must be at least two bytes long */
+
+    if (OriginalObject->Common.Type == ACPI_TYPE_BUFFER)
+    {
+        if (OriginalObject->Buffer.Length < 2)
+        {
+            return (AE_AML_OPERAND_VALUE);
+        }
+
+        *ReturnObject = NULL;
+        return (AE_OK);
+    }
+
+    /*
+     * The original object is an ASCII string. Convert this string to
+     * a unicode buffer.
+     */
+    AsciiString = OriginalObject->String.Pointer;
+    UnicodeLength = (OriginalObject->String.Length * 2) + 2;
+
+    /* Create a new buffer object for the Unicode data */
+
+    NewObject = AcpiUtCreateBufferObject (UnicodeLength);
+    if (!NewObject)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    UnicodeBuffer = ACPI_CAST_PTR (UINT16, NewObject->Buffer.Pointer);
+
+    /* Convert ASCII to Unicode */
+
+    for (i = 0; i < OriginalObject->String.Length; i++)
+    {
+        UnicodeBuffer[i] = (UINT16) AsciiString[i];
+    }
+
+    *ReturnObject = NewObject;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsConvertToResource
+ *
+ * PARAMETERS:  Scope               - Namespace node for the method/object
+ *              OriginalObject      - Object to be converted
+ *              ReturnObject        - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful
+ *
+ * DESCRIPTION: Attempt to convert a Integer object to a ResourceTemplate
+ *              Buffer.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiNsConvertToResource (
+    ACPI_NAMESPACE_NODE     *Scope,
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject)
+{
+    ACPI_OPERAND_OBJECT     *NewObject;
+    UINT8                   *Buffer;
+
+
+    /*
+     * We can fix the following cases for an expected resource template:
+     * 1. No return value (interpreter slack mode is disabled)
+     * 2. A "Return (Zero)" statement
+     * 3. A "Return empty buffer" statement
+     *
+     * We will return a buffer containing a single EndTag
+     * resource descriptor.
+     */
+    if (OriginalObject)
+    {
+        switch (OriginalObject->Common.Type)
+        {
+        case ACPI_TYPE_INTEGER:
+
+            /* We can only repair an Integer==0 */
+
+            if (OriginalObject->Integer.Value)
+            {
+                return (AE_AML_OPERAND_TYPE);
+            }
+            break;
+
+        case ACPI_TYPE_BUFFER:
+
+            if (OriginalObject->Buffer.Length)
+            {
+                /* Additional checks can be added in the future */
+
+                *ReturnObject = NULL;
+                return (AE_OK);
+            }
+            break;
+
+        case ACPI_TYPE_STRING:
+        default:
+
+            return (AE_AML_OPERAND_TYPE);
+        }
+    }
+
+    /* Create the new buffer object for the resource descriptor */
+
+    NewObject = AcpiUtCreateBufferObject (2);
+    if (!NewObject)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    Buffer = ACPI_CAST_PTR (UINT8, NewObject->Buffer.Pointer);
+
+    /* Initialize the Buffer with a single EndTag descriptor */
+
+    Buffer[0] = (ACPI_RESOURCE_NAME_END_TAG | ASL_RDESC_END_TAG_SIZE);
+    Buffer[1] = 0x00;
+
+    *ReturnObject = NewObject;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsConvertToReference
+ *
+ * PARAMETERS:  Scope               - Namespace node for the method/object
+ *              OriginalObject      - Object to be converted
+ *              ReturnObject        - Where the new converted object is returned
+ *
+ * RETURN:      Status. AE_OK if conversion was successful
+ *
+ * DESCRIPTION: Attempt to convert a Integer object to a ObjectReference.
+ *              Buffer.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiNsConvertToReference (
+    ACPI_NAMESPACE_NODE     *Scope,
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject)
+{
+    ACPI_OPERAND_OBJECT     *NewObject = NULL;
+    ACPI_STATUS             Status;
+    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_GENERIC_STATE      ScopeInfo;
+    char                    *Name;
+
+
+    ACPI_FUNCTION_NAME (NsConvertToReference);
+
+
+    /* Convert path into internal presentation */
+
+    Status = AcpiNsInternalizeName (OriginalObject->String.Pointer, &Name);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Find the namespace node */
+
+    ScopeInfo.Scope.Node = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Scope);
+    Status = AcpiNsLookup (&ScopeInfo, Name,
+        ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+        ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL, &Node);
+    if (ACPI_FAILURE (Status))
+    {
+        /* Check if we are resolving a named reference within a package */
+
+        ACPI_ERROR_NAMESPACE (OriginalObject->String.Pointer, Status);
+        goto ErrorExit;
+    }
+
+    /* Create and init a new internal ACPI object */
+
+    NewObject = AcpiUtCreateInternalObject (ACPI_TYPE_LOCAL_REFERENCE);
+    if (!NewObject)
+    {
+        Status = AE_NO_MEMORY;
+        goto ErrorExit;
+    }
+    NewObject->Reference.Node = Node;
+    NewObject->Reference.Object = Node->Object;
+    NewObject->Reference.Class = ACPI_REFCLASS_NAME;
+
+    /*
+     * Increase reference of the object if needed (the object is likely a
+     * null for device nodes).
+     */
+    AcpiUtAddReference (Node->Object);
+
+ErrorExit:
+    ACPI_FREE (Name);
+    *ReturnObject = NewObject;
+    return (AE_OK);
+}
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsdump.c b/usr/src/uts/intel/io/acpica/namespace/nsdump.c
index 6b7c505779..32ada86001 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsdump.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsdump.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,11 +41,10 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSDUMP_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
+#include "acoutput.h"
 
 
 #define _COMPONENT          ACPI_NAMESPACE
@@ -68,6 +67,22 @@ AcpiNsDumpOneDevice (
 
 
 #if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+
+static ACPI_STATUS
+AcpiNsDumpOneObjectPath (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue);
+
+static ACPI_STATUS
+AcpiNsGetMaxDepth (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue);
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiNsPrintPathname
@@ -84,7 +99,7 @@ AcpiNsDumpOneDevice (
 void
 AcpiNsPrintPathname (
     UINT32                  NumSegments,
-    char                    *Pathname)
+    const char              *Pathname)
 {
     UINT32                  i;
 
@@ -92,7 +107,9 @@ AcpiNsPrintPathname (
     ACPI_FUNCTION_NAME (NsPrintPathname);
 
 
-    if (!(AcpiDbgLevel & ACPI_LV_NAMES) || !(AcpiDbgLayer & ACPI_NAMESPACE))
+    /* Check if debug output enabled */
+
+    if (!ACPI_IS_DEBUG_ENABLED (ACPI_LV_NAMES, ACPI_NAMESPACE))
     {
         return;
     }
@@ -105,7 +122,7 @@ AcpiNsPrintPathname (
     {
         for (i = 0; i < 4; i++)
         {
-            ACPI_IS_PRINT (Pathname[i]) ?
+            isprint ((int) Pathname[i]) ?
                 AcpiOsPrintf ("%c", Pathname[i]) :
                 AcpiOsPrintf ("?");
         }
@@ -122,6 +139,9 @@ AcpiNsPrintPathname (
 }
 
 
+#ifdef ACPI_OBSOLETE_FUNCTIONS
+/* Not used at this time, perhaps later */
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiNsDumpPathname
@@ -141,7 +161,7 @@ AcpiNsPrintPathname (
 void
 AcpiNsDumpPathname (
     ACPI_HANDLE             Handle,
-    char                    *Msg,
+    const char              *Msg,
     UINT32                  Level,
     UINT32                  Component)
 {
@@ -151,7 +171,7 @@ AcpiNsDumpPathname (
 
     /* Do this only if the requested debug level and component are enabled */
 
-    if (!(AcpiDbgLevel & Level) || !(AcpiDbgLayer & Component))
+    if (!ACPI_IS_DEBUG_ENABLED (Level, Component))
     {
         return_VOID;
     }
@@ -162,7 +182,7 @@ AcpiNsDumpPathname (
     AcpiOsPrintf ("\n");
     return_VOID;
 }
-
+#endif
 
 /*******************************************************************************
  *
@@ -241,7 +261,8 @@ AcpiNsDumpOneObject (
 
         if (Type > ACPI_TYPE_LOCAL_MAX)
         {
-            ACPI_WARNING ((AE_INFO, "Invalid ACPI Object Type 0x%08X", Type));
+            ACPI_WARNING ((AE_INFO,
+                "Invalid ACPI Object Type 0x%08X", Type));
         }
 
         AcpiOsPrintf ("%4.4s", AcpiUtGetNodeName (ThisNode));
@@ -250,7 +271,7 @@ AcpiNsDumpOneObject (
     /* Now we can print out the pertinent information */
 
     AcpiOsPrintf (" %-12s %p %2.2X ",
-            AcpiUtGetTypeName (Type), ThisNode, ThisNode->OwnerId);
+        AcpiUtGetTypeName (Type), ThisNode, ThisNode->OwnerId);
 
     DbgLevel = AcpiDbgLevel;
     AcpiDbgLevel = 0;
@@ -279,10 +300,12 @@ AcpiNsDumpOneObject (
             case ACPI_TYPE_BUFFER:
             case ACPI_TYPE_STRING:
             case ACPI_TYPE_METHOD:
+
                 AcpiOsPrintf ("<No attached object>");
                 break;
 
             default:
+
                 break;
             }
 
@@ -294,18 +317,16 @@ AcpiNsDumpOneObject (
         {
         case ACPI_TYPE_PROCESSOR:
 
-            AcpiOsPrintf ("ID %X Len %.4X Addr %p\n",
+            AcpiOsPrintf ("ID %02X Len %02X Addr %8.8X%8.8X\n",
                 ObjDesc->Processor.ProcId, ObjDesc->Processor.Length,
-                ACPI_CAST_PTR (void, ObjDesc->Processor.Address));
+                ACPI_FORMAT_UINT64 (ObjDesc->Processor.Address));
             break;
 
-
         case ACPI_TYPE_DEVICE:
 
             AcpiOsPrintf ("Notify Object: %p\n", ObjDesc);
             break;
 
-
         case ACPI_TYPE_METHOD:
 
             AcpiOsPrintf ("Args %X Len %.4X Aml %p\n",
@@ -313,14 +334,12 @@ AcpiNsDumpOneObject (
                 ObjDesc->Method.AmlLength, ObjDesc->Method.AmlStart);
             break;
 
-
         case ACPI_TYPE_INTEGER:
 
             AcpiOsPrintf ("= %8.8X%8.8X\n",
                 ACPI_FORMAT_UINT64 (ObjDesc->Integer.Value));
             break;
 
-
         case ACPI_TYPE_PACKAGE:
 
             if (ObjDesc->Common.Flags & AOPOBJ_DATA_VALID)
@@ -334,13 +353,12 @@ AcpiNsDumpOneObject (
             }
             break;
 
-
         case ACPI_TYPE_BUFFER:
 
             if (ObjDesc->Common.Flags & AOPOBJ_DATA_VALID)
             {
                 AcpiOsPrintf ("Len %.2X",
-                            ObjDesc->Buffer.Length);
+                    ObjDesc->Buffer.Length);
 
                 /* Dump some of the buffer */
 
@@ -360,15 +378,13 @@ AcpiNsDumpOneObject (
             }
             break;
 
-
         case ACPI_TYPE_STRING:
 
             AcpiOsPrintf ("Len %.2X ", ObjDesc->String.Length);
-            AcpiUtPrintString (ObjDesc->String.Pointer, 32);
+            AcpiUtPrintString (ObjDesc->String.Pointer, 80);
             AcpiOsPrintf ("\n");
             break;
 
-
         case ACPI_TYPE_REGION:
 
             AcpiOsPrintf ("[%s]",
@@ -376,7 +392,7 @@ AcpiNsDumpOneObject (
             if (ObjDesc->Region.Flags & AOPOBJ_DATA_VALID)
             {
                 AcpiOsPrintf (" Addr %8.8X%8.8X Len %.4X\n",
-                    ACPI_FORMAT_NATIVE_UINT (ObjDesc->Region.Address),
+                    ACPI_FORMAT_UINT64 (ObjDesc->Region.Address),
                     ObjDesc->Region.Length);
             }
             else
@@ -385,13 +401,11 @@ AcpiNsDumpOneObject (
             }
             break;
 
-
         case ACPI_TYPE_LOCAL_REFERENCE:
 
             AcpiOsPrintf ("[%s]\n", AcpiUtGetReferenceName (ObjDesc));
             break;
 
-
         case ACPI_TYPE_BUFFER_FIELD:
 
             if (ObjDesc->BufferField.BufferObj &&
@@ -403,7 +417,6 @@ AcpiNsDumpOneObject (
             }
             break;
 
-
         case ACPI_TYPE_LOCAL_REGION_FIELD:
 
             AcpiOsPrintf ("Rgn [%4.4s]",
@@ -411,7 +424,6 @@ AcpiNsDumpOneObject (
                     ObjDesc->CommonField.RegionObj->Region.Node));
             break;
 
-
         case ACPI_TYPE_LOCAL_BANK_FIELD:
 
             AcpiOsPrintf ("Rgn [%4.4s] Bnk [%4.4s]",
@@ -421,7 +433,6 @@ AcpiNsDumpOneObject (
                     ObjDesc->BankField.BankObj->CommonField.Node));
             break;
 
-
         case ACPI_TYPE_LOCAL_INDEX_FIELD:
 
             AcpiOsPrintf ("Idx [%4.4s] Dat [%4.4s]",
@@ -431,7 +442,6 @@ AcpiNsDumpOneObject (
                     ObjDesc->IndexField.DataObj->CommonField.Node));
             break;
 
-
         case ACPI_TYPE_LOCAL_ALIAS:
         case ACPI_TYPE_LOCAL_METHOD_ALIAS:
 
@@ -462,11 +472,11 @@ AcpiNsDumpOneObject (
             break;
 
         default:
+
             break;
         }
         break;
 
-
     case ACPI_DISPLAY_OBJECTS:
 
         AcpiOsPrintf ("O:%p", ObjDesc);
@@ -515,7 +525,6 @@ AcpiNsDumpOneObject (
         }
         break;
 
-
     default:
         AcpiOsPrintf ("\n");
         break;
@@ -530,9 +539,9 @@ AcpiNsDumpOneObject (
 
     /* If there is an attached object, display it */
 
-    DbgLevel     = AcpiDbgLevel;
+    DbgLevel = AcpiDbgLevel;
     AcpiDbgLevel = 0;
-    ObjDesc      = AcpiNsGetAttachedObject (ThisNode);
+    ObjDesc = AcpiNsGetAttachedObject (ThisNode);
     AcpiDbgLevel = DbgLevel;
 
     /* Dump attached objects */
@@ -559,14 +568,18 @@ AcpiNsDumpOneObject (
 
             if (ObjType > ACPI_TYPE_LOCAL_MAX)
             {
-                AcpiOsPrintf ("(Pointer to ACPI Object type %.2X [UNKNOWN])\n",
+                AcpiOsPrintf (
+                    "(Pointer to ACPI Object type %.2X [UNKNOWN])\n",
                     ObjType);
+
                 BytesToDump = 32;
             }
             else
             {
-                AcpiOsPrintf ("(Pointer to ACPI Object type %.2X [%s])\n",
+                AcpiOsPrintf (
+                    "(Pointer to ACPI Object type %.2X [%s])\n",
                     ObjType, AcpiUtGetTypeName (ObjType));
+
                 BytesToDump = sizeof (ACPI_OPERAND_OBJECT);
             }
 
@@ -596,36 +609,44 @@ AcpiNsDumpOneObject (
              */
             BytesToDump = ObjDesc->String.Length;
             ObjDesc = (void *) ObjDesc->String.Pointer;
-            AcpiOsPrintf ( "(Buffer/String pointer %p length %X)\n",
+
+            AcpiOsPrintf ("(Buffer/String pointer %p length %X)\n",
                 ObjDesc, BytesToDump);
             ACPI_DUMP_BUFFER (ObjDesc, BytesToDump);
             goto Cleanup;
 
         case ACPI_TYPE_BUFFER_FIELD:
+
             ObjDesc = (ACPI_OPERAND_OBJECT *) ObjDesc->BufferField.BufferObj;
             break;
 
         case ACPI_TYPE_PACKAGE:
+
             ObjDesc = (void *) ObjDesc->Package.Elements;
             break;
 
         case ACPI_TYPE_METHOD:
+
             ObjDesc = (void *) ObjDesc->Method.AmlStart;
             break;
 
         case ACPI_TYPE_LOCAL_REGION_FIELD:
+
             ObjDesc = (void *) ObjDesc->Field.RegionObj;
             break;
 
         case ACPI_TYPE_LOCAL_BANK_FIELD:
+
             ObjDesc = (void *) ObjDesc->BankField.RegionObj;
             break;
 
         case ACPI_TYPE_LOCAL_INDEX_FIELD:
+
             ObjDesc = (void *) ObjDesc->IndexField.IndexObj;
             break;
 
         default:
+
             goto Cleanup;
         }
 
@@ -690,8 +711,151 @@ AcpiNsDumpObjects (
     Info.DisplayType = DisplayType;
 
     (void) AcpiNsWalkNamespace (Type, StartHandle, MaxDepth,
-                ACPI_NS_WALK_NO_UNLOCK | ACPI_NS_WALK_TEMP_NODES,
-                AcpiNsDumpOneObject, NULL, (void *) &Info, NULL);
+        ACPI_NS_WALK_NO_UNLOCK | ACPI_NS_WALK_TEMP_NODES,
+        AcpiNsDumpOneObject, NULL, (void *) &Info, NULL);
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsDumpOneObjectPath, AcpiNsGetMaxDepth
+ *
+ * PARAMETERS:  ObjHandle           - Node to be dumped
+ *              Level               - Nesting level of the handle
+ *              Context             - Passed into WalkNamespace
+ *              ReturnValue         - Not used
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Dump the full pathname to a namespace object. AcpNsGetMaxDepth
+ *              computes the maximum nesting depth in the namespace tree, in
+ *              order to simplify formatting in AcpiNsDumpOneObjectPath.
+ *              These procedures are UserFunctions called by AcpiNsWalkNamespace.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiNsDumpOneObjectPath (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue)
+{
+    UINT32                  MaxLevel = *((UINT32 *) Context);
+    char                    *Pathname;
+    ACPI_NAMESPACE_NODE     *Node;
+    int                     PathIndent;
+
+
+    if (!ObjHandle)
+    {
+        return (AE_OK);
+    }
+
+    Node = AcpiNsValidateHandle (ObjHandle);
+    if (!Node)
+    {
+        /* Ignore bad node during namespace walk */
+
+        return (AE_OK);
+    }
+
+    Pathname = AcpiNsGetNormalizedPathname (Node, TRUE);
+
+    PathIndent = 1;
+    if (Level <= MaxLevel)
+    {
+        PathIndent = MaxLevel - Level + 1;
+    }
+
+    AcpiOsPrintf ("%2d%*s%-12s%*s",
+        Level, Level, " ", AcpiUtGetTypeName (Node->Type),
+        PathIndent, " ");
+
+    AcpiOsPrintf ("%s\n", &Pathname[1]);
+    ACPI_FREE (Pathname);
+    return (AE_OK);
+}
+
+
+static ACPI_STATUS
+AcpiNsGetMaxDepth (
+    ACPI_HANDLE             ObjHandle,
+    UINT32                  Level,
+    void                    *Context,
+    void                    **ReturnValue)
+{
+    UINT32                  *MaxLevel = (UINT32 *) Context;
+
+
+    if (Level > *MaxLevel)
+    {
+        *MaxLevel = Level;
+    }
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsDumpObjectPaths
+ *
+ * PARAMETERS:  Type                - Object type to be dumped
+ *              DisplayType         - 0 or ACPI_DISPLAY_SUMMARY
+ *              MaxDepth            - Maximum depth of dump. Use ACPI_UINT32_MAX
+ *                                    for an effectively unlimited depth.
+ *              OwnerId             - Dump only objects owned by this ID. Use
+ *                                    ACPI_UINT32_MAX to match all owners.
+ *              StartHandle         - Where in namespace to start/end search
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump full object pathnames within the loaded namespace. Uses
+ *              AcpiNsWalkNamespace in conjunction with AcpiNsDumpOneObjectPath.
+ *
+ ******************************************************************************/
+
+void
+AcpiNsDumpObjectPaths (
+    ACPI_OBJECT_TYPE        Type,
+    UINT8                   DisplayType,
+    UINT32                  MaxDepth,
+    ACPI_OWNER_ID           OwnerId,
+    ACPI_HANDLE             StartHandle)
+{
+    ACPI_STATUS             Status;
+    UINT32                  MaxLevel = 0;
+
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    /*
+     * Just lock the entire namespace for the duration of the dump.
+     * We don't want any changes to the namespace during this time,
+     * especially the temporary nodes since we are going to display
+     * them also.
+     */
+    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
+    if (ACPI_FAILURE (Status))
+    {
+        AcpiOsPrintf ("Could not acquire namespace mutex\n");
+        return;
+    }
+
+    /* Get the max depth of the namespace tree, for formatting later */
+
+    (void) AcpiNsWalkNamespace (Type, StartHandle, MaxDepth,
+        ACPI_NS_WALK_NO_UNLOCK | ACPI_NS_WALK_TEMP_NODES,
+        AcpiNsGetMaxDepth, NULL, (void *) &MaxLevel, NULL);
+
+    /* Now dump the entire namespace */
+
+    (void) AcpiNsWalkNamespace (Type, StartHandle, MaxDepth,
+        ACPI_NS_WALK_NO_UNLOCK | ACPI_NS_WALK_TEMP_NODES,
+        AcpiNsDumpOneObjectPath, NULL, (void *) &MaxLevel, NULL);
 
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
 }
@@ -736,7 +900,7 @@ AcpiNsDumpEntry (
  *
  * PARAMETERS:  SearchBase          - Root of subtree to be dumped, or
  *                                    NS_ALL to dump the entire namespace
- *              MaxDepth            - Maximum depth of dump.  Use INT_MAX
+ *              MaxDepth            - Maximum depth of dump. Use INT_MAX
  *                                    for an effectively unlimited depth.
  *
  * RETURN:      None
@@ -762,7 +926,8 @@ AcpiNsDumpTables (
          * If the name space has not been initialized,
          * there is nothing to dump.
          */
-        ACPI_DEBUG_PRINT ((ACPI_DB_TABLES, "namespace not initialized!\n"));
+        ACPI_DEBUG_PRINT ((ACPI_DB_TABLES,
+            "namespace not initialized!\n"));
         return_VOID;
     }
 
@@ -775,9 +940,8 @@ AcpiNsDumpTables (
     }
 
     AcpiNsDumpObjects (ACPI_TYPE_ANY, ACPI_DISPLAY_OBJECTS, MaxDepth,
-            ACPI_OWNER_ID_MAX, SearchHandle);
+        ACPI_OWNER_ID_MAX, SearchHandle);
     return_VOID;
 }
 #endif
 #endif
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsdumpdv.c b/usr/src/uts/intel/io/acpica/namespace/nsdumpdv.c
index 9d30886608..ea143fb5b4 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsdumpdv.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsdumpdv.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSDUMPDV_C__
-
 #include "acpi.h"
 
 
@@ -151,11 +149,9 @@ AcpiNsDumpRootDevices (
         "Display of all devices in the namespace:\n"));
 
     Status = AcpiNsWalkNamespace (ACPI_TYPE_DEVICE, SysBusHandle,
-                ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
-                AcpiNsDumpOneDevice, NULL, NULL, NULL);
+        ACPI_UINT32_MAX, ACPI_NS_WALK_NO_UNLOCK,
+        AcpiNsDumpOneDevice, NULL, NULL, NULL);
 }
 
 #endif
 #endif
-
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nseval.c b/usr/src/uts/intel/io/acpica/namespace/nseval.c
index 0183f7e774..63051b8a52 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nseval.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nseval.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSEVAL_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -65,15 +63,14 @@ AcpiNsExecModuleCode (
  *
  * FUNCTION:    AcpiNsEvaluate
  *
- * PARAMETERS:  Info            - Evaluation info block, contains:
+ * PARAMETERS:  Info            - Evaluation info block, contains these fields
+ *                                and more:
  *                  PrefixNode      - Prefix or Method/Object Node to execute
- *                  Pathname        - Name of method to execute, If NULL, the
+ *                  RelativePath    - Name of method to execute, If NULL, the
  *                                    Node is the object to execute
  *                  Parameters      - List of parameters to pass to the method,
  *                                    terminated by NULL. Params itself may be
  *                                    NULL if no parameters are being passed.
- *                  ReturnObject    - Where to put method's return value (if
- *                                    any). If NULL, no value is returned.
  *                  ParameterType   - Type of Parameter list
  *                  ReturnObject    - Where to put method's return value (if
  *                                    any). If NULL, no value is returned.
@@ -93,7 +90,6 @@ AcpiNsEvaluate (
     ACPI_EVALUATE_INFO      *Info)
 {
     ACPI_STATUS             Status;
-    ACPI_NAMESPACE_NODE     *Node;
 
 
     ACPI_FUNCTION_TRACE (NsEvaluate);
@@ -104,80 +100,141 @@ AcpiNsEvaluate (
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
-    /* Initialize the return value to an invalid object */
+    if (!Info->Node)
+    {
+        /*
+         * Get the actual namespace node for the target object if we
+         * need to. Handles these cases:
+         *
+         * 1) Null node, valid pathname from root (absolute path)
+         * 2) Node and valid pathname (path relative to Node)
+         * 3) Node, Null pathname
+         */
+        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,
+            ACPI_NS_NO_UPSEARCH, &Info->Node);
+        if (ACPI_FAILURE (Status))
+        {
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+    /*
+     * For a method alias, we must grab the actual method node so that
+     * proper scoping context will be established before execution.
+     */
+    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)
+    {
+        Info->Node = ACPI_CAST_PTR (
+            ACPI_NAMESPACE_NODE, Info->Node->Object);
+    }
+
+    /* Complete the info block initialization */
 
     Info->ReturnObject = NULL;
+    Info->NodeFlags = Info->Node->Flags;
+    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "%s [%p] Value %p\n",
+        Info->RelativePathname, Info->Node,
+        AcpiNsGetAttachedObject (Info->Node)));
+
+    /* Get info if we have a predefined name (_HID, etc.) */
+
+    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);
+
+    /* Get the full pathname to the object, for use in warning messages */
+
+    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);
+    if (!Info->FullPathname)
+    {
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    /* Count the number of arguments being passed in */
+
     Info->ParamCount = 0;
+    if (Info->Parameters)
+    {
+        while (Info->Parameters[Info->ParamCount])
+        {
+            Info->ParamCount++;
+        }
+
+        /* Warn on impossible argument count */
+
+        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)
+        {
+            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,
+                "Excess arguments (%u) - using only %u",
+                Info->ParamCount, ACPI_METHOD_NUM_ARGS));
+
+            Info->ParamCount = ACPI_METHOD_NUM_ARGS;
+        }
+    }
 
     /*
-     * Get the actual namespace node for the target object. Handles these cases:
-     *
-     * 1) Null node, Pathname (absolute path)
-     * 2) Node, Pathname (path relative to Node)
-     * 3) Node, Null Pathname
+     * For predefined names: Check that the declared argument count
+     * matches the ACPI spec -- otherwise this is a BIOS error.
      */
-    Status = AcpiNsGetNode (Info->PrefixNode, Info->Pathname,
-                ACPI_NS_NO_UPSEARCH, &Info->ResolvedNode);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
+    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,
+        Info->Predefined);
 
     /*
-     * For a method alias, we must grab the actual method node so that proper
-     * scoping context will be established before execution.
+     * For all names: Check that the incoming argument count for
+     * this method/object matches the actual ASL/AML definition.
      */
-    if (AcpiNsGetType (Info->ResolvedNode) == ACPI_TYPE_LOCAL_METHOD_ALIAS)
-    {
-        Info->ResolvedNode =
-            ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Info->ResolvedNode->Object);
-    }
+    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,
+        Info->ParamCount, Info->Predefined);
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "%s [%p] Value %p\n", Info->Pathname,
-        Info->ResolvedNode, AcpiNsGetAttachedObject (Info->ResolvedNode)));
+    /* For predefined names: Typecheck all incoming arguments */
 
-    Node = Info->ResolvedNode;
+    AcpiNsCheckArgumentTypes (Info);
 
     /*
-     * Two major cases here:
+     * Three major evaluation cases:
      *
-     * 1) The object is a control method -- execute it
-     * 2) The object is not a method -- just return it's current value
+     * 1) Object types that cannot be evaluated by definition
+     * 2) The object is a control method -- execute it
+     * 3) The object is not a method -- just return it's current value
      */
-    if (AcpiNsGetType (Info->ResolvedNode) == ACPI_TYPE_METHOD)
+    switch (AcpiNsGetType (Info->Node))
     {
+    case ACPI_TYPE_DEVICE:
+    case ACPI_TYPE_EVENT:
+    case ACPI_TYPE_MUTEX:
+    case ACPI_TYPE_REGION:
+    case ACPI_TYPE_THERMAL:
+    case ACPI_TYPE_LOCAL_SCOPE:
         /*
-         * 1) Object is a control method - execute it
+         * 1) Disallow evaluation of certain object types. For these,
+         *    object evaluation is undefined and not supported.
          */
+        ACPI_ERROR ((AE_INFO,
+            "%s: Evaluation of object type [%s] is not supported",
+            Info->FullPathname,
+            AcpiUtGetTypeName (Info->Node->Type)));
 
-        /* Verify that there is a method object associated with this node */
+        Status = AE_TYPE;
+        goto Cleanup;
 
-        Info->ObjDesc = AcpiNsGetAttachedObject (Info->ResolvedNode);
-        if (!Info->ObjDesc)
-        {
-            ACPI_ERROR ((AE_INFO, "Control method has no attached sub-object"));
-            return_ACPI_STATUS (AE_NULL_OBJECT);
-        }
+    case ACPI_TYPE_METHOD:
+        /*
+         * 2) Object is a control method - execute it
+         */
 
-        /* Count the number of arguments being passed to the method */
+        /* Verify that there is a method object associated with this node */
 
-        if (Info->Parameters)
+        if (!Info->ObjDesc)
         {
-            while (Info->Parameters[Info->ParamCount])
-            {
-                if (Info->ParamCount > ACPI_METHOD_MAX_ARG)
-                {
-                    return_ACPI_STATUS (AE_LIMIT);
-                }
-                Info->ParamCount++;
-            }
+            ACPI_ERROR ((AE_INFO, "%s: Method has no attached sub-object",
+                Info->FullPathname));
+            Status = AE_NULL_OBJECT;
+            goto Cleanup;
         }
 
-        ACPI_DUMP_PATHNAME (Info->ResolvedNode, "ACPI: Execute Method",
-            ACPI_LV_INFO, _COMPONENT);
-
         ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "Method at AML address %p Length %X\n",
+            "**** Execute method [%s] at AML address %p length %X\n",
+            Info->FullPathname,
             Info->ObjDesc->Method.AmlStart + 1,
             Info->ObjDesc->Method.AmlLength - 1));
 
@@ -192,80 +249,59 @@ AcpiNsEvaluate (
         AcpiExEnterInterpreter ();
         Status = AcpiPsExecuteMethod (Info);
         AcpiExExitInterpreter ();
-    }
-    else
-    {
+        break;
+
+    default:
         /*
-         * 2) Object is not a method, return its current value
-         *
-         * Disallow certain object types. For these, "evaluation" is undefined.
+         * 3) All other non-method objects -- get the current object value
          */
-        switch (Info->ResolvedNode->Type)
-        {
-        case ACPI_TYPE_DEVICE:
-        case ACPI_TYPE_EVENT:
-        case ACPI_TYPE_MUTEX:
-        case ACPI_TYPE_REGION:
-        case ACPI_TYPE_THERMAL:
-        case ACPI_TYPE_LOCAL_SCOPE:
-
-            ACPI_ERROR ((AE_INFO,
-                "[%4.4s] Evaluation of object type [%s] is not supported",
-                Info->ResolvedNode->Name.Ascii,
-                AcpiUtGetTypeName (Info->ResolvedNode->Type)));
-
-            return_ACPI_STATUS (AE_TYPE);
-
-        default:
-            break;
-        }
 
         /*
-         * Objects require additional resolution steps (e.g., the Node may be
-         * a field that must be read, etc.) -- we can't just grab the object
-         * out of the node.
+         * Some objects require additional resolution steps (e.g., the Node
+         * may be a field that must be read, etc.) -- we can't just grab
+         * the object out of the node.
          *
          * Use ResolveNodeToValue() to get the associated value.
          *
          * NOTE: we can get away with passing in NULL for a walk state because
-         * ResolvedNode is guaranteed to not be a reference to either a method
+         * the Node is guaranteed to not be a reference to either a method
          * local or a method argument (because this interface is never called
          * from a running method.)
          *
          * Even though we do not directly invoke the interpreter for object
-         * resolution, we must lock it because we could access an opregion.
-         * The opregion access code assumes that the interpreter is locked.
+         * resolution, we must lock it because we could access an OpRegion.
+         * The OpRegion access code assumes that the interpreter is locked.
          */
         AcpiExEnterInterpreter ();
 
-        /* Function has a strange interface */
+        /* TBD: ResolveNodeToValue has a strange interface, fix */
 
-        Status = AcpiExResolveNodeToValue (&Info->ResolvedNode, NULL);
+        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);
+
+        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (
+            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);
         AcpiExExitInterpreter ();
 
-        /*
-         * If AcpiExResolveNodeToValue() succeeded, the return value was placed
-         * in ResolvedNode.
-         */
-        if (ACPI_SUCCESS (Status))
+        if (ACPI_FAILURE (Status))
         {
-            Status = AE_CTRL_RETURN_VALUE;
-            Info->ReturnObject =
-                ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->ResolvedNode);
-
-            ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Returning object %p [%s]\n",
-                Info->ReturnObject,
-                AcpiUtGetObjectTypeName (Info->ReturnObject)));
+            Info->ReturnObject = NULL;
+            goto Cleanup;
         }
+
+        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, "Returned object %p [%s]\n",
+            Info->ReturnObject,
+            AcpiUtGetObjectTypeName (Info->ReturnObject)));
+
+        Status = AE_CTRL_RETURN_VALUE; /* Always has a "return value" */
+        break;
     }
 
     /*
-     * Check input argument count against the ASL-defined count for a method.
-     * Also check predefined names: argument count and return value against
-     * the ACPI specification. Some incorrect return value types are repaired.
+     * For predefined names, check the return value against the ACPI
+     * specification. Some incorrect return value types are repaired.
      */
-    (void) AcpiNsCheckPredefinedNames (Node, Info->ParamCount,
-                Status, &Info->ReturnObject);
+    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,
+        Status, &Info->ReturnObject);
 
     /* Check if there is a return value that must be dealt with */
 
@@ -285,12 +321,16 @@ AcpiNsEvaluate (
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-        "*** Completed evaluation of object %s ***\n", Info->Pathname));
+        "*** Completed evaluation of object %s ***\n",
+        Info->RelativePathname));
 
+Cleanup:
     /*
      * Namespace was unlocked by the handling AcpiNs* function, so we
-     * just return
+     * just free the pathname and return
      */
+    ACPI_FREE (Info->FullPathname);
+    Info->FullPathname = NULL;
     return_ACPI_STATUS (Status);
 }
 
@@ -356,7 +396,7 @@ AcpiNsExecModuleCodeList (
         AcpiUtRemoveReference (Prev);
     }
 
-    ACPI_INFO ((AE_INFO,
+    ACPI_INFO ((
         "Executed %u blocks of module-level executable AML code",
         MethodCount));
 
@@ -400,8 +440,8 @@ AcpiNsExecModuleCode (
      * Get the parent node. We cheat by using the NextObject field
      * of the method object descriptor.
      */
-    ParentNode = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE,
-                    MethodObj->Method.NextObject);
+    ParentNode = ACPI_CAST_PTR (
+        ACPI_NAMESPACE_NODE, MethodObj->Method.NextObject);
     Type = AcpiNsGetType (ParentNode);
 
     /*
@@ -423,13 +463,13 @@ AcpiNsExecModuleCode (
 
     /* Initialize the evaluation information block */
 
-    ACPI_MEMSET (Info, 0, sizeof (ACPI_EVALUATE_INFO));
+    memset (Info, 0, sizeof (ACPI_EVALUATE_INFO));
     Info->PrefixNode = ParentNode;
 
     /*
-     * Get the currently attached parent object. Add a reference, because the
-     * ref count will be decreased when the method object is installed to
-     * the parent node.
+     * Get the currently attached parent object. Add a reference,
+     * because the ref count will be decreased when the method object
+     * is installed to the parent node.
      */
     ParentObj = AcpiNsGetAttachedObject (ParentNode);
     if (ParentObj)
@@ -439,8 +479,7 @@ AcpiNsExecModuleCode (
 
     /* Install the method (module-level code) in the parent node */
 
-    Status = AcpiNsAttachObject (ParentNode, MethodObj,
-                ACPI_TYPE_METHOD);
+    Status = AcpiNsAttachObject (ParentNode, MethodObj, ACPI_TYPE_METHOD);
     if (ACPI_FAILURE (Status))
     {
         goto Exit;
@@ -450,7 +489,8 @@ AcpiNsExecModuleCode (
 
     Status = AcpiNsEvaluate (Info);
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "Executed module-level code at %p\n",
+    ACPI_DEBUG_PRINT ((ACPI_DB_INIT_NAMES,
+        "Executed module-level code at %p\n",
         MethodObj->Method.AmlStart));
 
     /* Delete a possible implicit return value (in slack mode) */
@@ -482,4 +522,3 @@ Exit:
     }
     return_VOID;
 }
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsinit.c b/usr/src/uts/intel/io/acpica/namespace/nsinit.c
index f3907aafb3..dbe6c7c09f 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsinit.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsinit.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,14 +41,12 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __NSXFINIT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
 #include "acdispat.h"
 #include "acinterp.h"
+#include "acevents.h"
 
 #define _COMPONENT          ACPI_NAMESPACE
         ACPI_MODULE_NAME    ("nsinit")
@@ -101,27 +99,29 @@ AcpiNsInitializeObjects (
     ACPI_FUNCTION_TRACE (NsInitializeObjects);
 
 
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+        "[Init] Completing Initialization of ACPI Objects\n"));
     ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
         "**** Starting initialization of namespace objects ****\n"));
     ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
-        "Completing Region/Field/Buffer/Package initialization:"));
+        "Completing Region/Field/Buffer/Package initialization:\n"));
 
     /* Set all init info to zero */
 
-    ACPI_MEMSET (&Info, 0, sizeof (ACPI_INIT_WALK_INFO));
+    memset (&Info, 0, sizeof (ACPI_INIT_WALK_INFO));
 
     /* Walk entire namespace from the supplied root */
 
     Status = AcpiWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
-                ACPI_UINT32_MAX, AcpiNsInitOneObject, NULL,
-                &Info, NULL);
+        ACPI_UINT32_MAX, AcpiNsInitOneObject, NULL,
+        &Info, NULL);
     if (ACPI_FAILURE (Status))
     {
         ACPI_EXCEPTION ((AE_INFO, Status, "During WalkNamespace"));
     }
 
     ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
-        "\nInitialized %u/%u Regions %u/%u Fields %u/%u "
+        "    Initialized %u/%u Regions %u/%u Fields %u/%u "
         "Buffers %u/%u Packages (%u nodes)\n",
         Info.OpRegionInit,  Info.OpRegionCount,
         Info.FieldInit,     Info.FieldCount,
@@ -129,9 +129,8 @@ AcpiNsInitializeObjects (
         Info.PackageInit,   Info.PackageCount, Info.ObjectCount));
 
     ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-        "%u Control Methods found\n", Info.MethodCount));
-    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,
-        "%u Op Regions found\n", Info.OpRegionCount));
+        "%u Control Methods found\n%u Op Regions found\n",
+        Info.MethodCount, Info.OpRegionCount));
 
     return_ACPI_STATUS (AE_OK);
 }
@@ -155,84 +154,140 @@ AcpiNsInitializeObjects (
 
 ACPI_STATUS
 AcpiNsInitializeDevices (
-    void)
+    UINT32                  Flags)
 {
-    ACPI_STATUS             Status;
+    ACPI_STATUS             Status = AE_OK;
     ACPI_DEVICE_WALK_INFO   Info;
+    ACPI_HANDLE             Handle;
 
 
     ACPI_FUNCTION_TRACE (NsInitializeDevices);
 
 
-    /* Init counters */
+    if (!(Flags & ACPI_NO_DEVICE_INIT))
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "[Init] Initializing ACPI Devices\n"));
 
-    Info.DeviceCount = 0;
-    Info.Num_STA = 0;
-    Info.Num_INI = 0;
+        /* Init counters */
 
-    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
-        "Initializing Device/Processor/Thermal objects "
-        "by executing _INI methods:"));
+        Info.DeviceCount = 0;
+        Info.Num_STA = 0;
+        Info.Num_INI = 0;
 
-    /* Tree analysis: find all subtrees that contain _INI methods */
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+            "Initializing Device/Processor/Thermal objects "
+            "and executing _INI/_STA methods:\n"));
 
-    Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
-                ACPI_UINT32_MAX, FALSE, AcpiNsFindIniMethods, NULL, &Info, NULL);
-    if (ACPI_FAILURE (Status))
-    {
-        goto ErrorExit;
-    }
+        /* Tree analysis: find all subtrees that contain _INI methods */
 
-    /* Allocate the evaluation information block */
-
-    Info.EvaluateInfo = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_EVALUATE_INFO));
-    if (!Info.EvaluateInfo)
-    {
-        Status = AE_NO_MEMORY;
-        goto ErrorExit;
-    }
+        Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
+            ACPI_UINT32_MAX, FALSE, AcpiNsFindIniMethods, NULL, &Info, NULL);
+        if (ACPI_FAILURE (Status))
+        {
+            goto ErrorExit;
+        }
 
-    /*
-     * Execute the "global" _INI method that may appear at the root. This
-     * support is provided for Windows compatibility (Vista+) and is not
-     * part of the ACPI specification.
-     */
-    Info.EvaluateInfo->PrefixNode = AcpiGbl_RootNode;
-    Info.EvaluateInfo->Pathname = METHOD_NAME__INI;
-    Info.EvaluateInfo->Parameters = NULL;
-    Info.EvaluateInfo->Flags = ACPI_IGNORE_RETURN_VALUE;
+        /* Allocate the evaluation information block */
 
-    Status = AcpiNsEvaluate (Info.EvaluateInfo);
-    if (ACPI_SUCCESS (Status))
-    {
-        Info.Num_INI++;
-    }
+        Info.EvaluateInfo = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_EVALUATE_INFO));
+        if (!Info.EvaluateInfo)
+        {
+            Status = AE_NO_MEMORY;
+            goto ErrorExit;
+        }
 
-    /* Walk namespace to execute all _INIs on present devices */
+        /*
+         * Execute the "global" _INI method that may appear at the root.
+         * This support is provided for Windows compatibility (Vista+) and
+         * is not part of the ACPI specification.
+         */
+        Info.EvaluateInfo->PrefixNode = AcpiGbl_RootNode;
+        Info.EvaluateInfo->RelativePathname = METHOD_NAME__INI;
+        Info.EvaluateInfo->Parameters = NULL;
+        Info.EvaluateInfo->Flags = ACPI_IGNORE_RETURN_VALUE;
+
+        Status = AcpiNsEvaluate (Info.EvaluateInfo);
+        if (ACPI_SUCCESS (Status))
+        {
+            Info.Num_INI++;
+        }
 
-    Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
-                ACPI_UINT32_MAX, FALSE, AcpiNsInitOneDevice, NULL, &Info, NULL);
+        /*
+         * Execute \_SB._INI.
+         * There appears to be a strict order requirement for \_SB._INI,
+         * which should be evaluated before any _REG evaluations.
+         */
+        Status = AcpiGetHandle (NULL, "\\_SB", &Handle);
+        if (ACPI_SUCCESS (Status))
+        {
+            memset (Info.EvaluateInfo, 0, sizeof (ACPI_EVALUATE_INFO));
+            Info.EvaluateInfo->PrefixNode = Handle;
+            Info.EvaluateInfo->RelativePathname = METHOD_NAME__INI;
+            Info.EvaluateInfo->Parameters = NULL;
+            Info.EvaluateInfo->Flags = ACPI_IGNORE_RETURN_VALUE;
+
+            Status = AcpiNsEvaluate (Info.EvaluateInfo);
+            if (ACPI_SUCCESS (Status))
+            {
+                Info.Num_INI++;
+            }
+        }
+    }
 
     /*
-     * Any _OSI requests should be completed by now. If the BIOS has
-     * requested any Windows OSI strings, we will always truncate
-     * I/O addresses to 16 bits -- for Windows compatibility.
+     * Run all _REG methods
+     *
+     * Note: Any objects accessed by the _REG methods will be automatically
+     * initialized, even if they contain executable AML (see the call to
+     * AcpiNsInitializeObjects below).
+     *
+     * Note: According to the ACPI specification, we actually needn't execute
+     * _REG for SystemMemory/SystemIo operation regions, but for PCI_Config
+     * operation regions, it is required to evaluate _REG for those on a PCI
+     * root bus that doesn't contain _BBN object. So this code is kept here
+     * in order not to break things.
      */
-    if (AcpiGbl_OsiData >= ACPI_OSI_WIN_2000)
+    if (!(Flags & ACPI_NO_ADDRESS_SPACE_INIT))
     {
-        AcpiGbl_TruncateIoAddresses = TRUE;
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "[Init] Executing _REG OpRegion methods\n"));
+
+        Status = AcpiEvInitializeOpRegions ();
+        if (ACPI_FAILURE (Status))
+        {
+            goto ErrorExit;
+        }
     }
 
-    ACPI_FREE (Info.EvaluateInfo);
-    if (ACPI_FAILURE (Status))
+    if (!(Flags & ACPI_NO_DEVICE_INIT))
     {
-        goto ErrorExit;
-    }
+        /* Walk namespace to execute all _INIs on present devices */
 
-    ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
-        "\nExecuted %u _INI methods requiring %u _STA executions "
-        "(examined %u objects)\n",
-        Info.Num_INI, Info.Num_STA, Info.DeviceCount));
+        Status = AcpiNsWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT,
+            ACPI_UINT32_MAX, FALSE, AcpiNsInitOneDevice, NULL, &Info, NULL);
+
+        /*
+         * Any _OSI requests should be completed by now. If the BIOS has
+         * requested any Windows OSI strings, we will always truncate
+         * I/O addresses to 16 bits -- for Windows compatibility.
+         */
+        if (AcpiGbl_OsiData >= ACPI_OSI_WIN_2000)
+        {
+            AcpiGbl_TruncateIoAddresses = TRUE;
+        }
+
+        ACPI_FREE (Info.EvaluateInfo);
+        if (ACPI_FAILURE (Status))
+        {
+            goto ErrorExit;
+        }
+
+        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+            "    Executed %u _INI methods requiring %u _STA executions "
+            "(examined %u objects)\n",
+            Info.Num_INI, Info.Num_STA, Info.DeviceCount));
+    }
 
     return_ACPI_STATUS (Status);
 
@@ -254,7 +309,7 @@ ErrorExit:
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Callback from AcpiWalkNamespace.  Invoked for every object
+ * DESCRIPTION: Callback from AcpiWalkNamespace. Invoked for every object
  *              within the  namespace.
  *
  *              Currently, the only objects that require initialization are:
@@ -296,28 +351,34 @@ AcpiNsInitOneObject (
     switch (Type)
     {
     case ACPI_TYPE_REGION:
+
         Info->OpRegionCount++;
         break;
 
     case ACPI_TYPE_BUFFER_FIELD:
+
         Info->FieldCount++;
         break;
 
     case ACPI_TYPE_LOCAL_BANK_FIELD:
+
         Info->FieldCount++;
         break;
 
     case ACPI_TYPE_BUFFER:
+
         Info->BufferCount++;
         break;
 
     case ACPI_TYPE_PACKAGE:
+
         Info->PackageCount++;
         break;
 
     default:
 
         /* No init required, just exit now */
+
         return (AE_OK);
     }
 
@@ -369,7 +430,9 @@ AcpiNsInitOneObject (
         break;
 
     default:
+
         /* No other types can get here */
+
         break;
     }
 
@@ -380,15 +443,6 @@ AcpiNsInitOneObject (
             AcpiUtGetNodeName (Node), AcpiUtGetTypeName (Type)));
     }
 
-    /*
-     * Print a dot for each object unless we are going to print the entire
-     * pathname
-     */
-    if (!(AcpiDbgLevel & ACPI_LV_INIT_NAMES))
-    {
-        ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "."));
-    }
-
     /*
      * We ignore errors from above, and always return OK, since we don't want
      * to abort the walk on any single error.
@@ -465,6 +519,7 @@ AcpiNsFindIniMethods (
         break;
 
     default:
+
         break;
     }
 
@@ -615,38 +670,37 @@ AcpiNsInitOneDevice (
      * Note: We know there is an _INI within this subtree, but it may not be
      * under this particular device, it may be lower in the branch.
      */
-    ACPI_DEBUG_EXEC (AcpiUtDisplayInitPathname (
-        ACPI_TYPE_METHOD, DeviceNode, METHOD_NAME__INI));
-
-    Info->PrefixNode = DeviceNode;
-    Info->Pathname = METHOD_NAME__INI;
-    Info->Parameters = NULL;
-    Info->Flags = ACPI_IGNORE_RETURN_VALUE;
-
-    Status = AcpiNsEvaluate (Info);
-    if (ACPI_SUCCESS (Status))
+    if (!ACPI_COMPARE_NAME (DeviceNode->Name.Ascii, "_SB_") ||
+        DeviceNode->Parent != AcpiGbl_RootNode)
     {
-        WalkInfo->Num_INI++;
+        ACPI_DEBUG_EXEC (AcpiUtDisplayInitPathname (
+            ACPI_TYPE_METHOD, DeviceNode, METHOD_NAME__INI));
 
-        if ((AcpiDbgLevel <= ACPI_LV_ALL_EXCEPTIONS) &&
-            (!(AcpiDbgLevel & ACPI_LV_INFO)))
+        memset (Info, 0, sizeof (ACPI_EVALUATE_INFO));
+        Info->PrefixNode = DeviceNode;
+        Info->RelativePathname = METHOD_NAME__INI;
+        Info->Parameters = NULL;
+        Info->Flags = ACPI_IGNORE_RETURN_VALUE;
+
+        Status = AcpiNsEvaluate (Info);
+        if (ACPI_SUCCESS (Status))
         {
-            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT, "."));
+            WalkInfo->Num_INI++;
         }
-    }
 
 #ifdef ACPI_DEBUG_OUTPUT
-    else if (Status != AE_NOT_FOUND)
-    {
-        /* Ignore error and move on to next device */
+        else if (Status != AE_NOT_FOUND)
+        {
+            /* Ignore error and move on to next device */
 
-        char *ScopeName = AcpiNsGetExternalPathname (Info->ResolvedNode);
+            char *ScopeName = AcpiNsGetNormalizedPathname (DeviceNode, TRUE);
 
-        ACPI_EXCEPTION ((AE_INFO, Status, "during %s._INI execution",
-            ScopeName));
-        ACPI_FREE (ScopeName);
-    }
+            ACPI_EXCEPTION ((AE_INFO, Status, "during %s._INI execution",
+                ScopeName));
+            ACPI_FREE (ScopeName);
+        }
 #endif
+    }
 
     /* Ignore errors from above */
 
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsload.c b/usr/src/uts/intel/io/acpica/namespace/nsload.c
index 3ef33f9ce9..9c899e7846 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsload.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsload.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSLOAD_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -93,8 +91,8 @@ AcpiNsLoadTable (
 
     /*
      * Parse the table and load the namespace with all named
-     * objects found within.  Control methods are NOT parsed
-     * at this time.  In fact, the control methods cannot be
+     * objects found within. Control methods are NOT parsed
+     * at this time. In fact, the control methods cannot be
      * parsed until the entire namespace is loaded, because
      * if a control method makes a forward reference (call)
      * to another control method, we can't continue parsing
@@ -130,7 +128,21 @@ AcpiNsLoadTable (
     }
     else
     {
-        (void) AcpiTbReleaseOwnerId (TableIndex);
+        /*
+         * On error, delete any namespace objects created by this table.
+         * We cannot initialize these objects, so delete them. There are
+         * a couple of expecially bad cases:
+         * AE_ALREADY_EXISTS - namespace collision.
+         * AE_NOT_FOUND - the target of a Scope operator does not
+         * exist. This target of Scope must already exist in the
+         * namespace, as per the ACPI specification.
+         */
+        (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+        AcpiNsDeleteNamespaceByOwner (
+            AcpiGbl_RootTableList.Tables[TableIndex].OwnerId);
+
+        AcpiTbReleaseOwnerId (TableIndex);
+        return_ACPI_STATUS (Status);
     }
 
 Unlock:
@@ -142,18 +154,36 @@ Unlock:
     }
 
     /*
-     * Now we can parse the control methods.  We always parse
+     * Now we can parse the control methods. We always parse
      * them here for a sanity check, and if configured for
      * just-in-time parsing, we delete the control method
      * parse trees.
      */
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-        "**** Begin Table Method Parsing and Object Initialization\n"));
+        "**** Begin Table Object Initialization\n"));
 
     Status = AcpiDsInitializeObjects (TableIndex, Node);
 
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-        "**** Completed Table Method Parsing and Object Initialization\n"));
+        "**** Completed Table Object Initialization\n"));
+
+    /*
+     * Execute any module-level code that was detected during the table load
+     * phase. Although illegal since ACPI 2.0, there are many machines that
+     * contain this type of code. Each block of detected executable AML code
+     * outside of any control method is wrapped with a temporary control
+     * method object and placed on a global list. The methods on this list
+     * are executed below.
+     *
+     * This case executes the module-level code for each table immediately
+     * after the table has been loaded. This provides compatibility with
+     * other ACPI implementations. Optionally, the execution can be deferred
+     * until later, see AcpiInitializeObjects.
+     */
+    if (!AcpiGbl_GroupModuleLevelCode)
+    {
+        AcpiNsExecModuleCodeList ();
+    }
 
     return_ACPI_STATUS (Status);
 }
@@ -192,7 +222,7 @@ AcpiNsLoadNamespace (
     }
 
     /*
-     * Load the namespace.  The DSDT is required,
+     * Load the namespace. The DSDT is required,
      * but the SSDT and PSDT tables are optional.
      */
     Status = AcpiNsLoadTableByType (ACPI_TABLE_ID_DSDT);
@@ -247,8 +277,8 @@ AcpiNsDeleteSubtree (
 
 
     ParentHandle = StartHandle;
-    ChildHandle  = NULL;
-    Level        = 1;
+    ChildHandle = NULL;
+    Level = 1;
 
     /*
      * Traverse the tree of objects until we bubble back up
@@ -259,7 +289,7 @@ AcpiNsDeleteSubtree (
         /* Attempt to get the next object in this scope */
 
         Status = AcpiGetNextObject (ACPI_TYPE_ANY, ParentHandle,
-                                    ChildHandle, &NextChildHandle);
+            ChildHandle, &NextChildHandle);
 
         ChildHandle = NextChildHandle;
 
@@ -270,7 +300,7 @@ AcpiNsDeleteSubtree (
             /* Check if this object has any children */
 
             if (ACPI_SUCCESS (AcpiGetNextObject (ACPI_TYPE_ANY, ChildHandle,
-                                    NULL, &Dummy)))
+                NULL, &Dummy)))
             {
                 /*
                  * There is at least one child of this object,
@@ -318,7 +348,7 @@ AcpiNsDeleteSubtree (
  *  RETURN:         Status
  *
  *  DESCRIPTION:    Shrinks the namespace, typically in response to an undocking
- *                  event.  Deletes an entire subtree starting from (and
+ *                  event. Deletes an entire subtree starting from (and
  *                  including) the given handle.
  *
  ******************************************************************************/
@@ -348,9 +378,7 @@ AcpiNsUnloadNamespace (
     /* This function does the real work */
 
     Status = AcpiNsDeleteSubtree (Handle);
-
     return_ACPI_STATUS (Status);
 }
 #endif
 #endif
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsnames.c b/usr/src/uts/intel/io/acpica/namespace/nsnames.c
index f70900da1d..95f8c8db97 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsnames.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsnames.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSNAMES_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "amlcode.h"
@@ -53,82 +51,6 @@
         ACPI_MODULE_NAME    ("nsnames")
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsBuildExternalPath
- *
- * PARAMETERS:  Node            - NS node whose pathname is needed
- *              Size            - Size of the pathname
- *              *NameBuffer     - Where to return the pathname
- *
- * RETURN:      Status
- *              Places the pathname into the NameBuffer, in external format
- *              (name segments separated by path separators)
- *
- * DESCRIPTION: Generate a full pathaname
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiNsBuildExternalPath (
-    ACPI_NAMESPACE_NODE     *Node,
-    ACPI_SIZE               Size,
-    char                    *NameBuffer)
-{
-    ACPI_SIZE               Index;
-    ACPI_NAMESPACE_NODE     *ParentNode;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    /* Special case for root */
-
-    Index = Size - 1;
-    if (Index < ACPI_NAME_SIZE)
-    {
-        NameBuffer[0] = AML_ROOT_PREFIX;
-        NameBuffer[1] = 0;
-        return (AE_OK);
-    }
-
-    /* Store terminator byte, then build name backwards */
-
-    ParentNode = Node;
-    NameBuffer[Index] = 0;
-
-    while ((Index > ACPI_NAME_SIZE) && (ParentNode != AcpiGbl_RootNode))
-    {
-        Index -= ACPI_NAME_SIZE;
-
-        /* Put the name into the buffer */
-
-        ACPI_MOVE_32_TO_32 ((NameBuffer + Index), &ParentNode->Name);
-        ParentNode = ParentNode->Parent;
-
-        /* Prefix name with the path separator */
-
-        Index--;
-        NameBuffer[Index] = ACPI_PATH_SEPARATOR;
-    }
-
-    /* Overwrite final separator with the root prefix character */
-
-    NameBuffer[Index] = AML_ROOT_PREFIX;
-
-    if (Index != 0)
-    {
-        ACPI_ERROR ((AE_INFO,
-            "Could not construct external pathname; index=%u, size=%u, Path=%s",
-            (UINT32) Index, (UINT32) Size, &NameBuffer[Size]));
-
-        return (AE_BAD_PARAMETER);
-    }
-
-    return (AE_OK);
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiNsGetExternalPathname
@@ -148,40 +70,13 @@ char *
 AcpiNsGetExternalPathname (
     ACPI_NAMESPACE_NODE     *Node)
 {
-    ACPI_STATUS             Status;
     char                    *NameBuffer;
-    ACPI_SIZE               Size;
 
 
     ACPI_FUNCTION_TRACE_PTR (NsGetExternalPathname, Node);
 
 
-    /* Calculate required buffer size based on depth below root */
-
-    Size = AcpiNsGetPathnameLength (Node);
-    if (!Size)
-    {
-        return_PTR (NULL);
-    }
-
-    /* Allocate a buffer to be returned to caller */
-
-    NameBuffer = ACPI_ALLOCATE_ZEROED (Size);
-    if (!NameBuffer)
-    {
-        ACPI_ERROR ((AE_INFO, "Could not allocate %u bytes", (UINT32) Size));
-        return_PTR (NULL);
-    }
-
-    /* Build the path in the allocated buffer */
-
-    Status = AcpiNsBuildExternalPath (Node, Size, NameBuffer);
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_FREE (NameBuffer);
-        return_PTR (NULL);
-    }
-
+    NameBuffer = AcpiNsGetNormalizedPathname (Node, FALSE);
     return_PTR (NameBuffer);
 }
 
@@ -203,38 +98,13 @@ AcpiNsGetPathnameLength (
     ACPI_NAMESPACE_NODE     *Node)
 {
     ACPI_SIZE               Size;
-    ACPI_NAMESPACE_NODE     *NextNode;
 
 
     ACPI_FUNCTION_ENTRY ();
 
 
-    /*
-     * Compute length of pathname as 5 * number of name segments.
-     * Go back up the parent tree to the root
-     */
-    Size = 0;
-    NextNode = Node;
-
-    while (NextNode && (NextNode != AcpiGbl_RootNode))
-    {
-        if (ACPI_GET_DESCRIPTOR_TYPE (NextNode) != ACPI_DESC_TYPE_NAMED)
-        {
-            ACPI_ERROR ((AE_INFO,
-                "Invalid Namespace Node (%p) while traversing namespace",
-                NextNode));
-            return 0;
-        }
-        Size += ACPI_PATH_SEGMENT_LENGTH;
-        NextNode = NextNode->Parent;
-    }
-
-    if (!Size)
-    {
-        Size = 1; /* Root node case */
-    }
-
-    return (Size + 1);  /* +1 for null string terminator */
+    Size = AcpiNsBuildNormalizedPath (Node, NULL, 0, FALSE);
+    return (Size);
 }
 
 
@@ -245,6 +115,8 @@ AcpiNsGetPathnameLength (
  * PARAMETERS:  TargetHandle            - Handle of named object whose name is
  *                                        to be found
  *              Buffer                  - Where the pathname is returned
+ *              NoTrailing              - Remove trailing '_' for each name
+ *                                        segment
  *
  * RETURN:      Status, Buffer is filled with pathname if status is AE_OK
  *
@@ -255,7 +127,8 @@ AcpiNsGetPathnameLength (
 ACPI_STATUS
 AcpiNsHandleToPathname (
     ACPI_HANDLE             TargetHandle,
-    ACPI_BUFFER             *Buffer)
+    ACPI_BUFFER             *Buffer,
+    BOOLEAN                 NoTrailing)
 {
     ACPI_STATUS             Status;
     ACPI_NAMESPACE_NODE     *Node;
@@ -273,7 +146,7 @@ AcpiNsHandleToPathname (
 
     /* Determine size required for the caller buffer */
 
-    RequiredSize = AcpiNsGetPathnameLength (Node);
+    RequiredSize = AcpiNsBuildNormalizedPath (Node, NULL, 0, NoTrailing);
     if (!RequiredSize)
     {
         return_ACPI_STATUS (AE_BAD_PARAMETER);
@@ -289,7 +162,8 @@ AcpiNsHandleToPathname (
 
     /* Build the path in the caller buffer */
 
-    Status = AcpiNsBuildExternalPath (Node, RequiredSize, Buffer->Pointer);
+    (void) AcpiNsBuildNormalizedPath (Node, Buffer->Pointer,
+        RequiredSize, NoTrailing);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -301,3 +175,172 @@ AcpiNsHandleToPathname (
 }
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsBuildNormalizedPath
+ *
+ * PARAMETERS:  Node        - Namespace node
+ *              FullPath    - Where the path name is returned
+ *              PathSize    - Size of returned path name buffer
+ *              NoTrailing  - Remove trailing '_' from each name segment
+ *
+ * RETURN:      Return 1 if the AML path is empty, otherwise returning (length
+ *              of pathname + 1) which means the 'FullPath' contains a trailing
+ *              null.
+ *
+ * DESCRIPTION: Build and return a full namespace pathname.
+ *              Note that if the size of 'FullPath' isn't large enough to
+ *              contain the namespace node's path name, the actual required
+ *              buffer length is returned, and it should be greater than
+ *              'PathSize'. So callers are able to check the returning value
+ *              to determine the buffer size of 'FullPath'.
+ *
+ ******************************************************************************/
+
+UINT32
+AcpiNsBuildNormalizedPath (
+    ACPI_NAMESPACE_NODE     *Node,
+    char                    *FullPath,
+    UINT32                  PathSize,
+    BOOLEAN                 NoTrailing)
+{
+    UINT32                  Length = 0, i;
+    char                    Name[ACPI_NAME_SIZE];
+    BOOLEAN                 DoNoTrailing;
+    char                    c, *Left, *Right;
+    ACPI_NAMESPACE_NODE     *NextNode;
+
+
+    ACPI_FUNCTION_TRACE_PTR (NsBuildNormalizedPath, Node);
+
+
+#define ACPI_PATH_PUT8(Path, Size, Byte, Length)    \
+    do {                                            \
+        if ((Length) < (Size))                      \
+        {                                           \
+            (Path)[(Length)] = (Byte);              \
+        }                                           \
+        (Length)++;                                 \
+    } while (0)
+
+    /*
+     * Make sure the PathSize is correct, so that we don't need to
+     * validate both FullPath and PathSize.
+     */
+    if (!FullPath)
+    {
+        PathSize = 0;
+    }
+
+    if (!Node)
+    {
+        goto BuildTrailingNull;
+    }
+
+    NextNode = Node;
+    while (NextNode && NextNode != AcpiGbl_RootNode)
+    {
+        if (NextNode != Node)
+        {
+            ACPI_PATH_PUT8(FullPath, PathSize, AML_DUAL_NAME_PREFIX, Length);
+        }
+
+        ACPI_MOVE_32_TO_32 (Name, &NextNode->Name);
+        DoNoTrailing = NoTrailing;
+        for (i = 0; i < 4; i++)
+        {
+            c = Name[4-i-1];
+            if (DoNoTrailing && c != '_')
+            {
+                DoNoTrailing = FALSE;
+            }
+            if (!DoNoTrailing)
+            {
+                ACPI_PATH_PUT8(FullPath, PathSize, c, Length);
+            }
+        }
+
+        NextNode = NextNode->Parent;
+    }
+
+    ACPI_PATH_PUT8(FullPath, PathSize, AML_ROOT_PREFIX, Length);
+
+    /* Reverse the path string */
+
+    if (Length <= PathSize)
+    {
+        Left = FullPath;
+        Right = FullPath+Length - 1;
+
+        while (Left < Right)
+        {
+            c = *Left;
+            *Left++ = *Right;
+            *Right-- = c;
+        }
+    }
+
+    /* Append the trailing null */
+
+BuildTrailingNull:
+    ACPI_PATH_PUT8 (FullPath, PathSize, '\0', Length);
+
+#undef ACPI_PATH_PUT8
+
+    return_UINT32 (Length);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsGetNormalizedPathname
+ *
+ * PARAMETERS:  Node            - Namespace node whose pathname is needed
+ *              NoTrailing      - Remove trailing '_' from each name segment
+ *
+ * RETURN:      Pointer to storage containing the fully qualified name of
+ *              the node, In external format (name segments separated by path
+ *              separators.)
+ *
+ * DESCRIPTION: Used to obtain the full pathname to a namespace node, usually
+ *              for error and debug statements. All trailing '_' will be
+ *              removed from the full pathname if 'NoTrailing' is specified..
+ *
+ ******************************************************************************/
+
+char *
+AcpiNsGetNormalizedPathname (
+    ACPI_NAMESPACE_NODE     *Node,
+    BOOLEAN                 NoTrailing)
+{
+    char                    *NameBuffer;
+    ACPI_SIZE               Size;
+
+
+    ACPI_FUNCTION_TRACE_PTR (NsGetNormalizedPathname, Node);
+
+
+    /* Calculate required buffer size based on depth below root */
+
+    Size = AcpiNsBuildNormalizedPath (Node, NULL, 0, NoTrailing);
+    if (!Size)
+    {
+        return_PTR (NULL);
+    }
+
+    /* Allocate a buffer to be returned to caller */
+
+    NameBuffer = ACPI_ALLOCATE_ZEROED (Size);
+    if (!NameBuffer)
+    {
+        ACPI_ERROR ((AE_INFO,
+            "Could not allocate %u bytes", (UINT32) Size));
+        return_PTR (NULL);
+    }
+
+    /* Build the path in the allocated buffer */
+
+    (void) AcpiNsBuildNormalizedPath (Node, NameBuffer, Size, NoTrailing);
+
+    return_PTR (NameBuffer);
+}
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsobject.c b/usr/src/uts/intel/io/acpica/namespace/nsobject.c
index 9b219a5624..cf2436155b 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsobject.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsobject.c
@@ -6,7 +6,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,9 +42,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __NSOBJECT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -66,7 +63,7 @@
  * RETURN:      Status
  *
  * DESCRIPTION: Record the given object as the value associated with the
- *              name whose ACPI_HANDLE is passed.  If Object is NULL
+ *              name whose ACPI_HANDLE is passed. If Object is NULL
  *              and Type is ACPI_TYPE_ANY, set the name as having no value.
  *              Note: Future may require that the Node->Flags field be passed
  *              as a parameter.
@@ -146,9 +143,9 @@ AcpiNsAttachObject (
     {
         /*
          * Value passed is a name handle and that name has a
-         * non-null value.  Use that name's value and type.
+         * non-null value. Use that name's value and type.
          */
-        ObjDesc    = ((ACPI_NAMESPACE_NODE *) Object)->Object;
+        ObjDesc = ((ACPI_NAMESPACE_NODE *) Object)->Object;
         ObjectType = ((ACPI_NAMESPACE_NODE *) Object)->Type;
     }
 
@@ -198,8 +195,8 @@ AcpiNsAttachObject (
         LastObjDesc->Common.NextObject = Node->Object;
     }
 
-    Node->Type     = (UINT8) ObjectType;
-    Node->Object   = ObjDesc;
+    Node->Type = (UINT8) ObjectType;
+    Node->Object = ObjDesc;
 
     return_ACPI_STATUS (AE_OK);
 }
@@ -247,17 +244,32 @@ AcpiNsDetachObject (
         }
     }
 
-    /* Clear the entry in all cases */
+    /* Clear the Node entry in all cases */
 
     Node->Object = NULL;
     if (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) == ACPI_DESC_TYPE_OPERAND)
     {
+        /* Unlink object from front of possible object list */
+
         Node->Object = ObjDesc->Common.NextObject;
+
+        /* Handle possible 2-descriptor object */
+
         if (Node->Object &&
-           ((Node->Object)->Common.Type != ACPI_TYPE_LOCAL_DATA))
+           (Node->Object->Common.Type != ACPI_TYPE_LOCAL_DATA))
         {
             Node->Object = Node->Object->Common.NextObject;
         }
+
+        /*
+         * Detach the object from any data objects (which are still held by
+         * the namespace node)
+         */
+        if (ObjDesc->Common.NextObject &&
+           ((ObjDesc->Common.NextObject)->Common.Type == ACPI_TYPE_LOCAL_DATA))
+        {
+           ObjDesc->Common.NextObject = NULL;
+        }
     }
 
     /* Reset the node type to untyped */
@@ -354,7 +366,7 @@ AcpiNsGetSecondaryObject (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Low-level attach data.  Create and attach a Data object.
+ * DESCRIPTION: Low-level attach data. Create and attach a Data object.
  *
  ******************************************************************************/
 
@@ -420,7 +432,7 @@ AcpiNsAttachData (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Low-level detach data.  Delete the data node, but the caller
+ * DESCRIPTION: Low-level detach data. Delete the data node, but the caller
  *              is responsible for the actual data.
  *
  ******************************************************************************/
@@ -501,5 +513,3 @@ AcpiNsGetAttachedData (
 
     return (AE_NOT_FOUND);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsparse.c b/usr/src/uts/intel/io/acpica/namespace/nsparse.c
index 2c768c0b69..1ff33362ed 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsparse.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSPARSE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -86,6 +84,22 @@ AcpiNsOneCompleteParse (
     ACPI_FUNCTION_TRACE (NsOneCompleteParse);
 
 
+    Status = AcpiGetTableByIndex (TableIndex, &Table);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Table must consist of at least a complete header */
+
+    if (Table->Length < sizeof (ACPI_TABLE_HEADER))
+    {
+        return_ACPI_STATUS (AE_BAD_HEADER);
+    }
+
+    AmlStart = (UINT8 *) Table + sizeof (ACPI_TABLE_HEADER);
+    AmlLength = Table->Length - sizeof (ACPI_TABLE_HEADER);
+
     Status = AcpiTbGetOwnerId (TableIndex, &OwnerId);
     if (ACPI_FAILURE (Status))
     {
@@ -94,7 +108,7 @@ AcpiNsOneCompleteParse (
 
     /* Create and init a Root Node */
 
-    ParseRoot = AcpiPsCreateScopeOp ();
+    ParseRoot = AcpiPsCreateScopeOp (AmlStart);
     if (!ParseRoot)
     {
         return_ACPI_STATUS (AE_NO_MEMORY);
@@ -109,39 +123,28 @@ AcpiNsOneCompleteParse (
         return_ACPI_STATUS (AE_NO_MEMORY);
     }
 
-    Status = AcpiGetTableByIndex (TableIndex, &Table);
+    Status = AcpiDsInitAmlWalk (WalkState, ParseRoot, NULL,
+        AmlStart, AmlLength, NULL, (UINT8) PassNumber);
     if (ACPI_FAILURE (Status))
     {
         AcpiDsDeleteWalkState (WalkState);
-        AcpiPsFreeOp (ParseRoot);
-        return_ACPI_STATUS (Status);
+        goto Cleanup;
     }
 
-    /* Table must consist of at least a complete header */
+    /* Found OSDT table, enable the namespace override feature */
 
-    if (Table->Length < sizeof (ACPI_TABLE_HEADER))
+    if (ACPI_COMPARE_NAME(Table->Signature, ACPI_SIG_OSDT) &&
+        PassNumber == ACPI_IMODE_LOAD_PASS1)
     {
-        Status = AE_BAD_HEADER;
-    }
-    else
-    {
-        AmlStart = (UINT8 *) Table + sizeof (ACPI_TABLE_HEADER);
-        AmlLength = Table->Length - sizeof (ACPI_TABLE_HEADER);
-        Status = AcpiDsInitAmlWalk (WalkState, ParseRoot, NULL,
-                    AmlStart, AmlLength, NULL, (UINT8) PassNumber);
-    }
-
-    if (ACPI_FAILURE (Status))
-    {
-        AcpiDsDeleteWalkState (WalkState);
-        goto Cleanup;
+        WalkState->NamespaceOverride = TRUE;
     }
 
     /* StartNode is the default location to load the table  */
 
     if (StartNode && StartNode != AcpiGbl_RootNode)
     {
-        Status = AcpiDsScopeStackPush (StartNode, ACPI_TYPE_METHOD, WalkState);
+        Status = AcpiDsScopeStackPush (
+            StartNode, ACPI_TYPE_METHOD, WalkState);
         if (ACPI_FAILURE (Status))
         {
             AcpiDsDeleteWalkState (WalkState);
@@ -151,7 +154,8 @@ AcpiNsOneCompleteParse (
 
     /* Parse the AML */
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "*PARSE* pass %u parse\n", PassNumber));
+    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+        "*PARSE* pass %u parse\n", PassNumber));
     Status = AcpiPsParseAml (WalkState);
 
 Cleanup:
@@ -187,16 +191,17 @@ AcpiNsParseTable (
     /*
      * AML Parse, pass 1
      *
-     * In this pass, we load most of the namespace.  Control methods
-     * are not parsed until later.  A parse tree is not created.  Instead,
-     * each Parser Op subtree is deleted when it is finished.  This saves
+     * In this pass, we load most of the namespace. Control methods
+     * are not parsed until later. A parse tree is not created. Instead,
+     * each Parser Op subtree is deleted when it is finished. This saves
      * a great deal of memory, and allows a small cache of parse objects
-     * to service the entire parse.  The second pass of the parse then
+     * to service the entire parse. The second pass of the parse then
      * performs another complete parse of the AML.
      */
     ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "**** Start pass 1\n"));
+
     Status = AcpiNsOneCompleteParse (ACPI_IMODE_LOAD_PASS1,
-                TableIndex, StartNode);
+        TableIndex, StartNode);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -213,7 +218,7 @@ AcpiNsParseTable (
      */
     ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "**** Start pass 2\n"));
     Status = AcpiNsOneCompleteParse (ACPI_IMODE_LOAD_PASS2,
-                TableIndex, StartNode);
+        TableIndex, StartNode);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -221,5 +226,3 @@ AcpiNsParseTable (
 
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nspredef.c b/usr/src/uts/intel/io/acpica/namespace/nspredef.c
index 3a61aa3666..ccd4aba8f2 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nspredef.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nspredef.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -63,12 +63,12 @@
  * There are several areas that are validated:
  *
  *  1) The number of input arguments as defined by the method/object in the
- *      ASL is validated against the ACPI specification.
+ *     ASL is validated against the ACPI specification.
  *  2) The type of the return object (if any) is validated against the ACPI
- *      specification.
+ *     specification.
  *  3) For returned package objects, the count of package elements is
- *      validated, as well as the type of each package element. Nested
- *      packages are supported.
+ *     validated, as well as the type of each package element. Nested
+ *     packages are supported.
  *
  * For any problems found, a warning message is issued.
  *
@@ -77,64 +77,22 @@
 
 /* Local prototypes */
 
-static ACPI_STATUS
-AcpiNsCheckPackage (
-    ACPI_PREDEFINED_DATA        *Data,
-    ACPI_OPERAND_OBJECT         **ReturnObjectPtr);
-
-static ACPI_STATUS
-AcpiNsCheckPackageList (
-    ACPI_PREDEFINED_DATA        *Data,
-    const ACPI_PREDEFINED_INFO  *Package,
-    ACPI_OPERAND_OBJECT         **Elements,
-    UINT32                      Count);
-
-static ACPI_STATUS
-AcpiNsCheckPackageElements (
-    ACPI_PREDEFINED_DATA        *Data,
-    ACPI_OPERAND_OBJECT         **Elements,
-    UINT8                       Type1,
-    UINT32                      Count1,
-    UINT8                       Type2,
-    UINT32                      Count2,
-    UINT32                      StartIndex);
-
-static ACPI_STATUS
-AcpiNsCheckObjectType (
-    ACPI_PREDEFINED_DATA        *Data,
-    ACPI_OPERAND_OBJECT         **ReturnObjectPtr,
-    UINT32                      ExpectedBtypes,
-    UINT32                      PackageIndex);
-
 static ACPI_STATUS
 AcpiNsCheckReference (
-    ACPI_PREDEFINED_DATA        *Data,
+    ACPI_EVALUATE_INFO          *Info,
     ACPI_OPERAND_OBJECT         *ReturnObject);
 
-static void
-AcpiNsGetExpectedTypes (
-    char                        *Buffer,
-    UINT32                      ExpectedBtypes);
-
-/*
- * Names for the types that can be returned by the predefined objects.
- * Used for warning messages. Must be in the same order as the ACPI_RTYPEs
- */
-static const char   *AcpiRtypeNames[] =
-{
-    "/Integer",
-    "/String",
-    "/Buffer",
-    "/Package",
-    "/Reference",
-};
+static UINT32
+AcpiNsGetBitmappedType (
+    ACPI_OPERAND_OBJECT         *ReturnObject);
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiNsCheckPredefinedNames
+ * FUNCTION:    AcpiNsCheckReturnValue
  *
  * PARAMETERS:  Node            - Namespace node for the method/object
+ *              Info            - Method execution information block
  *              UserParamCount  - Number of parameters actually passed
  *              ReturnStatus    - Status from the object evaluation
  *              ReturnObjectPtr - Pointer to the object returned from the
@@ -142,77 +100,38 @@ static const char   *AcpiRtypeNames[] =
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Check an ACPI name for a match in the predefined name list.
+ * DESCRIPTION: Check the value returned from a predefined name.
  *
  ******************************************************************************/
 
 ACPI_STATUS
-AcpiNsCheckPredefinedNames (
+AcpiNsCheckReturnValue (
     ACPI_NAMESPACE_NODE         *Node,
+    ACPI_EVALUATE_INFO          *Info,
     UINT32                      UserParamCount,
     ACPI_STATUS                 ReturnStatus,
     ACPI_OPERAND_OBJECT         **ReturnObjectPtr)
 {
-    ACPI_OPERAND_OBJECT         *ReturnObject = *ReturnObjectPtr;
-    ACPI_STATUS                 Status = AE_OK;
+    ACPI_STATUS                 Status;
     const ACPI_PREDEFINED_INFO  *Predefined;
-    char                        *Pathname;
-    ACPI_PREDEFINED_DATA        *Data;
-
-
-    /* Match the name for this method/object against the predefined list */
 
-    Predefined = AcpiNsCheckForPredefinedName (Node);
-
-    /* Get the full pathname to the object, for use in warning messages */
-
-    Pathname = AcpiNsGetExternalPathname (Node);
-    if (!Pathname)
-    {
-        return (AE_OK); /* Could not get pathname, ignore */
-    }
-
-    /*
-     * Check that the parameter count for this method matches the ASL
-     * definition. For predefined names, ensure that both the caller and
-     * the method itself are in accordance with the ACPI specification.
-     */
-    AcpiNsCheckParameterCount (Pathname, Node, UserParamCount, Predefined);
 
     /* If not a predefined name, we cannot validate the return object */
 
+    Predefined = Info->Predefined;
     if (!Predefined)
     {
-        goto Cleanup;
+        return (AE_OK);
     }
 
     /*
      * If the method failed or did not actually return an object, we cannot
      * validate the return object
      */
-    if ((ReturnStatus != AE_OK) && (ReturnStatus != AE_CTRL_RETURN_VALUE))
-    {
-        goto Cleanup;
-    }
-
-    /*
-     * If there is no return value, check if we require a return value for
-     * this predefined name. Either one return value is expected, or none,
-     * for both methods and other objects.
-     *
-     * Exit now if there is no return object. Warning if one was expected.
-     */
-    if (!ReturnObject)
+    if ((ReturnStatus != AE_OK) &&
+        (ReturnStatus != AE_CTRL_RETURN_VALUE))
     {
-        if ((Predefined->Info.ExpectedBtypes) &&
-            (!(Predefined->Info.ExpectedBtypes & ACPI_RTYPE_NONE)))
-        {
-            ACPI_WARN_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
-                "Missing expected return value"));
-
-            Status = AE_AML_NO_RETURN_VALUE;
-        }
-        goto Cleanup;
+        return (AE_OK);
     }
 
     /*
@@ -232,43 +151,47 @@ AcpiNsCheckPredefinedNames (
         (!Predefined->Info.ExpectedBtypes) ||
         (Predefined->Info.ExpectedBtypes == ACPI_RTYPE_ALL))
     {
-        goto Cleanup;
-    }
-
-    /* Create the parameter data block for object validation */
-
-    Data = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_PREDEFINED_DATA));
-    if (!Data)
-    {
-        goto Cleanup;
+        return (AE_OK);
     }
-    Data->Predefined = Predefined;
-    Data->Node = Node;
-    Data->NodeFlags = Node->Flags;
-    Data->Pathname = Pathname;
 
     /*
      * Check that the type of the main return object is what is expected
      * for this predefined name
      */
-    Status = AcpiNsCheckObjectType (Data, ReturnObjectPtr,
-                Predefined->Info.ExpectedBtypes, ACPI_NOT_PACKAGE_ELEMENT);
+    Status = AcpiNsCheckObjectType (Info, ReturnObjectPtr,
+        Predefined->Info.ExpectedBtypes, ACPI_NOT_PACKAGE_ELEMENT);
     if (ACPI_FAILURE (Status))
     {
         goto Exit;
     }
 
+    /*
+     *
+     * 4) If there is no return value and it is optional, just return
+     * AE_OK (_WAK).
+     */
+    if (!(*ReturnObjectPtr))
+    {
+        goto Exit;
+    }
+
     /*
      * For returned Package objects, check the type of all sub-objects.
      * Note: Package may have been newly created by call above.
      */
     if ((*ReturnObjectPtr)->Common.Type == ACPI_TYPE_PACKAGE)
     {
-        Data->ParentPackage = *ReturnObjectPtr;
-        Status = AcpiNsCheckPackage (Data, ReturnObjectPtr);
+        Info->ParentPackage = *ReturnObjectPtr;
+        Status = AcpiNsCheckPackage (Info, ReturnObjectPtr);
         if (ACPI_FAILURE (Status))
         {
-            goto Exit;
+            /* We might be able to fix some errors */
+
+            if ((Status != AE_AML_OPERAND_TYPE) &&
+                (Status != AE_AML_OPERAND_VALUE))
+            {
+                goto Exit;
+            }
         }
     }
 
@@ -280,7 +203,7 @@ AcpiNsCheckPredefinedNames (
      * performed on a per-name basis, i.e., the code is specific to
      * particular predefined names.
      */
-    Status = AcpiNsComplexRepairs (Data, Node, Status, ReturnObjectPtr);
+    Status = AcpiNsComplexRepairs (Info, Node, Status, ReturnObjectPtr);
 
 Exit:
     /*
@@ -288,731 +211,13 @@ Exit:
      * or more objects, mark the parent node to suppress further warning
      * messages during the next evaluation of the same method/object.
      */
-    if (ACPI_FAILURE (Status) || (Data->Flags & ACPI_OBJECT_REPAIRED))
+    if (ACPI_FAILURE (Status) ||
+       (Info->ReturnFlags & ACPI_OBJECT_REPAIRED))
     {
         Node->Flags |= ANOBJ_EVALUATED;
     }
-    ACPI_FREE (Data);
-
-Cleanup:
-    ACPI_FREE (Pathname);
-    return (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsCheckParameterCount
- *
- * PARAMETERS:  Pathname        - Full pathname to the node (for error msgs)
- *              Node            - Namespace node for the method/object
- *              UserParamCount  - Number of args passed in by the caller
- *              Predefined      - Pointer to entry in predefined name table
- *
- * RETURN:      None
- *
- * DESCRIPTION: Check that the declared (in ASL/AML) parameter count for a
- *              predefined name is what is expected (i.e., what is defined in
- *              the ACPI specification for this predefined name.)
- *
- ******************************************************************************/
-
-void
-AcpiNsCheckParameterCount (
-    char                        *Pathname,
-    ACPI_NAMESPACE_NODE         *Node,
-    UINT32                      UserParamCount,
-    const ACPI_PREDEFINED_INFO  *Predefined)
-{
-    UINT32                      ParamCount;
-    UINT32                      RequiredParamsCurrent;
-    UINT32                      RequiredParamsOld;
-
-
-    /* Methods have 0-7 parameters. All other types have zero. */
-
-    ParamCount = 0;
-    if (Node->Type == ACPI_TYPE_METHOD)
-    {
-        ParamCount = Node->Object->Method.ParamCount;
-    }
-
-    if (!Predefined)
-    {
-        /*
-         * Check the parameter count for non-predefined methods/objects.
-         *
-         * Warning if too few or too many arguments have been passed by the
-         * caller. An incorrect number of arguments may not cause the method
-         * to fail. However, the method will fail if there are too few
-         * arguments and the method attempts to use one of the missing ones.
-         */
-        if (UserParamCount < ParamCount)
-        {
-            ACPI_WARN_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
-                "Insufficient arguments - needs %u, found %u",
-                ParamCount, UserParamCount));
-        }
-        else if (UserParamCount > ParamCount)
-        {
-            ACPI_WARN_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
-                "Excess arguments - needs %u, found %u",
-                ParamCount, UserParamCount));
-        }
-        return;
-    }
-
-    /*
-     * Validate the user-supplied parameter count.
-     * Allow two different legal argument counts (_SCP, etc.)
-     */
-    RequiredParamsCurrent = Predefined->Info.ParamCount & 0x0F;
-    RequiredParamsOld = Predefined->Info.ParamCount >> 4;
-
-    if (UserParamCount != ACPI_UINT32_MAX)
-    {
-        if ((UserParamCount != RequiredParamsCurrent) &&
-            (UserParamCount != RequiredParamsOld))
-        {
-            ACPI_WARN_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
-                "Parameter count mismatch - "
-                "caller passed %u, ACPI requires %u",
-                UserParamCount, RequiredParamsCurrent));
-        }
-    }
-
-    /*
-     * Check that the ASL-defined parameter count is what is expected for
-     * this predefined name (parameter count as defined by the ACPI
-     * specification)
-     */
-    if ((ParamCount != RequiredParamsCurrent) &&
-        (ParamCount != RequiredParamsOld))
-    {
-        ACPI_WARN_PREDEFINED ((AE_INFO, Pathname, Node->Flags,
-            "Parameter count mismatch - ASL declared %u, ACPI requires %u",
-            ParamCount, RequiredParamsCurrent));
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsCheckForPredefinedName
- *
- * PARAMETERS:  Node            - Namespace node for the method/object
- *
- * RETURN:      Pointer to entry in predefined table. NULL indicates not found.
- *
- * DESCRIPTION: Check an object name against the predefined object list.
- *
- ******************************************************************************/
-
-const ACPI_PREDEFINED_INFO *
-AcpiNsCheckForPredefinedName (
-    ACPI_NAMESPACE_NODE         *Node)
-{
-    const ACPI_PREDEFINED_INFO  *ThisName;
-
-
-    /* Quick check for a predefined name, first character must be underscore */
-
-    if (Node->Name.Ascii[0] != '_')
-    {
-        return (NULL);
-    }
-
-    /* Search info table for a predefined method/object name */
-
-    ThisName = PredefinedNames;
-    while (ThisName->Info.Name[0])
-    {
-        if (ACPI_COMPARE_NAME (Node->Name.Ascii, ThisName->Info.Name))
-        {
-            return (ThisName);
-        }
-
-        /*
-         * Skip next entry in the table if this name returns a Package
-         * (next entry contains the package info)
-         */
-        if (ThisName->Info.ExpectedBtypes & ACPI_RTYPE_PACKAGE)
-        {
-            ThisName++;
-        }
-
-        ThisName++;
-    }
-
-    return (NULL); /* Not found */
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsCheckPackage
- *
- * PARAMETERS:  Data            - Pointer to validation data structure
- *              ReturnObjectPtr - Pointer to the object returned from the
- *                                evaluation of a method or object
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Check a returned package object for the correct count and
- *              correct type of all sub-objects.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiNsCheckPackage (
-    ACPI_PREDEFINED_DATA        *Data,
-    ACPI_OPERAND_OBJECT         **ReturnObjectPtr)
-{
-    ACPI_OPERAND_OBJECT         *ReturnObject = *ReturnObjectPtr;
-    const ACPI_PREDEFINED_INFO  *Package;
-    ACPI_OPERAND_OBJECT         **Elements;
-    ACPI_STATUS                 Status = AE_OK;
-    UINT32                      ExpectedCount;
-    UINT32                      Count;
-    UINT32                      i;
-
-
-    ACPI_FUNCTION_NAME (NsCheckPackage);
-
-
-    /* The package info for this name is in the next table entry */
-
-    Package = Data->Predefined + 1;
-
-    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-        "%s Validating return Package of Type %X, Count %X\n",
-        Data->Pathname, Package->RetInfo.Type, ReturnObject->Package.Count));
-
-    /*
-     * For variable-length Packages, we can safely remove all embedded
-     * and trailing NULL package elements
-     */
-    AcpiNsRemoveNullElements (Data, Package->RetInfo.Type, ReturnObject);
-
-    /* Extract package count and elements array */
-
-    Elements = ReturnObject->Package.Elements;
-    Count = ReturnObject->Package.Count;
-
-    /* The package must have at least one element, else invalid */
-
-    if (!Count)
-    {
-        ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
-            "Return Package has no elements (empty)"));
-
-        return (AE_AML_OPERAND_VALUE);
-    }
-
-    /*
-     * Decode the type of the expected package contents
-     *
-     * PTYPE1 packages contain no subpackages
-     * PTYPE2 packages contain sub-packages
-     */
-    switch (Package->RetInfo.Type)
-    {
-    case ACPI_PTYPE1_FIXED:
-
-        /*
-         * The package count is fixed and there are no sub-packages
-         *
-         * If package is too small, exit.
-         * If package is larger than expected, issue warning but continue
-         */
-        ExpectedCount = Package->RetInfo.Count1 + Package->RetInfo.Count2;
-        if (Count < ExpectedCount)
-        {
-            goto PackageTooSmall;
-        }
-        else if (Count > ExpectedCount)
-        {
-            ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
-                "%s: Return Package is larger than needed - "
-                "found %u, expected %u\n",
-                Data->Pathname, Count, ExpectedCount));
-        }
-
-        /* Validate all elements of the returned package */
-
-        Status = AcpiNsCheckPackageElements (Data, Elements,
-                    Package->RetInfo.ObjectType1, Package->RetInfo.Count1,
-                    Package->RetInfo.ObjectType2, Package->RetInfo.Count2, 0);
-        break;
-
-
-    case ACPI_PTYPE1_VAR:
-
-        /*
-         * The package count is variable, there are no sub-packages, and all
-         * elements must be of the same type
-         */
-        for (i = 0; i < Count; i++)
-        {
-            Status = AcpiNsCheckObjectType (Data, Elements,
-                        Package->RetInfo.ObjectType1, i);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-            Elements++;
-        }
-        break;
-
-
-    case ACPI_PTYPE1_OPTION:
-
-        /*
-         * The package count is variable, there are no sub-packages. There are
-         * a fixed number of required elements, and a variable number of
-         * optional elements.
-         *
-         * Check if package is at least as large as the minimum required
-         */
-        ExpectedCount = Package->RetInfo3.Count;
-        if (Count < ExpectedCount)
-        {
-            goto PackageTooSmall;
-        }
-
-        /* Variable number of sub-objects */
-
-        for (i = 0; i < Count; i++)
-        {
-            if (i < Package->RetInfo3.Count)
-            {
-                /* These are the required package elements (0, 1, or 2) */
-
-                Status = AcpiNsCheckObjectType (Data, Elements,
-                            Package->RetInfo3.ObjectType[i], i);
-                if (ACPI_FAILURE (Status))
-                {
-                    return (Status);
-                }
-            }
-            else
-            {
-                /* These are the optional package elements */
-
-                Status = AcpiNsCheckObjectType (Data, Elements,
-                            Package->RetInfo3.TailObjectType, i);
-                if (ACPI_FAILURE (Status))
-                {
-                    return (Status);
-                }
-            }
-            Elements++;
-        }
-        break;
-
-
-    case ACPI_PTYPE2_REV_FIXED:
-
-        /* First element is the (Integer) revision */
-
-        Status = AcpiNsCheckObjectType (Data, Elements,
-                    ACPI_RTYPE_INTEGER, 0);
-        if (ACPI_FAILURE (Status))
-        {
-            return (Status);
-        }
-
-        Elements++;
-        Count--;
-
-        /* Examine the sub-packages */
-
-        Status = AcpiNsCheckPackageList (Data, Package, Elements, Count);
-        break;
-
-
-    case ACPI_PTYPE2_PKG_COUNT:
-
-        /* First element is the (Integer) count of sub-packages to follow */
-
-        Status = AcpiNsCheckObjectType (Data, Elements,
-                    ACPI_RTYPE_INTEGER, 0);
-        if (ACPI_FAILURE (Status))
-        {
-            return (Status);
-        }
-
-        /*
-         * Count cannot be larger than the parent package length, but allow it
-         * to be smaller. The >= accounts for the Integer above.
-         */
-        ExpectedCount = (UINT32) (*Elements)->Integer.Value;
-        if (ExpectedCount >= Count)
-        {
-            goto PackageTooSmall;
-        }
-
-        Count = ExpectedCount;
-        Elements++;
-
-        /* Examine the sub-packages */
-
-        Status = AcpiNsCheckPackageList (Data, Package, Elements, Count);
-        break;
-
-
-    case ACPI_PTYPE2:
-    case ACPI_PTYPE2_FIXED:
-    case ACPI_PTYPE2_MIN:
-    case ACPI_PTYPE2_COUNT:
-    case ACPI_PTYPE2_FIX_VAR:
-
-        /*
-         * These types all return a single Package that consists of a
-         * variable number of sub-Packages.
-         *
-         * First, ensure that the first element is a sub-Package. If not,
-         * the BIOS may have incorrectly returned the object as a single
-         * package instead of a Package of Packages (a common error if
-         * there is only one entry). We may be able to repair this by
-         * wrapping the returned Package with a new outer Package.
-         */
-        if (*Elements && ((*Elements)->Common.Type != ACPI_TYPE_PACKAGE))
-        {
-            /* Create the new outer package and populate it */
-
-            Status = AcpiNsWrapWithPackage (Data, *Elements, ReturnObjectPtr);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-
-            /* Update locals to point to the new package (of 1 element) */
-
-            ReturnObject = *ReturnObjectPtr;
-            Elements = ReturnObject->Package.Elements;
-            Count = 1;
-        }
-
-        /* Examine the sub-packages */
-
-        Status = AcpiNsCheckPackageList (Data, Package, Elements, Count);
-        break;
-
-
-    default:
-
-        /* Should not get here if predefined info table is correct */
-
-        ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
-            "Invalid internal return type in table entry: %X",
-            Package->RetInfo.Type));
-
-        return (AE_AML_INTERNAL);
-    }
 
     return (Status);
-
-
-PackageTooSmall:
-
-    /* Error exit for the case with an incorrect package count */
-
-    ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
-        "Return Package is too small - found %u elements, expected %u",
-        Count, ExpectedCount));
-
-    return (AE_AML_OPERAND_VALUE);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsCheckPackageList
- *
- * PARAMETERS:  Data            - Pointer to validation data structure
- *              Package         - Pointer to package-specific info for method
- *              Elements        - Element list of parent package. All elements
- *                                of this list should be of type Package.
- *              Count           - Count of subpackages
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Examine a list of subpackages
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiNsCheckPackageList (
-    ACPI_PREDEFINED_DATA        *Data,
-    const ACPI_PREDEFINED_INFO  *Package,
-    ACPI_OPERAND_OBJECT         **Elements,
-    UINT32                      Count)
-{
-    ACPI_OPERAND_OBJECT         *SubPackage;
-    ACPI_OPERAND_OBJECT         **SubElements;
-    ACPI_STATUS                 Status;
-    UINT32                      ExpectedCount;
-    UINT32                      i;
-    UINT32                      j;
-
-
-    /*
-     * Validate each sub-Package in the parent Package
-     *
-     * NOTE: assumes list of sub-packages contains no NULL elements.
-     * Any NULL elements should have been removed by earlier call
-     * to AcpiNsRemoveNullElements.
-     */
-    for (i = 0; i < Count; i++)
-    {
-        SubPackage = *Elements;
-        SubElements = SubPackage->Package.Elements;
-        Data->ParentPackage = SubPackage;
-
-        /* Each sub-object must be of type Package */
-
-        Status = AcpiNsCheckObjectType (Data, &SubPackage,
-                    ACPI_RTYPE_PACKAGE, i);
-        if (ACPI_FAILURE (Status))
-        {
-            return (Status);
-        }
-
-        /* Examine the different types of expected sub-packages */
-
-        Data->ParentPackage = SubPackage;
-        switch (Package->RetInfo.Type)
-        {
-        case ACPI_PTYPE2:
-        case ACPI_PTYPE2_PKG_COUNT:
-        case ACPI_PTYPE2_REV_FIXED:
-
-            /* Each subpackage has a fixed number of elements */
-
-            ExpectedCount = Package->RetInfo.Count1 + Package->RetInfo.Count2;
-            if (SubPackage->Package.Count < ExpectedCount)
-            {
-                goto PackageTooSmall;
-            }
-
-            Status = AcpiNsCheckPackageElements (Data, SubElements,
-                        Package->RetInfo.ObjectType1,
-                        Package->RetInfo.Count1,
-                        Package->RetInfo.ObjectType2,
-                        Package->RetInfo.Count2, 0);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-            break;
-
-
-        case ACPI_PTYPE2_FIX_VAR:
-            /*
-             * Each subpackage has a fixed number of elements and an
-             * optional element
-             */
-            ExpectedCount = Package->RetInfo.Count1 + Package->RetInfo.Count2;
-            if (SubPackage->Package.Count < ExpectedCount)
-            {
-                goto PackageTooSmall;
-            }
-
-            Status = AcpiNsCheckPackageElements (Data, SubElements,
-                        Package->RetInfo.ObjectType1,
-                        Package->RetInfo.Count1,
-                        Package->RetInfo.ObjectType2,
-                        SubPackage->Package.Count - Package->RetInfo.Count1, 0);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-            break;
-
-
-        case ACPI_PTYPE2_FIXED:
-
-            /* Each sub-package has a fixed length */
-
-            ExpectedCount = Package->RetInfo2.Count;
-            if (SubPackage->Package.Count < ExpectedCount)
-            {
-                goto PackageTooSmall;
-            }
-
-            /* Check the type of each sub-package element */
-
-            for (j = 0; j < ExpectedCount; j++)
-            {
-                Status = AcpiNsCheckObjectType (Data, &SubElements[j],
-                            Package->RetInfo2.ObjectType[j], j);
-                if (ACPI_FAILURE (Status))
-                {
-                    return (Status);
-                }
-            }
-            break;
-
-
-        case ACPI_PTYPE2_MIN:
-
-            /* Each sub-package has a variable but minimum length */
-
-            ExpectedCount = Package->RetInfo.Count1;
-            if (SubPackage->Package.Count < ExpectedCount)
-            {
-                goto PackageTooSmall;
-            }
-
-            /* Check the type of each sub-package element */
-
-            Status = AcpiNsCheckPackageElements (Data, SubElements,
-                        Package->RetInfo.ObjectType1,
-                        SubPackage->Package.Count, 0, 0, 0);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-            break;
-
-
-        case ACPI_PTYPE2_COUNT:
-
-            /*
-             * First element is the (Integer) count of elements, including
-             * the count field (the ACPI name is NumElements)
-             */
-            Status = AcpiNsCheckObjectType (Data, SubElements,
-                        ACPI_RTYPE_INTEGER, 0);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-
-            /*
-             * Make sure package is large enough for the Count and is
-             * is as large as the minimum size
-             */
-            ExpectedCount = (UINT32) (*SubElements)->Integer.Value;
-            if (SubPackage->Package.Count < ExpectedCount)
-            {
-                goto PackageTooSmall;
-            }
-            if (SubPackage->Package.Count < Package->RetInfo.Count1)
-            {
-                ExpectedCount = Package->RetInfo.Count1;
-                goto PackageTooSmall;
-            }
-            if (ExpectedCount == 0)
-            {
-                /*
-                 * Either the NumEntries element was originally zero or it was
-                 * a NULL element and repaired to an Integer of value zero.
-                 * In either case, repair it by setting NumEntries to be the
-                 * actual size of the subpackage.
-                 */
-                ExpectedCount = SubPackage->Package.Count;
-                (*SubElements)->Integer.Value = ExpectedCount;
-            }
-
-            /* Check the type of each sub-package element */
-
-            Status = AcpiNsCheckPackageElements (Data, (SubElements + 1),
-                        Package->RetInfo.ObjectType1,
-                        (ExpectedCount - 1), 0, 0, 1);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-            break;
-
-
-        default: /* Should not get here, type was validated by caller */
-
-            return (AE_AML_INTERNAL);
-        }
-
-        Elements++;
-    }
-
-    return (AE_OK);
-
-
-PackageTooSmall:
-
-    /* The sub-package count was smaller than required */
-
-    ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
-        "Return Sub-Package[%u] is too small - found %u elements, expected %u",
-        i, SubPackage->Package.Count, ExpectedCount));
-
-    return (AE_AML_OPERAND_VALUE);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsCheckPackageElements
- *
- * PARAMETERS:  Data            - Pointer to validation data structure
- *              Elements        - Pointer to the package elements array
- *              Type1           - Object type for first group
- *              Count1          - Count for first group
- *              Type2           - Object type for second group
- *              Count2          - Count for second group
- *              StartIndex      - Start of the first group of elements
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Check that all elements of a package are of the correct object
- *              type. Supports up to two groups of different object types.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiNsCheckPackageElements (
-    ACPI_PREDEFINED_DATA        *Data,
-    ACPI_OPERAND_OBJECT         **Elements,
-    UINT8                       Type1,
-    UINT32                      Count1,
-    UINT8                       Type2,
-    UINT32                      Count2,
-    UINT32                      StartIndex)
-{
-    ACPI_OPERAND_OBJECT         **ThisElement = Elements;
-    ACPI_STATUS                 Status;
-    UINT32                      i;
-
-
-    /*
-     * Up to two groups of package elements are supported by the data
-     * structure. All elements in each group must be of the same type.
-     * The second group can have a count of zero.
-     */
-    for (i = 0; i < Count1; i++)
-    {
-        Status = AcpiNsCheckObjectType (Data, ThisElement,
-                    Type1, i + StartIndex);
-        if (ACPI_FAILURE (Status))
-        {
-            return (Status);
-        }
-        ThisElement++;
-    }
-
-    for (i = 0; i < Count2; i++)
-    {
-        Status = AcpiNsCheckObjectType (Data, ThisElement,
-                    Type2, (i + Count1 + StartIndex));
-        if (ACPI_FAILURE (Status))
-        {
-            return (Status);
-        }
-        ThisElement++;
-    }
-
-    return (AE_OK);
 }
 
 
@@ -1020,7 +225,7 @@ AcpiNsCheckPackageElements (
  *
  * FUNCTION:    AcpiNsCheckObjectType
  *
- * PARAMETERS:  Data            - Pointer to validation data structure
+ * PARAMETERS:  Info            - Method execution information block
  *              ReturnObjectPtr - Pointer to the object returned from the
  *                                evaluation of a method or object
  *              ExpectedBtypes  - Bitmap of expected return type(s)
@@ -1035,41 +240,24 @@ AcpiNsCheckPackageElements (
  *
  ******************************************************************************/
 
-static ACPI_STATUS
+ACPI_STATUS
 AcpiNsCheckObjectType (
-    ACPI_PREDEFINED_DATA        *Data,
+    ACPI_EVALUATE_INFO          *Info,
     ACPI_OPERAND_OBJECT         **ReturnObjectPtr,
     UINT32                      ExpectedBtypes,
     UINT32                      PackageIndex)
 {
     ACPI_OPERAND_OBJECT         *ReturnObject = *ReturnObjectPtr;
     ACPI_STATUS                 Status = AE_OK;
-    UINT32                      ReturnBtype;
-    char                        TypeBuffer[48]; /* Room for 5 types */
-
+    char                        TypeBuffer[96]; /* Room for 10 types */
 
-    /*
-     * If we get a NULL ReturnObject here, it is a NULL package element.
-     * Since all extraneous NULL package elements were removed earlier by a
-     * call to AcpiNsRemoveNullElements, this is an unexpected NULL element.
-     * We will attempt to repair it.
-     */
-    if (!ReturnObject)
-    {
-        Status = AcpiNsRepairNullElement (Data, ExpectedBtypes,
-                    PackageIndex, ReturnObjectPtr);
-        if (ACPI_SUCCESS (Status))
-        {
-            return (AE_OK); /* Repair was successful */
-        }
-        goto TypeErrorExit;
-    }
 
     /* A Namespace node should not get here, but make sure */
 
-    if (ACPI_GET_DESCRIPTOR_TYPE (ReturnObject) == ACPI_DESC_TYPE_NAMED)
+    if (ReturnObject &&
+        ACPI_GET_DESCRIPTOR_TYPE (ReturnObject) == ACPI_DESC_TYPE_NAMED)
     {
-        ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
+        ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
             "Invalid return type - Found a Namespace node [%4.4s] type %s",
             ReturnObject->Node.Name.Ascii,
             AcpiUtGetTypeName (ReturnObject->Node.Type)));
@@ -1084,55 +272,28 @@ AcpiNsCheckObjectType (
      * from all of the predefined names (including elements of returned
      * packages)
      */
-    switch (ReturnObject->Common.Type)
+    Info->ReturnBtype = AcpiNsGetBitmappedType (ReturnObject);
+    if (Info->ReturnBtype == ACPI_RTYPE_ANY)
     {
-    case ACPI_TYPE_INTEGER:
-        ReturnBtype = ACPI_RTYPE_INTEGER;
-        break;
-
-    case ACPI_TYPE_BUFFER:
-        ReturnBtype = ACPI_RTYPE_BUFFER;
-        break;
-
-    case ACPI_TYPE_STRING:
-        ReturnBtype = ACPI_RTYPE_STRING;
-        break;
-
-    case ACPI_TYPE_PACKAGE:
-        ReturnBtype = ACPI_RTYPE_PACKAGE;
-        break;
-
-    case ACPI_TYPE_LOCAL_REFERENCE:
-        ReturnBtype = ACPI_RTYPE_REFERENCE;
-        break;
-
-    default:
         /* Not one of the supported objects, must be incorrect */
-
         goto TypeErrorExit;
     }
 
-    /* Is the object one of the expected types? */
+    /* For reference objects, check that the reference type is correct */
 
-    if (ReturnBtype & ExpectedBtypes)
+    if ((Info->ReturnBtype & ExpectedBtypes) == ACPI_RTYPE_REFERENCE)
     {
-        /* For reference objects, check that the reference type is correct */
-
-        if (ReturnObject->Common.Type == ACPI_TYPE_LOCAL_REFERENCE)
-        {
-            Status = AcpiNsCheckReference (Data, ReturnObject);
-        }
-
+        Status = AcpiNsCheckReference (Info, ReturnObject);
         return (Status);
     }
 
-    /* Type mismatch -- attempt repair of the returned object */
+    /* Attempt simple repair of the returned object if necessary */
 
-    Status = AcpiNsRepairObject (Data, ExpectedBtypes,
-                PackageIndex, ReturnObjectPtr);
+    Status = AcpiNsSimpleRepair (Info, ExpectedBtypes,
+        PackageIndex, ReturnObjectPtr);
     if (ACPI_SUCCESS (Status))
     {
-        return (AE_OK); /* Repair was successful */
+        return (AE_OK); /* Successful repair */
     }
 
 
@@ -1140,17 +301,23 @@ TypeErrorExit:
 
     /* Create a string with all expected types for this predefined object */
 
-    AcpiNsGetExpectedTypes (TypeBuffer, ExpectedBtypes);
+    AcpiUtGetExpectedReturnTypes (TypeBuffer, ExpectedBtypes);
 
-    if (PackageIndex == ACPI_NOT_PACKAGE_ELEMENT)
+    if (!ReturnObject)
     {
-        ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
+        ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
+            "Expected return object of type %s",
+            TypeBuffer));
+    }
+    else if (PackageIndex == ACPI_NOT_PACKAGE_ELEMENT)
+    {
+        ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
             "Return type mismatch - found %s, expected %s",
             AcpiUtGetObjectTypeName (ReturnObject), TypeBuffer));
     }
     else
     {
-        ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
+        ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
             "Return Package type mismatch at index %u - "
             "found %s, expected %s", PackageIndex,
             AcpiUtGetObjectTypeName (ReturnObject), TypeBuffer));
@@ -1164,7 +331,7 @@ TypeErrorExit:
  *
  * FUNCTION:    AcpiNsCheckReference
  *
- * PARAMETERS:  Data            - Pointer to validation data structure
+ * PARAMETERS:  Info            - Method execution information block
  *              ReturnObject    - Object returned from the evaluation of a
  *                                method or object
  *
@@ -1178,7 +345,7 @@ TypeErrorExit:
 
 static ACPI_STATUS
 AcpiNsCheckReference (
-    ACPI_PREDEFINED_DATA        *Data,
+    ACPI_EVALUATE_INFO          *Info,
     ACPI_OPERAND_OBJECT         *ReturnObject)
 {
 
@@ -1192,7 +359,7 @@ AcpiNsCheckReference (
         return (AE_OK);
     }
 
-    ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
+    ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
         "Return type mismatch - unexpected reference object type [%s] %2.2X",
         AcpiUtGetReferenceName (ReturnObject),
         ReturnObject->Reference.Class));
@@ -1203,41 +370,66 @@ AcpiNsCheckReference (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiNsGetExpectedTypes
+ * FUNCTION:    AcpiNsGetBitmappedType
  *
- * PARAMETERS:  Buffer          - Pointer to where the string is returned
- *              ExpectedBtypes  - Bitmap of expected return type(s)
+ * PARAMETERS:  ReturnObject    - Object returned from method/obj evaluation
  *
- * RETURN:      Buffer is populated with type names.
+ * RETURN:      Object return type. ACPI_RTYPE_ANY indicates that the object
+ *              type is not supported. ACPI_RTYPE_NONE indicates that no
+ *              object was returned (ReturnObject is NULL).
  *
- * DESCRIPTION: Translate the expected types bitmap into a string of ascii
- *              names of expected types, for use in warning messages.
+ * DESCRIPTION: Convert object type into a bitmapped object return type.
  *
  ******************************************************************************/
 
-static void
-AcpiNsGetExpectedTypes (
-    char                        *Buffer,
-    UINT32                      ExpectedBtypes)
+static UINT32
+AcpiNsGetBitmappedType (
+    ACPI_OPERAND_OBJECT         *ReturnObject)
 {
-    UINT32                      ThisRtype;
-    UINT32                      i;
-    UINT32                      j;
+    UINT32                      ReturnBtype;
+
 
+    if (!ReturnObject)
+    {
+        return (ACPI_RTYPE_NONE);
+    }
 
-    j = 1;
-    Buffer[0] = 0;
-    ThisRtype = ACPI_RTYPE_INTEGER;
+    /* Map ACPI_OBJECT_TYPE to internal bitmapped type */
 
-    for (i = 0; i < ACPI_NUM_RTYPES; i++)
+    switch (ReturnObject->Common.Type)
     {
-        /* If one of the expected types, concatenate the name of this type */
+    case ACPI_TYPE_INTEGER:
 
-        if (ExpectedBtypes & ThisRtype)
-        {
-            ACPI_STRCAT (Buffer, &AcpiRtypeNames[i][j]);
-            j = 0;              /* Use name separator from now on */
-        }
-        ThisRtype <<= 1;    /* Next Rtype */
+        ReturnBtype = ACPI_RTYPE_INTEGER;
+        break;
+
+    case ACPI_TYPE_BUFFER:
+
+        ReturnBtype = ACPI_RTYPE_BUFFER;
+        break;
+
+    case ACPI_TYPE_STRING:
+
+        ReturnBtype = ACPI_RTYPE_STRING;
+        break;
+
+    case ACPI_TYPE_PACKAGE:
+
+        ReturnBtype = ACPI_RTYPE_PACKAGE;
+        break;
+
+    case ACPI_TYPE_LOCAL_REFERENCE:
+
+        ReturnBtype = ACPI_RTYPE_REFERENCE;
+        break;
+
+    default:
+
+        /* Not one of the supported objects, must be incorrect */
+
+        ReturnBtype = ACPI_RTYPE_ANY;
+        break;
     }
+
+    return (ReturnBtype);
 }
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsprepkg.c b/usr/src/uts/intel/io/acpica/namespace/nsprepkg.c
new file mode 100644
index 0000000000..ae75c1a018
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/namespace/nsprepkg.c
@@ -0,0 +1,788 @@
+/******************************************************************************
+ *
+ * Module Name: nsprepkg - Validation of package objects for predefined names
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acnamesp.h"
+#include "acpredef.h"
+
+
+#define _COMPONENT          ACPI_NAMESPACE
+        ACPI_MODULE_NAME    ("nsprepkg")
+
+
+/* Local prototypes */
+
+static ACPI_STATUS
+AcpiNsCheckPackageList (
+    ACPI_EVALUATE_INFO          *Info,
+    const ACPI_PREDEFINED_INFO  *Package,
+    ACPI_OPERAND_OBJECT         **Elements,
+    UINT32                      Count);
+
+static ACPI_STATUS
+AcpiNsCheckPackageElements (
+    ACPI_EVALUATE_INFO          *Info,
+    ACPI_OPERAND_OBJECT         **Elements,
+    UINT8                       Type1,
+    UINT32                      Count1,
+    UINT8                       Type2,
+    UINT32                      Count2,
+    UINT32                      StartIndex);
+
+static ACPI_STATUS
+AcpiNsCustomPackage (
+    ACPI_EVALUATE_INFO          *Info,
+    ACPI_OPERAND_OBJECT         **Elements,
+    UINT32                      Count);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsCheckPackage
+ *
+ * PARAMETERS:  Info                - Method execution information block
+ *              ReturnObjectPtr     - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check a returned package object for the correct count and
+ *              correct type of all sub-objects.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiNsCheckPackage (
+    ACPI_EVALUATE_INFO          *Info,
+    ACPI_OPERAND_OBJECT         **ReturnObjectPtr)
+{
+    ACPI_OPERAND_OBJECT         *ReturnObject = *ReturnObjectPtr;
+    const ACPI_PREDEFINED_INFO  *Package;
+    ACPI_OPERAND_OBJECT         **Elements;
+    ACPI_STATUS                 Status = AE_OK;
+    UINT32                      ExpectedCount;
+    UINT32                      Count;
+    UINT32                      i;
+
+
+    ACPI_FUNCTION_NAME (NsCheckPackage);
+
+
+    /* The package info for this name is in the next table entry */
+
+    Package = Info->Predefined + 1;
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+        "%s Validating return Package of Type %X, Count %X\n",
+        Info->FullPathname, Package->RetInfo.Type,
+        ReturnObject->Package.Count));
+
+    /*
+     * For variable-length Packages, we can safely remove all embedded
+     * and trailing NULL package elements
+     */
+    AcpiNsRemoveNullElements (Info, Package->RetInfo.Type, ReturnObject);
+
+    /* Extract package count and elements array */
+
+    Elements = ReturnObject->Package.Elements;
+    Count = ReturnObject->Package.Count;
+
+    /*
+     * Most packages must have at least one element. The only exception
+     * is the variable-length package (ACPI_PTYPE1_VAR).
+     */
+    if (!Count)
+    {
+        if (Package->RetInfo.Type == ACPI_PTYPE1_VAR)
+        {
+            return (AE_OK);
+        }
+
+        ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
+            "Return Package has no elements (empty)"));
+
+        return (AE_AML_OPERAND_VALUE);
+    }
+
+    /*
+     * Decode the type of the expected package contents
+     *
+     * PTYPE1 packages contain no subpackages
+     * PTYPE2 packages contain subpackages
+     */
+    switch (Package->RetInfo.Type)
+    {
+    case ACPI_PTYPE_CUSTOM:
+
+        Status = AcpiNsCustomPackage (Info, Elements, Count);
+        break;
+
+    case ACPI_PTYPE1_FIXED:
+        /*
+         * The package count is fixed and there are no subpackages
+         *
+         * If package is too small, exit.
+         * If package is larger than expected, issue warning but continue
+         */
+        ExpectedCount = Package->RetInfo.Count1 + Package->RetInfo.Count2;
+        if (Count < ExpectedCount)
+        {
+            goto PackageTooSmall;
+        }
+        else if (Count > ExpectedCount)
+        {
+            ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
+                "%s: Return Package is larger than needed - "
+                "found %u, expected %u\n",
+                Info->FullPathname, Count, ExpectedCount));
+        }
+
+        /* Validate all elements of the returned package */
+
+        Status = AcpiNsCheckPackageElements (Info, Elements,
+            Package->RetInfo.ObjectType1, Package->RetInfo.Count1,
+            Package->RetInfo.ObjectType2, Package->RetInfo.Count2, 0);
+        break;
+
+    case ACPI_PTYPE1_VAR:
+        /*
+         * The package count is variable, there are no subpackages, and all
+         * elements must be of the same type
+         */
+        for (i = 0; i < Count; i++)
+        {
+            Status = AcpiNsCheckObjectType (Info, Elements,
+                Package->RetInfo.ObjectType1, i);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            Elements++;
+        }
+        break;
+
+    case ACPI_PTYPE1_OPTION:
+        /*
+         * The package count is variable, there are no subpackages. There are
+         * a fixed number of required elements, and a variable number of
+         * optional elements.
+         *
+         * Check if package is at least as large as the minimum required
+         */
+        ExpectedCount = Package->RetInfo3.Count;
+        if (Count < ExpectedCount)
+        {
+            goto PackageTooSmall;
+        }
+
+        /* Variable number of sub-objects */
+
+        for (i = 0; i < Count; i++)
+        {
+            if (i < Package->RetInfo3.Count)
+            {
+                /* These are the required package elements (0, 1, or 2) */
+
+                Status = AcpiNsCheckObjectType (Info, Elements,
+                    Package->RetInfo3.ObjectType[i], i);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+            }
+            else
+            {
+                /* These are the optional package elements */
+
+                Status = AcpiNsCheckObjectType (Info, Elements,
+                    Package->RetInfo3.TailObjectType, i);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+            }
+
+            Elements++;
+        }
+        break;
+
+    case ACPI_PTYPE2_REV_FIXED:
+
+        /* First element is the (Integer) revision */
+
+        Status = AcpiNsCheckObjectType (
+            Info, Elements, ACPI_RTYPE_INTEGER, 0);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        Elements++;
+        Count--;
+
+        /* Examine the subpackages */
+
+        Status = AcpiNsCheckPackageList (Info, Package, Elements, Count);
+        break;
+
+    case ACPI_PTYPE2_PKG_COUNT:
+
+        /* First element is the (Integer) count of subpackages to follow */
+
+        Status = AcpiNsCheckObjectType (
+            Info, Elements, ACPI_RTYPE_INTEGER, 0);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        /*
+         * Count cannot be larger than the parent package length, but allow it
+         * to be smaller. The >= accounts for the Integer above.
+         */
+        ExpectedCount = (UINT32) (*Elements)->Integer.Value;
+        if (ExpectedCount >= Count)
+        {
+            goto PackageTooSmall;
+        }
+
+        Count = ExpectedCount;
+        Elements++;
+
+        /* Examine the subpackages */
+
+        Status = AcpiNsCheckPackageList (Info, Package, Elements, Count);
+        break;
+
+    case ACPI_PTYPE2:
+    case ACPI_PTYPE2_FIXED:
+    case ACPI_PTYPE2_MIN:
+    case ACPI_PTYPE2_COUNT:
+    case ACPI_PTYPE2_FIX_VAR:
+        /*
+         * These types all return a single Package that consists of a
+         * variable number of subpackages.
+         *
+         * First, ensure that the first element is a subpackage. If not,
+         * the BIOS may have incorrectly returned the object as a single
+         * package instead of a Package of Packages (a common error if
+         * there is only one entry). We may be able to repair this by
+         * wrapping the returned Package with a new outer Package.
+         */
+        if (*Elements && ((*Elements)->Common.Type != ACPI_TYPE_PACKAGE))
+        {
+            /* Create the new outer package and populate it */
+
+            Status = AcpiNsWrapWithPackage (
+                Info, ReturnObject, ReturnObjectPtr);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            /* Update locals to point to the new package (of 1 element) */
+
+            ReturnObject = *ReturnObjectPtr;
+            Elements = ReturnObject->Package.Elements;
+            Count = 1;
+        }
+
+        /* Examine the subpackages */
+
+        Status = AcpiNsCheckPackageList (Info, Package, Elements, Count);
+        break;
+
+    case ACPI_PTYPE2_VAR_VAR:
+        /*
+         * Returns a variable list of packages, each with a variable list
+         * of objects.
+         */
+        break;
+
+    case ACPI_PTYPE2_UUID_PAIR:
+
+        /* The package must contain pairs of (UUID + type) */
+
+        if (Count & 1)
+        {
+            ExpectedCount = Count + 1;
+            goto PackageTooSmall;
+        }
+
+        while (Count > 0)
+        {
+            Status = AcpiNsCheckObjectType(Info, Elements,
+                Package->RetInfo.ObjectType1, 0);
+            if (ACPI_FAILURE(Status))
+            {
+                return (Status);
+            }
+
+            /* Validate length of the UUID buffer */
+
+            if ((*Elements)->Buffer.Length != 16)
+            {
+                ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname,
+                    Info->NodeFlags, "Invalid length for UUID Buffer"));
+                return (AE_AML_OPERAND_VALUE);
+            }
+
+            Status = AcpiNsCheckObjectType(Info, Elements + 1,
+                Package->RetInfo.ObjectType2, 0);
+            if (ACPI_FAILURE(Status))
+            {
+                return (Status);
+            }
+
+            Elements += 2;
+            Count -= 2;
+        }
+        break;
+
+    default:
+
+        /* Should not get here if predefined info table is correct */
+
+        ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
+            "Invalid internal return type in table entry: %X",
+            Package->RetInfo.Type));
+
+        return (AE_AML_INTERNAL);
+    }
+
+    return (Status);
+
+
+PackageTooSmall:
+
+    /* Error exit for the case with an incorrect package count */
+
+    ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
+        "Return Package is too small - found %u elements, expected %u",
+        Count, ExpectedCount));
+
+    return (AE_AML_OPERAND_VALUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsCheckPackageList
+ *
+ * PARAMETERS:  Info            - Method execution information block
+ *              Package         - Pointer to package-specific info for method
+ *              Elements        - Element list of parent package. All elements
+ *                                of this list should be of type Package.
+ *              Count           - Count of subpackages
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Examine a list of subpackages
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiNsCheckPackageList (
+    ACPI_EVALUATE_INFO          *Info,
+    const ACPI_PREDEFINED_INFO  *Package,
+    ACPI_OPERAND_OBJECT         **Elements,
+    UINT32                      Count)
+{
+    ACPI_OPERAND_OBJECT         *SubPackage;
+    ACPI_OPERAND_OBJECT         **SubElements;
+    ACPI_STATUS                 Status;
+    UINT32                      ExpectedCount;
+    UINT32                      i;
+    UINT32                      j;
+
+
+    /*
+     * Validate each subpackage in the parent Package
+     *
+     * NOTE: assumes list of subpackages contains no NULL elements.
+     * Any NULL elements should have been removed by earlier call
+     * to AcpiNsRemoveNullElements.
+     */
+    for (i = 0; i < Count; i++)
+    {
+        SubPackage = *Elements;
+        SubElements = SubPackage->Package.Elements;
+        Info->ParentPackage = SubPackage;
+
+        /* Each sub-object must be of type Package */
+
+        Status = AcpiNsCheckObjectType (Info, &SubPackage,
+            ACPI_RTYPE_PACKAGE, i);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        /* Examine the different types of expected subpackages */
+
+        Info->ParentPackage = SubPackage;
+        switch (Package->RetInfo.Type)
+        {
+        case ACPI_PTYPE2:
+        case ACPI_PTYPE2_PKG_COUNT:
+        case ACPI_PTYPE2_REV_FIXED:
+
+            /* Each subpackage has a fixed number of elements */
+
+            ExpectedCount = Package->RetInfo.Count1 + Package->RetInfo.Count2;
+            if (SubPackage->Package.Count < ExpectedCount)
+            {
+                goto PackageTooSmall;
+            }
+
+            Status = AcpiNsCheckPackageElements (Info, SubElements,
+                Package->RetInfo.ObjectType1,
+                Package->RetInfo.Count1,
+                Package->RetInfo.ObjectType2,
+                Package->RetInfo.Count2, 0);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+            break;
+
+        case ACPI_PTYPE2_FIX_VAR:
+            /*
+             * Each subpackage has a fixed number of elements and an
+             * optional element
+             */
+            ExpectedCount = Package->RetInfo.Count1 + Package->RetInfo.Count2;
+            if (SubPackage->Package.Count < ExpectedCount)
+            {
+                goto PackageTooSmall;
+            }
+
+            Status = AcpiNsCheckPackageElements (Info, SubElements,
+                Package->RetInfo.ObjectType1,
+                Package->RetInfo.Count1,
+                Package->RetInfo.ObjectType2,
+                SubPackage->Package.Count - Package->RetInfo.Count1, 0);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+            break;
+
+        case ACPI_PTYPE2_VAR_VAR:
+            /*
+             * Each subpackage has a fixed or variable number of elements
+             */
+            break;
+
+        case ACPI_PTYPE2_FIXED:
+
+            /* Each subpackage has a fixed length */
+
+            ExpectedCount = Package->RetInfo2.Count;
+            if (SubPackage->Package.Count < ExpectedCount)
+            {
+                goto PackageTooSmall;
+            }
+
+            /* Check the type of each subpackage element */
+
+            for (j = 0; j < ExpectedCount; j++)
+            {
+                Status = AcpiNsCheckObjectType (Info, &SubElements[j],
+                    Package->RetInfo2.ObjectType[j], j);
+                if (ACPI_FAILURE (Status))
+                {
+                    return (Status);
+                }
+            }
+            break;
+
+        case ACPI_PTYPE2_MIN:
+
+            /* Each subpackage has a variable but minimum length */
+
+            ExpectedCount = Package->RetInfo.Count1;
+            if (SubPackage->Package.Count < ExpectedCount)
+            {
+                goto PackageTooSmall;
+            }
+
+            /* Check the type of each subpackage element */
+
+            Status = AcpiNsCheckPackageElements (Info, SubElements,
+                Package->RetInfo.ObjectType1,
+                SubPackage->Package.Count, 0, 0, 0);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+            break;
+
+        case ACPI_PTYPE2_COUNT:
+            /*
+             * First element is the (Integer) count of elements, including
+             * the count field (the ACPI name is NumElements)
+             */
+            Status = AcpiNsCheckObjectType (Info, SubElements,
+                ACPI_RTYPE_INTEGER, 0);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+
+            /*
+             * Make sure package is large enough for the Count and is
+             * is as large as the minimum size
+             */
+            ExpectedCount = (UINT32) (*SubElements)->Integer.Value;
+            if (SubPackage->Package.Count < ExpectedCount)
+            {
+                goto PackageTooSmall;
+            }
+
+            if (SubPackage->Package.Count < Package->RetInfo.Count1)
+            {
+                ExpectedCount = Package->RetInfo.Count1;
+                goto PackageTooSmall;
+            }
+
+            if (ExpectedCount == 0)
+            {
+                /*
+                 * Either the NumEntries element was originally zero or it was
+                 * a NULL element and repaired to an Integer of value zero.
+                 * In either case, repair it by setting NumEntries to be the
+                 * actual size of the subpackage.
+                 */
+                ExpectedCount = SubPackage->Package.Count;
+                (*SubElements)->Integer.Value = ExpectedCount;
+            }
+
+            /* Check the type of each subpackage element */
+
+            Status = AcpiNsCheckPackageElements (Info, (SubElements + 1),
+                Package->RetInfo.ObjectType1,
+                (ExpectedCount - 1), 0, 0, 1);
+            if (ACPI_FAILURE (Status))
+            {
+                return (Status);
+            }
+            break;
+
+        default: /* Should not get here, type was validated by caller */
+
+            return (AE_AML_INTERNAL);
+        }
+
+        Elements++;
+    }
+
+    return (AE_OK);
+
+
+PackageTooSmall:
+
+    /* The subpackage count was smaller than required */
+
+    ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
+        "Return SubPackage[%u] is too small - found %u elements, expected %u",
+        i, SubPackage->Package.Count, ExpectedCount));
+
+    return (AE_AML_OPERAND_VALUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsCustomPackage
+ *
+ * PARAMETERS:  Info                - Method execution information block
+ *              Elements            - Pointer to the package elements array
+ *              Count               - Element count for the package
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check a returned package object for the correct count and
+ *              correct type of all sub-objects.
+ *
+ * NOTE: Currently used for the _BIX method only. When needed for two or more
+ * methods, probably a detect/dispatch mechanism will be required.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiNsCustomPackage (
+    ACPI_EVALUATE_INFO          *Info,
+    ACPI_OPERAND_OBJECT         **Elements,
+    UINT32                      Count)
+{
+    UINT32                      ExpectedCount;
+    UINT32                      Version;
+    ACPI_STATUS                 Status = AE_OK;
+
+
+    ACPI_FUNCTION_NAME (NsCustomPackage);
+
+
+    /* Get version number, must be Integer */
+
+    if ((*Elements)->Common.Type != ACPI_TYPE_INTEGER)
+    {
+        ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
+            "Return Package has invalid object type for version number"));
+        return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
+    }
+
+    Version = (UINT32) (*Elements)->Integer.Value;
+    ExpectedCount = 21;         /* Version 1 */
+
+    if (Version == 0)
+    {
+        ExpectedCount = 20;     /* Version 0 */
+    }
+
+    if (Count < ExpectedCount)
+    {
+        ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, Info->NodeFlags,
+            "Return Package is too small - found %u elements, expected %u",
+            Count, ExpectedCount));
+        return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
+    }
+    else if (Count > ExpectedCount)
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
+            "%s: Return Package is larger than needed - "
+            "found %u, expected %u\n",
+            Info->FullPathname, Count, ExpectedCount));
+    }
+
+    /* Validate all elements of the returned package */
+
+    Status = AcpiNsCheckPackageElements (Info, Elements,
+        ACPI_RTYPE_INTEGER, 16,
+        ACPI_RTYPE_STRING, 4, 0);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Version 1 has a single trailing integer */
+
+    if (Version > 0)
+    {
+        Status = AcpiNsCheckPackageElements (Info, Elements + 20,
+            ACPI_RTYPE_INTEGER, 1, 0, 0, 20);
+    }
+
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiNsCheckPackageElements
+ *
+ * PARAMETERS:  Info            - Method execution information block
+ *              Elements        - Pointer to the package elements array
+ *              Type1           - Object type for first group
+ *              Count1          - Count for first group
+ *              Type2           - Object type for second group
+ *              Count2          - Count for second group
+ *              StartIndex      - Start of the first group of elements
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Check that all elements of a package are of the correct object
+ *              type. Supports up to two groups of different object types.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiNsCheckPackageElements (
+    ACPI_EVALUATE_INFO          *Info,
+    ACPI_OPERAND_OBJECT         **Elements,
+    UINT8                       Type1,
+    UINT32                      Count1,
+    UINT8                       Type2,
+    UINT32                      Count2,
+    UINT32                      StartIndex)
+{
+    ACPI_OPERAND_OBJECT         **ThisElement = Elements;
+    ACPI_STATUS                 Status;
+    UINT32                      i;
+
+
+    /*
+     * Up to two groups of package elements are supported by the data
+     * structure. All elements in each group must be of the same type.
+     * The second group can have a count of zero.
+     */
+    for (i = 0; i < Count1; i++)
+    {
+        Status = AcpiNsCheckObjectType (Info, ThisElement,
+            Type1, i + StartIndex);
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ThisElement++;
+    }
+
+    for (i = 0; i < Count2; i++)
+    {
+        Status = AcpiNsCheckObjectType (Info, ThisElement,
+            Type2, (i + Count1 + StartIndex));
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+
+        ThisElement++;
+    }
+
+    return (AE_OK);
+}
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsrepair.c b/usr/src/uts/intel/io/acpica/namespace/nsrepair.c
index be9d3e889d..524fcf6671 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsrepair.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsrepair.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,13 +41,12 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSREPAIR_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
 #include "acinterp.h"
 #include "acpredef.h"
+#include "amlresrc.h"
 
 #define _COMPONENT          ACPI_NAMESPACE
         ACPI_MODULE_NAME    ("nsrepair")
@@ -74,6 +73,11 @@
  * Buffer  -> String
  * Buffer  -> Package of Integers
  * Package -> Package of one Package
+ *
+ * Additional conversions that are available:
+ *  Convert a null return or zero return value to an EndTag descriptor
+ *  Convert an ASCII string to a Unicode buffer
+ *
  * An incorrect standalone object is wrapped with required outer package
  *
  * Additional possible repairs:
@@ -84,27 +88,53 @@
 
 /* Local prototypes */
 
-static ACPI_STATUS
-AcpiNsConvertToInteger (
-    ACPI_OPERAND_OBJECT     *OriginalObject,
-    ACPI_OPERAND_OBJECT     **ReturnObject);
+static const ACPI_SIMPLE_REPAIR_INFO *
+AcpiNsMatchSimpleRepair (
+    ACPI_NAMESPACE_NODE     *Node,
+    UINT32                  ReturnBtype,
+    UINT32                  PackageIndex);
 
-static ACPI_STATUS
-AcpiNsConvertToString (
-    ACPI_OPERAND_OBJECT     *OriginalObject,
-    ACPI_OPERAND_OBJECT     **ReturnObject);
 
-static ACPI_STATUS
-AcpiNsConvertToBuffer (
-    ACPI_OPERAND_OBJECT     *OriginalObject,
-    ACPI_OPERAND_OBJECT     **ReturnObject);
+/*
+ * Special but simple repairs for some names.
+ *
+ * 2nd argument: Unexpected types that can be repaired
+ */
+static const ACPI_SIMPLE_REPAIR_INFO    AcpiObjectRepairInfo[] =
+{
+    /* Resource descriptor conversions */
+
+    { "_CRS", ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING | ACPI_RTYPE_BUFFER | ACPI_RTYPE_NONE,
+                ACPI_NOT_PACKAGE_ELEMENT,
+                AcpiNsConvertToResource },
+    { "_DMA", ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING | ACPI_RTYPE_BUFFER | ACPI_RTYPE_NONE,
+                ACPI_NOT_PACKAGE_ELEMENT,
+                AcpiNsConvertToResource },
+    { "_PRS", ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING | ACPI_RTYPE_BUFFER | ACPI_RTYPE_NONE,
+                ACPI_NOT_PACKAGE_ELEMENT,
+                AcpiNsConvertToResource },
+
+    /* Object reference conversions */
+
+    { "_DEP", ACPI_RTYPE_STRING, ACPI_ALL_PACKAGE_ELEMENTS,
+                AcpiNsConvertToReference },
+
+    /* Unicode conversions */
+
+    { "_MLS", ACPI_RTYPE_STRING, 1,
+                AcpiNsConvertToUnicode },
+    { "_STR", ACPI_RTYPE_STRING | ACPI_RTYPE_BUFFER,
+                ACPI_NOT_PACKAGE_ELEMENT,
+                AcpiNsConvertToUnicode },
+    { {0,0,0,0}, 0, 0, NULL } /* Table terminator */
+};
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiNsRepairObject
+ * FUNCTION:    AcpiNsSimpleRepair
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              ExpectedBtypes      - Object types expected
  *              PackageIndex        - Index of object within parent package (if
  *                                    applicable - ACPI_NOT_PACKAGE_ELEMENT
@@ -120,19 +150,59 @@ AcpiNsConvertToBuffer (
  ******************************************************************************/
 
 ACPI_STATUS
-AcpiNsRepairObject (
-    ACPI_PREDEFINED_DATA    *Data,
+AcpiNsSimpleRepair (
+    ACPI_EVALUATE_INFO      *Info,
     UINT32                  ExpectedBtypes,
     UINT32                  PackageIndex,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
 {
     ACPI_OPERAND_OBJECT     *ReturnObject = *ReturnObjectPtr;
-    ACPI_OPERAND_OBJECT     *NewObject;
+    ACPI_OPERAND_OBJECT     *NewObject = NULL;
     ACPI_STATUS             Status;
+    const ACPI_SIMPLE_REPAIR_INFO   *Predefined;
+
+
+    ACPI_FUNCTION_NAME (NsSimpleRepair);
+
+
+    /*
+     * Special repairs for certain names that are in the repair table.
+     * Check if this name is in the list of repairable names.
+     */
+    Predefined = AcpiNsMatchSimpleRepair (Info->Node,
+        Info->ReturnBtype, PackageIndex);
+    if (Predefined)
+    {
+        if (!ReturnObject)
+        {
+            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname,
+                ACPI_WARN_ALWAYS, "Missing expected return value"));
+        }
 
+        Status = Predefined->ObjectConverter (Info->Node, ReturnObject,
+            &NewObject);
+        if (ACPI_FAILURE (Status))
+        {
+            /* A fatal error occurred during a conversion */
 
-    ACPI_FUNCTION_NAME (NsRepairObject);
+            ACPI_EXCEPTION ((AE_INFO, Status,
+                "During return object analysis"));
+            return (Status);
+        }
+        if (NewObject)
+        {
+            goto ObjectRepaired;
+        }
+    }
 
+    /*
+     * Do not perform simple object repair unless the return type is not
+     * expected.
+     */
+    if (Info->ReturnBtype & ExpectedBtypes)
+    {
+        return (AE_OK);
+    }
 
     /*
      * At this point, we know that the type of the returned object was not
@@ -140,6 +210,40 @@ AcpiNsRepairObject (
      * repair the object by converting it to one of the expected object
      * types for this predefined name.
      */
+
+    /*
+     * If there is no return value, check if we require a return value for
+     * this predefined name. Either one return value is expected, or none,
+     * for both methods and other objects.
+     *
+     * Try to fix if there was no return object. Warning if failed to fix.
+     */
+    if (!ReturnObject)
+    {
+        if (ExpectedBtypes && (!(ExpectedBtypes & ACPI_RTYPE_NONE)))
+        {
+            if (PackageIndex != ACPI_NOT_PACKAGE_ELEMENT)
+            {
+                ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname,
+                    ACPI_WARN_ALWAYS, "Found unexpected NULL package element"));
+
+                Status = AcpiNsRepairNullElement (Info, ExpectedBtypes,
+                    PackageIndex, ReturnObjectPtr);
+                if (ACPI_SUCCESS (Status))
+                {
+                    return (AE_OK); /* Repair was successful */
+                }
+            }
+            else
+            {
+                ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname,
+                    ACPI_WARN_ALWAYS, "Missing expected return value"));
+            }
+
+            return (AE_AML_NO_RETURN_VALUE);
+        }
+    }
+
     if (ExpectedBtypes & ACPI_RTYPE_INTEGER)
     {
         Status = AcpiNsConvertToInteger (ReturnObject, &NewObject);
@@ -174,7 +278,7 @@ AcpiNsRepairObject (
          * object. Note: after the wrapping, the package will be validated
          * for correct contents (expected object type or types).
          */
-        Status = AcpiNsWrapWithPackage (Data, ReturnObject, &NewObject);
+        Status = AcpiNsWrapWithPackage (Info, ReturnObject, &NewObject);
         if (ACPI_SUCCESS (Status))
         {
             /*
@@ -182,7 +286,7 @@ AcpiNsRepairObject (
              * incremented for being inserted into the new package.
              */
             *ReturnObjectPtr = NewObject;       /* New Package object */
-            Data->Flags |= ACPI_OBJECT_REPAIRED;
+            Info->ReturnFlags |= ACPI_OBJECT_REPAIRED;
             return (AE_OK);
         }
     }
@@ -207,7 +311,7 @@ ObjectRepaired:
          * package object as part of the repair, we don't need to
          * change the reference count.
          */
-        if (!(Data->Flags & ACPI_OBJECT_WRAPPED))
+        if (!(Info->ReturnFlags & ACPI_OBJECT_WRAPPED))
         {
             NewObject->Common.ReferenceCount =
                 ReturnObject->Common.ReferenceCount;
@@ -220,14 +324,14 @@ ObjectRepaired:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
             "%s: Converted %s to expected %s at Package index %u\n",
-            Data->Pathname, AcpiUtGetObjectTypeName (ReturnObject),
+            Info->FullPathname, AcpiUtGetObjectTypeName (ReturnObject),
             AcpiUtGetObjectTypeName (NewObject), PackageIndex));
     }
     else
     {
         ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
             "%s: Converted %s to expected %s\n",
-            Data->Pathname, AcpiUtGetObjectTypeName (ReturnObject),
+            Info->FullPathname, AcpiUtGetObjectTypeName (ReturnObject),
             AcpiUtGetObjectTypeName (NewObject)));
     }
 
@@ -235,278 +339,59 @@ ObjectRepaired:
 
     AcpiUtRemoveReference (ReturnObject);
     *ReturnObjectPtr = NewObject;
-    Data->Flags |= ACPI_OBJECT_REPAIRED;
+    Info->ReturnFlags |= ACPI_OBJECT_REPAIRED;
     return (AE_OK);
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsConvertToInteger
- *
- * PARAMETERS:  OriginalObject      - Object to be converted
- *              ReturnObject        - Where the new converted object is returned
- *
- * RETURN:      Status. AE_OK if conversion was successful.
- *
- * DESCRIPTION: Attempt to convert a String/Buffer object to an Integer.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiNsConvertToInteger (
-    ACPI_OPERAND_OBJECT     *OriginalObject,
-    ACPI_OPERAND_OBJECT     **ReturnObject)
-{
-    ACPI_OPERAND_OBJECT     *NewObject;
-    ACPI_STATUS             Status;
-    UINT64                  Value = 0;
-    UINT32                  i;
-
-
-    switch (OriginalObject->Common.Type)
-    {
-    case ACPI_TYPE_STRING:
-
-        /* String-to-Integer conversion */
-
-        Status = AcpiUtStrtoul64 (OriginalObject->String.Pointer,
-                    ACPI_ANY_BASE, &Value);
-        if (ACPI_FAILURE (Status))
-        {
-            return (Status);
-        }
-        break;
-
-    case ACPI_TYPE_BUFFER:
-
-        /* Buffer-to-Integer conversion. Max buffer size is 64 bits. */
-
-        if (OriginalObject->Buffer.Length > 8)
-        {
-            return (AE_AML_OPERAND_TYPE);
-        }
-
-        /* Extract each buffer byte to create the integer */
-
-        for (i = 0; i < OriginalObject->Buffer.Length; i++)
-        {
-            Value |= ((UINT64) OriginalObject->Buffer.Pointer[i] << (i * 8));
-        }
-        break;
-
-    default:
-        return (AE_AML_OPERAND_TYPE);
-    }
-
-    NewObject = AcpiUtCreateIntegerObject (Value);
-    if (!NewObject)
-    {
-        return (AE_NO_MEMORY);
-    }
-
-    *ReturnObject = NewObject;
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
+/******************************************************************************
  *
- * FUNCTION:    AcpiNsConvertToString
+ * FUNCTION:    AcpiNsMatchSimpleRepair
  *
- * PARAMETERS:  OriginalObject      - Object to be converted
- *              ReturnObject        - Where the new converted object is returned
+ * PARAMETERS:  Node                - Namespace node for the method/object
+ *              ReturnBtype         - Object type that was returned
+ *              PackageIndex        - Index of object within parent package (if
+ *                                    applicable - ACPI_NOT_PACKAGE_ELEMENT
+ *                                    otherwise)
  *
- * RETURN:      Status. AE_OK if conversion was successful.
+ * RETURN:      Pointer to entry in repair table. NULL indicates not found.
  *
- * DESCRIPTION: Attempt to convert a Integer/Buffer object to a String.
+ * DESCRIPTION: Check an object name against the repairable object list.
  *
- ******************************************************************************/
+ *****************************************************************************/
 
-static ACPI_STATUS
-AcpiNsConvertToString (
-    ACPI_OPERAND_OBJECT     *OriginalObject,
-    ACPI_OPERAND_OBJECT     **ReturnObject)
+static const ACPI_SIMPLE_REPAIR_INFO *
+AcpiNsMatchSimpleRepair (
+    ACPI_NAMESPACE_NODE     *Node,
+    UINT32                  ReturnBtype,
+    UINT32                  PackageIndex)
 {
-    ACPI_OPERAND_OBJECT     *NewObject;
-    ACPI_SIZE               Length;
-    ACPI_STATUS             Status;
-
-
-    switch (OriginalObject->Common.Type)
-    {
-    case ACPI_TYPE_INTEGER:
-        /*
-         * Integer-to-String conversion. Commonly, convert
-         * an integer of value 0 to a NULL string. The last element of
-         * _BIF and _BIX packages occasionally need this fix.
-         */
-        if (OriginalObject->Integer.Value == 0)
-        {
-            /* Allocate a new NULL string object */
-
-            NewObject = AcpiUtCreateStringObject (0);
-            if (!NewObject)
-            {
-                return (AE_NO_MEMORY);
-            }
-        }
-        else
-        {
-            Status = AcpiExConvertToString (OriginalObject, &NewObject,
-                        ACPI_IMPLICIT_CONVERT_HEX);
-            if (ACPI_FAILURE (Status))
-            {
-                return (Status);
-            }
-        }
-        break;
-
-    case ACPI_TYPE_BUFFER:
-        /*
-         * Buffer-to-String conversion. Use a ToString
-         * conversion, no transform performed on the buffer data. The best
-         * example of this is the _BIF method, where the string data from
-         * the battery is often (incorrectly) returned as buffer object(s).
-         */
-        Length = 0;
-        while ((Length < OriginalObject->Buffer.Length) &&
-                (OriginalObject->Buffer.Pointer[Length]))
-        {
-            Length++;
-        }
-
-        /* Allocate a new string object */
-
-        NewObject = AcpiUtCreateStringObject (Length);
-        if (!NewObject)
-        {
-            return (AE_NO_MEMORY);
-        }
-
-        /*
-         * Copy the raw buffer data with no transform. String is already NULL
-         * terminated at Length+1.
-         */
-        ACPI_MEMCPY (NewObject->String.Pointer,
-            OriginalObject->Buffer.Pointer, Length);
-        break;
-
-    default:
-        return (AE_AML_OPERAND_TYPE);
-    }
+    const ACPI_SIMPLE_REPAIR_INFO   *ThisName;
 
-    *ReturnObject = NewObject;
-    return (AE_OK);
-}
 
+    /* Search info table for a repairable predefined method/object name */
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsConvertToBuffer
- *
- * PARAMETERS:  OriginalObject      - Object to be converted
- *              ReturnObject        - Where the new converted object is returned
- *
- * RETURN:      Status. AE_OK if conversion was successful.
- *
- * DESCRIPTION: Attempt to convert a Integer/String/Package object to a Buffer.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiNsConvertToBuffer (
-    ACPI_OPERAND_OBJECT     *OriginalObject,
-    ACPI_OPERAND_OBJECT     **ReturnObject)
-{
-    ACPI_OPERAND_OBJECT     *NewObject;
-    ACPI_STATUS             Status;
-    ACPI_OPERAND_OBJECT     **Elements;
-    UINT32                  *DwordBuffer;
-    UINT32                  Count;
-    UINT32                  i;
-
-
-    switch (OriginalObject->Common.Type)
+    ThisName = AcpiObjectRepairInfo;
+    while (ThisName->ObjectConverter)
     {
-    case ACPI_TYPE_INTEGER:
-        /*
-         * Integer-to-Buffer conversion.
-         * Convert the Integer to a packed-byte buffer. _MAT and other
-         * objects need this sometimes, if a read has been performed on a
-         * Field object that is less than or equal to the global integer
-         * size (32 or 64 bits).
-         */
-        Status = AcpiExConvertToBuffer (OriginalObject, &NewObject);
-        if (ACPI_FAILURE (Status))
+        if (ACPI_COMPARE_NAME (Node->Name.Ascii, ThisName->Name))
         {
-            return (Status);
-        }
-        break;
+            /* Check if we can actually repair this name/type combination */
 
-    case ACPI_TYPE_STRING:
-
-        /* String-to-Buffer conversion. Simple data copy */
-
-        NewObject = AcpiUtCreateBufferObject (OriginalObject->String.Length);
-        if (!NewObject)
-        {
-            return (AE_NO_MEMORY);
-        }
-
-        ACPI_MEMCPY (NewObject->Buffer.Pointer,
-            OriginalObject->String.Pointer, OriginalObject->String.Length);
-        break;
-
-    case ACPI_TYPE_PACKAGE:
-        /*
-         * This case is often seen for predefined names that must return a
-         * Buffer object with multiple DWORD integers within. For example,
-         * _FDE and _GTM. The Package can be converted to a Buffer.
-         */
-
-        /* All elements of the Package must be integers */
-
-        Elements = OriginalObject->Package.Elements;
-        Count = OriginalObject->Package.Count;
-
-        for (i = 0; i < Count; i++)
-        {
-            if ((!*Elements) ||
-                ((*Elements)->Common.Type != ACPI_TYPE_INTEGER))
+            if ((ReturnBtype & ThisName->UnexpectedBtypes) &&
+                (ThisName->PackageIndex == ACPI_ALL_PACKAGE_ELEMENTS ||
+                 PackageIndex == ThisName->PackageIndex))
             {
-                return (AE_AML_OPERAND_TYPE);
+                return (ThisName);
             }
-            Elements++;
-        }
-
-        /* Create the new buffer object to replace the Package */
 
-        NewObject = AcpiUtCreateBufferObject (ACPI_MUL_4 (Count));
-        if (!NewObject)
-        {
-            return (AE_NO_MEMORY);
+            return (NULL);
         }
 
-        /* Copy the package elements (integers) to the buffer as DWORDs */
-
-        Elements = OriginalObject->Package.Elements;
-        DwordBuffer = ACPI_CAST_PTR (UINT32, NewObject->Buffer.Pointer);
-
-        for (i = 0; i < Count; i++)
-        {
-            *DwordBuffer = (UINT32) (*Elements)->Integer.Value;
-            DwordBuffer++;
-            Elements++;
-        }
-        break;
-
-    default:
-        return (AE_AML_OPERAND_TYPE);
+        ThisName++;
     }
 
-    *ReturnObject = NewObject;
-    return (AE_OK);
+    return (NULL); /* Name was not found in the repair table */
 }
 
 
@@ -514,7 +399,7 @@ AcpiNsConvertToBuffer (
  *
  * FUNCTION:    AcpiNsRepairNullElement
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              ExpectedBtypes      - Object types expected
  *              PackageIndex        - Index of object within parent package (if
  *                                    applicable - ACPI_NOT_PACKAGE_ELEMENT
@@ -530,7 +415,7 @@ AcpiNsConvertToBuffer (
 
 ACPI_STATUS
 AcpiNsRepairNullElement (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     UINT32                  ExpectedBtypes,
     UINT32                  PackageIndex,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
@@ -587,14 +472,16 @@ AcpiNsRepairNullElement (
 
     /* Set the reference count according to the parent Package object */
 
-    NewObject->Common.ReferenceCount = Data->ParentPackage->Common.ReferenceCount;
+    NewObject->Common.ReferenceCount =
+        Info->ParentPackage->Common.ReferenceCount;
 
     ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
         "%s: Converted NULL package element to expected %s at index %u\n",
-         Data->Pathname, AcpiUtGetObjectTypeName (NewObject), PackageIndex));
+        Info->FullPathname, AcpiUtGetObjectTypeName (NewObject),
+        PackageIndex));
 
     *ReturnObjectPtr = NewObject;
-    Data->Flags |= ACPI_OBJECT_REPAIRED;
+    Info->ReturnFlags |= ACPI_OBJECT_REPAIRED;
     return (AE_OK);
 }
 
@@ -603,21 +490,21 @@ AcpiNsRepairNullElement (
  *
  * FUNCTION:    AcpiNsRemoveNullElements
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              PackageType         - An AcpiReturnPackageTypes value
  *              ObjDesc             - A Package object
  *
  * RETURN:      None.
  *
  * DESCRIPTION: Remove all NULL package elements from packages that contain
- *              a variable number of sub-packages. For these types of
+ *              a variable number of subpackages. For these types of
  *              packages, NULL elements can be safely removed.
  *
  *****************************************************************************/
 
 void
 AcpiNsRemoveNullElements (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     UINT8                   PackageType,
     ACPI_OPERAND_OBJECT     *ObjDesc)
 {
@@ -634,7 +521,7 @@ AcpiNsRemoveNullElements (
     /*
      * We can safely remove all NULL elements from these package types:
      * PTYPE1_VAR packages contain a variable number of simple data types.
-     * PTYPE2 packages contain a variable number of sub-packages.
+     * PTYPE2 packages contain a variable number of subpackages.
      */
     switch (PackageType)
     {
@@ -649,6 +536,7 @@ AcpiNsRemoveNullElements (
         break;
 
     default:
+    case ACPI_PTYPE2_VAR_VAR:
     case ACPI_PTYPE1_FIXED:
     case ACPI_PTYPE1_OPTION:
         return;
@@ -673,6 +561,7 @@ AcpiNsRemoveNullElements (
             *Dest = *Source;
             Dest++;
         }
+
         Source++;
     }
 
@@ -682,7 +571,7 @@ AcpiNsRemoveNullElements (
     {
         ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
             "%s: Found and removed %u NULL elements\n",
-            Data->Pathname, (Count - NewCount)));
+            Info->FullPathname, (Count - NewCount)));
 
         /* NULL terminate list and update the package count */
 
@@ -696,7 +585,7 @@ AcpiNsRemoveNullElements (
  *
  * FUNCTION:    AcpiNsWrapWithPackage
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              OriginalObject      - Pointer to the object to repair.
  *              ObjDescPtr          - The new package object is returned here
  *
@@ -718,7 +607,7 @@ AcpiNsRemoveNullElements (
 
 ACPI_STATUS
 AcpiNsWrapWithPackage (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     *OriginalObject,
     ACPI_OPERAND_OBJECT     **ObjDescPtr)
 {
@@ -729,8 +618,8 @@ AcpiNsWrapWithPackage (
 
 
     /*
-     * Create the new outer package and populate it. The new package will
-     * have a single element, the lone sub-object.
+     * Create the new outer package and populate it. The new
+     * package will have a single element, the lone sub-object.
      */
     PkgObjDesc = AcpiUtCreatePackageObject (1);
     if (!PkgObjDesc)
@@ -742,11 +631,11 @@ AcpiNsWrapWithPackage (
 
     ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
         "%s: Wrapped %s with expected Package object\n",
-        Data->Pathname, AcpiUtGetObjectTypeName (OriginalObject)));
+        Info->FullPathname, AcpiUtGetObjectTypeName (OriginalObject)));
 
     /* Return the new object in the object pointer */
 
     *ObjDescPtr = PkgObjDesc;
-    Data->Flags |= ACPI_OBJECT_REPAIRED | ACPI_OBJECT_WRAPPED;
+    Info->ReturnFlags |= ACPI_OBJECT_REPAIRED | ACPI_OBJECT_WRAPPED;
     return (AE_OK);
 }
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsrepair2.c b/usr/src/uts/intel/io/acpica/namespace/nsrepair2.c
index a6a4d6874d..d8625899a6 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsrepair2.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsrepair2.c
@@ -6,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +42,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSREPAIR2_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -58,7 +56,7 @@
  */
 typedef
 ACPI_STATUS (*ACPI_REPAIR_FUNCTION) (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
 
 typedef struct acpi_repair_info
@@ -72,48 +70,69 @@ typedef struct acpi_repair_info
 /* Local prototypes */
 
 static const ACPI_REPAIR_INFO *
-AcpiNsMatchRepairableName (
+AcpiNsMatchComplexRepair (
     ACPI_NAMESPACE_NODE     *Node);
 
 static ACPI_STATUS
 AcpiNsRepair_ALR (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
 
 static ACPI_STATUS
 AcpiNsRepair_CID (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
+    ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
+
+static ACPI_STATUS
+AcpiNsRepair_CST (
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
 
 static ACPI_STATUS
 AcpiNsRepair_FDE (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
 
 static ACPI_STATUS
 AcpiNsRepair_HID (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
+    ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
+
+static ACPI_STATUS
+AcpiNsRepair_PRT (
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
 
 static ACPI_STATUS
 AcpiNsRepair_PSS (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
 
 static ACPI_STATUS
 AcpiNsRepair_TSS (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
 
 static ACPI_STATUS
 AcpiNsCheckSortedList (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     *ReturnObject,
+    UINT32                  StartIndex,
     UINT32                  ExpectedCount,
     UINT32                  SortIndex,
     UINT8                   SortDirection,
     char                    *SortKeyName);
 
+/* Values for SortDirection above */
+
+#define ACPI_SORT_ASCENDING     0
+#define ACPI_SORT_DESCENDING    1
+
+static void
+AcpiNsRemoveElement (
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    UINT32                  Index);
+
 static void
 AcpiNsSortList (
     ACPI_OPERAND_OBJECT     **Elements,
@@ -121,11 +140,6 @@ AcpiNsSortList (
     UINT32                  Index,
     UINT8                   SortDirection);
 
-/* Values for SortDirection above */
-
-#define ACPI_SORT_ASCENDING     0
-#define ACPI_SORT_DESCENDING    1
-
 
 /*
  * This table contains the names of the predefined methods for which we can
@@ -135,9 +149,11 @@ AcpiNsSortList (
  *
  * _ALR: Sort the list ascending by AmbientIlluminance
  * _CID: Strings: uppercase all, remove any leading asterisk
+ * _CST: Sort the list ascending by C state type
  * _FDE: Convert Buffer of BYTEs to a Buffer of DWORDs
  * _GTM: Convert Buffer of BYTEs to a Buffer of DWORDs
  * _HID: Strings: uppercase all, remove any leading asterisk
+ * _PRT: Fix reversed SourceName and SourceIndex
  * _PSS: Sort the list descending by Power
  * _TSS: Sort the list descending by Power
  *
@@ -152,9 +168,11 @@ static const ACPI_REPAIR_INFO       AcpiNsRepairableNames[] =
 {
     {"_ALR", AcpiNsRepair_ALR},
     {"_CID", AcpiNsRepair_CID},
+    {"_CST", AcpiNsRepair_CST},
     {"_FDE", AcpiNsRepair_FDE},
     {"_GTM", AcpiNsRepair_FDE},     /* _GTM has same repair as _FDE */
     {"_HID", AcpiNsRepair_HID},
+    {"_PRT", AcpiNsRepair_PRT},
     {"_PSS", AcpiNsRepair_PSS},
     {"_TSS", AcpiNsRepair_TSS},
     {{0,0,0,0}, NULL}               /* Table terminator */
@@ -170,7 +188,7 @@ static const ACPI_REPAIR_INFO       AcpiNsRepairableNames[] =
  *
  * FUNCTION:    AcpiNsComplexRepairs
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              Node                - Namespace node for the method/object
  *              ValidateStatus      - Original status of earlier validation
  *              ReturnObjectPtr     - Pointer to the object returned from the
@@ -186,7 +204,7 @@ static const ACPI_REPAIR_INFO       AcpiNsRepairableNames[] =
 
 ACPI_STATUS
 AcpiNsComplexRepairs (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_NAMESPACE_NODE     *Node,
     ACPI_STATUS             ValidateStatus,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
@@ -197,20 +215,20 @@ AcpiNsComplexRepairs (
 
     /* Check if this name is in the list of repairable names */
 
-    Predefined = AcpiNsMatchRepairableName (Node);
+    Predefined = AcpiNsMatchComplexRepair (Node);
     if (!Predefined)
     {
         return (ValidateStatus);
     }
 
-    Status = Predefined->RepairFunction (Data, ReturnObjectPtr);
+    Status = Predefined->RepairFunction (Info, ReturnObjectPtr);
     return (Status);
 }
 
 
 /******************************************************************************
  *
- * FUNCTION:    AcpiNsMatchRepairableName
+ * FUNCTION:    AcpiNsMatchComplexRepair
  *
  * PARAMETERS:  Node                - Namespace node for the method/object
  *
@@ -221,7 +239,7 @@ AcpiNsComplexRepairs (
  *****************************************************************************/
 
 static const ACPI_REPAIR_INFO *
-AcpiNsMatchRepairableName (
+AcpiNsMatchComplexRepair (
     ACPI_NAMESPACE_NODE     *Node)
 {
     const ACPI_REPAIR_INFO  *ThisName;
@@ -236,6 +254,7 @@ AcpiNsMatchRepairableName (
         {
             return (ThisName);
         }
+
         ThisName++;
     }
 
@@ -247,7 +266,7 @@ AcpiNsMatchRepairableName (
  *
  * FUNCTION:    AcpiNsRepair_ALR
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              ReturnObjectPtr     - Pointer to the object returned from the
  *                                    evaluation of a method or object
  *
@@ -260,15 +279,15 @@ AcpiNsMatchRepairableName (
 
 static ACPI_STATUS
 AcpiNsRepair_ALR (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
 {
     ACPI_OPERAND_OBJECT     *ReturnObject = *ReturnObjectPtr;
     ACPI_STATUS             Status;
 
 
-    Status = AcpiNsCheckSortedList (Data, ReturnObject, 2, 1,
-                ACPI_SORT_ASCENDING, "AmbientIlluminance");
+    Status = AcpiNsCheckSortedList (Info, ReturnObject, 0, 2, 1,
+        ACPI_SORT_ASCENDING, "AmbientIlluminance");
 
     return (Status);
 }
@@ -278,7 +297,7 @@ AcpiNsRepair_ALR (
  *
  * FUNCTION:    AcpiNsRepair_FDE
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              ReturnObjectPtr     - Pointer to the object returned from the
  *                                    evaluation of a method or object
  *
@@ -293,7 +312,7 @@ AcpiNsRepair_ALR (
 
 static ACPI_STATUS
 AcpiNsRepair_FDE (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
 {
     ACPI_OPERAND_OBJECT     *ReturnObject = *ReturnObjectPtr;
@@ -321,7 +340,8 @@ AcpiNsRepair_FDE (
 
         if (ReturnObject->Buffer.Length != ACPI_FDE_BYTE_BUFFER_SIZE)
         {
-            ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
+            ACPI_WARN_PREDEFINED ((AE_INFO,
+                Info->FullPathname, Info->NodeFlags,
                 "Incorrect return buffer length %u, expected %u",
                 ReturnObject->Buffer.Length, ACPI_FDE_DWORD_BUFFER_SIZE));
 
@@ -330,7 +350,8 @@ AcpiNsRepair_FDE (
 
         /* Create the new (larger) buffer object */
 
-        BufferObject = AcpiUtCreateBufferObject (ACPI_FDE_DWORD_BUFFER_SIZE);
+        BufferObject = AcpiUtCreateBufferObject (
+            ACPI_FDE_DWORD_BUFFER_SIZE);
         if (!BufferObject)
         {
             return (AE_NO_MEMORY);
@@ -339,7 +360,8 @@ AcpiNsRepair_FDE (
         /* Expand each byte to a DWORD */
 
         ByteBuffer = ReturnObject->Buffer.Pointer;
-        DwordBuffer = ACPI_CAST_PTR (UINT32, BufferObject->Buffer.Pointer);
+        DwordBuffer = ACPI_CAST_PTR (UINT32,
+            BufferObject->Buffer.Pointer);
 
         for (i = 0; i < ACPI_FDE_FIELD_COUNT; i++)
         {
@@ -350,10 +372,11 @@ AcpiNsRepair_FDE (
 
         ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
             "%s Expanded Byte Buffer to expected DWord Buffer\n",
-            Data->Pathname));
+            Info->FullPathname));
         break;
 
     default:
+
         return (AE_AML_OPERAND_TYPE);
     }
 
@@ -362,7 +385,7 @@ AcpiNsRepair_FDE (
     AcpiUtRemoveReference (ReturnObject);
     *ReturnObjectPtr = BufferObject;
 
-    Data->Flags |= ACPI_OBJECT_REPAIRED;
+    Info->ReturnFlags |= ACPI_OBJECT_REPAIRED;
     return (AE_OK);
 }
 
@@ -371,7 +394,7 @@ AcpiNsRepair_FDE (
  *
  * FUNCTION:    AcpiNsRepair_CID
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              ReturnObjectPtr     - Pointer to the object returned from the
  *                                    evaluation of a method or object
  *
@@ -385,7 +408,7 @@ AcpiNsRepair_FDE (
 
 static ACPI_STATUS
 AcpiNsRepair_CID (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
 {
     ACPI_STATUS             Status;
@@ -400,7 +423,7 @@ AcpiNsRepair_CID (
 
     if (ReturnObject->Common.Type == ACPI_TYPE_STRING)
     {
-        Status = AcpiNsRepair_HID (Data, ReturnObjectPtr);
+        Status = AcpiNsRepair_HID (Info, ReturnObjectPtr);
         return (Status);
     }
 
@@ -419,7 +442,7 @@ AcpiNsRepair_CID (
         OriginalElement = *ElementPtr;
         OriginalRefCount = OriginalElement->Common.ReferenceCount;
 
-        Status = AcpiNsRepair_HID (Data, ElementPtr);
+        Status = AcpiNsRepair_HID (Info, ElementPtr);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
@@ -444,11 +467,106 @@ AcpiNsRepair_CID (
 }
 
 
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiNsRepair_CST
+ *
+ * PARAMETERS:  Info                - Method execution information block
+ *              ReturnObjectPtr     - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if object is OK or was repaired successfully
+ *
+ * DESCRIPTION: Repair for the _CST object:
+ *              1. Sort the list ascending by C state type
+ *              2. Ensure type cannot be zero
+ *              3. A subpackage count of zero means _CST is meaningless
+ *              4. Count must match the number of C state subpackages
+ *
+ *****************************************************************************/
+
+static ACPI_STATUS
+AcpiNsRepair_CST (
+    ACPI_EVALUATE_INFO      *Info,
+    ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
+{
+    ACPI_OPERAND_OBJECT     *ReturnObject = *ReturnObjectPtr;
+    ACPI_OPERAND_OBJECT     **OuterElements;
+    UINT32                  OuterElementCount;
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_STATUS             Status;
+    BOOLEAN                 Removing;
+    UINT32                  i;
+
+
+    ACPI_FUNCTION_NAME (NsRepair_CST);
+
+
+    /*
+     * Check if the C-state type values are proportional.
+     */
+    OuterElementCount = ReturnObject->Package.Count - 1;
+    i = 0;
+    while (i < OuterElementCount)
+    {
+        OuterElements = &ReturnObject->Package.Elements[i + 1];
+        Removing = FALSE;
+
+        if ((*OuterElements)->Package.Count == 0)
+        {
+            ACPI_WARN_PREDEFINED ((AE_INFO,
+                Info->FullPathname, Info->NodeFlags,
+                "SubPackage[%u] - removing entry due to zero count", i));
+            Removing = TRUE;
+            goto RemoveElement;
+        }
+
+        ObjDesc = (*OuterElements)->Package.Elements[1]; /* Index1 = Type */
+        if ((UINT32) ObjDesc->Integer.Value == 0)
+        {
+            ACPI_WARN_PREDEFINED ((AE_INFO,
+                Info->FullPathname, Info->NodeFlags,
+                "SubPackage[%u] - removing entry due to invalid Type(0)", i));
+            Removing = TRUE;
+        }
+
+RemoveElement:
+        if (Removing)
+        {
+            AcpiNsRemoveElement (ReturnObject, i + 1);
+            OuterElementCount--;
+        }
+        else
+        {
+            i++;
+        }
+    }
+
+    /* Update top-level package count, Type "Integer" checked elsewhere */
+
+    ObjDesc = ReturnObject->Package.Elements[0];
+    ObjDesc->Integer.Value = OuterElementCount;
+
+    /*
+     * Entries (subpackages) in the _CST Package must be sorted by the
+     * C-state type, in ascending order.
+     */
+    Status = AcpiNsCheckSortedList (Info, ReturnObject, 1, 4, 1,
+        ACPI_SORT_ASCENDING, "C-State Type");
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    return (AE_OK);
+}
+
+
 /******************************************************************************
  *
  * FUNCTION:    AcpiNsRepair_HID
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              ReturnObjectPtr     - Pointer to the object returned from the
  *                                    evaluation of a method or object
  *
@@ -461,7 +579,7 @@ AcpiNsRepair_CID (
 
 static ACPI_STATUS
 AcpiNsRepair_HID (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
 {
     ACPI_OPERAND_OBJECT     *ReturnObject = *ReturnObjectPtr;
@@ -482,12 +600,13 @@ AcpiNsRepair_HID (
 
     if (ReturnObject->String.Length == 0)
     {
-        ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
+        ACPI_WARN_PREDEFINED ((AE_INFO,
+            Info->FullPathname, Info->NodeFlags,
             "Invalid zero-length _HID or _CID string"));
 
         /* Return AE_OK anyway, let driver handle it */
 
-        Data->Flags |= ACPI_OBJECT_REPAIRED;
+        Info->ReturnFlags |= ACPI_OBJECT_REPAIRED;
         return (AE_OK);
     }
 
@@ -512,7 +631,7 @@ AcpiNsRepair_HID (
         NewString->String.Length--;
 
         ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
-            "%s: Removed invalid leading asterisk\n", Data->Pathname));
+            "%s: Removed invalid leading asterisk\n", Info->FullPathname));
     }
 
     /*
@@ -525,7 +644,7 @@ AcpiNsRepair_HID (
      */
     for (Dest = NewString->String.Pointer; *Source; Dest++, Source++)
     {
-        *Dest = (char) ACPI_TOUPPER (*Source);
+        *Dest = (char) toupper ((int) *Source);
     }
 
     AcpiUtRemoveReference (ReturnObject);
@@ -536,47 +655,73 @@ AcpiNsRepair_HID (
 
 /******************************************************************************
  *
- * FUNCTION:    AcpiNsRepair_TSS
+ * FUNCTION:    AcpiNsRepair_PRT
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              ReturnObjectPtr     - Pointer to the object returned from the
  *                                    evaluation of a method or object
  *
  * RETURN:      Status. AE_OK if object is OK or was repaired successfully
  *
- * DESCRIPTION: Repair for the _TSS object. If necessary, sort the object list
- *              descending by the power dissipation values.
+ * DESCRIPTION: Repair for the _PRT object. If necessary, fix reversed
+ *              SourceName and SourceIndex field, a common BIOS bug.
  *
  *****************************************************************************/
 
 static ACPI_STATUS
-AcpiNsRepair_TSS (
-    ACPI_PREDEFINED_DATA    *Data,
+AcpiNsRepair_PRT (
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
 {
-    ACPI_OPERAND_OBJECT     *ReturnObject = *ReturnObjectPtr;
-    ACPI_STATUS             Status;
-    ACPI_NAMESPACE_NODE     *Node;
+    ACPI_OPERAND_OBJECT     *PackageObject = *ReturnObjectPtr;
+    ACPI_OPERAND_OBJECT     **TopObjectList;
+    ACPI_OPERAND_OBJECT     **SubObjectList;
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_OPERAND_OBJECT     *SubPackage;
+    UINT32                  ElementCount;
+    UINT32                  Index;
 
 
-    /*
-     * We can only sort the _TSS return package if there is no _PSS in the
-     * same scope. This is because if _PSS is present, the ACPI specification
-     * dictates that the _TSS Power Dissipation field is to be ignored, and
-     * therefore some BIOSs leave garbage values in the _TSS Power field(s).
-     * In this case, it is best to just return the _TSS package as-is.
-     * (May, 2011)
-     */
-    Status = AcpiNsGetNode (Data->Node, "^_PSS", ACPI_NS_NO_UPSEARCH, &Node);
-    if (ACPI_SUCCESS (Status))
+    /* Each element in the _PRT package is a subpackage */
+
+    TopObjectList = PackageObject->Package.Elements;
+    ElementCount = PackageObject->Package.Count;
+
+    /* Examine each subpackage */
+
+    for (Index = 0; Index < ElementCount; Index++, TopObjectList++)
     {
-        return (AE_OK);
-    }
+        SubPackage = *TopObjectList;
+        SubObjectList = SubPackage->Package.Elements;
 
-    Status = AcpiNsCheckSortedList (Data, ReturnObject, 5, 1,
-                ACPI_SORT_DESCENDING, "PowerDissipation");
+        /* Check for minimum required element count */
 
-    return (Status);
+        if (SubPackage->Package.Count < 4)
+        {
+            continue;
+        }
+
+        /*
+         * If the BIOS has erroneously reversed the _PRT SourceName (index 2)
+         * and the SourceIndex (index 3), fix it. _PRT is important enough to
+         * workaround this BIOS error. This also provides compatibility with
+         * other ACPI implementations.
+         */
+        ObjDesc = SubObjectList[3];
+        if (!ObjDesc || (ObjDesc->Common.Type != ACPI_TYPE_INTEGER))
+        {
+            SubObjectList[3] = SubObjectList[2];
+            SubObjectList[2] = ObjDesc;
+            Info->ReturnFlags |= ACPI_OBJECT_REPAIRED;
+
+            ACPI_WARN_PREDEFINED ((AE_INFO,
+                Info->FullPathname, Info->NodeFlags,
+                "PRT[%X]: Fixed reversed SourceName and SourceIndex",
+                Index));
+        }
+    }
+
+    return (AE_OK);
 }
 
 
@@ -584,7 +729,7 @@ AcpiNsRepair_TSS (
  *
  * FUNCTION:    AcpiNsRepair_PSS
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              ReturnObjectPtr     - Pointer to the object returned from the
  *                                    evaluation of a method or object
  *
@@ -599,7 +744,7 @@ AcpiNsRepair_TSS (
 
 static ACPI_STATUS
 AcpiNsRepair_PSS (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
 {
     ACPI_OPERAND_OBJECT     *ReturnObject = *ReturnObjectPtr;
@@ -613,13 +758,13 @@ AcpiNsRepair_PSS (
 
 
     /*
-     * Entries (sub-packages) in the _PSS Package must be sorted by power
+     * Entries (subpackages) in the _PSS Package must be sorted by power
      * dissipation, in descending order. If it appears that the list is
      * incorrectly sorted, sort it. We sort by CpuFrequency, since this
      * should be proportional to the power.
      */
-    Status =AcpiNsCheckSortedList (Data, ReturnObject, 6, 0,
-                ACPI_SORT_DESCENDING, "CpuFrequency");
+    Status = AcpiNsCheckSortedList (Info, ReturnObject, 0, 6, 0,
+        ACPI_SORT_DESCENDING, "CpuFrequency");
     if (ACPI_FAILURE (Status))
     {
         return (Status);
@@ -640,7 +785,8 @@ AcpiNsRepair_PSS (
 
         if ((UINT32) ObjDesc->Integer.Value > PreviousValue)
         {
-            ACPI_WARN_PREDEFINED ((AE_INFO, Data->Pathname, Data->NodeFlags,
+            ACPI_WARN_PREDEFINED ((AE_INFO,
+                Info->FullPathname, Info->NodeFlags,
                 "SubPackage[%u,%u] - suspicious power dissipation values",
                 i-1, i));
         }
@@ -653,14 +799,62 @@ AcpiNsRepair_PSS (
 }
 
 
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiNsRepair_TSS
+ *
+ * PARAMETERS:  Info                - Method execution information block
+ *              ReturnObjectPtr     - Pointer to the object returned from the
+ *                                    evaluation of a method or object
+ *
+ * RETURN:      Status. AE_OK if object is OK or was repaired successfully
+ *
+ * DESCRIPTION: Repair for the _TSS object. If necessary, sort the object list
+ *              descending by the power dissipation values.
+ *
+ *****************************************************************************/
+
+static ACPI_STATUS
+AcpiNsRepair_TSS (
+    ACPI_EVALUATE_INFO      *Info,
+    ACPI_OPERAND_OBJECT     **ReturnObjectPtr)
+{
+    ACPI_OPERAND_OBJECT     *ReturnObject = *ReturnObjectPtr;
+    ACPI_STATUS             Status;
+    ACPI_NAMESPACE_NODE     *Node;
+
+
+    /*
+     * We can only sort the _TSS return package if there is no _PSS in the
+     * same scope. This is because if _PSS is present, the ACPI specification
+     * dictates that the _TSS Power Dissipation field is to be ignored, and
+     * therefore some BIOSs leave garbage values in the _TSS Power field(s).
+     * In this case, it is best to just return the _TSS package as-is.
+     * (May, 2011)
+     */
+    Status = AcpiNsGetNode (Info->Node, "^_PSS",
+        ACPI_NS_NO_UPSEARCH, &Node);
+    if (ACPI_SUCCESS (Status))
+    {
+        return (AE_OK);
+    }
+
+    Status = AcpiNsCheckSortedList (Info, ReturnObject, 0, 5, 1,
+        ACPI_SORT_DESCENDING, "PowerDissipation");
+
+    return (Status);
+}
+
+
 /******************************************************************************
  *
  * FUNCTION:    AcpiNsCheckSortedList
  *
- * PARAMETERS:  Data                - Pointer to validation data structure
+ * PARAMETERS:  Info                - Method execution information block
  *              ReturnObject        - Pointer to the top-level returned object
- *              ExpectedCount       - Minimum length of each sub-package
- *              SortIndex           - Sub-package entry to sort on
+ *              StartIndex          - Index of the first subpackage
+ *              ExpectedCount       - Minimum length of each subpackage
+ *              SortIndex           - Subpackage entry to sort on
  *              SortDirection       - Ascending or descending
  *              SortKeyName         - Name of the SortIndex field
  *
@@ -674,8 +868,9 @@ AcpiNsRepair_PSS (
 
 static ACPI_STATUS
 AcpiNsCheckSortedList (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     *ReturnObject,
+    UINT32                  StartIndex,
     UINT32                  ExpectedCount,
     UINT32                  SortIndex,
     UINT8                   SortDirection,
@@ -700,17 +895,19 @@ AcpiNsCheckSortedList (
     }
 
     /*
-     * NOTE: assumes list of sub-packages contains no NULL elements.
+     * NOTE: assumes list of subpackages contains no NULL elements.
      * Any NULL elements should have been removed by earlier call
      * to AcpiNsRemoveNullElements.
      */
-    OuterElements = ReturnObject->Package.Elements;
     OuterElementCount = ReturnObject->Package.Count;
-    if (!OuterElementCount)
+    if (!OuterElementCount || StartIndex >= OuterElementCount)
     {
         return (AE_AML_PACKAGE_LIMIT);
     }
 
+    OuterElements = &ReturnObject->Package.Elements[StartIndex];
+    OuterElementCount -= StartIndex;
+
     PreviousValue = 0;
     if (SortDirection == ACPI_SORT_DESCENDING)
     {
@@ -728,7 +925,7 @@ AcpiNsCheckSortedList (
             return (AE_AML_OPERAND_TYPE);
         }
 
-        /* Each sub-package must have the minimum length */
+        /* Each subpackage must have the minimum length */
 
         if ((*OuterElements)->Package.Count < ExpectedCount)
         {
@@ -752,14 +949,14 @@ AcpiNsCheckSortedList (
             ((SortDirection == ACPI_SORT_DESCENDING) &&
                 (ObjDesc->Integer.Value > PreviousValue)))
         {
-            AcpiNsSortList (ReturnObject->Package.Elements,
+            AcpiNsSortList (&ReturnObject->Package.Elements[StartIndex],
                 OuterElementCount, SortIndex, SortDirection);
 
-            Data->Flags |= ACPI_OBJECT_REPAIRED;
+            Info->ReturnFlags |= ACPI_OBJECT_REPAIRED;
 
             ACPI_DEBUG_PRINT ((ACPI_DB_REPAIR,
                 "%s: Repaired unsorted list - now sorted by %s\n",
-                Data->Pathname, SortKeyName));
+                Info->FullPathname, SortKeyName));
             return (AE_OK);
         }
 
@@ -825,3 +1022,62 @@ AcpiNsSortList (
         }
     }
 }
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiNsRemoveElement
+ *
+ * PARAMETERS:  ObjDesc             - Package object element list
+ *              Index               - Index of element to remove
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Remove the requested element of a package and delete it.
+ *
+ *****************************************************************************/
+
+static void
+AcpiNsRemoveElement (
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    UINT32                  Index)
+{
+    ACPI_OPERAND_OBJECT     **Source;
+    ACPI_OPERAND_OBJECT     **Dest;
+    UINT32                  Count;
+    UINT32                  NewCount;
+    UINT32                  i;
+
+
+    ACPI_FUNCTION_NAME (NsRemoveElement);
+
+
+    Count = ObjDesc->Package.Count;
+    NewCount = Count - 1;
+
+    Source = ObjDesc->Package.Elements;
+    Dest = Source;
+
+    /* Examine all elements of the package object, remove matched index */
+
+    for (i = 0; i < Count; i++)
+    {
+        if (i == Index)
+        {
+            AcpiUtRemoveReference (*Source); /* Remove one ref for being in pkg */
+            AcpiUtRemoveReference (*Source);
+        }
+        else
+        {
+            *Dest = *Source;
+            Dest++;
+        }
+
+        Source++;
+    }
+
+    /* NULL terminate list and update the package count */
+
+    *Dest = NULL;
+    ObjDesc->Package.Count = NewCount;
+}
diff --git a/usr/src/uts/intel/io/acpica/namespace/nssearch.c b/usr/src/uts/intel/io/acpica/namespace/nssearch.c
index d6f59ccbd1..3a0fe90ea4 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nssearch.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nssearch.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSSEARCH_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -114,7 +112,7 @@ AcpiNsSearchOneScope (
     {
         char                *ScopeName;
 
-        ScopeName = AcpiNsGetExternalPathname (ParentNode);
+        ScopeName = AcpiNsGetNormalizedPathname (ParentNode, TRUE);
         if (ScopeName)
         {
             ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
@@ -250,7 +248,7 @@ AcpiNsSearchParentTree (
          * the actual name we are searching for. Typechecking comes later.
          */
         Status = AcpiNsSearchOneScope (
-                    TargetName, ParentNode, ACPI_TYPE_ANY, ReturnNode);
+            TargetName, ParentNode, ACPI_TYPE_ANY, ReturnNode);
         if (ACPI_SUCCESS (Status))
         {
             return_ACPI_STATUS (Status);
@@ -340,10 +338,42 @@ AcpiNsSearchAndEnter (
          * If we found it AND the request specifies that a find is an error,
          * return the error
          */
-        if ((Status == AE_OK) &&
-            (Flags & ACPI_NS_ERROR_IF_FOUND))
+        if (Status == AE_OK)
         {
-            Status = AE_ALREADY_EXISTS;
+            /* The node was found in the namespace */
+
+            /*
+             * If the namespace override feature is enabled for this node,
+             * delete any existing attached sub-object and make the node
+             * look like a new node that is owned by the override table.
+             */
+            if (Flags & ACPI_NS_OVERRIDE_IF_FOUND)
+            {
+                ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
+                    "Namespace override: %4.4s pass %u type %X Owner %X\n",
+                    ACPI_CAST_PTR(char, &TargetName), InterpreterMode,
+                    (*ReturnNode)->Type, WalkState->OwnerId));
+
+                AcpiNsDeleteChildren (*ReturnNode);
+                if (AcpiGbl_RuntimeNamespaceOverride)
+                {
+                    AcpiUtRemoveReference ((*ReturnNode)->Object);
+                    (*ReturnNode)->Object = NULL;
+                    (*ReturnNode)->OwnerId = WalkState->OwnerId;
+                }
+                else
+                {
+                    AcpiNsRemoveNode (*ReturnNode);
+                    *ReturnNode = ACPI_ENTRY_NOT_FOUND;
+                }
+            }
+
+            /* Return an error if we don't expect to find the object */
+
+            else if (Flags & ACPI_NS_ERROR_IF_FOUND)
+            {
+                Status = AE_ALREADY_EXISTS;
+            }
         }
 
 #ifdef ACPI_ASL_COMPILER
@@ -421,4 +451,3 @@ AcpiNsSearchAndEnter (
     *ReturnNode = NewNode;
     return_ACPI_STATUS (AE_OK);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsutils.c b/usr/src/uts/intel/io/acpica/namespace/nsutils.c
index 43f734e819..72f9105ef5 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsutils.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsutils.c
@@ -6,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +42,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSUTILS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -54,10 +52,6 @@
 
 /* Local prototypes */
 
-static BOOLEAN
-AcpiNsValidPathSeparator (
-    char                    Sep);
-
 #ifdef ACPI_OBSOLETE_FUNCTIONS
 ACPI_NAME
 AcpiNsFindParentName (
@@ -96,7 +90,7 @@ AcpiNsPrintNodePathname (
 
     Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
 
-    Status = AcpiNsHandleToPathname (Node, &Buffer);
+    Status = AcpiNsHandleToPathname (Node, &Buffer, TRUE);
     if (ACPI_SUCCESS (Status))
     {
         if (Message)
@@ -110,48 +104,6 @@ AcpiNsPrintNodePathname (
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsValidRootPrefix
- *
- * PARAMETERS:  Prefix          - Character to be checked
- *
- * RETURN:      TRUE if a valid prefix
- *
- * DESCRIPTION: Check if a character is a valid ACPI Root prefix
- *
- ******************************************************************************/
-
-BOOLEAN
-AcpiNsValidRootPrefix (
-    char                    Prefix)
-{
-
-    return ((BOOLEAN) (Prefix == '\\'));
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiNsValidPathSeparator
- *
- * PARAMETERS:  Sep         - Character to be checked
- *
- * RETURN:      TRUE if a valid path separator
- *
- * DESCRIPTION: Check if a character is a valid ACPI path separator
- *
- ******************************************************************************/
-
-static BOOLEAN
-AcpiNsValidPathSeparator (
-    char                    Sep)
-{
-
-    return ((BOOLEAN) (Sep == '.'));
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiNsGetType
@@ -174,10 +126,10 @@ AcpiNsGetType (
     if (!Node)
     {
         ACPI_WARNING ((AE_INFO, "Null Node parameter"));
-        return_UINT32 (ACPI_TYPE_ANY);
+        return_UINT8 (ACPI_TYPE_ANY);
     }
 
-    return_UINT32 ((ACPI_OBJECT_TYPE) Node->Type);
+    return_UINT8 (Node->Type);
 }
 
 
@@ -209,7 +161,7 @@ AcpiNsLocal (
         return_UINT32 (ACPI_NS_NORMAL);
     }
 
-    return_UINT32 ((UINT32) AcpiGbl_NsProperties[Type] & ACPI_NS_LOCAL);
+    return_UINT32 (AcpiGbl_NsProperties[Type] & ACPI_NS_LOCAL);
 }
 
 
@@ -244,20 +196,21 @@ AcpiNsGetInternalNameLength (
     Info->FullyQualified = FALSE;
 
     /*
-     * For the internal name, the required length is 4 bytes per segment, plus
-     * 1 each for RootPrefix, MultiNamePrefixOp, segment count, trailing null
-     * (which is not really needed, but no there's harm in putting it there)
+     * For the internal name, the required length is 4 bytes per segment,
+     * plus 1 each for RootPrefix, MultiNamePrefixOp, segment count,
+     * trailing null (which is not really needed, but no there's harm in
+     * putting it there)
      *
      * strlen() + 1 covers the first NameSeg, which has no path separator
      */
-    if (AcpiNsValidRootPrefix (*NextExternalChar))
+    if (ACPI_IS_ROOT_PREFIX (*NextExternalChar))
     {
         Info->FullyQualified = TRUE;
         NextExternalChar++;
 
         /* Skip redundant RootPrefix, like \\_SB.PCI0.SBRG.EC0 */
 
-        while (AcpiNsValidRootPrefix (*NextExternalChar))
+        while (ACPI_IS_ROOT_PREFIX (*NextExternalChar))
         {
             NextExternalChar++;
         }
@@ -266,7 +219,7 @@ AcpiNsGetInternalNameLength (
     {
         /* Handle Carat prefixes */
 
-        while (*NextExternalChar == '^')
+        while (ACPI_IS_PARENT_PREFIX (*NextExternalChar))
         {
             Info->NumCarats++;
             NextExternalChar++;
@@ -283,7 +236,7 @@ AcpiNsGetInternalNameLength (
         Info->NumSegments = 1;
         for (i = 0; NextExternalChar[i]; i++)
         {
-            if (AcpiNsValidPathSeparator (NextExternalChar[i]))
+            if (ACPI_IS_PATH_SEPARATOR (NextExternalChar[i]))
             {
                 Info->NumSegments++;
             }
@@ -291,7 +244,7 @@ AcpiNsGetInternalNameLength (
     }
 
     Info->Length = (ACPI_NAME_SIZE * Info->NumSegments) +
-                    4 + Info->NumCarats;
+        4 + Info->NumCarats;
 
     Info->NextExternalChar = NextExternalChar;
 }
@@ -328,7 +281,7 @@ AcpiNsBuildInternalName (
 
     if (Info->FullyQualified)
     {
-        InternalName[0] = '\\';
+        InternalName[0] = AML_ROOT_PREFIX;
 
         if (NumSegments <= 1)
         {
@@ -357,7 +310,7 @@ AcpiNsBuildInternalName (
         {
             for (i = 0; i < Info->NumCarats; i++)
             {
-                InternalName[i] = '^';
+                InternalName[i] = AML_PARENT_PREFIX;
             }
         }
 
@@ -384,7 +337,7 @@ AcpiNsBuildInternalName (
     {
         for (i = 0; i < ACPI_NAME_SIZE; i++)
         {
-            if (AcpiNsValidPathSeparator (*ExternalName) ||
+            if (ACPI_IS_PATH_SEPARATOR (*ExternalName) ||
                (*ExternalName == 0))
             {
                 /* Pad the segment with underscore(s) if segment is short */
@@ -395,14 +348,14 @@ AcpiNsBuildInternalName (
             {
                 /* Convert the character to uppercase and save it */
 
-                Result[i] = (char) ACPI_TOUPPER ((int) *ExternalName);
+                Result[i] = (char) toupper ((int) *ExternalName);
                 ExternalName++;
             }
         }
 
         /* Now we must have a path separator, or the pathname is bad */
 
-        if (!AcpiNsValidPathSeparator (*ExternalName) &&
+        if (!ACPI_IS_PATH_SEPARATOR (*ExternalName) &&
             (*ExternalName != 0))
         {
             return_ACPI_STATUS (AE_BAD_PATHNAME);
@@ -542,14 +495,16 @@ AcpiNsExternalizeName (
 
     switch (InternalName[0])
     {
-    case '\\':
+    case AML_ROOT_PREFIX:
+
         PrefixLength = 1;
         break;
 
-    case '^':
+    case AML_PARENT_PREFIX:
+
         for (i = 0; i < InternalNameLength; i++)
         {
-            if (InternalName[i] == '^')
+            if (ACPI_IS_PARENT_PREFIX (InternalName[i]))
             {
                 PrefixLength = i + 1;
             }
@@ -567,6 +522,7 @@ AcpiNsExternalizeName (
         break;
 
     default:
+
         break;
     }
 
@@ -619,10 +575,10 @@ AcpiNsExternalizeName (
      * punctuation ('.') between object names, plus the NULL terminator.
      */
     RequiredLength = PrefixLength + (4 * NumSegments) +
-                        ((NumSegments > 0) ? (NumSegments - 1) : 0) + 1;
+        ((NumSegments > 0) ? (NumSegments - 1) : 0) + 1;
 
     /*
-     * Check to see if we're still in bounds.  If not, there's a problem
+     * Check to see if we're still in bounds. If not, there's a problem
      * with InternalName (invalid format).
      */
     if (RequiredLength > InternalNameLength)
@@ -655,10 +611,14 @@ AcpiNsExternalizeName (
                 (*ConvertedName)[j++] = '.';
             }
 
-            (*ConvertedName)[j++] = InternalName[NamesIndex++];
-            (*ConvertedName)[j++] = InternalName[NamesIndex++];
-            (*ConvertedName)[j++] = InternalName[NamesIndex++];
-            (*ConvertedName)[j++] = InternalName[NamesIndex++];
+            /* Copy and validate the 4-char name segment */
+
+            ACPI_MOVE_NAME (&(*ConvertedName)[j],
+                &InternalName[NamesIndex]);
+            AcpiUtRepairName (&(*ConvertedName)[j]);
+
+            j += ACPI_NAME_SIZE;
+            NamesIndex += ACPI_NAME_SIZE;
         }
     }
 
@@ -733,27 +693,47 @@ void
 AcpiNsTerminate (
     void)
 {
-    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_STATUS             Status;
 
 
     ACPI_FUNCTION_TRACE (NsTerminate);
 
 
+#ifdef ACPI_EXEC_APP
+    {
+        ACPI_OPERAND_OBJECT     *Prev;
+        ACPI_OPERAND_OBJECT     *Next;
+
+        /* Delete any module-level code blocks */
+
+        Next = AcpiGbl_ModuleCodeList;
+        while (Next)
+        {
+            Prev = Next;
+            Next = Next->Method.Mutex;
+            Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */
+            AcpiUtRemoveReference (Prev);
+        }
+    }
+#endif
+
     /*
-     * 1) Free the entire namespace -- all nodes and objects
-     *
-     * Delete all object descriptors attached to namepsace nodes
+     * Free the entire namespace -- all nodes and all objects
+     * attached to the nodes
      */
     AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);
 
-    /* Detach any objects attached to the root */
+    /* Delete any objects attached to the root node */
 
-    ObjDesc = AcpiNsGetAttachedObject (AcpiGbl_RootNode);
-    if (ObjDesc)
+    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
+    if (ACPI_FAILURE (Status))
     {
-        AcpiNsDetachObject (AcpiGbl_RootNode);
+        return_VOID;
     }
 
+    AcpiNsDeleteNode (AcpiGbl_RootNode);
+    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Namespace freed\n"));
     return_VOID;
 }
@@ -774,18 +754,18 @@ UINT32
 AcpiNsOpensScope (
     ACPI_OBJECT_TYPE        Type)
 {
-    ACPI_FUNCTION_TRACE_STR (NsOpensScope, AcpiUtGetTypeName (Type));
+    ACPI_FUNCTION_ENTRY ();
 
 
-    if (!AcpiUtValidObjectType (Type))
+    if (Type > ACPI_TYPE_LOCAL_MAX)
     {
         /* type code out of range  */
 
         ACPI_WARNING ((AE_INFO, "Invalid Object Type 0x%X", Type));
-        return_UINT32 (ACPI_NS_NORMAL);
+        return (ACPI_NS_NORMAL);
     }
 
-    return_UINT32 (((UINT32) AcpiGbl_NsProperties[Type]) & ACPI_NS_NEWSCOPE);
+    return (((UINT32) AcpiGbl_NsProperties[Type]) & ACPI_NS_NEWSCOPE);
 }
 
 
@@ -797,7 +777,7 @@ AcpiNsOpensScope (
  *                            \ (backslash) and ^ (carat) prefixes, and the
  *                            . (period) to separate segments are supported.
  *              PrefixNode   - Root of subtree to be searched, or NS_ALL for the
- *                            root of the name space.  If Name is fully
+ *                            root of the name space. If Name is fully
  *                            qualified (first INT8 is '\'), the passed value
  *                            of Scope will not be accessed.
  *              Flags       - Used to indicate whether to perform upsearch or
@@ -805,7 +785,7 @@ AcpiNsOpensScope (
  *              ReturnNode  - Where the Node is returned
  *
  * DESCRIPTION: Look up a name relative to a given scope and return the
- *              corresponding Node.  NOTE: Scope can be null.
+ *              corresponding Node. NOTE: Scope can be null.
  *
  * MUTEX:       Locks namespace
  *
@@ -826,6 +806,8 @@ AcpiNsGetNode (
     ACPI_FUNCTION_TRACE_PTR (NsGetNode, ACPI_CAST_PTR (char, Pathname));
 
 
+    /* Simplest case is a null pathname */
+
     if (!Pathname)
     {
         *ReturnNode = PrefixNode;
@@ -833,6 +815,15 @@ AcpiNsGetNode (
         {
             *ReturnNode = AcpiGbl_RootNode;
         }
+
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    /* Quick check for a reference to the root */
+
+    if (ACPI_IS_ROOT_PREFIX (Pathname[0]) && (!Pathname[1]))
+    {
+        *ReturnNode = AcpiGbl_RootNode;
         return_ACPI_STATUS (AE_OK);
     }
 
@@ -859,12 +850,12 @@ AcpiNsGetNode (
     /* Lookup the name in the namespace */
 
     Status = AcpiNsLookup (&ScopeInfo, InternalPath, ACPI_TYPE_ANY,
-                ACPI_IMODE_EXECUTE, (Flags | ACPI_NS_DONT_OPEN_SCOPE),
-                NULL, ReturnNode);
+        ACPI_IMODE_EXECUTE, (Flags | ACPI_NS_DONT_OPEN_SCOPE),
+        NULL, ReturnNode);
     if (ACPI_FAILURE (Status))
     {
         ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%s, %s\n",
-                Pathname, AcpiFormatException (Status)));
+            Pathname, AcpiFormatException (Status)));
     }
 
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
diff --git a/usr/src/uts/intel/io/acpica/namespace/nswalk.c b/usr/src/uts/intel/io/acpica/namespace/nswalk.c
index 35c3e17896..08637a6eee 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nswalk.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nswalk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __NSWALK_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -65,8 +62,8 @@
  * RETURN:      ACPI_NAMESPACE_NODE - Pointer to the NEXT child or NULL if
  *                                    none is found.
  *
- * DESCRIPTION: Return the next peer node within the namespace.  If Handle
- *              is valid, Scope is ignored.  Otherwise, the first node
+ * DESCRIPTION: Return the next peer node within the namespace. If Handle
+ *              is valid, Scope is ignored. Otherwise, the first node
  *              within Scope is returned.
  *
  ******************************************************************************/
@@ -105,8 +102,8 @@ AcpiNsGetNextNode (
  * RETURN:      ACPI_NAMESPACE_NODE - Pointer to the NEXT child or NULL if
  *                                    none is found.
  *
- * DESCRIPTION: Return the next peer node within the namespace.  If Handle
- *              is valid, Scope is ignored.  Otherwise, the first node
+ * DESCRIPTION: Return the next peer node within the namespace. If Handle
+ *              is valid, Scope is ignored. Otherwise, the first node
  *              within Scope is returned.
  *
  ******************************************************************************/
@@ -165,9 +162,9 @@ AcpiNsGetNextNodeTyped (
  *              MaxDepth            - Depth to which search is to reach
  *              Flags               - Whether to unlock the NS before invoking
  *                                    the callback routine
- *              PreOrderVisit       - Called during tree pre-order visit
+ *              DescendingCallback  - Called during tree descent
  *                                    when an object of "Type" is found
- *              PostOrderVisit      - Called during tree post-order visit
+ *              AscendingCallback   - Called during tree ascent
  *                                    when an object of "Type" is found
  *              Context             - Passed to user function(s) above
  *              ReturnValue         - from the UserFunction if terminated
@@ -195,8 +192,8 @@ AcpiNsWalkNamespace (
     ACPI_HANDLE             StartNode,
     UINT32                  MaxDepth,
     UINT32                  Flags,
-    ACPI_WALK_CALLBACK      PreOrderVisit,
-    ACPI_WALK_CALLBACK      PostOrderVisit,
+    ACPI_WALK_CALLBACK      DescendingCallback,
+    ACPI_WALK_CALLBACK      AscendingCallback,
     void                    *Context,
     void                    **ReturnValue)
 {
@@ -221,10 +218,10 @@ AcpiNsWalkNamespace (
 
     /* Null child means "get first node" */
 
-    ParentNode  = StartNode;
-    ChildNode   = AcpiNsGetNextNode (ParentNode, NULL);
-    ChildType   = ACPI_TYPE_ANY;
-    Level       = 1;
+    ParentNode = StartNode;
+    ChildNode = AcpiNsGetNextNode (ParentNode, NULL);
+    ChildType = ACPI_TYPE_ANY;
+    Level = 1;
 
     /*
      * Traverse the tree of nodes until we bubble back up to where we
@@ -274,23 +271,23 @@ AcpiNsWalkNamespace (
             }
 
             /*
-             * Invoke the user function, either pre-order or post-order
+             * Invoke the user function, either descending, ascending,
              * or both.
              */
             if (!NodePreviouslyVisited)
             {
-                if (PreOrderVisit)
+                if (DescendingCallback)
                 {
-                    Status = PreOrderVisit (ChildNode, Level,
-                                Context, ReturnValue);
+                    Status = DescendingCallback (ChildNode, Level,
+                        Context, ReturnValue);
                 }
             }
             else
             {
-                if (PostOrderVisit)
+                if (AscendingCallback)
                 {
-                    Status = PostOrderVisit (ChildNode, Level,
-                                Context, ReturnValue);
+                    Status = AscendingCallback (ChildNode, Level,
+                        Context, ReturnValue);
                 }
             }
 
@@ -327,7 +324,7 @@ AcpiNsWalkNamespace (
 
         /*
          * Depth first search: Attempt to go down another level in the
-         * namespace if we are allowed to.  Don't go any further if we have
+         * namespace if we are allowed to. Don't go any further if we have
          * reached the caller specified maximum depth or if the user
          * function has specified that the maximum depth has been reached.
          */
@@ -382,5 +379,3 @@ AcpiNsWalkNamespace (
 
     return_ACPI_STATUS (AE_OK);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsxfeval.c b/usr/src/uts/intel/io/acpica/namespace/nsxfeval.c
index 5006588e85..b88ecf507e 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsxfeval.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsxfeval.c
@@ -6,7 +6,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +42,7 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __NSXFEVAL_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
@@ -68,16 +67,16 @@ AcpiNsResolveReferences (
  * PARAMETERS:  Handle              - Object handle (optional)
  *              Pathname            - Object pathname (optional)
  *              ExternalParams      - List of parameters to pass to method,
- *                                    terminated by NULL.  May be NULL
+ *                                    terminated by NULL. May be NULL
  *                                    if no parameters are being passed.
  *              ReturnBuffer        - Where to put method's return value (if
- *                                    any).  If NULL, no value is returned.
+ *                                    any). If NULL, no value is returned.
  *              ReturnType          - Expected type of return object
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Find and evaluate the given object, passing the given
- *              parameters if necessary.  One of "Handle" or "Pathname" must
+ *              parameters if necessary. One of "Handle" or "Pathname" must
  *              be valid (non-null)
  *
  ******************************************************************************/
@@ -91,7 +90,7 @@ AcpiEvaluateObjectTyped (
     ACPI_OBJECT_TYPE        ReturnType)
 {
     ACPI_STATUS             Status;
-    BOOLEAN                 MustFree = FALSE;
+    BOOLEAN                 FreeBufferOnError = FALSE;
 
 
     ACPI_FUNCTION_TRACE (AcpiEvaluateObjectTyped);
@@ -106,12 +105,13 @@ AcpiEvaluateObjectTyped (
 
     if (ReturnBuffer->Length == ACPI_ALLOCATE_BUFFER)
     {
-        MustFree = TRUE;
+        FreeBufferOnError = TRUE;
     }
 
     /* Evaluate the object */
 
-    Status = AcpiEvaluateObject (Handle, Pathname, ExternalParams, ReturnBuffer);
+    Status = AcpiEvaluateObject (Handle, Pathname,
+        ExternalParams, ReturnBuffer);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -146,10 +146,15 @@ AcpiEvaluateObjectTyped (
         AcpiUtGetTypeName (((ACPI_OBJECT *) ReturnBuffer->Pointer)->Type),
         AcpiUtGetTypeName (ReturnType)));
 
-    if (MustFree)
+    if (FreeBufferOnError)
     {
-        /* Caller used ACPI_ALLOCATE_BUFFER, free the return buffer */
-
+        /*
+         * Free a buffer created via ACPI_ALLOCATE_BUFFER.
+         * Note: We use AcpiOsFree here because AcpiOsAllocate was used
+         * to allocate the buffer. This purposefully bypasses the
+         * (optionally enabled) allocation tracking mechanism since we
+         * only want to track internal allocations.
+         */
         AcpiOsFree (ReturnBuffer->Pointer);
         ReturnBuffer->Pointer = NULL;
     }
@@ -168,15 +173,15 @@ ACPI_EXPORT_SYMBOL (AcpiEvaluateObjectTyped)
  * PARAMETERS:  Handle              - Object handle (optional)
  *              Pathname            - Object pathname (optional)
  *              ExternalParams      - List of parameters to pass to method,
- *                                    terminated by NULL.  May be NULL
+ *                                    terminated by NULL. May be NULL
  *                                    if no parameters are being passed.
  *              ReturnBuffer        - Where to put method's return value (if
- *                                    any).  If NULL, no value is returned.
+ *                                    any). If NULL, no value is returned.
  *
  * RETURN:      Status
  *
  * DESCRIPTION: Find and evaluate the given object, passing the given
- *              parameters if necessary.  One of "Handle" or "Pathname" must
+ *              parameters if necessary. One of "Handle" or "Pathname" must
  *              be valid (non-null)
  *
  ******************************************************************************/
@@ -205,8 +210,6 @@ AcpiEvaluateObject (
         return_ACPI_STATUS (AE_NO_MEMORY);
     }
 
-    Info->Pathname = Pathname;
-
     /* Convert and validate the device handle */
 
     Info->PrefixNode = AcpiNsValidateHandle (Handle);
@@ -217,17 +220,69 @@ AcpiEvaluateObject (
     }
 
     /*
-     * If there are parameters to be passed to a control method, the external
-     * objects must all be converted to internal objects
+     * Get the actual namespace node for the target object.
+     * Handles these cases:
+     *
+     * 1) Null node, valid pathname from root (absolute path)
+     * 2) Node and valid pathname (path relative to Node)
+     * 3) Node, Null pathname
+     */
+    if ((Pathname) &&
+        (ACPI_IS_ROOT_PREFIX (Pathname[0])))
+    {
+        /* The path is fully qualified, just evaluate by name */
+
+        Info->PrefixNode = NULL;
+    }
+    else if (!Handle)
+    {
+        /*
+         * A handle is optional iff a fully qualified pathname is specified.
+         * Since we've already handled fully qualified names above, this is
+         * an error.
+         */
+        if (!Pathname)
+        {
+            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+                "Both Handle and Pathname are NULL"));
+        }
+        else
+        {
+            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+                "Null Handle with relative pathname [%s]", Pathname));
+        }
+
+        Status = AE_BAD_PARAMETER;
+        goto Cleanup;
+    }
+
+    Info->RelativePathname = Pathname;
+
+    /*
+     * Convert all external objects passed as arguments to the
+     * internal version(s).
      */
     if (ExternalParams && ExternalParams->Count)
     {
+        Info->ParamCount = (UINT16) ExternalParams->Count;
+
+        /* Warn on impossible argument count */
+
+        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)
+        {
+            ACPI_WARN_PREDEFINED ((AE_INFO, Pathname, ACPI_WARN_ALWAYS,
+                "Excess arguments (%u) - using only %u",
+                Info->ParamCount, ACPI_METHOD_NUM_ARGS));
+
+            Info->ParamCount = ACPI_METHOD_NUM_ARGS;
+        }
+
         /*
          * Allocate a new parameter block for the internal objects
          * Add 1 to count to allow for null terminated internal list
          */
         Info->Parameters = ACPI_ALLOCATE_ZEROED (
-            ((ACPI_SIZE) ExternalParams->Count + 1) * sizeof (void *));
+            ((ACPI_SIZE) Info->ParamCount + 1) * sizeof (void *));
         if (!Info->Parameters)
         {
             Status = AE_NO_MEMORY;
@@ -236,126 +291,181 @@ AcpiEvaluateObject (
 
         /* Convert each external object in the list to an internal object */
 
-        for (i = 0; i < ExternalParams->Count; i++)
+        for (i = 0; i < Info->ParamCount; i++)
         {
             Status = AcpiUtCopyEobjectToIobject (
-                        &ExternalParams->Pointer[i], &Info->Parameters[i]);
+                &ExternalParams->Pointer[i], &Info->Parameters[i]);
             if (ACPI_FAILURE (Status))
             {
                 goto Cleanup;
             }
         }
-        Info->Parameters[ExternalParams->Count] = NULL;
+
+        Info->Parameters[Info->ParamCount] = NULL;
     }
 
+
+#ifdef _FUTURE_FEATURE
+
     /*
-     * Three major cases:
-     * 1) Fully qualified pathname
-     * 2) No handle, not fully qualified pathname (error)
-     * 3) Valid handle
+     * Begin incoming argument count analysis. Check for too few args
+     * and too many args.
      */
-    if ((Pathname) &&
-        (AcpiNsValidRootPrefix (Pathname[0])))
+    switch (AcpiNsGetType (Info->Node))
     {
-        /* The path is fully qualified, just evaluate by name */
+    case ACPI_TYPE_METHOD:
+
+        /* Check incoming argument count against the method definition */
+
+        if (Info->ObjDesc->Method.ParamCount > Info->ParamCount)
+        {
+            ACPI_ERROR ((AE_INFO,
+                "Insufficient arguments (%u) - %u are required",
+                Info->ParamCount,
+                Info->ObjDesc->Method.ParamCount));
+
+            Status = AE_MISSING_ARGUMENTS;
+            goto Cleanup;
+        }
+
+        else if (Info->ObjDesc->Method.ParamCount < Info->ParamCount)
+        {
+            ACPI_WARNING ((AE_INFO,
+                "Excess arguments (%u) - only %u are required",
+                Info->ParamCount,
+                Info->ObjDesc->Method.ParamCount));
+
+            /* Just pass the required number of arguments */
+
+            Info->ParamCount = Info->ObjDesc->Method.ParamCount;
+        }
 
-        Info->PrefixNode = NULL;
-        Status = AcpiNsEvaluate (Info);
-    }
-    else if (!Handle)
-    {
         /*
-         * A handle is optional iff a fully qualified pathname is specified.
-         * Since we've already handled fully qualified names above, this is
-         * an error
+         * Any incoming external objects to be passed as arguments to the
+         * method must be converted to internal objects
          */
-        if (!Pathname)
+        if (Info->ParamCount)
         {
-            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-                "Both Handle and Pathname are NULL"));
+            /*
+             * Allocate a new parameter block for the internal objects
+             * Add 1 to count to allow for null terminated internal list
+             */
+            Info->Parameters = ACPI_ALLOCATE_ZEROED (
+                ((ACPI_SIZE) Info->ParamCount + 1) * sizeof (void *));
+            if (!Info->Parameters)
+            {
+                Status = AE_NO_MEMORY;
+                goto Cleanup;
+            }
+
+            /* Convert each external object in the list to an internal object */
+
+            for (i = 0; i < Info->ParamCount; i++)
+            {
+                Status = AcpiUtCopyEobjectToIobject (
+                    &ExternalParams->Pointer[i], &Info->Parameters[i]);
+                if (ACPI_FAILURE (Status))
+                {
+                    goto Cleanup;
+                }
+            }
+
+            Info->Parameters[Info->ParamCount] = NULL;
         }
-        else
+        break;
+
+    default:
+
+        /* Warn if arguments passed to an object that is not a method */
+
+        if (Info->ParamCount)
         {
-            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-                "Null Handle with relative pathname [%s]", Pathname));
+            ACPI_WARNING ((AE_INFO,
+                "%u arguments were passed to a non-method ACPI object",
+                Info->ParamCount));
         }
-
-        Status = AE_BAD_PARAMETER;
+        break;
     }
-    else
-    {
-        /* We have a namespace a node and a possible relative path */
 
-        Status = AcpiNsEvaluate (Info);
-    }
+#endif
+
+
+    /* Now we can evaluate the object */
+
+    Status = AcpiNsEvaluate (Info);
 
     /*
      * If we are expecting a return value, and all went well above,
      * copy the return value to an external object.
      */
-    if (ReturnBuffer)
+    if (!ReturnBuffer)
     {
-        if (!Info->ReturnObject)
+        goto CleanupReturnObject;
+    }
+
+    if (!Info->ReturnObject)
+    {
+        ReturnBuffer->Length = 0;
+        goto Cleanup;
+    }
+
+    if (ACPI_GET_DESCRIPTOR_TYPE (Info->ReturnObject) ==
+        ACPI_DESC_TYPE_NAMED)
+    {
+        /*
+         * If we received a NS Node as a return object, this means that
+         * the object we are evaluating has nothing interesting to
+         * return (such as a mutex, etc.)  We return an error because
+         * these types are essentially unsupported by this interface.
+         * We don't check up front because this makes it easier to add
+         * support for various types at a later date if necessary.
+         */
+        Status = AE_TYPE;
+        Info->ReturnObject = NULL;   /* No need to delete a NS Node */
+        ReturnBuffer->Length = 0;
+    }
+
+    if (ACPI_FAILURE (Status))
+    {
+        goto CleanupReturnObject;
+    }
+
+    /* Dereference Index and RefOf references */
+
+    AcpiNsResolveReferences (Info);
+
+    /* Get the size of the returned object */
+
+    Status = AcpiUtGetObjectSize (Info->ReturnObject,
+        &BufferSpaceNeeded);
+    if (ACPI_SUCCESS (Status))
+    {
+        /* Validate/Allocate/Clear caller buffer */
+
+        Status = AcpiUtInitializeBuffer (ReturnBuffer,
+            BufferSpaceNeeded);
+        if (ACPI_FAILURE (Status))
         {
-            ReturnBuffer->Length = 0;
+            /*
+             * Caller's buffer is too small or a new one can't
+             * be allocated
+             */
+            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+                "Needed buffer size %X, %s\n",
+                (UINT32) BufferSpaceNeeded,
+                AcpiFormatException (Status)));
         }
         else
         {
-            if (ACPI_GET_DESCRIPTOR_TYPE (Info->ReturnObject) ==
-                ACPI_DESC_TYPE_NAMED)
-            {
-                /*
-                 * If we received a NS Node as a return object, this means that
-                 * the object we are evaluating has nothing interesting to
-                 * return (such as a mutex, etc.)  We return an error because
-                 * these types are essentially unsupported by this interface.
-                 * We don't check up front because this makes it easier to add
-                 * support for various types at a later date if necessary.
-                 */
-                Status = AE_TYPE;
-                Info->ReturnObject = NULL;   /* No need to delete a NS Node */
-                ReturnBuffer->Length = 0;
-            }
-
-            if (ACPI_SUCCESS (Status))
-            {
-                /* Dereference Index and RefOf references */
-
-                AcpiNsResolveReferences (Info);
-
-                /* Get the size of the returned object */
+            /* We have enough space for the object, build it */
 
-                Status = AcpiUtGetObjectSize (Info->ReturnObject,
-                            &BufferSpaceNeeded);
-                if (ACPI_SUCCESS (Status))
-                {
-                    /* Validate/Allocate/Clear caller buffer */
-
-                    Status = AcpiUtInitializeBuffer (ReturnBuffer,
-                                BufferSpaceNeeded);
-                    if (ACPI_FAILURE (Status))
-                    {
-                        /*
-                         * Caller's buffer is too small or a new one can't
-                         * be allocated
-                         */
-                        ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-                            "Needed buffer size %X, %s\n",
-                            (UINT32) BufferSpaceNeeded,
-                            AcpiFormatException (Status)));
-                    }
-                    else
-                    {
-                        /* We have enough space for the object, build it */
-
-                        Status = AcpiUtCopyIobjectToEobject (Info->ReturnObject,
-                                    ReturnBuffer);
-                    }
-                }
-            }
+            Status = AcpiUtCopyIobjectToEobject (
+                Info->ReturnObject, ReturnBuffer);
         }
     }
 
+CleanupReturnObject:
+
     if (Info->ReturnObject)
     {
         /*
@@ -449,6 +559,7 @@ AcpiNsResolveReferences (
         break;
 
     default:
+
         return;
     }
 
@@ -472,9 +583,9 @@ AcpiNsResolveReferences (
  * PARAMETERS:  Type                - ACPI_OBJECT_TYPE to search for
  *              StartObject         - Handle in namespace where search begins
  *              MaxDepth            - Depth to which search is to reach
- *              PreOrderVisit       - Called during tree pre-order visit
+ *              DescendingCallback  - Called during tree descent
  *                                    when an object of "Type" is found
- *              PostOrderVisit      - Called during tree post-order visit
+ *              AscendingCallback   - Called during tree ascent
  *                                    when an object of "Type" is found
  *              Context             - Passed to user function(s) above
  *              ReturnValue         - Location where return value of
@@ -503,8 +614,8 @@ AcpiWalkNamespace (
     ACPI_OBJECT_TYPE        Type,
     ACPI_HANDLE             StartObject,
     UINT32                  MaxDepth,
-    ACPI_WALK_CALLBACK      PreOrderVisit,
-    ACPI_WALK_CALLBACK      PostOrderVisit,
+    ACPI_WALK_CALLBACK      DescendingCallback,
+    ACPI_WALK_CALLBACK      AscendingCallback,
     void                    *Context,
     void                    **ReturnValue)
 {
@@ -518,7 +629,7 @@ AcpiWalkNamespace (
 
     if ((Type > ACPI_TYPE_LOCAL_MAX) ||
         (!MaxDepth)                  ||
-        (!PreOrderVisit && !PostOrderVisit))
+        (!DescendingCallback && !AscendingCallback))
     {
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
@@ -537,7 +648,7 @@ AcpiWalkNamespace (
     Status = AcpiUtAcquireReadLock (&AcpiGbl_NamespaceRwLock);
     if (ACPI_FAILURE (Status))
     {
-        return (Status);
+        return_ACPI_STATUS (Status);
     }
 
     /*
@@ -552,10 +663,19 @@ AcpiWalkNamespace (
         goto UnlockAndExit;
     }
 
+    /* Now we can validate the starting node */
+
+    if (!AcpiNsValidateHandle (StartObject))
+    {
+        Status = AE_BAD_PARAMETER;
+        goto UnlockAndExit2;
+    }
+
     Status = AcpiNsWalkNamespace (Type, StartObject, MaxDepth,
-                ACPI_NS_WALK_UNLOCK, PreOrderVisit,
-                PostOrderVisit, Context, ReturnValue);
+        ACPI_NS_WALK_UNLOCK, DescendingCallback,
+        AscendingCallback, Context, ReturnValue);
 
+UnlockAndExit2:
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
 
 UnlockAndExit:
@@ -591,8 +711,8 @@ AcpiNsGetDeviceCallback (
     ACPI_STATUS             Status;
     ACPI_NAMESPACE_NODE     *Node;
     UINT32                  Flags;
-    ACPI_DEVICE_ID          *Hid;
-    ACPI_DEVICE_ID_LIST     *Cid;
+    ACPI_PNP_DEVICE_ID      *Hid;
+    ACPI_PNP_DEVICE_ID_LIST *Cid;
     UINT32                  i;
     BOOLEAN                 Found;
     int                     NoMatch;
@@ -642,7 +762,7 @@ AcpiNsGetDeviceCallback (
             return (AE_CTRL_DEPTH);
         }
 
-        NoMatch = ACPI_STRCMP (Hid->String, Info->Hid);
+        NoMatch = strcmp (Hid->String, Info->Hid);
         ACPI_FREE (Hid);
 
         if (NoMatch)
@@ -666,7 +786,7 @@ AcpiNsGetDeviceCallback (
             Found = FALSE;
             for (i = 0; i < Cid->Count; i++)
             {
-                if (ACPI_STRCMP (Cid->Ids[i].String, Info->Hid) == 0)
+                if (strcmp (Cid->Ids[i].String, Info->Hid) == 0)
                 {
                     /* Found a matching CID */
 
@@ -704,8 +824,8 @@ AcpiNsGetDeviceCallback (
 
     /* We have a valid device, invoke the user function */
 
-    Status = Info->UserFunction (ObjHandle, NestingLevel, Info->Context,
-                ReturnValue);
+    Status = Info->UserFunction (ObjHandle, NestingLevel,
+        Info->Context, ReturnValue);
     return (Status);
 }
 
@@ -726,7 +846,7 @@ AcpiNsGetDeviceCallback (
  * DESCRIPTION: Performs a modified depth-first walk of the namespace tree,
  *              starting (and ending) at the object specified by StartHandle.
  *              The UserFunction is called whenever an object of type
- *              Device is found.  If the user function returns
+ *              Device is found. If the user function returns
  *              a non-zero value, the search is terminated immediately and this
  *              value is returned to the caller.
  *
@@ -760,8 +880,8 @@ AcpiGetDevices (
      * We're going to call their callback from OUR callback, so we need
      * to know what it is, and their context parameter.
      */
-    Info.Hid          = HID;
-    Info.Context      = Context;
+    Info.Hid = HID;
+    Info.Context = Context;
     Info.UserFunction = UserFunction;
 
     /*
@@ -777,8 +897,8 @@ AcpiGetDevices (
     }
 
     Status = AcpiNsWalkNamespace (ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
-                ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
-                AcpiNsGetDeviceCallback, NULL, &Info, ReturnValue);
+        ACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,
+        AcpiNsGetDeviceCallback, NULL, &Info, ReturnValue);
 
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
     return_ACPI_STATUS (Status);
@@ -956,5 +1076,3 @@ UnlockAndExit:
 }
 
 ACPI_EXPORT_SYMBOL (AcpiGetData)
-
-
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsxfname.c b/usr/src/uts/intel/io/acpica/namespace/nsxfname.c
index 4690d09e90..cfd6937f49 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsxfname.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsxfname.c
@@ -6,7 +6,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,7 +42,7 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __NSXFNAME_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
@@ -58,8 +58,8 @@
 
 static char *
 AcpiNsCopyDeviceId (
-    ACPI_DEVICE_ID          *Dest,
-    ACPI_DEVICE_ID          *Source,
+    ACPI_PNP_DEVICE_ID      *Dest,
+    ACPI_PNP_DEVICE_ID      *Source,
     char                    *StringArea);
 
 
@@ -75,8 +75,8 @@ AcpiNsCopyDeviceId (
  * RETURN:      Status
  *
  * DESCRIPTION: This routine will search for a caller specified name in the
- *              name space.  The caller can restrict the search region by
- *              specifying a non NULL parent.  The parent value is itself a
+ *              name space. The caller can restrict the search region by
+ *              specifying a non NULL parent. The parent value is itself a
  *              namespace handle.
  *
  ******************************************************************************/
@@ -120,13 +120,13 @@ AcpiGetHandle (
      *
      * Error for <null Parent + relative path>
      */
-    if (AcpiNsValidRootPrefix (Pathname[0]))
+    if (ACPI_IS_ROOT_PREFIX (Pathname[0]))
     {
         /* Pathname is fully qualified (starts with '\') */
 
         /* Special case for root-only, since we can't search for it */
 
-        if (!ACPI_STRCMP (Pathname, ACPI_NS_ROOT_PATH))
+        if (!strcmp (Pathname, ACPI_NS_ROOT_PATH))
         {
             *RetHandle = ACPI_CAST_PTR (ACPI_HANDLE, AcpiGbl_RootNode);
             return (AE_OK);
@@ -164,7 +164,7 @@ ACPI_EXPORT_SYMBOL (AcpiGetHandle)
  * RETURN:      Pointer to a string containing the fully qualified Name.
  *
  * DESCRIPTION: This routine returns the fully qualified name associated with
- *              the Handle parameter.  This and the AcpiPathnameToHandle are
+ *              the Handle parameter. This and the AcpiPathnameToHandle are
  *              complementary functions.
  *
  ******************************************************************************/
@@ -177,6 +177,7 @@ AcpiGetName (
 {
     ACPI_STATUS             Status;
     ACPI_NAMESPACE_NODE     *Node;
+    const char              *NodeName;
 
 
     /* Parameter validation */
@@ -192,11 +193,13 @@ AcpiGetName (
         return (Status);
     }
 
-    if (NameType == ACPI_FULL_PATHNAME)
+    if (NameType == ACPI_FULL_PATHNAME ||
+        NameType == ACPI_FULL_PATHNAME_NO_TRAILING)
     {
         /* Get the full pathname (From the namespace root) */
 
-        Status = AcpiNsHandleToPathname (Handle, Buffer);
+        Status = AcpiNsHandleToPathname (Handle, Buffer,
+            NameType == ACPI_FULL_PATHNAME ? FALSE : TRUE);
         return (Status);
     }
 
@@ -227,8 +230,8 @@ AcpiGetName (
 
     /* Just copy the ACPI name from the Node and zero terminate it */
 
-    ACPI_STRNCPY (Buffer->Pointer, AcpiUtGetNodeName (Node),
-                ACPI_NAME_SIZE);
+    NodeName = AcpiUtGetNodeName (Node);
+    ACPI_MOVE_NAME (Buffer->Pointer, NodeName);
     ((char *) Buffer->Pointer) [ACPI_NAME_SIZE] = 0;
     Status = AE_OK;
 
@@ -246,30 +249,30 @@ ACPI_EXPORT_SYMBOL (AcpiGetName)
  *
  * FUNCTION:    AcpiNsCopyDeviceId
  *
- * PARAMETERS:  Dest                - Pointer to the destination DEVICE_ID
- *              Source              - Pointer to the source DEVICE_ID
+ * PARAMETERS:  Dest                - Pointer to the destination PNP_DEVICE_ID
+ *              Source              - Pointer to the source PNP_DEVICE_ID
  *              StringArea          - Pointer to where to copy the dest string
  *
  * RETURN:      Pointer to the next string area
  *
- * DESCRIPTION: Copy a single DEVICE_ID, including the string data.
+ * DESCRIPTION: Copy a single PNP_DEVICE_ID, including the string data.
  *
  ******************************************************************************/
 
 static char *
 AcpiNsCopyDeviceId (
-    ACPI_DEVICE_ID          *Dest,
-    ACPI_DEVICE_ID          *Source,
+    ACPI_PNP_DEVICE_ID      *Dest,
+    ACPI_PNP_DEVICE_ID      *Source,
     char                    *StringArea)
 {
-    /* Create the destination DEVICE_ID */
+    /* Create the destination PNP_DEVICE_ID */
 
     Dest->String = StringArea;
     Dest->Length = Source->Length;
 
     /* Copy actual string and return a pointer to the next string area */
 
-    ACPI_MEMCPY (StringArea, Source->String, Source->Length);
+    memcpy (StringArea, Source->String, Source->Length);
     return (StringArea + Source->Length);
 }
 
@@ -288,10 +291,17 @@ AcpiNsCopyDeviceId (
  *              control methods (Such as in the case of a device.)
  *
  * For Device and Processor objects, run the Device _HID, _UID, _CID, _STA,
- * _ADR, _SxW, and _SxD methods.
+ * _CLS, _ADR, _SxW, and _SxD methods.
  *
  * Note: Allocates the return buffer, must be freed by the caller.
  *
+ * Note: This interface is intended to be used during the initial device
+ * discovery namespace traversal. Therefore, no complex methods can be
+ * executed, especially those that access operation regions. Therefore, do
+ * not add any additional methods that could cause problems in this area.
+ * this was the fate of the _SUB method which was found to cause such
+ * problems and was removed (11/2015).
+ *
  ******************************************************************************/
 
 ACPI_STATUS
@@ -301,14 +311,15 @@ AcpiGetObjectInfo (
 {
     ACPI_NAMESPACE_NODE     *Node;
     ACPI_DEVICE_INFO        *Info;
-    ACPI_DEVICE_ID_LIST     *CidList = NULL;
-    ACPI_DEVICE_ID          *Hid = NULL;
-    ACPI_DEVICE_ID          *Uid = NULL;
+    ACPI_PNP_DEVICE_ID_LIST *CidList = NULL;
+    ACPI_PNP_DEVICE_ID      *Hid = NULL;
+    ACPI_PNP_DEVICE_ID      *Uid = NULL;
+    ACPI_PNP_DEVICE_ID      *Cls = NULL;
     char                    *NextIdString;
     ACPI_OBJECT_TYPE        Type;
     ACPI_NAME               Name;
     UINT8                   ParamCount= 0;
-    UINT8                   Valid = 0;
+    UINT16                  Valid = 0;
     UINT32                  InfoSize;
     UINT32                  i;
     ACPI_STATUS             Status;
@@ -324,7 +335,7 @@ AcpiGetObjectInfo (
     Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
     if (ACPI_FAILURE (Status))
     {
-        goto Cleanup;
+        return (Status);
     }
 
     Node = AcpiNsValidateHandle (Handle);
@@ -356,7 +367,7 @@ AcpiGetObjectInfo (
     {
         /*
          * Get extra info for ACPI Device/Processor objects only:
-         * Run the Device _HID, _UID, and _CID methods.
+         * Run the Device _HID, _UID, _CLS, and _CID methods.
          *
          * Note: none of these methods are required, so they may or may
          * not be present for this device. The Info->Valid bitfield is used
@@ -388,9 +399,18 @@ AcpiGetObjectInfo (
         {
             /* Add size of CID strings and CID pointer array */
 
-            InfoSize += (CidList->ListSize - sizeof (ACPI_DEVICE_ID_LIST));
+            InfoSize += (CidList->ListSize - sizeof (ACPI_PNP_DEVICE_ID_LIST));
             Valid |= ACPI_VALID_CID;
         }
+
+        /* Execute the Device._CLS method */
+
+        Status = AcpiUtExecute_CLS (Node, &Cls);
+        if (ACPI_SUCCESS (Status))
+        {
+            InfoSize += Cls->Length;
+            Valid |= ACPI_VALID_CLS;
+        }
     }
 
     /*
@@ -413,9 +433,14 @@ AcpiGetObjectInfo (
          * Get extra info for ACPI Device/Processor objects only:
          * Run the _STA, _ADR and, SxW, and _SxD methods.
          *
-         * Note: none of these methods are required, so they may or may
+         * Notes: none of these methods are required, so they may or may
          * not be present for this device. The Info->Valid bitfield is used
          * to indicate which methods were found and run successfully.
+         *
+         * For _STA, if the method does not exist, then (as per the ACPI
+         * specification), the returned CurrentStatus flags will indicate
+         * that the device is present/functional/enabled. Otherwise, the
+         * CurrentStatus flags reflect the value returned from _STA.
          */
 
         /* Execute the Device._STA method */
@@ -429,7 +454,7 @@ AcpiGetObjectInfo (
         /* Execute the Device._ADR method */
 
         Status = AcpiUtEvaluateNumericObject (METHOD_NAME__ADR, Node,
-                    &Info->Address);
+            &Info->Address);
         if (ACPI_SUCCESS (Status))
         {
             Valid |= ACPI_VALID_ADR;
@@ -438,8 +463,8 @@ AcpiGetObjectInfo (
         /* Execute the Device._SxW methods */
 
         Status = AcpiUtExecutePowerMethods (Node,
-                    AcpiGbl_LowestDstateNames, ACPI_NUM_SxW_METHODS,
-                    Info->LowestDstates);
+            AcpiGbl_LowestDstateNames, ACPI_NUM_SxW_METHODS,
+            Info->LowestDstates);
         if (ACPI_SUCCESS (Status))
         {
             Valid |= ACPI_VALID_SXWS;
@@ -448,8 +473,8 @@ AcpiGetObjectInfo (
         /* Execute the Device._SxD methods */
 
         Status = AcpiUtExecutePowerMethods (Node,
-                    AcpiGbl_HighestDstateNames, ACPI_NUM_SxD_METHODS,
-                    Info->HighestDstates);
+            AcpiGbl_HighestDstateNames, ACPI_NUM_SxD_METHODS,
+            Info->HighestDstates);
         if (ACPI_SUCCESS (Status))
         {
             Valid |= ACPI_VALID_SXDS;
@@ -463,9 +488,9 @@ AcpiGetObjectInfo (
     NextIdString = ACPI_CAST_PTR (char, Info->CompatibleIdList.Ids);
     if (CidList)
     {
-        /* Point past the CID DEVICE_ID array */
+        /* Point past the CID PNP_DEVICE_ID array */
 
-        NextIdString += ((ACPI_SIZE) CidList->Count * sizeof (ACPI_DEVICE_ID));
+        NextIdString += ((ACPI_SIZE) CidList->Count * sizeof (ACPI_PNP_DEVICE_ID));
     }
 
     /*
@@ -510,6 +535,12 @@ AcpiGetObjectInfo (
         }
     }
 
+    if (Cls)
+    {
+        NextIdString = AcpiNsCopyDeviceId (&Info->ClassCode,
+            Cls, NextIdString);
+    }
+
     /* Copy the fixed-length data */
 
     Info->InfoSize = InfoSize;
@@ -535,6 +566,10 @@ Cleanup:
     {
         ACPI_FREE (CidList);
     }
+    if (Cls)
+    {
+        ACPI_FREE (Cls);
+    }
     return (Status);
 }
 
@@ -602,6 +637,7 @@ AcpiInstallMethod (
     ParserState.Aml += AcpiPsGetOpcodeSize (Opcode);
     ParserState.PkgEnd = AcpiPsGetNextPackageEnd (&ParserState);
     Path = AcpiPsGetNextNamestring (&ParserState);
+
     MethodFlags = *ParserState.Aml++;
     AmlStart = ParserState.Aml;
     AmlLength = ACPI_PTR_DIFF (ParserState.PkgEnd, AmlStart);
@@ -634,7 +670,7 @@ AcpiInstallMethod (
     /* The lookup either returns an existing node or creates a new one */
 
     Status = AcpiNsLookup (NULL, Path, ACPI_TYPE_METHOD, ACPI_IMODE_LOAD_PASS1,
-                ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND, NULL, &Node);
+        ACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND, NULL, &Node);
 
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
 
@@ -656,7 +692,7 @@ AcpiInstallMethod (
 
     /* Copy the method AML to the local buffer */
 
-    ACPI_MEMCPY (AmlBuffer, AmlStart, AmlLength);
+    memcpy (AmlBuffer, AmlStart, AmlLength);
 
     /* Initialize the method object with the new method's information */
 
diff --git a/usr/src/uts/intel/io/acpica/namespace/nsxfobj.c b/usr/src/uts/intel/io/acpica/namespace/nsxfobj.c
index 02f7777a39..f006047431 100644
--- a/usr/src/uts/intel/io/acpica/namespace/nsxfobj.c
+++ b/usr/src/uts/intel/io/acpica/namespace/nsxfobj.c
@@ -6,7 +6,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,8 +42,7 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __NSXFOBJ_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
@@ -82,10 +81,8 @@ AcpiGetType (
         return (AE_BAD_PARAMETER);
     }
 
-    /*
-     * Special case for the predefined Root Node
-     * (return type ANY)
-     */
+    /* Special case for the predefined Root Node (return type ANY) */
+
     if (Handle == ACPI_ROOT_OBJECT)
     {
         *RetType = ACPI_TYPE_ANY;
@@ -109,7 +106,6 @@ AcpiGetType (
 
     *RetType = Node->Type;
 
-
     Status = AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
     return (Status);
 }
@@ -202,8 +198,8 @@ ACPI_EXPORT_SYMBOL (AcpiGetParent)
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Return the next peer object within the namespace.  If Handle is
- *              valid, Scope is ignored.  Otherwise, the first object within
+ * DESCRIPTION: Return the next peer object within the namespace. If Handle is
+ *              valid, Scope is ignored. Otherwise, the first object within
  *              Scope is returned.
  *
  ******************************************************************************/
@@ -282,4 +278,3 @@ UnlockAndExit:
 }
 
 ACPI_EXPORT_SYMBOL (AcpiGetNextObject)
-
diff --git a/usr/src/uts/intel/io/acpica/osl.c b/usr/src/uts/intel/io/acpica/osl.c
index 44f8d2f48f..3a2d124ef5 100644
--- a/usr/src/uts/intel/io/acpica/osl.c
+++ b/usr/src/uts/intel/io/acpica/osl.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2012 Joyent, Inc.  All rights reserved.
+ * Copyright 2016 Joyent, Inc.
  */
 /*
  * Copyright (c) 2009-2010, Intel Corporation.
@@ -749,6 +749,22 @@ AcpiOsExecute(ACPI_EXECUTE_TYPE Type, ACPI_OSD_EXEC_CALLBACK  Function,
 
 }
 
+
+void
+AcpiOsWaitEventsComplete(void)
+{
+	int	i;
+
+	/*
+	 * Wait for event queues to be empty.
+	 */
+	for (i = OSL_GLOBAL_LOCK_HANDLER; i <= OSL_EC_BURST_HANDLER; i++) {
+		if (osl_eventq[i] != NULL) {
+			ddi_taskq_wait(osl_eventq[i]);
+		}
+	}
+}
+
 void
 AcpiOsSleep(ACPI_INTEGER Milliseconds)
 {
@@ -2350,3 +2366,15 @@ acpica_write_cpupm_capabilities(boolean_t pstates, boolean_t cstates)
 		(void) AcpiHwRegisterWrite(ACPI_REGISTER_SMI_COMMAND_BLOCK,
 		    AcpiGbl_FADT.CstControl);
 }
+
+uint32_t
+acpi_strtoul(const char *str, char **ep, int base)
+{
+	ulong_t v;
+
+	if (ddi_strtoul(str, ep, base, &v) != 0 || v > ACPI_UINT32_MAX) {
+		return (ACPI_UINT32_MAX);
+	}
+
+	return ((uint32_t)v);
+}
diff --git a/usr/src/uts/intel/io/acpica/parser/psargs.c b/usr/src/uts/intel/io/acpica/parser/psargs.c
index 8140fdbb9d..a4745c3adc 100644
--- a/usr/src/uts/intel/io/acpica/parser/psargs.c
+++ b/usr/src/uts/intel/io/acpica/parser/psargs.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __PSARGS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -131,7 +129,7 @@ AcpiPsGetNextPackageLength (
  * RETURN:      Pointer to end-of-package +1
  *
  * DESCRIPTION: Get next package length and return a pointer past the end of
- *              the package.  Consumes the package length field
+ *              the package. Consumes the package length field
  *
  ******************************************************************************/
 
@@ -163,8 +161,8 @@ AcpiPsGetNextPackageEnd (
  * RETURN:      Pointer to the start of the name string (pointer points into
  *              the AML.
  *
- * DESCRIPTION: Get next raw namestring within the AML stream.  Handles all name
- *              prefix characters.  Set parser state to point past the string.
+ * DESCRIPTION: Get next raw namestring within the AML stream. Handles all name
+ *              prefix characters. Set parser state to point past the string.
  *              (Name is consumed from the AML.)
  *
  ******************************************************************************/
@@ -182,7 +180,8 @@ AcpiPsGetNextNamestring (
 
     /* Point past any namestring prefix characters (backslash or carat) */
 
-    while (AcpiPsIsPrefixChar (*End))
+    while (ACPI_IS_ROOT_PREFIX (*End) ||
+           ACPI_IS_PARENT_PREFIX (*End))
     {
         End++;
     }
@@ -244,7 +243,7 @@ AcpiPsGetNextNamestring (
  *
  * DESCRIPTION: Get next name (if method call, return # of required args).
  *              Names are looked up in the internal namespace to determine
- *              if the name represents a control method.  If a method
+ *              if the name represents a control method. If a method
  *              is found, the number of arguments to the method is returned.
  *              This information is critical for parsing to continue correctly.
  *
@@ -288,8 +287,8 @@ AcpiPsGetNextNamepath (
      * the upsearch)
      */
     Status = AcpiNsLookup (WalkState->ScopeInfo, Path,
-                ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
-                ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL, &Node);
+        ACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,
+        ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, NULL, &Node);
 
     /*
      * If this name is a control method invocation, we must
@@ -317,7 +316,7 @@ AcpiPsGetNextNamepath (
         ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
             "Control Method - %p Desc %p Path=%p\n", Node, MethodDesc, Path));
 
-        NameOp = AcpiPsAllocOp (AML_INT_NAMEPATH_OP);
+        NameOp = AcpiPsAllocOp (AML_INT_NAMEPATH_OP, Start);
         if (!NameOp)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
@@ -360,7 +359,7 @@ AcpiPsGetNextNamepath (
         /* 1) NotFound is ok during load pass 1/2 (allow forward references) */
 
         if ((WalkState->ParseFlags & ACPI_PARSE_MODE_MASK) !=
-                ACPI_PARSE_EXECUTE)
+            ACPI_PARSE_EXECUTE)
         {
             Status = AE_OK;
         }
@@ -392,7 +391,7 @@ AcpiPsGetNextNamepath (
         ACPI_ERROR_NAMESPACE (Path, Status);
 
         if ((WalkState->ParseFlags & ACPI_PARSE_MODE_MASK) ==
-                ACPI_PARSE_EXECUTE)
+            ACPI_PARSE_EXECUTE)
         {
             /* Report a control method execution error */
 
@@ -446,7 +445,6 @@ AcpiPsGetNextSimpleArg (
         Length = 1;
         break;
 
-
     case ARGP_WORDDATA:
 
         /* Get 2 bytes from the AML stream */
@@ -456,7 +454,6 @@ AcpiPsGetNextSimpleArg (
         Length = 2;
         break;
 
-
     case ARGP_DWORDDATA:
 
         /* Get 4 bytes from the AML stream */
@@ -466,7 +463,6 @@ AcpiPsGetNextSimpleArg (
         Length = 4;
         break;
 
-
     case ARGP_QWORDDATA:
 
         /* Get 8 bytes from the AML stream */
@@ -476,7 +472,6 @@ AcpiPsGetNextSimpleArg (
         Length = 8;
         break;
 
-
     case ARGP_CHARLIST:
 
         /* Get a pointer to the string, point past the string */
@@ -494,7 +489,6 @@ AcpiPsGetNextSimpleArg (
         Length++;
         break;
 
-
     case ARGP_NAME:
     case ARGP_NAMESTRING:
 
@@ -502,7 +496,6 @@ AcpiPsGetNextSimpleArg (
         Arg->Common.Value.Name = AcpiPsGetNextNamestring (ParserState);
         return_VOID;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Invalid ArgType 0x%X", ArgType));
@@ -531,7 +524,7 @@ static ACPI_PARSE_OBJECT *
 AcpiPsGetNextField (
     ACPI_PARSE_STATE        *ParserState)
 {
-    UINT32                  AmlOffset;
+    UINT8                   *Aml;
     ACPI_PARSE_OBJECT       *Field;
     ACPI_PARSE_OBJECT       *Arg = NULL;
     UINT16                  Opcode;
@@ -547,8 +540,7 @@ AcpiPsGetNextField (
     ACPI_FUNCTION_TRACE (PsGetNextField);
 
 
-    AmlOffset = (UINT32) ACPI_PTR_DIFF (
-        ParserState->Aml, ParserState->AmlStart);
+    Aml = ParserState->Aml;
 
     /* Determine field type */
 
@@ -586,14 +578,12 @@ AcpiPsGetNextField (
 
     /* Allocate a new field op */
 
-    Field = AcpiPsAllocOp (Opcode);
+    Field = AcpiPsAllocOp (Opcode, Aml);
     if (!Field)
     {
         return_PTR (NULL);
     }
 
-    Field->Common.AmlOffset = AmlOffset;
-
     /* Decode the field type */
 
     switch (Opcode)
@@ -657,6 +647,7 @@ AcpiPsGetNextField (
          * Argument for Connection operator can be either a Buffer
          * (resource descriptor), or a NameString.
          */
+        Aml = ParserState->Aml;
         if (ACPI_GET8 (ParserState->Aml) == AML_BUFFER_OP)
         {
             ParserState->Aml++;
@@ -669,7 +660,7 @@ AcpiPsGetNextField (
             {
                 /* Non-empty list */
 
-                Arg = AcpiPsAllocOp (AML_INT_BYTELIST_OP);
+                Arg = AcpiPsAllocOp (AML_INT_BYTELIST_OP, Aml);
                 if (!Arg)
                 {
                     AcpiPsFreeOp (Field);
@@ -684,21 +675,25 @@ AcpiPsGetNextField (
                 switch (Opcode)
                 {
                 case AML_BYTE_OP:       /* AML_BYTEDATA_ARG */
+
                     BufferLength = ACPI_GET8 (ParserState->Aml);
                     ParserState->Aml += 1;
                     break;
 
                 case AML_WORD_OP:       /* AML_WORDDATA_ARG */
+
                     BufferLength = ACPI_GET16 (ParserState->Aml);
                     ParserState->Aml += 2;
                     break;
 
                 case AML_DWORD_OP:      /* AML_DWORDATA_ARG */
+
                     BufferLength = ACPI_GET32 (ParserState->Aml);
                     ParserState->Aml += 4;
                     break;
 
                 default:
+
                     BufferLength = 0;
                     break;
                 }
@@ -715,7 +710,7 @@ AcpiPsGetNextField (
         }
         else
         {
-            Arg = AcpiPsAllocOp (AML_INT_NAMEPATH_OP);
+            Arg = AcpiPsAllocOp (AML_INT_NAMEPATH_OP, Aml);
             if (!Arg)
             {
                 AcpiPsFreeOp (Field);
@@ -787,15 +782,15 @@ AcpiPsGetNextArg (
 
         /* Constants, strings, and namestrings are all the same size */
 
-        Arg = AcpiPsAllocOp (AML_BYTE_OP);
+        Arg = AcpiPsAllocOp (AML_BYTE_OP, ParserState->Aml);
         if (!Arg)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
         }
+
         AcpiPsGetNextSimpleArg (ParserState, ArgType, Arg);
         break;
 
-
     case ARGP_PKGLENGTH:
 
         /* Package length, nothing returned */
@@ -803,7 +798,6 @@ AcpiPsGetNextArg (
         ParserState->PkgEnd = AcpiPsGetNextPackageEnd (ParserState);
         break;
 
-
     case ARGP_FIELDLIST:
 
         if (ParserState->Aml < ParserState->PkgEnd)
@@ -835,14 +829,14 @@ AcpiPsGetNextArg (
         }
         break;
 
-
     case ARGP_BYTELIST:
 
         if (ParserState->Aml < ParserState->PkgEnd)
         {
             /* Non-empty list */
 
-            Arg = AcpiPsAllocOp (AML_INT_BYTELIST_OP);
+            Arg = AcpiPsAllocOp (AML_INT_BYTELIST_OP,
+                ParserState->Aml);
             if (!Arg)
             {
                 return_ACPI_STATUS (AE_NO_MEMORY);
@@ -860,19 +854,20 @@ AcpiPsGetNextArg (
         }
         break;
 
-
     case ARGP_TARGET:
     case ARGP_SUPERNAME:
     case ARGP_SIMPLENAME:
+    case ARGP_NAME_OR_REF:
 
         Subop = AcpiPsPeekOpcode (ParserState);
         if (Subop == 0                  ||
             AcpiPsIsLeadingChar (Subop) ||
-            AcpiPsIsPrefixChar (Subop))
+            ACPI_IS_ROOT_PREFIX (Subop) ||
+            ACPI_IS_PARENT_PREFIX (Subop))
         {
             /* NullName or NameString */
 
-            Arg = AcpiPsAllocOp (AML_INT_NAMEPATH_OP);
+            Arg = AcpiPsAllocOp (AML_INT_NAMEPATH_OP, ParserState->Aml);
             if (!Arg)
             {
                 return_ACPI_STATUS (AE_NO_MEMORY);
@@ -882,11 +877,12 @@ AcpiPsGetNextArg (
 
             if (WalkState->Opcode == AML_UNLOAD_OP)
             {
-                Status = AcpiPsGetNextNamepath (WalkState, ParserState, Arg, 1);
+                Status = AcpiPsGetNextNamepath (WalkState, ParserState,
+                    Arg, ACPI_POSSIBLE_METHOD_CALL);
 
                 /*
-                 * If the SuperName arg of Unload is a method call,
-                 * we have restored the AML pointer, just free this Arg
+                 * If the SuperName argument is a method call, we have
+                 * already restored the AML pointer, just free this Arg
                  */
                 if (Arg->Common.AmlOpcode == AML_INT_METHODCALL_OP)
                 {
@@ -896,7 +892,8 @@ AcpiPsGetNextArg (
             }
             else
             {
-                Status = AcpiPsGetNextNamepath (WalkState, ParserState, Arg, 0);
+                Status = AcpiPsGetNextNamepath (WalkState, ParserState,
+                    Arg, ACPI_NOT_METHOD_CALL);
             }
         }
         else
@@ -907,7 +904,6 @@ AcpiPsGetNextArg (
         }
         break;
 
-
     case ARGP_DATAOBJ:
     case ARGP_TERMARG:
 
@@ -916,7 +912,6 @@ AcpiPsGetNextArg (
         WalkState->ArgCount = 1;
         break;
 
-
     case ARGP_DATAOBJLIST:
     case ARGP_TERMLIST:
     case ARGP_OBJLIST:
@@ -929,7 +924,6 @@ AcpiPsGetNextArg (
         }
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Invalid ArgType: 0x%X", ArgType));
diff --git a/usr/src/uts/intel/io/acpica/parser/psloop.c b/usr/src/uts/intel/io/acpica/parser/psloop.c
index d578c7e36b..e0839fd7d8 100644
--- a/usr/src/uts/intel/io/acpica/parser/psloop.c
+++ b/usr/src/uts/intel/io/acpica/parser/psloop.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 /*
  * Parse the AML and build an operation tree as most interpreters, (such as
  * Perl) do. Parsing is done by hand rather than with a YACC generated parser
@@ -52,6 +51,7 @@
 
 #include "acpi.h"
 #include "accommon.h"
+#include "acinterp.h"
 #include "acparser.h"
 #include "acdispat.h"
 #include "amlcode.h"
@@ -59,46 +59,15 @@
 #define _COMPONENT          ACPI_PARSER
         ACPI_MODULE_NAME    ("psloop")
 
-static UINT32               AcpiGbl_Depth = 0;
-
 
 /* Local prototypes */
 
-static ACPI_STATUS
-AcpiPsGetAmlOpcode (
-    ACPI_WALK_STATE         *WalkState);
-
-static ACPI_STATUS
-AcpiPsBuildNamedOp (
-    ACPI_WALK_STATE         *WalkState,
-    UINT8                   *AmlOpStart,
-    ACPI_PARSE_OBJECT       *UnnamedOp,
-    ACPI_PARSE_OBJECT       **Op);
-
-static ACPI_STATUS
-AcpiPsCreateOp (
-    ACPI_WALK_STATE         *WalkState,
-    UINT8                   *AmlOpStart,
-    ACPI_PARSE_OBJECT       **NewOp);
-
 static ACPI_STATUS
 AcpiPsGetArguments (
     ACPI_WALK_STATE         *WalkState,
     UINT8                   *AmlOpStart,
     ACPI_PARSE_OBJECT       *Op);
 
-static ACPI_STATUS
-AcpiPsCompleteOp (
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       **Op,
-    ACPI_STATUS             Status);
-
-static ACPI_STATUS
-AcpiPsCompleteFinalOp (
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       *Op,
-    ACPI_STATUS             Status);
-
 static void
 AcpiPsLinkModuleCode (
     ACPI_PARSE_OBJECT       *ParentOp,
@@ -107,314 +76,6 @@ AcpiPsLinkModuleCode (
     ACPI_OWNER_ID           OwnerId);
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsGetAmlOpcode
- *
- * PARAMETERS:  WalkState           - Current state
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Extract the next AML opcode from the input stream.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiPsGetAmlOpcode (
-    ACPI_WALK_STATE         *WalkState)
-{
-
-    ACPI_FUNCTION_TRACE_PTR (PsGetAmlOpcode, WalkState);
-
-
-    WalkState->AmlOffset = (UINT32) ACPI_PTR_DIFF (WalkState->ParserState.Aml,
-                                WalkState->ParserState.AmlStart);
-    WalkState->Opcode = AcpiPsPeekOpcode (&(WalkState->ParserState));
-
-    /*
-     * First cut to determine what we have found:
-     * 1) A valid AML opcode
-     * 2) A name string
-     * 3) An unknown/invalid opcode
-     */
-    WalkState->OpInfo = AcpiPsGetOpcodeInfo (WalkState->Opcode);
-
-    switch (WalkState->OpInfo->Class)
-    {
-    case AML_CLASS_ASCII:
-    case AML_CLASS_PREFIX:
-        /*
-         * Starts with a valid prefix or ASCII char, this is a name
-         * string. Convert the bare name string to a namepath.
-         */
-        WalkState->Opcode = AML_INT_NAMEPATH_OP;
-        WalkState->ArgTypes = ARGP_NAMESTRING;
-        break;
-
-    case AML_CLASS_UNKNOWN:
-
-        /* The opcode is unrecognized. Just skip unknown opcodes */
-
-        ACPI_ERROR ((AE_INFO,
-             "Found unknown opcode 0x%X at AML address %p offset 0x%X, ignoring",
-              WalkState->Opcode, WalkState->ParserState.Aml, WalkState->AmlOffset));
-
-        ACPI_DUMP_BUFFER (WalkState->ParserState.Aml, 128);
-
-        /* Assume one-byte bad opcode */
-
-        WalkState->ParserState.Aml++;
-        return_ACPI_STATUS (AE_CTRL_PARSE_CONTINUE);
-
-    default:
-
-        /* Found opcode info, this is a normal opcode */
-
-        WalkState->ParserState.Aml += AcpiPsGetOpcodeSize (WalkState->Opcode);
-        WalkState->ArgTypes = WalkState->OpInfo->ParseArgs;
-        break;
-    }
-
-    return_ACPI_STATUS (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsBuildNamedOp
- *
- * PARAMETERS:  WalkState           - Current state
- *              AmlOpStart          - Begin of named Op in AML
- *              UnnamedOp           - Early Op (not a named Op)
- *              Op                  - Returned Op
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Parse a named Op
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiPsBuildNamedOp (
-    ACPI_WALK_STATE         *WalkState,
-    UINT8                   *AmlOpStart,
-    ACPI_PARSE_OBJECT       *UnnamedOp,
-    ACPI_PARSE_OBJECT       **Op)
-{
-    ACPI_STATUS             Status = AE_OK;
-    ACPI_PARSE_OBJECT       *Arg = NULL;
-
-
-    ACPI_FUNCTION_TRACE_PTR (PsBuildNamedOp, WalkState);
-
-
-    UnnamedOp->Common.Value.Arg = NULL;
-    UnnamedOp->Common.ArgListLength = 0;
-    UnnamedOp->Common.AmlOpcode = WalkState->Opcode;
-
-    /*
-     * Get and append arguments until we find the node that contains
-     * the name (the type ARGP_NAME).
-     */
-    while (GET_CURRENT_ARG_TYPE (WalkState->ArgTypes) &&
-          (GET_CURRENT_ARG_TYPE (WalkState->ArgTypes) != ARGP_NAME))
-    {
-        Status = AcpiPsGetNextArg (WalkState, &(WalkState->ParserState),
-                    GET_CURRENT_ARG_TYPE (WalkState->ArgTypes), &Arg);
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-
-        AcpiPsAppendArg (UnnamedOp, Arg);
-        INCREMENT_ARG_LIST (WalkState->ArgTypes);
-    }
-
-    /*
-     * Make sure that we found a NAME and didn't run out of arguments
-     */
-    if (!GET_CURRENT_ARG_TYPE (WalkState->ArgTypes))
-    {
-        return_ACPI_STATUS (AE_AML_NO_OPERAND);
-    }
-
-    /* We know that this arg is a name, move to next arg */
-
-    INCREMENT_ARG_LIST (WalkState->ArgTypes);
-
-    /*
-     * Find the object. This will either insert the object into
-     * the namespace or simply look it up
-     */
-    WalkState->Op = NULL;
-
-    Status = WalkState->DescendingCallback (WalkState, Op);
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_EXCEPTION ((AE_INFO, Status, "During name lookup/catalog"));
-        return_ACPI_STATUS (Status);
-    }
-
-    if (!*Op)
-    {
-        return_ACPI_STATUS (AE_CTRL_PARSE_CONTINUE);
-    }
-
-    Status = AcpiPsNextParseState (WalkState, *Op, Status);
-    if (ACPI_FAILURE (Status))
-    {
-        if (Status == AE_CTRL_PENDING)
-        {
-            return_ACPI_STATUS (AE_CTRL_PARSE_PENDING);
-        }
-        return_ACPI_STATUS (Status);
-    }
-
-    AcpiPsAppendArg (*Op, UnnamedOp->Common.Value.Arg);
-    AcpiGbl_Depth++;
-
-    if ((*Op)->Common.AmlOpcode == AML_REGION_OP ||
-        (*Op)->Common.AmlOpcode == AML_DATA_REGION_OP)
-    {
-        /*
-         * Defer final parsing of an OperationRegion body, because we don't
-         * have enough info in the first pass to parse it correctly (i.e.,
-         * there may be method calls within the TermArg elements of the body.)
-         *
-         * However, we must continue parsing because the opregion is not a
-         * standalone package -- we don't know where the end is at this point.
-         *
-         * (Length is unknown until parse of the body complete)
-         */
-        (*Op)->Named.Data = AmlOpStart;
-        (*Op)->Named.Length = 0;
-    }
-
-    return_ACPI_STATUS (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsCreateOp
- *
- * PARAMETERS:  WalkState           - Current state
- *              AmlOpStart          - Op start in AML
- *              NewOp               - Returned Op
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Get Op from AML
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiPsCreateOp (
-    ACPI_WALK_STATE         *WalkState,
-    UINT8                   *AmlOpStart,
-    ACPI_PARSE_OBJECT       **NewOp)
-{
-    ACPI_STATUS             Status = AE_OK;
-    ACPI_PARSE_OBJECT       *Op;
-    ACPI_PARSE_OBJECT       *NamedOp = NULL;
-    ACPI_PARSE_OBJECT       *ParentScope;
-    UINT8                   ArgumentCount;
-    const ACPI_OPCODE_INFO  *OpInfo;
-
-
-    ACPI_FUNCTION_TRACE_PTR (PsCreateOp, WalkState);
-
-
-    Status = AcpiPsGetAmlOpcode (WalkState);
-    if (Status == AE_CTRL_PARSE_CONTINUE)
-    {
-        return_ACPI_STATUS (AE_CTRL_PARSE_CONTINUE);
-    }
-
-    /* Create Op structure and append to parent's argument list */
-
-    WalkState->OpInfo = AcpiPsGetOpcodeInfo (WalkState->Opcode);
-    Op = AcpiPsAllocOp (WalkState->Opcode);
-    if (!Op)
-    {
-        return_ACPI_STATUS (AE_NO_MEMORY);
-    }
-
-    if (WalkState->OpInfo->Flags & AML_NAMED)
-    {
-        Status = AcpiPsBuildNamedOp (WalkState, AmlOpStart, Op, &NamedOp);
-        AcpiPsFreeOp (Op);
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-
-        *NewOp = NamedOp;
-        return_ACPI_STATUS (AE_OK);
-    }
-
-    /* Not a named opcode, just allocate Op and append to parent */
-
-    if (WalkState->OpInfo->Flags & AML_CREATE)
-    {
-        /*
-         * Backup to beginning of CreateXXXfield declaration
-         * BodyLength is unknown until we parse the body
-         */
-        Op->Named.Data = AmlOpStart;
-        Op->Named.Length = 0;
-    }
-
-    if (WalkState->Opcode == AML_BANK_FIELD_OP)
-    {
-        /*
-         * Backup to beginning of BankField declaration
-         * BodyLength is unknown until we parse the body
-         */
-        Op->Named.Data = AmlOpStart;
-        Op->Named.Length = 0;
-    }
-
-    ParentScope = AcpiPsGetParentScope (&(WalkState->ParserState));
-    AcpiPsAppendArg (ParentScope, Op);
-
-    if (ParentScope)
-    {
-        OpInfo = AcpiPsGetOpcodeInfo (ParentScope->Common.AmlOpcode);
-        if (OpInfo->Flags & AML_HAS_TARGET)
-        {
-            ArgumentCount = AcpiPsGetArgumentCount (OpInfo->Type);
-            if (ParentScope->Common.ArgListLength > ArgumentCount)
-            {
-                Op->Common.Flags |= ACPI_PARSEOP_TARGET;
-            }
-        }
-        else if (ParentScope->Common.AmlOpcode == AML_INCREMENT_OP)
-        {
-            Op->Common.Flags |= ACPI_PARSEOP_TARGET;
-        }
-    }
-
-    if (WalkState->DescendingCallback != NULL)
-    {
-        /*
-         * Find the object. This will either insert the object into
-         * the namespace or simply look it up
-         */
-        WalkState->Op = *NewOp = Op;
-
-        Status = WalkState->DescendingCallback (WalkState, &Op);
-        Status = AcpiPsNextParseState (WalkState, Op, Status);
-        if (Status == AE_CTRL_PENDING)
-        {
-            Status = AE_CTRL_PARSE_PENDING;
-        }
-    }
-
-    return_ACPI_STATUS (Status);
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiPsGetArguments
@@ -459,7 +120,8 @@ AcpiPsGetArguments (
 
     case AML_INT_NAMEPATH_OP:   /* AML_NAMESTRING_ARG */
 
-        Status = AcpiPsGetNextNamepath (WalkState, &(WalkState->ParserState), Op, 1);
+        Status = AcpiPsGetNextNamepath (WalkState,
+            &(WalkState->ParserState), Op, ACPI_POSSIBLE_METHOD_CALL);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -472,13 +134,13 @@ AcpiPsGetArguments (
         /*
          * Op is not a constant or string, append each argument to the Op
          */
-        while (GET_CURRENT_ARG_TYPE (WalkState->ArgTypes) && !WalkState->ArgCount)
+        while (GET_CURRENT_ARG_TYPE (WalkState->ArgTypes) &&
+            !WalkState->ArgCount)
         {
-            WalkState->AmlOffset = (UINT32) ACPI_PTR_DIFF (WalkState->ParserState.Aml,
-                WalkState->ParserState.AmlStart);
+            WalkState->Aml = WalkState->ParserState.Aml;
 
             Status = AcpiPsGetNextArg (WalkState, &(WalkState->ParserState),
-                        GET_CURRENT_ARG_TYPE (WalkState->ArgTypes), &Arg);
+                GET_CURRENT_ARG_TYPE (WalkState->ArgTypes), &Arg);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -486,7 +148,6 @@ AcpiPsGetArguments (
 
             if (Arg)
             {
-                Arg->Common.AmlOffset = WalkState->AmlOffset;
                 AcpiPsAppendArg (Op, Arg);
             }
 
@@ -513,7 +174,6 @@ AcpiPsGetArguments (
             case AML_IF_OP:
             case AML_ELSE_OP:
             case AML_WHILE_OP:
-
                 /*
                  * Currently supported module-level opcodes are:
                  * IF/ELSE/WHILE. These appear to be the most common,
@@ -551,8 +211,8 @@ AcpiPsGetArguments (
                         (!Arg))
                     {
                         ACPI_WARNING ((AE_INFO,
-                            "Detected an unsupported executable opcode "
-                            "at module-level: [0x%.4X] at table offset 0x%.4X",
+                            "Unsupported module-level executable opcode "
+                            "0x%.2X at table offset 0x%.4X",
                             Op->Common.AmlOpcode,
                             (UINT32) (ACPI_PTR_DIFF (AmlOpStart,
                                 WalkState->ParserState.AmlStart) +
@@ -619,6 +279,7 @@ AcpiPsGetArguments (
         default:
 
             /* No action for all other opcodes */
+
             break;
         }
 
@@ -659,6 +320,9 @@ AcpiPsLinkModuleCode (
     ACPI_NAMESPACE_NODE     *ParentNode;
 
 
+    ACPI_FUNCTION_TRACE (PsLinkModuleCode);
+
+
     /* Get the tail of the list */
 
     Prev = Next = AcpiGbl_ModuleCodeList;
@@ -680,9 +344,12 @@ AcpiPsLinkModuleCode (
         MethodObj = AcpiUtCreateInternalObject (ACPI_TYPE_METHOD);
         if (!MethodObj)
         {
-            return;
+            return_VOID;
         }
 
+        ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+            "Create/Link new code block: %p\n", MethodObj));
+
         if (ParentOp->Common.Node)
         {
             ParentNode = ParentOp->Common.Node;
@@ -715,302 +382,15 @@ AcpiPsLinkModuleCode (
     }
     else
     {
-        Prev->Method.AmlLength += AmlLength;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsCompleteOp
- *
- * PARAMETERS:  WalkState           - Current state
- *              Op                  - Returned Op
- *              Status              - Parse status before complete Op
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Complete Op
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiPsCompleteOp (
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       **Op,
-    ACPI_STATUS             Status)
-{
-    ACPI_STATUS             Status2;
-
-
-    ACPI_FUNCTION_TRACE_PTR (PsCompleteOp, WalkState);
-
-
-    /*
-     * Finished one argument of the containing scope
-     */
-    WalkState->ParserState.Scope->ParseScope.ArgCount--;
-
-    /* Close this Op (will result in parse subtree deletion) */
-
-    Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
-    if (ACPI_FAILURE (Status2))
-    {
-        return_ACPI_STATUS (Status2);
-    }
-
-    *Op = NULL;
-
-    switch (Status)
-    {
-    case AE_OK:
-        break;
-
-
-    case AE_CTRL_TRANSFER:
-
-        /* We are about to transfer to a called method */
-
-        WalkState->PrevOp = NULL;
-        WalkState->PrevArgTypes = WalkState->ArgTypes;
-        return_ACPI_STATUS (Status);
-
+        ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
+            "Appending to existing code block: %p\n", Prev));
 
-    case AE_CTRL_END:
-
-        AcpiPsPopScope (&(WalkState->ParserState), Op,
-            &WalkState->ArgTypes, &WalkState->ArgCount);
-
-        if (*Op)
-        {
-            WalkState->Op = *Op;
-            WalkState->OpInfo = AcpiPsGetOpcodeInfo ((*Op)->Common.AmlOpcode);
-            WalkState->Opcode = (*Op)->Common.AmlOpcode;
-
-            Status = WalkState->AscendingCallback (WalkState);
-            Status = AcpiPsNextParseState (WalkState, *Op, Status);
-
-            Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
-            if (ACPI_FAILURE (Status2))
-            {
-                return_ACPI_STATUS (Status2);
-            }
-        }
-
-        Status = AE_OK;
-        break;
-
-
-    case AE_CTRL_BREAK:
-    case AE_CTRL_CONTINUE:
-
-        /* Pop off scopes until we find the While */
-
-        while (!(*Op) || ((*Op)->Common.AmlOpcode != AML_WHILE_OP))
-        {
-            AcpiPsPopScope (&(WalkState->ParserState), Op,
-                &WalkState->ArgTypes, &WalkState->ArgCount);
-        }
-
-        /* Close this iteration of the While loop */
-
-        WalkState->Op = *Op;
-        WalkState->OpInfo = AcpiPsGetOpcodeInfo ((*Op)->Common.AmlOpcode);
-        WalkState->Opcode = (*Op)->Common.AmlOpcode;
-
-        Status = WalkState->AscendingCallback (WalkState);
-        Status = AcpiPsNextParseState (WalkState, *Op, Status);
-
-        Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
-        if (ACPI_FAILURE (Status2))
-        {
-            return_ACPI_STATUS (Status2);
-        }
-
-        Status = AE_OK;
-        break;
-
-
-    case AE_CTRL_TERMINATE:
-
-        /* Clean up */
-        do
-        {
-            if (*Op)
-            {
-                Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
-                if (ACPI_FAILURE (Status2))
-                {
-                    return_ACPI_STATUS (Status2);
-                }
-
-                AcpiUtDeleteGenericState (
-                    AcpiUtPopGenericState (&WalkState->ControlState));
-            }
-
-            AcpiPsPopScope (&(WalkState->ParserState), Op,
-                &WalkState->ArgTypes, &WalkState->ArgCount);
-
-        } while (*Op);
-
-        return_ACPI_STATUS (AE_OK);
-
-
-    default:  /* All other non-AE_OK status */
-
-        do
-        {
-            if (*Op)
-            {
-                Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
-                if (ACPI_FAILURE (Status2))
-                {
-                    return_ACPI_STATUS (Status2);
-                }
-            }
-
-            AcpiPsPopScope (&(WalkState->ParserState), Op,
-                &WalkState->ArgTypes, &WalkState->ArgCount);
-
-        } while (*Op);
-
-
-#if 0
-        /*
-         * TBD: Cleanup parse ops on error
-         */
-        if (*Op == NULL)
-        {
-            AcpiPsPopScope (ParserState, Op,
-                &WalkState->ArgTypes, &WalkState->ArgCount);
-        }
-#endif
-        WalkState->PrevOp = NULL;
-        WalkState->PrevArgTypes = WalkState->ArgTypes;
-        return_ACPI_STATUS (Status);
-    }
-
-    /* This scope complete? */
-
-    if (AcpiPsHasCompletedScope (&(WalkState->ParserState)))
-    {
-        AcpiPsPopScope (&(WalkState->ParserState), Op,
-            &WalkState->ArgTypes, &WalkState->ArgCount);
-        ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped scope, Op=%p\n", *Op));
-    }
-    else
-    {
-        *Op = NULL;
+        Prev->Method.AmlLength += AmlLength;
     }
 
-    return_ACPI_STATUS (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsCompleteFinalOp
- *
- * PARAMETERS:  WalkState           - Current state
- *              Op                  - Current Op
- *              Status              - Current parse status before complete last
- *                                    Op
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Complete last Op.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiPsCompleteFinalOp (
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       *Op,
-    ACPI_STATUS             Status)
-{
-    ACPI_STATUS             Status2;
-
-
-    ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);
-
-
-    /*
-     * Complete the last Op (if not completed), and clear the scope stack.
-     * It is easily possible to end an AML "package" with an unbounded number
-     * of open scopes (such as when several ASL blocks are closed with
-     * sequential closing braces). We want to terminate each one cleanly.
-     */
-    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "AML package complete at Op %p\n", Op));
-    do
-    {
-        if (Op)
-        {
-            if (WalkState->AscendingCallback != NULL)
-            {
-                WalkState->Op = Op;
-                WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
-                WalkState->Opcode = Op->Common.AmlOpcode;
-
-                Status = WalkState->AscendingCallback (WalkState);
-                Status = AcpiPsNextParseState (WalkState, Op, Status);
-                if (Status == AE_CTRL_PENDING)
-                {
-                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);
-                    if (ACPI_FAILURE (Status))
-                    {
-                        return_ACPI_STATUS (Status);
-                    }
-                }
-
-                if (Status == AE_CTRL_TERMINATE)
-                {
-                    Status = AE_OK;
-
-                    /* Clean up */
-                    do
-                    {
-                        if (Op)
-                        {
-                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
-                            if (ACPI_FAILURE (Status2))
-                            {
-                                return_ACPI_STATUS (Status2);
-                            }
-                        }
-
-                        AcpiPsPopScope (&(WalkState->ParserState), &Op,
-                            &WalkState->ArgTypes, &WalkState->ArgCount);
-
-                    } while (Op);
-
-                    return_ACPI_STATUS (Status);
-                }
-
-                else if (ACPI_FAILURE (Status))
-                {
-                    /* First error is most important */
-
-                    (void) AcpiPsCompleteThisOp (WalkState, Op);
-                    return_ACPI_STATUS (Status);
-                }
-            }
-
-            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
-            if (ACPI_FAILURE (Status2))
-            {
-                return_ACPI_STATUS (Status2);
-            }
-        }
-
-        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,
-            &WalkState->ArgCount);
-
-    } while (Op);
-
-    return_ACPI_STATUS (Status);
+    return_VOID;
 }
 
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiPsParseLoop
@@ -1120,6 +500,11 @@ AcpiPsParseLoop (
                     Status = AE_OK;
                 }
 
+                if (Status == AE_CTRL_TERMINATE)
+                {
+                    return_ACPI_STATUS (Status);
+                }
+
                 Status = AcpiPsCompleteOp (WalkState, &Op, Status);
                 if (ACPI_FAILURE (Status))
                 {
@@ -1129,15 +514,7 @@ AcpiPsParseLoop (
                 continue;
             }
 
-            Op->Common.AmlOffset = WalkState->AmlOffset;
-
-            if (WalkState->OpInfo)
-            {
-                ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
-                    "Opcode %4.4X [%s] Op %p Aml %p AmlOffset %5.5X\n",
-                     (UINT32) Op->Common.AmlOpcode, WalkState->OpInfo->Name,
-                     Op, ParserState->Aml, Op->Common.AmlOffset));
-            }
+            AcpiExStartTraceOpcode (Op, WalkState);
         }
 
 
@@ -1175,7 +552,7 @@ AcpiPsParseLoop (
              * prepare for argument
              */
             Status = AcpiPsPushScope (ParserState, Op,
-                        WalkState->ArgTypes, WalkState->ArgCount);
+                WalkState->ArgTypes, WalkState->ArgCount);
             if (ACPI_FAILURE (Status))
             {
                 Status = AcpiPsCompleteOp (WalkState, &Op, Status);
@@ -1198,11 +575,6 @@ AcpiPsParseLoop (
         WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
         if (WalkState->OpInfo->Flags & AML_NAMED)
         {
-            if (AcpiGbl_Depth)
-            {
-                AcpiGbl_Depth--;
-            }
-
             if (Op->Common.AmlOpcode == AML_REGION_OP ||
                 Op->Common.AmlOpcode == AML_DATA_REGION_OP)
             {
@@ -1265,4 +637,3 @@ AcpiPsParseLoop (
     Status = AcpiPsCompleteFinalOp (WalkState, Op, Status);
     return_ACPI_STATUS (Status);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/parser/psobject.c b/usr/src/uts/intel/io/acpica/parser/psobject.c
new file mode 100644
index 0000000000..7edc39e2b7
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/parser/psobject.c
@@ -0,0 +1,686 @@
+/******************************************************************************
+ *
+ * Module Name: psobject - Support for parse objects
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acparser.h"
+#include "amlcode.h"
+
+#define _COMPONENT          ACPI_PARSER
+        ACPI_MODULE_NAME    ("psobject")
+
+
+/* Local prototypes */
+
+static ACPI_STATUS
+AcpiPsGetAmlOpcode (
+    ACPI_WALK_STATE         *WalkState);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiPsGetAmlOpcode
+ *
+ * PARAMETERS:  WalkState           - Current state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Extract the next AML opcode from the input stream.
+ *
+ ******************************************************************************/
+
+static ACPI_STATUS
+AcpiPsGetAmlOpcode (
+    ACPI_WALK_STATE         *WalkState)
+{
+    UINT32                  AmlOffset;
+
+
+    ACPI_FUNCTION_TRACE_PTR (PsGetAmlOpcode, WalkState);
+
+
+    WalkState->Aml = WalkState->ParserState.Aml;
+    WalkState->Opcode = AcpiPsPeekOpcode (&(WalkState->ParserState));
+
+    /*
+     * First cut to determine what we have found:
+     * 1) A valid AML opcode
+     * 2) A name string
+     * 3) An unknown/invalid opcode
+     */
+    WalkState->OpInfo = AcpiPsGetOpcodeInfo (WalkState->Opcode);
+
+    switch (WalkState->OpInfo->Class)
+    {
+    case AML_CLASS_ASCII:
+    case AML_CLASS_PREFIX:
+        /*
+         * Starts with a valid prefix or ASCII char, this is a name
+         * string. Convert the bare name string to a namepath.
+         */
+        WalkState->Opcode = AML_INT_NAMEPATH_OP;
+        WalkState->ArgTypes = ARGP_NAMESTRING;
+        break;
+
+    case AML_CLASS_UNKNOWN:
+
+        /* The opcode is unrecognized. Complain and skip unknown opcodes */
+
+        if (WalkState->PassNumber == 2)
+        {
+            AmlOffset = (UINT32) ACPI_PTR_DIFF (WalkState->Aml,
+                WalkState->ParserState.AmlStart);
+
+            ACPI_ERROR ((AE_INFO,
+                "Unknown opcode 0x%.2X at table offset 0x%.4X, ignoring",
+                WalkState->Opcode,
+                (UINT32) (AmlOffset + sizeof (ACPI_TABLE_HEADER))));
+
+            ACPI_DUMP_BUFFER ((WalkState->ParserState.Aml - 16), 48);
+
+#ifdef ACPI_ASL_COMPILER
+            /*
+             * This is executed for the disassembler only. Output goes
+             * to the disassembled ASL output file.
+             */
+            AcpiOsPrintf (
+                "/*\nError: Unknown opcode 0x%.2X at table offset 0x%.4X, context:\n",
+                WalkState->Opcode,
+                (UINT32) (AmlOffset + sizeof (ACPI_TABLE_HEADER)));
+
+            /* Dump the context surrounding the invalid opcode */
+
+            AcpiUtDumpBuffer (((UINT8 *) WalkState->ParserState.Aml - 16),
+                48, DB_BYTE_DISPLAY,
+                (AmlOffset + sizeof (ACPI_TABLE_HEADER) - 16));
+            AcpiOsPrintf (" */\n");
+#endif
+        }
+
+        /* Increment past one-byte or two-byte opcode */
+
+        WalkState->ParserState.Aml++;
+        if (WalkState->Opcode > 0xFF) /* Can only happen if first byte is 0x5B */
+        {
+            WalkState->ParserState.Aml++;
+        }
+
+        return_ACPI_STATUS (AE_CTRL_PARSE_CONTINUE);
+
+    default:
+
+        /* Found opcode info, this is a normal opcode */
+
+        WalkState->ParserState.Aml +=
+            AcpiPsGetOpcodeSize (WalkState->Opcode);
+        WalkState->ArgTypes = WalkState->OpInfo->ParseArgs;
+        break;
+    }
+
+    return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiPsBuildNamedOp
+ *
+ * PARAMETERS:  WalkState           - Current state
+ *              AmlOpStart          - Begin of named Op in AML
+ *              UnnamedOp           - Early Op (not a named Op)
+ *              Op                  - Returned Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Parse a named Op
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiPsBuildNamedOp (
+    ACPI_WALK_STATE         *WalkState,
+    UINT8                   *AmlOpStart,
+    ACPI_PARSE_OBJECT       *UnnamedOp,
+    ACPI_PARSE_OBJECT       **Op)
+{
+    ACPI_STATUS             Status = AE_OK;
+    ACPI_PARSE_OBJECT       *Arg = NULL;
+
+
+    ACPI_FUNCTION_TRACE_PTR (PsBuildNamedOp, WalkState);
+
+
+    UnnamedOp->Common.Value.Arg = NULL;
+    UnnamedOp->Common.ArgListLength = 0;
+    UnnamedOp->Common.AmlOpcode = WalkState->Opcode;
+
+    /*
+     * Get and append arguments until we find the node that contains
+     * the name (the type ARGP_NAME).
+     */
+    while (GET_CURRENT_ARG_TYPE (WalkState->ArgTypes) &&
+          (GET_CURRENT_ARG_TYPE (WalkState->ArgTypes) != ARGP_NAME))
+    {
+        Status = AcpiPsGetNextArg (WalkState, &(WalkState->ParserState),
+            GET_CURRENT_ARG_TYPE (WalkState->ArgTypes), &Arg);
+        if (ACPI_FAILURE (Status))
+        {
+            return_ACPI_STATUS (Status);
+        }
+
+        AcpiPsAppendArg (UnnamedOp, Arg);
+        INCREMENT_ARG_LIST (WalkState->ArgTypes);
+    }
+
+    /*
+     * Make sure that we found a NAME and didn't run out of arguments
+     */
+    if (!GET_CURRENT_ARG_TYPE (WalkState->ArgTypes))
+    {
+        return_ACPI_STATUS (AE_AML_NO_OPERAND);
+    }
+
+    /* We know that this arg is a name, move to next arg */
+
+    INCREMENT_ARG_LIST (WalkState->ArgTypes);
+
+    /*
+     * Find the object. This will either insert the object into
+     * the namespace or simply look it up
+     */
+    WalkState->Op = NULL;
+
+    Status = WalkState->DescendingCallback (WalkState, Op);
+    if (ACPI_FAILURE (Status))
+    {
+        if (Status != AE_CTRL_TERMINATE)
+        {
+            ACPI_EXCEPTION ((AE_INFO, Status, "During name lookup/catalog"));
+        }
+        return_ACPI_STATUS (Status);
+    }
+
+    if (!*Op)
+    {
+        return_ACPI_STATUS (AE_CTRL_PARSE_CONTINUE);
+    }
+
+    Status = AcpiPsNextParseState (WalkState, *Op, Status);
+    if (ACPI_FAILURE (Status))
+    {
+        if (Status == AE_CTRL_PENDING)
+        {
+            Status = AE_CTRL_PARSE_PENDING;
+        }
+        return_ACPI_STATUS (Status);
+    }
+
+    AcpiPsAppendArg (*Op, UnnamedOp->Common.Value.Arg);
+
+    if ((*Op)->Common.AmlOpcode == AML_REGION_OP ||
+        (*Op)->Common.AmlOpcode == AML_DATA_REGION_OP)
+    {
+        /*
+         * Defer final parsing of an OperationRegion body, because we don't
+         * have enough info in the first pass to parse it correctly (i.e.,
+         * there may be method calls within the TermArg elements of the body.)
+         *
+         * However, we must continue parsing because the opregion is not a
+         * standalone package -- we don't know where the end is at this point.
+         *
+         * (Length is unknown until parse of the body complete)
+         */
+        (*Op)->Named.Data = AmlOpStart;
+        (*Op)->Named.Length = 0;
+    }
+
+    return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiPsCreateOp
+ *
+ * PARAMETERS:  WalkState           - Current state
+ *              AmlOpStart          - Op start in AML
+ *              NewOp               - Returned Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Get Op from AML
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiPsCreateOp (
+    ACPI_WALK_STATE         *WalkState,
+    UINT8                   *AmlOpStart,
+    ACPI_PARSE_OBJECT       **NewOp)
+{
+    ACPI_STATUS             Status = AE_OK;
+    ACPI_PARSE_OBJECT       *Op;
+    ACPI_PARSE_OBJECT       *NamedOp = NULL;
+    ACPI_PARSE_OBJECT       *ParentScope;
+    UINT8                   ArgumentCount;
+    const ACPI_OPCODE_INFO  *OpInfo;
+
+
+    ACPI_FUNCTION_TRACE_PTR (PsCreateOp, WalkState);
+
+
+    Status = AcpiPsGetAmlOpcode (WalkState);
+    if (Status == AE_CTRL_PARSE_CONTINUE)
+    {
+        return_ACPI_STATUS (AE_CTRL_PARSE_CONTINUE);
+    }
+
+    /* Create Op structure and append to parent's argument list */
+
+    WalkState->OpInfo = AcpiPsGetOpcodeInfo (WalkState->Opcode);
+    Op = AcpiPsAllocOp (WalkState->Opcode, AmlOpStart);
+    if (!Op)
+    {
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    if (WalkState->OpInfo->Flags & AML_NAMED)
+    {
+        Status = AcpiPsBuildNamedOp (WalkState, AmlOpStart, Op, &NamedOp);
+        AcpiPsFreeOp (Op);
+        if (ACPI_FAILURE (Status))
+        {
+            return_ACPI_STATUS (Status);
+        }
+
+        *NewOp = NamedOp;
+        return_ACPI_STATUS (AE_OK);
+    }
+
+    /* Not a named opcode, just allocate Op and append to parent */
+
+    if (WalkState->OpInfo->Flags & AML_CREATE)
+    {
+        /*
+         * Backup to beginning of CreateXXXfield declaration
+         * BodyLength is unknown until we parse the body
+         */
+        Op->Named.Data = AmlOpStart;
+        Op->Named.Length = 0;
+    }
+
+    if (WalkState->Opcode == AML_BANK_FIELD_OP)
+    {
+        /*
+         * Backup to beginning of BankField declaration
+         * BodyLength is unknown until we parse the body
+         */
+        Op->Named.Data = AmlOpStart;
+        Op->Named.Length = 0;
+    }
+
+    ParentScope = AcpiPsGetParentScope (&(WalkState->ParserState));
+    AcpiPsAppendArg (ParentScope, Op);
+
+    if (ParentScope)
+    {
+        OpInfo = AcpiPsGetOpcodeInfo (ParentScope->Common.AmlOpcode);
+        if (OpInfo->Flags & AML_HAS_TARGET)
+        {
+            ArgumentCount = AcpiPsGetArgumentCount (OpInfo->Type);
+            if (ParentScope->Common.ArgListLength > ArgumentCount)
+            {
+                Op->Common.Flags |= ACPI_PARSEOP_TARGET;
+            }
+        }
+        else if (ParentScope->Common.AmlOpcode == AML_INCREMENT_OP)
+        {
+            Op->Common.Flags |= ACPI_PARSEOP_TARGET;
+        }
+    }
+
+    if (WalkState->DescendingCallback != NULL)
+    {
+        /*
+         * Find the object. This will either insert the object into
+         * the namespace or simply look it up
+         */
+        WalkState->Op = *NewOp = Op;
+
+        Status = WalkState->DescendingCallback (WalkState, &Op);
+        Status = AcpiPsNextParseState (WalkState, Op, Status);
+        if (Status == AE_CTRL_PENDING)
+        {
+            Status = AE_CTRL_PARSE_PENDING;
+        }
+    }
+
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiPsCompleteOp
+ *
+ * PARAMETERS:  WalkState           - Current state
+ *              Op                  - Returned Op
+ *              Status              - Parse status before complete Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Complete Op
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiPsCompleteOp (
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       **Op,
+    ACPI_STATUS             Status)
+{
+    ACPI_STATUS             Status2;
+
+
+    ACPI_FUNCTION_TRACE_PTR (PsCompleteOp, WalkState);
+
+
+    /*
+     * Finished one argument of the containing scope
+     */
+    WalkState->ParserState.Scope->ParseScope.ArgCount--;
+
+    /* Close this Op (will result in parse subtree deletion) */
+
+    Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
+    if (ACPI_FAILURE (Status2))
+    {
+        return_ACPI_STATUS (Status2);
+    }
+
+    *Op = NULL;
+
+    switch (Status)
+    {
+    case AE_OK:
+
+        break;
+
+    case AE_CTRL_TRANSFER:
+
+        /* We are about to transfer to a called method */
+
+        WalkState->PrevOp = NULL;
+        WalkState->PrevArgTypes = WalkState->ArgTypes;
+        return_ACPI_STATUS (Status);
+
+    case AE_CTRL_END:
+
+        AcpiPsPopScope (&(WalkState->ParserState), Op,
+            &WalkState->ArgTypes, &WalkState->ArgCount);
+
+        if (*Op)
+        {
+            WalkState->Op = *Op;
+            WalkState->OpInfo = AcpiPsGetOpcodeInfo ((*Op)->Common.AmlOpcode);
+            WalkState->Opcode = (*Op)->Common.AmlOpcode;
+
+            Status = WalkState->AscendingCallback (WalkState);
+            Status = AcpiPsNextParseState (WalkState, *Op, Status);
+
+            Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
+            if (ACPI_FAILURE (Status2))
+            {
+                return_ACPI_STATUS (Status2);
+            }
+        }
+
+        Status = AE_OK;
+        break;
+
+    case AE_CTRL_BREAK:
+    case AE_CTRL_CONTINUE:
+
+        /* Pop off scopes until we find the While */
+
+        while (!(*Op) || ((*Op)->Common.AmlOpcode != AML_WHILE_OP))
+        {
+            AcpiPsPopScope (&(WalkState->ParserState), Op,
+                &WalkState->ArgTypes, &WalkState->ArgCount);
+        }
+
+        /* Close this iteration of the While loop */
+
+        WalkState->Op = *Op;
+        WalkState->OpInfo = AcpiPsGetOpcodeInfo ((*Op)->Common.AmlOpcode);
+        WalkState->Opcode = (*Op)->Common.AmlOpcode;
+
+        Status = WalkState->AscendingCallback (WalkState);
+        Status = AcpiPsNextParseState (WalkState, *Op, Status);
+
+        Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
+        if (ACPI_FAILURE (Status2))
+        {
+            return_ACPI_STATUS (Status2);
+        }
+
+        Status = AE_OK;
+        break;
+
+    case AE_CTRL_TERMINATE:
+
+        /* Clean up */
+        do
+        {
+            if (*Op)
+            {
+                Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
+                if (ACPI_FAILURE (Status2))
+                {
+                    return_ACPI_STATUS (Status2);
+                }
+
+                AcpiUtDeleteGenericState (
+                    AcpiUtPopGenericState (&WalkState->ControlState));
+            }
+
+            AcpiPsPopScope (&(WalkState->ParserState), Op,
+                &WalkState->ArgTypes, &WalkState->ArgCount);
+
+        } while (*Op);
+
+        return_ACPI_STATUS (AE_OK);
+
+    default:  /* All other non-AE_OK status */
+
+        do
+        {
+            if (*Op)
+            {
+                Status2 = AcpiPsCompleteThisOp (WalkState, *Op);
+                if (ACPI_FAILURE (Status2))
+                {
+                    return_ACPI_STATUS (Status2);
+                }
+            }
+
+            AcpiPsPopScope (&(WalkState->ParserState), Op,
+                &WalkState->ArgTypes, &WalkState->ArgCount);
+
+        } while (*Op);
+
+
+#if 0
+        /*
+         * TBD: Cleanup parse ops on error
+         */
+        if (*Op == NULL)
+        {
+            AcpiPsPopScope (ParserState, Op,
+                &WalkState->ArgTypes, &WalkState->ArgCount);
+        }
+#endif
+        WalkState->PrevOp = NULL;
+        WalkState->PrevArgTypes = WalkState->ArgTypes;
+        return_ACPI_STATUS (Status);
+    }
+
+    /* This scope complete? */
+
+    if (AcpiPsHasCompletedScope (&(WalkState->ParserState)))
+    {
+        AcpiPsPopScope (&(WalkState->ParserState), Op,
+            &WalkState->ArgTypes, &WalkState->ArgCount);
+        ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "Popped scope, Op=%p\n", *Op));
+    }
+    else
+    {
+        *Op = NULL;
+    }
+
+    return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiPsCompleteFinalOp
+ *
+ * PARAMETERS:  WalkState           - Current state
+ *              Op                  - Current Op
+ *              Status              - Current parse status before complete last
+ *                                    Op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Complete last Op.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiPsCompleteFinalOp (
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_STATUS             Status)
+{
+    ACPI_STATUS             Status2;
+
+
+    ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);
+
+
+    /*
+     * Complete the last Op (if not completed), and clear the scope stack.
+     * It is easily possible to end an AML "package" with an unbounded number
+     * of open scopes (such as when several ASL blocks are closed with
+     * sequential closing braces). We want to terminate each one cleanly.
+     */
+    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "AML package complete at Op %p\n", Op));
+    do
+    {
+        if (Op)
+        {
+            if (WalkState->AscendingCallback != NULL)
+            {
+                WalkState->Op = Op;
+                WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
+                WalkState->Opcode = Op->Common.AmlOpcode;
+
+                Status = WalkState->AscendingCallback (WalkState);
+                Status = AcpiPsNextParseState (WalkState, Op, Status);
+                if (Status == AE_CTRL_PENDING)
+                {
+                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);
+                    if (ACPI_FAILURE (Status))
+                    {
+                        return_ACPI_STATUS (Status);
+                    }
+                }
+
+                if (Status == AE_CTRL_TERMINATE)
+                {
+                    Status = AE_OK;
+
+                    /* Clean up */
+                    do
+                    {
+                        if (Op)
+                        {
+                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
+                            if (ACPI_FAILURE (Status2))
+                            {
+                                return_ACPI_STATUS (Status2);
+                            }
+                        }
+
+                        AcpiPsPopScope (&(WalkState->ParserState), &Op,
+                            &WalkState->ArgTypes, &WalkState->ArgCount);
+
+                    } while (Op);
+
+                    return_ACPI_STATUS (Status);
+                }
+
+                else if (ACPI_FAILURE (Status))
+                {
+                    /* First error is most important */
+
+                    (void) AcpiPsCompleteThisOp (WalkState, Op);
+                    return_ACPI_STATUS (Status);
+                }
+            }
+
+            Status2 = AcpiPsCompleteThisOp (WalkState, Op);
+            if (ACPI_FAILURE (Status2))
+            {
+                return_ACPI_STATUS (Status2);
+            }
+        }
+
+        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,
+            &WalkState->ArgCount);
+
+    } while (Op);
+
+    return_ACPI_STATUS (Status);
+}
diff --git a/usr/src/uts/intel/io/acpica/parser/psopcode.c b/usr/src/uts/intel/io/acpica/parser/psopcode.c
index ef2257e86f..ec44339b76 100644
--- a/usr/src/uts/intel/io/acpica/parser/psopcode.c
+++ b/usr/src/uts/intel/io/acpica/parser/psopcode.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,10 +41,8 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
-#include "acparser.h"
 #include "acopcode.h"
 #include "amlcode.h"
 
@@ -53,16 +51,13 @@
         ACPI_MODULE_NAME    ("psopcode")
 
 
-static const UINT8          AcpiGbl_ArgumentCount[] = {0,1,1,1,1,2,2,2,2,3,3,6};
-
-
 /*******************************************************************************
  *
  * NAME:        AcpiGbl_AmlOpInfo
  *
  * DESCRIPTION: Opcode table. Each entry contains <opcode, type, name, operands>
  *              The name is a simple ascii string, the operand specifier is an
- *              ascii string with one letter per operand.  The letter specifies
+ *              ascii string with one letter per operand. The letter specifies
  *              the operand type.
  *
  ******************************************************************************/
@@ -187,7 +182,7 @@ static const UINT8          AcpiGbl_ArgumentCount[] = {0,1,1,1,1,2,2,2,2,3,3,6};
 
 
 /*
- * Master Opcode information table.  A summary of everything we know about each
+ * Master Opcode information table. A summary of everything we know about each
  * opcode, all in one place.
  */
 const ACPI_OPCODE_INFO    AcpiGbl_AmlOpInfo[AML_NUM_OPCODES] =
@@ -250,7 +245,7 @@ const ACPI_OPCODE_INFO    AcpiGbl_AmlOpInfo[AML_NUM_OPCODES] =
 /* 34 */ ACPI_OP ("CreateWordField",    ARGP_CREATE_WORD_FIELD_OP, ARGI_CREATE_WORD_FIELD_OP,  ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
 /* 35 */ ACPI_OP ("CreateByteField",    ARGP_CREATE_BYTE_FIELD_OP, ARGI_CREATE_BYTE_FIELD_OP,  ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
 /* 36 */ ACPI_OP ("CreateBitField",     ARGP_CREATE_BIT_FIELD_OP,  ARGI_CREATE_BIT_FIELD_OP,   ACPI_TYPE_BUFFER_FIELD,      AML_CLASS_CREATE,          AML_TYPE_CREATE_FIELD,    AML_HAS_ARGS | AML_NSOBJECT | AML_NSNODE | AML_DEFER | AML_CREATE),
-/* 37 */ ACPI_OP ("ObjectType",         ARGP_TYPE_OP,              ARGI_TYPE_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_NO_OPERAND_RESOLVE),
+/* 37 */ ACPI_OP ("ObjectType",         ARGP_OBJECT_TYPE_OP,       ARGI_OBJECT_TYPE_OP,        ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_NO_OPERAND_RESOLVE),
 /* 38 */ ACPI_OP ("LAnd",               ARGP_LAND_OP,              ARGI_LAND_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL_NUMERIC | AML_CONSTANT),
 /* 39 */ ACPI_OP ("LOr",                ARGP_LOR_OP,               ARGI_LOR_OP,                ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_2A_0T_1R,   AML_FLAGS_EXEC_2A_0T_1R | AML_LOGICAL_NUMERIC | AML_CONSTANT),
 /* 3A */ ACPI_OP ("LNot",               ARGP_LNOT_OP,              ARGI_LNOT_OP,               ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,         AML_TYPE_EXEC_1A_0T_1R,   AML_FLAGS_EXEC_1A_0T_1R | AML_CONSTANT),
@@ -338,185 +333,11 @@ const ACPI_OPCODE_INFO    AcpiGbl_AmlOpInfo[AML_NUM_OPCODES] =
 /* ACPI 5.0 opcodes */
 
 /* 7F */ ACPI_OP ("-ConnectField-",     ARGP_CONNECTFIELD_OP,      ARGI_CONNECTFIELD_OP,       ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           AML_HAS_ARGS),
-/* 80 */ ACPI_OP ("-ExtAccessField-",   ARGP_CONNECTFIELD_OP,      ARGI_CONNECTFIELD_OP,       ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           0)
+/* 80 */ ACPI_OP ("-ExtAccessField-",   ARGP_CONNECTFIELD_OP,      ARGI_CONNECTFIELD_OP,       ACPI_TYPE_ANY,               AML_CLASS_INTERNAL,        AML_TYPE_BOGUS,           0),
 
-/*! [End] no source code translation !*/
-};
+/* ACPI 6.0 opcodes */
 
-/*
- * This table is directly indexed by the opcodes, and returns an
- * index into the table above
- */
-static const UINT8 AcpiGbl_ShortOpIndex[256] =
-{
-/*              0     1     2     3     4     5     6     7  */
-/*              8     9     A     B     C     D     E     F  */
-/* 0x00 */    0x00, 0x01, _UNK, _UNK, _UNK, _UNK, 0x02, _UNK,
-/* 0x08 */    0x03, _UNK, 0x04, 0x05, 0x06, 0x07, 0x6E, _UNK,
-/* 0x10 */    0x08, 0x09, 0x0a, 0x6F, 0x0b, _UNK, _UNK, _UNK,
-/* 0x18 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x20 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x28 */    _UNK, _UNK, _UNK, _UNK, _UNK, 0x63, _PFX, _PFX,
-/* 0x30 */    0x67, 0x66, 0x68, 0x65, 0x69, 0x64, 0x6A, 0x7D,
-/* 0x38 */    0x7F, 0x80, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x40 */    _UNK, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
-/* 0x48 */    _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
-/* 0x50 */    _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
-/* 0x58 */    _ASC, _ASC, _ASC, _UNK, _PFX, _UNK, _PFX, _ASC,
-/* 0x60 */    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
-/* 0x68 */    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, _UNK,
-/* 0x70 */    0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,
-/* 0x78 */    0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
-/* 0x80 */    0x2b, 0x2c, 0x2d, 0x2e, 0x70, 0x71, 0x2f, 0x30,
-/* 0x88 */    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x72,
-/* 0x90 */    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x73, 0x74,
-/* 0x98 */    0x75, 0x76, _UNK, _UNK, 0x77, 0x78, 0x79, 0x7A,
-/* 0xA0 */    0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x60, 0x61,
-/* 0xA8 */    0x62, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0xB0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0xB8 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0xC0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0xC8 */    _UNK, _UNK, _UNK, _UNK, 0x44, _UNK, _UNK, _UNK,
-/* 0xD0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0xD8 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0xE0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0xE8 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0xF0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0xF8 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, 0x45,
-};
+/* 81 */ ACPI_OP ("External",           ARGP_EXTERNAL_OP,          ARGI_EXTERNAL_OP,           ACPI_TYPE_ANY,               AML_CLASS_EXECUTE,/* ? */  AML_TYPE_EXEC_3A_0T_0R,   AML_FLAGS_EXEC_3A_0T_0R)
 
-/*
- * This table is indexed by the second opcode of the extended opcode
- * pair.  It returns an index into the opcode table (AcpiGbl_AmlOpInfo)
- */
-static const UINT8 AcpiGbl_LongOpIndex[NUM_EXTENDED_OPCODE] =
-{
-/*              0     1     2     3     4     5     6     7  */
-/*              8     9     A     B     C     D     E     F  */
-/* 0x00 */    _UNK, 0x46, 0x47, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x08 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x10 */    _UNK, _UNK, 0x48, 0x49, _UNK, _UNK, _UNK, _UNK,
-/* 0x18 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, 0x7B,
-/* 0x20 */    0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51,
-/* 0x28 */    0x52, 0x53, 0x54, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x30 */    0x55, 0x56, 0x57, 0x7e, _UNK, _UNK, _UNK, _UNK,
-/* 0x38 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x40 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x48 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x50 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x58 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x60 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x68 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x70 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x78 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
-/* 0x80 */    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
-/* 0x88 */    0x7C,
+/*! [End] no source code translation !*/
 };
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsGetOpcodeInfo
- *
- * PARAMETERS:  Opcode              - The AML opcode
- *
- * RETURN:      A pointer to the info about the opcode.
- *
- * DESCRIPTION: Find AML opcode description based on the opcode.
- *              NOTE: This procedure must ALWAYS return a valid pointer!
- *
- ******************************************************************************/
-
-const ACPI_OPCODE_INFO *
-AcpiPsGetOpcodeInfo (
-    UINT16                  Opcode)
-{
-    ACPI_FUNCTION_NAME (PsGetOpcodeInfo);
-
-
-    /*
-     * Detect normal 8-bit opcode or extended 16-bit opcode
-     */
-    if (!(Opcode & 0xFF00))
-    {
-        /* Simple (8-bit) opcode: 0-255, can't index beyond table  */
-
-        return (&AcpiGbl_AmlOpInfo [AcpiGbl_ShortOpIndex [(UINT8) Opcode]]);
-    }
-
-    if (((Opcode & 0xFF00) == AML_EXTENDED_OPCODE) &&
-        (((UINT8) Opcode) <= MAX_EXTENDED_OPCODE))
-    {
-        /* Valid extended (16-bit) opcode */
-
-        return (&AcpiGbl_AmlOpInfo [AcpiGbl_LongOpIndex [(UINT8) Opcode]]);
-    }
-
-    /* Unknown AML opcode */
-
-    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-        "Unknown AML opcode [%4.4X]\n", Opcode));
-
-    return (&AcpiGbl_AmlOpInfo [_UNK]);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsGetOpcodeName
- *
- * PARAMETERS:  Opcode              - The AML opcode
- *
- * RETURN:      A pointer to the name of the opcode (ASCII String)
- *              Note: Never returns NULL.
- *
- * DESCRIPTION: Translate an opcode into a human-readable string
- *
- ******************************************************************************/
-
-char *
-AcpiPsGetOpcodeName (
-    UINT16                  Opcode)
-{
-#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUG_OUTPUT)
-
-    const ACPI_OPCODE_INFO  *Op;
-
-
-    Op = AcpiPsGetOpcodeInfo (Opcode);
-
-    /* Always guaranteed to return a valid pointer */
-
-    return (Op->Name);
-
-#else
-    return ("OpcodeName unavailable");
-
-#endif
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsGetArgumentCount
- *
- * PARAMETERS:  OpType              - Type associated with the AML opcode
- *
- * RETURN:      Argument count
- *
- * DESCRIPTION: Obtain the number of expected arguments for an AML opcode
- *
- ******************************************************************************/
-
-UINT8
-AcpiPsGetArgumentCount (
-    UINT32                  OpType)
-{
-
-    if (OpType <= AML_TYPE_EXEC_6A_0T_1R)
-    {
-        return (AcpiGbl_ArgumentCount[OpType]);
-    }
-
-    return (0);
-}
diff --git a/usr/src/uts/intel/io/acpica/parser/psopinfo.c b/usr/src/uts/intel/io/acpica/parser/psopinfo.c
new file mode 100644
index 0000000000..324d87a93f
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/parser/psopinfo.c
@@ -0,0 +1,284 @@
+/******************************************************************************
+ *
+ * Module Name: psopinfo - AML opcode information functions and dispatch tables
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acparser.h"
+#include "acopcode.h"
+#include "amlcode.h"
+
+
+#define _COMPONENT          ACPI_PARSER
+        ACPI_MODULE_NAME    ("psopinfo")
+
+
+static const UINT8      AcpiGbl_ArgumentCount[] = {0,1,1,1,1,2,2,2,2,3,3,6};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiPsGetOpcodeInfo
+ *
+ * PARAMETERS:  Opcode              - The AML opcode
+ *
+ * RETURN:      A pointer to the info about the opcode.
+ *
+ * DESCRIPTION: Find AML opcode description based on the opcode.
+ *              NOTE: This procedure must ALWAYS return a valid pointer!
+ *
+ ******************************************************************************/
+
+const ACPI_OPCODE_INFO *
+AcpiPsGetOpcodeInfo (
+    UINT16                  Opcode)
+{
+#ifdef ACPI_DEBUG_OUTPUT
+    const char              *OpcodeName = "Unknown AML opcode";
+#endif
+
+    ACPI_FUNCTION_NAME (PsGetOpcodeInfo);
+
+
+    /*
+     * Detect normal 8-bit opcode or extended 16-bit opcode
+     */
+    if (!(Opcode & 0xFF00))
+    {
+        /* Simple (8-bit) opcode: 0-255, can't index beyond table  */
+
+        return (&AcpiGbl_AmlOpInfo [AcpiGbl_ShortOpIndex [(UINT8) Opcode]]);
+    }
+
+    if (((Opcode & 0xFF00) == AML_EXTENDED_OPCODE) &&
+        (((UINT8) Opcode) <= MAX_EXTENDED_OPCODE))
+    {
+        /* Valid extended (16-bit) opcode */
+
+        return (&AcpiGbl_AmlOpInfo [AcpiGbl_LongOpIndex [(UINT8) Opcode]]);
+    }
+
+#if defined ACPI_ASL_COMPILER && defined ACPI_DEBUG_OUTPUT
+#include "asldefine.h"
+
+    switch (Opcode)
+    {
+    case AML_RAW_DATA_BYTE:
+        OpcodeName = "-Raw Data Byte-";
+        break;
+
+    case AML_RAW_DATA_WORD:
+        OpcodeName = "-Raw Data Word-";
+        break;
+
+    case AML_RAW_DATA_DWORD:
+        OpcodeName = "-Raw Data Dword-";
+        break;
+
+    case AML_RAW_DATA_QWORD:
+        OpcodeName = "-Raw Data Qword-";
+        break;
+
+    case AML_RAW_DATA_BUFFER:
+        OpcodeName = "-Raw Data Buffer-";
+        break;
+
+    case AML_RAW_DATA_CHAIN:
+        OpcodeName = "-Raw Data Buffer Chain-";
+        break;
+
+    case AML_PACKAGE_LENGTH:
+        OpcodeName = "-Package Length-";
+        break;
+
+    case AML_UNASSIGNED_OPCODE:
+        OpcodeName = "-Unassigned Opcode-";
+        break;
+
+    case AML_DEFAULT_ARG_OP:
+        OpcodeName = "-Default Arg-";
+        break;
+
+    default:
+        break;
+    }
+#endif
+
+    /* Unknown AML opcode */
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+        "%s [%4.4X]\n", OpcodeName, Opcode));
+
+    return (&AcpiGbl_AmlOpInfo [_UNK]);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiPsGetOpcodeName
+ *
+ * PARAMETERS:  Opcode              - The AML opcode
+ *
+ * RETURN:      A pointer to the name of the opcode (ASCII String)
+ *              Note: Never returns NULL.
+ *
+ * DESCRIPTION: Translate an opcode into a human-readable string
+ *
+ ******************************************************************************/
+
+const char *
+AcpiPsGetOpcodeName (
+    UINT16                  Opcode)
+{
+#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUG_OUTPUT)
+
+    const ACPI_OPCODE_INFO  *Op;
+
+
+    Op = AcpiPsGetOpcodeInfo (Opcode);
+
+    /* Always guaranteed to return a valid pointer */
+
+    return (Op->Name);
+
+#else
+    return ("OpcodeName unavailable");
+
+#endif
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiPsGetArgumentCount
+ *
+ * PARAMETERS:  OpType              - Type associated with the AML opcode
+ *
+ * RETURN:      Argument count
+ *
+ * DESCRIPTION: Obtain the number of expected arguments for an AML opcode
+ *
+ ******************************************************************************/
+
+UINT8
+AcpiPsGetArgumentCount (
+    UINT32                  OpType)
+{
+
+    if (OpType <= AML_TYPE_EXEC_6A_0T_1R)
+    {
+        return (AcpiGbl_ArgumentCount[OpType]);
+    }
+
+    return (0);
+}
+
+
+/*
+ * This table is directly indexed by the opcodes It returns
+ * an index into the opcode table (AcpiGbl_AmlOpInfo)
+ */
+const UINT8 AcpiGbl_ShortOpIndex[256] =
+{
+/*              0     1     2     3     4     5     6     7  */
+/*              8     9     A     B     C     D     E     F  */
+/* 0x00 */    0x00, 0x01, _UNK, _UNK, _UNK, _UNK, 0x02, _UNK,
+/* 0x08 */    0x03, _UNK, 0x04, 0x05, 0x06, 0x07, 0x6E, _UNK,
+/* 0x10 */    0x08, 0x09, 0x0a, 0x6F, 0x0b, 0x81, _UNK, _UNK,
+/* 0x18 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x20 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x28 */    _UNK, _UNK, _UNK, _UNK, _UNK, 0x63, _PFX, _PFX,
+/* 0x30 */    0x67, 0x66, 0x68, 0x65, 0x69, 0x64, 0x6A, 0x7D,
+/* 0x38 */    0x7F, 0x80, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x40 */    _UNK, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
+/* 0x48 */    _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
+/* 0x50 */    _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC, _ASC,
+/* 0x58 */    _ASC, _ASC, _ASC, _UNK, _PFX, _UNK, _PFX, _ASC,
+/* 0x60 */    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,
+/* 0x68 */    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, _UNK,
+/* 0x70 */    0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,
+/* 0x78 */    0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
+/* 0x80 */    0x2b, 0x2c, 0x2d, 0x2e, 0x70, 0x71, 0x2f, 0x30,
+/* 0x88 */    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x72,
+/* 0x90 */    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x73, 0x74,
+/* 0x98 */    0x75, 0x76, _UNK, _UNK, 0x77, 0x78, 0x79, 0x7A,
+/* 0xA0 */    0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x60, 0x61,
+/* 0xA8 */    0x62, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xB0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xB8 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xC0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xC8 */    _UNK, _UNK, _UNK, _UNK, 0x44, _UNK, _UNK, _UNK,
+/* 0xD0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xD8 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xE0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xE8 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xF0 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0xF8 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, 0x45,
+};
+
+/*
+ * This table is indexed by the second opcode of the extended opcode
+ * pair. It returns an index into the opcode table (AcpiGbl_AmlOpInfo)
+ */
+const UINT8 AcpiGbl_LongOpIndex[NUM_EXTENDED_OPCODE] =
+{
+/*              0     1     2     3     4     5     6     7  */
+/*              8     9     A     B     C     D     E     F  */
+/* 0x00 */    _UNK, 0x46, 0x47, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x08 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x10 */    _UNK, _UNK, 0x48, 0x49, _UNK, _UNK, _UNK, _UNK,
+/* 0x18 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, 0x7B,
+/* 0x20 */    0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51,
+/* 0x28 */    0x52, 0x53, 0x54, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x30 */    0x55, 0x56, 0x57, 0x7e, _UNK, _UNK, _UNK, _UNK,
+/* 0x38 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x40 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x48 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x50 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x58 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x60 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x68 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x70 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x78 */    _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK, _UNK,
+/* 0x80 */    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+/* 0x88 */    0x7C,
+};
diff --git a/usr/src/uts/intel/io/acpica/parser/psparse.c b/usr/src/uts/intel/io/acpica/parser/psparse.c
index bcf46adfe5..810d97e0e0 100644
--- a/usr/src/uts/intel/io/acpica/parser/psparse.c
+++ b/usr/src/uts/intel/io/acpica/parser/psparse.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,12 +41,11 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 /*
  * Parse the AML and build an operation tree as most interpreters,
- * like Perl, do.  Parsing is done by hand rather than with a YACC
+ * like Perl, do. Parsing is done by hand rather than with a YACC
  * generated parser to tightly constrain stack and dynamic memory
- * usage.  At the same time, parsing is kept flexible and the code
+ * usage. At the same time, parsing is kept flexible and the code
  * fairly compact by parsing based on a list of AML opcode
  * templates in AmlOpInfo[]
  */
@@ -162,6 +161,8 @@ AcpiPsCompleteThisOp (
         return_ACPI_STATUS (AE_OK);  /* OK for now */
     }
 
+    AcpiExStopTraceOpcode (Op, WalkState);
+
     /* Delete this op and the subtree below it if asked to */
 
     if (((WalkState->ParseFlags & ACPI_PARSE_TREE_MASK) != ACPI_PARSE_DELETE_TREE) ||
@@ -191,15 +192,16 @@ AcpiPsCompleteThisOp (
         switch (ParentInfo->Class)
         {
         case AML_CLASS_CONTROL:
+
             break;
 
         case AML_CLASS_CREATE:
-
             /*
-             * These opcodes contain TermArg operands.  The current
+             * These opcodes contain TermArg operands. The current
              * op must be replaced by a placeholder return op
              */
-            ReplacementOp = AcpiPsAllocOp (AML_INT_RETURN_VALUE_OP);
+            ReplacementOp = AcpiPsAllocOp (
+                AML_INT_RETURN_VALUE_OP, Op->Common.Aml);
             if (!ReplacementOp)
             {
                 Status = AE_NO_MEMORY;
@@ -207,9 +209,8 @@ AcpiPsCompleteThisOp (
             break;
 
         case AML_CLASS_NAMED_OBJECT:
-
             /*
-             * These opcodes contain TermArg operands.  The current
+             * These opcodes contain TermArg operands. The current
              * op must be replaced by a placeholder return op
              */
             if ((Op->Common.Parent->Common.AmlOpcode == AML_REGION_OP)       ||
@@ -219,7 +220,8 @@ AcpiPsCompleteThisOp (
                 (Op->Common.Parent->Common.AmlOpcode == AML_BANK_FIELD_OP)   ||
                 (Op->Common.Parent->Common.AmlOpcode == AML_VAR_PACKAGE_OP))
             {
-                ReplacementOp = AcpiPsAllocOp (AML_INT_RETURN_VALUE_OP);
+                ReplacementOp = AcpiPsAllocOp (
+                    AML_INT_RETURN_VALUE_OP, Op->Common.Aml);
                 if (!ReplacementOp)
                 {
                     Status = AE_NO_MEMORY;
@@ -232,7 +234,8 @@ AcpiPsCompleteThisOp (
                     (Op->Common.AmlOpcode == AML_PACKAGE_OP) ||
                     (Op->Common.AmlOpcode == AML_VAR_PACKAGE_OP))
                 {
-                    ReplacementOp = AcpiPsAllocOp (Op->Common.AmlOpcode);
+                    ReplacementOp = AcpiPsAllocOp (Op->Common.AmlOpcode,
+                        Op->Common.Aml);
                     if (!ReplacementOp)
                     {
                         Status = AE_NO_MEMORY;
@@ -248,7 +251,8 @@ AcpiPsCompleteThisOp (
 
         default:
 
-            ReplacementOp = AcpiPsAllocOp (AML_INT_RETURN_VALUE_OP);
+            ReplacementOp = AcpiPsAllocOp (
+                AML_INT_RETURN_VALUE_OP, Op->Common.Aml);
             if (!ReplacementOp)
             {
                 Status = AE_NO_MEMORY;
@@ -263,11 +267,11 @@ AcpiPsCompleteThisOp (
 
             if (ReplacementOp)
             {
-                ReplacementOp->Common.Parent        = Op->Common.Parent;
-                ReplacementOp->Common.Value.Arg     = NULL;
-                ReplacementOp->Common.Node          = Op->Common.Node;
+                ReplacementOp->Common.Parent = Op->Common.Parent;
+                ReplacementOp->Common.Value.Arg = NULL;
+                ReplacementOp->Common.Node = Op->Common.Node;
                 Op->Common.Parent->Common.Value.Arg = ReplacementOp;
-                ReplacementOp->Common.Next          = Op->Common.Next;
+                ReplacementOp->Common.Next = Op->Common.Next;
             }
             else
             {
@@ -286,11 +290,11 @@ AcpiPsCompleteThisOp (
             {
                 if (ReplacementOp)
                 {
-                    ReplacementOp->Common.Parent    = Op->Common.Parent;
+                    ReplacementOp->Common.Parent = Op->Common.Parent;
                     ReplacementOp->Common.Value.Arg = NULL;
-                    ReplacementOp->Common.Node      = Op->Common.Node;
-                    Prev->Common.Next               = ReplacementOp;
-                    ReplacementOp->Common.Next      = Op->Common.Next;
+                    ReplacementOp->Common.Node = Op->Common.Node;
+                    Prev->Common.Next = ReplacementOp;
+                    ReplacementOp->Common.Next = Op->Common.Next;
                     Next = NULL;
                 }
                 else
@@ -352,7 +356,6 @@ AcpiPsNextParseState (
         Status = AE_CTRL_TERMINATE;
         break;
 
-
     case AE_CTRL_BREAK:
 
         ParserState->Aml = WalkState->AmlLastWhile;
@@ -360,14 +363,12 @@ AcpiPsNextParseState (
         Status = AE_CTRL_BREAK;
         break;
 
-
     case AE_CTRL_CONTINUE:
 
         ParserState->Aml = WalkState->AmlLastWhile;
         Status = AE_CTRL_CONTINUE;
         break;
 
-
     case AE_CTRL_PENDING:
 
         ParserState->Aml = WalkState->AmlLastWhile;
@@ -390,11 +391,10 @@ AcpiPsNextParseState (
         Status = AE_CTRL_PENDING;
         break;
 
-
     case AE_CTRL_FALSE:
         /*
          * Either an IF/WHILE Predicate was false or we encountered a BREAK
-         * opcode.  In both cases, we do not execute the rest of the
+         * opcode. In both cases, we do not execute the rest of the
          * package;  We simply close out the parent (finishing the walk of
          * this branch of the tree) and continue execution at the parent
          * level.
@@ -407,7 +407,6 @@ AcpiPsNextParseState (
         Status = AE_CTRL_END;
         break;
 
-
     case AE_CTRL_TRANSFER:
 
         /* A method call (invocation) -- transfer control */
@@ -422,7 +421,6 @@ AcpiPsNextParseState (
         WalkState->ReturnUsed = AcpiDsIsResultUsed (Op, WalkState);
         break;
 
-
     default:
 
         Status = CallbackStatus;
@@ -496,7 +494,8 @@ AcpiPsParseAml (
      */
     if (WalkState->MethodDesc)
     {
-        WalkState->Thread->CurrentSyncLevel = WalkState->MethodDesc->Method.SyncLevel;
+        WalkState->Thread->CurrentSyncLevel =
+            WalkState->MethodDesc->Method.SyncLevel;
     }
 
     AcpiDsPushWalkState (WalkState, Thread);
@@ -508,7 +507,7 @@ AcpiPsParseAml (
     AcpiGbl_CurrentWalkList = Thread;
 
     /*
-     * Execute the walk loop as long as there is a valid Walk State.  This
+     * Execute the walk loop as long as there is a valid Walk State. This
      * handles nested control method invocations without recursion.
      */
     ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, "State=%p\n", WalkState));
@@ -542,8 +541,8 @@ AcpiPsParseAml (
             }
 
             /*
-             * If the transfer to the new method method call worked, a new walk
-             * state was created -- get it
+             * If the transfer to the new method method call worked
+             *, a new walk state was created -- get it
              */
             WalkState = AcpiDsGetCurrentWalkState (Thread);
             continue;
@@ -562,7 +561,8 @@ AcpiPsParseAml (
             /* Check for possible multi-thread reentrancy problem */
 
             if ((Status == AE_ALREADY_EXISTS) &&
-                (!(WalkState->MethodDesc->Method.InfoFlags & ACPI_METHOD_SERIALIZED)))
+                (!(WalkState->MethodDesc->Method.InfoFlags &
+                    ACPI_METHOD_SERIALIZED)))
             {
                 /*
                  * Method is not serialized and tried to create an object
@@ -588,7 +588,8 @@ AcpiPsParseAml (
          * encountered an error during the method parse phase, there's lots of
          * cleanup to do
          */
-        if (((WalkState->ParseFlags & ACPI_PARSE_MODE_MASK) == ACPI_PARSE_EXECUTE) ||
+        if (((WalkState->ParseFlags & ACPI_PARSE_MODE_MASK) ==
+            ACPI_PARSE_EXECUTE) ||
             (ACPI_FAILURE (Status)))
         {
             AcpiDsTerminateControlMethod (WalkState->MethodDesc, WalkState);
@@ -635,7 +636,7 @@ AcpiPsParseAml (
                     /* Restart the calling control method */
 
                     Status = AcpiDsRestartControlMethod (WalkState,
-                                PreviousWalkState->ImplicitReturnObj);
+                        PreviousWalkState->ImplicitReturnObj);
                 }
                 else
                 {
@@ -646,7 +647,7 @@ AcpiPsParseAml (
                     AcpiDsClearImplicitReturn (PreviousWalkState);
 
                     Status = AcpiDsRestartControlMethod (WalkState,
-                                PreviousWalkState->ReturnDesc);
+                        PreviousWalkState->ReturnDesc);
                 }
                 if (ACPI_SUCCESS (Status))
                 {
@@ -707,5 +708,3 @@ AcpiPsParseAml (
     AcpiGbl_CurrentWalkList = PrevWalkList;
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/parser/psscope.c b/usr/src/uts/intel/io/acpica/parser/psscope.c
index 1df5a33af3..f5b89d0f5d 100644
--- a/usr/src/uts/intel/io/acpica/parser/psscope.c
+++ b/usr/src/uts/intel/io/acpica/parser/psscope.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -237,9 +236,9 @@ AcpiPsPopScope (
 
         /* Return to parsing previous op */
 
-        *Op                 = Scope->ParseScope.Op;
-        *ArgList            = Scope->ParseScope.ArgList;
-        *ArgCount           = Scope->ParseScope.ArgCount;
+        *Op = Scope->ParseScope.Op;
+        *ArgList = Scope->ParseScope.ArgList;
+        *ArgCount = Scope->ParseScope.ArgCount;
         ParserState->PkgEnd = Scope->ParseScope.PkgEnd;
 
         /* All done with this scope state structure */
@@ -250,8 +249,8 @@ AcpiPsPopScope (
     {
         /* Empty parse stack, prepare to fetch next opcode */
 
-        *Op       = NULL;
-        *ArgList  = 0;
+        *Op = NULL;
+        *ArgList = 0;
         *ArgCount = 0;
     }
 
@@ -299,4 +298,3 @@ AcpiPsCleanupScope (
 
     return_VOID;
 }
-
diff --git a/usr/src/uts/intel/io/acpica/parser/pstree.c b/usr/src/uts/intel/io/acpica/parser/pstree.c
index 8271314e16..729856982b 100644
--- a/usr/src/uts/intel/io/acpica/parser/pstree.c
+++ b/usr/src/uts/intel/io/acpica/parser/pstree.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __PSTREE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -322,7 +319,6 @@ AcpiPsGetChild (
         Child = AcpiPsGetArg (Op, 0);
         break;
 
-
     case AML_BUFFER_OP:
     case AML_PACKAGE_OP:
     case AML_METHOD_OP:
@@ -333,28 +329,25 @@ AcpiPsGetChild (
         Child = AcpiPsGetArg (Op, 1);
         break;
 
-
     case AML_POWER_RES_OP:
     case AML_INDEX_FIELD_OP:
 
         Child = AcpiPsGetArg (Op, 2);
         break;
 
-
     case AML_PROCESSOR_OP:
     case AML_BANK_FIELD_OP:
 
         Child = AcpiPsGetArg (Op, 3);
         break;
 
-
     default:
+
         /* All others have no children */
+
         break;
     }
 
     return (Child);
 }
 #endif
-
-
diff --git a/usr/src/uts/intel/io/acpica/parser/psutils.c b/usr/src/uts/intel/io/acpica/parser/psutils.c
index e28b75cc8f..9b1019c711 100644
--- a/usr/src/uts/intel/io/acpica/parser/psutils.c
+++ b/usr/src/uts/intel/io/acpica/parser/psutils.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -65,12 +64,12 @@
 
 ACPI_PARSE_OBJECT *
 AcpiPsCreateScopeOp (
-    void)
+    UINT8                   *Aml)
 {
     ACPI_PARSE_OBJECT       *ScopeOp;
 
 
-    ScopeOp = AcpiPsAllocOp (AML_SCOPE_OP);
+    ScopeOp = AcpiPsAllocOp (AML_SCOPE_OP, Aml);
     if (!ScopeOp)
     {
         return (NULL);
@@ -105,9 +104,9 @@ AcpiPsInitOp (
     Op->Common.DescriptorType = ACPI_DESC_TYPE_PARSER;
     Op->Common.AmlOpcode = Opcode;
 
-    ACPI_DISASM_ONLY_MEMBERS (ACPI_STRNCPY (Op->Common.AmlOpName,
-            (AcpiPsGetOpcodeInfo (Opcode))->Name,
-                sizeof (Op->Common.AmlOpName)));
+    ACPI_DISASM_ONLY_MEMBERS (strncpy (Op->Common.AmlOpName,
+        (AcpiPsGetOpcodeInfo (Opcode))->Name,
+        sizeof (Op->Common.AmlOpName)));
 }
 
 
@@ -116,18 +115,20 @@ AcpiPsInitOp (
  * FUNCTION:    AcpiPsAllocOp
  *
  * PARAMETERS:  Opcode          - Opcode that will be stored in the new Op
+ *              Aml             - Address of the opcode
  *
  * RETURN:      Pointer to the new Op, null on failure
  *
  * DESCRIPTION: Allocate an acpi_op, choose op type (and thus size) based on
- *              opcode.  A cache of opcodes is available for the pure
+ *              opcode. A cache of opcodes is available for the pure
  *              GENERIC_OP, since this is by far the most commonly used.
  *
  ******************************************************************************/
 
 ACPI_PARSE_OBJECT*
 AcpiPsAllocOp (
-    UINT16                  Opcode)
+    UINT16                  Opcode,
+    UINT8                   *Aml)
 {
     ACPI_PARSE_OBJECT       *Op;
     const ACPI_OPCODE_INFO  *OpInfo;
@@ -147,7 +148,7 @@ AcpiPsAllocOp (
     }
     else if (OpInfo->Flags & AML_NAMED)
     {
-        Flags = ACPI_PARSEOP_NAMED;
+        Flags = ACPI_PARSEOP_NAMED_OBJECT;
     }
     else if (Opcode == AML_INT_BYTELIST_OP)
     {
@@ -174,6 +175,7 @@ AcpiPsAllocOp (
     if (Op)
     {
         AcpiPsInitOp (Op, Opcode);
+        Op->Common.Aml = Aml;
         Op->Common.Flags = Flags;
     }
 
@@ -189,7 +191,7 @@ AcpiPsAllocOp (
  *
  * RETURN:      None.
  *
- * DESCRIPTION: Free an Op object.  Either put it on the GENERIC_OP cache list
+ * DESCRIPTION: Free an Op object. Either put it on the GENERIC_OP cache list
  *              or actually free it.
  *
  ******************************************************************************/
@@ -203,7 +205,8 @@ AcpiPsFreeOp (
 
     if (Op->Common.AmlOpcode == AML_INT_RETURN_VALUE_OP)
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Free retval op: %p\n", Op));
+        ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+            "Free retval op: %p\n", Op));
     }
 
     if (Op->Common.Flags & ACPI_PARSEOP_GENERIC)
@@ -237,17 +240,6 @@ AcpiPsIsLeadingChar (
 }
 
 
-/*
- * Is "c" a namestring prefix character?
- */
-BOOLEAN
-AcpiPsIsPrefixChar (
-    UINT32                  c)
-{
-    return ((BOOLEAN) (c == '\\' || c == '^'));
-}
-
-
 /*
  * Get op's name (4-byte name segment) or 0 if unnamed
  */
@@ -287,4 +279,3 @@ AcpiPsSetName (
 
     Op->Named.Name = name;
 }
-
diff --git a/usr/src/uts/intel/io/acpica/parser/pswalk.c b/usr/src/uts/intel/io/acpica/parser/pswalk.c
index 9734c4d177..fb6071adef 100644
--- a/usr/src/uts/intel/io/acpica/parser/pswalk.c
+++ b/usr/src/uts/intel/io/acpica/parser/pswalk.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
@@ -107,6 +106,7 @@ AcpiPsDeleteParseTree (
         {
             return_VOID;
         }
+
         if (Next)
         {
             Op = Next;
diff --git a/usr/src/uts/intel/io/acpica/parser/psxface.c b/usr/src/uts/intel/io/acpica/parser/psxface.c
index 2a012c2915..a6fe31648e 100644
--- a/usr/src/uts/intel/io/acpica/parser/psxface.c
+++ b/usr/src/uts/intel/io/acpica/parser/psxface.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,14 +41,13 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __PSXFACE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acparser.h"
 #include "acdispat.h"
 #include "acinterp.h"
 #include "actables.h"
+#include "acnamesp.h"
 
 
 #define _COMPONENT          ACPI_PARSER
@@ -56,14 +55,6 @@
 
 /* Local Prototypes */
 
-static void
-AcpiPsStartTrace (
-    ACPI_EVALUATE_INFO      *Info);
-
-static void
-AcpiPsStopTrace (
-    ACPI_EVALUATE_INFO      *Info);
-
 static void
 AcpiPsUpdateParameterList (
     ACPI_EVALUATE_INFO      *Info,
@@ -88,7 +79,7 @@ AcpiPsUpdateParameterList (
 
 ACPI_STATUS
 AcpiDebugTrace (
-    char                    *Name,
+    const char              *Name,
     UINT32                  DebugLevel,
     UINT32                  DebugLayer,
     UINT32                  Flags)
@@ -102,128 +93,14 @@ AcpiDebugTrace (
         return (Status);
     }
 
-    /* TBDs: Validate name, allow full path or just nameseg */
-
-    AcpiGbl_TraceMethodName = *ACPI_CAST_PTR (UINT32, Name);
+    AcpiGbl_TraceMethodName = Name;
     AcpiGbl_TraceFlags = Flags;
+    AcpiGbl_TraceDbgLevel = DebugLevel;
+    AcpiGbl_TraceDbgLayer = DebugLayer;
+    Status = AE_OK;
 
-    if (DebugLevel)
-    {
-        AcpiGbl_TraceDbgLevel = DebugLevel;
-    }
-    if (DebugLayer)
-    {
-        AcpiGbl_TraceDbgLayer = DebugLayer;
-    }
-
-    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsStartTrace
- *
- * PARAMETERS:  Info        - Method info struct
- *
- * RETURN:      None
- *
- * DESCRIPTION: Start control method execution trace
- *
- ******************************************************************************/
-
-static void
-AcpiPsStartTrace (
-    ACPI_EVALUATE_INFO      *Info)
-{
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
-    if (ACPI_FAILURE (Status))
-    {
-        return;
-    }
-
-    if ((!AcpiGbl_TraceMethodName) ||
-        (AcpiGbl_TraceMethodName != Info->ResolvedNode->Name.Integer))
-    {
-        goto Exit;
-    }
-
-    AcpiGbl_OriginalDbgLevel = AcpiDbgLevel;
-    AcpiGbl_OriginalDbgLayer = AcpiDbgLayer;
-
-    AcpiDbgLevel = 0x00FFFFFF;
-    AcpiDbgLayer = ACPI_UINT32_MAX;
-
-    if (AcpiGbl_TraceDbgLevel)
-    {
-        AcpiDbgLevel = AcpiGbl_TraceDbgLevel;
-    }
-    if (AcpiGbl_TraceDbgLayer)
-    {
-        AcpiDbgLayer = AcpiGbl_TraceDbgLayer;
-    }
-
-
-Exit:
-    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiPsStopTrace
- *
- * PARAMETERS:  Info        - Method info struct
- *
- * RETURN:      None
- *
- * DESCRIPTION: Stop control method execution trace
- *
- ******************************************************************************/
-
-static void
-AcpiPsStopTrace (
-    ACPI_EVALUATE_INFO      *Info)
-{
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
-    if (ACPI_FAILURE (Status))
-    {
-        return;
-    }
-
-    if ((!AcpiGbl_TraceMethodName) ||
-        (AcpiGbl_TraceMethodName != Info->ResolvedNode->Name.Integer))
-    {
-        goto Exit;
-    }
-
-    /* Disable further tracing if type is one-shot */
-
-    if (AcpiGbl_TraceFlags & 1)
-    {
-        AcpiGbl_TraceMethodName = 0;
-        AcpiGbl_TraceDbgLevel = 0;
-        AcpiGbl_TraceDbgLayer = 0;
-    }
-
-    AcpiDbgLevel = AcpiGbl_OriginalDbgLevel;
-    AcpiDbgLayer = AcpiGbl_OriginalDbgLayer;
-
-Exit:
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
+    return (Status);
 }
 
 
@@ -268,14 +145,14 @@ AcpiPsExecuteMethod (
 
     /* Validate the Info and method Node */
 
-    if (!Info || !Info->ResolvedNode)
+    if (!Info || !Info->Node)
     {
         return_ACPI_STATUS (AE_NULL_ENTRY);
     }
 
     /* Init for new method, wait on concurrency semaphore */
 
-    Status = AcpiDsBeginMethodExecution (Info->ResolvedNode, Info->ObjDesc, NULL);
+    Status = AcpiDsBeginMethodExecution (Info->Node, Info->ObjDesc, NULL);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -286,20 +163,16 @@ AcpiPsExecuteMethod (
      */
     AcpiPsUpdateParameterList (Info, REF_INCREMENT);
 
-    /* Begin tracing if requested */
-
-    AcpiPsStartTrace (Info);
-
     /*
      * Execute the method. Performs parse simultaneously
      */
     ACPI_DEBUG_PRINT ((ACPI_DB_PARSE,
         "**** Begin Method Parse/Execute [%4.4s] **** Node=%p Obj=%p\n",
-        Info->ResolvedNode->Name.Ascii, Info->ResolvedNode, Info->ObjDesc));
+        Info->Node->Name.Ascii, Info->Node, Info->ObjDesc));
 
     /* Create and init a Root Node */
 
-    Op = AcpiPsCreateScopeOp ();
+    Op = AcpiPsCreateScopeOp (Info->ObjDesc->Method.AmlStart);
     if (!Op)
     {
         Status = AE_NO_MEMORY;
@@ -310,16 +183,16 @@ AcpiPsExecuteMethod (
 
     Info->PassNumber = ACPI_IMODE_EXECUTE;
     WalkState = AcpiDsCreateWalkState (
-                    Info->ObjDesc->Method.OwnerId, NULL, NULL, NULL);
+        Info->ObjDesc->Method.OwnerId, NULL, NULL, NULL);
     if (!WalkState)
     {
         Status = AE_NO_MEMORY;
         goto Cleanup;
     }
 
-    Status = AcpiDsInitAmlWalk (WalkState, Op, Info->ResolvedNode,
-                Info->ObjDesc->Method.AmlStart,
-                Info->ObjDesc->Method.AmlLength, Info, Info->PassNumber);
+    Status = AcpiDsInitAmlWalk (WalkState, Op, Info->Node,
+        Info->ObjDesc->Method.AmlStart,
+        Info->ObjDesc->Method.AmlLength, Info, Info->PassNumber);
     if (ACPI_FAILURE (Status))
     {
         AcpiDsDeleteWalkState (WalkState);
@@ -348,8 +221,8 @@ AcpiPsExecuteMethod (
     }
 
     /*
-     * Start method evaluation with an implicit return of zero. This is done
-     * for Windows compatibility.
+     * Start method evaluation with an implicit return of zero.
+     * This is done for Windows compatibility.
      */
     if (AcpiGbl_EnableInterpreterSlack)
     {
@@ -372,10 +245,6 @@ AcpiPsExecuteMethod (
 Cleanup:
     AcpiPsDeleteParseTree (Op);
 
-    /* End optional tracing */
-
-    AcpiPsStopTrace (Info);
-
     /* Take away the extra reference that we gave the parameters above */
 
     AcpiPsUpdateParameterList (Info, REF_DECREMENT);
@@ -434,9 +303,8 @@ AcpiPsUpdateParameterList (
         {
             /* Ignore errors, just do them all */
 
-            (void) AcpiUtUpdateObjectReference (Info->Parameters[i], Action);
+            (void) AcpiUtUpdateObjectReference (
+                Info->Parameters[i], Action);
         }
     }
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/resources/rsaddr.c b/usr/src/uts/intel/io/acpica/resources/rsaddr.c
index 90e7d43b6e..4a3823c82c 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsaddr.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsaddr.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSADDR_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -79,7 +77,7 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertAddress16[5] =
      * Address Translation Offset
      * Address Length
      */
-    {ACPI_RSC_MOVE16,   ACPI_RS_OFFSET (Data.Address16.Granularity),
+    {ACPI_RSC_MOVE16,   ACPI_RS_OFFSET (Data.Address16.Address.Granularity),
                         AML_OFFSET (Address16.Granularity),
                         5},
 
@@ -119,7 +117,7 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertAddress32[5] =
      * Address Translation Offset
      * Address Length
      */
-    {ACPI_RSC_MOVE32,   ACPI_RS_OFFSET (Data.Address32.Granularity),
+    {ACPI_RSC_MOVE32,   ACPI_RS_OFFSET (Data.Address32.Address.Granularity),
                         AML_OFFSET (Address32.Granularity),
                         5},
 
@@ -159,7 +157,7 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertAddress64[5] =
      * Address Translation Offset
      * Address Length
      */
-    {ACPI_RSC_MOVE64,   ACPI_RS_OFFSET (Data.Address64.Granularity),
+    {ACPI_RSC_MOVE64,   ACPI_RS_OFFSET (Data.Address64.Address.Granularity),
                         AML_OFFSET (Address64.Granularity),
                         5},
 
@@ -205,7 +203,7 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertExtAddress64[5] =
      * Address Length
      * Type-Specific Attribute
      */
-    {ACPI_RSC_MOVE64,   ACPI_RS_OFFSET (Data.ExtAddress64.Granularity),
+    {ACPI_RSC_MOVE64,   ACPI_RS_OFFSET (Data.ExtAddress64.Address.Granularity),
                         AML_OFFSET (ExtAddress64.Granularity),
                         6}
 };
@@ -330,30 +328,35 @@ AcpiRsGetAddressCommon (
 
     /* Validate the Resource Type */
 
-    if ((Aml->Address.ResourceType > 2) && (Aml->Address.ResourceType < 0xC0))
+    if ((Aml->Address.ResourceType > 2) &&
+        (Aml->Address.ResourceType < 0xC0))
     {
         return (FALSE);
     }
 
     /* Get the Resource Type and General Flags */
 
-    (void) AcpiRsConvertAmlToResource (Resource, Aml, AcpiRsConvertGeneralFlags);
+    (void) AcpiRsConvertAmlToResource (
+        Resource, Aml, AcpiRsConvertGeneralFlags);
 
     /* Get the Type-Specific Flags (Memory and I/O descriptors only) */
 
     if (Resource->Data.Address.ResourceType == ACPI_MEMORY_RANGE)
     {
-        (void) AcpiRsConvertAmlToResource (Resource, Aml, AcpiRsConvertMemFlags);
+        (void) AcpiRsConvertAmlToResource (
+            Resource, Aml, AcpiRsConvertMemFlags);
     }
     else if (Resource->Data.Address.ResourceType == ACPI_IO_RANGE)
     {
-        (void) AcpiRsConvertAmlToResource (Resource, Aml, AcpiRsConvertIoFlags);
+        (void) AcpiRsConvertAmlToResource (
+            Resource, Aml, AcpiRsConvertIoFlags);
     }
     else
     {
         /* Generic resource type, just grab the TypeSpecific byte */
 
-        Resource->Data.Address.Info.TypeSpecific = Aml->Address.SpecificFlags;
+        Resource->Data.Address.Info.TypeSpecific =
+            Aml->Address.SpecificFlags;
     }
 
     return (TRUE);
@@ -384,24 +387,26 @@ AcpiRsSetAddressCommon (
 
     /* Set the Resource Type and General Flags */
 
-    (void) AcpiRsConvertResourceToAml (Resource, Aml, AcpiRsConvertGeneralFlags);
+    (void) AcpiRsConvertResourceToAml (
+        Resource, Aml, AcpiRsConvertGeneralFlags);
 
     /* Set the Type-Specific Flags (Memory and I/O descriptors only) */
 
     if (Resource->Data.Address.ResourceType == ACPI_MEMORY_RANGE)
     {
-        (void) AcpiRsConvertResourceToAml (Resource, Aml, AcpiRsConvertMemFlags);
+        (void) AcpiRsConvertResourceToAml (
+            Resource, Aml, AcpiRsConvertMemFlags);
     }
     else if (Resource->Data.Address.ResourceType == ACPI_IO_RANGE)
     {
-        (void) AcpiRsConvertResourceToAml (Resource, Aml, AcpiRsConvertIoFlags);
+        (void) AcpiRsConvertResourceToAml (
+            Resource, Aml, AcpiRsConvertIoFlags);
     }
     else
     {
         /* Generic resource type, just copy the TypeSpecific byte */
 
-        Aml->Address.SpecificFlags = Resource->Data.Address.Info.TypeSpecific;
+        Aml->Address.SpecificFlags =
+            Resource->Data.Address.Info.TypeSpecific;
     }
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/resources/rscalc.c b/usr/src/uts/intel/io/acpica/resources/rscalc.c
index 845ed69c7d..92a710c1eb 100644
--- a/usr/src/uts/intel/io/acpica/resources/rscalc.c
+++ b/usr/src/uts/intel/io/acpica/resources/rscalc.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSCALC_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -166,16 +164,17 @@ AcpiRsStreamOptionLength (
 
 
     /*
-     * The ResourceSourceIndex and ResourceSource are optional elements of some
-     * Large-type resource descriptors.
+     * The ResourceSourceIndex and ResourceSource are optional elements of
+     * some Large-type resource descriptors.
      */
 
     /*
-     * If the length of the actual resource descriptor is greater than the ACPI
-     * spec-defined minimum length, it means that a ResourceSourceIndex exists
-     * and is followed by a (required) null terminated string. The string length
-     * (including the null terminator) is the resource length minus the minimum
-     * length, minus one byte for the ResourceSourceIndex itself.
+     * If the length of the actual resource descriptor is greater than the
+     * ACPI spec-defined minimum length, it means that a ResourceSourceIndex
+     * exists and is followed by a (required) null terminated string. The
+     * string length (including the null terminator) is the resource length
+     * minus the minimum length, minus one byte for the ResourceSourceIndex
+     * itself.
      */
     if (ResourceLength > MinimumAmlResourceLength)
     {
@@ -197,6 +196,7 @@ AcpiRsStreamOptionLength (
  * FUNCTION:    AcpiRsGetAmlLength
  *
  * PARAMETERS:  Resource            - Pointer to the resource linked list
+ *              ResourceListSize    - Size of the resource linked list
  *              SizeNeeded          - Where the required size is returned
  *
  * RETURN:      Status
@@ -210,9 +210,11 @@ AcpiRsStreamOptionLength (
 ACPI_STATUS
 AcpiRsGetAmlLength (
     ACPI_RESOURCE           *Resource,
+    ACPI_SIZE               ResourceListSize,
     ACPI_SIZE               *SizeNeeded)
 {
     ACPI_SIZE               AmlSizeNeeded = 0;
+    ACPI_RESOURCE           *ResourceEnd;
     ACPI_RS_LENGTH          TotalSize;
 
 
@@ -221,7 +223,8 @@ AcpiRsGetAmlLength (
 
     /* Traverse entire list of internal resource descriptors */
 
-    while (Resource)
+    ResourceEnd = ACPI_ADD_PTR (ACPI_RESOURCE, Resource, ResourceListSize);
+    while (Resource < ResourceEnd)
     {
         /* Validate the descriptor type */
 
@@ -230,6 +233,13 @@ AcpiRsGetAmlLength (
             return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
         }
 
+        /* Sanity check the length. It must not be zero, or we loop forever */
+
+        if (!Resource->Length)
+        {
+            return_ACPI_STATUS (AE_AML_BAD_RESOURCE_LENGTH);
+        }
+
         /* Get the base size of the (external stream) resource descriptor */
 
         TotalSize = AcpiGbl_AmlResourceSizes [Resource->Type];
@@ -300,9 +310,9 @@ AcpiRsGetAmlLength (
              * 16-Bit Address Resource:
              * Add the size of the optional ResourceSource info
              */
-            TotalSize = (ACPI_RS_LENGTH)
-                (TotalSize + AcpiRsStructOptionLength (
-                                &Resource->Data.Address16.ResourceSource));
+            TotalSize = (ACPI_RS_LENGTH) (TotalSize +
+                AcpiRsStructOptionLength (
+                    &Resource->Data.Address16.ResourceSource));
             break;
 
 
@@ -311,9 +321,9 @@ AcpiRsGetAmlLength (
              * 32-Bit Address Resource:
              * Add the size of the optional ResourceSource info
              */
-            TotalSize = (ACPI_RS_LENGTH)
-                (TotalSize + AcpiRsStructOptionLength (
-                                &Resource->Data.Address32.ResourceSource));
+            TotalSize = (ACPI_RS_LENGTH) (TotalSize +
+                AcpiRsStructOptionLength (
+                    &Resource->Data.Address32.ResourceSource));
             break;
 
 
@@ -322,9 +332,9 @@ AcpiRsGetAmlLength (
              * 64-Bit Address Resource:
              * Add the size of the optional ResourceSource info
              */
-            TotalSize = (ACPI_RS_LENGTH)
-                (TotalSize + AcpiRsStructOptionLength (
-                                &Resource->Data.Address64.ResourceSource));
+            TotalSize = (ACPI_RS_LENGTH) (TotalSize +
+                AcpiRsStructOptionLength (
+                    &Resource->Data.Address64.ResourceSource));
             break;
 
 
@@ -334,8 +344,7 @@ AcpiRsGetAmlLength (
              * Add the size of each additional optional interrupt beyond the
              * required 1 (4 bytes for each UINT32 interrupt number)
              */
-            TotalSize = (ACPI_RS_LENGTH)
-                (TotalSize +
+            TotalSize = (ACPI_RS_LENGTH) (TotalSize +
                 ((Resource->Data.ExtendedIrq.InterruptCount - 1) * 4) +
 
                 /* Add the size of the optional ResourceSource info */
@@ -347,7 +356,8 @@ AcpiRsGetAmlLength (
 
         case ACPI_RESOURCE_TYPE_GPIO:
 
-            TotalSize = (ACPI_RS_LENGTH) (TotalSize + (Resource->Data.Gpio.PinTableLength * 2) +
+            TotalSize = (ACPI_RS_LENGTH) (TotalSize +
+                (Resource->Data.Gpio.PinTableLength * 2) +
                 Resource->Data.Gpio.ResourceSource.StringLength +
                 Resource->Data.Gpio.VendorLength);
 
@@ -356,7 +366,8 @@ AcpiRsGetAmlLength (
 
         case ACPI_RESOURCE_TYPE_SERIAL_BUS:
 
-            TotalSize = AcpiGbl_AmlResourceSerialBusSizes [Resource->Data.CommonSerialBus.Type];
+            TotalSize = AcpiGbl_AmlResourceSerialBusSizes [
+                Resource->Data.CommonSerialBus.Type];
 
             TotalSize = (ACPI_RS_LENGTH) (TotalSize +
                 Resource->Data.I2cSerialBus.ResourceSource.StringLength +
@@ -364,8 +375,8 @@ AcpiRsGetAmlLength (
 
             break;
 
-
         default:
+
             break;
         }
 
@@ -430,7 +441,7 @@ AcpiRsGetListLength (
     {
         /* Validate the Resource Type and Resource Length */
 
-        Status = AcpiUtValidateResource (AmlBuffer, &ResourceIndex);
+        Status = AcpiUtValidateResource (NULL, AmlBuffer, &ResourceIndex);
         if (ACPI_FAILURE (Status))
         {
             /*
@@ -482,6 +493,16 @@ AcpiRsGetListLength (
              * Get the number of vendor data bytes
              */
             ExtraStructBytes = ResourceLength;
+
+            /*
+             * There is already one byte included in the minimum
+             * descriptor size. If there are extra struct bytes,
+             * subtract one from the count.
+             */
+            if (ExtraStructBytes)
+            {
+                ExtraStructBytes--;
+            }
             break;
 
 
@@ -525,12 +546,15 @@ AcpiRsGetListLength (
 
             if (AmlResource->Gpio.VendorLength)
             {
-                ExtraStructBytes += AmlResource->Gpio.VendorOffset -
-                    AmlResource->Gpio.PinTableOffset + AmlResource->Gpio.VendorLength;
+                ExtraStructBytes +=
+                    AmlResource->Gpio.VendorOffset -
+                    AmlResource->Gpio.PinTableOffset +
+                    AmlResource->Gpio.VendorLength;
             }
             else
             {
-                ExtraStructBytes += AmlResource->LargeHeader.ResourceLength +
+                ExtraStructBytes +=
+                    AmlResource->LargeHeader.ResourceLength +
                     sizeof (AML_RESOURCE_LARGE_HEADER) -
                     AmlResource->Gpio.PinTableOffset;
             }
@@ -540,11 +564,13 @@ AcpiRsGetListLength (
 
             MinimumAmlResourceLength = AcpiGbl_ResourceAmlSerialBusSizes[
                 AmlResource->CommonSerialBus.Type];
-            ExtraStructBytes += AmlResource->CommonSerialBus.ResourceLength -
+            ExtraStructBytes +=
+                AmlResource->CommonSerialBus.ResourceLength -
                 MinimumAmlResourceLength;
             break;
 
         default:
+
             break;
         }
 
@@ -554,7 +580,8 @@ AcpiRsGetListLength (
          * Important: Round the size up for the appropriate alignment. This
          * is a requirement on IA64.
          */
-        if (AcpiUtGetResourceType (AmlBuffer) == ACPI_RESOURCE_NAME_SERIAL_BUS)
+        if (AcpiUtGetResourceType (AmlBuffer) ==
+            ACPI_RESOURCE_NAME_SERIAL_BUS)
         {
             BufferSize = AcpiGbl_ResourceStructSerialBusSizes[
                 AmlResource->CommonSerialBus.Type] + ExtraStructBytes;
@@ -562,10 +589,10 @@ AcpiRsGetListLength (
         else
         {
             BufferSize = AcpiGbl_ResourceStructSizes[ResourceIndex] +
-                        ExtraStructBytes;
+                ExtraStructBytes;
         }
-        BufferSize = (UINT32) ACPI_ROUND_UP_TO_NATIVE_WORD (BufferSize);
 
+        BufferSize = (UINT32) ACPI_ROUND_UP_TO_NATIVE_WORD (BufferSize);
         *SizeNeeded += BufferSize;
 
         ACPI_DEBUG_PRINT ((ACPI_DB_RESOURCES,
@@ -626,7 +653,7 @@ AcpiRsGetPciRoutingTableLength (
     /*
      * Calculate the size of the return buffer.
      * The base size is the number of elements * the sizes of the
-     * structures.  Additional space for the strings is added below.
+     * structures. Additional space for the strings is added below.
      * The minus one is to subtract the size of the UINT8 Source[1]
      * member because it is added below.
      *
@@ -637,7 +664,7 @@ AcpiRsGetPciRoutingTableLength (
 
     for (Index = 0; Index < NumberOfElements; Index++)
     {
-        /* Dereference the sub-package */
+        /* Dereference the subpackage */
 
         PackageElement = *TopObjectList;
 
@@ -659,7 +686,9 @@ AcpiRsGetPciRoutingTableLength (
 
         NameFound = FALSE;
 
-        for (TableIndex = 0; TableIndex < 4 && !NameFound; TableIndex++)
+        for (TableIndex = 0;
+             TableIndex < PackageElement->Package.Count && !NameFound;
+             TableIndex++)
         {
             if (*SubObjectList && /* Null object allowed */
 
@@ -700,7 +729,7 @@ AcpiRsGetPciRoutingTableLength (
             else
             {
                 TempSizeNeeded += AcpiNsGetPathnameLength (
-                                    (*SubObjectList)->Reference.Node);
+                    (*SubObjectList)->Reference.Node);
             }
         }
         else
diff --git a/usr/src/uts/intel/io/acpica/resources/rscreate.c b/usr/src/uts/intel/io/acpica/resources/rscreate.c
index f06ea0cb4d..64bbdbe995 100644
--- a/usr/src/uts/intel/io/acpica/resources/rscreate.c
+++ b/usr/src/uts/intel/io/acpica/resources/rscreate.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSCREATE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -77,6 +75,10 @@ AcpiBufferToResource (
     void                    *Resource;
     void                    *CurrentResourcePtr;
 
+
+    ACPI_FUNCTION_TRACE (AcpiBufferToResource);
+
+
     /*
      * Note: we allow AE_AML_NO_RESOURCE_END_TAG, since an end tag
      * is not required here.
@@ -84,15 +86,15 @@ AcpiBufferToResource (
 
     /* Get the required length for the converted resource */
 
-    Status = AcpiRsGetListLength (AmlBuffer, AmlBufferLength,
-                &ListSizeNeeded);
+    Status = AcpiRsGetListLength (
+        AmlBuffer, AmlBufferLength, &ListSizeNeeded);
     if (Status == AE_AML_NO_RESOURCE_END_TAG)
     {
         Status = AE_OK;
     }
     if (ACPI_FAILURE (Status))
     {
-        return (Status);
+        return_ACPI_STATUS (Status);
     }
 
     /* Allocate a buffer for the converted resource */
@@ -101,13 +103,13 @@ AcpiBufferToResource (
     CurrentResourcePtr = Resource;
     if (!Resource)
     {
-        return (AE_NO_MEMORY);
+        return_ACPI_STATUS (AE_NO_MEMORY);
     }
 
     /* Perform the AML-to-Resource conversion */
 
-    Status = AcpiUtWalkAmlResources (AmlBuffer, AmlBufferLength,
-                AcpiRsConvertAmlToResources, &CurrentResourcePtr);
+    Status = AcpiUtWalkAmlResources (NULL, AmlBuffer, AmlBufferLength,
+        AcpiRsConvertAmlToResources, &CurrentResourcePtr);
     if (Status == AE_AML_NO_RESOURCE_END_TAG)
     {
         Status = AE_OK;
@@ -121,9 +123,11 @@ AcpiBufferToResource (
         *ResourcePtr = Resource;
     }
 
-    return (Status);
+    return_ACPI_STATUS (Status);
 }
 
+ACPI_EXPORT_SYMBOL (AcpiBufferToResource)
+
 
 /*******************************************************************************
  *
@@ -192,15 +196,15 @@ AcpiRsCreateResourceList (
     /* Do the conversion */
 
     Resource = OutputBuffer->Pointer;
-    Status = AcpiUtWalkAmlResources (AmlStart, AmlBufferLength,
-                AcpiRsConvertAmlToResources, &Resource);
+    Status = AcpiUtWalkAmlResources (NULL, AmlStart, AmlBufferLength,
+        AcpiRsConvertAmlToResources, &Resource);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "OutputBuffer %p Length %X\n",
-            OutputBuffer->Pointer, (UINT32) OutputBuffer->Length));
+        OutputBuffer->Pointer, (UINT32) OutputBuffer->Length));
     return_ACPI_STATUS (AE_OK);
 }
 
@@ -209,8 +213,8 @@ AcpiRsCreateResourceList (
  *
  * FUNCTION:    AcpiRsCreatePciRoutingTable
  *
- * PARAMETERS:  PackageObject           - Pointer to an ACPI_OPERAND_OBJECT
- *                                        package
+ * PARAMETERS:  PackageObject           - Pointer to a package containing one
+ *                                        of more ACPI_OPERAND_OBJECTs
  *              OutputBuffer            - Pointer to the user's buffer
  *
  * RETURN:      Status  AE_OK if okay, else a valid ACPI_STATUS code.
@@ -218,7 +222,7 @@ AcpiRsCreateResourceList (
  *              AE_BUFFER_OVERFLOW and OutputBuffer->Length will point
  *              to the size buffer needed.
  *
- * DESCRIPTION: Takes the ACPI_OPERAND_OBJECT  package and creates a
+ * DESCRIPTION: Takes the ACPI_OPERAND_OBJECT package and creates a
  *              linked list of PCI interrupt descriptions
  *
  * NOTE: It is the caller's responsibility to ensure that the start of the
@@ -251,8 +255,8 @@ AcpiRsCreatePciRoutingTable (
 
     /* Get the required buffer length */
 
-    Status = AcpiRsGetPciRoutingTableLength (PackageObject,
-                &BufferSizeNeeded);
+    Status = AcpiRsGetPciRoutingTableLength (
+        PackageObject,&BufferSizeNeeded);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -274,10 +278,10 @@ AcpiRsCreatePciRoutingTable (
      * package that in turn contains an UINT64 Address, a UINT8 Pin,
      * a Name, and a UINT8 SourceIndex.
      */
-    TopObjectList    = PackageObject->Package.Elements;
+    TopObjectList = PackageObject->Package.Elements;
     NumberOfElements = PackageObject->Package.Count;
-    Buffer           = OutputBuffer->Pointer;
-    UserPrt          = ACPI_CAST_PTR (ACPI_PCI_ROUTING_TABLE, Buffer);
+    Buffer = OutputBuffer->Pointer;
+    UserPrt = ACPI_CAST_PTR (ACPI_PCI_ROUTING_TABLE, Buffer);
 
     for (Index = 0; Index < NumberOfElements; Index++)
     {
@@ -291,23 +295,13 @@ AcpiRsCreatePciRoutingTable (
         UserPrt = ACPI_CAST_PTR (ACPI_PCI_ROUTING_TABLE, Buffer);
 
         /*
-         * Fill in the Length field with the information we have at this point.
-         * The minus four is to subtract the size of the UINT8 Source[4] member
-         * because it is added below.
+         * Fill in the Length field with the information we have at this
+         * point. The minus four is to subtract the size of the UINT8
+         * Source[4] member because it is added below.
          */
         UserPrt->Length = (sizeof (ACPI_PCI_ROUTING_TABLE) - 4);
 
-        /* Each element of the top-level package must also be a package */
-
-        if ((*TopObjectList)->Common.Type != ACPI_TYPE_PACKAGE)
-        {
-            ACPI_ERROR ((AE_INFO,
-                "(PRT[%u]) Need sub-package, found %s",
-                Index, AcpiUtGetObjectTypeName (*TopObjectList)));
-            return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
-        }
-
-        /* Each sub-package must be of length 4 */
+        /* Each subpackage must be of length 4 */
 
         if ((*TopObjectList)->Package.Count != 4)
         {
@@ -318,7 +312,7 @@ AcpiRsCreatePciRoutingTable (
         }
 
         /*
-         * Dereference the sub-package.
+         * Dereference the subpackage.
          * The SubObjectList will now point to an array of the four IRQ
          * elements: [Address, Pin, Source, SourceIndex]
          */
@@ -327,9 +321,10 @@ AcpiRsCreatePciRoutingTable (
         /* 1) First subobject: Dereference the PRT.Address */
 
         ObjDesc = SubObjectList[0];
-        if (ObjDesc->Common.Type != ACPI_TYPE_INTEGER)
+        if (!ObjDesc || ObjDesc->Common.Type != ACPI_TYPE_INTEGER)
         {
-            ACPI_ERROR ((AE_INFO, "(PRT[%u].Address) Need Integer, found %s",
+            ACPI_ERROR ((AE_INFO,
+                "(PRT[%u].Address) Need Integer, found %s",
                 Index, AcpiUtGetObjectTypeName (ObjDesc)));
             return_ACPI_STATUS (AE_BAD_DATA);
         }
@@ -339,7 +334,7 @@ AcpiRsCreatePciRoutingTable (
         /* 2) Second subobject: Dereference the PRT.Pin */
 
         ObjDesc = SubObjectList[1];
-        if (ObjDesc->Common.Type != ACPI_TYPE_INTEGER)
+        if (!ObjDesc || ObjDesc->Common.Type != ACPI_TYPE_INTEGER)
         {
             ACPI_ERROR ((AE_INFO, "(PRT[%u].Pin) Need Integer, found %s",
                 Index, AcpiUtGetObjectTypeName (ObjDesc)));
@@ -348,23 +343,6 @@ AcpiRsCreatePciRoutingTable (
 
         UserPrt->Pin = (UINT32) ObjDesc->Integer.Value;
 
-        /*
-         * If the BIOS has erroneously reversed the _PRT SourceName (index 2)
-         * and the SourceIndex (index 3), fix it. _PRT is important enough to
-         * workaround this BIOS error. This also provides compatibility with
-         * other ACPI implementations.
-         */
-        ObjDesc = SubObjectList[3];
-        if (!ObjDesc || (ObjDesc->Common.Type != ACPI_TYPE_INTEGER))
-        {
-            SubObjectList[3] = SubObjectList[2];
-            SubObjectList[2] = ObjDesc;
-
-            ACPI_WARNING ((AE_INFO,
-                "(PRT[%X].Source) SourceName and SourceIndex are reversed, fixed",
-                Index));
-        }
-
         /*
          * 3) Third subobject: Dereference the PRT.SourceName
          * The name may be unresolved (slack mode), so allow a null object
@@ -389,21 +367,21 @@ AcpiRsCreatePciRoutingTable (
                 /* Use *remaining* length of the buffer as max for pathname */
 
                 PathBuffer.Length = OutputBuffer->Length -
-                                    (UINT32) ((UINT8 *) UserPrt->Source -
-                                    (UINT8 *) OutputBuffer->Pointer);
+                    (UINT32) ((UINT8 *) UserPrt->Source -
+                    (UINT8 *) OutputBuffer->Pointer);
                 PathBuffer.Pointer = UserPrt->Source;
 
-                Status = AcpiNsHandleToPathname ((ACPI_HANDLE) Node, &PathBuffer);
+                Status = AcpiNsHandleToPathname (
+                    (ACPI_HANDLE) Node, &PathBuffer, FALSE);
 
                 /* +1 to include null terminator */
 
-                UserPrt->Length += (UINT32) ACPI_STRLEN (UserPrt->Source) + 1;
+                UserPrt->Length += (UINT32) strlen (UserPrt->Source) + 1;
                 break;
 
-
             case ACPI_TYPE_STRING:
 
-                ACPI_STRCPY (UserPrt->Source, ObjDesc->String.Pointer);
+                strcpy (UserPrt->Source, ObjDesc->String.Pointer);
 
                 /*
                  * Add to the Length field the length of the string
@@ -412,18 +390,16 @@ AcpiRsCreatePciRoutingTable (
                 UserPrt->Length += ObjDesc->String.Length + 1;
                 break;
 
-
             case ACPI_TYPE_INTEGER:
                 /*
-                 * If this is a number, then the Source Name is NULL, since the
-                 * entire buffer was zeroed out, we can leave this alone.
+                 * If this is a number, then the Source Name is NULL, since
+                 * the entire buffer was zeroed out, we can leave this alone.
                  *
                  * Add to the Length field the length of the UINT32 NULL
                  */
                 UserPrt->Length += sizeof (UINT32);
                 break;
 
-
             default:
 
                ACPI_ERROR ((AE_INFO,
@@ -440,7 +416,7 @@ AcpiRsCreatePciRoutingTable (
         /* 4) Fourth subobject: Dereference the PRT.SourceIndex */
 
         ObjDesc = SubObjectList[3];
-        if (ObjDesc->Common.Type != ACPI_TYPE_INTEGER)
+        if (!ObjDesc || ObjDesc->Common.Type != ACPI_TYPE_INTEGER)
         {
             ACPI_ERROR ((AE_INFO,
                 "(PRT[%u].SourceIndex) Need Integer, found %s",
@@ -456,7 +432,7 @@ AcpiRsCreatePciRoutingTable (
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "OutputBuffer %p Length %X\n",
-            OutputBuffer->Pointer, (UINT32) OutputBuffer->Length));
+        OutputBuffer->Pointer, (UINT32) OutputBuffer->Length));
     return_ACPI_STATUS (AE_OK);
 }
 
@@ -465,23 +441,22 @@ AcpiRsCreatePciRoutingTable (
  *
  * FUNCTION:    AcpiRsCreateAmlResources
  *
- * PARAMETERS:  LinkedListBuffer        - Pointer to the resource linked list
- *              OutputBuffer            - Pointer to the user's buffer
+ * PARAMETERS:  ResourceList            - Pointer to the resource list buffer
+ *              OutputBuffer            - Where the AML buffer is returned
  *
  * RETURN:      Status  AE_OK if okay, else a valid ACPI_STATUS code.
  *              If the OutputBuffer is too small, the error will be
  *              AE_BUFFER_OVERFLOW and OutputBuffer->Length will point
  *              to the size buffer needed.
  *
- * DESCRIPTION: Takes the linked list of device resources and
- *              creates a bytestream to be used as input for the
- *              _SRS control method.
+ * DESCRIPTION: Converts a list of device resources to an AML bytestream
+ *              to be used as input for the _SRS control method.
  *
  ******************************************************************************/
 
 ACPI_STATUS
 AcpiRsCreateAmlResources (
-    ACPI_RESOURCE           *LinkedListBuffer,
+    ACPI_BUFFER             *ResourceList,
     ACPI_BUFFER             *OutputBuffer)
 {
     ACPI_STATUS             Status;
@@ -491,17 +466,15 @@ AcpiRsCreateAmlResources (
     ACPI_FUNCTION_TRACE (RsCreateAmlResources);
 
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "LinkedListBuffer = %p\n",
-        LinkedListBuffer));
+    /* Params already validated, no need to re-validate here */
 
-    /*
-     * Params already validated, so we don't re-validate here
-     *
-     * Pass the LinkedListBuffer into a module that calculates
-     * the buffer size needed for the byte stream.
-     */
-    Status = AcpiRsGetAmlLength (LinkedListBuffer,
-                &AmlSizeNeeded);
+    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "ResourceList Buffer = %p\n",
+        ResourceList->Pointer));
+
+    /* Get the buffer size needed for the AML byte stream */
+
+    Status = AcpiRsGetAmlLength (
+        ResourceList->Pointer, ResourceList->Length, &AmlSizeNeeded);
 
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "AmlSizeNeeded=%X, %s\n",
         (UINT32) AmlSizeNeeded, AcpiFormatException (Status)));
@@ -520,15 +493,14 @@ AcpiRsCreateAmlResources (
 
     /* Do the conversion */
 
-    Status = AcpiRsConvertResourcesToAml (LinkedListBuffer, AmlSizeNeeded,
-                    OutputBuffer->Pointer);
+    Status = AcpiRsConvertResourcesToAml (ResourceList->Pointer,
+        AmlSizeNeeded, OutputBuffer->Pointer);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "OutputBuffer %p Length %X\n",
-            OutputBuffer->Pointer, (UINT32) OutputBuffer->Length));
+        OutputBuffer->Pointer, (UINT32) OutputBuffer->Length));
     return_ACPI_STATUS (AE_OK);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/resources/rsdump.c b/usr/src/uts/intel/io/acpica/resources/rsdump.c
index 68564739eb..e7948850bc 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsdump.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsdump.c
@@ -1,11 +1,11 @@
 /*******************************************************************************
  *
- * Module Name: rsdump - Functions to display the resource structures.
+ * Module Name: rsdump - AML debugger support for resource structures.
  *
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __RSDUMP_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -51,39 +48,40 @@
 #define _COMPONENT          ACPI_RESOURCES
         ACPI_MODULE_NAME    ("rsdump")
 
-
-#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+/*
+ * All functions in this module are used by the AML Debugger only
+ */
 
 /* Local prototypes */
 
 static void
 AcpiRsOutString (
-    char                    *Title,
-    char                    *Value);
+    const char              *Title,
+    const char              *Value);
 
 static void
 AcpiRsOutInteger8 (
-    char                    *Title,
+    const char              *Title,
     UINT8                   Value);
 
 static void
 AcpiRsOutInteger16 (
-    char                    *Title,
+    const char              *Title,
     UINT16                  Value);
 
 static void
 AcpiRsOutInteger32 (
-    char                    *Title,
+    const char              *Title,
     UINT32                  Value);
 
 static void
 AcpiRsOutInteger64 (
-    char                    *Title,
+    const char              *Title,
     UINT64                  Value);
 
 static void
 AcpiRsOutTitle (
-    char                    *Title);
+    const char              *Title);
 
 static void
 AcpiRsDumpByteList (
@@ -92,8 +90,8 @@ AcpiRsDumpByteList (
 
 static void
 AcpiRsDumpWordList (
-    UINT16                   Length,
-    UINT16                   *Data);
+    UINT16                  Length,
+    UINT16                  *Data);
 
 static void
 AcpiRsDumpDwordList (
@@ -102,8 +100,8 @@ AcpiRsDumpDwordList (
 
 static void
 AcpiRsDumpShortByteList (
-    UINT8                  Length,
-    UINT8                  *Data);
+    UINT8                   Length,
+    UINT8                   *Data);
 
 static void
 AcpiRsDumpResourceSource (
@@ -116,318 +114,145 @@ AcpiRsDumpAddressCommon (
 static void
 AcpiRsDumpDescriptor (
     void                    *Resource,
-    ACPI_RSDUMP_INFO *Table);
-
-
-#define ACPI_RSD_OFFSET(f)          (UINT8) ACPI_OFFSET (ACPI_RESOURCE_DATA,f)
-#define ACPI_PRT_OFFSET(f)          (UINT8) ACPI_OFFSET (ACPI_PCI_ROUTING_TABLE,f)
-#define ACPI_RSD_TABLE_SIZE(name)   (sizeof(name) / sizeof (ACPI_RSDUMP_INFO))
+    ACPI_RSDUMP_INFO        *Table);
 
 
 /*******************************************************************************
  *
- * Resource Descriptor info tables
+ * FUNCTION:    AcpiRsDumpResourceList
+ *
+ * PARAMETERS:  ResourceList        - Pointer to a resource descriptor list
+ *
+ * RETURN:      None
  *
- * Note: The first table entry must be a Title or Literal and must contain
- * the table length (number of table entries)
+ * DESCRIPTION: Dispatches the structure to the correct dump routine.
  *
  ******************************************************************************/
 
-ACPI_RSDUMP_INFO        AcpiRsDumpIrq[7] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpIrq),                "IRQ",                      NULL},
-    {ACPI_RSD_UINT8 ,   ACPI_RSD_OFFSET (Irq.DescriptorLength),             "Descriptor Length",        NULL},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Irq.Triggering),                   "Triggering",               AcpiGbl_HeDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Irq.Polarity),                     "Polarity",                 AcpiGbl_LlDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Irq.Sharable),                     "Sharing",                  AcpiGbl_ShrDecode},
-    {ACPI_RSD_UINT8 ,   ACPI_RSD_OFFSET (Irq.InterruptCount),               "Interrupt Count",          NULL},
-    {ACPI_RSD_SHORTLIST,ACPI_RSD_OFFSET (Irq.Interrupts[0]),                "Interrupt List",           NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpDma[6] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpDma),                "DMA",                      NULL},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Dma.Type),                         "Speed",                    AcpiGbl_TypDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Dma.BusMaster),                    "Mastering",                AcpiGbl_BmDecode},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Dma.Transfer),                     "Transfer Type",            AcpiGbl_SizDecode},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Dma.ChannelCount),                 "Channel Count",            NULL},
-    {ACPI_RSD_SHORTLIST,ACPI_RSD_OFFSET (Dma.Channels[0]),                  "Channel List",             NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpStartDpf[4] =
+void
+AcpiRsDumpResourceList (
+    ACPI_RESOURCE           *ResourceList)
 {
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpStartDpf),           "Start-Dependent-Functions",NULL},
-    {ACPI_RSD_UINT8 ,   ACPI_RSD_OFFSET (StartDpf.DescriptorLength),        "Descriptor Length",        NULL},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (StartDpf.CompatibilityPriority),   "Compatibility Priority",   AcpiGbl_ConfigDecode},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (StartDpf.PerformanceRobustness),   "Performance/Robustness",   AcpiGbl_ConfigDecode}
-};
+    UINT32                  Count = 0;
+    UINT32                  Type;
 
-ACPI_RSDUMP_INFO        AcpiRsDumpEndDpf[1] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpEndDpf),             "End-Dependent-Functions",  NULL}
-};
 
-ACPI_RSDUMP_INFO        AcpiRsDumpIo[6] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpIo),                 "I/O",                      NULL},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Io.IoDecode),                      "Address Decoding",         AcpiGbl_IoDecode},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Io.Minimum),                       "Address Minimum",          NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Io.Maximum),                       "Address Maximum",          NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Io.Alignment),                     "Alignment",                NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Io.AddressLength),                 "Address Length",           NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpFixedIo[3] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpFixedIo),            "Fixed I/O",                NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (FixedIo.Address),                  "Address",                  NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (FixedIo.AddressLength),            "Address Length",           NULL}
-};
+    ACPI_FUNCTION_ENTRY ();
 
-ACPI_RSDUMP_INFO        AcpiRsDumpVendor[3] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpVendor),             "Vendor Specific",          NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Vendor.ByteLength),                "Length",                   NULL},
-    {ACPI_RSD_LONGLIST, ACPI_RSD_OFFSET (Vendor.ByteData[0]),               "Vendor Data",              NULL}
-};
 
-ACPI_RSDUMP_INFO        AcpiRsDumpEndTag[1] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpEndTag),             "EndTag",                   NULL}
-};
+    /* Check if debug output enabled */
 
-ACPI_RSDUMP_INFO        AcpiRsDumpMemory24[6] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpMemory24),           "24-Bit Memory Range",      NULL},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Memory24.WriteProtect),            "Write Protect",            AcpiGbl_RwDecode},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Memory24.Minimum),                 "Address Minimum",          NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Memory24.Maximum),                 "Address Maximum",          NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Memory24.Alignment),               "Alignment",                NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Memory24.AddressLength),           "Address Length",           NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpMemory32[6] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpMemory32),           "32-Bit Memory Range",      NULL},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Memory32.WriteProtect),            "Write Protect",            AcpiGbl_RwDecode},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Memory32.Minimum),                 "Address Minimum",          NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Memory32.Maximum),                 "Address Maximum",          NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Memory32.Alignment),               "Alignment",                NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Memory32.AddressLength),           "Address Length",           NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpFixedMemory32[4] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpFixedMemory32),      "32-Bit Fixed Memory Range",NULL},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (FixedMemory32.WriteProtect),       "Write Protect",            AcpiGbl_RwDecode},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (FixedMemory32.Address),            "Address",                  NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (FixedMemory32.AddressLength),      "Address Length",           NULL}
-};
+    if (!ACPI_IS_DEBUG_ENABLED (ACPI_LV_RESOURCES, _COMPONENT))
+    {
+        return;
+    }
 
-ACPI_RSDUMP_INFO        AcpiRsDumpAddress16[8] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpAddress16),          "16-Bit WORD Address Space",NULL},
-    {ACPI_RSD_ADDRESS,  0,                                                  NULL,                       NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.Granularity),            "Granularity",              NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.Minimum),                "Address Minimum",          NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.Maximum),                "Address Maximum",          NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.TranslationOffset),      "Translation Offset",       NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.AddressLength),          "Address Length",           NULL},
-    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (Address16.ResourceSource),         NULL,                       NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpAddress32[8] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpAddress32),         "32-Bit DWORD Address Space", NULL},
-    {ACPI_RSD_ADDRESS,  0,                                                  NULL,                       NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.Granularity),            "Granularity",              NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.Minimum),                "Address Minimum",          NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.Maximum),                "Address Maximum",          NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.TranslationOffset),      "Translation Offset",       NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.AddressLength),          "Address Length",           NULL},
-    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (Address32.ResourceSource),         NULL,                       NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpAddress64[8] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpAddress64),          "64-Bit QWORD Address Space", NULL},
-    {ACPI_RSD_ADDRESS,  0,                                                  NULL,                       NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.Granularity),            "Granularity",              NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.Minimum),                "Address Minimum",          NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.Maximum),                "Address Maximum",          NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.TranslationOffset),      "Translation Offset",       NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.AddressLength),          "Address Length",           NULL},
-    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (Address64.ResourceSource),         NULL,                       NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpExtAddress64[8] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpExtAddress64),       "64-Bit Extended Address Space", NULL},
-    {ACPI_RSD_ADDRESS,  0,                                                  NULL,                       NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.Granularity),         "Granularity",              NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.Minimum),             "Address Minimum",          NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.Maximum),             "Address Maximum",          NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.TranslationOffset),   "Translation Offset",       NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.AddressLength),       "Address Length",           NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.TypeSpecific),        "Type-Specific Attribute",  NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpExtIrq[8] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpExtIrq),             "Extended IRQ",             NULL},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (ExtendedIrq.ProducerConsumer),     "Type",                     AcpiGbl_ConsumeDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (ExtendedIrq.Triggering),           "Triggering",               AcpiGbl_HeDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (ExtendedIrq.Polarity),             "Polarity",                 AcpiGbl_LlDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (ExtendedIrq.Sharable),             "Sharing",                  AcpiGbl_ShrDecode},
-    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (ExtendedIrq.ResourceSource),       NULL,                       NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (ExtendedIrq.InterruptCount),       "Interrupt Count",          NULL},
-    {ACPI_RSD_DWORDLIST,ACPI_RSD_OFFSET (ExtendedIrq.Interrupts[0]),        "Interrupt List",           NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpGenericReg[6] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpGenericReg),         "Generic Register",         NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (GenericReg.SpaceId),               "Space ID",                 NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (GenericReg.BitWidth),              "Bit Width",                NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (GenericReg.BitOffset),             "Bit Offset",               NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (GenericReg.AccessSize),            "Access Size",              NULL},
-    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (GenericReg.Address),               "Address",                  NULL}
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpGpio[16] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpGpio),               "GPIO",                     NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Gpio.RevisionId),                  "RevisionId",               NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Gpio.ConnectionType),              "ConnectionType",           AcpiGbl_CtDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Gpio.ProducerConsumer),            "ProducerConsumer",         AcpiGbl_ConsumeDecode},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Gpio.PinConfig),                   "PinConfig",                AcpiGbl_PpcDecode},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Gpio.Sharable),                    "Sharable",                 AcpiGbl_ShrDecode},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Gpio.IoRestriction),               "IoRestriction",            AcpiGbl_IorDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Gpio.Triggering),                  "Triggering",               AcpiGbl_HeDecode},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Gpio.Polarity),                    "Polarity",                 AcpiGbl_LlDecode},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Gpio.DriveStrength),               "DriveStrength",            NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Gpio.DebounceTimeout),             "DebounceTimeout",          NULL},
-    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (Gpio.ResourceSource),              "ResourceSource",           NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Gpio.PinTableLength),              "PinTableLength",           NULL},
-    {ACPI_RSD_WORDLIST, ACPI_RSD_OFFSET (Gpio.PinTable),                    "PinTable",                 NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Gpio.VendorLength),                "VendorLength",             NULL},
-    {ACPI_RSD_SHORTLISTX,ACPI_RSD_OFFSET (Gpio.VendorData),                 "VendorData",               NULL},
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpFixedDma[4] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpFixedDma),           "FixedDma",                 NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (FixedDma.RequestLines),            "RequestLines",             NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (FixedDma.Channels),                "Channels",                 NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (FixedDma.Width),                   "TransferWidth",            AcpiGbl_DtsDecode},
-};
-
-#define ACPI_RS_DUMP_COMMON_SERIAL_BUS \
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (CommonSerialBus.RevisionId),       "RevisionId",               NULL}, \
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (CommonSerialBus.Type),             "Type",                     AcpiGbl_SbtDecode}, \
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (CommonSerialBus.ProducerConsumer), "ProducerConsumer",         AcpiGbl_ConsumeDecode}, \
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (CommonSerialBus.SlaveMode),        "SlaveMode",                AcpiGbl_SmDecode}, \
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (CommonSerialBus.TypeRevisionId),   "TypeRevisionId",           NULL}, \
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (CommonSerialBus.TypeDataLength),   "TypeDataLength",           NULL}, \
-    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (CommonSerialBus.ResourceSource),   "ResourceSource",           NULL}, \
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (CommonSerialBus.VendorLength),     "VendorLength",             NULL}, \
-    {ACPI_RSD_SHORTLISTX,ACPI_RSD_OFFSET (CommonSerialBus.VendorData),      "VendorData",               NULL},
-
-ACPI_RSDUMP_INFO        AcpiRsDumpCommonSerialBus[10] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpCommonSerialBus),    "Common Serial Bus",        NULL},
-    ACPI_RS_DUMP_COMMON_SERIAL_BUS
-};
+    /* Walk list and dump all resource descriptors (END_TAG terminates) */
 
-ACPI_RSDUMP_INFO        AcpiRsDumpI2cSerialBus[13] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpI2cSerialBus),       "I2C Serial Bus",           NULL},
-    ACPI_RS_DUMP_COMMON_SERIAL_BUS
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (I2cSerialBus.AccessMode),          "AccessMode",               AcpiGbl_AmDecode},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (I2cSerialBus.ConnectionSpeed),     "ConnectionSpeed",          NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (I2cSerialBus.SlaveAddress),        "SlaveAddress",             NULL},
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpSpiSerialBus[17] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpSpiSerialBus),       "Spi Serial Bus",           NULL},
-    ACPI_RS_DUMP_COMMON_SERIAL_BUS
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (SpiSerialBus.WireMode),            "WireMode",                 AcpiGbl_WmDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (SpiSerialBus.DevicePolarity),      "DevicePolarity",           AcpiGbl_DpDecode},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (SpiSerialBus.DataBitLength),       "DataBitLength",            NULL},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (SpiSerialBus.ClockPhase),          "ClockPhase",               AcpiGbl_CphDecode},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (SpiSerialBus.ClockPolarity),       "ClockPolarity",            AcpiGbl_CpoDecode},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (SpiSerialBus.DeviceSelection),     "DeviceSelection",          NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (SpiSerialBus.ConnectionSpeed),     "ConnectionSpeed",          NULL},
-};
-
-ACPI_RSDUMP_INFO        AcpiRsDumpUartSerialBus[19] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpUartSerialBus),       "Uart Serial Bus",         NULL},
-    ACPI_RS_DUMP_COMMON_SERIAL_BUS
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (UartSerialBus.FlowControl),         "FlowControl",             AcpiGbl_FcDecode},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (UartSerialBus.StopBits),            "StopBits",                AcpiGbl_SbDecode},
-    {ACPI_RSD_3BITFLAG, ACPI_RSD_OFFSET (UartSerialBus.DataBits),            "DataBits",                AcpiGbl_BpbDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (UartSerialBus.Endian),              "Endian",                  AcpiGbl_EdDecode},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (UartSerialBus.Parity),              "Parity",                  AcpiGbl_PtDecode},
-    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (UartSerialBus.LinesEnabled),        "LinesEnabled",            NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (UartSerialBus.RxFifoSize),          "RxFifoSize",              NULL},
-    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (UartSerialBus.TxFifoSize),          "TxFifoSize",              NULL},
-    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (UartSerialBus.DefaultBaudRate),     "ConnectionSpeed",         NULL},
-};
+    do
+    {
+        AcpiOsPrintf ("\n[%02X] ", Count);
+        Count++;
 
-/*
- * Tables used for common address descriptor flag fields
- */
-static ACPI_RSDUMP_INFO AcpiRsDumpGeneralFlags[5] =
-{
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpGeneralFlags),       NULL,                       NULL},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.ProducerConsumer),         "Consumer/Producer",        AcpiGbl_ConsumeDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Decode),                   "Address Decode",           AcpiGbl_DecDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.MinAddressFixed),          "Min Relocatability",       AcpiGbl_MinDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.MaxAddressFixed),          "Max Relocatability",       AcpiGbl_MaxDecode}
-};
-
-static ACPI_RSDUMP_INFO AcpiRsDumpMemoryFlags[5] =
-{
-    {ACPI_RSD_LITERAL,  ACPI_RSD_TABLE_SIZE (AcpiRsDumpMemoryFlags),        "Resource Type",            (void *) "Memory Range"},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Info.Mem.WriteProtect),    "Write Protect",            AcpiGbl_RwDecode},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Address.Info.Mem.Caching),         "Caching",                  AcpiGbl_MemDecode},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Address.Info.Mem.RangeType),       "Range Type",               AcpiGbl_MtpDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Info.Mem.Translation),     "Translation",              AcpiGbl_TtpDecode}
-};
-
-static ACPI_RSDUMP_INFO AcpiRsDumpIoFlags[4] =
-{
-    {ACPI_RSD_LITERAL,  ACPI_RSD_TABLE_SIZE (AcpiRsDumpIoFlags),            "Resource Type",            (void *) "I/O Range"},
-    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Address.Info.Io.RangeType),        "Range Type",               AcpiGbl_RngDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Info.Io.Translation),      "Translation",              AcpiGbl_TtpDecode},
-    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Info.Io.TranslationType),  "Translation Type",         AcpiGbl_TrsDecode}
-};
+        /* Validate Type before dispatch */
+
+        Type = ResourceList->Type;
+        if (Type > ACPI_RESOURCE_TYPE_MAX)
+        {
+            AcpiOsPrintf (
+                "Invalid descriptor type (%X) in resource list\n",
+                ResourceList->Type);
+            return;
+        }
 
+        /* Sanity check the length. It must not be zero, or we loop forever */
 
-/*
- * Table used to dump _PRT contents
- */
-static ACPI_RSDUMP_INFO   AcpiRsDumpPrt[5] =
+        if (!ResourceList->Length)
+        {
+            AcpiOsPrintf (
+                "Invalid zero length descriptor in resource list\n");
+            return;
+        }
+
+        /* Dump the resource descriptor */
+
+        if (Type == ACPI_RESOURCE_TYPE_SERIAL_BUS)
+        {
+            AcpiRsDumpDescriptor (&ResourceList->Data,
+                AcpiGbl_DumpSerialBusDispatch[
+                    ResourceList->Data.CommonSerialBus.Type]);
+        }
+        else
+        {
+            AcpiRsDumpDescriptor (&ResourceList->Data,
+                AcpiGbl_DumpResourceDispatch[Type]);
+        }
+
+        /* Point to the next resource structure */
+
+        ResourceList = ACPI_NEXT_RESOURCE (ResourceList);
+
+        /* Exit when END_TAG descriptor is reached */
+
+    } while (Type != ACPI_RESOURCE_TYPE_END_TAG);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiRsDumpIrqList
+ *
+ * PARAMETERS:  RouteTable      - Pointer to the routing table to dump.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print IRQ routing table
+ *
+ ******************************************************************************/
+
+void
+AcpiRsDumpIrqList (
+    UINT8                   *RouteTable)
 {
-    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpPrt),                NULL,                       NULL},
-    {ACPI_RSD_UINT64,   ACPI_PRT_OFFSET (Address),                          "Address",                  NULL},
-    {ACPI_RSD_UINT32,   ACPI_PRT_OFFSET (Pin),                              "Pin",                      NULL},
-    {ACPI_RSD_STRING,   ACPI_PRT_OFFSET (Source[0]),                        "Source",                   NULL},
-    {ACPI_RSD_UINT32,   ACPI_PRT_OFFSET (SourceIndex),                      "Source Index",             NULL}
-};
+    ACPI_PCI_ROUTING_TABLE  *PrtElement;
+    UINT8                   Count;
+
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    /* Check if debug output enabled */
+
+    if (!ACPI_IS_DEBUG_ENABLED (ACPI_LV_RESOURCES, _COMPONENT))
+    {
+        return;
+    }
+
+    PrtElement = ACPI_CAST_PTR (ACPI_PCI_ROUTING_TABLE, RouteTable);
+
+    /* Dump all table elements, Exit on zero length element */
+
+    for (Count = 0; PrtElement->Length; Count++)
+    {
+        AcpiOsPrintf ("\n[%02X] PCI IRQ Routing Table Package\n", Count);
+        AcpiRsDumpDescriptor (PrtElement, AcpiRsDumpPrt);
+
+        PrtElement = ACPI_ADD_PTR (ACPI_PCI_ROUTING_TABLE,
+            PrtElement, PrtElement->Length);
+    }
+}
 
 
 /*******************************************************************************
  *
  * FUNCTION:    AcpiRsDumpDescriptor
  *
- * PARAMETERS:  Resource
+ * PARAMETERS:  Resource            - Buffer containing the resource
+ *              Table               - Table entry to decode the resource
  *
  * RETURN:      None
  *
- * DESCRIPTION:
+ * DESCRIPTION: Dump a resource descriptor based on a dump table entry.
  *
  ******************************************************************************/
 
@@ -438,8 +263,8 @@ AcpiRsDumpDescriptor (
 {
     UINT8                   *Target = NULL;
     UINT8                   *PreviousTarget;
-    char                    *Name;
-    UINT8                    Count;
+    const char              *Name;
+    UINT8                   Count;
 
 
     /* First table entry must contain the table length (# of table entries) */
@@ -467,20 +292,22 @@ AcpiRsDumpDescriptor (
         /* Strings */
 
         case ACPI_RSD_LITERAL:
+
             AcpiRsOutString (Name, ACPI_CAST_PTR (char, Table->Pointer));
             break;
 
         case ACPI_RSD_STRING:
+
             AcpiRsOutString (Name, ACPI_CAST_PTR (char, Target));
             break;
 
         /* Data items, 8/16/32/64 bit */
 
         case ACPI_RSD_UINT8:
+
             if (Table->Pointer)
             {
-                AcpiRsOutString (Name, ACPI_CAST_PTR (char,
-                    Table->Pointer [*Target]));
+                AcpiRsOutString (Name, Table->Pointer [*Target]);
             }
             else
             {
@@ -489,32 +316,35 @@ AcpiRsDumpDescriptor (
             break;
 
         case ACPI_RSD_UINT16:
+
             AcpiRsOutInteger16 (Name, ACPI_GET16 (Target));
             break;
 
         case ACPI_RSD_UINT32:
+
             AcpiRsOutInteger32 (Name, ACPI_GET32 (Target));
             break;
 
         case ACPI_RSD_UINT64:
+
             AcpiRsOutInteger64 (Name, ACPI_GET64 (Target));
             break;
 
         /* Flags: 1-bit and 2-bit flags supported */
 
         case ACPI_RSD_1BITFLAG:
-            AcpiRsOutString (Name, ACPI_CAST_PTR (char,
-                Table->Pointer [*Target & 0x01]));
+
+            AcpiRsOutString (Name, Table->Pointer [*Target & 0x01]);
             break;
 
         case ACPI_RSD_2BITFLAG:
-            AcpiRsOutString (Name, ACPI_CAST_PTR (char,
-                Table->Pointer [*Target & 0x03]));
+
+            AcpiRsOutString (Name, Table->Pointer [*Target & 0x03]);
             break;
 
         case ACPI_RSD_3BITFLAG:
-            AcpiRsOutString (Name, ACPI_CAST_PTR (char,
-                Table->Pointer [*Target & 0x07]));
+
+            AcpiRsOutString (Name, Table->Pointer [*Target & 0x07]);
             break;
 
         case ACPI_RSD_SHORTLIST:
@@ -581,17 +411,20 @@ AcpiRsDumpDescriptor (
             /*
              * Common flags for all Address resources
              */
-            AcpiRsDumpAddressCommon (ACPI_CAST_PTR (ACPI_RESOURCE_DATA, Target));
+            AcpiRsDumpAddressCommon (ACPI_CAST_PTR (
+                ACPI_RESOURCE_DATA, Target));
             break;
 
         case ACPI_RSD_SOURCE:
             /*
              * Optional ResourceSource for Address resources
              */
-            AcpiRsDumpResourceSource (ACPI_CAST_PTR (ACPI_RESOURCE_SOURCE, Target));
+            AcpiRsDumpResourceSource (ACPI_CAST_PTR (
+                ACPI_RESOURCE_SOURCE, Target));
             break;
 
         default:
+
             AcpiOsPrintf ("**** Invalid table opcode [%X] ****\n",
                 Table->Opcode);
             return;
@@ -689,118 +522,6 @@ AcpiRsDumpAddressCommon (
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiRsDumpResourceList
- *
- * PARAMETERS:  ResourceList        - Pointer to a resource descriptor list
- *
- * RETURN:      None
- *
- * DESCRIPTION: Dispatches the structure to the correct dump routine.
- *
- ******************************************************************************/
-
-void
-AcpiRsDumpResourceList (
-    ACPI_RESOURCE           *ResourceList)
-{
-    UINT32                  Count = 0;
-    UINT32                  Type;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    if (!(AcpiDbgLevel & ACPI_LV_RESOURCES) || !( _COMPONENT & AcpiDbgLayer))
-    {
-        return;
-    }
-
-    /* Walk list and dump all resource descriptors (END_TAG terminates) */
-
-    do
-    {
-        AcpiOsPrintf ("\n[%02X] ", Count);
-        Count++;
-
-        /* Validate Type before dispatch */
-
-        Type = ResourceList->Type;
-        if (Type > ACPI_RESOURCE_TYPE_MAX)
-        {
-            AcpiOsPrintf (
-                "Invalid descriptor type (%X) in resource list\n",
-                ResourceList->Type);
-            return;
-        }
-
-        /* Dump the resource descriptor */
-
-        if (Type == ACPI_RESOURCE_TYPE_SERIAL_BUS)
-        {
-            AcpiRsDumpDescriptor (&ResourceList->Data,
-                AcpiGbl_DumpSerialBusDispatch[ResourceList->Data.CommonSerialBus.Type]);
-        }
-        else
-        {
-            AcpiRsDumpDescriptor (&ResourceList->Data,
-                AcpiGbl_DumpResourceDispatch[Type]);
-        }
-
-        /* Point to the next resource structure */
-
-        ResourceList = ACPI_NEXT_RESOURCE (ResourceList);
-
-        /* Exit when END_TAG descriptor is reached */
-
-    } while (Type != ACPI_RESOURCE_TYPE_END_TAG);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiRsDumpIrqList
- *
- * PARAMETERS:  RouteTable      - Pointer to the routing table to dump.
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print IRQ routing table
- *
- ******************************************************************************/
-
-void
-AcpiRsDumpIrqList (
-    UINT8                   *RouteTable)
-{
-    ACPI_PCI_ROUTING_TABLE  *PrtElement;
-    UINT8                   Count;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    if (!(AcpiDbgLevel & ACPI_LV_RESOURCES) || !( _COMPONENT & AcpiDbgLayer))
-    {
-        return;
-    }
-
-    PrtElement = ACPI_CAST_PTR (ACPI_PCI_ROUTING_TABLE, RouteTable);
-
-    /* Dump all table elements, Exit on zero length element */
-
-    for (Count = 0; PrtElement->Length; Count++)
-    {
-        AcpiOsPrintf ("\n[%02X] PCI IRQ Routing Table Package\n", Count);
-        AcpiRsDumpDescriptor (PrtElement, AcpiRsDumpPrt);
-
-        PrtElement = ACPI_ADD_PTR (ACPI_PCI_ROUTING_TABLE,
-                        PrtElement, PrtElement->Length);
-    }
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiRsOut*
@@ -817,9 +538,10 @@ AcpiRsDumpIrqList (
 
 static void
 AcpiRsOutString (
-    char                    *Title,
-    char                    *Value)
+    const char              *Title,
+    const char              *Value)
 {
+
     AcpiOsPrintf ("%27s : %s", Title, Value);
     if (!*Value)
     {
@@ -830,7 +552,7 @@ AcpiRsOutString (
 
 static void
 AcpiRsOutInteger8 (
-    char                    *Title,
+    const char              *Title,
     UINT8                   Value)
 {
     AcpiOsPrintf ("%27s : %2.2X\n", Title, Value);
@@ -838,33 +560,37 @@ AcpiRsOutInteger8 (
 
 static void
 AcpiRsOutInteger16 (
-    char                    *Title,
+    const char              *Title,
     UINT16                  Value)
 {
+
     AcpiOsPrintf ("%27s : %4.4X\n", Title, Value);
 }
 
 static void
 AcpiRsOutInteger32 (
-    char                    *Title,
+    const char              *Title,
     UINT32                  Value)
 {
+
     AcpiOsPrintf ("%27s : %8.8X\n", Title, Value);
 }
 
 static void
 AcpiRsOutInteger64 (
-    char                    *Title,
+    const char              *Title,
     UINT64                  Value)
 {
+
     AcpiOsPrintf ("%27s : %8.8X%8.8X\n", Title,
         ACPI_FORMAT_UINT64 (Value));
 }
 
 static void
 AcpiRsOutTitle (
-    char                    *Title)
+    const char              *Title)
 {
+
     AcpiOsPrintf ("%27s : ", Title);
 }
 
@@ -892,15 +618,14 @@ AcpiRsDumpByteList (
 
     for (i = 0; i < Length; i++)
     {
-        AcpiOsPrintf ("%25s%2.2X : %2.2X\n",
-            "Byte", i, Data[i]);
+        AcpiOsPrintf ("%25s%2.2X : %2.2X\n", "Byte", i, Data[i]);
     }
 }
 
 static void
 AcpiRsDumpShortByteList (
-    UINT8                  Length,
-    UINT8                  *Data)
+    UINT8                   Length,
+    UINT8                   *Data)
 {
     UINT8                   i;
 
@@ -909,6 +634,7 @@ AcpiRsDumpShortByteList (
     {
         AcpiOsPrintf ("%X ", Data[i]);
     }
+
     AcpiOsPrintf ("\n");
 }
 
@@ -922,8 +648,7 @@ AcpiRsDumpDwordList (
 
     for (i = 0; i < Length; i++)
     {
-        AcpiOsPrintf ("%25s%2.2X : %8.8X\n",
-            "Dword", i, Data[i]);
+        AcpiOsPrintf ("%25s%2.2X : %8.8X\n", "Dword", i, Data[i]);
     }
 }
 
@@ -937,10 +662,6 @@ AcpiRsDumpWordList (
 
     for (i = 0; i < Length; i++)
     {
-        AcpiOsPrintf ("%25s%2.2X : %4.4X\n",
-            "Word", i, Data[i]);
+        AcpiOsPrintf ("%25s%2.2X : %4.4X\n", "Word", i, Data[i]);
     }
 }
-
-#endif
-
diff --git a/usr/src/uts/intel/io/acpica/resources/rsdumpinfo.c b/usr/src/uts/intel/io/acpica/resources/rsdumpinfo.c
new file mode 100644
index 0000000000..bc779ce58c
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/resources/rsdumpinfo.c
@@ -0,0 +1,360 @@
+/*******************************************************************************
+ *
+ * Module Name: rsdumpinfo - Tables used to display resource descriptors.
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acresrc.h"
+
+#define _COMPONENT          ACPI_RESOURCES
+        ACPI_MODULE_NAME    ("rsdumpinfo")
+
+
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DISASSEMBLER) || defined(ACPI_DEBUGGER)
+
+
+#define ACPI_RSD_OFFSET(f)          (UINT8) ACPI_OFFSET (ACPI_RESOURCE_DATA,f)
+#define ACPI_PRT_OFFSET(f)          (UINT8) ACPI_OFFSET (ACPI_PCI_ROUTING_TABLE,f)
+#define ACPI_RSD_TABLE_SIZE(name)   (sizeof(name) / sizeof (ACPI_RSDUMP_INFO))
+
+
+/*******************************************************************************
+ *
+ * Resource Descriptor info tables
+ *
+ * Note: The first table entry must be a Title or Literal and must contain
+ * the table length (number of table entries)
+ *
+ ******************************************************************************/
+
+ACPI_RSDUMP_INFO        AcpiRsDumpIrq[7] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpIrq),                "IRQ",                      NULL},
+    {ACPI_RSD_UINT8 ,   ACPI_RSD_OFFSET (Irq.DescriptorLength),             "Descriptor Length",        NULL},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Irq.Triggering),                   "Triggering",               AcpiGbl_HeDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Irq.Polarity),                     "Polarity",                 AcpiGbl_LlDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Irq.Sharable),                     "Sharing",                  AcpiGbl_ShrDecode},
+    {ACPI_RSD_UINT8 ,   ACPI_RSD_OFFSET (Irq.InterruptCount),               "Interrupt Count",          NULL},
+    {ACPI_RSD_SHORTLIST,ACPI_RSD_OFFSET (Irq.Interrupts[0]),                "Interrupt List",           NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpDma[6] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpDma),                "DMA",                      NULL},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Dma.Type),                         "Speed",                    AcpiGbl_TypDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Dma.BusMaster),                    "Mastering",                AcpiGbl_BmDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Dma.Transfer),                     "Transfer Type",            AcpiGbl_SizDecode},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Dma.ChannelCount),                 "Channel Count",            NULL},
+    {ACPI_RSD_SHORTLIST,ACPI_RSD_OFFSET (Dma.Channels[0]),                  "Channel List",             NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpStartDpf[4] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpStartDpf),           "Start-Dependent-Functions",NULL},
+    {ACPI_RSD_UINT8 ,   ACPI_RSD_OFFSET (StartDpf.DescriptorLength),        "Descriptor Length",        NULL},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (StartDpf.CompatibilityPriority),   "Compatibility Priority",   AcpiGbl_ConfigDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (StartDpf.PerformanceRobustness),   "Performance/Robustness",   AcpiGbl_ConfigDecode}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpEndDpf[1] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpEndDpf),             "End-Dependent-Functions",  NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpIo[6] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpIo),                 "I/O",                      NULL},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Io.IoDecode),                      "Address Decoding",         AcpiGbl_IoDecode},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Io.Minimum),                       "Address Minimum",          NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Io.Maximum),                       "Address Maximum",          NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Io.Alignment),                     "Alignment",                NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Io.AddressLength),                 "Address Length",           NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpFixedIo[3] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpFixedIo),            "Fixed I/O",                NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (FixedIo.Address),                  "Address",                  NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (FixedIo.AddressLength),            "Address Length",           NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpVendor[3] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpVendor),             "Vendor Specific",          NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Vendor.ByteLength),                "Length",                   NULL},
+    {ACPI_RSD_LONGLIST, ACPI_RSD_OFFSET (Vendor.ByteData[0]),               "Vendor Data",              NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpEndTag[1] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpEndTag),             "EndTag",                   NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpMemory24[6] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpMemory24),           "24-Bit Memory Range",      NULL},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Memory24.WriteProtect),            "Write Protect",            AcpiGbl_RwDecode},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Memory24.Minimum),                 "Address Minimum",          NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Memory24.Maximum),                 "Address Maximum",          NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Memory24.Alignment),               "Alignment",                NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Memory24.AddressLength),           "Address Length",           NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpMemory32[6] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpMemory32),           "32-Bit Memory Range",      NULL},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Memory32.WriteProtect),            "Write Protect",            AcpiGbl_RwDecode},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Memory32.Minimum),                 "Address Minimum",          NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Memory32.Maximum),                 "Address Maximum",          NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Memory32.Alignment),               "Alignment",                NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Memory32.AddressLength),           "Address Length",           NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpFixedMemory32[4] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpFixedMemory32),      "32-Bit Fixed Memory Range",NULL},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (FixedMemory32.WriteProtect),       "Write Protect",            AcpiGbl_RwDecode},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (FixedMemory32.Address),            "Address",                  NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (FixedMemory32.AddressLength),      "Address Length",           NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpAddress16[8] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpAddress16),          "16-Bit WORD Address Space",NULL},
+    {ACPI_RSD_ADDRESS,  0,                                                  NULL,                       NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.Address.Granularity),    "Granularity",              NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.Address.Minimum),        "Address Minimum",          NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.Address.Maximum),        "Address Maximum",          NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.Address.TranslationOffset),
+                                                                            "Translation Offset",       NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Address16.Address.AddressLength),  "Address Length",           NULL},
+    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (Address16.ResourceSource),         NULL,                       NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpAddress32[8] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpAddress32),         "32-Bit DWORD Address Space", NULL},
+    {ACPI_RSD_ADDRESS,  0,                                                  NULL,                       NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.Address.Granularity),    "Granularity",              NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.Address.Minimum),        "Address Minimum",          NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.Address.Maximum),        "Address Maximum",          NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.Address.TranslationOffset),
+                                                                            "Translation Offset",       NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (Address32.Address.AddressLength),  "Address Length",           NULL},
+    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (Address32.ResourceSource),         NULL,                       NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpAddress64[8] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpAddress64),          "64-Bit QWORD Address Space", NULL},
+    {ACPI_RSD_ADDRESS,  0,                                                  NULL,                       NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.Address.Granularity),    "Granularity",              NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.Address.Minimum),        "Address Minimum",          NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.Address.Maximum),        "Address Maximum",          NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.Address.TranslationOffset),
+                                                                            "Translation Offset",       NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (Address64.Address.AddressLength),  "Address Length",           NULL},
+    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (Address64.ResourceSource),         NULL,                       NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpExtAddress64[8] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpExtAddress64),       "64-Bit Extended Address Space", NULL},
+    {ACPI_RSD_ADDRESS,  0,                                                  NULL,                       NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.Address.Granularity), "Granularity",              NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.Address.Minimum),     "Address Minimum",          NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.Address.Maximum),     "Address Maximum",          NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.Address.TranslationOffset),
+                                                                            "Translation Offset",       NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.Address.AddressLength),
+                                                                            "Address Length",           NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (ExtAddress64.TypeSpecific),        "Type-Specific Attribute",  NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpExtIrq[8] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpExtIrq),             "Extended IRQ",             NULL},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (ExtendedIrq.ProducerConsumer),     "Type",                     AcpiGbl_ConsumeDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (ExtendedIrq.Triggering),           "Triggering",               AcpiGbl_HeDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (ExtendedIrq.Polarity),             "Polarity",                 AcpiGbl_LlDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (ExtendedIrq.Sharable),             "Sharing",                  AcpiGbl_ShrDecode},
+    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (ExtendedIrq.ResourceSource),       NULL,                       NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (ExtendedIrq.InterruptCount),       "Interrupt Count",          NULL},
+    {ACPI_RSD_DWORDLIST,ACPI_RSD_OFFSET (ExtendedIrq.Interrupts[0]),        "Interrupt List",           NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpGenericReg[6] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpGenericReg),         "Generic Register",         NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (GenericReg.SpaceId),               "Space ID",                 NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (GenericReg.BitWidth),              "Bit Width",                NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (GenericReg.BitOffset),             "Bit Offset",               NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (GenericReg.AccessSize),            "Access Size",              NULL},
+    {ACPI_RSD_UINT64,   ACPI_RSD_OFFSET (GenericReg.Address),               "Address",                  NULL}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpGpio[16] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpGpio),               "GPIO",                     NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Gpio.RevisionId),                  "RevisionId",               NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Gpio.ConnectionType),              "ConnectionType",           AcpiGbl_CtDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Gpio.ProducerConsumer),            "ProducerConsumer",         AcpiGbl_ConsumeDecode},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (Gpio.PinConfig),                   "PinConfig",                AcpiGbl_PpcDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Gpio.Sharable),                    "Sharing",                  AcpiGbl_ShrDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Gpio.IoRestriction),               "IoRestriction",            AcpiGbl_IorDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Gpio.Triggering),                  "Triggering",               AcpiGbl_HeDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Gpio.Polarity),                    "Polarity",                 AcpiGbl_LlDecode},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Gpio.DriveStrength),               "DriveStrength",            NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Gpio.DebounceTimeout),             "DebounceTimeout",          NULL},
+    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (Gpio.ResourceSource),              "ResourceSource",           NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Gpio.PinTableLength),              "PinTableLength",           NULL},
+    {ACPI_RSD_WORDLIST, ACPI_RSD_OFFSET (Gpio.PinTable),                    "PinTable",                 NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (Gpio.VendorLength),                "VendorLength",             NULL},
+    {ACPI_RSD_SHORTLISTX,ACPI_RSD_OFFSET (Gpio.VendorData),                 "VendorData",               NULL},
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpFixedDma[4] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpFixedDma),           "FixedDma",                 NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (FixedDma.RequestLines),            "RequestLines",             NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (FixedDma.Channels),                "Channels",                 NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (FixedDma.Width),                   "TransferWidth",            AcpiGbl_DtsDecode},
+};
+
+#define ACPI_RS_DUMP_COMMON_SERIAL_BUS \
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (CommonSerialBus.RevisionId),       "RevisionId",               NULL}, \
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (CommonSerialBus.Type),             "Type",                     AcpiGbl_SbtDecode}, \
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (CommonSerialBus.ProducerConsumer), "ProducerConsumer",         AcpiGbl_ConsumeDecode}, \
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (CommonSerialBus.SlaveMode),        "SlaveMode",                AcpiGbl_SmDecode}, \
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (CommonSerialBus.ConnectionSharing),"ConnectionSharing",        AcpiGbl_ShrDecode}, \
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (CommonSerialBus.TypeRevisionId),   "TypeRevisionId",           NULL}, \
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (CommonSerialBus.TypeDataLength),   "TypeDataLength",           NULL}, \
+    {ACPI_RSD_SOURCE,   ACPI_RSD_OFFSET (CommonSerialBus.ResourceSource),   "ResourceSource",           NULL}, \
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (CommonSerialBus.VendorLength),     "VendorLength",             NULL}, \
+    {ACPI_RSD_SHORTLISTX,ACPI_RSD_OFFSET (CommonSerialBus.VendorData),      "VendorData",               NULL},
+
+ACPI_RSDUMP_INFO        AcpiRsDumpCommonSerialBus[11] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpCommonSerialBus),    "Common Serial Bus",        NULL},
+    ACPI_RS_DUMP_COMMON_SERIAL_BUS
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpI2cSerialBus[14] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpI2cSerialBus),       "I2C Serial Bus",           NULL},
+    ACPI_RS_DUMP_COMMON_SERIAL_BUS
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (I2cSerialBus.AccessMode),          "AccessMode",               AcpiGbl_AmDecode},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (I2cSerialBus.ConnectionSpeed),     "ConnectionSpeed",          NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (I2cSerialBus.SlaveAddress),        "SlaveAddress",             NULL},
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpSpiSerialBus[18] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpSpiSerialBus),       "Spi Serial Bus",           NULL},
+    ACPI_RS_DUMP_COMMON_SERIAL_BUS
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (SpiSerialBus.WireMode),            "WireMode",                 AcpiGbl_WmDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (SpiSerialBus.DevicePolarity),      "DevicePolarity",           AcpiGbl_DpDecode},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (SpiSerialBus.DataBitLength),       "DataBitLength",            NULL},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (SpiSerialBus.ClockPhase),          "ClockPhase",               AcpiGbl_CphDecode},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (SpiSerialBus.ClockPolarity),       "ClockPolarity",            AcpiGbl_CpoDecode},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (SpiSerialBus.DeviceSelection),     "DeviceSelection",          NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (SpiSerialBus.ConnectionSpeed),     "ConnectionSpeed",          NULL},
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpUartSerialBus[20] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpUartSerialBus),       "Uart Serial Bus",         NULL},
+    ACPI_RS_DUMP_COMMON_SERIAL_BUS
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (UartSerialBus.FlowControl),         "FlowControl",             AcpiGbl_FcDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (UartSerialBus.StopBits),            "StopBits",                AcpiGbl_SbDecode},
+    {ACPI_RSD_3BITFLAG, ACPI_RSD_OFFSET (UartSerialBus.DataBits),            "DataBits",                AcpiGbl_BpbDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (UartSerialBus.Endian),              "Endian",                  AcpiGbl_EdDecode},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (UartSerialBus.Parity),              "Parity",                  AcpiGbl_PtDecode},
+    {ACPI_RSD_UINT8,    ACPI_RSD_OFFSET (UartSerialBus.LinesEnabled),        "LinesEnabled",            NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (UartSerialBus.RxFifoSize),          "RxFifoSize",              NULL},
+    {ACPI_RSD_UINT16,   ACPI_RSD_OFFSET (UartSerialBus.TxFifoSize),          "TxFifoSize",              NULL},
+    {ACPI_RSD_UINT32,   ACPI_RSD_OFFSET (UartSerialBus.DefaultBaudRate),     "ConnectionSpeed",         NULL},
+};
+
+/*
+ * Tables used for common address descriptor flag fields
+ */
+ACPI_RSDUMP_INFO        AcpiRsDumpGeneralFlags[5] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpGeneralFlags),       NULL,                       NULL},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.ProducerConsumer),         "Consumer/Producer",        AcpiGbl_ConsumeDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Decode),                   "Address Decode",           AcpiGbl_DecDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.MinAddressFixed),          "Min Relocatability",       AcpiGbl_MinDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.MaxAddressFixed),          "Max Relocatability",       AcpiGbl_MaxDecode}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpMemoryFlags[5] =
+{
+    {ACPI_RSD_LITERAL,  ACPI_RSD_TABLE_SIZE (AcpiRsDumpMemoryFlags),        "Resource Type",            (void *) "Memory Range"},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Info.Mem.WriteProtect),    "Write Protect",            AcpiGbl_RwDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Address.Info.Mem.Caching),         "Caching",                  AcpiGbl_MemDecode},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Address.Info.Mem.RangeType),       "Range Type",               AcpiGbl_MtpDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Info.Mem.Translation),     "Translation",              AcpiGbl_TtpDecode}
+};
+
+ACPI_RSDUMP_INFO        AcpiRsDumpIoFlags[4] =
+{
+    {ACPI_RSD_LITERAL,  ACPI_RSD_TABLE_SIZE (AcpiRsDumpIoFlags),            "Resource Type",            (void *) "I/O Range"},
+    {ACPI_RSD_2BITFLAG, ACPI_RSD_OFFSET (Address.Info.Io.RangeType),        "Range Type",               AcpiGbl_RngDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Info.Io.Translation),      "Translation",              AcpiGbl_TtpDecode},
+    {ACPI_RSD_1BITFLAG, ACPI_RSD_OFFSET (Address.Info.Io.TranslationType),  "Translation Type",         AcpiGbl_TrsDecode}
+};
+
+
+/*
+ * Table used to dump _PRT contents
+ */
+ACPI_RSDUMP_INFO        AcpiRsDumpPrt[5] =
+{
+    {ACPI_RSD_TITLE,    ACPI_RSD_TABLE_SIZE (AcpiRsDumpPrt),                NULL,                       NULL},
+    {ACPI_RSD_UINT64,   ACPI_PRT_OFFSET (Address),                          "Address",                  NULL},
+    {ACPI_RSD_UINT32,   ACPI_PRT_OFFSET (Pin),                              "Pin",                      NULL},
+    {ACPI_RSD_STRING,   ACPI_PRT_OFFSET (Source[0]),                        "Source",                   NULL},
+    {ACPI_RSD_UINT32,   ACPI_PRT_OFFSET (SourceIndex),                      "Source Index",             NULL}
+};
+
+#endif
diff --git a/usr/src/uts/intel/io/acpica/resources/rsinfo.c b/usr/src/uts/intel/io/acpica/resources/rsinfo.c
index e7287d5455..15f6105c80 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsinfo.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsinfo.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSINFO_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -141,7 +139,7 @@ ACPI_RSCONVERT_INFO         *AcpiGbl_ConvertResourceSerialBusDispatch[] =
 };
 
 
-#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
+#if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DISASSEMBLER) || defined(ACPI_DEBUGGER)
 
 /* Dispatch table for resource dump functions */
 
diff --git a/usr/src/uts/intel/io/acpica/resources/rsio.c b/usr/src/uts/intel/io/acpica/resources/rsio.c
index 065108cfa1..442a7b8b3a 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsio.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsio.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSIO_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -300,5 +298,3 @@ ACPI_RSCONVERT_INFO   AcpiRsSetStartDpf[10] =
 
     {ACPI_RSC_LENGTH,   0, 0, sizeof (AML_RESOURCE_START_DEPENDENT_NOPRIO)}
 };
-
-
diff --git a/usr/src/uts/intel/io/acpica/resources/rsirq.c b/usr/src/uts/intel/io/acpica/resources/rsirq.c
index c2a88ee89a..d094a9bfd9 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsirq.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsirq.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSIRQ_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -57,7 +55,7 @@
  *
  ******************************************************************************/
 
-ACPI_RSCONVERT_INFO     AcpiRsGetIrq[8] =
+ACPI_RSCONVERT_INFO     AcpiRsGetIrq[9] =
 {
     {ACPI_RSC_INITGET,  ACPI_RESOURCE_TYPE_IRQ,
                         ACPI_RS_SIZE (ACPI_RESOURCE_IRQ),
@@ -85,7 +83,7 @@ ACPI_RSCONVERT_INFO     AcpiRsGetIrq[8] =
 
     {ACPI_RSC_EXIT_NE,  ACPI_RSC_COMPARE_AML_LENGTH, 0, 3},
 
-    /* Get flags: Triggering[0], Polarity[3], Sharing[4] */
+    /* Get flags: Triggering[0], Polarity[3], Sharing[4], Wake[5] */
 
     {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.Irq.Triggering),
                         AML_OFFSET (Irq.Flags),
@@ -97,7 +95,11 @@ ACPI_RSCONVERT_INFO     AcpiRsGetIrq[8] =
 
     {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.Irq.Sharable),
                         AML_OFFSET (Irq.Flags),
-                        4}
+                        4},
+
+    {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.Irq.WakeCapable),
+                        AML_OFFSET (Irq.Flags),
+                        5}
 };
 
 
@@ -107,7 +109,7 @@ ACPI_RSCONVERT_INFO     AcpiRsGetIrq[8] =
  *
  ******************************************************************************/
 
-ACPI_RSCONVERT_INFO     AcpiRsSetIrq[13] =
+ACPI_RSCONVERT_INFO     AcpiRsSetIrq[14] =
 {
     /* Start with a default descriptor of length 3 */
 
@@ -121,7 +123,7 @@ ACPI_RSCONVERT_INFO     AcpiRsSetIrq[13] =
                         AML_OFFSET (Irq.IrqMask),
                         ACPI_RS_OFFSET (Data.Irq.InterruptCount)},
 
-    /* Set the flags byte */
+    /* Set flags: Triggering[0], Polarity[3], Sharing[4], Wake[5] */
 
     {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.Irq.Triggering),
                         AML_OFFSET (Irq.Flags),
@@ -135,6 +137,10 @@ ACPI_RSCONVERT_INFO     AcpiRsSetIrq[13] =
                         AML_OFFSET (Irq.Flags),
                         4},
 
+    {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.Irq.WakeCapable),
+                        AML_OFFSET (Irq.Flags),
+                        5},
+
     /*
      * All done if the output descriptor length is required to be 3
      * (i.e., optimization to 2 bytes cannot be attempted)
@@ -189,7 +195,7 @@ ACPI_RSCONVERT_INFO     AcpiRsSetIrq[13] =
  *
  ******************************************************************************/
 
-ACPI_RSCONVERT_INFO     AcpiRsConvertExtIrq[9] =
+ACPI_RSCONVERT_INFO     AcpiRsConvertExtIrq[10] =
 {
     {ACPI_RSC_INITGET,  ACPI_RESOURCE_TYPE_EXTENDED_IRQ,
                         ACPI_RS_SIZE (ACPI_RESOURCE_EXTENDED_IRQ),
@@ -199,8 +205,10 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertExtIrq[9] =
                         sizeof (AML_RESOURCE_EXTENDED_IRQ),
                         0},
 
-    /* Flag bits */
-
+    /*
+     * Flags: Producer/Consumer[0], Triggering[1], Polarity[2],
+     *        Sharing[3], Wake[4]
+     */
     {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.ExtendedIrq.ProducerConsumer),
                         AML_OFFSET (ExtendedIrq.Flags),
                         0},
@@ -217,6 +225,10 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertExtIrq[9] =
                         AML_OFFSET (ExtendedIrq.Flags),
                         3},
 
+    {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.ExtendedIrq.WakeCapable),
+                        AML_OFFSET (ExtendedIrq.Flags),
+                        4},
+
     /* IRQ Table length (Byte4) */
 
     {ACPI_RSC_COUNT,    ACPI_RS_OFFSET (Data.ExtendedIrq.InterruptCount),
@@ -296,7 +308,6 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertFixedDma[4] =
      * RequestLines
      * Channels
      */
-
     {ACPI_RSC_MOVE16,   ACPI_RS_OFFSET (Data.FixedDma.RequestLines),
                         AML_OFFSET (FixedDma.RequestLines),
                         2},
@@ -304,5 +315,4 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertFixedDma[4] =
     {ACPI_RSC_MOVE8,    ACPI_RS_OFFSET (Data.FixedDma.Width),
                         AML_OFFSET (FixedDma.Width),
                         1},
-
 };
diff --git a/usr/src/uts/intel/io/acpica/resources/rslist.c b/usr/src/uts/intel/io/acpica/resources/rslist.c
index 187d56cd42..0f7a496031 100644
--- a/usr/src/uts/intel/io/acpica/resources/rslist.c
+++ b/usr/src/uts/intel/io/acpica/resources/rslist.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSLIST_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -72,7 +70,7 @@ AcpiRsConvertAmlToResources (
     UINT32                  Length,
     UINT32                  Offset,
     UINT8                   ResourceIndex,
-    void                    *Context)
+    void                    **Context)
 {
     ACPI_RESOURCE           **ResourcePtr = ACPI_CAST_INDIRECT_PTR (
                                 ACPI_RESOURCE, Context);
@@ -99,9 +97,12 @@ AcpiRsConvertAmlToResources (
     /* Get the appropriate conversion info table */
 
     AmlResource = ACPI_CAST_PTR (AML_RESOURCE, Aml);
-    if (AcpiUtGetResourceType (Aml) == ACPI_RESOURCE_NAME_SERIAL_BUS)
+
+    if (AcpiUtGetResourceType (Aml) ==
+        ACPI_RESOURCE_NAME_SERIAL_BUS)
     {
-        if (AmlResource->CommonSerialBus.Type > AML_RESOURCE_MAX_SERIALBUSTYPE)
+        if (AmlResource->CommonSerialBus.Type >
+            AML_RESOURCE_MAX_SERIALBUSTYPE)
         {
             ConversionTable = NULL;
         }
@@ -109,15 +110,13 @@ AcpiRsConvertAmlToResources (
         {
             /* This is an I2C, SPI, or UART SerialBus descriptor */
 
-            ConversionTable =
-                AcpiGbl_ConvertResourceSerialBusDispatch[
-                    AmlResource->CommonSerialBus.Type];
+            ConversionTable = AcpiGbl_ConvertResourceSerialBusDispatch [
+                AmlResource->CommonSerialBus.Type];
         }
     }
     else
     {
-        ConversionTable =
-            AcpiGbl_GetResourceDispatch[ResourceIndex];
+        ConversionTable = AcpiGbl_GetResourceDispatch[ResourceIndex];
     }
 
     if (!ConversionTable)
@@ -125,7 +124,7 @@ AcpiRsConvertAmlToResources (
         ACPI_ERROR ((AE_INFO,
             "Invalid/unsupported resource descriptor: Type 0x%2.2X",
             ResourceIndex));
-        return (AE_AML_INVALID_RESOURCE_TYPE);
+        return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
     }
 
      /* Convert the AML byte stream resource to a local resource struct */
@@ -199,11 +198,21 @@ AcpiRsConvertResourcesToAml (
             return_ACPI_STATUS (AE_BAD_DATA);
         }
 
+        /* Sanity check the length. It must not be zero, or we loop forever */
+
+        if (!Resource->Length)
+        {
+            ACPI_ERROR ((AE_INFO,
+                "Invalid zero length descriptor in resource list\n"));
+            return_ACPI_STATUS (AE_AML_BAD_RESOURCE_LENGTH);
+        }
+
         /* Perform the conversion */
 
         if (Resource->Type == ACPI_RESOURCE_TYPE_SERIAL_BUS)
         {
-            if (Resource->Data.CommonSerialBus.Type > AML_RESOURCE_MAX_SERIALBUSTYPE)
+            if (Resource->Data.CommonSerialBus.Type >
+                AML_RESOURCE_MAX_SERIALBUSTYPE)
             {
                 ConversionTable = NULL;
             }
@@ -225,12 +234,11 @@ AcpiRsConvertResourcesToAml (
             ACPI_ERROR ((AE_INFO,
                 "Invalid/unsupported resource descriptor: Type 0x%2.2X",
                 Resource->Type));
-            return (AE_AML_INVALID_RESOURCE_TYPE);
+            return_ACPI_STATUS (AE_AML_INVALID_RESOURCE_TYPE);
         }
 
         Status = AcpiRsConvertResourceToAml (Resource,
-                ACPI_CAST_PTR (AML_RESOURCE, Aml),
-                ConversionTable);
+            ACPI_CAST_PTR (AML_RESOURCE, Aml), ConversionTable);
         if (ACPI_FAILURE (Status))
         {
             ACPI_EXCEPTION ((AE_INFO, Status,
@@ -242,7 +250,7 @@ AcpiRsConvertResourcesToAml (
         /* Perform final sanity check on the new AML resource descriptor */
 
         Status = AcpiUtValidateResource (
-                    ACPI_CAST_PTR (AML_RESOURCE, Aml), NULL);
+            NULL, ACPI_CAST_PTR (AML_RESOURCE, Aml), NULL);
         if (ACPI_FAILURE (Status))
         {
             return_ACPI_STATUS (Status);
@@ -272,4 +280,3 @@ AcpiRsConvertResourcesToAml (
 
     return_ACPI_STATUS (AE_AML_NO_RESOURCE_END_TAG);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/resources/rsmemory.c b/usr/src/uts/intel/io/acpica/resources/rsmemory.c
index 83d131956f..90e58fc20e 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsmemory.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsmemory.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSMEMORY_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -247,5 +245,3 @@ ACPI_RSCONVERT_INFO     AcpiRsSetVendor[7] =
                         sizeof (AML_RESOURCE_LARGE_HEADER),
                         0}
 };
-
-
diff --git a/usr/src/uts/intel/io/acpica/resources/rsmisc.c b/usr/src/uts/intel/io/acpica/resources/rsmisc.c
index dfad696ca1..73019a9b6d 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsmisc.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsmisc.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSMISC_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -123,7 +121,7 @@ AcpiRsConvertAmlToResource (
          * Source is the external AML byte stream buffer,
          * destination is the internal resource descriptor
          */
-        Source      = ACPI_ADD_PTR (void, Aml, Info->AmlOffset);
+        Source = ACPI_ADD_PTR (void, Aml, Info->AmlOffset);
         Destination = ACPI_ADD_PTR (void, Resource, Info->ResourceOffset);
 
         switch (Info->Opcode)
@@ -132,69 +130,61 @@ AcpiRsConvertAmlToResource (
             /*
              * Get the resource type and the initial (minimum) length
              */
-            ACPI_MEMSET (Resource, 0, INIT_RESOURCE_LENGTH (Info));
+            memset (Resource, 0, INIT_RESOURCE_LENGTH (Info));
             Resource->Type = INIT_RESOURCE_TYPE (Info);
             Resource->Length = INIT_RESOURCE_LENGTH (Info);
             break;
 
-
         case ACPI_RSC_INITSET:
             break;
 
-
         case ACPI_RSC_FLAGINIT:
 
             FlagsMode = TRUE;
             break;
 
-
         case ACPI_RSC_1BITFLAG:
             /*
              * Mask and shift the flag bit
              */
-            ACPI_SET8 (Destination) = (UINT8)
-                ((ACPI_GET8 (Source) >> Info->Value) & 0x01);
+            ACPI_SET8 (Destination,
+                ((ACPI_GET8 (Source) >> Info->Value) & 0x01));
             break;
 
-
         case ACPI_RSC_2BITFLAG:
             /*
              * Mask and shift the flag bits
              */
-            ACPI_SET8 (Destination) = (UINT8)
-                ((ACPI_GET8 (Source) >> Info->Value) & 0x03);
+            ACPI_SET8 (Destination,
+                ((ACPI_GET8 (Source) >> Info->Value) & 0x03));
             break;
 
-
         case ACPI_RSC_3BITFLAG:
             /*
              * Mask and shift the flag bits
              */
-            ACPI_SET8 (Destination) = (UINT8)
-                ((ACPI_GET8 (Source) >> Info->Value) & 0x07);
+            ACPI_SET8 (Destination,
+                ((ACPI_GET8 (Source) >> Info->Value) & 0x07));
             break;
 
-
         case ACPI_RSC_COUNT:
 
             ItemCount = ACPI_GET8 (Source);
-            ACPI_SET8 (Destination) = (UINT8) ItemCount;
+            ACPI_SET8 (Destination, ItemCount);
 
             Resource->Length = Resource->Length +
                 (Info->Value * (ItemCount - 1));
             break;
 
-
         case ACPI_RSC_COUNT16:
 
             ItemCount = AmlResourceLength;
-            ACPI_SET16 (Destination) = ItemCount;
+            ACPI_SET16 (Destination, ItemCount);
 
             Resource->Length = Resource->Length +
                 (Info->Value * (ItemCount - 1));
             break;
 
-
         case ACPI_RSC_COUNT_GPIO_PIN:
 
             Target = ACPI_ADD_PTR (void, Aml, Info->Value);
@@ -202,22 +192,18 @@ AcpiRsConvertAmlToResource (
 
             Resource->Length = Resource->Length + ItemCount;
             ItemCount = ItemCount / 2;
-            ACPI_SET16 (Destination) = ItemCount;
+            ACPI_SET16 (Destination, ItemCount);
             break;
 
-
         case ACPI_RSC_COUNT_GPIO_VEN:
 
             ItemCount = ACPI_GET8 (Source);
-            ACPI_SET8 (Destination) = (UINT8) ItemCount;
+            ACPI_SET8 (Destination, ItemCount);
 
-            Resource->Length = Resource->Length +
-                (Info->Value * ItemCount);
+            Resource->Length = Resource->Length + (Info->Value * ItemCount);
             break;
 
-
         case ACPI_RSC_COUNT_GPIO_RES:
-
             /*
              * Vendor data is optional (length/offset may both be zero)
              * Examine vendor data length field first
@@ -240,19 +226,17 @@ AcpiRsConvertAmlToResource (
             }
 
             Resource->Length = Resource->Length + ItemCount;
-            ACPI_SET16 (Destination) = ItemCount;
+            ACPI_SET16 (Destination, ItemCount);
             break;
 
-
         case ACPI_RSC_COUNT_SERIAL_VEN:
 
             ItemCount = ACPI_GET16 (Source) - Info->Value;
 
             Resource->Length = Resource->Length + ItemCount;
-            ACPI_SET16 (Destination) = ItemCount;
+            ACPI_SET16 (Destination, ItemCount);
             break;
 
-
         case ACPI_RSC_COUNT_SERIAL_RES:
 
             ItemCount = (AmlResourceLength +
@@ -260,16 +244,14 @@ AcpiRsConvertAmlToResource (
                 ACPI_GET16 (Source) - Info->Value;
 
             Resource->Length = Resource->Length + ItemCount;
-            ACPI_SET16 (Destination) = ItemCount;
+            ACPI_SET16 (Destination, ItemCount);
             break;
 
-
         case ACPI_RSC_LENGTH:
 
             Resource->Length = Resource->Length + Info->Value;
             break;
 
-
         case ACPI_RSC_MOVE8:
         case ACPI_RSC_MOVE16:
         case ACPI_RSC_MOVE32:
@@ -285,13 +267,12 @@ AcpiRsConvertAmlToResource (
             AcpiRsMoveData (Destination, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_MOVE_GPIO_PIN:
 
             /* Generate and set the PIN data pointer */
 
             Target = (char *) ACPI_ADD_PTR (void, Resource,
-                  (Resource->Length - ItemCount * 2));
+                (Resource->Length - ItemCount * 2));
             *(UINT16 **) Destination = ACPI_CAST_PTR (UINT16, Target);
 
             /* Copy the PIN data */
@@ -300,13 +281,12 @@ AcpiRsConvertAmlToResource (
             AcpiRsMoveData (Target, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_MOVE_GPIO_RES:
 
             /* Generate and set the ResourceSource string pointer */
 
             Target = (char *) ACPI_ADD_PTR (void, Resource,
-                  (Resource->Length - ItemCount));
+                (Resource->Length - ItemCount));
             *(UINT8 **) Destination = ACPI_CAST_PTR (UINT8, Target);
 
             /* Copy the ResourceSource string */
@@ -315,13 +295,12 @@ AcpiRsConvertAmlToResource (
             AcpiRsMoveData (Target, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_MOVE_SERIAL_VEN:
 
             /* Generate and set the Vendor Data pointer */
 
             Target = (char *) ACPI_ADD_PTR (void, Resource,
-                  (Resource->Length - ItemCount));
+                (Resource->Length - ItemCount));
             *(UINT8 **) Destination = ACPI_CAST_PTR (UINT8, Target);
 
             /* Copy the Vendor Data */
@@ -330,35 +309,32 @@ AcpiRsConvertAmlToResource (
             AcpiRsMoveData (Target, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_MOVE_SERIAL_RES:
 
             /* Generate and set the ResourceSource string pointer */
 
             Target = (char *) ACPI_ADD_PTR (void, Resource,
-                  (Resource->Length - ItemCount));
+                (Resource->Length - ItemCount));
             *(UINT8 **) Destination = ACPI_CAST_PTR (UINT8, Target);
 
             /* Copy the ResourceSource string */
 
-            Source = ACPI_ADD_PTR (void, Aml, (ACPI_GET16 (Source) + Info->Value));
+            Source = ACPI_ADD_PTR (
+                void, Aml, (ACPI_GET16 (Source) + Info->Value));
             AcpiRsMoveData (Target, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_SET8:
 
-            ACPI_MEMSET (Destination, Info->AmlOffset, Info->Value);
+            memset (Destination, Info->AmlOffset, Info->Value);
             break;
 
-
         case ACPI_RSC_DATA8:
 
             Target = ACPI_ADD_PTR (char, Resource, Info->Value);
-            ACPI_MEMCPY (Destination, Source,  ACPI_GET16 (Target));
+            memcpy (Destination, Source,  ACPI_GET16 (Target));
             break;
 
-
         case ACPI_RSC_ADDRESS:
             /*
              * Common handler for address descriptor flags
@@ -369,7 +345,6 @@ AcpiRsConvertAmlToResource (
             }
             break;
 
-
         case ACPI_RSC_SOURCE:
             /*
              * Optional ResourceSource (Index and String)
@@ -379,7 +354,6 @@ AcpiRsConvertAmlToResource (
                     Destination, Aml, NULL);
             break;
 
-
         case ACPI_RSC_SOURCEX:
             /*
              * Optional ResourceSource (Index and String). This is the more
@@ -394,7 +368,6 @@ AcpiRsConvertAmlToResource (
                     Destination, Aml, Target);
             break;
 
-
         case ACPI_RSC_BITMASK:
             /*
              * 8-bit encoded bitmask (DMA macro)
@@ -406,10 +379,9 @@ AcpiRsConvertAmlToResource (
             }
 
             Target = ACPI_ADD_PTR (char, Resource, Info->Value);
-            ACPI_SET8 (Target) = (UINT8) ItemCount;
+            ACPI_SET8 (Target, ItemCount);
             break;
 
-
         case ACPI_RSC_BITMASK16:
             /*
              * 16-bit encoded bitmask (IRQ macro)
@@ -423,10 +395,9 @@ AcpiRsConvertAmlToResource (
             }
 
             Target = ACPI_ADD_PTR (char, Resource, Info->Value);
-            ACPI_SET8 (Target) = (UINT8) ItemCount;
+            ACPI_SET8 (Target, ItemCount);
             break;
 
-
         case ACPI_RSC_EXIT_NE:
             /*
              * Control - Exit conversion if not equal
@@ -434,6 +405,7 @@ AcpiRsConvertAmlToResource (
             switch (Info->ResourceOffset)
             {
             case ACPI_RSC_COMPARE_AML_LENGTH:
+
                 if (AmlResourceLength != Info->Value)
                 {
                     goto Exit;
@@ -441,6 +413,7 @@ AcpiRsConvertAmlToResource (
                 break;
 
             case ACPI_RSC_COMPARE_VALUE:
+
                 if (ACPI_GET8 (Source) != Info->Value)
                 {
                     goto Exit;
@@ -454,7 +427,6 @@ AcpiRsConvertAmlToResource (
             }
             break;
 
-
         default:
 
             ACPI_ERROR ((AE_INFO, "Invalid conversion opcode"));
@@ -470,7 +442,8 @@ Exit:
     {
         /* Round the resource struct length up to the next boundary (32 or 64) */
 
-        Resource->Length = (UINT32) ACPI_ROUND_UP_TO_NATIVE_WORD (Resource->Length);
+        Resource->Length = (UINT32)
+            ACPI_ROUND_UP_TO_NATIVE_WORD (Resource->Length);
     }
     return_ACPI_STATUS (AE_OK);
 }
@@ -526,67 +499,62 @@ AcpiRsConvertResourceToAml (
          * Source is the internal resource descriptor,
          * destination is the external AML byte stream buffer
          */
-        Source      = ACPI_ADD_PTR (void, Resource, Info->ResourceOffset);
+        Source = ACPI_ADD_PTR (void, Resource, Info->ResourceOffset);
         Destination = ACPI_ADD_PTR (void, Aml, Info->AmlOffset);
 
         switch (Info->Opcode)
         {
         case ACPI_RSC_INITSET:
 
-            ACPI_MEMSET (Aml, 0, INIT_RESOURCE_LENGTH (Info));
+            memset (Aml, 0, INIT_RESOURCE_LENGTH (Info));
             AmlLength = INIT_RESOURCE_LENGTH (Info);
-            AcpiRsSetResourceHeader (INIT_RESOURCE_TYPE (Info), AmlLength, Aml);
+            AcpiRsSetResourceHeader (
+                INIT_RESOURCE_TYPE (Info), AmlLength, Aml);
             break;
 
-
         case ACPI_RSC_INITGET:
             break;
 
-
         case ACPI_RSC_FLAGINIT:
             /*
              * Clear the flag byte
              */
-            ACPI_SET8 (Destination) = 0;
+            ACPI_SET8 (Destination, 0);
             break;
 
-
         case ACPI_RSC_1BITFLAG:
             /*
              * Mask and shift the flag bit
              */
-            ACPI_SET8 (Destination) |= (UINT8)
-                ((ACPI_GET8 (Source) & 0x01) << Info->Value);
+            ACPI_SET_BIT (*ACPI_CAST8 (Destination), (UINT8)
+                ((ACPI_GET8 (Source) & 0x01) << Info->Value));
             break;
 
-
         case ACPI_RSC_2BITFLAG:
             /*
              * Mask and shift the flag bits
              */
-            ACPI_SET8 (Destination) |= (UINT8)
-                ((ACPI_GET8 (Source) & 0x03) << Info->Value);
+            ACPI_SET_BIT (*ACPI_CAST8 (Destination), (UINT8)
+                ((ACPI_GET8 (Source) & 0x03) << Info->Value));
             break;
 
-
         case ACPI_RSC_3BITFLAG:
             /*
              * Mask and shift the flag bits
              */
-            ACPI_SET8 (Destination) |= (UINT8)
-                ((ACPI_GET8 (Source) & 0x07) << Info->Value);
+            ACPI_SET_BIT (*ACPI_CAST8 (Destination), (UINT8)
+                ((ACPI_GET8 (Source) & 0x07) << Info->Value));
             break;
 
-
         case ACPI_RSC_COUNT:
 
             ItemCount = ACPI_GET8 (Source);
-            ACPI_SET8 (Destination) = (UINT8) ItemCount;
+            ACPI_SET8 (Destination, ItemCount);
 
-            AmlLength = (UINT16) (AmlLength + (Info->Value * (ItemCount - 1)));
+            AmlLength = (UINT16)
+                (AmlLength + (Info->Value * (ItemCount - 1)));
             break;
 
-
         case ACPI_RSC_COUNT16:
 
             ItemCount = ACPI_GET16 (Source);
@@ -594,35 +562,33 @@ AcpiRsConvertResourceToAml (
             AcpiRsSetResourceLength (AmlLength, Aml);
             break;
 
-
         case ACPI_RSC_COUNT_GPIO_PIN:
 
             ItemCount = ACPI_GET16 (Source);
-            ACPI_SET16 (Destination) = (UINT16) AmlLength;
+            ACPI_SET16 (Destination, AmlLength);
 
             AmlLength = (UINT16) (AmlLength + ItemCount * 2);
             Target = ACPI_ADD_PTR (void, Aml, Info->Value);
-            ACPI_SET16 (Target) = (UINT16) AmlLength;
+            ACPI_SET16 (Target, AmlLength);
             AcpiRsSetResourceLength (AmlLength, Aml);
             break;
 
-
         case ACPI_RSC_COUNT_GPIO_VEN:
 
             ItemCount = ACPI_GET16 (Source);
-            ACPI_SET16 (Destination) = (UINT16) ItemCount;
+            ACPI_SET16 (Destination, ItemCount);
 
-            AmlLength = (UINT16) (AmlLength + (Info->Value * ItemCount));
+            AmlLength = (UINT16) (
+                AmlLength + (Info->Value * ItemCount));
             AcpiRsSetResourceLength (AmlLength, Aml);
             break;
 
-
         case ACPI_RSC_COUNT_GPIO_RES:
 
             /* Set resource source string length */
 
             ItemCount = ACPI_GET16 (Source);
-            ACPI_SET16 (Destination) = (UINT16) AmlLength;
+            ACPI_SET16 (Destination, AmlLength);
 
             /* Compute offset for the Vendor Data */
 
@@ -633,22 +599,20 @@ AcpiRsConvertResourceToAml (
 
             if (Resource->Data.Gpio.VendorLength)
             {
-                ACPI_SET16 (Target) = (UINT16) AmlLength;
+                ACPI_SET16 (Target, AmlLength);
             }
 
             AcpiRsSetResourceLength (AmlLength, Aml);
             break;
 
-
         case ACPI_RSC_COUNT_SERIAL_VEN:
 
             ItemCount = ACPI_GET16 (Source);
-            ACPI_SET16 (Destination) = ItemCount + Info->Value;
+            ACPI_SET16 (Destination, ItemCount + Info->Value);
             AmlLength = (UINT16) (AmlLength + ItemCount);
             AcpiRsSetResourceLength (AmlLength, Aml);
             break;
 
-
         case ACPI_RSC_COUNT_SERIAL_RES:
 
             ItemCount = ACPI_GET16 (Source);
@@ -656,13 +620,11 @@ AcpiRsConvertResourceToAml (
             AcpiRsSetResourceLength (AmlLength, Aml);
             break;
 
-
         case ACPI_RSC_LENGTH:
 
             AcpiRsSetResourceLength (Info->Value, Aml);
             break;
 
-
         case ACPI_RSC_MOVE8:
         case ACPI_RSC_MOVE16:
         case ACPI_RSC_MOVE32:
@@ -675,45 +637,40 @@ AcpiRsConvertResourceToAml (
             AcpiRsMoveData (Destination, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_MOVE_GPIO_PIN:
 
             Destination = (char *) ACPI_ADD_PTR (void, Aml,
-                  ACPI_GET16 (Destination));
+                ACPI_GET16 (Destination));
             Source = * (UINT16 **) Source;
             AcpiRsMoveData (Destination, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_MOVE_GPIO_RES:
 
             /* Used for both ResourceSource string and VendorData */
 
             Destination = (char *) ACPI_ADD_PTR (void, Aml,
-                  ACPI_GET16 (Destination));
+                ACPI_GET16 (Destination));
             Source = * (UINT8 **) Source;
             AcpiRsMoveData (Destination, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_MOVE_SERIAL_VEN:
 
             Destination = (char *) ACPI_ADD_PTR (void, Aml,
-                  (AmlLength - ItemCount));
+                (AmlLength - ItemCount));
             Source = * (UINT8 **) Source;
             AcpiRsMoveData (Destination, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_MOVE_SERIAL_RES:
 
             Destination = (char *) ACPI_ADD_PTR (void, Aml,
-                  (AmlLength - ItemCount));
+                (AmlLength - ItemCount));
             Source = * (UINT8 **) Source;
             AcpiRsMoveData (Destination, Source, ItemCount, Info->Opcode);
             break;
 
-
         case ACPI_RSC_ADDRESS:
 
             /* Set the Resource Type, General Flags, and Type-Specific Flags */
@@ -721,17 +678,15 @@ AcpiRsConvertResourceToAml (
             AcpiRsSetAddressCommon (Aml, Resource);
             break;
 
-
         case ACPI_RSC_SOURCEX:
             /*
              * Optional ResourceSource (Index and String)
              */
             AmlLength = AcpiRsSetResourceSource (
-                            Aml, (ACPI_RS_LENGTH) AmlLength, Source);
+                Aml, (ACPI_RS_LENGTH) AmlLength, Source);
             AcpiRsSetResourceLength (AmlLength, Aml);
             break;
 
-
         case ACPI_RSC_SOURCE:
             /*
              * Optional ResourceSource (Index and String). This is the more
@@ -741,27 +696,24 @@ AcpiRsConvertResourceToAml (
             AcpiRsSetResourceLength (AmlLength, Aml);
             break;
 
-
         case ACPI_RSC_BITMASK:
             /*
              * 8-bit encoded bitmask (DMA macro)
              */
-            ACPI_SET8 (Destination) = (UINT8)
+            ACPI_SET8 (Destination,
                 AcpiRsEncodeBitmask (Source,
-                    *ACPI_ADD_PTR (UINT8, Resource, Info->Value));
+                    *ACPI_ADD_PTR (UINT8, Resource, Info->Value)));
             break;
 
-
         case ACPI_RSC_BITMASK16:
             /*
              * 16-bit encoded bitmask (IRQ macro)
              */
-            Temp16 = AcpiRsEncodeBitmask (Source,
-                        *ACPI_ADD_PTR (UINT8, Resource, Info->Value));
+            Temp16 = AcpiRsEncodeBitmask (
+                Source, *ACPI_ADD_PTR (UINT8, Resource, Info->Value));
             ACPI_MOVE_16_TO_16 (Destination, &Temp16);
             break;
 
-
         case ACPI_RSC_EXIT_LE:
             /*
              * Control - Exit conversion if less than or equal
@@ -772,7 +724,6 @@ AcpiRsConvertResourceToAml (
             }
             break;
 
-
         case ACPI_RSC_EXIT_NE:
             /*
              * Control - Exit conversion if not equal
@@ -782,7 +733,7 @@ AcpiRsConvertResourceToAml (
             case ACPI_RSC_COMPARE_VALUE:
 
                 if (*ACPI_ADD_PTR (UINT8, Resource,
-                        COMPARE_TARGET (Info)) != COMPARE_VALUE (Info))
+                    COMPARE_TARGET (Info)) != COMPARE_VALUE (Info))
                 {
                     goto Exit;
                 }
@@ -795,19 +746,17 @@ AcpiRsConvertResourceToAml (
             }
             break;
 
-
         case ACPI_RSC_EXIT_EQ:
             /*
              * Control - Exit conversion if equal
              */
             if (*ACPI_ADD_PTR (UINT8, Resource,
-                    COMPARE_TARGET (Info)) == COMPARE_VALUE (Info))
+                COMPARE_TARGET (Info)) == COMPARE_VALUE (Info))
             {
                 goto Exit;
             }
             break;
 
-
         default:
 
             ACPI_ERROR ((AE_INFO, "Invalid conversion opcode"));
@@ -826,7 +775,8 @@ Exit:
 #if 0
 /* Previous resource validations */
 
-    if (Aml->ExtAddress64.RevisionID != AML_RESOURCE_EXTENDED_ADDRESS_REVISION)
+    if (Aml->ExtAddress64.RevisionID !=
+        AML_RESOURCE_EXTENDED_ADDRESS_REVISION)
     {
         return_ACPI_STATUS (AE_SUPPORT);
     }
@@ -865,5 +815,3 @@ Exit:
         return_ACPI_STATUS (AE_BAD_DATA);
     }
 #endif
-
-
diff --git a/usr/src/uts/intel/io/acpica/resources/rsserial.c b/usr/src/uts/intel/io/acpica/resources/rsserial.c
index 3a7784e96c..1eae4502f7 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsserial.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsserial.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __RSIRQ_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -57,7 +55,7 @@
  *
  ******************************************************************************/
 
-ACPI_RSCONVERT_INFO     AcpiRsConvertGpio[17] =
+ACPI_RSCONVERT_INFO     AcpiRsConvertGpio[18] =
 {
     {ACPI_RSC_INITGET,  ACPI_RESOURCE_TYPE_GPIO,
                         ACPI_RS_SIZE (ACPI_RESOURCE_GPIO),
@@ -80,10 +78,14 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertGpio[17] =
                         AML_OFFSET (Gpio.Flags),
                         0},
 
-    {ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET (Data.Gpio.Sharable),
+    {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.Gpio.Sharable),
                         AML_OFFSET (Gpio.IntFlags),
                         3},
 
+    {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.Gpio.WakeCapable),
+                        AML_OFFSET (Gpio.IntFlags),
+                        4},
+
     {ACPI_RSC_2BITFLAG, ACPI_RS_OFFSET (Data.Gpio.IoRestriction),
                         AML_OFFSET (Gpio.IntFlags),
                         0},
@@ -151,7 +153,7 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertGpio[17] =
  *
  ******************************************************************************/
 
-ACPI_RSCONVERT_INFO     AcpiRsConvertI2cSerialBus[16] =
+ACPI_RSCONVERT_INFO     AcpiRsConvertI2cSerialBus[17] =
 {
     {ACPI_RSC_INITGET,  ACPI_RESOURCE_TYPE_SERIAL_BUS,
                         ACPI_RS_SIZE (ACPI_RESOURCE_I2C_SERIALBUS),
@@ -177,6 +179,10 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertI2cSerialBus[16] =
                         AML_OFFSET (CommonSerialBus.Flags),
                         1},
 
+    {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.CommonSerialBus.ConnectionSharing),
+                        AML_OFFSET (CommonSerialBus.Flags),
+                        2},
+
     {ACPI_RSC_MOVE8,    ACPI_RS_OFFSET (Data.CommonSerialBus.TypeRevisionId),
                         AML_OFFSET (CommonSerialBus.TypeRevisionId),
                         1},
@@ -231,7 +237,7 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertI2cSerialBus[16] =
  *
  ******************************************************************************/
 
-ACPI_RSCONVERT_INFO     AcpiRsConvertSpiSerialBus[20] =
+ACPI_RSCONVERT_INFO     AcpiRsConvertSpiSerialBus[21] =
 {
     {ACPI_RSC_INITGET,  ACPI_RESOURCE_TYPE_SERIAL_BUS,
                         ACPI_RS_SIZE (ACPI_RESOURCE_SPI_SERIALBUS),
@@ -257,6 +263,10 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertSpiSerialBus[20] =
                         AML_OFFSET (CommonSerialBus.Flags),
                         1},
 
+    {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.CommonSerialBus.ConnectionSharing),
+                        AML_OFFSET (CommonSerialBus.Flags),
+                        2},
+
     {ACPI_RSC_MOVE8,    ACPI_RS_OFFSET (Data.CommonSerialBus.TypeRevisionId),
                         AML_OFFSET (CommonSerialBus.TypeRevisionId),
                         1},
@@ -327,7 +337,7 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertSpiSerialBus[20] =
  *
  ******************************************************************************/
 
-ACPI_RSCONVERT_INFO     AcpiRsConvertUartSerialBus[22] =
+ACPI_RSCONVERT_INFO     AcpiRsConvertUartSerialBus[23] =
 {
     {ACPI_RSC_INITGET,  ACPI_RESOURCE_TYPE_SERIAL_BUS,
                         ACPI_RS_SIZE (ACPI_RESOURCE_UART_SERIALBUS),
@@ -353,6 +363,10 @@ ACPI_RSCONVERT_INFO     AcpiRsConvertUartSerialBus[22] =
                         AML_OFFSET (CommonSerialBus.Flags),
                         1},
 
+    {ACPI_RSC_1BITFLAG, ACPI_RS_OFFSET (Data.CommonSerialBus.ConnectionSharing),
+                        AML_OFFSET (CommonSerialBus.Flags),
+                        2},
+
     {ACPI_RSC_MOVE8,    ACPI_RS_OFFSET (Data.CommonSerialBus.TypeRevisionId),
                         AML_OFFSET (CommonSerialBus.TypeRevisionId),
                         1},
diff --git a/usr/src/uts/intel/io/acpica/resources/rsutils.c b/usr/src/uts/intel/io/acpica/resources/rsutils.c
index 062678651e..cec4180bfd 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsutils.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsutils.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __RSUTILS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -176,31 +173,39 @@ AcpiRsMoveData (
         case ACPI_RSC_MOVE_GPIO_RES:
         case ACPI_RSC_MOVE_SERIAL_VEN:
         case ACPI_RSC_MOVE_SERIAL_RES:
-            ACPI_MEMCPY (Destination, Source, ItemCount);
+
+            memcpy (Destination, Source, ItemCount);
             return;
 
         /*
          * 16-, 32-, and 64-bit cases must use the move macros that perform
-         * endian conversion and/or accomodate hardware that cannot perform
+         * endian conversion and/or accommodate hardware that cannot perform
          * misaligned memory transfers
          */
         case ACPI_RSC_MOVE16:
         case ACPI_RSC_MOVE_GPIO_PIN:
-            ACPI_MOVE_16_TO_16 (&ACPI_CAST_PTR (UINT16, Destination)[i],
-                                &ACPI_CAST_PTR (UINT16, Source)[i]);
+
+            ACPI_MOVE_16_TO_16 (
+                &ACPI_CAST_PTR (UINT16, Destination)[i],
+                &ACPI_CAST_PTR (UINT16, Source)[i]);
             break;
 
         case ACPI_RSC_MOVE32:
-            ACPI_MOVE_32_TO_32 (&ACPI_CAST_PTR (UINT32, Destination)[i],
-                                &ACPI_CAST_PTR (UINT32, Source)[i]);
+
+            ACPI_MOVE_32_TO_32 (
+                &ACPI_CAST_PTR (UINT32, Destination)[i],
+                &ACPI_CAST_PTR (UINT32, Source)[i]);
             break;
 
         case ACPI_RSC_MOVE64:
-            ACPI_MOVE_64_TO_64 (&ACPI_CAST_PTR (UINT64, Destination)[i],
-                                &ACPI_CAST_PTR (UINT64, Source)[i]);
+
+            ACPI_MOVE_64_TO_64 (
+                &ACPI_CAST_PTR (UINT64, Destination)[i],
+                &ACPI_CAST_PTR (UINT64, Source)[i]);
             break;
 
         default:
+
             return;
         }
     }
@@ -246,18 +251,18 @@ AcpiRsSetResourceLength (
     {
         /* Large descriptor -- bytes 1-2 contain the 16-bit length */
 
-        ACPI_MOVE_16_TO_16 (&Aml->LargeHeader.ResourceLength, &ResourceLength);
+        ACPI_MOVE_16_TO_16 (
+            &Aml->LargeHeader.ResourceLength, &ResourceLength);
     }
     else
     {
-        /* Small descriptor -- bits 2:0 of byte 0 contain the length */
-
+        /*
+         * Small descriptor -- bits 2:0 of byte 0 contain the length
+         * Clear any existing length, preserving descriptor type bits
+         */
         Aml->SmallHeader.DescriptorType = (UINT8)
-
-            /* Clear any existing length, preserving descriptor type bits */
-
-            ((Aml->SmallHeader.DescriptorType & ~ACPI_RESOURCE_NAME_SMALL_LENGTH_MASK)
-
+            ((Aml->SmallHeader.DescriptorType &
+                ~ACPI_RESOURCE_NAME_SMALL_LENGTH_MASK)
             | ResourceLength);
     }
 }
@@ -376,8 +381,8 @@ AcpiRsGetResourceSource (
     AmlResourceSource = ACPI_ADD_PTR (UINT8, Aml, MinimumLength);
 
     /*
-     * ResourceSource is present if the length of the descriptor is longer than
-     * the minimum length.
+     * ResourceSource is present if the length of the descriptor is longer
+     * than the minimum length.
      *
      * Note: Some resource descriptors will have an additional null, so
      * we add 1 to the minimum length.
@@ -395,8 +400,8 @@ AcpiRsGetResourceSource (
              * String destination pointer is not specified; Set the String
              * pointer to the end of the current ResourceSource structure.
              */
-            ResourceSource->StringPtr = ACPI_ADD_PTR (char, ResourceSource,
-                sizeof (ACPI_RESOURCE_SOURCE));
+            ResourceSource->StringPtr = ACPI_ADD_PTR (
+                char, ResourceSource, sizeof (ACPI_RESOURCE_SOURCE));
         }
 
         /*
@@ -406,15 +411,17 @@ AcpiRsGetResourceSource (
          *
          * Zero the entire area of the buffer.
          */
-        TotalLength = (UINT32) ACPI_STRLEN (
+        TotalLength = (UINT32) strlen (
             ACPI_CAST_PTR (char, &AmlResourceSource[1])) + 1;
+
         TotalLength = (UINT32) ACPI_ROUND_UP_TO_NATIVE_WORD (TotalLength);
 
-        ACPI_MEMSET (ResourceSource->StringPtr, 0, TotalLength);
+        memset (ResourceSource->StringPtr, 0, TotalLength);
 
         /* Copy the ResourceSource string to the destination */
 
-        ResourceSource->StringLength = AcpiRsStrcpy (ResourceSource->StringPtr,
+        ResourceSource->StringLength = AcpiRsStrcpy (
+            ResourceSource->StringPtr,
             ACPI_CAST_PTR (char, &AmlResourceSource[1]));
 
         return ((ACPI_RS_LENGTH) TotalLength);
@@ -475,14 +482,15 @@ AcpiRsSetResourceSource (
 
         /* Copy the ResourceSource string */
 
-        ACPI_STRCPY (ACPI_CAST_PTR (char, &AmlResourceSource[1]),
+        strcpy (ACPI_CAST_PTR (char, &AmlResourceSource[1]),
             ResourceSource->StringPtr);
 
         /*
          * Add the length of the string (+ 1 for null terminator) to the
          * final descriptor length
          */
-        DescriptorLength += ((ACPI_RSDESC_SIZE) ResourceSource->StringLength + 1);
+        DescriptorLength += ((ACPI_RSDESC_SIZE)
+            ResourceSource->StringLength + 1);
     }
 
     /* Return the new total length of the AML descriptor */
@@ -525,8 +533,8 @@ AcpiRsGetPrtMethodData (
 
     /* Execute the method, no parameters */
 
-    Status = AcpiUtEvaluateObject (Node, METHOD_NAME__PRT,
-                ACPI_BTYPE_PACKAGE, &ObjDesc);
+    Status = AcpiUtEvaluateObject (
+        Node, METHOD_NAME__PRT, ACPI_BTYPE_PACKAGE, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -579,8 +587,8 @@ AcpiRsGetCrsMethodData (
 
     /* Execute the method, no parameters */
 
-    Status = AcpiUtEvaluateObject (Node, METHOD_NAME__CRS,
-                ACPI_BTYPE_BUFFER, &ObjDesc);
+    Status = AcpiUtEvaluateObject (
+        Node, METHOD_NAME__CRS, ACPI_BTYPE_BUFFER, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -634,8 +642,8 @@ AcpiRsGetPrsMethodData (
 
     /* Execute the method, no parameters */
 
-    Status = AcpiUtEvaluateObject (Node, METHOD_NAME__PRS,
-                ACPI_BTYPE_BUFFER, &ObjDesc);
+    Status = AcpiUtEvaluateObject (
+        Node, METHOD_NAME__PRS, ACPI_BTYPE_BUFFER, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -689,8 +697,8 @@ AcpiRsGetAeiMethodData (
 
     /* Execute the method, no parameters */
 
-    Status = AcpiUtEvaluateObject (Node, METHOD_NAME__AEI,
-                ACPI_BTYPE_BUFFER, &ObjDesc);
+    Status = AcpiUtEvaluateObject (
+        Node, METHOD_NAME__AEI, ACPI_BTYPE_BUFFER, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -732,7 +740,7 @@ AcpiRsGetAeiMethodData (
 ACPI_STATUS
 AcpiRsGetMethodData (
     ACPI_HANDLE             Handle,
-    char                    *Path,
+    const char              *Path,
     ACPI_BUFFER             *RetBuffer)
 {
     ACPI_OPERAND_OBJECT     *ObjDesc;
@@ -746,7 +754,9 @@ AcpiRsGetMethodData (
 
     /* Execute the method, no parameters */
 
-    Status = AcpiUtEvaluateObject (Handle, Path, ACPI_BTYPE_BUFFER, &ObjDesc);
+    Status = AcpiUtEvaluateObject (
+        ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Handle),
+        Path, ACPI_BTYPE_BUFFER, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -809,7 +819,7 @@ AcpiRsSetSrsMethodData (
     }
 
     Info->PrefixNode = Node;
-    Info->Pathname = METHOD_NAME__SRS;
+    Info->RelativePathname = METHOD_NAME__SRS;
     Info->Parameters = Args;
     Info->Flags = ACPI_IGNORE_RETURN_VALUE;
 
@@ -821,7 +831,7 @@ AcpiRsSetSrsMethodData (
      * Convert the linked list into a byte stream
      */
     Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-    Status = AcpiRsCreateAmlResources (InBuffer->Pointer, &Buffer);
+    Status = AcpiRsCreateAmlResources (InBuffer, &Buffer);
     if (ACPI_FAILURE (Status))
     {
         goto Cleanup;
@@ -858,4 +868,3 @@ Cleanup:
     ACPI_FREE (Info);
     return_ACPI_STATUS (Status);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/resources/rsxface.c b/usr/src/uts/intel/io/acpica/resources/rsxface.c
index d8c3938b31..81c9ac8b4c 100644
--- a/usr/src/uts/intel/io/acpica/resources/rsxface.c
+++ b/usr/src/uts/intel/io/acpica/resources/rsxface.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,7 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __RSXFACE_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
@@ -55,18 +54,18 @@
 /* Local macros for 16,32-bit to 64-bit conversion */
 
 #define ACPI_COPY_FIELD(Out, In, Field)  ((Out)->Field = (In)->Field)
-#define ACPI_COPY_ADDRESS(Out, In)                      \
+#define ACPI_COPY_ADDRESS(Out, In)                       \
     ACPI_COPY_FIELD(Out, In, ResourceType);              \
     ACPI_COPY_FIELD(Out, In, ProducerConsumer);          \
     ACPI_COPY_FIELD(Out, In, Decode);                    \
     ACPI_COPY_FIELD(Out, In, MinAddressFixed);           \
     ACPI_COPY_FIELD(Out, In, MaxAddressFixed);           \
     ACPI_COPY_FIELD(Out, In, Info);                      \
-    ACPI_COPY_FIELD(Out, In, Granularity);               \
-    ACPI_COPY_FIELD(Out, In, Minimum);                   \
-    ACPI_COPY_FIELD(Out, In, Maximum);                   \
-    ACPI_COPY_FIELD(Out, In, TranslationOffset);         \
-    ACPI_COPY_FIELD(Out, In, AddressLength);             \
+    ACPI_COPY_FIELD(Out, In, Address.Granularity);       \
+    ACPI_COPY_FIELD(Out, In, Address.Minimum);           \
+    ACPI_COPY_FIELD(Out, In, Address.Maximum);           \
+    ACPI_COPY_FIELD(Out, In, Address.TranslationOffset); \
+    ACPI_COPY_FIELD(Out, In, Address.AddressLength);     \
     ACPI_COPY_FIELD(Out, In, ResourceSource);
 
 
@@ -434,13 +433,15 @@ AcpiResourceToAddress64 (
     {
     case ACPI_RESOURCE_TYPE_ADDRESS16:
 
-        Address16 = ACPI_CAST_PTR (ACPI_RESOURCE_ADDRESS16, &Resource->Data);
+        Address16 = ACPI_CAST_PTR (
+            ACPI_RESOURCE_ADDRESS16, &Resource->Data);
         ACPI_COPY_ADDRESS (Out, Address16);
         break;
 
     case ACPI_RESOURCE_TYPE_ADDRESS32:
 
-        Address32 = ACPI_CAST_PTR (ACPI_RESOURCE_ADDRESS32, &Resource->Data);
+        Address32 = ACPI_CAST_PTR (
+            ACPI_RESOURCE_ADDRESS32, &Resource->Data);
         ACPI_COPY_ADDRESS (Out, Address32);
         break;
 
@@ -448,10 +449,11 @@ AcpiResourceToAddress64 (
 
         /* Simple copy for 64 bit source */
 
-        ACPI_MEMCPY (Out, &Resource->Data, sizeof (ACPI_RESOURCE_ADDRESS64));
+        memcpy (Out, &Resource->Data, sizeof (ACPI_RESOURCE_ADDRESS64));
         break;
 
     default:
+
         return (AE_BAD_PARAMETER);
     }
 
@@ -474,7 +476,7 @@ ACPI_EXPORT_SYMBOL (AcpiResourceToAddress64)
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Walk a resource template for the specified evice to find a
+ * DESCRIPTION: Walk a resource template for the specified device to find a
  *              vendor-defined resource that matches the supplied UUID and
  *              UUID subtype. Returns a ACPI_RESOURCE of type Vendor.
  *
@@ -504,8 +506,8 @@ AcpiGetVendorResource (
 
     /* Walk the _CRS or _PRS resource list for this device */
 
-    Status = AcpiWalkResources (DeviceHandle, Name, AcpiRsMatchVendorResource,
-                &Info);
+    Status = AcpiWalkResources (
+        DeviceHandle, Name, AcpiRsMatchVendorResource, &Info);
     if (ACPI_FAILURE (Status))
     {
         return (Status);
@@ -558,7 +560,7 @@ AcpiRsMatchVendorResource (
      */
     if ((Vendor->ByteLength < (ACPI_UUID_LENGTH + 1)) ||
         (Vendor->UuidSubtype != Info->Uuid->Subtype)  ||
-        (ACPI_MEMCMP (Vendor->Uuid, Info->Uuid->Data, ACPI_UUID_LENGTH)))
+        (memcmp (Vendor->Uuid, Info->Uuid->Data, ACPI_UUID_LENGTH)))
     {
         return (AE_OK);
     }
@@ -574,7 +576,7 @@ AcpiRsMatchVendorResource (
 
     /* Found the correct resource, copy and return it */
 
-    ACPI_MEMCPY (Buffer->Pointer, Resource, Resource->Length);
+    memcpy (Buffer->Pointer, Resource, Resource->Length);
     Buffer->Length = Resource->Length;
 
     /* Found the desired descriptor, terminate resource walk */
@@ -586,69 +588,52 @@ AcpiRsMatchVendorResource (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiWalkResources
+ * FUNCTION:    AcpiWalkResourceBuffer
  *
- * PARAMETERS:  DeviceHandle    - Handle to the device object for the
- *                                device we are querying
- *              Name            - Method name of the resources we want.
- *                                (METHOD_NAME__CRS, METHOD_NAME__PRS, or
- *                                METHOD_NAME__AEI)
+ * PARAMETERS:  Buffer          - Formatted buffer returned by one of the
+ *                                various Get*Resource functions
  *              UserFunction    - Called for each resource
  *              Context         - Passed to UserFunction
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Retrieves the current or possible resource list for the
- *              specified device. The UserFunction is called once for
- *              each resource in the list.
+ * DESCRIPTION: Walks the input resource template. The UserFunction is called
+ *              once for each resource in the list.
  *
  ******************************************************************************/
 
 ACPI_STATUS
-AcpiWalkResources (
-    ACPI_HANDLE                 DeviceHandle,
-    char                        *Name,
+AcpiWalkResourceBuffer (
+    ACPI_BUFFER                 *Buffer,
     ACPI_WALK_RESOURCE_CALLBACK UserFunction,
     void                        *Context)
 {
-    ACPI_STATUS                 Status;
-    ACPI_BUFFER                 Buffer;
+    ACPI_STATUS                 Status = AE_OK;
     ACPI_RESOURCE               *Resource;
     ACPI_RESOURCE               *ResourceEnd;
 
 
-    ACPI_FUNCTION_TRACE (AcpiWalkResources);
+    ACPI_FUNCTION_TRACE (AcpiWalkResourceBuffer);
 
 
     /* Parameter validation */
 
-    if (!DeviceHandle || !UserFunction || !Name ||
-        (!ACPI_COMPARE_NAME (Name, METHOD_NAME__CRS) &&
-         !ACPI_COMPARE_NAME (Name, METHOD_NAME__PRS) &&
-         !ACPI_COMPARE_NAME (Name, METHOD_NAME__AEI)))
+    if (!Buffer || !Buffer->Pointer || !UserFunction)
     {
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
-    /* Get the _CRS/_PRS/_AEI resource list */
+    /* Buffer contains the resource list and length */
 
-    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-    Status = AcpiRsGetMethodData (DeviceHandle, Name, &Buffer);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Buffer now contains the resource list */
-
-    Resource = ACPI_CAST_PTR (ACPI_RESOURCE, Buffer.Pointer);
-    ResourceEnd = ACPI_ADD_PTR (ACPI_RESOURCE, Buffer.Pointer, Buffer.Length);
+    Resource = ACPI_CAST_PTR (ACPI_RESOURCE, Buffer->Pointer);
+    ResourceEnd = ACPI_ADD_PTR (
+        ACPI_RESOURCE, Buffer->Pointer, Buffer->Length);
 
     /* Walk the resource list until the EndTag is found (or buffer end) */
 
     while (Resource < ResourceEnd)
     {
-        /* Sanity check the resource */
+        /* Sanity check the resource type */
 
         if (Resource->Type > ACPI_RESOURCE_TYPE_MAX)
         {
@@ -656,6 +641,13 @@ AcpiWalkResources (
             break;
         }
 
+        /* Sanity check the length. It must not be zero, or we loop forever */
+
+        if (!Resource->Length)
+        {
+            return_ACPI_STATUS (AE_AML_BAD_RESOURCE_LENGTH);
+        }
+
         /* Invoke the user function, abort on any error returned */
 
         Status = UserFunction (Resource, Context);
@@ -679,9 +671,71 @@ AcpiWalkResources (
 
         /* Get the next resource descriptor */
 
-        Resource = ACPI_ADD_PTR (ACPI_RESOURCE, Resource, Resource->Length);
+        Resource = ACPI_NEXT_RESOURCE (Resource);
     }
 
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiWalkResourceBuffer)
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiWalkResources
+ *
+ * PARAMETERS:  DeviceHandle    - Handle to the device object for the
+ *                                device we are querying
+ *              Name            - Method name of the resources we want.
+ *                                (METHOD_NAME__CRS, METHOD_NAME__PRS, or
+ *                                METHOD_NAME__AEI)
+ *              UserFunction    - Called for each resource
+ *              Context         - Passed to UserFunction
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Retrieves the current or possible resource list for the
+ *              specified device. The UserFunction is called once for
+ *              each resource in the list.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiWalkResources (
+    ACPI_HANDLE                 DeviceHandle,
+    char                        *Name,
+    ACPI_WALK_RESOURCE_CALLBACK UserFunction,
+    void                        *Context)
+{
+    ACPI_STATUS                 Status;
+    ACPI_BUFFER                 Buffer;
+
+
+    ACPI_FUNCTION_TRACE (AcpiWalkResources);
+
+
+    /* Parameter validation */
+
+    if (!DeviceHandle || !UserFunction || !Name ||
+        (!ACPI_COMPARE_NAME (Name, METHOD_NAME__CRS) &&
+         !ACPI_COMPARE_NAME (Name, METHOD_NAME__PRS) &&
+         !ACPI_COMPARE_NAME (Name, METHOD_NAME__AEI)))
+    {
+        return_ACPI_STATUS (AE_BAD_PARAMETER);
+    }
+
+    /* Get the _CRS/_PRS/_AEI resource list */
+
+    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
+    Status = AcpiRsGetMethodData (DeviceHandle, Name, &Buffer);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Walk the resource list and cleanup */
+
+    Status = AcpiWalkResourceBuffer (&Buffer, UserFunction, Context);
     ACPI_FREE (Buffer.Pointer);
     return_ACPI_STATUS (Status);
 }
diff --git a/usr/src/uts/intel/io/acpica/tables/tbdata.c b/usr/src/uts/intel/io/acpica/tables/tbdata.c
new file mode 100644
index 0000000000..31fa25b92e
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/tables/tbdata.c
@@ -0,0 +1,869 @@
+/******************************************************************************
+ *
+ * Module Name: tbdata - Table manager data structure functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acnamesp.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_TABLES
+        ACPI_MODULE_NAME    ("tbdata")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbInitTableDescriptor
+ *
+ * PARAMETERS:  TableDesc               - Table descriptor
+ *              Address                 - Physical address of the table
+ *              Flags                   - Allocation flags of the table
+ *              Table                   - Pointer to the table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Initialize a new table descriptor
+ *
+ ******************************************************************************/
+
+void
+AcpiTbInitTableDescriptor (
+    ACPI_TABLE_DESC         *TableDesc,
+    ACPI_PHYSICAL_ADDRESS   Address,
+    UINT8                   Flags,
+    ACPI_TABLE_HEADER       *Table)
+{
+
+    /*
+     * Initialize the table descriptor. Set the pointer to NULL, since the
+     * table is not fully mapped at this time.
+     */
+    memset (TableDesc, 0, sizeof (ACPI_TABLE_DESC));
+    TableDesc->Address = Address;
+    TableDesc->Length = Table->Length;
+    TableDesc->Flags = Flags;
+    ACPI_MOVE_32_TO_32 (TableDesc->Signature.Ascii, Table->Signature);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbAcquireTable
+ *
+ * PARAMETERS:  TableDesc           - Table descriptor
+ *              TablePtr            - Where table is returned
+ *              TableLength         - Where table length is returned
+ *              TableFlags          - Where table allocation flags are returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Acquire an ACPI table. It can be used for tables not
+ *              maintained in the AcpiGbl_RootTableList.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbAcquireTable (
+    ACPI_TABLE_DESC         *TableDesc,
+    ACPI_TABLE_HEADER       **TablePtr,
+    UINT32                  *TableLength,
+    UINT8                   *TableFlags)
+{
+    ACPI_TABLE_HEADER       *Table = NULL;
+
+
+    switch (TableDesc->Flags & ACPI_TABLE_ORIGIN_MASK)
+    {
+    case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
+
+        Table = AcpiOsMapMemory (TableDesc->Address, TableDesc->Length);
+        break;
+
+    case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
+    case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
+
+        Table = ACPI_CAST_PTR (ACPI_TABLE_HEADER,
+            ACPI_PHYSADDR_TO_PTR (TableDesc->Address));
+        break;
+
+    default:
+
+        break;
+    }
+
+    /* Table is not valid yet */
+
+    if (!Table)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    /* Fill the return values */
+
+    *TablePtr = Table;
+    *TableLength = TableDesc->Length;
+    *TableFlags = TableDesc->Flags;
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbReleaseTable
+ *
+ * PARAMETERS:  Table               - Pointer for the table
+ *              TableLength         - Length for the table
+ *              TableFlags          - Allocation flags for the table
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Release a table. The inverse of AcpiTbAcquireTable().
+ *
+ ******************************************************************************/
+
+void
+AcpiTbReleaseTable (
+    ACPI_TABLE_HEADER       *Table,
+    UINT32                  TableLength,
+    UINT8                   TableFlags)
+{
+
+    switch (TableFlags & ACPI_TABLE_ORIGIN_MASK)
+    {
+    case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
+
+        AcpiOsUnmapMemory (Table, TableLength);
+        break;
+
+    case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
+    case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
+    default:
+
+        break;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbAcquireTempTable
+ *
+ * PARAMETERS:  TableDesc           - Table descriptor to be acquired
+ *              Address             - Address of the table
+ *              Flags               - Allocation flags of the table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function validates the table header to obtain the length
+ *              of a table and fills the table descriptor to make its state as
+ *              "INSTALLED". Such a table descriptor is only used for verified
+ *              installation.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbAcquireTempTable (
+    ACPI_TABLE_DESC         *TableDesc,
+    ACPI_PHYSICAL_ADDRESS   Address,
+    UINT8                   Flags)
+{
+    ACPI_TABLE_HEADER       *TableHeader;
+
+
+    switch (Flags & ACPI_TABLE_ORIGIN_MASK)
+    {
+    case ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:
+
+        /* Get the length of the full table from the header */
+
+        TableHeader = AcpiOsMapMemory (Address, sizeof (ACPI_TABLE_HEADER));
+        if (!TableHeader)
+        {
+            return (AE_NO_MEMORY);
+        }
+
+        AcpiTbInitTableDescriptor (TableDesc, Address, Flags, TableHeader);
+        AcpiOsUnmapMemory (TableHeader, sizeof (ACPI_TABLE_HEADER));
+        return (AE_OK);
+
+    case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
+    case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
+
+        TableHeader = ACPI_CAST_PTR (ACPI_TABLE_HEADER,
+            ACPI_PHYSADDR_TO_PTR (Address));
+        if (!TableHeader)
+        {
+            return (AE_NO_MEMORY);
+        }
+
+        AcpiTbInitTableDescriptor (TableDesc, Address, Flags, TableHeader);
+        return (AE_OK);
+
+    default:
+
+        break;
+    }
+
+    /* Table is not valid yet */
+
+    return (AE_NO_MEMORY);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbReleaseTempTable
+ *
+ * PARAMETERS:  TableDesc           - Table descriptor to be released
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: The inverse of AcpiTbAcquireTempTable().
+ *
+ *****************************************************************************/
+
+void
+AcpiTbReleaseTempTable (
+    ACPI_TABLE_DESC         *TableDesc)
+{
+
+    /*
+     * Note that the .Address is maintained by the callers of
+     * AcpiTbAcquireTempTable(), thus do not invoke AcpiTbUninstallTable()
+     * where .Address will be freed.
+     */
+    AcpiTbInvalidateTable (TableDesc);
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiTbValidateTable
+ *
+ * PARAMETERS:  TableDesc           - Table descriptor
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to validate the table, the returned
+ *              table descriptor is in "VALIDATED" state.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiTbValidateTable (
+    ACPI_TABLE_DESC         *TableDesc)
+{
+    ACPI_STATUS             Status = AE_OK;
+
+
+    ACPI_FUNCTION_TRACE (TbValidateTable);
+
+
+    /* Validate the table if necessary */
+
+    if (!TableDesc->Pointer)
+    {
+        Status = AcpiTbAcquireTable (TableDesc, &TableDesc->Pointer,
+            &TableDesc->Length, &TableDesc->Flags);
+        if (!TableDesc->Pointer)
+        {
+            Status = AE_NO_MEMORY;
+        }
+    }
+
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbInvalidateTable
+ *
+ * PARAMETERS:  TableDesc           - Table descriptor
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Invalidate one internal ACPI table, this is the inverse of
+ *              AcpiTbValidateTable().
+ *
+ ******************************************************************************/
+
+void
+AcpiTbInvalidateTable (
+    ACPI_TABLE_DESC         *TableDesc)
+{
+
+    ACPI_FUNCTION_TRACE (TbInvalidateTable);
+
+
+    /* Table must be validated */
+
+    if (!TableDesc->Pointer)
+    {
+        return_VOID;
+    }
+
+    AcpiTbReleaseTable (TableDesc->Pointer, TableDesc->Length,
+        TableDesc->Flags);
+    TableDesc->Pointer = NULL;
+
+    return_VOID;
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiTbValidateTempTable
+ *
+ * PARAMETERS:  TableDesc           - Table descriptor
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to validate the table, the returned
+ *              table descriptor is in "VALIDATED" state.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiTbValidateTempTable (
+    ACPI_TABLE_DESC         *TableDesc)
+{
+
+    if (!TableDesc->Pointer && !AcpiGbl_VerifyTableChecksum)
+    {
+        /*
+         * Only validates the header of the table.
+         * Note that Length contains the size of the mapping after invoking
+         * this work around, this value is required by
+         * AcpiTbReleaseTempTable().
+         * We can do this because in AcpiInitTableDescriptor(), the Length
+         * field of the installed descriptor is filled with the actual
+         * table length obtaining from the table header.
+         */
+        TableDesc->Length = sizeof (ACPI_TABLE_HEADER);
+    }
+
+    return (AcpiTbValidateTable (TableDesc));
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiTbVerifyTempTable
+ *
+ * PARAMETERS:  TableDesc           - Table descriptor
+ *              Signature           - Table signature to verify
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: This function is called to validate and verify the table, the
+ *              returned table descriptor is in "VALIDATED" state.
+ *
+ *****************************************************************************/
+
+ACPI_STATUS
+AcpiTbVerifyTempTable (
+    ACPI_TABLE_DESC         *TableDesc,
+    char                    *Signature)
+{
+    ACPI_STATUS             Status = AE_OK;
+
+
+    ACPI_FUNCTION_TRACE (TbVerifyTempTable);
+
+
+    /* Validate the table */
+
+    Status = AcpiTbValidateTempTable (TableDesc);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    /* If a particular signature is expected (DSDT/FACS), it must match */
+
+    if (Signature &&
+        !ACPI_COMPARE_NAME (&TableDesc->Signature, Signature))
+    {
+        ACPI_BIOS_ERROR ((AE_INFO,
+            "Invalid signature 0x%X for ACPI table, expected [%s]",
+            TableDesc->Signature.Integer, Signature));
+        Status = AE_BAD_SIGNATURE;
+        goto InvalidateAndExit;
+    }
+
+    /* Verify the checksum */
+
+    if (AcpiGbl_VerifyTableChecksum)
+    {
+        Status = AcpiTbVerifyChecksum (TableDesc->Pointer, TableDesc->Length);
+        if (ACPI_FAILURE (Status))
+        {
+            ACPI_EXCEPTION ((AE_INFO, AE_NO_MEMORY,
+                "%4.4s 0x%8.8X%8.8X"
+                " Attempted table install failed",
+                AcpiUtValidNameseg (TableDesc->Signature.Ascii) ?
+                    TableDesc->Signature.Ascii : "????",
+                ACPI_FORMAT_UINT64 (TableDesc->Address)));
+
+            goto InvalidateAndExit;
+        }
+    }
+
+    return_ACPI_STATUS (AE_OK);
+
+InvalidateAndExit:
+    AcpiTbInvalidateTable (TableDesc);
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbResizeRootTableList
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Expand the size of global table array
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbResizeRootTableList (
+    void)
+{
+    ACPI_TABLE_DESC         *Tables;
+    UINT32                  TableCount;
+
+
+    ACPI_FUNCTION_TRACE (TbResizeRootTableList);
+
+
+    /* AllowResize flag is a parameter to AcpiInitializeTables */
+
+    if (!(AcpiGbl_RootTableList.Flags & ACPI_ROOT_ALLOW_RESIZE))
+    {
+        ACPI_ERROR ((AE_INFO, "Resize of Root Table Array is not allowed"));
+        return_ACPI_STATUS (AE_SUPPORT);
+    }
+
+    /* Increase the Table Array size */
+
+    if (AcpiGbl_RootTableList.Flags & ACPI_ROOT_ORIGIN_ALLOCATED)
+    {
+        TableCount = AcpiGbl_RootTableList.MaxTableCount;
+    }
+    else
+    {
+        TableCount = AcpiGbl_RootTableList.CurrentTableCount;
+    }
+
+    Tables = ACPI_ALLOCATE_ZEROED (
+        ((ACPI_SIZE) TableCount + ACPI_ROOT_TABLE_SIZE_INCREMENT) *
+        sizeof (ACPI_TABLE_DESC));
+    if (!Tables)
+    {
+        ACPI_ERROR ((AE_INFO, "Could not allocate new root table array"));
+        return_ACPI_STATUS (AE_NO_MEMORY);
+    }
+
+    /* Copy and free the previous table array */
+
+    if (AcpiGbl_RootTableList.Tables)
+    {
+        memcpy (Tables, AcpiGbl_RootTableList.Tables,
+            (ACPI_SIZE) TableCount * sizeof (ACPI_TABLE_DESC));
+
+        if (AcpiGbl_RootTableList.Flags & ACPI_ROOT_ORIGIN_ALLOCATED)
+        {
+            ACPI_FREE (AcpiGbl_RootTableList.Tables);
+        }
+    }
+
+    AcpiGbl_RootTableList.Tables = Tables;
+    AcpiGbl_RootTableList.MaxTableCount =
+        TableCount + ACPI_ROOT_TABLE_SIZE_INCREMENT;
+    AcpiGbl_RootTableList.Flags |= ACPI_ROOT_ORIGIN_ALLOCATED;
+
+    return_ACPI_STATUS (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbGetNextTableDescriptor
+ *
+ * PARAMETERS:  TableIndex          - Where table index is returned
+ *              TableDesc           - Where table descriptor is returned
+ *
+ * RETURN:      Status and table index/descriptor.
+ *
+ * DESCRIPTION: Allocate a new ACPI table entry to the global table list
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbGetNextTableDescriptor (
+    UINT32                  *TableIndex,
+    ACPI_TABLE_DESC         **TableDesc)
+{
+    ACPI_STATUS             Status;
+    UINT32                  i;
+
+
+    /* Ensure that there is room for the table in the Root Table List */
+
+    if (AcpiGbl_RootTableList.CurrentTableCount >=
+        AcpiGbl_RootTableList.MaxTableCount)
+    {
+        Status = AcpiTbResizeRootTableList();
+        if (ACPI_FAILURE (Status))
+        {
+            return (Status);
+        }
+    }
+
+    i = AcpiGbl_RootTableList.CurrentTableCount;
+    AcpiGbl_RootTableList.CurrentTableCount++;
+
+    if (TableIndex)
+    {
+        *TableIndex = i;
+    }
+    if (TableDesc)
+    {
+        *TableDesc = &AcpiGbl_RootTableList.Tables[i];
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbTerminate
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Delete all internal ACPI tables
+ *
+ ******************************************************************************/
+
+void
+AcpiTbTerminate (
+    void)
+{
+    UINT32                  i;
+
+
+    ACPI_FUNCTION_TRACE (TbTerminate);
+
+
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+
+    /* Delete the individual tables */
+
+    for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; i++)
+    {
+        AcpiTbUninstallTable (&AcpiGbl_RootTableList.Tables[i]);
+    }
+
+    /*
+     * Delete the root table array if allocated locally. Array cannot be
+     * mapped, so we don't need to check for that flag.
+     */
+    if (AcpiGbl_RootTableList.Flags & ACPI_ROOT_ORIGIN_ALLOCATED)
+    {
+        ACPI_FREE (AcpiGbl_RootTableList.Tables);
+    }
+
+    AcpiGbl_RootTableList.Tables = NULL;
+    AcpiGbl_RootTableList.Flags = 0;
+    AcpiGbl_RootTableList.CurrentTableCount = 0;
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "ACPI Tables freed\n"));
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+    return_VOID;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbDeleteNamespaceByOwner
+ *
+ * PARAMETERS:  TableIndex          - Table index
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Delete all namespace objects created when this table was loaded.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbDeleteNamespaceByOwner (
+    UINT32                  TableIndex)
+{
+    ACPI_OWNER_ID           OwnerId;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (TbDeleteNamespaceByOwner);
+
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    if (TableIndex >= AcpiGbl_RootTableList.CurrentTableCount)
+    {
+        /* The table index does not exist */
+
+        (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+        return_ACPI_STATUS (AE_NOT_EXIST);
+    }
+
+    /* Get the owner ID for this table, used to delete namespace nodes */
+
+    OwnerId = AcpiGbl_RootTableList.Tables[TableIndex].OwnerId;
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+
+    /*
+     * Need to acquire the namespace writer lock to prevent interference
+     * with any concurrent namespace walks. The interpreter must be
+     * released during the deletion since the acquisition of the deletion
+     * lock may block, and also since the execution of a namespace walk
+     * must be allowed to use the interpreter.
+     */
+    (void) AcpiUtReleaseMutex (ACPI_MTX_INTERPRETER);
+    Status = AcpiUtAcquireWriteLock (&AcpiGbl_NamespaceRwLock);
+
+    AcpiNsDeleteNamespaceByOwner (OwnerId);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    AcpiUtReleaseWriteLock (&AcpiGbl_NamespaceRwLock);
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_INTERPRETER);
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbAllocateOwnerId
+ *
+ * PARAMETERS:  TableIndex          - Table index
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Allocates OwnerId in TableDesc
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbAllocateOwnerId (
+    UINT32                  TableIndex)
+{
+    ACPI_STATUS             Status = AE_BAD_PARAMETER;
+
+
+    ACPI_FUNCTION_TRACE (TbAllocateOwnerId);
+
+
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
+    {
+        Status = AcpiUtAllocateOwnerId (
+            &(AcpiGbl_RootTableList.Tables[TableIndex].OwnerId));
+    }
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbReleaseOwnerId
+ *
+ * PARAMETERS:  TableIndex          - Table index
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Releases OwnerId in TableDesc
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbReleaseOwnerId (
+    UINT32                  TableIndex)
+{
+    ACPI_STATUS             Status = AE_BAD_PARAMETER;
+
+
+    ACPI_FUNCTION_TRACE (TbReleaseOwnerId);
+
+
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
+    {
+        AcpiUtReleaseOwnerId (
+            &(AcpiGbl_RootTableList.Tables[TableIndex].OwnerId));
+        Status = AE_OK;
+    }
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbGetOwnerId
+ *
+ * PARAMETERS:  TableIndex          - Table index
+ *              OwnerId             - Where the table OwnerId is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: returns OwnerId for the ACPI table
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbGetOwnerId (
+    UINT32                  TableIndex,
+    ACPI_OWNER_ID           *OwnerId)
+{
+    ACPI_STATUS             Status = AE_BAD_PARAMETER;
+
+
+    ACPI_FUNCTION_TRACE (TbGetOwnerId);
+
+
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
+    {
+        *OwnerId = AcpiGbl_RootTableList.Tables[TableIndex].OwnerId;
+        Status = AE_OK;
+    }
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbIsTableLoaded
+ *
+ * PARAMETERS:  TableIndex          - Index into the root table
+ *
+ * RETURN:      Table Loaded Flag
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AcpiTbIsTableLoaded (
+    UINT32                  TableIndex)
+{
+    BOOLEAN                 IsLoaded = FALSE;
+
+
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
+    {
+        IsLoaded = (BOOLEAN)
+            (AcpiGbl_RootTableList.Tables[TableIndex].Flags &
+            ACPI_TABLE_IS_LOADED);
+    }
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+    return (IsLoaded);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbSetTableLoadedFlag
+ *
+ * PARAMETERS:  TableIndex          - Table index
+ *              IsLoaded            - TRUE if table is loaded, FALSE otherwise
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Sets the table loaded flag to either TRUE or FALSE.
+ *
+ ******************************************************************************/
+
+void
+AcpiTbSetTableLoadedFlag (
+    UINT32                  TableIndex,
+    BOOLEAN                 IsLoaded)
+{
+
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
+    {
+        if (IsLoaded)
+        {
+            AcpiGbl_RootTableList.Tables[TableIndex].Flags |=
+                ACPI_TABLE_IS_LOADED;
+        }
+        else
+        {
+            AcpiGbl_RootTableList.Tables[TableIndex].Flags &=
+                ~ACPI_TABLE_IS_LOADED;
+        }
+    }
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+}
diff --git a/usr/src/uts/intel/io/acpica/tables/tbfadt.c b/usr/src/uts/intel/io/acpica/tables/tbfadt.c
index e877320447..51eb49b42a 100644
--- a/usr/src/uts/intel/io/acpica/tables/tbfadt.c
+++ b/usr/src/uts/intel/io/acpica/tables/tbfadt.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __TBFADT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "actables.h"
@@ -52,42 +50,47 @@
 
 /* Local prototypes */
 
-static ACPI_INLINE void
+static void
 AcpiTbInitGenericAddress (
     ACPI_GENERIC_ADDRESS    *GenericAddress,
     UINT8                   SpaceId,
     UINT8                   ByteWidth,
-    UINT64                  Address);
+    UINT64                  Address,
+    const char              *RegisterName,
+    UINT8                   Flags);
 
 static void
 AcpiTbConvertFadt (
     void);
 
-static void
-AcpiTbValidateFadt (
-    void);
-
 static void
 AcpiTbSetupFadtRegisters (
     void);
 
+static UINT64
+AcpiTbSelectAddress (
+    char                    *RegisterName,
+    UINT32                  Address32,
+    UINT64                  Address64);
+
 
 /* Table for conversion of FADT to common internal format and FADT validation */
 
 typedef struct acpi_fadt_info
 {
-    char                    *Name;
+    const char              *Name;
     UINT16                  Address64;
     UINT16                  Address32;
     UINT16                  Length;
     UINT8                   DefaultLength;
-    UINT8                   Type;
+    UINT8                   Flags;
 
 } ACPI_FADT_INFO;
 
 #define ACPI_FADT_OPTIONAL          0
 #define ACPI_FADT_REQUIRED          1
 #define ACPI_FADT_SEPARATE_LENGTH   2
+#define ACPI_FADT_GPE_REGISTER      4
 
 static ACPI_FADT_INFO     FadtInfoTable[] =
 {
@@ -131,21 +134,21 @@ static ACPI_FADT_INFO     FadtInfoTable[] =
         ACPI_FADT_OFFSET (PmTimerBlock),
         ACPI_FADT_OFFSET (PmTimerLength),
         ACPI_PM_TIMER_WIDTH,
-        ACPI_FADT_REQUIRED},
+        ACPI_FADT_SEPARATE_LENGTH},         /* ACPI 5.0A: Timer is optional */
 
     {"Gpe0Block",
         ACPI_FADT_OFFSET (XGpe0Block),
         ACPI_FADT_OFFSET (Gpe0Block),
         ACPI_FADT_OFFSET (Gpe0BlockLength),
         0,
-        ACPI_FADT_SEPARATE_LENGTH},
+        ACPI_FADT_SEPARATE_LENGTH | ACPI_FADT_GPE_REGISTER},
 
     {"Gpe1Block",
         ACPI_FADT_OFFSET (XGpe1Block),
         ACPI_FADT_OFFSET (Gpe1Block),
         ACPI_FADT_OFFSET (Gpe1BlockLength),
         0,
-        ACPI_FADT_SEPARATE_LENGTH}
+        ACPI_FADT_SEPARATE_LENGTH | ACPI_FADT_GPE_REGISTER}
 };
 
 #define ACPI_FADT_INFO_ENTRIES \
@@ -191,8 +194,9 @@ static ACPI_FADT_PM_INFO    FadtPmInfoTable[] =
  *
  * PARAMETERS:  GenericAddress      - GAS struct to be initialized
  *              SpaceId             - ACPI Space ID for this register
- *              ByteWidth           - Width of this register, in bytes
+ *              ByteWidth           - Width of this register
  *              Address             - Address of the register
+ *              RegisterName        - ASCII name of the ACPI register
  *
  * RETURN:      None
  *
@@ -202,13 +206,40 @@ static ACPI_FADT_PM_INFO    FadtPmInfoTable[] =
  *
  ******************************************************************************/
 
-static ACPI_INLINE void
+static void
 AcpiTbInitGenericAddress (
     ACPI_GENERIC_ADDRESS    *GenericAddress,
     UINT8                   SpaceId,
     UINT8                   ByteWidth,
-    UINT64                  Address)
+    UINT64                  Address,
+    const char              *RegisterName,
+    UINT8                   Flags)
 {
+    UINT8                   BitWidth;
+
+
+    /*
+     * Bit width field in the GAS is only one byte long, 255 max.
+     * Check for BitWidth overflow in GAS.
+     */
+    BitWidth = (UINT8) (ByteWidth * 8);
+    if (ByteWidth > 31)     /* (31*8)=248, (32*8)=256 */
+    {
+        /*
+         * No error for GPE blocks, because we do not use the BitWidth
+         * for GPEs, the legacy length (ByteWidth) is used instead to
+         * allow for a large number of GPEs.
+         */
+        if (!(Flags & ACPI_FADT_GPE_REGISTER))
+        {
+            ACPI_ERROR ((AE_INFO,
+                "%s - 32-bit FADT register is too long (%u bytes, %u bits) "
+                "to convert to GAS struct - 255 bits max, truncating",
+                RegisterName, ByteWidth, (ByteWidth * 8)));
+        }
+
+        BitWidth = 255;
+    }
 
     /*
      * The 64-bit Address field is non-aligned in the byte packed
@@ -219,17 +250,83 @@ AcpiTbInitGenericAddress (
     /* All other fields are byte-wide */
 
     GenericAddress->SpaceId = SpaceId;
-    GenericAddress->BitWidth = (UINT8) ACPI_MUL_8 (ByteWidth);
+    GenericAddress->BitWidth = BitWidth;
     GenericAddress->BitOffset = 0;
     GenericAddress->AccessWidth = 0; /* Access width ANY */
 }
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbSelectAddress
+ *
+ * PARAMETERS:  RegisterName        - ASCII name of the ACPI register
+ *              Address32           - 32-bit address of the register
+ *              Address64           - 64-bit address of the register
+ *
+ * RETURN:      The resolved 64-bit address
+ *
+ * DESCRIPTION: Select between 32-bit and 64-bit versions of addresses within
+ *              the FADT. Used for the FACS and DSDT addresses.
+ *
+ * NOTES:
+ *
+ * Check for FACS and DSDT address mismatches. An address mismatch between
+ * the 32-bit and 64-bit address fields (FIRMWARE_CTRL/X_FIRMWARE_CTRL and
+ * DSDT/X_DSDT) could be a corrupted address field or it might indicate
+ * the presence of two FACS or two DSDT tables.
+ *
+ * November 2013:
+ * By default, as per the ACPICA specification, a valid 64-bit address is
+ * used regardless of the value of the 32-bit address. However, this
+ * behavior can be overridden via the AcpiGbl_Use32BitFadtAddresses flag.
+ *
+ ******************************************************************************/
+
+static UINT64
+AcpiTbSelectAddress (
+    char                    *RegisterName,
+    UINT32                  Address32,
+    UINT64                  Address64)
+{
+
+    if (!Address64)
+    {
+        /* 64-bit address is zero, use 32-bit address */
+
+        return ((UINT64) Address32);
+    }
+
+    if (Address32 &&
+       (Address64 != (UINT64) Address32))
+    {
+        /* Address mismatch between 32-bit and 64-bit versions */
+
+        ACPI_BIOS_WARNING ((AE_INFO,
+            "32/64X %s address mismatch in FADT: "
+            "0x%8.8X/0x%8.8X%8.8X, using %u-bit address",
+            RegisterName, Address32, ACPI_FORMAT_UINT64 (Address64),
+            AcpiGbl_Use32BitFadtAddresses ? 32 : 64));
+
+        /* 32-bit address override */
+
+        if (AcpiGbl_Use32BitFadtAddresses)
+        {
+            return ((UINT64) Address32);
+        }
+    }
+
+    /* Default is to use the 64-bit address */
+
+    return (Address64);
+}
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiTbParseFadt
  *
- * PARAMETERS:  TableIndex          - Index for the FADT
+ * PARAMETERS:  None
  *
  * RETURN:      None
  *
@@ -240,7 +337,7 @@ AcpiTbInitGenericAddress (
 
 void
 AcpiTbParseFadt (
-    UINT32                  TableIndex)
+    void)
 {
     UINT32                  Length;
     ACPI_TABLE_HEADER       *Table;
@@ -253,10 +350,10 @@ AcpiTbParseFadt (
      * Get a local copy of the FADT and convert it to a common format
      * Map entire FADT, assumed to be smaller than one page.
      */
-    Length = AcpiGbl_RootTableList.Tables[TableIndex].Length;
+    Length = AcpiGbl_RootTableList.Tables[AcpiGbl_FadtIndex].Length;
 
     Table = AcpiOsMapMemory (
-                AcpiGbl_RootTableList.Tables[TableIndex].Address, Length);
+        AcpiGbl_RootTableList.Tables[AcpiGbl_FadtIndex].Address, Length);
     if (!Table)
     {
         return;
@@ -278,15 +375,23 @@ AcpiTbParseFadt (
 
     /* Obtain the DSDT and FACS tables via their addresses within the FADT */
 
-    AcpiTbInstallTable ((ACPI_PHYSICAL_ADDRESS) AcpiGbl_FADT.XDsdt,
-        ACPI_SIG_DSDT, ACPI_TABLE_INDEX_DSDT);
+    AcpiTbInstallFixedTable ((ACPI_PHYSICAL_ADDRESS) AcpiGbl_FADT.XDsdt,
+        ACPI_SIG_DSDT, &AcpiGbl_DsdtIndex);
 
     /* If Hardware Reduced flag is set, there is no FACS */
 
     if (!AcpiGbl_ReducedHardware)
     {
-        AcpiTbInstallTable ((ACPI_PHYSICAL_ADDRESS) AcpiGbl_FADT.XFacs,
-            ACPI_SIG_FACS, ACPI_TABLE_INDEX_FACS);
+        if (AcpiGbl_FADT.Facs)
+        {
+            AcpiTbInstallFixedTable ((ACPI_PHYSICAL_ADDRESS) AcpiGbl_FADT.Facs,
+                ACPI_SIG_FACS, &AcpiGbl_FacsIndex);
+        }
+        if (AcpiGbl_FADT.XFacs)
+        {
+            AcpiTbInstallFixedTable ((ACPI_PHYSICAL_ADDRESS) AcpiGbl_FADT.XFacs,
+                ACPI_SIG_FACS, &AcpiGbl_XFacsIndex);
+        }
     }
 }
 
@@ -315,24 +420,25 @@ AcpiTbCreateLocalFadt (
 
     /*
      * Check if the FADT is larger than the largest table that we expect
-     * (the ACPI 5.0 version). If so, truncate the table, and issue
-     * a warning.
+     * (typically the current ACPI specification version). If so, truncate
+     * the table, and issue a warning.
      */
     if (Length > sizeof (ACPI_TABLE_FADT))
     {
-        ACPI_WARNING ((AE_INFO,
-            "FADT (revision %u) is longer than ACPI 5.0 version, "
+        ACPI_BIOS_WARNING ((AE_INFO,
+            "FADT (revision %u) is longer than %s length, "
             "truncating length %u to %u",
-            Table->Revision, Length, (UINT32) sizeof (ACPI_TABLE_FADT)));
+            Table->Revision, ACPI_FADT_CONFORMANCE, Length,
+            (UINT32) sizeof (ACPI_TABLE_FADT)));
     }
 
     /* Clear the entire local FADT */
 
-    ACPI_MEMSET (&AcpiGbl_FADT, 0, sizeof (ACPI_TABLE_FADT));
+    memset (&AcpiGbl_FADT, 0, sizeof (ACPI_TABLE_FADT));
 
     /* Copy the original FADT, up to sizeof (ACPI_TABLE_FADT) */
 
-    ACPI_MEMCPY (&AcpiGbl_FADT, Table,
+    memcpy (&AcpiGbl_FADT, Table,
         ACPI_MIN (Length, sizeof (ACPI_TABLE_FADT)));
 
     /* Take a copy of the Hardware Reduced flag */
@@ -347,10 +453,6 @@ AcpiTbCreateLocalFadt (
 
     AcpiTbConvertFadt ();
 
-    /* Validate FADT values now, before we make any changes */
-
-    AcpiTbValidateFadt ();
-
     /* Initialize the global ACPI register structures */
 
     AcpiTbSetupFadtRegisters ();
@@ -361,33 +463,43 @@ AcpiTbCreateLocalFadt (
  *
  * FUNCTION:    AcpiTbConvertFadt
  *
- * PARAMETERS:  None, uses AcpiGbl_FADT
+ * PARAMETERS:  None - AcpiGbl_FADT is used.
  *
  * RETURN:      None
  *
  * DESCRIPTION: Converts all versions of the FADT to a common internal format.
- *              Expand 32-bit addresses to 64-bit as necessary.
+ *              Expand 32-bit addresses to 64-bit as necessary. Also validate
+ *              important fields within the FADT.
  *
- * NOTE:        AcpiGbl_FADT must be of size (ACPI_TABLE_FADT),
- *              and must contain a copy of the actual FADT.
+ * NOTE:        AcpiGbl_FADT must be of size (ACPI_TABLE_FADT), and must
+ *              contain a copy of the actual BIOS-provided FADT.
  *
  * Notes on 64-bit register addresses:
  *
  * After this FADT conversion, later ACPICA code will only use the 64-bit "X"
  * fields of the FADT for all ACPI register addresses.
  *
- * The 64-bit "X" fields are optional extensions to the original 32-bit FADT
+ * The 64-bit X fields are optional extensions to the original 32-bit FADT
  * V1.0 fields. Even if they are present in the FADT, they are optional and
  * are unused if the BIOS sets them to zero. Therefore, we must copy/expand
- * 32-bit V1.0 fields if the corresponding X field is zero.
+ * 32-bit V1.0 fields to the 64-bit X fields if the the 64-bit X field is
+ * originally zero.
  *
- * For ACPI 1.0 FADTs, all 32-bit address fields are expanded to the
- * corresponding "X" fields in the internal FADT.
+ * For ACPI 1.0 FADTs (that contain no 64-bit addresses), all 32-bit address
+ * fields are expanded to the corresponding 64-bit X fields in the internal
+ * common FADT.
  *
  * For ACPI 2.0+ FADTs, all valid (non-zero) 32-bit address fields are expanded
- * to the corresponding 64-bit X fields. For compatibility with other ACPI
- * implementations, we ignore the 64-bit field if the 32-bit field is valid,
- * regardless of whether the host OS is 32-bit or 64-bit.
+ * to the corresponding 64-bit X fields, if the 64-bit field is originally
+ * zero. Adhering to the ACPI specification, we completely ignore the 32-bit
+ * field if the 64-bit field is valid, regardless of whether the host OS is
+ * 32-bit or 64-bit.
+ *
+ * Possible additional checks:
+ *  (AcpiGbl_FADT.Pm1EventLength >= 4)
+ *  (AcpiGbl_FADT.Pm1ControlLength >= 2)
+ *  (AcpiGbl_FADT.PmTimerLength >= 4)
+ *  Gpe block lengths must be multiple of 2
  *
  ******************************************************************************/
 
@@ -395,24 +507,14 @@ static void
 AcpiTbConvertFadt (
     void)
 {
+    const char              *Name;
     ACPI_GENERIC_ADDRESS    *Address64;
     UINT32                  Address32;
+    UINT8                   Length;
+    UINT8                   Flags;
     UINT32                  i;
 
 
-    /*
-     * Expand the 32-bit FACS and DSDT addresses to 64-bit as necessary.
-     * Later code will always use the X 64-bit field.
-     */
-    if (!AcpiGbl_FADT.XFacs)
-    {
-        AcpiGbl_FADT.XFacs = (UINT64) AcpiGbl_FADT.Facs;
-    }
-    if (!AcpiGbl_FADT.XDsdt)
-    {
-        AcpiGbl_FADT.XDsdt = (UINT64) AcpiGbl_FADT.Dsdt;
-    }
-
     /*
      * For ACPI 1.0 FADTs (revision 1 or 2), ensure that reserved fields which
      * should be zero are indeed zero. This will workaround BIOSs that
@@ -440,112 +542,11 @@ AcpiTbConvertFadt (
     AcpiGbl_FADT.Header.Length = sizeof (ACPI_TABLE_FADT);
 
     /*
-     * Expand the ACPI 1.0 32-bit addresses to the ACPI 2.0 64-bit "X"
-     * generic address structures as necessary. Later code will always use
-     * the 64-bit address structures.
-     *
-     * March 2009:
-     * We now always use the 32-bit address if it is valid (non-null). This
-     * is not in accordance with the ACPI specification which states that
-     * the 64-bit address supersedes the 32-bit version, but we do this for
-     * compatibility with other ACPI implementations. Most notably, in the
-     * case where both the 32 and 64 versions are non-null, we use the 32-bit
-     * version. This is the only address that is guaranteed to have been
-     * tested by the BIOS manufacturer.
+     * Expand the 32-bit DSDT addresses to 64-bit as necessary.
+     * Later ACPICA code will always use the X 64-bit field.
      */
-    for (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++)
-    {
-        Address32 = *ACPI_ADD_PTR (UINT32,
-            &AcpiGbl_FADT, FadtInfoTable[i].Address32);
-
-        Address64 = ACPI_ADD_PTR (ACPI_GENERIC_ADDRESS,
-            &AcpiGbl_FADT, FadtInfoTable[i].Address64);
-
-        /*
-         * If both 32- and 64-bit addresses are valid (non-zero),
-         * they must match.
-         */
-        if (Address64->Address && Address32 &&
-           (Address64->Address != (UINT64) Address32))
-        {
-            ACPI_ERROR ((AE_INFO,
-                "32/64X address mismatch in %s: 0x%8.8X/0x%8.8X%8.8X, using 32",
-                FadtInfoTable[i].Name, Address32,
-                ACPI_FORMAT_UINT64 (Address64->Address)));
-        }
-
-        /* Always use 32-bit address if it is valid (non-null) */
-
-        if (Address32)
-        {
-            /*
-             * Copy the 32-bit address to the 64-bit GAS structure. The
-             * Space ID is always I/O for 32-bit legacy address fields
-             */
-            AcpiTbInitGenericAddress (Address64, ACPI_ADR_SPACE_SYSTEM_IO,
-                *ACPI_ADD_PTR (UINT8, &AcpiGbl_FADT, FadtInfoTable[i].Length),
-                (UINT64) Address32);
-        }
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbValidateFadt
- *
- * PARAMETERS:  Table           - Pointer to the FADT to be validated
- *
- * RETURN:      None
- *
- * DESCRIPTION: Validate various important fields within the FADT. If a problem
- *              is found, issue a message, but no status is returned.
- *              Used by both the table manager and the disassembler.
- *
- * Possible additional checks:
- * (AcpiGbl_FADT.Pm1EventLength >= 4)
- * (AcpiGbl_FADT.Pm1ControlLength >= 2)
- * (AcpiGbl_FADT.PmTimerLength >= 4)
- * Gpe block lengths must be multiple of 2
- *
- ******************************************************************************/
-
-static void
-AcpiTbValidateFadt (
-    void)
-{
-    char                    *Name;
-    ACPI_GENERIC_ADDRESS    *Address64;
-    UINT8                   Length;
-    UINT32                  i;
-
-
-    /*
-     * Check for FACS and DSDT address mismatches. An address mismatch between
-     * the 32-bit and 64-bit address fields (FIRMWARE_CTRL/X_FIRMWARE_CTRL and
-     * DSDT/X_DSDT) would indicate the presence of two FACS or two DSDT tables.
-     */
-    if (AcpiGbl_FADT.Facs &&
-        (AcpiGbl_FADT.XFacs != (UINT64) AcpiGbl_FADT.Facs))
-    {
-        ACPI_WARNING ((AE_INFO,
-            "32/64X FACS address mismatch in FADT - "
-            "0x%8.8X/0x%8.8X%8.8X, using 32",
-            AcpiGbl_FADT.Facs, ACPI_FORMAT_UINT64 (AcpiGbl_FADT.XFacs)));
-
-        AcpiGbl_FADT.XFacs = (UINT64) AcpiGbl_FADT.Facs;
-    }
-
-    if (AcpiGbl_FADT.Dsdt &&
-        (AcpiGbl_FADT.XDsdt != (UINT64) AcpiGbl_FADT.Dsdt))
-    {
-        ACPI_WARNING ((AE_INFO,
-            "32/64X DSDT address mismatch in FADT - "
-            "0x%8.8X/0x%8.8X%8.8X, using 32",
-            AcpiGbl_FADT.Dsdt, ACPI_FORMAT_UINT64 (AcpiGbl_FADT.XDsdt)));
-
-        AcpiGbl_FADT.XDsdt = (UINT64) AcpiGbl_FADT.Dsdt;
-    }
+    AcpiGbl_FADT.XDsdt = AcpiTbSelectAddress ("DSDT",
+        AcpiGbl_FADT.Dsdt, AcpiGbl_FADT.XDsdt);
 
     /* If Hardware Reduced flag is set, we are all done */
 
@@ -559,42 +560,113 @@ AcpiTbValidateFadt (
     for (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++)
     {
         /*
-         * Generate pointer to the 64-bit address, get the register
-         * length (width) and the register name
+         * Get the 32-bit and 64-bit addresses, as well as the register
+         * length and register name.
          */
+        Address32 = *ACPI_ADD_PTR (UINT32,
+            &AcpiGbl_FADT, FadtInfoTable[i].Address32);
+
         Address64 = ACPI_ADD_PTR (ACPI_GENERIC_ADDRESS,
-                        &AcpiGbl_FADT, FadtInfoTable[i].Address64);
+            &AcpiGbl_FADT, FadtInfoTable[i].Address64);
+
         Length = *ACPI_ADD_PTR (UINT8,
-                        &AcpiGbl_FADT, FadtInfoTable[i].Length);
+            &AcpiGbl_FADT, FadtInfoTable[i].Length);
+
         Name = FadtInfoTable[i].Name;
+        Flags = FadtInfoTable[i].Flags;
+
+        /*
+         * Expand the ACPI 1.0 32-bit addresses to the ACPI 2.0 64-bit "X"
+         * generic address structures as necessary. Later code will always use
+         * the 64-bit address structures.
+         *
+         * November 2013:
+         * Now always use the 64-bit address if it is valid (non-zero), in
+         * accordance with the ACPI specification which states that a 64-bit
+         * address supersedes the 32-bit version. This behavior can be
+         * overridden by the AcpiGbl_Use32BitFadtAddresses flag.
+         *
+         * During 64-bit address construction and verification,
+         * these cases are handled:
+         *
+         * Address32 zero, Address64 [don't care]   - Use Address64
+         *
+         * Address32 non-zero, Address64 zero       - Copy/use Address32
+         * Address32 non-zero == Address64 non-zero - Use Address64
+         * Address32 non-zero != Address64 non-zero - Warning, use Address64
+         *
+         * Override: if AcpiGbl_Use32BitFadtAddresses is TRUE, and:
+         * Address32 non-zero != Address64 non-zero - Warning, copy/use Address32
+         *
+         * Note: SpaceId is always I/O for 32-bit legacy address fields
+         */
+        if (Address32)
+        {
+            if (!Address64->Address)
+            {
+                /* 64-bit address is zero, use 32-bit address */
+
+                AcpiTbInitGenericAddress (Address64,
+                    ACPI_ADR_SPACE_SYSTEM_IO,
+                    *ACPI_ADD_PTR (UINT8, &AcpiGbl_FADT,
+                        FadtInfoTable[i].Length),
+                    (UINT64) Address32, Name, Flags);
+            }
+            else if (Address64->Address != (UINT64) Address32)
+            {
+                /* Address mismatch */
+
+                ACPI_BIOS_WARNING ((AE_INFO,
+                    "32/64X address mismatch in FADT/%s: "
+                    "0x%8.8X/0x%8.8X%8.8X, using %u-bit address",
+                    Name, Address32,
+                    ACPI_FORMAT_UINT64 (Address64->Address),
+                    AcpiGbl_Use32BitFadtAddresses ? 32 : 64));
+
+                if (AcpiGbl_Use32BitFadtAddresses)
+                {
+                    /* 32-bit address override */
+
+                    AcpiTbInitGenericAddress (Address64,
+                        ACPI_ADR_SPACE_SYSTEM_IO,
+                        *ACPI_ADD_PTR (UINT8, &AcpiGbl_FADT,
+                            FadtInfoTable[i].Length),
+                        (UINT64) Address32, Name, Flags);
+                }
+            }
+        }
 
         /*
          * For each extended field, check for length mismatch between the
          * legacy length field and the corresponding 64-bit X length field.
+         * Note: If the legacy length field is > 0xFF bits, ignore this
+         * check. (GPE registers can be larger than the 64-bit GAS structure
+         * can accomodate, 0xFF bits).
          */
         if (Address64->Address &&
+           (ACPI_MUL_8 (Length) <= ACPI_UINT8_MAX) &&
            (Address64->BitWidth != ACPI_MUL_8 (Length)))
         {
-            ACPI_WARNING ((AE_INFO,
-                "32/64X length mismatch in %s: %u/%u",
+            ACPI_BIOS_WARNING ((AE_INFO,
+                "32/64X length mismatch in FADT/%s: %u/%u",
                 Name, ACPI_MUL_8 (Length), Address64->BitWidth));
         }
 
-        if (FadtInfoTable[i].Type & ACPI_FADT_REQUIRED)
+        if (FadtInfoTable[i].Flags & ACPI_FADT_REQUIRED)
         {
             /*
-             * Field is required (PM1aEvent, PM1aControl, PmTimer).
+             * Field is required (PM1aEvent, PM1aControl).
              * Both the address and length must be non-zero.
              */
             if (!Address64->Address || !Length)
             {
-                ACPI_ERROR ((AE_INFO,
-                    "Required field %s has zero address and/or length:"
-                    " 0x%8.8X%8.8X/0x%X",
+                ACPI_BIOS_ERROR ((AE_INFO,
+                    "Required FADT field %s has zero address and/or length: "
+                    "0x%8.8X%8.8X/0x%X",
                     Name, ACPI_FORMAT_UINT64 (Address64->Address), Length));
             }
         }
-        else if (FadtInfoTable[i].Type & ACPI_FADT_SEPARATE_LENGTH)
+        else if (FadtInfoTable[i].Flags & ACPI_FADT_SEPARATE_LENGTH)
         {
             /*
              * Field is optional (PM2Control, GPE0, GPE1) AND has its own
@@ -604,10 +676,12 @@ AcpiTbValidateFadt (
             if ((Address64->Address && !Length) ||
                 (!Address64->Address && Length))
             {
-                ACPI_WARNING ((AE_INFO,
-                    "Optional field %s has zero address or length: "
-                    "0x%8.8X%8.8X/0x%X",
-                    Name, ACPI_FORMAT_UINT64 (Address64->Address), Length));
+                ACPI_BIOS_WARNING ((AE_INFO,
+                    "Optional FADT field %s has valid %s but zero %s: "
+                    "0x%8.8X%8.8X/0x%X", Name,
+                    (Length ? "Length" : "Address"),
+                    (Length ? "Address": "Length"),
+                    ACPI_FORMAT_UINT64 (Address64->Address), Length));
             }
         }
     }
@@ -656,8 +730,8 @@ AcpiTbSetupFadtRegisters (
                 (FadtInfoTable[i].DefaultLength > 0) &&
                 (FadtInfoTable[i].DefaultLength != Target64->BitWidth))
             {
-                ACPI_WARNING ((AE_INFO,
-                    "Invalid length for %s: %u, using default %u",
+                ACPI_BIOS_WARNING ((AE_INFO,
+                    "Invalid length for FADT/%s: %u, using default %u",
                     FadtInfoTable[i].Name, Target64->BitWidth,
                     FadtInfoTable[i].DefaultLength));
 
@@ -700,8 +774,8 @@ AcpiTbSetupFadtRegisters (
             AcpiTbInitGenericAddress (FadtPmInfoTable[i].Target,
                 Source64->SpaceId, Pm1RegisterByteWidth,
                 Source64->Address +
-                    (FadtPmInfoTable[i].RegisterNum * Pm1RegisterByteWidth));
+                    (FadtPmInfoTable[i].RegisterNum * Pm1RegisterByteWidth),
+                "PmRegisters", 0);
         }
     }
 }
-
diff --git a/usr/src/uts/intel/io/acpica/tables/tbfind.c b/usr/src/uts/intel/io/acpica/tables/tbfind.c
index d7e2440b32..32839a3cd3 100644
--- a/usr/src/uts/intel/io/acpica/tables/tbfind.c
+++ b/usr/src/uts/intel/io/acpica/tables/tbfind.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __TBFIND_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "actables.h"
@@ -75,27 +73,42 @@ AcpiTbFindTable (
     char                    *OemTableId,
     UINT32                  *TableIndex)
 {
-    UINT32                  i;
     ACPI_STATUS             Status;
     ACPI_TABLE_HEADER       Header;
+    UINT32                  i;
 
 
     ACPI_FUNCTION_TRACE (TbFindTable);
 
 
+    /* Validate the input table signature */
+
+    if (!AcpiUtValidNameseg (Signature))
+    {
+        return_ACPI_STATUS (AE_BAD_SIGNATURE);
+    }
+
+    /* Don't allow the OEM strings to be too long */
+
+    if ((strlen (OemId) > ACPI_OEM_ID_SIZE) ||
+        (strlen (OemTableId) > ACPI_OEM_TABLE_ID_SIZE))
+    {
+        return_ACPI_STATUS (AE_AML_STRING_LIMIT);
+    }
+
     /* Normalize the input strings */
 
-    ACPI_MEMSET (&Header, 0, sizeof (ACPI_TABLE_HEADER));
-    ACPI_STRNCPY (Header.Signature, Signature, ACPI_NAME_SIZE);
-    ACPI_STRNCPY (Header.OemId, OemId, ACPI_OEM_ID_SIZE);
-    ACPI_STRNCPY (Header.OemTableId, OemTableId, ACPI_OEM_TABLE_ID_SIZE);
+    memset (&Header, 0, sizeof (ACPI_TABLE_HEADER));
+    ACPI_MOVE_NAME (Header.Signature, Signature);
+    strncpy (Header.OemId, OemId, ACPI_OEM_ID_SIZE);
+    strncpy (Header.OemTableId, OemTableId, ACPI_OEM_TABLE_ID_SIZE);
 
     /* Search for the table */
 
     for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; ++i)
     {
-        if (ACPI_MEMCMP (&(AcpiGbl_RootTableList.Tables[i].Signature),
-                            Header.Signature, ACPI_NAME_SIZE))
+        if (memcmp (&(AcpiGbl_RootTableList.Tables[i].Signature),
+            Header.Signature, ACPI_NAME_SIZE))
         {
             /* Not the requested table */
 
@@ -108,7 +121,7 @@ AcpiTbFindTable (
         {
             /* Table is not currently mapped, map it */
 
-            Status = AcpiTbVerifyTable (&AcpiGbl_RootTableList.Tables[i]);
+            Status = AcpiTbValidateTable (&AcpiGbl_RootTableList.Tables[i]);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -122,14 +135,14 @@ AcpiTbFindTable (
 
         /* Check for table match on all IDs */
 
-        if (!ACPI_MEMCMP (AcpiGbl_RootTableList.Tables[i].Pointer->Signature,
-                            Header.Signature, ACPI_NAME_SIZE) &&
+        if (!memcmp (AcpiGbl_RootTableList.Tables[i].Pointer->Signature,
+                Header.Signature, ACPI_NAME_SIZE) &&
             (!OemId[0] ||
-             !ACPI_MEMCMP (AcpiGbl_RootTableList.Tables[i].Pointer->OemId,
-                             Header.OemId, ACPI_OEM_ID_SIZE)) &&
+             !memcmp (AcpiGbl_RootTableList.Tables[i].Pointer->OemId,
+                 Header.OemId, ACPI_OEM_ID_SIZE)) &&
             (!OemTableId[0] ||
-             !ACPI_MEMCMP (AcpiGbl_RootTableList.Tables[i].Pointer->OemTableId,
-                             Header.OemTableId, ACPI_OEM_TABLE_ID_SIZE)))
+             !memcmp (AcpiGbl_RootTableList.Tables[i].Pointer->OemTableId,
+                 Header.OemTableId, ACPI_OEM_TABLE_ID_SIZE)))
         {
             *TableIndex = i;
 
diff --git a/usr/src/uts/intel/io/acpica/tables/tbinstal.c b/usr/src/uts/intel/io/acpica/tables/tbinstal.c
index f100ab43f7..78e8b4ec8b 100644
--- a/usr/src/uts/intel/io/acpica/tables/tbinstal.c
+++ b/usr/src/uts/intel/io/acpica/tables/tbinstal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,768 +41,488 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __TBINSTAL_C__
-
 #include "acpi.h"
 #include "accommon.h"
-#include "acnamesp.h"
 #include "actables.h"
 
-
 #define _COMPONENT          ACPI_TABLES
         ACPI_MODULE_NAME    ("tbinstal")
 
+/* Local prototypes */
 
-/******************************************************************************
+static BOOLEAN
+AcpiTbCompareTables (
+    ACPI_TABLE_DESC         *TableDesc,
+    UINT32                  TableIndex);
+
+
+/*******************************************************************************
  *
- * FUNCTION:    AcpiTbVerifyTable
+ * FUNCTION:    AcpiTbCompareTables
  *
- * PARAMETERS:  TableDesc           - table
+ * PARAMETERS:  TableDesc           - Table 1 descriptor to be compared
+ *              TableIndex          - Index of table 2 to be compared
  *
- * RETURN:      Status
+ * RETURN:      TRUE if both tables are identical.
  *
- * DESCRIPTION: this function is called to verify and map table
+ * DESCRIPTION: This function compares a table with another table that has
+ *              already been installed in the root table list.
  *
- *****************************************************************************/
+ ******************************************************************************/
 
-ACPI_STATUS
-AcpiTbVerifyTable (
-    ACPI_TABLE_DESC         *TableDesc)
+static BOOLEAN
+AcpiTbCompareTables (
+    ACPI_TABLE_DESC         *TableDesc,
+    UINT32                  TableIndex)
 {
     ACPI_STATUS             Status = AE_OK;
+    BOOLEAN                 IsIdentical;
+    ACPI_TABLE_HEADER       *Table;
+    UINT32                  TableLength;
+    UINT8                   TableFlags;
 
 
-    ACPI_FUNCTION_TRACE (TbVerifyTable);
-
-
-    /* Map the table if necessary */
-
-    if (!TableDesc->Pointer)
+    Status = AcpiTbAcquireTable (&AcpiGbl_RootTableList.Tables[TableIndex],
+        &Table, &TableLength, &TableFlags);
+    if (ACPI_FAILURE (Status))
     {
-        if ((TableDesc->Flags & ACPI_TABLE_ORIGIN_MASK) ==
-            ACPI_TABLE_ORIGIN_MAPPED)
-        {
-            TableDesc->Pointer = AcpiOsMapMemory (
-                TableDesc->Address, TableDesc->Length);
-        }
-
-        if (!TableDesc->Pointer)
-        {
-            return_ACPI_STATUS (AE_NO_MEMORY);
-        }
+        return (FALSE);
     }
 
-    /* FACS is the odd table, has no standard ACPI header and no checksum */
-
-    if (!ACPI_COMPARE_NAME (&TableDesc->Signature, ACPI_SIG_FACS))
-    {
-        /* Always calculate checksum, ignore bad checksum if requested */
+    /*
+     * Check for a table match on the entire table length,
+     * not just the header.
+     */
+    IsIdentical = (BOOLEAN)((TableDesc->Length != TableLength ||
+        memcmp (TableDesc->Pointer, Table, TableLength)) ?
+        FALSE : TRUE);
 
-        Status = AcpiTbVerifyChecksum (TableDesc->Pointer, TableDesc->Length);
-    }
+    /* Release the acquired table */
 
-    return_ACPI_STATUS (Status);
+    AcpiTbReleaseTable (Table, TableLength, TableFlags);
+    return (IsIdentical);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiTbAddTable
+ * FUNCTION:    AcpiTbInstallTableWithOverride
  *
- * PARAMETERS:  TableDesc           - Table descriptor
- *              TableIndex          - Where the table index is returned
+ * PARAMETERS:  NewTableDesc            - New table descriptor to install
+ *              Override                - Whether override should be performed
+ *              TableIndex              - Where the table index is returned
  *
- * RETURN:      Status
+ * RETURN:      None
  *
- * DESCRIPTION: This function is called to add an ACPI table. It is used to
- *              dynamically load tables via the Load and LoadTable AML
- *              operators.
+ * DESCRIPTION: Install an ACPI table into the global data structure. The
+ *              table override mechanism is called to allow the host
+ *              OS to replace any table before it is installed in the root
+ *              table array.
  *
  ******************************************************************************/
 
-ACPI_STATUS
-AcpiTbAddTable (
-    ACPI_TABLE_DESC         *TableDesc,
+void
+AcpiTbInstallTableWithOverride (
+    ACPI_TABLE_DESC         *NewTableDesc,
+    BOOLEAN                 Override,
     UINT32                  *TableIndex)
 {
     UINT32                  i;
-    ACPI_STATUS             Status = AE_OK;
-
-
-    ACPI_FUNCTION_TRACE (TbAddTable);
+    ACPI_STATUS             Status;
 
 
-    if (!TableDesc->Pointer)
+    Status = AcpiTbGetNextTableDescriptor (&i, NULL);
+    if (ACPI_FAILURE (Status))
     {
-        Status = AcpiTbVerifyTable (TableDesc);
-        if (ACPI_FAILURE (Status) || !TableDesc->Pointer)
-        {
-            return_ACPI_STATUS (Status);
-        }
+        return;
     }
 
     /*
-     * Validate the incoming table signature.
+     * ACPI Table Override:
      *
-     * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
-     * 2) We added support for OEMx tables, signature "OEM".
-     * 3) Valid tables were encountered with a null signature, so we just
-     *    gave up on validating the signature, (05/2008).
-     * 4) We encountered non-AML tables such as the MADT, which caused
-     *    interpreter errors and kernel faults. So now, we once again allow
-     *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
+     * Before we install the table, let the host OS override it with a new
+     * one if desired. Any table within the RSDT/XSDT can be replaced,
+     * including the DSDT which is pointed to by the FADT.
      */
-    if ((TableDesc->Pointer->Signature[0] != 0x00) &&
-       (!ACPI_COMPARE_NAME (TableDesc->Pointer->Signature, ACPI_SIG_SSDT)) &&
-       (ACPI_STRNCMP (TableDesc->Pointer->Signature, "OEM", 3)))
+    if (Override)
     {
-        ACPI_ERROR ((AE_INFO,
-            "Table has invalid signature [%4.4s] (0x%8.8X), must be SSDT or OEMx",
-            AcpiUtValidAcpiName (*(UINT32 *) TableDesc->Pointer->Signature) ?
-                TableDesc->Pointer->Signature : "????",
-            *(UINT32 *) TableDesc->Pointer->Signature));
-
-        return_ACPI_STATUS (AE_BAD_SIGNATURE);
+        AcpiTbOverrideTable (NewTableDesc);
     }
 
-    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    AcpiTbInitTableDescriptor (&AcpiGbl_RootTableList.Tables[i],
+        NewTableDesc->Address, NewTableDesc->Flags, NewTableDesc->Pointer);
 
-    /* Check if table is already registered */
+    AcpiTbPrintTableHeader (NewTableDesc->Address, NewTableDesc->Pointer);
 
-    for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; ++i)
-    {
-        if (!AcpiGbl_RootTableList.Tables[i].Pointer)
-        {
-            Status = AcpiTbVerifyTable (&AcpiGbl_RootTableList.Tables[i]);
-            if (ACPI_FAILURE (Status) ||
-                !AcpiGbl_RootTableList.Tables[i].Pointer)
-            {
-                continue;
-            }
-        }
-
-        /*
-         * Check for a table match on the entire table length,
-         * not just the header.
-         */
-        if (TableDesc->Length != AcpiGbl_RootTableList.Tables[i].Length)
-        {
-            continue;
-        }
+    /* This synchronizes AcpiGbl_DsdtIndex */
 
-        if (ACPI_MEMCMP (TableDesc->Pointer,
-                AcpiGbl_RootTableList.Tables[i].Pointer,
-                AcpiGbl_RootTableList.Tables[i].Length))
-        {
-            continue;
-        }
+    *TableIndex = i;
 
-        /*
-         * Note: the current mechanism does not unregister a table if it is
-         * dynamically unloaded. The related namespace entries are deleted,
-         * but the table remains in the root table list.
-         *
-         * The assumption here is that the number of different tables that
-         * will be loaded is actually small, and there is minimal overhead
-         * in just keeping the table in case it is needed again.
-         *
-         * If this assumption changes in the future (perhaps on large
-         * machines with many table load/unload operations), tables will
-         * need to be unregistered when they are unloaded, and slots in the
-         * root table list should be reused when empty.
-         */
-
-        /*
-         * Table is already registered.
-         * We can delete the table that was passed as a parameter.
-         */
-        AcpiTbDeleteTable (TableDesc);
-        *TableIndex = i;
-
-        if (AcpiGbl_RootTableList.Tables[i].Flags & ACPI_TABLE_IS_LOADED)
-        {
-            /* Table is still loaded, this is an error */
-
-            Status = AE_ALREADY_EXISTS;
-            goto Release;
-        }
-        else
-        {
-            /* Table was unloaded, allow it to be reloaded */
-
-            TableDesc->Pointer = AcpiGbl_RootTableList.Tables[i].Pointer;
-            TableDesc->Address = AcpiGbl_RootTableList.Tables[i].Address;
-            Status = AE_OK;
-            goto PrintHeader;
-        }
-    }
-
-    /*
-     * ACPI Table Override:
-     * Allow the host to override dynamically loaded tables.
-     * NOTE: the table is fully mapped at this point, and the mapping will
-     * be deleted by TbTableOverride if the table is actually overridden.
-     */
-    (void) AcpiTbTableOverride (TableDesc->Pointer, TableDesc);
-
-    /* Add the table to the global root table list */
+    /* Set the global integer width (based upon revision of the DSDT) */
 
-    Status = AcpiTbStoreTable (TableDesc->Address, TableDesc->Pointer,
-                TableDesc->Length, TableDesc->Flags, TableIndex);
-    if (ACPI_FAILURE (Status))
+    if (i == AcpiGbl_DsdtIndex)
     {
-        goto Release;
+        AcpiUtSetIntegerWidth (NewTableDesc->Pointer->Revision);
     }
-
-PrintHeader:
-    AcpiTbPrintTableHeader (TableDesc->Address, TableDesc->Pointer);
-
-Release:
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-    return_ACPI_STATUS (Status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiTbTableOverride
+ * FUNCTION:    AcpiTbInstallFixedTable
  *
- * PARAMETERS:  TableHeader         - Header for the original table
- *              TableDesc           - Table descriptor initialized for the
- *                                    original table. May or may not be mapped.
+ * PARAMETERS:  Address                 - Physical address of DSDT or FACS
+ *              Signature               - Table signature, NULL if no need to
+ *                                        match
+ *              TableIndex              - Where the table index is returned
  *
- * RETURN:      Pointer to the entire new table. NULL if table not overridden.
- *              If overridden, installs the new table within the input table
- *              descriptor.
+ * RETURN:      Status
  *
- * DESCRIPTION: Attempt table override by calling the OSL override functions.
- *              Note: If the table is overridden, then the entire new table
- *              is mapped and returned by this function.
+ * DESCRIPTION: Install a fixed ACPI table (DSDT/FACS) into the global data
+ *              structure.
  *
  ******************************************************************************/
 
-ACPI_TABLE_HEADER *
-AcpiTbTableOverride (
-    ACPI_TABLE_HEADER       *TableHeader,
-    ACPI_TABLE_DESC         *TableDesc)
+ACPI_STATUS
+AcpiTbInstallFixedTable (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    char                    *Signature,
+    UINT32                  *TableIndex)
 {
+    ACPI_TABLE_DESC         NewTableDesc;
     ACPI_STATUS             Status;
-    ACPI_TABLE_HEADER       *NewTable = NULL;
-    ACPI_PHYSICAL_ADDRESS   NewAddress = 0;
-    UINT32                  NewTableLength = 0;
-    UINT8                   NewFlags;
-    char                    *OverrideType;
 
 
-    /* (1) Attempt logical override (returns a logical address) */
+    ACPI_FUNCTION_TRACE (TbInstallFixedTable);
+
 
-    Status = AcpiOsTableOverride (TableHeader, &NewTable);
-    if (ACPI_SUCCESS (Status) && NewTable)
+    if (!Address)
     {
-        NewAddress = ACPI_PTR_TO_PHYSADDR (NewTable);
-        NewTableLength = NewTable->Length;
-        NewFlags = ACPI_TABLE_ORIGIN_OVERRIDE;
-        OverrideType = "Logical";
-        goto FinishOverride;
+        ACPI_ERROR ((AE_INFO, "Null physical address for ACPI table [%s]",
+            Signature));
+        return (AE_NO_MEMORY);
     }
 
-    /* (2) Attempt physical override (returns a physical address) */
+    /* Fill a table descriptor for validation */
 
-    Status = AcpiOsPhysicalTableOverride (TableHeader,
-        &NewAddress, &NewTableLength);
-    if (ACPI_SUCCESS (Status) && NewAddress && NewTableLength)
+    Status = AcpiTbAcquireTempTable (&NewTableDesc, Address,
+        ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
+    if (ACPI_FAILURE (Status))
     {
-        /* Map the entire new table */
-
-        NewTable = AcpiOsMapMemory (NewAddress, NewTableLength);
-        if (!NewTable)
-        {
-            ACPI_EXCEPTION ((AE_INFO, AE_NO_MEMORY,
-                "%4.4s %p Attempted physical table override failed",
-                TableHeader->Signature,
-                ACPI_CAST_PTR (void, TableDesc->Address)));
-            return (NULL);
-        }
-
-        OverrideType = "Physical";
-        NewFlags = ACPI_TABLE_ORIGIN_MAPPED;
-        goto FinishOverride;
+        ACPI_ERROR ((AE_INFO, "Could not acquire table length at %8.8X%8.8X",
+            ACPI_FORMAT_UINT64 (Address)));
+        return_ACPI_STATUS (Status);
     }
 
-    return (NULL); /* There was no override */
-
+    /* Validate and verify a table before installation */
 
-FinishOverride:
-
-    ACPI_INFO ((AE_INFO,
-        "%4.4s %p %s table override, new table: %p",
-        TableHeader->Signature,
-        ACPI_CAST_PTR (void, TableDesc->Address),
-        OverrideType, NewTable));
+    Status = AcpiTbVerifyTempTable (&NewTableDesc, Signature);
+    if (ACPI_FAILURE (Status))
+    {
+        goto ReleaseAndExit;
+    }
 
-    /* We can now unmap/delete the original table (if fully mapped) */
+    /* Add the table to the global root table list */
 
-    AcpiTbDeleteTable (TableDesc);
+    AcpiTbInstallTableWithOverride (&NewTableDesc, TRUE, TableIndex);
 
-    /* Setup descriptor for the new table */
+ReleaseAndExit:
 
-    TableDesc->Address = NewAddress;
-    TableDesc->Pointer = NewTable;
-    TableDesc->Length = NewTableLength;
-    TableDesc->Flags = NewFlags;
+    /* Release the temporary table descriptor */
 
-    return (NewTable);
+    AcpiTbReleaseTempTable (&NewTableDesc);
+    return_ACPI_STATUS (Status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiTbResizeRootTableList
+ * FUNCTION:    AcpiTbInstallStandardTable
  *
- * PARAMETERS:  None
+ * PARAMETERS:  Address             - Address of the table (might be a virtual
+ *                                    address depending on the TableFlags)
+ *              Flags               - Flags for the table
+ *              Reload              - Whether reload should be performed
+ *              Override            - Whether override should be performed
+ *              TableIndex          - Where the table index is returned
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Expand the size of global table array
+ * DESCRIPTION: This function is called to install an ACPI table that is
+ *              neither DSDT nor FACS (a "standard" table.)
+ *              When this function is called by "Load" or "LoadTable" opcodes,
+ *              or by AcpiLoadTable() API, the "Reload" parameter is set.
+ *              After sucessfully returning from this function, table is
+ *              "INSTALLED" but not "VALIDATED".
  *
  ******************************************************************************/
 
 ACPI_STATUS
-AcpiTbResizeRootTableList (
-    void)
+AcpiTbInstallStandardTable (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    UINT8                   Flags,
+    BOOLEAN                 Reload,
+    BOOLEAN                 Override,
+    UINT32                  *TableIndex)
 {
-    ACPI_TABLE_DESC         *Tables;
+    UINT32                  i;
+    ACPI_STATUS             Status = AE_OK;
+    ACPI_TABLE_DESC         NewTableDesc;
 
 
-    ACPI_FUNCTION_TRACE (TbResizeRootTableList);
+    ACPI_FUNCTION_TRACE (TbInstallStandardTable);
 
 
-    /* AllowResize flag is a parameter to AcpiInitializeTables */
+    /* Acquire a temporary table descriptor for validation */
 
-    if (!(AcpiGbl_RootTableList.Flags & ACPI_ROOT_ALLOW_RESIZE))
+    Status = AcpiTbAcquireTempTable (&NewTableDesc, Address, Flags);
+    if (ACPI_FAILURE (Status))
     {
-        ACPI_ERROR ((AE_INFO, "Resize of Root Table Array is not allowed"));
-        return_ACPI_STATUS (AE_SUPPORT);
+        ACPI_ERROR ((AE_INFO,
+            "Could not acquire table length at %8.8X%8.8X",
+            ACPI_FORMAT_UINT64 (Address)));
+        return_ACPI_STATUS (Status);
     }
 
-    /* Increase the Table Array size */
-
-    Tables = ACPI_ALLOCATE_ZEROED (
-        ((ACPI_SIZE) AcpiGbl_RootTableList.MaxTableCount +
-            ACPI_ROOT_TABLE_SIZE_INCREMENT) *
-        sizeof (ACPI_TABLE_DESC));
-    if (!Tables)
+    /*
+     * Optionally do not load any SSDTs from the RSDT/XSDT. This can
+     * be useful for debugging ACPI problems on some machines.
+     */
+    if (!Reload &&
+        AcpiGbl_DisableSsdtTableInstall &&
+        ACPI_COMPARE_NAME (&NewTableDesc.Signature, ACPI_SIG_SSDT))
     {
-        ACPI_ERROR ((AE_INFO, "Could not allocate new root table array"));
-        return_ACPI_STATUS (AE_NO_MEMORY);
+        ACPI_INFO ((
+            "Ignoring installation of %4.4s at %8.8X%8.8X",
+            NewTableDesc.Signature.Ascii, ACPI_FORMAT_UINT64 (Address)));
+        goto ReleaseAndExit;
     }
 
-    /* Copy and free the previous table array */
+    /* Validate and verify a table before installation */
 
-    if (AcpiGbl_RootTableList.Tables)
+    Status = AcpiTbVerifyTempTable (&NewTableDesc, NULL);
+    if (ACPI_FAILURE (Status))
     {
-        ACPI_MEMCPY (Tables, AcpiGbl_RootTableList.Tables,
-            (ACPI_SIZE) AcpiGbl_RootTableList.MaxTableCount * sizeof (ACPI_TABLE_DESC));
-
-        if (AcpiGbl_RootTableList.Flags & ACPI_ROOT_ORIGIN_ALLOCATED)
-        {
-            ACPI_FREE (AcpiGbl_RootTableList.Tables);
-        }
+        goto ReleaseAndExit;
     }
 
-    AcpiGbl_RootTableList.Tables = Tables;
-    AcpiGbl_RootTableList.MaxTableCount += ACPI_ROOT_TABLE_SIZE_INCREMENT;
-    AcpiGbl_RootTableList.Flags |= (UINT8) ACPI_ROOT_ORIGIN_ALLOCATED;
-
-    return_ACPI_STATUS (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbStoreTable
- *
- * PARAMETERS:  Address             - Table address
- *              Table               - Table header
- *              Length              - Table length
- *              Flags               - flags
- *
- * RETURN:      Status and table index.
- *
- * DESCRIPTION: Add an ACPI table to the global table list
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiTbStoreTable (
-    ACPI_PHYSICAL_ADDRESS   Address,
-    ACPI_TABLE_HEADER       *Table,
-    UINT32                  Length,
-    UINT8                   Flags,
-    UINT32                  *TableIndex)
-{
-    ACPI_STATUS             Status;
-    ACPI_TABLE_DESC         *NewTable;
-
-
-    /* Ensure that there is room for the table in the Root Table List */
-
-    if (AcpiGbl_RootTableList.CurrentTableCount >=
-        AcpiGbl_RootTableList.MaxTableCount)
+    if (Reload)
     {
-        Status = AcpiTbResizeRootTableList();
-        if (ACPI_FAILURE (Status))
+        /*
+         * Validate the incoming table signature.
+         *
+         * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
+         * 2) We added support for OEMx tables, signature "OEM".
+         * 3) Valid tables were encountered with a null signature, so we just
+         *    gave up on validating the signature, (05/2008).
+         * 4) We encountered non-AML tables such as the MADT, which caused
+         *    interpreter errors and kernel faults. So now, we once again allow
+         *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
+         */
+        if ((NewTableDesc.Signature.Ascii[0] != 0x00) &&
+           (!ACPI_COMPARE_NAME (&NewTableDesc.Signature, ACPI_SIG_SSDT)) &&
+           (strncmp (NewTableDesc.Signature.Ascii, "OEM", 3)))
         {
-            return (Status);
+            ACPI_BIOS_ERROR ((AE_INFO,
+                "Table has invalid signature [%4.4s] (0x%8.8X), "
+                "must be SSDT or OEMx",
+                AcpiUtValidNameseg (NewTableDesc.Signature.Ascii) ?
+                    NewTableDesc.Signature.Ascii : "????",
+                NewTableDesc.Signature.Integer));
+
+            Status = AE_BAD_SIGNATURE;
+            goto ReleaseAndExit;
         }
-    }
-
-    NewTable = &AcpiGbl_RootTableList.Tables[AcpiGbl_RootTableList.CurrentTableCount];
-
-    /* Initialize added table */
-
-    NewTable->Address = Address;
-    NewTable->Pointer = Table;
-    NewTable->Length = Length;
-    NewTable->OwnerId = 0;
-    NewTable->Flags = Flags;
 
-    ACPI_MOVE_32_TO_32 (&NewTable->Signature, Table->Signature);
+        /* Check if table is already registered */
 
-    *TableIndex = AcpiGbl_RootTableList.CurrentTableCount;
-    AcpiGbl_RootTableList.CurrentTableCount++;
-    return (AE_OK);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbDeleteTable
- *
- * PARAMETERS:  TableIndex          - Table index
- *
- * RETURN:      None
- *
- * DESCRIPTION: Delete one internal ACPI table
- *
- ******************************************************************************/
-
-void
-AcpiTbDeleteTable (
-    ACPI_TABLE_DESC         *TableDesc)
-{
+        for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; ++i)
+        {
+            /*
+             * Check for a table match on the entire table length,
+             * not just the header.
+             */
+            if (!AcpiTbCompareTables (&NewTableDesc, i))
+            {
+                continue;
+            }
 
-    /* Table must be mapped or allocated */
+            /*
+             * Note: the current mechanism does not unregister a table if it is
+             * dynamically unloaded. The related namespace entries are deleted,
+             * but the table remains in the root table list.
+             *
+             * The assumption here is that the number of different tables that
+             * will be loaded is actually small, and there is minimal overhead
+             * in just keeping the table in case it is needed again.
+             *
+             * If this assumption changes in the future (perhaps on large
+             * machines with many table load/unload operations), tables will
+             * need to be unregistered when they are unloaded, and slots in the
+             * root table list should be reused when empty.
+             */
+            if (AcpiGbl_RootTableList.Tables[i].Flags &
+                ACPI_TABLE_IS_LOADED)
+            {
+                /* Table is still loaded, this is an error */
 
-    if (!TableDesc->Pointer)
-    {
-        return;
+                Status = AE_ALREADY_EXISTS;
+                goto ReleaseAndExit;
+            }
+            else
+            {
+                /*
+                 * Table was unloaded, allow it to be reloaded.
+                 * As we are going to return AE_OK to the caller, we should
+                 * take the responsibility of freeing the input descriptor.
+                 * Refill the input descriptor to ensure
+                 * AcpiTbInstallTableWithOverride() can be called again to
+                 * indicate the re-installation.
+                 */
+                AcpiTbUninstallTable (&NewTableDesc);
+                *TableIndex = i;
+                return_ACPI_STATUS (AE_OK);
+            }
+        }
     }
 
-    switch (TableDesc->Flags & ACPI_TABLE_ORIGIN_MASK)
-    {
-    case ACPI_TABLE_ORIGIN_MAPPED:
-        AcpiOsUnmapMemory (TableDesc->Pointer, TableDesc->Length);
-        break;
+    /* Add the table to the global root table list */
 
-    case ACPI_TABLE_ORIGIN_ALLOCATED:
-        ACPI_FREE (TableDesc->Pointer);
-        break;
+    AcpiTbInstallTableWithOverride (&NewTableDesc, Override, TableIndex);
 
-    /* Not mapped or allocated, there is nothing we can do */
+ReleaseAndExit:
 
-    default:
-        return;
-    }
+    /* Release the temporary table descriptor */
 
-    TableDesc->Pointer = NULL;
+    AcpiTbReleaseTempTable (&NewTableDesc);
+    return_ACPI_STATUS (Status);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiTbTerminate
+ * FUNCTION:    AcpiTbOverrideTable
  *
- * PARAMETERS:  None
+ * PARAMETERS:  OldTableDesc        - Validated table descriptor to be
+ *                                    overridden
  *
  * RETURN:      None
  *
- * DESCRIPTION: Delete all internal ACPI tables
+ * DESCRIPTION: Attempt table override by calling the OSL override functions.
+ *              Note: If the table is overridden, then the entire new table
+ *              is acquired and returned by this function.
+ *              Before/after invocation, the table descriptor is in a state
+ *              that is "VALIDATED".
  *
  ******************************************************************************/
 
 void
-AcpiTbTerminate (
-    void)
+AcpiTbOverrideTable (
+    ACPI_TABLE_DESC         *OldTableDesc)
 {
-    UINT32                  i;
-
-
-    ACPI_FUNCTION_TRACE (TbTerminate);
-
+    ACPI_STATUS             Status;
+    char                    *OverrideType;
+    ACPI_TABLE_DESC         NewTableDesc;
+    ACPI_TABLE_HEADER       *Table;
+    ACPI_PHYSICAL_ADDRESS   Address;
+    UINT32                  Length;
 
-    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
 
-    /* Delete the individual tables */
+    /* (1) Attempt logical override (returns a logical address) */
 
-    for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; i++)
+    Status = AcpiOsTableOverride (OldTableDesc->Pointer, &Table);
+    if (ACPI_SUCCESS (Status) && Table)
     {
-        AcpiTbDeleteTable (&AcpiGbl_RootTableList.Tables[i]);
+        AcpiTbAcquireTempTable (&NewTableDesc, ACPI_PTR_TO_PHYSADDR (Table),
+            ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL);
+        OverrideType = "Logical";
+        goto FinishOverride;
     }
 
-    /*
-     * Delete the root table array if allocated locally. Array cannot be
-     * mapped, so we don't need to check for that flag.
-     */
-    if (AcpiGbl_RootTableList.Flags & ACPI_ROOT_ORIGIN_ALLOCATED)
+    /* (2) Attempt physical override (returns a physical address) */
+
+    Status = AcpiOsPhysicalTableOverride (OldTableDesc->Pointer,
+        &Address, &Length);
+    if (ACPI_SUCCESS (Status) && Address && Length)
     {
-        ACPI_FREE (AcpiGbl_RootTableList.Tables);
+        AcpiTbAcquireTempTable (&NewTableDesc, Address,
+            ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
+        OverrideType = "Physical";
+        goto FinishOverride;
     }
 
-    AcpiGbl_RootTableList.Tables = NULL;
-    AcpiGbl_RootTableList.Flags = 0;
-    AcpiGbl_RootTableList.CurrentTableCount = 0;
-
-    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "ACPI Tables freed\n"));
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-}
+    return; /* There was no override */
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbDeleteNamespaceByOwner
- *
- * PARAMETERS:  TableIndex          - Table index
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Delete all namespace objects created when this table was loaded.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiTbDeleteNamespaceByOwner (
-    UINT32                  TableIndex)
-{
-    ACPI_OWNER_ID           OwnerId;
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_TRACE (TbDeleteNamespaceByOwner);
+FinishOverride:
 
+    /* Validate and verify a table before overriding */
 
-    Status = AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    Status = AcpiTbVerifyTempTable (&NewTableDesc, NULL);
     if (ACPI_FAILURE (Status))
     {
-        return_ACPI_STATUS (Status);
+        return;
     }
 
-    if (TableIndex >= AcpiGbl_RootTableList.CurrentTableCount)
-    {
-        /* The table index does not exist */
-
-        (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-        return_ACPI_STATUS (AE_NOT_EXIST);
-    }
+    ACPI_INFO (("%4.4s 0x%8.8X%8.8X"
+        " %s table override, new table: 0x%8.8X%8.8X",
+        OldTableDesc->Signature.Ascii,
+        ACPI_FORMAT_UINT64 (OldTableDesc->Address),
+        OverrideType, ACPI_FORMAT_UINT64 (NewTableDesc.Address)));
 
-    /* Get the owner ID for this table, used to delete namespace nodes */
+    /* We can now uninstall the original table */
 
-    OwnerId = AcpiGbl_RootTableList.Tables[TableIndex].OwnerId;
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+    AcpiTbUninstallTable (OldTableDesc);
 
     /*
-     * Need to acquire the namespace writer lock to prevent interference
-     * with any concurrent namespace walks. The interpreter must be
-     * released during the deletion since the acquisition of the deletion
-     * lock may block, and also since the execution of a namespace walk
-     * must be allowed to use the interpreter.
+     * Replace the original table descriptor and keep its state as
+     * "VALIDATED".
      */
-    (void) AcpiUtReleaseMutex (ACPI_MTX_INTERPRETER);
-    Status = AcpiUtAcquireWriteLock (&AcpiGbl_NamespaceRwLock);
-
-    AcpiNsDeleteNamespaceByOwner (OwnerId);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
+    AcpiTbInitTableDescriptor (OldTableDesc, NewTableDesc.Address,
+        NewTableDesc.Flags, NewTableDesc.Pointer);
+    AcpiTbValidateTempTable (OldTableDesc);
 
-    AcpiUtReleaseWriteLock (&AcpiGbl_NamespaceRwLock);
+    /* Release the temporary table descriptor */
 
-    Status = AcpiUtAcquireMutex (ACPI_MTX_INTERPRETER);
-    return_ACPI_STATUS (Status);
+    AcpiTbReleaseTempTable (&NewTableDesc);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiTbAllocateOwnerId
- *
- * PARAMETERS:  TableIndex          - Table index
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Allocates OwnerId in TableDesc
+ * FUNCTION:    AcpiTbUninstallTable
  *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiTbAllocateOwnerId (
-    UINT32                  TableIndex)
-{
-    ACPI_STATUS             Status = AE_BAD_PARAMETER;
-
-
-    ACPI_FUNCTION_TRACE (TbAllocateOwnerId);
-
-
-    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
-    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
-    {
-        Status = AcpiUtAllocateOwnerId
-                    (&(AcpiGbl_RootTableList.Tables[TableIndex].OwnerId));
-    }
-
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-    return_ACPI_STATUS (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbReleaseOwnerId
- *
- * PARAMETERS:  TableIndex          - Table index
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Releases OwnerId in TableDesc
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiTbReleaseOwnerId (
-    UINT32                  TableIndex)
-{
-    ACPI_STATUS             Status = AE_BAD_PARAMETER;
-
-
-    ACPI_FUNCTION_TRACE (TbReleaseOwnerId);
-
-
-    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
-    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
-    {
-        AcpiUtReleaseOwnerId (
-            &(AcpiGbl_RootTableList.Tables[TableIndex].OwnerId));
-        Status = AE_OK;
-    }
-
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-    return_ACPI_STATUS (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbGetOwnerId
- *
- * PARAMETERS:  TableIndex          - Table index
- *              OwnerId             - Where the table OwnerId is returned
+ * PARAMETERS:  TableDesc           - Table descriptor
  *
- * RETURN:      Status
+ * RETURN:      None
  *
- * DESCRIPTION: returns OwnerId for the ACPI table
+ * DESCRIPTION: Delete one internal ACPI table
  *
  ******************************************************************************/
 
-ACPI_STATUS
-AcpiTbGetOwnerId (
-    UINT32                  TableIndex,
-    ACPI_OWNER_ID           *OwnerId)
+void
+AcpiTbUninstallTable (
+    ACPI_TABLE_DESC         *TableDesc)
 {
-    ACPI_STATUS             Status = AE_BAD_PARAMETER;
-
-
-    ACPI_FUNCTION_TRACE (TbGetOwnerId);
-
-
-    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
-    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
-    {
-        *OwnerId = AcpiGbl_RootTableList.Tables[TableIndex].OwnerId;
-        Status = AE_OK;
-    }
-
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-    return_ACPI_STATUS (Status);
-}
-
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbIsTableLoaded
- *
- * PARAMETERS:  TableIndex          - Table index
- *
- * RETURN:      Table Loaded Flag
- *
- ******************************************************************************/
+    ACPI_FUNCTION_TRACE (TbUninstallTable);
 
-BOOLEAN
-AcpiTbIsTableLoaded (
-    UINT32                  TableIndex)
-{
-    BOOLEAN                 IsLoaded = FALSE;
 
+    /* Table must be installed */
 
-    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
-    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
+    if (!TableDesc->Address)
     {
-        IsLoaded = (BOOLEAN)
-            (AcpiGbl_RootTableList.Tables[TableIndex].Flags &
-            ACPI_TABLE_IS_LOADED);
+        return_VOID;
     }
 
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-    return (IsLoaded);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbSetTableLoadedFlag
- *
- * PARAMETERS:  TableIndex          - Table index
- *              IsLoaded            - TRUE if table is loaded, FALSE otherwise
- *
- * RETURN:      None
- *
- * DESCRIPTION: Sets the table loaded flag to either TRUE or FALSE.
- *
- ******************************************************************************/
-
-void
-AcpiTbSetTableLoadedFlag (
-    UINT32                  TableIndex,
-    BOOLEAN                 IsLoaded)
-{
+    AcpiTbInvalidateTable (TableDesc);
 
-    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
-    if (TableIndex < AcpiGbl_RootTableList.CurrentTableCount)
+    if ((TableDesc->Flags & ACPI_TABLE_ORIGIN_MASK) ==
+        ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL)
     {
-        if (IsLoaded)
-        {
-            AcpiGbl_RootTableList.Tables[TableIndex].Flags |=
-                ACPI_TABLE_IS_LOADED;
-        }
-        else
-        {
-            AcpiGbl_RootTableList.Tables[TableIndex].Flags &=
-                ~ACPI_TABLE_IS_LOADED;
-        }
+        ACPI_FREE (ACPI_PHYSADDR_TO_PTR (TableDesc->Address));
     }
 
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+    TableDesc->Address = ACPI_PTR_TO_PHYSADDR (NULL);
+    return_VOID;
 }
-
diff --git a/usr/src/uts/intel/io/acpica/tables/tbprint.c b/usr/src/uts/intel/io/acpica/tables/tbprint.c
new file mode 100644
index 0000000000..9dab6d9d4a
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/tables/tbprint.c
@@ -0,0 +1,272 @@
+/******************************************************************************
+ *
+ * Module Name: tbprint - Table output utilities
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_TABLES
+        ACPI_MODULE_NAME    ("tbprint")
+
+
+/* Local prototypes */
+
+static void
+AcpiTbFixString (
+    char                    *String,
+    ACPI_SIZE               Length);
+
+static void
+AcpiTbCleanupTableHeader (
+    ACPI_TABLE_HEADER       *OutHeader,
+    ACPI_TABLE_HEADER       *Header);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbFixString
+ *
+ * PARAMETERS:  String              - String to be repaired
+ *              Length              - Maximum length
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Replace every non-printable or non-ascii byte in the string
+ *              with a question mark '?'.
+ *
+ ******************************************************************************/
+
+static void
+AcpiTbFixString (
+    char                    *String,
+    ACPI_SIZE               Length)
+{
+
+    while (Length && *String)
+    {
+        if (!isprint ((int) *String))
+        {
+            *String = '?';
+        }
+
+        String++;
+        Length--;
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbCleanupTableHeader
+ *
+ * PARAMETERS:  OutHeader           - Where the cleaned header is returned
+ *              Header              - Input ACPI table header
+ *
+ * RETURN:      Returns the cleaned header in OutHeader
+ *
+ * DESCRIPTION: Copy the table header and ensure that all "string" fields in
+ *              the header consist of printable characters.
+ *
+ ******************************************************************************/
+
+static void
+AcpiTbCleanupTableHeader (
+    ACPI_TABLE_HEADER       *OutHeader,
+    ACPI_TABLE_HEADER       *Header)
+{
+
+    memcpy (OutHeader, Header, sizeof (ACPI_TABLE_HEADER));
+
+    AcpiTbFixString (OutHeader->Signature, ACPI_NAME_SIZE);
+    AcpiTbFixString (OutHeader->OemId, ACPI_OEM_ID_SIZE);
+    AcpiTbFixString (OutHeader->OemTableId, ACPI_OEM_TABLE_ID_SIZE);
+    AcpiTbFixString (OutHeader->AslCompilerId, ACPI_NAME_SIZE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbPrintTableHeader
+ *
+ * PARAMETERS:  Address             - Table physical address
+ *              Header              - Table header
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print an ACPI table header. Special cases for FACS and RSDP.
+ *
+ ******************************************************************************/
+
+void
+AcpiTbPrintTableHeader (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    ACPI_TABLE_HEADER       *Header)
+{
+    ACPI_TABLE_HEADER       LocalHeader;
+
+
+    if (ACPI_COMPARE_NAME (Header->Signature, ACPI_SIG_FACS))
+    {
+        /* FACS only has signature and length fields */
+
+        ACPI_INFO (("%-4.4s 0x%8.8X%8.8X %06X",
+            Header->Signature, ACPI_FORMAT_UINT64 (Address),
+            Header->Length));
+    }
+    else if (ACPI_VALIDATE_RSDP_SIG (Header->Signature))
+    {
+        /* RSDP has no common fields */
+
+        memcpy (LocalHeader.OemId, ACPI_CAST_PTR (ACPI_TABLE_RSDP,
+            Header)->OemId, ACPI_OEM_ID_SIZE);
+        AcpiTbFixString (LocalHeader.OemId, ACPI_OEM_ID_SIZE);
+
+        ACPI_INFO (("RSDP 0x%8.8X%8.8X %06X (v%.2d %-6.6s)",
+            ACPI_FORMAT_UINT64 (Address),
+            (ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->Revision > 0) ?
+                ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->Length : 20,
+            ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->Revision,
+            LocalHeader.OemId));
+    }
+    else
+    {
+        /* Standard ACPI table with full common header */
+
+        AcpiTbCleanupTableHeader (&LocalHeader, Header);
+
+        ACPI_INFO ((
+            "%-4.4s 0x%8.8X%8.8X"
+            " %06X (v%.2d %-6.6s %-8.8s %08X %-4.4s %08X)",
+            LocalHeader.Signature, ACPI_FORMAT_UINT64 (Address),
+            LocalHeader.Length, LocalHeader.Revision, LocalHeader.OemId,
+            LocalHeader.OemTableId, LocalHeader.OemRevision,
+            LocalHeader.AslCompilerId, LocalHeader.AslCompilerRevision));
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbValidateChecksum
+ *
+ * PARAMETERS:  Table               - ACPI table to verify
+ *              Length              - Length of entire table
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Verifies that the table checksums to zero. Optionally returns
+ *              exception on bad checksum.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbVerifyChecksum (
+    ACPI_TABLE_HEADER       *Table,
+    UINT32                  Length)
+{
+    UINT8                   Checksum;
+
+
+    /*
+     * FACS/S3PT:
+     * They are the odd tables, have no standard ACPI header and no checksum
+     */
+
+    if (ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_S3PT) ||
+        ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_FACS))
+    {
+        return (AE_OK);
+    }
+
+    /* Compute the checksum on the table */
+
+    Checksum = AcpiTbChecksum (ACPI_CAST_PTR (UINT8, Table), Length);
+
+    /* Checksum ok? (should be zero) */
+
+    if (Checksum)
+    {
+        ACPI_BIOS_WARNING ((AE_INFO,
+            "Incorrect checksum in table [%4.4s] - 0x%2.2X, "
+            "should be 0x%2.2X",
+            Table->Signature, Table->Checksum,
+            (UINT8) (Table->Checksum - Checksum)));
+
+#if (ACPI_CHECKSUM_ABORT)
+        return (AE_BAD_CHECKSUM);
+#endif
+    }
+
+    return (AE_OK);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbChecksum
+ *
+ * PARAMETERS:  Buffer          - Pointer to memory region to be checked
+ *              Length          - Length of this memory region
+ *
+ * RETURN:      Checksum (UINT8)
+ *
+ * DESCRIPTION: Calculates circular checksum of memory region.
+ *
+ ******************************************************************************/
+
+UINT8
+AcpiTbChecksum (
+    UINT8                   *Buffer,
+    UINT32                  Length)
+{
+    UINT8                   Sum = 0;
+    UINT8                   *End = Buffer + Length;
+
+
+    while (Buffer < End)
+    {
+        Sum = (UINT8) (Sum + *(Buffer++));
+    }
+
+    return (Sum);
+}
diff --git a/usr/src/uts/intel/io/acpica/tables/tbutils.c b/usr/src/uts/intel/io/acpica/tables/tbutils.c
index e8b5705e96..5fc07b76e0 100644
--- a/usr/src/uts/intel/io/acpica/tables/tbutils.c
+++ b/usr/src/uts/intel/io/acpica/tables/tbutils.c
@@ -1,11 +1,11 @@
 /******************************************************************************
  *
- * Module Name: tbutils   - table utilities
+ * Module Name: tbutils - ACPI Table utilities
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __TBUTILS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "actables.h"
@@ -53,16 +51,6 @@
 
 /* Local prototypes */
 
-static void
-AcpiTbFixString (
-    char                    *String,
-    ACPI_SIZE               Length);
-
-static void
-AcpiTbCleanupTableHeader (
-    ACPI_TABLE_HEADER       *OutHeader,
-    ACPI_TABLE_HEADER       *Header);
-
 static ACPI_PHYSICAL_ADDRESS
 AcpiTbGetRootTableEntry (
     UINT8                   *TableEntry,
@@ -87,7 +75,7 @@ ACPI_STATUS
 AcpiTbInitializeFacs (
     void)
 {
-    ACPI_STATUS             Status;
+    ACPI_TABLE_FACS         *Facs;
 
 
     /* If Hardware Reduced flag is set, there is no FACS */
@@ -97,239 +85,25 @@ AcpiTbInitializeFacs (
         AcpiGbl_FACS = NULL;
         return (AE_OK);
     }
-
-    Status = AcpiGetTableByIndex (ACPI_TABLE_INDEX_FACS,
-                ACPI_CAST_INDIRECT_PTR (ACPI_TABLE_HEADER, &AcpiGbl_FACS));
-    return (Status);
-}
-#endif /* !ACPI_REDUCED_HARDWARE */
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbTablesLoaded
- *
- * PARAMETERS:  None
- *
- * RETURN:      TRUE if required ACPI tables are loaded
- *
- * DESCRIPTION: Determine if the minimum required ACPI tables are present
- *              (FADT, FACS, DSDT)
- *
- ******************************************************************************/
-
-BOOLEAN
-AcpiTbTablesLoaded (
-    void)
-{
-
-    if (AcpiGbl_RootTableList.CurrentTableCount >= 3)
-    {
-        return (TRUE);
-    }
-
-    return (FALSE);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbFixString
- *
- * PARAMETERS:  String              - String to be repaired
- *              Length              - Maximum length
- *
- * RETURN:      None
- *
- * DESCRIPTION: Replace every non-printable or non-ascii byte in the string
- *              with a question mark '?'.
- *
- ******************************************************************************/
-
-static void
-AcpiTbFixString (
-    char                    *String,
-    ACPI_SIZE               Length)
-{
-
-    while (Length && *String)
-    {
-        if (!ACPI_IS_PRINT (*String))
-        {
-            *String = '?';
-        }
-        String++;
-        Length--;
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbCleanupTableHeader
- *
- * PARAMETERS:  OutHeader           - Where the cleaned header is returned
- *              Header              - Input ACPI table header
- *
- * RETURN:      Returns the cleaned header in OutHeader
- *
- * DESCRIPTION: Copy the table header and ensure that all "string" fields in
- *              the header consist of printable characters.
- *
- ******************************************************************************/
-
-static void
-AcpiTbCleanupTableHeader (
-    ACPI_TABLE_HEADER       *OutHeader,
-    ACPI_TABLE_HEADER       *Header)
-{
-
-    ACPI_MEMCPY (OutHeader, Header, sizeof (ACPI_TABLE_HEADER));
-
-    AcpiTbFixString (OutHeader->Signature, ACPI_NAME_SIZE);
-    AcpiTbFixString (OutHeader->OemId, ACPI_OEM_ID_SIZE);
-    AcpiTbFixString (OutHeader->OemTableId, ACPI_OEM_TABLE_ID_SIZE);
-    AcpiTbFixString (OutHeader->AslCompilerId, ACPI_NAME_SIZE);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbPrintTableHeader
- *
- * PARAMETERS:  Address             - Table physical address
- *              Header              - Table header
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print an ACPI table header. Special cases for FACS and RSDP.
- *
- ******************************************************************************/
-
-void
-AcpiTbPrintTableHeader (
-    ACPI_PHYSICAL_ADDRESS   Address,
-    ACPI_TABLE_HEADER       *Header)
-{
-    ACPI_TABLE_HEADER       LocalHeader;
-
-
-    /*
-     * The reason that the Address is cast to a void pointer is so that we
-     * can use %p which will work properly on both 32-bit and 64-bit hosts.
-     */
-    if (ACPI_COMPARE_NAME (Header->Signature, ACPI_SIG_FACS))
-    {
-        /* FACS only has signature and length fields */
-
-        ACPI_INFO ((AE_INFO, "%4.4s %p %05X",
-            Header->Signature, ACPI_CAST_PTR (void, Address),
-            Header->Length));
-    }
-    else if (ACPI_COMPARE_NAME (Header->Signature, ACPI_SIG_RSDP))
+    else if (AcpiGbl_FADT.XFacs &&
+         (!AcpiGbl_FADT.Facs || !AcpiGbl_Use32BitFacsAddresses))
     {
-        /* RSDP has no common fields */
-
-        ACPI_MEMCPY (LocalHeader.OemId,
-            ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->OemId, ACPI_OEM_ID_SIZE);
-        AcpiTbFixString (LocalHeader.OemId, ACPI_OEM_ID_SIZE);
-
-        ACPI_INFO ((AE_INFO, "RSDP %p %05X (v%.2d %6.6s)",
-            ACPI_CAST_PTR (void, Address),
-            (ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->Revision > 0) ?
-                ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->Length : 20,
-            ACPI_CAST_PTR (ACPI_TABLE_RSDP, Header)->Revision,
-            LocalHeader.OemId));
+        (void) AcpiGetTableByIndex (AcpiGbl_XFacsIndex,
+            ACPI_CAST_INDIRECT_PTR (ACPI_TABLE_HEADER, &Facs));
+        AcpiGbl_FACS = Facs;
     }
-    else
+    else if (AcpiGbl_FADT.Facs)
     {
-        /* Standard ACPI table with full common header */
-
-        AcpiTbCleanupTableHeader (&LocalHeader, Header);
-
-        ACPI_INFO ((AE_INFO,
-            "%4.4s %p %05X (v%.2d %6.6s %8.8s %08X %4.4s %08X)",
-            LocalHeader.Signature, ACPI_CAST_PTR (void, Address),
-            LocalHeader.Length, LocalHeader.Revision, LocalHeader.OemId,
-            LocalHeader.OemTableId, LocalHeader.OemRevision,
-            LocalHeader.AslCompilerId, LocalHeader.AslCompilerRevision));
+        (void) AcpiGetTableByIndex (AcpiGbl_FacsIndex,
+            ACPI_CAST_INDIRECT_PTR (ACPI_TABLE_HEADER, &Facs));
+        AcpiGbl_FACS = Facs;
     }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbValidateChecksum
- *
- * PARAMETERS:  Table               - ACPI table to verify
- *              Length              - Length of entire table
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Verifies that the table checksums to zero. Optionally returns
- *              exception on bad checksum.
- *
- ******************************************************************************/
 
-ACPI_STATUS
-AcpiTbVerifyChecksum (
-    ACPI_TABLE_HEADER       *Table,
-    UINT32                  Length)
-{
-    UINT8                   Checksum;
-
-
-    /* Compute the checksum on the table */
-
-    Checksum = AcpiTbChecksum (ACPI_CAST_PTR (UINT8, Table), Length);
-
-    /* Checksum ok? (should be zero) */
-
-    if (Checksum)
-    {
-        ACPI_WARNING ((AE_INFO,
-            "Incorrect checksum in table [%4.4s] - 0x%2.2X, should be 0x%2.2X",
-            Table->Signature, Table->Checksum,
-            (UINT8) (Table->Checksum - Checksum)));
-
-#if (ACPI_CHECKSUM_ABORT)
-        return (AE_BAD_CHECKSUM);
-#endif
-    }
+    /* If there is no FACS, just continue. There was already an error msg */
 
     return (AE_OK);
 }
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbChecksum
- *
- * PARAMETERS:  Buffer          - Pointer to memory region to be checked
- *              Length          - Length of this memory region
- *
- * RETURN:      Checksum (UINT8)
- *
- * DESCRIPTION: Calculates circular checksum of memory region.
- *
- ******************************************************************************/
-
-UINT8
-AcpiTbChecksum (
-    UINT8                   *Buffer,
-    UINT32                  Length)
-{
-    UINT8                   Sum = 0;
-    UINT8                   *End = Buffer + Length;
-
-
-    while (Buffer < End)
-    {
-        Sum = (UINT8) (Sum + *(Buffer++));
-    }
-
-    return Sum;
-}
+#endif /* !ACPI_REDUCED_HARDWARE */
 
 
 /*******************************************************************************
@@ -356,8 +130,10 @@ AcpiTbCheckDsdtHeader (
     if (AcpiGbl_OriginalDsdtHeader.Length != AcpiGbl_DSDT->Length ||
         AcpiGbl_OriginalDsdtHeader.Checksum != AcpiGbl_DSDT->Checksum)
     {
-        ACPI_ERROR ((AE_INFO,
-            "The DSDT has been corrupted or replaced - old, new headers below"));
+        ACPI_BIOS_ERROR ((AE_INFO,
+            "The DSDT has been corrupted or replaced - "
+            "old, new headers below"));
+
         AcpiTbPrintTableHeader (0, &AcpiGbl_OriginalDsdtHeader);
         AcpiTbPrintTableHeader (0, AcpiGbl_DSDT);
 
@@ -401,12 +177,15 @@ AcpiTbCopyDsdt (
         return (NULL);
     }
 
-    ACPI_MEMCPY (NewTable, TableDesc->Pointer, TableDesc->Length);
-    AcpiTbDeleteTable (TableDesc);
-    TableDesc->Pointer = NewTable;
-    TableDesc->Flags = ACPI_TABLE_ORIGIN_ALLOCATED;
+    memcpy (NewTable, TableDesc->Pointer, TableDesc->Length);
+    AcpiTbUninstallTable (TableDesc);
 
-    ACPI_INFO ((AE_INFO,
+    AcpiTbInitTableDescriptor (
+        &AcpiGbl_RootTableList.Tables[AcpiGbl_DsdtIndex],
+        ACPI_PTR_TO_PHYSADDR (NewTable),
+        ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL, NewTable);
+
+    ACPI_INFO ((
         "Forced DSDT copy: length 0x%05X copied locally, original unmapped",
         NewTable->Length));
 
@@ -414,125 +193,6 @@ AcpiTbCopyDsdt (
 }
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbInstallTable
- *
- * PARAMETERS:  Address                 - Physical address of DSDT or FACS
- *              Signature               - Table signature, NULL if no need to
- *                                        match
- *              TableIndex              - Index into root table array
- *
- * RETURN:      None
- *
- * DESCRIPTION: Install an ACPI table into the global data structure. The
- *              table override mechanism is called to allow the host
- *              OS to replace any table before it is installed in the root
- *              table array.
- *
- ******************************************************************************/
-
-void
-AcpiTbInstallTable (
-    ACPI_PHYSICAL_ADDRESS   Address,
-    char                    *Signature,
-    UINT32                  TableIndex)
-{
-    ACPI_TABLE_HEADER       *Table;
-    ACPI_TABLE_HEADER       *FinalTable;
-    ACPI_TABLE_DESC         *TableDesc;
-
-
-    if (!Address)
-    {
-        ACPI_ERROR ((AE_INFO, "Null physical address for ACPI table [%s]",
-            Signature));
-        return;
-    }
-
-    /* Map just the table header */
-
-    Table = AcpiOsMapMemory (Address, sizeof (ACPI_TABLE_HEADER));
-    if (!Table)
-    {
-        ACPI_ERROR ((AE_INFO, "Could not map memory for table [%s] at %p",
-            Signature, ACPI_CAST_PTR (void, Address)));
-        return;
-    }
-
-    /* If a particular signature is expected (DSDT/FACS), it must match */
-
-    if (Signature &&
-        !ACPI_COMPARE_NAME (Table->Signature, Signature))
-    {
-        ACPI_ERROR ((AE_INFO,
-            "Invalid signature 0x%X for ACPI table, expected [%s]",
-            *ACPI_CAST_PTR (UINT32, Table->Signature), Signature));
-        goto UnmapAndExit;
-    }
-
-    /*
-     * Initialize the table entry. Set the pointer to NULL, since the
-     * table is not fully mapped at this time.
-     */
-    TableDesc = &AcpiGbl_RootTableList.Tables[TableIndex];
-
-    TableDesc->Address = Address;
-    TableDesc->Pointer = NULL;
-    TableDesc->Length = Table->Length;
-    TableDesc->Flags = ACPI_TABLE_ORIGIN_MAPPED;
-    ACPI_MOVE_32_TO_32 (TableDesc->Signature.Ascii, Table->Signature);
-
-    /*
-     * ACPI Table Override:
-     *
-     * Before we install the table, let the host OS override it with a new
-     * one if desired. Any table within the RSDT/XSDT can be replaced,
-     * including the DSDT which is pointed to by the FADT.
-     *
-     * NOTE: If the table is overridden, then FinalTable will contain a
-     * mapped pointer to the full new table. If the table is not overridden,
-     * or if there has been a physical override, then the table will be
-     * fully mapped later (in verify table). In any case, we must
-     * unmap the header that was mapped above.
-     */
-    FinalTable = AcpiTbTableOverride (Table, TableDesc);
-    if (!FinalTable)
-    {
-        FinalTable = Table; /* There was no override */
-    }
-
-    AcpiTbPrintTableHeader (TableDesc->Address, FinalTable);
-
-    /* Set the global integer width (based upon revision of the DSDT) */
-
-    if (TableIndex == ACPI_TABLE_INDEX_DSDT)
-    {
-        AcpiUtSetIntegerWidth (FinalTable->Revision);
-    }
-
-    /*
-     * If we have a physical override during this early loading of the ACPI
-     * tables, unmap the table for now. It will be mapped again later when
-     * it is actually used. This supports very early loading of ACPI tables,
-     * before virtual memory is fully initialized and running within the
-     * host OS. Note: A logical override has the ACPI_TABLE_ORIGIN_OVERRIDE
-     * flag set and will not be deleted below.
-     */
-    if (FinalTable != Table)
-    {
-        AcpiTbDeleteTable (TableDesc);
-    }
-
-
-UnmapAndExit:
-
-    /* Always unmap the table header that we mapped above */
-
-    AcpiOsUnmapMemory (Table, sizeof (ACPI_TABLE_HEADER));
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiTbGetRootTableEntry
@@ -562,13 +222,14 @@ AcpiTbGetRootTableEntry (
      * Get the table physical address (32-bit for RSDT, 64-bit for XSDT):
      * Note: Addresses are 32-bit aligned (not 64) in both RSDT and XSDT
      */
-    if (TableEntrySize == sizeof (UINT32))
+    if (TableEntrySize == ACPI_RSDT_ENTRY_SIZE)
     {
         /*
          * 32-bit platform, RSDT: Return 32-bit table entry
          * 64-bit platform, RSDT: Expand 32-bit to 64-bit and return
          */
-        return ((ACPI_PHYSICAL_ADDRESS) (*ACPI_CAST_PTR (UINT32, TableEntry)));
+        return ((ACPI_PHYSICAL_ADDRESS) (*ACPI_CAST_PTR (
+            UINT32, TableEntry)));
     }
     else
     {
@@ -584,7 +245,7 @@ AcpiTbGetRootTableEntry (
         {
             /* Will truncate 64-bit address to 32 bits, issue warning */
 
-            ACPI_WARNING ((AE_INFO,
+            ACPI_BIOS_WARNING ((AE_INFO,
                 "64-bit Physical Address in XSDT is too large (0x%8.8X%8.8X),"
                 " truncating",
                 ACPI_FORMAT_UINT64 (Address64)));
@@ -625,14 +286,14 @@ AcpiTbParseRootTable (
     UINT32                  Length;
     UINT8                   *TableEntry;
     ACPI_STATUS             Status;
+    UINT32                  TableIndex;
 
 
     ACPI_FUNCTION_TRACE (TbParseRootTable);
 
 
-    /*
-     * Map the entire RSDP and extract the address of the RSDT or XSDT
-     */
+    /* Map the entire RSDP and extract the address of the RSDT or XSDT */
+
     Rsdp = AcpiOsMapMemory (RsdpAddress, sizeof (ACPI_TABLE_RSDP));
     if (!Rsdp)
     {
@@ -642,24 +303,26 @@ AcpiTbParseRootTable (
     AcpiTbPrintTableHeader (RsdpAddress,
         ACPI_CAST_PTR (ACPI_TABLE_HEADER, Rsdp));
 
-    /* Differentiate between RSDT and XSDT root tables */
+    /* Use XSDT if present and not overridden. Otherwise, use RSDT */
 
-    if (Rsdp->Revision > 1 && Rsdp->XsdtPhysicalAddress)
+    if ((Rsdp->Revision > 1) &&
+        Rsdp->XsdtPhysicalAddress &&
+        !AcpiGbl_DoNotUseXsdt)
     {
         /*
-         * Root table is an XSDT (64-bit physical addresses). We must use the
-         * XSDT if the revision is > 1 and the XSDT pointer is present, as per
-         * the ACPI specification.
+         * RSDP contains an XSDT (64-bit physical addresses). We must use
+         * the XSDT if the revision is > 1 and the XSDT pointer is present,
+         * as per the ACPI specification.
          */
         Address = (ACPI_PHYSICAL_ADDRESS) Rsdp->XsdtPhysicalAddress;
-        TableEntrySize = sizeof (UINT64);
+        TableEntrySize = ACPI_XSDT_ENTRY_SIZE;
     }
     else
     {
         /* Root table is an RSDT (32-bit physical addresses) */
 
         Address = (ACPI_PHYSICAL_ADDRESS) Rsdp->RsdtPhysicalAddress;
-        TableEntrySize = sizeof (UINT32);
+        TableEntrySize = ACPI_RSDT_ENTRY_SIZE;
     }
 
     /*
@@ -668,7 +331,6 @@ AcpiTbParseRootTable (
      */
     AcpiOsUnmapMemory (Rsdp, sizeof (ACPI_TABLE_RSDP));
 
-
     /* Map the RSDT/XSDT table header to get the full table length */
 
     Table = AcpiOsMapMemory (Address, sizeof (ACPI_TABLE_HEADER));
@@ -679,14 +341,17 @@ AcpiTbParseRootTable (
 
     AcpiTbPrintTableHeader (Address, Table);
 
-    /* Get the length of the full table, verify length and map entire table */
-
+    /*
+     * Validate length of the table, and map entire table.
+     * Minimum length table must contain at least one entry.
+     */
     Length = Table->Length;
     AcpiOsUnmapMemory (Table, sizeof (ACPI_TABLE_HEADER));
 
-    if (Length < sizeof (ACPI_TABLE_HEADER))
+    if (Length < (sizeof (ACPI_TABLE_HEADER) + TableEntrySize))
     {
-        ACPI_ERROR ((AE_INFO, "Invalid length 0x%X in RSDT/XSDT", Length));
+        ACPI_BIOS_ERROR ((AE_INFO,
+            "Invalid table length 0x%X in RSDT/XSDT", Length));
         return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
     }
 
@@ -705,71 +370,44 @@ AcpiTbParseRootTable (
         return_ACPI_STATUS (Status);
     }
 
-    /* Calculate the number of tables described in the root table */
+    /* Get the number of entries and pointer to first entry */
 
     TableCount = (UINT32) ((Table->Length - sizeof (ACPI_TABLE_HEADER)) /
         TableEntrySize);
+    TableEntry = ACPI_ADD_PTR (UINT8, Table, sizeof (ACPI_TABLE_HEADER));
 
-    /*
-     * First two entries in the table array are reserved for the DSDT
-     * and FACS, which are not actually present in the RSDT/XSDT - they
-     * come from the FADT
-     */
-    TableEntry = ACPI_CAST_PTR (UINT8, Table) + sizeof (ACPI_TABLE_HEADER);
-    AcpiGbl_RootTableList.CurrentTableCount = 2;
+    /* Initialize the root table array from the RSDT/XSDT */
 
-    /*
-     * Initialize the root table array from the RSDT/XSDT
-     */
     for (i = 0; i < TableCount; i++)
     {
-        if (AcpiGbl_RootTableList.CurrentTableCount >=
-            AcpiGbl_RootTableList.MaxTableCount)
-        {
-            /* There is no more room in the root table array, attempt resize */
-
-            Status = AcpiTbResizeRootTableList ();
-            if (ACPI_FAILURE (Status))
-            {
-                ACPI_WARNING ((AE_INFO, "Truncating %u table entries!",
-                    (unsigned) (TableCount -
-                    (AcpiGbl_RootTableList.CurrentTableCount - 2))));
-                break;
-            }
-        }
-
         /* Get the table physical address (32-bit for RSDT, 64-bit for XSDT) */
 
-        AcpiGbl_RootTableList.Tables[AcpiGbl_RootTableList.CurrentTableCount].Address =
-            AcpiTbGetRootTableEntry (TableEntry, TableEntrySize);
-
-        TableEntry += TableEntrySize;
-        AcpiGbl_RootTableList.CurrentTableCount++;
-    }
+        Address = AcpiTbGetRootTableEntry (TableEntry, TableEntrySize);
 
-    /*
-     * It is not possible to map more than one entry in some environments,
-     * so unmap the root table here before mapping other tables
-     */
-    AcpiOsUnmapMemory (Table, Length);
+        /* Skip NULL entries in RSDT/XSDT */
 
-    /*
-     * Complete the initialization of the root table array by examining
-     * the header of each table
-     */
-    for (i = 2; i < AcpiGbl_RootTableList.CurrentTableCount; i++)
-    {
-        AcpiTbInstallTable (AcpiGbl_RootTableList.Tables[i].Address,
-            NULL, i);
+        if (!Address)
+        {
+            goto NextTable;
+        }
 
-        /* Special case for FADT - get the DSDT and FACS */
+        Status = AcpiTbInstallStandardTable (Address,
+            ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL, FALSE, TRUE, &TableIndex);
 
-        if (ACPI_COMPARE_NAME (
-                &AcpiGbl_RootTableList.Tables[i].Signature, ACPI_SIG_FADT))
+        if (ACPI_SUCCESS (Status) &&
+            ACPI_COMPARE_NAME (
+                &AcpiGbl_RootTableList.Tables[TableIndex].Signature,
+                ACPI_SIG_FADT))
         {
-            AcpiTbParseFadt (i);
+            AcpiGbl_FadtIndex = TableIndex;
+            AcpiTbParseFadt ();
         }
+
+NextTable:
+
+        TableEntry += TableEntrySize;
     }
 
+    AcpiOsUnmapMemory (Table, Length);
     return_ACPI_STATUS (AE_OK);
 }
diff --git a/usr/src/uts/intel/io/acpica/tables/tbxface.c b/usr/src/uts/intel/io/acpica/tables/tbxface.c
index 58dae6935d..8c0caaee75 100644
--- a/usr/src/uts/intel/io/acpica/tables/tbxface.c
+++ b/usr/src/uts/intel/io/acpica/tables/tbxface.c
@@ -1,12 +1,11 @@
 /******************************************************************************
  *
- * Module Name: tbxface - Public interfaces to the ACPI subsystem
- *                         ACPI table oriented interfaces
+ * Module Name: tbxface - ACPI table-oriented external interfaces
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,22 +41,15 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __TBXFACE_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
-#include "acnamesp.h"
 #include "actables.h"
 
 #define _COMPONENT          ACPI_TABLES
         ACPI_MODULE_NAME    ("tbxface")
 
-/* Local prototypes */
-
-static ACPI_STATUS
-AcpiTbLoadNamespace (
-    void);
-
 
 /*******************************************************************************
  *
@@ -94,7 +86,7 @@ AcpiAllocateRootTable (
  *                                    array is dynamically allocated.
  *              InitialTableCount   - Size of InitialTableArray, in number of
  *                                    ACPI_TABLE_DESC structures
- *              AllowRealloc        - Flag to tell Table Manager if resize of
+ *              AllowResize         - Flag to tell Table Manager if resize of
  *                                    pre-allocated array is allowed. Ignored
  *                                    if InitialTableArray is NULL.
  *
@@ -125,8 +117,8 @@ AcpiInitializeTables (
 
 
     /*
-     * Set up the Root Table Array
-     * Allocate the table array if requested
+     * Setup the Root Table Array and allocate the table array
+     * if requested
      */
     if (!InitialTableArray)
     {
@@ -140,7 +132,7 @@ AcpiInitializeTables (
     {
         /* Root Table Array has been statically allocated by the host */
 
-        ACPI_MEMSET (InitialTableArray, 0,
+        memset (InitialTableArray, 0,
             (ACPI_SIZE) InitialTableCount * sizeof (ACPI_TABLE_DESC));
 
         AcpiGbl_RootTableList.Tables = InitialTableArray;
@@ -169,7 +161,7 @@ AcpiInitializeTables (
     return_ACPI_STATUS (Status);
 }
 
-ACPI_EXPORT_SYMBOL (AcpiInitializeTables)
+ACPI_EXPORT_SYMBOL_INIT (AcpiInitializeTables)
 
 
 /*******************************************************************************
@@ -183,7 +175,7 @@ ACPI_EXPORT_SYMBOL (AcpiInitializeTables)
  * DESCRIPTION: Reallocate Root Table List into dynamic memory. Copies the
  *              root list from the previously provided scratch area. Should
  *              be called once dynamic memory allocation is available in the
- *              kernel
+ *              kernel.
  *
  ******************************************************************************/
 
@@ -191,9 +183,7 @@ ACPI_STATUS
 AcpiReallocateRootTable (
     void)
 {
-    ACPI_TABLE_DESC         *Tables;
-    ACPI_SIZE               NewSize;
-    ACPI_SIZE               CurrentSize;
+    ACPI_STATUS             Status;
 
 
     ACPI_FUNCTION_TRACE (AcpiReallocateRootTable);
@@ -208,41 +198,13 @@ AcpiReallocateRootTable (
         return_ACPI_STATUS (AE_SUPPORT);
     }
 
-    /*
-     * Get the current size of the root table and add the default
-     * increment to create the new table size.
-     */
-    CurrentSize = (ACPI_SIZE)
-        AcpiGbl_RootTableList.CurrentTableCount * sizeof (ACPI_TABLE_DESC);
-
-    NewSize = CurrentSize +
-        (ACPI_ROOT_TABLE_SIZE_INCREMENT * sizeof (ACPI_TABLE_DESC));
-
-    /* Create new array and copy the old array */
-
-    Tables = ACPI_ALLOCATE_ZEROED (NewSize);
-    if (!Tables)
-    {
-        return_ACPI_STATUS (AE_NO_MEMORY);
-    }
-
-    ACPI_MEMCPY (Tables, AcpiGbl_RootTableList.Tables, CurrentSize);
-
-    /*
-     * Update the root table descriptor. The new size will be the current
-     * number of tables plus the increment, independent of the reserved
-     * size of the original table list.
-     */
-    AcpiGbl_RootTableList.Tables = Tables;
-    AcpiGbl_RootTableList.MaxTableCount =
-        AcpiGbl_RootTableList.CurrentTableCount + ACPI_ROOT_TABLE_SIZE_INCREMENT;
-    AcpiGbl_RootTableList.Flags =
-        ACPI_ROOT_ORIGIN_ALLOCATED | ACPI_ROOT_ALLOW_RESIZE;
+    AcpiGbl_RootTableList.Flags |= ACPI_ROOT_ALLOW_RESIZE;
 
-    return_ACPI_STATUS (AE_OK);
+    Status = AcpiTbResizeRootTableList ();
+    return_ACPI_STATUS (Status);
 }
 
-ACPI_EXPORT_SYMBOL (AcpiReallocateRootTable)
+ACPI_EXPORT_SYMBOL_INIT (AcpiReallocateRootTable)
 
 
 /*******************************************************************************
@@ -284,8 +246,8 @@ AcpiGetTableHeader (
 
     for (i = 0, j = 0; i < AcpiGbl_RootTableList.CurrentTableCount; i++)
     {
-        if (!ACPI_COMPARE_NAME (&(AcpiGbl_RootTableList.Tables[i].Signature),
-                    Signature))
+        if (!ACPI_COMPARE_NAME (
+                &(AcpiGbl_RootTableList.Tables[i].Signature), Signature))
         {
             continue;
         }
@@ -299,29 +261,29 @@ AcpiGetTableHeader (
         {
             if ((AcpiGbl_RootTableList.Tables[i].Flags &
                     ACPI_TABLE_ORIGIN_MASK) ==
-                ACPI_TABLE_ORIGIN_MAPPED)
+                ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL)
             {
                 Header = AcpiOsMapMemory (
-                            AcpiGbl_RootTableList.Tables[i].Address,
-                            sizeof (ACPI_TABLE_HEADER));
+                    AcpiGbl_RootTableList.Tables[i].Address,
+                    sizeof (ACPI_TABLE_HEADER));
                 if (!Header)
                 {
-                    return AE_NO_MEMORY;
+                    return (AE_NO_MEMORY);
                 }
 
-                ACPI_MEMCPY (OutTableHeader, Header, sizeof(ACPI_TABLE_HEADER));
-                AcpiOsUnmapMemory (Header, sizeof(ACPI_TABLE_HEADER));
+                memcpy (OutTableHeader, Header, sizeof (ACPI_TABLE_HEADER));
+                AcpiOsUnmapMemory (Header, sizeof (ACPI_TABLE_HEADER));
             }
             else
             {
-                return AE_NOT_FOUND;
+                return (AE_NOT_FOUND);
             }
         }
         else
         {
-            ACPI_MEMCPY (OutTableHeader,
+            memcpy (OutTableHeader,
                 AcpiGbl_RootTableList.Tables[i].Pointer,
-                sizeof(ACPI_TABLE_HEADER));
+                sizeof (ACPI_TABLE_HEADER));
         }
 
         return (AE_OK);
@@ -341,9 +303,10 @@ ACPI_EXPORT_SYMBOL (AcpiGetTableHeader)
  *              Instance            - Which instance (for SSDTs)
  *              OutTable            - Where the pointer to the table is returned
  *
- * RETURN:      Status and pointer to table
+ * RETURN:      Status and pointer to the requested table
  *
- * DESCRIPTION: Finds and verifies an ACPI table.
+ * DESCRIPTION: Finds and verifies an ACPI table. Table must be in the
+ *              RSDT/XSDT.
  *
  ******************************************************************************/
 
@@ -369,8 +332,8 @@ AcpiGetTable (
 
     for (i = 0, j = 0; i < AcpiGbl_RootTableList.CurrentTableCount; i++)
     {
-        if (!ACPI_COMPARE_NAME (&(AcpiGbl_RootTableList.Tables[i].Signature),
-                Signature))
+        if (!ACPI_COMPARE_NAME (
+                &(AcpiGbl_RootTableList.Tables[i].Signature), Signature))
         {
             continue;
         }
@@ -380,7 +343,7 @@ AcpiGetTable (
             continue;
         }
 
-        Status = AcpiTbVerifyTable (&AcpiGbl_RootTableList.Tables[i]);
+        Status = AcpiTbValidateTable (&AcpiGbl_RootTableList.Tables[i]);
         if (ACPI_SUCCESS (Status))
         {
             *OutTable = AcpiGbl_RootTableList.Tables[i].Pointer;
@@ -402,9 +365,10 @@ ACPI_EXPORT_SYMBOL (AcpiGetTable)
  * PARAMETERS:  TableIndex          - Table index
  *              Table               - Where the pointer to the table is returned
  *
- * RETURN:      Status and pointer to the table
+ * RETURN:      Status and pointer to the requested table
  *
- * DESCRIPTION: Obtain a table by an index into the global table list.
+ * DESCRIPTION: Obtain a table by an index into the global table list. Used
+ *              internally also.
  *
  ******************************************************************************/
 
@@ -440,7 +404,8 @@ AcpiGetTableByIndex (
     {
         /* Table is not mapped, map it */
 
-        Status = AcpiTbVerifyTable (&AcpiGbl_RootTableList.Tables[TableIndex]);
+        Status = AcpiTbValidateTable (
+            &AcpiGbl_RootTableList.Tables[TableIndex]);
         if (ACPI_FAILURE (Status))
         {
             (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
@@ -456,155 +421,6 @@ AcpiGetTableByIndex (
 ACPI_EXPORT_SYMBOL (AcpiGetTableByIndex)
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiTbLoadNamespace
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Load the namespace from the DSDT and all SSDTs/PSDTs found in
- *              the RSDT/XSDT.
- *
- ******************************************************************************/
-
-static ACPI_STATUS
-AcpiTbLoadNamespace (
-    void)
-{
-    ACPI_STATUS             Status;
-    UINT32                  i;
-    ACPI_TABLE_HEADER       *NewDsdt;
-
-
-    ACPI_FUNCTION_TRACE (TbLoadNamespace);
-
-
-    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
-
-    /*
-     * Load the namespace. The DSDT is required, but any SSDT and
-     * PSDT tables are optional. Verify the DSDT.
-     */
-    if (!AcpiGbl_RootTableList.CurrentTableCount ||
-        !ACPI_COMPARE_NAME (
-            &(AcpiGbl_RootTableList.Tables[ACPI_TABLE_INDEX_DSDT].Signature),
-            ACPI_SIG_DSDT) ||
-         ACPI_FAILURE (AcpiTbVerifyTable (
-            &AcpiGbl_RootTableList.Tables[ACPI_TABLE_INDEX_DSDT])))
-    {
-        Status = AE_NO_ACPI_TABLES;
-        goto UnlockAndExit;
-    }
-
-    /*
-     * Save the DSDT pointer for simple access. This is the mapped memory
-     * address. We must take care here because the address of the .Tables
-     * array can change dynamically as tables are loaded at run-time. Note:
-     * .Pointer field is not validated until after call to AcpiTbVerifyTable.
-     */
-    AcpiGbl_DSDT = AcpiGbl_RootTableList.Tables[ACPI_TABLE_INDEX_DSDT].Pointer;
-
-    /*
-     * Optionally copy the entire DSDT to local memory (instead of simply
-     * mapping it.) There are some BIOSs that corrupt or replace the original
-     * DSDT, creating the need for this option. Default is FALSE, do not copy
-     * the DSDT.
-     */
-    if (AcpiGbl_CopyDsdtLocally)
-    {
-        NewDsdt = AcpiTbCopyDsdt (ACPI_TABLE_INDEX_DSDT);
-        if (NewDsdt)
-        {
-            AcpiGbl_DSDT = NewDsdt;
-        }
-    }
-
-    /*
-     * Save the original DSDT header for detection of table corruption
-     * and/or replacement of the DSDT from outside the OS.
-     */
-    ACPI_MEMCPY (&AcpiGbl_OriginalDsdtHeader, AcpiGbl_DSDT,
-        sizeof (ACPI_TABLE_HEADER));
-
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-
-    /* Load and parse tables */
-
-    Status = AcpiNsLoadTable (ACPI_TABLE_INDEX_DSDT, AcpiGbl_RootNode);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Load any SSDT or PSDT tables. Note: Loop leaves tables locked */
-
-    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
-    for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; ++i)
-    {
-        if ((!ACPI_COMPARE_NAME (&(AcpiGbl_RootTableList.Tables[i].Signature),
-                    ACPI_SIG_SSDT) &&
-             !ACPI_COMPARE_NAME (&(AcpiGbl_RootTableList.Tables[i].Signature),
-                    ACPI_SIG_PSDT)) ||
-             ACPI_FAILURE (AcpiTbVerifyTable (
-                &AcpiGbl_RootTableList.Tables[i])))
-        {
-            continue;
-        }
-
-        /* Ignore errors while loading tables, get as many as possible */
-
-        (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-        (void) AcpiNsLoadTable (i, AcpiGbl_RootNode);
-        (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
-    }
-
-    ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "ACPI Tables successfully acquired\n"));
-
-UnlockAndExit:
-    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
-    return_ACPI_STATUS (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiLoadTables
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Load the ACPI tables from the RSDT/XSDT
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiLoadTables (
-    void)
-{
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_TRACE (AcpiLoadTables);
-
-
-    /* Load the namespace from the tables */
-
-    Status = AcpiTbLoadNamespace ();
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_EXCEPTION ((AE_INFO, Status,
-            "While loading namespace from ACPI tables"));
-    }
-
-    return_ACPI_STATUS (Status);
-}
-
-ACPI_EXPORT_SYMBOL (AcpiLoadTables)
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiInstallTableHandler
@@ -614,7 +430,7 @@ ACPI_EXPORT_SYMBOL (AcpiLoadTables)
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Install table event handler
+ * DESCRIPTION: Install a global table event handler.
  *
  ******************************************************************************/
 
@@ -670,7 +486,7 @@ ACPI_EXPORT_SYMBOL (AcpiInstallTableHandler)
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Remove table event handler
+ * DESCRIPTION: Remove a table event handler
  *
  ******************************************************************************/
 
@@ -709,4 +525,3 @@ Cleanup:
 }
 
 ACPI_EXPORT_SYMBOL (AcpiRemoveTableHandler)
-
diff --git a/usr/src/uts/intel/io/acpica/tables/tbxfload.c b/usr/src/uts/intel/io/acpica/tables/tbxfload.c
new file mode 100644
index 0000000000..645b9d57ac
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/tables/tbxfload.c
@@ -0,0 +1,538 @@
+/******************************************************************************
+ *
+ * Module Name: tbxfload - Table load/unload external interfaces
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define EXPORT_ACPI_INTERFACES
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acnamesp.h"
+#include "actables.h"
+#include "acevents.h"
+
+#define _COMPONENT          ACPI_TABLES
+        ACPI_MODULE_NAME    ("tbxfload")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiLoadTables
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load the ACPI tables from the RSDT/XSDT
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiLoadTables (
+    void)
+{
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (AcpiLoadTables);
+
+
+    /*
+     * Install the default operation region handlers. These are the
+     * handlers that are defined by the ACPI specification to be
+     * "always accessible" -- namely, SystemMemory, SystemIO, and
+     * PCI_Config. This also means that no _REG methods need to be
+     * run for these address spaces. We need to have these handlers
+     * installed before any AML code can be executed, especially any
+     * module-level code (11/2015).
+     * Note that we allow OSPMs to install their own region handlers
+     * between AcpiInitializeSubsystem() and AcpiLoadTables() to use
+     * their customized default region handlers.
+     */
+    Status = AcpiEvInstallRegionHandlers ();
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_EXCEPTION ((AE_INFO, Status, "During Region initialization"));
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Load the namespace from the tables */
+
+    Status = AcpiTbLoadNamespace ();
+
+    /* Don't let single failures abort the load */
+
+    if (Status == AE_CTRL_TERMINATE)
+    {
+        Status = AE_OK;
+    }
+
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_EXCEPTION ((AE_INFO, Status,
+            "While loading namespace from ACPI tables"));
+    }
+
+    if (!AcpiGbl_GroupModuleLevelCode)
+    {
+        /*
+         * Initialize the objects that remain uninitialized. This
+         * runs the executable AML that may be part of the
+         * declaration of these objects:
+         * OperationRegions, BufferFields, Buffers, and Packages.
+         */
+        Status = AcpiNsInitializeObjects ();
+        if (ACPI_FAILURE (Status))
+        {
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+    AcpiGbl_NamespaceInitialized = TRUE;
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL_INIT (AcpiLoadTables)
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbLoadNamespace
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Load the namespace from the DSDT and all SSDTs/PSDTs found in
+ *              the RSDT/XSDT.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiTbLoadNamespace (
+    void)
+{
+    ACPI_STATUS             Status;
+    UINT32                  i;
+    ACPI_TABLE_HEADER       *NewDsdt;
+    ACPI_TABLE_DESC         *Table;
+    UINT32                  TablesLoaded = 0;
+    UINT32                  TablesFailed = 0;
+
+
+    ACPI_FUNCTION_TRACE (TbLoadNamespace);
+
+
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+
+    /*
+     * Load the namespace. The DSDT is required, but any SSDT and
+     * PSDT tables are optional. Verify the DSDT.
+     */
+    Table = &AcpiGbl_RootTableList.Tables[AcpiGbl_DsdtIndex];
+
+    if (!AcpiGbl_RootTableList.CurrentTableCount ||
+        !ACPI_COMPARE_NAME (Table->Signature.Ascii, ACPI_SIG_DSDT) ||
+         ACPI_FAILURE (AcpiTbValidateTable (Table)))
+    {
+        Status = AE_NO_ACPI_TABLES;
+        goto UnlockAndExit;
+    }
+
+    /*
+     * Save the DSDT pointer for simple access. This is the mapped memory
+     * address. We must take care here because the address of the .Tables
+     * array can change dynamically as tables are loaded at run-time. Note:
+     * .Pointer field is not validated until after call to AcpiTbValidateTable.
+     */
+    AcpiGbl_DSDT = Table->Pointer;
+
+    /*
+     * Optionally copy the entire DSDT to local memory (instead of simply
+     * mapping it.) There are some BIOSs that corrupt or replace the original
+     * DSDT, creating the need for this option. Default is FALSE, do not copy
+     * the DSDT.
+     */
+    if (AcpiGbl_CopyDsdtLocally)
+    {
+        NewDsdt = AcpiTbCopyDsdt (AcpiGbl_DsdtIndex);
+        if (NewDsdt)
+        {
+            AcpiGbl_DSDT = NewDsdt;
+        }
+    }
+
+    /*
+     * Save the original DSDT header for detection of table corruption
+     * and/or replacement of the DSDT from outside the OS.
+     */
+    memcpy (&AcpiGbl_OriginalDsdtHeader, AcpiGbl_DSDT,
+        sizeof (ACPI_TABLE_HEADER));
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+
+    /* Load and parse tables */
+
+    Status = AcpiNsLoadTable (AcpiGbl_DsdtIndex, AcpiGbl_RootNode);
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_EXCEPTION ((AE_INFO, Status, "[DSDT] table load failed"));
+        TablesFailed++;
+    }
+    else
+    {
+        TablesLoaded++;
+    }
+
+    /* Load any SSDT or PSDT tables. Note: Loop leaves tables locked */
+
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; ++i)
+    {
+        Table = &AcpiGbl_RootTableList.Tables[i];
+
+        if (!AcpiGbl_RootTableList.Tables[i].Address ||
+            (!ACPI_COMPARE_NAME (Table->Signature.Ascii, ACPI_SIG_SSDT) &&
+             !ACPI_COMPARE_NAME (Table->Signature.Ascii, ACPI_SIG_PSDT) &&
+             !ACPI_COMPARE_NAME (Table->Signature.Ascii, ACPI_SIG_OSDT)) ||
+             ACPI_FAILURE (AcpiTbValidateTable (Table)))
+        {
+            continue;
+        }
+
+        /* Ignore errors while loading tables, get as many as possible */
+
+        (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+        Status =  AcpiNsLoadTable (i, AcpiGbl_RootNode);
+        if (ACPI_FAILURE (Status))
+        {
+            ACPI_EXCEPTION ((AE_INFO, Status, "(%4.4s:%8.8s) while loading table",
+                Table->Signature.Ascii, Table->Pointer->OemTableId));
+
+            TablesFailed++;
+
+            ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
+                "Table [%4.4s:%8.8s] (id FF) - Table namespace load failed\n\n",
+                Table->Signature.Ascii, Table->Pointer->OemTableId));
+        }
+        else
+        {
+            TablesLoaded++;
+        }
+
+        (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+    }
+
+    if (!TablesFailed)
+    {
+        ACPI_INFO ((
+            "%u ACPI AML tables successfully acquired and loaded\n",
+            TablesLoaded));
+    }
+    else
+    {
+        ACPI_ERROR ((AE_INFO,
+            "%u table load failures, %u successful",
+            TablesFailed, TablesLoaded));
+
+        /* Indicate at least one failure */
+
+        Status = AE_CTRL_TERMINATE;
+    }
+
+UnlockAndExit:
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiInstallTable
+ *
+ * PARAMETERS:  Address             - Address of the ACPI table to be installed.
+ *              Physical            - Whether the address is a physical table
+ *                                    address or not
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Dynamically install an ACPI table.
+ *              Note: This function should only be invoked after
+ *                    AcpiInitializeTables() and before AcpiLoadTables().
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiInstallTable (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    BOOLEAN                 Physical)
+{
+    ACPI_STATUS             Status;
+    UINT8                   Flags;
+    UINT32                  TableIndex;
+
+
+    ACPI_FUNCTION_TRACE (AcpiInstallTable);
+
+
+    if (Physical)
+    {
+        Flags = ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL;
+    }
+    else
+    {
+        Flags = ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL;
+    }
+
+    Status = AcpiTbInstallStandardTable (Address, Flags,
+        FALSE, FALSE, &TableIndex);
+
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL_INIT (AcpiInstallTable)
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiLoadTable
+ *
+ * PARAMETERS:  Table               - Pointer to a buffer containing the ACPI
+ *                                    table to be loaded.
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Dynamically load an ACPI table from the caller's buffer. Must
+ *              be a valid ACPI table with a valid ACPI table header.
+ *              Note1: Mainly intended to support hotplug addition of SSDTs.
+ *              Note2: Does not copy the incoming table. User is responsible
+ *              to ensure that the table is not deleted or unmapped.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiLoadTable (
+    ACPI_TABLE_HEADER       *Table)
+{
+    ACPI_STATUS             Status;
+    UINT32                  TableIndex;
+
+
+    ACPI_FUNCTION_TRACE (AcpiLoadTable);
+
+
+    /* Parameter validation */
+
+    if (!Table)
+    {
+        return_ACPI_STATUS (AE_BAD_PARAMETER);
+    }
+
+    /* Must acquire the interpreter lock during this operation */
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_INTERPRETER);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Install the table and load it into the namespace */
+
+    ACPI_INFO (("Host-directed Dynamic ACPI Table Load:"));
+    (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
+
+    Status = AcpiTbInstallStandardTable (ACPI_PTR_TO_PHYSADDR (Table),
+        ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL, TRUE, FALSE,
+        &TableIndex);
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_TABLES);
+    if (ACPI_FAILURE (Status))
+    {
+        goto UnlockAndExit;
+    }
+
+    /*
+     * Note: Now table is "INSTALLED", it must be validated before
+     * using.
+     */
+    Status = AcpiTbValidateTable (
+        &AcpiGbl_RootTableList.Tables[TableIndex]);
+    if (ACPI_FAILURE (Status))
+    {
+        goto UnlockAndExit;
+    }
+
+    Status = AcpiNsLoadTable (TableIndex, AcpiGbl_RootNode);
+
+    /* Invoke table handler if present */
+
+    if (AcpiGbl_TableHandler)
+    {
+        (void) AcpiGbl_TableHandler (ACPI_TABLE_EVENT_LOAD, Table,
+            AcpiGbl_TableHandlerContext);
+    }
+
+UnlockAndExit:
+    (void) AcpiUtReleaseMutex (ACPI_MTX_INTERPRETER);
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiLoadTable)
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUnloadParentTable
+ *
+ * PARAMETERS:  Object              - Handle to any namespace object owned by
+ *                                    the table to be unloaded
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Via any namespace object within an SSDT or OEMx table, unloads
+ *              the table and deletes all namespace objects associated with
+ *              that table. Unloading of the DSDT is not allowed.
+ *              Note: Mainly intended to support hotplug removal of SSDTs.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiUnloadParentTable (
+    ACPI_HANDLE             Object)
+{
+    ACPI_NAMESPACE_NODE     *Node = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Object);
+    ACPI_STATUS             Status = AE_NOT_EXIST;
+    ACPI_OWNER_ID           OwnerId;
+    UINT32                  i;
+
+
+    ACPI_FUNCTION_TRACE (AcpiUnloadParentTable);
+
+
+    /* Parameter validation */
+
+    if (!Object)
+    {
+        return_ACPI_STATUS (AE_BAD_PARAMETER);
+    }
+
+    /*
+     * The node OwnerId is currently the same as the parent table ID.
+     * However, this could change in the future.
+     */
+    OwnerId = Node->OwnerId;
+    if (!OwnerId)
+    {
+        /* OwnerId==0 means DSDT is the owner. DSDT cannot be unloaded */
+
+        return_ACPI_STATUS (AE_TYPE);
+    }
+
+    /* Must acquire the interpreter lock during this operation */
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_INTERPRETER);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Find the table in the global table list */
+
+    for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; i++)
+    {
+        if (OwnerId != AcpiGbl_RootTableList.Tables[i].OwnerId)
+        {
+            continue;
+        }
+
+        /*
+         * Allow unload of SSDT and OEMx tables only. Do not allow unload
+         * of the DSDT. No other types of tables should get here, since
+         * only these types can contain AML and thus are the only types
+         * that can create namespace objects.
+         */
+        if (ACPI_COMPARE_NAME (
+                AcpiGbl_RootTableList.Tables[i].Signature.Ascii,
+                ACPI_SIG_DSDT))
+        {
+            Status = AE_TYPE;
+            break;
+        }
+
+        /* Ensure the table is actually loaded */
+
+        if (!AcpiTbIsTableLoaded (i))
+        {
+            Status = AE_NOT_EXIST;
+            break;
+        }
+
+        /* Invoke table handler if present */
+
+        if (AcpiGbl_TableHandler)
+        {
+            (void) AcpiGbl_TableHandler (ACPI_TABLE_EVENT_UNLOAD,
+                AcpiGbl_RootTableList.Tables[i].Pointer,
+                AcpiGbl_TableHandlerContext);
+        }
+
+        /*
+         * Delete all namespace objects owned by this table. Note that
+         * these objects can appear anywhere in the namespace by virtue
+         * of the AML "Scope" operator. Thus, we need to track ownership
+         * by an ID, not simply a position within the hierarchy.
+         */
+        Status = AcpiTbDeleteNamespaceByOwner (i);
+        if (ACPI_FAILURE (Status))
+        {
+            break;
+        }
+
+        Status = AcpiTbReleaseOwnerId (i);
+        AcpiTbSetTableLoadedFlag (i, FALSE);
+        break;
+    }
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_INTERPRETER);
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiUnloadParentTable)
diff --git a/usr/src/uts/intel/io/acpica/tables/tbxfroot.c b/usr/src/uts/intel/io/acpica/tables/tbxfroot.c
index 17e52ef7f4..aaa24c470f 100644
--- a/usr/src/uts/intel/io/acpica/tables/tbxfroot.c
+++ b/usr/src/uts/intel/io/acpica/tables/tbxfroot.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __TBXFROOT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "actables.h"
@@ -51,16 +49,42 @@
 #define _COMPONENT          ACPI_TABLES
         ACPI_MODULE_NAME    ("tbxfroot")
 
-/* Local prototypes */
 
-static UINT8 *
-AcpiTbScanMemoryForRsdp (
-    UINT8                   *StartAddress,
-    UINT32                  Length);
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTbGetRsdpLength
+ *
+ * PARAMETERS:  Rsdp                - Pointer to RSDP
+ *
+ * RETURN:      Table length
+ *
+ * DESCRIPTION: Get the length of the RSDP
+ *
+ ******************************************************************************/
 
-static ACPI_STATUS
-AcpiTbValidateRsdp (
-    ACPI_TABLE_RSDP         *Rsdp);
+UINT32
+AcpiTbGetRsdpLength (
+    ACPI_TABLE_RSDP         *Rsdp)
+{
+
+    if (!ACPI_VALIDATE_RSDP_SIG (Rsdp->Signature))
+    {
+        /* BAD Signature */
+
+        return (0);
+    }
+
+    /* "Length" field is available if table version >= 2 */
+
+    if (Rsdp->Revision >= 2)
+    {
+        return (Rsdp->Length);
+    }
+    else
+    {
+        return (ACPI_RSDP_CHECKSUM_LENGTH);
+    }
+}
 
 
 /*******************************************************************************
@@ -75,12 +99,10 @@ AcpiTbValidateRsdp (
  *
  ******************************************************************************/
 
-static ACPI_STATUS
+ACPI_STATUS
 AcpiTbValidateRsdp (
     ACPI_TABLE_RSDP         *Rsdp)
 {
-    ACPI_FUNCTION_ENTRY ();
-
 
     /*
      * The signature and checksum must both be correct
@@ -88,8 +110,7 @@ AcpiTbValidateRsdp (
      * Note: Sometimes there exists more than one RSDP in memory; the valid
      * RSDP has a valid checksum, all others have an invalid checksum.
      */
-    if (ACPI_STRNCMP ((char *) Rsdp, ACPI_SIG_RSDP,
-            sizeof (ACPI_SIG_RSDP)-1) != 0)
+    if (!ACPI_VALIDATE_RSDP_SIG (Rsdp->Signature))
     {
         /* Nope, BAD Signature */
 
@@ -124,7 +145,7 @@ AcpiTbValidateRsdp (
  * RETURN:      Status, RSDP physical address
  *
  * DESCRIPTION: Search lower 1Mbyte of memory for the root system descriptor
- *              pointer structure.  If it is found, set *RSDP to point to it.
+ *              pointer structure. If it is found, set *RSDP to point to it.
  *
  * NOTE1:       The RSDP must be either in the first 1K of the Extended
  *              BIOS Data Area or between E0000 and FFFFF (From ACPI Spec.)
@@ -137,7 +158,7 @@ AcpiTbValidateRsdp (
 
 ACPI_STATUS
 AcpiFindRootPointer (
-    ACPI_SIZE               *TableAddress)
+    ACPI_PHYSICAL_ADDRESS   *TableAddress)
 {
     UINT8                   *TablePtr;
     UINT8                   *MemRover;
@@ -150,8 +171,8 @@ AcpiFindRootPointer (
     /* 1a) Get the location of the Extended BIOS Data Area (EBDA) */
 
     TablePtr = AcpiOsMapMemory (
-                (ACPI_PHYSICAL_ADDRESS) ACPI_EBDA_PTR_LOCATION,
-                ACPI_EBDA_PTR_LENGTH);
+        (ACPI_PHYSICAL_ADDRESS) ACPI_EBDA_PTR_LOCATION,
+        ACPI_EBDA_PTR_LENGTH);
     if (!TablePtr)
     {
         ACPI_ERROR ((AE_INFO,
@@ -177,8 +198,8 @@ AcpiFindRootPointer (
          *     minimum of 1K length)
          */
         TablePtr = AcpiOsMapMemory (
-                    (ACPI_PHYSICAL_ADDRESS) PhysicalAddress,
-                    ACPI_EBDA_WINDOW_SIZE);
+            (ACPI_PHYSICAL_ADDRESS) PhysicalAddress,
+            ACPI_EBDA_WINDOW_SIZE);
         if (!TablePtr)
         {
             ACPI_ERROR ((AE_INFO,
@@ -188,16 +209,18 @@ AcpiFindRootPointer (
             return_ACPI_STATUS (AE_NO_MEMORY);
         }
 
-        MemRover = AcpiTbScanMemoryForRsdp (TablePtr, ACPI_EBDA_WINDOW_SIZE);
+        MemRover = AcpiTbScanMemoryForRsdp (
+            TablePtr, ACPI_EBDA_WINDOW_SIZE);
         AcpiOsUnmapMemory (TablePtr, ACPI_EBDA_WINDOW_SIZE);
 
         if (MemRover)
         {
             /* Return the physical address */
 
-            PhysicalAddress += (UINT32) ACPI_PTR_DIFF (MemRover, TablePtr);
+            PhysicalAddress +=
+                (UINT32) ACPI_PTR_DIFF (MemRover, TablePtr);
 
-            *TableAddress = PhysicalAddress;
+            *TableAddress = (ACPI_PHYSICAL_ADDRESS) PhysicalAddress;
             return_ACPI_STATUS (AE_OK);
         }
     }
@@ -206,8 +229,8 @@ AcpiFindRootPointer (
      * 2) Search upper memory: 16-byte boundaries in E0000h-FFFFFh
      */
     TablePtr = AcpiOsMapMemory (
-                (ACPI_PHYSICAL_ADDRESS) ACPI_HI_RSDP_WINDOW_BASE,
-                ACPI_HI_RSDP_WINDOW_SIZE);
+        (ACPI_PHYSICAL_ADDRESS) ACPI_HI_RSDP_WINDOW_BASE,
+        ACPI_HI_RSDP_WINDOW_SIZE);
 
     if (!TablePtr)
     {
@@ -218,7 +241,8 @@ AcpiFindRootPointer (
         return_ACPI_STATUS (AE_NO_MEMORY);
     }
 
-    MemRover = AcpiTbScanMemoryForRsdp (TablePtr, ACPI_HI_RSDP_WINDOW_SIZE);
+    MemRover = AcpiTbScanMemoryForRsdp (
+        TablePtr, ACPI_HI_RSDP_WINDOW_SIZE);
     AcpiOsUnmapMemory (TablePtr, ACPI_HI_RSDP_WINDOW_SIZE);
 
     if (MemRover)
@@ -228,13 +252,13 @@ AcpiFindRootPointer (
         PhysicalAddress = (UINT32)
             (ACPI_HI_RSDP_WINDOW_BASE + ACPI_PTR_DIFF (MemRover, TablePtr));
 
-        *TableAddress = PhysicalAddress;
+        *TableAddress = (ACPI_PHYSICAL_ADDRESS) PhysicalAddress;
         return_ACPI_STATUS (AE_OK);
     }
 
     /* A valid RSDP was not found */
 
-    ACPI_ERROR ((AE_INFO, "A valid RSDP was not found"));
+    ACPI_BIOS_ERROR ((AE_INFO, "A valid RSDP was not found"));
     return_ACPI_STATUS (AE_NOT_FOUND);
 }
 
@@ -254,7 +278,7 @@ ACPI_EXPORT_SYMBOL (AcpiFindRootPointer)
  *
  ******************************************************************************/
 
-static UINT8 *
+UINT8 *
 AcpiTbScanMemoryForRsdp (
     UINT8                   *StartAddress,
     UINT32                  Length)
@@ -276,7 +300,8 @@ AcpiTbScanMemoryForRsdp (
     {
         /* The RSDP signature and checksum must both be correct */
 
-        Status = AcpiTbValidateRsdp (ACPI_CAST_PTR (ACPI_TABLE_RSDP, MemRover));
+        Status = AcpiTbValidateRsdp (
+            ACPI_CAST_PTR (ACPI_TABLE_RSDP, MemRover));
         if (ACPI_SUCCESS (Status))
         {
             /* Sig and checksum valid, we have found a real RSDP */
@@ -296,4 +321,3 @@ AcpiTbScanMemoryForRsdp (
         StartAddress));
     return_PTR (NULL);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utaddress.c b/usr/src/uts/intel/io/acpica/utilities/utaddress.c
index 0b357b681b..4b36391e24 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utaddress.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utaddress.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTADDRESS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -119,10 +117,10 @@ AcpiUtAddAddressRange (
     AcpiGbl_AddressRangeList[SpaceId] = RangeInfo;
 
     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-        "\nAdded [%4.4s] address range: 0x%p-0x%p\n",
+        "\nAdded [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\n",
         AcpiUtGetNodeName (RangeInfo->RegionNode),
-        ACPI_CAST_PTR (void, Address),
-        ACPI_CAST_PTR (void, RangeInfo->EndAddress)));
+        ACPI_FORMAT_UINT64 (Address),
+        ACPI_FORMAT_UINT64 (RangeInfo->EndAddress)));
 
     (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
     return_ACPI_STATUS (AE_OK);
@@ -181,10 +179,10 @@ AcpiUtRemoveAddressRange (
             }
 
             ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
-                "\nRemoved [%4.4s] address range: 0x%p-0x%p\n",
+                "\nRemoved [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\n",
                 AcpiUtGetNodeName (RangeInfo->RegionNode),
-                ACPI_CAST_PTR (void, RangeInfo->StartAddress),
-                ACPI_CAST_PTR (void, RangeInfo->EndAddress)));
+                ACPI_FORMAT_UINT64 (RangeInfo->StartAddress),
+                ACPI_FORMAT_UINT64 (RangeInfo->EndAddress)));
 
             ACPI_FREE (RangeInfo);
             return_VOID;
@@ -248,10 +246,11 @@ AcpiUtCheckAddressRange (
     while (RangeInfo)
     {
         /*
-         * Check if the requested Address/Length overlaps this AddressRange.
-         * Four cases to consider:
+         * Check if the requested address/length overlaps this
+         * address range. There are four cases to consider:
          *
-         * 1) Input address/length is contained completely in the address range
+         * 1) Input address/length is contained completely in the
+         *    address range
          * 2) Input address/length overlaps range at the range start
          * 3) Input address/length overlaps range at the range end
          * 4) Input address/length completely encompasses the range
@@ -264,13 +263,16 @@ AcpiUtCheckAddressRange (
             OverlapCount++;
             if (Warn)   /* Optional warning message */
             {
-                Pathname = AcpiNsGetExternalPathname (RangeInfo->RegionNode);
+                Pathname = AcpiNsGetNormalizedPathname (RangeInfo->RegionNode, TRUE);
 
                 ACPI_WARNING ((AE_INFO,
-                    "0x%p-0x%p %s conflicts with Region %s %d",
-                    ACPI_CAST_PTR (void, Address),
-                    ACPI_CAST_PTR (void, EndAddress),
-                    AcpiUtGetRegionName (SpaceId), Pathname, OverlapCount));
+                    "%s range 0x%8.8X%8.8X-0x%8.8X%8.8X conflicts with OpRegion 0x%8.8X%8.8X-0x%8.8X%8.8X (%s)",
+                    AcpiUtGetRegionName (SpaceId),
+                    ACPI_FORMAT_UINT64 (Address),
+                    ACPI_FORMAT_UINT64 (EndAddress),
+                    ACPI_FORMAT_UINT64 (RangeInfo->StartAddress),
+                    ACPI_FORMAT_UINT64 (RangeInfo->EndAddress),
+                    Pathname));
                 ACPI_FREE (Pathname);
             }
         }
diff --git a/usr/src/uts/intel/io/acpica/utilities/utalloc.c b/usr/src/uts/intel/io/acpica/utilities/utalloc.c
index d2eb11edcb..bb29586e89 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utalloc.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utalloc.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTALLOC_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acdebug.h"
@@ -51,6 +49,45 @@
         ACPI_MODULE_NAME    ("utalloc")
 
 
+#if !defined (USE_NATIVE_ALLOCATE_ZEROED)
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiOsAllocateZeroed
+ *
+ * PARAMETERS:  Size                - Size of the allocation
+ *
+ * RETURN:      Address of the allocated memory on success, NULL on failure.
+ *
+ * DESCRIPTION: Subsystem equivalent of calloc. Allocate and zero memory.
+ *              This is the default implementation. Can be overridden via the
+ *              USE_NATIVE_ALLOCATE_ZEROED flag.
+ *
+ ******************************************************************************/
+
+void *
+AcpiOsAllocateZeroed (
+    ACPI_SIZE               Size)
+{
+    void                    *Allocation;
+
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    Allocation = AcpiOsAllocate (Size);
+    if (Allocation)
+    {
+        /* Clear the memory block */
+
+        memset (Allocation, 0, Size);
+    }
+
+    return (Allocation);
+}
+
+#endif /* !USE_NATIVE_ALLOCATE_ZEROED */
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiUtCreateCaches
@@ -73,35 +110,35 @@ AcpiUtCreateCaches (
     /* Object Caches, for frequently used objects */
 
     Status = AcpiOsCreateCache ("Acpi-Namespace", sizeof (ACPI_NAMESPACE_NODE),
-                ACPI_MAX_NAMESPACE_CACHE_DEPTH, &AcpiGbl_NamespaceCache);
+        ACPI_MAX_NAMESPACE_CACHE_DEPTH, &AcpiGbl_NamespaceCache);
     if (ACPI_FAILURE (Status))
     {
         return (Status);
     }
 
     Status = AcpiOsCreateCache ("Acpi-State", sizeof (ACPI_GENERIC_STATE),
-                ACPI_MAX_STATE_CACHE_DEPTH, &AcpiGbl_StateCache);
+        ACPI_MAX_STATE_CACHE_DEPTH, &AcpiGbl_StateCache);
     if (ACPI_FAILURE (Status))
     {
         return (Status);
     }
 
     Status = AcpiOsCreateCache ("Acpi-Parse", sizeof (ACPI_PARSE_OBJ_COMMON),
-                ACPI_MAX_PARSE_CACHE_DEPTH, &AcpiGbl_PsNodeCache);
+        ACPI_MAX_PARSE_CACHE_DEPTH, &AcpiGbl_PsNodeCache);
     if (ACPI_FAILURE (Status))
     {
         return (Status);
     }
 
     Status = AcpiOsCreateCache ("Acpi-ParseExt", sizeof (ACPI_PARSE_OBJ_NAMED),
-                ACPI_MAX_EXTPARSE_CACHE_DEPTH, &AcpiGbl_PsNodeExtCache);
+        ACPI_MAX_EXTPARSE_CACHE_DEPTH, &AcpiGbl_PsNodeExtCache);
     if (ACPI_FAILURE (Status))
     {
         return (Status);
     }
 
     Status = AcpiOsCreateCache ("Acpi-Operand", sizeof (ACPI_OPERAND_OBJECT),
-                ACPI_MAX_OBJECT_CACHE_DEPTH, &AcpiGbl_OperandCache);
+        ACPI_MAX_OBJECT_CACHE_DEPTH, &AcpiGbl_OperandCache);
     if (ACPI_FAILURE (Status))
     {
         return (Status);
@@ -113,14 +150,14 @@ AcpiUtCreateCaches (
     /* Memory allocation lists */
 
     Status = AcpiUtCreateList ("Acpi-Global", 0,
-                &AcpiGbl_GlobalList);
+        &AcpiGbl_GlobalList);
     if (ACPI_FAILURE (Status))
     {
         return (Status);
     }
 
     Status = AcpiUtCreateList ("Acpi-Namespace", sizeof (ACPI_NAMESPACE_NODE),
-                &AcpiGbl_NsNodeList);
+        &AcpiGbl_NsNodeList);
     if (ACPI_FAILURE (Status))
     {
         return (Status);
@@ -150,9 +187,10 @@ AcpiUtDeleteCaches (
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
     char                    Buffer[7];
 
+
     if (AcpiGbl_DisplayFinalMemStats)
     {
-        ACPI_STRCPY (Buffer, "MEMORY");
+        strcpy (Buffer, "MEMORY");
         (void) AcpiDbDisplayStatistics (Buffer);
     }
 #endif
@@ -285,9 +323,13 @@ AcpiUtInitializeBuffer (
         return (AE_BUFFER_OVERFLOW);
 
     case ACPI_ALLOCATE_BUFFER:
-
-        /* Allocate a new buffer */
-
+        /*
+         * Allocate a new buffer. We directectly call AcpiOsAllocate here to
+         * purposefully bypass the (optionally enabled) internal allocation
+         * tracking mechanism since we only want to track internal
+         * allocations. Note: The caller should use AcpiOsFree to free this
+         * buffer created via ACPI_ALLOCATE_BUFFER.
+         */
         Buffer->Pointer = AcpiOsAllocate (RequiredLength);
         break;
 
@@ -318,99 +360,6 @@ AcpiUtInitializeBuffer (
 
     /* Have a valid buffer, clear it */
 
-    ACPI_MEMSET (Buffer->Pointer, 0, RequiredLength);
+    memset (Buffer->Pointer, 0, RequiredLength);
     return (AE_OK);
 }
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtAllocate
- *
- * PARAMETERS:  Size                - Size of the allocation
- *              Component           - Component type of caller
- *              Module              - Source file name of caller
- *              Line                - Line number of caller
- *
- * RETURN:      Address of the allocated memory on success, NULL on failure.
- *
- * DESCRIPTION: Subsystem equivalent of malloc.
- *
- ******************************************************************************/
-
-void *
-AcpiUtAllocate (
-    ACPI_SIZE               Size,
-    UINT32                  Component,
-    const char              *Module,
-    UINT32                  Line)
-{
-    void                    *Allocation;
-
-
-    ACPI_FUNCTION_TRACE_U32 (UtAllocate, Size);
-
-
-    /* Check for an inadvertent size of zero bytes */
-
-    if (!Size)
-    {
-        ACPI_WARNING ((Module, Line,
-            "Attempt to allocate zero bytes, allocating 1 byte"));
-        Size = 1;
-    }
-
-    Allocation = AcpiOsAllocate (Size);
-    if (!Allocation)
-    {
-        /* Report allocation error */
-
-        ACPI_WARNING ((Module, Line,
-            "Could not allocate size %u", (UINT32) Size));
-
-        return_PTR (NULL);
-    }
-
-    return_PTR (Allocation);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtAllocateZeroed
- *
- * PARAMETERS:  Size                - Size of the allocation
- *              Component           - Component type of caller
- *              Module              - Source file name of caller
- *              Line                - Line number of caller
- *
- * RETURN:      Address of the allocated memory on success, NULL on failure.
- *
- * DESCRIPTION: Subsystem equivalent of calloc. Allocate and zero memory.
- *
- ******************************************************************************/
-
-void *
-AcpiUtAllocateZeroed (
-    ACPI_SIZE               Size,
-    UINT32                  Component,
-    const char              *Module,
-    UINT32                  Line)
-{
-    void                    *Allocation;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    Allocation = AcpiUtAllocate (Size, Component, Module, Line);
-    if (Allocation)
-    {
-        /* Clear the memory block */
-
-        ACPI_MEMSET (Allocation, 0, Size);
-    }
-
-    return (Allocation);
-}
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utascii.c b/usr/src/uts/intel/io/acpica/utilities/utascii.c
new file mode 100644
index 0000000000..25c02e674e
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utascii.c
@@ -0,0 +1,161 @@
+/******************************************************************************
+ *
+ * Module Name: utascii - Utility ascii functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtValidNameseg
+ *
+ * PARAMETERS:  Name            - The name or table signature to be examined.
+ *                                Four characters, does not have to be a
+ *                                NULL terminated string.
+ *
+ * RETURN:      TRUE if signature is has 4 valid ACPI characters
+ *
+ * DESCRIPTION: Validate an ACPI table signature.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AcpiUtValidNameseg (
+    char                    *Name)
+{
+    UINT32                  i;
+
+
+    /* Validate each character in the signature */
+
+    for (i = 0; i < ACPI_NAME_SIZE; i++)
+    {
+        if (!AcpiUtValidNameChar (Name[i], i))
+        {
+            return (FALSE);
+        }
+    }
+
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtValidNameChar
+ *
+ * PARAMETERS:  Char            - The character to be examined
+ *              Position        - Byte position (0-3)
+ *
+ * RETURN:      TRUE if the character is valid, FALSE otherwise
+ *
+ * DESCRIPTION: Check for a valid ACPI character. Must be one of:
+ *              1) Upper case alpha
+ *              2) numeric
+ *              3) underscore
+ *
+ *              We allow a '!' as the last character because of the ASF! table
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AcpiUtValidNameChar (
+    char                    Character,
+    UINT32                  Position)
+{
+
+    if (!((Character >= 'A' && Character <= 'Z') ||
+          (Character >= '0' && Character <= '9') ||
+          (Character == '_')))
+    {
+        /* Allow a '!' in the last position */
+
+        if (Character == '!' && Position == 3)
+        {
+            return (TRUE);
+        }
+
+        return (FALSE);
+    }
+
+    return (TRUE);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtCheckAndRepairAscii
+ *
+ * PARAMETERS:  Name                - Ascii string
+ *              Count               - Number of characters to check
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Ensure that the requested number of characters are printable
+ *              Ascii characters. Sets non-printable and null chars to <space>.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtCheckAndRepairAscii (
+    UINT8                   *Name,
+    char                    *RepairedName,
+    UINT32                  Count)
+{
+    UINT32                  i;
+
+
+    for (i = 0; i < Count; i++)
+    {
+        RepairedName[i] = (char) Name[i];
+
+        if (!Name[i])
+        {
+            return;
+        }
+        if (!isprint (Name[i]))
+        {
+            RepairedName[i] = ' ';
+        }
+    }
+}
diff --git a/usr/src/uts/intel/io/acpica/utilities/utbuffer.c b/usr/src/uts/intel/io/acpica/utilities/utbuffer.c
new file mode 100644
index 0000000000..863055f737
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utbuffer.c
@@ -0,0 +1,362 @@
+/******************************************************************************
+ *
+ * Module Name: utbuffer - Buffer dump routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("utbuffer")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtDumpBuffer
+ *
+ * PARAMETERS:  Buffer              - Buffer to dump
+ *              Count               - Amount to dump, in bytes
+ *              Display             - BYTE, WORD, DWORD, or QWORD display:
+ *                                      DB_BYTE_DISPLAY
+ *                                      DB_WORD_DISPLAY
+ *                                      DB_DWORD_DISPLAY
+ *                                      DB_QWORD_DISPLAY
+ *              BaseOffset          - Beginning buffer offset (display only)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generic dump buffer in both hex and ascii.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtDumpBuffer (
+    UINT8                   *Buffer,
+    UINT32                  Count,
+    UINT32                  Display,
+    UINT32                  BaseOffset)
+{
+    UINT32                  i = 0;
+    UINT32                  j;
+    UINT32                  Temp32;
+    UINT8                   BufChar;
+
+
+    if (!Buffer)
+    {
+        AcpiOsPrintf ("Null Buffer Pointer in DumpBuffer!\n");
+        return;
+    }
+
+    if ((Count < 4) || (Count & 0x01))
+    {
+        Display = DB_BYTE_DISPLAY;
+    }
+
+    /* Nasty little dump buffer routine! */
+
+    while (i < Count)
+    {
+        /* Print current offset */
+
+        AcpiOsPrintf ("%6.4X: ", (BaseOffset + i));
+
+        /* Print 16 hex chars */
+
+        for (j = 0; j < 16;)
+        {
+            if (i + j >= Count)
+            {
+                /* Dump fill spaces */
+
+                AcpiOsPrintf ("%*s", ((Display * 2) + 1), " ");
+                j += Display;
+                continue;
+            }
+
+            switch (Display)
+            {
+            case DB_BYTE_DISPLAY:
+            default:    /* Default is BYTE display */
+
+                AcpiOsPrintf ("%02X ", Buffer[(ACPI_SIZE) i + j]);
+                break;
+
+            case DB_WORD_DISPLAY:
+
+                ACPI_MOVE_16_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
+                AcpiOsPrintf ("%04X ", Temp32);
+                break;
+
+            case DB_DWORD_DISPLAY:
+
+                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
+                AcpiOsPrintf ("%08X ", Temp32);
+                break;
+
+            case DB_QWORD_DISPLAY:
+
+                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
+                AcpiOsPrintf ("%08X", Temp32);
+
+                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j + 4]);
+                AcpiOsPrintf ("%08X ", Temp32);
+                break;
+            }
+
+            j += Display;
+        }
+
+        /*
+         * Print the ASCII equivalent characters but watch out for the bad
+         * unprintable ones (printable chars are 0x20 through 0x7E)
+         */
+        AcpiOsPrintf (" ");
+        for (j = 0; j < 16; j++)
+        {
+            if (i + j >= Count)
+            {
+                AcpiOsPrintf ("\n");
+                return;
+            }
+
+            /*
+             * Add comment characters so rest of line is ignored when
+             * compiled
+             */
+            if (j == 0)
+            {
+                AcpiOsPrintf ("// ");
+            }
+
+            BufChar = Buffer[(ACPI_SIZE) i + j];
+            if (isprint (BufChar))
+            {
+                AcpiOsPrintf ("%c", BufChar);
+            }
+            else
+            {
+                AcpiOsPrintf (".");
+            }
+        }
+
+        /* Done with that line. */
+
+        AcpiOsPrintf ("\n");
+        i += 16;
+    }
+
+    return;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtDebugDumpBuffer
+ *
+ * PARAMETERS:  Buffer              - Buffer to dump
+ *              Count               - Amount to dump, in bytes
+ *              Display             - BYTE, WORD, DWORD, or QWORD display:
+ *                                      DB_BYTE_DISPLAY
+ *                                      DB_WORD_DISPLAY
+ *                                      DB_DWORD_DISPLAY
+ *                                      DB_QWORD_DISPLAY
+ *              ComponentID         - Caller's component ID
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generic dump buffer in both hex and ascii.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtDebugDumpBuffer (
+    UINT8                   *Buffer,
+    UINT32                  Count,
+    UINT32                  Display,
+    UINT32                  ComponentId)
+{
+
+    /* Only dump the buffer if tracing is enabled */
+
+    if (!((ACPI_LV_TABLES & AcpiDbgLevel) &&
+        (ComponentId & AcpiDbgLayer)))
+    {
+        return;
+    }
+
+    AcpiUtDumpBuffer (Buffer, Count, Display, 0);
+}
+
+
+#ifdef ACPI_APPLICATION
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtDumpBufferToFile
+ *
+ * PARAMETERS:  File                - File descriptor
+ *              Buffer              - Buffer to dump
+ *              Count               - Amount to dump, in bytes
+ *              Display             - BYTE, WORD, DWORD, or QWORD display:
+ *                                      DB_BYTE_DISPLAY
+ *                                      DB_WORD_DISPLAY
+ *                                      DB_DWORD_DISPLAY
+ *                                      DB_QWORD_DISPLAY
+ *              BaseOffset          - Beginning buffer offset (display only)
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Generic dump buffer in both hex and ascii to a file.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtDumpBufferToFile (
+    ACPI_FILE               File,
+    UINT8                   *Buffer,
+    UINT32                  Count,
+    UINT32                  Display,
+    UINT32                  BaseOffset)
+{
+    UINT32                  i = 0;
+    UINT32                  j;
+    UINT32                  Temp32;
+    UINT8                   BufChar;
+
+
+    if (!Buffer)
+    {
+        AcpiUtFilePrintf (File, "Null Buffer Pointer in DumpBuffer!\n");
+        return;
+    }
+
+    if ((Count < 4) || (Count & 0x01))
+    {
+        Display = DB_BYTE_DISPLAY;
+    }
+
+    /* Nasty little dump buffer routine! */
+
+    while (i < Count)
+    {
+        /* Print current offset */
+
+        AcpiUtFilePrintf (File, "%6.4X: ", (BaseOffset + i));
+
+        /* Print 16 hex chars */
+
+        for (j = 0; j < 16;)
+        {
+            if (i + j >= Count)
+            {
+                /* Dump fill spaces */
+
+                AcpiUtFilePrintf (File, "%*s", ((Display * 2) + 1), " ");
+                j += Display;
+                continue;
+            }
+
+            switch (Display)
+            {
+            case DB_BYTE_DISPLAY:
+            default:    /* Default is BYTE display */
+
+                AcpiUtFilePrintf (File, "%02X ", Buffer[(ACPI_SIZE) i + j]);
+                break;
+
+            case DB_WORD_DISPLAY:
+
+                ACPI_MOVE_16_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
+                AcpiUtFilePrintf (File, "%04X ", Temp32);
+                break;
+
+            case DB_DWORD_DISPLAY:
+
+                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
+                AcpiUtFilePrintf (File, "%08X ", Temp32);
+                break;
+
+            case DB_QWORD_DISPLAY:
+
+                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
+                AcpiUtFilePrintf (File, "%08X", Temp32);
+
+                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j + 4]);
+                AcpiUtFilePrintf (File, "%08X ", Temp32);
+                break;
+            }
+
+            j += Display;
+        }
+
+        /*
+         * Print the ASCII equivalent characters but watch out for the bad
+         * unprintable ones (printable chars are 0x20 through 0x7E)
+         */
+        AcpiUtFilePrintf (File, " ");
+        for (j = 0; j < 16; j++)
+        {
+            if (i + j >= Count)
+            {
+                AcpiUtFilePrintf (File, "\n");
+                return;
+            }
+
+            BufChar = Buffer[(ACPI_SIZE) i + j];
+            if (isprint (BufChar))
+            {
+                AcpiUtFilePrintf (File, "%c", BufChar);
+            }
+            else
+            {
+                AcpiUtFilePrintf (File, ".");
+            }
+        }
+
+        /* Done with that line. */
+
+        AcpiUtFilePrintf (File, "\n");
+        i += 16;
+    }
+
+    return;
+}
+#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utcache.c b/usr/src/uts/intel/io/acpica/utilities/utcache.c
index 7b3abe2894..049dae8e98 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utcache.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utcache.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTCACHE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -94,11 +92,10 @@ AcpiOsCreateCache (
 
     /* Populate the cache object and return it */
 
-    ACPI_MEMSET (Cache, 0, sizeof (ACPI_MEMORY_LIST));
-    Cache->LinkOffset = 8;
-    Cache->ListName   = CacheName;
+    memset (Cache, 0, sizeof (ACPI_MEMORY_LIST));
+    Cache->ListName = CacheName;
     Cache->ObjectSize = ObjectSize;
-    Cache->MaxDepth   = MaxDepth;
+    Cache->MaxDepth = MaxDepth;
 
     *ReturnCache = Cache;
     return (AE_OK);
@@ -121,7 +118,7 @@ ACPI_STATUS
 AcpiOsPurgeCache (
     ACPI_MEMORY_LIST        *Cache)
 {
-    char                    *Next;
+    void                    *Next;
     ACPI_STATUS             Status;
 
 
@@ -145,8 +142,7 @@ AcpiOsPurgeCache (
     {
         /* Delete and unlink one cached state object */
 
-        Next = *(ACPI_CAST_INDIRECT_PTR (char,
-                    &(((char *) Cache->ListHead)[Cache->LinkOffset])));
+        Next = ACPI_GET_DESCRIPTOR_PTR (Cache->ListHead);
         ACPI_FREE (Cache->ListHead);
 
         Cache->ListHead = Next;
@@ -205,7 +201,7 @@ AcpiOsDeleteCache (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Release an object to the specified cache.  If cache is full,
+ * DESCRIPTION: Release an object to the specified cache. If cache is full,
  *              the object is deleted.
  *
  ******************************************************************************/
@@ -246,13 +242,12 @@ AcpiOsReleaseObject (
 
         /* Mark the object as cached */
 
-        ACPI_MEMSET (Object, 0xCA, Cache->ObjectSize);
+        memset (Object, 0xCA, Cache->ObjectSize);
         ACPI_SET_DESCRIPTOR_TYPE (Object, ACPI_DESC_TYPE_CACHED);
 
         /* Put the object at the head of the cache list */
 
-        * (ACPI_CAST_INDIRECT_PTR (char,
-            &(((char *) Object)[Cache->LinkOffset]))) = Cache->ListHead;
+        ACPI_SET_DESCRIPTOR_PTR (Object, Cache->ListHead);
         Cache->ListHead = Object;
         Cache->CurrentDepth++;
 
@@ -269,9 +264,9 @@ AcpiOsReleaseObject (
  *
  * PARAMETERS:  Cache           - Handle to cache object
  *
- * RETURN:      the acquired object.  NULL on error
+ * RETURN:      the acquired object. NULL on error
  *
- * DESCRIPTION: Get an object from the specified cache.  If cache is empty,
+ * DESCRIPTION: Get an object from the specified cache. If cache is empty,
  *              the object is allocated.
  *
  ******************************************************************************/
@@ -284,18 +279,18 @@ AcpiOsAcquireObject (
     void                    *Object;
 
 
-    ACPI_FUNCTION_NAME (OsAcquireObject);
+    ACPI_FUNCTION_TRACE (OsAcquireObject);
 
 
     if (!Cache)
     {
-        return (NULL);
+        return_PTR (NULL);
     }
 
     Status = AcpiUtAcquireMutex (ACPI_MTX_CACHES);
     if (ACPI_FAILURE (Status))
     {
-        return (NULL);
+        return_PTR (NULL);
     }
 
     ACPI_MEM_TRACKING (Cache->Requests++);
@@ -307,8 +302,7 @@ AcpiOsAcquireObject (
         /* There is an object available, use it */
 
         Object = Cache->ListHead;
-        Cache->ListHead = *(ACPI_CAST_INDIRECT_PTR (char,
-                                &(((char *) Object)[Cache->LinkOffset])));
+        Cache->ListHead = ACPI_GET_DESCRIPTOR_PTR (Object);
 
         Cache->CurrentDepth--;
 
@@ -319,12 +313,12 @@ AcpiOsAcquireObject (
         Status = AcpiUtReleaseMutex (ACPI_MTX_CACHES);
         if (ACPI_FAILURE (Status))
         {
-            return (NULL);
+            return_PTR (NULL);
         }
 
         /* Clear (zero) the previously used Object */
 
-        ACPI_MEMSET (Object, 0, Cache->ObjectSize);
+        memset (Object, 0, Cache->ObjectSize);
     }
     else
     {
@@ -344,18 +338,16 @@ AcpiOsAcquireObject (
         Status = AcpiUtReleaseMutex (ACPI_MTX_CACHES);
         if (ACPI_FAILURE (Status))
         {
-            return (NULL);
+            return_PTR (NULL);
         }
 
         Object = ACPI_ALLOCATE_ZEROED (Cache->ObjectSize);
         if (!Object)
         {
-            return (NULL);
+            return_PTR (NULL);
         }
     }
 
-    return (Object);
+    return_PTR (Object);
 }
 #endif /* ACPI_USE_LOCAL_CACHE */
-
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utclib.c b/usr/src/uts/intel/io/acpica/utilities/utclib.c
index d0153ec5d2..8c188d00a4 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utclib.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utclib.c
@@ -1,11 +1,11 @@
 /******************************************************************************
  *
- * Module Name: cmclib - Local implementation of C library functions
+ * Module Name: utclib - ACPICA implementations of C library functions
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,31 +41,62 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __CMCLIB_C__
-
+#define ACPI_CLIBRARY
 #include "acpi.h"
 #include "accommon.h"
 
 /*
- * These implementations of standard C Library routines can optionally be
- * used if a C library is not available.  In general, they are less efficient
- * than an inline or assembly implementation
+ * This module contains implementations of the standard C library functions
+ * that are required by the ACPICA code at both application level and kernel
+ * level.
+ *
+ * The module is an optional feature that can be used if a local/system
+ * C library is not available. Some operating system kernels may not have
+ * an internal C library.
+ *
+ * In general, these functions are less efficient than an inline or assembly
+ * code implementation.
+ *
+ * These C functions and the associated prototypes are enabled by default
+ * unless the ACPI_USE_SYSTEM_CLIBRARY symbol is defined. This is usually
+ * automatically defined for the ACPICA applications such as iASL and
+ * AcpiExec, so that these user-level applications use the local C library
+ * instead of the functions in this module.
  */
 
-#define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("cmclib")
+/*******************************************************************************
+ *
+ * Functions implemented in this module:
+ *
+ * FUNCTION:    memcmp
+ * FUNCTION:    memcpy
+ * FUNCTION:    memset
+ * FUNCTION:    strlen
+ * FUNCTION:    strcpy
+ * FUNCTION:    strncpy
+ * FUNCTION:    strcmp
+ * FUNCTION:    strchr
+ * FUNCTION:    strncmp
+ * FUNCTION:    strcat
+ * FUNCTION:    strncat
+ * FUNCTION:    strstr
+ * FUNCTION:    strtoul
+ * FUNCTION:    toupper
+ * FUNCTION:    tolower
+ * FUNCTION:    is* functions
+ *
+ ******************************************************************************/
 
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("utclib")
 
-#ifndef ACPI_USE_SYSTEM_CLIBRARY
 
-#define NEGATIVE    1
-#define POSITIVE    0
+#ifndef ACPI_USE_SYSTEM_CLIBRARY    /* Entire module */
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtMemcmp (memcmp)
+ * FUNCTION:    memcmp
  *
  * PARAMETERS:  Buffer1         - First Buffer
  *              Buffer2         - Second Buffer
@@ -78,11 +109,14 @@
  ******************************************************************************/
 
 int
-AcpiUtMemcmp (
-    const char              *Buffer1,
-    const char              *Buffer2,
+memcmp (
+    void                    *VBuffer1,
+    void                    *VBuffer2,
     ACPI_SIZE               Count)
 {
+    char                    *Buffer1 = (char *) VBuffer1;
+    char                    *Buffer2 = (char *) VBuffer2;
+
 
     for ( ; Count-- && (*Buffer1 == *Buffer2); Buffer1++, Buffer2++)
     {
@@ -95,7 +129,7 @@ AcpiUtMemcmp (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtMemcpy (memcpy)
+ * FUNCTION:    memcpy
  *
  * PARAMETERS:  Dest        - Target of the copy
  *              Src         - Source buffer to copy
@@ -108,7 +142,7 @@ AcpiUtMemcmp (
  ******************************************************************************/
 
 void *
-AcpiUtMemcpy (
+memcpy (
     void                    *Dest,
     const void              *Src,
     ACPI_SIZE               Count)
@@ -131,7 +165,7 @@ AcpiUtMemcpy (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtMemset (memset)
+ * FUNCTION:    memset
  *
  * PARAMETERS:  Dest        - Buffer to set
  *              Value       - Value to set each byte of memory
@@ -144,9 +178,9 @@ AcpiUtMemcpy (
  ******************************************************************************/
 
 void *
-AcpiUtMemset (
+memset (
     void                    *Dest,
-    UINT8                   Value,
+    int                     Value,
     ACPI_SIZE               Count)
 {
     char                    *New = (char *) Dest;
@@ -165,7 +199,7 @@ AcpiUtMemset (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrlen (strlen)
+ * FUNCTION:    strlen
  *
  * PARAMETERS:  String              - Null terminated string
  *
@@ -177,7 +211,7 @@ AcpiUtMemset (
 
 
 ACPI_SIZE
-AcpiUtStrlen (
+strlen (
     const char              *String)
 {
     UINT32                  Length = 0;
@@ -197,7 +231,7 @@ AcpiUtStrlen (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrcpy (strcpy)
+ * FUNCTION:    strcpy
  *
  * PARAMETERS:  DstString       - Target of the copy
  *              SrcString       - The source string to copy
@@ -209,7 +243,7 @@ AcpiUtStrlen (
  ******************************************************************************/
 
 char *
-AcpiUtStrcpy (
+strcpy (
     char                    *DstString,
     const char              *SrcString)
 {
@@ -235,7 +269,7 @@ AcpiUtStrcpy (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrncpy (strncpy)
+ * FUNCTION:    strncpy
  *
  * PARAMETERS:  DstString       - Target of the copy
  *              SrcString       - The source string to copy
@@ -248,7 +282,7 @@ AcpiUtStrcpy (
  ******************************************************************************/
 
 char *
-AcpiUtStrncpy (
+strncpy (
     char                    *DstString,
     const char              *SrcString,
     ACPI_SIZE               Count)
@@ -278,7 +312,7 @@ AcpiUtStrncpy (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrcmp (strcmp)
+ * FUNCTION:    strcmp
  *
  * PARAMETERS:  String1         - First string
  *              String2         - Second string
@@ -290,7 +324,7 @@ AcpiUtStrncpy (
  ******************************************************************************/
 
 int
-AcpiUtStrcmp (
+strcmp (
     const char              *String1,
     const char              *String2)
 {
@@ -308,11 +342,9 @@ AcpiUtStrcmp (
 }
 
 
-#ifdef ACPI_FUTURE_IMPLEMENTATION
-/* Not used at this time */
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrchr (strchr)
+ * FUNCTION:    strchr
  *
  * PARAMETERS:  String          - Search string
  *              ch              - character to search for
@@ -324,7 +356,7 @@ AcpiUtStrcmp (
  ******************************************************************************/
 
 char *
-AcpiUtStrchr (
+strchr (
     const char              *String,
     int                     ch)
 {
@@ -340,11 +372,11 @@ AcpiUtStrchr (
 
     return (NULL);
 }
-#endif
+
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrncmp (strncmp)
+ * FUNCTION:    strncmp
  *
  * PARAMETERS:  String1         - First string
  *              String2         - Second string
@@ -357,7 +389,7 @@ AcpiUtStrchr (
  ******************************************************************************/
 
 int
-AcpiUtStrncmp (
+strncmp (
     const char              *String1,
     const char              *String2,
     ACPI_SIZE               Count)
@@ -379,7 +411,7 @@ AcpiUtStrncmp (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrcat (Strcat)
+ * FUNCTION:    strcat
  *
  * PARAMETERS:  DstString       - Target of the copy
  *              SrcString       - The source string to copy
@@ -391,7 +423,7 @@ AcpiUtStrncmp (
  ******************************************************************************/
 
 char *
-AcpiUtStrcat (
+strcat (
     char                    *DstString,
     const char              *SrcString)
 {
@@ -414,7 +446,7 @@ AcpiUtStrcat (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrncat (strncat)
+ * FUNCTION:    strncat
  *
  * PARAMETERS:  DstString       - Target of the copy
  *              SrcString       - The source string to copy
@@ -428,7 +460,7 @@ AcpiUtStrcat (
  ******************************************************************************/
 
 char *
-AcpiUtStrncat (
+strncat (
     char                    *DstString,
     const char              *SrcString,
     ACPI_SIZE               Count)
@@ -462,7 +494,7 @@ AcpiUtStrncat (
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrstr (strstr)
+ * FUNCTION:    strstr
  *
  * PARAMETERS:  String1         - Target string
  *              String2         - Substring to search for
@@ -476,38 +508,35 @@ AcpiUtStrncat (
  ******************************************************************************/
 
 char *
-AcpiUtStrstr (
+strstr (
     char                    *String1,
     char                    *String2)
 {
-    char                    *String;
+    UINT32                  Length;
 
 
-    if (AcpiUtStrlen (String2) > AcpiUtStrlen (String1))
+    Length = strlen (String2);
+    if (!Length)
     {
-        return (NULL);
+        return (String1);
     }
 
-    /* Walk entire string, comparing the letters */
-
-    for (String = String1; *String2; )
+    while (strlen (String1) >= Length)
     {
-        if (*String2 != *String)
+        if (memcmp (String1, String2, Length) == 0)
         {
-            return (NULL);
+            return (String1);
         }
-
-        String2++;
-        String++;
+        String1++;
     }
 
-    return (String1);
+    return (NULL);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrtoul (strtoul)
+ * FUNCTION:    strtoul
  *
  * PARAMETERS:  String          - Null terminated string
  *              Terminater      - Where a pointer to the terminating byte is
@@ -517,12 +546,12 @@ AcpiUtStrstr (
  * RETURN:      Converted value
  *
  * DESCRIPTION: Convert a string into a 32-bit unsigned value.
- *              Note: use AcpiUtStrtoul64 for 64-bit integers.
+ *              Note: use strtoul64 for 64-bit integers.
  *
  ******************************************************************************/
 
 UINT32
-AcpiUtStrtoul (
+strtoul (
     const char              *String,
     char                    **Terminator,
     UINT32                  Base)
@@ -541,7 +570,7 @@ AcpiUtStrtoul (
      * skip over any white space in the buffer:
      */
     StringStart = String;
-    while (ACPI_IS_SPACE (*String) || *String == '\t')
+    while (isspace (*String) || *String == '\t')
     {
         ++String;
     }
@@ -552,17 +581,17 @@ AcpiUtStrtoul (
      */
     if (*String == '-')
     {
-        sign = NEGATIVE;
+        sign = ACPI_SIGN_NEGATIVE;
         ++String;
     }
     else if (*String == '+')
     {
         ++String;
-        sign = POSITIVE;
+        sign = ACPI_SIGN_POSITIVE;
     }
     else
     {
-        sign = POSITIVE;
+        sign = ACPI_SIGN_POSITIVE;
     }
 
     /*
@@ -573,7 +602,7 @@ AcpiUtStrtoul (
     {
         if (*String == '0')
         {
-            if (AcpiUtToLower (*(++String)) == 'x')
+            if (tolower (*(++String)) == 'x')
             {
                 Base = 16;
                 ++String;
@@ -608,7 +637,7 @@ AcpiUtStrtoul (
 
     if (Base == 16 &&
         *String == '0' &&
-        AcpiUtToLower (*(++String)) == 'x')
+        tolower (*(++String)) == 'x')
     {
         String++;
     }
@@ -618,14 +647,14 @@ AcpiUtStrtoul (
      */
     while (*String)
     {
-        if (ACPI_IS_DIGIT (*String))
+        if (isdigit (*String))
         {
             index = (UINT32) ((UINT8) *String - '0');
         }
         else
         {
-            index = (UINT32) AcpiUtToUpper (*String);
-            if (ACPI_IS_UPPER (index))
+            index = (UINT32) toupper (*String);
+            if (isupper (index))
             {
                 index = index - 'A' + 10;
             }
@@ -685,7 +714,7 @@ done:
     /*
      * If a minus sign was present, then "the conversion is negated":
      */
-    if (sign == NEGATIVE)
+    if (sign == ACPI_SIGN_NEGATIVE)
     {
         ReturnValue = (ACPI_UINT32_MAX - ReturnValue) + 1;
     }
@@ -696,7 +725,7 @@ done:
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtToUpper (TOUPPER)
+ * FUNCTION:    toupper
  *
  * PARAMETERS:  c           - Character to convert
  *
@@ -707,17 +736,17 @@ done:
  ******************************************************************************/
 
 int
-AcpiUtToUpper (
+toupper (
     int                     c)
 {
 
-    return (ACPI_IS_LOWER(c) ? ((c)-0x20) : (c));
+    return (islower(c) ? ((c)-0x20) : (c));
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtToLower (TOLOWER)
+ * FUNCTION:    tolower
  *
  * PARAMETERS:  c           - Character to convert
  *
@@ -728,151 +757,151 @@ AcpiUtToUpper (
  ******************************************************************************/
 
 int
-AcpiUtToLower (
+tolower (
     int                     c)
 {
 
-    return (ACPI_IS_UPPER(c) ? ((c)+0x20) : (c));
+    return (isupper(c) ? ((c)+0x20) : (c));
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    is* functions
+ * FUNCTION:    is* function array
  *
  * DESCRIPTION: is* functions use the ctype table below
  *
  ******************************************************************************/
 
-const UINT8 _acpi_ctype[257] = {
-    _ACPI_CN,            /* 0x0      0.     */
-    _ACPI_CN,            /* 0x1      1.     */
-    _ACPI_CN,            /* 0x2      2.     */
-    _ACPI_CN,            /* 0x3      3.     */
-    _ACPI_CN,            /* 0x4      4.     */
-    _ACPI_CN,            /* 0x5      5.     */
-    _ACPI_CN,            /* 0x6      6.     */
-    _ACPI_CN,            /* 0x7      7.     */
-    _ACPI_CN,            /* 0x8      8.     */
-    _ACPI_CN|_ACPI_SP,   /* 0x9      9.     */
-    _ACPI_CN|_ACPI_SP,   /* 0xA     10.     */
-    _ACPI_CN|_ACPI_SP,   /* 0xB     11.     */
-    _ACPI_CN|_ACPI_SP,   /* 0xC     12.     */
-    _ACPI_CN|_ACPI_SP,   /* 0xD     13.     */
-    _ACPI_CN,            /* 0xE     14.     */
-    _ACPI_CN,            /* 0xF     15.     */
-    _ACPI_CN,            /* 0x10    16.     */
-    _ACPI_CN,            /* 0x11    17.     */
-    _ACPI_CN,            /* 0x12    18.     */
-    _ACPI_CN,            /* 0x13    19.     */
-    _ACPI_CN,            /* 0x14    20.     */
-    _ACPI_CN,            /* 0x15    21.     */
-    _ACPI_CN,            /* 0x16    22.     */
-    _ACPI_CN,            /* 0x17    23.     */
-    _ACPI_CN,            /* 0x18    24.     */
-    _ACPI_CN,            /* 0x19    25.     */
-    _ACPI_CN,            /* 0x1A    26.     */
-    _ACPI_CN,            /* 0x1B    27.     */
-    _ACPI_CN,            /* 0x1C    28.     */
-    _ACPI_CN,            /* 0x1D    29.     */
-    _ACPI_CN,            /* 0x1E    30.     */
-    _ACPI_CN,            /* 0x1F    31.     */
-    _ACPI_XS|_ACPI_SP,   /* 0x20    32. ' ' */
-    _ACPI_PU,            /* 0x21    33. '!' */
-    _ACPI_PU,            /* 0x22    34. '"' */
-    _ACPI_PU,            /* 0x23    35. '#' */
-    _ACPI_PU,            /* 0x24    36. '$' */
-    _ACPI_PU,            /* 0x25    37. '%' */
-    _ACPI_PU,            /* 0x26    38. '&' */
-    _ACPI_PU,            /* 0x27    39. ''' */
-    _ACPI_PU,            /* 0x28    40. '(' */
-    _ACPI_PU,            /* 0x29    41. ')' */
-    _ACPI_PU,            /* 0x2A    42. '*' */
-    _ACPI_PU,            /* 0x2B    43. '+' */
-    _ACPI_PU,            /* 0x2C    44. ',' */
-    _ACPI_PU,            /* 0x2D    45. '-' */
-    _ACPI_PU,            /* 0x2E    46. '.' */
-    _ACPI_PU,            /* 0x2F    47. '/' */
-    _ACPI_XD|_ACPI_DI,   /* 0x30    48. '0' */
-    _ACPI_XD|_ACPI_DI,   /* 0x31    49. '1' */
-    _ACPI_XD|_ACPI_DI,   /* 0x32    50. '2' */
-    _ACPI_XD|_ACPI_DI,   /* 0x33    51. '3' */
-    _ACPI_XD|_ACPI_DI,   /* 0x34    52. '4' */
-    _ACPI_XD|_ACPI_DI,   /* 0x35    53. '5' */
-    _ACPI_XD|_ACPI_DI,   /* 0x36    54. '6' */
-    _ACPI_XD|_ACPI_DI,   /* 0x37    55. '7' */
-    _ACPI_XD|_ACPI_DI,   /* 0x38    56. '8' */
-    _ACPI_XD|_ACPI_DI,   /* 0x39    57. '9' */
-    _ACPI_PU,            /* 0x3A    58. ':' */
-    _ACPI_PU,            /* 0x3B    59. ';' */
-    _ACPI_PU,            /* 0x3C    60. '<' */
-    _ACPI_PU,            /* 0x3D    61. '=' */
-    _ACPI_PU,            /* 0x3E    62. '>' */
-    _ACPI_PU,            /* 0x3F    63. '?' */
-    _ACPI_PU,            /* 0x40    64. '@' */
-    _ACPI_XD|_ACPI_UP,   /* 0x41    65. 'A' */
-    _ACPI_XD|_ACPI_UP,   /* 0x42    66. 'B' */
-    _ACPI_XD|_ACPI_UP,   /* 0x43    67. 'C' */
-    _ACPI_XD|_ACPI_UP,   /* 0x44    68. 'D' */
-    _ACPI_XD|_ACPI_UP,   /* 0x45    69. 'E' */
-    _ACPI_XD|_ACPI_UP,   /* 0x46    70. 'F' */
-    _ACPI_UP,            /* 0x47    71. 'G' */
-    _ACPI_UP,            /* 0x48    72. 'H' */
-    _ACPI_UP,            /* 0x49    73. 'I' */
-    _ACPI_UP,            /* 0x4A    74. 'J' */
-    _ACPI_UP,            /* 0x4B    75. 'K' */
-    _ACPI_UP,            /* 0x4C    76. 'L' */
-    _ACPI_UP,            /* 0x4D    77. 'M' */
-    _ACPI_UP,            /* 0x4E    78. 'N' */
-    _ACPI_UP,            /* 0x4F    79. 'O' */
-    _ACPI_UP,            /* 0x50    80. 'P' */
-    _ACPI_UP,            /* 0x51    81. 'Q' */
-    _ACPI_UP,            /* 0x52    82. 'R' */
-    _ACPI_UP,            /* 0x53    83. 'S' */
-    _ACPI_UP,            /* 0x54    84. 'T' */
-    _ACPI_UP,            /* 0x55    85. 'U' */
-    _ACPI_UP,            /* 0x56    86. 'V' */
-    _ACPI_UP,            /* 0x57    87. 'W' */
-    _ACPI_UP,            /* 0x58    88. 'X' */
-    _ACPI_UP,            /* 0x59    89. 'Y' */
-    _ACPI_UP,            /* 0x5A    90. 'Z' */
-    _ACPI_PU,            /* 0x5B    91. '[' */
-    _ACPI_PU,            /* 0x5C    92. '\' */
-    _ACPI_PU,            /* 0x5D    93. ']' */
-    _ACPI_PU,            /* 0x5E    94. '^' */
-    _ACPI_PU,            /* 0x5F    95. '_' */
-    _ACPI_PU,            /* 0x60    96. '`' */
-    _ACPI_XD|_ACPI_LO,   /* 0x61    97. 'a' */
-    _ACPI_XD|_ACPI_LO,   /* 0x62    98. 'b' */
-    _ACPI_XD|_ACPI_LO,   /* 0x63    99. 'c' */
-    _ACPI_XD|_ACPI_LO,   /* 0x64   100. 'd' */
-    _ACPI_XD|_ACPI_LO,   /* 0x65   101. 'e' */
-    _ACPI_XD|_ACPI_LO,   /* 0x66   102. 'f' */
-    _ACPI_LO,            /* 0x67   103. 'g' */
-    _ACPI_LO,            /* 0x68   104. 'h' */
-    _ACPI_LO,            /* 0x69   105. 'i' */
-    _ACPI_LO,            /* 0x6A   106. 'j' */
-    _ACPI_LO,            /* 0x6B   107. 'k' */
-    _ACPI_LO,            /* 0x6C   108. 'l' */
-    _ACPI_LO,            /* 0x6D   109. 'm' */
-    _ACPI_LO,            /* 0x6E   110. 'n' */
-    _ACPI_LO,            /* 0x6F   111. 'o' */
-    _ACPI_LO,            /* 0x70   112. 'p' */
-    _ACPI_LO,            /* 0x71   113. 'q' */
-    _ACPI_LO,            /* 0x72   114. 'r' */
-    _ACPI_LO,            /* 0x73   115. 's' */
-    _ACPI_LO,            /* 0x74   116. 't' */
-    _ACPI_LO,            /* 0x75   117. 'u' */
-    _ACPI_LO,            /* 0x76   118. 'v' */
-    _ACPI_LO,            /* 0x77   119. 'w' */
-    _ACPI_LO,            /* 0x78   120. 'x' */
-    _ACPI_LO,            /* 0x79   121. 'y' */
-    _ACPI_LO,            /* 0x7A   122. 'z' */
-    _ACPI_PU,            /* 0x7B   123. '{' */
-    _ACPI_PU,            /* 0x7C   124. '|' */
-    _ACPI_PU,            /* 0x7D   125. '}' */
-    _ACPI_PU,            /* 0x7E   126. '~' */
-    _ACPI_CN,            /* 0x7F   127.     */
+const UINT8 AcpiGbl_Ctypes[257] = {
+    _ACPI_CN,            /* 0x00     0 NUL */
+    _ACPI_CN,            /* 0x01     1 SOH */
+    _ACPI_CN,            /* 0x02     2 STX */
+    _ACPI_CN,            /* 0x03     3 ETX */
+    _ACPI_CN,            /* 0x04     4 EOT */
+    _ACPI_CN,            /* 0x05     5 ENQ */
+    _ACPI_CN,            /* 0x06     6 ACK */
+    _ACPI_CN,            /* 0x07     7 BEL */
+    _ACPI_CN,            /* 0x08     8 BS  */
+    _ACPI_CN|_ACPI_SP,   /* 0x09     9 TAB */
+    _ACPI_CN|_ACPI_SP,   /* 0x0A    10 LF  */
+    _ACPI_CN|_ACPI_SP,   /* 0x0B    11 VT  */
+    _ACPI_CN|_ACPI_SP,   /* 0x0C    12 FF  */
+    _ACPI_CN|_ACPI_SP,   /* 0x0D    13 CR  */
+    _ACPI_CN,            /* 0x0E    14 SO  */
+    _ACPI_CN,            /* 0x0F    15 SI  */
+    _ACPI_CN,            /* 0x10    16 DLE */
+    _ACPI_CN,            /* 0x11    17 DC1 */
+    _ACPI_CN,            /* 0x12    18 DC2 */
+    _ACPI_CN,            /* 0x13    19 DC3 */
+    _ACPI_CN,            /* 0x14    20 DC4 */
+    _ACPI_CN,            /* 0x15    21 NAK */
+    _ACPI_CN,            /* 0x16    22 SYN */
+    _ACPI_CN,            /* 0x17    23 ETB */
+    _ACPI_CN,            /* 0x18    24 CAN */
+    _ACPI_CN,            /* 0x19    25 EM  */
+    _ACPI_CN,            /* 0x1A    26 SUB */
+    _ACPI_CN,            /* 0x1B    27 ESC */
+    _ACPI_CN,            /* 0x1C    28 FS  */
+    _ACPI_CN,            /* 0x1D    29 GS  */
+    _ACPI_CN,            /* 0x1E    30 RS  */
+    _ACPI_CN,            /* 0x1F    31 US  */
+    _ACPI_XS|_ACPI_SP,   /* 0x20    32 ' ' */
+    _ACPI_PU,            /* 0x21    33 '!' */
+    _ACPI_PU,            /* 0x22    34 '"' */
+    _ACPI_PU,            /* 0x23    35 '#' */
+    _ACPI_PU,            /* 0x24    36 '$' */
+    _ACPI_PU,            /* 0x25    37 '%' */
+    _ACPI_PU,            /* 0x26    38 '&' */
+    _ACPI_PU,            /* 0x27    39 ''' */
+    _ACPI_PU,            /* 0x28    40 '(' */
+    _ACPI_PU,            /* 0x29    41 ')' */
+    _ACPI_PU,            /* 0x2A    42 '*' */
+    _ACPI_PU,            /* 0x2B    43 '+' */
+    _ACPI_PU,            /* 0x2C    44 ',' */
+    _ACPI_PU,            /* 0x2D    45 '-' */
+    _ACPI_PU,            /* 0x2E    46 '.' */
+    _ACPI_PU,            /* 0x2F    47 '/' */
+    _ACPI_XD|_ACPI_DI,   /* 0x30    48 '0' */
+    _ACPI_XD|_ACPI_DI,   /* 0x31    49 '1' */
+    _ACPI_XD|_ACPI_DI,   /* 0x32    50 '2' */
+    _ACPI_XD|_ACPI_DI,   /* 0x33    51 '3' */
+    _ACPI_XD|_ACPI_DI,   /* 0x34    52 '4' */
+    _ACPI_XD|_ACPI_DI,   /* 0x35    53 '5' */
+    _ACPI_XD|_ACPI_DI,   /* 0x36    54 '6' */
+    _ACPI_XD|_ACPI_DI,   /* 0x37    55 '7' */
+    _ACPI_XD|_ACPI_DI,   /* 0x38    56 '8' */
+    _ACPI_XD|_ACPI_DI,   /* 0x39    57 '9' */
+    _ACPI_PU,            /* 0x3A    58 ':' */
+    _ACPI_PU,            /* 0x3B    59 ';' */
+    _ACPI_PU,            /* 0x3C    60 '<' */
+    _ACPI_PU,            /* 0x3D    61 '=' */
+    _ACPI_PU,            /* 0x3E    62 '>' */
+    _ACPI_PU,            /* 0x3F    63 '?' */
+    _ACPI_PU,            /* 0x40    64 '@' */
+    _ACPI_XD|_ACPI_UP,   /* 0x41    65 'A' */
+    _ACPI_XD|_ACPI_UP,   /* 0x42    66 'B' */
+    _ACPI_XD|_ACPI_UP,   /* 0x43    67 'C' */
+    _ACPI_XD|_ACPI_UP,   /* 0x44    68 'D' */
+    _ACPI_XD|_ACPI_UP,   /* 0x45    69 'E' */
+    _ACPI_XD|_ACPI_UP,   /* 0x46    70 'F' */
+    _ACPI_UP,            /* 0x47    71 'G' */
+    _ACPI_UP,            /* 0x48    72 'H' */
+    _ACPI_UP,            /* 0x49    73 'I' */
+    _ACPI_UP,            /* 0x4A    74 'J' */
+    _ACPI_UP,            /* 0x4B    75 'K' */
+    _ACPI_UP,            /* 0x4C    76 'L' */
+    _ACPI_UP,            /* 0x4D    77 'M' */
+    _ACPI_UP,            /* 0x4E    78 'N' */
+    _ACPI_UP,            /* 0x4F    79 'O' */
+    _ACPI_UP,            /* 0x50    80 'P' */
+    _ACPI_UP,            /* 0x51    81 'Q' */
+    _ACPI_UP,            /* 0x52    82 'R' */
+    _ACPI_UP,            /* 0x53    83 'S' */
+    _ACPI_UP,            /* 0x54    84 'T' */
+    _ACPI_UP,            /* 0x55    85 'U' */
+    _ACPI_UP,            /* 0x56    86 'V' */
+    _ACPI_UP,            /* 0x57    87 'W' */
+    _ACPI_UP,            /* 0x58    88 'X' */
+    _ACPI_UP,            /* 0x59    89 'Y' */
+    _ACPI_UP,            /* 0x5A    90 'Z' */
+    _ACPI_PU,            /* 0x5B    91 '[' */
+    _ACPI_PU,            /* 0x5C    92 '\' */
+    _ACPI_PU,            /* 0x5D    93 ']' */
+    _ACPI_PU,            /* 0x5E    94 '^' */
+    _ACPI_PU,            /* 0x5F    95 '_' */
+    _ACPI_PU,            /* 0x60    96 '`' */
+    _ACPI_XD|_ACPI_LO,   /* 0x61    97 'a' */
+    _ACPI_XD|_ACPI_LO,   /* 0x62    98 'b' */
+    _ACPI_XD|_ACPI_LO,   /* 0x63    99 'c' */
+    _ACPI_XD|_ACPI_LO,   /* 0x64   100 'd' */
+    _ACPI_XD|_ACPI_LO,   /* 0x65   101 'e' */
+    _ACPI_XD|_ACPI_LO,   /* 0x66   102 'f' */
+    _ACPI_LO,            /* 0x67   103 'g' */
+    _ACPI_LO,            /* 0x68   104 'h' */
+    _ACPI_LO,            /* 0x69   105 'i' */
+    _ACPI_LO,            /* 0x6A   106 'j' */
+    _ACPI_LO,            /* 0x6B   107 'k' */
+    _ACPI_LO,            /* 0x6C   108 'l' */
+    _ACPI_LO,            /* 0x6D   109 'm' */
+    _ACPI_LO,            /* 0x6E   110 'n' */
+    _ACPI_LO,            /* 0x6F   111 'o' */
+    _ACPI_LO,            /* 0x70   112 'p' */
+    _ACPI_LO,            /* 0x71   113 'q' */
+    _ACPI_LO,            /* 0x72   114 'r' */
+    _ACPI_LO,            /* 0x73   115 's' */
+    _ACPI_LO,            /* 0x74   116 't' */
+    _ACPI_LO,            /* 0x75   117 'u' */
+    _ACPI_LO,            /* 0x76   118 'v' */
+    _ACPI_LO,            /* 0x77   119 'w' */
+    _ACPI_LO,            /* 0x78   120 'x' */
+    _ACPI_LO,            /* 0x79   121 'y' */
+    _ACPI_LO,            /* 0x7A   122 'z' */
+    _ACPI_PU,            /* 0x7B   123 '{' */
+    _ACPI_PU,            /* 0x7C   124 '|' */
+    _ACPI_PU,            /* 0x7D   125 '}' */
+    _ACPI_PU,            /* 0x7E   126 '~' */
+    _ACPI_CN,            /* 0x7F   127 DEL */
 
     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 0x80 to 0x8F    */
     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 0x90 to 0x9F    */
@@ -881,9 +910,9 @@ const UINT8 _acpi_ctype[257] = {
     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 0xC0 to 0xCF    */
     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 0xD0 to 0xDF    */
     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 0xE0 to 0xEF    */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* 0xF0 to 0x100   */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 0xF0 to 0xFF    */
+    0                                 /* 0x100 */
 };
 
 
 #endif /* ACPI_USE_SYSTEM_CLIBRARY */
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utcopy.c b/usr/src/uts/intel/io/acpica/utilities/utcopy.c
index ab04a7a7aa..40abdfb76b 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utcopy.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utcopy.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTCOPY_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -148,7 +146,7 @@ AcpiUtCopyIsimpleToEsimple (
 
     /* Always clear the external object */
 
-    ACPI_MEMSET (ExternalObject, 0, sizeof (ACPI_OBJECT));
+    memset (ExternalObject, 0, sizeof (ACPI_OBJECT));
 
     /*
      * In general, the external object will be the same type as
@@ -165,33 +163,30 @@ AcpiUtCopyIsimpleToEsimple (
         ExternalObject->String.Pointer = (char *) DataSpace;
         ExternalObject->String.Length  = InternalObject->String.Length;
         *BufferSpaceUsed = ACPI_ROUND_UP_TO_NATIVE_WORD (
-                            (ACPI_SIZE) InternalObject->String.Length + 1);
+            (ACPI_SIZE) InternalObject->String.Length + 1);
 
-        ACPI_MEMCPY ((void *) DataSpace,
+        memcpy ((void *) DataSpace,
             (void *) InternalObject->String.Pointer,
             (ACPI_SIZE) InternalObject->String.Length + 1);
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         ExternalObject->Buffer.Pointer = DataSpace;
         ExternalObject->Buffer.Length  = InternalObject->Buffer.Length;
         *BufferSpaceUsed = ACPI_ROUND_UP_TO_NATIVE_WORD (
-                            InternalObject->String.Length);
+            InternalObject->String.Length);
 
-        ACPI_MEMCPY ((void *) DataSpace,
+        memcpy ((void *) DataSpace,
             (void *) InternalObject->Buffer.Pointer,
             InternalObject->Buffer.Length);
         break;
 
-
     case ACPI_TYPE_INTEGER:
 
         ExternalObject->Integer.Value = InternalObject->Integer.Value;
         break;
 
-
     case ACPI_TYPE_LOCAL_REFERENCE:
 
         /* This is an object reference. */
@@ -199,7 +194,6 @@ AcpiUtCopyIsimpleToEsimple (
         switch (InternalObject->Reference.Class)
         {
         case ACPI_REFCLASS_NAME:
-
             /*
              * For namepath, return the object handle ("reference")
              * We are referring to the namespace node
@@ -218,7 +212,6 @@ AcpiUtCopyIsimpleToEsimple (
         }
         break;
 
-
     case ACPI_TYPE_PROCESSOR:
 
         ExternalObject->Processor.ProcId =
@@ -229,7 +222,6 @@ AcpiUtCopyIsimpleToEsimple (
             InternalObject->Processor.Length;
         break;
 
-
     case ACPI_TYPE_POWER:
 
         ExternalObject->PowerResource.SystemLevel =
@@ -239,7 +231,6 @@ AcpiUtCopyIsimpleToEsimple (
             InternalObject->PowerResource.ResourceOrder;
         break;
 
-
     default:
         /*
          * There is no corresponding external object type
@@ -284,34 +275,31 @@ AcpiUtCopyIelementToEelement (
     ACPI_FUNCTION_ENTRY ();
 
 
-    ThisIndex    = State->Pkg.Index;
-    TargetObject = (ACPI_OBJECT *)
-        &((ACPI_OBJECT *)(State->Pkg.DestObject))->Package.Elements[ThisIndex];
+    ThisIndex = State->Pkg.Index;
+    TargetObject = (ACPI_OBJECT *) &((ACPI_OBJECT *)
+        (State->Pkg.DestObject))->Package.Elements[ThisIndex];
 
     switch (ObjectType)
     {
     case ACPI_COPY_TYPE_SIMPLE:
-
         /*
          * This is a simple or null object
          */
         Status = AcpiUtCopyIsimpleToEsimple (SourceObject,
-                        TargetObject, Info->FreeSpace, &ObjectSpace);
+            TargetObject, Info->FreeSpace, &ObjectSpace);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
         }
         break;
 
-
     case ACPI_COPY_TYPE_PACKAGE:
-
         /*
          * Build the package object
          */
-        TargetObject->Type              = ACPI_TYPE_PACKAGE;
-        TargetObject->Package.Count     = SourceObject->Package.Count;
-        TargetObject->Package.Elements  =
+        TargetObject->Type = ACPI_TYPE_PACKAGE;
+        TargetObject->Package.Count = SourceObject->Package.Count;
+        TargetObject->Package.Elements =
             ACPI_CAST_PTR (ACPI_OBJECT, Info->FreeSpace);
 
         /*
@@ -324,17 +312,17 @@ AcpiUtCopyIelementToEelement (
          * update the buffer length counter
          */
         ObjectSpace = ACPI_ROUND_UP_TO_NATIVE_WORD (
-                            (ACPI_SIZE) TargetObject->Package.Count *
-                            sizeof (ACPI_OBJECT));
+            (ACPI_SIZE) TargetObject->Package.Count *
+            sizeof (ACPI_OBJECT));
         break;
 
-
     default:
+
         return (AE_BAD_PARAMETER);
     }
 
-    Info->FreeSpace   += ObjectSpace;
-    Info->Length      += ObjectSpace;
+    Info->FreeSpace += ObjectSpace;
+    Info->Length += ObjectSpace;
     return (Status);
 }
 
@@ -380,28 +368,28 @@ AcpiUtCopyIpackageToEpackage (
     /*
      * Free space begins right after the first package
      */
-    Info.Length      = ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT));
-    Info.FreeSpace   = Buffer + ACPI_ROUND_UP_TO_NATIVE_WORD (
-                                    sizeof (ACPI_OBJECT));
+    Info.Length = ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT));
+    Info.FreeSpace = Buffer +
+        ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT));
     Info.ObjectSpace = 0;
     Info.NumPackages = 1;
 
-    ExternalObject->Type             = InternalObject->Common.Type;
-    ExternalObject->Package.Count    = InternalObject->Package.Count;
-    ExternalObject->Package.Elements = ACPI_CAST_PTR (ACPI_OBJECT,
-                                            Info.FreeSpace);
+    ExternalObject->Type = InternalObject->Common.Type;
+    ExternalObject->Package.Count = InternalObject->Package.Count;
+    ExternalObject->Package.Elements =
+        ACPI_CAST_PTR (ACPI_OBJECT, Info.FreeSpace);
 
     /*
      * Leave room for an array of ACPI_OBJECTS in the buffer
      * and move the free space past it
      */
-    Info.Length    += (ACPI_SIZE) ExternalObject->Package.Count *
-                            ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT));
+    Info.Length += (ACPI_SIZE) ExternalObject->Package.Count *
+        ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT));
     Info.FreeSpace += ExternalObject->Package.Count *
-                            ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT));
+        ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT));
 
     Status = AcpiUtWalkPackageTree (InternalObject, ExternalObject,
-                AcpiUtCopyIelementToEelement, &Info);
+        AcpiUtCopyIelementToEelement, &Info);
 
     *SpaceUsed = Info.Length;
     return_ACPI_STATUS (Status);
@@ -440,7 +428,7 @@ AcpiUtCopyIobjectToEobject (
          * nested packages)
          */
         Status = AcpiUtCopyIpackageToEpackage (InternalObject,
-                        RetBuffer->Pointer, &RetBuffer->Length);
+            RetBuffer->Pointer, &RetBuffer->Length);
     }
     else
     {
@@ -448,10 +436,10 @@ AcpiUtCopyIobjectToEobject (
          * Build a simple object (no nested objects)
          */
         Status = AcpiUtCopyIsimpleToEsimple (InternalObject,
-                    ACPI_CAST_PTR (ACPI_OBJECT, RetBuffer->Pointer),
-                    ACPI_ADD_PTR (UINT8, RetBuffer->Pointer,
-                        ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT))),
-                    &RetBuffer->Length);
+            ACPI_CAST_PTR (ACPI_OBJECT, RetBuffer->Pointer),
+            ACPI_ADD_PTR (UINT8, RetBuffer->Pointer,
+                ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT))),
+            &RetBuffer->Length);
         /*
          * build simple does not include the object size in the length
          * so we add it in here
@@ -501,7 +489,7 @@ AcpiUtCopyEsimpleToIsimple (
     case ACPI_TYPE_LOCAL_REFERENCE:
 
         InternalObject = AcpiUtCreateInternalObject (
-                            (UINT8) ExternalObject->Type);
+            (UINT8) ExternalObject->Type);
         if (!InternalObject)
         {
             return_ACPI_STATUS (AE_NO_MEMORY);
@@ -514,6 +502,7 @@ AcpiUtCopyEsimpleToIsimple (
         return_ACPI_STATUS (AE_OK);
 
     default:
+
         /* All other types are not supported */
 
         ACPI_ERROR ((AE_INFO,
@@ -539,14 +528,13 @@ AcpiUtCopyEsimpleToIsimple (
             goto ErrorExit;
         }
 
-        ACPI_MEMCPY (InternalObject->String.Pointer,
-                     ExternalObject->String.Pointer,
-                     ExternalObject->String.Length);
+        memcpy (InternalObject->String.Pointer,
+            ExternalObject->String.Pointer,
+            ExternalObject->String.Length);
 
-        InternalObject->String.Length  = ExternalObject->String.Length;
+        InternalObject->String.Length = ExternalObject->String.Length;
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         InternalObject->Buffer.Pointer =
@@ -556,33 +544,34 @@ AcpiUtCopyEsimpleToIsimple (
             goto ErrorExit;
         }
 
-        ACPI_MEMCPY (InternalObject->Buffer.Pointer,
-                     ExternalObject->Buffer.Pointer,
-                     ExternalObject->Buffer.Length);
+        memcpy (InternalObject->Buffer.Pointer,
+            ExternalObject->Buffer.Pointer,
+            ExternalObject->Buffer.Length);
 
-        InternalObject->Buffer.Length  = ExternalObject->Buffer.Length;
+        InternalObject->Buffer.Length = ExternalObject->Buffer.Length;
 
         /* Mark buffer data valid */
 
         InternalObject->Buffer.Flags |= AOPOBJ_DATA_VALID;
         break;
 
-
     case ACPI_TYPE_INTEGER:
 
-        InternalObject->Integer.Value   = ExternalObject->Integer.Value;
+        InternalObject->Integer.Value = ExternalObject->Integer.Value;
         break;
 
     case ACPI_TYPE_LOCAL_REFERENCE:
 
-        /* TBD: should validate incoming handle */
+        /* An incoming reference is defined to be a namespace node */
 
-        InternalObject->Reference.Class = ACPI_REFCLASS_NAME;
-        InternalObject->Reference.Node = ExternalObject->Reference.Handle;
+        InternalObject->Reference.Class = ACPI_REFCLASS_REFOF;
+        InternalObject->Reference.Object = ExternalObject->Reference.Handle;
         break;
 
     default:
+
         /* Other types can't get here */
+
         break;
     }
 
@@ -626,7 +615,8 @@ AcpiUtCopyEpackageToIpackage (
 
     /* Create the package object */
 
-    PackageObject = AcpiUtCreatePackageObject (ExternalObject->Package.Count);
+    PackageObject = AcpiUtCreatePackageObject (
+        ExternalObject->Package.Count);
     if (!PackageObject)
     {
         return_ACPI_STATUS (AE_NO_MEMORY);
@@ -635,14 +625,14 @@ AcpiUtCopyEpackageToIpackage (
     PackageElements = PackageObject->Package.Elements;
 
     /*
-     * Recursive implementation. Probably ok, since nested external packages
-     * as parameters should be very rare.
+     * Recursive implementation. Probably ok, since nested external
+     * packages as parameters should be very rare.
      */
     for (i = 0; i < ExternalObject->Package.Count; i++)
     {
         Status = AcpiUtCopyEobjectToIobject (
-                    &ExternalObject->Package.Elements[i],
-                    &PackageElements[i]);
+            &ExternalObject->Package.Elements[i],
+            &PackageElements[i]);
         if (ACPI_FAILURE (Status))
         {
             /* Truncate package and delete it */
@@ -689,14 +679,16 @@ AcpiUtCopyEobjectToIobject (
 
     if (ExternalObject->Type == ACPI_TYPE_PACKAGE)
     {
-        Status = AcpiUtCopyEpackageToIpackage (ExternalObject, InternalObject);
+        Status = AcpiUtCopyEpackageToIpackage (
+            ExternalObject, InternalObject);
     }
     else
     {
         /*
          * Build a simple object (no nested objects)
          */
-        Status = AcpiUtCopyEsimpleToIsimple (ExternalObject, InternalObject);
+        Status = AcpiUtCopyEsimpleToIsimple (ExternalObject,
+            InternalObject);
     }
 
     return_ACPI_STATUS (Status);
@@ -743,7 +735,7 @@ AcpiUtCopySimpleObject (
         CopySize = sizeof (ACPI_NAMESPACE_NODE);
     }
 
-    ACPI_MEMCPY (ACPI_CAST_PTR (char, DestDesc),
+    memcpy (ACPI_CAST_PTR (char, DestDesc),
         ACPI_CAST_PTR (char, SourceDesc), CopySize);
 
     /* Restore the saved fields */
@@ -777,7 +769,7 @@ AcpiUtCopySimpleObject (
 
             /* Copy the actual buffer data */
 
-            ACPI_MEMCPY (DestDesc->Buffer.Pointer,
+            memcpy (DestDesc->Buffer.Pointer,
                 SourceDesc->Buffer.Pointer, SourceDesc->Buffer.Length);
         }
         break;
@@ -799,7 +791,7 @@ AcpiUtCopySimpleObject (
 
             /* Copy the actual string data */
 
-            ACPI_MEMCPY (DestDesc->String.Pointer, SourceDesc->String.Pointer,
+            memcpy (DestDesc->String.Pointer, SourceDesc->String.Pointer,
                 (ACPI_SIZE) SourceDesc->String.Length + 1);
         }
         break;
@@ -847,7 +839,7 @@ AcpiUtCopySimpleObject (
     case ACPI_TYPE_EVENT:
 
         Status = AcpiOsCreateSemaphore (ACPI_NO_UNIT_LIMIT, 0,
-                    &DestDesc->Event.OsSemaphore);
+            &DestDesc->Event.OsSemaphore);
         if (ACPI_FAILURE (Status))
         {
             return (Status);
@@ -855,7 +847,9 @@ AcpiUtCopySimpleObject (
         break;
 
     default:
+
         /* Nothing to do for other simple objects */
+
         break;
     }
 
@@ -891,9 +885,9 @@ AcpiUtCopyIelementToIelement (
     ACPI_FUNCTION_ENTRY ();
 
 
-    ThisIndex     = State->Pkg.Index;
+    ThisIndex = State->Pkg.Index;
     ThisTargetPtr = (ACPI_OPERAND_OBJECT **)
-                        &State->Pkg.DestObject->Package.Elements[ThisIndex];
+        &State->Pkg.DestObject->Package.Elements[ThisIndex];
 
     switch (ObjectType)
     {
@@ -907,7 +901,7 @@ AcpiUtCopyIelementToIelement (
              * This is a simple object, just copy it
              */
             TargetObject = AcpiUtCreateInternalObject (
-                                SourceObject->Common.Type);
+                SourceObject->Common.Type);
             if (!TargetObject)
             {
                 return (AE_NO_MEMORY);
@@ -929,14 +923,13 @@ AcpiUtCopyIelementToIelement (
         }
         break;
 
-
     case ACPI_COPY_TYPE_PACKAGE:
-
         /*
          * This object is a package - go down another nesting level
          * Create and build the package object
          */
-        TargetObject = AcpiUtCreatePackageObject (SourceObject->Package.Count);
+        TargetObject = AcpiUtCreatePackageObject (
+            SourceObject->Package.Count);
         if (!TargetObject)
         {
             return (AE_NO_MEMORY);
@@ -953,8 +946,8 @@ AcpiUtCopyIelementToIelement (
         *ThisTargetPtr = TargetObject;
         break;
 
-
     default:
+
         return (AE_BAD_PARAMETER);
     }
 
@@ -993,16 +986,16 @@ AcpiUtCopyIpackageToIpackage (
     ACPI_FUNCTION_TRACE (UtCopyIpackageToIpackage);
 
 
-    DestObj->Common.Type    = SourceObj->Common.Type;
-    DestObj->Common.Flags   = SourceObj->Common.Flags;
-    DestObj->Package.Count  = SourceObj->Package.Count;
+    DestObj->Common.Type = SourceObj->Common.Type;
+    DestObj->Common.Flags = SourceObj->Common.Flags;
+    DestObj->Package.Count = SourceObj->Package.Count;
 
     /*
      * Create the object array and walk the source package tree
      */
     DestObj->Package.Elements = ACPI_ALLOCATE_ZEROED (
-                                    ((ACPI_SIZE) SourceObj->Package.Count + 1) *
-                                    sizeof (void *));
+        ((ACPI_SIZE) SourceObj->Package.Count + 1) *
+        sizeof (void *));
     if (!DestObj->Package.Elements)
     {
         ACPI_ERROR ((AE_INFO, "Package allocation failure"));
@@ -1014,7 +1007,7 @@ AcpiUtCopyIpackageToIpackage (
      * This handles nested packages of arbitrary depth.
      */
     Status = AcpiUtWalkPackageTree (SourceObj, DestObj,
-                AcpiUtCopyIelementToIelement, WalkState);
+        AcpiUtCopyIelementToIelement, WalkState);
     if (ACPI_FAILURE (Status))
     {
         /* On failure, delete the destination package object */
@@ -1064,15 +1057,20 @@ AcpiUtCopyIobjectToIobject (
 
     if (SourceDesc->Common.Type == ACPI_TYPE_PACKAGE)
     {
-        Status = AcpiUtCopyIpackageToIpackage (SourceDesc, *DestDesc,
-                        WalkState);
+        Status = AcpiUtCopyIpackageToIpackage (
+            SourceDesc, *DestDesc, WalkState);
     }
     else
     {
         Status = AcpiUtCopySimpleObject (SourceDesc, *DestDesc);
     }
 
-    return_ACPI_STATUS (Status);
-}
+    /* Delete the allocated object if copy failed */
 
+    if (ACPI_FAILURE (Status))
+    {
+        AcpiUtRemoveReference (*DestDesc);
+    }
 
+    return_ACPI_STATUS (Status);
+}
diff --git a/usr/src/uts/intel/io/acpica/utilities/utdebug.c b/usr/src/uts/intel/io/acpica/utilities/utdebug.c
index 051d47b443..6a298d175b 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utdebug.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utdebug.c
@@ -1,11 +1,11 @@
 /******************************************************************************
  *
- * Module Name: utdebug - Debug print routines
+ * Module Name: utdebug - Debug print/trace routines
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,10 +41,11 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTDEBUG_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
+#include "acinterp.h"
 
 #define _COMPONENT          ACPI_UTILITIES
         ACPI_MODULE_NAME    ("utdebug")
@@ -52,15 +53,9 @@
 
 #ifdef ACPI_DEBUG_OUTPUT
 
-static ACPI_THREAD_ID       AcpiGbl_PrevThreadId = (ACPI_THREAD_ID) 0xFFFFFFFF;
-static char                 *AcpiGbl_FnEntryStr = "----Entry";
-static char                 *AcpiGbl_FnExitStr  = "----Exit-";
-
-/* Local prototypes */
-
-static const char *
-AcpiUtTrimFunctionName (
-    const char              *FunctionName);
+static ACPI_THREAD_ID       AcpiGbl_PreviousThreadId = (ACPI_THREAD_ID) 0xFFFFFFFF;
+static const char           *AcpiGbl_FunctionEntryPrefix = "----Entry";
+static const char           *AcpiGbl_FunctionExitPrefix  = "----Exit-";
 
 
 /*******************************************************************************
@@ -189,11 +184,9 @@ AcpiDebugPrint (
     va_list                 args;
 
 
-    /*
-     * Stay silent if the debug level or component ID is disabled
-     */
-    if (!(RequestedDebugLevel & AcpiDbgLevel) ||
-        !(ComponentId & AcpiDbgLayer))
+    /* Check if debug output enabled */
+
+    if (!ACPI_IS_DEBUG_ENABLED (RequestedDebugLevel, ComponentId))
     {
         return;
     }
@@ -202,31 +195,41 @@ AcpiDebugPrint (
      * Thread tracking and context switch notification
      */
     ThreadId = AcpiOsGetThreadId ();
-    if (ThreadId != AcpiGbl_PrevThreadId)
+    if (ThreadId != AcpiGbl_PreviousThreadId)
     {
         if (ACPI_LV_THREADS & AcpiDbgLevel)
         {
             AcpiOsPrintf (
                 "\n**** Context Switch from TID %u to TID %u ****\n\n",
-                (UINT32) AcpiGbl_PrevThreadId, (UINT32) ThreadId);
+                (UINT32) AcpiGbl_PreviousThreadId, (UINT32) ThreadId);
         }
 
-        AcpiGbl_PrevThreadId = ThreadId;
+        AcpiGbl_PreviousThreadId = ThreadId;
+        AcpiGbl_NestingLevel = 0;
     }
 
     /*
      * Display the module name, current line number, thread ID (if requested),
      * current procedure nesting level, and the current procedure name
      */
-    AcpiOsPrintf ("%8s-%04ld ", ModuleName, LineNumber);
+    AcpiOsPrintf ("%9s-%04ld ", ModuleName, LineNumber);
 
+#ifdef ACPI_APPLICATION
+    /*
+     * For AcpiExec/iASL only, emit the thread ID and nesting level.
+     * Note: nesting level is really only useful during a single-thread
+     * execution. Otherwise, multiple threads will keep resetting the
+     * level.
+     */
     if (ACPI_LV_THREADS & AcpiDbgLevel)
     {
         AcpiOsPrintf ("[%u] ", (UINT32) ThreadId);
     }
 
-    AcpiOsPrintf ("[%02ld] %-22.22s: ",
-        AcpiGbl_NestingLevel, AcpiUtTrimFunctionName (FunctionName));
+    AcpiOsPrintf ("[%02ld] ", AcpiGbl_NestingLevel);
+#endif
+
+    AcpiOsPrintf ("%-22.22s: ", AcpiUtTrimFunctionName (FunctionName));
 
     va_start (args, Format);
     AcpiOsVprintf (Format, args);
@@ -250,7 +253,7 @@ ACPI_EXPORT_SYMBOL (AcpiDebugPrint)
  *
  * RETURN:      None
  *
- * DESCRIPTION: Print message with no headers.  Has same interface as
+ * DESCRIPTION: Print message with no headers. Has same interface as
  *              DebugPrint so that the same macros can be used.
  *
  ******************************************************************************/
@@ -268,8 +271,9 @@ AcpiDebugPrintRaw (
     va_list                 args;
 
 
-    if (!(RequestedDebugLevel & AcpiDbgLevel) ||
-        !(ComponentId & AcpiDbgLayer))
+    /* Check if debug output enabled */
+
+    if (!ACPI_IS_DEBUG_ENABLED (RequestedDebugLevel, ComponentId))
     {
         return;
     }
@@ -293,7 +297,7 @@ ACPI_EXPORT_SYMBOL (AcpiDebugPrintRaw)
  *
  * RETURN:      None
  *
- * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
+ * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is
  *              set in DebugLevel
  *
  ******************************************************************************/
@@ -309,9 +313,14 @@ AcpiUtTrace (
     AcpiGbl_NestingLevel++;
     AcpiUtTrackStackPtr ();
 
-    AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-        LineNumber, FunctionName, ModuleName, ComponentId,
-        "%s\n", AcpiGbl_FnEntryStr);
+    /* Check if enabled up-front for performance */
+
+    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
+    {
+        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+            LineNumber, FunctionName, ModuleName, ComponentId,
+            "%s\n", AcpiGbl_FunctionEntryPrefix);
+    }
 }
 
 ACPI_EXPORT_SYMBOL (AcpiUtTrace)
@@ -329,7 +338,7 @@ ACPI_EXPORT_SYMBOL (AcpiUtTrace)
  *
  * RETURN:      None
  *
- * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
+ * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is
  *              set in DebugLevel
  *
  ******************************************************************************/
@@ -340,14 +349,20 @@ AcpiUtTracePtr (
     const char              *FunctionName,
     const char              *ModuleName,
     UINT32                  ComponentId,
-    void                    *Pointer)
+    const void              *Pointer)
 {
+
     AcpiGbl_NestingLevel++;
     AcpiUtTrackStackPtr ();
 
-    AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-        LineNumber, FunctionName, ModuleName, ComponentId,
-        "%s %p\n", AcpiGbl_FnEntryStr, Pointer);
+    /* Check if enabled up-front for performance */
+
+    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
+    {
+        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+            LineNumber, FunctionName, ModuleName, ComponentId,
+            "%s %p\n", AcpiGbl_FunctionEntryPrefix, Pointer);
+    }
 }
 
 
@@ -363,7 +378,7 @@ AcpiUtTracePtr (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
+ * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is
  *              set in DebugLevel
  *
  ******************************************************************************/
@@ -374,15 +389,20 @@ AcpiUtTraceStr (
     const char              *FunctionName,
     const char              *ModuleName,
     UINT32                  ComponentId,
-    char                    *String)
+    const char              *String)
 {
 
     AcpiGbl_NestingLevel++;
     AcpiUtTrackStackPtr ();
 
-    AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-        LineNumber, FunctionName, ModuleName, ComponentId,
-        "%s %s\n", AcpiGbl_FnEntryStr, String);
+    /* Check if enabled up-front for performance */
+
+    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
+    {
+        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+            LineNumber, FunctionName, ModuleName, ComponentId,
+            "%s %s\n", AcpiGbl_FunctionEntryPrefix, String);
+    }
 }
 
 
@@ -398,7 +418,7 @@ AcpiUtTraceStr (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Function entry trace.  Prints only if TRACE_FUNCTIONS bit is
+ * DESCRIPTION: Function entry trace. Prints only if TRACE_FUNCTIONS bit is
  *              set in DebugLevel
  *
  ******************************************************************************/
@@ -415,9 +435,14 @@ AcpiUtTraceU32 (
     AcpiGbl_NestingLevel++;
     AcpiUtTrackStackPtr ();
 
-    AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-        LineNumber, FunctionName, ModuleName, ComponentId,
-        "%s %08X\n", AcpiGbl_FnEntryStr, Integer);
+    /* Check if enabled up-front for performance */
+
+    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
+    {
+        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+            LineNumber, FunctionName, ModuleName, ComponentId,
+            "%s %08X\n", AcpiGbl_FunctionEntryPrefix, Integer);
+    }
 }
 
 
@@ -432,7 +457,7 @@ AcpiUtTraceU32 (
  *
  * RETURN:      None
  *
- * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
+ * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
  *              set in DebugLevel
  *
  ******************************************************************************/
@@ -445,11 +470,19 @@ AcpiUtExit (
     UINT32                  ComponentId)
 {
 
-    AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-        LineNumber, FunctionName, ModuleName, ComponentId,
-        "%s\n", AcpiGbl_FnExitStr);
+    /* Check if enabled up-front for performance */
+
+    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
+    {
+        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+            LineNumber, FunctionName, ModuleName, ComponentId,
+            "%s\n", AcpiGbl_FunctionExitPrefix);
+    }
 
-    AcpiGbl_NestingLevel--;
+    if (AcpiGbl_NestingLevel)
+    {
+        AcpiGbl_NestingLevel--;
+    }
 }
 
 ACPI_EXPORT_SYMBOL (AcpiUtExit)
@@ -467,8 +500,8 @@ ACPI_EXPORT_SYMBOL (AcpiUtExit)
  *
  * RETURN:      None
  *
- * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel.  Prints exit status also.
+ * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
+ *              set in DebugLevel. Prints exit status also.
  *
  ******************************************************************************/
 
@@ -481,22 +514,30 @@ AcpiUtStatusExit (
     ACPI_STATUS             Status)
 {
 
-    if (ACPI_SUCCESS (Status))
+    /* Check if enabled up-front for performance */
+
+    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
     {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s %s\n", AcpiGbl_FnExitStr,
-            AcpiFormatException (Status));
+        if (ACPI_SUCCESS (Status))
+        {
+            AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+                LineNumber, FunctionName, ModuleName, ComponentId,
+                "%s %s\n", AcpiGbl_FunctionExitPrefix,
+                AcpiFormatException (Status));
+        }
+        else
+        {
+            AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+                LineNumber, FunctionName, ModuleName, ComponentId,
+                "%s ****Exception****: %s\n", AcpiGbl_FunctionExitPrefix,
+                AcpiFormatException (Status));
+        }
     }
-    else
+
+    if (AcpiGbl_NestingLevel)
     {
-        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-            LineNumber, FunctionName, ModuleName, ComponentId,
-            "%s ****Exception****: %s\n", AcpiGbl_FnExitStr,
-            AcpiFormatException (Status));
+        AcpiGbl_NestingLevel--;
     }
-
-    AcpiGbl_NestingLevel--;
 }
 
 ACPI_EXPORT_SYMBOL (AcpiUtStatusExit)
@@ -514,8 +555,8 @@ ACPI_EXPORT_SYMBOL (AcpiUtStatusExit)
  *
  * RETURN:      None
  *
- * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel.  Prints exit value also.
+ * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
+ *              set in DebugLevel. Prints exit value also.
  *
  ******************************************************************************/
 
@@ -528,12 +569,20 @@ AcpiUtValueExit (
     UINT64                  Value)
 {
 
-    AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-        LineNumber, FunctionName, ModuleName, ComponentId,
-        "%s %8.8X%8.8X\n", AcpiGbl_FnExitStr,
-        ACPI_FORMAT_UINT64 (Value));
+    /* Check if enabled up-front for performance */
+
+    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
+    {
+        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+            LineNumber, FunctionName, ModuleName, ComponentId,
+            "%s %8.8X%8.8X\n", AcpiGbl_FunctionExitPrefix,
+            ACPI_FORMAT_UINT64 (Value));
+    }
 
-    AcpiGbl_NestingLevel--;
+    if (AcpiGbl_NestingLevel)
+    {
+        AcpiGbl_NestingLevel--;
+    }
 }
 
 ACPI_EXPORT_SYMBOL (AcpiUtValueExit)
@@ -551,8 +600,8 @@ ACPI_EXPORT_SYMBOL (AcpiUtValueExit)
  *
  * RETURN:      None
  *
- * DESCRIPTION: Function exit trace.  Prints only if TRACE_FUNCTIONS bit is
- *              set in DebugLevel.  Prints exit value also.
+ * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
+ *              set in DebugLevel. Prints exit value also.
  *
  ******************************************************************************/
 
@@ -565,177 +614,127 @@ AcpiUtPtrExit (
     UINT8                   *Ptr)
 {
 
-    AcpiDebugPrint (ACPI_LV_FUNCTIONS,
-        LineNumber, FunctionName, ModuleName, ComponentId,
-        "%s %p\n", AcpiGbl_FnExitStr, Ptr);
+    /* Check if enabled up-front for performance */
 
-    AcpiGbl_NestingLevel--;
-}
+    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
+    {
+        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+            LineNumber, FunctionName, ModuleName, ComponentId,
+            "%s %p\n", AcpiGbl_FunctionExitPrefix, Ptr);
+    }
 
-#endif
+    if (AcpiGbl_NestingLevel)
+    {
+        AcpiGbl_NestingLevel--;
+    }
+}
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtDumpBuffer
+ * FUNCTION:    AcpiUtStrExit
  *
- * PARAMETERS:  Buffer              - Buffer to dump
- *              Count               - Amount to dump, in bytes
- *              Display             - BYTE, WORD, DWORD, or QWORD display
- *              ComponentID         - Caller's component ID
+ * PARAMETERS:  LineNumber          - Caller's line number
+ *              FunctionName        - Caller's procedure name
+ *              ModuleName          - Caller's module name
+ *              ComponentId         - Caller's component ID
+ *              String              - String to display
  *
  * RETURN:      None
  *
- * DESCRIPTION: Generic dump buffer in both hex and ascii.
+ * DESCRIPTION: Function exit trace. Prints only if TRACE_FUNCTIONS bit is
+ *              set in DebugLevel. Prints exit value also.
  *
  ******************************************************************************/
 
 void
-AcpiUtDumpBuffer2 (
-    UINT8                   *Buffer,
-    UINT32                  Count,
-    UINT32                  Display)
+AcpiUtStrExit (
+    UINT32                  LineNumber,
+    const char              *FunctionName,
+    const char              *ModuleName,
+    UINT32                  ComponentId,
+    const char              *String)
 {
-    UINT32                  i = 0;
-    UINT32                  j;
-    UINT32                  Temp32;
-    UINT8                   BufChar;
 
+    /* Check if enabled up-front for performance */
 
-    if (!Buffer)
+    if (ACPI_IS_DEBUG_ENABLED (ACPI_LV_FUNCTIONS, ComponentId))
     {
-        AcpiOsPrintf ("Null Buffer Pointer in DumpBuffer!\n");
-        return;
+        AcpiDebugPrint (ACPI_LV_FUNCTIONS,
+            LineNumber, FunctionName, ModuleName, ComponentId,
+            "%s %s\n", AcpiGbl_FunctionExitPrefix, String);
     }
 
-    if ((Count < 4) || (Count & 0x01))
+    if (AcpiGbl_NestingLevel)
     {
-        Display = DB_BYTE_DISPLAY;
+        AcpiGbl_NestingLevel--;
     }
+}
 
-    /* Nasty little dump buffer routine! */
-
-    while (i < Count)
-    {
-        /* Print current offset */
-
-        AcpiOsPrintf ("%6.4X: ", i);
-
-        /* Print 16 hex chars */
-
-        for (j = 0; j < 16;)
-        {
-            if (i + j >= Count)
-            {
-                /* Dump fill spaces */
-
-                AcpiOsPrintf ("%*s", ((Display * 2) + 1), " ");
-                j += Display;
-                continue;
-            }
-
-            switch (Display)
-            {
-            case DB_BYTE_DISPLAY:
-            default:    /* Default is BYTE display */
-
-                AcpiOsPrintf ("%02X ", Buffer[(ACPI_SIZE) i + j]);
-                break;
-
-
-            case DB_WORD_DISPLAY:
-
-                ACPI_MOVE_16_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
-                AcpiOsPrintf ("%04X ", Temp32);
-                break;
-
-
-            case DB_DWORD_DISPLAY:
-
-                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
-                AcpiOsPrintf ("%08X ", Temp32);
-                break;
-
-
-            case DB_QWORD_DISPLAY:
 
-                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j]);
-                AcpiOsPrintf ("%08X", Temp32);
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiTracePoint
+ *
+ * PARAMETERS:  Type                - Trace event type
+ *              Begin               - TRUE if before execution
+ *              Aml                 - Executed AML address
+ *              Pathname            - Object path
+ *              Pointer             - Pointer to the related object
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Interpreter execution trace.
+ *
+ ******************************************************************************/
 
-                ACPI_MOVE_32_TO_32 (&Temp32, &Buffer[(ACPI_SIZE) i + j + 4]);
-                AcpiOsPrintf ("%08X ", Temp32);
-                break;
-            }
+void
+AcpiTracePoint (
+    ACPI_TRACE_EVENT_TYPE   Type,
+    BOOLEAN                 Begin,
+    UINT8                   *Aml,
+    char                    *Pathname)
+{
 
-            j += Display;
-        }
+    ACPI_FUNCTION_ENTRY ();
 
-        /*
-         * Print the ASCII equivalent characters but watch out for the bad
-         * unprintable ones (printable chars are 0x20 through 0x7E)
-         */
-        AcpiOsPrintf (" ");
-        for (j = 0; j < 16; j++)
-        {
-            if (i + j >= Count)
-            {
-                AcpiOsPrintf ("\n");
-                return;
-            }
-
-            BufChar = Buffer[(ACPI_SIZE) i + j];
-            if (ACPI_IS_PRINT (BufChar))
-            {
-                AcpiOsPrintf ("%c", BufChar);
-            }
-            else
-            {
-                AcpiOsPrintf (".");
-            }
-        }
+    AcpiExTracePoint (Type, Begin, Aml, Pathname);
 
-        /* Done with that line. */
+#ifdef ACPI_USE_SYSTEM_TRACER
+    AcpiOsTracePoint (Type, Begin, Aml, Pathname);
+#endif
+}
 
-        AcpiOsPrintf ("\n");
-        i += 16;
-    }
+ACPI_EXPORT_SYMBOL (AcpiTracePoint)
 
-    return;
-}
+#endif
 
 
+#ifdef ACPI_APPLICATION
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtDumpBuffer
+ * FUNCTION:    AcpiLogError
  *
- * PARAMETERS:  Buffer              - Buffer to dump
- *              Count               - Amount to dump, in bytes
- *              Display             - BYTE, WORD, DWORD, or QWORD display
- *              ComponentID         - Caller's component ID
+ * PARAMETERS:  Format              - Printf format field
+ *              ...                 - Optional printf arguments
  *
  * RETURN:      None
  *
- * DESCRIPTION: Generic dump buffer in both hex and ascii.
+ * DESCRIPTION: Print error message to the console, used by applications.
  *
  ******************************************************************************/
 
-void
-AcpiUtDumpBuffer (
-    UINT8                   *Buffer,
-    UINT32                  Count,
-    UINT32                  Display,
-    UINT32                  ComponentId)
+void  ACPI_INTERNAL_VAR_XFACE
+AcpiLogError (
+    const char              *Format,
+    ...)
 {
+    va_list                 Args;
 
-    /* Only dump the buffer if tracing is enabled */
-
-    if (!((ACPI_LV_TABLES & AcpiDbgLevel) &&
-        (ComponentId & AcpiDbgLayer)))
-    {
-        return;
-    }
-
-    AcpiUtDumpBuffer2 (Buffer, Count, Display);
+    va_start (Args, Format);
+    (void) AcpiUtFileVprintf (ACPI_FILE_ERR, Format, Args);
+    va_end (Args);
 }
 
-
+ACPI_EXPORT_SYMBOL (AcpiLogError)
+#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utdecode.c b/usr/src/uts/intel/io/acpica/utilities/utdecode.c
index 718d73db4e..5c8f2cec80 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utdecode.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utdecode.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTDECODE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -51,47 +49,6 @@
         ACPI_MODULE_NAME    ("utdecode")
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiFormatException
- *
- * PARAMETERS:  Status       - The ACPI_STATUS code to be formatted
- *
- * RETURN:      A string containing the exception text. A valid pointer is
- *              always returned.
- *
- * DESCRIPTION: This function translates an ACPI exception into an ASCII string
- *              It is here instead of utxface.c so it is always present.
- *
- ******************************************************************************/
-
-const char *
-AcpiFormatException (
-    ACPI_STATUS             Status)
-{
-    const char              *Exception = NULL;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    Exception = AcpiUtValidateException (Status);
-    if (!Exception)
-    {
-        /* Exception code was not recognized */
-
-        ACPI_ERROR ((AE_INFO,
-            "Unknown exception code: 0x%8.8X", Status));
-
-        Exception = "UNKNOWN_STATUS_CODE";
-    }
-
-    return (ACPI_CAST_PTR (const char, Exception));
-}
-
-ACPI_EXPORT_SYMBOL (AcpiFormatException)
-
-
 /*
  * Properties of the ACPI Object Types, both internal and external.
  * The table is indexed by values of ACPI_OBJECT_TYPE
@@ -132,38 +89,6 @@ const UINT8                     AcpiGbl_NsProperties[ACPI_NUM_NS_TYPES] =
 };
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtHexToAsciiChar
- *
- * PARAMETERS:  Integer             - Contains the hex digit
- *              Position            - bit position of the digit within the
- *                                    integer (multiple of 4)
- *
- * RETURN:      The converted Ascii character
- *
- * DESCRIPTION: Convert a hex digit to an Ascii character
- *
- ******************************************************************************/
-
-/* Hex to ASCII conversion table */
-
-static const char           AcpiGbl_HexToAscii[] =
-{
-    '0','1','2','3','4','5','6','7',
-    '8','9','A','B','C','D','E','F'
-};
-
-char
-AcpiUtHexToAsciiChar (
-    UINT64                  Integer,
-    UINT32                  Position)
-{
-
-    return (AcpiGbl_HexToAscii[(Integer >> Position) & 0xF]);
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiUtGetRegionName
@@ -180,20 +105,21 @@ AcpiUtHexToAsciiChar (
 
 const char        *AcpiGbl_RegionTypes[ACPI_NUM_PREDEFINED_REGIONS] =
 {
-    "SystemMemory",
-    "SystemIO",
-    "PCI_Config",
-    "EmbeddedControl",
-    "SMBus",
-    "SystemCMOS",
-    "PCIBARTarget",
-    "IPMI",
-    "GeneralPurposeIo",
-    "GenericSerialBus"
+    "SystemMemory",     /* 0x00 */
+    "SystemIO",         /* 0x01 */
+    "PCI_Config",       /* 0x02 */
+    "EmbeddedControl",  /* 0x03 */
+    "SMBus",            /* 0x04 */
+    "SystemCMOS",       /* 0x05 */
+    "PCIBARTarget",     /* 0x06 */
+    "IPMI",             /* 0x07 */
+    "GeneralPurposeIo", /* 0x08 */
+    "GenericSerialBus", /* 0x09 */
+    "PCC"               /* 0x0A */
 };
 
 
-char *
+const char *
 AcpiUtGetRegionName (
     UINT8                   SpaceId)
 {
@@ -215,7 +141,7 @@ AcpiUtGetRegionName (
         return ("InvalidSpaceId");
     }
 
-    return (ACPI_CAST_PTR (char, AcpiGbl_RegionTypes[SpaceId]));
+    return (AcpiGbl_RegionTypes[SpaceId]);
 }
 
 
@@ -243,7 +169,7 @@ static const char        *AcpiGbl_EventTypes[ACPI_NUM_FIXED_EVENTS] =
 };
 
 
-char *
+const char *
 AcpiUtGetEventName (
     UINT32                  EventId)
 {
@@ -253,7 +179,7 @@ AcpiUtGetEventName (
         return ("InvalidEventID");
     }
 
-    return (ACPI_CAST_PTR (char, AcpiGbl_EventTypes[EventId]));
+    return (AcpiGbl_EventTypes[EventId]);
 }
 
 
@@ -275,7 +201,8 @@ AcpiUtGetEventName (
  *
  * The type ACPI_TYPE_ANY (Untyped) is used as a "don't care" when searching;
  * when stored in a table it really means that we have thus far seen no
- * evidence to indicate what type is actually going to be stored for this entry.
+ * evidence to indicate what type is actually going to be stored for this
+ & entry.
  */
 static const char           AcpiGbl_BadType[] = "UNDEFINED";
 
@@ -317,31 +244,47 @@ static const char           *AcpiGbl_NsTypeNames[] =
 };
 
 
-char *
+const char *
 AcpiUtGetTypeName (
     ACPI_OBJECT_TYPE        Type)
 {
 
     if (Type > ACPI_TYPE_INVALID)
     {
-        return (ACPI_CAST_PTR (char, AcpiGbl_BadType));
+        return (AcpiGbl_BadType);
     }
 
-    return (ACPI_CAST_PTR (char, AcpiGbl_NsTypeNames[Type]));
+    return (AcpiGbl_NsTypeNames[Type]);
 }
 
 
-char *
+const char *
 AcpiUtGetObjectTypeName (
     ACPI_OPERAND_OBJECT     *ObjDesc)
 {
+    ACPI_FUNCTION_TRACE (UtGetObjectTypeName);
+
 
     if (!ObjDesc)
     {
-        return ("[NULL Object Descriptor]");
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Null Object Descriptor\n"));
+        return_PTR ("[NULL Object Descriptor]");
+    }
+
+    /* These descriptor types share a common area */
+
+    if ((ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) != ACPI_DESC_TYPE_OPERAND) &&
+        (ACPI_GET_DESCRIPTOR_TYPE (ObjDesc) != ACPI_DESC_TYPE_NAMED))
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "Invalid object descriptor type: 0x%2.2X [%s] (%p)\n",
+            ACPI_GET_DESCRIPTOR_TYPE (ObjDesc),
+            AcpiUtGetDescriptorName (ObjDesc), ObjDesc));
+
+        return_PTR ("Invalid object");
     }
 
-    return (AcpiUtGetTypeName (ObjDesc->Common.Type));
+    return_STR (AcpiUtGetTypeName (ObjDesc->Common.Type));
 }
 
 
@@ -357,7 +300,7 @@ AcpiUtGetObjectTypeName (
  *
  ******************************************************************************/
 
-char *
+const char *
 AcpiUtGetNodeName (
     void                    *Object)
 {
@@ -433,7 +376,7 @@ static const char           *AcpiGbl_DescTypeNames[] =
 };
 
 
-char *
+const char *
 AcpiUtGetDescriptorName (
     void                    *Object)
 {
@@ -448,9 +391,7 @@ AcpiUtGetDescriptorName (
         return ("Not a Descriptor");
     }
 
-    return (ACPI_CAST_PTR (char,
-        AcpiGbl_DescTypeNames[ACPI_GET_DESCRIPTOR_TYPE (Object)]));
-
+    return (AcpiGbl_DescTypeNames[ACPI_GET_DESCRIPTOR_TYPE (Object)]);
 }
 
 
@@ -527,7 +468,7 @@ AcpiUtGetReferenceName (
 
 /* Names for internal mutex objects, used for debug output */
 
-static char                 *AcpiGbl_MutexNames[ACPI_NUM_MUTEX] =
+static const char           *AcpiGbl_MutexNames[ACPI_NUM_MUTEX] =
 {
     "ACPI_MTX_Interpreter",
     "ACPI_MTX_Namespace",
@@ -535,11 +476,9 @@ static char                 *AcpiGbl_MutexNames[ACPI_NUM_MUTEX] =
     "ACPI_MTX_Events",
     "ACPI_MTX_Caches",
     "ACPI_MTX_Memory",
-    "ACPI_MTX_CommandComplete",
-    "ACPI_MTX_CommandReady"
 };
 
-char *
+const char *
 AcpiUtGetMutexName (
     UINT32                  MutexId)
 {
@@ -567,7 +506,7 @@ AcpiUtGetMutexName (
 
 /* Names for Notify() values, used for debug output */
 
-static const char           *AcpiGbl_NotifyValueNames[ACPI_NOTIFY_MAX + 1] =
+static const char           *AcpiGbl_GenericNotify[ACPI_GENERIC_NOTIFY_MAX + 1] =
 {
     /* 00 */ "Bus Check",
     /* 01 */ "Device Check",
@@ -579,32 +518,91 @@ static const char           *AcpiGbl_NotifyValueNames[ACPI_NOTIFY_MAX + 1] =
     /* 07 */ "Power Fault",
     /* 08 */ "Capabilities Check",
     /* 09 */ "Device PLD Check",
-    /* 10 */ "Reserved",
-    /* 11 */ "System Locality Update",
-    /* 12 */ "Shutdown Request"
+    /* 0A */ "Reserved",
+    /* 0B */ "System Locality Update",
+    /* 0C */ "Shutdown Request", /* Reserved in ACPI 6.0 */
+    /* 0D */ "System Resource Affinity Update"
 };
 
+static const char           *AcpiGbl_DeviceNotify[5] =
+{
+    /* 80 */ "Status Change",
+    /* 81 */ "Information Change",
+    /* 82 */ "Device-Specific Change",
+    /* 83 */ "Device-Specific Change",
+    /* 84 */ "Reserved"
+};
+
+static const char           *AcpiGbl_ProcessorNotify[5] =
+{
+    /* 80 */ "Performance Capability Change",
+    /* 81 */ "C-State Change",
+    /* 82 */ "Throttling Capability Change",
+    /* 83 */ "Guaranteed Change",
+    /* 84 */ "Minimum Excursion"
+};
+
+static const char           *AcpiGbl_ThermalNotify[5] =
+{
+    /* 80 */ "Thermal Status Change",
+    /* 81 */ "Thermal Trip Point Change",
+    /* 82 */ "Thermal Device List Change",
+    /* 83 */ "Thermal Relationship Change",
+    /* 84 */ "Reserved"
+};
+
+
 const char *
 AcpiUtGetNotifyName (
-    UINT32                  NotifyValue)
+    UINT32                  NotifyValue,
+    ACPI_OBJECT_TYPE        Type)
 {
 
-    if (NotifyValue <= ACPI_NOTIFY_MAX)
+    /* 00 - 0D are "common to all object types" (from ACPI Spec) */
+
+    if (NotifyValue <= ACPI_GENERIC_NOTIFY_MAX)
     {
-        return (AcpiGbl_NotifyValueNames[NotifyValue]);
+        return (AcpiGbl_GenericNotify[NotifyValue]);
     }
-    else if (NotifyValue <= ACPI_MAX_SYS_NOTIFY)
+
+    /* 0E - 7F are reserved */
+
+    if (NotifyValue <= ACPI_MAX_SYS_NOTIFY)
     {
         return ("Reserved");
     }
-    else if (NotifyValue <= ACPI_MAX_DEVICE_SPECIFIC_NOTIFY)
+
+    /* 80 - 84 are per-object-type */
+
+    if (NotifyValue <= ACPI_SPECIFIC_NOTIFY_MAX)
     {
-        return ("Device Specific");
+        switch (Type)
+        {
+        case ACPI_TYPE_ANY:
+        case ACPI_TYPE_DEVICE:
+            return (AcpiGbl_DeviceNotify [NotifyValue - 0x80]);
+
+        case ACPI_TYPE_PROCESSOR:
+            return (AcpiGbl_ProcessorNotify [NotifyValue - 0x80]);
+
+        case ACPI_TYPE_THERMAL:
+            return (AcpiGbl_ThermalNotify [NotifyValue - 0x80]);
+
+        default:
+            return ("Target object type does not support notifies");
+        }
     }
-    else
+
+    /* 84 - BF are device-specific */
+
+    if (NotifyValue <= ACPI_MAX_DEVICE_SPECIFIC_NOTIFY)
     {
-        return ("Hardware Specific");
+        return ("Device-Specific");
     }
+
+    /* C0 and above are hardware-specific */
+
+    return ("Hardware-Specific");
 }
 #endif
 
diff --git a/usr/src/uts/intel/io/acpica/utilities/utdelete.c b/usr/src/uts/intel/io/acpica/utilities/utdelete.c
index fb32611121..95a98f5681 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utdelete.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utdelete.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTDELETE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -86,6 +84,7 @@ AcpiUtDeleteInternalObj (
     ACPI_OPERAND_OBJECT     *HandlerDesc;
     ACPI_OPERAND_OBJECT     *SecondDesc;
     ACPI_OPERAND_OBJECT     *NextDesc;
+    ACPI_OPERAND_OBJECT     *StartDesc;
     ACPI_OPERAND_OBJECT     **LastObjPtr;
 
 
@@ -118,7 +117,6 @@ AcpiUtDeleteInternalObj (
         }
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "**** Buffer %p, ptr %p\n",
@@ -134,7 +132,6 @@ AcpiUtDeleteInternalObj (
         }
         break;
 
-
     case ACPI_TYPE_PACKAGE:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, " **** Package of count %X\n",
@@ -150,7 +147,6 @@ AcpiUtDeleteInternalObj (
         ObjPointer = Object->Package.Elements;
         break;
 
-
     /*
      * These objects have a possible list of notify handlers.
      * Device object also may have a GPE block.
@@ -178,7 +174,6 @@ AcpiUtDeleteInternalObj (
         }
         break;
 
-
     case ACPI_TYPE_MUTEX:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
@@ -202,7 +197,6 @@ AcpiUtDeleteInternalObj (
         }
         break;
 
-
     case ACPI_TYPE_EVENT:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
@@ -213,7 +207,6 @@ AcpiUtDeleteInternalObj (
         Object->Event.OsSemaphore = NULL;
         break;
 
-
     case ACPI_TYPE_METHOD:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
@@ -227,8 +220,12 @@ AcpiUtDeleteInternalObj (
             AcpiUtDeleteObjectDesc (Object->Method.Mutex);
             Object->Method.Mutex = NULL;
         }
-        break;
 
+        if (Object->Method.Node)
+        {
+            Object->Method.Node = NULL;
+        }
+        break;
 
     case ACPI_TYPE_REGION:
 
@@ -257,9 +254,10 @@ AcpiUtDeleteInternalObj (
             if (HandlerDesc)
             {
                 NextDesc = HandlerDesc->AddressSpace.RegionList;
+                StartDesc = NextDesc;
                 LastObjPtr = &HandlerDesc->AddressSpace.RegionList;
 
-                /* Remove the region object from the handler's list */
+                /* Remove the region object from the handler list */
 
                 while (NextDesc)
                 {
@@ -269,10 +267,20 @@ AcpiUtDeleteInternalObj (
                         break;
                     }
 
-                    /* Walk the linked list of handler */
+                    /* Walk the linked list of handlers */
 
                     LastObjPtr = &NextDesc->Region.Next;
                     NextDesc = NextDesc->Region.Next;
+
+                    /* Prevent infinite loop if list is corrupted */
+
+                    if (NextDesc == StartDesc)
+                    {
+                        ACPI_ERROR ((AE_INFO,
+                            "Circular region list in address handler object %p",
+                            HandlerDesc));
+                        return_VOID;
+                    }
                 }
 
                 if (HandlerDesc->AddressSpace.HandlerFlags &
@@ -298,7 +306,6 @@ AcpiUtDeleteInternalObj (
         }
         break;
 
-
     case ACPI_TYPE_BUFFER_FIELD:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
@@ -311,7 +318,6 @@ AcpiUtDeleteInternalObj (
         }
         break;
 
-
     case ACPI_TYPE_LOCAL_BANK_FIELD:
 
         ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
@@ -324,8 +330,8 @@ AcpiUtDeleteInternalObj (
         }
         break;
 
-
     default:
+
         break;
     }
 
@@ -368,7 +374,7 @@ AcpiUtDeleteInternalObjectList (
     ACPI_OPERAND_OBJECT     **InternalObj;
 
 
-    ACPI_FUNCTION_TRACE (UtDeleteInternalObjectList);
+    ACPI_FUNCTION_ENTRY ();
 
 
     /* Walk the null-terminated internal list */
@@ -381,7 +387,7 @@ AcpiUtDeleteInternalObjectList (
     /* Free the combined parameter pointer list and object array */
 
     ACPI_FREE (ObjList);
-    return_VOID;
+    return;
 }
 
 
@@ -390,11 +396,11 @@ AcpiUtDeleteInternalObjectList (
  * FUNCTION:    AcpiUtUpdateRefCount
  *
  * PARAMETERS:  Object          - Object whose ref count is to be updated
- *              Action          - What to do
+ *              Action          - What to do (REF_INCREMENT or REF_DECREMENT)
  *
- * RETURN:      New ref count
+ * RETURN:      None. Sets new reference count within the object
  *
- * DESCRIPTION: Modify the ref count and return it.
+ * DESCRIPTION: Modify the reference count for an internal acpi object
  *
  ******************************************************************************/
 
@@ -403,8 +409,9 @@ AcpiUtUpdateRefCount (
     ACPI_OPERAND_OBJECT     *Object,
     UINT32                  Action)
 {
-    UINT16                  Count;
-    UINT16                  NewCount;
+    UINT16                  OriginalCount;
+    UINT16                  NewCount = 0;
+    ACPI_CPU_FLAGS          LockFlags;
 
 
     ACPI_FUNCTION_NAME (UtUpdateRefCount);
@@ -415,80 +422,85 @@ AcpiUtUpdateRefCount (
         return;
     }
 
-    Count = Object->Common.ReferenceCount;
-    NewCount = Count;
-
     /*
-     * Perform the reference count action (increment, decrement, force delete)
+     * Always get the reference count lock. Note: Interpreter and/or
+     * Namespace is not always locked when this function is called.
      */
+    LockFlags = AcpiOsAcquireLock (AcpiGbl_ReferenceCountLock);
+    OriginalCount = Object->Common.ReferenceCount;
+
+    /* Perform the reference count action (increment, decrement) */
+
     switch (Action)
     {
     case REF_INCREMENT:
 
-        NewCount++;
+        NewCount = OriginalCount + 1;
         Object->Common.ReferenceCount = NewCount;
+        AcpiOsReleaseLock (AcpiGbl_ReferenceCountLock, LockFlags);
+
+        /* The current reference count should never be zero here */
+
+        if (!OriginalCount)
+        {
+            ACPI_WARNING ((AE_INFO,
+                "Obj %p, Reference Count was zero before increment\n",
+                Object));
+        }
 
         ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
-            "Obj %p Refs=%X, [Incremented]\n",
-            Object, NewCount));
+            "Obj %p Type %.2X Refs %.2X [Incremented]\n",
+            Object, Object->Common.Type, NewCount));
         break;
 
     case REF_DECREMENT:
 
-        if (Count < 1)
-        {
-            ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
-                "Obj %p Refs=%X, can't decrement! (Set to 0)\n",
-                Object, NewCount));
+        /* The current reference count must be non-zero */
 
-            NewCount = 0;
-        }
-        else
+        if (OriginalCount)
         {
-            NewCount--;
-
-            ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
-                "Obj %p Refs=%X, [Decremented]\n",
-                Object, NewCount));
+            NewCount = OriginalCount - 1;
+            Object->Common.ReferenceCount = NewCount;
         }
 
-        if (Object->Common.Type == ACPI_TYPE_METHOD)
+        AcpiOsReleaseLock (AcpiGbl_ReferenceCountLock, LockFlags);
+
+        if (!OriginalCount)
         {
-            ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
-                "Method Obj %p Refs=%X, [Decremented]\n", Object, NewCount));
+            ACPI_WARNING ((AE_INFO,
+                "Obj %p, Reference Count is already zero, cannot decrement\n",
+                Object));
         }
 
-        Object->Common.ReferenceCount = NewCount;
+        ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
+            "Obj %p Type %.2X Refs %.2X [Decremented]\n",
+            Object, Object->Common.Type, NewCount));
+
+        /* Actually delete the object on a reference count of zero */
+
         if (NewCount == 0)
         {
             AcpiUtDeleteInternalObj (Object);
         }
         break;
 
-    case REF_FORCE_DELETE:
-
-        ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
-            "Obj %p Refs=%X, Force delete! (Set to 0)\n", Object, Count));
-
-        NewCount = 0;
-        Object->Common.ReferenceCount = NewCount;
-        AcpiUtDeleteInternalObj (Object);
-        break;
-
     default:
 
-        ACPI_ERROR ((AE_INFO, "Unknown action (0x%X)", Action));
-        break;
+        AcpiOsReleaseLock (AcpiGbl_ReferenceCountLock, LockFlags);
+        ACPI_ERROR ((AE_INFO, "Unknown Reference Count action (0x%X)",
+            Action));
+        return;
     }
 
     /*
      * Sanity check the reference count, for debug purposes only.
      * (A deleted object will have a huge reference count)
      */
-    if (Count > ACPI_MAX_REFERENCE_COUNT)
+    if (NewCount > ACPI_MAX_REFERENCE_COUNT)
     {
         ACPI_WARNING ((AE_INFO,
-            "Large Reference Count (0x%X) in object %p", Count, Object));
+            "Large Reference Count (0x%X) in object %p, Type=0x%.2X",
+            NewCount, Object, Object->Common.Type));
     }
 }
 
@@ -499,8 +511,7 @@ AcpiUtUpdateRefCount (
  *
  * PARAMETERS:  Object              - Increment ref count for this object
  *                                    and all sub-objects
- *              Action              - Either REF_INCREMENT or REF_DECREMENT or
- *                                    REF_FORCE_DELETE
+ *              Action              - Either REF_INCREMENT or REF_DECREMENT
  *
  * RETURN:      Status
  *
@@ -528,7 +539,7 @@ AcpiUtUpdateObjectReference (
     UINT32                  i;
 
 
-    ACPI_FUNCTION_TRACE_PTR (UtUpdateObjectReference, Object);
+    ACPI_FUNCTION_NAME (UtUpdateObjectReference);
 
 
     while (Object)
@@ -539,12 +550,12 @@ AcpiUtUpdateObjectReference (
         {
             ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
                 "Object %p is NS handle\n", Object));
-            return_ACPI_STATUS (AE_OK);
+            return (AE_OK);
         }
 
         /*
-         * All sub-objects must have their reference count incremented also.
-         * Different object types have different subobjects.
+         * All sub-objects must have their reference count incremented
+         * also. Different object types have different subobjects.
          */
         switch (Object->Common.Type)
         {
@@ -552,7 +563,6 @@ AcpiUtUpdateObjectReference (
         case ACPI_TYPE_PROCESSOR:
         case ACPI_TYPE_POWER:
         case ACPI_TYPE_THERMAL:
-
             /*
              * Update the notify objects for these types (if present)
              * Two lists, system and device notify handlers.
@@ -577,17 +587,43 @@ AcpiUtUpdateObjectReference (
             for (i = 0; i < Object->Package.Count; i++)
             {
                 /*
-                 * Push each element onto the stack for later processing.
-                 * Note: There can be null elements within the package,
-                 * these are simply ignored
+                 * Null package elements are legal and can be simply
+                 * ignored.
                  */
-                Status = AcpiUtCreateUpdateStateAndPush (
-                            Object->Package.Elements[i], Action, &StateList);
-                if (ACPI_FAILURE (Status))
+                NextObject = Object->Package.Elements[i];
+                if (!NextObject)
+                {
+                    continue;
+                }
+
+                switch (NextObject->Common.Type)
                 {
-                    goto ErrorExit;
+                case ACPI_TYPE_INTEGER:
+                case ACPI_TYPE_STRING:
+                case ACPI_TYPE_BUFFER:
+                    /*
+                     * For these very simple sub-objects, we can just
+                     * update the reference count here and continue.
+                     * Greatly increases performance of this operation.
+                     */
+                    AcpiUtUpdateRefCount (NextObject, Action);
+                    break;
+
+                default:
+                    /*
+                     * For complex sub-objects, push them onto the stack
+                     * for later processing (this eliminates recursion.)
+                     */
+                    Status = AcpiUtCreateUpdateStateAndPush (
+                        NextObject, Action, &StateList);
+                    if (ACPI_FAILURE (Status))
+                    {
+                        goto ErrorExit;
+                    }
+                    break;
                 }
             }
+            NextObject = NULL;
             break;
 
         case ACPI_TYPE_BUFFER_FIELD:
@@ -604,7 +640,7 @@ AcpiUtUpdateObjectReference (
 
             NextObject = Object->BankField.BankObj;
             Status = AcpiUtCreateUpdateStateAndPush (
-                        Object->BankField.RegionObj, Action, &StateList);
+                Object->BankField.RegionObj, Action, &StateList);
             if (ACPI_FAILURE (Status))
             {
                 goto ErrorExit;
@@ -615,7 +651,7 @@ AcpiUtUpdateObjectReference (
 
             NextObject = Object->IndexField.IndexObj;
             Status = AcpiUtCreateUpdateStateAndPush (
-                        Object->IndexField.DataObj, Action, &StateList);
+                Object->IndexField.DataObj, Action, &StateList);
             if (ACPI_FAILURE (Status))
             {
                 goto ErrorExit;
@@ -637,6 +673,7 @@ AcpiUtUpdateObjectReference (
 
         case ACPI_TYPE_REGION:
         default:
+
             break; /* No subobjects for all other types */
         }
 
@@ -663,7 +700,7 @@ AcpiUtUpdateObjectReference (
         }
     }
 
-    return_ACPI_STATUS (AE_OK);
+    return (AE_OK);
 
 
 ErrorExit:
@@ -679,7 +716,7 @@ ErrorExit:
         AcpiUtDeleteGenericState (State);
     }
 
-    return_ACPI_STATUS (Status);
+    return (Status);
 }
 
 
@@ -701,14 +738,14 @@ AcpiUtAddReference (
     ACPI_OPERAND_OBJECT     *Object)
 {
 
-    ACPI_FUNCTION_TRACE_PTR (UtAddReference, Object);
+    ACPI_FUNCTION_NAME (UtAddReference);
 
 
     /* Ensure that we have a valid object */
 
     if (!AcpiUtValidInternalObject (Object))
     {
-        return_VOID;
+        return;
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
@@ -718,7 +755,7 @@ AcpiUtAddReference (
     /* Increment the reference count */
 
     (void) AcpiUtUpdateObjectReference (Object, REF_INCREMENT);
-    return_VOID;
+    return;
 }
 
 
@@ -739,26 +776,25 @@ AcpiUtRemoveReference (
     ACPI_OPERAND_OBJECT     *Object)
 {
 
-    ACPI_FUNCTION_TRACE_PTR (UtRemoveReference, Object);
+    ACPI_FUNCTION_NAME (UtRemoveReference);
 
 
     /*
      * Allow a NULL pointer to be passed in, just ignore it. This saves
      * each caller from having to check. Also, ignore NS nodes.
-     *
      */
     if (!Object ||
         (ACPI_GET_DESCRIPTOR_TYPE (Object) == ACPI_DESC_TYPE_NAMED))
 
     {
-        return_VOID;
+        return;
     }
 
     /* Ensure that we have a valid object */
 
     if (!AcpiUtValidInternalObject (Object))
     {
-        return_VOID;
+        return;
     }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS,
@@ -771,7 +807,5 @@ AcpiUtRemoveReference (
      * of all subobjects!)
      */
     (void) AcpiUtUpdateObjectReference (Object, REF_DECREMENT);
-    return_VOID;
+    return;
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/uterror.c b/usr/src/uts/intel/io/acpica/utilities/uterror.c
new file mode 100644
index 0000000000..86d2368521
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/uterror.c
@@ -0,0 +1,325 @@
+/*******************************************************************************
+ *
+ * Module Name: uterror - Various internal error/warning output functions
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acnamesp.h"
+
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("uterror")
+
+
+/*
+ * This module contains internal error functions that may
+ * be configured out.
+ */
+#if !defined (ACPI_NO_ERROR_MESSAGES)
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtPredefinedWarning
+ *
+ * PARAMETERS:  ModuleName      - Caller's module name (for error output)
+ *              LineNumber      - Caller's line number (for error output)
+ *              Pathname        - Full pathname to the node
+ *              NodeFlags       - From Namespace node for the method/object
+ *              Format          - Printf format string + additional args
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Warnings for the predefined validation module. Messages are
+ *              only emitted the first time a problem with a particular
+ *              method/object is detected. This prevents a flood of error
+ *              messages for methods that are repeatedly evaluated.
+ *
+ ******************************************************************************/
+
+void ACPI_INTERNAL_VAR_XFACE
+AcpiUtPredefinedWarning (
+    const char              *ModuleName,
+    UINT32                  LineNumber,
+    char                    *Pathname,
+    UINT8                   NodeFlags,
+    const char              *Format,
+    ...)
+{
+    va_list                 ArgList;
+
+
+    /*
+     * Warning messages for this method/object will be disabled after the
+     * first time a validation fails or an object is successfully repaired.
+     */
+    if (NodeFlags & ANOBJ_EVALUATED)
+    {
+        return;
+    }
+
+    AcpiOsPrintf (ACPI_MSG_WARNING "%s: ", Pathname);
+
+    va_start (ArgList, Format);
+    AcpiOsVprintf (Format, ArgList);
+    ACPI_MSG_SUFFIX;
+    va_end (ArgList);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtPredefinedInfo
+ *
+ * PARAMETERS:  ModuleName      - Caller's module name (for error output)
+ *              LineNumber      - Caller's line number (for error output)
+ *              Pathname        - Full pathname to the node
+ *              NodeFlags       - From Namespace node for the method/object
+ *              Format          - Printf format string + additional args
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Info messages for the predefined validation module. Messages
+ *              are only emitted the first time a problem with a particular
+ *              method/object is detected. This prevents a flood of
+ *              messages for methods that are repeatedly evaluated.
+ *
+ ******************************************************************************/
+
+void ACPI_INTERNAL_VAR_XFACE
+AcpiUtPredefinedInfo (
+    const char              *ModuleName,
+    UINT32                  LineNumber,
+    char                    *Pathname,
+    UINT8                   NodeFlags,
+    const char              *Format,
+    ...)
+{
+    va_list                 ArgList;
+
+
+    /*
+     * Warning messages for this method/object will be disabled after the
+     * first time a validation fails or an object is successfully repaired.
+     */
+    if (NodeFlags & ANOBJ_EVALUATED)
+    {
+        return;
+    }
+
+    AcpiOsPrintf (ACPI_MSG_INFO "%s: ", Pathname);
+
+    va_start (ArgList, Format);
+    AcpiOsVprintf (Format, ArgList);
+    ACPI_MSG_SUFFIX;
+    va_end (ArgList);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtPredefinedBiosError
+ *
+ * PARAMETERS:  ModuleName      - Caller's module name (for error output)
+ *              LineNumber      - Caller's line number (for error output)
+ *              Pathname        - Full pathname to the node
+ *              NodeFlags       - From Namespace node for the method/object
+ *              Format          - Printf format string + additional args
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: BIOS error message for predefined names. Messages
+ *              are only emitted the first time a problem with a particular
+ *              method/object is detected. This prevents a flood of
+ *              messages for methods that are repeatedly evaluated.
+ *
+ ******************************************************************************/
+
+void ACPI_INTERNAL_VAR_XFACE
+AcpiUtPredefinedBiosError (
+    const char              *ModuleName,
+    UINT32                  LineNumber,
+    char                    *Pathname,
+    UINT8                   NodeFlags,
+    const char              *Format,
+    ...)
+{
+    va_list                 ArgList;
+
+
+    /*
+     * Warning messages for this method/object will be disabled after the
+     * first time a validation fails or an object is successfully repaired.
+     */
+    if (NodeFlags & ANOBJ_EVALUATED)
+    {
+        return;
+    }
+
+    AcpiOsPrintf (ACPI_MSG_BIOS_ERROR "%s: ", Pathname);
+
+    va_start (ArgList, Format);
+    AcpiOsVprintf (Format, ArgList);
+    ACPI_MSG_SUFFIX;
+    va_end (ArgList);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtNamespaceError
+ *
+ * PARAMETERS:  ModuleName          - Caller's module name (for error output)
+ *              LineNumber          - Caller's line number (for error output)
+ *              InternalName        - Name or path of the namespace node
+ *              LookupStatus        - Exception code from NS lookup
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print error message with the full pathname for the NS node.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtNamespaceError (
+    const char              *ModuleName,
+    UINT32                  LineNumber,
+    const char              *InternalName,
+    ACPI_STATUS             LookupStatus)
+{
+    ACPI_STATUS             Status;
+    UINT32                  BadName;
+    char                    *Name = NULL;
+
+
+    ACPI_MSG_REDIRECT_BEGIN;
+    AcpiOsPrintf (ACPI_MSG_ERROR);
+
+    if (LookupStatus == AE_BAD_CHARACTER)
+    {
+        /* There is a non-ascii character in the name */
+
+        ACPI_MOVE_32_TO_32 (&BadName, ACPI_CAST_PTR (UINT32, InternalName));
+        AcpiOsPrintf ("[0x%.8X] (NON-ASCII)", BadName);
+    }
+    else
+    {
+        /* Convert path to external format */
+
+        Status = AcpiNsExternalizeName (
+            ACPI_UINT32_MAX, InternalName, NULL, &Name);
+
+        /* Print target name */
+
+        if (ACPI_SUCCESS (Status))
+        {
+            AcpiOsPrintf ("[%s]", Name);
+        }
+        else
+        {
+            AcpiOsPrintf ("[COULD NOT EXTERNALIZE NAME]");
+        }
+
+        if (Name)
+        {
+            ACPI_FREE (Name);
+        }
+    }
+
+    AcpiOsPrintf (" Namespace lookup failure, %s",
+        AcpiFormatException (LookupStatus));
+
+    ACPI_MSG_SUFFIX;
+    ACPI_MSG_REDIRECT_END;
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtMethodError
+ *
+ * PARAMETERS:  ModuleName          - Caller's module name (for error output)
+ *              LineNumber          - Caller's line number (for error output)
+ *              Message             - Error message to use on failure
+ *              PrefixNode          - Prefix relative to the path
+ *              Path                - Path to the node (optional)
+ *              MethodStatus        - Execution status
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Print error message with the full pathname for the method.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtMethodError (
+    const char              *ModuleName,
+    UINT32                  LineNumber,
+    const char              *Message,
+    ACPI_NAMESPACE_NODE     *PrefixNode,
+    const char              *Path,
+    ACPI_STATUS             MethodStatus)
+{
+    ACPI_STATUS             Status;
+    ACPI_NAMESPACE_NODE     *Node = PrefixNode;
+
+
+    ACPI_MSG_REDIRECT_BEGIN;
+    AcpiOsPrintf (ACPI_MSG_ERROR);
+
+    if (Path)
+    {
+        Status = AcpiNsGetNode (PrefixNode, Path,
+            ACPI_NS_NO_UPSEARCH, &Node);
+        if (ACPI_FAILURE (Status))
+        {
+            AcpiOsPrintf ("[Could not get node by pathname]");
+        }
+    }
+
+    AcpiNsPrintNodePathname (Node, Message);
+    AcpiOsPrintf (", %s", AcpiFormatException (MethodStatus));
+
+    ACPI_MSG_SUFFIX;
+    ACPI_MSG_REDIRECT_END;
+}
+
+#endif /* ACPI_NO_ERROR_MESSAGES */
diff --git a/usr/src/uts/intel/io/acpica/utilities/uteval.c b/usr/src/uts/intel/io/acpica/utilities/uteval.c
index 0bcb894b58..d4864f3813 100644
--- a/usr/src/uts/intel/io/acpica/utilities/uteval.c
+++ b/usr/src/uts/intel/io/acpica/utilities/uteval.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTEVAL_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -74,7 +72,7 @@
 ACPI_STATUS
 AcpiUtEvaluateObject (
     ACPI_NAMESPACE_NODE     *PrefixNode,
-    char                    *Path,
+    const char              *Path,
     UINT32                  ExpectedReturnBtypes,
     ACPI_OPERAND_OBJECT     **ReturnDesc)
 {
@@ -95,7 +93,7 @@ AcpiUtEvaluateObject (
     }
 
     Info->PrefixNode = PrefixNode;
-    Info->Pathname = Path;
+    Info->RelativePathname = Path;
 
     /* Evaluate the object/method */
 
@@ -136,22 +134,27 @@ AcpiUtEvaluateObject (
     switch ((Info->ReturnObject)->Common.Type)
     {
     case ACPI_TYPE_INTEGER:
+
         ReturnBtype = ACPI_BTYPE_INTEGER;
         break;
 
     case ACPI_TYPE_BUFFER:
+
         ReturnBtype = ACPI_BTYPE_BUFFER;
         break;
 
     case ACPI_TYPE_STRING:
+
         ReturnBtype = ACPI_BTYPE_STRING;
         break;
 
     case ACPI_TYPE_PACKAGE:
+
         ReturnBtype = ACPI_BTYPE_PACKAGE;
         break;
 
     default:
+
         ReturnBtype = 0;
         break;
     }
@@ -216,7 +219,7 @@ Cleanup:
 
 ACPI_STATUS
 AcpiUtEvaluateNumericObject (
-    char                    *ObjectName,
+    const char              *ObjectName,
     ACPI_NAMESPACE_NODE     *DeviceNode,
     UINT64                  *Value)
 {
@@ -228,7 +231,7 @@ AcpiUtEvaluateNumericObject (
 
 
     Status = AcpiUtEvaluateObject (DeviceNode, ObjectName,
-                ACPI_BTYPE_INTEGER, &ObjDesc);
+        ACPI_BTYPE_INTEGER, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -255,7 +258,8 @@ AcpiUtEvaluateNumericObject (
  * RETURN:      Status
  *
  * DESCRIPTION: Executes _STA for selected device and stores results in
- *              *Flags.
+ *              *Flags. If _STA does not exist, then the device is assumed
+ *              to be present/functional/enabled (as per the ACPI spec).
  *
  *              NOTE: Internal function, no parameter validation
  *
@@ -274,11 +278,16 @@ AcpiUtExecute_STA (
 
 
     Status = AcpiUtEvaluateObject (DeviceNode, METHOD_NAME__STA,
-                ACPI_BTYPE_INTEGER, &ObjDesc);
+        ACPI_BTYPE_INTEGER, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         if (AE_NOT_FOUND == Status)
         {
+            /*
+             * if _STA does not exist, then (as per the ACPI specification),
+             * the returned flags will indicate that the device is present,
+             * functional, and enabled.
+             */
             ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
                 "_STA on %4.4s was not found, assuming device is present\n",
                 AcpiUtGetNodeName (DeviceNode)));
@@ -342,8 +351,8 @@ AcpiUtExecutePowerMethods (
          * return type is an Integer.
          */
         Status = AcpiUtEvaluateObject (DeviceNode,
-                    ACPI_CAST_PTR (char, MethodNames[i]),
-                    ACPI_BTYPE_INTEGER, &ObjDesc);
+            ACPI_CAST_PTR (char, MethodNames[i]),
+            ACPI_BTYPE_INTEGER, &ObjDesc);
         if (ACPI_SUCCESS (Status))
         {
             OutValues[i] = (UINT8) ObjDesc->Integer.Value;
diff --git a/usr/src/uts/intel/io/acpica/utilities/utexcep.c b/usr/src/uts/intel/io/acpica/utilities/utexcep.c
new file mode 100644
index 0000000000..5be8efd5f2
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utexcep.c
@@ -0,0 +1,179 @@
+/*******************************************************************************
+ *
+ * Module Name: utexcep - Exception code support
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define EXPORT_ACPI_INTERFACES
+
+#define ACPI_DEFINE_EXCEPTION_TABLE
+#include "acpi.h"
+#include "accommon.h"
+
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("utexcep")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiFormatException
+ *
+ * PARAMETERS:  Status              - The ACPI_STATUS code to be formatted
+ *
+ * RETURN:      A string containing the exception text. A valid pointer is
+ *              always returned.
+ *
+ * DESCRIPTION: This function translates an ACPI exception into an ASCII
+ *              string. Returns "unknown status" string for invalid codes.
+ *
+ ******************************************************************************/
+
+const char *
+AcpiFormatException (
+    ACPI_STATUS             Status)
+{
+    const ACPI_EXCEPTION_INFO   *Exception;
+
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    Exception = AcpiUtValidateException (Status);
+    if (!Exception)
+    {
+        /* Exception code was not recognized */
+
+        ACPI_ERROR ((AE_INFO,
+            "Unknown exception code: 0x%8.8X", Status));
+
+        return ("UNKNOWN_STATUS_CODE");
+    }
+
+    return (Exception->Name);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiFormatException)
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtValidateException
+ *
+ * PARAMETERS:  Status              - The ACPI_STATUS code to be formatted
+ *
+ * RETURN:      A string containing the exception text. NULL if exception is
+ *              not valid.
+ *
+ * DESCRIPTION: This function validates and translates an ACPI exception into
+ *              an ASCII string.
+ *
+ ******************************************************************************/
+
+const ACPI_EXCEPTION_INFO *
+AcpiUtValidateException (
+    ACPI_STATUS             Status)
+{
+    UINT32                      SubStatus;
+    const ACPI_EXCEPTION_INFO   *Exception = NULL;
+
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    /*
+     * Status is composed of two parts, a "type" and an actual code
+     */
+    SubStatus = (Status & ~AE_CODE_MASK);
+
+    switch (Status & AE_CODE_MASK)
+    {
+    case AE_CODE_ENVIRONMENTAL:
+
+        if (SubStatus <= AE_CODE_ENV_MAX)
+        {
+            Exception = &AcpiGbl_ExceptionNames_Env [SubStatus];
+        }
+        break;
+
+    case AE_CODE_PROGRAMMER:
+
+        if (SubStatus <= AE_CODE_PGM_MAX)
+        {
+            Exception = &AcpiGbl_ExceptionNames_Pgm [SubStatus];
+        }
+        break;
+
+    case AE_CODE_ACPI_TABLES:
+
+        if (SubStatus <= AE_CODE_TBL_MAX)
+        {
+            Exception = &AcpiGbl_ExceptionNames_Tbl [SubStatus];
+        }
+        break;
+
+    case AE_CODE_AML:
+
+        if (SubStatus <= AE_CODE_AML_MAX)
+        {
+            Exception = &AcpiGbl_ExceptionNames_Aml [SubStatus];
+        }
+        break;
+
+    case AE_CODE_CONTROL:
+
+        if (SubStatus <= AE_CODE_CTRL_MAX)
+        {
+            Exception = &AcpiGbl_ExceptionNames_Ctrl [SubStatus];
+        }
+        break;
+
+    default:
+
+        break;
+    }
+
+    if (!Exception || !Exception->Name)
+    {
+        return (NULL);
+    }
+
+    return (Exception);
+}
diff --git a/usr/src/uts/intel/io/acpica/utilities/utglobal.c b/usr/src/uts/intel/io/acpica/utilities/utglobal.c
index f913e32228..0d8dff88c9 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utglobal.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utglobal.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,7 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTGLOBAL_C__
+#define EXPORT_ACPI_INTERFACES
 #define DEFINE_ACPI_GLOBALS
 
 #include "acpi.h"
@@ -57,37 +57,7 @@
  *
  ******************************************************************************/
 
-/*
- * We want the debug switches statically initialized so they
- * are already set when the debugger is entered.
- */
-
-/* Debug switch - level and trace mask */
-
-#ifdef ACPI_DEBUG_OUTPUT
-UINT32                      AcpiDbgLevel = ACPI_DEBUG_DEFAULT;
-#else
-UINT32                      AcpiDbgLevel = ACPI_NORMAL_DEFAULT;
-#endif
-
-/* Debug switch - layer (component) mask */
-
-UINT32                      AcpiDbgLayer = ACPI_COMPONENT_DEFAULT;
-UINT32                      AcpiGbl_NestingLevel = 0;
-
-/* Debugger globals */
-
-BOOLEAN                     AcpiGbl_DbTerminateThreads = FALSE;
-BOOLEAN                     AcpiGbl_AbortMethod = FALSE;
-BOOLEAN                     AcpiGbl_MethodExecuting = FALSE;
-
-/* System flags */
-
-UINT32                      AcpiGbl_StartupFlags = 0;
-
-/* System starts uninitialized */
-
-BOOLEAN                     AcpiGbl_Shutdown = TRUE;
+/* Various state name strings */
 
 const char                  *AcpiGbl_SleepStateNames[ACPI_S_STATE_COUNT] =
 {
@@ -117,6 +87,12 @@ const char                  *AcpiGbl_HighestDstateNames[ACPI_NUM_SxD_METHODS] =
 };
 
 
+/* Hex-to-ascii */
+
+const char                  AcpiGbl_LowerHexDigits[] = "0123456789abcdef";
+const char                  AcpiGbl_UpperHexDigits[] = "0123456789ABCDEF";
+
+
 /*******************************************************************************
  *
  * Namespace globals
@@ -141,12 +117,19 @@ const ACPI_PREDEFINED_NAMES     AcpiGbl_PreDefinedNames[] =
     {"_SB_",    ACPI_TYPE_DEVICE,           NULL},
     {"_SI_",    ACPI_TYPE_LOCAL_SCOPE,      NULL},
     {"_TZ_",    ACPI_TYPE_DEVICE,           NULL},
-    {"_REV",    ACPI_TYPE_INTEGER,          (char *) ACPI_CA_SUPPORT_LEVEL},
+    /*
+     * March, 2015:
+     * The _REV object is in the process of being deprecated, because
+     * other ACPI implementations permanently return 2. Thus, it
+     * has little or no value. Return 2 for compatibility with
+     * other ACPI implementations.
+     */
+    {"_REV",    ACPI_TYPE_INTEGER,          ACPI_CAST_PTR (char, 2)},
     {"_OS_",    ACPI_TYPE_STRING,           ACPI_OS_NAME},
-    {"_GL_",    ACPI_TYPE_MUTEX,            (char *) 1},
+    {"_GL_",    ACPI_TYPE_MUTEX,            ACPI_CAST_PTR (char, 1)},
 
 #if !defined (ACPI_NO_METHOD_EXECUTION) || defined (ACPI_CONSTANT_EVAL_ONLY)
-    {"_OSI",    ACPI_TYPE_METHOD,           (char *) 1},
+    {"_OSI",    ACPI_TYPE_METHOD,           ACPI_CAST_PTR (char, 1)},
 #endif
 
     /* Table terminator */
@@ -203,158 +186,53 @@ ACPI_FIXED_EVENT_INFO       AcpiGbl_FixedEventInfo[ACPI_NUM_FIXED_EVENTS] =
 #endif /* !ACPI_REDUCED_HARDWARE */
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtInitGlobals
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Init ACPICA globals.  All globals that require specific
- *              initialization should be initialized here!
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiUtInitGlobals (
-    void)
-{
-    ACPI_STATUS             Status;
-    UINT32                  i;
-
-
-    ACPI_FUNCTION_TRACE (UtInitGlobals);
-
+#if defined (ACPI_DISASSEMBLER) || defined (ACPI_ASL_COMPILER)
 
-    /* Create all memory caches */
+/* ToPld macro: compile/disassemble strings */
 
-    Status = AcpiUtCreateCaches ();
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Address Range lists */
-
-    for (i = 0; i < ACPI_ADDRESS_RANGE_MAX; i++)
-    {
-        AcpiGbl_AddressRangeList[i] = NULL;
-    }
-
-    /* Mutex locked flags */
-
-    for (i = 0; i < ACPI_NUM_MUTEX; i++)
-    {
-        AcpiGbl_MutexInfo[i].Mutex          = NULL;
-        AcpiGbl_MutexInfo[i].ThreadId       = ACPI_MUTEX_NOT_ACQUIRED;
-        AcpiGbl_MutexInfo[i].UseCount       = 0;
-    }
-
-    for (i = 0; i < ACPI_NUM_OWNERID_MASKS; i++)
-    {
-        AcpiGbl_OwnerIdMask[i]              = 0;
-    }
-
-    /* Last OwnerID is never valid */
-
-    AcpiGbl_OwnerIdMask[ACPI_NUM_OWNERID_MASKS - 1] = 0x80000000;
-
-    /* Event counters */
-
-    AcpiMethodCount                     = 0;
-    AcpiSciCount                        = 0;
-    AcpiGpeCount                        = 0;
-
-    for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++)
-    {
-        AcpiFixedEventCount[i]              = 0;
-    }
-
-#if (!ACPI_REDUCED_HARDWARE)
-
-    /* GPE support */
-
-    AcpiGbl_AllGpesInitialized          = FALSE;
-    AcpiGbl_GpeXruptListHead            = NULL;
-    AcpiGbl_GpeFadtBlocks[0]            = NULL;
-    AcpiGbl_GpeFadtBlocks[1]            = NULL;
-    AcpiCurrentGpeCount                 = 0;
-
-    AcpiGbl_GlobalEventHandler          = NULL;
-
-#endif /* !ACPI_REDUCED_HARDWARE */
+const char              *AcpiGbl_PldPanelList[] =
+{
+    "TOP",
+    "BOTTOM",
+    "LEFT",
+    "RIGHT",
+    "FRONT",
+    "BACK",
+    "UNKNOWN",
+    NULL
+};
 
-    /* Global handlers */
-
-    AcpiGbl_GlobalNotify[0].Handler     = NULL;
-    AcpiGbl_GlobalNotify[1].Handler     = NULL;
-    AcpiGbl_ExceptionHandler            = NULL;
-    AcpiGbl_InitHandler                 = NULL;
-    AcpiGbl_TableHandler                = NULL;
-    AcpiGbl_InterfaceHandler            = NULL;
-
-    /* Global Lock support */
-
-    AcpiGbl_GlobalLockSemaphore         = NULL;
-    AcpiGbl_GlobalLockMutex             = NULL;
-    AcpiGbl_GlobalLockAcquired          = FALSE;
-    AcpiGbl_GlobalLockHandle            = 0;
-    AcpiGbl_GlobalLockPresent           = FALSE;
-
-    /* Miscellaneous variables */
-
-    AcpiGbl_DSDT                        = NULL;
-    AcpiGbl_CmSingleStep                = FALSE;
-    AcpiGbl_DbTerminateThreads          = FALSE;
-    AcpiGbl_Shutdown                    = FALSE;
-    AcpiGbl_NsLookupCount               = 0;
-    AcpiGbl_PsFindCount                 = 0;
-    AcpiGbl_AcpiHardwarePresent         = TRUE;
-    AcpiGbl_LastOwnerIdIndex            = 0;
-    AcpiGbl_NextOwnerIdOffset           = 0;
-    AcpiGbl_TraceMethodName             = 0;
-    AcpiGbl_TraceDbgLevel               = 0;
-    AcpiGbl_TraceDbgLayer               = 0;
-    AcpiGbl_DebuggerConfiguration       = DEBUGGER_THREADING;
-    AcpiGbl_DbOutputFlags               = ACPI_DB_CONSOLE_OUTPUT;
-    AcpiGbl_OsiData                     = 0;
-    AcpiGbl_OsiMutex                    = NULL;
-    AcpiGbl_RegMethodsExecuted          = FALSE;
-
-    /* Hardware oriented */
-
-    AcpiGbl_EventsInitialized           = FALSE;
-    AcpiGbl_SystemAwakeAndRunning       = TRUE;
-
-    /* Namespace */
-
-    AcpiGbl_ModuleCodeList              = NULL;
-    AcpiGbl_RootNode                    = NULL;
-    AcpiGbl_RootNodeStruct.Name.Integer = ACPI_ROOT_NAME;
-    AcpiGbl_RootNodeStruct.DescriptorType = ACPI_DESC_TYPE_NAMED;
-    AcpiGbl_RootNodeStruct.Type         = ACPI_TYPE_DEVICE;
-    AcpiGbl_RootNodeStruct.Parent       = NULL;
-    AcpiGbl_RootNodeStruct.Child        = NULL;
-    AcpiGbl_RootNodeStruct.Peer         = NULL;
-    AcpiGbl_RootNodeStruct.Object       = NULL;
-
-
-#ifdef ACPI_DISASSEMBLER
-    AcpiGbl_ExternalList                = NULL;
-#endif
+const char              *AcpiGbl_PldVerticalPositionList[] =
+{
+    "UPPER",
+    "CENTER",
+    "LOWER",
+    NULL
+};
 
-#ifdef ACPI_DEBUG_OUTPUT
-    AcpiGbl_LowestStackPointer          = ACPI_CAST_PTR (ACPI_SIZE, ACPI_SIZE_MAX);
-#endif
+const char              *AcpiGbl_PldHorizontalPositionList[] =
+{
+    "LEFT",
+    "CENTER",
+    "RIGHT",
+    NULL
+};
 
-#ifdef ACPI_DBG_TRACK_ALLOCATIONS
-    AcpiGbl_DisplayFinalMemStats        = FALSE;
-    AcpiGbl_DisableMemTracking          = FALSE;
+const char              *AcpiGbl_PldShapeList[] =
+{
+    "ROUND",
+    "OVAL",
+    "SQUARE",
+    "VERTICALRECTANGLE",
+    "HORIZONTALRECTANGLE",
+    "VERTICALTRAPEZOID",
+    "HORIZONTALTRAPEZOID",
+    "UNKNOWN",
+    "CHAMFERED",
+    NULL
+};
 #endif
 
-    return_ACPI_STATUS (AE_OK);
-}
 
 /* Public globals */
 
diff --git a/usr/src/uts/intel/io/acpica/utilities/uthex.c b/usr/src/uts/intel/io/acpica/utilities/uthex.c
new file mode 100644
index 0000000000..b93013b200
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/uthex.c
@@ -0,0 +1,111 @@
+/******************************************************************************
+ *
+ * Module Name: uthex -- Hex/ASCII support functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("uthex")
+
+
+/* Hex to ASCII conversion table */
+
+static const char           AcpiGbl_HexToAscii[] =
+{
+    '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtHexToAsciiChar
+ *
+ * PARAMETERS:  Integer             - Contains the hex digit
+ *              Position            - bit position of the digit within the
+ *                                    integer (multiple of 4)
+ *
+ * RETURN:      The converted Ascii character
+ *
+ * DESCRIPTION: Convert a hex digit to an Ascii character
+ *
+ ******************************************************************************/
+
+char
+AcpiUtHexToAsciiChar (
+    UINT64                  Integer,
+    UINT32                  Position)
+{
+
+    return (AcpiGbl_HexToAscii[(Integer >> Position) & 0xF]);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtAsciiCharToHex
+ *
+ * PARAMETERS:  HexChar                 - Hex character in Ascii
+ *
+ * RETURN:      The binary value of the ascii/hex character
+ *
+ * DESCRIPTION: Perform ascii-to-hex translation
+ *
+ ******************************************************************************/
+
+UINT8
+AcpiUtAsciiCharToHex (
+    int                     HexChar)
+{
+
+    if (HexChar <= 0x39)
+    {
+        return ((UINT8) (HexChar - 0x30));
+    }
+
+    if (HexChar <= 0x46)
+    {
+        return ((UINT8) (HexChar - 0x37));
+    }
+
+    return ((UINT8) (HexChar - 0x57));
+}
diff --git a/usr/src/uts/intel/io/acpica/utilities/utids.c b/usr/src/uts/intel/io/acpica/utilities/utids.c
index 226d8c1631..7182a91ae8 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utids.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utids.c
@@ -1,11 +1,11 @@
 /******************************************************************************
  *
- * Module Name: utids - support for device IDs - HID, UID, CID
+ * Module Name: utids - support for device IDs - HID, UID, CID, SUB, CLS
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTIDS_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acinterp.h"
@@ -73,10 +71,10 @@
 ACPI_STATUS
 AcpiUtExecute_HID (
     ACPI_NAMESPACE_NODE     *DeviceNode,
-    ACPI_DEVICE_ID          **ReturnId)
+    ACPI_PNP_DEVICE_ID      **ReturnId)
 {
     ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_DEVICE_ID          *Hid;
+    ACPI_PNP_DEVICE_ID      *Hid;
     UINT32                  Length;
     ACPI_STATUS             Status;
 
@@ -85,7 +83,7 @@ AcpiUtExecute_HID (
 
 
     Status = AcpiUtEvaluateObject (DeviceNode, METHOD_NAME__HID,
-                ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING, &ObjDesc);
+        ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -104,16 +102,17 @@ AcpiUtExecute_HID (
 
     /* Allocate a buffer for the HID */
 
-    Hid = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_DEVICE_ID) + (ACPI_SIZE) Length);
+    Hid = ACPI_ALLOCATE_ZEROED (
+        sizeof (ACPI_PNP_DEVICE_ID) + (ACPI_SIZE) Length);
     if (!Hid)
     {
         Status = AE_NO_MEMORY;
         goto Cleanup;
     }
 
-    /* Area for the string starts after DEVICE_ID struct */
+    /* Area for the string starts after PNP_DEVICE_ID struct */
 
-    Hid->String = ACPI_ADD_PTR (char, Hid, sizeof (ACPI_DEVICE_ID));
+    Hid->String = ACPI_ADD_PTR (char, Hid, sizeof (ACPI_PNP_DEVICE_ID));
 
     /* Convert EISAID to a string or simply copy existing string */
 
@@ -123,7 +122,7 @@ AcpiUtExecute_HID (
     }
     else
     {
-        ACPI_STRCPY (Hid->String, ObjDesc->String.Pointer);
+        strcpy (Hid->String, ObjDesc->String.Pointer);
     }
 
     Hid->Length = Length;
@@ -160,10 +159,10 @@ Cleanup:
 ACPI_STATUS
 AcpiUtExecute_UID (
     ACPI_NAMESPACE_NODE     *DeviceNode,
-    ACPI_DEVICE_ID          **ReturnId)
+    ACPI_PNP_DEVICE_ID      **ReturnId)
 {
     ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_DEVICE_ID          *Uid;
+    ACPI_PNP_DEVICE_ID      *Uid;
     UINT32                  Length;
     ACPI_STATUS             Status;
 
@@ -172,7 +171,7 @@ AcpiUtExecute_UID (
 
 
     Status = AcpiUtEvaluateObject (DeviceNode, METHOD_NAME__UID,
-                ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING, &ObjDesc);
+        ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING, &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -191,16 +190,17 @@ AcpiUtExecute_UID (
 
     /* Allocate a buffer for the UID */
 
-    Uid = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_DEVICE_ID) + (ACPI_SIZE) Length);
+    Uid = ACPI_ALLOCATE_ZEROED (
+        sizeof (ACPI_PNP_DEVICE_ID) + (ACPI_SIZE) Length);
     if (!Uid)
     {
         Status = AE_NO_MEMORY;
         goto Cleanup;
     }
 
-    /* Area for the string starts after DEVICE_ID struct */
+    /* Area for the string starts after PNP_DEVICE_ID struct */
 
-    Uid->String = ACPI_ADD_PTR (char, Uid, sizeof (ACPI_DEVICE_ID));
+    Uid->String = ACPI_ADD_PTR (char, Uid, sizeof (ACPI_PNP_DEVICE_ID));
 
     /* Convert an Integer to string, or just copy an existing string */
 
@@ -210,7 +210,7 @@ AcpiUtExecute_UID (
     }
     else
     {
-        ACPI_STRCPY (Uid->String, ObjDesc->String.Pointer);
+        strcpy (Uid->String, ObjDesc->String.Pointer);
     }
 
     Uid->Length = Length;
@@ -252,11 +252,11 @@ Cleanup:
 ACPI_STATUS
 AcpiUtExecute_CID (
     ACPI_NAMESPACE_NODE     *DeviceNode,
-    ACPI_DEVICE_ID_LIST     **ReturnCidList)
+    ACPI_PNP_DEVICE_ID_LIST **ReturnCidList)
 {
     ACPI_OPERAND_OBJECT     **CidObjects;
     ACPI_OPERAND_OBJECT     *ObjDesc;
-    ACPI_DEVICE_ID_LIST     *CidList;
+    ACPI_PNP_DEVICE_ID_LIST *CidList;
     char                    *NextIdString;
     UINT32                  StringAreaSize;
     UINT32                  Length;
@@ -272,8 +272,8 @@ AcpiUtExecute_CID (
     /* Evaluate the _CID method for this device */
 
     Status = AcpiUtEvaluateObject (DeviceNode, METHOD_NAME__CID,
-                ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING | ACPI_BTYPE_PACKAGE,
-                &ObjDesc);
+        ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING | ACPI_BTYPE_PACKAGE,
+        &ObjDesc);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -304,14 +304,17 @@ AcpiUtExecute_CID (
         switch (CidObjects[i]->Common.Type)
         {
         case ACPI_TYPE_INTEGER:
+
             StringAreaSize += ACPI_EISAID_STRING_SIZE;
             break;
 
         case ACPI_TYPE_STRING:
+
             StringAreaSize += CidObjects[i]->String.Length + 1;
             break;
 
         default:
+
             Status = AE_TYPE;
             goto Cleanup;
         }
@@ -320,11 +323,11 @@ AcpiUtExecute_CID (
     /*
      * Now that we know the length of the CIDs, allocate return buffer:
      * 1) Size of the base structure +
-     * 2) Size of the CID DEVICE_ID array +
+     * 2) Size of the CID PNP_DEVICE_ID array +
      * 3) Size of the actual CID strings
      */
-    CidListSize = sizeof (ACPI_DEVICE_ID_LIST) +
-        ((Count - 1) * sizeof (ACPI_DEVICE_ID)) +
+    CidListSize = sizeof (ACPI_PNP_DEVICE_ID_LIST) +
+        ((Count - 1) * sizeof (ACPI_PNP_DEVICE_ID)) +
         StringAreaSize;
 
     CidList = ACPI_ALLOCATE_ZEROED (CidListSize);
@@ -334,10 +337,10 @@ AcpiUtExecute_CID (
         goto Cleanup;
     }
 
-    /* Area for CID strings starts after the CID DEVICE_ID array */
+    /* Area for CID strings starts after the CID PNP_DEVICE_ID array */
 
     NextIdString = ACPI_CAST_PTR (char, CidList->Ids) +
-        ((ACPI_SIZE) Count * sizeof (ACPI_DEVICE_ID));
+        ((ACPI_SIZE) Count * sizeof (ACPI_PNP_DEVICE_ID));
 
     /* Copy/convert the CIDs to the return buffer */
 
@@ -347,14 +350,15 @@ AcpiUtExecute_CID (
         {
             /* Convert the Integer (EISAID) CID to a string */
 
-            AcpiExEisaIdToString (NextIdString, CidObjects[i]->Integer.Value);
+            AcpiExEisaIdToString (
+                NextIdString, CidObjects[i]->Integer.Value);
             Length = ACPI_EISAID_STRING_SIZE;
         }
         else /* ACPI_TYPE_STRING */
         {
             /* Copy the String CID from the returned object */
 
-            ACPI_STRCPY (NextIdString, CidObjects[i]->String.Pointer);
+            strcpy (NextIdString, CidObjects[i]->String.Pointer);
             Length = CidObjects[i]->String.Length + 1;
         }
 
@@ -378,3 +382,97 @@ Cleanup:
     return_ACPI_STATUS (Status);
 }
 
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtExecute_CLS
+ *
+ * PARAMETERS:  DeviceNode          - Node for the device
+ *              ReturnId            - Where the _CLS is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Executes the _CLS control method that returns PCI-defined
+ *              class code of the device. The _CLS value is always a package
+ *              containing PCI class information as a list of integers.
+ *              The returned string has format "BBSSPP", where:
+ *                BB = Base-class code
+ *                SS = Sub-class code
+ *                PP = Programming Interface code
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiUtExecute_CLS (
+    ACPI_NAMESPACE_NODE     *DeviceNode,
+    ACPI_PNP_DEVICE_ID      **ReturnId)
+{
+    ACPI_OPERAND_OBJECT     *ObjDesc;
+    ACPI_OPERAND_OBJECT     **ClsObjects;
+    UINT32                  Count;
+    ACPI_PNP_DEVICE_ID      *Cls;
+    UINT32                  Length;
+    ACPI_STATUS             Status;
+    UINT8                   ClassCode[3] = {0, 0, 0};
+
+
+    ACPI_FUNCTION_TRACE (UtExecute_CLS);
+
+
+    Status = AcpiUtEvaluateObject (DeviceNode, METHOD_NAME__CLS,
+        ACPI_BTYPE_PACKAGE, &ObjDesc);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Get the size of the String to be returned, includes null terminator */
+
+    Length = ACPI_PCICLS_STRING_SIZE;
+    ClsObjects = ObjDesc->Package.Elements;
+    Count = ObjDesc->Package.Count;
+
+    if (ObjDesc->Common.Type == ACPI_TYPE_PACKAGE)
+    {
+        if (Count > 0 && ClsObjects[0]->Common.Type == ACPI_TYPE_INTEGER)
+        {
+            ClassCode[0] = (UINT8) ClsObjects[0]->Integer.Value;
+        }
+        if (Count > 1 && ClsObjects[1]->Common.Type == ACPI_TYPE_INTEGER)
+        {
+            ClassCode[1] = (UINT8) ClsObjects[1]->Integer.Value;
+        }
+        if (Count > 2 && ClsObjects[2]->Common.Type == ACPI_TYPE_INTEGER)
+        {
+            ClassCode[2] = (UINT8) ClsObjects[2]->Integer.Value;
+        }
+    }
+
+    /* Allocate a buffer for the CLS */
+
+    Cls = ACPI_ALLOCATE_ZEROED (
+        sizeof (ACPI_PNP_DEVICE_ID) + (ACPI_SIZE) Length);
+    if (!Cls)
+    {
+        Status = AE_NO_MEMORY;
+        goto Cleanup;
+    }
+
+    /* Area for the string starts after PNP_DEVICE_ID struct */
+
+    Cls->String = ACPI_ADD_PTR (char, Cls, sizeof (ACPI_PNP_DEVICE_ID));
+
+    /* Simply copy existing string */
+
+    AcpiExPciClsToString (Cls->String, ClassCode);
+    Cls->Length = Length;
+    *ReturnId = Cls;
+
+
+Cleanup:
+
+    /* On exit, we must delete the return object */
+
+    AcpiUtRemoveReference (ObjDesc);
+    return_ACPI_STATUS (Status);
+}
diff --git a/usr/src/uts/intel/io/acpica/utilities/utinit.c b/usr/src/uts/intel/io/acpica/utilities/utinit.c
index 6831595e68..03c3e510b8 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utinit.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utinit.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __UTINIT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -116,6 +113,158 @@ AcpiUtFreeGpeLists (
 #endif /* !ACPI_REDUCED_HARDWARE */
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtInitGlobals
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initialize ACPICA globals. All globals that require specific
+ *              initialization should be initialized here. This allows for
+ *              a warm restart.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiUtInitGlobals (
+    void)
+{
+    ACPI_STATUS             Status;
+    UINT32                  i;
+
+
+    ACPI_FUNCTION_TRACE (UtInitGlobals);
+
+
+    /* Create all memory caches */
+
+    Status = AcpiUtCreateCaches ();
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Address Range lists */
+
+    for (i = 0; i < ACPI_ADDRESS_RANGE_MAX; i++)
+    {
+        AcpiGbl_AddressRangeList[i] = NULL;
+    }
+
+    /* Mutex locked flags */
+
+    for (i = 0; i < ACPI_NUM_MUTEX; i++)
+    {
+        AcpiGbl_MutexInfo[i].Mutex          = NULL;
+        AcpiGbl_MutexInfo[i].ThreadId       = ACPI_MUTEX_NOT_ACQUIRED;
+        AcpiGbl_MutexInfo[i].UseCount       = 0;
+    }
+
+    for (i = 0; i < ACPI_NUM_OWNERID_MASKS; i++)
+    {
+        AcpiGbl_OwnerIdMask[i]              = 0;
+    }
+
+    /* Last OwnerID is never valid */
+
+    AcpiGbl_OwnerIdMask[ACPI_NUM_OWNERID_MASKS - 1] = 0x80000000;
+
+    /* Event counters */
+
+    AcpiMethodCount                     = 0;
+    AcpiSciCount                        = 0;
+    AcpiGpeCount                        = 0;
+
+    for (i = 0; i < ACPI_NUM_FIXED_EVENTS; i++)
+    {
+        AcpiFixedEventCount[i]              = 0;
+    }
+
+#if (!ACPI_REDUCED_HARDWARE)
+
+    /* GPE/SCI support */
+
+    AcpiGbl_AllGpesInitialized          = FALSE;
+    AcpiGbl_GpeXruptListHead            = NULL;
+    AcpiGbl_GpeFadtBlocks[0]            = NULL;
+    AcpiGbl_GpeFadtBlocks[1]            = NULL;
+    AcpiCurrentGpeCount                 = 0;
+
+    AcpiGbl_GlobalEventHandler          = NULL;
+    AcpiGbl_SciHandlerList              = NULL;
+
+#endif /* !ACPI_REDUCED_HARDWARE */
+
+    /* Global handlers */
+
+    AcpiGbl_GlobalNotify[0].Handler     = NULL;
+    AcpiGbl_GlobalNotify[1].Handler     = NULL;
+    AcpiGbl_ExceptionHandler            = NULL;
+    AcpiGbl_InitHandler                 = NULL;
+    AcpiGbl_TableHandler                = NULL;
+    AcpiGbl_InterfaceHandler            = NULL;
+
+    /* Global Lock support */
+
+    AcpiGbl_GlobalLockSemaphore         = NULL;
+    AcpiGbl_GlobalLockMutex             = NULL;
+    AcpiGbl_GlobalLockAcquired          = FALSE;
+    AcpiGbl_GlobalLockHandle            = 0;
+    AcpiGbl_GlobalLockPresent           = FALSE;
+
+    /* Miscellaneous variables */
+
+    AcpiGbl_DSDT                        = NULL;
+    AcpiGbl_CmSingleStep                = FALSE;
+    AcpiGbl_Shutdown                    = FALSE;
+    AcpiGbl_NsLookupCount               = 0;
+    AcpiGbl_PsFindCount                 = 0;
+    AcpiGbl_AcpiHardwarePresent         = TRUE;
+    AcpiGbl_LastOwnerIdIndex            = 0;
+    AcpiGbl_NextOwnerIdOffset           = 0;
+    AcpiGbl_DebuggerConfiguration       = DEBUGGER_THREADING;
+    AcpiGbl_OsiMutex                    = NULL;
+    AcpiGbl_MaxLoopIterations           = 0xFFFF;
+
+    /* Hardware oriented */
+
+    AcpiGbl_EventsInitialized           = FALSE;
+    AcpiGbl_SystemAwakeAndRunning       = TRUE;
+
+    /* Namespace */
+
+    AcpiGbl_ModuleCodeList              = NULL;
+    AcpiGbl_RootNode                    = NULL;
+    AcpiGbl_RootNodeStruct.Name.Integer = ACPI_ROOT_NAME;
+    AcpiGbl_RootNodeStruct.DescriptorType = ACPI_DESC_TYPE_NAMED;
+    AcpiGbl_RootNodeStruct.Type         = ACPI_TYPE_DEVICE;
+    AcpiGbl_RootNodeStruct.Parent       = NULL;
+    AcpiGbl_RootNodeStruct.Child        = NULL;
+    AcpiGbl_RootNodeStruct.Peer         = NULL;
+    AcpiGbl_RootNodeStruct.Object       = NULL;
+
+
+#ifdef ACPI_DISASSEMBLER
+    AcpiGbl_ExternalList                = NULL;
+    AcpiGbl_NumExternalMethods          = 0;
+    AcpiGbl_ResolvedExternalMethods     = 0;
+#endif
+
+#ifdef ACPI_DEBUG_OUTPUT
+    AcpiGbl_LowestStackPointer          = ACPI_CAST_PTR (ACPI_SIZE, ACPI_SIZE_MAX);
+#endif
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+    AcpiGbl_DisplayFinalMemStats        = FALSE;
+    AcpiGbl_DisableMemTracking          = FALSE;
+#endif
+
+    return_ACPI_STATUS (AE_OK);
+}
+
+
 /******************************************************************************
  *
  * FUNCTION:    AcpiUtTerminate
@@ -160,6 +309,20 @@ AcpiUtSubsystemShutdown (
     ACPI_FUNCTION_TRACE (UtSubsystemShutdown);
 
 
+    /* Just exit if subsystem is already shutdown */
+
+    if (AcpiGbl_Shutdown)
+    {
+        ACPI_ERROR ((AE_INFO, "ACPI Subsystem is already terminated"));
+        return_VOID;
+    }
+
+    /* Subsystem appears active, go ahead and shut it down */
+
+    AcpiGbl_Shutdown = TRUE;
+    AcpiGbl_StartupFlags = 0;
+    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Shutting down ACPI Subsystem\n"));
+
 #ifndef ACPI_ASL_COMPILER
 
     /* Close the AcpiEvent Handling */
@@ -188,5 +351,3 @@ AcpiUtSubsystemShutdown (
     (void) AcpiUtDeleteCaches ();
     return_VOID;
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utlock.c b/usr/src/uts/intel/io/acpica/utilities/utlock.c
index 61585ad499..c62a37d9f5 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utlock.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utlock.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTLOCK_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -202,4 +200,3 @@ AcpiUtReleaseWriteLock (
 
     AcpiOsReleaseMutex (Lock->WriterMutex);
 }
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utmath.c b/usr/src/uts/intel/io/acpica/utilities/utmath.c
index d0fad7cb6c..aa3d762c0d 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utmath.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utmath.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __UTMATH_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -90,7 +87,7 @@ typedef union uint64_overlay
  * RETURN:      Status (Checks for divide-by-zero)
  *
  * DESCRIPTION: Perform a short (maximum 64 bits divided by 32 bits)
- *              divide and modulo.  The result is a 64-bit quotient and a
+ *              divide and modulo. The result is a 64-bit quotient and a
  *              32-bit remainder.
  *
  ******************************************************************************/
@@ -125,9 +122,10 @@ AcpiUtShortDivide (
      * and is generated by the second divide.
      */
     ACPI_DIV_64_BY_32 (0, DividendOvl.Part.Hi, Divisor,
-                       Quotient.Part.Hi, Remainder32);
+        Quotient.Part.Hi, Remainder32);
+
     ACPI_DIV_64_BY_32 (Remainder32, DividendOvl.Part.Lo, Divisor,
-                       Quotient.Part.Lo, Remainder32);
+        Quotient.Part.Lo, Remainder32);
 
     /* Return only what was requested */
 
@@ -203,9 +201,10 @@ AcpiUtDivide (
          * and is generated by the second divide.
          */
         ACPI_DIV_64_BY_32 (0, Dividend.Part.Hi, Divisor.Part.Lo,
-                           Quotient.Part.Hi, Partial1);
+            Quotient.Part.Hi, Partial1);
+
         ACPI_DIV_64_BY_32 (Partial1, Dividend.Part.Lo, Divisor.Part.Lo,
-                           Quotient.Part.Lo, Remainder.Part.Lo);
+            Quotient.Part.Lo, Remainder.Part.Lo);
     }
 
     else
@@ -222,25 +221,24 @@ AcpiUtDivide (
 
         do
         {
-            ACPI_SHIFT_RIGHT_64 (NormalizedDivisor.Part.Hi,
-                                 NormalizedDivisor.Part.Lo);
-            ACPI_SHIFT_RIGHT_64 (NormalizedDividend.Part.Hi,
-                                 NormalizedDividend.Part.Lo);
+            ACPI_SHIFT_RIGHT_64 (
+                NormalizedDivisor.Part.Hi, NormalizedDivisor.Part.Lo);
+            ACPI_SHIFT_RIGHT_64 (
+                NormalizedDividend.Part.Hi, NormalizedDividend.Part.Lo);
 
         } while (NormalizedDivisor.Part.Hi != 0);
 
         /* Partial divide */
 
-        ACPI_DIV_64_BY_32 (NormalizedDividend.Part.Hi,
-                           NormalizedDividend.Part.Lo,
-                           NormalizedDivisor.Part.Lo,
-                           Quotient.Part.Lo, Partial1);
+        ACPI_DIV_64_BY_32 (
+            NormalizedDividend.Part.Hi, NormalizedDividend.Part.Lo,
+            NormalizedDivisor.Part.Lo, Quotient.Part.Lo, Partial1);
 
         /*
-         * The quotient is always 32 bits, and simply requires adjustment.
-         * The 64-bit remainder must be generated.
+         * The quotient is always 32 bits, and simply requires
+         * adjustment. The 64-bit remainder must be generated.
          */
-        Partial1      = Quotient.Part.Lo * Divisor.Part.Hi;
+        Partial1 = Quotient.Part.Lo * Divisor.Part.Hi;
         Partial2.Full = (UINT64) Quotient.Part.Lo * Divisor.Part.Lo;
         Partial3.Full = (UINT64) Partial2.Part.Hi + Partial1;
 
@@ -266,7 +264,7 @@ AcpiUtDivide (
                 }
             }
 
-            Remainder.Full    = Remainder.Full - Dividend.Full;
+            Remainder.Full = Remainder.Full - Dividend.Full;
             Remainder.Part.Hi = (UINT32) -((INT32) Remainder.Part.Hi);
             Remainder.Part.Lo = (UINT32) -((INT32) Remainder.Part.Lo);
 
@@ -375,5 +373,3 @@ AcpiUtDivide (
 }
 
 #endif
-
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utmisc.c b/usr/src/uts/intel/io/acpica/utilities/utmisc.c
index 062c768e72..ce8f25426d 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utmisc.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utmisc.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,1079 +41,161 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __UTMISC_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
 
 
 #define _COMPONENT          ACPI_UTILITIES
-        ACPI_MODULE_NAME    ("utmisc")
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtValidateException
- *
- * PARAMETERS:  Status       - The ACPI_STATUS code to be formatted
- *
- * RETURN:      A string containing the exception text. NULL if exception is
- *              not valid.
- *
- * DESCRIPTION: This function validates and translates an ACPI exception into
- *              an ASCII string.
- *
- ******************************************************************************/
-
-const char *
-AcpiUtValidateException (
-    ACPI_STATUS             Status)
-{
-    UINT32                  SubStatus;
-    const char              *Exception = NULL;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    /*
-     * Status is composed of two parts, a "type" and an actual code
-     */
-    SubStatus = (Status & ~AE_CODE_MASK);
-
-    switch (Status & AE_CODE_MASK)
-    {
-    case AE_CODE_ENVIRONMENTAL:
-
-        if (SubStatus <= AE_CODE_ENV_MAX)
-        {
-            Exception = AcpiGbl_ExceptionNames_Env [SubStatus];
-        }
-        break;
-
-    case AE_CODE_PROGRAMMER:
-
-        if (SubStatus <= AE_CODE_PGM_MAX)
-        {
-            Exception = AcpiGbl_ExceptionNames_Pgm [SubStatus];
-        }
-        break;
-
-    case AE_CODE_ACPI_TABLES:
-
-        if (SubStatus <= AE_CODE_TBL_MAX)
-        {
-            Exception = AcpiGbl_ExceptionNames_Tbl [SubStatus];
-        }
-        break;
-
-    case AE_CODE_AML:
-
-        if (SubStatus <= AE_CODE_AML_MAX)
-        {
-            Exception = AcpiGbl_ExceptionNames_Aml [SubStatus];
-        }
-        break;
-
-    case AE_CODE_CONTROL:
-
-        if (SubStatus <= AE_CODE_CTRL_MAX)
-        {
-            Exception = AcpiGbl_ExceptionNames_Ctrl [SubStatus];
-        }
-        break;
-
-    default:
-        break;
-    }
-
-    return (ACPI_CAST_PTR (const char, Exception));
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtIsPciRootBridge
- *
- * PARAMETERS:  Id              - The HID/CID in string format
- *
- * RETURN:      TRUE if the Id is a match for a PCI/PCI-Express Root Bridge
- *
- * DESCRIPTION: Determine if the input ID is a PCI Root Bridge ID.
- *
- ******************************************************************************/
-
-BOOLEAN
-AcpiUtIsPciRootBridge (
-    char                    *Id)
-{
-
-    /*
-     * Check if this is a PCI root bridge.
-     * ACPI 3.0+: check for a PCI Express root also.
-     */
-    if (!(ACPI_STRCMP (Id,
-            PCI_ROOT_HID_STRING)) ||
-
-        !(ACPI_STRCMP (Id,
-            PCI_EXPRESS_ROOT_HID_STRING)))
-    {
-        return (TRUE);
-    }
-
-    return (FALSE);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtIsAmlTable
- *
- * PARAMETERS:  Table               - An ACPI table
- *
- * RETURN:      TRUE if table contains executable AML; FALSE otherwise
- *
- * DESCRIPTION: Check ACPI Signature for a table that contains AML code.
- *              Currently, these are DSDT,SSDT,PSDT. All other table types are
- *              data tables that do not contain AML code.
- *
- ******************************************************************************/
-
-BOOLEAN
-AcpiUtIsAmlTable (
-    ACPI_TABLE_HEADER       *Table)
-{
-
-    /* These are the only tables that contain executable AML */
-
-    if (ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_DSDT) ||
-        ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_PSDT) ||
-        ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_SSDT))
-    {
-        return (TRUE);
-    }
-
-    return (FALSE);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtAllocateOwnerId
- *
- * PARAMETERS:  OwnerId         - Where the new owner ID is returned
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Allocate a table or method owner ID. The owner ID is used to
- *              track objects created by the table or method, to be deleted
- *              when the method exits or the table is unloaded.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiUtAllocateOwnerId (
-    ACPI_OWNER_ID           *OwnerId)
-{
-    UINT32                  i;
-    UINT32                  j;
-    UINT32                  k;
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_TRACE (UtAllocateOwnerId);
-
-
-    /* Guard against multiple allocations of ID to the same location */
-
-    if (*OwnerId)
-    {
-        ACPI_ERROR ((AE_INFO, "Owner ID [0x%2.2X] already exists", *OwnerId));
-        return_ACPI_STATUS (AE_ALREADY_EXISTS);
-    }
-
-    /* Mutex for the global ID mask */
-
-    Status = AcpiUtAcquireMutex (ACPI_MTX_CACHES);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /*
-     * Find a free owner ID, cycle through all possible IDs on repeated
-     * allocations. (ACPI_NUM_OWNERID_MASKS + 1) because first index may have
-     * to be scanned twice.
-     */
-    for (i = 0, j = AcpiGbl_LastOwnerIdIndex;
-         i < (ACPI_NUM_OWNERID_MASKS + 1);
-         i++, j++)
-    {
-        if (j >= ACPI_NUM_OWNERID_MASKS)
-        {
-            j = 0;  /* Wraparound to start of mask array */
-        }
-
-        for (k = AcpiGbl_NextOwnerIdOffset; k < 32; k++)
-        {
-            if (AcpiGbl_OwnerIdMask[j] == ACPI_UINT32_MAX)
-            {
-                /* There are no free IDs in this mask */
-
-                break;
-            }
-
-            if (!(AcpiGbl_OwnerIdMask[j] & (1 << k)))
-            {
-                /*
-                 * Found a free ID. The actual ID is the bit index plus one,
-                 * making zero an invalid Owner ID. Save this as the last ID
-                 * allocated and update the global ID mask.
-                 */
-                AcpiGbl_OwnerIdMask[j] |= (1 << k);
-
-                AcpiGbl_LastOwnerIdIndex = (UINT8) j;
-                AcpiGbl_NextOwnerIdOffset = (UINT8) (k + 1);
-
-                /*
-                 * Construct encoded ID from the index and bit position
-                 *
-                 * Note: Last [j].k (bit 255) is never used and is marked
-                 * permanently allocated (prevents +1 overflow)
-                 */
-                *OwnerId = (ACPI_OWNER_ID) ((k + 1) + ACPI_MUL_32 (j));
-
-                ACPI_DEBUG_PRINT ((ACPI_DB_VALUES,
-                    "Allocated OwnerId: %2.2X\n", (unsigned int) *OwnerId));
-                goto Exit;
-            }
-        }
-
-        AcpiGbl_NextOwnerIdOffset = 0;
-    }
-
-    /*
-     * All OwnerIds have been allocated. This typically should
-     * not happen since the IDs are reused after deallocation. The IDs are
-     * allocated upon table load (one per table) and method execution, and
-     * they are released when a table is unloaded or a method completes
-     * execution.
-     *
-     * If this error happens, there may be very deep nesting of invoked control
-     * methods, or there may be a bug where the IDs are not released.
-     */
-    Status = AE_OWNER_ID_LIMIT;
-    ACPI_ERROR ((AE_INFO,
-        "Could not allocate new OwnerId (255 max), AE_OWNER_ID_LIMIT"));
-
-Exit:
-    (void) AcpiUtReleaseMutex (ACPI_MTX_CACHES);
-    return_ACPI_STATUS (Status);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtReleaseOwnerId
- *
- * PARAMETERS:  OwnerIdPtr          - Pointer to a previously allocated OwnerID
- *
- * RETURN:      None. No error is returned because we are either exiting a
- *              control method or unloading a table. Either way, we would
- *              ignore any error anyway.
- *
- * DESCRIPTION: Release a table or method owner ID.  Valid IDs are 1 - 255
- *
- ******************************************************************************/
-
-void
-AcpiUtReleaseOwnerId (
-    ACPI_OWNER_ID           *OwnerIdPtr)
-{
-    ACPI_OWNER_ID           OwnerId = *OwnerIdPtr;
-    ACPI_STATUS             Status;
-    UINT32                  Index;
-    UINT32                  Bit;
-
-
-    ACPI_FUNCTION_TRACE_U32 (UtReleaseOwnerId, OwnerId);
-
-
-    /* Always clear the input OwnerId (zero is an invalid ID) */
-
-    *OwnerIdPtr = 0;
-
-    /* Zero is not a valid OwnerID */
-
-    if (OwnerId == 0)
-    {
-        ACPI_ERROR ((AE_INFO, "Invalid OwnerId: 0x%2.2X", OwnerId));
-        return_VOID;
-    }
-
-    /* Mutex for the global ID mask */
-
-    Status = AcpiUtAcquireMutex (ACPI_MTX_CACHES);
-    if (ACPI_FAILURE (Status))
-    {
-        return_VOID;
-    }
-
-    /* Normalize the ID to zero */
-
-    OwnerId--;
-
-    /* Decode ID to index/offset pair */
-
-    Index = ACPI_DIV_32 (OwnerId);
-    Bit = 1 << ACPI_MOD_32 (OwnerId);
-
-    /* Free the owner ID only if it is valid */
-
-    if (AcpiGbl_OwnerIdMask[Index] & Bit)
-    {
-        AcpiGbl_OwnerIdMask[Index] ^= Bit;
-    }
-    else
-    {
-        ACPI_ERROR ((AE_INFO,
-            "Release of non-allocated OwnerId: 0x%2.2X", OwnerId + 1));
-    }
-
-    (void) AcpiUtReleaseMutex (ACPI_MTX_CACHES);
-    return_VOID;
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtStrupr (strupr)
- *
- * PARAMETERS:  SrcString       - The source string to convert
- *
- * RETURN:      None
- *
- * DESCRIPTION: Convert string to uppercase
- *
- * NOTE: This is not a POSIX function, so it appears here, not in utclib.c
- *
- ******************************************************************************/
-
-void
-AcpiUtStrupr (
-    char                    *SrcString)
-{
-    char                    *String;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    if (!SrcString)
-    {
-        return;
-    }
-
-    /* Walk entire string, uppercasing the letters */
-
-    for (String = SrcString; *String; String++)
-    {
-        *String = (char) ACPI_TOUPPER (*String);
-    }
-
-    return;
-}
-
-
-#ifdef ACPI_ASL_COMPILER
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtStrlwr (strlwr)
- *
- * PARAMETERS:  SrcString       - The source string to convert
- *
- * RETURN:      None
- *
- * DESCRIPTION: Convert string to lowercase
- *
- * NOTE: This is not a POSIX function, so it appears here, not in utclib.c
- *
- ******************************************************************************/
-
-void
-AcpiUtStrlwr (
-    char                    *SrcString)
-{
-    char                    *String;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    if (!SrcString)
-    {
-        return;
-    }
-
-    /* Walk entire string, lowercasing the letters */
-
-    for (String = SrcString; *String; String++)
-    {
-        *String = (char) ACPI_TOLOWER (*String);
-    }
-
-    return;
-}
-
-
-/******************************************************************************
- *
- * FUNCTION:    AcpiUtStricmp
- *
- * PARAMETERS:  String1             - first string to compare
- *              String2             - second string to compare
- *
- * RETURN:      int that signifies string relationship. Zero means strings
- *              are equal.
- *
- * DESCRIPTION: Implementation of the non-ANSI stricmp function (compare
- *              strings with no case sensitivity)
- *
- ******************************************************************************/
-
-int
-AcpiUtStricmp (
-    char                    *String1,
-    char                    *String2)
-{
-    int                     c1;
-    int                     c2;
-
-
-    do
-    {
-        c1 = tolower ((int) *String1);
-        c2 = tolower ((int) *String2);
-
-        String1++;
-        String2++;
-    }
-    while ((c1 == c2) && (c1));
-
-    return (c1 - c2);
-}
-#endif
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtPrintString
- *
- * PARAMETERS:  String          - Null terminated ASCII string
- *              MaxLength       - Maximum output length
- *
- * RETURN:      None
- *
- * DESCRIPTION: Dump an ASCII string with support for ACPI-defined escape
- *              sequences.
- *
- ******************************************************************************/
-
-void
-AcpiUtPrintString (
-    char                    *String,
-    UINT8                   MaxLength)
-{
-    UINT32                  i;
-
-
-    if (!String)
-    {
-        AcpiOsPrintf ("<\"NULL STRING PTR\">");
-        return;
-    }
-
-    AcpiOsPrintf ("\"");
-    for (i = 0; String[i] && (i < MaxLength); i++)
-    {
-        /* Escape sequences */
-
-        switch (String[i])
-        {
-        case 0x07:
-            AcpiOsPrintf ("\\a");       /* BELL */
-            break;
-
-        case 0x08:
-            AcpiOsPrintf ("\\b");       /* BACKSPACE */
-            break;
-
-        case 0x0C:
-            AcpiOsPrintf ("\\f");       /* FORMFEED */
-            break;
-
-        case 0x0A:
-            AcpiOsPrintf ("\\n");       /* LINEFEED */
-            break;
-
-        case 0x0D:
-            AcpiOsPrintf ("\\r");       /* CARRIAGE RETURN*/
-            break;
-
-        case 0x09:
-            AcpiOsPrintf ("\\t");       /* HORIZONTAL TAB */
-            break;
-
-        case 0x0B:
-            AcpiOsPrintf ("\\v");       /* VERTICAL TAB */
-            break;
-
-        case '\'':                      /* Single Quote */
-        case '\"':                      /* Double Quote */
-        case '\\':                      /* Backslash */
-            AcpiOsPrintf ("\\%c", (int) String[i]);
-            break;
-
-        default:
-
-            /* Check for printable character or hex escape */
-
-            if (ACPI_IS_PRINT (String[i]))
-            {
-                /* This is a normal character */
-
-                AcpiOsPrintf ("%c", (int) String[i]);
-            }
-            else
-            {
-                /* All others will be Hex escapes */
-
-                AcpiOsPrintf ("\\x%2.2X", (INT32) String[i]);
-            }
-            break;
-        }
-    }
-    AcpiOsPrintf ("\"");
-
-    if (i == MaxLength && String[i])
-    {
-        AcpiOsPrintf ("...");
-    }
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtDwordByteSwap
- *
- * PARAMETERS:  Value           - Value to be converted
- *
- * RETURN:      UINT32 integer with bytes swapped
- *
- * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)
- *
- ******************************************************************************/
-
-UINT32
-AcpiUtDwordByteSwap (
-    UINT32                  Value)
-{
-    union
-    {
-        UINT32              Value;
-        UINT8               Bytes[4];
-    } Out;
-    union
-    {
-        UINT32              Value;
-        UINT8               Bytes[4];
-    } In;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    In.Value = Value;
-
-    Out.Bytes[0] = In.Bytes[3];
-    Out.Bytes[1] = In.Bytes[2];
-    Out.Bytes[2] = In.Bytes[1];
-    Out.Bytes[3] = In.Bytes[0];
-
-    return (Out.Value);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtSetIntegerWidth
- *
- * PARAMETERS:  Revision            From DSDT header
- *
- * RETURN:      None
- *
- * DESCRIPTION: Set the global integer bit width based upon the revision
- *              of the DSDT.  For Revision 1 and 0, Integers are 32 bits.
- *              For Revision 2 and above, Integers are 64 bits.  Yes, this
- *              makes a difference.
- *
- ******************************************************************************/
-
-void
-AcpiUtSetIntegerWidth (
-    UINT8                   Revision)
-{
-
-    if (Revision < 2)
-    {
-        /* 32-bit case */
-
-        AcpiGbl_IntegerBitWidth    = 32;
-        AcpiGbl_IntegerNybbleWidth = 8;
-        AcpiGbl_IntegerByteWidth   = 4;
-    }
-    else
-    {
-        /* 64-bit case (ACPI 2.0+) */
-
-        AcpiGbl_IntegerBitWidth    = 64;
-        AcpiGbl_IntegerNybbleWidth = 16;
-        AcpiGbl_IntegerByteWidth   = 8;
-    }
-}
-
-
-#ifdef ACPI_DEBUG_OUTPUT
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtDisplayInitPathname
- *
- * PARAMETERS:  Type                - Object type of the node
- *              ObjHandle           - Handle whose pathname will be displayed
- *              Path                - Additional path string to be appended.
- *                                      (NULL if no extra path)
- *
- * RETURN:      ACPI_STATUS
- *
- * DESCRIPTION: Display full pathname of an object, DEBUG ONLY
- *
- ******************************************************************************/
-
-void
-AcpiUtDisplayInitPathname (
-    UINT8                   Type,
-    ACPI_NAMESPACE_NODE     *ObjHandle,
-    char                    *Path)
-{
-    ACPI_STATUS             Status;
-    ACPI_BUFFER             Buffer;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    /* Only print the path if the appropriate debug level is enabled */
-
-    if (!(AcpiDbgLevel & ACPI_LV_INIT_NAMES))
-    {
-        return;
-    }
-
-    /* Get the full pathname to the node */
-
-    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
-    Status = AcpiNsHandleToPathname (ObjHandle, &Buffer);
-    if (ACPI_FAILURE (Status))
-    {
-        return;
-    }
-
-    /* Print what we're doing */
-
-    switch (Type)
-    {
-    case ACPI_TYPE_METHOD:
-        AcpiOsPrintf ("Executing    ");
-        break;
-
-    default:
-        AcpiOsPrintf ("Initializing ");
-        break;
-    }
-
-    /* Print the object type and pathname */
-
-    AcpiOsPrintf ("%-12s  %s",
-        AcpiUtGetTypeName (Type), (char *) Buffer.Pointer);
-
-    /* Extra path is used to append names like _STA, _INI, etc. */
-
-    if (Path)
-    {
-        AcpiOsPrintf (".%s", Path);
-    }
-    AcpiOsPrintf ("\n");
-
-    ACPI_FREE (Buffer.Pointer);
-}
-#endif
+        ACPI_MODULE_NAME    ("utmisc")
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtValidAcpiChar
- *
- * PARAMETERS:  Char            - The character to be examined
- *              Position        - Byte position (0-3)
+ * FUNCTION:    AcpiUtIsPciRootBridge
  *
- * RETURN:      TRUE if the character is valid, FALSE otherwise
+ * PARAMETERS:  Id              - The HID/CID in string format
  *
- * DESCRIPTION: Check for a valid ACPI character. Must be one of:
- *              1) Upper case alpha
- *              2) numeric
- *              3) underscore
+ * RETURN:      TRUE if the Id is a match for a PCI/PCI-Express Root Bridge
  *
- *              We allow a '!' as the last character because of the ASF! table
+ * DESCRIPTION: Determine if the input ID is a PCI Root Bridge ID.
  *
  ******************************************************************************/
 
 BOOLEAN
-AcpiUtValidAcpiChar (
-    char                    Character,
-    UINT32                  Position)
+AcpiUtIsPciRootBridge (
+    char                    *Id)
 {
 
-    if (!((Character >= 'A' && Character <= 'Z') ||
-          (Character >= '0' && Character <= '9') ||
-          (Character == '_')))
-    {
-        /* Allow a '!' in the last position */
-
-        if (Character == '!' && Position == 3)
-        {
-            return (TRUE);
-        }
+    /*
+     * Check if this is a PCI root bridge.
+     * ACPI 3.0+: check for a PCI Express root also.
+     */
+    if (!(strcmp (Id,
+        PCI_ROOT_HID_STRING)) ||
 
-        return (FALSE);
+        !(strcmp (Id,
+        PCI_EXPRESS_ROOT_HID_STRING)))
+    {
+        return (TRUE);
     }
 
-    return (TRUE);
+    return (FALSE);
 }
 
 
+#if (defined ACPI_ASL_COMPILER || defined ACPI_EXEC_APP || defined ACPI_NAMES_APP)
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtValidAcpiName
+ * FUNCTION:    AcpiUtIsAmlTable
  *
- * PARAMETERS:  Name            - The name to be examined
+ * PARAMETERS:  Table               - An ACPI table
  *
- * RETURN:      TRUE if the name is valid, FALSE otherwise
+ * RETURN:      TRUE if table contains executable AML; FALSE otherwise
  *
- * DESCRIPTION: Check for a valid ACPI name.  Each character must be one of:
- *              1) Upper case alpha
- *              2) numeric
- *              3) underscore
+ * DESCRIPTION: Check ACPI Signature for a table that contains AML code.
+ *              Currently, these are DSDT,SSDT,PSDT. All other table types are
+ *              data tables that do not contain AML code.
  *
  ******************************************************************************/
 
 BOOLEAN
-AcpiUtValidAcpiName (
-    UINT32                  Name)
+AcpiUtIsAmlTable (
+    ACPI_TABLE_HEADER       *Table)
 {
-    UINT32                  i;
-
-
-    ACPI_FUNCTION_ENTRY ();
 
+    /* These are the only tables that contain executable AML */
 
-    for (i = 0; i < ACPI_NAME_SIZE; i++)
+    if (ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_DSDT) ||
+        ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_PSDT) ||
+        ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_SSDT) ||
+        ACPI_COMPARE_NAME (Table->Signature, ACPI_SIG_OSDT))
     {
-        if (!AcpiUtValidAcpiChar ((ACPI_CAST_PTR (char, &Name))[i], i))
-        {
-            return (FALSE);
-        }
+        return (TRUE);
     }
 
-    return (TRUE);
+    return (FALSE);
 }
+#endif
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtRepairName
- *
- * PARAMETERS:  Name            - The ACPI name to be repaired
- *
- * RETURN:      Repaired version of the name
+ * FUNCTION:    AcpiUtDwordByteSwap
  *
- * DESCRIPTION: Repair an ACPI name: Change invalid characters to '*' and
- *              return the new name. NOTE: the Name parameter must reside in
- *              read/write memory, cannot be a const.
+ * PARAMETERS:  Value           - Value to be converted
  *
- * An ACPI Name must consist of valid ACPI characters. We will repair the name
- * if necessary because we don't want to abort because of this, but we want
- * all namespace names to be printable. A warning message is appropriate.
+ * RETURN:      UINT32 integer with bytes swapped
  *
- * This issue came up because there are in fact machines that exhibit
- * this problem, and we want to be able to enable ACPI support for them,
- * even though there are a few bad names.
+ * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)
  *
  ******************************************************************************/
 
-void
-AcpiUtRepairName (
-    char                    *Name)
+UINT32
+AcpiUtDwordByteSwap (
+    UINT32                  Value)
 {
-    UINT32                  i;
-    BOOLEAN                 FoundBadChar = FALSE;
-
-
-    ACPI_FUNCTION_NAME (UtRepairName);
+    union
+    {
+        UINT32              Value;
+        UINT8               Bytes[4];
+    } Out;
+    union
+    {
+        UINT32              Value;
+        UINT8               Bytes[4];
+    } In;
 
 
-    /* Check each character in the name */
+    ACPI_FUNCTION_ENTRY ();
 
-    for (i = 0; i < ACPI_NAME_SIZE; i++)
-    {
-        if (AcpiUtValidAcpiChar (Name[i], i))
-        {
-            continue;
-        }
 
-        /*
-         * Replace a bad character with something printable, yet technically
-         * still invalid. This prevents any collisions with existing "good"
-         * names in the namespace.
-         */
-        Name[i] = '*';
-        FoundBadChar = TRUE;
-    }
+    In.Value = Value;
 
-    if (FoundBadChar)
-    {
-        /* Report warning only if in strict mode or debug mode */
+    Out.Bytes[0] = In.Bytes[3];
+    Out.Bytes[1] = In.Bytes[2];
+    Out.Bytes[2] = In.Bytes[1];
+    Out.Bytes[3] = In.Bytes[0];
 
-        if (!AcpiGbl_EnableInterpreterSlack)
-        {
-            ACPI_WARNING ((AE_INFO,
-                "Found bad character(s) in name, repaired: [%4.4s]\n", Name));
-        }
-        else
-        {
-            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
-                "Found bad character(s) in name, repaired: [%4.4s]\n", Name));
-        }
-    }
+    return (Out.Value);
 }
 
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtStrtoul64
+ * FUNCTION:    AcpiUtSetIntegerWidth
  *
- * PARAMETERS:  String          - Null terminated string
- *              Base            - Radix of the string: 16 or ACPI_ANY_BASE;
- *                                ACPI_ANY_BASE means 'in behalf of ToInteger'
- *              RetInteger      - Where the converted integer is returned
+ * PARAMETERS:  Revision            From DSDT header
  *
- * RETURN:      Status and Converted value
+ * RETURN:      None
  *
- * DESCRIPTION: Convert a string into an unsigned value. Performs either a
- *              32-bit or 64-bit conversion, depending on the current mode
- *              of the interpreter.
- *              NOTE: Does not support Octal strings, not needed.
+ * DESCRIPTION: Set the global integer bit width based upon the revision
+ *              of the DSDT. For Revision 1 and 0, Integers are 32 bits.
+ *              For Revision 2 and above, Integers are 64 bits. Yes, this
+ *              makes a difference.
  *
  ******************************************************************************/
 
-ACPI_STATUS
-AcpiUtStrtoul64 (
-    char                    *String,
-    UINT32                  Base,
-    UINT64                  *RetInteger)
+void
+AcpiUtSetIntegerWidth (
+    UINT8                   Revision)
 {
-    UINT32                  ThisDigit = 0;
-    UINT64                  ReturnValue = 0;
-    UINT64                  Quotient;
-    UINT64                  Dividend;
-    UINT32                  ToIntegerOp = (Base == ACPI_ANY_BASE);
-    UINT32                  Mode32 = (AcpiGbl_IntegerByteWidth == 4);
-    UINT8                   ValidDigits = 0;
-    UINT8                   SignOf0x = 0;
-    UINT8                   Term = 0;
-
-
-    ACPI_FUNCTION_TRACE_STR (UtStroul64, String);
-
-
-    switch (Base)
-    {
-    case ACPI_ANY_BASE:
-    case 16:
-        break;
-
-    default:
-        /* Invalid Base */
-        return_ACPI_STATUS (AE_BAD_PARAMETER);
-    }
-
-    if (!String)
-    {
-        goto ErrorExit;
-    }
-
-    /* Skip over any white space in the buffer */
-
-    while ((*String) && (ACPI_IS_SPACE (*String) || *String == '\t'))
-    {
-        String++;
-    }
-
-    if (ToIntegerOp)
-    {
-        /*
-         * Base equal to ACPI_ANY_BASE means 'ToInteger operation case'.
-         * We need to determine if it is decimal or hexadecimal.
-         */
-        if ((*String == '0') && (ACPI_TOLOWER (*(String + 1)) == 'x'))
-        {
-            SignOf0x = 1;
-            Base = 16;
-
-            /* Skip over the leading '0x' */
-            String += 2;
-        }
-        else
-        {
-            Base = 10;
-        }
-    }
-
-    /* Any string left? Check that '0x' is not followed by white space. */
-
-    if (!(*String) || ACPI_IS_SPACE (*String) || *String == '\t')
-    {
-        if (ToIntegerOp)
-        {
-            goto ErrorExit;
-        }
-        else
-        {
-            goto AllDone;
-        }
-    }
-
-    /*
-     * Perform a 32-bit or 64-bit conversion, depending upon the current
-     * execution mode of the interpreter
-     */
-    Dividend = (Mode32) ? ACPI_UINT32_MAX : ACPI_UINT64_MAX;
 
-    /* Main loop: convert the string to a 32- or 64-bit integer */
-
-    while (*String)
+    if (Revision < 2)
     {
-        if (ACPI_IS_DIGIT (*String))
-        {
-            /* Convert ASCII 0-9 to Decimal value */
-
-            ThisDigit = ((UINT8) *String) - '0';
-        }
-        else if (Base == 10)
-        {
-            /* Digit is out of range; possible in ToInteger case only */
-
-            Term = 1;
-        }
-        else
-        {
-            ThisDigit = (UINT8) ACPI_TOUPPER (*String);
-            if (ACPI_IS_XDIGIT ((char) ThisDigit))
-            {
-                /* Convert ASCII Hex char to value */
-
-                ThisDigit = ThisDigit - 'A' + 10;
-            }
-            else
-            {
-                Term = 1;
-            }
-        }
-
-        if (Term)
-        {
-            if (ToIntegerOp)
-            {
-                goto ErrorExit;
-            }
-            else
-            {
-                break;
-            }
-        }
-        else if ((ValidDigits == 0) && (ThisDigit == 0) && !SignOf0x)
-        {
-            /* Skip zeros */
-            String++;
-            continue;
-        }
-
-        ValidDigits++;
-
-        if (SignOf0x && ((ValidDigits > 16) || ((ValidDigits > 8) && Mode32)))
-        {
-            /*
-             * This is ToInteger operation case.
-             * No any restrictions for string-to-integer conversion,
-             * see ACPI spec.
-             */
-            goto ErrorExit;
-        }
-
-        /* Divide the digit into the correct position */
-
-        (void) AcpiUtShortDivide ((Dividend - (UINT64) ThisDigit),
-                    Base, &Quotient, NULL);
-
-        if (ReturnValue > Quotient)
-        {
-            if (ToIntegerOp)
-            {
-                goto ErrorExit;
-            }
-            else
-            {
-                break;
-            }
-        }
-
-        ReturnValue *= Base;
-        ReturnValue += ThisDigit;
-        String++;
-    }
-
-    /* All done, normal exit */
-
-AllDone:
-
-    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Converted value: %8.8X%8.8X\n",
-        ACPI_FORMAT_UINT64 (ReturnValue)));
-
-    *RetInteger = ReturnValue;
-    return_ACPI_STATUS (AE_OK);
-
-
-ErrorExit:
-    /* Base was set/validated above */
+        /* 32-bit case */
 
-    if (Base == 10)
-    {
-        return_ACPI_STATUS (AE_BAD_DECIMAL_CONSTANT);
+        AcpiGbl_IntegerBitWidth = 32;
+        AcpiGbl_IntegerNybbleWidth = 8;
+        AcpiGbl_IntegerByteWidth = 4;
     }
     else
     {
-        return_ACPI_STATUS (AE_BAD_HEX_CONSTANT);
+        /* 64-bit case (ACPI 2.0+) */
+
+        AcpiGbl_IntegerBitWidth = 64;
+        AcpiGbl_IntegerNybbleWidth = 16;
+        AcpiGbl_IntegerByteWidth = 8;
     }
 }
 
@@ -1204,20 +286,21 @@ AcpiUtWalkPackageTree (
     {
         /* Get one element of the package */
 
-        ThisIndex     = State->Pkg.Index;
+        ThisIndex = State->Pkg.Index;
         ThisSourceObj = (ACPI_OPERAND_OBJECT *)
-                        State->Pkg.SourceObject->Package.Elements[ThisIndex];
+            State->Pkg.SourceObject->Package.Elements[ThisIndex];
 
         /*
          * Check for:
-         * 1) An uninitialized package element.  It is completely
+         * 1) An uninitialized package element. It is completely
          *    legal to declare a package and leave it uninitialized
          * 2) Not an internal object - can be a namespace node instead
-         * 3) Any type other than a package.  Packages are handled in else
+         * 3) Any type other than a package. Packages are handled in else
          *    case below.
          */
         if ((!ThisSourceObj) ||
-            (ACPI_GET_DESCRIPTOR_TYPE (ThisSourceObj) != ACPI_DESC_TYPE_OPERAND) ||
+            (ACPI_GET_DESCRIPTOR_TYPE (ThisSourceObj) !=
+                ACPI_DESC_TYPE_OPERAND) ||
             (ThisSourceObj->Common.Type != ACPI_TYPE_PACKAGE))
         {
             Status = WalkCallback (ACPI_COPY_TYPE_SIMPLE, ThisSourceObj,
@@ -1228,11 +311,12 @@ AcpiUtWalkPackageTree (
             }
 
             State->Pkg.Index++;
-            while (State->Pkg.Index >= State->Pkg.SourceObject->Package.Count)
+            while (State->Pkg.Index >=
+                State->Pkg.SourceObject->Package.Count)
             {
                 /*
                  * We've handled all of the objects at this level,  This means
-                 * that we have just completed a package.  That package may
+                 * that we have just completed a package. That package may
                  * have contained one or more packages itself.
                  *
                  * Delete this state and pop the previous state (package).
@@ -1263,8 +347,8 @@ AcpiUtWalkPackageTree (
         {
             /* This is a subobject of type package */
 
-            Status = WalkCallback (ACPI_COPY_TYPE_PACKAGE, ThisSourceObj,
-                                        State, Context);
+            Status = WalkCallback (
+                ACPI_COPY_TYPE_PACKAGE, ThisSourceObj, State, Context);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -1275,8 +359,8 @@ AcpiUtWalkPackageTree (
              * The callback above returned a new target package object.
              */
             AcpiUtPushGenericState (&StateList, State);
-            State = AcpiUtCreatePkgState (ThisSourceObj,
-                                            State->Pkg.ThisTargetObj, 0);
+            State = AcpiUtCreatePkgState (
+                ThisSourceObj, State->Pkg.ThisTargetObj, 0);
             if (!State)
             {
                 /* Free any stacked Update State objects */
@@ -1297,3 +381,79 @@ AcpiUtWalkPackageTree (
 }
 
 
+#ifdef ACPI_DEBUG_OUTPUT
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtDisplayInitPathname
+ *
+ * PARAMETERS:  Type                - Object type of the node
+ *              ObjHandle           - Handle whose pathname will be displayed
+ *              Path                - Additional path string to be appended.
+ *                                      (NULL if no extra path)
+ *
+ * RETURN:      ACPI_STATUS
+ *
+ * DESCRIPTION: Display full pathname of an object, DEBUG ONLY
+ *
+ ******************************************************************************/
+
+void
+AcpiUtDisplayInitPathname (
+    UINT8                   Type,
+    ACPI_NAMESPACE_NODE     *ObjHandle,
+    const char              *Path)
+{
+    ACPI_STATUS             Status;
+    ACPI_BUFFER             Buffer;
+
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    /* Only print the path if the appropriate debug level is enabled */
+
+    if (!(AcpiDbgLevel & ACPI_LV_INIT_NAMES))
+    {
+        return;
+    }
+
+    /* Get the full pathname to the node */
+
+    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
+    Status = AcpiNsHandleToPathname (ObjHandle, &Buffer, TRUE);
+    if (ACPI_FAILURE (Status))
+    {
+        return;
+    }
+
+    /* Print what we're doing */
+
+    switch (Type)
+    {
+    case ACPI_TYPE_METHOD:
+
+        AcpiOsPrintf ("Executing    ");
+        break;
+
+    default:
+
+        AcpiOsPrintf ("Initializing ");
+        break;
+    }
+
+    /* Print the object type and pathname */
+
+    AcpiOsPrintf ("%-12s  %s",
+        AcpiUtGetTypeName (Type), (char *) Buffer.Pointer);
+
+    /* Extra path is used to append names like _STA, _INI, etc. */
+
+    if (Path)
+    {
+        AcpiOsPrintf (".%s", Path);
+    }
+    AcpiOsPrintf ("\n");
+
+    ACPI_FREE (Buffer.Pointer);
+}
+#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utmutex.c b/usr/src/uts/intel/io/acpica/utilities/utmutex.c
index f1cdb01804..83b1cee0d7 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utmutex.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utmutex.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __UTMUTEX_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -96,7 +93,7 @@ AcpiUtMutexInitialize (
         }
     }
 
-    /* Create the spinlocks for use at interrupt level */
+    /* Create the spinlocks for use at interrupt level or for speed */
 
     Status = AcpiOsCreateLock (&AcpiGbl_GpeLock);
     if (ACPI_FAILURE (Status))
@@ -110,7 +107,14 @@ AcpiUtMutexInitialize (
         return_ACPI_STATUS (Status);
     }
 
+    Status = AcpiOsCreateLock (&AcpiGbl_ReferenceCountLock);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
     /* Mutex for _OSI support */
+
     Status = AcpiOsCreateMutex (&AcpiGbl_OsiMutex);
     if (ACPI_FAILURE (Status))
     {
@@ -120,6 +124,24 @@ AcpiUtMutexInitialize (
     /* Create the reader/writer lock for namespace access */
 
     Status = AcpiUtCreateRwLock (&AcpiGbl_NamespaceRwLock);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+#ifdef ACPI_DEBUGGER
+
+    /* Debugger Support */
+
+    Status = AcpiOsCreateMutex (&AcpiGbl_DbCommandReady);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    Status = AcpiOsCreateMutex (&AcpiGbl_DbCommandComplete);
+#endif
+
     return_ACPI_STATUS (Status);
 }
 
@@ -160,10 +182,17 @@ AcpiUtMutexTerminate (
 
     AcpiOsDeleteLock (AcpiGbl_GpeLock);
     AcpiOsDeleteLock (AcpiGbl_HardwareLock);
+    AcpiOsDeleteLock (AcpiGbl_ReferenceCountLock);
 
     /* Delete the reader/writer lock */
 
     AcpiUtDeleteRwLock (&AcpiGbl_NamespaceRwLock);
+
+#ifdef ACPI_DEBUGGER
+    AcpiOsDeleteMutex (AcpiGbl_DbCommandReady);
+    AcpiOsDeleteMutex (AcpiGbl_DbCommandComplete);
+#endif
+
     return_VOID;
 }
 
@@ -225,6 +254,8 @@ AcpiUtDeleteMutex (
 
     AcpiGbl_MutexInfo[MutexId].Mutex = NULL;
     AcpiGbl_MutexInfo[MutexId].ThreadId = ACPI_MUTEX_NOT_ACQUIRED;
+
+    return_VOID;
 }
 
 
@@ -264,9 +295,9 @@ AcpiUtAcquireMutex (
         /*
          * Mutex debug code, for internal debugging only.
          *
-         * Deadlock prevention.  Check if this thread owns any mutexes of value
-         * greater than or equal to this one.  If so, the thread has violated
-         * the mutex ordering rule.  This indicates a coding error somewhere in
+         * Deadlock prevention. Check if this thread owns any mutexes of value
+         * greater than or equal to this one. If so, the thread has violated
+         * the mutex ordering rule. This indicates a coding error somewhere in
          * the ACPI subsystem code.
          */
         for (i = MutexId; i < ACPI_NUM_MUTEX; i++)
@@ -298,11 +329,12 @@ AcpiUtAcquireMutex (
         "Thread %u attempting to acquire Mutex [%s]\n",
         (UINT32) ThisThreadId, AcpiUtGetMutexName (MutexId)));
 
-    Status = AcpiOsAcquireMutex (AcpiGbl_MutexInfo[MutexId].Mutex,
-                ACPI_WAIT_FOREVER);
+    Status = AcpiOsAcquireMutex (
+        AcpiGbl_MutexInfo[MutexId].Mutex, ACPI_WAIT_FOREVER);
     if (ACPI_SUCCESS (Status))
     {
-        ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Thread %u acquired Mutex [%s]\n",
+        ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX,
+            "Thread %u acquired Mutex [%s]\n",
             (UINT32) ThisThreadId, AcpiUtGetMutexName (MutexId)));
 
         AcpiGbl_MutexInfo[MutexId].UseCount++;
@@ -337,6 +369,7 @@ AcpiUtReleaseMutex (
 {
     ACPI_FUNCTION_NAME (UtReleaseMutex);
 
+
     ACPI_DEBUG_PRINT ((ACPI_DB_MUTEX, "Thread %u releasing Mutex [%s]\n",
         (UINT32) AcpiOsGetThreadId (), AcpiUtGetMutexName (MutexId)));
 
@@ -362,9 +395,9 @@ AcpiUtReleaseMutex (
         /*
          * Mutex debug code, for internal debugging only.
          *
-         * Deadlock prevention.  Check if this thread owns any mutexes of value
-         * greater than this one.  If so, the thread has violated the mutex
-         * ordering rule.  This indicates a coding error somewhere in
+         * Deadlock prevention. Check if this thread owns any mutexes of value
+         * greater than this one. If so, the thread has violated the mutex
+         * ordering rule. This indicates a coding error somewhere in
          * the ACPI subsystem code.
          */
         for (i = MutexId; i < ACPI_NUM_MUTEX; i++)
@@ -393,5 +426,3 @@ AcpiUtReleaseMutex (
     AcpiOsReleaseMutex (AcpiGbl_MutexInfo[MutexId].Mutex);
     return (AE_OK);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utnonansi.c b/usr/src/uts/intel/io/acpica/utilities/utnonansi.c
new file mode 100644
index 0000000000..70fb33e64c
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utnonansi.c
@@ -0,0 +1,667 @@
+/*******************************************************************************
+ *
+ * Module Name: utnonansi - Non-ansi C library functions
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("utnonansi")
+
+
+/*
+ * Non-ANSI C library functions - strlwr, strupr, stricmp, and a 64-bit
+ * version of strtoul.
+ */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtStrlwr (strlwr)
+ *
+ * PARAMETERS:  SrcString       - The source string to convert
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert a string to lowercase
+ *
+ ******************************************************************************/
+
+void
+AcpiUtStrlwr (
+    char                    *SrcString)
+{
+    char                    *String;
+
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    if (!SrcString)
+    {
+        return;
+    }
+
+    /* Walk entire string, lowercasing the letters */
+
+    for (String = SrcString; *String; String++)
+    {
+        *String = (char) tolower ((int) *String);
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtStrupr (strupr)
+ *
+ * PARAMETERS:  SrcString       - The source string to convert
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Convert a string to uppercase
+ *
+ ******************************************************************************/
+
+void
+AcpiUtStrupr (
+    char                    *SrcString)
+{
+    char                    *String;
+
+
+    ACPI_FUNCTION_ENTRY ();
+
+
+    if (!SrcString)
+    {
+        return;
+    }
+
+    /* Walk entire string, uppercasing the letters */
+
+    for (String = SrcString; *String; String++)
+    {
+        *String = (char) toupper ((int) *String);
+    }
+}
+
+
+/******************************************************************************
+ *
+ * FUNCTION:    AcpiUtStricmp (stricmp)
+ *
+ * PARAMETERS:  String1             - first string to compare
+ *              String2             - second string to compare
+ *
+ * RETURN:      int that signifies string relationship. Zero means strings
+ *              are equal.
+ *
+ * DESCRIPTION: Case-insensitive string compare. Implementation of the
+ *              non-ANSI stricmp function.
+ *
+ ******************************************************************************/
+
+int
+AcpiUtStricmp (
+    char                    *String1,
+    char                    *String2)
+{
+    int                     c1;
+    int                     c2;
+
+
+    do
+    {
+        c1 = tolower ((int) *String1);
+        c2 = tolower ((int) *String2);
+
+        String1++;
+        String2++;
+    }
+    while ((c1 == c2) && (c1));
+
+    return (c1 - c2);
+}
+
+
+#if defined (ACPI_DEBUGGER) || defined (ACPI_APPLICATION)
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtSafeStrcpy, AcpiUtSafeStrcat, AcpiUtSafeStrncat
+ *
+ * PARAMETERS:  Adds a "DestSize" parameter to each of the standard string
+ *              functions. This is the size of the Destination buffer.
+ *
+ * RETURN:      TRUE if the operation would overflow the destination buffer.
+ *
+ * DESCRIPTION: Safe versions of standard Clib string functions. Ensure that
+ *              the result of the operation will not overflow the output string
+ *              buffer.
+ *
+ * NOTE:        These functions are typically only helpful for processing
+ *              user input and command lines. For most ACPICA code, the
+ *              required buffer length is precisely calculated before buffer
+ *              allocation, so the use of these functions is unnecessary.
+ *
+ ******************************************************************************/
+
+BOOLEAN
+AcpiUtSafeStrcpy (
+    char                    *Dest,
+    ACPI_SIZE               DestSize,
+    char                    *Source)
+{
+
+    if (strlen (Source) >= DestSize)
+    {
+        return (TRUE);
+    }
+
+    strcpy (Dest, Source);
+    return (FALSE);
+}
+
+BOOLEAN
+AcpiUtSafeStrcat (
+    char                    *Dest,
+    ACPI_SIZE               DestSize,
+    char                    *Source)
+{
+
+    if ((strlen (Dest) + strlen (Source)) >= DestSize)
+    {
+        return (TRUE);
+    }
+
+    strcat (Dest, Source);
+    return (FALSE);
+}
+
+BOOLEAN
+AcpiUtSafeStrncat (
+    char                    *Dest,
+    ACPI_SIZE               DestSize,
+    char                    *Source,
+    ACPI_SIZE               MaxTransferLength)
+{
+    ACPI_SIZE               ActualTransferLength;
+
+
+    ActualTransferLength = ACPI_MIN (MaxTransferLength, strlen (Source));
+
+    if ((strlen (Dest) + ActualTransferLength) >= DestSize)
+    {
+        return (TRUE);
+    }
+
+    strncat (Dest, Source, MaxTransferLength);
+    return (FALSE);
+}
+#endif
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtStrtoul64
+ *
+ * PARAMETERS:  String                  - Null terminated string
+ *              Base                    - Radix of the string: 16 or 10 or
+ *                                        ACPI_ANY_BASE
+ *              MaxIntegerByteWidth     - Maximum allowable integer,in bytes:
+ *                                        4 or 8 (32 or 64 bits)
+ *              RetInteger              - Where the converted integer is
+ *                                        returned
+ *
+ * RETURN:      Status and Converted value
+ *
+ * DESCRIPTION: Convert a string into an unsigned value. Performs either a
+ *              32-bit or 64-bit conversion, depending on the input integer
+ *              size (often the current mode of the interpreter).
+ *
+ * NOTES:       Negative numbers are not supported, as they are not supported
+ *              by ACPI.
+ *
+ *              AcpiGbl_IntegerByteWidth should be set to the proper width.
+ *              For the core ACPICA code, this width depends on the DSDT
+ *              version. For iASL, the default byte width is always 8 for the
+ *              parser, but error checking is performed later to flag cases
+ *              where a 64-bit constant is defined in a 32-bit DSDT/SSDT.
+ *
+ *              Does not support Octal strings, not needed at this time.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiUtStrtoul64 (
+    char                    *String,
+    UINT32                  Base,
+    UINT32                  MaxIntegerByteWidth,
+    UINT64                  *RetInteger)
+{
+    UINT32                  ThisDigit = 0;
+    UINT64                  ReturnValue = 0;
+    UINT64                  Quotient;
+    UINT64                  Dividend;
+    UINT8                   ValidDigits = 0;
+    UINT8                   SignOf0x = 0;
+    UINT8                   Term = 0;
+
+
+    ACPI_FUNCTION_TRACE_STR (UtStrtoul64, String);
+
+
+    switch (Base)
+    {
+    case ACPI_ANY_BASE:
+    case 10:
+    case 16:
+
+        break;
+
+    default:
+
+        /* Invalid Base */
+
+        return_ACPI_STATUS (AE_BAD_PARAMETER);
+    }
+
+    if (!String)
+    {
+        goto ErrorExit;
+    }
+
+    /* Skip over any white space in the buffer */
+
+    while ((*String) && (isspace ((int) *String) || *String == '\t'))
+    {
+        String++;
+    }
+
+    if (Base == ACPI_ANY_BASE)
+    {
+        /*
+         * Base equal to ACPI_ANY_BASE means 'Either decimal or hex'.
+         * We need to determine if it is decimal or hexadecimal.
+         */
+        if ((*String == '0') && (tolower ((int) *(String + 1)) == 'x'))
+        {
+            SignOf0x = 1;
+            Base = 16;
+
+            /* Skip over the leading '0x' */
+            String += 2;
+        }
+        else
+        {
+            Base = 10;
+        }
+    }
+
+    /* Any string left? Check that '0x' is not followed by white space. */
+
+    if (!(*String) || isspace ((int) *String) || *String == '\t')
+    {
+        if (Base == ACPI_ANY_BASE)
+        {
+            goto ErrorExit;
+        }
+        else
+        {
+            goto AllDone;
+        }
+    }
+
+    /*
+     * Perform a 32-bit or 64-bit conversion, depending upon the input
+     * byte width
+     */
+    Dividend = (MaxIntegerByteWidth <= ACPI_MAX32_BYTE_WIDTH) ?
+        ACPI_UINT32_MAX : ACPI_UINT64_MAX;
+
+    /* Main loop: convert the string to a 32- or 64-bit integer */
+
+    while (*String)
+    {
+        if (isdigit ((int) *String))
+        {
+            /* Convert ASCII 0-9 to Decimal value */
+
+            ThisDigit = ((UINT8) *String) - '0';
+        }
+        else if (Base == 10)
+        {
+            /* Digit is out of range; possible in ToInteger case only */
+
+            Term = 1;
+        }
+        else
+        {
+            ThisDigit = (UINT8) toupper ((int) *String);
+            if (isxdigit ((int) ThisDigit))
+            {
+                /* Convert ASCII Hex char to value */
+
+                ThisDigit = ThisDigit - 'A' + 10;
+            }
+            else
+            {
+                Term = 1;
+            }
+        }
+
+        if (Term)
+        {
+            if (Base == ACPI_ANY_BASE)
+            {
+                goto ErrorExit;
+            }
+            else
+            {
+                break;
+            }
+        }
+        else if ((ValidDigits == 0) && (ThisDigit == 0) && !SignOf0x)
+        {
+            /* Skip zeros */
+            String++;
+            continue;
+        }
+
+        ValidDigits++;
+
+        if (SignOf0x && ((ValidDigits > 16) ||
+            ((ValidDigits > 8) && (MaxIntegerByteWidth <= ACPI_MAX32_BYTE_WIDTH))))
+        {
+            /*
+             * This is ToInteger operation case.
+             * No restrictions for string-to-integer conversion,
+             * see ACPI spec.
+             */
+            goto ErrorExit;
+        }
+
+        /* Divide the digit into the correct position */
+
+        (void) AcpiUtShortDivide (
+            (Dividend - (UINT64) ThisDigit), Base, &Quotient, NULL);
+
+        if (ReturnValue > Quotient)
+        {
+            if (Base == ACPI_ANY_BASE)
+            {
+                goto ErrorExit;
+            }
+            else
+            {
+                break;
+            }
+        }
+
+        ReturnValue *= Base;
+        ReturnValue += ThisDigit;
+        String++;
+    }
+
+    /* All done, normal exit */
+
+AllDone:
+
+    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "Converted value: %8.8X%8.8X\n",
+        ACPI_FORMAT_UINT64 (ReturnValue)));
+
+    *RetInteger = ReturnValue;
+    return_ACPI_STATUS (AE_OK);
+
+
+ErrorExit:
+
+    /* Base was set/validated above (10 or 16) */
+
+    if (Base == 10)
+    {
+        return_ACPI_STATUS (AE_BAD_DECIMAL_CONSTANT);
+    }
+    else
+    {
+        return_ACPI_STATUS (AE_BAD_HEX_CONSTANT);
+    }
+}
+
+
+#ifdef _OBSOLETE_FUNCTIONS
+/* Removed: 01/2016 */
+
+/*******************************************************************************
+ *
+ * FUNCTION:    strtoul64
+ *
+ * PARAMETERS:  String              - Null terminated string
+ *              Terminater          - Where a pointer to the terminating byte
+ *                                    is returned
+ *              Base                - Radix of the string
+ *
+ * RETURN:      Converted value
+ *
+ * DESCRIPTION: Convert a string into an unsigned value.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+strtoul64 (
+    char                    *String,
+    UINT32                  Base,
+    UINT64                  *RetInteger)
+{
+    UINT32                  Index;
+    UINT32                  Sign;
+    UINT64                  ReturnValue = 0;
+    ACPI_STATUS             Status = AE_OK;
+
+
+    *RetInteger = 0;
+
+    switch (Base)
+    {
+    case 0:
+    case 8:
+    case 10:
+    case 16:
+
+        break;
+
+    default:
+        /*
+         * The specified Base parameter is not in the domain of
+         * this function:
+         */
+        return (AE_BAD_PARAMETER);
+    }
+
+    /* Skip over any white space in the buffer: */
+
+    while (isspace ((int) *String) || *String == '\t')
+    {
+        ++String;
+    }
+
+    /*
+     * The buffer may contain an optional plus or minus sign.
+     * If it does, then skip over it but remember what is was:
+     */
+    if (*String == '-')
+    {
+        Sign = ACPI_SIGN_NEGATIVE;
+        ++String;
+    }
+    else if (*String == '+')
+    {
+        ++String;
+        Sign = ACPI_SIGN_POSITIVE;
+    }
+    else
+    {
+        Sign = ACPI_SIGN_POSITIVE;
+    }
+
+    /*
+     * If the input parameter Base is zero, then we need to
+     * determine if it is octal, decimal, or hexadecimal:
+     */
+    if (Base == 0)
+    {
+        if (*String == '0')
+        {
+            if (tolower ((int) *(++String)) == 'x')
+            {
+                Base = 16;
+                ++String;
+            }
+            else
+            {
+                Base = 8;
+            }
+        }
+        else
+        {
+            Base = 10;
+        }
+    }
+
+    /*
+     * For octal and hexadecimal bases, skip over the leading
+     * 0 or 0x, if they are present.
+     */
+    if (Base == 8 && *String == '0')
+    {
+        String++;
+    }
+
+    if (Base == 16 &&
+        *String == '0' &&
+        tolower ((int) *(++String)) == 'x')
+    {
+        String++;
+    }
+
+    /* Main loop: convert the string to an unsigned long */
+
+    while (*String)
+    {
+        if (isdigit ((int) *String))
+        {
+            Index = ((UINT8) *String) - '0';
+        }
+        else
+        {
+            Index = (UINT8) toupper ((int) *String);
+            if (isupper ((int) Index))
+            {
+                Index = Index - 'A' + 10;
+            }
+            else
+            {
+                goto ErrorExit;
+            }
+        }
+
+        if (Index >= Base)
+        {
+            goto ErrorExit;
+        }
+
+        /* Check to see if value is out of range: */
+
+        if (ReturnValue > ((ACPI_UINT64_MAX - (UINT64) Index) /
+            (UINT64) Base))
+        {
+            goto ErrorExit;
+        }
+        else
+        {
+            ReturnValue *= Base;
+            ReturnValue += Index;
+        }
+
+        ++String;
+    }
+
+
+    /* If a minus sign was present, then "the conversion is negated": */
+
+    if (Sign == ACPI_SIGN_NEGATIVE)
+    {
+        ReturnValue = (ACPI_UINT32_MAX - ReturnValue) + 1;
+    }
+
+    *RetInteger = ReturnValue;
+    return (Status);
+
+
+ErrorExit:
+    switch (Base)
+    {
+    case 8:
+
+        Status = AE_BAD_OCTAL_CONSTANT;
+        break;
+
+    case 10:
+
+        Status = AE_BAD_DECIMAL_CONSTANT;
+        break;
+
+    case 16:
+
+        Status = AE_BAD_HEX_CONSTANT;
+        break;
+
+    default:
+
+        /* Base validated above */
+
+        break;
+    }
+
+    return (Status);
+}
+#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utobject.c b/usr/src/uts/intel/io/acpica/utilities/utobject.c
index fea140946c..ed3b85f1d7 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utobject.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utobject.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTOBJECT_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -86,7 +84,7 @@ AcpiUtGetElementLength (
  *
  * NOTE:        We always allocate the worst-case object descriptor because
  *              these objects are cached, and we want them to be
- *              one-size-satisifies-any-request.  This in itself may not be
+ *              one-size-satisifies-any-request. This in itself may not be
  *              the most memory efficient, but the efficiency of the object
  *              cache should more than make up for this!
  *
@@ -109,7 +107,8 @@ AcpiUtCreateInternalObjectDbg (
 
     /* Allocate the raw object descriptor */
 
-    Object = AcpiUtAllocateObjectDescDbg (ModuleName, LineNumber, ComponentId);
+    Object = AcpiUtAllocateObjectDescDbg (
+        ModuleName, LineNumber, ComponentId);
     if (!Object)
     {
         return_PTR (NULL);
@@ -123,8 +122,8 @@ AcpiUtCreateInternalObjectDbg (
 
         /* These types require a secondary object */
 
-        SecondObject = AcpiUtAllocateObjectDescDbg (ModuleName,
-                            LineNumber, ComponentId);
+        SecondObject = AcpiUtAllocateObjectDescDbg (
+            ModuleName, LineNumber, ComponentId);
         if (!SecondObject)
         {
             AcpiUtDeleteObjectDesc (Object);
@@ -140,6 +139,7 @@ AcpiUtCreateInternalObjectDbg (
         break;
 
     default:
+
         /* All others have no secondary object */
         break;
     }
@@ -194,7 +194,7 @@ AcpiUtCreatePackageObject (
      * terminated.
      */
     PackageElements = ACPI_ALLOCATE_ZEROED (
-                        ((ACPI_SIZE) Count + 1) * sizeof (void *));
+        ((ACPI_SIZE) Count + 1) * sizeof (void *));
     if (!PackageElements)
     {
         ACPI_FREE (PackageDesc);
@@ -284,6 +284,7 @@ AcpiUtCreateBufferObject (
         {
             ACPI_ERROR ((AE_INFO, "Could not allocate size %u",
                 (UINT32) BufferSize));
+
             AcpiUtRemoveReference (BufferDesc);
             return_PTR (NULL);
         }
@@ -343,6 +344,7 @@ AcpiUtCreateStringObject (
     {
         ACPI_ERROR ((AE_INFO, "Could not allocate size %u",
             (UINT32) StringSize));
+
         AcpiUtRemoveReference (StringDesc);
         return_PTR (NULL);
     }
@@ -366,7 +368,7 @@ AcpiUtCreateStringObject (
  *
  * RETURN:      TRUE if object is valid, FALSE otherwise
  *
- * DESCRIPTION: Validate a pointer to be an ACPI_OPERAND_OBJECT
+ * DESCRIPTION: Validate a pointer to be of type ACPI_OPERAND_OBJECT
  *
  ******************************************************************************/
 
@@ -392,14 +394,15 @@ AcpiUtValidInternalObject (
     {
     case ACPI_DESC_TYPE_OPERAND:
 
-        /* The object appears to be a valid ACPI_OPERAND_OBJECT  */
+        /* The object appears to be a valid ACPI_OPERAND_OBJECT */
 
         return (TRUE);
 
     default:
+
         ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-                "%p is not not an ACPI operand obj [%s]\n",
-                Object, AcpiUtGetDescriptorName (Object)));
+            "%p is not an ACPI operand obj [%s]\n",
+            Object, AcpiUtGetDescriptorName (Object)));
         break;
     }
 
@@ -415,9 +418,9 @@ AcpiUtValidInternalObject (
  *              LineNumber          - Caller's line number (for error output)
  *              ComponentId         - Caller's component ID (for error output)
  *
- * RETURN:      Pointer to newly allocated object descriptor.  Null on error
+ * RETURN:      Pointer to newly allocated object descriptor. Null on error
  *
- * DESCRIPTION: Allocate a new object descriptor.  Gracefully handle
+ * DESCRIPTION: Allocate a new object descriptor. Gracefully handle
  *              error conditions.
  *
  ******************************************************************************/
@@ -448,7 +451,7 @@ AcpiUtAllocateObjectDescDbg (
     ACPI_SET_DESCRIPTOR_TYPE (Object, ACPI_DESC_TYPE_OPERAND);
 
     ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p Size %X\n",
-            Object, (UINT32) sizeof (ACPI_OPERAND_OBJECT)));
+        Object, (UINT32) sizeof (ACPI_OPERAND_OBJECT)));
 
     return_PTR (Object);
 }
@@ -473,7 +476,7 @@ AcpiUtDeleteObjectDesc (
     ACPI_FUNCTION_TRACE_PTR (UtDeleteObjectDesc, Object);
 
 
-    /* Object must be an ACPI_OPERAND_OBJECT  */
+    /* Object must be of type ACPI_OPERAND_OBJECT */
 
     if (ACPI_GET_DESCRIPTOR_TYPE (Object) != ACPI_DESC_TYPE_OPERAND)
     {
@@ -556,13 +559,11 @@ AcpiUtGetSimpleObjectSize (
         Length += (ACPI_SIZE) InternalObject->String.Length + 1;
         break;
 
-
     case ACPI_TYPE_BUFFER:
 
         Length += (ACPI_SIZE) InternalObject->Buffer.Length;
         break;
 
-
     case ACPI_TYPE_INTEGER:
     case ACPI_TYPE_PROCESSOR:
     case ACPI_TYPE_POWER:
@@ -571,13 +572,11 @@ AcpiUtGetSimpleObjectSize (
 
         break;
 
-
     case ACPI_TYPE_LOCAL_REFERENCE:
 
         switch (InternalObject->Reference.Class)
         {
         case ACPI_REFCLASS_NAME:
-
             /*
              * Get the actual length of the full pathname to this object.
              * The reference will be converted to the pathname to the object
@@ -592,7 +591,6 @@ AcpiUtGetSimpleObjectSize (
             break;
 
         default:
-
             /*
              * No other reference opcodes are supported.
              * Notably, Locals and Args are not supported, but this may be
@@ -607,7 +605,6 @@ AcpiUtGetSimpleObjectSize (
         }
         break;
 
-
     default:
 
         ACPI_ERROR ((AE_INFO, "Cannot convert to external object - "
@@ -620,7 +617,7 @@ AcpiUtGetSimpleObjectSize (
 
     /*
      * Account for the space required by the object rounded up to the next
-     * multiple of the machine word size.  This keeps each object aligned
+     * multiple of the machine word size. This keeps each object aligned
      * on a machine word boundary. (preventing alignment faults on some
      * machines.)
      */
@@ -656,7 +653,6 @@ AcpiUtGetElementLength (
     switch (ObjectType)
     {
     case ACPI_COPY_TYPE_SIMPLE:
-
         /*
          * Simple object - just get the size (Null object/entry is handled
          * here also) and sum it into the running package length
@@ -670,7 +666,6 @@ AcpiUtGetElementLength (
         Info->Length += ObjectSpace;
         break;
 
-
     case ACPI_COPY_TYPE_PACKAGE:
 
         /* Package object - nothing much to do here, let the walk handle it */
@@ -679,7 +674,6 @@ AcpiUtGetElementLength (
         State->Pkg.ThisTargetObj = NULL;
         break;
 
-
     default:
 
         /* No other types allowed */
@@ -720,12 +714,12 @@ AcpiUtGetPackageObjectSize (
     ACPI_FUNCTION_TRACE_PTR (UtGetPackageObjectSize, InternalObject);
 
 
-    Info.Length      = 0;
+    Info.Length = 0;
     Info.ObjectSpace = 0;
     Info.NumPackages = 1;
 
-    Status = AcpiUtWalkPackageTree (InternalObject, NULL,
-                            AcpiUtGetElementLength, &Info);
+    Status = AcpiUtWalkPackageTree (
+        InternalObject, NULL, AcpiUtGetElementLength, &Info);
     if (ACPI_FAILURE (Status))
     {
         return_ACPI_STATUS (Status);
@@ -736,8 +730,8 @@ AcpiUtGetPackageObjectSize (
      * just add the length of the package objects themselves.
      * Round up to the next machine word.
      */
-    Info.Length += ACPI_ROUND_UP_TO_NATIVE_WORD (sizeof (ACPI_OBJECT)) *
-                    (ACPI_SIZE) Info.NumPackages;
+    Info.Length += ACPI_ROUND_UP_TO_NATIVE_WORD (
+        sizeof (ACPI_OBJECT)) * (ACPI_SIZE) Info.NumPackages;
 
     /* Return the total package length */
 
@@ -771,7 +765,8 @@ AcpiUtGetObjectSize (
     ACPI_FUNCTION_ENTRY ();
 
 
-    if ((ACPI_GET_DESCRIPTOR_TYPE (InternalObject) == ACPI_DESC_TYPE_OPERAND) &&
+    if ((ACPI_GET_DESCRIPTOR_TYPE (InternalObject) ==
+            ACPI_DESC_TYPE_OPERAND) &&
         (InternalObject->Common.Type == ACPI_TYPE_PACKAGE))
     {
         Status = AcpiUtGetPackageObjectSize (InternalObject, ObjLength);
@@ -783,5 +778,3 @@ AcpiUtGetObjectSize (
 
     return (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utosi.c b/usr/src/uts/intel/io/acpica/utilities/utosi.c
index dcce8a99e1..674fe364d3 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utosi.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utosi.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTOSI_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -50,6 +48,34 @@
 #define _COMPONENT          ACPI_UTILITIES
         ACPI_MODULE_NAME    ("utosi")
 
+
+/******************************************************************************
+ *
+ * ACPICA policy for new _OSI strings:
+ *
+ * It is the stated policy of ACPICA that new _OSI strings will be integrated
+ * into this module as soon as possible after they are defined. It is strongly
+ * recommended that all ACPICA hosts mirror this policy and integrate any
+ * changes to this module as soon as possible. There are several historical
+ * reasons behind this policy:
+ *
+ * 1) New BIOSs tend to test only the case where the host responds TRUE to
+ *    the latest version of Windows, which would respond to the latest/newest
+ *    _OSI string. Not responding TRUE to the latest version of Windows will
+ *    risk executing untested code paths throughout the DSDT and SSDTs.
+ *
+ * 2) If a new _OSI string is recognized only after a significant delay, this
+ *    has the potential to cause problems on existing working machines because
+ *    of the possibility that a new and different path through the ASL code
+ *    will be executed.
+ *
+ * 3) New _OSI strings are tending to come out about once per year. A delay
+ *    in recognizing a new string for a significant amount of time risks the
+ *    release of another string which only compounds the initial problem.
+ *
+ *****************************************************************************/
+
+
 /*
  * Strings supported by the _OSI predefined control method (which is
  * implemented internally within this module.)
@@ -77,24 +103,26 @@ static ACPI_INTERFACE_INFO    AcpiDefaultSupportedInterfaces[] =
     {"Windows 2006 SP1",    NULL, 0, ACPI_OSI_WIN_VISTA_SP1},    /* Windows Vista SP1 - Added 09/2009 */
     {"Windows 2006 SP2",    NULL, 0, ACPI_OSI_WIN_VISTA_SP2},    /* Windows Vista SP2 - Added 09/2010 */
     {"Windows 2009",        NULL, 0, ACPI_OSI_WIN_7},            /* Windows 7 and Server 2008 R2 - Added 09/2009 */
+    {"Windows 2012",        NULL, 0, ACPI_OSI_WIN_8},            /* Windows 8 and Server 2012 - Added 08/2012 */
+    {"Windows 2013",        NULL, 0, ACPI_OSI_WIN_8},            /* Windows 8.1 and Server 2012 R2 - Added 01/2014 */
+    {"Windows 2015",        NULL, 0, ACPI_OSI_WIN_10},           /* Windows 10 - Added 03/2015 */
 
     /* Feature Group Strings */
 
-    {"Extended Address Space Descriptor", NULL, 0, 0}
+    {"Extended Address Space Descriptor", NULL, ACPI_OSI_FEATURE, 0},
 
     /*
      * All "optional" feature group strings (features that are implemented
-     * by the host) should be dynamically added by the host via
-     * AcpiInstallInterface and should not be manually added here.
-     *
-     * Examples of optional feature group strings:
-     *
-     * "Module Device"
-     * "Processor Device"
-     * "3.0 Thermal Model"
-     * "3.0 _SCP Extensions"
-     * "Processor Aggregator Device"
+     * by the host) should be dynamically modified to VALID by the host via
+     * AcpiInstallInterface or AcpiUpdateInterfaces. Such optional feature
+     * group strings are set as INVALID by default here.
      */
+
+    {"Module Device",               NULL, ACPI_OSI_OPTIONAL_FEATURE, 0},
+    {"Processor Device",            NULL, ACPI_OSI_OPTIONAL_FEATURE, 0},
+    {"3.0 Thermal Model",           NULL, ACPI_OSI_OPTIONAL_FEATURE, 0},
+    {"3.0 _SCP Extensions",         NULL, ACPI_OSI_OPTIONAL_FEATURE, 0},
+    {"Processor Aggregator Device", NULL, ACPI_OSI_OPTIONAL_FEATURE, 0}
 };
 
 
@@ -114,15 +142,23 @@ ACPI_STATUS
 AcpiUtInitializeInterfaces (
     void)
 {
+    ACPI_STATUS             Status;
     UINT32                  i;
 
 
-    (void) AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    Status = AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
     AcpiGbl_SupportedInterfaces = AcpiDefaultSupportedInterfaces;
 
     /* Link the static list of supported interfaces */
 
-    for (i = 0; i < (ACPI_ARRAY_LENGTH (AcpiDefaultSupportedInterfaces) - 1); i++)
+    for (i = 0;
+        i < (ACPI_ARRAY_LENGTH (AcpiDefaultSupportedInterfaces) - 1);
+        i++)
     {
         AcpiDefaultSupportedInterfaces[i].Next =
             &AcpiDefaultSupportedInterfaces[(ACPI_SIZE) i + 1];
@@ -139,39 +175,58 @@ AcpiUtInitializeInterfaces (
  *
  * PARAMETERS:  None
  *
- * RETURN:      None
+ * RETURN:      Status
  *
  * DESCRIPTION: Delete all interfaces in the global list. Sets
  *              AcpiGbl_SupportedInterfaces to NULL.
  *
  ******************************************************************************/
 
-void
+ACPI_STATUS
 AcpiUtInterfaceTerminate (
     void)
 {
+    ACPI_STATUS             Status;
     ACPI_INTERFACE_INFO     *NextInterface;
 
 
-    (void) AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
-    NextInterface = AcpiGbl_SupportedInterfaces;
+    Status = AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
 
+    NextInterface = AcpiGbl_SupportedInterfaces;
     while (NextInterface)
     {
         AcpiGbl_SupportedInterfaces = NextInterface->Next;
 
-        /* Only interfaces added at runtime can be freed */
-
         if (NextInterface->Flags & ACPI_OSI_DYNAMIC)
         {
+            /* Only interfaces added at runtime can be freed */
+
             ACPI_FREE (NextInterface->Name);
             ACPI_FREE (NextInterface);
         }
+        else
+        {
+            /* Interface is in static list. Reset it to invalid or valid. */
+
+            if (NextInterface->Flags & ACPI_OSI_DEFAULT_INVALID)
+            {
+                NextInterface->Flags |= ACPI_OSI_INVALID;
+            }
+            else
+            {
+                NextInterface->Flags &= ~ACPI_OSI_INVALID;
+            }
+        }
 
         NextInterface = AcpiGbl_SupportedInterfaces;
     }
 
     AcpiOsReleaseMutex (AcpiGbl_OsiMutex);
+    return (AE_OK);
 }
 
 
@@ -203,7 +258,7 @@ AcpiUtInstallInterface (
         return (AE_NO_MEMORY);
     }
 
-    InterfaceInfo->Name = ACPI_ALLOCATE_ZEROED (ACPI_STRLEN (InterfaceName) + 1);
+    InterfaceInfo->Name = ACPI_ALLOCATE_ZEROED (strlen (InterfaceName) + 1);
     if (!InterfaceInfo->Name)
     {
         ACPI_FREE (InterfaceInfo);
@@ -212,7 +267,7 @@ AcpiUtInstallInterface (
 
     /* Initialize new info and insert at the head of the global list */
 
-    ACPI_STRCPY (InterfaceInfo->Name, InterfaceName);
+    strcpy (InterfaceInfo->Name, InterfaceName);
     InterfaceInfo->Flags = ACPI_OSI_DYNAMIC;
     InterfaceInfo->Next = AcpiGbl_SupportedInterfaces;
 
@@ -245,10 +300,12 @@ AcpiUtRemoveInterface (
     PreviousInterface = NextInterface = AcpiGbl_SupportedInterfaces;
     while (NextInterface)
     {
-        if (!ACPI_STRCMP (InterfaceName, NextInterface->Name))
+        if (!strcmp (InterfaceName, NextInterface->Name))
         {
-            /* Found: name is in either the static list or was added at runtime */
-
+            /*
+             * Found: name is in either the static list
+             * or was added at runtime
+             */
             if (NextInterface->Flags & ACPI_OSI_DYNAMIC)
             {
                 /* Interface was added dynamically, remove and free it */
@@ -268,8 +325,8 @@ AcpiUtRemoveInterface (
             else
             {
                 /*
-                 * Interface is in static list. If marked invalid, then it
-                 * does not actually exist. Else, mark it invalid.
+                 * Interface is in static list. If marked invalid, then
+                 * it does not actually exist. Else, mark it invalid.
                  */
                 if (NextInterface->Flags & ACPI_OSI_INVALID)
                 {
@@ -292,6 +349,57 @@ AcpiUtRemoveInterface (
 }
 
 
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtUpdateInterfaces
+ *
+ * PARAMETERS:  Action              - Actions to be performed during the
+ *                                    update
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Update _OSI interface strings, disabling or enabling OS vendor
+ *              strings or/and feature group strings.
+ *              Caller MUST hold AcpiGbl_OsiMutex
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiUtUpdateInterfaces (
+    UINT8                   Action)
+{
+    ACPI_INTERFACE_INFO     *NextInterface;
+
+
+    NextInterface = AcpiGbl_SupportedInterfaces;
+    while (NextInterface)
+    {
+        if (((NextInterface->Flags & ACPI_OSI_FEATURE) &&
+             (Action & ACPI_FEATURE_STRINGS)) ||
+            (!(NextInterface->Flags & ACPI_OSI_FEATURE) &&
+             (Action & ACPI_VENDOR_STRINGS)))
+        {
+            if (Action & ACPI_DISABLE_INTERFACES)
+            {
+                /* Mark the interfaces as invalid */
+
+                NextInterface->Flags |= ACPI_OSI_INVALID;
+            }
+            else
+            {
+                /* Mark the interfaces as valid */
+
+                NextInterface->Flags &= ~ACPI_OSI_INVALID;
+            }
+        }
+
+        NextInterface = NextInterface->Next;
+    }
+
+    return (AE_OK);
+}
+
+
 /*******************************************************************************
  *
  * FUNCTION:    AcpiUtGetInterface
@@ -315,7 +423,7 @@ AcpiUtGetInterface (
     NextInterface = AcpiGbl_SupportedInterfaces;
     while (NextInterface)
     {
-        if (!ACPI_STRCMP (InterfaceName, NextInterface->Name))
+        if (!strcmp (InterfaceName, NextInterface->Name))
         {
             return (NextInterface);
         }
@@ -349,6 +457,7 @@ AcpiUtOsiImplementation (
     ACPI_OPERAND_OBJECT     *ReturnDesc;
     ACPI_INTERFACE_INFO     *InterfaceInfo;
     ACPI_INTERFACE_HANDLER  InterfaceHandler;
+    ACPI_STATUS             Status;
     UINT32                  ReturnValue;
 
 
@@ -375,7 +484,12 @@ AcpiUtOsiImplementation (
     /* Default return value is 0, NOT SUPPORTED */
 
     ReturnValue = 0;
-    (void) AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    Status = AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    if (ACPI_FAILURE (Status))
+    {
+        AcpiUtRemoveReference (ReturnDesc);
+        return_ACPI_STATUS (Status);
+    }
 
     /* Lookup the interface in the global _OSI list */
 
diff --git a/usr/src/uts/intel/io/acpica/utilities/utownerid.c b/usr/src/uts/intel/io/acpica/utilities/utownerid.c
new file mode 100644
index 0000000000..8fe67bc332
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utownerid.c
@@ -0,0 +1,239 @@
+/*******************************************************************************
+ *
+ * Module Name: utownerid - Support for Table/Method Owner IDs
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acnamesp.h"
+
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("utownerid")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtAllocateOwnerId
+ *
+ * PARAMETERS:  OwnerId         - Where the new owner ID is returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Allocate a table or method owner ID. The owner ID is used to
+ *              track objects created by the table or method, to be deleted
+ *              when the method exits or the table is unloaded.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiUtAllocateOwnerId (
+    ACPI_OWNER_ID           *OwnerId)
+{
+    UINT32                  i;
+    UINT32                  j;
+    UINT32                  k;
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (UtAllocateOwnerId);
+
+
+    /* Guard against multiple allocations of ID to the same location */
+
+    if (*OwnerId)
+    {
+        ACPI_ERROR ((AE_INFO,
+            "Owner ID [0x%2.2X] already exists", *OwnerId));
+        return_ACPI_STATUS (AE_ALREADY_EXISTS);
+    }
+
+    /* Mutex for the global ID mask */
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_CACHES);
+    if (ACPI_FAILURE (Status))
+    {
+        return_ACPI_STATUS (Status);
+    }
+
+    /*
+     * Find a free owner ID, cycle through all possible IDs on repeated
+     * allocations. (ACPI_NUM_OWNERID_MASKS + 1) because first index
+     * may have to be scanned twice.
+     */
+    for (i = 0, j = AcpiGbl_LastOwnerIdIndex;
+         i < (ACPI_NUM_OWNERID_MASKS + 1);
+         i++, j++)
+    {
+        if (j >= ACPI_NUM_OWNERID_MASKS)
+        {
+            j = 0;  /* Wraparound to start of mask array */
+        }
+
+        for (k = AcpiGbl_NextOwnerIdOffset; k < 32; k++)
+        {
+            if (AcpiGbl_OwnerIdMask[j] == ACPI_UINT32_MAX)
+            {
+                /* There are no free IDs in this mask */
+
+                break;
+            }
+
+            if (!(AcpiGbl_OwnerIdMask[j] & (1 << k)))
+            {
+                /*
+                 * Found a free ID. The actual ID is the bit index plus one,
+                 * making zero an invalid Owner ID. Save this as the last ID
+                 * allocated and update the global ID mask.
+                 */
+                AcpiGbl_OwnerIdMask[j] |= (1 << k);
+
+                AcpiGbl_LastOwnerIdIndex = (UINT8) j;
+                AcpiGbl_NextOwnerIdOffset = (UINT8) (k + 1);
+
+                /*
+                 * Construct encoded ID from the index and bit position
+                 *
+                 * Note: Last [j].k (bit 255) is never used and is marked
+                 * permanently allocated (prevents +1 overflow)
+                 */
+                *OwnerId = (ACPI_OWNER_ID) ((k + 1) + ACPI_MUL_32 (j));
+
+                ACPI_DEBUG_PRINT ((ACPI_DB_VALUES,
+                    "Allocated OwnerId: %2.2X\n", (unsigned int) *OwnerId));
+                goto Exit;
+            }
+        }
+
+        AcpiGbl_NextOwnerIdOffset = 0;
+    }
+
+    /*
+     * All OwnerIds have been allocated. This typically should
+     * not happen since the IDs are reused after deallocation. The IDs are
+     * allocated upon table load (one per table) and method execution, and
+     * they are released when a table is unloaded or a method completes
+     * execution.
+     *
+     * If this error happens, there may be very deep nesting of invoked
+     * control methods, or there may be a bug where the IDs are not released.
+     */
+    Status = AE_OWNER_ID_LIMIT;
+    ACPI_ERROR ((AE_INFO,
+        "Could not allocate new OwnerId (255 max), AE_OWNER_ID_LIMIT"));
+
+Exit:
+    (void) AcpiUtReleaseMutex (ACPI_MTX_CACHES);
+    return_ACPI_STATUS (Status);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtReleaseOwnerId
+ *
+ * PARAMETERS:  OwnerIdPtr          - Pointer to a previously allocated OwnerID
+ *
+ * RETURN:      None. No error is returned because we are either exiting a
+ *              control method or unloading a table. Either way, we would
+ *              ignore any error anyway.
+ *
+ * DESCRIPTION: Release a table or method owner ID. Valid IDs are 1 - 255
+ *
+ ******************************************************************************/
+
+void
+AcpiUtReleaseOwnerId (
+    ACPI_OWNER_ID           *OwnerIdPtr)
+{
+    ACPI_OWNER_ID           OwnerId = *OwnerIdPtr;
+    ACPI_STATUS             Status;
+    UINT32                  Index;
+    UINT32                  Bit;
+
+
+    ACPI_FUNCTION_TRACE_U32 (UtReleaseOwnerId, OwnerId);
+
+
+    /* Always clear the input OwnerId (zero is an invalid ID) */
+
+    *OwnerIdPtr = 0;
+
+    /* Zero is not a valid OwnerID */
+
+    if (OwnerId == 0)
+    {
+        ACPI_ERROR ((AE_INFO, "Invalid OwnerId: 0x%2.2X", OwnerId));
+        return_VOID;
+    }
+
+    /* Mutex for the global ID mask */
+
+    Status = AcpiUtAcquireMutex (ACPI_MTX_CACHES);
+    if (ACPI_FAILURE (Status))
+    {
+        return_VOID;
+    }
+
+    /* Normalize the ID to zero */
+
+    OwnerId--;
+
+    /* Decode ID to index/offset pair */
+
+    Index = ACPI_DIV_32 (OwnerId);
+    Bit = 1 << ACPI_MOD_32 (OwnerId);
+
+    /* Free the owner ID only if it is valid */
+
+    if (AcpiGbl_OwnerIdMask[Index] & Bit)
+    {
+        AcpiGbl_OwnerIdMask[Index] ^= Bit;
+    }
+    else
+    {
+        ACPI_ERROR ((AE_INFO,
+            "Release of non-allocated OwnerId: 0x%2.2X", OwnerId + 1));
+    }
+
+    (void) AcpiUtReleaseMutex (ACPI_MTX_CACHES);
+    return_VOID;
+}
diff --git a/usr/src/uts/intel/io/acpica/utilities/utpredef.c b/usr/src/uts/intel/io/acpica/utilities/utpredef.c
new file mode 100644
index 0000000000..0f6658ecf7
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utpredef.c
@@ -0,0 +1,452 @@
+/******************************************************************************
+ *
+ * Module Name: utpredef - support functions for predefined names
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acpredef.h"
+
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("utpredef")
+
+
+/*
+ * Names for the types that can be returned by the predefined objects.
+ * Used for warning messages. Must be in the same order as the ACPI_RTYPEs
+ */
+static const char   *UtRtypeNames[] =
+{
+    "/Integer",
+    "/String",
+    "/Buffer",
+    "/Package",
+    "/Reference",
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtGetNextPredefinedMethod
+ *
+ * PARAMETERS:  ThisName            - Entry in the predefined method/name table
+ *
+ * RETURN:      Pointer to next entry in predefined table.
+ *
+ * DESCRIPTION: Get the next entry in the predefine method table. Handles the
+ *              cases where a package info entry follows a method name that
+ *              returns a package.
+ *
+ ******************************************************************************/
+
+const ACPI_PREDEFINED_INFO *
+AcpiUtGetNextPredefinedMethod (
+    const ACPI_PREDEFINED_INFO  *ThisName)
+{
+
+    /*
+     * Skip next entry in the table if this name returns a Package
+     * (next entry contains the package info)
+     */
+    if ((ThisName->Info.ExpectedBtypes & ACPI_RTYPE_PACKAGE) &&
+        (ThisName->Info.ExpectedBtypes != ACPI_RTYPE_ALL))
+    {
+        ThisName++;
+    }
+
+    ThisName++;
+    return (ThisName);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtMatchPredefinedMethod
+ *
+ * PARAMETERS:  Name                - Name to find
+ *
+ * RETURN:      Pointer to entry in predefined table. NULL indicates not found.
+ *
+ * DESCRIPTION: Check an object name against the predefined object list.
+ *
+ ******************************************************************************/
+
+const ACPI_PREDEFINED_INFO *
+AcpiUtMatchPredefinedMethod (
+    char                        *Name)
+{
+    const ACPI_PREDEFINED_INFO  *ThisName;
+
+
+    /* Quick check for a predefined name, first character must be underscore */
+
+    if (Name[0] != '_')
+    {
+        return (NULL);
+    }
+
+    /* Search info table for a predefined method/object name */
+
+    ThisName = AcpiGbl_PredefinedMethods;
+    while (ThisName->Info.Name[0])
+    {
+        if (ACPI_COMPARE_NAME (Name, ThisName->Info.Name))
+        {
+            return (ThisName);
+        }
+
+        ThisName = AcpiUtGetNextPredefinedMethod (ThisName);
+    }
+
+    return (NULL); /* Not found */
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtGetExpectedReturnTypes
+ *
+ * PARAMETERS:  Buffer              - Where the formatted string is returned
+ *              ExpectedBTypes      - Bitfield of expected data types
+ *
+ * RETURN:      Formatted string in Buffer.
+ *
+ * DESCRIPTION: Format the expected object types into a printable string.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtGetExpectedReturnTypes (
+    char                    *Buffer,
+    UINT32                  ExpectedBtypes)
+{
+    UINT32                  ThisRtype;
+    UINT32                  i;
+    UINT32                  j;
+
+
+    if (!ExpectedBtypes)
+    {
+        strcpy (Buffer, "NONE");
+        return;
+    }
+
+    j = 1;
+    Buffer[0] = 0;
+    ThisRtype = ACPI_RTYPE_INTEGER;
+
+    for (i = 0; i < ACPI_NUM_RTYPES; i++)
+    {
+        /* If one of the expected types, concatenate the name of this type */
+
+        if (ExpectedBtypes & ThisRtype)
+        {
+            strcat (Buffer, &UtRtypeNames[i][j]);
+            j = 0;              /* Use name separator from now on */
+        }
+
+        ThisRtype <<= 1;    /* Next Rtype */
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * The remaining functions are used by iASL and AcpiHelp only
+ *
+ ******************************************************************************/
+
+#if (defined ACPI_ASL_COMPILER || defined ACPI_HELP_APP)
+#include <stdio.h>
+#include <string.h>
+
+/* Local prototypes */
+
+static UINT32
+AcpiUtGetArgumentTypes (
+    char                    *Buffer,
+    UINT16                  ArgumentTypes);
+
+
+/* Types that can be returned externally by a predefined name */
+
+static const char   *UtExternalTypeNames[] = /* Indexed by ACPI_TYPE_* */
+{
+    ", UNSUPPORTED-TYPE",
+    ", Integer",
+    ", String",
+    ", Buffer",
+    ", Package"
+};
+
+/* Bit widths for resource descriptor predefined names */
+
+static const char   *UtResourceTypeNames[] =
+{
+    "/1",
+    "/2",
+    "/3",
+    "/8",
+    "/16",
+    "/32",
+    "/64",
+    "/variable",
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtMatchResourceName
+ *
+ * PARAMETERS:  Name                - Name to find
+ *
+ * RETURN:      Pointer to entry in the resource table. NULL indicates not
+ *              found.
+ *
+ * DESCRIPTION: Check an object name against the predefined resource
+ *              descriptor object list.
+ *
+ ******************************************************************************/
+
+const ACPI_PREDEFINED_INFO *
+AcpiUtMatchResourceName (
+    char                        *Name)
+{
+    const ACPI_PREDEFINED_INFO  *ThisName;
+
+
+    /*
+     * Quick check for a predefined name, first character must
+     * be underscore
+     */
+    if (Name[0] != '_')
+    {
+        return (NULL);
+    }
+
+    /* Search info table for a predefined method/object name */
+
+    ThisName = AcpiGbl_ResourceNames;
+    while (ThisName->Info.Name[0])
+    {
+        if (ACPI_COMPARE_NAME (Name, ThisName->Info.Name))
+        {
+            return (ThisName);
+        }
+
+        ThisName++;
+    }
+
+    return (NULL); /* Not found */
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtDisplayPredefinedMethod
+ *
+ * PARAMETERS:  Buffer              - Scratch buffer for this function
+ *              ThisName            - Entry in the predefined method/name table
+ *              MultiLine           - TRUE if output should be on >1 line
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Display information about a predefined method. Number and
+ *              type of the input arguments, and expected type(s) for the
+ *              return value, if any.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtDisplayPredefinedMethod (
+    char                        *Buffer,
+    const ACPI_PREDEFINED_INFO  *ThisName,
+    BOOLEAN                     MultiLine)
+{
+    UINT32                      ArgCount;
+
+    /*
+     * Get the argument count and the string buffer
+     * containing all argument types
+     */
+    ArgCount = AcpiUtGetArgumentTypes (Buffer,
+        ThisName->Info.ArgumentList);
+
+    if (MultiLine)
+    {
+        printf ("      ");
+    }
+
+    printf ("%4.4s    Requires %s%u argument%s",
+        ThisName->Info.Name,
+        (ThisName->Info.ArgumentList & ARG_COUNT_IS_MINIMUM) ?
+            "(at least) " : "",
+        ArgCount, ArgCount != 1 ? "s" : "");
+
+    /* Display the types for any arguments */
+
+    if (ArgCount > 0)
+    {
+        printf (" (%s)", Buffer);
+    }
+
+    if (MultiLine)
+    {
+        printf ("\n    ");
+    }
+
+    /* Get the return value type(s) allowed */
+
+    if (ThisName->Info.ExpectedBtypes)
+    {
+        AcpiUtGetExpectedReturnTypes (Buffer, ThisName->Info.ExpectedBtypes);
+        printf ("  Return value types: %s\n", Buffer);
+    }
+    else
+    {
+        printf ("  No return value\n");
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtGetArgumentTypes
+ *
+ * PARAMETERS:  Buffer              - Where to return the formatted types
+ *              ArgumentTypes       - Types field for this method
+ *
+ * RETURN:      Count - the number of arguments required for this method
+ *
+ * DESCRIPTION: Format the required data types for this method (Integer,
+ *              String, Buffer, or Package) and return the required argument
+ *              count.
+ *
+ ******************************************************************************/
+
+static UINT32
+AcpiUtGetArgumentTypes (
+    char                    *Buffer,
+    UINT16                  ArgumentTypes)
+{
+    UINT16                  ThisArgumentType;
+    UINT16                  SubIndex;
+    UINT16                  ArgCount;
+    UINT32                  i;
+
+
+    *Buffer = 0;
+    SubIndex = 2;
+
+    /* First field in the types list is the count of args to follow */
+
+    ArgCount = METHOD_GET_ARG_COUNT (ArgumentTypes);
+    if (ArgCount > METHOD_PREDEF_ARGS_MAX)
+    {
+        printf ("**** Invalid argument count (%u) "
+            "in predefined info structure\n", ArgCount);
+        return (ArgCount);
+    }
+
+    /* Get each argument from the list, convert to ascii, store to buffer */
+
+    for (i = 0; i < ArgCount; i++)
+    {
+        ThisArgumentType = METHOD_GET_NEXT_TYPE (ArgumentTypes);
+
+        if (!ThisArgumentType || (ThisArgumentType > METHOD_MAX_ARG_TYPE))
+        {
+            printf ("**** Invalid argument type (%u) "
+                "in predefined info structure\n", ThisArgumentType);
+            return (ArgCount);
+        }
+
+        strcat (Buffer, UtExternalTypeNames[ThisArgumentType] + SubIndex);
+        SubIndex = 0;
+    }
+
+    return (ArgCount);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtGetResourceBitWidth
+ *
+ * PARAMETERS:  Buffer              - Where the formatted string is returned
+ *              Types               - Bitfield of expected data types
+ *
+ * RETURN:      Count of return types. Formatted string in Buffer.
+ *
+ * DESCRIPTION: Format the resource bit widths into a printable string.
+ *
+ ******************************************************************************/
+
+UINT32
+AcpiUtGetResourceBitWidth (
+    char                    *Buffer,
+    UINT16                  Types)
+{
+    UINT32                  i;
+    UINT16                  SubIndex;
+    UINT32                  Found;
+
+
+    *Buffer = 0;
+    SubIndex = 1;
+    Found = 0;
+
+    for (i = 0; i < NUM_RESOURCE_WIDTHS; i++)
+    {
+        if (Types & 1)
+        {
+            strcat (Buffer, &(UtResourceTypeNames[i][SubIndex]));
+            SubIndex = 0;
+            Found++;
+        }
+
+        Types >>= 1;
+    }
+
+    return (Found);
+}
+#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utprint.c b/usr/src/uts/intel/io/acpica/utilities/utprint.c
new file mode 100644
index 0000000000..e01f1734a9
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utprint.c
@@ -0,0 +1,812 @@
+/******************************************************************************
+ *
+ * Module Name: utprint - Formatted printing routines
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("utprint")
+
+
+#define ACPI_FORMAT_SIGN            0x01
+#define ACPI_FORMAT_SIGN_PLUS       0x02
+#define ACPI_FORMAT_SIGN_PLUS_SPACE 0x04
+#define ACPI_FORMAT_ZERO            0x08
+#define ACPI_FORMAT_LEFT            0x10
+#define ACPI_FORMAT_UPPER           0x20
+#define ACPI_FORMAT_PREFIX          0x40
+
+
+/* Local prototypes */
+
+static ACPI_SIZE
+AcpiUtBoundStringLength (
+    const char              *String,
+    ACPI_SIZE               Count);
+
+static char *
+AcpiUtBoundStringOutput (
+    char                    *String,
+    const char              *End,
+    char                    c);
+
+static char *
+AcpiUtFormatNumber (
+    char                    *String,
+    char                    *End,
+    UINT64                  Number,
+    UINT8                   Base,
+    INT32                   Width,
+    INT32                   Precision,
+    UINT8                   Type);
+
+static char *
+AcpiUtPutNumber (
+    char                    *String,
+    UINT64                  Number,
+    UINT8                   Base,
+    BOOLEAN                 Upper);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtBoundStringLength
+ *
+ * PARAMETERS:  String              - String with boundary
+ *              Count               - Boundary of the string
+ *
+ * RETURN:      Length of the string. Less than or equal to Count.
+ *
+ * DESCRIPTION: Calculate the length of a string with boundary.
+ *
+ ******************************************************************************/
+
+static ACPI_SIZE
+AcpiUtBoundStringLength (
+    const char              *String,
+    ACPI_SIZE               Count)
+{
+    UINT32                  Length = 0;
+
+
+    while (*String && Count)
+    {
+        Length++;
+        String++;
+        Count--;
+    }
+
+    return (Length);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtBoundStringOutput
+ *
+ * PARAMETERS:  String              - String with boundary
+ *              End                 - Boundary of the string
+ *              c                   - Character to be output to the string
+ *
+ * RETURN:      Updated position for next valid character
+ *
+ * DESCRIPTION: Output a character into a string with boundary check.
+ *
+ ******************************************************************************/
+
+static char *
+AcpiUtBoundStringOutput (
+    char                    *String,
+    const char              *End,
+    char                    c)
+{
+
+    if (String < End)
+    {
+        *String = c;
+    }
+
+    ++String;
+    return (String);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtPutNumber
+ *
+ * PARAMETERS:  String              - Buffer to hold reverse-ordered string
+ *              Number              - Integer to be converted
+ *              Base                - Base of the integer
+ *              Upper               - Whether or not using upper cased digits
+ *
+ * RETURN:      Updated position for next valid character
+ *
+ * DESCRIPTION: Convert an integer into a string, note that, the string holds a
+ *              reversed ordered number without the trailing zero.
+ *
+ ******************************************************************************/
+
+static char *
+AcpiUtPutNumber (
+    char                    *String,
+    UINT64                  Number,
+    UINT8                   Base,
+    BOOLEAN                 Upper)
+{
+    const char              *Digits;
+    UINT64                  DigitIndex;
+    char                    *Pos;
+
+
+    Pos = String;
+    Digits = Upper ? AcpiGbl_UpperHexDigits : AcpiGbl_LowerHexDigits;
+
+    if (Number == 0)
+    {
+        *(Pos++) = '0';
+    }
+    else
+    {
+        while (Number)
+        {
+            (void) AcpiUtDivide (Number, Base, &Number, &DigitIndex);
+            *(Pos++) = Digits[DigitIndex];
+        }
+    }
+
+    /* *(Pos++) = '0'; */
+    return (Pos);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtScanNumber
+ *
+ * PARAMETERS:  String              - String buffer
+ *              NumberPtr           - Where the number is returned
+ *
+ * RETURN:      Updated position for next valid character
+ *
+ * DESCRIPTION: Scan a string for a decimal integer.
+ *
+ ******************************************************************************/
+
+const char *
+AcpiUtScanNumber (
+    const char              *String,
+    UINT64                  *NumberPtr)
+{
+    UINT64                  Number = 0;
+
+
+    while (isdigit ((int) *String))
+    {
+        Number *= 10;
+        Number += *(String++) - '0';
+    }
+
+    *NumberPtr = Number;
+    return (String);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtPrintNumber
+ *
+ * PARAMETERS:  String              - String buffer
+ *              Number              - The number to be converted
+ *
+ * RETURN:      Updated position for next valid character
+ *
+ * DESCRIPTION: Print a decimal integer into a string.
+ *
+ ******************************************************************************/
+
+const char *
+AcpiUtPrintNumber (
+    char                    *String,
+    UINT64                  Number)
+{
+    char                    AsciiString[20];
+    const char              *Pos1;
+    char                    *Pos2;
+
+
+    Pos1 = AcpiUtPutNumber (AsciiString, Number, 10, FALSE);
+    Pos2 = String;
+
+    while (Pos1 != AsciiString)
+    {
+        *(Pos2++) = *(--Pos1);
+    }
+
+    *Pos2 = 0;
+    return (String);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtFormatNumber
+ *
+ * PARAMETERS:  String              - String buffer with boundary
+ *              End                 - Boundary of the string
+ *              Number              - The number to be converted
+ *              Base                - Base of the integer
+ *              Width               - Field width
+ *              Precision           - Precision of the integer
+ *              Type                - Special printing flags
+ *
+ * RETURN:      Updated position for next valid character
+ *
+ * DESCRIPTION: Print an integer into a string with any base and any precision.
+ *
+ ******************************************************************************/
+
+static char *
+AcpiUtFormatNumber (
+    char                    *String,
+    char                    *End,
+    UINT64                  Number,
+    UINT8                   Base,
+    INT32                   Width,
+    INT32                   Precision,
+    UINT8                   Type)
+{
+    char                    *Pos;
+    char                    Sign;
+    char                    Zero;
+    BOOLEAN                 NeedPrefix;
+    BOOLEAN                 Upper;
+    INT32                   i;
+    char                    ReversedString[66];
+
+
+    /* Parameter validation */
+
+    if (Base < 2 || Base > 16)
+    {
+        return (NULL);
+    }
+
+    if (Type & ACPI_FORMAT_LEFT)
+    {
+        Type &= ~ACPI_FORMAT_ZERO;
+    }
+
+    NeedPrefix = ((Type & ACPI_FORMAT_PREFIX) && Base != 10) ? TRUE : FALSE;
+    Upper = (Type & ACPI_FORMAT_UPPER) ? TRUE : FALSE;
+    Zero = (Type & ACPI_FORMAT_ZERO) ? '0' : ' ';
+
+    /* Calculate size according to sign and prefix */
+
+    Sign = '\0';
+    if (Type & ACPI_FORMAT_SIGN)
+    {
+        if ((INT64) Number < 0)
+        {
+            Sign = '-';
+            Number = - (INT64) Number;
+            Width--;
+        }
+        else if (Type & ACPI_FORMAT_SIGN_PLUS)
+        {
+            Sign = '+';
+            Width--;
+        }
+        else if (Type & ACPI_FORMAT_SIGN_PLUS_SPACE)
+        {
+            Sign = ' ';
+            Width--;
+        }
+    }
+    if (NeedPrefix)
+    {
+        Width--;
+        if (Base == 16)
+        {
+            Width--;
+        }
+    }
+
+    /* Generate full string in reverse order */
+
+    Pos = AcpiUtPutNumber (ReversedString, Number, Base, Upper);
+    i = ACPI_PTR_DIFF (Pos, ReversedString);
+
+    /* Printing 100 using %2d gives "100", not "00" */
+
+    if (i > Precision)
+    {
+        Precision = i;
+    }
+
+    Width -= Precision;
+
+    /* Output the string */
+
+    if (!(Type & (ACPI_FORMAT_ZERO | ACPI_FORMAT_LEFT)))
+    {
+        while (--Width >= 0)
+        {
+            String = AcpiUtBoundStringOutput (String, End, ' ');
+        }
+    }
+    if (Sign)
+    {
+        String = AcpiUtBoundStringOutput (String, End, Sign);
+    }
+    if (NeedPrefix)
+    {
+        String = AcpiUtBoundStringOutput (String, End, '0');
+        if (Base == 16)
+        {
+            String = AcpiUtBoundStringOutput (
+                String, End, Upper ? 'X' : 'x');
+        }
+    }
+    if (!(Type & ACPI_FORMAT_LEFT))
+    {
+        while (--Width >= 0)
+        {
+            String = AcpiUtBoundStringOutput (String, End, Zero);
+        }
+    }
+
+    while (i <= --Precision)
+    {
+        String = AcpiUtBoundStringOutput (String, End, '0');
+    }
+    while (--i >= 0)
+    {
+        String = AcpiUtBoundStringOutput (String, End,
+                    ReversedString[i]);
+    }
+    while (--Width >= 0)
+    {
+        String = AcpiUtBoundStringOutput (String, End, ' ');
+    }
+
+    return (String);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtVsnprintf
+ *
+ * PARAMETERS:  String              - String with boundary
+ *              Size                - Boundary of the string
+ *              Format              - Standard printf format
+ *              Args                - Argument list
+ *
+ * RETURN:      Number of bytes actually written.
+ *
+ * DESCRIPTION: Formatted output to a string using argument list pointer.
+ *
+ ******************************************************************************/
+
+int
+AcpiUtVsnprintf (
+    char                    *String,
+    ACPI_SIZE               Size,
+    const char              *Format,
+    va_list                 Args)
+{
+    UINT8                   Base;
+    UINT8                   Type;
+    INT32                   Width;
+    INT32                   Precision;
+    char                    Qualifier;
+    UINT64                  Number;
+    char                    *Pos;
+    char                    *End;
+    char                    c;
+    const char              *s;
+    const void              *p;
+    INT32                   Length;
+    int                     i;
+
+
+    Pos = String;
+    End = String + Size;
+
+    for (; *Format; ++Format)
+    {
+        if (*Format != '%')
+        {
+            Pos = AcpiUtBoundStringOutput (Pos, End, *Format);
+            continue;
+        }
+
+        Type = 0;
+        Base = 10;
+
+        /* Process sign */
+
+        do
+        {
+            ++Format;
+            if (*Format == '#')
+            {
+                Type |= ACPI_FORMAT_PREFIX;
+            }
+            else if (*Format == '0')
+            {
+                Type |= ACPI_FORMAT_ZERO;
+            }
+            else if (*Format == '+')
+            {
+                Type |= ACPI_FORMAT_SIGN_PLUS;
+            }
+            else if (*Format == ' ')
+            {
+                Type |= ACPI_FORMAT_SIGN_PLUS_SPACE;
+            }
+            else if (*Format == '-')
+            {
+                Type |= ACPI_FORMAT_LEFT;
+            }
+            else
+            {
+                break;
+            }
+
+        } while (1);
+
+        /* Process width */
+
+        Width = -1;
+        if (isdigit ((int) *Format))
+        {
+            Format = AcpiUtScanNumber (Format, &Number);
+            Width = (INT32) Number;
+        }
+        else if (*Format == '*')
+        {
+            ++Format;
+            Width = va_arg (Args, int);
+            if (Width < 0)
+            {
+                Width = -Width;
+                Type |= ACPI_FORMAT_LEFT;
+            }
+        }
+
+        /* Process precision */
+
+        Precision = -1;
+        if (*Format == '.')
+        {
+            ++Format;
+            if (isdigit ((int) *Format))
+            {
+                Format = AcpiUtScanNumber (Format, &Number);
+                Precision = (INT32) Number;
+            }
+            else if (*Format == '*')
+            {
+                ++Format;
+                Precision = va_arg (Args, int);
+            }
+
+            if (Precision < 0)
+            {
+                Precision = 0;
+            }
+        }
+
+        /* Process qualifier */
+
+        Qualifier = -1;
+        if (*Format == 'h' || *Format == 'l' || *Format == 'L')
+        {
+            Qualifier = *Format;
+            ++Format;
+
+            if (Qualifier == 'l' && *Format == 'l')
+            {
+                Qualifier = 'L';
+                ++Format;
+            }
+        }
+
+        switch (*Format)
+        {
+        case '%':
+
+            Pos = AcpiUtBoundStringOutput (Pos, End, '%');
+            continue;
+
+        case 'c':
+
+            if (!(Type & ACPI_FORMAT_LEFT))
+            {
+                while (--Width > 0)
+                {
+                    Pos = AcpiUtBoundStringOutput (Pos, End, ' ');
+                }
+            }
+
+            c = (char) va_arg (Args, int);
+            Pos = AcpiUtBoundStringOutput (Pos, End, c);
+
+            while (--Width > 0)
+            {
+                Pos = AcpiUtBoundStringOutput (Pos, End, ' ');
+            }
+            continue;
+
+        case 's':
+
+            s = va_arg (Args, char *);
+            if (!s)
+            {
+                s = "<NULL>";
+            }
+            Length = AcpiUtBoundStringLength (s, Precision);
+            if (!(Type & ACPI_FORMAT_LEFT))
+            {
+                while (Length < Width--)
+                {
+                    Pos = AcpiUtBoundStringOutput (Pos, End, ' ');
+                }
+            }
+
+            for (i = 0; i < Length; ++i)
+            {
+                Pos = AcpiUtBoundStringOutput (Pos, End, *s);
+                ++s;
+            }
+
+            while (Length < Width--)
+            {
+                Pos = AcpiUtBoundStringOutput (Pos, End, ' ');
+            }
+            continue;
+
+        case 'o':
+
+            Base = 8;
+            break;
+
+        case 'X':
+
+            Type |= ACPI_FORMAT_UPPER;
+
+        case 'x':
+
+            Base = 16;
+            break;
+
+        case 'd':
+        case 'i':
+
+            Type |= ACPI_FORMAT_SIGN;
+
+        case 'u':
+
+            break;
+
+        case 'p':
+
+            if (Width == -1)
+            {
+                Width = 2 * sizeof (void *);
+                Type |= ACPI_FORMAT_ZERO;
+            }
+
+            p = va_arg (Args, void *);
+            Pos = AcpiUtFormatNumber (
+                Pos, End, ACPI_TO_INTEGER (p), 16, Width, Precision, Type);
+            continue;
+
+        default:
+
+            Pos = AcpiUtBoundStringOutput (Pos, End, '%');
+            if (*Format)
+            {
+                Pos = AcpiUtBoundStringOutput (Pos, End, *Format);
+            }
+            else
+            {
+                --Format;
+            }
+            continue;
+        }
+
+        if (Qualifier == 'L')
+        {
+            Number = va_arg (Args, UINT64);
+            if (Type & ACPI_FORMAT_SIGN)
+            {
+                Number = (INT64) Number;
+            }
+        }
+        else if (Qualifier == 'l')
+        {
+            Number = va_arg (Args, unsigned long);
+            if (Type & ACPI_FORMAT_SIGN)
+            {
+                Number = (INT32) Number;
+            }
+        }
+        else if (Qualifier == 'h')
+        {
+            Number = (UINT16) va_arg (Args, int);
+            if (Type & ACPI_FORMAT_SIGN)
+            {
+                Number = (INT16) Number;
+            }
+        }
+        else
+        {
+            Number = va_arg (Args, unsigned int);
+            if (Type & ACPI_FORMAT_SIGN)
+            {
+                Number = (signed int) Number;
+            }
+        }
+
+        Pos = AcpiUtFormatNumber (Pos, End, Number, Base,
+            Width, Precision, Type);
+    }
+
+    if (Size > 0)
+    {
+        if (Pos < End)
+        {
+            *Pos = '\0';
+        }
+        else
+        {
+            End[-1] = '\0';
+        }
+    }
+
+    return (ACPI_PTR_DIFF (Pos, String));
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtSnprintf
+ *
+ * PARAMETERS:  String              - String with boundary
+ *              Size                - Boundary of the string
+ *              Format, ...         - Standard printf format
+ *
+ * RETURN:      Number of bytes actually written.
+ *
+ * DESCRIPTION: Formatted output to a string.
+ *
+ ******************************************************************************/
+
+int
+AcpiUtSnprintf (
+    char                    *String,
+    ACPI_SIZE               Size,
+    const char              *Format,
+    ...)
+{
+    va_list                 Args;
+    int                     Length;
+
+
+    va_start (Args, Format);
+    Length = AcpiUtVsnprintf (String, Size, Format, Args);
+    va_end (Args);
+
+    return (Length);
+}
+
+
+#ifdef ACPI_APPLICATION
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtFileVprintf
+ *
+ * PARAMETERS:  File                - File descriptor
+ *              Format              - Standard printf format
+ *              Args                - Argument list
+ *
+ * RETURN:      Number of bytes actually written.
+ *
+ * DESCRIPTION: Formatted output to a file using argument list pointer.
+ *
+ ******************************************************************************/
+
+int
+AcpiUtFileVprintf (
+    ACPI_FILE               File,
+    const char              *Format,
+    va_list                 Args)
+{
+    ACPI_CPU_FLAGS          Flags;
+    int                     Length;
+
+
+    Flags = AcpiOsAcquireLock (AcpiGbl_PrintLock);
+    Length = AcpiUtVsnprintf (AcpiGbl_PrintBuffer,
+        sizeof (AcpiGbl_PrintBuffer), Format, Args);
+
+    (void) AcpiOsWriteFile (File, AcpiGbl_PrintBuffer, Length, 1);
+    AcpiOsReleaseLock (AcpiGbl_PrintLock, Flags);
+
+    return (Length);
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtFilePrintf
+ *
+ * PARAMETERS:  File                - File descriptor
+ *              Format, ...         - Standard printf format
+ *
+ * RETURN:      Number of bytes actually written.
+ *
+ * DESCRIPTION: Formatted output to a file.
+ *
+ ******************************************************************************/
+
+int
+AcpiUtFilePrintf (
+    ACPI_FILE               File,
+    const char              *Format,
+    ...)
+{
+    va_list                 Args;
+    int                     Length;
+
+
+    va_start (Args, Format);
+    Length = AcpiUtFileVprintf (File, Format, Args);
+    va_end (Args);
+
+    return (Length);
+}
+#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utresrc.c b/usr/src/uts/intel/io/acpica/utilities/utresrc.c
index c2c135b7d2..8efae42977 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utresrc.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utresrc.c
@@ -1,11 +1,11 @@
 /*******************************************************************************
  *
- * Module Name: utresrc - Resource managment utilities
+ * Module Name: utresrc - Resource management utilities
  *
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __UTRESRC_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acresrc.h"
@@ -53,11 +50,11 @@
         ACPI_MODULE_NAME    ("utresrc")
 
 
-#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUGGER)
+#if defined(ACPI_DEBUG_OUTPUT) || defined (ACPI_DISASSEMBLER) || defined (ACPI_DEBUGGER)
 
 /*
  * Strings used to decode resource descriptors.
- * Used by both the disasssembler and the debugger resource dump routines
+ * Used by both the disassembler and the debugger resource dump routines
  */
 const char                      *AcpiGbl_BmDecode[] =
 {
@@ -100,7 +97,9 @@ const char                      *AcpiGbl_IoDecode[] =
 const char                      *AcpiGbl_LlDecode[] =
 {
     "ActiveHigh",
-    "ActiveLow"
+    "ActiveLow",
+    "ActiveBoth",
+    "Reserved"
 };
 
 const char                      *AcpiGbl_MaxDecode[] =
@@ -148,7 +147,9 @@ const char                      *AcpiGbl_RwDecode[] =
 const char                      *AcpiGbl_ShrDecode[] =
 {
     "Exclusive",
-    "Shared"
+    "Shared",
+    "ExclusiveAndWake",         /* ACPI 5.0 */
+    "SharedAndWake"             /* ACPI 5.0 */
 };
 
 const char                      *AcpiGbl_SizDecode[] =
@@ -297,7 +298,7 @@ const char                      *AcpiGbl_BpbDecode[] =
 
 const char                      *AcpiGbl_SbDecode[] =
 {
-    "StopBitsNone",
+    "StopBitsZero",
     "StopBitsOne",
     "StopBitsOnePlusHalf",
     "StopBitsTwo"
@@ -429,27 +430,17 @@ static const UINT8          AcpiGbl_ResourceTypes[] =
     ACPI_VARIABLE_LENGTH            /* 0E *SerialBus */
 };
 
-/*
- * For the iASL compiler/disassembler, we don't want any error messages
- * because the disassembler uses the resource validation code to determine
- * if Buffer objects are actually Resource Templates.
- */
-#ifdef ACPI_ASL_COMPILER
-#define ACPI_RESOURCE_ERROR(plist)
-#else
-#define ACPI_RESOURCE_ERROR(plist)  ACPI_ERROR(plist)
-#endif
-
 
 /*******************************************************************************
  *
  * FUNCTION:    AcpiUtWalkAmlResources
  *
- * PARAMETERS:  Aml             - Pointer to the raw AML resource template
- *              AmlLength       - Length of the entire template
- *              UserFunction    - Called once for each descriptor found. If
- *                                NULL, a pointer to the EndTag is returned
- *              Context         - Passed to UserFunction
+ * PARAMETERS:  WalkState           - Current walk info
+ * PARAMETERS:  Aml                 - Pointer to the raw AML resource template
+ *              AmlLength           - Length of the entire template
+ *              UserFunction        - Called once for each descriptor found. If
+ *                                    NULL, a pointer to the EndTag is returned
+ *              Context             - Passed to UserFunction
  *
  * RETURN:      Status
  *
@@ -460,10 +451,11 @@ static const UINT8          AcpiGbl_ResourceTypes[] =
 
 ACPI_STATUS
 AcpiUtWalkAmlResources (
+    ACPI_WALK_STATE         *WalkState,
     UINT8                   *Aml,
     ACPI_SIZE               AmlLength,
     ACPI_WALK_AML_CALLBACK  UserFunction,
-    void                    *Context)
+    void                    **Context)
 {
     ACPI_STATUS             Status;
     UINT8                   *EndAml;
@@ -493,12 +485,12 @@ AcpiUtWalkAmlResources (
     {
         /* Validate the Resource Type and Resource Length */
 
-        Status = AcpiUtValidateResource (Aml, &ResourceIndex);
+        Status = AcpiUtValidateResource (WalkState, Aml, &ResourceIndex);
         if (ACPI_FAILURE (Status))
         {
             /*
-             * Exit on failure. Cannot continue because the descriptor length
-             * may be bogus also.
+             * Exit on failure. Cannot continue because the descriptor
+             * length may be bogus also.
              */
             return_ACPI_STATUS (Status);
         }
@@ -511,7 +503,8 @@ AcpiUtWalkAmlResources (
 
         if (UserFunction)
         {
-            Status = UserFunction (Aml, Length, Offset, ResourceIndex, Context);
+            Status = UserFunction (
+                Aml, Length, Offset, ResourceIndex, Context);
             if (ACPI_FAILURE (Status))
             {
                 return_ACPI_STATUS (Status);
@@ -535,7 +528,7 @@ AcpiUtWalkAmlResources (
 
             if (!UserFunction)
             {
-                *(void **) Context = Aml;
+                *Context = Aml;
             }
 
             /* Normal exit */
@@ -553,7 +546,7 @@ AcpiUtWalkAmlResources (
     {
         /* Insert an EndTag anyway. AcpiRsGetListLength always leaves room */
 
-        (void) AcpiUtValidateResource (EndTag, &ResourceIndex);
+        (void) AcpiUtValidateResource (WalkState, EndTag, &ResourceIndex);
         Status = UserFunction (EndTag, 2, Offset, ResourceIndex, Context);
         if (ACPI_FAILURE (Status))
         {
@@ -569,9 +562,10 @@ AcpiUtWalkAmlResources (
  *
  * FUNCTION:    AcpiUtValidateResource
  *
- * PARAMETERS:  Aml             - Pointer to the raw AML resource descriptor
- *              ReturnIndex     - Where the resource index is returned. NULL
- *                                if the index is not required.
+ * PARAMETERS:  WalkState           - Current walk info
+ *              Aml                 - Pointer to the raw AML resource descriptor
+ *              ReturnIndex         - Where the resource index is returned. NULL
+ *                                    if the index is not required.
  *
  * RETURN:      Status, and optionally the Index into the global resource tables
  *
@@ -583,6 +577,7 @@ AcpiUtWalkAmlResources (
 
 ACPI_STATUS
 AcpiUtValidateResource (
+    ACPI_WALK_STATE         *WalkState,
     void                    *Aml,
     UINT8                   *ReturnIndex)
 {
@@ -631,8 +626,8 @@ AcpiUtValidateResource (
     }
 
     /*
-     * Check validity of the resource type, via AcpiGbl_ResourceTypes. Zero
-     * indicates an invalid resource.
+     * Check validity of the resource type, via AcpiGbl_ResourceTypes.
+     * Zero indicates an invalid resource.
      */
     if (!AcpiGbl_ResourceTypes[ResourceIndex])
     {
@@ -696,9 +691,12 @@ AcpiUtValidateResource (
         if ((AmlResource->CommonSerialBus.Type == 0) ||
             (AmlResource->CommonSerialBus.Type > AML_RESOURCE_MAX_SERIALBUSTYPE))
         {
-            ACPI_RESOURCE_ERROR ((AE_INFO,
-                "Invalid/unsupported SerialBus resource descriptor: BusType 0x%2.2X",
-                AmlResource->CommonSerialBus.Type));
+            if (WalkState)
+            {
+                ACPI_ERROR ((AE_INFO,
+                    "Invalid/unsupported SerialBus resource descriptor: BusType 0x%2.2X",
+                    AmlResource->CommonSerialBus.Type));
+            }
             return (AE_AML_INVALID_RESOURCE_TYPE);
         }
     }
@@ -715,17 +713,23 @@ AcpiUtValidateResource (
 
 InvalidResource:
 
-    ACPI_RESOURCE_ERROR ((AE_INFO,
-        "Invalid/unsupported resource descriptor: Type 0x%2.2X",
-        ResourceType));
+    if (WalkState)
+    {
+        ACPI_ERROR ((AE_INFO,
+            "Invalid/unsupported resource descriptor: Type 0x%2.2X",
+            ResourceType));
+    }
     return (AE_AML_INVALID_RESOURCE_TYPE);
 
 BadResourceLength:
 
-    ACPI_RESOURCE_ERROR ((AE_INFO,
-        "Invalid resource descriptor length: Type "
-        "0x%2.2X, Length 0x%4.4X, MinLength 0x%4.4X",
-        ResourceType, ResourceLength, MinimumResourceLength));
+    if (WalkState)
+    {
+        ACPI_ERROR ((AE_INFO,
+            "Invalid resource descriptor length: Type "
+            "0x%2.2X, Length 0x%4.4X, MinLength 0x%4.4X",
+            ResourceType, ResourceLength, MinimumResourceLength));
+    }
     return (AE_AML_BAD_RESOURCE_LENGTH);
 }
 
@@ -810,7 +814,7 @@ AcpiUtGetResourceLength (
         /* Small Resource type -- bits 2:0 of byte 0 contain the length */
 
         ResourceLength = (UINT16) (ACPI_GET8 (Aml) &
-                                    ACPI_RESOURCE_NAME_SMALL_LENGTH_MASK);
+            ACPI_RESOURCE_NAME_SMALL_LENGTH_MASK);
     }
 
     return (ResourceLength);
@@ -875,7 +879,7 @@ AcpiUtGetDescriptorLength (
      * the header length (depends on if this is a small or large resource)
      */
     return (AcpiUtGetResourceLength (Aml) +
-            AcpiUtGetResourceHeaderLength (Aml));
+        AcpiUtGetResourceHeaderLength (Aml));
 }
 
 
@@ -914,10 +918,8 @@ AcpiUtGetResourceEndTag (
 
     /* Validate the template and get a pointer to the EndTag */
 
-    Status = AcpiUtWalkAmlResources (ObjDesc->Buffer.Pointer,
-                ObjDesc->Buffer.Length, NULL, EndTag);
+    Status = AcpiUtWalkAmlResources (NULL, ObjDesc->Buffer.Pointer,
+        ObjDesc->Buffer.Length, NULL, (void **) EndTag);
 
     return_ACPI_STATUS (Status);
 }
-
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utstate.c b/usr/src/uts/intel/io/acpica/utilities/utstate.c
index 62a1aefec7..deffd283ca 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utstate.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utstate.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,9 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __UTSTATE_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -51,44 +48,6 @@
         ACPI_MODULE_NAME    ("utstate")
 
 
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtCreatePkgStateAndPush
- *
- * PARAMETERS:  Object          - Object to be added to the new state
- *              Action          - Increment/Decrement
- *              StateList       - List the state will be added to
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Create a new state and push it
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiUtCreatePkgStateAndPush (
-    void                    *InternalObject,
-    void                    *ExternalObject,
-    UINT16                  Index,
-    ACPI_GENERIC_STATE      **StateList)
-{
-    ACPI_GENERIC_STATE       *State;
-
-
-    ACPI_FUNCTION_ENTRY ();
-
-
-    State = AcpiUtCreatePkgState (InternalObject, ExternalObject, Index);
-    if (!State)
-    {
-        return (AE_NO_MEMORY);
-    }
-
-    AcpiUtPushGenericState (StateList, State);
-    return (AE_OK);
-}
-
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiUtPushGenericState
@@ -107,15 +66,14 @@ AcpiUtPushGenericState (
     ACPI_GENERIC_STATE      **ListHead,
     ACPI_GENERIC_STATE      *State)
 {
-    ACPI_FUNCTION_TRACE (UtPushGenericState);
+    ACPI_FUNCTION_ENTRY ();
 
 
     /* Push the state object onto the front of the list (stack) */
 
     State->Common.Next = *ListHead;
     *ListHead = State;
-
-    return_VOID;
+    return;
 }
 
 
@@ -138,7 +96,7 @@ AcpiUtPopGenericState (
     ACPI_GENERIC_STATE      *State;
 
 
-    ACPI_FUNCTION_TRACE (UtPopGenericState);
+    ACPI_FUNCTION_ENTRY ();
 
 
     /* Remove the state object at the head of the list (stack) */
@@ -151,7 +109,7 @@ AcpiUtPopGenericState (
         *ListHead = State->Common.Next;
     }
 
-    return_PTR (State);
+    return (State);
 }
 
 
@@ -163,7 +121,7 @@ AcpiUtPopGenericState (
  *
  * RETURN:      The new state object. NULL on failure.
  *
- * DESCRIPTION: Create a generic state object.  Attempt to obtain one from
+ * DESCRIPTION: Create a generic state object. Attempt to obtain one from
  *              the global state cache;  If none available, create a new one.
  *
  ******************************************************************************/
@@ -209,7 +167,7 @@ AcpiUtCreateThreadState (
     ACPI_GENERIC_STATE      *State;
 
 
-    ACPI_FUNCTION_TRACE (UtCreateThreadState);
+    ACPI_FUNCTION_ENTRY ();
 
 
     /* Create the generic state object */
@@ -217,7 +175,7 @@ AcpiUtCreateThreadState (
     State = AcpiUtCreateGenericState ();
     if (!State)
     {
-        return_PTR (NULL);
+        return (NULL);
     }
 
     /* Init fields specific to the update struct */
@@ -233,7 +191,7 @@ AcpiUtCreateThreadState (
         State->Thread.ThreadId = (ACPI_THREAD_ID) 1;
     }
 
-    return_PTR ((ACPI_THREAD_STATE *) State);
+    return ((ACPI_THREAD_STATE *) State);
 }
 
 
@@ -260,7 +218,7 @@ AcpiUtCreateUpdateState (
     ACPI_GENERIC_STATE      *State;
 
 
-    ACPI_FUNCTION_TRACE_PTR (UtCreateUpdateState, Object);
+    ACPI_FUNCTION_ENTRY ();
 
 
     /* Create the generic state object */
@@ -268,7 +226,7 @@ AcpiUtCreateUpdateState (
     State = AcpiUtCreateGenericState ();
     if (!State)
     {
-        return_PTR (NULL);
+        return (NULL);
     }
 
     /* Init fields specific to the update struct */
@@ -276,8 +234,7 @@ AcpiUtCreateUpdateState (
     State->Common.DescriptorType = ACPI_DESC_TYPE_STATE_UPDATE;
     State->Update.Object = Object;
     State->Update.Value = Action;
-
-    return_PTR (State);
+    return (State);
 }
 
 
@@ -303,7 +260,7 @@ AcpiUtCreatePkgState (
     ACPI_GENERIC_STATE      *State;
 
 
-    ACPI_FUNCTION_TRACE_PTR (UtCreatePkgState, InternalObject);
+    ACPI_FUNCTION_ENTRY ();
 
 
     /* Create the generic state object */
@@ -311,7 +268,7 @@ AcpiUtCreatePkgState (
     State = AcpiUtCreateGenericState ();
     if (!State)
     {
-        return_PTR (NULL);
+        return (NULL);
     }
 
     /* Init fields specific to the update struct */
@@ -322,7 +279,7 @@ AcpiUtCreatePkgState (
     State->Pkg.Index= Index;
     State->Pkg.NumPackages = 1;
 
-    return_PTR (State);
+    return (State);
 }
 
 
@@ -346,7 +303,7 @@ AcpiUtCreateControlState (
     ACPI_GENERIC_STATE      *State;
 
 
-    ACPI_FUNCTION_TRACE (UtCreateControlState);
+    ACPI_FUNCTION_ENTRY ();
 
 
     /* Create the generic state object */
@@ -354,7 +311,7 @@ AcpiUtCreateControlState (
     State = AcpiUtCreateGenericState ();
     if (!State)
     {
-        return_PTR (NULL);
+        return (NULL);
     }
 
     /* Init fields specific to the control struct */
@@ -362,7 +319,7 @@ AcpiUtCreateControlState (
     State->Common.DescriptorType = ACPI_DESC_TYPE_STATE_CONTROL;
     State->Common.State = ACPI_CONTROL_CONDITIONAL_EXECUTING;
 
-    return_PTR (State);
+    return (State);
 }
 
 
@@ -383,7 +340,7 @@ void
 AcpiUtDeleteGenericState (
     ACPI_GENERIC_STATE      *State)
 {
-    ACPI_FUNCTION_TRACE (UtDeleteGenericState);
+    ACPI_FUNCTION_ENTRY ();
 
 
     /* Ignore null state */
@@ -392,7 +349,6 @@ AcpiUtDeleteGenericState (
     {
         (void) AcpiOsReleaseObject (AcpiGbl_StateCache, State);
     }
-    return_VOID;
-}
-
 
+    return;
+}
diff --git a/usr/src/uts/intel/io/acpica/utilities/utstring.c b/usr/src/uts/intel/io/acpica/utilities/utstring.c
new file mode 100644
index 0000000000..cb46193e6e
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utstring.c
@@ -0,0 +1,277 @@
+/*******************************************************************************
+ *
+ * Module Name: utstring - Common functions for strings and characters
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acnamesp.h"
+
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("utstring")
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtPrintString
+ *
+ * PARAMETERS:  String          - Null terminated ASCII string
+ *              MaxLength       - Maximum output length. Used to constrain the
+ *                                length of strings during debug output only.
+ *
+ * RETURN:      None
+ *
+ * DESCRIPTION: Dump an ASCII string with support for ACPI-defined escape
+ *              sequences.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtPrintString (
+    char                    *String,
+    UINT16                  MaxLength)
+{
+    UINT32                  i;
+
+
+    if (!String)
+    {
+        AcpiOsPrintf ("<\"NULL STRING PTR\">");
+        return;
+    }
+
+    AcpiOsPrintf ("\"");
+    for (i = 0; (i < MaxLength) && String[i]; i++)
+    {
+        /* Escape sequences */
+
+        switch (String[i])
+        {
+        case 0x07:
+
+            AcpiOsPrintf ("\\a");       /* BELL */
+            break;
+
+        case 0x08:
+
+            AcpiOsPrintf ("\\b");       /* BACKSPACE */
+            break;
+
+        case 0x0C:
+
+            AcpiOsPrintf ("\\f");       /* FORMFEED */
+            break;
+
+        case 0x0A:
+
+            AcpiOsPrintf ("\\n");       /* LINEFEED */
+            break;
+
+        case 0x0D:
+
+            AcpiOsPrintf ("\\r");       /* CARRIAGE RETURN*/
+            break;
+
+        case 0x09:
+
+            AcpiOsPrintf ("\\t");       /* HORIZONTAL TAB */
+            break;
+
+        case 0x0B:
+
+            AcpiOsPrintf ("\\v");       /* VERTICAL TAB */
+            break;
+
+        case '\'':                      /* Single Quote */
+        case '\"':                      /* Double Quote */
+        case '\\':                      /* Backslash */
+
+            AcpiOsPrintf ("\\%c", (int) String[i]);
+            break;
+
+        default:
+
+            /* Check for printable character or hex escape */
+
+            if (isprint ((int) String[i]))
+            {
+                /* This is a normal character */
+
+                AcpiOsPrintf ("%c", (int) String[i]);
+            }
+            else
+            {
+                /* All others will be Hex escapes */
+
+                AcpiOsPrintf ("\\x%2.2X", (INT32) String[i]);
+            }
+            break;
+        }
+    }
+
+    AcpiOsPrintf ("\"");
+
+    if (i == MaxLength && String[i])
+    {
+        AcpiOsPrintf ("...");
+    }
+}
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtRepairName
+ *
+ * PARAMETERS:  Name            - The ACPI name to be repaired
+ *
+ * RETURN:      Repaired version of the name
+ *
+ * DESCRIPTION: Repair an ACPI name: Change invalid characters to '*' and
+ *              return the new name. NOTE: the Name parameter must reside in
+ *              read/write memory, cannot be a const.
+ *
+ * An ACPI Name must consist of valid ACPI characters. We will repair the name
+ * if necessary because we don't want to abort because of this, but we want
+ * all namespace names to be printable. A warning message is appropriate.
+ *
+ * This issue came up because there are in fact machines that exhibit
+ * this problem, and we want to be able to enable ACPI support for them,
+ * even though there are a few bad names.
+ *
+ ******************************************************************************/
+
+void
+AcpiUtRepairName (
+    char                    *Name)
+{
+    UINT32                  i;
+    BOOLEAN                 FoundBadChar = FALSE;
+    UINT32                  OriginalName;
+
+
+    ACPI_FUNCTION_NAME (UtRepairName);
+
+
+    /*
+     * Special case for the root node. This can happen if we get an
+     * error during the execution of module-level code.
+     */
+    if (ACPI_COMPARE_NAME (Name, "\\___"))
+    {
+        return;
+    }
+
+    ACPI_MOVE_NAME (&OriginalName, Name);
+
+    /* Check each character in the name */
+
+    for (i = 0; i < ACPI_NAME_SIZE; i++)
+    {
+        if (AcpiUtValidNameChar (Name[i], i))
+        {
+            continue;
+        }
+
+        /*
+         * Replace a bad character with something printable, yet technically
+         * still invalid. This prevents any collisions with existing "good"
+         * names in the namespace.
+         */
+        Name[i] = '*';
+        FoundBadChar = TRUE;
+    }
+
+    if (FoundBadChar)
+    {
+        /* Report warning only if in strict mode or debug mode */
+
+        if (!AcpiGbl_EnableInterpreterSlack)
+        {
+            ACPI_WARNING ((AE_INFO,
+                "Invalid character(s) in name (0x%.8X), repaired: [%4.4s]",
+                OriginalName, Name));
+        }
+        else
+        {
+            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,
+                "Invalid character(s) in name (0x%.8X), repaired: [%4.4s]",
+                OriginalName, Name));
+        }
+    }
+}
+
+
+#if defined ACPI_ASL_COMPILER || defined ACPI_EXEC_APP
+/*******************************************************************************
+ *
+ * FUNCTION:    UtConvertBackslashes
+ *
+ * PARAMETERS:  Pathname        - File pathname string to be converted
+ *
+ * RETURN:      Modifies the input Pathname
+ *
+ * DESCRIPTION: Convert all backslashes (0x5C) to forward slashes (0x2F) within
+ *              the entire input file pathname string.
+ *
+ ******************************************************************************/
+
+void
+UtConvertBackslashes (
+    char                    *Pathname)
+{
+
+    if (!Pathname)
+    {
+        return;
+    }
+
+    while (*Pathname)
+    {
+        if (*Pathname == '\\')
+        {
+            *Pathname = '/';
+        }
+
+        Pathname++;
+    }
+}
+#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/uttrack.c b/usr/src/uts/intel/io/acpica/utilities/uttrack.c
index 7d58f5c8a8..9efa9d6ec7 100644
--- a/usr/src/uts/intel/io/acpica/utilities/uttrack.c
+++ b/usr/src/uts/intel/io/acpica/utilities/uttrack.c
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -45,15 +45,13 @@
  * These procedures are used for tracking memory leaks in the subsystem, and
  * they get compiled out when the ACPI_DBG_TRACK_ALLOCATIONS is not set.
  *
- * Each memory allocation is tracked via a doubly linked list.  Each
+ * Each memory allocation is tracked via a doubly linked list. Each
  * element contains the caller's component, module name, function name, and
- * line number.  AcpiUtAllocate and AcpiUtAllocateZeroed call
+ * line number. AcpiUtAllocate and AcpiUtAllocateZeroed call
  * AcpiUtTrackAllocation to add an element to the list; deletion
  * occurs in the body of AcpiUtFree.
  */
 
-#define __UTTRACK_C__
-
 #include "acpi.h"
 #include "accommon.h"
 
@@ -62,11 +60,12 @@
 #define _COMPONENT          ACPI_UTILITIES
         ACPI_MODULE_NAME    ("uttrack")
 
+
 /* Local prototypes */
 
 static ACPI_DEBUG_MEM_BLOCK *
 AcpiUtFindAllocation (
-    void                    *Allocation);
+    ACPI_DEBUG_MEM_BLOCK    *Allocation);
 
 static ACPI_STATUS
 AcpiUtTrackAllocation (
@@ -101,7 +100,7 @@ AcpiUtRemoveAllocation (
 
 ACPI_STATUS
 AcpiUtCreateList (
-    char                    *ListName,
+    const char              *ListName,
     UINT16                  ObjectSize,
     ACPI_MEMORY_LIST        **ReturnCache)
 {
@@ -114,9 +113,9 @@ AcpiUtCreateList (
         return (AE_NO_MEMORY);
     }
 
-    ACPI_MEMSET (Cache, 0, sizeof (ACPI_MEMORY_LIST));
+    memset (Cache, 0, sizeof (ACPI_MEMORY_LIST));
 
-    Cache->ListName   = ListName;
+    Cache->ListName = ListName;
     Cache->ObjectSize = ObjectSize;
 
     *ReturnCache = Cache;
@@ -150,15 +149,28 @@ AcpiUtAllocateAndTrack (
     ACPI_STATUS             Status;
 
 
-    Allocation = AcpiUtAllocate (Size + sizeof (ACPI_DEBUG_MEM_HEADER),
-                    Component, Module, Line);
+    /* Check for an inadvertent size of zero bytes */
+
+    if (!Size)
+    {
+        ACPI_WARNING ((Module, Line,
+            "Attempt to allocate zero bytes, allocating 1 byte"));
+        Size = 1;
+    }
+
+    Allocation = AcpiOsAllocate (Size + sizeof (ACPI_DEBUG_MEM_HEADER));
     if (!Allocation)
     {
+        /* Report allocation error */
+
+        ACPI_WARNING ((Module, Line,
+            "Could not allocate size %u", (UINT32) Size));
+
         return (NULL);
     }
 
-    Status = AcpiUtTrackAllocation (Allocation, Size,
-                    ACPI_MEM_MALLOC, Component, Module, Line);
+    Status = AcpiUtTrackAllocation (
+        Allocation, Size, ACPI_MEM_MALLOC, Component, Module, Line);
     if (ACPI_FAILURE (Status))
     {
         AcpiOsFree (Allocation);
@@ -168,9 +180,12 @@ AcpiUtAllocateAndTrack (
     AcpiGbl_GlobalList->TotalAllocated++;
     AcpiGbl_GlobalList->TotalSize += (UINT32) Size;
     AcpiGbl_GlobalList->CurrentTotalSize += (UINT32) Size;
-    if (AcpiGbl_GlobalList->CurrentTotalSize > AcpiGbl_GlobalList->MaxOccupied)
+
+    if (AcpiGbl_GlobalList->CurrentTotalSize >
+        AcpiGbl_GlobalList->MaxOccupied)
     {
-        AcpiGbl_GlobalList->MaxOccupied = AcpiGbl_GlobalList->CurrentTotalSize;
+        AcpiGbl_GlobalList->MaxOccupied =
+            AcpiGbl_GlobalList->CurrentTotalSize;
     }
 
     return ((void *) &Allocation->UserSpace);
@@ -203,8 +218,17 @@ AcpiUtAllocateZeroedAndTrack (
     ACPI_STATUS             Status;
 
 
-    Allocation = AcpiUtAllocateZeroed (Size + sizeof (ACPI_DEBUG_MEM_HEADER),
-                    Component, Module, Line);
+    /* Check for an inadvertent size of zero bytes */
+
+    if (!Size)
+    {
+        ACPI_WARNING ((Module, Line,
+            "Attempt to allocate zero bytes, allocating 1 byte"));
+        Size = 1;
+    }
+
+    Allocation = AcpiOsAllocateZeroed (
+        Size + sizeof (ACPI_DEBUG_MEM_HEADER));
     if (!Allocation)
     {
         /* Report allocation error */
@@ -215,7 +239,7 @@ AcpiUtAllocateZeroedAndTrack (
     }
 
     Status = AcpiUtTrackAllocation (Allocation, Size,
-                ACPI_MEM_CALLOC, Component, Module, Line);
+        ACPI_MEM_CALLOC, Component, Module, Line);
     if (ACPI_FAILURE (Status))
     {
         AcpiOsFree (Allocation);
@@ -225,9 +249,12 @@ AcpiUtAllocateZeroedAndTrack (
     AcpiGbl_GlobalList->TotalAllocated++;
     AcpiGbl_GlobalList->TotalSize += (UINT32) Size;
     AcpiGbl_GlobalList->CurrentTotalSize += (UINT32) Size;
-    if (AcpiGbl_GlobalList->CurrentTotalSize > AcpiGbl_GlobalList->MaxOccupied)
+
+    if (AcpiGbl_GlobalList->CurrentTotalSize >
+        AcpiGbl_GlobalList->MaxOccupied)
     {
-        AcpiGbl_GlobalList->MaxOccupied = AcpiGbl_GlobalList->CurrentTotalSize;
+        AcpiGbl_GlobalList->MaxOccupied =
+            AcpiGbl_GlobalList->CurrentTotalSize;
     }
 
     return ((void *) &Allocation->UserSpace);
@@ -272,20 +299,20 @@ AcpiUtFreeAndTrack (
     }
 
     DebugBlock = ACPI_CAST_PTR (ACPI_DEBUG_MEM_BLOCK,
-                    (((char *) Allocation) - sizeof (ACPI_DEBUG_MEM_HEADER)));
+        (((char *) Allocation) - sizeof (ACPI_DEBUG_MEM_HEADER)));
 
     AcpiGbl_GlobalList->TotalFreed++;
     AcpiGbl_GlobalList->CurrentTotalSize -= DebugBlock->Size;
 
-    Status = AcpiUtRemoveAllocation (DebugBlock,
-                    Component, Module, Line);
+    Status = AcpiUtRemoveAllocation (DebugBlock, Component, Module, Line);
     if (ACPI_FAILURE (Status))
     {
         ACPI_EXCEPTION ((AE_INFO, Status, "Could not free memory"));
     }
 
     AcpiOsFree (DebugBlock);
-    ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p freed\n", Allocation));
+    ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "%p freed (block %p)\n",
+        Allocation, DebugBlock));
     return_VOID;
 }
 
@@ -296,29 +323,52 @@ AcpiUtFreeAndTrack (
  *
  * PARAMETERS:  Allocation              - Address of allocated memory
  *
- * RETURN:      A list element if found; NULL otherwise.
+ * RETURN:      Three cases:
+ *              1) List is empty, NULL is returned.
+ *              2) Element was found. Returns Allocation parameter.
+ *              3) Element was not found. Returns position where it should be
+ *                  inserted into the list.
  *
  * DESCRIPTION: Searches for an element in the global allocation tracking list.
+ *              If the element is not found, returns the location within the
+ *              list where the element should be inserted.
+ *
+ *              Note: The list is ordered by larger-to-smaller addresses.
+ *
+ *              This global list is used to detect memory leaks in ACPICA as
+ *              well as other issues such as an attempt to release the same
+ *              internal object more than once. Although expensive as far
+ *              as cpu time, this list is much more helpful for finding these
+ *              types of issues than using memory leak detectors outside of
+ *              the ACPICA code.
  *
  ******************************************************************************/
 
 static ACPI_DEBUG_MEM_BLOCK *
 AcpiUtFindAllocation (
-    void                    *Allocation)
+    ACPI_DEBUG_MEM_BLOCK    *Allocation)
 {
     ACPI_DEBUG_MEM_BLOCK    *Element;
 
 
-    ACPI_FUNCTION_ENTRY ();
-
-
     Element = AcpiGbl_GlobalList->ListHead;
+    if (!Element)
+    {
+        return (NULL);
+    }
 
-    /* Search for the address. */
-
-    while (Element)
+    /*
+     * Search for the address.
+     *
+     * Note: List is ordered by larger-to-smaller addresses, on the
+     * assumption that a new allocation usually has a larger address
+     * than previous allocations.
+     */
+    while (Element > Allocation)
     {
-        if (Element == Allocation)
+        /* Check for end-of-list */
+
+        if (!Element->Next)
         {
             return (Element);
         }
@@ -326,7 +376,12 @@ AcpiUtFindAllocation (
         Element = Element->Next;
     }
 
-    return (NULL);
+    if (Element == Allocation)
+    {
+        return (Element);
+    }
+
+    return (Element->Previous);
 }
 
 
@@ -341,7 +396,7 @@ AcpiUtFindAllocation (
  *              Module              - Source file name of caller
  *              Line                - Line number of caller
  *
- * RETURN:      None.
+ * RETURN:      Status
  *
  * DESCRIPTION: Inserts an element into the global allocation tracking list.
  *
@@ -377,43 +432,57 @@ AcpiUtTrackAllocation (
     }
 
     /*
-     * Search list for this address to make sure it is not already on the list.
-     * This will catch several kinds of problems.
+     * Search the global list for this address to make sure it is not
+     * already present. This will catch several kinds of problems.
      */
     Element = AcpiUtFindAllocation (Allocation);
-    if (Element)
+    if (Element == Allocation)
     {
         ACPI_ERROR ((AE_INFO,
-            "UtTrackAllocation: Allocation already present in list! (%p)",
+            "UtTrackAllocation: Allocation (%p) already present in global list!",
             Allocation));
-
-        ACPI_ERROR ((AE_INFO, "Element %p Address %p",
-            Element, Allocation));
-
         goto UnlockAndExit;
     }
 
-    /* Fill in the instance data. */
+    /* Fill in the instance data */
 
-    Allocation->Size      = (UINT32) Size;
+    Allocation->Size = (UINT32) Size;
     Allocation->AllocType = AllocType;
     Allocation->Component = Component;
-    Allocation->Line      = Line;
+    Allocation->Line = Line;
 
-    ACPI_STRNCPY (Allocation->Module, Module, ACPI_MAX_MODULE_NAME);
+    strncpy (Allocation->Module, Module, ACPI_MAX_MODULE_NAME);
     Allocation->Module[ACPI_MAX_MODULE_NAME-1] = 0;
 
-    /* Insert at list head */
-
-    if (MemList->ListHead)
+    if (!Element)
     {
-        ((ACPI_DEBUG_MEM_BLOCK *)(MemList->ListHead))->Previous = Allocation;
+        /* Insert at list head */
+
+        if (MemList->ListHead)
+        {
+            ((ACPI_DEBUG_MEM_BLOCK *)(MemList->ListHead))->Previous =
+                Allocation;
+        }
+
+        Allocation->Next = MemList->ListHead;
+        Allocation->Previous = NULL;
+
+        MemList->ListHead = Allocation;
     }
+    else
+    {
+        /* Insert after element */
 
-    Allocation->Next = MemList->ListHead;
-    Allocation->Previous = NULL;
+        Allocation->Next = Element->Next;
+        Allocation->Previous = Element;
+
+        if (Element->Next)
+        {
+            (Element->Next)->Previous = Allocation;
+        }
 
-    MemList->ListHead = Allocation;
+        Element->Next = Allocation;
+    }
 
 
 UnlockAndExit:
@@ -431,7 +500,7 @@ UnlockAndExit:
  *              Module              - Source file name of caller
  *              Line                - Line number of caller
  *
- * RETURN:
+ * RETURN:      Status
  *
  * DESCRIPTION: Deletes an element from the global allocation tracking list.
  *
@@ -448,12 +517,12 @@ AcpiUtRemoveAllocation (
     ACPI_STATUS             Status;
 
 
-    ACPI_FUNCTION_TRACE (UtRemoveAllocation);
+    ACPI_FUNCTION_NAME (UtRemoveAllocation);
 
 
     if (AcpiGbl_DisableMemTracking)
     {
-        return_ACPI_STATUS (AE_OK);
+        return (AE_OK);
     }
 
     MemList = AcpiGbl_GlobalList;
@@ -464,13 +533,13 @@ AcpiUtRemoveAllocation (
         ACPI_ERROR ((Module, Line,
             "Empty allocation list, nothing to free!"));
 
-        return_ACPI_STATUS (AE_OK);
+        return (AE_OK);
     }
 
     Status = AcpiUtAcquireMutex (ACPI_MTX_MEMORY);
     if (ACPI_FAILURE (Status))
     {
-        return_ACPI_STATUS (Status);
+        return (Status);
     }
 
     /* Unlink */
@@ -489,15 +558,15 @@ AcpiUtRemoveAllocation (
         (Allocation->Next)->Previous = Allocation->Previous;
     }
 
-    /* Mark the segment as deleted */
+    ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Freeing %p, size 0%X\n",
+        &Allocation->UserSpace, Allocation->Size));
 
-    ACPI_MEMSET (&Allocation->UserSpace, 0xEA, Allocation->Size);
+    /* Mark the segment as deleted */
 
-    ACPI_DEBUG_PRINT ((ACPI_DB_ALLOCATIONS, "Freeing size 0%X\n",
-        Allocation->Size));
+    memset (&Allocation->UserSpace, 0xEA, Allocation->Size);
 
     Status = AcpiUtReleaseMutex (ACPI_MTX_MEMORY);
-    return_ACPI_STATUS (Status);
+    return (Status);
 }
 
 
@@ -505,7 +574,7 @@ AcpiUtRemoveAllocation (
  *
  * FUNCTION:    AcpiUtDumpAllocationInfo
  *
- * PARAMETERS:
+ * PARAMETERS:  None
  *
  * RETURN:      None
  *
@@ -525,37 +594,37 @@ AcpiUtDumpAllocationInfo (
 
 /*
     ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-                    ("%30s: %4d (%3d Kb)\n", "Current allocations",
-                    MemList->CurrentCount,
-                    ROUND_UP_TO_1K (MemList->CurrentSize)));
+        ("%30s: %4d (%3d Kb)\n", "Current allocations",
+        MemList->CurrentCount,
+        ROUND_UP_TO_1K (MemList->CurrentSize)));
 
     ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-                    ("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",
-                    MemList->MaxConcurrentCount,
-                    ROUND_UP_TO_1K (MemList->MaxConcurrentSize)));
+        ("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",
+        MemList->MaxConcurrentCount,
+        ROUND_UP_TO_1K (MemList->MaxConcurrentSize)));
 
 
     ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-                    ("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",
-                    RunningObjectCount,
-                    ROUND_UP_TO_1K (RunningObjectSize)));
+        ("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",
+        RunningObjectCount,
+        ROUND_UP_TO_1K (RunningObjectSize)));
 
     ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-                    ("%30s: %4d (%3d Kb)\n", "Total (all) allocations",
-                    RunningAllocCount,
-                    ROUND_UP_TO_1K (RunningAllocSize)));
+        ("%30s: %4d (%3d Kb)\n", "Total (all) allocations",
+        RunningAllocCount,
+        ROUND_UP_TO_1K (RunningAllocSize)));
 
 
     ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-                    ("%30s: %4d (%3d Kb)\n", "Current Nodes",
-                    AcpiGbl_CurrentNodeCount,
-                    ROUND_UP_TO_1K (AcpiGbl_CurrentNodeSize)));
+        ("%30s: %4d (%3d Kb)\n", "Current Nodes",
+        AcpiGbl_CurrentNodeCount,
+        ROUND_UP_TO_1K (AcpiGbl_CurrentNodeSize)));
 
     ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-                    ("%30s: %4d (%3d Kb)\n", "Max Nodes",
-                    AcpiGbl_MaxConcurrentNodeCount,
-                    ROUND_UP_TO_1K ((AcpiGbl_MaxConcurrentNodeCount *
-                        sizeof (ACPI_NAMESPACE_NODE)))));
+        ("%30s: %4d (%3d Kb)\n", "Max Nodes",
+        AcpiGbl_MaxConcurrentNodeCount,
+        ROUND_UP_TO_1K ((AcpiGbl_MaxConcurrentNodeCount *
+            sizeof (ACPI_NAMESPACE_NODE)))));
 */
     return_VOID;
 }
@@ -566,7 +635,7 @@ AcpiUtDumpAllocationInfo (
  * FUNCTION:    AcpiUtDumpAllocations
  *
  * PARAMETERS:  Component           - Component(s) to dump info for.
- *              Module              - Module to dump info for.  NULL means all.
+ *              Module              - Module to dump info for. NULL means all.
  *
  * RETURN:      None
  *
@@ -590,7 +659,7 @@ AcpiUtDumpAllocations (
 
     if (AcpiGbl_DisableMemTracking)
     {
-        return;
+        return_VOID;
     }
 
     /*
@@ -598,16 +667,17 @@ AcpiUtDumpAllocations (
      */
     if (ACPI_FAILURE (AcpiUtAcquireMutex (ACPI_MTX_MEMORY)))
     {
-        return;
+        return_VOID;
     }
 
     Element = AcpiGbl_GlobalList->ListHead;
     while (Element)
     {
         if ((Element->Component & Component) &&
-            ((Module == NULL) || (0 == ACPI_STRCMP (Module, Element->Module))))
+            ((Module == NULL) || (0 == strcmp (Module, Element->Module))))
         {
-            Descriptor = ACPI_CAST_PTR (ACPI_DESCRIPTOR, &Element->UserSpace);
+            Descriptor = ACPI_CAST_PTR (
+                ACPI_DESCRIPTOR, &Element->UserSpace);
 
             if (Element->Size < sizeof (ACPI_COMMON_DESCRIPTOR))
             {
@@ -620,7 +690,8 @@ AcpiUtDumpAllocations (
             {
                 /* Ignore allocated objects that are in a cache */
 
-                if (ACPI_GET_DESCRIPTOR_TYPE (Descriptor) != ACPI_DESC_TYPE_CACHED)
+                if (ACPI_GET_DESCRIPTOR_TYPE (Descriptor) !=
+                    ACPI_DESC_TYPE_CACHED)
                 {
                     AcpiOsPrintf ("%p Length 0x%04X %9.9s-%u [%s] ",
                         Descriptor, Element->Size, Element->Module,
@@ -633,6 +704,7 @@ AcpiUtDumpAllocations (
                     switch (ACPI_GET_DESCRIPTOR_TYPE (Descriptor))
                     {
                     case ACPI_DESC_TYPE_OPERAND:
+
                         if (Element->Size == sizeof (ACPI_OPERAND_OBJECT))
                         {
                             DescriptorType = ACPI_DESC_TYPE_OPERAND;
@@ -640,6 +712,7 @@ AcpiUtDumpAllocations (
                         break;
 
                     case ACPI_DESC_TYPE_PARSER:
+
                         if (Element->Size == sizeof (ACPI_PARSE_OBJECT))
                         {
                             DescriptorType = ACPI_DESC_TYPE_PARSER;
@@ -647,6 +720,7 @@ AcpiUtDumpAllocations (
                         break;
 
                     case ACPI_DESC_TYPE_NAMED:
+
                         if (Element->Size == sizeof (ACPI_NAMESPACE_NODE))
                         {
                             DescriptorType = ACPI_DESC_TYPE_NAMED;
@@ -654,6 +728,7 @@ AcpiUtDumpAllocations (
                         break;
 
                     default:
+
                         break;
                     }
 
@@ -662,22 +737,26 @@ AcpiUtDumpAllocations (
                     switch (DescriptorType)
                     {
                     case ACPI_DESC_TYPE_OPERAND:
+
                         AcpiOsPrintf ("%12.12s  RefCount 0x%04X\n",
                             AcpiUtGetTypeName (Descriptor->Object.Common.Type),
                             Descriptor->Object.Common.ReferenceCount);
                         break;
 
                     case ACPI_DESC_TYPE_PARSER:
+
                         AcpiOsPrintf ("AmlOpcode 0x%04hX\n",
                             Descriptor->Op.Asl.AmlOpcode);
                         break;
 
                     case ACPI_DESC_TYPE_NAMED:
+
                         AcpiOsPrintf ("%4.4s\n",
                             AcpiUtGetNodeName (&Descriptor->Node));
                         break;
 
                     default:
+
                         AcpiOsPrintf ( "\n");
                         break;
                     }
@@ -696,7 +775,7 @@ AcpiUtDumpAllocations (
 
     if (!NumOutstanding)
     {
-        ACPI_INFO ((AE_INFO, "No outstanding allocations"));
+        ACPI_INFO (("No outstanding allocations"));
     }
     else
     {
@@ -708,4 +787,3 @@ AcpiUtDumpAllocations (
 }
 
 #endif  /* ACPI_DBG_TRACK_ALLOCATIONS */
-
diff --git a/usr/src/uts/intel/io/acpica/utilities/utuuid.c b/usr/src/uts/intel/io/acpica/utilities/utuuid.c
new file mode 100644
index 0000000000..df48912a23
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utuuid.c
@@ -0,0 +1,103 @@
+/******************************************************************************
+ *
+ * Module Name: utuuid -- UUID support functions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "acpi.h"
+#include "accommon.h"
+
+#define _COMPONENT          ACPI_COMPILER
+        ACPI_MODULE_NAME    ("utuuid")
+
+
+#if (defined ACPI_ASL_COMPILER || defined ACPI_EXEC_APP || defined ACPI_HELP_APP)
+/*
+ * UUID support functions.
+ *
+ * This table is used to convert an input UUID ascii string to a 16 byte
+ * buffer and the reverse. The table maps a UUID buffer index 0-15 to
+ * the index within the 36-byte UUID string where the associated 2-byte
+ * hex value can be found.
+ *
+ * 36-byte UUID strings are of the form:
+ *     aabbccdd-eeff-gghh-iijj-kkllmmnnoopp
+ * Where aa-pp are one byte hex numbers, made up of two hex digits
+ *
+ * Note: This table is basically the inverse of the string-to-offset table
+ * found in the ACPI spec in the description of the ToUUID macro.
+ */
+const UINT8    AcpiGbl_MapToUuidOffset[UUID_BUFFER_LENGTH] =
+{
+    6,4,2,0,11,9,16,14,19,21,24,26,28,30,32,34
+};
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiUtConvertStringToUuid
+ *
+ * PARAMETERS:  InString            - 36-byte formatted UUID string
+ *              UuidBuffer          - Where the 16-byte UUID buffer is returned
+ *
+ * RETURN:      None. Output data is returned in the UuidBuffer
+ *
+ * DESCRIPTION: Convert a 36-byte formatted UUID string to 16-byte UUID buffer
+ *
+ ******************************************************************************/
+
+void
+AcpiUtConvertStringToUuid (
+    char                    *InString,
+    UINT8                   *UuidBuffer)
+{
+    UINT32                  i;
+
+
+    for (i = 0; i < UUID_BUFFER_LENGTH; i++)
+    {
+        UuidBuffer[i] = (AcpiUtAsciiCharToHex (
+            InString[AcpiGbl_MapToUuidOffset[i]]) << 4);
+
+        UuidBuffer[i] |= AcpiUtAsciiCharToHex (
+            InString[AcpiGbl_MapToUuidOffset[i] + 1]);
+    }
+}
+#endif
diff --git a/usr/src/uts/intel/io/acpica/utilities/utxface.c b/usr/src/uts/intel/io/acpica/utilities/utxface.c
index 3e858c9b0f..a8452c3295 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utxface.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utxface.c
@@ -1,11 +1,11 @@
 /******************************************************************************
  *
- * Module Name: utxface - External interfaces for "global" ACPI functions
+ * Module Name: utxface - External interfaces, miscellaneous utility functions
  *
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,326 +41,16 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
-#define __UTXFACE_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
-#include "acevents.h"
-#include "acnamesp.h"
 #include "acdebug.h"
-#include "actables.h"
 
 #define _COMPONENT          ACPI_UTILITIES
         ACPI_MODULE_NAME    ("utxface")
 
 
-#ifndef ACPI_ASL_COMPILER
-/*******************************************************************************
- *
- * FUNCTION:    AcpiInitializeSubsystem
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Initializes all global variables.  This is the first function
- *              called, so any early initialization belongs here.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiInitializeSubsystem (
-    void)
-{
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_TRACE (AcpiInitializeSubsystem);
-
-
-    AcpiGbl_StartupFlags = ACPI_SUBSYSTEM_INITIALIZE;
-    ACPI_DEBUG_EXEC (AcpiUtInitStackPtrTrace ());
-
-    /* Initialize the OS-Dependent layer */
-
-    Status = AcpiOsInitialize ();
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_EXCEPTION ((AE_INFO, Status, "During OSL initialization"));
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Initialize all globals used by the subsystem */
-
-    Status = AcpiUtInitGlobals ();
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_EXCEPTION ((AE_INFO, Status, "During initialization of globals"));
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Create the default mutex objects */
-
-    Status = AcpiUtMutexInitialize ();
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_EXCEPTION ((AE_INFO, Status, "During Global Mutex creation"));
-        return_ACPI_STATUS (Status);
-    }
-
-    /*
-     * Initialize the namespace manager and
-     * the root of the namespace tree
-     */
-    Status = AcpiNsRootInitialize ();
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_EXCEPTION ((AE_INFO, Status, "During Namespace initialization"));
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Initialize the global OSI interfaces list with the static names */
-
-    Status = AcpiUtInitializeInterfaces ();
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_EXCEPTION ((AE_INFO, Status, "During OSI interfaces initialization"));
-        return_ACPI_STATUS (Status);
-    }
-
-    /* If configured, initialize the AML debugger */
-
-    ACPI_DEBUGGER_EXEC (Status = AcpiDbInitialize ());
-    return_ACPI_STATUS (Status);
-}
-
-ACPI_EXPORT_SYMBOL (AcpiInitializeSubsystem)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiEnableSubsystem
- *
- * PARAMETERS:  Flags           - Init/enable Options
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Completes the subsystem initialization including hardware.
- *              Puts system into ACPI mode if it isn't already.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiEnableSubsystem (
-    UINT32                  Flags)
-{
-    ACPI_STATUS             Status = AE_OK;
-
-
-    ACPI_FUNCTION_TRACE (AcpiEnableSubsystem);
-
-
-#if (!ACPI_REDUCED_HARDWARE)
-
-    /* Enable ACPI mode */
-
-    if (!(Flags & ACPI_NO_ACPI_ENABLE))
-    {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Going into ACPI mode\n"));
-
-        AcpiGbl_OriginalMode = AcpiHwGetMode();
-
-        Status = AcpiEnable ();
-        if (ACPI_FAILURE (Status))
-        {
-            ACPI_WARNING ((AE_INFO, "AcpiEnable failed"));
-            return_ACPI_STATUS (Status);
-        }
-    }
-
-    /*
-     * Obtain a permanent mapping for the FACS. This is required for the
-     * Global Lock and the Firmware Waking Vector
-     */
-    Status = AcpiTbInitializeFacs ();
-    if (ACPI_FAILURE (Status))
-    {
-        ACPI_WARNING ((AE_INFO, "Could not map the FACS table"));
-        return_ACPI_STATUS (Status);
-    }
-
-#endif /* !ACPI_REDUCED_HARDWARE */
-
-    /*
-     * Install the default OpRegion handlers.  These are installed unless
-     * other handlers have already been installed via the
-     * InstallAddressSpaceHandler interface.
-     */
-    if (!(Flags & ACPI_NO_ADDRESS_SPACE_INIT))
-    {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "[Init] Installing default address space handlers\n"));
-
-        Status = AcpiEvInstallRegionHandlers ();
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-    }
-
-#if (!ACPI_REDUCED_HARDWARE)
-    /*
-     * Initialize ACPI Event handling (Fixed and General Purpose)
-     *
-     * Note1: We must have the hardware and events initialized before we can
-     * execute any control methods safely. Any control method can require
-     * ACPI hardware support, so the hardware must be fully initialized before
-     * any method execution!
-     *
-     * Note2: Fixed events are initialized and enabled here. GPEs are
-     * initialized, but cannot be enabled until after the hardware is
-     * completely initialized (SCI and GlobalLock activated) and the various
-     * initialization control methods are run (_REG, _STA, _INI) on the
-     * entire namespace.
-     */
-    if (!(Flags & ACPI_NO_EVENT_INIT))
-    {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "[Init] Initializing ACPI events\n"));
-
-        Status = AcpiEvInitializeEvents ();
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-    }
-
-    /*
-     * Install the SCI handler and Global Lock handler. This completes the
-     * hardware initialization.
-     */
-    if (!(Flags & ACPI_NO_HANDLER_INIT))
-    {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "[Init] Installing SCI/GL handlers\n"));
-
-        Status = AcpiEvInstallXruptHandlers ();
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-    }
-
-#endif /* !ACPI_REDUCED_HARDWARE */
-
-    return_ACPI_STATUS (Status);
-}
-
-ACPI_EXPORT_SYMBOL (AcpiEnableSubsystem)
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiInitializeObjects
- *
- * PARAMETERS:  Flags           - Init/enable Options
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Completes namespace initialization by initializing device
- *              objects and executing AML code for Regions, buffers, etc.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiInitializeObjects (
-    UINT32                  Flags)
-{
-    ACPI_STATUS             Status = AE_OK;
-
-
-    ACPI_FUNCTION_TRACE (AcpiInitializeObjects);
-
-
-    /*
-     * Run all _REG methods
-     *
-     * Note: Any objects accessed by the _REG methods will be automatically
-     * initialized, even if they contain executable AML (see the call to
-     * AcpiNsInitializeObjects below).
-     */
-    if (!(Flags & ACPI_NO_ADDRESS_SPACE_INIT))
-    {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "[Init] Executing _REG OpRegion methods\n"));
-
-        Status = AcpiEvInitializeOpRegions ();
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-    }
-
-    /*
-     * Execute any module-level code that was detected during the table load
-     * phase. Although illegal since ACPI 2.0, there are many machines that
-     * contain this type of code. Each block of detected executable AML code
-     * outside of any control method is wrapped with a temporary control
-     * method object and placed on a global list. The methods on this list
-     * are executed below.
-     */
-    AcpiNsExecModuleCodeList ();
-
-    /*
-     * Initialize the objects that remain uninitialized. This runs the
-     * executable AML that may be part of the declaration of these objects:
-     * OperationRegions, BufferFields, Buffers, and Packages.
-     */
-    if (!(Flags & ACPI_NO_OBJECT_INIT))
-    {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "[Init] Completing Initialization of ACPI Objects\n"));
-
-        Status = AcpiNsInitializeObjects ();
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-    }
-
-    /*
-     * Initialize all device objects in the namespace. This runs the device
-     * _STA and _INI methods.
-     */
-    if (!(Flags & ACPI_NO_DEVICE_INIT))
-    {
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
-            "[Init] Initializing ACPI Devices\n"));
-
-        Status = AcpiNsInitializeDevices ();
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-    }
-
-    /*
-     * Empty the caches (delete the cached objects) on the assumption that
-     * the table load filled them up more than they will be at runtime --
-     * thus wasting non-paged memory.
-     */
-    Status = AcpiPurgeCachedObjects ();
-
-    AcpiGbl_StartupFlags |= ACPI_INITIALIZED_OK;
-    return_ACPI_STATUS (Status);
-}
-
-ACPI_EXPORT_SYMBOL (AcpiInitializeObjects)
-
-
-#endif
-
 /*******************************************************************************
  *
  * FUNCTION:    AcpiTerminate
@@ -383,24 +73,6 @@ AcpiTerminate (
     ACPI_FUNCTION_TRACE (AcpiTerminate);
 
 
-    /* Just exit if subsystem is already shutdown */
-
-    if (AcpiGbl_Shutdown)
-    {
-        ACPI_ERROR ((AE_INFO, "ACPI Subsystem is already terminated"));
-        return_ACPI_STATUS (AE_OK);
-    }
-
-    /* Subsystem appears active, go ahead and shut it down */
-
-    AcpiGbl_Shutdown = TRUE;
-    AcpiGbl_StartupFlags = 0;
-    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, "Shutting down ACPI Subsystem\n"));
-
-    /* Terminate the AML Debugger if present */
-
-    ACPI_DEBUGGER_EXEC (AcpiGbl_DbTerminateThreads = TRUE);
-
     /* Shutdown and free all resources */
 
     AcpiUtSubsystemShutdown ();
@@ -409,21 +81,13 @@ AcpiTerminate (
 
     AcpiUtMutexTerminate ();
 
-
-#ifdef ACPI_DEBUGGER
-
-    /* Shut down the debugger */
-
-    AcpiDbTerminate ();
-#endif
-
     /* Now we can shutdown the OS-dependent layer */
 
     Status = AcpiOsTerminate ();
     return_ACPI_STATUS (Status);
 }
 
-ACPI_EXPORT_SYMBOL (AcpiTerminate)
+ACPI_EXPORT_SYMBOL_INIT (AcpiTerminate)
 
 
 #ifndef ACPI_ASL_COMPILER
@@ -469,7 +133,7 @@ ACPI_EXPORT_SYMBOL (AcpiSubsystemStatus)
  * RETURN:      Status          - the status of the call
  *
  * DESCRIPTION: This function is called to get information about the current
- *              state of the ACPI subsystem.  It will return system information
+ *              state of the ACPI subsystem. It will return system information
  *              in the OutBuffer.
  *
  *              If the function fails an appropriate status will be returned
@@ -508,7 +172,6 @@ AcpiGetSystemInfo (
      * Populate the return buffer
      */
     InfoPtr = (ACPI_SYSTEM_INFO *) OutBuffer->Pointer;
-
     InfoPtr->AcpiCaVersion = ACPI_CA_VERSION;
 
     /* System flags (ACPI capabilities) */
@@ -573,14 +236,12 @@ AcpiGetStatistics (
     Stats->SciCount = AcpiSciCount;
     Stats->GpeCount = AcpiGpeCount;
 
-    ACPI_MEMCPY (Stats->FixedEventCount, AcpiFixedEventCount,
+    memcpy (Stats->FixedEventCount, AcpiFixedEventCount,
         sizeof (AcpiFixedEventCount));
 
-
     /* Other counters */
 
     Stats->MethodCount = AcpiMethodCount;
-
     return_ACPI_STATUS (AE_OK);
 }
 
@@ -619,7 +280,7 @@ AcpiInstallInitializationHandler (
     }
 
     AcpiGbl_InitHandler = Handler;
-    return AE_OK;
+    return (AE_OK);
 }
 
 ACPI_EXPORT_SYMBOL (AcpiInstallInitializationHandler)
@@ -643,10 +304,12 @@ AcpiPurgeCachedObjects (
 {
     ACPI_FUNCTION_TRACE (AcpiPurgeCachedObjects);
 
+
     (void) AcpiOsPurgeCache (AcpiGbl_StateCache);
     (void) AcpiOsPurgeCache (AcpiGbl_OperandCache);
     (void) AcpiOsPurgeCache (AcpiGbl_PsNodeCache);
     (void) AcpiOsPurgeCache (AcpiGbl_PsNodeExtCache);
+
     return_ACPI_STATUS (AE_OK);
 }
 
@@ -675,12 +338,16 @@ AcpiInstallInterface (
 
     /* Parameter validation */
 
-    if (!InterfaceName || (ACPI_STRLEN (InterfaceName) == 0))
+    if (!InterfaceName || (strlen (InterfaceName) == 0))
     {
         return (AE_BAD_PARAMETER);
     }
 
-    (void) AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    Status = AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
 
     /* Check if the interface name is already in the global list */
 
@@ -736,12 +403,16 @@ AcpiRemoveInterface (
 
     /* Parameter validation */
 
-    if (!InterfaceName || (ACPI_STRLEN (InterfaceName) == 0))
+    if (!InterfaceName || (strlen (InterfaceName) == 0))
     {
         return (AE_BAD_PARAMETER);
     }
 
-    (void) AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    Status = AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
 
     Status = AcpiUtRemoveInterface (InterfaceName);
 
@@ -771,10 +442,14 @@ ACPI_STATUS
 AcpiInstallInterfaceHandler (
     ACPI_INTERFACE_HANDLER  Handler)
 {
-    ACPI_STATUS             Status = AE_OK;
+    ACPI_STATUS             Status;
 
 
-    (void) AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    Status = AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
 
     if (Handler && AcpiGbl_InterfaceHandler)
     {
@@ -792,6 +467,40 @@ AcpiInstallInterfaceHandler (
 ACPI_EXPORT_SYMBOL (AcpiInstallInterfaceHandler)
 
 
+/*****************************************************************************
+ *
+ * FUNCTION:    AcpiUpdateInterfaces
+ *
+ * PARAMETERS:  Action              - Actions to be performed during the
+ *                                    update
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Update _OSI interface strings, disabling or enabling OS vendor
+ *              string or/and feature group strings.
+ *
+ ****************************************************************************/
+
+ACPI_STATUS
+AcpiUpdateInterfaces (
+    UINT8                   Action)
+{
+    ACPI_STATUS             Status;
+
+
+    Status = AcpiOsAcquireMutex (AcpiGbl_OsiMutex, ACPI_WAIT_FOREVER);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    Status = AcpiUtUpdateInterfaces (Action);
+
+    AcpiOsReleaseMutex (AcpiGbl_OsiMutex);
+    return (Status);
+}
+
+
 /*****************************************************************************
  *
  * FUNCTION:    AcpiCheckAddressRange
@@ -835,3 +544,100 @@ AcpiCheckAddressRange (
 ACPI_EXPORT_SYMBOL (AcpiCheckAddressRange)
 
 #endif /* !ACPI_ASL_COMPILER */
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiDecodePldBuffer
+ *
+ * PARAMETERS:  InBuffer            - Buffer returned by _PLD method
+ *              Length              - Length of the InBuffer
+ *              ReturnBuffer        - Where the decode buffer is returned
+ *
+ * RETURN:      Status and the decoded _PLD buffer. User must deallocate
+ *              the buffer via ACPI_FREE.
+ *
+ * DESCRIPTION: Decode the bit-packed buffer returned by the _PLD method into
+ *              a local struct that is much more useful to an ACPI driver.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiDecodePldBuffer (
+    UINT8                   *InBuffer,
+    ACPI_SIZE               Length,
+    ACPI_PLD_INFO           **ReturnBuffer)
+{
+    ACPI_PLD_INFO           *PldInfo;
+    UINT32                  *Buffer = ACPI_CAST_PTR (UINT32, InBuffer);
+    UINT32                  Dword;
+
+
+    /* Parameter validation */
+
+    if (!InBuffer || !ReturnBuffer || (Length < ACPI_PLD_REV1_BUFFER_SIZE))
+    {
+        return (AE_BAD_PARAMETER);
+    }
+
+    PldInfo = ACPI_ALLOCATE_ZEROED (sizeof (ACPI_PLD_INFO));
+    if (!PldInfo)
+    {
+        return (AE_NO_MEMORY);
+    }
+
+    /* First 32-bit DWord */
+
+    ACPI_MOVE_32_TO_32 (&Dword, &Buffer[0]);
+    PldInfo->Revision =             ACPI_PLD_GET_REVISION (&Dword);
+    PldInfo->IgnoreColor =          ACPI_PLD_GET_IGNORE_COLOR (&Dword);
+    PldInfo->Red =                  ACPI_PLD_GET_RED (&Dword);
+    PldInfo->Green =                ACPI_PLD_GET_GREEN (&Dword);
+    PldInfo->Blue =                 ACPI_PLD_GET_BLUE (&Dword);
+
+    /* Second 32-bit DWord */
+
+    ACPI_MOVE_32_TO_32 (&Dword, &Buffer[1]);
+    PldInfo->Width =                ACPI_PLD_GET_WIDTH (&Dword);
+    PldInfo->Height =               ACPI_PLD_GET_HEIGHT(&Dword);
+
+    /* Third 32-bit DWord */
+
+    ACPI_MOVE_32_TO_32 (&Dword, &Buffer[2]);
+    PldInfo->UserVisible =          ACPI_PLD_GET_USER_VISIBLE (&Dword);
+    PldInfo->Dock =                 ACPI_PLD_GET_DOCK (&Dword);
+    PldInfo->Lid =                  ACPI_PLD_GET_LID (&Dword);
+    PldInfo->Panel =                ACPI_PLD_GET_PANEL (&Dword);
+    PldInfo->VerticalPosition =     ACPI_PLD_GET_VERTICAL (&Dword);
+    PldInfo->HorizontalPosition =   ACPI_PLD_GET_HORIZONTAL (&Dword);
+    PldInfo->Shape =                ACPI_PLD_GET_SHAPE (&Dword);
+    PldInfo->GroupOrientation =     ACPI_PLD_GET_ORIENTATION (&Dword);
+    PldInfo->GroupToken =           ACPI_PLD_GET_TOKEN (&Dword);
+    PldInfo->GroupPosition =        ACPI_PLD_GET_POSITION (&Dword);
+    PldInfo->Bay =                  ACPI_PLD_GET_BAY (&Dword);
+
+    /* Fourth 32-bit DWord */
+
+    ACPI_MOVE_32_TO_32 (&Dword, &Buffer[3]);
+    PldInfo->Ejectable =            ACPI_PLD_GET_EJECTABLE (&Dword);
+    PldInfo->OspmEjectRequired =    ACPI_PLD_GET_OSPM_EJECT (&Dword);
+    PldInfo->CabinetNumber =        ACPI_PLD_GET_CABINET (&Dword);
+    PldInfo->CardCageNumber =       ACPI_PLD_GET_CARD_CAGE (&Dword);
+    PldInfo->Reference =            ACPI_PLD_GET_REFERENCE (&Dword);
+    PldInfo->Rotation =             ACPI_PLD_GET_ROTATION (&Dword);
+    PldInfo->Order =                ACPI_PLD_GET_ORDER (&Dword);
+
+    if (Length >= ACPI_PLD_REV2_BUFFER_SIZE)
+    {
+        /* Fifth 32-bit DWord (Revision 2 of _PLD) */
+
+        ACPI_MOVE_32_TO_32 (&Dword, &Buffer[4]);
+        PldInfo->VerticalOffset =       ACPI_PLD_GET_VERT_OFFSET (&Dword);
+        PldInfo->HorizontalOffset =     ACPI_PLD_GET_HORIZ_OFFSET (&Dword);
+    }
+
+    *ReturnBuffer = PldInfo;
+    return (AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL (AcpiDecodePldBuffer)
diff --git a/usr/src/uts/intel/io/acpica/utilities/utxferror.c b/usr/src/uts/intel/io/acpica/utilities/utxferror.c
index 8ffb274894..e79ffc94f3 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utxferror.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utxferror.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,11 +41,10 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTXFERROR_C__
+#define EXPORT_ACPI_INTERFACES
 
 #include "acpi.h"
 #include "accommon.h"
-#include "acnamesp.h"
 
 
 #define _COMPONENT          ACPI_UTILITIES
@@ -54,45 +53,9 @@
 /*
  * This module is used for the in-kernel ACPICA as well as the ACPICA
  * tools/applications.
- *
- * For the iASL compiler case, the output is redirected to stderr so that
- * any of the various ACPI errors and warnings do not appear in the output
- * files, for either the compiler or disassembler portions of the tool.
- */
-#ifdef ACPI_ASL_COMPILER
-#include <stdio.h>
-
-extern FILE                 *AcpiGbl_OutputFile;
-
-#define ACPI_MSG_REDIRECT_BEGIN \
-    FILE                    *OutputFile = AcpiGbl_OutputFile; \
-    AcpiOsRedirectOutput (stderr);
-
-#define ACPI_MSG_REDIRECT_END \
-    AcpiOsRedirectOutput (OutputFile);
-
-#else
-/*
- * non-iASL case - no redirection, nothing to do
- */
-#define ACPI_MSG_REDIRECT_BEGIN
-#define ACPI_MSG_REDIRECT_END
-#endif
-
-/*
- * Common message prefixes
- */
-#define ACPI_MSG_ERROR          "ACPI Error: "
-#define ACPI_MSG_EXCEPTION      "ACPI Exception: "
-#define ACPI_MSG_WARNING        "ACPI Warning: "
-#define ACPI_MSG_INFO           "ACPI: "
-
-/*
- * Common message suffix
  */
-#define ACPI_MSG_SUFFIX \
-    AcpiOsPrintf (" (%8.8X/%s-%u)\n", ACPI_CA_VERSION, ModuleName, LineNumber)
 
+#ifndef ACPI_NO_ERROR_MESSAGES /* Entire module */
 
 /*******************************************************************************
  *
@@ -160,7 +123,19 @@ AcpiException (
 
 
     ACPI_MSG_REDIRECT_BEGIN;
-    AcpiOsPrintf (ACPI_MSG_EXCEPTION "%s, ", AcpiFormatException (Status));
+
+    /* For AE_OK, just print the message */
+
+    if (ACPI_SUCCESS (Status))
+    {
+        AcpiOsPrintf (ACPI_MSG_EXCEPTION);
+
+    }
+    else
+    {
+        AcpiOsPrintf (ACPI_MSG_EXCEPTION "%s, ",
+            AcpiFormatException (Status));
+    }
 
     va_start (ArgList, Format);
     AcpiOsVprintf (Format, ArgList);
@@ -230,8 +205,6 @@ ACPI_EXPORT_SYMBOL (AcpiWarning)
 
 void ACPI_INTERNAL_VAR_XFACE
 AcpiInfo (
-    const char              *ModuleName,
-    UINT32                  LineNumber,
     const char              *Format,
     ...)
 {
@@ -252,227 +225,81 @@ AcpiInfo (
 ACPI_EXPORT_SYMBOL (AcpiInfo)
 
 
-/*
- * The remainder of this module contains internal error functions that may
- * be configured out.
- */
-#if !defined (ACPI_NO_ERROR_MESSAGES) && !defined (ACPI_BIN_APP)
-
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtPredefinedWarning
+ * FUNCTION:    AcpiBiosError
  *
- * PARAMETERS:  ModuleName      - Caller's module name (for error output)
- *              LineNumber      - Caller's line number (for error output)
- *              Pathname        - Full pathname to the node
- *              NodeFlags       - From Namespace node for the method/object
- *              Format          - Printf format string + additional args
+ * PARAMETERS:  ModuleName          - Caller's module name (for error output)
+ *              LineNumber          - Caller's line number (for error output)
+ *              Format              - Printf format string + additional args
  *
  * RETURN:      None
  *
- * DESCRIPTION: Warnings for the predefined validation module. Messages are
- *              only emitted the first time a problem with a particular
- *              method/object is detected. This prevents a flood of error
- *              messages for methods that are repeatedly evaluated.
+ * DESCRIPTION: Print "ACPI Firmware Error" message with module/line/version
+ *              info
  *
  ******************************************************************************/
 
 void ACPI_INTERNAL_VAR_XFACE
-AcpiUtPredefinedWarning (
+AcpiBiosError (
     const char              *ModuleName,
     UINT32                  LineNumber,
-    char                    *Pathname,
-    UINT8                   NodeFlags,
     const char              *Format,
     ...)
 {
     va_list                 ArgList;
 
 
-    /*
-     * Warning messages for this method/object will be disabled after the
-     * first time a validation fails or an object is successfully repaired.
-     */
-    if (NodeFlags & ANOBJ_EVALUATED)
-    {
-        return;
-    }
-
-    AcpiOsPrintf (ACPI_MSG_WARNING "For %s: ", Pathname);
+    ACPI_MSG_REDIRECT_BEGIN;
+    AcpiOsPrintf (ACPI_MSG_BIOS_ERROR);
 
     va_start (ArgList, Format);
     AcpiOsVprintf (Format, ArgList);
     ACPI_MSG_SUFFIX;
     va_end (ArgList);
+
+    ACPI_MSG_REDIRECT_END;
 }
 
+ACPI_EXPORT_SYMBOL (AcpiBiosError)
+
 
 /*******************************************************************************
  *
- * FUNCTION:    AcpiUtPredefinedInfo
+ * FUNCTION:    AcpiBiosWarning
  *
- * PARAMETERS:  ModuleName      - Caller's module name (for error output)
- *              LineNumber      - Caller's line number (for error output)
- *              Pathname        - Full pathname to the node
- *              NodeFlags       - From Namespace node for the method/object
- *              Format          - Printf format string + additional args
+ * PARAMETERS:  ModuleName          - Caller's module name (for error output)
+ *              LineNumber          - Caller's line number (for error output)
+ *              Format              - Printf format string + additional args
  *
  * RETURN:      None
  *
- * DESCRIPTION: Info messages for the predefined validation module. Messages
- *              are only emitted the first time a problem with a particular
- *              method/object is detected. This prevents a flood of
- *              messages for methods that are repeatedly evaluated.
+ * DESCRIPTION: Print "ACPI Firmware Warning" message with module/line/version
+ *              info
  *
  ******************************************************************************/
 
 void ACPI_INTERNAL_VAR_XFACE
-AcpiUtPredefinedInfo (
+AcpiBiosWarning (
     const char              *ModuleName,
     UINT32                  LineNumber,
-    char                    *Pathname,
-    UINT8                   NodeFlags,
     const char              *Format,
     ...)
 {
     va_list                 ArgList;
 
 
-    /*
-     * Warning messages for this method/object will be disabled after the
-     * first time a validation fails or an object is successfully repaired.
-     */
-    if (NodeFlags & ANOBJ_EVALUATED)
-    {
-        return;
-    }
-
-    AcpiOsPrintf (ACPI_MSG_INFO "For %s: ", Pathname);
+    ACPI_MSG_REDIRECT_BEGIN;
+    AcpiOsPrintf (ACPI_MSG_BIOS_WARNING);
 
     va_start (ArgList, Format);
     AcpiOsVprintf (Format, ArgList);
     ACPI_MSG_SUFFIX;
     va_end (ArgList);
-}
-
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtNamespaceError
- *
- * PARAMETERS:  ModuleName          - Caller's module name (for error output)
- *              LineNumber          - Caller's line number (for error output)
- *              InternalName        - Name or path of the namespace node
- *              LookupStatus        - Exception code from NS lookup
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print error message with the full pathname for the NS node.
- *
- ******************************************************************************/
 
-void
-AcpiUtNamespaceError (
-    const char              *ModuleName,
-    UINT32                  LineNumber,
-    const char              *InternalName,
-    ACPI_STATUS             LookupStatus)
-{
-    ACPI_STATUS             Status;
-    UINT32                  BadName;
-    char                    *Name = NULL;
-
-
-    ACPI_MSG_REDIRECT_BEGIN;
-    AcpiOsPrintf (ACPI_MSG_ERROR);
-
-    if (LookupStatus == AE_BAD_CHARACTER)
-    {
-        /* There is a non-ascii character in the name */
-
-        ACPI_MOVE_32_TO_32 (&BadName, ACPI_CAST_PTR (UINT32, InternalName));
-        AcpiOsPrintf ("[0x%4.4X] (NON-ASCII)", BadName);
-    }
-    else
-    {
-        /* Convert path to external format */
-
-        Status = AcpiNsExternalizeName (ACPI_UINT32_MAX,
-                    InternalName, NULL, &Name);
-
-        /* Print target name */
-
-        if (ACPI_SUCCESS (Status))
-        {
-            AcpiOsPrintf ("[%s]", Name);
-        }
-        else
-        {
-            AcpiOsPrintf ("[COULD NOT EXTERNALIZE NAME]");
-        }
-
-        if (Name)
-        {
-            ACPI_FREE (Name);
-        }
-    }
-
-    AcpiOsPrintf (" Namespace lookup failure, %s",
-        AcpiFormatException (LookupStatus));
-
-    ACPI_MSG_SUFFIX;
     ACPI_MSG_REDIRECT_END;
 }
 
-
-/*******************************************************************************
- *
- * FUNCTION:    AcpiUtMethodError
- *
- * PARAMETERS:  ModuleName          - Caller's module name (for error output)
- *              LineNumber          - Caller's line number (for error output)
- *              Message             - Error message to use on failure
- *              PrefixNode          - Prefix relative to the path
- *              Path                - Path to the node (optional)
- *              MethodStatus        - Execution status
- *
- * RETURN:      None
- *
- * DESCRIPTION: Print error message with the full pathname for the method.
- *
- ******************************************************************************/
-
-void
-AcpiUtMethodError (
-    const char              *ModuleName,
-    UINT32                  LineNumber,
-    const char              *Message,
-    ACPI_NAMESPACE_NODE     *PrefixNode,
-    const char              *Path,
-    ACPI_STATUS             MethodStatus)
-{
-    ACPI_STATUS             Status;
-    ACPI_NAMESPACE_NODE     *Node = PrefixNode;
-
-
-    ACPI_MSG_REDIRECT_BEGIN;
-    AcpiOsPrintf (ACPI_MSG_ERROR);
-
-    if (Path)
-    {
-        Status = AcpiNsGetNode (PrefixNode, Path, ACPI_NS_NO_UPSEARCH,
-                    &Node);
-        if (ACPI_FAILURE (Status))
-        {
-            AcpiOsPrintf ("[Could not get node by pathname]");
-        }
-    }
-
-    AcpiNsPrintNodePathname (Node, Message);
-    AcpiOsPrintf (", %s", AcpiFormatException (MethodStatus));
-
-    ACPI_MSG_SUFFIX;
-    ACPI_MSG_REDIRECT_END;
-}
+ACPI_EXPORT_SYMBOL (AcpiBiosWarning)
 
 #endif /* ACPI_NO_ERROR_MESSAGES */
diff --git a/usr/src/uts/intel/io/acpica/utilities/utxfinit.c b/usr/src/uts/intel/io/acpica/utilities/utxfinit.c
new file mode 100644
index 0000000000..2a518bc82d
--- /dev/null
+++ b/usr/src/uts/intel/io/acpica/utilities/utxfinit.c
@@ -0,0 +1,340 @@
+/******************************************************************************
+ *
+ * Module Name: utxfinit - External interfaces for ACPICA initialization
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#define EXPORT_ACPI_INTERFACES
+
+#include "acpi.h"
+#include "accommon.h"
+#include "acevents.h"
+#include "acnamesp.h"
+#include "acdebug.h"
+#include "actables.h"
+
+#define _COMPONENT          ACPI_UTILITIES
+        ACPI_MODULE_NAME    ("utxfinit")
+
+/* For AcpiExec only */
+void
+AeDoObjectOverrides (
+    void);
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiInitializeSubsystem
+ *
+ * PARAMETERS:  None
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Initializes all global variables. This is the first function
+ *              called, so any early initialization belongs here.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiInitializeSubsystem (
+    void)
+{
+    ACPI_STATUS             Status;
+
+
+    ACPI_FUNCTION_TRACE (AcpiInitializeSubsystem);
+
+
+    AcpiGbl_StartupFlags = ACPI_SUBSYSTEM_INITIALIZE;
+    ACPI_DEBUG_EXEC (AcpiUtInitStackPtrTrace ());
+
+    /* Initialize the OS-Dependent layer */
+
+    Status = AcpiOsInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_EXCEPTION ((AE_INFO, Status, "During OSL initialization"));
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Initialize all globals used by the subsystem */
+
+    Status = AcpiUtInitGlobals ();
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_EXCEPTION ((AE_INFO, Status, "During initialization of globals"));
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Create the default mutex objects */
+
+    Status = AcpiUtMutexInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_EXCEPTION ((AE_INFO, Status, "During Global Mutex creation"));
+        return_ACPI_STATUS (Status);
+    }
+
+    /*
+     * Initialize the namespace manager and
+     * the root of the namespace tree
+     */
+    Status = AcpiNsRootInitialize ();
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_EXCEPTION ((AE_INFO, Status, "During Namespace initialization"));
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Initialize the global OSI interfaces list with the static names */
+
+    Status = AcpiUtInitializeInterfaces ();
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_EXCEPTION ((AE_INFO, Status, "During OSI interfaces initialization"));
+        return_ACPI_STATUS (Status);
+    }
+
+    return_ACPI_STATUS (AE_OK);
+}
+
+ACPI_EXPORT_SYMBOL_INIT (AcpiInitializeSubsystem)
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiEnableSubsystem
+ *
+ * PARAMETERS:  Flags               - Init/enable Options
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Completes the subsystem initialization including hardware.
+ *              Puts system into ACPI mode if it isn't already.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiEnableSubsystem (
+    UINT32                  Flags)
+{
+    ACPI_STATUS             Status = AE_OK;
+
+
+    ACPI_FUNCTION_TRACE (AcpiEnableSubsystem);
+
+
+    /*
+     * The early initialization phase is complete. The namespace is loaded,
+     * and we can now support address spaces other than Memory, I/O, and
+     * PCI_Config.
+     */
+    AcpiGbl_EarlyInitialization = FALSE;
+
+#if (!ACPI_REDUCED_HARDWARE)
+
+    /* Enable ACPI mode */
+
+    if (!(Flags & ACPI_NO_ACPI_ENABLE))
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "[Init] Going into ACPI mode\n"));
+
+        AcpiGbl_OriginalMode = AcpiHwGetMode();
+
+        Status = AcpiEnable ();
+        if (ACPI_FAILURE (Status))
+        {
+            ACPI_WARNING ((AE_INFO, "AcpiEnable failed"));
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+    /*
+     * Obtain a permanent mapping for the FACS. This is required for the
+     * Global Lock and the Firmware Waking Vector
+     */
+    if (!(Flags & ACPI_NO_FACS_INIT))
+    {
+        Status = AcpiTbInitializeFacs ();
+        if (ACPI_FAILURE (Status))
+        {
+            ACPI_WARNING ((AE_INFO, "Could not map the FACS table"));
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+    /*
+     * Initialize ACPI Event handling (Fixed and General Purpose)
+     *
+     * Note1: We must have the hardware and events initialized before we can
+     * execute any control methods safely. Any control method can require
+     * ACPI hardware support, so the hardware must be fully initialized before
+     * any method execution!
+     *
+     * Note2: Fixed events are initialized and enabled here. GPEs are
+     * initialized, but cannot be enabled until after the hardware is
+     * completely initialized (SCI and GlobalLock activated) and the various
+     * initialization control methods are run (_REG, _STA, _INI) on the
+     * entire namespace.
+     */
+    if (!(Flags & ACPI_NO_EVENT_INIT))
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "[Init] Initializing ACPI events\n"));
+
+        Status = AcpiEvInitializeEvents ();
+        if (ACPI_FAILURE (Status))
+        {
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+    /*
+     * Install the SCI handler and Global Lock handler. This completes the
+     * hardware initialization.
+     */
+    if (!(Flags & ACPI_NO_HANDLER_INIT))
+    {
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            "[Init] Installing SCI/GL handlers\n"));
+
+        Status = AcpiEvInstallXruptHandlers ();
+        if (ACPI_FAILURE (Status))
+        {
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+#endif /* !ACPI_REDUCED_HARDWARE */
+
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL_INIT (AcpiEnableSubsystem)
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    AcpiInitializeObjects
+ *
+ * PARAMETERS:  Flags               - Init/enable Options
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Completes namespace initialization by initializing device
+ *              objects and executing AML code for Regions, buffers, etc.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiInitializeObjects (
+    UINT32                  Flags)
+{
+    ACPI_STATUS             Status = AE_OK;
+
+
+    ACPI_FUNCTION_TRACE (AcpiInitializeObjects);
+
+
+#ifdef ACPI_EXEC_APP
+    /*
+     * This call implements the "initialization file" option for AcpiExec.
+     * This is the precise point that we want to perform the overrides.
+     */
+    AeDoObjectOverrides ();
+#endif
+
+    /*
+     * Execute any module-level code that was detected during the table load
+     * phase. Although illegal since ACPI 2.0, there are many machines that
+     * contain this type of code. Each block of detected executable AML code
+     * outside of any control method is wrapped with a temporary control
+     * method object and placed on a global list. The methods on this list
+     * are executed below.
+     *
+     * This case executes the module-level code for all tables only after
+     * all of the tables have been loaded. It is a legacy option and is
+     * not compatible with other ACPI implementations. See AcpiNsLoadTable.
+     */
+    if (AcpiGbl_GroupModuleLevelCode)
+    {
+        AcpiNsExecModuleCodeList ();
+
+        /*
+         * Initialize the objects that remain uninitialized. This
+         * runs the executable AML that may be part of the
+         * declaration of these objects:
+         * OperationRegions, BufferFields, Buffers, and Packages.
+         */
+        if (!(Flags & ACPI_NO_OBJECT_INIT))
+        {
+            Status = AcpiNsInitializeObjects ();
+            if (ACPI_FAILURE (Status))
+            {
+                return_ACPI_STATUS (Status);
+            }
+        }
+    }
+
+    /*
+     * Initialize all device/region objects in the namespace. This runs
+     * the device _STA and _INI methods and region _REG methods.
+     */
+    if (!(Flags & (ACPI_NO_DEVICE_INIT | ACPI_NO_ADDRESS_SPACE_INIT)))
+    {
+        Status = AcpiNsInitializeDevices (Flags);
+        if (ACPI_FAILURE (Status))
+        {
+            return_ACPI_STATUS (Status);
+        }
+    }
+
+    /*
+     * Empty the caches (delete the cached objects) on the assumption that
+     * the table load filled them up more than they will be at runtime --
+     * thus wasting non-paged memory.
+     */
+    Status = AcpiPurgeCachedObjects ();
+
+    AcpiGbl_StartupFlags |= ACPI_INITIALIZED_OK;
+    return_ACPI_STATUS (Status);
+}
+
+ACPI_EXPORT_SYMBOL_INIT (AcpiInitializeObjects)
diff --git a/usr/src/uts/intel/io/acpica/utilities/utxfmutex.c b/usr/src/uts/intel/io/acpica/utilities/utxfmutex.c
index c4784310d3..f47fbe5546 100644
--- a/usr/src/uts/intel/io/acpica/utilities/utxfmutex.c
+++ b/usr/src/uts/intel/io/acpica/utilities/utxfmutex.c
@@ -5,7 +5,7 @@
  ******************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,8 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-#define __UTXFMUTEX_C__
-
 #include "acpi.h"
 #include "accommon.h"
 #include "acnamesp.h"
@@ -100,8 +98,8 @@ AcpiUtGetMutexObject (
     MutexNode = Handle;
     if (Pathname != NULL)
     {
-        Status = AcpiGetHandle (Handle, Pathname,
-            ACPI_CAST_PTR (ACPI_HANDLE, &MutexNode));
+        Status = AcpiGetHandle (
+            Handle, Pathname, ACPI_CAST_PTR (ACPI_HANDLE, &MutexNode));
         if (ACPI_FAILURE (Status))
         {
             return (Status);
diff --git a/usr/src/uts/intel/io/pci/pci_resource.c b/usr/src/uts/intel/io/pci/pci_resource.c
index 21ca552d91..a088deb456 100644
--- a/usr/src/uts/intel/io/pci/pci_resource.c
+++ b/usr/src/uts/intel/io/pci/pci_resource.c
@@ -22,6 +22,8 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  *
+ * Copyright 2016 Joyent, Inc.
+ *
  * pci_resource.c -- routines to retrieve available bus resources from
  *		 the MP Spec. Table and Hotplug Resource Table
  */
@@ -321,23 +323,23 @@ acpi_wr_cb(ACPI_RESOURCE *rp, void *context)
 		break;
 
 	case ACPI_RESOURCE_TYPE_ADDRESS16:
-		if (rp->Data.Address16.AddressLength == 0)
+		if (rp->Data.Address16.Address.AddressLength == 0)
 			break;
 		acpi_cb_cnt++;
 		memlist_insert(rlistpp(rp->Data.Address16.ResourceType,
 		    rp->Data.Address16.Info.TypeSpecific, bus),
-		    rp->Data.Address16.Minimum,
-		    rp->Data.Address16.AddressLength);
+		    rp->Data.Address16.Address.Minimum,
+		    rp->Data.Address16.Address.AddressLength);
 		break;
 
 	case ACPI_RESOURCE_TYPE_ADDRESS32:
-		if (rp->Data.Address32.AddressLength == 0)
+		if (rp->Data.Address32.Address.AddressLength == 0)
 			break;
 		acpi_cb_cnt++;
 		memlist_insert(rlistpp(rp->Data.Address32.ResourceType,
 		    rp->Data.Address32.Info.TypeSpecific, bus),
-		    rp->Data.Address32.Minimum,
-		    rp->Data.Address32.AddressLength);
+		    rp->Data.Address32.Address.Minimum,
+		    rp->Data.Address32.Address.AddressLength);
 		break;
 
 	case ACPI_RESOURCE_TYPE_ADDRESS64:
diff --git a/usr/src/uts/intel/pci_autoconfig/Makefile b/usr/src/uts/intel/pci_autoconfig/Makefile
index 94fdc98af0..afbf30e155 100644
--- a/usr/src/uts/intel/pci_autoconfig/Makefile
+++ b/usr/src/uts/intel/pci_autoconfig/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 #	This makefile drives the production of the PCI autoconfiguration
 #	kernel module.
 #
@@ -69,6 +71,8 @@ LINTTAGS	+= -erroff=E_BAD_PTR_CAST_ALIGN
 LINTTAGS	+= -erroff=E_ASSIGN_NARROW_CONV
 
 CERRWARN	+= -_gcc=-Wno-parentheses
+$(OBJS_DIR)/pci_boot.o :=	CERRWARN += -_gcc=-Wno-unused-function
+$(OBJS_DIR)/pci_resource.o :=	CERRWARN += -_gcc=-Wno-unused-function
 
 #
 #	Default build targets.
diff --git a/usr/src/uts/intel/power/Makefile b/usr/src/uts/intel/power/Makefile
index 363cf2407e..7765878b09 100644
--- a/usr/src/uts/intel/power/Makefile
+++ b/usr/src/uts/intel/power/Makefile
@@ -23,6 +23,8 @@
 # Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2016 Joyent, Inc.
+#
 
 #
 #	This makefile drives the production of the power driver
@@ -67,6 +69,8 @@ CFLAGS += $(CCVERBOSE)
 CFLAGS += -DACPI_POWER_BUTTON
 LINTFLAGS += -DACPI_POWER_BUTTON
 
+CERRWARN += -_gcc=-Wno-unused-function
+
 LDFLAGS += -dy -N misc/acpica
 
 #
diff --git a/usr/src/uts/intel/sys/acpi/acapps.h b/usr/src/uts/intel/sys/acpi/acapps.h
index 0382ca8547..87284f20b0 100644
--- a/usr/src/uts/intel/sys/acpi/acapps.h
+++ b/usr/src/uts/intel/sys/acpi/acapps.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -44,6 +44,7 @@
 #ifndef _ACAPPS
 #define _ACAPPS
 
+#include <stdio.h>
 
 #ifdef _MSC_VER                 /* disable some level-4 warnings */
 #pragma warning(disable:4100)   /* warning C4100: unreferenced formal parameter */
@@ -52,7 +53,7 @@
 /* Common info for tool signons */
 
 #define ACPICA_NAME                 "Intel ACPI Component Architecture"
-#define ACPICA_COPYRIGHT            "Copyright (c) 2000 - 2012 Intel Corporation"
+#define ACPICA_COPYRIGHT            "Copyright (c) 2000 - 2016 Intel Corporation"
 
 #if ACPI_MACHINE_WIDTH == 64
 #define ACPI_WIDTH          "-64"
@@ -69,29 +70,70 @@
 /* Macros for signons and file headers */
 
 #define ACPI_COMMON_SIGNON(UtilityName) \
-    "\n%s\n%s version %8.8X%s [%s]\n%s\n\n", \
+    "\n%s\n%s version %8.8X%s\n%s\n\n", \
     ACPICA_NAME, \
-    UtilityName, ((UINT32) ACPI_CA_VERSION), ACPI_WIDTH, __DATE__, \
+    UtilityName, ((UINT32) ACPI_CA_VERSION), ACPI_WIDTH, \
     ACPICA_COPYRIGHT
 
 #define ACPI_COMMON_HEADER(UtilityName, Prefix) \
-    "%s%s\n%s%s version %8.8X%s [%s]\n%s%s\n%s\n", \
+    "%s%s\n%s%s version %8.8X%s\n%s%s\n%s\n", \
     Prefix, ACPICA_NAME, \
-    Prefix, UtilityName, ((UINT32) ACPI_CA_VERSION), ACPI_WIDTH, __DATE__, \
+    Prefix, UtilityName, ((UINT32) ACPI_CA_VERSION), ACPI_WIDTH, \
     Prefix, ACPICA_COPYRIGHT, \
     Prefix
 
 /* Macros for usage messages */
 
 #define ACPI_USAGE_HEADER(Usage) \
-    printf ("Usage: %s\nOptions:\n", Usage);
+    AcpiOsPrintf ("Usage: %s\nOptions:\n", Usage);
+
+#define ACPI_USAGE_TEXT(Description) \
+    AcpiOsPrintf (Description);
 
 #define ACPI_OPTION(Name, Description) \
-    printf ("  %-18s%s\n", Name, Description);
+    AcpiOsPrintf ("  %-20s%s\n", Name, Description);
+
+
+/* Check for unexpected exceptions */
+
+#define ACPI_CHECK_STATUS(Name, Status, Expected) \
+    if (Status != Expected) \
+    { \
+        AcpiOsPrintf ("Unexpected %s from %s (%s-%d)\n", \
+            AcpiFormatException (Status), #Name, _AcpiModuleName, __LINE__); \
+    }
+
+/* Check for unexpected non-AE_OK errors */
+
 
+#define ACPI_CHECK_OK(Name, Status)   ACPI_CHECK_STATUS (Name, Status, AE_OK);
 
 #define FILE_SUFFIX_DISASSEMBLY     "dsl"
-#define ACPI_TABLE_FILE_SUFFIX      ".dat"
+#define FILE_SUFFIX_BINARY_TABLE    ".dat" /* Needs the dot */
+
+
+/* acfileio */
+
+ACPI_STATUS
+AcGetAllTablesFromFile (
+    char                    *Filename,
+    UINT8                   GetOnlyAmlTables,
+    ACPI_NEW_TABLE_DESC     **ReturnListHead);
+
+BOOLEAN
+AcIsFileBinary (
+    FILE                    *File);
+
+ACPI_STATUS
+AcValidateTableHeader (
+    FILE                    *File,
+    long                    TableOffset);
+
+
+/* Values for GetOnlyAmlTables */
+
+#define ACPI_GET_ONLY_AML_TABLES    TRUE
+#define ACPI_GET_ALL_TABLES         FALSE
 
 
 /*
@@ -103,55 +145,23 @@ AcpiGetopt(
     char                    **argv,
     char                    *opts);
 
+int
+AcpiGetoptArgument (
+    int                     argc,
+    char                    **argv);
+
 extern int                  AcpiGbl_Optind;
 extern int                  AcpiGbl_Opterr;
+extern int                  AcpiGbl_SubOptChar;
 extern char                 *AcpiGbl_Optarg;
 
 
 /*
- * adisasm
+ * cmfsize - Common get file size function
  */
-ACPI_STATUS
-AdAmlDisassemble (
-    BOOLEAN                 OutToFile,
-    char                    *Filename,
-    char                    *Prefix,
-    char                    **OutFilename,
-    BOOLEAN                 GetAllTables);
-
-void
-AdPrintStatistics (
-    void);
-
-ACPI_STATUS
-AdFindDsdt(
-    UINT8                   **DsdtPtr,
-    UINT32                  *DsdtLength);
-
-void
-AdDumpTables (
-    void);
-
-ACPI_STATUS
-AdGetLocalTables (
-    char                    *Filename,
-    BOOLEAN                 GetAllTables);
-
-ACPI_STATUS
-AdParseTable (
-    ACPI_TABLE_HEADER       *Table,
-    ACPI_OWNER_ID           *OwnerId,
-    BOOLEAN                 LoadTable,
-    BOOLEAN                 External);
-
-ACPI_STATUS
-AdDisplayTables (
-    char                    *Filename,
-    ACPI_TABLE_HEADER       *Table);
-
-ACPI_STATUS
-AdDisplayStatistics (
-    void);
+UINT32
+CmGetFileSize (
+    ACPI_FILE               File);
 
 
 /*
@@ -214,4 +224,3 @@ AdWriteTable (
     char                    *OemTableId);
 
 #endif /* _ACAPPS */
-
diff --git a/usr/src/uts/intel/sys/acpi/acbuffer.h b/usr/src/uts/intel/sys/acpi/acbuffer.h
new file mode 100644
index 0000000000..78f6db4a9e
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/acbuffer.h
@@ -0,0 +1,255 @@
+/******************************************************************************
+ *
+ * Name: acbuffer.h - Support for buffers returned by ACPI predefined names
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACBUFFER_H__
+#define __ACBUFFER_H__
+
+/*
+ * Contains buffer structures for these predefined names:
+ * _FDE, _GRT, _GTM, _PLD, _SRT
+ */
+
+/*
+ * Note: C bitfields are not used for this reason:
+ *
+ * "Bitfields are great and easy to read, but unfortunately the C language
+ * does not specify the layout of bitfields in memory, which means they are
+ * essentially useless for dealing with packed data in on-disk formats or
+ * binary wire protocols." (Or ACPI tables and buffers.) "If you ask me,
+ * this decision was a design error in C. Ritchie could have picked an order
+ * and stuck with it." Norman Ramsey.
+ * See http://stackoverflow.com/a/1053662/41661
+ */
+
+
+/* _FDE return value */
+
+typedef struct acpi_fde_info
+{
+    UINT32              Floppy0;
+    UINT32              Floppy1;
+    UINT32              Floppy2;
+    UINT32              Floppy3;
+    UINT32              Tape;
+
+} ACPI_FDE_INFO;
+
+/*
+ * _GRT return value
+ * _SRT input value
+ */
+typedef struct acpi_grt_info
+{
+    UINT16              Year;
+    UINT8               Month;
+    UINT8               Day;
+    UINT8               Hour;
+    UINT8               Minute;
+    UINT8               Second;
+    UINT8               Valid;
+    UINT16              Milliseconds;
+    UINT16              Timezone;
+    UINT8               Daylight;
+    UINT8               Reserved[3];
+
+} ACPI_GRT_INFO;
+
+/* _GTM return value */
+
+typedef struct acpi_gtm_info
+{
+    UINT32              PioSpeed0;
+    UINT32              DmaSpeed0;
+    UINT32              PioSpeed1;
+    UINT32              DmaSpeed1;
+    UINT32              Flags;
+
+} ACPI_GTM_INFO;
+
+/*
+ * Formatted _PLD return value. The minimum size is a package containing
+ * one buffer.
+ * Revision 1: Buffer is 16 bytes (128 bits)
+ * Revision 2: Buffer is 20 bytes (160 bits)
+ *
+ * Note: This structure is returned from the AcpiDecodePldBuffer
+ * interface.
+ */
+typedef struct acpi_pld_info
+{
+    UINT8               Revision;
+    UINT8               IgnoreColor;
+    UINT8               Red;
+    UINT8               Green;
+    UINT8               Blue;
+    UINT16              Width;
+    UINT16              Height;
+    UINT8               UserVisible;
+    UINT8               Dock;
+    UINT8               Lid;
+    UINT8               Panel;
+    UINT8               VerticalPosition;
+    UINT8               HorizontalPosition;
+    UINT8               Shape;
+    UINT8               GroupOrientation;
+    UINT8               GroupToken;
+    UINT8               GroupPosition;
+    UINT8               Bay;
+    UINT8               Ejectable;
+    UINT8               OspmEjectRequired;
+    UINT8               CabinetNumber;
+    UINT8               CardCageNumber;
+    UINT8               Reference;
+    UINT8               Rotation;
+    UINT8               Order;
+    UINT8               Reserved;
+    UINT16              VerticalOffset;
+    UINT16              HorizontalOffset;
+
+} ACPI_PLD_INFO;
+
+
+/*
+ * Macros to:
+ *     1) Convert a _PLD buffer to internal ACPI_PLD_INFO format - ACPI_PLD_GET*
+ *        (Used by AcpiDecodePldBuffer)
+ *     2) Construct a _PLD buffer - ACPI_PLD_SET*
+ *        (Intended for BIOS use only)
+ */
+#define ACPI_PLD_REV1_BUFFER_SIZE               16 /* For Revision 1 of the buffer (From ACPI spec) */
+#define ACPI_PLD_REV2_BUFFER_SIZE               20 /* For Revision 2 of the buffer (From ACPI spec) */
+#define ACPI_PLD_BUFFER_SIZE                    20 /* For Revision 2 of the buffer (From ACPI spec) */
+
+/* First 32-bit dword, bits 0:32 */
+
+#define ACPI_PLD_GET_REVISION(dword)            ACPI_GET_BITS (dword, 0, ACPI_7BIT_MASK)
+#define ACPI_PLD_SET_REVISION(dword,value)      ACPI_SET_BITS (dword, 0, ACPI_7BIT_MASK, value)     /* Offset 0, Len 7 */
+
+#define ACPI_PLD_GET_IGNORE_COLOR(dword)        ACPI_GET_BITS (dword, 7, ACPI_1BIT_MASK)
+#define ACPI_PLD_SET_IGNORE_COLOR(dword,value)  ACPI_SET_BITS (dword, 7, ACPI_1BIT_MASK, value)     /* Offset 7, Len 1 */
+
+#define ACPI_PLD_GET_RED(dword)                 ACPI_GET_BITS (dword, 8, ACPI_8BIT_MASK)
+#define ACPI_PLD_SET_RED(dword,value)           ACPI_SET_BITS (dword, 8, ACPI_8BIT_MASK, value)    /* Offset 8, Len 8 */
+
+#define ACPI_PLD_GET_GREEN(dword)               ACPI_GET_BITS (dword, 16, ACPI_8BIT_MASK)
+#define ACPI_PLD_SET_GREEN(dword,value)         ACPI_SET_BITS (dword, 16, ACPI_8BIT_MASK, value)    /* Offset 16, Len 8 */
+
+#define ACPI_PLD_GET_BLUE(dword)                ACPI_GET_BITS (dword, 24, ACPI_8BIT_MASK)
+#define ACPI_PLD_SET_BLUE(dword,value)          ACPI_SET_BITS (dword, 24, ACPI_8BIT_MASK, value)    /* Offset 24, Len 8 */
+
+/* Second 32-bit dword, bits 33:63 */
+
+#define ACPI_PLD_GET_WIDTH(dword)               ACPI_GET_BITS (dword, 0, ACPI_16BIT_MASK)
+#define ACPI_PLD_SET_WIDTH(dword,value)         ACPI_SET_BITS (dword, 0, ACPI_16BIT_MASK, value)    /* Offset 32+0=32, Len 16 */
+
+#define ACPI_PLD_GET_HEIGHT(dword)              ACPI_GET_BITS (dword, 16, ACPI_16BIT_MASK)
+#define ACPI_PLD_SET_HEIGHT(dword,value)        ACPI_SET_BITS (dword, 16, ACPI_16BIT_MASK, value)   /* Offset 32+16=48, Len 16 */
+
+/* Third 32-bit dword, bits 64:95 */
+
+#define ACPI_PLD_GET_USER_VISIBLE(dword)        ACPI_GET_BITS (dword, 0, ACPI_1BIT_MASK)
+#define ACPI_PLD_SET_USER_VISIBLE(dword,value)  ACPI_SET_BITS (dword, 0, ACPI_1BIT_MASK, value)     /* Offset 64+0=64, Len 1 */
+
+#define ACPI_PLD_GET_DOCK(dword)                ACPI_GET_BITS (dword, 1, ACPI_1BIT_MASK)
+#define ACPI_PLD_SET_DOCK(dword,value)          ACPI_SET_BITS (dword, 1, ACPI_1BIT_MASK, value)     /* Offset 64+1=65, Len 1 */
+
+#define ACPI_PLD_GET_LID(dword)                 ACPI_GET_BITS (dword, 2, ACPI_1BIT_MASK)
+#define ACPI_PLD_SET_LID(dword,value)           ACPI_SET_BITS (dword, 2, ACPI_1BIT_MASK, value)     /* Offset 64+2=66, Len 1 */
+
+#define ACPI_PLD_GET_PANEL(dword)               ACPI_GET_BITS (dword, 3, ACPI_3BIT_MASK)
+#define ACPI_PLD_SET_PANEL(dword,value)         ACPI_SET_BITS (dword, 3, ACPI_3BIT_MASK, value)     /* Offset 64+3=67, Len 3 */
+
+#define ACPI_PLD_GET_VERTICAL(dword)            ACPI_GET_BITS (dword, 6, ACPI_2BIT_MASK)
+#define ACPI_PLD_SET_VERTICAL(dword,value)      ACPI_SET_BITS (dword, 6, ACPI_2BIT_MASK, value)     /* Offset 64+6=70, Len 2 */
+
+#define ACPI_PLD_GET_HORIZONTAL(dword)          ACPI_GET_BITS (dword, 8, ACPI_2BIT_MASK)
+#define ACPI_PLD_SET_HORIZONTAL(dword,value)    ACPI_SET_BITS (dword, 8, ACPI_2BIT_MASK, value)     /* Offset 64+8=72, Len 2 */
+
+#define ACPI_PLD_GET_SHAPE(dword)               ACPI_GET_BITS (dword, 10, ACPI_4BIT_MASK)
+#define ACPI_PLD_SET_SHAPE(dword,value)         ACPI_SET_BITS (dword, 10, ACPI_4BIT_MASK, value)    /* Offset 64+10=74, Len 4 */
+
+#define ACPI_PLD_GET_ORIENTATION(dword)         ACPI_GET_BITS (dword, 14, ACPI_1BIT_MASK)
+#define ACPI_PLD_SET_ORIENTATION(dword,value)   ACPI_SET_BITS (dword, 14, ACPI_1BIT_MASK, value)    /* Offset 64+14=78, Len 1 */
+
+#define ACPI_PLD_GET_TOKEN(dword)               ACPI_GET_BITS (dword, 15, ACPI_8BIT_MASK)
+#define ACPI_PLD_SET_TOKEN(dword,value)         ACPI_SET_BITS (dword, 15, ACPI_8BIT_MASK, value)    /* Offset 64+15=79, Len 8 */
+
+#define ACPI_PLD_GET_POSITION(dword)            ACPI_GET_BITS (dword, 23, ACPI_8BIT_MASK)
+#define ACPI_PLD_SET_POSITION(dword,value)      ACPI_SET_BITS (dword, 23, ACPI_8BIT_MASK, value)    /* Offset 64+23=87, Len 8 */
+
+#define ACPI_PLD_GET_BAY(dword)                 ACPI_GET_BITS (dword, 31, ACPI_1BIT_MASK)
+#define ACPI_PLD_SET_BAY(dword,value)           ACPI_SET_BITS (dword, 31, ACPI_1BIT_MASK, value)    /* Offset 64+31=95, Len 1 */
+
+/* Fourth 32-bit dword, bits 96:127 */
+
+#define ACPI_PLD_GET_EJECTABLE(dword)           ACPI_GET_BITS (dword, 0, ACPI_1BIT_MASK)
+#define ACPI_PLD_SET_EJECTABLE(dword,value)     ACPI_SET_BITS (dword, 0, ACPI_1BIT_MASK, value)     /* Offset 96+0=96, Len 1 */
+
+#define ACPI_PLD_GET_OSPM_EJECT(dword)          ACPI_GET_BITS (dword, 1, ACPI_1BIT_MASK)
+#define ACPI_PLD_SET_OSPM_EJECT(dword,value)    ACPI_SET_BITS (dword, 1, ACPI_1BIT_MASK, value)     /* Offset 96+1=97, Len 1 */
+
+#define ACPI_PLD_GET_CABINET(dword)             ACPI_GET_BITS (dword, 2, ACPI_8BIT_MASK)
+#define ACPI_PLD_SET_CABINET(dword,value)       ACPI_SET_BITS (dword, 2, ACPI_8BIT_MASK, value)     /* Offset 96+2=98, Len 8 */
+
+#define ACPI_PLD_GET_CARD_CAGE(dword)           ACPI_GET_BITS (dword, 10, ACPI_8BIT_MASK)
+#define ACPI_PLD_SET_CARD_CAGE(dword,value)     ACPI_SET_BITS (dword, 10, ACPI_8BIT_MASK, value)    /* Offset 96+10=106, Len 8 */
+
+#define ACPI_PLD_GET_REFERENCE(dword)           ACPI_GET_BITS (dword, 18, ACPI_1BIT_MASK)
+#define ACPI_PLD_SET_REFERENCE(dword,value)     ACPI_SET_BITS (dword, 18, ACPI_1BIT_MASK, value)    /* Offset 96+18=114, Len 1 */
+
+#define ACPI_PLD_GET_ROTATION(dword)            ACPI_GET_BITS (dword, 19, ACPI_4BIT_MASK)
+#define ACPI_PLD_SET_ROTATION(dword,value)      ACPI_SET_BITS (dword, 19, ACPI_4BIT_MASK, value)    /* Offset 96+19=115, Len 4 */
+
+#define ACPI_PLD_GET_ORDER(dword)               ACPI_GET_BITS (dword, 23, ACPI_5BIT_MASK)
+#define ACPI_PLD_SET_ORDER(dword,value)         ACPI_SET_BITS (dword, 23, ACPI_5BIT_MASK, value)    /* Offset 96+23=119, Len 5 */
+
+/* Fifth 32-bit dword, bits 128:159 (Revision 2 of _PLD only) */
+
+#define ACPI_PLD_GET_VERT_OFFSET(dword)         ACPI_GET_BITS (dword, 0, ACPI_16BIT_MASK)
+#define ACPI_PLD_SET_VERT_OFFSET(dword,value)   ACPI_SET_BITS (dword, 0, ACPI_16BIT_MASK, value)    /* Offset 128+0=128, Len 16 */
+
+#define ACPI_PLD_GET_HORIZ_OFFSET(dword)        ACPI_GET_BITS (dword, 16, ACPI_16BIT_MASK)
+#define ACPI_PLD_SET_HORIZ_OFFSET(dword,value)  ACPI_SET_BITS (dword, 16, ACPI_16BIT_MASK, value)   /* Offset 128+16=144, Len 16 */
+
+
+#endif /* ACBUFFER_H */
diff --git a/usr/src/uts/intel/sys/acpi/acclib.h b/usr/src/uts/intel/sys/acpi/acclib.h
new file mode 100644
index 0000000000..56a30723ae
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/acclib.h
@@ -0,0 +1,167 @@
+/******************************************************************************
+ *
+ * Name: acclib.h -- C library support. Prototypes for the (optional) local
+ *                   implementations of required C library functions.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef _ACCLIB_H
+#define _ACCLIB_H
+
+
+/*
+ * Prototypes and macros for local implementations of C library functions
+ */
+
+/* is* functions. The AcpiGbl_Ctypes array is defined in utclib.c */
+
+extern const UINT8 AcpiGbl_Ctypes[];
+
+#define _ACPI_XA     0x00    /* extra alphabetic - not supported */
+#define _ACPI_XS     0x40    /* extra space */
+#define _ACPI_BB     0x00    /* BEL, BS, etc. - not supported */
+#define _ACPI_CN     0x20    /* CR, FF, HT, NL, VT */
+#define _ACPI_DI     0x04    /* '0'-'9' */
+#define _ACPI_LO     0x02    /* 'a'-'z' */
+#define _ACPI_PU     0x10    /* punctuation */
+#define _ACPI_SP     0x08    /* space, tab, CR, LF, VT, FF */
+#define _ACPI_UP     0x01    /* 'A'-'Z' */
+#define _ACPI_XD     0x80    /* '0'-'9', 'A'-'F', 'a'-'f' */
+
+#define isdigit(c)  (AcpiGbl_Ctypes[(unsigned char)(c)] & (_ACPI_DI))
+#define isspace(c)  (AcpiGbl_Ctypes[(unsigned char)(c)] & (_ACPI_SP))
+#define isxdigit(c) (AcpiGbl_Ctypes[(unsigned char)(c)] & (_ACPI_XD))
+#define isupper(c)  (AcpiGbl_Ctypes[(unsigned char)(c)] & (_ACPI_UP))
+#define islower(c)  (AcpiGbl_Ctypes[(unsigned char)(c)] & (_ACPI_LO))
+#define isprint(c)  (AcpiGbl_Ctypes[(unsigned char)(c)] & (_ACPI_LO | _ACPI_UP | _ACPI_DI | _ACPI_XS | _ACPI_PU))
+#define isalpha(c)  (AcpiGbl_Ctypes[(unsigned char)(c)] & (_ACPI_LO | _ACPI_UP))
+
+
+/* Strings */
+
+char *
+strcat (
+    char                    *DstString,
+    const char              *SrcString);
+
+char *
+strchr (
+    const char              *String,
+    int                     ch);
+
+char *
+strcpy (
+    char                    *DstString,
+    const char              *SrcString);
+
+int
+strcmp (
+    const char              *String1,
+    const char              *String2);
+
+ACPI_SIZE
+strlen (
+    const char              *String);
+
+char *
+strncat (
+    char                    *DstString,
+    const char              *SrcString,
+    ACPI_SIZE               Count);
+
+int
+strncmp (
+    const char              *String1,
+    const char              *String2,
+    ACPI_SIZE               Count);
+
+char *
+strncpy (
+    char                    *DstString,
+    const char              *SrcString,
+    ACPI_SIZE               Count);
+
+char *
+strstr (
+    char                    *String1,
+    char                    *String2);
+
+
+/* Conversion */
+
+UINT32
+strtoul (
+    const char              *String,
+    char                    **Terminator,
+    UINT32                  Base);
+
+
+/* Memory */
+
+int
+memcmp (
+    void                    *Buffer1,
+    void                    *Buffer2,
+    ACPI_SIZE               Count);
+
+void *
+memcpy (
+    void                    *Dest,
+    const void              *Src,
+    ACPI_SIZE               Count);
+
+void *
+memset (
+    void                    *Dest,
+    int                     Value,
+    ACPI_SIZE               Count);
+
+
+/* upper/lower case */
+
+int
+tolower (
+    int                     c);
+
+int
+toupper (
+    int                     c);
+
+#endif /* _ACCLIB_H */
diff --git a/usr/src/uts/intel/sys/acpi/accommon.h b/usr/src/uts/intel/sys/acpi/accommon.h
index 7e6d05aa8d..02e6f51396 100644
--- a/usr/src/uts/intel/sys/acpi/accommon.h
+++ b/usr/src/uts/intel/sys/acpi/accommon.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -59,6 +59,9 @@
 #include "acglobal.h"           /* All global variables */
 #include "achware.h"            /* Hardware defines and interfaces */
 #include "acutils.h"            /* Utility interfaces */
+#ifndef ACPI_USE_SYSTEM_CLIBRARY
+#include "acclib.h"             /* C library interfaces */
+#endif /* !ACPI_USE_SYSTEM_CLIBRARY */
 
 
 #endif /* __ACCOMMON_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/acconfig.h b/usr/src/uts/intel/sys/acpi/acconfig.h
index 7880516e47..a626f87591 100644
--- a/usr/src/uts/intel/sys/acpi/acconfig.h
+++ b/usr/src/uts/intel/sys/acpi/acconfig.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -53,8 +53,8 @@
 
 /*
  * ACPI_DEBUG_OUTPUT    - This switch enables all the debug facilities of the
- *                        ACPI subsystem.  This includes the DEBUG_PRINT output
- *                        statements.  When disabled, all DEBUG_PRINT
+ *                        ACPI subsystem. This includes the DEBUG_PRINT output
+ *                        statements. When disabled, all DEBUG_PRINT
  *                        statements are compiled out.
  *
  * ACPI_APPLICATION     - Use this switch if the subsystem is going to be run
@@ -63,12 +63,12 @@
  */
 
 /*
- * OS name, used for the _OS object.  The _OS object is essentially obsolete,
+ * OS name, used for the _OS object. The _OS object is essentially obsolete,
  * but there is a large base of ASL/AML code in existing machines that check
- * for the string below.  The use of this string usually guarantees that
- * the ASL will execute down the most tested code path.  Also, there is some
+ * for the string below. The use of this string usually guarantees that
+ * the ASL will execute down the most tested code path. Also, there is some
  * code that will not execute the _OSI method unless _OS matches the string
- * below.  Therefore, change this string at your own risk.
+ * below. Therefore, change this string at your own risk.
  */
 #define ACPI_OS_NAME                    "Microsoft Windows NT"
 
@@ -84,7 +84,9 @@
  * Should the subsystem abort the loading of an ACPI table if the
  * table checksum is incorrect?
  */
+#ifndef ACPI_CHECKSUM_ABORT
 #define ACPI_CHECKSUM_ABORT             FALSE
+#endif
 
 /*
  * Generate a version of ACPICA that only supports "reduced hardware"
@@ -101,7 +103,9 @@
  *      ACPI PM timer
  *      FACS table (Waking vectors and Global Lock)
  */
+#ifndef ACPI_REDUCED_HARDWARE
 #define ACPI_REDUCED_HARDWARE           FALSE
+#endif
 
 
 /******************************************************************************
@@ -134,10 +138,6 @@
 
 #define ACPI_ROOT_TABLE_SIZE_INCREMENT  4
 
-/* Maximum number of While() loop iterations before forced abort */
-
-#define ACPI_MAX_LOOP_ITERATIONS        0xFFFF
-
 /* Maximum sleep allowed via Sleep() operator */
 
 #define ACPI_MAX_SLEEP                  2000    /* 2000 millisec == two seconds */
@@ -194,8 +194,9 @@
 /* Maximum SpaceIds for Operation Regions */
 
 #define ACPI_MAX_ADDRESS_SPACE          255
+#define ACPI_NUM_DEFAULT_SPACES         4
 
-/* Array sizes.  Used for range checking also */
+/* Array sizes. Used for range checking also */
 
 #define ACPI_MAX_MATCH_OPCODE           5
 
@@ -216,13 +217,32 @@
 #define ACPI_NUM_SxW_METHODS            5
 
 
+/******************************************************************************
+ *
+ * Miscellaneous constants
+ *
+ *****************************************************************************/
+
+/* UUID constants */
+
+#define UUID_BUFFER_LENGTH          16 /* Length of UUID in memory */
+#define UUID_STRING_LENGTH          36 /* Total length of a UUID string */
+
+/* Positions for required hyphens (dashes) in UUID strings */
+
+#define UUID_HYPHEN1_OFFSET         8
+#define UUID_HYPHEN2_OFFSET         13
+#define UUID_HYPHEN3_OFFSET         18
+#define UUID_HYPHEN4_OFFSET         23
+
+
 /******************************************************************************
  *
  * ACPI AML Debugger
  *
  *****************************************************************************/
 
-#define ACPI_DEBUGGER_MAX_ARGS          ACPI_METHOD_NUM_ARGS + 2 /* Max command line arguments */
+#define ACPI_DEBUGGER_MAX_ARGS          ACPI_METHOD_NUM_ARGS + 4 /* Max command line arguments */
 #define ACPI_DB_LINE_BUFFER_SIZE        512
 
 #define ACPI_DEBUGGER_COMMAND_PROMPT    '-'
@@ -230,4 +250,3 @@
 
 
 #endif /* _ACCONFIG_H */
-
diff --git a/usr/src/uts/intel/sys/acpi/acdebug.h b/usr/src/uts/intel/sys/acpi/acdebug.h
index bcc505c8d5..8f3f47175b 100644
--- a/usr/src/uts/intel/sys/acpi/acdebug.h
+++ b/usr/src/uts/intel/sys/acpi/acdebug.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -44,34 +44,45 @@
 #ifndef __ACDEBUG_H__
 #define __ACDEBUG_H__
 
+/* The debugger is used in conjunction with the disassembler most of time */
+
+#ifdef ACPI_DISASSEMBLER
+#include "acdisasm.h"
+#endif
+
 
 #define ACPI_DEBUG_BUFFER_SIZE  0x4000      /* 16K buffer for return objects */
 
-typedef struct CommandInfo
+typedef struct acpi_db_command_info
 {
-    char                    *Name;          /* Command Name */
+    const char              *Name;          /* Command Name */
     UINT8                   MinArgs;        /* Minimum arguments required */
 
-} COMMAND_INFO;
+} ACPI_DB_COMMAND_INFO;
 
-typedef struct ArgumentInfo
+typedef struct acpi_db_command_help
 {
-    char                    *Name;          /* Argument Name */
+    UINT8                   LineCount;      /* Number of help lines */
+    char                    *Invocation;    /* Command Invocation */
+    char                    *Description;   /* Command Description */
 
-} ARGUMENT_INFO;
+} ACPI_DB_COMMAND_HELP;
 
-typedef struct acpi_execute_walk
+typedef struct acpi_db_argument_info
+{
+    const char              *Name;          /* Argument Name */
+
+} ACPI_DB_ARGUMENT_INFO;
+
+typedef struct acpi_db_execute_walk
 {
     UINT32                  Count;
     UINT32                  MaxCount;
 
-} ACPI_EXECUTE_WALK;
+} ACPI_DB_EXECUTE_WALK;
 
 
 #define PARAM_LIST(pl)                  pl
-#define DBTEST_OUTPUT_LEVEL(lvl)        if (AcpiGbl_DbOpt_verbose)
-#define VERBOSE_PRINT(fp)               DBTEST_OUTPUT_LEVEL(lvl) {\
-                                            AcpiOsPrintf PARAM_LIST(fp);}
 
 #define EX_NO_SINGLE_STEP               1
 #define EX_SINGLE_STEP                  2
@@ -80,19 +91,17 @@ typedef struct acpi_execute_walk
 /*
  * dbxface - external debugger interfaces
  */
-ACPI_STATUS
-AcpiDbInitialize (
-    void);
-
-void
-AcpiDbTerminate (
-    void);
-
+ACPI_DBR_DEPENDENT_RETURN_OK (
 ACPI_STATUS
 AcpiDbSingleStep (
     ACPI_WALK_STATE         *WalkState,
     ACPI_PARSE_OBJECT       *Op,
-    UINT32                  OpType);
+    UINT32                  OpType))
+
+ACPI_DBR_DEPENDENT_RETURN_VOID (
+void
+AcpiDbSignalBreakPoint (
+    ACPI_WALK_STATE         *WalkState))
 
 
 /*
@@ -112,8 +121,7 @@ AcpiDbDisplayTemplate (
 
 void
 AcpiDbUnloadAcpiTable (
-    char                    *TableArg,
-    char                    *InstanceArg);
+    char                    *Name);
 
 void
 AcpiDbSendNotify (
@@ -129,6 +137,12 @@ ACPI_STATUS
 AcpiDbSleep (
     char                    *ObjectArg);
 
+void
+AcpiDbTrace (
+    char                    *EnableArg,
+    char                    *MethodArg,
+    char                    *OnceArg);
+
 void
 AcpiDbDisplayLocks (
     void);
@@ -152,6 +166,43 @@ AcpiDbGenerateGpe (
     char                    *GpeArg,
     char                    *BlockArg))
 
+ACPI_HW_DEPENDENT_RETURN_VOID (
+void
+AcpiDbGenerateSci (
+    void))
+
+void
+AcpiDbExecuteTest (
+    char                    *TypeArg);
+
+
+/*
+ * dbconvert - miscellaneous conversion routines
+ */
+ACPI_STATUS
+AcpiDbHexCharToValue (
+    int                     HexChar,
+    UINT8                   *ReturnValue);
+
+ACPI_STATUS
+AcpiDbConvertToPackage (
+    char                    *String,
+    ACPI_OBJECT             *Object);
+
+ACPI_STATUS
+AcpiDbConvertToObject (
+    ACPI_OBJECT_TYPE        Type,
+    char                    *String,
+    ACPI_OBJECT             *Object);
+
+UINT8 *
+AcpiDbEncodePldBuffer (
+    ACPI_PLD_INFO           *PldInfo);
+
+void
+AcpiDbDumpPldBuffer (
+    ACPI_OBJECT             *ObjDesc);
+
 
 /*
  * dbmethod - control method commands
@@ -198,6 +249,10 @@ AcpiDbDumpNamespace (
     char                    *StartArg,
     char                    *DepthArg);
 
+void
+AcpiDbDumpNamespacePaths (
+    void);
+
 void
 AcpiDbDumpNamespaceByOwner (
     char                    *OwnerArg,
@@ -241,10 +296,11 @@ AcpiDbDecodeAndDisplayObject (
     char                    *Target,
     char                    *OutputType);
 
+ACPI_DBR_DEPENDENT_RETURN_VOID (
 void
 AcpiDbDisplayResultObject (
     ACPI_OPERAND_OBJECT     *ObjDesc,
-    ACPI_WALK_STATE         *WalkState);
+    ACPI_WALK_STATE         *WalkState))
 
 ACPI_STATUS
 AcpiDbDisplayAllMethods (
@@ -270,10 +326,11 @@ void
 AcpiDbDisplayObjectType (
     char                    *ObjectArg);
 
+ACPI_DBR_DEPENDENT_RETURN_VOID (
 void
 AcpiDbDisplayArgumentObject (
     ACPI_OPERAND_OBJECT     *ObjDesc,
-    ACPI_WALK_STATE         *WalkState);
+    ACPI_WALK_STATE         *WalkState))
 
 
 /*
@@ -292,6 +349,11 @@ AcpiDbCreateExecutionThreads (
     char                    *NumLoopsArg,
     char                    *MethodNameArg);
 
+void
+AcpiDbDeleteObjects (
+    UINT32                  Count,
+    ACPI_OBJECT             *Objects);
+
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
 UINT32
 AcpiDbGetCacheInfo (
@@ -305,7 +367,7 @@ AcpiDbGetCacheInfo (
 ACPI_OBJECT_TYPE
 AcpiDbMatchArgument (
     char                    *UserArgument,
-    ARGUMENT_INFO           *Arguments);
+    ACPI_DB_ARGUMENT_INFO   *Arguments);
 
 void
 AcpiDbCloseDebugFile (
@@ -320,14 +382,8 @@ AcpiDbLoadAcpiTable (
     char                    *Filename);
 
 ACPI_STATUS
-AcpiDbGetTableFromFile (
-    char                    *Filename,
-    ACPI_TABLE_HEADER       **Table);
-
-ACPI_STATUS
-AcpiDbReadTableFromFile (
-    char                    *Filename,
-    ACPI_TABLE_HEADER       **Table);
+AcpiDbLoadTables (
+    ACPI_NEW_TABLE_DESC     *ListHead);
 
 
 /*
@@ -345,6 +401,10 @@ char *
 AcpiDbGetFromHistory (
     char                    *CommandNumArg);
 
+char *
+AcpiDbGetHistoryByIndex (
+    UINT32                  CommanddNum);
+
 
 /*
  * dbinput - user front-end to the AML debugger
@@ -371,6 +431,32 @@ AcpiDbGetNextToken (
     ACPI_OBJECT_TYPE        *ReturnType);
 
 
+/*
+ * dbobject
+ */
+void
+AcpiDbDecodeInternalObject (
+    ACPI_OPERAND_OBJECT     *ObjDesc);
+
+void
+AcpiDbDisplayInternalObject (
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_WALK_STATE         *WalkState);
+
+void
+AcpiDbDecodeArguments (
+    ACPI_WALK_STATE         *WalkState);
+
+void
+AcpiDbDecodeLocals (
+    ACPI_WALK_STATE         *WalkState);
+
+void
+AcpiDbDumpMethodInfo (
+    ACPI_STATUS             Status,
+    ACPI_WALK_STATE         *WalkState);
+
+
 /*
  * dbstats - Generation and display of ACPI table statistics
  */
@@ -405,7 +491,7 @@ AcpiDbLocalNsLookup (
     char                    *Name);
 
 void
-AcpiDbUInt32ToHexString (
+AcpiDbUint32ToHexString (
     UINT32                  Value,
     char                    *Buffer);
 
diff --git a/usr/src/uts/intel/sys/acpi/acdisasm.h b/usr/src/uts/intel/sys/acpi/acdisasm.h
index 9ec12713b4..545622d4ec 100644
--- a/usr/src/uts/intel/sys/acpi/acdisasm.h
+++ b/usr/src/uts/intel/sys/acpi/acdisasm.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -60,7 +60,7 @@
 #define ACPI_RAW_TABLE_DATA_HEADER      "Raw Table Data"
 
 
-typedef const struct acpi_dmtable_info
+typedef struct acpi_dmtable_info
 {
     UINT8                       Opcode;
     UINT16                      Offset;
@@ -69,14 +69,14 @@ typedef const struct acpi_dmtable_info
 
 } ACPI_DMTABLE_INFO;
 
+/* Values for Flags field above */
+
 #define DT_LENGTH                       0x01    /* Field is a subtable length */
 #define DT_FLAG                         0x02    /* Field is a flag value */
 #define DT_NON_ZERO                     0x04    /* Field must be non-zero */
-
-/* TBD: Not used at this time */
-
-#define DT_OPTIONAL                     0x08
-#define DT_COUNT                        0x10
+#define DT_OPTIONAL                     0x08    /* Field is optional */
+#define DT_DESCRIBES_OPTIONAL           0x10    /* Field describes an optional field (length, etc.) */
+#define DT_COUNT                        0x20    /* Currently not used */
 
 /*
  * Values for Opcode above.
@@ -108,6 +108,7 @@ typedef enum
     ACPI_DMT_UINT56,
     ACPI_DMT_UINT64,
     ACPI_DMT_BUF7,
+    ACPI_DMT_BUF10,
     ACPI_DMT_BUF16,
     ACPI_DMT_BUF128,
     ACPI_DMT_SIG,
@@ -128,6 +129,7 @@ typedef enum
     /* Types used only for the Data Table Compiler */
 
     ACPI_DMT_BUFFER,
+    ACPI_DMT_RAW_BUFFER,  /* Large, multiple line buffer */
     ACPI_DMT_DEVICE_PATH,
     ACPI_DMT_LABEL,
     ACPI_DMT_PCI_PATH,
@@ -136,16 +138,22 @@ typedef enum
 
     ACPI_DMT_ASF,
     ACPI_DMT_DMAR,
+    ACPI_DMT_DMAR_SCOPE,
     ACPI_DMT_EINJACT,
     ACPI_DMT_EINJINST,
     ACPI_DMT_ERSTACT,
     ACPI_DMT_ERSTINST,
     ACPI_DMT_FADTPM,
+    ACPI_DMT_GTDT,
     ACPI_DMT_HEST,
     ACPI_DMT_HESTNTFY,
     ACPI_DMT_HESTNTYP,
+    ACPI_DMT_IORTMEM,
     ACPI_DMT_IVRS,
+    ACPI_DMT_LPIT,
     ACPI_DMT_MADT,
+    ACPI_DMT_NFIT,
+    ACPI_DMT_PCCT,
     ACPI_DMT_PMTT,
     ACPI_DMT_SLIC,
     ACPI_DMT_SRAT,
@@ -172,19 +180,22 @@ typedef struct acpi_dmtable_data
     ACPI_DMTABLE_HANDLER    TableHandler;
     ACPI_CMTABLE_HANDLER    CmTableHandler;
     const unsigned char     *Template;
-    char                    *Name;
 
 } ACPI_DMTABLE_DATA;
 
 
 typedef struct acpi_op_walk_info
 {
+    ACPI_WALK_STATE         *WalkState;
+    ACPI_PARSE_OBJECT       *MappingOp;
+    UINT8                   *PreviousAml;
+    UINT8                   *StartAml;
     UINT32                  Level;
     UINT32                  LastLevel;
     UINT32                  Count;
     UINT32                  BitOffset;
     UINT32                  Flags;
-    ACPI_WALK_STATE         *WalkState;
+    UINT32                  AmlOffset;
 
 } ACPI_OP_WALK_INFO;
 
@@ -202,6 +213,7 @@ ACPI_STATUS (*ASL_WALK_CALLBACK) (
 
 typedef
 void (*ACPI_RESOURCE_HANDLER) (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
@@ -235,6 +247,16 @@ extern ACPI_DMTABLE_INFO        AcpiDmTableInfoBert[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoBgrt[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoCpep[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoCpep0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoCsrt0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoCsrt1[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoCsrt2[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoCsrt2a[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDbg2[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDbg2Device[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDbg2Addr[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDbg2Size[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDbg2Name[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDbg2OemData[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDbgp[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDmar[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDmarHdr[];
@@ -243,7 +265,13 @@ extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDmar0[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDmar1[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDmar2[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDmar3[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDmar4[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDrtm[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDrtm0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDrtm0a[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDrtm1[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDrtm1a[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoDrtm2[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoEcdt[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoEinj[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoEinj0[];
@@ -254,12 +282,17 @@ extern ACPI_DMTABLE_INFO        AcpiDmTableInfoFadt1[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoFadt2[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoFadt3[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoFadt5[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoFadt6[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoFpdt[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoFpdtHdr[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoFpdt0[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoFpdt1[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoGas[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoGtdt[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoGtdtHdr[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoGtdt0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoGtdt0a[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoGtdt1[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHeader[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHest[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHest0[];
@@ -269,9 +302,28 @@ extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHest6[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHest7[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHest8[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHest9[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHest10[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHestNotify[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHestBank[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoHpet[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoLpitHdr[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoLpit0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoLpit1[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort0a[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort1[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort1a[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort2[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort3[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort3a[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort3b[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort3c[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIort4[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIortAcc[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIortHdr[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIortMap[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIortPad[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIvrs[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIvrs0[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoIvrs1[];
@@ -294,6 +346,9 @@ extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMadt9[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMadt10[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMadt11[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMadt12[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMadt13[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMadt14[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMadt15[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMadtHdr[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMcfg[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMcfg0[];
@@ -306,6 +361,20 @@ extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMpst1[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMpst2[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMsct[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMsct0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMtmr[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoMtmr0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfitHdr[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit1[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit2[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit2a[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit3[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit3a[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit4[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit5[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit6[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoNfit6a[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPmtt[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPmtt0[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPmtt1[];
@@ -313,7 +382,10 @@ extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPmtt1a[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPmtt2[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPmttHdr[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPcct[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPcctHdr[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPcct0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPcct1[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoPcct2[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoRsdp1[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoRsdp2[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoS3pt[];
@@ -321,9 +393,7 @@ extern ACPI_DMTABLE_INFO        AcpiDmTableInfoS3ptHdr[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoS3pt0[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoS3pt1[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSbst[];
-extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSlicHdr[];
-extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSlic0[];
-extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSlic1[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSlic[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSlit[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSpcr[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSpmi[];
@@ -332,21 +402,32 @@ extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSratHdr[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSrat0[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSrat1[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSrat2[];
-extern ACPI_DMTABLE_INFO        AcpiDmTableInfoTcpa[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoSrat3[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoStao[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoStaoStr[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoTcpaHdr[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoTcpaClient[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoTcpaServer[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoTpm2[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoUefi[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoVrtc[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoVrtc0[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoWaet[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoWdat[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoWdat0[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoWddt[];
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoWdrt[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoWpbt[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoWpbt0[];
+extern ACPI_DMTABLE_INFO        AcpiDmTableInfoXenv[];
 
 extern ACPI_DMTABLE_INFO        AcpiDmTableInfoGeneric[][2];
 
-
 /*
- * dmtable
+ * dmtable and ahtable
  */
-extern ACPI_DMTABLE_DATA        AcpiDmTableData[];
+extern const ACPI_DMTABLE_DATA  AcpiDmTableData[];
+extern const AH_TABLE           AcpiSupportedTables[];
 
 UINT8
 AcpiDmGenerateChecksum (
@@ -354,7 +435,7 @@ AcpiDmGenerateChecksum (
     UINT32                  Length,
     UINT8                   OriginalChecksum);
 
-ACPI_DMTABLE_DATA *
+const ACPI_DMTABLE_DATA *
 AcpiDmGetTableData (
     char                    *Signature);
 
@@ -388,6 +469,20 @@ AcpiDmLineHeader2 (
  * dmtbdump
  */
 void
+AcpiDmDumpBuffer (
+    void                    *Table,
+    UINT32                  BufferOffset,
+    UINT32                  Length,
+    UINT32                  AbsoluteOffset,
+    char                    *Header);
+
+void
+AcpiDmDumpUnicode (
+    void                    *Table,
+    UINT32                  BufferOffset,
+    UINT32                  ByteLength);
+
+void
 AcpiDmDumpAsf (
     ACPI_TABLE_HEADER       *Table);
 
@@ -395,10 +490,22 @@ void
 AcpiDmDumpCpep (
     ACPI_TABLE_HEADER       *Table);
 
+void
+AcpiDmDumpCsrt (
+    ACPI_TABLE_HEADER       *Table);
+
+void
+AcpiDmDumpDbg2 (
+    ACPI_TABLE_HEADER       *Table);
+
 void
 AcpiDmDumpDmar (
     ACPI_TABLE_HEADER       *Table);
 
+void
+AcpiDmDumpDrtm (
+    ACPI_TABLE_HEADER       *Table);
+
 void
 AcpiDmDumpEinj (
     ACPI_TABLE_HEADER       *Table);
@@ -415,14 +522,26 @@ void
 AcpiDmDumpFpdt (
     ACPI_TABLE_HEADER       *Table);
 
+void
+AcpiDmDumpGtdt (
+    ACPI_TABLE_HEADER       *Table);
+
 void
 AcpiDmDumpHest (
     ACPI_TABLE_HEADER       *Table);
 
+void
+AcpiDmDumpIort (
+    ACPI_TABLE_HEADER       *Table);
+
 void
 AcpiDmDumpIvrs (
     ACPI_TABLE_HEADER       *Table);
 
+void
+AcpiDmDumpLpit (
+    ACPI_TABLE_HEADER       *Table);
+
 void
 AcpiDmDumpMadt (
     ACPI_TABLE_HEADER       *Table);
@@ -439,6 +558,14 @@ void
 AcpiDmDumpMsct (
     ACPI_TABLE_HEADER       *Table);
 
+void
+AcpiDmDumpMtmr (
+    ACPI_TABLE_HEADER       *Table);
+
+void
+AcpiDmDumpNfit (
+    ACPI_TABLE_HEADER       *Table);
+
 void
 AcpiDmDumpPcct (
     ACPI_TABLE_HEADER       *Table);
@@ -471,10 +598,26 @@ void
 AcpiDmDumpSrat (
     ACPI_TABLE_HEADER       *Table);
 
+void
+AcpiDmDumpStao (
+    ACPI_TABLE_HEADER       *Table);
+
+void
+AcpiDmDumpTcpa (
+    ACPI_TABLE_HEADER       *Table);
+
+void
+AcpiDmDumpVrtc (
+    ACPI_TABLE_HEADER       *Table);
+
 void
 AcpiDmDumpWdat (
     ACPI_TABLE_HEADER       *Table);
 
+void
+AcpiDmDumpWpbt (
+    ACPI_TABLE_HEADER       *Table);
+
 void
 AcpiDmDumpXsdt (
     ACPI_TABLE_HEADER       *Table);
@@ -506,10 +649,6 @@ AcpiDmDisassembleOneOp (
     ACPI_OP_WALK_INFO       *Info,
     ACPI_PARSE_OBJECT       *Op);
 
-void
-AcpiDmDecodeInternalObject (
-    ACPI_OPERAND_OBJECT     *ObjDesc);
-
 UINT32
 AcpiDmListType (
     ACPI_PARSE_OBJECT       *Op);
@@ -518,6 +657,22 @@ void
 AcpiDmMethodFlags (
     ACPI_PARSE_OBJECT       *Op);
 
+void
+AcpiDmDisplayTargetPathname (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+AcpiDmNotifyDescription (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+AcpiDmPredefinedDescription (
+    ACPI_PARSE_OBJECT       *Op);
+
+void
+AcpiDmFieldPredefinedDescription (
+    ACPI_PARSE_OBJECT       *Op);
+
 void
 AcpiDmFieldFlags (
     ACPI_PARSE_OBJECT       *Op);
@@ -552,29 +707,6 @@ AcpiDmNamestring (
     char                    *Name);
 
 
-/*
- * dmobject
- */
-void
-AcpiDmDisplayInternalObject (
-    ACPI_OPERAND_OBJECT     *ObjDesc,
-    ACPI_WALK_STATE         *WalkState);
-
-void
-AcpiDmDisplayArguments (
-    ACPI_WALK_STATE         *WalkState);
-
-void
-AcpiDmDisplayLocals (
-    ACPI_WALK_STATE         *WalkState);
-
-void
-AcpiDmDumpMethodInfo (
-    ACPI_STATUS             Status,
-    ACPI_WALK_STATE         *WalkState,
-    ACPI_PARSE_OBJECT       *Op);
-
-
 /*
  * dmbuffer
  */
@@ -590,13 +722,17 @@ AcpiDmByteList (
     ACPI_PARSE_OBJECT       *Op);
 
 void
-AcpiDmIsEisaId (
+AcpiDmCheckForHardwareId (
     ACPI_PARSE_OBJECT       *Op);
 
 void
-AcpiDmEisaId (
+AcpiDmDecompressEisaId (
     UINT32                  EncodedId);
 
+BOOLEAN
+AcpiDmIsUuidBuffer (
+    ACPI_PARSE_OBJECT       *Op);
+
 BOOLEAN
 AcpiDmIsUnicodeBuffer (
     ACPI_PARSE_OBJECT       *Op);
@@ -605,11 +741,22 @@ BOOLEAN
 AcpiDmIsStringBuffer (
     ACPI_PARSE_OBJECT       *Op);
 
+BOOLEAN
+AcpiDmIsPldBuffer (
+    ACPI_PARSE_OBJECT       *Op);
+
 
 /*
- * dmextern
+ * dmdeferred
  */
+ACPI_STATUS
+AcpiDmParseDeferredOps (
+    ACPI_PARSE_OBJECT       *Root);
+
 
+/*
+ * dmextern
+ */
 ACPI_STATUS
 AcpiDmAddToExternalFileList (
     char                    *PathList);
@@ -619,11 +766,19 @@ AcpiDmClearExternalFileList (
     void);
 
 void
-AcpiDmAddToExternalList (
+AcpiDmAddOpToExternalList (
     ACPI_PARSE_OBJECT       *Op,
     char                    *Path,
     UINT8                   Type,
-    UINT32                  Value);
+    UINT32                  Value,
+    UINT16                  Flags);
+
+void
+AcpiDmAddNodeToExternalList (
+    ACPI_NAMESPACE_NODE     *Node,
+    UINT8                   Type,
+    UINT32                  Value,
+    UINT16                  Flags);
 
 void
 AcpiDmAddExternalsToNamespace (
@@ -641,6 +796,13 @@ void
 AcpiDmEmitExternals (
     void);
 
+void
+AcpiDmUnresolvedWarning (
+    UINT8                   Type);
+
+void
+AcpiDmGetExternalsFromFile (
+    void);
 
 /*
  * dmresrc
@@ -648,22 +810,22 @@ AcpiDmEmitExternals (
 void
 AcpiDmDumpInteger8 (
     UINT8                   Value,
-    char                    *Name);
+    const char              *Name);
 
 void
 AcpiDmDumpInteger16 (
     UINT16                  Value,
-    char                    *Name);
+    const char              *Name);
 
 void
 AcpiDmDumpInteger32 (
     UINT32                  Value,
-    char                    *Name);
+    const char              *Name);
 
 void
 AcpiDmDumpInteger64 (
     UINT64                  Value,
-    char                    *Name);
+    const char              *Name);
 
 void
 AcpiDmResourceTemplate (
@@ -674,6 +836,7 @@ AcpiDmResourceTemplate (
 
 ACPI_STATUS
 AcpiDmIsResourceTemplate (
+    ACPI_WALK_STATE         *WalkState,
     ACPI_PARSE_OBJECT       *Op);
 
 void
@@ -690,79 +853,91 @@ AcpiDmDescriptorName (
  */
 void
 AcpiDmWordDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmDwordDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmExtendedDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmQwordDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmMemory24Descriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmMemory32Descriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmFixedMemory32Descriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmGenericRegisterDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmInterruptDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmVendorLargeDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmGpioDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmSerialBusDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmVendorCommon (
-    char                    *Name,
+    const char              *Name,
     UINT8                   *ByteData,
     UINT32                  Length,
     UINT32                  Level);
@@ -773,48 +948,56 @@ AcpiDmVendorCommon (
  */
 void
 AcpiDmIrqDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmDmaDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmFixedDmaDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmIoDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmFixedIoDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmStartDependentDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmEndDependentDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
 
 void
 AcpiDmVendorSmallDescriptor (
+    ACPI_OP_WALK_INFO       *Info,
     AML_RESOURCE            *Resource,
     UINT32                  Length,
     UINT32                  Level);
@@ -854,11 +1037,58 @@ AcpiDmCheckResourceReference (
 
 
 /*
- * acdisasm
+ * dmcstyle
+ */
+BOOLEAN
+AcpiDmCheckForSymbolicOpcode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_OP_WALK_INFO       *Info);
+
+void
+AcpiDmCloseOperator (
+    ACPI_PARSE_OBJECT       *Op);
+
+
+/*
+ * dmtables
  */
 void
 AdDisassemblerHeader (
-    char                    *Filename);
+    char                    *Filename,
+    UINT8                   TableType);
+
+#define ACPI_IS_AML_TABLE   0
+#define ACPI_IS_DATA_TABLE  1
+
 
+/*
+ * adisasm
+ */
+ACPI_STATUS
+AdAmlDisassemble (
+    BOOLEAN                 OutToFile,
+    char                    *Filename,
+    char                    *Prefix,
+    char                    **OutFilename);
+
+ACPI_STATUS
+AdGetLocalTables (
+    void);
+
+ACPI_STATUS
+AdParseTable (
+    ACPI_TABLE_HEADER       *Table,
+    ACPI_OWNER_ID           *OwnerId,
+    BOOLEAN                 LoadTable,
+    BOOLEAN                 External);
+
+ACPI_STATUS
+AdDisplayTables (
+    char                    *Filename,
+    ACPI_TABLE_HEADER       *Table);
+
+ACPI_STATUS
+AdDisplayStatistics (
+    void);
 
 #endif  /* __ACDISASM_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/acdispat.h b/usr/src/uts/intel/sys/acpi/acdispat.h
index 0699ee77a1..1a6f39e2aa 100644
--- a/usr/src/uts/intel/sys/acpi/acdispat.h
+++ b/usr/src/uts/intel/sys/acpi/acdispat.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #ifndef _ACDISPAT_H_
 #define _ACDISPAT_H_
 
@@ -173,13 +172,15 @@ AcpiDsInitFieldObjects (
 
 
 /*
- * dsload - Parser/Interpreter interface, pass 1 namespace load callbacks
+ * dsload - Parser/Interpreter interface
  */
 ACPI_STATUS
 AcpiDsInitCallbacks (
     ACPI_WALK_STATE         *WalkState,
     UINT32                  PassNumber);
 
+/* dsload - pass 1 namespace load callbacks */
+
 ACPI_STATUS
 AcpiDsLoad1BeginOp (
     ACPI_WALK_STATE         *WalkState,
@@ -190,9 +191,8 @@ AcpiDsLoad1EndOp (
     ACPI_WALK_STATE         *WalkState);
 
 
-/*
- * dsload - Parser/Interpreter interface, pass 2 namespace load callbacks
- */
+/* dsload - pass 2 namespace load callbacks */
+
 ACPI_STATUS
 AcpiDsLoad2BeginOp (
     ACPI_WALK_STATE         *WalkState,
@@ -257,8 +257,9 @@ AcpiDsMethodDataInit (
  * dsmethod - Parser/Interpreter interface - control method parsing
  */
 ACPI_STATUS
-AcpiDsParseMethod (
-    ACPI_NAMESPACE_NODE     *Node);
+AcpiDsAutoSerializeMethod (
+    ACPI_NAMESPACE_NODE     *Node,
+    ACPI_OPERAND_OBJECT     *ObjDesc);
 
 ACPI_STATUS
 AcpiDsCallControlMethod (
@@ -460,4 +461,14 @@ AcpiDsResultPush (
     ACPI_OPERAND_OBJECT     *Object,
     ACPI_WALK_STATE         *WalkState);
 
+
+/*
+ * dsdebug - parser debugging routines
+ */
+void
+AcpiDsDumpMethodStack (
+    ACPI_STATUS             Status,
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       *Op);
+
 #endif /* _ACDISPAT_H_ */
diff --git a/usr/src/uts/intel/sys/acpi/acevents.h b/usr/src/uts/intel/sys/acpi/acevents.h
index 3b874f1075..a14dbe57c1 100644
--- a/usr/src/uts/intel/sys/acpi/acevents.h
+++ b/usr/src/uts/intel/sys/acpi/acevents.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -144,9 +144,10 @@ AcpiEvFinishGpe (
 ACPI_STATUS
 AcpiEvCreateGpeBlock (
     ACPI_NAMESPACE_NODE     *GpeDevice,
-    ACPI_GENERIC_ADDRESS    *GpeBlockAddress,
+    UINT64                  Address,
+    UINT8                   SpaceId,
     UINT32                  RegisterCount,
-    UINT8                   GpeBlockBaseNumber,
+    UINT16                  GpeBlockBaseNumber,
     UINT32                  InterruptNumber,
     ACPI_GPE_BLOCK_INFO     **ReturnGpeBlock);
 
@@ -167,6 +168,7 @@ AcpiEvGpeDispatch (
     ACPI_GPE_EVENT_INFO     *GpeEventInfo,
     UINT32                  GpeNumber);
 
+
 /*
  * evgpeinit - GPE initialization and update
  */
@@ -186,6 +188,7 @@ AcpiEvMatchGpeMethod (
     void                    *Context,
     void                    **ReturnValue);
 
+
 /*
  * evgpeutil - GPE utilities
  */
@@ -194,19 +197,16 @@ AcpiEvWalkGpeList (
     ACPI_GPE_CALLBACK       GpeWalkCallback,
     void                    *Context);
 
-BOOLEAN
-AcpiEvValidGpeEvent (
-    ACPI_GPE_EVENT_INFO     *GpeEventInfo);
-
 ACPI_STATUS
 AcpiEvGetGpeDevice (
     ACPI_GPE_XRUPT_INFO     *GpeXruptInfo,
     ACPI_GPE_BLOCK_INFO     *GpeBlock,
     void                    *Context);
 
-ACPI_GPE_XRUPT_INFO *
+ACPI_STATUS
 AcpiEvGetGpeXruptBlock (
-    UINT32                  InterruptNumber);
+    UINT32                  InterruptNumber,
+    ACPI_GPE_XRUPT_INFO     **GpeXruptBlock);
 
 ACPI_STATUS
 AcpiEvDeleteGpeXrupt (
@@ -220,13 +220,35 @@ AcpiEvDeleteGpeHandlers (
 
 
 /*
- * evregion - Address Space handling
+ * evhandler - Address space handling
  */
+ACPI_OPERAND_OBJECT *
+AcpiEvFindRegionHandler (
+    ACPI_ADR_SPACE_TYPE     SpaceId,
+    ACPI_OPERAND_OBJECT     *HandlerObj);
+
+BOOLEAN
+AcpiEvHasDefaultHandler (
+    ACPI_NAMESPACE_NODE     *Node,
+    ACPI_ADR_SPACE_TYPE     SpaceId);
+
 ACPI_STATUS
 AcpiEvInstallRegionHandlers (
     void);
 
 ACPI_STATUS
+AcpiEvInstallSpaceHandler (
+    ACPI_NAMESPACE_NODE     *Node,
+    ACPI_ADR_SPACE_TYPE     SpaceId,
+    ACPI_ADR_SPACE_HANDLER  Handler,
+    ACPI_ADR_SPACE_SETUP    Setup,
+    void                    *Context);
+
+
+/*
+ * evregion - Operation region support
+ */
+ACPI_STATUS
 AcpiEvInitializeOpRegions (
     void);
 
@@ -247,25 +269,18 @@ AcpiEvAttachRegion (
 
 void
 AcpiEvDetachRegion (
-    ACPI_OPERAND_OBJECT    *RegionObj,
+    ACPI_OPERAND_OBJECT     *RegionObj,
     BOOLEAN                 AcpiNsIsLocked);
 
-ACPI_STATUS
-AcpiEvInstallSpaceHandler (
-    ACPI_NAMESPACE_NODE     *Node,
-    ACPI_ADR_SPACE_TYPE     SpaceId,
-    ACPI_ADR_SPACE_HANDLER  Handler,
-    ACPI_ADR_SPACE_SETUP    Setup,
-    void                    *Context);
-
-ACPI_STATUS
+void
 AcpiEvExecuteRegMethods (
     ACPI_NAMESPACE_NODE     *Node,
-    ACPI_ADR_SPACE_TYPE     SpaceId);
+    ACPI_ADR_SPACE_TYPE     SpaceId,
+    UINT32                  Function);
 
 ACPI_STATUS
 AcpiEvExecuteRegMethod (
-    ACPI_OPERAND_OBJECT    *RegionObj,
+    ACPI_OPERAND_OBJECT     *RegionObj,
     UINT32                  Function);
 
 
@@ -327,18 +342,18 @@ UINT32 ACPI_SYSTEM_XFACE
 AcpiEvGpeXruptHandler (
     void                    *Context);
 
+UINT32
+AcpiEvSciDispatch (
+    void);
+
 UINT32
 AcpiEvInstallSciHandler (
     void);
 
 ACPI_STATUS
-AcpiEvRemoveSciHandler (
+AcpiEvRemoveAllSciHandlers (
     void);
 
-UINT32
-AcpiEvInitializeSCI (
-    UINT32                  ProgramSCI);
-
 ACPI_HW_DEPENDENT_RETURN_VOID (
 void
 AcpiEvTerminate (
diff --git a/usr/src/uts/intel/sys/acpi/acexcep.h b/usr/src/uts/intel/sys/acpi/acexcep.h
index 10f5a113da..0f9a6aa569 100644
--- a/usr/src/uts/intel/sys/acpi/acexcep.h
+++ b/usr/src/uts/intel/sys/acpi/acexcep.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -45,70 +45,106 @@
 #define __ACEXCEP_H__
 
 
+/* This module contains all possible exception codes for ACPI_STATUS */
+
 /*
- * Exceptions returned by external ACPI interfaces
+ * Exception code classes
  */
-#define AE_CODE_ENVIRONMENTAL           0x0000
-#define AE_CODE_PROGRAMMER              0x1000
-#define AE_CODE_ACPI_TABLES             0x2000
-#define AE_CODE_AML                     0x3000
-#define AE_CODE_CONTROL                 0x4000
+#define AE_CODE_ENVIRONMENTAL           0x0000 /* General ACPICA environment */
+#define AE_CODE_PROGRAMMER              0x1000 /* External ACPICA interface caller */
+#define AE_CODE_ACPI_TABLES             0x2000 /* ACPI tables */
+#define AE_CODE_AML                     0x3000 /* From executing AML code */
+#define AE_CODE_CONTROL                 0x4000 /* Internal control codes */
+
+#define AE_CODE_MAX                     0x4000
 #define AE_CODE_MASK                    0xF000
 
+/*
+ * Macros to insert the exception code classes
+ */
+#define EXCEP_ENV(code)                 ((ACPI_STATUS) (code | AE_CODE_ENVIRONMENTAL))
+#define EXCEP_PGM(code)                 ((ACPI_STATUS) (code | AE_CODE_PROGRAMMER))
+#define EXCEP_TBL(code)                 ((ACPI_STATUS) (code | AE_CODE_ACPI_TABLES))
+#define EXCEP_AML(code)                 ((ACPI_STATUS) (code | AE_CODE_AML))
+#define EXCEP_CTL(code)                 ((ACPI_STATUS) (code | AE_CODE_CONTROL))
+
+/*
+ * Exception info table. The "Description" field is used only by the
+ * ACPICA help application (acpihelp).
+ */
+typedef struct acpi_exception_info
+{
+    char                *Name;
+
+#ifdef ACPI_HELP_APP
+    char                *Description;
+#endif
+} ACPI_EXCEPTION_INFO;
+
+#ifdef ACPI_HELP_APP
+#define EXCEP_TXT(Name,Description)     {Name, Description}
+#else
+#define EXCEP_TXT(Name,Description)     {Name}
+#endif
+
 
+/*
+ * Success is always zero, failure is non-zero
+ */
 #define ACPI_SUCCESS(a)                 (!(a))
 #define ACPI_FAILURE(a)                 (a)
 
-
 #define AE_OK                           (ACPI_STATUS) 0x0000
 
 /*
  * Environmental exceptions
  */
-#define AE_ERROR                        (ACPI_STATUS) (0x0001 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_ACPI_TABLES               (ACPI_STATUS) (0x0002 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_NAMESPACE                 (ACPI_STATUS) (0x0003 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_MEMORY                    (ACPI_STATUS) (0x0004 | AE_CODE_ENVIRONMENTAL)
-#define AE_NOT_FOUND                    (ACPI_STATUS) (0x0005 | AE_CODE_ENVIRONMENTAL)
-#define AE_NOT_EXIST                    (ACPI_STATUS) (0x0006 | AE_CODE_ENVIRONMENTAL)
-#define AE_ALREADY_EXISTS               (ACPI_STATUS) (0x0007 | AE_CODE_ENVIRONMENTAL)
-#define AE_TYPE                         (ACPI_STATUS) (0x0008 | AE_CODE_ENVIRONMENTAL)
-#define AE_NULL_OBJECT                  (ACPI_STATUS) (0x0009 | AE_CODE_ENVIRONMENTAL)
-#define AE_NULL_ENTRY                   (ACPI_STATUS) (0x000A | AE_CODE_ENVIRONMENTAL)
-#define AE_BUFFER_OVERFLOW              (ACPI_STATUS) (0x000B | AE_CODE_ENVIRONMENTAL)
-#define AE_STACK_OVERFLOW               (ACPI_STATUS) (0x000C | AE_CODE_ENVIRONMENTAL)
-#define AE_STACK_UNDERFLOW              (ACPI_STATUS) (0x000D | AE_CODE_ENVIRONMENTAL)
-#define AE_NOT_IMPLEMENTED              (ACPI_STATUS) (0x000E | AE_CODE_ENVIRONMENTAL)
-#define AE_SUPPORT                      (ACPI_STATUS) (0x000F | AE_CODE_ENVIRONMENTAL)
-#define AE_LIMIT                        (ACPI_STATUS) (0x0010 | AE_CODE_ENVIRONMENTAL)
-#define AE_TIME                         (ACPI_STATUS) (0x0011 | AE_CODE_ENVIRONMENTAL)
-#define AE_ACQUIRE_DEADLOCK             (ACPI_STATUS) (0x0012 | AE_CODE_ENVIRONMENTAL)
-#define AE_RELEASE_DEADLOCK             (ACPI_STATUS) (0x0013 | AE_CODE_ENVIRONMENTAL)
-#define AE_NOT_ACQUIRED                 (ACPI_STATUS) (0x0014 | AE_CODE_ENVIRONMENTAL)
-#define AE_ALREADY_ACQUIRED             (ACPI_STATUS) (0x0015 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_HARDWARE_RESPONSE         (ACPI_STATUS) (0x0016 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_GLOBAL_LOCK               (ACPI_STATUS) (0x0017 | AE_CODE_ENVIRONMENTAL)
-#define AE_ABORT_METHOD                 (ACPI_STATUS) (0x0018 | AE_CODE_ENVIRONMENTAL)
-#define AE_SAME_HANDLER                 (ACPI_STATUS) (0x0019 | AE_CODE_ENVIRONMENTAL)
-#define AE_NO_HANDLER                   (ACPI_STATUS) (0x001A | AE_CODE_ENVIRONMENTAL)
-#define AE_OWNER_ID_LIMIT               (ACPI_STATUS) (0x001B | AE_CODE_ENVIRONMENTAL)
-#define AE_NOT_CONFIGURED               (ACPI_STATUS) (0x001C | AE_CODE_ENVIRONMENTAL)
-
-#define AE_CODE_ENV_MAX                 0x001C
+#define AE_ERROR                        EXCEP_ENV (0x0001)
+#define AE_NO_ACPI_TABLES               EXCEP_ENV (0x0002)
+#define AE_NO_NAMESPACE                 EXCEP_ENV (0x0003)
+#define AE_NO_MEMORY                    EXCEP_ENV (0x0004)
+#define AE_NOT_FOUND                    EXCEP_ENV (0x0005)
+#define AE_NOT_EXIST                    EXCEP_ENV (0x0006)
+#define AE_ALREADY_EXISTS               EXCEP_ENV (0x0007)
+#define AE_TYPE                         EXCEP_ENV (0x0008)
+#define AE_NULL_OBJECT                  EXCEP_ENV (0x0009)
+#define AE_NULL_ENTRY                   EXCEP_ENV (0x000A)
+#define AE_BUFFER_OVERFLOW              EXCEP_ENV (0x000B)
+#define AE_STACK_OVERFLOW               EXCEP_ENV (0x000C)
+#define AE_STACK_UNDERFLOW              EXCEP_ENV (0x000D)
+#define AE_NOT_IMPLEMENTED              EXCEP_ENV (0x000E)
+#define AE_SUPPORT                      EXCEP_ENV (0x000F)
+#define AE_LIMIT                        EXCEP_ENV (0x0010)
+#define AE_TIME                         EXCEP_ENV (0x0011)
+#define AE_ACQUIRE_DEADLOCK             EXCEP_ENV (0x0012)
+#define AE_RELEASE_DEADLOCK             EXCEP_ENV (0x0013)
+#define AE_NOT_ACQUIRED                 EXCEP_ENV (0x0014)
+#define AE_ALREADY_ACQUIRED             EXCEP_ENV (0x0015)
+#define AE_NO_HARDWARE_RESPONSE         EXCEP_ENV (0x0016)
+#define AE_NO_GLOBAL_LOCK               EXCEP_ENV (0x0017)
+#define AE_ABORT_METHOD                 EXCEP_ENV (0x0018)
+#define AE_SAME_HANDLER                 EXCEP_ENV (0x0019)
+#define AE_NO_HANDLER                   EXCEP_ENV (0x001A)
+#define AE_OWNER_ID_LIMIT               EXCEP_ENV (0x001B)
+#define AE_NOT_CONFIGURED               EXCEP_ENV (0x001C)
+#define AE_ACCESS                       EXCEP_ENV (0x001D)
+#define AE_IO_ERROR                     EXCEP_ENV (0x001E)
+
+#define AE_CODE_ENV_MAX                 0x001E
 
 
 /*
  * Programmer exceptions
  */
-#define AE_BAD_PARAMETER                (ACPI_STATUS) (0x0001 | AE_CODE_PROGRAMMER)
-#define AE_BAD_CHARACTER                (ACPI_STATUS) (0x0002 | AE_CODE_PROGRAMMER)
-#define AE_BAD_PATHNAME                 (ACPI_STATUS) (0x0003 | AE_CODE_PROGRAMMER)
-#define AE_BAD_DATA                     (ACPI_STATUS) (0x0004 | AE_CODE_PROGRAMMER)
-#define AE_BAD_HEX_CONSTANT             (ACPI_STATUS) (0x0005 | AE_CODE_PROGRAMMER)
-#define AE_BAD_OCTAL_CONSTANT           (ACPI_STATUS) (0x0006 | AE_CODE_PROGRAMMER)
-#define AE_BAD_DECIMAL_CONSTANT         (ACPI_STATUS) (0x0007 | AE_CODE_PROGRAMMER)
-#define AE_MISSING_ARGUMENTS            (ACPI_STATUS) (0x0008 | AE_CODE_PROGRAMMER)
-#define AE_BAD_ADDRESS                  (ACPI_STATUS) (0x0009 | AE_CODE_PROGRAMMER)
+#define AE_BAD_PARAMETER                EXCEP_PGM (0x0001)
+#define AE_BAD_CHARACTER                EXCEP_PGM (0x0002)
+#define AE_BAD_PATHNAME                 EXCEP_PGM (0x0003)
+#define AE_BAD_DATA                     EXCEP_PGM (0x0004)
+#define AE_BAD_HEX_CONSTANT             EXCEP_PGM (0x0005)
+#define AE_BAD_OCTAL_CONSTANT           EXCEP_PGM (0x0006)
+#define AE_BAD_DECIMAL_CONSTANT         EXCEP_PGM (0x0007)
+#define AE_MISSING_ARGUMENTS            EXCEP_PGM (0x0008)
+#define AE_BAD_ADDRESS                  EXCEP_PGM (0x0009)
 
 #define AE_CODE_PGM_MAX                 0x0009
 
@@ -116,197 +152,203 @@
 /*
  * Acpi table exceptions
  */
-#define AE_BAD_SIGNATURE                (ACPI_STATUS) (0x0001 | AE_CODE_ACPI_TABLES)
-#define AE_BAD_HEADER                   (ACPI_STATUS) (0x0002 | AE_CODE_ACPI_TABLES)
-#define AE_BAD_CHECKSUM                 (ACPI_STATUS) (0x0003 | AE_CODE_ACPI_TABLES)
-#define AE_BAD_VALUE                    (ACPI_STATUS) (0x0004 | AE_CODE_ACPI_TABLES)
-#define AE_INVALID_TABLE_LENGTH         (ACPI_STATUS) (0x0005 | AE_CODE_ACPI_TABLES)
+#define AE_BAD_SIGNATURE                EXCEP_TBL (0x0001)
+#define AE_BAD_HEADER                   EXCEP_TBL (0x0002)
+#define AE_BAD_CHECKSUM                 EXCEP_TBL (0x0003)
+#define AE_BAD_VALUE                    EXCEP_TBL (0x0004)
+#define AE_INVALID_TABLE_LENGTH         EXCEP_TBL (0x0005)
 
 #define AE_CODE_TBL_MAX                 0x0005
 
 
 /*
- * AML exceptions.  These are caused by problems with
+ * AML exceptions. These are caused by problems with
  * the actual AML byte stream
  */
-#define AE_AML_BAD_OPCODE               (ACPI_STATUS) (0x0001 | AE_CODE_AML)
-#define AE_AML_NO_OPERAND               (ACPI_STATUS) (0x0002 | AE_CODE_AML)
-#define AE_AML_OPERAND_TYPE             (ACPI_STATUS) (0x0003 | AE_CODE_AML)
-#define AE_AML_OPERAND_VALUE            (ACPI_STATUS) (0x0004 | AE_CODE_AML)
-#define AE_AML_UNINITIALIZED_LOCAL      (ACPI_STATUS) (0x0005 | AE_CODE_AML)
-#define AE_AML_UNINITIALIZED_ARG        (ACPI_STATUS) (0x0006 | AE_CODE_AML)
-#define AE_AML_UNINITIALIZED_ELEMENT    (ACPI_STATUS) (0x0007 | AE_CODE_AML)
-#define AE_AML_NUMERIC_OVERFLOW         (ACPI_STATUS) (0x0008 | AE_CODE_AML)
-#define AE_AML_REGION_LIMIT             (ACPI_STATUS) (0x0009 | AE_CODE_AML)
-#define AE_AML_BUFFER_LIMIT             (ACPI_STATUS) (0x000A | AE_CODE_AML)
-#define AE_AML_PACKAGE_LIMIT            (ACPI_STATUS) (0x000B | AE_CODE_AML)
-#define AE_AML_DIVIDE_BY_ZERO           (ACPI_STATUS) (0x000C | AE_CODE_AML)
-#define AE_AML_BAD_NAME                 (ACPI_STATUS) (0x000D | AE_CODE_AML)
-#define AE_AML_NAME_NOT_FOUND           (ACPI_STATUS) (0x000E | AE_CODE_AML)
-#define AE_AML_INTERNAL                 (ACPI_STATUS) (0x000F | AE_CODE_AML)
-#define AE_AML_INVALID_SPACE_ID         (ACPI_STATUS) (0x0010 | AE_CODE_AML)
-#define AE_AML_STRING_LIMIT             (ACPI_STATUS) (0x0011 | AE_CODE_AML)
-#define AE_AML_NO_RETURN_VALUE          (ACPI_STATUS) (0x0012 | AE_CODE_AML)
-#define AE_AML_METHOD_LIMIT             (ACPI_STATUS) (0x0013 | AE_CODE_AML)
-#define AE_AML_NOT_OWNER                (ACPI_STATUS) (0x0014 | AE_CODE_AML)
-#define AE_AML_MUTEX_ORDER              (ACPI_STATUS) (0x0015 | AE_CODE_AML)
-#define AE_AML_MUTEX_NOT_ACQUIRED       (ACPI_STATUS) (0x0016 | AE_CODE_AML)
-#define AE_AML_INVALID_RESOURCE_TYPE    (ACPI_STATUS) (0x0017 | AE_CODE_AML)
-#define AE_AML_INVALID_INDEX            (ACPI_STATUS) (0x0018 | AE_CODE_AML)
-#define AE_AML_REGISTER_LIMIT           (ACPI_STATUS) (0x0019 | AE_CODE_AML)
-#define AE_AML_NO_WHILE                 (ACPI_STATUS) (0x001A | AE_CODE_AML)
-#define AE_AML_ALIGNMENT                (ACPI_STATUS) (0x001B | AE_CODE_AML)
-#define AE_AML_NO_RESOURCE_END_TAG      (ACPI_STATUS) (0x001C | AE_CODE_AML)
-#define AE_AML_BAD_RESOURCE_VALUE       (ACPI_STATUS) (0x001D | AE_CODE_AML)
-#define AE_AML_CIRCULAR_REFERENCE       (ACPI_STATUS) (0x001E | AE_CODE_AML)
-#define AE_AML_BAD_RESOURCE_LENGTH      (ACPI_STATUS) (0x001F | AE_CODE_AML)
-#define AE_AML_ILLEGAL_ADDRESS          (ACPI_STATUS) (0x0020 | AE_CODE_AML)
-#define AE_AML_INFINITE_LOOP            (ACPI_STATUS) (0x0021 | AE_CODE_AML)
-
-#define AE_CODE_AML_MAX                 0x0021
+#define AE_AML_BAD_OPCODE               EXCEP_AML (0x0001)
+#define AE_AML_NO_OPERAND               EXCEP_AML (0x0002)
+#define AE_AML_OPERAND_TYPE             EXCEP_AML (0x0003)
+#define AE_AML_OPERAND_VALUE            EXCEP_AML (0x0004)
+#define AE_AML_UNINITIALIZED_LOCAL      EXCEP_AML (0x0005)
+#define AE_AML_UNINITIALIZED_ARG        EXCEP_AML (0x0006)
+#define AE_AML_UNINITIALIZED_ELEMENT    EXCEP_AML (0x0007)
+#define AE_AML_NUMERIC_OVERFLOW         EXCEP_AML (0x0008)
+#define AE_AML_REGION_LIMIT             EXCEP_AML (0x0009)
+#define AE_AML_BUFFER_LIMIT             EXCEP_AML (0x000A)
+#define AE_AML_PACKAGE_LIMIT            EXCEP_AML (0x000B)
+#define AE_AML_DIVIDE_BY_ZERO           EXCEP_AML (0x000C)
+#define AE_AML_BAD_NAME                 EXCEP_AML (0x000D)
+#define AE_AML_NAME_NOT_FOUND           EXCEP_AML (0x000E)
+#define AE_AML_INTERNAL                 EXCEP_AML (0x000F)
+#define AE_AML_INVALID_SPACE_ID         EXCEP_AML (0x0010)
+#define AE_AML_STRING_LIMIT             EXCEP_AML (0x0011)
+#define AE_AML_NO_RETURN_VALUE          EXCEP_AML (0x0012)
+#define AE_AML_METHOD_LIMIT             EXCEP_AML (0x0013)
+#define AE_AML_NOT_OWNER                EXCEP_AML (0x0014)
+#define AE_AML_MUTEX_ORDER              EXCEP_AML (0x0015)
+#define AE_AML_MUTEX_NOT_ACQUIRED       EXCEP_AML (0x0016)
+#define AE_AML_INVALID_RESOURCE_TYPE    EXCEP_AML (0x0017)
+#define AE_AML_INVALID_INDEX            EXCEP_AML (0x0018)
+#define AE_AML_REGISTER_LIMIT           EXCEP_AML (0x0019)
+#define AE_AML_NO_WHILE                 EXCEP_AML (0x001A)
+#define AE_AML_ALIGNMENT                EXCEP_AML (0x001B)
+#define AE_AML_NO_RESOURCE_END_TAG      EXCEP_AML (0x001C)
+#define AE_AML_BAD_RESOURCE_VALUE       EXCEP_AML (0x001D)
+#define AE_AML_CIRCULAR_REFERENCE       EXCEP_AML (0x001E)
+#define AE_AML_BAD_RESOURCE_LENGTH      EXCEP_AML (0x001F)
+#define AE_AML_ILLEGAL_ADDRESS          EXCEP_AML (0x0020)
+#define AE_AML_INFINITE_LOOP            EXCEP_AML (0x0021)
+#define AE_AML_UNINITIALIZED_NODE       EXCEP_AML (0x0022)
+#define AE_AML_TARGET_TYPE              EXCEP_AML (0x0023)
+
+#define AE_CODE_AML_MAX                 0x0023
 
 
 /*
  * Internal exceptions used for control
  */
-#define AE_CTRL_RETURN_VALUE            (ACPI_STATUS) (0x0001 | AE_CODE_CONTROL)
-#define AE_CTRL_PENDING                 (ACPI_STATUS) (0x0002 | AE_CODE_CONTROL)
-#define AE_CTRL_TERMINATE               (ACPI_STATUS) (0x0003 | AE_CODE_CONTROL)
-#define AE_CTRL_TRUE                    (ACPI_STATUS) (0x0004 | AE_CODE_CONTROL)
-#define AE_CTRL_FALSE                   (ACPI_STATUS) (0x0005 | AE_CODE_CONTROL)
-#define AE_CTRL_DEPTH                   (ACPI_STATUS) (0x0006 | AE_CODE_CONTROL)
-#define AE_CTRL_END                     (ACPI_STATUS) (0x0007 | AE_CODE_CONTROL)
-#define AE_CTRL_TRANSFER                (ACPI_STATUS) (0x0008 | AE_CODE_CONTROL)
-#define AE_CTRL_BREAK                   (ACPI_STATUS) (0x0009 | AE_CODE_CONTROL)
-#define AE_CTRL_CONTINUE                (ACPI_STATUS) (0x000A | AE_CODE_CONTROL)
-#define AE_CTRL_SKIP                    (ACPI_STATUS) (0x000B | AE_CODE_CONTROL)
-#define AE_CTRL_PARSE_CONTINUE          (ACPI_STATUS) (0x000C | AE_CODE_CONTROL)
-#define AE_CTRL_PARSE_PENDING           (ACPI_STATUS) (0x000D | AE_CODE_CONTROL)
+#define AE_CTRL_RETURN_VALUE            EXCEP_CTL (0x0001)
+#define AE_CTRL_PENDING                 EXCEP_CTL (0x0002)
+#define AE_CTRL_TERMINATE               EXCEP_CTL (0x0003)
+#define AE_CTRL_TRUE                    EXCEP_CTL (0x0004)
+#define AE_CTRL_FALSE                   EXCEP_CTL (0x0005)
+#define AE_CTRL_DEPTH                   EXCEP_CTL (0x0006)
+#define AE_CTRL_END                     EXCEP_CTL (0x0007)
+#define AE_CTRL_TRANSFER                EXCEP_CTL (0x0008)
+#define AE_CTRL_BREAK                   EXCEP_CTL (0x0009)
+#define AE_CTRL_CONTINUE                EXCEP_CTL (0x000A)
+#define AE_CTRL_SKIP                    EXCEP_CTL (0x000B)
+#define AE_CTRL_PARSE_CONTINUE          EXCEP_CTL (0x000C)
+#define AE_CTRL_PARSE_PENDING           EXCEP_CTL (0x000D)
 
 #define AE_CODE_CTRL_MAX                0x000D
 
 
 /* Exception strings for AcpiFormatException */
 
-#ifdef DEFINE_ACPI_GLOBALS
+#ifdef ACPI_DEFINE_EXCEPTION_TABLE
 
 /*
  * String versions of the exception codes above
  * These strings must match the corresponding defines exactly
  */
-char const   *AcpiGbl_ExceptionNames_Env[] =
+static const ACPI_EXCEPTION_INFO    AcpiGbl_ExceptionNames_Env[] =
 {
-    "AE_OK",
-    "AE_ERROR",
-    "AE_NO_ACPI_TABLES",
-    "AE_NO_NAMESPACE",
-    "AE_NO_MEMORY",
-    "AE_NOT_FOUND",
-    "AE_NOT_EXIST",
-    "AE_ALREADY_EXISTS",
-    "AE_TYPE",
-    "AE_NULL_OBJECT",
-    "AE_NULL_ENTRY",
-    "AE_BUFFER_OVERFLOW",
-    "AE_STACK_OVERFLOW",
-    "AE_STACK_UNDERFLOW",
-    "AE_NOT_IMPLEMENTED",
-    "AE_SUPPORT",
-    "AE_LIMIT",
-    "AE_TIME",
-    "AE_ACQUIRE_DEADLOCK",
-    "AE_RELEASE_DEADLOCK",
-    "AE_NOT_ACQUIRED",
-    "AE_ALREADY_ACQUIRED",
-    "AE_NO_HARDWARE_RESPONSE",
-    "AE_NO_GLOBAL_LOCK",
-    "AE_ABORT_METHOD",
-    "AE_SAME_HANDLER",
-    "AE_NO_HANDLER",
-    "AE_OWNER_ID_LIMIT",
-    "AE_NOT_CONFIGURED"
+    EXCEP_TXT ("AE_OK",                         "No error"),
+    EXCEP_TXT ("AE_ERROR",                      "Unspecified error"),
+    EXCEP_TXT ("AE_NO_ACPI_TABLES",             "ACPI tables could not be found"),
+    EXCEP_TXT ("AE_NO_NAMESPACE",               "A namespace has not been loaded"),
+    EXCEP_TXT ("AE_NO_MEMORY",                  "Insufficient dynamic memory"),
+    EXCEP_TXT ("AE_NOT_FOUND",                  "A requested entity is not found"),
+    EXCEP_TXT ("AE_NOT_EXIST",                  "A required entity does not exist"),
+    EXCEP_TXT ("AE_ALREADY_EXISTS",             "An entity already exists"),
+    EXCEP_TXT ("AE_TYPE",                       "The object type is incorrect"),
+    EXCEP_TXT ("AE_NULL_OBJECT",                "A required object was missing"),
+    EXCEP_TXT ("AE_NULL_ENTRY",                 "The requested object does not exist"),
+    EXCEP_TXT ("AE_BUFFER_OVERFLOW",            "The buffer provided is too small"),
+    EXCEP_TXT ("AE_STACK_OVERFLOW",             "An internal stack overflowed"),
+    EXCEP_TXT ("AE_STACK_UNDERFLOW",            "An internal stack underflowed"),
+    EXCEP_TXT ("AE_NOT_IMPLEMENTED",            "The feature is not implemented"),
+    EXCEP_TXT ("AE_SUPPORT",                    "The feature is not supported"),
+    EXCEP_TXT ("AE_LIMIT",                      "A predefined limit was exceeded"),
+    EXCEP_TXT ("AE_TIME",                       "A time limit or timeout expired"),
+    EXCEP_TXT ("AE_ACQUIRE_DEADLOCK",           "Internal error, attempt was made to acquire a mutex in improper order"),
+    EXCEP_TXT ("AE_RELEASE_DEADLOCK",           "Internal error, attempt was made to release a mutex in improper order"),
+    EXCEP_TXT ("AE_NOT_ACQUIRED",               "An attempt to release a mutex or Global Lock without a previous acquire"),
+    EXCEP_TXT ("AE_ALREADY_ACQUIRED",           "Internal error, attempt was made to acquire a mutex twice"),
+    EXCEP_TXT ("AE_NO_HARDWARE_RESPONSE",       "Hardware did not respond after an I/O operation"),
+    EXCEP_TXT ("AE_NO_GLOBAL_LOCK",             "There is no FACS Global Lock"),
+    EXCEP_TXT ("AE_ABORT_METHOD",               "A control method was aborted"),
+    EXCEP_TXT ("AE_SAME_HANDLER",               "Attempt was made to install the same handler that is already installed"),
+    EXCEP_TXT ("AE_NO_HANDLER",                 "A handler for the operation is not installed"),
+    EXCEP_TXT ("AE_OWNER_ID_LIMIT",             "There are no more Owner IDs available for ACPI tables or control methods"),
+    EXCEP_TXT ("AE_NOT_CONFIGURED",             "The interface is not part of the current subsystem configuration"),
+    EXCEP_TXT ("AE_ACCESS",                     "Permission denied for the requested operation"),
+    EXCEP_TXT ("AE_IO_ERROR",                   "An I/O error occurred")
 };
 
-char const   *AcpiGbl_ExceptionNames_Pgm[] =
+static const ACPI_EXCEPTION_INFO    AcpiGbl_ExceptionNames_Pgm[] =
 {
-    NULL,
-    "AE_BAD_PARAMETER",
-    "AE_BAD_CHARACTER",
-    "AE_BAD_PATHNAME",
-    "AE_BAD_DATA",
-    "AE_BAD_HEX_CONSTANT",
-    "AE_BAD_OCTAL_CONSTANT",
-    "AE_BAD_DECIMAL_CONSTANT",
-    "AE_MISSING_ARGUMENTS",
-    "AE_BAD_ADDRESS"
+    EXCEP_TXT (NULL, NULL),
+    EXCEP_TXT ("AE_BAD_PARAMETER",              "A parameter is out of range or invalid"),
+    EXCEP_TXT ("AE_BAD_CHARACTER",              "An invalid character was found in a name"),
+    EXCEP_TXT ("AE_BAD_PATHNAME",               "An invalid character was found in a pathname"),
+    EXCEP_TXT ("AE_BAD_DATA",                   "A package or buffer contained incorrect data"),
+    EXCEP_TXT ("AE_BAD_HEX_CONSTANT",           "Invalid character in a Hex constant"),
+    EXCEP_TXT ("AE_BAD_OCTAL_CONSTANT",         "Invalid character in an Octal constant"),
+    EXCEP_TXT ("AE_BAD_DECIMAL_CONSTANT",       "Invalid character in a Decimal constant"),
+    EXCEP_TXT ("AE_MISSING_ARGUMENTS",          "Too few arguments were passed to a control method"),
+    EXCEP_TXT ("AE_BAD_ADDRESS",                "An illegal null I/O address")
 };
 
-char const   *AcpiGbl_ExceptionNames_Tbl[] =
+static const ACPI_EXCEPTION_INFO    AcpiGbl_ExceptionNames_Tbl[] =
 {
-    NULL,
-    "AE_BAD_SIGNATURE",
-    "AE_BAD_HEADER",
-    "AE_BAD_CHECKSUM",
-    "AE_BAD_VALUE",
-    "AE_INVALID_TABLE_LENGTH"
+    EXCEP_TXT (NULL, NULL),
+    EXCEP_TXT ("AE_BAD_SIGNATURE",              "An ACPI table has an invalid signature"),
+    EXCEP_TXT ("AE_BAD_HEADER",                 "Invalid field in an ACPI table header"),
+    EXCEP_TXT ("AE_BAD_CHECKSUM",               "An ACPI table checksum is not correct"),
+    EXCEP_TXT ("AE_BAD_VALUE",                  "An invalid value was found in a table"),
+    EXCEP_TXT ("AE_INVALID_TABLE_LENGTH",       "The FADT or FACS has improper length")
 };
 
-char const   *AcpiGbl_ExceptionNames_Aml[] =
+static const ACPI_EXCEPTION_INFO    AcpiGbl_ExceptionNames_Aml[] =
 {
-    NULL,
-    "AE_AML_BAD_OPCODE",
-    "AE_AML_NO_OPERAND",
-    "AE_AML_OPERAND_TYPE",
-    "AE_AML_OPERAND_VALUE",
-    "AE_AML_UNINITIALIZED_LOCAL",
-    "AE_AML_UNINITIALIZED_ARG",
-    "AE_AML_UNINITIALIZED_ELEMENT",
-    "AE_AML_NUMERIC_OVERFLOW",
-    "AE_AML_REGION_LIMIT",
-    "AE_AML_BUFFER_LIMIT",
-    "AE_AML_PACKAGE_LIMIT",
-    "AE_AML_DIVIDE_BY_ZERO",
-    "AE_AML_BAD_NAME",
-    "AE_AML_NAME_NOT_FOUND",
-    "AE_AML_INTERNAL",
-    "AE_AML_INVALID_SPACE_ID",
-    "AE_AML_STRING_LIMIT",
-    "AE_AML_NO_RETURN_VALUE",
-    "AE_AML_METHOD_LIMIT",
-    "AE_AML_NOT_OWNER",
-    "AE_AML_MUTEX_ORDER",
-    "AE_AML_MUTEX_NOT_ACQUIRED",
-    "AE_AML_INVALID_RESOURCE_TYPE",
-    "AE_AML_INVALID_INDEX",
-    "AE_AML_REGISTER_LIMIT",
-    "AE_AML_NO_WHILE",
-    "AE_AML_ALIGNMENT",
-    "AE_AML_NO_RESOURCE_END_TAG",
-    "AE_AML_BAD_RESOURCE_VALUE",
-    "AE_AML_CIRCULAR_REFERENCE",
-    "AE_AML_BAD_RESOURCE_LENGTH",
-    "AE_AML_ILLEGAL_ADDRESS",
-    "AE_AML_INFINITE_LOOP"
+    EXCEP_TXT (NULL, NULL),
+    EXCEP_TXT ("AE_AML_BAD_OPCODE",             "Invalid AML opcode encountered"),
+    EXCEP_TXT ("AE_AML_NO_OPERAND",             "A required operand is missing"),
+    EXCEP_TXT ("AE_AML_OPERAND_TYPE",           "An operand of an incorrect type was encountered"),
+    EXCEP_TXT ("AE_AML_OPERAND_VALUE",          "The operand had an inappropriate or invalid value"),
+    EXCEP_TXT ("AE_AML_UNINITIALIZED_LOCAL",    "Method tried to use an uninitialized local variable"),
+    EXCEP_TXT ("AE_AML_UNINITIALIZED_ARG",      "Method tried to use an uninitialized argument"),
+    EXCEP_TXT ("AE_AML_UNINITIALIZED_ELEMENT",  "Method tried to use an empty package element"),
+    EXCEP_TXT ("AE_AML_NUMERIC_OVERFLOW",       "Overflow during BCD conversion or other"),
+    EXCEP_TXT ("AE_AML_REGION_LIMIT",           "Tried to access beyond the end of an Operation Region"),
+    EXCEP_TXT ("AE_AML_BUFFER_LIMIT",           "Tried to access beyond the end of a buffer"),
+    EXCEP_TXT ("AE_AML_PACKAGE_LIMIT",          "Tried to access beyond the end of a package"),
+    EXCEP_TXT ("AE_AML_DIVIDE_BY_ZERO",         "During execution of AML Divide operator"),
+    EXCEP_TXT ("AE_AML_BAD_NAME",               "An ACPI name contains invalid character(s)"),
+    EXCEP_TXT ("AE_AML_NAME_NOT_FOUND",         "Could not resolve a named reference"),
+    EXCEP_TXT ("AE_AML_INTERNAL",               "An internal error within the interprete"),
+    EXCEP_TXT ("AE_AML_INVALID_SPACE_ID",       "An Operation Region SpaceID is invalid"),
+    EXCEP_TXT ("AE_AML_STRING_LIMIT",           "String is longer than 200 characters"),
+    EXCEP_TXT ("AE_AML_NO_RETURN_VALUE",        "A method did not return a required value"),
+    EXCEP_TXT ("AE_AML_METHOD_LIMIT",           "A control method reached the maximum reentrancy limit of 255"),
+    EXCEP_TXT ("AE_AML_NOT_OWNER",              "A thread tried to release a mutex that it does not own"),
+    EXCEP_TXT ("AE_AML_MUTEX_ORDER",            "Mutex SyncLevel release mismatch"),
+    EXCEP_TXT ("AE_AML_MUTEX_NOT_ACQUIRED",     "Attempt to release a mutex that was not previously acquired"),
+    EXCEP_TXT ("AE_AML_INVALID_RESOURCE_TYPE",  "Invalid resource type in resource list"),
+    EXCEP_TXT ("AE_AML_INVALID_INDEX",          "Invalid Argx or Localx (x too large)"),
+    EXCEP_TXT ("AE_AML_REGISTER_LIMIT",         "Bank value or Index value beyond range of register"),
+    EXCEP_TXT ("AE_AML_NO_WHILE",               "Break or Continue without a While"),
+    EXCEP_TXT ("AE_AML_ALIGNMENT",              "Non-aligned memory transfer on platform that does not support this"),
+    EXCEP_TXT ("AE_AML_NO_RESOURCE_END_TAG",    "No End Tag in a resource list"),
+    EXCEP_TXT ("AE_AML_BAD_RESOURCE_VALUE",     "Invalid value of a resource element"),
+    EXCEP_TXT ("AE_AML_CIRCULAR_REFERENCE",     "Two references refer to each other"),
+    EXCEP_TXT ("AE_AML_BAD_RESOURCE_LENGTH",    "The length of a Resource Descriptor in the AML is incorrect"),
+    EXCEP_TXT ("AE_AML_ILLEGAL_ADDRESS",        "A memory, I/O, or PCI configuration address is invalid"),
+    EXCEP_TXT ("AE_AML_INFINITE_LOOP",          "An apparent infinite AML While loop, method was aborted"),
+    EXCEP_TXT ("AE_AML_UNINITIALIZED_NODE",     "A namespace node is uninitialized or unresolved"),
+    EXCEP_TXT ("AE_AML_TARGET_TYPE",            "A target operand of an incorrect type was encountered")
 };
 
-char const   *AcpiGbl_ExceptionNames_Ctrl[] =
+static const ACPI_EXCEPTION_INFO    AcpiGbl_ExceptionNames_Ctrl[] =
 {
-    NULL,
-    "AE_CTRL_RETURN_VALUE",
-    "AE_CTRL_PENDING",
-    "AE_CTRL_TERMINATE",
-    "AE_CTRL_TRUE",
-    "AE_CTRL_FALSE",
-    "AE_CTRL_DEPTH",
-    "AE_CTRL_END",
-    "AE_CTRL_TRANSFER",
-    "AE_CTRL_BREAK",
-    "AE_CTRL_CONTINUE",
-    "AE_CTRL_SKIP",
-    "AE_CTRL_PARSE_CONTINUE",
-    "AE_CTRL_PARSE_PENDING"
+    EXCEP_TXT (NULL, NULL),
+    EXCEP_TXT ("AE_CTRL_RETURN_VALUE",          "A Method returned a value"),
+    EXCEP_TXT ("AE_CTRL_PENDING",               "Method is calling another method"),
+    EXCEP_TXT ("AE_CTRL_TERMINATE",             "Terminate the executing method"),
+    EXCEP_TXT ("AE_CTRL_TRUE",                  "An If or While predicate result"),
+    EXCEP_TXT ("AE_CTRL_FALSE",                 "An If or While predicate result"),
+    EXCEP_TXT ("AE_CTRL_DEPTH",                 "Maximum search depth has been reached"),
+    EXCEP_TXT ("AE_CTRL_END",                   "An If or While predicate is false"),
+    EXCEP_TXT ("AE_CTRL_TRANSFER",              "Transfer control to called method"),
+    EXCEP_TXT ("AE_CTRL_BREAK",                 "A Break has been executed"),
+    EXCEP_TXT ("AE_CTRL_CONTINUE",              "A Continue has been executed"),
+    EXCEP_TXT ("AE_CTRL_SKIP",                  "Not currently used"),
+    EXCEP_TXT ("AE_CTRL_PARSE_CONTINUE",        "Used to skip over bad opcodes"),
+    EXCEP_TXT ("AE_CTRL_PARSE_PENDING",         "Used to implement AML While loops")
 };
 
-#endif /* ACPI GLOBALS */
+#endif /* EXCEPTION_TABLE */
 
 #endif /* __ACEXCEP_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/acglobal.h b/usr/src/uts/intel/sys/acpi/acglobal.h
index 79e53d07e2..a883ac4921 100644
--- a/usr/src/uts/intel/sys/acpi/acglobal.h
+++ b/usr/src/uts/intel/sys/acpi/acglobal.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -45,155 +45,46 @@
 #define __ACGLOBAL_H__
 
 
-/*
- * Ensure that the globals are actually defined and initialized only once.
- *
- * The use of these macros allows a single list of globals (here) in order
- * to simplify maintenance of the code.
- */
-#ifdef DEFINE_ACPI_GLOBALS
-#define ACPI_EXTERN
-#define ACPI_INIT_GLOBAL(a,b) a=b
-#else
-#define ACPI_EXTERN extern
-#define ACPI_INIT_GLOBAL(a,b) a
-#endif
-
-
-#ifdef DEFINE_ACPI_GLOBALS
-
-/* Public globals, available from outside ACPICA subsystem */
-
 /*****************************************************************************
  *
- * Runtime configuration (static defaults that can be overriden at runtime)
+ * Globals related to the ACPI tables
  *
  ****************************************************************************/
 
-/*
- * Enable "slack" in the AML interpreter?  Default is FALSE, and the
- * interpreter strictly follows the ACPI specification.  Setting to TRUE
- * allows the interpreter to ignore certain errors and/or bad AML constructs.
- *
- * Currently, these features are enabled by this flag:
- *
- * 1) Allow "implicit return" of last value in a control method
- * 2) Allow access beyond the end of an operation region
- * 3) Allow access to uninitialized locals/args (auto-init to integer 0)
- * 4) Allow ANY object type to be a source operand for the Store() operator
- * 5) Allow unresolved references (invalid target name) in package objects
- * 6) Enable warning messages for behavior that is not ACPI spec compliant
- */
-UINT8       ACPI_INIT_GLOBAL (AcpiGbl_EnableInterpreterSlack, FALSE);
+/* Master list of all ACPI tables that were found in the RSDT/XSDT */
 
-/*
- * Automatically serialize ALL control methods? Default is FALSE, meaning
- * to use the Serialized/NotSerialized method flags on a per method basis.
- * Only change this if the ASL code is poorly written and cannot handle
- * reentrancy even though methods are marked "NotSerialized".
- */
-UINT8       ACPI_INIT_GLOBAL (AcpiGbl_AllMethodsSerialized, FALSE);
-
-/*
- * Create the predefined _OSI method in the namespace? Default is TRUE
- * because ACPI CA is fully compatible with other ACPI implementations.
- * Changing this will revert ACPI CA (and machine ASL) to pre-OSI behavior.
- */
-UINT8       ACPI_INIT_GLOBAL (AcpiGbl_CreateOsiMethod, TRUE);
-
-/*
- * Optionally use default values for the ACPI register widths. Set this to
- * TRUE to use the defaults, if an FADT contains incorrect widths/lengths.
- */
-UINT8       ACPI_INIT_GLOBAL (AcpiGbl_UseDefaultRegisterWidths, TRUE);
-
-/*
- * Optionally enable output from the AML Debug Object.
- */
-UINT8       ACPI_INIT_GLOBAL (AcpiGbl_EnableAmlDebugObject, FALSE);
+ACPI_GLOBAL (ACPI_TABLE_LIST,           AcpiGbl_RootTableList);
 
-/*
- * Optionally copy the entire DSDT to local memory (instead of simply
- * mapping it.) There are some BIOSs that corrupt or replace the original
- * DSDT, creating the need for this option. Default is FALSE, do not copy
- * the DSDT.
- */
-UINT8       ACPI_INIT_GLOBAL (AcpiGbl_CopyDsdtLocally, FALSE);
-
-/*
- * Optionally truncate I/O addresses to 16 bits. Provides compatibility
- * with other ACPI implementations. NOTE: During ACPICA initialization,
- * this value is set to TRUE if any Windows OSI strings have been
- * requested by the BIOS.
- */
-UINT8       ACPI_INIT_GLOBAL (AcpiGbl_TruncateIoAddresses, FALSE);
-
-/*
- * Disable runtime checking and repair of values returned by control methods.
- * Use only if the repair is causing a problem on a particular machine.
- */
-UINT8       ACPI_INIT_GLOBAL (AcpiGbl_DisableAutoRepair, FALSE);
-
-
-/* AcpiGbl_FADT is a local copy of the FADT, converted to a common format. */
-
-ACPI_TABLE_FADT             AcpiGbl_FADT;
-UINT32                      AcpiCurrentGpeCount;
-UINT32                      AcpiGbl_TraceFlags;
-ACPI_NAME                   AcpiGbl_TraceMethodName;
-BOOLEAN                     AcpiGbl_SystemAwakeAndRunning;
-
-/*
- * ACPI 5.0 introduces the concept of a "reduced hardware platform", meaning
- * that the ACPI hardware is no longer required. A flag in the FADT indicates
- * a reduced HW machine, and that flag is duplicated here for convenience.
- */
-BOOLEAN                     AcpiGbl_ReducedHardware;
-
-#endif /* DEFINE_ACPI_GLOBALS */
-
-/* Do not disassemble buffers to resource descriptors */
-
-ACPI_EXTERN UINT8       ACPI_INIT_GLOBAL (AcpiGbl_NoResourceDisassembly, FALSE);
+/* DSDT information. Used to check for DSDT corruption */
 
-/*****************************************************************************
- *
- * ACPI Table globals
- *
- ****************************************************************************/
-
-/*
- * AcpiGbl_RootTableList is the master list of ACPI tables that were
- * found in the RSDT/XSDT.
- */
-ACPI_EXTERN ACPI_TABLE_LIST             AcpiGbl_RootTableList;
+ACPI_GLOBAL (ACPI_TABLE_HEADER *,       AcpiGbl_DSDT);
+ACPI_GLOBAL (ACPI_TABLE_HEADER,         AcpiGbl_OriginalDsdtHeader);
+ACPI_INIT_GLOBAL (UINT32,               AcpiGbl_DsdtIndex, ACPI_INVALID_TABLE_INDEX);
+ACPI_INIT_GLOBAL (UINT32,               AcpiGbl_FacsIndex, ACPI_INVALID_TABLE_INDEX);
+ACPI_INIT_GLOBAL (UINT32,               AcpiGbl_XFacsIndex, ACPI_INVALID_TABLE_INDEX);
+ACPI_INIT_GLOBAL (UINT32,               AcpiGbl_FadtIndex, ACPI_INVALID_TABLE_INDEX);
 
 #if (!ACPI_REDUCED_HARDWARE)
-ACPI_EXTERN ACPI_TABLE_FACS            *AcpiGbl_FACS;
+ACPI_GLOBAL (ACPI_TABLE_FACS *,         AcpiGbl_FACS);
 
 #endif /* !ACPI_REDUCED_HARDWARE */
 
 /* These addresses are calculated from the FADT Event Block addresses */
 
-ACPI_EXTERN ACPI_GENERIC_ADDRESS        AcpiGbl_XPm1aStatus;
-ACPI_EXTERN ACPI_GENERIC_ADDRESS        AcpiGbl_XPm1aEnable;
-
-ACPI_EXTERN ACPI_GENERIC_ADDRESS        AcpiGbl_XPm1bStatus;
-ACPI_EXTERN ACPI_GENERIC_ADDRESS        AcpiGbl_XPm1bEnable;
-
-/* DSDT information. Used to check for DSDT corruption */
+ACPI_GLOBAL (ACPI_GENERIC_ADDRESS,      AcpiGbl_XPm1aStatus);
+ACPI_GLOBAL (ACPI_GENERIC_ADDRESS,      AcpiGbl_XPm1aEnable);
 
-ACPI_EXTERN ACPI_TABLE_HEADER          *AcpiGbl_DSDT;
-ACPI_EXTERN ACPI_TABLE_HEADER           AcpiGbl_OriginalDsdtHeader;
+ACPI_GLOBAL (ACPI_GENERIC_ADDRESS,      AcpiGbl_XPm1bStatus);
+ACPI_GLOBAL (ACPI_GENERIC_ADDRESS,      AcpiGbl_XPm1bEnable);
 
 /*
- * Handle both ACPI 1.0 and ACPI 2.0 Integer widths. The integer width is
+ * Handle both ACPI 1.0 and ACPI 2.0+ Integer widths. The integer width is
  * determined by the revision of the DSDT: If the DSDT revision is less than
  * 2, use only the lower 32 bits of the internal 64-bit Integer.
  */
-ACPI_EXTERN UINT8                       AcpiGbl_IntegerBitWidth;
-ACPI_EXTERN UINT8                       AcpiGbl_IntegerByteWidth;
-ACPI_EXTERN UINT8                       AcpiGbl_IntegerNybbleWidth;
+ACPI_GLOBAL (UINT8,                     AcpiGbl_IntegerBitWidth);
+ACPI_GLOBAL (UINT8,                     AcpiGbl_IntegerByteWidth);
+ACPI_GLOBAL (UINT8,                     AcpiGbl_IntegerNybbleWidth);
 
 
 /*****************************************************************************
@@ -207,35 +98,36 @@ ACPI_EXTERN UINT8                       AcpiGbl_IntegerNybbleWidth;
  * actual OS mutex handles, indexed by the local ACPI_MUTEX_HANDLEs.
  * (The table maps local handles to the real OS handles)
  */
-ACPI_EXTERN ACPI_MUTEX_INFO             AcpiGbl_MutexInfo[ACPI_NUM_MUTEX];
+ACPI_GLOBAL (ACPI_MUTEX_INFO,           AcpiGbl_MutexInfo[ACPI_NUM_MUTEX]);
 
 /*
  * Global lock mutex is an actual AML mutex object
  * Global lock semaphore works in conjunction with the actual global lock
  * Global lock spinlock is used for "pending" handshake
  */
-ACPI_EXTERN ACPI_OPERAND_OBJECT        *AcpiGbl_GlobalLockMutex;
-ACPI_EXTERN ACPI_SEMAPHORE              AcpiGbl_GlobalLockSemaphore;
-ACPI_EXTERN ACPI_SPINLOCK               AcpiGbl_GlobalLockPendingLock;
-ACPI_EXTERN UINT16                      AcpiGbl_GlobalLockHandle;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_GlobalLockAcquired;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_GlobalLockPresent;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_GlobalLockPending;
+ACPI_GLOBAL (ACPI_OPERAND_OBJECT *,     AcpiGbl_GlobalLockMutex);
+ACPI_GLOBAL (ACPI_SEMAPHORE,            AcpiGbl_GlobalLockSemaphore);
+ACPI_GLOBAL (ACPI_SPINLOCK,             AcpiGbl_GlobalLockPendingLock);
+ACPI_GLOBAL (UINT16,                    AcpiGbl_GlobalLockHandle);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_GlobalLockAcquired);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_GlobalLockPresent);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_GlobalLockPending);
 
 /*
  * Spinlocks are used for interfaces that can be possibly called at
  * interrupt level
  */
-ACPI_EXTERN ACPI_SPINLOCK               AcpiGbl_GpeLock;      /* For GPE data structs and registers */
-ACPI_EXTERN ACPI_SPINLOCK               AcpiGbl_HardwareLock; /* For ACPI H/W except GPE registers */
+ACPI_GLOBAL (ACPI_SPINLOCK,             AcpiGbl_GpeLock);       /* For GPE data structs and registers */
+ACPI_GLOBAL (ACPI_SPINLOCK,             AcpiGbl_HardwareLock);  /* For ACPI H/W except GPE registers */
+ACPI_GLOBAL (ACPI_SPINLOCK,             AcpiGbl_ReferenceCountLock);
 
 /* Mutex for _OSI support */
 
-ACPI_EXTERN ACPI_MUTEX                  AcpiGbl_OsiMutex;
+ACPI_GLOBAL (ACPI_MUTEX,                AcpiGbl_OsiMutex);
 
 /* Reader/Writer lock is used for namespace walk and dynamic table unload */
 
-ACPI_EXTERN ACPI_RW_LOCK                AcpiGbl_NamespaceRwLock;
+ACPI_GLOBAL (ACPI_RW_LOCK,              AcpiGbl_NamespaceRwLock);
 
 
 /*****************************************************************************
@@ -246,78 +138,70 @@ ACPI_EXTERN ACPI_RW_LOCK                AcpiGbl_NamespaceRwLock;
 
 /* Object caches */
 
-ACPI_EXTERN ACPI_CACHE_T               *AcpiGbl_NamespaceCache;
-ACPI_EXTERN ACPI_CACHE_T               *AcpiGbl_StateCache;
-ACPI_EXTERN ACPI_CACHE_T               *AcpiGbl_PsNodeCache;
-ACPI_EXTERN ACPI_CACHE_T               *AcpiGbl_PsNodeExtCache;
-ACPI_EXTERN ACPI_CACHE_T               *AcpiGbl_OperandCache;
+ACPI_GLOBAL (ACPI_CACHE_T *,            AcpiGbl_NamespaceCache);
+ACPI_GLOBAL (ACPI_CACHE_T *,            AcpiGbl_StateCache);
+ACPI_GLOBAL (ACPI_CACHE_T *,            AcpiGbl_PsNodeCache);
+ACPI_GLOBAL (ACPI_CACHE_T *,            AcpiGbl_PsNodeExtCache);
+ACPI_GLOBAL (ACPI_CACHE_T *,            AcpiGbl_OperandCache);
+
+/* System */
+
+ACPI_INIT_GLOBAL (UINT32,               AcpiGbl_StartupFlags, 0);
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_Shutdown, TRUE);
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_EarlyInitialization, TRUE);
 
 /* Global handlers */
 
-ACPI_EXTERN ACPI_GLOBAL_NOTIFY_HANDLER  AcpiGbl_GlobalNotify[2];
-ACPI_EXTERN ACPI_EXCEPTION_HANDLER      AcpiGbl_ExceptionHandler;
-ACPI_EXTERN ACPI_INIT_HANDLER           AcpiGbl_InitHandler;
-ACPI_EXTERN ACPI_TABLE_HANDLER          AcpiGbl_TableHandler;
-ACPI_EXTERN void                       *AcpiGbl_TableHandlerContext;
-ACPI_EXTERN ACPI_WALK_STATE            *AcpiGbl_BreakpointWalk;
-ACPI_EXTERN ACPI_INTERFACE_HANDLER      AcpiGbl_InterfaceHandler;
+ACPI_GLOBAL (ACPI_GLOBAL_NOTIFY_HANDLER,AcpiGbl_GlobalNotify[2]);
+ACPI_GLOBAL (ACPI_EXCEPTION_HANDLER,    AcpiGbl_ExceptionHandler);
+ACPI_GLOBAL (ACPI_INIT_HANDLER,         AcpiGbl_InitHandler);
+ACPI_GLOBAL (ACPI_TABLE_HANDLER,        AcpiGbl_TableHandler);
+ACPI_GLOBAL (void *,                    AcpiGbl_TableHandlerContext);
+ACPI_GLOBAL (ACPI_INTERFACE_HANDLER,    AcpiGbl_InterfaceHandler);
+ACPI_GLOBAL (ACPI_SCI_HANDLER_INFO *,   AcpiGbl_SciHandlerList);
 
 /* Owner ID support */
 
-ACPI_EXTERN UINT32                      AcpiGbl_OwnerIdMask[ACPI_NUM_OWNERID_MASKS];
-ACPI_EXTERN UINT8                       AcpiGbl_LastOwnerIdIndex;
-ACPI_EXTERN UINT8                       AcpiGbl_NextOwnerIdOffset;
+ACPI_GLOBAL (UINT32,                    AcpiGbl_OwnerIdMask[ACPI_NUM_OWNERID_MASKS]);
+ACPI_GLOBAL (UINT8,                     AcpiGbl_LastOwnerIdIndex);
+ACPI_GLOBAL (UINT8,                     AcpiGbl_NextOwnerIdOffset);
 
 /* Initialization sequencing */
 
-ACPI_EXTERN BOOLEAN                     AcpiGbl_RegMethodsExecuted;
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_NamespaceInitialized, FALSE);
 
 /* Misc */
 
-ACPI_EXTERN UINT32                      AcpiGbl_OriginalMode;
-ACPI_EXTERN UINT32                      AcpiGbl_RsdpOriginalLocation;
-ACPI_EXTERN UINT32                      AcpiGbl_NsLookupCount;
-ACPI_EXTERN UINT32                      AcpiGbl_PsFindCount;
-ACPI_EXTERN UINT16                      AcpiGbl_Pm1EnableRegisterSave;
-ACPI_EXTERN UINT8                       AcpiGbl_DebuggerConfiguration;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_StepToNextCall;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_AcpiHardwarePresent;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_EventsInitialized;
-ACPI_EXTERN UINT8                       AcpiGbl_OsiData;
-ACPI_EXTERN ACPI_INTERFACE_INFO        *AcpiGbl_SupportedInterfaces;
-ACPI_EXTERN ACPI_ADDRESS_RANGE         *AcpiGbl_AddressRangeList[ACPI_ADDRESS_RANGE_MAX];
+ACPI_GLOBAL (UINT32,                    AcpiGbl_OriginalMode);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_NsLookupCount);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_PsFindCount);
+ACPI_GLOBAL (UINT16,                    AcpiGbl_Pm1EnableRegisterSave);
+ACPI_GLOBAL (UINT8,                     AcpiGbl_DebuggerConfiguration);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_StepToNextCall);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_AcpiHardwarePresent);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_EventsInitialized);
+ACPI_GLOBAL (ACPI_INTERFACE_INFO *,     AcpiGbl_SupportedInterfaces);
+ACPI_GLOBAL (ACPI_ADDRESS_RANGE *,      AcpiGbl_AddressRangeList[ACPI_ADDRESS_RANGE_MAX]);
 
+/* Other miscellaneous, declared and initialized in utglobal */
 
-#ifndef DEFINE_ACPI_GLOBALS
-
-/* Exception codes */
-
-extern char const                       *AcpiGbl_ExceptionNames_Env[];
-extern char const                       *AcpiGbl_ExceptionNames_Pgm[];
-extern char const                       *AcpiGbl_ExceptionNames_Tbl[];
-extern char const                       *AcpiGbl_ExceptionNames_Aml[];
-extern char const                       *AcpiGbl_ExceptionNames_Ctrl[];
-
-/* Other miscellaneous */
-
-extern BOOLEAN                          AcpiGbl_Shutdown;
-extern UINT32                           AcpiGbl_StartupFlags;
 extern const char                      *AcpiGbl_SleepStateNames[ACPI_S_STATE_COUNT];
 extern const char                      *AcpiGbl_LowestDstateNames[ACPI_NUM_SxW_METHODS];
 extern const char                      *AcpiGbl_HighestDstateNames[ACPI_NUM_SxD_METHODS];
-extern const ACPI_OPCODE_INFO           AcpiGbl_AmlOpInfo[AML_NUM_OPCODES];
 extern const char                      *AcpiGbl_RegionTypes[ACPI_NUM_PREDEFINED_REGIONS];
-#endif
+extern const char                       AcpiGbl_LowerHexDigits[];
+extern const char                       AcpiGbl_UpperHexDigits[];
+extern const ACPI_OPCODE_INFO           AcpiGbl_AmlOpInfo[AML_NUM_OPCODES];
 
 
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
 
-/* Lists for tracking memory allocations */
+/* Lists for tracking memory allocations (debug only) */
 
-ACPI_EXTERN ACPI_MEMORY_LIST           *AcpiGbl_GlobalList;
-ACPI_EXTERN ACPI_MEMORY_LIST           *AcpiGbl_NsNodeList;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_DisplayFinalMemStats;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_DisableMemTracking;
+ACPI_GLOBAL (ACPI_MEMORY_LIST *,        AcpiGbl_GlobalList);
+ACPI_GLOBAL (ACPI_MEMORY_LIST *,        AcpiGbl_NsNodeList);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_DisplayFinalMemStats);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_DisableMemTracking);
 #endif
 
 
@@ -333,22 +217,23 @@ ACPI_EXTERN BOOLEAN                     AcpiGbl_DisableMemTracking;
 #define NUM_PREDEFINED_NAMES            9
 #endif
 
-ACPI_EXTERN ACPI_NAMESPACE_NODE         AcpiGbl_RootNodeStruct;
-ACPI_EXTERN ACPI_NAMESPACE_NODE        *AcpiGbl_RootNode;
-ACPI_EXTERN ACPI_NAMESPACE_NODE        *AcpiGbl_FadtGpeDevice;
-ACPI_EXTERN ACPI_OPERAND_OBJECT        *AcpiGbl_ModuleCodeList;
+ACPI_GLOBAL (ACPI_NAMESPACE_NODE,       AcpiGbl_RootNodeStruct);
+ACPI_GLOBAL (ACPI_NAMESPACE_NODE *,     AcpiGbl_RootNode);
+ACPI_GLOBAL (ACPI_NAMESPACE_NODE *,     AcpiGbl_FadtGpeDevice);
+ACPI_GLOBAL (ACPI_OPERAND_OBJECT *,     AcpiGbl_ModuleCodeList);
 
 
 extern const UINT8                      AcpiGbl_NsProperties [ACPI_NUM_NS_TYPES];
 extern const ACPI_PREDEFINED_NAMES      AcpiGbl_PreDefinedNames [NUM_PREDEFINED_NAMES];
 
 #ifdef ACPI_DEBUG_OUTPUT
-ACPI_EXTERN UINT32                      AcpiGbl_CurrentNodeCount;
-ACPI_EXTERN UINT32                      AcpiGbl_CurrentNodeSize;
-ACPI_EXTERN UINT32                      AcpiGbl_MaxConcurrentNodeCount;
-ACPI_EXTERN ACPI_SIZE                  *AcpiGbl_EntryStackPointer;
-ACPI_EXTERN ACPI_SIZE                  *AcpiGbl_LowestStackPointer;
-ACPI_EXTERN UINT32                      AcpiGbl_DeepestNesting;
+ACPI_GLOBAL (UINT32,                    AcpiGbl_CurrentNodeCount);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_CurrentNodeSize);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_MaxConcurrentNodeCount);
+ACPI_GLOBAL (ACPI_SIZE *,               AcpiGbl_EntryStackPointer);
+ACPI_GLOBAL (ACPI_SIZE *,               AcpiGbl_LowestStackPointer);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_DeepestNesting);
+ACPI_INIT_GLOBAL (UINT32,               AcpiGbl_NestingLevel, 0);
 #endif
 
 
@@ -358,12 +243,15 @@ ACPI_EXTERN UINT32                      AcpiGbl_DeepestNesting;
  *
  ****************************************************************************/
 
+ACPI_GLOBAL (ACPI_THREAD_STATE *,       AcpiGbl_CurrentWalkList);
+
+/* Maximum number of While() loop iterations before forced abort */
 
-ACPI_EXTERN ACPI_THREAD_STATE          *AcpiGbl_CurrentWalkList;
+ACPI_GLOBAL (UINT16,                    AcpiGbl_MaxLoopIterations);
 
 /* Control method single step flag */
 
-ACPI_EXTERN UINT8                       AcpiGbl_CmSingleStep;
+ACPI_GLOBAL (UINT8,                     AcpiGbl_CmSingleStep);
 
 
 /*****************************************************************************
@@ -372,9 +260,10 @@ ACPI_EXTERN UINT8                       AcpiGbl_CmSingleStep;
  *
  ****************************************************************************/
 
-extern      ACPI_BIT_REGISTER_INFO      AcpiGbl_BitRegisterInfo[ACPI_NUM_BITREG];
-ACPI_EXTERN UINT8                       AcpiGbl_SleepTypeA;
-ACPI_EXTERN UINT8                       AcpiGbl_SleepTypeB;
+extern ACPI_BIT_REGISTER_INFO           AcpiGbl_BitRegisterInfo[ACPI_NUM_BITREG];
+
+ACPI_GLOBAL (UINT8,                     AcpiGbl_SleepTypeA);
+ACPI_GLOBAL (UINT8,                     AcpiGbl_SleepTypeB);
 
 
 /*****************************************************************************
@@ -385,13 +274,14 @@ ACPI_EXTERN UINT8                       AcpiGbl_SleepTypeB;
 
 #if (!ACPI_REDUCED_HARDWARE)
 
-ACPI_EXTERN UINT8                       AcpiGbl_AllGpesInitialized;
-ACPI_EXTERN ACPI_GPE_XRUPT_INFO        *AcpiGbl_GpeXruptListHead;
-ACPI_EXTERN ACPI_GPE_BLOCK_INFO        *AcpiGbl_GpeFadtBlocks[ACPI_MAX_GPE_BLOCKS];
-ACPI_EXTERN ACPI_GBL_EVENT_HANDLER      AcpiGbl_GlobalEventHandler;
-ACPI_EXTERN void                       *AcpiGbl_GlobalEventHandlerContext;
-ACPI_EXTERN ACPI_FIXED_EVENT_HANDLER    AcpiGbl_FixedEventHandlers[ACPI_NUM_FIXED_EVENTS];
-extern      ACPI_FIXED_EVENT_INFO       AcpiGbl_FixedEventInfo[ACPI_NUM_FIXED_EVENTS];
+ACPI_GLOBAL (UINT8,                     AcpiGbl_AllGpesInitialized);
+ACPI_GLOBAL (ACPI_GPE_XRUPT_INFO *,     AcpiGbl_GpeXruptListHead);
+ACPI_GLOBAL (ACPI_GPE_BLOCK_INFO *,     AcpiGbl_GpeFadtBlocks[ACPI_MAX_GPE_BLOCKS]);
+ACPI_GLOBAL (ACPI_GBL_EVENT_HANDLER,    AcpiGbl_GlobalEventHandler);
+ACPI_GLOBAL (void *,                    AcpiGbl_GlobalEventHandlerContext);
+ACPI_GLOBAL (ACPI_FIXED_EVENT_HANDLER,  AcpiGbl_FixedEventHandlers[ACPI_NUM_FIXED_EVENTS]);
+
+extern ACPI_FIXED_EVENT_INFO            AcpiGbl_FixedEventInfo[ACPI_NUM_FIXED_EVENTS];
 
 #endif /* !ACPI_REDUCED_HARDWARE */
 
@@ -401,82 +291,124 @@ extern      ACPI_FIXED_EVENT_INFO       AcpiGbl_FixedEventInfo[ACPI_NUM_FIXED_EV
  *
  ****************************************************************************/
 
-/* Procedure nesting level for debug output */
-
-extern      UINT32                      AcpiGbl_NestingLevel;
-
 /* Event counters */
 
-ACPI_EXTERN UINT32                      AcpiMethodCount;
-ACPI_EXTERN UINT32                      AcpiGpeCount;
-ACPI_EXTERN UINT32                      AcpiSciCount;
-ACPI_EXTERN UINT32                      AcpiFixedEventCount[ACPI_NUM_FIXED_EVENTS];
+ACPI_GLOBAL (UINT32,                    AcpiMethodCount);
+ACPI_GLOBAL (UINT32,                    AcpiGpeCount);
+ACPI_GLOBAL (UINT32,                    AcpiSciCount);
+ACPI_GLOBAL (UINT32,                    AcpiFixedEventCount[ACPI_NUM_FIXED_EVENTS]);
 
 /* Support for dynamic control method tracing mechanism */
 
-ACPI_EXTERN UINT32                      AcpiGbl_OriginalDbgLevel;
-ACPI_EXTERN UINT32                      AcpiGbl_OriginalDbgLayer;
-ACPI_EXTERN UINT32                      AcpiGbl_TraceDbgLevel;
-ACPI_EXTERN UINT32                      AcpiGbl_TraceDbgLayer;
+ACPI_GLOBAL (UINT32,                    AcpiGbl_OriginalDbgLevel);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_OriginalDbgLayer);
 
 
 /*****************************************************************************
  *
- * Debugger globals
+ * Debugger and Disassembler globals
  *
  ****************************************************************************/
 
-ACPI_EXTERN UINT8                       AcpiGbl_DbOutputFlags;
+ACPI_INIT_GLOBAL (UINT8,                AcpiGbl_DbOutputFlags, ACPI_DB_CONSOLE_OUTPUT);
 
 #ifdef ACPI_DISASSEMBLER
 
-ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_disasm;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_verbose;
-ACPI_EXTERN ACPI_EXTERNAL_LIST         *AcpiGbl_ExternalList;
-ACPI_EXTERN ACPI_EXTERNAL_FILE         *AcpiGbl_ExternalFileList;
-#endif
+/* Do not disassemble buffers to resource descriptors */
 
+ACPI_INIT_GLOBAL (UINT8,                AcpiGbl_NoResourceDisassembly, FALSE);
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_IgnoreNoopOperator, FALSE);
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_CstyleDisassembly, TRUE);
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_ForceAmlDisassembly, FALSE);
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_DmOpt_Verbose, TRUE);
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_DmEmitExternalOpcodes, FALSE);
+
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_DmOpt_Disasm);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_DmOpt_Listing);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_NumExternalMethods);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_ResolvedExternalMethods);
+ACPI_GLOBAL (ACPI_EXTERNAL_LIST *,      AcpiGbl_ExternalList);
+ACPI_GLOBAL (ACPI_EXTERNAL_FILE *,      AcpiGbl_ExternalFileList);
+#endif
 
 #ifdef ACPI_DEBUGGER
 
-extern      BOOLEAN                     AcpiGbl_MethodExecuting;
-extern      BOOLEAN                     AcpiGbl_AbortMethod;
-extern      BOOLEAN                     AcpiGbl_DbTerminateThreads;
-
-ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_tables;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_stats;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_ini_methods;
-ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_NoRegionSupport;
-
-ACPI_EXTERN char                       *AcpiGbl_DbArgs[ACPI_DEBUGGER_MAX_ARGS];
-ACPI_EXTERN ACPI_OBJECT_TYPE            AcpiGbl_DbArgTypes[ACPI_DEBUGGER_MAX_ARGS];
-ACPI_EXTERN char                        AcpiGbl_DbLineBuf[ACPI_DB_LINE_BUFFER_SIZE];
-ACPI_EXTERN char                        AcpiGbl_DbParsedBuf[ACPI_DB_LINE_BUFFER_SIZE];
-ACPI_EXTERN char                        AcpiGbl_DbScopeBuf[80];
-ACPI_EXTERN char                        AcpiGbl_DbDebugFilename[80];
-ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOutputToFile;
-ACPI_EXTERN char                       *AcpiGbl_DbBuffer;
-ACPI_EXTERN char                       *AcpiGbl_DbFilename;
-ACPI_EXTERN UINT32                      AcpiGbl_DbDebugLevel;
-ACPI_EXTERN UINT32                      AcpiGbl_DbConsoleDebugLevel;
-ACPI_EXTERN ACPI_NAMESPACE_NODE        *AcpiGbl_DbScopeNode;
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_AbortMethod, FALSE);
+ACPI_INIT_GLOBAL (BOOLEAN,              AcpiGbl_MethodExecuting, FALSE);
+ACPI_INIT_GLOBAL (ACPI_THREAD_ID,       AcpiGbl_DbThreadId, ACPI_INVALID_THREAD_ID);
+
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_DbOpt_NoIniMethods);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_DbOpt_NoRegionSupport);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_DbOutputToFile);
+ACPI_GLOBAL (char *,                    AcpiGbl_DbBuffer);
+ACPI_GLOBAL (char *,                    AcpiGbl_DbFilename);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_DbDebugLevel);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_DbConsoleDebugLevel);
+ACPI_GLOBAL (ACPI_NAMESPACE_NODE *,     AcpiGbl_DbScopeNode);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_DbTerminateLoop);
+ACPI_GLOBAL (BOOLEAN,                   AcpiGbl_DbThreadsTerminated);
+
+ACPI_GLOBAL (char *,                    AcpiGbl_DbArgs[ACPI_DEBUGGER_MAX_ARGS]);
+ACPI_GLOBAL (ACPI_OBJECT_TYPE,          AcpiGbl_DbArgTypes[ACPI_DEBUGGER_MAX_ARGS]);
+
+/* These buffers should all be the same size */
+
+ACPI_GLOBAL (char,                      AcpiGbl_DbLineBuf[ACPI_DB_LINE_BUFFER_SIZE]);
+ACPI_GLOBAL (char,                      AcpiGbl_DbParsedBuf[ACPI_DB_LINE_BUFFER_SIZE]);
+ACPI_GLOBAL (char,                      AcpiGbl_DbScopeBuf[ACPI_DB_LINE_BUFFER_SIZE]);
+ACPI_GLOBAL (char,                      AcpiGbl_DbDebugFilename[ACPI_DB_LINE_BUFFER_SIZE]);
 
 /*
  * Statistic globals
  */
-ACPI_EXTERN UINT16                      AcpiGbl_ObjTypeCount[ACPI_TYPE_NS_NODE_MAX+1];
-ACPI_EXTERN UINT16                      AcpiGbl_NodeTypeCount[ACPI_TYPE_NS_NODE_MAX+1];
-ACPI_EXTERN UINT16                      AcpiGbl_ObjTypeCountMisc;
-ACPI_EXTERN UINT16                      AcpiGbl_NodeTypeCountMisc;
-ACPI_EXTERN UINT32                      AcpiGbl_NumNodes;
-ACPI_EXTERN UINT32                      AcpiGbl_NumObjects;
-
+ACPI_GLOBAL (UINT16,                    AcpiGbl_ObjTypeCount[ACPI_TOTAL_TYPES]);
+ACPI_GLOBAL (UINT16,                    AcpiGbl_NodeTypeCount[ACPI_TOTAL_TYPES]);
+ACPI_GLOBAL (UINT16,                    AcpiGbl_ObjTypeCountMisc);
+ACPI_GLOBAL (UINT16,                    AcpiGbl_NodeTypeCountMisc);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_NumNodes);
+ACPI_GLOBAL (UINT32,                    AcpiGbl_NumObjects);
 
-ACPI_EXTERN UINT32                      AcpiGbl_SizeOfParseTree;
-ACPI_EXTERN UINT32                      AcpiGbl_SizeOfMethodTrees;
-ACPI_EXTERN UINT32                      AcpiGbl_SizeOfNodeEntries;
-ACPI_EXTERN UINT32                      AcpiGbl_SizeOfAcpiObjects;
+ACPI_GLOBAL (ACPI_MUTEX,                AcpiGbl_DbCommandReady);
+ACPI_GLOBAL (ACPI_MUTEX,                AcpiGbl_DbCommandComplete);
 
 #endif /* ACPI_DEBUGGER */
 
+#if defined (ACPI_DISASSEMBLER) || defined (ACPI_ASL_COMPILER)
+
+ACPI_GLOBAL (const char,                *AcpiGbl_PldPanelList[]);
+ACPI_GLOBAL (const char,                *AcpiGbl_PldVerticalPositionList[]);
+ACPI_GLOBAL (const char,                *AcpiGbl_PldHorizontalPositionList[]);
+ACPI_GLOBAL (const char,                *AcpiGbl_PldShapeList[]);
+
+#endif
+
+/*****************************************************************************
+ *
+ * Application globals
+ *
+ ****************************************************************************/
+
+#ifdef ACPI_APPLICATION
+
+ACPI_INIT_GLOBAL (ACPI_FILE,            AcpiGbl_DebugFile, NULL);
+ACPI_INIT_GLOBAL (ACPI_FILE,            AcpiGbl_OutputFile, NULL);
+
+/* Print buffer */
+
+ACPI_GLOBAL (ACPI_SPINLOCK,             AcpiGbl_PrintLock);     /* For print buffer */
+ACPI_GLOBAL (char,                      AcpiGbl_PrintBuffer[1024]);
+
+#endif /* ACPI_APPLICATION */
+
+
+/*****************************************************************************
+ *
+ * Info/help support
+ *
+ ****************************************************************************/
+
+extern const AH_PREDEFINED_NAME         AslPredefinedInfo[];
+extern const AH_DEVICE_ID               AslDeviceIds[];
+
+
 #endif /* __ACGLOBAL_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/achware.h b/usr/src/uts/intel/sys/acpi/achware.h
index f607d1702a..b7a5f20fec 100644
--- a/usr/src/uts/intel/sys/acpi/achware.h
+++ b/usr/src/uts/intel/sys/acpi/achware.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -114,18 +114,15 @@ AcpiHwClearAcpiStatus (
  */
 ACPI_STATUS
 AcpiHwLegacySleep (
-    UINT8                   SleepState,
-    UINT8                   Flags);
+    UINT8                   SleepState);
 
 ACPI_STATUS
 AcpiHwLegacyWakePrep (
-    UINT8                   SleepState,
-    UINT8                   Flags);
+    UINT8                   SleepState);
 
 ACPI_STATUS
 AcpiHwLegacyWake (
-    UINT8                   SleepState,
-    UINT8                   Flags);
+    UINT8                   SleepState);
 
 
 /*
@@ -138,18 +135,15 @@ AcpiHwExecuteSleepMethod (
 
 ACPI_STATUS
 AcpiHwExtendedSleep (
-    UINT8                   SleepState,
-    UINT8                   Flags);
+    UINT8                   SleepState);
 
 ACPI_STATUS
 AcpiHwExtendedWakePrep (
-    UINT8                   SleepState,
-    UINT8                   Flags);
+    UINT8                   SleepState);
 
 ACPI_STATUS
 AcpiHwExtendedWake (
-    UINT8                   SleepState,
-    UINT8                   Flags);
+    UINT8                   SleepState);
 
 
 /*
@@ -173,8 +167,7 @@ AcpiHwWritePort (
  */
 UINT32
 AcpiHwGetGpeRegisterBit (
-    ACPI_GPE_EVENT_INFO     *GpeEventInfo,
-    ACPI_GPE_REGISTER_INFO  *GpeRegisterInfo);
+    ACPI_GPE_EVENT_INFO     *GpeEventInfo);
 
 ACPI_STATUS
 AcpiHwLowSetGpe (
diff --git a/usr/src/uts/intel/sys/acpi/acinterp.h b/usr/src/uts/intel/sys/acpi/acinterp.h
index 45e9814f79..148e8d0caf 100644
--- a/usr/src/uts/intel/sys/acpi/acinterp.h
+++ b/usr/src/uts/intel/sys/acpi/acinterp.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -69,7 +69,7 @@ typedef const struct acpi_exdump_info
 {
     UINT8                   Opcode;
     UINT8                   Offset;
-    char                    *Name;
+    const char              *Name;
 
 } ACPI_EXDUMP_INFO;
 
@@ -89,6 +89,10 @@ typedef const struct acpi_exdump_info
 #define ACPI_EXD_PACKAGE                11
 #define ACPI_EXD_FIELD                  12
 #define ACPI_EXD_REFERENCE              13
+#define ACPI_EXD_LIST                   14 /* Operand object list */
+#define ACPI_EXD_HDLR_LIST              15 /* Address Handler list */
+#define ACPI_EXD_RGN_LIST               16 /* Region list */
+#define ACPI_EXD_NODE                   17 /* Namespace Node */
 
 /* restore default alignment */
 
@@ -139,6 +143,35 @@ AcpiExDoDebugObject (
     UINT32                  Level,
     UINT32                  Index);
 
+void
+AcpiExStartTraceMethod (
+    ACPI_NAMESPACE_NODE     *MethodNode,
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_WALK_STATE         *WalkState);
+
+void
+AcpiExStopTraceMethod (
+    ACPI_NAMESPACE_NODE     *MethodNode,
+    ACPI_OPERAND_OBJECT     *ObjDesc,
+    ACPI_WALK_STATE         *WalkState);
+
+void
+AcpiExStartTraceOpcode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState);
+
+void
+AcpiExStopTraceOpcode (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_WALK_STATE         *WalkState);
+
+void
+AcpiExTracePoint (
+    ACPI_TRACE_EVENT_TYPE   Type,
+    BOOLEAN                 Begin,
+    UINT8                   *Aml,
+    char                    *Pathname);
+
 
 /*
  * exfield - ACPI AML (p-code) execution - field manipulation
@@ -612,15 +645,7 @@ void
 AcpiExExitInterpreter (
     void);
 
-void
-AcpiExReacquireInterpreter (
-    void);
-
-void
-AcpiExRelinquishInterpreter (
-    void);
-
-void
+BOOLEAN
 AcpiExTruncateFor32bitTable (
     ACPI_OPERAND_OBJECT     *ObjDesc);
 
@@ -642,6 +667,11 @@ AcpiExIntegerToString (
     char                    *Dest,
     UINT64                  Value);
 
+void
+AcpiExPciClsToString (
+    char                    *Dest,
+    UINT8                   ClassCode[3]);
+
 BOOLEAN
 AcpiIsValidSpaceId (
     UINT8                   SpaceId);
diff --git a/usr/src/uts/intel/sys/acpi/aclocal.h b/usr/src/uts/intel/sys/acpi/aclocal.h
index 68ea95b7c8..e7a0d37d14 100644
--- a/usr/src/uts/intel/sys/acpi/aclocal.h
+++ b/usr/src/uts/intel/sys/acpi/aclocal.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -54,7 +54,7 @@ typedef UINT32                          ACPI_MUTEX_HANDLE;
 
 /* Total number of aml opcodes defined */
 
-#define AML_NUM_OPCODES                 0x81
+#define AML_NUM_OPCODES                 0x82
 
 
 /* Forward declarations */
@@ -87,11 +87,9 @@ union acpi_parse_object;
 #define ACPI_MTX_EVENTS                 3   /* Data for ACPI events */
 #define ACPI_MTX_CACHES                 4   /* Internal caches, general purposes */
 #define ACPI_MTX_MEMORY                 5   /* Debug memory tracking lists */
-#define ACPI_MTX_DEBUG_CMD_COMPLETE     6   /* AML debugger */
-#define ACPI_MTX_DEBUG_CMD_READY        7   /* AML debugger */
 
-#define ACPI_MAX_MUTEX                  7
-#define ACPI_NUM_MUTEX                  ACPI_MAX_MUTEX+1
+#define ACPI_MAX_MUTEX                  5
+#define ACPI_NUM_MUTEX                  (ACPI_MAX_MUTEX+1)
 
 
 /* Lock structure for reader/writer interfaces */
@@ -113,12 +111,20 @@ typedef struct acpi_rw_lock
 #define ACPI_LOCK_HARDWARE              1
 
 #define ACPI_MAX_LOCK                   1
-#define ACPI_NUM_LOCK                   ACPI_MAX_LOCK+1
+#define ACPI_NUM_LOCK                   (ACPI_MAX_LOCK+1)
 
 
 /* This Thread ID means that the mutex is not in use (unlocked) */
 
-#define ACPI_MUTEX_NOT_ACQUIRED         (ACPI_THREAD_ID) -1
+#define ACPI_MUTEX_NOT_ACQUIRED         ((ACPI_THREAD_ID) -1)
+
+/* This Thread ID means an invalid thread ID */
+
+#ifdef ACPI_OS_INVALID_THREAD_ID
+#define ACPI_INVALID_THREAD_ID          ACPI_OS_INVALID_THREAD_ID
+#else
+#define ACPI_INVALID_THREAD_ID          ((ACPI_THREAD_ID) 0xFFFFFFFF)
+#endif
 
 /* Table for the global mutexes */
 
@@ -193,8 +199,12 @@ typedef struct acpi_namespace_node
      */
 #ifdef ACPI_LARGE_NAMESPACE_NODE
     union acpi_parse_object         *Op;
+    void                            *MethodLocals;
+    void                            *MethodArgs;
     UINT32                          Value;
     UINT32                          Length;
+    UINT8                           ArgCount;
+
 #endif
 
 } ACPI_NAMESPACE_NODE;
@@ -234,10 +244,19 @@ typedef struct acpi_table_list
 #define ACPI_ROOT_ALLOW_RESIZE          (2)
 
 
-/* Predefined (fixed) table indexes */
+/* List to manage incoming ACPI tables */
+
+typedef struct acpi_new_table_desc
+{
+    ACPI_TABLE_HEADER               *Table;
+    struct acpi_new_table_desc      *Next;
+
+} ACPI_NEW_TABLE_DESC;
+
 
-#define ACPI_TABLE_INDEX_DSDT           (0)
-#define ACPI_TABLE_INDEX_FACS           (1)
+/* Predefined table indexes */
+
+#define ACPI_INVALID_TABLE_INDEX        (0xFFFFFFFF)
 
 
 typedef struct acpi_find_context
@@ -291,6 +310,7 @@ typedef struct acpi_create_field_info
     UINT32                          FieldBitPosition;
     UINT32                          FieldBitLength;
     UINT16                          ResourceLength;
+    UINT16                          PinNumberIndex;
     UINT8                           FieldFlags;
     UINT8                           Attribute;
     UINT8                           FieldType;
@@ -305,7 +325,7 @@ ACPI_STATUS (*ACPI_INTERNAL_METHOD) (
 
 
 /*
- * Bitmapped ACPI types.  Used internally only
+ * Bitmapped ACPI types. Used internally only
  */
 #define ACPI_BTYPE_ANY                  0x00000000
 #define ACPI_BTYPE_INTEGER              0x00000001
@@ -324,17 +344,22 @@ ACPI_STATUS (*ACPI_INTERNAL_METHOD) (
 #define ACPI_BTYPE_BUFFER_FIELD         0x00002000
 #define ACPI_BTYPE_DDB_HANDLE           0x00004000
 #define ACPI_BTYPE_DEBUG_OBJECT         0x00008000
-#define ACPI_BTYPE_REFERENCE            0x00010000
+#define ACPI_BTYPE_REFERENCE_OBJECT     0x00010000 /* From Index(), RefOf(), etc (Type6Opcodes) */
 #define ACPI_BTYPE_RESOURCE             0x00020000
+#define ACPI_BTYPE_NAMED_REFERENCE      0x00040000 /* Generic unresolved Name or Namepath */
 
 #define ACPI_BTYPE_COMPUTE_DATA         (ACPI_BTYPE_INTEGER | ACPI_BTYPE_STRING | ACPI_BTYPE_BUFFER)
 
 #define ACPI_BTYPE_DATA                 (ACPI_BTYPE_COMPUTE_DATA  | ACPI_BTYPE_PACKAGE)
-#define ACPI_BTYPE_DATA_REFERENCE       (ACPI_BTYPE_DATA | ACPI_BTYPE_REFERENCE | ACPI_BTYPE_DDB_HANDLE)
+
+    /* Used by Copy, DeRefOf, Store, Printf, Fprintf */
+
+#define ACPI_BTYPE_DATA_REFERENCE       (ACPI_BTYPE_DATA | ACPI_BTYPE_REFERENCE_OBJECT | ACPI_BTYPE_DDB_HANDLE)
 #define ACPI_BTYPE_DEVICE_OBJECTS       (ACPI_BTYPE_DEVICE | ACPI_BTYPE_THERMAL | ACPI_BTYPE_PROCESSOR)
 #define ACPI_BTYPE_OBJECTS_AND_REFS     0x0001FFFF  /* ARG or LOCAL */
 #define ACPI_BTYPE_ALL_OBJECTS          0x0000FFFF
 
+#pragma pack(1)
 
 /*
  * Information structure for ACPI predefined names.
@@ -347,7 +372,7 @@ ACPI_STATUS (*ACPI_INTERNAL_METHOD) (
 typedef struct acpi_name_info
 {
     char                        Name[ACPI_NAME_SIZE];
-    UINT8                       ParamCount;
+    UINT16                      ArgumentList;
     UINT8                       ExpectedBtypes;
 
 } ACPI_NAME_INFO;
@@ -372,7 +397,7 @@ typedef struct acpi_package_info
     UINT8                       Count1;
     UINT8                       ObjectType2;
     UINT8                       Count2;
-    UINT8                       Reserved;
+    UINT16                      Reserved;
 
 } ACPI_PACKAGE_INFO;
 
@@ -383,6 +408,7 @@ typedef struct acpi_package_info2
     UINT8                       Type;
     UINT8                       Count;
     UINT8                       ObjectType[4];
+    UINT8                       Reserved;
 
 } ACPI_PACKAGE_INFO2;
 
@@ -394,37 +420,51 @@ typedef struct acpi_package_info3
     UINT8                       Count;
     UINT8                       ObjectType[2];
     UINT8                       TailObjectType;
-    UINT8                       Reserved;
+    UINT16                      Reserved;
 
 } ACPI_PACKAGE_INFO3;
 
+typedef struct acpi_package_info4
+{
+    UINT8                       Type;
+    UINT8                       ObjectType1;
+    UINT8                       Count1;
+    UINT8                       SubObjectTypes;
+    UINT8                       PkgCount;
+    UINT16                      Reserved;
+
+} ACPI_PACKAGE_INFO4;
+
 typedef union acpi_predefined_info
 {
     ACPI_NAME_INFO              Info;
     ACPI_PACKAGE_INFO           RetInfo;
     ACPI_PACKAGE_INFO2          RetInfo2;
     ACPI_PACKAGE_INFO3          RetInfo3;
+    ACPI_PACKAGE_INFO4          RetInfo4;
 
 } ACPI_PREDEFINED_INFO;
 
+/* Reset to default packing */
 
-/* Data block used during object validation */
+#pragma pack()
 
-typedef struct acpi_predefined_data
-{
-    char                        *Pathname;
-    const ACPI_PREDEFINED_INFO  *Predefined;
-    union acpi_operand_object   *ParentPackage;
-    ACPI_NAMESPACE_NODE         *Node;
-    UINT32                      Flags;
-    UINT8                       NodeFlags;
 
-} ACPI_PREDEFINED_DATA;
+/* Return object auto-repair info */
+
+typedef ACPI_STATUS (*ACPI_OBJECT_CONVERTER) (
+    struct acpi_namespace_node  *Scope,
+    union acpi_operand_object   *OriginalObject,
+    union acpi_operand_object   **ConvertedObject);
 
-/* Defines for Flags field above */
+typedef struct acpi_simple_repair_info
+{
+    char                        Name[ACPI_NAME_SIZE];
+    UINT32                      UnexpectedBtypes;
+    UINT32                      PackageIndex;
+    ACPI_OBJECT_CONVERTER       ObjectConverter;
 
-#define ACPI_OBJECT_REPAIRED    1
-#define ACPI_OBJECT_WRAPPED     2
+} ACPI_SIMPLE_REPAIR_INFO;
 
 
 /*
@@ -444,12 +484,33 @@ typedef struct acpi_predefined_data
 #define ACPI_NUM_RTYPES                 5   /* Number of actual object types */
 
 
+/* Info for running the _REG methods */
+
+typedef struct acpi_reg_walk_info
+{
+    ACPI_ADR_SPACE_TYPE     SpaceId;
+    UINT32                  Function;
+    UINT32                  RegRunCount;
+
+} ACPI_REG_WALK_INFO;
+
+
 /*****************************************************************************
  *
  * Event typedefs and structs
  *
  ****************************************************************************/
 
+/* Dispatch info for each host-installed SCI handler */
+
+typedef struct acpi_sci_handler_info
+{
+    struct acpi_sci_handler_info    *Next;
+    ACPI_SCI_HANDLER                Address;        /* Address of handler */
+    void                            *Context;       /* Context to be passed to handler */
+
+} ACPI_SCI_HANDLER_INFO;
+
 /* Dispatch info for each GPE -- either a method or handler, cannot be both */
 
 typedef struct acpi_gpe_handler_info
@@ -462,6 +523,15 @@ typedef struct acpi_gpe_handler_info
 
 } ACPI_GPE_HANDLER_INFO;
 
+/* Notify info for implicit notify, multiple device objects */
+
+typedef struct acpi_gpe_notify_info
+{
+    ACPI_NAMESPACE_NODE             *DeviceNode;    /* Device to be notified */
+    struct acpi_gpe_notify_info     *Next;
+
+} ACPI_GPE_NOTIFY_INFO;
+
 /*
  * GPE dispatch info. At any time, the GPE can have at most one type
  * of dispatch - Method, Handler, or Implicit Notify.
@@ -469,8 +539,8 @@ typedef struct acpi_gpe_handler_info
 typedef union acpi_gpe_dispatch_info
 {
     ACPI_NAMESPACE_NODE             *MethodNode;    /* Method node for this GPE level */
-    struct acpi_gpe_handler_info    *Handler;       /* Installed GPE handler */
-    ACPI_NAMESPACE_NODE             *DeviceNode;    /* Parent _PRW device for implicit notify */
+    ACPI_GPE_HANDLER_INFO           *Handler;       /* Installed GPE handler */
+    ACPI_GPE_NOTIFY_INFO            *NotifyList;    /* List of _PRW devices for implicit notifies */
 
 } ACPI_GPE_DISPATCH_INFO;
 
@@ -480,7 +550,7 @@ typedef union acpi_gpe_dispatch_info
  */
 typedef struct acpi_gpe_event_info
 {
-    union acpi_gpe_dispatch_info    Dispatch;       /* Either Method or Handler */
+    union acpi_gpe_dispatch_info    Dispatch;       /* Either Method, Handler, or NotifyList */
     struct acpi_gpe_register_info   *RegisterInfo;  /* Backpointer to register info */
     UINT8                           Flags;          /* Misc info about this GPE */
     UINT8                           GpeNumber;      /* This GPE */
@@ -494,9 +564,10 @@ typedef struct acpi_gpe_register_info
 {
     ACPI_GENERIC_ADDRESS            StatusAddress;  /* Address of status reg */
     ACPI_GENERIC_ADDRESS            EnableAddress;  /* Address of enable reg */
+    UINT16                          BaseGpeNumber;  /* Base GPE number for this register */
     UINT8                           EnableForWake;  /* GPEs to keep enabled when sleeping */
     UINT8                           EnableForRun;   /* GPEs to keep enabled when running */
-    UINT8                           BaseGpeNumber;  /* Base GPE number for this register */
+    UINT8                           EnableMask;     /* Current mask of enabled GPEs */
 
 } ACPI_GPE_REGISTER_INFO;
 
@@ -512,10 +583,11 @@ typedef struct acpi_gpe_block_info
     struct acpi_gpe_xrupt_info      *XruptBlock;    /* Backpointer to interrupt block */
     ACPI_GPE_REGISTER_INFO          *RegisterInfo;  /* One per GPE register pair */
     ACPI_GPE_EVENT_INFO             *EventInfo;     /* One for each GPE */
-    ACPI_GENERIC_ADDRESS            BlockAddress;   /* Base address of the block */
+    UINT64                          Address;        /* Base address of the block */
     UINT32                          RegisterCount;  /* Number of register pairs in block */
     UINT16                          GpeCount;       /* Number of individual GPEs in block */
-    UINT8                           BlockBaseNumber;/* Base GPE number for this block */
+    UINT16                          BlockBaseNumber;/* Base GPE number for this block */
+    UINT8                           SpaceId;
     BOOLEAN                         Initialized;    /* TRUE if this block is initialized */
 
 } ACPI_GPE_BLOCK_INFO;
@@ -680,7 +752,7 @@ typedef struct acpi_pscope_state
 
 
 /*
- * Thread state - one per thread across multiple walk states.  Multiple walk
+ * Thread state - one per thread across multiple walk states. Multiple walk
  * states are created when there are nested control methods executing.
  */
 typedef struct acpi_thread_state
@@ -826,7 +898,7 @@ typedef union acpi_parse_value
 } ACPI_PARSE_VALUE;
 
 
-#ifdef ACPI_DISASSEMBLER
+#if defined(ACPI_DISASSEMBLER) || defined(ACPI_DEBUG_OUTPUT)
 #define ACPI_DISASM_ONLY_MEMBERS(a)     a;
 #else
 #define ACPI_DISASM_ONLY_MEMBERS(a)
@@ -837,7 +909,7 @@ typedef union acpi_parse_value
     UINT8                           DescriptorType; /* To differentiate various internal objs */\
     UINT8                           Flags;          /* Type of Op */\
     UINT16                          AmlOpcode;      /* AML opcode */\
-    UINT32                          AmlOffset;      /* Offset of declaration in AML */\
+    UINT8                           *Aml;           /* Address of declaration in AML */\
     union acpi_parse_object         *Next;          /* Next op */\
     ACPI_NAMESPACE_NODE             *Node;          /* For use by interpreter */\
     ACPI_PARSE_VALUE                Value;          /* Value or args associated with the opcode */\
@@ -845,18 +917,24 @@ typedef union acpi_parse_value
     ACPI_DISASM_ONLY_MEMBERS (\
     UINT8                           DisasmFlags;    /* Used during AML disassembly */\
     UINT8                           DisasmOpcode;   /* Subtype used for disassembly */\
+    char                            *OperatorSymbol;/* Used for C-style operator name strings */\
     char                            AmlOpName[16])  /* Op name (debug only) */
 
 
-#define ACPI_DASM_BUFFER                0x00
-#define ACPI_DASM_RESOURCE              0x01
-#define ACPI_DASM_STRING                0x02
-#define ACPI_DASM_UNICODE               0x03
-#define ACPI_DASM_EISAID                0x04
-#define ACPI_DASM_MATCHOP               0x05
-#define ACPI_DASM_LNOT_PREFIX           0x06
-#define ACPI_DASM_LNOT_SUFFIX           0x07
-#define ACPI_DASM_IGNORE                0x08
+/* Flags for DisasmFlags field  above */
+
+#define ACPI_DASM_BUFFER                0x00        /* Buffer is a simple data buffer */
+#define ACPI_DASM_RESOURCE              0x01        /* Buffer is a Resource Descriptor */
+#define ACPI_DASM_STRING                0x02        /* Buffer is a ASCII string */
+#define ACPI_DASM_UNICODE               0x03        /* Buffer is a Unicode string */
+#define ACPI_DASM_PLD_METHOD            0x04        /* Buffer is a _PLD method bit-packed buffer */
+#define ACPI_DASM_UUID                  0x05        /* Buffer is a UUID/GUID */
+#define ACPI_DASM_EISAID                0x06        /* Integer is an EISAID */
+#define ACPI_DASM_MATCHOP               0x07        /* Parent opcode is a Match() operator */
+#define ACPI_DASM_LNOT_PREFIX           0x08        /* Start of a LNotEqual (etc.) pair of opcodes */
+#define ACPI_DASM_LNOT_SUFFIX           0x09        /* End  of a LNotEqual (etc.) pair of opcodes */
+#define ACPI_DASM_HID_STRING            0x0A        /* String is a _HID or _CID */
+#define ACPI_DASM_IGNORE                0x0B        /* Not used at this time */
 
 /*
  * Generic operation (for example:  If, While, Store)
@@ -947,20 +1025,24 @@ typedef struct acpi_parse_state
 
 /* Parse object flags */
 
-#define ACPI_PARSEOP_GENERIC            0x01
-#define ACPI_PARSEOP_NAMED              0x02
-#define ACPI_PARSEOP_DEFERRED           0x04
-#define ACPI_PARSEOP_BYTELIST           0x08
-#define ACPI_PARSEOP_IN_STACK           0x10
-#define ACPI_PARSEOP_TARGET             0x20
-#define ACPI_PARSEOP_IN_CACHE           0x80
+#define ACPI_PARSEOP_GENERIC                0x01
+#define ACPI_PARSEOP_NAMED_OBJECT           0x02
+#define ACPI_PARSEOP_DEFERRED               0x04
+#define ACPI_PARSEOP_BYTELIST               0x08
+#define ACPI_PARSEOP_IN_STACK               0x10
+#define ACPI_PARSEOP_TARGET                 0x20
+#define ACPI_PARSEOP_IN_CACHE               0x80
 
 /* Parse object DisasmFlags */
 
-#define ACPI_PARSEOP_IGNORE             0x01
-#define ACPI_PARSEOP_PARAMLIST          0x02
-#define ACPI_PARSEOP_EMPTY_TERMLIST     0x04
-#define ACPI_PARSEOP_SPECIAL            0x10
+#define ACPI_PARSEOP_IGNORE                 0x01
+#define ACPI_PARSEOP_PARAMETER_LIST         0x02
+#define ACPI_PARSEOP_EMPTY_TERMLIST         0x04
+#define ACPI_PARSEOP_PREDEFINED_CHECKED     0x08
+#define ACPI_PARSEOP_CLOSING_PAREN          0x10
+#define ACPI_PARSEOP_COMPOUND_ASSIGNMENT    0x20
+#define ACPI_PARSEOP_ASSIGNMENT             0x40
+#define ACPI_PARSEOP_ELSEIF                 0x80
 
 
 /*****************************************************************************
@@ -1084,18 +1166,6 @@ typedef struct acpi_bit_register_info
 
 /* Structs and definitions for _OSI support and I/O port validation */
 
-#define ACPI_OSI_WIN_2000               0x01
-#define ACPI_OSI_WIN_XP                 0x02
-#define ACPI_OSI_WIN_XP_SP1             0x03
-#define ACPI_OSI_WINSRV_2003            0x04
-#define ACPI_OSI_WIN_XP_SP2             0x05
-#define ACPI_OSI_WINSRV_2003_SP1        0x06
-#define ACPI_OSI_WIN_VISTA              0x07
-#define ACPI_OSI_WINSRV_2008            0x08
-#define ACPI_OSI_WIN_VISTA_SP1          0x09
-#define ACPI_OSI_WIN_VISTA_SP2          0x0A
-#define ACPI_OSI_WIN_7                  0x0B
-
 #define ACPI_ALWAYS_ILLEGAL             0x00
 
 typedef struct acpi_interface_info
@@ -1109,6 +1179,9 @@ typedef struct acpi_interface_info
 
 #define ACPI_OSI_INVALID                0x01
 #define ACPI_OSI_DYNAMIC                0x02
+#define ACPI_OSI_FEATURE                0x04
+#define ACPI_OSI_DEFAULT_INVALID        0x08
+#define ACPI_OSI_OPTIONAL_FEATURE       (ACPI_OSI_FEATURE | ACPI_OSI_DEFAULT_INVALID | ACPI_OSI_INVALID)
 
 typedef struct acpi_port_info
 {
@@ -1201,14 +1274,18 @@ typedef struct acpi_external_list
     struct acpi_external_list   *Next;
     UINT32                      Value;
     UINT16                      Length;
+    UINT16                      Flags;
     UINT8                       Type;
-    UINT8                       Flags;
 
 } ACPI_EXTERNAL_LIST;
 
 /* Values for Flags field above */
 
-#define ACPI_IPATH_ALLOCATED    0x01
+#define ACPI_EXT_RESOLVED_REFERENCE         0x01    /* Object was resolved during cross ref */
+#define ACPI_EXT_ORIGIN_FROM_FILE           0x02    /* External came from a file */
+#define ACPI_EXT_INTERNAL_PATH_ALLOCATED    0x04    /* Deallocate internal path on completion */
+#define ACPI_EXT_EXTERNAL_EMITTED           0x08    /* External() statement has been emitted */
+#define ACPI_EXT_ORIGIN_FROM_OPCODE         0x10    /* External came from a External() opcode */
 
 
 typedef struct acpi_external_file
@@ -1227,6 +1304,7 @@ typedef struct acpi_external_file
 
 typedef struct acpi_db_method_info
 {
+    ACPI_HANDLE                     Method;
     ACPI_HANDLE                     MainThreadGate;
     ACPI_HANDLE                     ThreadCompleteGate;
     ACPI_HANDLE                     InfoGate;
@@ -1238,7 +1316,7 @@ typedef struct acpi_db_method_info
     char                            *Name;
     UINT32                          Flags;
     UINT32                          NumLoops;
-    char                            Pathname[128];
+    char                            Pathname[ACPI_DB_LINE_BUFFER_SIZE];
     char                            **Args;
     ACPI_OBJECT_TYPE                *Types;
 
@@ -1249,7 +1327,9 @@ typedef struct acpi_db_method_info
      *   Index of current thread inside all them created.
      */
     char                            InitArgs;
+#ifdef ACPI_DEBUGGER
     ACPI_OBJECT_TYPE                ArgTypes[4];
+#endif
     char                            *Arguments[4];
     char                            NumThreadsStr[11];
     char                            IdOfThreadStr[11];
@@ -1265,11 +1345,19 @@ typedef struct acpi_integrity_info
 } ACPI_INTEGRITY_INFO;
 
 
+#define ACPI_DB_DISABLE_OUTPUT          0x00
 #define ACPI_DB_REDIRECTABLE_OUTPUT     0x01
 #define ACPI_DB_CONSOLE_OUTPUT          0x02
 #define ACPI_DB_DUPLICATE_OUTPUT        0x03
 
 
+typedef struct acpi_object_info
+{
+    UINT32                  Types[ACPI_TOTAL_TYPES];
+
+} ACPI_OBJECT_INFO;
+
+
 /*****************************************************************************
  *
  * Debug
@@ -1311,4 +1399,41 @@ typedef struct acpi_debug_mem_block
 #define ACPI_NUM_MEM_LISTS              2
 
 
+/*****************************************************************************
+ *
+ * Info/help support
+ *
+ ****************************************************************************/
+
+typedef struct ah_predefined_name
+{
+    char            *Name;
+    char            *Description;
+#ifndef ACPI_ASL_COMPILER
+    char            *Action;
+#endif
+
+} AH_PREDEFINED_NAME;
+
+typedef struct ah_device_id
+{
+    char            *Name;
+    char            *Description;
+
+} AH_DEVICE_ID;
+
+typedef struct ah_uuid
+{
+    char            *Description;
+    char            *String;
+
+} AH_UUID;
+
+typedef struct ah_table
+{
+    char                    *Signature;
+    char                    *Description;
+
+} AH_TABLE;
+
 #endif /* __ACLOCAL_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/acmacros.h b/usr/src/uts/intel/sys/acpi/acmacros.h
index cdb9cb109e..21256cbba7 100644
--- a/usr/src/uts/intel/sys/acpi/acmacros.h
+++ b/usr/src/uts/intel/sys/acpi/acmacros.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -50,29 +50,26 @@
  * get into potential aligment issues -- see the STORE macros below.
  * Use with care.
  */
-#define ACPI_GET8(ptr)                  *ACPI_CAST_PTR (UINT8, ptr)
-#define ACPI_GET16(ptr)                 *ACPI_CAST_PTR (UINT16, ptr)
-#define ACPI_GET32(ptr)                 *ACPI_CAST_PTR (UINT32, ptr)
-#define ACPI_GET64(ptr)                 *ACPI_CAST_PTR (UINT64, ptr)
-#define ACPI_SET8(ptr)                  *ACPI_CAST_PTR (UINT8, ptr)
-#define ACPI_SET16(ptr)                 *ACPI_CAST_PTR (UINT16, ptr)
-#define ACPI_SET32(ptr)                 *ACPI_CAST_PTR (UINT32, ptr)
-#define ACPI_SET64(ptr)                 *ACPI_CAST_PTR (UINT64, ptr)
+#define ACPI_CAST8(ptr)                 ACPI_CAST_PTR (UINT8, (ptr))
+#define ACPI_CAST16(ptr)                ACPI_CAST_PTR (UINT16, (ptr))
+#define ACPI_CAST32(ptr)                ACPI_CAST_PTR (UINT32, (ptr))
+#define ACPI_CAST64(ptr)                ACPI_CAST_PTR (UINT64, (ptr))
+#define ACPI_GET8(ptr)                  (*ACPI_CAST8 (ptr))
+#define ACPI_GET16(ptr)                 (*ACPI_CAST16 (ptr))
+#define ACPI_GET32(ptr)                 (*ACPI_CAST32 (ptr))
+#define ACPI_GET64(ptr)                 (*ACPI_CAST64 (ptr))
+#define ACPI_SET8(ptr, val)             (*ACPI_CAST8 (ptr) = (UINT8) (val))
+#define ACPI_SET16(ptr, val)            (*ACPI_CAST16 (ptr) = (UINT16) (val))
+#define ACPI_SET32(ptr, val)            (*ACPI_CAST32 (ptr) = (UINT32) (val))
+#define ACPI_SET64(ptr, val)            (*ACPI_CAST64 (ptr) = (UINT64) (val))
 
 /*
- * printf() format helpers
+ * printf() format helper. This macros is a workaround for the difficulties
+ * with emitting 64-bit integers and 64-bit pointers with the same code
+ * for both 32-bit and 64-bit hosts.
  */
-
-/* Split 64-bit integer into two 32-bit values. Use with %8.8X%8.8X */
-
 #define ACPI_FORMAT_UINT64(i)           ACPI_HIDWORD(i), ACPI_LODWORD(i)
 
-#if ACPI_MACHINE_WIDTH == 64
-#define ACPI_FORMAT_NATIVE_UINT(i)      ACPI_FORMAT_UINT64(i)
-#else
-#define ACPI_FORMAT_NATIVE_UINT(i)      0, (i)
-#endif
-
 
 /*
  * Macros for moving data around to/from buffers that are possibly unaligned.
@@ -226,6 +223,16 @@
 #define ACPI_MUL_32(a)                  _ACPI_MUL(a, 5)
 #define ACPI_MOD_32(a)                  _ACPI_MOD(a, 32)
 
+/* Test for ASCII character */
+
+#define ACPI_IS_ASCII(c)                ((c) < 0x80)
+
+/* Signed integers */
+
+#define ACPI_SIGN_POSITIVE              0
+#define ACPI_SIGN_NEGATIVE              1
+
+
 /*
  * Rounding macros (Power of two boundaries only)
  */
@@ -268,20 +275,65 @@
 
 /* Bitfields within ACPI registers */
 
-#define ACPI_REGISTER_PREPARE_BITS(Val, Pos, Mask)      ((Val << Pos) & Mask)
-#define ACPI_REGISTER_INSERT_VALUE(Reg, Pos, Mask, Val)  Reg = (Reg & (~(Mask))) | ACPI_REGISTER_PREPARE_BITS(Val, Pos, Mask)
+#define ACPI_REGISTER_PREPARE_BITS(Val, Pos, Mask) \
+    ((Val << Pos) & Mask)
+
+#define ACPI_REGISTER_INSERT_VALUE(Reg, Pos, Mask, Val) \
+    Reg = (Reg & (~(Mask))) | ACPI_REGISTER_PREPARE_BITS(Val, Pos, Mask)
+
+#define ACPI_INSERT_BITS(Target, Mask, Source) \
+    Target = ((Target & (~(Mask))) | (Source & Mask))
+
+/* Generic bitfield macros and masks */
+
+#define ACPI_GET_BITS(SourcePtr, Position, Mask) \
+    ((*(SourcePtr) >> (Position)) & (Mask))
+
+#define ACPI_SET_BITS(TargetPtr, Position, Mask, Value) \
+    (*(TargetPtr) |= (((Value) & (Mask)) << (Position)))
 
-#define ACPI_INSERT_BITS(Target, Mask, Source)          Target = ((Target & (~(Mask))) | (Source & Mask))
+#define ACPI_1BIT_MASK      0x00000001
+#define ACPI_2BIT_MASK      0x00000003
+#define ACPI_3BIT_MASK      0x00000007
+#define ACPI_4BIT_MASK      0x0000000F
+#define ACPI_5BIT_MASK      0x0000001F
+#define ACPI_6BIT_MASK      0x0000003F
+#define ACPI_7BIT_MASK      0x0000007F
+#define ACPI_8BIT_MASK      0x000000FF
+#define ACPI_16BIT_MASK     0x0000FFFF
+#define ACPI_24BIT_MASK     0x00FFFFFF
+
+/* Macros to extract flag bits from position zero */
+
+#define ACPI_GET_1BIT_FLAG(Value)                   ((Value) & ACPI_1BIT_MASK)
+#define ACPI_GET_2BIT_FLAG(Value)                   ((Value) & ACPI_2BIT_MASK)
+#define ACPI_GET_3BIT_FLAG(Value)                   ((Value) & ACPI_3BIT_MASK)
+#define ACPI_GET_4BIT_FLAG(Value)                   ((Value) & ACPI_4BIT_MASK)
+
+/* Macros to extract flag bits from position one and above */
+
+#define ACPI_EXTRACT_1BIT_FLAG(Field, Position)     (ACPI_GET_1BIT_FLAG ((Field) >> Position))
+#define ACPI_EXTRACT_2BIT_FLAG(Field, Position)     (ACPI_GET_2BIT_FLAG ((Field) >> Position))
+#define ACPI_EXTRACT_3BIT_FLAG(Field, Position)     (ACPI_GET_3BIT_FLAG ((Field) >> Position))
+#define ACPI_EXTRACT_4BIT_FLAG(Field, Position)     (ACPI_GET_4BIT_FLAG ((Field) >> Position))
+
+/* ACPI Pathname helpers */
+
+#define ACPI_IS_ROOT_PREFIX(c)      ((c) == (UINT8) 0x5C) /* Backslash */
+#define ACPI_IS_PARENT_PREFIX(c)    ((c) == (UINT8) 0x5E) /* Carat */
+#define ACPI_IS_PATH_SEPARATOR(c)   ((c) == (UINT8) 0x2E) /* Period (dot) */
 
 /*
- * An ACPI_NAMESPACE_NODE can appear in some contexts
- * where a pointer to an ACPI_OPERAND_OBJECT can also
+ * An object of type ACPI_NAMESPACE_NODE can appear in some contexts
+ * where a pointer to an object of type ACPI_OPERAND_OBJECT can also
  * appear. This macro is used to distinguish them.
  *
- * The "Descriptor" field is the first field in both structures.
+ * The "DescriptorType" field is the second field in both structures.
  */
+#define ACPI_GET_DESCRIPTOR_PTR(d)      (((ACPI_DESCRIPTOR *)(void *)(d))->Common.CommonPointer)
+#define ACPI_SET_DESCRIPTOR_PTR(d, p)   (((ACPI_DESCRIPTOR *)(void *)(d))->Common.CommonPointer = (p))
 #define ACPI_GET_DESCRIPTOR_TYPE(d)     (((ACPI_DESCRIPTOR *)(void *)(d))->Common.DescriptorType)
-#define ACPI_SET_DESCRIPTOR_TYPE(d, t)  (((ACPI_DESCRIPTOR *)(void *)(d))->Common.DescriptorType = t)
+#define ACPI_SET_DESCRIPTOR_TYPE(d, t)  (((ACPI_DESCRIPTOR *)(void *)(d))->Common.DescriptorType = (t))
 
 /*
  * Macros for the master AML opcode table
@@ -328,10 +380,11 @@
  * the plist contains a set of parens to allow variable-length lists.
  * These macros are used for both the debug and non-debug versions of the code.
  */
-#define ACPI_ERROR_NAMESPACE(s, e)      AcpiUtNamespaceError (AE_INFO, s, e);
-#define ACPI_ERROR_METHOD(s, n, p, e)   AcpiUtMethodError (AE_INFO, s, n, p, e);
-#define ACPI_WARN_PREDEFINED(plist)     AcpiUtPredefinedWarning plist
-#define ACPI_INFO_PREDEFINED(plist)     AcpiUtPredefinedInfo plist
+#define ACPI_ERROR_NAMESPACE(s, e)          AcpiUtNamespaceError (AE_INFO, s, e);
+#define ACPI_ERROR_METHOD(s, n, p, e)       AcpiUtMethodError (AE_INFO, s, n, p, e);
+#define ACPI_WARN_PREDEFINED(plist)         AcpiUtPredefinedWarning plist
+#define ACPI_INFO_PREDEFINED(plist)         AcpiUtPredefinedInfo plist
+#define ACPI_BIOS_ERROR_PREDEFINED(plist)   AcpiUtPredefinedBiosError plist
 
 #else
 
@@ -341,142 +394,10 @@
 #define ACPI_ERROR_METHOD(s, n, p, e)
 #define ACPI_WARN_PREDEFINED(plist)
 #define ACPI_INFO_PREDEFINED(plist)
+#define ACPI_BIOS_ERROR_PREDEFINED(plist)
 
 #endif /* ACPI_NO_ERROR_MESSAGES */
 
-/*
- * Debug macros that are conditionally compiled
- */
-#ifdef ACPI_DEBUG_OUTPUT
-/*
- * Function entry tracing
- */
-#define ACPI_FUNCTION_TRACE(a)          ACPI_FUNCTION_NAME(a) \
-                                            AcpiUtTrace(ACPI_DEBUG_PARAMETERS)
-#define ACPI_FUNCTION_TRACE_PTR(a, b)   ACPI_FUNCTION_NAME(a) \
-                                            AcpiUtTracePtr(ACPI_DEBUG_PARAMETERS, (void *)b)
-#define ACPI_FUNCTION_TRACE_U32(a, b)   ACPI_FUNCTION_NAME(a) \
-                                            AcpiUtTraceU32(ACPI_DEBUG_PARAMETERS, (UINT32)b)
-#define ACPI_FUNCTION_TRACE_STR(a, b)   ACPI_FUNCTION_NAME(a) \
-                                            AcpiUtTraceStr(ACPI_DEBUG_PARAMETERS, (char *)b)
-
-#define ACPI_FUNCTION_ENTRY()           AcpiUtTrackStackPtr()
-
-/*
- * Function exit tracing.
- * WARNING: These macros include a return statement. This is usually considered
- * bad form, but having a separate exit macro is very ugly and difficult to maintain.
- * One of the FUNCTION_TRACE macros above must be used in conjunction with these macros
- * so that "_AcpiFunctionName" is defined.
- *
- * Note: the DO_WHILE0 macro is used to prevent some compilers from complaining
- * about these constructs.
- */
-#ifdef ACPI_USE_DO_WHILE_0
-#define ACPI_DO_WHILE0(a)               do a while(0)
-#else
-#define ACPI_DO_WHILE0(a)               a
-#endif
-
-#define return_VOID                     ACPI_DO_WHILE0 ({ \
-                                            AcpiUtExit (ACPI_DEBUG_PARAMETERS); \
-                                            return;})
-/*
- * There are two versions of most of the return macros. The default version is
- * safer, since it avoids side-effects by guaranteeing that the argument will
- * not be evaluated twice.
- *
- * A less-safe version of the macros is provided for optional use if the
- * compiler uses excessive CPU stack (for example, this may happen in the
- * debug case if code optimzation is disabled.)
- */
-#ifndef ACPI_SIMPLE_RETURN_MACROS
-
-#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({ \
-                                            register ACPI_STATUS _s = (s); \
-                                            AcpiUtStatusExit (ACPI_DEBUG_PARAMETERS, _s); \
-                                            return (_s); })
-#define return_PTR(s)                   ACPI_DO_WHILE0 ({ \
-                                            register void *_s = (void *) (s); \
-                                            AcpiUtPtrExit (ACPI_DEBUG_PARAMETERS, (UINT8 *) _s); \
-                                            return (_s); })
-#define return_VALUE(s)                 ACPI_DO_WHILE0 ({ \
-                                            register UINT64 _s = (s); \
-                                            AcpiUtValueExit (ACPI_DEBUG_PARAMETERS, _s); \
-                                            return (_s); })
-#define return_UINT8(s)                 ACPI_DO_WHILE0 ({ \
-                                            register UINT8 _s = (UINT8) (s); \
-                                            AcpiUtValueExit (ACPI_DEBUG_PARAMETERS, (UINT64) _s); \
-                                            return (_s); })
-#define return_UINT32(s)                ACPI_DO_WHILE0 ({ \
-                                            register UINT32 _s = (UINT32) (s); \
-                                            AcpiUtValueExit (ACPI_DEBUG_PARAMETERS, (UINT64) _s); \
-                                            return (_s); })
-#else /* Use original less-safe macros */
-
-#define return_ACPI_STATUS(s)           ACPI_DO_WHILE0 ({ \
-                                            AcpiUtStatusExit (ACPI_DEBUG_PARAMETERS, (s)); \
-                                            return((s)); })
-#define return_PTR(s)                   ACPI_DO_WHILE0 ({ \
-                                            AcpiUtPtrExit (ACPI_DEBUG_PARAMETERS, (UINT8 *) (s)); \
-                                            return((s)); })
-#define return_VALUE(s)                 ACPI_DO_WHILE0 ({ \
-                                            AcpiUtValueExit (ACPI_DEBUG_PARAMETERS, (UINT64) (s)); \
-                                            return((s)); })
-#define return_UINT8(s)                 return_VALUE(s)
-#define return_UINT32(s)                return_VALUE(s)
-
-#endif /* ACPI_SIMPLE_RETURN_MACROS */
-
-/* Conditional execution */
-
-#define ACPI_DEBUG_EXEC(a)              a
-#define ACPI_DEBUG_ONLY_MEMBERS(a)      a;
-#define _VERBOSE_STRUCTURES
-
-
-/* Various object display routines for debug */
-
-#define ACPI_DUMP_STACK_ENTRY(a)        AcpiExDumpOperand((a), 0)
-#define ACPI_DUMP_OPERANDS(a, b ,c)     AcpiExDumpOperands(a, b, c)
-#define ACPI_DUMP_ENTRY(a, b)           AcpiNsDumpEntry (a, b)
-#define ACPI_DUMP_PATHNAME(a, b, c, d)  AcpiNsDumpPathname(a, b, c, d)
-#define ACPI_DUMP_BUFFER(a, b)          AcpiUtDumpBuffer((UINT8 *) a, b, DB_BYTE_DISPLAY, _COMPONENT)
-
-#else
-/*
- * This is the non-debug case -- make everything go away,
- * leaving no executable debug code!
- */
-#define ACPI_DEBUG_EXEC(a)
-#define ACPI_DEBUG_ONLY_MEMBERS(a)
-#define ACPI_FUNCTION_TRACE(a)
-#define ACPI_FUNCTION_TRACE_PTR(a, b)
-#define ACPI_FUNCTION_TRACE_U32(a, b)
-#define ACPI_FUNCTION_TRACE_STR(a, b)
-#define ACPI_FUNCTION_EXIT
-#define ACPI_FUNCTION_STATUS_EXIT(s)
-#define ACPI_FUNCTION_VALUE_EXIT(s)
-#define ACPI_FUNCTION_ENTRY()
-#define ACPI_DUMP_STACK_ENTRY(a)
-#define ACPI_DUMP_OPERANDS(a, b, c)
-#define ACPI_DUMP_ENTRY(a, b)
-#define ACPI_DUMP_TABLES(a, b)
-#define ACPI_DUMP_PATHNAME(a, b, c, d)
-#define ACPI_DUMP_BUFFER(a, b)
-#define ACPI_DEBUG_PRINT(pl)
-#define ACPI_DEBUG_PRINT_RAW(pl)
-
-#define return_VOID                     return
-#define return_ACPI_STATUS(s)           return(s)
-#define return_VALUE(s)                 return(s)
-#define return_UINT8(s)                 return(s)
-#define return_UINT32(s)                return(s)
-#define return_PTR(s)                   return(s)
-
-#endif /* ACPI_DEBUG_OUTPUT */
-
-
 #if (!ACPI_REDUCED_HARDWARE)
 #define ACPI_HW_OPTIONAL_FUNCTION(addr)     addr
 #else
@@ -484,44 +405,6 @@
 #endif
 
 
-/*
- * Some code only gets executed when the debugger is built in.
- * Note that this is entirely independent of whether the
- * DEBUG_PRINT stuff (set by ACPI_DEBUG_OUTPUT) is on, or not.
- */
-#ifdef ACPI_DEBUGGER
-#define ACPI_DEBUGGER_EXEC(a)           a
-#else
-#define ACPI_DEBUGGER_EXEC(a)
-#endif
-
-
-/*
- * Memory allocation tracking (DEBUG ONLY)
- */
-#define ACPI_MEM_PARAMETERS         _COMPONENT, _AcpiModuleName, __LINE__
-
-#ifndef ACPI_DBG_TRACK_ALLOCATIONS
-
-/* Memory allocation */
-
-#define ACPI_ALLOCATE(a)            AcpiUtAllocate((ACPI_SIZE) (a), ACPI_MEM_PARAMETERS)
-#define ACPI_ALLOCATE_ZEROED(a)     AcpiUtAllocateZeroed((ACPI_SIZE) (a), ACPI_MEM_PARAMETERS)
-#define ACPI_FREE(a)                AcpiOsFree(a)
-#define ACPI_MEM_TRACKING(a)
-
-#else
-
-/* Memory allocation */
-
-#define ACPI_ALLOCATE(a)            AcpiUtAllocateAndTrack((ACPI_SIZE) (a), ACPI_MEM_PARAMETERS)
-#define ACPI_ALLOCATE_ZEROED(a)     AcpiUtAllocateZeroedAndTrack((ACPI_SIZE) (a), ACPI_MEM_PARAMETERS)
-#define ACPI_FREE(a)                AcpiUtFreeAndTrack(a, ACPI_MEM_PARAMETERS)
-#define ACPI_MEM_TRACKING(a)        a
-
-#endif /* ACPI_DBG_TRACK_ALLOCATIONS */
-
-
 /*
  * Macros used for ACPICA utilities only
  */
diff --git a/usr/src/uts/intel/sys/acpi/acnames.h b/usr/src/uts/intel/sys/acpi/acnames.h
index 4c5fab696f..4710323e0c 100644
--- a/usr/src/uts/intel/sys/acpi/acnames.h
+++ b/usr/src/uts/intel/sys/acpi/acnames.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -46,27 +46,35 @@
 
 /* Method names - these methods can appear anywhere in the namespace */
 
-#define METHOD_NAME__SB_        "_SB_"
-#define METHOD_NAME__HID        "_HID"
-#define METHOD_NAME__CID        "_CID"
-#define METHOD_NAME__UID        "_UID"
 #define METHOD_NAME__ADR        "_ADR"
-#define METHOD_NAME__INI        "_INI"
-#define METHOD_NAME__STA        "_STA"
-#define METHOD_NAME__REG        "_REG"
-#define METHOD_NAME__SEG        "_SEG"
+#define METHOD_NAME__AEI        "_AEI"
 #define METHOD_NAME__BBN        "_BBN"
-#define METHOD_NAME__PRT        "_PRT"
+#define METHOD_NAME__CBA        "_CBA"
+#define METHOD_NAME__CID        "_CID"
+#define METHOD_NAME__CLS        "_CLS"
 #define METHOD_NAME__CRS        "_CRS"
+#define METHOD_NAME__DDN        "_DDN"
+#define METHOD_NAME__HID        "_HID"
+#define METHOD_NAME__INI        "_INI"
+#define METHOD_NAME__PLD        "_PLD"
+#define METHOD_NAME__DSD        "_DSD"
 #define METHOD_NAME__PRS        "_PRS"
-#define METHOD_NAME__AEI        "_AEI"
+#define METHOD_NAME__PRT        "_PRT"
 #define METHOD_NAME__PRW        "_PRW"
+#define METHOD_NAME__PS0        "_PS0"
+#define METHOD_NAME__PS1        "_PS1"
+#define METHOD_NAME__PS2        "_PS2"
+#define METHOD_NAME__PS3        "_PS3"
+#define METHOD_NAME__REG        "_REG"
+#define METHOD_NAME__SB_        "_SB_"
+#define METHOD_NAME__SEG        "_SEG"
 #define METHOD_NAME__SRS        "_SRS"
+#define METHOD_NAME__STA        "_STA"
+#define METHOD_NAME__SUB        "_SUB"
+#define METHOD_NAME__UID        "_UID"
 
 /* Method names - these methods must appear at the namespace root */
 
-#define METHOD_PATHNAME__BFS    "\\_BFS"
-#define METHOD_PATHNAME__GTS    "\\_GTS"
 #define METHOD_PATHNAME__PTS    "\\_PTS"
 #define METHOD_PATHNAME__SST    "\\_SI._SST"
 #define METHOD_PATHNAME__WAK    "\\_WAK"
@@ -82,5 +90,3 @@
 #define ACPI_NS_ROOT_PATH       "\\"
 
 #endif  /* __ACNAMES_H__  */
-
-
diff --git a/usr/src/uts/intel/sys/acpi/acnamesp.h b/usr/src/uts/intel/sys/acpi/acnamesp.h
index 4a91108eae..11ee70d044 100644
--- a/usr/src/uts/intel/sys/acpi/acnamesp.h
+++ b/usr/src/uts/intel/sys/acpi/acnamesp.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -67,6 +67,7 @@
 #define ACPI_NS_PREFIX_IS_SCOPE     0x10
 #define ACPI_NS_EXTERNAL            0x20
 #define ACPI_NS_TEMPORARY           0x40
+#define ACPI_NS_OVERRIDE_IF_FOUND   0x80
 
 /* Flags for AcpiNsWalkNamespace */
 
@@ -77,6 +78,7 @@
 /* Object is not a package element */
 
 #define ACPI_NOT_PACKAGE_ELEMENT    ACPI_UINT32_MAX
+#define ACPI_ALL_PACKAGE_ELEMENTS   (ACPI_UINT32_MAX-1)
 
 /* Always emit warning message, not dependent on node flags */
 
@@ -92,7 +94,7 @@ AcpiNsInitializeObjects (
 
 ACPI_STATUS
 AcpiNsInitializeDevices (
-    void);
+    UINT32                  Flags);
 
 
 /*
@@ -117,8 +119,8 @@ AcpiNsWalkNamespace (
     ACPI_HANDLE             StartObject,
     UINT32                  MaxDepth,
     UINT32                  Flags,
-    ACPI_WALK_CALLBACK      PreOrderVisit,
-    ACPI_WALK_CALLBACK      PostOrderVisit,
+    ACPI_WALK_CALLBACK      DescendingCallback,
+    ACPI_WALK_CALLBACK      AscendingCallback,
     void                    *Context,
     void                    **ReturnValue);
 
@@ -203,6 +205,43 @@ AcpiNsCompareNames (
     char                    *Name2);
 
 
+/*
+ * nsconvert - Dynamic object conversion routines
+ */
+ACPI_STATUS
+AcpiNsConvertToInteger (
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject);
+
+ACPI_STATUS
+AcpiNsConvertToString (
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject);
+
+ACPI_STATUS
+AcpiNsConvertToBuffer (
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject);
+
+ACPI_STATUS
+AcpiNsConvertToUnicode (
+    ACPI_NAMESPACE_NODE     *Scope,
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject);
+
+ACPI_STATUS
+AcpiNsConvertToResource (
+    ACPI_NAMESPACE_NODE     *Scope,
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject);
+
+ACPI_STATUS
+AcpiNsConvertToReference (
+    ACPI_NAMESPACE_NODE     *Scope,
+    ACPI_OPERAND_OBJECT     *OriginalObject,
+    ACPI_OPERAND_OBJECT     **ReturnObject);
+
+
 /*
  * nsdump - Namespace dump/print utilities
  */
@@ -219,14 +258,14 @@ AcpiNsDumpEntry (
 void
 AcpiNsDumpPathname (
     ACPI_HANDLE             Handle,
-    char                    *Msg,
+    const char              *Msg,
     UINT32                  Level,
     UINT32                  Component);
 
 void
 AcpiNsPrintPathname (
     UINT32                  NumSegments,
-    char                    *Pathname);
+    const char              *Pathname);
 
 ACPI_STATUS
 AcpiNsDumpOneObject (
@@ -243,6 +282,14 @@ AcpiNsDumpObjects (
     ACPI_OWNER_ID           OwnerId,
     ACPI_HANDLE             StartHandle);
 
+void
+AcpiNsDumpObjectPaths (
+    ACPI_OBJECT_TYPE        Type,
+    UINT8                   DisplayType,
+    UINT32                  MaxDepth,
+    ACPI_OWNER_ID           OwnerId,
+    ACPI_HANDLE             StartHandle);
+
 
 /*
  * nseval - Namespace evaluation functions
@@ -257,26 +304,53 @@ AcpiNsExecModuleCodeList (
 
 
 /*
- * nspredef - Support for predefined/reserved names
+ * nsarguments - Argument count/type checking for predefined/reserved names
  */
-ACPI_STATUS
-AcpiNsCheckPredefinedNames (
-    ACPI_NAMESPACE_NODE     *Node,
-    UINT32                  UserParamCount,
-    ACPI_STATUS             ReturnStatus,
-    ACPI_OPERAND_OBJECT     **ReturnObject);
-
-const ACPI_PREDEFINED_INFO *
-AcpiNsCheckForPredefinedName (
-    ACPI_NAMESPACE_NODE     *Node);
-
 void
-AcpiNsCheckParameterCount (
+AcpiNsCheckArgumentCount (
     char                        *Pathname,
     ACPI_NAMESPACE_NODE         *Node,
     UINT32                      UserParamCount,
     const ACPI_PREDEFINED_INFO  *Info);
 
+void
+AcpiNsCheckAcpiCompliance (
+    char                        *Pathname,
+    ACPI_NAMESPACE_NODE         *Node,
+    const ACPI_PREDEFINED_INFO  *Predefined);
+
+void
+AcpiNsCheckArgumentTypes (
+    ACPI_EVALUATE_INFO          *Info);
+
+
+/*
+ * nspredef - Return value checking for predefined/reserved names
+ */
+ACPI_STATUS
+AcpiNsCheckReturnValue (
+    ACPI_NAMESPACE_NODE         *Node,
+    ACPI_EVALUATE_INFO          *Info,
+    UINT32                      UserParamCount,
+    ACPI_STATUS                 ReturnStatus,
+    ACPI_OPERAND_OBJECT         **ReturnObject);
+
+ACPI_STATUS
+AcpiNsCheckObjectType (
+    ACPI_EVALUATE_INFO          *Info,
+    ACPI_OPERAND_OBJECT         **ReturnObjectPtr,
+    UINT32                      ExpectedBtypes,
+    UINT32                      PackageIndex);
+
+
+/*
+ * nsprepkg - Validation of predefined name packages
+ */
+ACPI_STATUS
+AcpiNsCheckPackage (
+    ACPI_EVALUATE_INFO          *Info,
+    ACPI_OPERAND_OBJECT         **ReturnObjectPtr);
+
 
 /*
  * nsnames - Name and Scope manipulation
@@ -285,16 +359,22 @@ UINT32
 AcpiNsOpensScope (
     ACPI_OBJECT_TYPE        Type);
 
-ACPI_STATUS
-AcpiNsBuildExternalPath (
-    ACPI_NAMESPACE_NODE     *Node,
-    ACPI_SIZE               Size,
-    char                    *NameBuffer);
-
 char *
 AcpiNsGetExternalPathname (
     ACPI_NAMESPACE_NODE     *Node);
 
+UINT32
+AcpiNsBuildNormalizedPath (
+    ACPI_NAMESPACE_NODE     *Node,
+    char                    *FullPath,
+    UINT32                  PathSize,
+    BOOLEAN                 NoTrailing);
+
+char *
+AcpiNsGetNormalizedPathname (
+    ACPI_NAMESPACE_NODE     *Node,
+    BOOLEAN                 NoTrailing);
+
 char *
 AcpiNsNameOfCurrentScope (
     ACPI_WALK_STATE         *WalkState);
@@ -302,7 +382,8 @@ AcpiNsNameOfCurrentScope (
 ACPI_STATUS
 AcpiNsHandleToPathname (
     ACPI_HANDLE             TargetHandle,
-    ACPI_BUFFER             *Buffer);
+    ACPI_BUFFER             *Buffer,
+    BOOLEAN                 NoTrailing);
 
 BOOLEAN
 AcpiNsPatternMatch (
@@ -361,28 +442,28 @@ AcpiNsGetAttachedData (
  * predefined methods/objects
  */
 ACPI_STATUS
-AcpiNsRepairObject (
-    ACPI_PREDEFINED_DATA    *Data,
+AcpiNsSimpleRepair (
+    ACPI_EVALUATE_INFO      *Info,
     UINT32                  ExpectedBtypes,
     UINT32                  PackageIndex,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
 
 ACPI_STATUS
 AcpiNsWrapWithPackage (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_OPERAND_OBJECT     *OriginalObject,
     ACPI_OPERAND_OBJECT     **ObjDescPtr);
 
 ACPI_STATUS
 AcpiNsRepairNullElement (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     UINT32                  ExpectedBtypes,
     UINT32                  PackageIndex,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
 
 void
 AcpiNsRemoveNullElements (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     UINT8                   PackageType,
     ACPI_OPERAND_OBJECT     *ObjDesc);
 
@@ -393,7 +474,7 @@ AcpiNsRemoveNullElements (
  */
 ACPI_STATUS
 AcpiNsComplexRepairs (
-    ACPI_PREDEFINED_DATA    *Data,
+    ACPI_EVALUATE_INFO      *Info,
     ACPI_NAMESPACE_NODE     *Node,
     ACPI_STATUS             ValidateStatus,
     ACPI_OPERAND_OBJECT     **ReturnObjectPtr);
@@ -430,10 +511,6 @@ AcpiNsInstallNode (
 /*
  * nsutils - Utility functions
  */
-BOOLEAN
-AcpiNsValidRootPrefix (
-    char                    Prefix);
-
 ACPI_OBJECT_TYPE
 AcpiNsGetType (
     ACPI_NAMESPACE_NODE     *Node);
diff --git a/usr/src/uts/intel/sys/acpi/acobject.h b/usr/src/uts/intel/sys/acpi/acobject.h
index f2f8a1cfb1..83f29ec3c9 100644
--- a/usr/src/uts/intel/sys/acpi/acobject.h
+++ b/usr/src/uts/intel/sys/acpi/acobject.h
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Name: acobject.h - Definition of ACPI_OPERAND_OBJECT  (Internal object only)
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -94,10 +93,11 @@
 
 #define AOPOBJ_AML_CONSTANT         0x01    /* Integer is an AML constant */
 #define AOPOBJ_STATIC_POINTER       0x02    /* Data is part of an ACPI table, don't delete */
-#define AOPOBJ_DATA_VALID           0x04    /* Object is intialized and data is valid */
-#define AOPOBJ_OBJECT_INITIALIZED   0x08    /* Region is initialized, _REG was run */
-#define AOPOBJ_SETUP_COMPLETE       0x10    /* Region setup is complete */
-#define AOPOBJ_INVALID              0x20    /* Host OS won't allow a Region address */
+#define AOPOBJ_DATA_VALID           0x04    /* Object is initialized and data is valid */
+#define AOPOBJ_OBJECT_INITIALIZED   0x08    /* Region is initialized */
+#define AOPOBJ_REG_CONNECTED        0x10    /* _REG was run */
+#define AOPOBJ_SETUP_COMPLETE       0x20    /* Region setup is complete */
+#define AOPOBJ_INVALID              0x40    /* Host OS won't allow a Region address */
 
 
 /******************************************************************************
@@ -123,8 +123,8 @@ typedef struct acpi_object_integer
 
 
 /*
- * Note: The String and Buffer object must be identical through the Pointer
- * and length elements.  There is code that depends on this.
+ * Note: The String and Buffer object must be identical through the
+ * pointer and length elements. There is code that depends on this.
  *
  * Fields common to both Strings and Buffers
  */
@@ -214,6 +214,7 @@ typedef struct acpi_object_method
     UINT8                           ParamCount;
     UINT8                           SyncLevel;
     union acpi_operand_object       *Mutex;
+    union acpi_operand_object       *Node;
     UINT8                           *AmlStart;
     union
     {
@@ -233,12 +234,13 @@ typedef struct acpi_object_method
 #define ACPI_METHOD_INTERNAL_ONLY       0x02    /* Method is implemented internally (_OSI) */
 #define ACPI_METHOD_SERIALIZED          0x04    /* Method is serialized */
 #define ACPI_METHOD_SERIALIZED_PENDING  0x08    /* Method is to be marked serialized */
-#define ACPI_METHOD_MODIFIED_NAMESPACE  0x10    /* Method modified the namespace */
+#define ACPI_METHOD_IGNORE_SYNC_LEVEL   0x10    /* Method was auto-serialized at table load time */
+#define ACPI_METHOD_MODIFIED_NAMESPACE  0x20    /* Method modified the namespace */
 
 
 /******************************************************************************
  *
- * Objects that can be notified.  All share a common NotifyInfo area.
+ * Objects that can be notified. All share a common NotifyInfo area.
  *
  *****************************************************************************/
 
@@ -301,7 +303,7 @@ typedef struct acpi_object_thermal_zone
 
 /******************************************************************************
  *
- * Fields.  All share a common header/info field.
+ * Fields. All share a common header/info field.
  *
  *****************************************************************************/
 
@@ -338,6 +340,7 @@ typedef struct acpi_object_region_field
     UINT16                          ResourceLength;
     union acpi_operand_object       *RegionObj;         /* Containing OpRegion object */
     UINT8                           *ResourceBuffer;    /* ResourceTemplate for serial regions/fields */
+    UINT16                          PinNumberIndex;     /* Index relative to previous Connection/Template */
 
 } ACPI_OBJECT_REGION_FIELD;
 
@@ -389,7 +392,7 @@ typedef struct acpi_object_notify_handler
     ACPI_OBJECT_COMMON_HEADER
     ACPI_NAMESPACE_NODE             *Node;              /* Parent device */
     UINT32                          HandlerType;        /* Type: Device/System/Both */
-    ACPI_NOTIFY_HANDLER             Handler;            /* Handler addess */
+    ACPI_NOTIFY_HANDLER             Handler;            /* Handler address */
     void                            *Context;
     union acpi_operand_object       *Next[2];           /* Device and System handler lists */
 
@@ -405,7 +408,7 @@ typedef struct acpi_object_addr_handler
     ACPI_NAMESPACE_NODE             *Node;              /* Parent device */
     void                            *Context;
     ACPI_ADR_SPACE_SETUP            Setup;
-    union acpi_operand_object       *RegionList;        /* regions using this handler */
+    union acpi_operand_object       *RegionList;        /* Regions using this handler */
     union acpi_operand_object       *Next;
 
 } ACPI_OBJECT_ADDR_HANDLER;
@@ -429,13 +432,14 @@ typedef struct acpi_object_addr_handler
 typedef struct acpi_object_reference
 {
     ACPI_OBJECT_COMMON_HEADER
-     UINT8                           Class;              /* Reference Class */
-     UINT8                           TargetType;         /* Used for Index Op */
-     UINT8                           Reserved;
-     void                            *Object;            /* NameOp=>HANDLE to obj, IndexOp=>ACPI_OPERAND_OBJECT */
-     ACPI_NAMESPACE_NODE             *Node;              /* RefOf or Namepath */
-     union acpi_operand_object       **Where;            /* Target of Index */
-     UINT32                          Value;              /* Used for Local/Arg/Index/DdbHandle */
+    UINT8                           Class;              /* Reference Class */
+    UINT8                           TargetType;         /* Used for Index Op */
+    UINT8                           Reserved;
+    void                            *Object;            /* NameOp=>HANDLE to obj, IndexOp=>ACPI_OPERAND_OBJECT */
+    ACPI_NAMESPACE_NODE             *Node;              /* RefOf or Namepath */
+    union acpi_operand_object       **Where;            /* Target of Index */
+    UINT8                           *IndexPointer;      /* Used for Buffers and Strings */
+    UINT32                          Value;              /* Used for Local/Arg/Index/DdbHandle */
 
 } ACPI_OBJECT_REFERENCE;
 
diff --git a/usr/src/uts/intel/sys/acpi/acopcode.h b/usr/src/uts/intel/sys/acpi/acopcode.h
index e182a07e61..a278d4a154 100644
--- a/usr/src/uts/intel/sys/acpi/acopcode.h
+++ b/usr/src/uts/intel/sys/acpi/acopcode.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -54,7 +54,7 @@
 #define _UNK                        0x6B
 
 /*
- * Reserved ASCII characters.  Do not use any of these for
+ * Reserved ASCII characters. Do not use any of these for
  * internal opcodes, since they are used to differentiate
  * name strings from AML opcodes
  */
@@ -64,7 +64,7 @@
 
 
 /*
- * All AML opcodes and the parse-time arguments for each.  Used by the AML
+ * All AML opcodes and the parse-time arguments for each. Used by the AML
  * parser  Each list is compressed into a 32-bit number and stored in the
  * master opcode table (in psopcode.c).
  */
@@ -93,7 +93,7 @@
 #define ARGP_BYTELIST_OP                ARGP_LIST1 (ARGP_NAMESTRING)
 #define ARGP_CONCAT_OP                  ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
 #define ARGP_CONCAT_RES_OP              ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_COND_REF_OF_OP             ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_SUPERNAME)
+#define ARGP_COND_REF_OF_OP             ARGP_LIST2 (ARGP_NAME_OR_REF,ARGP_TARGET)
 #define ARGP_CONNECTFIELD_OP            ARGP_LIST1 (ARGP_NAMESTRING)
 #define ARGP_CONTINUE_OP                ARG_NONE
 #define ARGP_COPY_OP                    ARGP_LIST2 (ARGP_TERMARG,    ARGP_SIMPLENAME)
@@ -112,6 +112,7 @@
 #define ARGP_DWORD_OP                   ARGP_LIST1 (ARGP_DWORDDATA)
 #define ARGP_ELSE_OP                    ARGP_LIST2 (ARGP_PKGLENGTH,  ARGP_TERMLIST)
 #define ARGP_EVENT_OP                   ARGP_LIST1 (ARGP_NAME)
+#define ARGP_EXTERNAL_OP                ARGP_LIST3 (ARGP_NAMESTRING, ARGP_BYTEDATA,      ARGP_BYTEDATA)
 #define ARGP_FATAL_OP                   ARGP_LIST3 (ARGP_BYTEDATA,   ARGP_DWORDDATA,     ARGP_TERMARG)
 #define ARGP_FIELD_OP                   ARGP_LIST4 (ARGP_PKGLENGTH,  ARGP_NAMESTRING,    ARGP_BYTEDATA,  ARGP_FIELDLIST)
 #define ARGP_FIND_SET_LEFT_BIT_OP       ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
@@ -152,13 +153,14 @@
 #define ARGP_NAMEPATH_OP                ARGP_LIST1 (ARGP_NAMESTRING)
 #define ARGP_NOOP_OP                    ARG_NONE
 #define ARGP_NOTIFY_OP                  ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
+#define ARGP_OBJECT_TYPE_OP             ARGP_LIST1 (ARGP_NAME_OR_REF)
 #define ARGP_ONE_OP                     ARG_NONE
 #define ARGP_ONES_OP                    ARG_NONE
 #define ARGP_PACKAGE_OP                 ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_BYTEDATA,      ARGP_DATAOBJLIST)
 #define ARGP_POWER_RES_OP               ARGP_LIST5 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_WORDDATA,  ARGP_OBJLIST)
 #define ARGP_PROCESSOR_OP               ARGP_LIST6 (ARGP_PKGLENGTH,  ARGP_NAME,          ARGP_BYTEDATA,  ARGP_DWORDDATA, ARGP_BYTEDATA,  ARGP_OBJLIST)
 #define ARGP_QWORD_OP                   ARGP_LIST1 (ARGP_QWORDDATA)
-#define ARGP_REF_OF_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
+#define ARGP_REF_OF_OP                  ARGP_LIST1 (ARGP_NAME_OR_REF)
 #define ARGP_REGION_OP                  ARGP_LIST4 (ARGP_NAME,       ARGP_BYTEDATA,      ARGP_TERMARG,   ARGP_TERMARG)
 #define ARGP_RELEASE_OP                 ARGP_LIST1 (ARGP_SUPERNAME)
 #define ARGP_RESERVEDFIELD_OP           ARGP_LIST1 (ARGP_NAMESTRING)
@@ -185,7 +187,6 @@
 #define ARGP_TO_HEX_STR_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
 #define ARGP_TO_INTEGER_OP              ARGP_LIST2 (ARGP_TERMARG,    ARGP_TARGET)
 #define ARGP_TO_STRING_OP               ARGP_LIST3 (ARGP_TERMARG,    ARGP_TERMARG,       ARGP_TARGET)
-#define ARGP_TYPE_OP                    ARGP_LIST1 (ARGP_SUPERNAME)
 #define ARGP_UNLOAD_OP                  ARGP_LIST1 (ARGP_SUPERNAME)
 #define ARGP_VAR_PACKAGE_OP             ARGP_LIST3 (ARGP_PKGLENGTH,  ARGP_TERMARG,       ARGP_DATAOBJLIST)
 #define ARGP_WAIT_OP                    ARGP_LIST2 (ARGP_SUPERNAME,  ARGP_TERMARG)
@@ -195,7 +196,7 @@
 
 
 /*
- * All AML opcodes and the runtime arguments for each.  Used by the AML
+ * All AML opcodes and the runtime arguments for each. Used by the AML
  * interpreter  Each list is compressed into a 32-bit number and stored
  * in the master opcode table (in psopcode.c).
  *
@@ -212,7 +213,7 @@
 #define ARGI_ARG4                       ARG_NONE
 #define ARGI_ARG5                       ARG_NONE
 #define ARGI_ARG6                       ARG_NONE
-#define ARGI_BANK_FIELD_OP              ARGI_INVALID_OPCODE
+#define ARGI_BANK_FIELD_OP              ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_BIT_AND_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
 #define ARGI_BIT_NAND_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
 #define ARGI_BIT_NOR_OP                 ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
@@ -224,7 +225,7 @@
 #define ARGI_BUFFER_OP                  ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_BYTE_OP                    ARGI_INVALID_OPCODE
 #define ARGI_BYTELIST_OP                ARGI_INVALID_OPCODE
-#define ARGI_CONCAT_OP                  ARGI_LIST3 (ARGI_COMPUTEDATA,ARGI_COMPUTEDATA,   ARGI_TARGETREF)
+#define ARGI_CONCAT_OP                  ARGI_LIST3 (ARGI_ANYTYPE,    ARGI_ANYTYPE,       ARGI_TARGETREF)
 #define ARGI_CONCAT_RES_OP              ARGI_LIST3 (ARGI_BUFFER,     ARGI_BUFFER,        ARGI_TARGETREF)
 #define ARGI_COND_REF_OF_OP             ARGI_LIST2 (ARGI_OBJECT_REF, ARGI_TARGETREF)
 #define ARGI_CONNECTFIELD_OP            ARGI_INVALID_OPCODE
@@ -245,6 +246,7 @@
 #define ARGI_DWORD_OP                   ARGI_INVALID_OPCODE
 #define ARGI_ELSE_OP                    ARGI_INVALID_OPCODE
 #define ARGI_EVENT_OP                   ARGI_INVALID_OPCODE
+#define ARGI_EXTERNAL_OP                ARGI_LIST3 (ARGI_STRING,     ARGI_INTEGER,       ARGI_INTEGER)
 #define ARGI_FATAL_OP                   ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_INTEGER)
 #define ARGI_FIELD_OP                   ARGI_INVALID_OPCODE
 #define ARGI_FIND_SET_LEFT_BIT_OP       ARGI_LIST2 (ARGI_INTEGER,    ARGI_TARGETREF)
@@ -285,6 +287,7 @@
 #define ARGI_NAMEPATH_OP                ARGI_INVALID_OPCODE
 #define ARGI_NOOP_OP                    ARG_NONE
 #define ARGI_NOTIFY_OP                  ARGI_LIST2 (ARGI_DEVICE_REF, ARGI_INTEGER)
+#define ARGI_OBJECT_TYPE_OP             ARGI_LIST1 (ARGI_ANYTYPE)
 #define ARGI_ONE_OP                     ARG_NONE
 #define ARGI_ONES_OP                    ARG_NONE
 #define ARGI_PACKAGE_OP                 ARGI_LIST1 (ARGI_INTEGER)
@@ -307,7 +310,7 @@
 #define ARGI_SLEEP_OP                   ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_STALL_OP                   ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_STATICSTRING_OP            ARGI_INVALID_OPCODE
-#define ARGI_STORE_OP                   ARGI_LIST2 (ARGI_DATAREFOBJ, ARGI_TARGETREF)
+#define ARGI_STORE_OP                   ARGI_LIST2 (ARGI_DATAREFOBJ, ARGI_STORE_TARGET)
 #define ARGI_STRING_OP                  ARGI_INVALID_OPCODE
 #define ARGI_SUBTRACT_OP                ARGI_LIST3 (ARGI_INTEGER,    ARGI_INTEGER,       ARGI_TARGETREF)
 #define ARGI_THERMAL_ZONE_OP            ARGI_INVALID_OPCODE
@@ -318,7 +321,6 @@
 #define ARGI_TO_HEX_STR_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
 #define ARGI_TO_INTEGER_OP              ARGI_LIST2 (ARGI_COMPUTEDATA,ARGI_FIXED_TARGET)
 #define ARGI_TO_STRING_OP               ARGI_LIST3 (ARGI_BUFFER,     ARGI_INTEGER,       ARGI_FIXED_TARGET)
-#define ARGI_TYPE_OP                    ARGI_LIST1 (ARGI_ANYTYPE)
 #define ARGI_UNLOAD_OP                  ARGI_LIST1 (ARGI_DDBHANDLE)
 #define ARGI_VAR_PACKAGE_OP             ARGI_LIST1 (ARGI_INTEGER)
 #define ARGI_WAIT_OP                    ARGI_LIST2 (ARGI_EVENT,      ARGI_INTEGER)
diff --git a/usr/src/uts/intel/sys/acpi/acoutput.h b/usr/src/uts/intel/sys/acpi/acoutput.h
index a1d89d408c..4fb718208c 100644
--- a/usr/src/uts/intel/sys/acpi/acoutput.h
+++ b/usr/src/uts/intel/sys/acpi/acoutput.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -89,7 +89,8 @@
 #define ACPI_LV_DEBUG_OBJECT        0x00000002
 #define ACPI_LV_INFO                0x00000004
 #define ACPI_LV_REPAIR              0x00000008
-#define ACPI_LV_ALL_EXCEPTIONS      0x0000000F
+#define ACPI_LV_TRACE_POINT         0x00000010
+#define ACPI_LV_ALL_EXCEPTIONS      0x0000001F
 
 /* Trace verbosity level 1 [Standard Trace Level] */
 
@@ -149,6 +150,7 @@
 #define ACPI_DB_DEBUG_OBJECT        ACPI_DEBUG_LEVEL (ACPI_LV_DEBUG_OBJECT)
 #define ACPI_DB_INFO                ACPI_DEBUG_LEVEL (ACPI_LV_INFO)
 #define ACPI_DB_REPAIR              ACPI_DEBUG_LEVEL (ACPI_LV_REPAIR)
+#define ACPI_DB_TRACE_POINT         ACPI_DEBUG_LEVEL (ACPI_LV_TRACE_POINT)
 #define ACPI_DB_ALL_EXCEPTIONS      ACPI_DEBUG_LEVEL (ACPI_LV_ALL_EXCEPTIONS)
 
 /* Trace level -- also used in the global "DebugLevel" */
@@ -185,6 +187,21 @@
 #define ACPI_DEBUG_ALL              (ACPI_LV_AML_DISASSEMBLE | ACPI_LV_ALL_EXCEPTIONS | ACPI_LV_ALL)
 
 
+/*
+ * Global trace flags
+ */
+#define ACPI_TRACE_ENABLED          ((UINT32) 4)
+#define ACPI_TRACE_ONESHOT          ((UINT32) 2)
+#define ACPI_TRACE_OPCODE           ((UINT32) 1)
+
+/* Defaults for trace debugging level/layer */
+
+#define ACPI_TRACE_LEVEL_ALL        ACPI_LV_ALL
+#define ACPI_TRACE_LAYER_ALL        0x000001FF
+#define ACPI_TRACE_LEVEL_DEFAULT    ACPI_LV_TRACE_POINT
+#define ACPI_TRACE_LAYER_DEFAULT    ACPI_EXECUTER
+
+
 #if defined (ACPI_DEBUG_OUTPUT) || !defined (ACPI_NO_ERROR_MESSAGES)
 /*
  * The module name is used primarily for error and debug messages.
@@ -217,6 +234,8 @@
 #define ACPI_WARNING(plist)             AcpiWarning plist
 #define ACPI_EXCEPTION(plist)           AcpiException plist
 #define ACPI_ERROR(plist)               AcpiError plist
+#define ACPI_BIOS_WARNING(plist)        AcpiBiosWarning plist
+#define ACPI_BIOS_ERROR(plist)          AcpiBiosError plist
 #define ACPI_DEBUG_OBJECT(obj,l,i)      AcpiExDoDebugObject(obj,l,i)
 
 #else
@@ -227,6 +246,8 @@
 #define ACPI_WARNING(plist)
 #define ACPI_EXCEPTION(plist)
 #define ACPI_ERROR(plist)
+#define ACPI_BIOS_WARNING(plist)
+#define ACPI_BIOS_ERROR(plist)
 #define ACPI_DEBUG_OBJECT(obj,l,i)
 
 #endif /* ACPI_NO_ERROR_MESSAGES */
@@ -246,7 +267,7 @@
 #define ACPI_GET_FUNCTION_NAME          _AcpiFunctionName
 
 /*
- * The Name parameter should be the procedure name as a quoted string.
+ * The Name parameter should be the procedure name as a non-quoted string.
  * The function name is also used by the function exit macros below.
  * Note: (const char) is used to be compatible with the debug interfaces
  * and macros such as __FUNCTION__.
@@ -263,25 +284,215 @@
  * Common parameters used for debug output functions:
  * line number, function name, module(file) name, component ID
  */
-#define ACPI_DEBUG_PARAMETERS           __LINE__, ACPI_GET_FUNCTION_NAME, _AcpiModuleName, _COMPONENT
+#define ACPI_DEBUG_PARAMETERS \
+    __LINE__, ACPI_GET_FUNCTION_NAME, _AcpiModuleName, _COMPONENT
+
+/* Check if debug output is currently dynamically enabled */
+
+#define ACPI_IS_DEBUG_ENABLED(Level, Component) \
+    ((Level & AcpiDbgLevel) && (Component & AcpiDbgLayer))
 
 /*
  * Master debug print macros
  * Print message if and only if:
  *    1) Debug print for the current component is enabled
  *    2) Debug error level or trace level for the print statement is enabled
+ *
+ * November 2012: Moved the runtime check for whether to actually emit the
+ * debug message outside of the print function itself. This improves overall
+ * performance at a relatively small code cost. Implementation involves the
+ * use of variadic macros supported by C99.
+ *
+ * Note: the ACPI_DO_WHILE0 macro is used to prevent some compilers from
+ * complaining about these constructs. On other compilers the do...while
+ * adds some extra code, so this feature is optional.
  */
+#ifdef ACPI_USE_DO_WHILE_0
+#define ACPI_DO_WHILE0(a)               do a while(0)
+#else
+#define ACPI_DO_WHILE0(a)               a
+#endif
+
+/* DEBUG_PRINT functions */
+
+#ifndef COMPILER_VA_MACRO
+
 #define ACPI_DEBUG_PRINT(plist)         AcpiDebugPrint plist
 #define ACPI_DEBUG_PRINT_RAW(plist)     AcpiDebugPrintRaw plist
 
 #else
+
+/* Helper macros for DEBUG_PRINT */
+
+#define ACPI_DO_DEBUG_PRINT(Function, Level, Line, Filename, Modulename, Component, ...) \
+    ACPI_DO_WHILE0 ({ \
+        if (ACPI_IS_DEBUG_ENABLED (Level, Component)) \
+        { \
+            Function (Level, Line, Filename, Modulename, Component, __VA_ARGS__); \
+        } \
+    })
+
+#define ACPI_ACTUAL_DEBUG(Level, Line, Filename, Modulename, Component, ...) \
+    ACPI_DO_DEBUG_PRINT (AcpiDebugPrint, Level, Line, \
+        Filename, Modulename, Component, __VA_ARGS__)
+
+#define ACPI_ACTUAL_DEBUG_RAW(Level, Line, Filename, Modulename, Component, ...) \
+    ACPI_DO_DEBUG_PRINT (AcpiDebugPrintRaw, Level, Line, \
+        Filename, Modulename, Component, __VA_ARGS__)
+
+#define ACPI_DEBUG_PRINT(plist)         ACPI_ACTUAL_DEBUG plist
+#define ACPI_DEBUG_PRINT_RAW(plist)     ACPI_ACTUAL_DEBUG_RAW plist
+
+#endif
+
+
+/*
+ * Function entry tracing
+ *
+ * The name of the function is emitted as a local variable that is
+ * intended to be used by both the entry trace and the exit trace.
+ */
+
+/* Helper macro */
+
+#define ACPI_TRACE_ENTRY(Name, Function, Type, Param) \
+    ACPI_FUNCTION_NAME (Name) \
+    Function (ACPI_DEBUG_PARAMETERS, (Type) (Param))
+
+/* The actual entry trace macros */
+
+#define ACPI_FUNCTION_TRACE(Name) \
+    ACPI_FUNCTION_NAME(Name) \
+    AcpiUtTrace (ACPI_DEBUG_PARAMETERS)
+
+#define ACPI_FUNCTION_TRACE_PTR(Name, Pointer) \
+    ACPI_TRACE_ENTRY (Name, AcpiUtTracePtr, void *, Pointer)
+
+#define ACPI_FUNCTION_TRACE_U32(Name, Value) \
+    ACPI_TRACE_ENTRY (Name, AcpiUtTraceU32, UINT32, Value)
+
+#define ACPI_FUNCTION_TRACE_STR(Name, String) \
+    ACPI_TRACE_ENTRY (Name, AcpiUtTraceStr, const char *, String)
+
+#define ACPI_FUNCTION_ENTRY() \
+    AcpiUtTrackStackPtr()
+
+
+/*
+ * Function exit tracing
+ *
+ * These macros include a return statement. This is usually considered
+ * bad form, but having a separate exit macro before the actual return
+ * is very ugly and difficult to maintain.
+ *
+ * One of the FUNCTION_TRACE macros above must be used in conjunction
+ * with these macros so that "_AcpiFunctionName" is defined.
+ *
+ * There are two versions of most of the return macros. The default version is
+ * safer, since it avoids side-effects by guaranteeing that the argument will
+ * not be evaluated twice.
+ *
+ * A less-safe version of the macros is provided for optional use if the
+ * compiler uses excessive CPU stack (for example, this may happen in the
+ * debug case if code optimzation is disabled.)
+ */
+
+/* Exit trace helper macro */
+
+#ifndef ACPI_SIMPLE_RETURN_MACROS
+
+#define ACPI_TRACE_EXIT(Function, Type, Param) \
+    ACPI_DO_WHILE0 ({ \
+        register Type _Param = (Type) (Param); \
+        Function (ACPI_DEBUG_PARAMETERS, _Param); \
+        return (_Param); \
+    })
+
+#else /* Use original less-safe macros */
+
+#define ACPI_TRACE_EXIT(Function, Type, Param) \
+    ACPI_DO_WHILE0 ({ \
+        Function (ACPI_DEBUG_PARAMETERS, (Type) (Param)); \
+        return (Param); \
+    })
+
+#endif /* ACPI_SIMPLE_RETURN_MACROS */
+
+/* The actual exit macros */
+
+#define return_VOID \
+    ACPI_DO_WHILE0 ({ \
+        AcpiUtExit (ACPI_DEBUG_PARAMETERS); \
+        return; \
+    })
+
+#define return_ACPI_STATUS(Status) \
+    ACPI_TRACE_EXIT (AcpiUtStatusExit, ACPI_STATUS, Status)
+
+#define return_PTR(Pointer) \
+    ACPI_TRACE_EXIT (AcpiUtPtrExit, void *, Pointer)
+
+#define return_STR(String) \
+    ACPI_TRACE_EXIT (AcpiUtStrExit, const char *, String)
+
+#define return_VALUE(Value) \
+    ACPI_TRACE_EXIT (AcpiUtValueExit, UINT64, Value)
+
+#define return_UINT32(Value) \
+    ACPI_TRACE_EXIT (AcpiUtValueExit, UINT32, Value)
+
+#define return_UINT8(Value) \
+    ACPI_TRACE_EXIT (AcpiUtValueExit, UINT8, Value)
+
+/* Conditional execution */
+
+#define ACPI_DEBUG_EXEC(a)              a
+#define ACPI_DEBUG_ONLY_MEMBERS(a)      a;
+#define _VERBOSE_STRUCTURES
+
+
+/* Various object display routines for debug */
+
+#define ACPI_DUMP_STACK_ENTRY(a)        AcpiExDumpOperand((a), 0)
+#define ACPI_DUMP_OPERANDS(a, b ,c)     AcpiExDumpOperands(a, b, c)
+#define ACPI_DUMP_ENTRY(a, b)           AcpiNsDumpEntry (a, b)
+#define ACPI_DUMP_PATHNAME(a, b, c, d)  AcpiNsDumpPathname(a, b, c, d)
+#define ACPI_DUMP_BUFFER(a, b)          AcpiUtDebugDumpBuffer((UINT8 *) a, b, DB_BYTE_DISPLAY, _COMPONENT)
+
+#define ACPI_TRACE_POINT(a, b, c, d)    AcpiTracePoint (a, b, c, d)
+
+#else /* ACPI_DEBUG_OUTPUT */
 /*
  * This is the non-debug case -- make everything go away,
  * leaving no executable debug code!
  */
-#define ACPI_FUNCTION_NAME(a)
 #define ACPI_DEBUG_PRINT(pl)
 #define ACPI_DEBUG_PRINT_RAW(pl)
+#define ACPI_DEBUG_EXEC(a)
+#define ACPI_DEBUG_ONLY_MEMBERS(a)
+#define ACPI_FUNCTION_NAME(a)
+#define ACPI_FUNCTION_TRACE(a)
+#define ACPI_FUNCTION_TRACE_PTR(a, b)
+#define ACPI_FUNCTION_TRACE_U32(a, b)
+#define ACPI_FUNCTION_TRACE_STR(a, b)
+#define ACPI_FUNCTION_ENTRY()
+#define ACPI_DUMP_STACK_ENTRY(a)
+#define ACPI_DUMP_OPERANDS(a, b, c)
+#define ACPI_DUMP_ENTRY(a, b)
+#define ACPI_DUMP_PATHNAME(a, b, c, d)
+#define ACPI_DUMP_BUFFER(a, b)
+#define ACPI_IS_DEBUG_ENABLED(Level, Component) 0
+#define ACPI_TRACE_POINT(a, b, c, d)
+
+/* Return macros must have a return statement at the minimum */
+
+#define return_VOID                     return
+#define return_ACPI_STATUS(s)           return(s)
+#define return_PTR(s)                   return(s)
+#define return_STR(s)                   return(s)
+#define return_VALUE(s)                 return(s)
+#define return_UINT8(s)                 return(s)
+#define return_UINT32(s)                return(s)
 
 #endif /* ACPI_DEBUG_OUTPUT */
 
diff --git a/usr/src/uts/intel/sys/acpi/acparser.h b/usr/src/uts/intel/sys/acpi/acparser.h
index f46d3cbc2c..dd2782199d 100644
--- a/usr/src/uts/intel/sys/acpi/acparser.h
+++ b/usr/src/uts/intel/sys/acpi/acparser.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #ifndef __ACPARSER_H__
 #define __ACPARSER_H__
 
@@ -73,6 +72,9 @@
  *
  *****************************************************************************/
 
+extern const UINT8      AcpiGbl_ShortOpIndex[];
+extern const UINT8      AcpiGbl_LongOpIndex[];
+
 
 /*
  * psxface - Parser external interfaces
@@ -104,7 +106,12 @@ AcpiPsGetNextNamepath (
     ACPI_WALK_STATE         *WalkState,
     ACPI_PARSE_STATE        *ParserState,
     ACPI_PARSE_OBJECT       *Arg,
-    BOOLEAN                 MethodCall);
+    BOOLEAN                 PossibleMethodCall);
+
+/* Values for BOOLEAN above */
+
+#define ACPI_NOT_METHOD_CALL            FALSE
+#define ACPI_POSSIBLE_METHOD_CALL       TRUE
 
 ACPI_STATUS
 AcpiPsGetNextArg (
@@ -129,13 +136,42 @@ AcpiPsGetParent (
 
 
 /*
- * psopcode - AML Opcode information
+ * psobject - support for parse object processing
+ */
+ACPI_STATUS
+AcpiPsBuildNamedOp (
+    ACPI_WALK_STATE         *WalkState,
+    UINT8                   *AmlOpStart,
+    ACPI_PARSE_OBJECT       *UnnamedOp,
+    ACPI_PARSE_OBJECT       **Op);
+
+ACPI_STATUS
+AcpiPsCreateOp (
+    ACPI_WALK_STATE         *WalkState,
+    UINT8                   *AmlOpStart,
+    ACPI_PARSE_OBJECT       **NewOp);
+
+ACPI_STATUS
+AcpiPsCompleteOp (
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       **Op,
+    ACPI_STATUS             Status);
+
+ACPI_STATUS
+AcpiPsCompleteFinalOp (
+    ACPI_WALK_STATE         *WalkState,
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_STATUS             Status);
+
+
+/*
+ * psopinfo - AML Opcode information
  */
 const ACPI_OPCODE_INFO *
 AcpiPsGetOpcodeInfo (
     UINT16                  Opcode);
 
-char *
+const char *
 AcpiPsGetOpcodeName (
     UINT16                  Opcode);
 
@@ -275,7 +311,7 @@ AcpiPsDeleteParseTree (
  */
 ACPI_PARSE_OBJECT *
 AcpiPsCreateScopeOp (
-    void);
+    UINT8                   *Aml);
 
 void
 AcpiPsInitOp (
@@ -284,7 +320,8 @@ AcpiPsInitOp (
 
 ACPI_PARSE_OBJECT *
 AcpiPsAllocOp (
-    UINT16                  opcode);
+    UINT16                  Opcode,
+    UINT8                   *Aml);
 
 void
 AcpiPsFreeOp (
@@ -294,10 +331,6 @@ BOOLEAN
 AcpiPsIsLeadingChar (
     UINT32                  c);
 
-BOOLEAN
-AcpiPsIsPrefixChar (
-    UINT32                  c);
-
 UINT32
 AcpiPsGetName(
     ACPI_PARSE_OBJECT       *op);
diff --git a/usr/src/uts/intel/sys/acpi/acpi.h b/usr/src/uts/intel/sys/acpi/acpi.h
index aa40219112..105cb52568 100644
--- a/usr/src/uts/intel/sys/acpi/acpi.h
+++ b/usr/src/uts/intel/sys/acpi/acpi.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -62,5 +62,6 @@
 #include "acrestyp.h"           /* Resource Descriptor structs */
 #include "acpiosxf.h"           /* OSL interfaces (ACPICA-to-OS) */
 #include "acpixf.h"             /* ACPI core subsystem external interfaces */
+#include "platform/acenvex.h"   /* Extra environment-specific items */
 
 #endif /* __ACPI_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/acpi_pci.h b/usr/src/uts/intel/sys/acpi/acpi_pci.h
index d994eb8e2d..b4fd3393ab 100644
--- a/usr/src/uts/intel/sys/acpi/acpi_pci.h
+++ b/usr/src/uts/intel/sys/acpi/acpi_pci.h
@@ -21,6 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2016 Joyent, Inc.
  */
 
 #ifndef	_ACPI_PCI_H
@@ -32,13 +33,10 @@ extern "C" {
 
 /*
  * Memory mapped configuration space address description table documented
- * in ACPI 3.0.  These definitions are currently not included in the
- * actbl.h from Intel.  This file will need to be removed once Intel has
- * updated their include file with these information.
+ * in ACPI 3.0.  These definitions are currently not the same as in the
+ * actbl2.h from Intel.  This file might be removed if the code can be ported
+ * to use the definition provided by Intel.
  */
-#define	MCFG_SIG	"MCFG"		/* Memory mapped config space address */
-					/* description table's signature */
-
 #pragma pack(1)
 
 typedef struct cfg_base_addr_alloc {
diff --git a/usr/src/uts/intel/sys/acpi/acpiosxf.h b/usr/src/uts/intel/sys/acpi/acpiosxf.h
index b79d0e6ade..eb61d9a8ce 100644
--- a/usr/src/uts/intel/sys/acpi/acpiosxf.h
+++ b/usr/src/uts/intel/sys/acpi/acpiosxf.h
@@ -1,15 +1,13 @@
-
 /******************************************************************************
  *
- * Name: acpiosxf.h - All interfaces to the OS Services Layer (OSL).  These
+ * Name: acpiosxf.h - All interfaces to the OS Services Layer (OSL). These
  *                    interfaces must be implemented by OSL to interface the
  *                    ACPI components to the host operating system.
  *
  *****************************************************************************/
 
-
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -59,7 +57,8 @@ typedef enum
     OSL_GLOBAL_LOCK_HANDLER,
     OSL_NOTIFY_HANDLER,
     OSL_GPE_HANDLER,
-    OSL_DEBUGGER_THREAD,
+    OSL_DEBUGGER_MAIN_THREAD,
+    OSL_DEBUGGER_EXEC_THREAD,
     OSL_EC_POLL_HANDLER,
     OSL_EC_BURST_HANDLER
 
@@ -86,83 +85,111 @@ typedef struct acpi_signal_fatal_info
 /*
  * OSL Initialization and shutdown primitives
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsInitialize
 ACPI_STATUS
 AcpiOsInitialize (
     void);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsTerminate
 ACPI_STATUS
 AcpiOsTerminate (
     void);
+#endif
 
 
 /*
  * ACPI Table interfaces
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetRootPointer
 ACPI_PHYSICAL_ADDRESS
 AcpiOsGetRootPointer (
     void);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsPredefinedOverride
 ACPI_STATUS
 AcpiOsPredefinedOverride (
     const ACPI_PREDEFINED_NAMES *InitVal,
     ACPI_STRING                 *NewVal);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsTableOverride
 ACPI_STATUS
 AcpiOsTableOverride (
     ACPI_TABLE_HEADER       *ExistingTable,
     ACPI_TABLE_HEADER       **NewTable);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsPhysicalTableOverride
 ACPI_STATUS
 AcpiOsPhysicalTableOverride (
     ACPI_TABLE_HEADER       *ExistingTable,
     ACPI_PHYSICAL_ADDRESS   *NewAddress,
     UINT32                  *NewTableLength);
+#endif
 
 
 /*
  * Spinlock primitives
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCreateLock
 ACPI_STATUS
 AcpiOsCreateLock (
     ACPI_SPINLOCK           *OutHandle);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsDeleteLock
 void
 AcpiOsDeleteLock (
     ACPI_SPINLOCK           Handle);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAcquireLock
 ACPI_CPU_FLAGS
 AcpiOsAcquireLock (
     ACPI_SPINLOCK           Handle);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReleaseLock
 void
 AcpiOsReleaseLock (
     ACPI_SPINLOCK           Handle,
     ACPI_CPU_FLAGS          Flags);
+#endif
 
 
 /*
  * Semaphore primitives
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCreateSemaphore
 ACPI_STATUS
 AcpiOsCreateSemaphore (
     UINT32                  MaxUnits,
     UINT32                  InitialUnits,
     ACPI_SEMAPHORE          *OutHandle);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsDeleteSemaphore
 ACPI_STATUS
 AcpiOsDeleteSemaphore (
     ACPI_SEMAPHORE          Handle);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWaitSemaphore
 ACPI_STATUS
 AcpiOsWaitSemaphore (
     ACPI_SEMAPHORE          Handle,
     UINT32                  Units,
     UINT16                  Timeout);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsSignalSemaphore
 ACPI_STATUS
 AcpiOsSignalSemaphore (
     ACPI_SEMAPHORE          Handle,
     UINT32                  Units);
+#endif
 
 
 /*
@@ -171,151 +198,208 @@ AcpiOsSignalSemaphore (
  */
 #if (ACPI_MUTEX_TYPE != ACPI_BINARY_SEMAPHORE)
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCreateMutex
 ACPI_STATUS
 AcpiOsCreateMutex (
     ACPI_MUTEX              *OutHandle);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsDeleteMutex
 void
 AcpiOsDeleteMutex (
     ACPI_MUTEX              Handle);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAcquireMutex
 ACPI_STATUS
 AcpiOsAcquireMutex (
     ACPI_MUTEX              Handle,
     UINT16                  Timeout);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReleaseMutex
 void
 AcpiOsReleaseMutex (
     ACPI_MUTEX              Handle);
 #endif
 
+#endif
+
 
 /*
  * Memory allocation and mapping
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAllocate
 void *
 AcpiOsAllocate (
     ACPI_SIZE               Size);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAllocateZeroed
+void *
+AcpiOsAllocateZeroed (
+    ACPI_SIZE               Size);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsFree
 void
 AcpiOsFree (
     void *                  Memory);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsMapMemory
 void *
 AcpiOsMapMemory (
     ACPI_PHYSICAL_ADDRESS   Where,
     ACPI_SIZE               Length);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsUnmapMemory
 void
 AcpiOsUnmapMemory (
     void                    *LogicalAddress,
     ACPI_SIZE               Size);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetPhysicalAddress
 ACPI_STATUS
 AcpiOsGetPhysicalAddress (
     void                    *LogicalAddress,
     ACPI_PHYSICAL_ADDRESS   *PhysicalAddress);
+#endif
 
 
 /*
  * Memory/Object Cache
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCreateCache
 ACPI_STATUS
 AcpiOsCreateCache (
     char                    *CacheName,
     UINT16                  ObjectSize,
     UINT16                  MaxDepth,
     ACPI_CACHE_T            **ReturnCache);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsDeleteCache
 ACPI_STATUS
 AcpiOsDeleteCache (
     ACPI_CACHE_T            *Cache);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsPurgeCache
 ACPI_STATUS
 AcpiOsPurgeCache (
     ACPI_CACHE_T            *Cache);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAcquireObject
 void *
 AcpiOsAcquireObject (
     ACPI_CACHE_T            *Cache);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReleaseObject
 ACPI_STATUS
 AcpiOsReleaseObject (
     ACPI_CACHE_T            *Cache,
     void                    *Object);
+#endif
 
 
 /*
  * Interrupt handlers
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsInstallInterruptHandler
 ACPI_STATUS
 AcpiOsInstallInterruptHandler (
     UINT32                  InterruptNumber,
     ACPI_OSD_HANDLER        ServiceRoutine,
     void                    *Context);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsRemoveInterruptHandler
 ACPI_STATUS
 AcpiOsRemoveInterruptHandler (
     UINT32                  InterruptNumber,
     ACPI_OSD_HANDLER        ServiceRoutine);
+#endif
 
 
 /*
  * Threads and Scheduling
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetThreadId
 ACPI_THREAD_ID
 AcpiOsGetThreadId (
     void);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsExecute
 ACPI_STATUS
 AcpiOsExecute (
     ACPI_EXECUTE_TYPE       Type,
     ACPI_OSD_EXEC_CALLBACK  Function,
     void                    *Context);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWaitEventsComplete
 void
 AcpiOsWaitEventsComplete (
-    void                    *Context);
+    void);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsSleep
 void
 AcpiOsSleep (
     UINT64                  Milliseconds);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsStall
 void
 AcpiOsStall (
     UINT32                  Microseconds);
+#endif
 
 
 /*
  * Platform and hardware-independent I/O interfaces
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadPort
 ACPI_STATUS
 AcpiOsReadPort (
     ACPI_IO_ADDRESS         Address,
     UINT32                  *Value,
     UINT32                  Width);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWritePort
 ACPI_STATUS
 AcpiOsWritePort (
     ACPI_IO_ADDRESS         Address,
     UINT32                  Value,
     UINT32                  Width);
+#endif
 
 
 /*
  * Platform and hardware-independent physical memory interfaces
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadMemory
 ACPI_STATUS
 AcpiOsReadMemory (
     ACPI_PHYSICAL_ADDRESS   Address,
     UINT64                  *Value,
     UINT32                  Width);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWriteMemory
 ACPI_STATUS
 AcpiOsWriteMemory (
     ACPI_PHYSICAL_ADDRESS   Address,
     UINT64                  Value,
     UINT32                  Width);
+#endif
 
 
 /*
@@ -323,80 +407,131 @@ AcpiOsWriteMemory (
  * Note: Can't use "Register" as a parameter, changed to "Reg" --
  * certain compilers complain.
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadPciConfiguration
 ACPI_STATUS
 AcpiOsReadPciConfiguration (
     ACPI_PCI_ID             *PciId,
     UINT32                  Reg,
     UINT64                  *Value,
     UINT32                  Width);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWritePciConfiguration
 ACPI_STATUS
 AcpiOsWritePciConfiguration (
     ACPI_PCI_ID             *PciId,
     UINT32                  Reg,
     UINT64                  Value,
     UINT32                  Width);
+#endif
 
 
 /*
  * Miscellaneous
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadable
 BOOLEAN
 AcpiOsReadable (
     void                    *Pointer,
     ACPI_SIZE               Length);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWritable
 BOOLEAN
 AcpiOsWritable (
     void                    *Pointer,
     ACPI_SIZE               Length);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTimer
 UINT64
 AcpiOsGetTimer (
     void);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsSignal
 ACPI_STATUS
 AcpiOsSignal (
     UINT32                  Function,
     void                    *Info);
+#endif
 
 
 /*
  * Debug print routines
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsPrintf
 void ACPI_INTERNAL_VAR_XFACE
 AcpiOsPrintf (
     const char              *Format,
     ...);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsVprintf
 void
 AcpiOsVprintf (
     const char              *Format,
     va_list                 Args);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsRedirectOutput
 void
 AcpiOsRedirectOutput (
     void                    *Destination);
+#endif
 
 
 /*
  * Debug input
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetLine
 ACPI_STATUS
 AcpiOsGetLine (
     char                    *Buffer,
     UINT32                  BufferLength,
     UINT32                  *BytesRead);
+#endif
+
+
+/*
+ * Obtain ACPI table(s)
+ */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTableByName
+ACPI_STATUS
+AcpiOsGetTableByName (
+    char                    *Signature,
+    UINT32                  Instance,
+    ACPI_TABLE_HEADER       **Table,
+    ACPI_PHYSICAL_ADDRESS   *Address);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTableByIndex
+ACPI_STATUS
+AcpiOsGetTableByIndex (
+    UINT32                  Index,
+    ACPI_TABLE_HEADER       **Table,
+    UINT32                  *Instance,
+    ACPI_PHYSICAL_ADDRESS   *Address);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTableByAddress
+ACPI_STATUS
+AcpiOsGetTableByAddress (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    ACPI_TABLE_HEADER       **Table);
+#endif
 
 
 /*
  * Directory manipulation
  */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsOpenDirectory
 void *
 AcpiOsOpenDirectory (
     char                    *Pathname,
     char                    *WildcardSpec,
     char                    RequestedFileType);
+#endif
 
 /* RequesteFileType values */
 
@@ -404,13 +539,75 @@ AcpiOsOpenDirectory (
 #define REQUEST_DIR_ONLY                    1
 
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetNextFilename
 char *
 AcpiOsGetNextFilename (
     void                    *DirHandle);
+#endif
 
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCloseDirectory
 void
 AcpiOsCloseDirectory (
     void                    *DirHandle);
+#endif
+
+
+/*
+ * File I/O and related support
+ */
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsOpenFile
+ACPI_FILE
+AcpiOsOpenFile (
+    const char              *Path,
+    UINT8                   Modes);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCloseFile
+void
+AcpiOsCloseFile (
+    ACPI_FILE               File);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadFile
+int
+AcpiOsReadFile (
+    ACPI_FILE               File,
+    void                    *Buffer,
+    ACPI_SIZE               Size,
+    ACPI_SIZE               Count);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWriteFile
+int
+AcpiOsWriteFile (
+    ACPI_FILE               File,
+    void                    *Buffer,
+    ACPI_SIZE               Size,
+    ACPI_SIZE               Count);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetFileOffset
+long
+AcpiOsGetFileOffset (
+    ACPI_FILE               File);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsSetFileOffset
+ACPI_STATUS
+AcpiOsSetFileOffset (
+    ACPI_FILE               File,
+    long                    Offset,
+    UINT8                   From);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsTracePoint
+void
+AcpiOsTracePoint (
+    ACPI_TRACE_EVENT_TYPE   Type,
+    BOOLEAN                 Begin,
+    UINT8                   *Aml,
+    char                    *Pathname);
+#endif
 
 
 #endif /* __ACPIOSXF_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/acpixf.h b/usr/src/uts/intel/sys/acpi/acpixf.h
index 7478c78940..10eeb11041 100644
--- a/usr/src/uts/intel/sys/acpi/acpixf.h
+++ b/usr/src/uts/intel/sys/acpi/acpixf.h
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Name: acpixf.h - External interfaces to the ACPI subsystem
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,59 +41,283 @@
  * POSSIBILITY OF SUCH DAMAGES.
  */
 
-
 #ifndef __ACXFACE_H__
 #define __ACXFACE_H__
 
 /* Current ACPICA subsystem version in YYYYMMDD format */
 
-#define ACPI_CA_VERSION                 0x20120420
+#define ACPI_CA_VERSION                 0x20160527
 
 #include "acconfig.h"
 #include "actypes.h"
 #include "actbl.h"
+#include "acbuffer.h"
+
+
+/*****************************************************************************
+ *
+ * Macros used for ACPICA globals and configuration
+ *
+ ****************************************************************************/
+
+/*
+ * Ensure that global variables are defined and initialized only once.
+ *
+ * The use of these macros allows for a single list of globals (here)
+ * in order to simplify maintenance of the code.
+ */
+#ifdef DEFINE_ACPI_GLOBALS
+#define ACPI_GLOBAL(type,name) \
+    extern type name; \
+    type name
+
+#define ACPI_INIT_GLOBAL(type,name,value) \
+    type name=value
+
+#else
+#ifndef ACPI_GLOBAL
+#define ACPI_GLOBAL(type,name) \
+    extern type name
+#endif
+
+#ifndef ACPI_INIT_GLOBAL
+#define ACPI_INIT_GLOBAL(type,name,value) \
+    extern type name
+#endif
+#endif
+
+/*
+ * These macros configure the various ACPICA interfaces. They are
+ * useful for generating stub inline functions for features that are
+ * configured out of the current kernel or ACPICA application.
+ */
+#ifndef ACPI_EXTERNAL_RETURN_STATUS
+#define ACPI_EXTERNAL_RETURN_STATUS(Prototype) \
+    Prototype;
+#endif
+
+#ifndef ACPI_EXTERNAL_RETURN_OK
+#define ACPI_EXTERNAL_RETURN_OK(Prototype) \
+    Prototype;
+#endif
+
+#ifndef ACPI_EXTERNAL_RETURN_VOID
+#define ACPI_EXTERNAL_RETURN_VOID(Prototype) \
+    Prototype;
+#endif
+
+#ifndef ACPI_EXTERNAL_RETURN_UINT32
+#define ACPI_EXTERNAL_RETURN_UINT32(Prototype) \
+    Prototype;
+#endif
+
+#ifndef ACPI_EXTERNAL_RETURN_PTR
+#define ACPI_EXTERNAL_RETURN_PTR(Prototype) \
+    Prototype;
+#endif
+
+
+/*****************************************************************************
+ *
+ * Public globals and runtime configuration options
+ *
+ ****************************************************************************/
 
 /*
- * Globals that are publically available
+ * Enable "slack mode" of the AML interpreter?  Default is FALSE, and the
+ * interpreter strictly follows the ACPI specification. Setting to TRUE
+ * allows the interpreter to ignore certain errors and/or bad AML constructs.
+ *
+ * Currently, these features are enabled by this flag:
+ *
+ * 1) Allow "implicit return" of last value in a control method
+ * 2) Allow access beyond the end of an operation region
+ * 3) Allow access to uninitialized locals/args (auto-init to integer 0)
+ * 4) Allow ANY object type to be a source operand for the Store() operator
+ * 5) Allow unresolved references (invalid target name) in package objects
+ * 6) Enable warning messages for behavior that is not ACPI spec compliant
  */
-extern UINT32               AcpiCurrentGpeCount;
-extern ACPI_TABLE_FADT      AcpiGbl_FADT;
-extern BOOLEAN              AcpiGbl_SystemAwakeAndRunning;
-extern BOOLEAN              AcpiGbl_ReducedHardware;        /* ACPI 5.0 */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_EnableInterpreterSlack, FALSE);
 
-/* Runtime configuration of debug print levels */
+/*
+ * Automatically serialize all methods that create named objects? Default
+ * is TRUE, meaning that all NonSerialized methods are scanned once at
+ * table load time to determine those that create named objects. Methods
+ * that create named objects are marked Serialized in order to prevent
+ * possible run-time problems if they are entered by more than one thread.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_AutoSerializeMethods, TRUE);
 
-extern UINT32               AcpiDbgLevel;
-extern UINT32               AcpiDbgLayer;
+/*
+ * Create the predefined _OSI method in the namespace? Default is TRUE
+ * because ACPICA is fully compatible with other ACPI implementations.
+ * Changing this will revert ACPICA (and machine ASL) to pre-OSI behavior.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_CreateOsiMethod, TRUE);
 
-/* ACPICA runtime options */
+/*
+ * Optionally use default values for the ACPI register widths. Set this to
+ * TRUE to use the defaults, if an FADT contains incorrect widths/lengths.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_UseDefaultRegisterWidths, TRUE);
 
-extern UINT8                AcpiGbl_EnableInterpreterSlack;
-extern UINT8                AcpiGbl_AllMethodsSerialized;
-extern UINT8                AcpiGbl_CreateOsiMethod;
-extern UINT8                AcpiGbl_UseDefaultRegisterWidths;
-extern ACPI_NAME            AcpiGbl_TraceMethodName;
-extern UINT32               AcpiGbl_TraceFlags;
-extern UINT8                AcpiGbl_EnableAmlDebugObject;
-extern UINT8                AcpiGbl_CopyDsdtLocally;
-extern UINT8                AcpiGbl_TruncateIoAddresses;
-extern UINT8                AcpiGbl_DisableAutoRepair;
+/*
+ * Whether or not to verify the table checksum before installation. Set
+ * this to TRUE to verify the table checksum before install it to the table
+ * manager. Note that enabling this option causes errors to happen in some
+ * OSPMs during early initialization stages. Default behavior is to do such
+ * verification.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_VerifyTableChecksum, TRUE);
+
+/*
+ * Optionally enable output from the AML Debug Object.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_EnableAmlDebugObject, FALSE);
 
+/*
+ * Optionally copy the entire DSDT to local memory (instead of simply
+ * mapping it.) There are some BIOSs that corrupt or replace the original
+ * DSDT, creating the need for this option. Default is FALSE, do not copy
+ * the DSDT.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_CopyDsdtLocally, FALSE);
+
+/*
+ * Optionally ignore an XSDT if present and use the RSDT instead.
+ * Although the ACPI specification requires that an XSDT be used instead
+ * of the RSDT, the XSDT has been found to be corrupt or ill-formed on
+ * some machines. Default behavior is to use the XSDT if present.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_DoNotUseXsdt, FALSE);
+
+/*
+ * Optionally support group module level code.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_GroupModuleLevelCode, FALSE);
+
+/*
+ * Optionally use 32-bit FADT addresses if and when there is a conflict
+ * (address mismatch) between the 32-bit and 64-bit versions of the
+ * address. Although ACPICA adheres to the ACPI specification which
+ * requires the use of the corresponding 64-bit address if it is non-zero,
+ * some machines have been found to have a corrupted non-zero 64-bit
+ * address. Default is FALSE, do not favor the 32-bit addresses.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_Use32BitFadtAddresses, FALSE);
 
 /*
- * Hardware-reduced prototypes. All interfaces that use these macros will
- * be configured out of the ACPICA build if the ACPI_REDUCED_HARDWARE flag
+ * Optionally use 32-bit FACS table addresses.
+ * It is reported that some platforms fail to resume from system suspending
+ * if 64-bit FACS table address is selected:
+ * https://bugzilla.kernel.org/show_bug.cgi?id=74021
+ * Default is TRUE, favor the 32-bit addresses.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_Use32BitFacsAddresses, TRUE);
+
+/*
+ * Optionally truncate I/O addresses to 16 bits. Provides compatibility
+ * with other ACPI implementations. NOTE: During ACPICA initialization,
+ * this value is set to TRUE if any Windows OSI strings have been
+ * requested by the BIOS.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_TruncateIoAddresses, FALSE);
+
+/*
+ * Disable runtime checking and repair of values returned by control methods.
+ * Use only if the repair is causing a problem on a particular machine.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_DisableAutoRepair, FALSE);
+
+/*
+ * Optionally do not install any SSDTs from the RSDT/XSDT during initialization.
+ * This can be useful for debugging ACPI problems on some machines.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_DisableSsdtTableInstall, FALSE);
+
+/*
+ * Optionally enable runtime namespace override.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_RuntimeNamespaceOverride, TRUE);
+
+/*
+ * We keep track of the latest version of Windows that has been requested by
+ * the BIOS. ACPI 5.0.
+ */
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_OsiData, 0);
+
+/*
+ * ACPI 5.0 introduces the concept of a "reduced hardware platform", meaning
+ * that the ACPI hardware is no longer required. A flag in the FADT indicates
+ * a reduced HW machine, and that flag is duplicated here for convenience.
+ */
+ACPI_INIT_GLOBAL (BOOLEAN,          AcpiGbl_ReducedHardware, FALSE);
+
+/*
+ * This mechanism is used to trace a specified AML method. The method is
+ * traced each time it is executed.
+ */
+ACPI_INIT_GLOBAL (UINT32,           AcpiGbl_TraceFlags, 0);
+ACPI_INIT_GLOBAL (const char *,     AcpiGbl_TraceMethodName, NULL);
+ACPI_INIT_GLOBAL (UINT32,           AcpiGbl_TraceDbgLevel, ACPI_TRACE_LEVEL_DEFAULT);
+ACPI_INIT_GLOBAL (UINT32,           AcpiGbl_TraceDbgLayer, ACPI_TRACE_LAYER_DEFAULT);
+
+/*
+ * Runtime configuration of debug output control masks. We want the debug
+ * switches statically initialized so they are already set when the debugger
+ * is entered.
+ */
+#ifdef ACPI_DEBUG_OUTPUT
+ACPI_INIT_GLOBAL (UINT32,           AcpiDbgLevel, ACPI_DEBUG_DEFAULT);
+#else
+ACPI_INIT_GLOBAL (UINT32,           AcpiDbgLevel, ACPI_NORMAL_DEFAULT);
+#endif
+ACPI_INIT_GLOBAL (UINT32,           AcpiDbgLayer, ACPI_COMPONENT_DEFAULT);
+
+/* Optionally enable timer output with Debug Object output */
+
+ACPI_INIT_GLOBAL (UINT8,            AcpiGbl_DisplayDebugTimer, FALSE);
+
+/*
+ * Other miscellaneous globals
+ */
+ACPI_GLOBAL (ACPI_TABLE_FADT,       AcpiGbl_FADT);
+ACPI_GLOBAL (UINT32,                AcpiCurrentGpeCount);
+ACPI_GLOBAL (BOOLEAN,               AcpiGbl_SystemAwakeAndRunning);
+
+
+/*****************************************************************************
+ *
+ * ACPICA public interface configuration.
+ *
+ * Interfaces that are configured out of the ACPICA build are replaced
+ * by inlined stubs by default.
+ *
+ ****************************************************************************/
+
+/*
+ * Hardware-reduced prototypes (default: Not hardware reduced).
+ *
+ * All ACPICA hardware-related interfaces that use these macros will be
+ * configured out of the ACPICA build if the ACPI_REDUCED_HARDWARE flag
  * is set to TRUE.
+ *
+ * Note: This static build option for reduced hardware is intended to
+ * reduce ACPICA code size if desired or necessary. However, even if this
+ * option is not specified, the runtime behavior of ACPICA is dependent
+ * on the actual FADT reduced hardware flag (HW_REDUCED_ACPI). If set,
+ * the flag will enable similar behavior -- ACPICA will not attempt
+ * to access any ACPI-relate hardware (SCI, GPEs, Fixed Events, etc.)
  */
 #if (!ACPI_REDUCED_HARDWARE)
 #define ACPI_HW_DEPENDENT_RETURN_STATUS(Prototype) \
-    Prototype;
+    ACPI_EXTERNAL_RETURN_STATUS(Prototype)
 
 #define ACPI_HW_DEPENDENT_RETURN_OK(Prototype) \
-    Prototype;
+    ACPI_EXTERNAL_RETURN_OK(Prototype)
 
 #define ACPI_HW_DEPENDENT_RETURN_VOID(Prototype) \
-    Prototype;
+    ACPI_EXTERNAL_RETURN_VOID(Prototype)
 
 #else
 #define ACPI_HW_DEPENDENT_RETURN_STATUS(Prototype) \
@@ -104,35 +327,124 @@ extern UINT8                AcpiGbl_DisableAutoRepair;
     static ACPI_INLINE Prototype {return(AE_OK);}
 
 #define ACPI_HW_DEPENDENT_RETURN_VOID(Prototype) \
-    static ACPI_INLINE Prototype {}
+    static ACPI_INLINE Prototype {return;}
 
 #endif /* !ACPI_REDUCED_HARDWARE */
 
 
+/*
+ * Error message prototypes (default: error messages enabled).
+ *
+ * All interfaces related to error and warning messages
+ * will be configured out of the ACPICA build if the
+ * ACPI_NO_ERROR_MESSAGE flag is defined.
+ */
+#ifndef ACPI_NO_ERROR_MESSAGES
+#define ACPI_MSG_DEPENDENT_RETURN_VOID(Prototype) \
+    Prototype;
+
+#else
+#define ACPI_MSG_DEPENDENT_RETURN_VOID(Prototype) \
+    static ACPI_INLINE Prototype {return;}
+
+#endif /* ACPI_NO_ERROR_MESSAGES */
+
+
+/*
+ * Debugging output prototypes (default: no debug output).
+ *
+ * All interfaces related to debug output messages
+ * will be configured out of the ACPICA build unless the
+ * ACPI_DEBUG_OUTPUT flag is defined.
+ */
+#ifdef ACPI_DEBUG_OUTPUT
+#define ACPI_DBG_DEPENDENT_RETURN_VOID(Prototype) \
+    Prototype;
+
+#else
+#define ACPI_DBG_DEPENDENT_RETURN_VOID(Prototype) \
+    static ACPI_INLINE Prototype {return;}
+
+#endif /* ACPI_DEBUG_OUTPUT */
+
+
+/*
+ * Application prototypes
+ *
+ * All interfaces used by application will be configured
+ * out of the ACPICA build unless the ACPI_APPLICATION
+ * flag is defined.
+ */
+#ifdef ACPI_APPLICATION
+#define ACPI_APP_DEPENDENT_RETURN_VOID(Prototype) \
+    Prototype;
+
+#else
+#define ACPI_APP_DEPENDENT_RETURN_VOID(Prototype) \
+    static ACPI_INLINE Prototype {return;}
+
+#endif /* ACPI_APPLICATION */
+
+
+/*
+ * Debugger prototypes
+ *
+ * All interfaces used by debugger will be configured
+ * out of the ACPICA build unless the ACPI_DEBUGGER
+ * flag is defined.
+ */
+#ifdef ACPI_DEBUGGER
+#define ACPI_DBR_DEPENDENT_RETURN_OK(Prototype) \
+    ACPI_EXTERNAL_RETURN_OK(Prototype)
+
+#define ACPI_DBR_DEPENDENT_RETURN_VOID(Prototype) \
+    ACPI_EXTERNAL_RETURN_VOID(Prototype)
+
+#else
+#define ACPI_DBR_DEPENDENT_RETURN_OK(Prototype) \
+    static ACPI_INLINE Prototype {return(AE_OK);}
+
+#define ACPI_DBR_DEPENDENT_RETURN_VOID(Prototype) \
+    static ACPI_INLINE Prototype {return;}
+
+#endif /* ACPI_DEBUGGER */
+
+
+/*****************************************************************************
+ *
+ * ACPICA public interface prototypes
+ *
+ ****************************************************************************/
+
 /*
  * Initialization
  */
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInitializeTables (
     ACPI_TABLE_DESC         *InitialStorage,
     UINT32                  InitialTableCount,
-    BOOLEAN                 AllowResize);
+    BOOLEAN                 AllowResize))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInitializeSubsystem (
-    void);
+    void))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiEnableSubsystem (
-    UINT32                  Flags);
+    UINT32                  Flags))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInitializeObjects (
-    UINT32                  Flags);
+    UINT32                  Flags))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiTerminate (
-    void);
+    void))
 
 
 /*
@@ -148,209 +460,268 @@ ACPI_STATUS
 AcpiDisable (
     void))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiSubsystemStatus (
-    void);
+    void))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetSystemInfo (
-    ACPI_BUFFER             *RetBuffer);
+    ACPI_BUFFER             *RetBuffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetStatistics (
-    ACPI_STATISTICS         *Stats);
+    ACPI_STATISTICS         *Stats))
 
+ACPI_EXTERNAL_RETURN_PTR (
 const char *
 AcpiFormatException (
-    ACPI_STATUS             Exception);
+    ACPI_STATUS             Exception))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiPurgeCachedObjects (
-    void);
+    void))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInstallInterface (
-    ACPI_STRING             InterfaceName);
+    ACPI_STRING             InterfaceName))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiRemoveInterface (
-    ACPI_STRING             InterfaceName);
+    ACPI_STRING             InterfaceName))
+
+ACPI_EXTERNAL_RETURN_STATUS (
+ACPI_STATUS
+AcpiUpdateInterfaces (
+    UINT8                   Action))
 
+ACPI_EXTERNAL_RETURN_UINT32 (
 UINT32
 AcpiCheckAddressRange (
     ACPI_ADR_SPACE_TYPE     SpaceId,
     ACPI_PHYSICAL_ADDRESS   Address,
     ACPI_SIZE               Length,
-    BOOLEAN                 Warn);
+    BOOLEAN                 Warn))
+
+ACPI_EXTERNAL_RETURN_STATUS (
+ACPI_STATUS
+AcpiDecodePldBuffer (
+    UINT8                   *InBuffer,
+    ACPI_SIZE               Length,
+    ACPI_PLD_INFO           **ReturnBuffer))
 
 
 /*
- * ACPI Memory management
+ * ACPI table load/unload interfaces
  */
-void *
-AcpiAllocate (
-    UINT32                  Size);
+ACPI_EXTERNAL_RETURN_STATUS (
+ACPI_STATUS
+AcpiInstallTable (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    BOOLEAN                 Physical))
 
-void *
-AcpiCallocate (
-    UINT32                  Size);
+ACPI_EXTERNAL_RETURN_STATUS (
+ACPI_STATUS
+AcpiLoadTable (
+    ACPI_TABLE_HEADER       *Table))
 
-void
-AcpiFree (
-    void                    *Address);
+ACPI_EXTERNAL_RETURN_STATUS (
+ACPI_STATUS
+AcpiUnloadParentTable (
+    ACPI_HANDLE             Object))
+
+ACPI_EXTERNAL_RETURN_STATUS (
+ACPI_STATUS
+AcpiLoadTables (
+    void))
 
 
 /*
  * ACPI table manipulation interfaces
  */
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiReallocateRootTable (
-    void);
+    void))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiFindRootPointer (
-    ACPI_SIZE               *RsdpAddress);
-
-ACPI_STATUS
-AcpiLoadTables (
-    void);
+    ACPI_PHYSICAL_ADDRESS   *RsdpAddress))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetTableHeader (
     ACPI_STRING             Signature,
     UINT32                  Instance,
-    ACPI_TABLE_HEADER       *OutTableHeader);
+    ACPI_TABLE_HEADER       *OutTableHeader))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetTable (
     ACPI_STRING             Signature,
     UINT32                  Instance,
-    ACPI_TABLE_HEADER       **OutTable);
+    ACPI_TABLE_HEADER       **OutTable))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetTableByIndex (
     UINT32                  TableIndex,
-    ACPI_TABLE_HEADER       **OutTable);
+    ACPI_TABLE_HEADER       **OutTable))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInstallTableHandler (
     ACPI_TABLE_HANDLER      Handler,
-    void                    *Context);
+    void                    *Context))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiRemoveTableHandler (
-    ACPI_TABLE_HANDLER      Handler);
+    ACPI_TABLE_HANDLER      Handler))
 
 
 /*
  * Namespace and name interfaces
  */
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiWalkNamespace (
     ACPI_OBJECT_TYPE        Type,
     ACPI_HANDLE             StartObject,
     UINT32                  MaxDepth,
-    ACPI_WALK_CALLBACK      PreOrderVisit,
-    ACPI_WALK_CALLBACK      PostOrderVisit,
+    ACPI_WALK_CALLBACK      DescendingCallback,
+    ACPI_WALK_CALLBACK      AscendingCallback,
     void                    *Context,
-    void                    **ReturnValue);
+    void                    **ReturnValue))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetDevices (
     char                    *HID,
     ACPI_WALK_CALLBACK      UserFunction,
     void                    *Context,
-    void                    **ReturnValue);
+    void                    **ReturnValue))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetName (
     ACPI_HANDLE             Object,
     UINT32                  NameType,
-    ACPI_BUFFER             *RetPathPtr);
+    ACPI_BUFFER             *RetPathPtr))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetHandle (
     ACPI_HANDLE             Parent,
     ACPI_STRING             Pathname,
-    ACPI_HANDLE             *RetHandle);
+    ACPI_HANDLE             *RetHandle))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiAttachData (
     ACPI_HANDLE             Object,
     ACPI_OBJECT_HANDLER     Handler,
-    void                    *Data);
+    void                    *Data))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiDetachData (
     ACPI_HANDLE             Object,
-    ACPI_OBJECT_HANDLER     Handler);
+    ACPI_OBJECT_HANDLER     Handler))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetData (
     ACPI_HANDLE             Object,
     ACPI_OBJECT_HANDLER     Handler,
-    void                    **Data);
+    void                    **Data))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiDebugTrace (
-    char                    *Name,
+    const char              *Name,
     UINT32                  DebugLevel,
     UINT32                  DebugLayer,
-    UINT32                  Flags);
+    UINT32                  Flags))
 
 
 /*
  * Object manipulation and enumeration
  */
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiEvaluateObject (
     ACPI_HANDLE             Object,
     ACPI_STRING             Pathname,
     ACPI_OBJECT_LIST        *ParameterObjects,
-    ACPI_BUFFER             *ReturnObjectBuffer);
+    ACPI_BUFFER             *ReturnObjectBuffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiEvaluateObjectTyped (
     ACPI_HANDLE             Object,
     ACPI_STRING             Pathname,
     ACPI_OBJECT_LIST        *ExternalParams,
     ACPI_BUFFER             *ReturnBuffer,
-    ACPI_OBJECT_TYPE        ReturnType);
+    ACPI_OBJECT_TYPE        ReturnType))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetObjectInfo (
     ACPI_HANDLE             Object,
-    ACPI_DEVICE_INFO        **ReturnBuffer);
+    ACPI_DEVICE_INFO        **ReturnBuffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInstallMethod (
-    UINT8                   *Buffer);
+    UINT8                   *Buffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetNextObject (
     ACPI_OBJECT_TYPE        Type,
     ACPI_HANDLE             Parent,
     ACPI_HANDLE             Child,
-    ACPI_HANDLE             *OutHandle);
+    ACPI_HANDLE             *OutHandle))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetType (
     ACPI_HANDLE             Object,
-    ACPI_OBJECT_TYPE        *OutType);
+    ACPI_OBJECT_TYPE        *OutType))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetParent (
     ACPI_HANDLE             Object,
-    ACPI_HANDLE             *OutHandle);
+    ACPI_HANDLE             *OutHandle))
 
 
 /*
  * Handler interfaces
  */
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInstallInitializationHandler (
     ACPI_INIT_HANDLER       Handler,
-    UINT32                  Function);
+    UINT32                  Function))
+
+ACPI_HW_DEPENDENT_RETURN_STATUS (
+ACPI_STATUS
+AcpiInstallSciHandler (
+    ACPI_SCI_HANDLER        Address,
+    void                    *Context))
+
+ACPI_HW_DEPENDENT_RETURN_STATUS (
+ACPI_STATUS
+AcpiRemoveSciHandler (
+    ACPI_SCI_HANDLER        Address))
 
 ACPI_HW_DEPENDENT_RETURN_STATUS (
 ACPI_STATUS
@@ -380,6 +751,15 @@ AcpiInstallGpeHandler (
     ACPI_GPE_HANDLER        Address,
     void                    *Context))
 
+ACPI_HW_DEPENDENT_RETURN_STATUS (
+ACPI_STATUS
+AcpiInstallGpeRawHandler (
+    ACPI_HANDLE             GpeDevice,
+    UINT32                  GpeNumber,
+    UINT32                  Type,
+    ACPI_GPE_HANDLER        Address,
+    void                    *Context))
+
 ACPI_HW_DEPENDENT_RETURN_STATUS (
 ACPI_STATUS
 AcpiRemoveGpeHandler (
@@ -387,40 +767,46 @@ AcpiRemoveGpeHandler (
     UINT32                  GpeNumber,
     ACPI_GPE_HANDLER        Address))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInstallNotifyHandler (
     ACPI_HANDLE             Device,
     UINT32                  HandlerType,
     ACPI_NOTIFY_HANDLER     Handler,
-    void                    *Context);
+    void                    *Context))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiRemoveNotifyHandler (
     ACPI_HANDLE             Device,
     UINT32                  HandlerType,
-    ACPI_NOTIFY_HANDLER     Handler);
+    ACPI_NOTIFY_HANDLER     Handler))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInstallAddressSpaceHandler (
     ACPI_HANDLE             Device,
     ACPI_ADR_SPACE_TYPE     SpaceId,
     ACPI_ADR_SPACE_HANDLER  Handler,
     ACPI_ADR_SPACE_SETUP    Setup,
-    void                    *Context);
+    void                    *Context))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiRemoveAddressSpaceHandler (
     ACPI_HANDLE             Device,
     ACPI_ADR_SPACE_TYPE     SpaceId,
-    ACPI_ADR_SPACE_HANDLER  Handler);
+    ACPI_ADR_SPACE_HANDLER  Handler))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInstallExceptionHandler (
-    ACPI_EXCEPTION_HANDLER  Handler);
+    ACPI_EXCEPTION_HANDLER  Handler))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiInstallInterfaceHandler (
-    ACPI_INTERFACE_HANDLER  Handler);
+    ACPI_INTERFACE_HANDLER  Handler))
 
 
 /*
@@ -441,16 +827,18 @@ AcpiReleaseGlobalLock (
 /*
  * Interfaces to AML mutex objects
  */
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiAcquireMutex (
     ACPI_HANDLE             Handle,
     ACPI_STRING             Pathname,
-    UINT16                  Timeout);
+    UINT16                  Timeout))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiReleaseMutex (
     ACPI_HANDLE             Handle,
-    ACPI_STRING             Pathname);
+    ACPI_STRING             Pathname))
 
 
 /*
@@ -519,6 +907,12 @@ AcpiFinishGpe (
     ACPI_HANDLE             GpeDevice,
     UINT32                  GpeNumber))
 
+ACPI_HW_DEPENDENT_RETURN_STATUS (
+ACPI_STATUS
+AcpiMarkGpeForWake (
+    ACPI_HANDLE             GpeDevice,
+    UINT32                  GpeNumber))
+
 ACPI_HW_DEPENDENT_RETURN_STATUS (
 ACPI_STATUS
 AcpiSetupGpeForWake (
@@ -550,6 +944,11 @@ ACPI_STATUS
 AcpiEnableAllRuntimeGpes (
     void))
 
+ACPI_HW_DEPENDENT_RETURN_STATUS (
+ACPI_STATUS
+AcpiEnableAllWakeupGpes (
+    void))
+
 ACPI_HW_DEPENDENT_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetGpeDevice (
@@ -578,73 +977,92 @@ ACPI_STATUS (*ACPI_WALK_RESOURCE_CALLBACK) (
     ACPI_RESOURCE           *Resource,
     void                    *Context);
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetVendorResource (
     ACPI_HANDLE             Device,
     char                    *Name,
     ACPI_VENDOR_UUID        *Uuid,
-    ACPI_BUFFER             *RetBuffer);
+    ACPI_BUFFER             *RetBuffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetCurrentResources (
     ACPI_HANDLE             Device,
-    ACPI_BUFFER             *RetBuffer);
+    ACPI_BUFFER             *RetBuffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetPossibleResources (
     ACPI_HANDLE             Device,
-    ACPI_BUFFER             *RetBuffer);
+    ACPI_BUFFER             *RetBuffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetEventResources (
     ACPI_HANDLE             DeviceHandle,
-    ACPI_BUFFER             *RetBuffer);
+    ACPI_BUFFER             *RetBuffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
+ACPI_STATUS
+AcpiWalkResourceBuffer (
+    ACPI_BUFFER                 *Buffer,
+    ACPI_WALK_RESOURCE_CALLBACK UserFunction,
+    void                        *Context))
+
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiWalkResources (
     ACPI_HANDLE                 Device,
     char                        *Name,
     ACPI_WALK_RESOURCE_CALLBACK UserFunction,
-    void                        *Context);
+    void                        *Context))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiSetCurrentResources (
     ACPI_HANDLE             Device,
-    ACPI_BUFFER             *InBuffer);
+    ACPI_BUFFER             *InBuffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetIrqRoutingTable (
     ACPI_HANDLE             Device,
-    ACPI_BUFFER             *RetBuffer);
+    ACPI_BUFFER             *RetBuffer))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiResourceToAddress64 (
     ACPI_RESOURCE           *Resource,
-    ACPI_RESOURCE_ADDRESS64 *Out);
+    ACPI_RESOURCE_ADDRESS64 *Out))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiBufferToResource (
     UINT8                   *AmlBuffer,
     UINT16                  AmlBufferLength,
-    ACPI_RESOURCE           **ResourcePtr);
+    ACPI_RESOURCE           **ResourcePtr))
 
 
 /*
  * Hardware (ACPI device) interfaces
  */
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiReset (
-    void);
+    void))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiRead (
     UINT64                  *Value,
-    ACPI_GENERIC_ADDRESS    *Reg);
+    ACPI_GENERIC_ADDRESS    *Reg))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiWrite (
     UINT64                  Value,
-    ACPI_GENERIC_ADDRESS    *Reg);
+    ACPI_GENERIC_ADDRESS    *Reg))
 
 ACPI_HW_DEPENDENT_RETURN_STATUS (
 ACPI_STATUS
@@ -662,46 +1080,43 @@ AcpiWriteBitRegister (
 /*
  * Sleep/Wake interfaces
  */
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiGetSleepTypeData (
     UINT8                   SleepState,
     UINT8                   *Slp_TypA,
-    UINT8                   *Slp_TypB);
+    UINT8                   *Slp_TypB))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiEnterSleepStatePrep (
-    UINT8                   SleepState);
+    UINT8                   SleepState))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiEnterSleepState (
-    UINT8                   SleepState,
-    UINT8                   Flags);
+    UINT8                   SleepState))
 
 ACPI_HW_DEPENDENT_RETURN_STATUS (
 ACPI_STATUS
 AcpiEnterSleepStateS4bios (
     void))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiLeaveSleepStatePrep (
-    UINT8                   SleepState,
-    UINT8                   Flags);
+    UINT8                   SleepState))
 
+ACPI_EXTERNAL_RETURN_STATUS (
 ACPI_STATUS
 AcpiLeaveSleepState (
-    UINT8                   SleepState);
+    UINT8                   SleepState))
 
 ACPI_HW_DEPENDENT_RETURN_STATUS (
 ACPI_STATUS
 AcpiSetFirmwareWakingVector (
-    UINT32                  PhysicalAddress))
-
-#if ACPI_MACHINE_WIDTH == 64
-ACPI_HW_DEPENDENT_RETURN_STATUS (
-ACPI_STATUS
-AcpiSetFirmwareWakingVector64 (
-    UINT64                  PhysicalAddress))
-#endif
+    ACPI_PHYSICAL_ADDRESS   PhysicalAddress,
+    ACPI_PHYSICAL_ADDRESS   PhysicalAddress64))
 
 
 /*
@@ -728,41 +1143,65 @@ AcpiGetTimerDuration (
 /*
  * Error/Warning output
  */
+ACPI_MSG_DEPENDENT_RETURN_VOID (
+ACPI_PRINTF_LIKE(3)
 void ACPI_INTERNAL_VAR_XFACE
 AcpiError (
     const char              *ModuleName,
     UINT32                  LineNumber,
     const char              *Format,
-    ...) ACPI_PRINTF_LIKE(3);
+    ...))
 
+ACPI_MSG_DEPENDENT_RETURN_VOID (
+ACPI_PRINTF_LIKE(4)
 void  ACPI_INTERNAL_VAR_XFACE
 AcpiException (
     const char              *ModuleName,
     UINT32                  LineNumber,
     ACPI_STATUS             Status,
     const char              *Format,
-    ...) ACPI_PRINTF_LIKE(4);
+    ...))
 
+ACPI_MSG_DEPENDENT_RETURN_VOID (
+ACPI_PRINTF_LIKE(3)
 void ACPI_INTERNAL_VAR_XFACE
 AcpiWarning (
     const char              *ModuleName,
     UINT32                  LineNumber,
     const char              *Format,
-    ...) ACPI_PRINTF_LIKE(3);
+    ...))
 
+ACPI_MSG_DEPENDENT_RETURN_VOID (
+ACPI_PRINTF_LIKE(1)
 void ACPI_INTERNAL_VAR_XFACE
 AcpiInfo (
+    const char              *Format,
+    ...))
+
+ACPI_MSG_DEPENDENT_RETURN_VOID (
+ACPI_PRINTF_LIKE(3)
+void ACPI_INTERNAL_VAR_XFACE
+AcpiBiosError (
+    const char              *ModuleName,
+    UINT32                  LineNumber,
+    const char              *Format,
+    ...))
+
+ACPI_MSG_DEPENDENT_RETURN_VOID (
+ACPI_PRINTF_LIKE(3)
+void ACPI_INTERNAL_VAR_XFACE
+AcpiBiosWarning (
     const char              *ModuleName,
     UINT32                  LineNumber,
     const char              *Format,
-    ...) ACPI_PRINTF_LIKE(3);
+    ...))
 
 
 /*
  * Debug output
  */
-#ifdef ACPI_DEBUG_OUTPUT
-
+ACPI_DBG_DEPENDENT_RETURN_VOID (
+ACPI_PRINTF_LIKE(6)
 void ACPI_INTERNAL_VAR_XFACE
 AcpiDebugPrint (
     UINT32                  RequestedDebugLevel,
@@ -771,8 +1210,10 @@ AcpiDebugPrint (
     const char              *ModuleName,
     UINT32                  ComponentId,
     const char              *Format,
-    ...) ACPI_PRINTF_LIKE(6);
+    ...))
 
+ACPI_DBG_DEPENDENT_RETURN_VOID (
+ACPI_PRINTF_LIKE(6)
 void ACPI_INTERNAL_VAR_XFACE
 AcpiDebugPrintRaw (
     UINT32                  RequestedDebugLevel,
@@ -781,7 +1222,33 @@ AcpiDebugPrintRaw (
     const char              *ModuleName,
     UINT32                  ComponentId,
     const char              *Format,
-    ...) ACPI_PRINTF_LIKE(6);
-#endif
+    ...))
+
+ACPI_DBG_DEPENDENT_RETURN_VOID (
+void
+AcpiTracePoint (
+    ACPI_TRACE_EVENT_TYPE   Type,
+    BOOLEAN                 Begin,
+    UINT8                   *Aml,
+    char                    *Pathname))
+
+ACPI_APP_DEPENDENT_RETURN_VOID (
+ACPI_PRINTF_LIKE(1)
+void ACPI_INTERNAL_VAR_XFACE
+AcpiLogError (
+    const char              *Format,
+    ...))
+
+ACPI_STATUS
+AcpiInitializeDebugger (
+    void);
+
+void
+AcpiTerminateDebugger (
+    void);
+
+void
+AcpiSetDebuggerThreadId (
+    ACPI_THREAD_ID          ThreadId);
 
 #endif /* __ACXFACE_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/acpredef.h b/usr/src/uts/intel/sys/acpi/acpredef.h
index c17a6d9145..ab61c53d7b 100644
--- a/usr/src/uts/intel/sys/acpi/acpredef.h
+++ b/usr/src/uts/intel/sys/acpi/acpredef.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,7 +49,7 @@
  *
  * Return Package types
  *
- * 1) PTYPE1 packages do not contain sub-packages.
+ * 1) PTYPE1 packages do not contain subpackages.
  *
  * ACPI_PTYPE1_FIXED: Fixed-length length, 1 or 2 object types:
  *      object type
@@ -57,24 +57,26 @@
  *      object type
  *      count
  *
- * ACPI_PTYPE1_VAR: Variable-length length:
+ * ACPI_PTYPE1_VAR: Variable-length length. Zero-length package is allowed:
  *      object type (Int/Buf/Ref)
  *
  * ACPI_PTYPE1_OPTION: Package has some required and some optional elements
  *      (Used for _PRW)
  *
  *
- * 2) PTYPE2 packages contain a Variable-length number of sub-packages. Each
- *    of the different types describe the contents of each of the sub-packages.
+ * 2) PTYPE2 packages contain a Variable-length number of subpackages. Each
+ *    of the different types describe the contents of each of the subpackages.
  *
- * ACPI_PTYPE2: Each subpackage contains 1 or 2 object types:
+ * ACPI_PTYPE2: Each subpackage contains 1 or 2 object types. Zero-length
+ *      parent package is allowed:
  *      object type
  *      count
  *      object type
  *      count
  *      (Used for _ALR,_MLS,_PSS,_TRT,_TSS)
  *
- * ACPI_PTYPE2_COUNT: Each subpackage has a count as first element:
+ * ACPI_PTYPE2_COUNT: Each subpackage has a count as first element.
+ *      Zero-length parent package is allowed:
  *      object type
  *      (Used for _CSD,_PSD,_TSD)
  *
@@ -85,23 +87,35 @@
  *      count
  *      (Used for _CST)
  *
- * ACPI_PTYPE2_FIXED: Each subpackage is of Fixed-length
+ * ACPI_PTYPE2_FIXED: Each subpackage is of Fixed-length. Zero-length
+ *      parent package is allowed.
  *      (Used for _PRT)
  *
- * ACPI_PTYPE2_MIN: Each subpackage has a Variable-length but minimum length
+ * ACPI_PTYPE2_MIN: Each subpackage has a Variable-length but minimum length.
+ *      Zero-length parent package is allowed:
  *      (Used for _HPX)
  *
  * ACPI_PTYPE2_REV_FIXED: Revision at start, each subpackage is Fixed-length
  *      (Used for _ART, _FPS)
  *
  * ACPI_PTYPE2_FIX_VAR: Each subpackage consists of some fixed-length elements
- *      followed by an optional element
+ *      followed by an optional element. Zero-length parent package is allowed.
  *      object type
  *      count
  *      object type
  *      count = 0 (optional)
  *      (Used for _DLM)
  *
+ * ACPI_PTYPE2_VAR_VAR: Variable number of subpackages, each of either a
+ *      constant or variable length. The subpackages are preceded by a
+ *      constant number of objects.
+ *      (Used for _LPI, _RDI)
+ *
+ * ACPI_PTYPE2_UUID_PAIR: Each subpackage is preceded by a UUID Buffer. The UUID
+ *      defines the format of the package. Zero-length parent package is
+ *      allowed.
+ *      (Used for _DSD)
+ *
  *****************************************************************************/
 
 enum AcpiReturnPackageTypes
@@ -115,22 +129,67 @@ enum AcpiReturnPackageTypes
     ACPI_PTYPE2_FIXED       = 7,
     ACPI_PTYPE2_MIN         = 8,
     ACPI_PTYPE2_REV_FIXED   = 9,
-    ACPI_PTYPE2_FIX_VAR     = 10
+    ACPI_PTYPE2_FIX_VAR     = 10,
+    ACPI_PTYPE2_VAR_VAR     = 11,
+    ACPI_PTYPE2_UUID_PAIR   = 12,
+    ACPI_PTYPE_CUSTOM       = 13
 };
 
 
+/* Support macros for users of the predefined info table */
+
+#define METHOD_PREDEF_ARGS_MAX          4
+#define METHOD_ARG_BIT_WIDTH            3
+#define METHOD_ARG_MASK                 0x0007
+#define ARG_COUNT_IS_MINIMUM            0x8000
+#define METHOD_MAX_ARG_TYPE             ACPI_TYPE_PACKAGE
+
+#define METHOD_GET_ARG_COUNT(ArgList)   ((ArgList) & METHOD_ARG_MASK)
+#define METHOD_GET_NEXT_TYPE(ArgList)   (((ArgList) >>= METHOD_ARG_BIT_WIDTH) & METHOD_ARG_MASK)
+
+/* Macros used to build the predefined info table */
+
+#define METHOD_0ARGS                    0
+#define METHOD_1ARGS(a1)                (1 | (a1 << 3))
+#define METHOD_2ARGS(a1,a2)             (2 | (a1 << 3) | (a2 << 6))
+#define METHOD_3ARGS(a1,a2,a3)          (3 | (a1 << 3) | (a2 << 6) | (a3 << 9))
+#define METHOD_4ARGS(a1,a2,a3,a4)       (4 | (a1 << 3) | (a2 << 6) | (a3 << 9) | (a4 << 12))
+
+#define METHOD_RETURNS(type)            (type)
+#define METHOD_NO_RETURN_VALUE          0
+
+#define PACKAGE_INFO(a,b,c,d,e,f)       {{{(a),(b),(c),(d)}, ((((UINT16)(f)) << 8) | (e)), 0}}
+
+
+/* Support macros for the resource descriptor info table */
+
+#define WIDTH_1                         0x0001
+#define WIDTH_2                         0x0002
+#define WIDTH_3                         0x0004
+#define WIDTH_8                         0x0008
+#define WIDTH_16                        0x0010
+#define WIDTH_32                        0x0020
+#define WIDTH_64                        0x0040
+#define VARIABLE_DATA                   0x0080
+#define NUM_RESOURCE_WIDTHS             8
+
+#define WIDTH_ADDRESS                   WIDTH_16 | WIDTH_32 | WIDTH_64
+
+
 #ifdef ACPI_CREATE_PREDEFINED_TABLE
-/*
+/******************************************************************************
+ *
  * Predefined method/object information table.
  *
  * These are the names that can actually be evaluated via AcpiEvaluateObject.
  * Not present in this table are the following:
  *
- *      1) Predefined/Reserved names that are never evaluated via
+ *      1) Predefined/Reserved names that are not usually evaluated via
  *         AcpiEvaluateObject:
  *              _Lxx and _Exx GPE methods
  *              _Qxx EC methods
  *              _T_x compiler temporary variables
+ *              _Wxx wake events
  *
  *      2) Predefined names that never actually exist within the AML code:
  *              Predefined resource descriptor field names
@@ -138,13 +197,13 @@ enum AcpiReturnPackageTypes
  *      3) Predefined names that are implemented within ACPICA:
  *              _OSI
  *
- *      4) Some predefined names that are not documented within the ACPI spec.
- *              _WDG, _WED
- *
  * The main entries in the table each contain the following items:
  *
  * Name                 - The ACPI reserved name
- * ParamCount           - Number of arguments to the method
+ * ArgumentList         - Contains (in 16 bits), the number of required
+ *                        arguments to the method (3 bits), and a 3-bit type
+ *                        field for each argument (up to 4 arguments). The
+ *                        METHOD_?ARGS macros generate the correct packed data.
  * ExpectedBtypes       - Allowed type(s) for the return value.
  *                        0 means that no return value is expected.
  *
@@ -154,252 +213,524 @@ enum AcpiReturnPackageTypes
  * overall size of the stored data.
  *
  * Note: The additional braces are intended to promote portability.
- */
-static const ACPI_PREDEFINED_INFO     PredefinedNames[] =
+ *
+ * Note2: Table is used by the kernel-resident subsystem, the iASL compiler,
+ * and the AcpiHelp utility.
+ *
+ * TBD: _PRT - currently ignore reversed entries. Attempt to fix in nsrepair.
+ * Possibly fixing package elements like _BIF, etc.
+ *
+ *****************************************************************************/
+
+const ACPI_PREDEFINED_INFO          AcpiGbl_PredefinedMethods[] =
 {
-    {{"_AC0", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AC1", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AC2", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AC3", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AC4", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AC5", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AC6", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AC7", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AC8", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AC9", 0, ACPI_RTYPE_INTEGER}},
-    {{"_ADR", 0, ACPI_RTYPE_INTEGER}},
-    {{"_AEI", 0, ACPI_RTYPE_BUFFER}},
-    {{"_AL0", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_AL1", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_AL2", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_AL3", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_AL4", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_AL5", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_AL6", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_AL7", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_AL8", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_AL9", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_ALC", 0, ACPI_RTYPE_INTEGER}},
-    {{"_ALI", 0, ACPI_RTYPE_INTEGER}},
-    {{"_ALP", 0, ACPI_RTYPE_INTEGER}},
-    {{"_ALR", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each 2 (Ints) */
-                    {{{ACPI_PTYPE2, ACPI_RTYPE_INTEGER, 2,0}, 0,0}},
-
-    {{"_ALT", 0, ACPI_RTYPE_INTEGER}},
-    {{"_ART", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (1 Int(rev), n Pkg (2 Ref/11 Int) */
-                    {{{ACPI_PTYPE2_REV_FIXED,ACPI_RTYPE_REFERENCE, 2, ACPI_RTYPE_INTEGER}, 11,0}},
-
-    {{"_BBN", 0, ACPI_RTYPE_INTEGER}},
-    {{"_BCL", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Ints) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 0,0}, 0,0}},
-
-    {{"_BCM", 1, 0}},
-    {{"_BCT", 1, ACPI_RTYPE_INTEGER}},
-    {{"_BDN", 0, ACPI_RTYPE_INTEGER}},
-    {{"_BFS", 1, 0}},
-    {{"_BIF", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (9 Int),(4 Str) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 9, ACPI_RTYPE_STRING}, 4,0}},
-
-    {{"_BIX", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (16 Int),(4 Str) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 16, ACPI_RTYPE_STRING}, 4,0}},
-
-    {{"_BLT", 3, 0}},
-    {{"_BMA", 1, ACPI_RTYPE_INTEGER}},
-    {{"_BMC", 1, 0}},
-    {{"_BMD", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (5 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 5,0}, 0,0}},
-
-    {{"_BMS", 1, ACPI_RTYPE_INTEGER}},
-    {{"_BQC", 0, ACPI_RTYPE_INTEGER}},
-    {{"_BST", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (4 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4,0}, 0,0}},
-
-    {{"_BTM", 1, ACPI_RTYPE_INTEGER}},
-    {{"_BTP", 1, 0}},
-    {{"_CBA", 0, ACPI_RTYPE_INTEGER}}, /* See PCI firmware spec 3.0 */
-    {{"_CDM", 0, ACPI_RTYPE_INTEGER}},
-    {{"_CID", 0, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING | ACPI_RTYPE_PACKAGE}}, /* Variable-length (Ints/Strs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING, 0,0}, 0,0}},
-
-    {{"_CLS", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (3 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 3,0}, 0,0}},
-
-    {{"_CPC", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Ints/Bufs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER | ACPI_RTYPE_BUFFER, 0,0}, 0,0}},
-
-    {{"_CRS", 0, ACPI_RTYPE_BUFFER}},
-    {{"_CRT", 0, ACPI_RTYPE_INTEGER}},
-    {{"_CSD", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (1 Int(n), n-1 Int) */
-                    {{{ACPI_PTYPE2_COUNT, ACPI_RTYPE_INTEGER, 0,0}, 0,0}},
-
-    {{"_CST", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (1 Int(n), n Pkg (1 Buf/3 Int) */
-                    {{{ACPI_PTYPE2_PKG_COUNT,ACPI_RTYPE_BUFFER, 1, ACPI_RTYPE_INTEGER}, 3,0}},
-
-    {{"_CWS", 1, ACPI_RTYPE_INTEGER}},
-    {{"_DCK", 1, ACPI_RTYPE_INTEGER}},
-    {{"_DCS", 0, ACPI_RTYPE_INTEGER}},
-    {{"_DDC", 1, ACPI_RTYPE_INTEGER | ACPI_RTYPE_BUFFER}},
-    {{"_DDN", 0, ACPI_RTYPE_STRING}},
-    {{"_DEP", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_DGS", 0, ACPI_RTYPE_INTEGER}},
-    {{"_DIS", 0, 0}},
-
-    {{"_DLM", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each (1 Ref, 0/1 Optional Buf/Ref) */
-                    {{{ACPI_PTYPE2_FIX_VAR, ACPI_RTYPE_REFERENCE, 1, ACPI_RTYPE_REFERENCE | ACPI_RTYPE_BUFFER}, 0,0}},
-
-    {{"_DMA", 0, ACPI_RTYPE_BUFFER}},
-    {{"_DOD", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Ints) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 0,0}, 0,0}},
-
-    {{"_DOS", 1, 0}},
-    {{"_DSM", 4, ACPI_RTYPE_ALL}},     /* Must return a type, but it can be of any type */
-    {{"_DSS", 1, 0}},
-    {{"_DSW", 3, 0}},
-    {{"_DTI", 1, 0}},
-    {{"_EC_", 0, ACPI_RTYPE_INTEGER}},
-    {{"_EDL", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs)*/
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_EJ0", 1, 0}},
-    {{"_EJ1", 1, 0}},
-    {{"_EJ2", 1, 0}},
-    {{"_EJ3", 1, 0}},
-    {{"_EJ4", 1, 0}},
-    {{"_EJD", 0, ACPI_RTYPE_STRING}},
-    {{"_ERR", 3, ACPI_RTYPE_INTEGER}}, /* Internal use only, used by ACPICA test suites */
-    {{"_EVT", 1, 0}},
-    {{"_FDE", 0, ACPI_RTYPE_BUFFER}},
-    {{"_FDI", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (16 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 16,0}, 0,0}},
-
-    {{"_FDM", 1, 0}},
-    {{"_FIF", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (4 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4,0}, 0,0}},
-
-    {{"_FIX", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Ints) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 0,0}, 0,0}},
-
-    {{"_FPS", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (1 Int(rev), n Pkg (5 Int) */
-                    {{{ACPI_PTYPE2_REV_FIXED,ACPI_RTYPE_INTEGER, 5, 0}, 0,0}},
-
-    {{"_FSL", 1, 0}},
-    {{"_FST", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (3 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 3,0}, 0,0}},
-
-
-    {{"_GAI", 0, ACPI_RTYPE_INTEGER}},
-    {{"_GCP", 0, ACPI_RTYPE_INTEGER}},
-    {{"_GHL", 0, ACPI_RTYPE_INTEGER}},
-    {{"_GLK", 0, ACPI_RTYPE_INTEGER}},
-    {{"_GPD", 0, ACPI_RTYPE_INTEGER}},
-    {{"_GPE", 0, ACPI_RTYPE_INTEGER}}, /* _GPE method, not _GPE scope */
-    {{"_GRT", 0, ACPI_RTYPE_BUFFER}},
-    {{"_GSB", 0, ACPI_RTYPE_INTEGER}},
-    {{"_GTF", 0, ACPI_RTYPE_BUFFER}},
-    {{"_GTM", 0, ACPI_RTYPE_BUFFER}},
-    {{"_GTS", 1, 0}},
-    {{"_GWS", 1, ACPI_RTYPE_INTEGER}},
-    {{"_HID", 0, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING}},
-    {{"_HOT", 0, ACPI_RTYPE_INTEGER}},
-    {{"_HPP", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (4 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4,0}, 0,0}},
+    {{"_AC0",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AC1",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AC2",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AC3",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AC4",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AC5",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AC6",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AC7",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AC8",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AC9",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_ADR",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_AEI",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_AL0",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_AL1",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_AL2",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_AL3",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_AL4",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_AL5",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_AL6",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_AL7",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_AL8",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_AL9",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_ALC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_ALI",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_ALP",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_ALR",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each 2 (Ints) */
+                    PACKAGE_INFO (ACPI_PTYPE2, ACPI_RTYPE_INTEGER, 2,0,0,0),
+
+    {{"_ALT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_ART",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (1 Int(rev), n Pkg (2 Ref/11 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE2_REV_FIXED, ACPI_RTYPE_REFERENCE, 2, ACPI_RTYPE_INTEGER, 11,0),
+
+    {{"_BBN",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_BCL",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Ints) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 0,0,0,0),
+
+    {{"_BCM",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_BCT",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_BDN",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_BFS",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_BIF",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (9 Int),(4 Str) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 9, ACPI_RTYPE_STRING, 4,0),
+
+    {{"_BIX",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (16 Int),(4 Str) */
+                    PACKAGE_INFO (ACPI_PTYPE_CUSTOM, ACPI_RTYPE_INTEGER, 16, ACPI_RTYPE_STRING, 4,0),
+
+    {{"_BLT",   METHOD_3ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_BMA",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_BMC",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_BMD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (5 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 5,0,0,0),
+
+    {{"_BMS",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_BQC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_BST",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (4 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4,0,0,0),
+
+    {{"_BTH",   METHOD_1ARGS (ACPI_TYPE_INTEGER),      /* ACPI 6.0 */
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_BTM",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_BTP",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_CBA",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}}, /* See PCI firmware spec 3.0 */
+
+    {{"_CCA",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}}, /* ACPI 5.1 */
+
+    {{"_CDM",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_CID",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING | ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Ints/Strs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING, 0,0,0,0),
+
+    {{"_CLS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (3 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 3,0,0,0),
+
+    {{"_CPC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Ints/Bufs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER | ACPI_RTYPE_BUFFER, 0,0,0,0),
+
+    {{"_CR3",   METHOD_0ARGS,                          /* ACPI 6.0 */
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_CRS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_CRT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_CSD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (1 Int(n), n-1 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE2_COUNT, ACPI_RTYPE_INTEGER, 0,0,0,0),
+
+    {{"_CST",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (1 Int(n), n Pkg (1 Buf/3 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE2_PKG_COUNT,ACPI_RTYPE_BUFFER, 1, ACPI_RTYPE_INTEGER, 3,0),
+
+    {{"_CWS",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_DCK",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_DCS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_DDC",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER | ACPI_RTYPE_BUFFER)}},
+
+    {{"_DDN",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_STRING)}},
+
+    {{"_DEP",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_DGS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_DIS",   METHOD_0ARGS,
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_DLM",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each (1 Ref, 0/1 Optional Buf/Ref) */
+                    PACKAGE_INFO (ACPI_PTYPE2_FIX_VAR, ACPI_RTYPE_REFERENCE, 1, ACPI_RTYPE_REFERENCE | ACPI_RTYPE_BUFFER, 0,0),
+
+    {{"_DMA",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_DOD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Ints) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 0,0,0,0),
+
+    {{"_DOS",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_DSD",   METHOD_0ARGS,                          /* ACPI 6.0 */
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each: 1 Buf, 1 Pkg */
+                    PACKAGE_INFO (ACPI_PTYPE2_UUID_PAIR, ACPI_RTYPE_BUFFER, 1, ACPI_RTYPE_PACKAGE, 1,0),
+
+    {{"_DSM",   METHOD_4ARGS (ACPI_TYPE_BUFFER, ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER, ACPI_TYPE_PACKAGE),
+                METHOD_RETURNS (ACPI_RTYPE_ALL)}}, /* Must return a value, but it can be of any type */
+
+    {{"_DSS",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_DSW",   METHOD_3ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_DTI",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_EC_",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_EDL",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs)*/
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_EJ0",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_EJ1",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_EJ2",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_EJ3",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_EJ4",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_EJD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_STRING)}},
+
+    {{"_ERR",   METHOD_3ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_STRING, ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}}, /* Internal use only, used by ACPICA test suites */
+
+    {{"_EVT",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_FDE",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_FDI",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (16 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 16,0,0,0),
+
+    {{"_FDM",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_FIF",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (4 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4,0,0,0),
+
+    {{"_FIT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},  /* ACPI 6.0 */
+
+    {{"_FIX",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Ints) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 0,0,0,0),
+
+    {{"_FPS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (1 Int(rev), n Pkg (5 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE2_REV_FIXED,ACPI_RTYPE_INTEGER, 5, 0,0,0),
+
+    {{"_FSL",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_FST",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (3 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 3,0,0,0),
+
+    {{"_GAI",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_GCP",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_GHL",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_GLK",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_GPD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_GPE",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}}, /* _GPE method, not _GPE scope */
+
+    {{"_GRT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_GSB",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_GTF",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_GTM",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_GTS",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_GWS",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_HID",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING)}},
+
+    {{"_HOT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_HPP",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (4 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4,0,0,0),
 
     /*
-     * For _HPX, a single package is returned, containing a Variable-length number
-     * of sub-packages. Each sub-package contains a PCI record setting.
+     * For _HPX, a single package is returned, containing a variable-length number
+     * of subpackages. Each subpackage contains a PCI record setting.
      * There are several different type of record settings, of different
      * lengths, but all elements of all settings are Integers.
      */
-    {{"_HPX", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each (var Ints) */
-                    {{{ACPI_PTYPE2_MIN, ACPI_RTYPE_INTEGER, 5,0}, 0,0}},
-
-    {{"_HRV", 0, ACPI_RTYPE_INTEGER}},
-    {{"_IFT", 0, ACPI_RTYPE_INTEGER}}, /* See IPMI spec */
-    {{"_INI", 0, 0}},
-    {{"_IRC", 0, 0}},
-    {{"_LCK", 1, 0}},
-    {{"_LID", 0, ACPI_RTYPE_INTEGER}},
-    {{"_MAT", 0, ACPI_RTYPE_BUFFER}},
-    {{"_MBM", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (8 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 8,0}, 0,0}},
-
-    {{"_MLS", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each (2 Str) */
-                    {{{ACPI_PTYPE2, ACPI_RTYPE_STRING, 2,0}, 0,0}},
-
-    {{"_MSG", 1, 0}},
-    {{"_MSM", 4, ACPI_RTYPE_INTEGER}},
-    {{"_NTT", 0, ACPI_RTYPE_INTEGER}},
-    {{"_OFF", 0, 0}},
-    {{"_ON_", 0, 0}},
-    {{"_OS_", 0, ACPI_RTYPE_STRING}},
-    {{"_OSC", 4, ACPI_RTYPE_BUFFER}},
-    {{"_OST", 3, 0}},
-    {{"_PAI", 1, ACPI_RTYPE_INTEGER}},
-    {{"_PCL", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_PCT", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (2 Buf) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_BUFFER, 2,0}, 0,0}},
-
-    {{"_PDC", 1, 0}},
-    {{"_PDL", 0, ACPI_RTYPE_INTEGER}},
-    {{"_PIC", 1, 0}},
-    {{"_PIF", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (3 Int),(3 Str) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 3, ACPI_RTYPE_STRING}, 3,0}},
-
-    {{"_PLD", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Bufs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_BUFFER, 0,0}, 0,0}},
-
-    {{"_PMC", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (11 Int),(3 Str) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 11, ACPI_RTYPE_STRING}, 3,0}},
-
-    {{"_PMD", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_PMM", 0, ACPI_RTYPE_INTEGER}},
-    {{"_PPC", 0, ACPI_RTYPE_INTEGER}},
-    {{"_PPE", 0, ACPI_RTYPE_INTEGER}}, /* See dig64 spec */
-    {{"_PR0", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_PR1", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_PR2", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_PR3", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_PRE", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_PRL", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_PRS", 0, ACPI_RTYPE_BUFFER}},
+    {{"_HPX",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each (var Ints) */
+                    PACKAGE_INFO (ACPI_PTYPE2_MIN, ACPI_RTYPE_INTEGER, 5,0,0,0),
+
+    {{"_HRV",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_IFT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}}, /* See IPMI spec */
+
+    {{"_INI",   METHOD_0ARGS,
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_IRC",   METHOD_0ARGS,
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_LCK",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_LID",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_LPD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (1 Int(rev), n Pkg (2 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE2_REV_FIXED, ACPI_RTYPE_INTEGER, 2,0,0,0),
+
+    {{"_LPI",   METHOD_0ARGS,                          /* ACPI 6.0 */
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (3 Int, n Pkg (10 Int/Buf) */
+                    PACKAGE_INFO (ACPI_PTYPE2_VAR_VAR, ACPI_RTYPE_INTEGER, 3,
+                    ACPI_RTYPE_INTEGER | ACPI_RTYPE_BUFFER | ACPI_RTYPE_STRING, 10,0),
+
+    {{"_MAT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_MBM",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (8 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 8,0,0,0),
+
+    {{"_MLS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each (1 Str/1 Buf) */
+                    PACKAGE_INFO (ACPI_PTYPE2, ACPI_RTYPE_STRING, 1, ACPI_RTYPE_BUFFER, 1,0),
+
+    {{"_MSG",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_MSM",   METHOD_4ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_MTL",   METHOD_0ARGS,                          /* ACPI 6.0 */
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_NTT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_OFF",   METHOD_0ARGS,
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_ON_",   METHOD_0ARGS,
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_OS_",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_STRING)}},
+
+    {{"_OSC",   METHOD_4ARGS (ACPI_TYPE_BUFFER, ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER, ACPI_TYPE_BUFFER),
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_OST",   METHOD_3ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER, ACPI_TYPE_BUFFER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PAI",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_PCL",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_PCT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (2 Buf) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_BUFFER, 2,0,0,0),
+
+    {{"_PDC",   METHOD_1ARGS (ACPI_TYPE_BUFFER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PDL",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_PIC",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PIF",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (3 Int),(3 Str) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 3, ACPI_RTYPE_STRING, 3,0),
+
+    {{"_PLD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Bufs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_BUFFER, 0,0,0,0),
+
+    {{"_PMC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (11 Int),(3 Str) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 11, ACPI_RTYPE_STRING, 3,0),
+
+    {{"_PMD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_PMM",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_PPC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_PPE",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}}, /* See dig64 spec */
+
+    {{"_PR0",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_PR1",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_PR2",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_PR3",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_PRE",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_PRL",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_PRR",   METHOD_0ARGS,                          /* ACPI 6.0 */
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (1 Ref) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_REFERENCE, 1,0,0,0),
+
+    {{"_PRS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
 
     /*
      * For _PRT, many BIOSs reverse the 3rd and 4th Package elements (Source
@@ -409,47 +740,94 @@ static const ACPI_PREDEFINED_INFO     PredefinedNames[] =
      * warning, add the ACPI_RTYPE_REFERENCE type to the 4th element (index 3)
      * in the statement below.
      */
-    {{"_PRT", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each (4): Int,Int,Int/Ref,Int */
-                    {{{ACPI_PTYPE2_FIXED, 4, ACPI_RTYPE_INTEGER,ACPI_RTYPE_INTEGER},
-                    ACPI_RTYPE_INTEGER | ACPI_RTYPE_REFERENCE,
-                    ACPI_RTYPE_INTEGER}},
-
-    {{"_PRW", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each: Pkg/Int,Int,[Variable-length Refs] (Pkg is Ref/Int) */
-                    {{{ACPI_PTYPE1_OPTION, 2, ACPI_RTYPE_INTEGER | ACPI_RTYPE_PACKAGE,
-                    ACPI_RTYPE_INTEGER}, ACPI_RTYPE_REFERENCE,0}},
-
-    {{"_PS0", 0, 0}},
-    {{"_PS1", 0, 0}},
-    {{"_PS2", 0, 0}},
-    {{"_PS3", 0, 0}},
-    {{"_PSC", 0, ACPI_RTYPE_INTEGER}},
-    {{"_PSD", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each (5 Int) with count */
-                    {{{ACPI_PTYPE2_COUNT, ACPI_RTYPE_INTEGER,0,0}, 0,0}},
-
-    {{"_PSE", 1, 0}},
-    {{"_PSL", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_PSR", 0, ACPI_RTYPE_INTEGER}},
-    {{"_PSS", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each (6 Int) */
-                    {{{ACPI_PTYPE2, ACPI_RTYPE_INTEGER, 6,0}, 0,0}},
-
-    {{"_PSV", 0, ACPI_RTYPE_INTEGER}},
-    {{"_PSW", 1, 0}},
-    {{"_PTC", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (2 Buf) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_BUFFER, 2,0}, 0,0}},
-
-    {{"_PTP", 2, ACPI_RTYPE_INTEGER}},
-    {{"_PTS", 1, 0}},
-    {{"_PUR", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (2 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 2,0}, 0,0}},
-
-    {{"_PXM", 0, ACPI_RTYPE_INTEGER}},
-    {{"_REG", 2, 0}},
-    {{"_REV", 0, ACPI_RTYPE_INTEGER}},
-    {{"_RMV", 0, ACPI_RTYPE_INTEGER}},
-    {{"_ROM", 2, ACPI_RTYPE_BUFFER}},
-    {{"_RTV", 0, ACPI_RTYPE_INTEGER}},
+    {{"_PRT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each (4): Int,Int,Int/Ref,Int */
+                    PACKAGE_INFO (ACPI_PTYPE2_FIXED, 4, ACPI_RTYPE_INTEGER, ACPI_RTYPE_INTEGER,
+                                  ACPI_RTYPE_INTEGER | ACPI_RTYPE_REFERENCE, ACPI_RTYPE_INTEGER),
+
+    {{"_PRW",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each: Pkg/Int,Int,[Variable-length Refs] (Pkg is Ref/Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_OPTION, 2, ACPI_RTYPE_INTEGER | ACPI_RTYPE_PACKAGE,
+                                  ACPI_RTYPE_INTEGER, ACPI_RTYPE_REFERENCE, 0),
+
+    {{"_PS0",   METHOD_0ARGS,
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PS1",   METHOD_0ARGS,
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PS2",   METHOD_0ARGS,
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PS3",   METHOD_0ARGS,
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PSC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_PSD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each (5 Int) with count */
+                    PACKAGE_INFO (ACPI_PTYPE2_COUNT, ACPI_RTYPE_INTEGER, 0,0,0,0),
+
+    {{"_PSE",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PSL",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_PSR",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_PSS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each (6 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE2, ACPI_RTYPE_INTEGER, 6,0,0,0),
+
+    {{"_PSV",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_PSW",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PTC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (2 Buf) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_BUFFER, 2,0,0,0),
+
+    {{"_PTP",   METHOD_2ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_PTS",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_PUR",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (2 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 2,0,0,0),
+
+    {{"_PXM",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_RDI",   METHOD_0ARGS,                          /* ACPI 6.0 */
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (1 Int, n Pkg (m Ref)) */
+                    PACKAGE_INFO (ACPI_PTYPE2_VAR_VAR, ACPI_RTYPE_INTEGER, 1,
+                    ACPI_RTYPE_REFERENCE,0,0),
+
+    {{"_REG",   METHOD_2ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_REV",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_RMV",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_ROM",   METHOD_2ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_RST",   METHOD_0ARGS,                          /* ACPI 6.0 */
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_RTV",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
 
     /*
      * For _S0_ through _S5_, the ACPI spec defines a return Package
@@ -457,108 +835,295 @@ static const ACPI_PREDEFINED_INFO     PredefinedNames[] =
      * Allow this by making the objects "Variable-length length", but all elements
      * must be Integers.
      */
-    {{"_S0_", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (1 Int) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0}, 0,0}},
-
-    {{"_S1_", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (1 Int) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0}, 0,0}},
-
-    {{"_S2_", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (1 Int) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0}, 0,0}},
-
-    {{"_S3_", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (1 Int) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0}, 0,0}},
-
-    {{"_S4_", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (1 Int) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0}, 0,0}},
-
-    {{"_S5_", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (1 Int) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0}, 0,0}},
-
-    {{"_S1D", 0, ACPI_RTYPE_INTEGER}},
-    {{"_S2D", 0, ACPI_RTYPE_INTEGER}},
-    {{"_S3D", 0, ACPI_RTYPE_INTEGER}},
-    {{"_S4D", 0, ACPI_RTYPE_INTEGER}},
-    {{"_S0W", 0, ACPI_RTYPE_INTEGER}},
-    {{"_S1W", 0, ACPI_RTYPE_INTEGER}},
-    {{"_S2W", 0, ACPI_RTYPE_INTEGER}},
-    {{"_S3W", 0, ACPI_RTYPE_INTEGER}},
-    {{"_S4W", 0, ACPI_RTYPE_INTEGER}},
-    {{"_SBS", 0, ACPI_RTYPE_INTEGER}},
-    {{"_SCP", 0x13, 0}},               /* Acpi 1.0 allowed 1 arg. Acpi 3.0 expanded to 3 args. Allow both. */
-                                       /* Note: the 3-arg definition may be removed for ACPI 4.0 */
-    {{"_SDD", 1, 0}},
-    {{"_SEG", 0, ACPI_RTYPE_INTEGER}},
-    {{"_SHL", 1, ACPI_RTYPE_INTEGER}},
-    {{"_SLI", 0, ACPI_RTYPE_BUFFER}},
-    {{"_SPD", 1, ACPI_RTYPE_INTEGER}},
-    {{"_SRS", 1, 0}},
-    {{"_SRT", 1, ACPI_RTYPE_INTEGER}},
-    {{"_SRV", 0, ACPI_RTYPE_INTEGER}}, /* See IPMI spec */
-    {{"_SST", 1, 0}},
-    {{"_STA", 0, ACPI_RTYPE_INTEGER}},
-    {{"_STM", 3, 0}},
-    {{"_STP", 2, ACPI_RTYPE_INTEGER}},
-    {{"_STR", 0, ACPI_RTYPE_BUFFER}},
-    {{"_STV", 2, ACPI_RTYPE_INTEGER}},
-    {{"_SUB", 0, ACPI_RTYPE_STRING}},
-    {{"_SUN", 0, ACPI_RTYPE_INTEGER}},
-    {{"_SWS", 0, ACPI_RTYPE_INTEGER}},
-    {{"_TC1", 0, ACPI_RTYPE_INTEGER}},
-    {{"_TC2", 0, ACPI_RTYPE_INTEGER}},
-    {{"_TDL", 0, ACPI_RTYPE_INTEGER}},
-    {{"_TIP", 1, ACPI_RTYPE_INTEGER}},
-    {{"_TIV", 1, ACPI_RTYPE_INTEGER}},
-    {{"_TMP", 0, ACPI_RTYPE_INTEGER}},
-    {{"_TPC", 0, ACPI_RTYPE_INTEGER}},
-    {{"_TPT", 1, 0}},
-    {{"_TRT", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each 2Ref/6Int */
-                    {{{ACPI_PTYPE2, ACPI_RTYPE_REFERENCE, 2, ACPI_RTYPE_INTEGER}, 6, 0}},
-
-    {{"_TSD", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each 5Int with count */
-                    {{{ACPI_PTYPE2_COUNT,ACPI_RTYPE_INTEGER, 5,0}, 0,0}},
-
-    {{"_TSP", 0, ACPI_RTYPE_INTEGER}},
-    {{"_TSS", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Pkgs) each 5Int */
-                    {{{ACPI_PTYPE2, ACPI_RTYPE_INTEGER, 5,0}, 0,0}},
-
-    {{"_TST", 0, ACPI_RTYPE_INTEGER}},
-    {{"_TTS", 1, 0}},
-    {{"_TZD", 0, ACPI_RTYPE_PACKAGE}}, /* Variable-length (Refs) */
-                    {{{ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0}, 0,0}},
-
-    {{"_TZM", 0, ACPI_RTYPE_REFERENCE}},
-    {{"_TZP", 0, ACPI_RTYPE_INTEGER}},
-    {{"_UID", 0, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING}},
-    {{"_UPC", 0, ACPI_RTYPE_PACKAGE}}, /* Fixed-length (4 Int) */
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4,0}, 0,0}},
-
-    {{"_UPD", 0, ACPI_RTYPE_INTEGER}},
-    {{"_UPP", 0, ACPI_RTYPE_INTEGER}},
-    {{"_VPO", 0, ACPI_RTYPE_INTEGER}},
+    {{"_S0_",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (1 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0,0,0),
+
+    {{"_S1_",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (1 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0,0,0),
+
+    {{"_S2_",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (1 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0,0,0),
+
+    {{"_S3_",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (1 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0,0,0),
+
+    {{"_S4_",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (1 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0,0,0),
+
+    {{"_S5_",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (1 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_INTEGER, 1,0,0,0),
+
+    {{"_S1D",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_S2D",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_S3D",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_S4D",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_S0W",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_S1W",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_S2W",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_S3W",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_S4W",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_SBS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_SCP",   METHOD_1ARGS (ACPI_TYPE_INTEGER) | ARG_COUNT_IS_MINIMUM,
+                METHOD_NO_RETURN_VALUE}},   /* Acpi 1.0 allowed 1 integer arg. Acpi 3.0 expanded to 3 args. Allow both. */
+
+    {{"_SDD",   METHOD_1ARGS (ACPI_TYPE_BUFFER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_SEG",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_SHL",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_SLI",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_SPD",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_SRS",   METHOD_1ARGS (ACPI_TYPE_BUFFER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_SRT",   METHOD_1ARGS (ACPI_TYPE_BUFFER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_SRV",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}}, /* See IPMI spec */
+
+    {{"_SST",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_STA",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_STM",   METHOD_3ARGS (ACPI_TYPE_BUFFER, ACPI_TYPE_BUFFER, ACPI_TYPE_BUFFER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_STP",   METHOD_2ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_STR",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_STV",   METHOD_2ARGS (ACPI_TYPE_INTEGER, ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_SUB",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_STRING)}},
+
+    {{"_SUN",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_SWS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TC1",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TC2",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TDL",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TFP",   METHOD_0ARGS,                          /* ACPI 6.0 */
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TIP",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TIV",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TMP",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TPC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TPT",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_TRT",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each 2 Ref/6 Int */
+                    PACKAGE_INFO (ACPI_PTYPE2, ACPI_RTYPE_REFERENCE, 2, ACPI_RTYPE_INTEGER, 6, 0),
+
+    {{"_TSD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each 5 Int with count */
+                    PACKAGE_INFO (ACPI_PTYPE2_COUNT,ACPI_RTYPE_INTEGER, 5,0,0,0),
+
+    {{"_TSN",   METHOD_0ARGS,                          /* ACPI 6.0 */
+                METHOD_RETURNS (ACPI_RTYPE_REFERENCE)}},
+
+    {{"_TSP",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TSS",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Pkgs) each 5 Int */
+                    PACKAGE_INFO (ACPI_PTYPE2, ACPI_RTYPE_INTEGER, 5,0,0,0),
+
+    {{"_TST",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_TTS",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_NO_RETURN_VALUE}},
+
+    {{"_TZD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Variable-length (Refs) */
+                    PACKAGE_INFO (ACPI_PTYPE1_VAR, ACPI_RTYPE_REFERENCE, 0,0,0,0),
+
+    {{"_TZM",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_REFERENCE)}},
+
+    {{"_TZP",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_UID",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING)}},
+
+    {{"_UPC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_PACKAGE)}}, /* Fixed-length (4 Int) */
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 4,0,0,0),
+
+    {{"_UPD",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_UPP",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
+
+    {{"_VPO",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},
 
     /* Acpi 1.0 defined _WAK with no return value. Later, it was changed to return a package */
 
-    {{"_WAK", 1, ACPI_RTYPE_NONE | ACPI_RTYPE_INTEGER | ACPI_RTYPE_PACKAGE}},
-                    {{{ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 2,0}, 0,0}}, /* Fixed-length (2 Int), but is optional */
+    {{"_WAK",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_NONE | ACPI_RTYPE_INTEGER | ACPI_RTYPE_PACKAGE)}},
+                    PACKAGE_INFO (ACPI_PTYPE1_FIXED, ACPI_RTYPE_INTEGER, 2,0,0,0), /* Fixed-length (2 Int), but is optional */
 
     /* _WDG/_WED are MS extensions defined by "Windows Instrumentation" */
 
-    {{"_WDG", 0, ACPI_RTYPE_BUFFER}},
-    {{"_WED", 1, ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING | ACPI_RTYPE_BUFFER}},
+    {{"_WDG",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_BUFFER)}},
+
+    {{"_WED",   METHOD_1ARGS (ACPI_TYPE_INTEGER),
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER | ACPI_RTYPE_STRING | ACPI_RTYPE_BUFFER)}},
+
+    {{"_WPC",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},  /* ACPI 6.1 */
 
-    {{{0,0,0,0}, 0,0}} /* Table terminator */
+    {{"_WPP",   METHOD_0ARGS,
+                METHOD_RETURNS (ACPI_RTYPE_INTEGER)}},  /* ACPI 6.1 */
+
+    PACKAGE_INFO (0,0,0,0,0,0) /* Table terminator */
 };
+#else
+extern const ACPI_PREDEFINED_INFO       AcpiGbl_PredefinedMethods[];
+#endif
 
-#if 0
 
-    /* This is an internally implemented control method, no need to check */
-    {{"_OSI", 1, ACPI_RTYPE_INTEGER}},
+#if (defined ACPI_CREATE_RESOURCE_TABLE && defined ACPI_APPLICATION)
+/******************************************************************************
+ *
+ * Predefined names for use in Resource Descriptors. These names do not
+ * appear in the global Predefined Name table (since these names never
+ * appear in actual AML byte code, only in the original ASL)
+ *
+ * Note: Used by iASL compiler and AcpiHelp utility only.
+ *
+ *****************************************************************************/
 
-    /* TBD: */
+const ACPI_PREDEFINED_INFO      AcpiGbl_ResourceNames[] =
+{
+    {{"_ADR",   WIDTH_16 | WIDTH_64,            0}},
+    {{"_ALN",   WIDTH_8 | WIDTH_16 | WIDTH_32,  0}},
+    {{"_ASI",   WIDTH_8,                        0}},
+    {{"_ASZ",   WIDTH_8,                        0}},
+    {{"_ATT",   WIDTH_64,                       0}},
+    {{"_BAS",   WIDTH_16 | WIDTH_32,            0}},
+    {{"_BM_",   WIDTH_1,                        0}},
+    {{"_DBT",   WIDTH_16,                       0}},  /* Acpi 5.0 */
+    {{"_DEC",   WIDTH_1,                        0}},
+    {{"_DMA",   WIDTH_8,                        0}},
+    {{"_DPL",   WIDTH_1,                        0}},  /* Acpi 5.0 */
+    {{"_DRS",   WIDTH_16,                       0}},  /* Acpi 5.0 */
+    {{"_END",   WIDTH_1,                        0}},  /* Acpi 5.0 */
+    {{"_FLC",   WIDTH_2,                        0}},  /* Acpi 5.0 */
+    {{"_GRA",   WIDTH_ADDRESS,                  0}},
+    {{"_HE_",   WIDTH_1,                        0}},
+    {{"_INT",   WIDTH_16 | WIDTH_32,            0}},
+    {{"_IOR",   WIDTH_2,                        0}},  /* Acpi 5.0 */
+    {{"_LEN",   WIDTH_8 | WIDTH_ADDRESS,        0}},
+    {{"_LIN",   WIDTH_8,                        0}},  /* Acpi 5.0 */
+    {{"_LL_",   WIDTH_1,                        0}},
+    {{"_MAF",   WIDTH_1,                        0}},
+    {{"_MAX",   WIDTH_ADDRESS,                  0}},
+    {{"_MEM",   WIDTH_2,                        0}},
+    {{"_MIF",   WIDTH_1,                        0}},
+    {{"_MIN",   WIDTH_ADDRESS,                  0}},
+    {{"_MOD",   WIDTH_1,                        0}},  /* Acpi 5.0 */
+    {{"_MTP",   WIDTH_2,                        0}},
+    {{"_PAR",   WIDTH_8,                        0}},  /* Acpi 5.0 */
+    {{"_PHA",   WIDTH_1,                        0}},  /* Acpi 5.0 */
+    {{"_PIN",   WIDTH_16,                       0}},  /* Acpi 5.0 */
+    {{"_PPI",   WIDTH_8,                        0}},  /* Acpi 5.0 */
+    {{"_POL",   WIDTH_1 | WIDTH_2,              0}},  /* Acpi 5.0 */
+    {{"_RBO",   WIDTH_8,                        0}},
+    {{"_RBW",   WIDTH_8,                        0}},
+    {{"_RNG",   WIDTH_1,                        0}},
+    {{"_RT_",   WIDTH_8,                        0}},  /* Acpi 3.0 */
+    {{"_RW_",   WIDTH_1,                        0}},
+    {{"_RXL",   WIDTH_16,                       0}},  /* Acpi 5.0 */
+    {{"_SHR",   WIDTH_2,                        0}},
+    {{"_SIZ",   WIDTH_2,                        0}},
+    {{"_SLV",   WIDTH_1,                        0}},  /* Acpi 5.0 */
+    {{"_SPE",   WIDTH_32,                       0}},  /* Acpi 5.0 */
+    {{"_STB",   WIDTH_2,                        0}},  /* Acpi 5.0 */
+    {{"_TRA",   WIDTH_ADDRESS,                  0}},
+    {{"_TRS",   WIDTH_1,                        0}},
+    {{"_TSF",   WIDTH_8,                        0}},  /* Acpi 3.0 */
+    {{"_TTP",   WIDTH_1,                        0}},
+    {{"_TXL",   WIDTH_16,                       0}},  /* Acpi 5.0 */
+    {{"_TYP",   WIDTH_2 | WIDTH_16,             0}},
+    {{"_VEN",   VARIABLE_DATA,                  0}},  /* Acpi 5.0 */
+    PACKAGE_INFO (0,0,0,0,0,0) /* Table terminator */
+};
 
-    _PRT - currently ignore reversed entries. Attempt to fix here?
-    Think about possibly fixing package elements like _BIF, etc.
-#endif
+const ACPI_PREDEFINED_INFO              AcpiGbl_ScopeNames[] = {
+    {{"_GPE",     0,      0}},
+    {{"_PR_",     0,      0}},
+    {{"_SB_",     0,      0}},
+    {{"_SI_",     0,      0}},
+    {{"_TZ_",     0,      0}},
+    PACKAGE_INFO (0,0,0,0,0,0) /* Table terminator */
+};
+#else
+extern const ACPI_PREDEFINED_INFO       AcpiGbl_ResourceNames[];
 #endif
+
 #endif
diff --git a/usr/src/uts/intel/sys/acpi/acresrc.h b/usr/src/uts/intel/sys/acpi/acresrc.h
index c879fdc4a3..1d077caac0 100644
--- a/usr/src/uts/intel/sys/acpi/acresrc.h
+++ b/usr/src/uts/intel/sys/acpi/acresrc.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -130,7 +130,7 @@ typedef const struct acpi_rsdump_info
 {
     UINT8                   Opcode;
     UINT8                   Offset;
-    char                    *Name;
+    const char              *Name;
     const char              **Pointer;
 
 } ACPI_RSDUMP_INFO;
@@ -197,7 +197,7 @@ AcpiRsCreateResourceList (
 
 ACPI_STATUS
 AcpiRsCreateAmlResources (
-    ACPI_RESOURCE           *LinkedListBuffer,
+    ACPI_BUFFER             *ResourceList,
     ACPI_BUFFER             *OutputBuffer);
 
 ACPI_STATUS
@@ -227,7 +227,7 @@ AcpiRsGetPrsMethodData (
 ACPI_STATUS
 AcpiRsGetMethodData (
     ACPI_HANDLE             Handle,
-    char                    *Path,
+    const char              *Path,
     ACPI_BUFFER             *RetBuffer);
 
 ACPI_STATUS
@@ -251,7 +251,8 @@ AcpiRsGetListLength (
 
 ACPI_STATUS
 AcpiRsGetAmlLength (
-    ACPI_RESOURCE           *LinkedListBuffer,
+    ACPI_RESOURCE           *ResourceList,
+    ACPI_SIZE               ResourceListSize,
     ACPI_SIZE               *SizeNeeded);
 
 ACPI_STATUS
@@ -265,7 +266,7 @@ AcpiRsConvertAmlToResources (
     UINT32                  Length,
     UINT32                  Offset,
     UINT8                   ResourceIndex,
-    void                    *Context);
+    void                    **Context);
 
 ACPI_STATUS
 AcpiRsConvertResourcesToAml (
@@ -351,8 +352,9 @@ AcpiRsSetResourceLength (
 
 
 /*
- * rsdump
+ * rsdump - Debugger support
  */
+#ifdef ACPI_DEBUGGER
 void
 AcpiRsDumpResourceList (
     ACPI_RESOURCE           *Resource);
@@ -360,6 +362,7 @@ AcpiRsDumpResourceList (
 void
 AcpiRsDumpIrqList (
     UINT8                   *RouteTable);
+#endif
 
 
 /*
@@ -405,18 +408,21 @@ extern ACPI_RSDUMP_INFO         *AcpiGbl_DumpResourceDispatch[];
 extern ACPI_RSDUMP_INFO         *AcpiGbl_DumpSerialBusDispatch[];
 
 /*
- * rsdump
+ * rsdumpinfo
  */
 extern ACPI_RSDUMP_INFO         AcpiRsDumpIrq[];
+extern ACPI_RSDUMP_INFO         AcpiRsDumpPrt[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpDma[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpStartDpf[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpEndDpf[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpIo[];
+extern ACPI_RSDUMP_INFO         AcpiRsDumpIoFlags[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpFixedIo[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpVendor[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpEndTag[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpMemory24[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpMemory32[];
+extern ACPI_RSDUMP_INFO         AcpiRsDumpMemoryFlags[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpFixedMemory32[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpAddress16[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpAddress32[];
@@ -430,6 +436,7 @@ extern ACPI_RSDUMP_INFO         AcpiRsDumpCommonSerialBus[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpI2cSerialBus[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpSpiSerialBus[];
 extern ACPI_RSDUMP_INFO         AcpiRsDumpUartSerialBus[];
+extern ACPI_RSDUMP_INFO         AcpiRsDumpGeneralFlags[];
 #endif
 
 #endif  /* __ACRESRC_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/acrestyp.h b/usr/src/uts/intel/sys/acpi/acrestyp.h
index b927c9c58e..72f0d16310 100644
--- a/usr/src/uts/intel/sys/acpi/acrestyp.h
+++ b/usr/src/uts/intel/sys/acpi/acrestyp.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -103,8 +103,11 @@ typedef UINT32                          ACPI_RSDESC_SIZE;  /* Max Resource Descr
 
 #define ACPI_EXCLUSIVE                  (UINT8) 0x00
 #define ACPI_SHARED                     (UINT8) 0x01
-#define ACPI_EXCLUSIVE_AND_WAKE         (UINT8) 0x02
-#define ACPI_SHARED_AND_WAKE            (UINT8) 0x03
+
+/* Wake */
+
+#define ACPI_NOT_WAKE_CAPABLE           (UINT8) 0x00
+#define ACPI_WAKE_CAPABLE               (UINT8) 0x01
 
 /*
  * DMA Attributes
@@ -177,6 +180,7 @@ typedef struct acpi_resource_irq
     UINT8                           Triggering;
     UINT8                           Polarity;
     UINT8                           Sharable;
+    UINT8                           WakeCapable;
     UINT8                           InterruptCount;
     UINT8                           Interrupts[1];
 
@@ -341,6 +345,36 @@ typedef struct acpi_resource_source
     UINT8                           MaxAddressFixed; \
     ACPI_RESOURCE_ATTRIBUTE         Info;
 
+typedef struct acpi_address16_attribute
+{
+    UINT16                          Granularity;
+    UINT16                          Minimum;
+    UINT16                          Maximum;
+    UINT16                          TranslationOffset;
+    UINT16                          AddressLength;
+
+} ACPI_ADDRESS16_ATTRIBUTE;
+
+typedef struct acpi_address32_attribute
+{
+    UINT32                          Granularity;
+    UINT32                          Minimum;
+    UINT32                          Maximum;
+    UINT32                          TranslationOffset;
+    UINT32                          AddressLength;
+
+} ACPI_ADDRESS32_ATTRIBUTE;
+
+typedef struct acpi_address64_attribute
+{
+    UINT64                          Granularity;
+    UINT64                          Minimum;
+    UINT64                          Maximum;
+    UINT64                          TranslationOffset;
+    UINT64                          AddressLength;
+
+} ACPI_ADDRESS64_ATTRIBUTE;
+
 typedef struct acpi_resource_address
 {
     ACPI_RESOURCE_ADDRESS_COMMON
@@ -350,11 +384,7 @@ typedef struct acpi_resource_address
 typedef struct acpi_resource_address16
 {
     ACPI_RESOURCE_ADDRESS_COMMON
-    UINT16                          Granularity;
-    UINT16                          Minimum;
-    UINT16                          Maximum;
-    UINT16                          TranslationOffset;
-    UINT16                          AddressLength;
+    ACPI_ADDRESS16_ATTRIBUTE        Address;
     ACPI_RESOURCE_SOURCE            ResourceSource;
 
 } ACPI_RESOURCE_ADDRESS16;
@@ -362,11 +392,7 @@ typedef struct acpi_resource_address16
 typedef struct acpi_resource_address32
 {
     ACPI_RESOURCE_ADDRESS_COMMON
-    UINT32                          Granularity;
-    UINT32                          Minimum;
-    UINT32                          Maximum;
-    UINT32                          TranslationOffset;
-    UINT32                          AddressLength;
+    ACPI_ADDRESS32_ATTRIBUTE        Address;
     ACPI_RESOURCE_SOURCE            ResourceSource;
 
 } ACPI_RESOURCE_ADDRESS32;
@@ -374,11 +400,7 @@ typedef struct acpi_resource_address32
 typedef struct acpi_resource_address64
 {
     ACPI_RESOURCE_ADDRESS_COMMON
-    UINT64                          Granularity;
-    UINT64                          Minimum;
-    UINT64                          Maximum;
-    UINT64                          TranslationOffset;
-    UINT64                          AddressLength;
+    ACPI_ADDRESS64_ATTRIBUTE        Address;
     ACPI_RESOURCE_SOURCE            ResourceSource;
 
 } ACPI_RESOURCE_ADDRESS64;
@@ -387,11 +409,7 @@ typedef struct acpi_resource_extended_address64
 {
     ACPI_RESOURCE_ADDRESS_COMMON
     UINT8                           RevisionID;
-    UINT64                          Granularity;
-    UINT64                          Minimum;
-    UINT64                          Maximum;
-    UINT64                          TranslationOffset;
-    UINT64                          AddressLength;
+    ACPI_ADDRESS64_ATTRIBUTE        Address;
     UINT64                          TypeSpecific;
 
 } ACPI_RESOURCE_EXTENDED_ADDRESS64;
@@ -402,6 +420,7 @@ typedef struct acpi_resource_extended_irq
     UINT8                           Triggering;
     UINT8                           Polarity;
     UINT8                           Sharable;
+    UINT8                           WakeCapable;
     UINT8                           InterruptCount;
     ACPI_RESOURCE_SOURCE            ResourceSource;
     UINT32                          Interrupts[1];
@@ -425,6 +444,7 @@ typedef struct acpi_resource_gpio
     UINT8                           ProducerConsumer;   /* For values, see Producer/Consumer above */
     UINT8                           PinConfig;
     UINT8                           Sharable;           /* For values, see Interrupt Attributes above */
+    UINT8                           WakeCapable;        /* For values, see Interrupt Attributes above */
     UINT8                           IoRestriction;
     UINT8                           Triggering;         /* For values, see Interrupt Attributes above */
     UINT8                           Polarity;           /* For values, see Interrupt Attributes above */
@@ -465,6 +485,7 @@ typedef struct acpi_resource_gpio
     UINT8                           Type; \
     UINT8                           ProducerConsumer;    /* For values, see Producer/Consumer above */\
     UINT8                           SlaveMode; \
+    UINT8                           ConnectionSharing; \
     UINT8                           TypeRevisionId; \
     UINT16                          TypeDataLength; \
     UINT16                          VendorLength; \
@@ -675,7 +696,10 @@ typedef struct acpi_resource
 #define ACPI_RS_SIZE_MIN                    (UINT32) ACPI_ROUND_UP_TO_NATIVE_WORD (12)
 #define ACPI_RS_SIZE(Type)                  (UINT32) (ACPI_RS_SIZE_NO_DATA + sizeof (Type))
 
-#define ACPI_NEXT_RESOURCE(Res)             (ACPI_RESOURCE *)((UINT8 *) Res + Res->Length)
+/* Macro for walking resource templates with multiple descriptors */
+
+#define ACPI_NEXT_RESOURCE(Res) \
+    ACPI_ADD_PTR (ACPI_RESOURCE, (Res), (Res)->Length)
 
 
 typedef struct acpi_pci_routing_table
@@ -689,4 +713,3 @@ typedef struct acpi_pci_routing_table
 } ACPI_PCI_ROUTING_TABLE;
 
 #endif /* __ACRESTYP_H__ */
-
diff --git a/usr/src/uts/intel/sys/acpi/acstruct.h b/usr/src/uts/intel/sys/acpi/acstruct.h
index b3927caa41..f7538aded9 100644
--- a/usr/src/uts/intel/sys/acpi/acstruct.h
+++ b/usr/src/uts/intel/sys/acpi/acstruct.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -54,7 +54,7 @@
 
 
 /*
- * Walk state - current state of a parse tree walk.  Used for both a leisurely
+ * Walk state - current state of a parse tree walk. Used for both a leisurely
  * stroll through the tree (for whatever reason), and for control method
  * execution.
  */
@@ -69,11 +69,6 @@
 #define ACPI_WALK_METHOD            0x01
 #define ACPI_WALK_METHOD_RESTART    0x02
 
-/* Flags for iASL compiler only */
-
-#define ACPI_WALK_CONST_REQUIRED    0x10
-#define ACPI_WALK_CONST_OPTIONAL    0x20
-
 
 typedef struct acpi_walk_state
 {
@@ -90,9 +85,10 @@ typedef struct acpi_walk_state
     UINT8                           ReturnUsed;
     UINT8                           ScopeDepth;
     UINT8                           PassNumber;         /* Parse pass during table load */
+    BOOLEAN                         NamespaceOverride;  /* Override existing objects */
     UINT8                           ResultSize;         /* Total elements for the result stack */
     UINT8                           ResultCount;        /* Current number of occupied elements of result stack */
-    UINT32                          AmlOffset;
+    UINT8                           *Aml;
     UINT32                          ArgTypes;
     UINT32                          MethodBreakpoint;   /* For single stepping */
     UINT32                          UserBreakpoint;     /* User AML breakpoint */
@@ -139,6 +135,9 @@ typedef struct acpi_init_walk_info
     UINT32                          TableIndex;
     UINT32                          ObjectCount;
     UINT32                          MethodCount;
+    UINT32                          SerialMethodCount;
+    UINT32                          NonSerialMethodCount;
+    UINT32                          SerializedMethodCount;
     UINT32                          DeviceCount;
     UINT32                          OpRegionCount;
     UINT32                          FieldCount;
@@ -195,27 +194,43 @@ typedef union acpi_aml_operands
 
 
 /*
- * Structure used to pass object evaluation parameters.
+ * Structure used to pass object evaluation information and parameters.
  * Purpose is to reduce CPU stack use.
  */
 typedef struct acpi_evaluate_info
 {
-    ACPI_NAMESPACE_NODE             *PrefixNode;
-    char                            *Pathname;
-    ACPI_OPERAND_OBJECT             *ObjDesc;
-    ACPI_OPERAND_OBJECT             **Parameters;
-    ACPI_NAMESPACE_NODE             *ResolvedNode;
-    ACPI_OPERAND_OBJECT             *ReturnObject;
-    UINT8                           ParamCount;
-    UINT8                           PassNumber;
-    UINT8                           ReturnObjectType;
-    UINT8                           Flags;
+    /* The first 3 elements are passed by the caller to AcpiNsEvaluate */
+
+    ACPI_NAMESPACE_NODE             *PrefixNode;        /* Input: starting node */
+    const char                      *RelativePathname;  /* Input: path relative to PrefixNode */
+    ACPI_OPERAND_OBJECT             **Parameters;       /* Input: argument list */
+
+    ACPI_NAMESPACE_NODE             *Node;              /* Resolved node (PrefixNode:RelativePathname) */
+    ACPI_OPERAND_OBJECT             *ObjDesc;           /* Object attached to the resolved node */
+    char                            *FullPathname;      /* Full pathname of the resolved node */
+
+    const ACPI_PREDEFINED_INFO      *Predefined;        /* Used if Node is a predefined name */
+    ACPI_OPERAND_OBJECT             *ReturnObject;      /* Object returned from the evaluation */
+    union acpi_operand_object       *ParentPackage;     /* Used if return object is a Package */
+
+    UINT32                          ReturnFlags;        /* Used for return value analysis */
+    UINT32                          ReturnBtype;        /* Bitmapped type of the returned object */
+    UINT16                          ParamCount;         /* Count of the input argument list */
+    UINT8                           PassNumber;         /* Parser pass number */
+    UINT8                           ReturnObjectType;   /* Object type of the returned object */
+    UINT8                           NodeFlags;          /* Same as Node->Flags */
+    UINT8                           Flags;              /* General flags */
 
 } ACPI_EVALUATE_INFO;
 
 /* Values for Flags above */
 
-#define ACPI_IGNORE_RETURN_VALUE        1
+#define ACPI_IGNORE_RETURN_VALUE    1
+
+/* Defines for ReturnFlags field above */
+
+#define ACPI_OBJECT_REPAIRED        1
+#define ACPI_OBJECT_WRAPPED         2
 
 
 /* Info used by AcpiNsInitializeDevices */
diff --git a/usr/src/uts/intel/sys/acpi/actables.h b/usr/src/uts/intel/sys/acpi/actables.h
index 26a7947dc9..e1a4a6eb63 100644
--- a/usr/src/uts/intel/sys/acpi/actables.h
+++ b/usr/src/uts/intel/sys/acpi/actables.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,12 +49,73 @@ ACPI_STATUS
 AcpiAllocateRootTable (
     UINT32                  InitialTableCount);
 
+/*
+ * tbxfroot - Root pointer utilities
+ */
+UINT32
+AcpiTbGetRsdpLength (
+    ACPI_TABLE_RSDP         *Rsdp);
+
+ACPI_STATUS
+AcpiTbValidateRsdp (
+    ACPI_TABLE_RSDP         *Rsdp);
+
+UINT8 *
+AcpiTbScanMemoryForRsdp (
+    UINT8                   *StartAddress,
+    UINT32                  Length);
+
+
+/*
+ * tbdata - table data structure management
+ */
+ACPI_STATUS
+AcpiTbGetNextTableDescriptor (
+    UINT32                  *TableIndex,
+    ACPI_TABLE_DESC         **TableDesc);
+
+void
+AcpiTbInitTableDescriptor (
+    ACPI_TABLE_DESC         *TableDesc,
+    ACPI_PHYSICAL_ADDRESS   Address,
+    UINT8                   Flags,
+    ACPI_TABLE_HEADER       *Table);
+
+ACPI_STATUS
+AcpiTbAcquireTempTable (
+    ACPI_TABLE_DESC         *TableDesc,
+    ACPI_PHYSICAL_ADDRESS   Address,
+    UINT8                   Flags);
+
+void
+AcpiTbReleaseTempTable (
+    ACPI_TABLE_DESC         *TableDesc);
+
+ACPI_STATUS
+AcpiTbValidateTempTable (
+    ACPI_TABLE_DESC         *TableDesc);
+
+ACPI_STATUS
+AcpiTbVerifyTempTable (
+    ACPI_TABLE_DESC         *TableDesc,
+    char                    *Signature);
+
+BOOLEAN
+AcpiTbIsTableLoaded (
+    UINT32                  TableIndex);
+
+void
+AcpiTbSetTableLoadedFlag (
+    UINT32                  TableIndex,
+    BOOLEAN                 IsLoaded);
+
+
 /*
  * tbfadt - FADT parse/convert/validate
  */
 void
 AcpiTbParseFadt (
-    UINT32                  TableIndex);
+    void);
 
 void
 AcpiTbCreateLocalFadt (
@@ -81,29 +142,40 @@ AcpiTbResizeRootTableList (
     void);
 
 ACPI_STATUS
-AcpiTbVerifyTable (
+AcpiTbValidateTable (
     ACPI_TABLE_DESC         *TableDesc);
 
-ACPI_TABLE_HEADER *
-AcpiTbTableOverride (
-    ACPI_TABLE_HEADER       *TableHeader,
+void
+AcpiTbInvalidateTable (
     ACPI_TABLE_DESC         *TableDesc);
 
+void
+AcpiTbOverrideTable (
+    ACPI_TABLE_DESC         *OldTableDesc);
+
 ACPI_STATUS
-AcpiTbAddTable (
+AcpiTbAcquireTable (
     ACPI_TABLE_DESC         *TableDesc,
-    UINT32                  *TableIndex);
+    ACPI_TABLE_HEADER       **TablePtr,
+    UINT32                  *TableLength,
+    UINT8                   *TableFlags);
+
+void
+AcpiTbReleaseTable (
+    ACPI_TABLE_HEADER       *Table,
+    UINT32                  TableLength,
+    UINT8                   TableFlags);
 
 ACPI_STATUS
-AcpiTbStoreTable (
+AcpiTbInstallStandardTable (
     ACPI_PHYSICAL_ADDRESS   Address,
-    ACPI_TABLE_HEADER       *Table,
-    UINT32                  Length,
     UINT8                   Flags,
+    BOOLEAN                 Reload,
+    BOOLEAN                 Override,
     UINT32                  *TableIndex);
 
 void
-AcpiTbDeleteTable (
+AcpiTbUninstallTable (
     ACPI_TABLE_DESC        *TableDesc);
 
 void
@@ -127,15 +199,6 @@ AcpiTbGetOwnerId (
     UINT32                  TableIndex,
     ACPI_OWNER_ID           *OwnerId);
 
-BOOLEAN
-AcpiTbIsTableLoaded (
-    UINT32                  TableIndex);
-
-void
-AcpiTbSetTableLoadedFlag (
-    UINT32                  TableIndex,
-    BOOLEAN                 IsLoaded);
-
 
 /*
  * tbutils - table manager utilities
@@ -144,10 +207,6 @@ ACPI_STATUS
 AcpiTbInitializeFacs (
     void);
 
-BOOLEAN
-AcpiTbTablesLoaded (
-    void);
-
 void
 AcpiTbPrintTableHeader(
     ACPI_PHYSICAL_ADDRESS   Address,
@@ -172,13 +231,27 @@ AcpiTbCopyDsdt (
     UINT32                  TableIndex);
 
 void
-AcpiTbInstallTable (
+AcpiTbInstallTableWithOverride (
+    ACPI_TABLE_DESC         *NewTableDesc,
+    BOOLEAN                 Override,
+    UINT32                  *TableIndex);
+
+ACPI_STATUS
+AcpiTbInstallFixedTable (
     ACPI_PHYSICAL_ADDRESS   Address,
     char                    *Signature,
-    UINT32                  TableIndex);
+    UINT32                  *TableIndex);
 
 ACPI_STATUS
 AcpiTbParseRootTable (
     ACPI_PHYSICAL_ADDRESS   RsdpAddress);
 
+
+/*
+ * tbxfload
+ */
+ACPI_STATUS
+AcpiTbLoadNamespace (
+    void);
+
 #endif /* __ACTABLES_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/actbl.h b/usr/src/uts/intel/sys/acpi/actbl.h
index 7da7378d14..faeb744962 100644
--- a/usr/src/uts/intel/sys/acpi/actbl.h
+++ b/usr/src/uts/intel/sys/acpi/actbl.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -67,6 +67,7 @@
 #define ACPI_SIG_DSDT           "DSDT"      /* Differentiated System Description Table */
 #define ACPI_SIG_FADT           "FACP"      /* Fixed ACPI Description Table */
 #define ACPI_SIG_FACS           "FACS"      /* Firmware ACPI Control Structure */
+#define ACPI_SIG_OSDT           "OSDT"      /* Override System Description Table */
 #define ACPI_SIG_PSDT           "PSDT"      /* Persistent System Description Table */
 #define ACPI_SIG_RSDP           "RSD PTR "  /* Root System Description Pointer */
 #define ACPI_SIG_RSDT           "RSDT"      /* Root System Description Table */
@@ -82,9 +83,15 @@
 #pragma pack(1)
 
 /*
- * Note about bitfields: The UINT8 type is used for bitfields in ACPI tables.
- * This is the only type that is even remotely portable. Anything else is not
- * portable, so do not use any other bitfield types.
+ * Note: C bitfields are not used for this reason:
+ *
+ * "Bitfields are great and easy to read, but unfortunately the C language
+ * does not specify the layout of bitfields in memory, which means they are
+ * essentially useless for dealing with packed data in on-disk formats or
+ * binary wire protocols." (Or ACPI tables and buffers.) "If you ask me,
+ * this decision was a design error in C. Ritchie could have picked an order
+ * and stuck with it." Norman Ramsey.
+ * See http://stackoverflow.com/a/1053662/41661
  */
 
 
@@ -99,7 +106,7 @@ typedef struct acpi_table_header
 {
     char                    Signature[ACPI_NAME_SIZE];          /* ASCII table signature */
     UINT32                  Length;                             /* Length of table in bytes, including this header */
-    UINT8                   Revision;                           /* ACPI Specification minor version # */
+    UINT8                   Revision;                           /* ACPI Specification minor version number */
     UINT8                   Checksum;                           /* To make sum of entire table == 0 */
     char                    OemId[ACPI_OEM_ID_SIZE];            /* ASCII OEM identification */
     char                    OemTableId[ACPI_OEM_TABLE_ID_SIZE]; /* ASCII OEM table identification */
@@ -115,7 +122,7 @@ typedef struct acpi_table_header
  * GAS - Generic Address Structure (ACPI 2.0+)
  *
  * Note: Since this structure is used in the ACPI tables, it is byte aligned.
- * If misaliged access is not supported by the hardware, accesses to the
+ * If misaligned access is not supported by the hardware, accesses to the
  * 64-bit Address field must be performed with care.
  *
  ******************************************************************************/
@@ -197,6 +204,9 @@ typedef struct acpi_table_xsdt
 
 } ACPI_TABLE_XSDT;
 
+#define ACPI_RSDT_ENTRY_SIZE        (sizeof (UINT32))
+#define ACPI_XSDT_ENTRY_SIZE        (sizeof (UINT64))
+
 
 /*******************************************************************************
  *
@@ -238,7 +248,7 @@ typedef struct acpi_table_facs
 /*******************************************************************************
  *
  * FADT - Fixed ACPI Description Table (Signature "FACP")
- *        Version 4
+ *        Version 6
  *
  ******************************************************************************/
 
@@ -253,18 +263,18 @@ typedef struct acpi_table_fadt
     UINT8                   PreferredProfile;   /* Conveys preferred power management profile to OSPM. */
     UINT16                  SciInterrupt;       /* System vector of SCI interrupt */
     UINT32                  SmiCommand;         /* 32-bit Port address of SMI command port */
-    UINT8                   AcpiEnable;         /* Value to write to smi_cmd to enable ACPI */
-    UINT8                   AcpiDisable;        /* Value to write to smi_cmd to disable ACPI */
-    UINT8                   S4BiosRequest;      /* Value to write to SMI CMD to enter S4BIOS state */
+    UINT8                   AcpiEnable;         /* Value to write to SMI_CMD to enable ACPI */
+    UINT8                   AcpiDisable;        /* Value to write to SMI_CMD to disable ACPI */
+    UINT8                   S4BiosRequest;      /* Value to write to SMI_CMD to enter S4BIOS state */
     UINT8                   PstateControl;      /* Processor performance state control*/
-    UINT32                  Pm1aEventBlock;     /* 32-bit Port address of Power Mgt 1a Event Reg Blk */
-    UINT32                  Pm1bEventBlock;     /* 32-bit Port address of Power Mgt 1b Event Reg Blk */
-    UINT32                  Pm1aControlBlock;   /* 32-bit Port address of Power Mgt 1a Control Reg Blk */
-    UINT32                  Pm1bControlBlock;   /* 32-bit Port address of Power Mgt 1b Control Reg Blk */
-    UINT32                  Pm2ControlBlock;    /* 32-bit Port address of Power Mgt 2 Control Reg Blk */
-    UINT32                  PmTimerBlock;       /* 32-bit Port address of Power Mgt Timer Ctrl Reg Blk */
-    UINT32                  Gpe0Block;          /* 32-bit Port address of General Purpose Event 0 Reg Blk */
-    UINT32                  Gpe1Block;          /* 32-bit Port address of General Purpose Event 1 Reg Blk */
+    UINT32                  Pm1aEventBlock;     /* 32-bit port address of Power Mgt 1a Event Reg Blk */
+    UINT32                  Pm1bEventBlock;     /* 32-bit port address of Power Mgt 1b Event Reg Blk */
+    UINT32                  Pm1aControlBlock;   /* 32-bit port address of Power Mgt 1a Control Reg Blk */
+    UINT32                  Pm1bControlBlock;   /* 32-bit port address of Power Mgt 1b Control Reg Blk */
+    UINT32                  Pm2ControlBlock;    /* 32-bit port address of Power Mgt 2 Control Reg Blk */
+    UINT32                  PmTimerBlock;       /* 32-bit port address of Power Mgt Timer Ctrl Reg Blk */
+    UINT32                  Gpe0Block;          /* 32-bit port address of General Purpose Event 0 Reg Blk */
+    UINT32                  Gpe1Block;          /* 32-bit port address of General Purpose Event 1 Reg Blk */
     UINT8                   Pm1EventLength;     /* Byte Length of ports at Pm1xEventBlock */
     UINT8                   Pm1ControlLength;   /* Byte Length of ports at Pm1xControlBlock */
     UINT8                   Pm2ControlLength;   /* Byte Length of ports at Pm2ControlBlock */
@@ -272,12 +282,12 @@ typedef struct acpi_table_fadt
     UINT8                   Gpe0BlockLength;    /* Byte Length of ports at Gpe0Block */
     UINT8                   Gpe1BlockLength;    /* Byte Length of ports at Gpe1Block */
     UINT8                   Gpe1Base;           /* Offset in GPE number space where GPE1 events start */
-    UINT8                   CstControl;         /* Support for the _CST object and C States change notification */
+    UINT8                   CstControl;         /* Support for the _CST object and C-States change notification */
     UINT16                  C2Latency;          /* Worst case HW latency to enter/exit C2 state */
     UINT16                  C3Latency;          /* Worst case HW latency to enter/exit C3 state */
-    UINT16                  FlushSize;          /* Processor's memory cache line width, in bytes */
+    UINT16                  FlushSize;          /* Processor memory cache line width, in bytes */
     UINT16                  FlushStride;        /* Number of flush strides that need to be read */
-    UINT8                   DutyOffset;         /* Processor duty cycle index in processor's P_CNT reg */
+    UINT8                   DutyOffset;         /* Processor duty cycle index in processor P_CNT reg */
     UINT8                   DutyWidth;          /* Processor duty cycle value bit width in P_CNT register */
     UINT8                   DayAlarm;           /* Index to day-of-month alarm in RTC CMOS RAM */
     UINT8                   MonthAlarm;         /* Index to month-of-year alarm in RTC CMOS RAM */
@@ -287,7 +297,8 @@ typedef struct acpi_table_fadt
     UINT32                  Flags;              /* Miscellaneous flag bits (see below for individual flags) */
     ACPI_GENERIC_ADDRESS    ResetRegister;      /* 64-bit address of the Reset register */
     UINT8                   ResetValue;         /* Value to write to the ResetRegister port to reset the system */
-    UINT8                   Reserved4[3];       /* Reserved, must be zero */
+    UINT16                  ArmBootFlags;       /* ARM-Specific Boot Flags (see below for individual flags) (ACPI 5.1) */
+    UINT8                   MinorRevision;      /* FADT Minor Revision (ACPI 5.1) */
     UINT64                  XFacs;              /* 64-bit physical address of FACS */
     UINT64                  XDsdt;              /* 64-bit physical address of DSDT */
     ACPI_GENERIC_ADDRESS    XPm1aEventBlock;    /* 64-bit Extended Power Mgt 1a Event Reg Blk address */
@@ -298,13 +309,14 @@ typedef struct acpi_table_fadt
     ACPI_GENERIC_ADDRESS    XPmTimerBlock;      /* 64-bit Extended Power Mgt Timer Ctrl Reg Blk address */
     ACPI_GENERIC_ADDRESS    XGpe0Block;         /* 64-bit Extended General Purpose Event 0 Reg Blk address */
     ACPI_GENERIC_ADDRESS    XGpe1Block;         /* 64-bit Extended General Purpose Event 1 Reg Blk address */
-    ACPI_GENERIC_ADDRESS    SleepControl;       /* 64-bit Sleep Control register */
-    ACPI_GENERIC_ADDRESS    SleepStatus;        /* 64-bit Sleep Status register */
+    ACPI_GENERIC_ADDRESS    SleepControl;       /* 64-bit Sleep Control register (ACPI 5.0) */
+    ACPI_GENERIC_ADDRESS    SleepStatus;        /* 64-bit Sleep Status register (ACPI 5.0) */
+    UINT64                  HypervisorId;       /* Hypervisor Vendor ID (ACPI 6.0) */
 
 } ACPI_TABLE_FADT;
 
 
-/* Masks for FADT Boot Architecture Flags (BootFlags) */
+/* Masks for FADT IA-PC Boot Architecture Flags (boot_flags) [Vx]=Introduced in this FADT revision */
 
 #define ACPI_FADT_LEGACY_DEVICES    (1)         /* 00: [V2] System has LPC or ISA bus devices */
 #define ACPI_FADT_8042              (1<<1)      /* 01: [V3] System has an 8042 controller on port 60/64 */
@@ -313,15 +325,20 @@ typedef struct acpi_table_fadt
 #define ACPI_FADT_NO_ASPM           (1<<4)      /* 04: [V4] PCIe ASPM control must not be enabled */
 #define ACPI_FADT_NO_CMOS_RTC       (1<<5)      /* 05: [V5] No CMOS real-time clock present */
 
+/* Masks for FADT ARM Boot Architecture Flags (arm_boot_flags) ACPI 5.1 */
+
+#define ACPI_FADT_PSCI_COMPLIANT    (1)         /* 00: [V5+] PSCI 0.2+ is implemented */
+#define ACPI_FADT_PSCI_USE_HVC      (1<<1)      /* 01: [V5+] HVC must be used instead of SMC as the PSCI conduit */
+
 /* Masks for FADT flags */
 
-#define ACPI_FADT_WBINVD            (1)         /* 00: [V1] The wbinvd instruction works properly */
-#define ACPI_FADT_WBINVD_FLUSH      (1<<1)      /* 01: [V1] wbinvd flushes but does not invalidate caches */
+#define ACPI_FADT_WBINVD            (1)         /* 00: [V1] The WBINVD instruction works properly */
+#define ACPI_FADT_WBINVD_FLUSH      (1<<1)      /* 01: [V1] WBINVD flushes but does not invalidate caches */
 #define ACPI_FADT_C1_SUPPORTED      (1<<2)      /* 02: [V1] All processors support C1 state */
 #define ACPI_FADT_C2_MP_SUPPORTED   (1<<3)      /* 03: [V1] C2 state works on MP system */
 #define ACPI_FADT_POWER_BUTTON      (1<<4)      /* 04: [V1] Power button is handled as a control method device */
 #define ACPI_FADT_SLEEP_BUTTON      (1<<5)      /* 05: [V1] Sleep button is handled as a control method device */
-#define ACPI_FADT_FIXED_RTC         (1<<6)      /* 06: [V1] RTC wakeup status not in fixed register space */
+#define ACPI_FADT_FIXED_RTC         (1<<6)      /* 06: [V1] RTC wakeup status is not in fixed register space */
 #define ACPI_FADT_S4_RTC_WAKE       (1<<7)      /* 07: [V1] RTC alarm can wake system from S4 */
 #define ACPI_FADT_32BIT_TIMER       (1<<8)      /* 08: [V1] ACPI timer width is 32-bit (0=24-bit) */
 #define ACPI_FADT_DOCKING_SUPPORTED (1<<9)      /* 09: [V1] Docking supported */
@@ -339,9 +356,9 @@ typedef struct acpi_table_fadt
 #define ACPI_FADT_LOW_POWER_S0      (1<<21)     /* 21: [V5] S0 power savings are equal or better than S3 (ACPI 5.0) */
 
 
-/* Values for PreferredProfile (Prefered Power Management Profiles) */
+/* Values for PreferredProfile (Preferred Power Management Profiles) */
 
-enum AcpiPreferedPmProfiles
+enum AcpiPreferredPmProfiles
 {
     PM_UNSPECIFIED          = 0,
     PM_DESKTOP              = 1,
@@ -354,7 +371,7 @@ enum AcpiPreferedPmProfiles
     PM_TABLET               = 8
 };
 
-/* Values for SleepStatus and SleepControl registers (V5 FADT) */
+/* Values for SleepStatus and SleepControl registers (V5+ FADT) */
 
 #define ACPI_X_WAKE_STATUS          0x80
 #define ACPI_X_SLEEP_TYPE_MASK      0x1C
@@ -384,7 +401,7 @@ typedef struct acpi_table_desc
 {
     ACPI_PHYSICAL_ADDRESS           Address;
     ACPI_TABLE_HEADER               *Pointer;
-    UINT32                          Length;     /* Length fixed at 32 bits */
+    UINT32                          Length;     /* Length fixed at 32 bits (fixed in table header) */
     ACPI_NAME_UNION                 Signature;
     ACPI_OWNER_ID                   OwnerId;
     UINT8                           Flags;
@@ -393,12 +410,11 @@ typedef struct acpi_table_desc
 
 /* Masks for Flags field above */
 
-#define ACPI_TABLE_ORIGIN_UNKNOWN       (0)
-#define ACPI_TABLE_ORIGIN_MAPPED        (1)
-#define ACPI_TABLE_ORIGIN_ALLOCATED     (2)
-#define ACPI_TABLE_ORIGIN_OVERRIDE      (4)
-#define ACPI_TABLE_ORIGIN_MASK          (7)
-#define ACPI_TABLE_IS_LOADED            (8)
+#define ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL  (0) /* Virtual address, external maintained */
+#define ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL (1) /* Physical address, internally mapped */
+#define ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL  (2) /* Virtual address, internallly allocated */
+#define ACPI_TABLE_ORIGIN_MASK              (3)
+#define ACPI_TABLE_IS_LOADED                (8)
 
 
 /*
@@ -420,15 +436,19 @@ typedef struct acpi_table_desc
  * FADT is the bottom line as to what the version really is.
  *
  * For reference, the values below are as follows:
- *     FADT V1  size: 0x074
- *     FADT V2  size: 0x084
- *     FADT V3  size: 0x0F4
- *     FADT V4  size: 0x0F4
- *     FADT V5  size: 0x10C
+ *     FADT V1 size: 0x074
+ *     FADT V2 size: 0x084
+ *     FADT V3 size: 0x0F4
+ *     FADT V4 size: 0x0F4
+ *     FADT V5 size: 0x10C
+ *     FADT V6 size: 0x114
  */
 #define ACPI_FADT_V1_SIZE       (UINT32) (ACPI_FADT_OFFSET (Flags) + 4)
-#define ACPI_FADT_V2_SIZE       (UINT32) (ACPI_FADT_OFFSET (Reserved4[0]) + 3)
+#define ACPI_FADT_V2_SIZE       (UINT32) (ACPI_FADT_OFFSET (MinorRevision) + 1)
 #define ACPI_FADT_V3_SIZE       (UINT32) (ACPI_FADT_OFFSET (SleepControl))
-#define ACPI_FADT_V5_SIZE       (UINT32) (sizeof (ACPI_TABLE_FADT))
+#define ACPI_FADT_V5_SIZE       (UINT32) (ACPI_FADT_OFFSET (HypervisorId))
+#define ACPI_FADT_V6_SIZE       (UINT32) (sizeof (ACPI_TABLE_FADT))
+
+#define ACPI_FADT_CONFORMANCE   "ACPI 6.1 (FADT version 6)"
 
 #endif /* __ACTBL_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/actbl1.h b/usr/src/uts/intel/sys/acpi/actbl1.h
index 824135d3dd..0fe925a84b 100644
--- a/usr/src/uts/intel/sys/acpi/actbl1.h
+++ b/usr/src/uts/intel/sys/acpi/actbl1.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -73,6 +73,7 @@
 #define ACPI_SIG_SBST           "SBST"      /* Smart Battery Specification Table */
 #define ACPI_SIG_SLIT           "SLIT"      /* System Locality Distance Information Table */
 #define ACPI_SIG_SRAT           "SRAT"      /* System Resource Affinity Table */
+#define ACPI_SIG_NFIT           "NFIT"      /* NVDIMM Firmware Interface Table */
 
 
 /*
@@ -82,9 +83,15 @@
 #pragma pack(1)
 
 /*
- * Note about bitfields: The UINT8 type is used for bitfields in ACPI tables.
- * This is the only type that is even remotely portable. Anything else is not
- * portable, so do not use any other bitfield types.
+ * Note: C bitfields are not used for this reason:
+ *
+ * "Bitfields are great and easy to read, but unfortunately the C language
+ * does not specify the layout of bitfields in memory, which means they are
+ * essentially useless for dealing with packed data in on-disk formats or
+ * binary wire protocols." (Or ACPI tables and buffers.) "If you ask me,
+ * this decision was a design error in C. Ritchie could have picked an order
+ * and stuck with it." Norman Ramsey.
+ * See http://stackoverflow.com/a/1053662/41661
  */
 
 
@@ -130,7 +137,7 @@ typedef struct acpi_table_bert
 {
     ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
     UINT32                  RegionLength;       /* Length of the boot error region */
-    UINT64                  Address;            /* Physical addresss of the error region */
+    UINT64                  Address;            /* Physical address of the error region */
 
 } ACPI_TABLE_BERT;
 
@@ -261,7 +268,8 @@ enum AcpiEinjActions
     ACPI_EINJ_CHECK_BUSY_STATUS             = 6,
     ACPI_EINJ_GET_COMMAND_STATUS            = 7,
     ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS   = 8,
-    ACPI_EINJ_ACTION_RESERVED               = 9,     /* 9 and greater are reserved */
+    ACPI_EINJ_GET_EXECUTE_TIMINGS           = 9,
+    ACPI_EINJ_ACTION_RESERVED               = 10,    /* 10 and greater are reserved */
     ACPI_EINJ_TRIGGER_ERROR                 = 0xFF   /* Except for this value */
 };
 
@@ -390,7 +398,8 @@ enum AcpiErstActions
     ACPI_ERST_GET_ERROR_RANGE       = 13,
     ACPI_ERST_GET_ERROR_LENGTH      = 14,
     ACPI_ERST_GET_ERROR_ATTRIBUTES  = 15,
-    ACPI_ERST_ACTION_RESERVED       = 16    /* 16 and greater are reserved */
+    ACPI_ERST_EXECUTE_TIMINGS       = 16,
+    ACPI_ERST_ACTION_RESERVED       = 17    /* 17 and greater are reserved */
 };
 
 /* Values for Instruction field above */
@@ -482,7 +491,8 @@ enum AcpiHestTypes
     ACPI_HEST_TYPE_AER_ENDPOINT         = 7,
     ACPI_HEST_TYPE_AER_BRIDGE           = 8,
     ACPI_HEST_TYPE_GENERIC_ERROR        = 9,
-    ACPI_HEST_TYPE_RESERVED             = 10    /* 10 and greater are reserved */
+    ACPI_HEST_TYPE_GENERIC_ERROR_V2     = 10,
+    ACPI_HEST_TYPE_RESERVED             = 11    /* 11 and greater are reserved */
 };
 
 
@@ -518,7 +528,7 @@ typedef struct acpi_hest_aer_common
     UINT8                   Enabled;
     UINT32                  RecordsToPreallocate;
     UINT32                  MaxSectionsPerRecord;
-    UINT32                  Bus;
+    UINT32                  Bus;                    /* Bus and Segment numbers */
     UINT16                  Device;
     UINT16                  Function;
     UINT16                  DeviceControl;
@@ -535,6 +545,14 @@ typedef struct acpi_hest_aer_common
 #define ACPI_HEST_FIRMWARE_FIRST        (1)
 #define ACPI_HEST_GLOBAL                (1<<1)
 
+/*
+ * Macros to access the bus/segment numbers in Bus field above:
+ *  Bus number is encoded in bits 7:0
+ *  Segment number is encoded in bits 23:8
+ */
+#define ACPI_HEST_BUS(Bus)              ((Bus) & 0xFF)
+#define ACPI_HEST_SEGMENT(Bus)          (((Bus) >> 8) & 0xFFFF)
+
 
 /* Hardware Error Notification */
 
@@ -561,7 +579,13 @@ enum AcpiHestNotifyTypes
     ACPI_HEST_NOTIFY_LOCAL      = 2,
     ACPI_HEST_NOTIFY_SCI        = 3,
     ACPI_HEST_NOTIFY_NMI        = 4,
-    ACPI_HEST_NOTIFY_RESERVED   = 5     /* 5 and greater are reserved */
+    ACPI_HEST_NOTIFY_CMCI       = 5,    /* ACPI 5.0 */
+    ACPI_HEST_NOTIFY_MCE        = 6,    /* ACPI 5.0 */
+    ACPI_HEST_NOTIFY_GPIO       = 7,    /* ACPI 6.0 */
+    ACPI_HEST_NOTIFY_SEA        = 8,    /* ACPI 6.1 */
+    ACPI_HEST_NOTIFY_SEI        = 9,    /* ACPI 6.1 */
+    ACPI_HEST_NOTIFY_GSIV       = 10,   /* ACPI 6.1 */
+    ACPI_HEST_NOTIFY_RESERVED   = 11    /* 11 and greater are reserved */
 };
 
 /* Values for ConfigWriteEnable bitfield above */
@@ -680,6 +704,27 @@ typedef struct acpi_hest_generic
 } ACPI_HEST_GENERIC;
 
 
+/* 10: Generic Hardware Error Source, version 2 */
+
+typedef struct acpi_hest_generic_v2
+{
+    ACPI_HEST_HEADER        Header;
+    UINT16                  RelatedSourceId;
+    UINT8                   Reserved;
+    UINT8                   Enabled;
+    UINT32                  RecordsToPreallocate;
+    UINT32                  MaxSectionsPerRecord;
+    UINT32                  MaxRawDataLength;
+    ACPI_GENERIC_ADDRESS    ErrorStatusAddress;
+    ACPI_HEST_NOTIFY        Notify;
+    UINT32                  ErrorBlockLength;
+    ACPI_GENERIC_ADDRESS    ReadAckRegister;
+    UINT64                  ReadAckPreserve;
+    UINT64                  ReadAckWrite;
+
+} ACPI_HEST_GENERIC_V2;
+
+
 /* Generic Error Status block */
 
 typedef struct acpi_hest_generic_status
@@ -716,6 +761,35 @@ typedef struct acpi_hest_generic_data
 
 } ACPI_HEST_GENERIC_DATA;
 
+/* Extension for revision 0x0300 */
+
+typedef struct acpi_hest_generic_data_v300
+{
+    UINT8                   SectionType[16];
+    UINT32                  ErrorSeverity;
+    UINT16                  Revision;
+    UINT8                   ValidationBits;
+    UINT8                   Flags;
+    UINT32                  ErrorDataLength;
+    UINT8                   FruId[16];
+    UINT8                   FruText[20];
+    UINT64                  TimeStamp;
+
+} ACPI_HEST_GENERIC_DATA_V300;
+
+/* Values for ErrorSeverity above */
+
+#define ACPI_HEST_GEN_ERROR_RECOVERABLE     0
+#define ACPI_HEST_GEN_ERROR_FATAL           1
+#define ACPI_HEST_GEN_ERROR_CORRECTED       2
+#define ACPI_HEST_GEN_ERROR_NONE            3
+
+/* Flags for ValidationBits above */
+
+#define ACPI_HEST_GEN_VALID_FRU_ID          (1)
+#define ACPI_HEST_GEN_VALID_FRU_STRING      (1<<1)
+#define ACPI_HEST_GEN_VALID_TIMESTAMP       (1<<2)
+
 
 /*******************************************************************************
  *
@@ -746,25 +820,28 @@ typedef struct acpi_table_madt
 
 enum AcpiMadtType
 {
-    ACPI_MADT_TYPE_LOCAL_APIC           = 0,
-    ACPI_MADT_TYPE_IO_APIC              = 1,
-    ACPI_MADT_TYPE_INTERRUPT_OVERRIDE   = 2,
-    ACPI_MADT_TYPE_NMI_SOURCE           = 3,
-    ACPI_MADT_TYPE_LOCAL_APIC_NMI       = 4,
-    ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE  = 5,
-    ACPI_MADT_TYPE_IO_SAPIC             = 6,
-    ACPI_MADT_TYPE_LOCAL_SAPIC          = 7,
-    ACPI_MADT_TYPE_INTERRUPT_SOURCE     = 8,
-    ACPI_MADT_TYPE_LOCAL_X2APIC         = 9,
-    ACPI_MADT_TYPE_LOCAL_X2APIC_NMI     = 10,
-    ACPI_MADT_TYPE_GENERIC_INTERRUPT    = 11,
-    ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR  = 12,
-    ACPI_MADT_TYPE_RESERVED             = 13    /* 13 and greater are reserved */
+    ACPI_MADT_TYPE_LOCAL_APIC               = 0,
+    ACPI_MADT_TYPE_IO_APIC                  = 1,
+    ACPI_MADT_TYPE_INTERRUPT_OVERRIDE       = 2,
+    ACPI_MADT_TYPE_NMI_SOURCE               = 3,
+    ACPI_MADT_TYPE_LOCAL_APIC_NMI           = 4,
+    ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE      = 5,
+    ACPI_MADT_TYPE_IO_SAPIC                 = 6,
+    ACPI_MADT_TYPE_LOCAL_SAPIC              = 7,
+    ACPI_MADT_TYPE_INTERRUPT_SOURCE         = 8,
+    ACPI_MADT_TYPE_LOCAL_X2APIC             = 9,
+    ACPI_MADT_TYPE_LOCAL_X2APIC_NMI         = 10,
+    ACPI_MADT_TYPE_GENERIC_INTERRUPT        = 11,
+    ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR      = 12,
+    ACPI_MADT_TYPE_GENERIC_MSI_FRAME        = 13,
+    ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR    = 14,
+    ACPI_MADT_TYPE_GENERIC_TRANSLATOR       = 15,
+    ACPI_MADT_TYPE_RESERVED                 = 16    /* 16 and greater are reserved */
 };
 
 
 /*
- * MADT Sub-tables, correspond to Type in ACPI_SUBTABLE_HEADER
+ * MADT Subtables, correspond to Type in ACPI_SUBTABLE_HEADER
  */
 
 /* 0: Processor Local APIC */
@@ -914,24 +991,37 @@ typedef struct acpi_madt_local_x2apic_nmi
 } ACPI_MADT_LOCAL_X2APIC_NMI;
 
 
-/* 11: Generic Interrupt (ACPI 5.0) */
+/* 11: Generic Interrupt (ACPI 5.0 + ACPI 6.0 changes) */
 
 typedef struct acpi_madt_generic_interrupt
 {
     ACPI_SUBTABLE_HEADER    Header;
     UINT16                  Reserved;           /* Reserved - must be zero */
-    UINT32                  GicId;
+    UINT32                  CpuInterfaceNumber;
     UINT32                  Uid;
     UINT32                  Flags;
     UINT32                  ParkingVersion;
     UINT32                  PerformanceInterrupt;
     UINT64                  ParkedAddress;
     UINT64                  BaseAddress;
+    UINT64                  GicvBaseAddress;
+    UINT64                  GichBaseAddress;
+    UINT32                  VgicInterrupt;
+    UINT64                  GicrBaseAddress;
+    UINT64                  ArmMpidr;
+    UINT8                   EfficiencyClass;
+    UINT8                   Reserved2[3];
 
 } ACPI_MADT_GENERIC_INTERRUPT;
 
+/* Masks for Flags field above */
+
+/* ACPI_MADT_ENABLED                    (1)      Processor is usable if set */
+#define ACPI_MADT_PERFORMANCE_IRQ_MODE  (1<<1)  /* 01: Performance Interrupt Mode */
+#define ACPI_MADT_VGIC_IRQ_MODE         (1<<2)  /* 02: VGIC Maintenance Interrupt mode */
+
 
-/* 12: Generic Distributor (ACPI 5.0) */
+/* 12: Generic Distributor (ACPI 5.0 + ACPI 6.0 changes) */
 
 typedef struct acpi_madt_generic_distributor
 {
@@ -940,16 +1030,73 @@ typedef struct acpi_madt_generic_distributor
     UINT32                  GicId;
     UINT64                  BaseAddress;
     UINT32                  GlobalIrqBase;
-    UINT32                  Reserved2;          /* Reserved - must be zero */
+    UINT8                   Version;
+    UINT8                   Reserved2[3];       /* Reserved - must be zero */
 
 } ACPI_MADT_GENERIC_DISTRIBUTOR;
 
+/* Values for Version field above */
+
+enum AcpiMadtGicVersion
+{
+    ACPI_MADT_GIC_VERSION_NONE          = 0,
+    ACPI_MADT_GIC_VERSION_V1            = 1,
+    ACPI_MADT_GIC_VERSION_V2            = 2,
+    ACPI_MADT_GIC_VERSION_V3            = 3,
+    ACPI_MADT_GIC_VERSION_V4            = 4,
+    ACPI_MADT_GIC_VERSION_RESERVED      = 5     /* 5 and greater are reserved */
+};
+
+
+/* 13: Generic MSI Frame (ACPI 5.1) */
+
+typedef struct acpi_madt_generic_msi_frame
+{
+    ACPI_SUBTABLE_HEADER    Header;
+    UINT16                  Reserved;           /* Reserved - must be zero */
+    UINT32                  MsiFrameId;
+    UINT64                  BaseAddress;
+    UINT32                  Flags;
+    UINT16                  SpiCount;
+    UINT16                  SpiBase;
+
+} ACPI_MADT_GENERIC_MSI_FRAME;
+
+/* Masks for Flags field above */
+
+#define ACPI_MADT_OVERRIDE_SPI_VALUES   (1)
+
+
+/* 14: Generic Redistributor (ACPI 5.1) */
+
+typedef struct acpi_madt_generic_redistributor
+{
+    ACPI_SUBTABLE_HEADER    Header;
+    UINT16                  Reserved;           /* reserved - must be zero */
+    UINT64                  BaseAddress;
+    UINT32                  Length;
+
+} ACPI_MADT_GENERIC_REDISTRIBUTOR;
+
+
+/* 15: Generic Translator (ACPI 6.0) */
+
+typedef struct acpi_madt_generic_translator
+{
+    ACPI_SUBTABLE_HEADER    Header;
+    UINT16                  Reserved;           /* reserved - must be zero */
+    UINT32                  TranslationId;
+    UINT64                  BaseAddress;
+    UINT32                  Reserved2;
+
+} ACPI_MADT_GENERIC_TRANSLATOR;
+
 
 /*
  * Common flags fields for MADT subtables
  */
 
-/* MADT Local APIC flags (LapicFlags) and GIC flags */
+/* MADT Local APIC flags */
 
 #define ACPI_MADT_ENABLED           (1)         /* 00: Processor is usable if set */
 
@@ -1003,6 +1150,194 @@ typedef struct acpi_msct_proximity
 } ACPI_MSCT_PROXIMITY;
 
 
+/*******************************************************************************
+ *
+ * NFIT - NVDIMM Interface Table (ACPI 6.0+)
+ *        Version 1
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_nfit
+{
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+    UINT32                  Reserved;           /* Reserved, must be zero */
+
+} ACPI_TABLE_NFIT;
+
+/* Subtable header for NFIT */
+
+typedef struct acpi_nfit_header
+{
+    UINT16                   Type;
+    UINT16                   Length;
+
+} ACPI_NFIT_HEADER;
+
+
+/* Values for subtable type in ACPI_NFIT_HEADER */
+
+enum AcpiNfitType
+{
+    ACPI_NFIT_TYPE_SYSTEM_ADDRESS       = 0,
+    ACPI_NFIT_TYPE_MEMORY_MAP           = 1,
+    ACPI_NFIT_TYPE_INTERLEAVE           = 2,
+    ACPI_NFIT_TYPE_SMBIOS               = 3,
+    ACPI_NFIT_TYPE_CONTROL_REGION       = 4,
+    ACPI_NFIT_TYPE_DATA_REGION          = 5,
+    ACPI_NFIT_TYPE_FLUSH_ADDRESS        = 6,
+    ACPI_NFIT_TYPE_RESERVED             = 7     /* 7 and greater are reserved */
+};
+
+/*
+ * NFIT Subtables
+ */
+
+/* 0: System Physical Address Range Structure */
+
+typedef struct acpi_nfit_system_address
+{
+    ACPI_NFIT_HEADER        Header;
+    UINT16                  RangeIndex;
+    UINT16                  Flags;
+    UINT32                  Reserved;           /* Reseved, must be zero */
+    UINT32                  ProximityDomain;
+    UINT8                   RangeGuid[16];
+    UINT64                  Address;
+    UINT64                  Length;
+    UINT64                  MemoryMapping;
+
+} ACPI_NFIT_SYSTEM_ADDRESS;
+
+/* Flags */
+
+#define ACPI_NFIT_ADD_ONLINE_ONLY       (1)     /* 00: Add/Online Operation Only */
+#define ACPI_NFIT_PROXIMITY_VALID       (1<<1)  /* 01: Proximity Domain Valid */
+
+/* Range Type GUIDs appear in the include/acuuid.h file */
+
+
+/* 1: Memory Device to System Address Range Map Structure */
+
+typedef struct acpi_nfit_memory_map
+{
+    ACPI_NFIT_HEADER        Header;
+    UINT32                  DeviceHandle;
+    UINT16                  PhysicalId;
+    UINT16                  RegionId;
+    UINT16                  RangeIndex;
+    UINT16                  RegionIndex;
+    UINT64                  RegionSize;
+    UINT64                  RegionOffset;
+    UINT64                  Address;
+    UINT16                  InterleaveIndex;
+    UINT16                  InterleaveWays;
+    UINT16                  Flags;
+    UINT16                  Reserved;           /* Reserved, must be zero */
+
+} ACPI_NFIT_MEMORY_MAP;
+
+/* Flags */
+
+#define ACPI_NFIT_MEM_SAVE_FAILED       (1)     /* 00: Last SAVE to Memory Device failed */
+#define ACPI_NFIT_MEM_RESTORE_FAILED    (1<<1)  /* 01: Last RESTORE from Memory Device failed */
+#define ACPI_NFIT_MEM_FLUSH_FAILED      (1<<2)  /* 02: Platform flush failed */
+#define ACPI_NFIT_MEM_NOT_ARMED         (1<<3)  /* 03: Memory Device is not armed */
+#define ACPI_NFIT_MEM_HEALTH_OBSERVED   (1<<4)  /* 04: Memory Device observed SMART/health events */
+#define ACPI_NFIT_MEM_HEALTH_ENABLED    (1<<5)  /* 05: SMART/health events enabled */
+#define ACPI_NFIT_MEM_MAP_FAILED        (1<<6)  /* 06: Mapping to SPA failed */
+
+
+/* 2: Interleave Structure */
+
+typedef struct acpi_nfit_interleave
+{
+    ACPI_NFIT_HEADER        Header;
+    UINT16                  InterleaveIndex;
+    UINT16                  Reserved;           /* Reserved, must be zero */
+    UINT32                  LineCount;
+    UINT32                  LineSize;
+    UINT32                  LineOffset[1];      /* Variable length */
+
+} ACPI_NFIT_INTERLEAVE;
+
+
+/* 3: SMBIOS Management Information Structure */
+
+typedef struct acpi_nfit_smbios
+{
+    ACPI_NFIT_HEADER        Header;
+    UINT32                  Reserved;           /* Reserved, must be zero */
+    UINT8                   Data[1];            /* Variable length */
+
+} ACPI_NFIT_SMBIOS;
+
+
+/* 4: NVDIMM Control Region Structure */
+
+typedef struct acpi_nfit_control_region
+{
+    ACPI_NFIT_HEADER        Header;
+    UINT16                  RegionIndex;
+    UINT16                  VendorId;
+    UINT16                  DeviceId;
+    UINT16                  RevisionId;
+    UINT16                  SubsystemVendorId;
+    UINT16                  SubsystemDeviceId;
+    UINT16                  SubsystemRevisionId;
+    UINT8                   ValidFields;
+    UINT8                   ManufacturingLocation;
+    UINT16                  ManufacturingDate;
+    UINT8                   Reserved[2];        /* Reserved, must be zero */
+    UINT32                  SerialNumber;
+    UINT16                  Code;
+    UINT16                  Windows;
+    UINT64                  WindowSize;
+    UINT64                  CommandOffset;
+    UINT64                  CommandSize;
+    UINT64                  StatusOffset;
+    UINT64                  StatusSize;
+    UINT16                  Flags;
+    UINT8                   Reserved1[6];       /* Reserved, must be zero */
+
+} ACPI_NFIT_CONTROL_REGION;
+
+/* Flags */
+
+#define ACPI_NFIT_CONTROL_BUFFERED          (1)     /* Block Data Windows implementation is buffered */
+
+/* ValidFields bits */
+
+#define ACPI_NFIT_CONTROL_MFG_INFO_VALID    (1)     /* Manufacturing fields are valid */
+
+
+/* 5: NVDIMM Block Data Window Region Structure */
+
+typedef struct acpi_nfit_data_region
+{
+    ACPI_NFIT_HEADER        Header;
+    UINT16                  RegionIndex;
+    UINT16                  Windows;
+    UINT64                  Offset;
+    UINT64                  Size;
+    UINT64                  Capacity;
+    UINT64                  StartAddress;
+
+} ACPI_NFIT_DATA_REGION;
+
+
+/* 6: Flush Hint Address Structure */
+
+typedef struct acpi_nfit_flush_address
+{
+    ACPI_NFIT_HEADER        Header;
+    UINT32                  DeviceHandle;
+    UINT16                  HintCount;
+    UINT8                   Reserved[6];        /* Reserved, must be zero */
+    UINT64                  HintAddress[1];     /* Variable length */
+
+} ACPI_NFIT_FLUSH_ADDRESS;
+
+
 /*******************************************************************************
  *
  * SBST - Smart Battery Specification Table
@@ -1058,11 +1393,12 @@ enum AcpiSratType
     ACPI_SRAT_TYPE_CPU_AFFINITY         = 0,
     ACPI_SRAT_TYPE_MEMORY_AFFINITY      = 1,
     ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY  = 2,
-    ACPI_SRAT_TYPE_RESERVED             = 3     /* 3 and greater are reserved */
+    ACPI_SRAT_TYPE_GICC_AFFINITY        = 3,
+    ACPI_SRAT_TYPE_RESERVED             = 4     /* 4 and greater are reserved */
 };
 
 /*
- * SRAT Sub-tables, correspond to Type in ACPI_SUBTABLE_HEADER
+ * SRAT Subtables, correspond to Type in ACPI_SUBTABLE_HEADER
  */
 
 /* 0: Processor Local APIC/SAPIC Affinity */
@@ -1075,7 +1411,7 @@ typedef struct acpi_srat_cpu_affinity
     UINT32                  Flags;
     UINT8                   LocalSapicEid;
     UINT8                   ProximityDomainHi[3];
-    UINT32                  Reserved;           /* Reserved, must be zero */
+    UINT32                  ClockDomain;
 
 } ACPI_SRAT_CPU_AFFINITY;
 
@@ -1125,6 +1461,23 @@ typedef struct acpi_srat_x2apic_cpu_affinity
 #define ACPI_SRAT_CPU_ENABLED       (1)         /* 00: Use affinity structure */
 
 
+/* 3: GICC Affinity (ACPI 5.1) */
+
+typedef struct acpi_srat_gicc_affinity
+{
+    ACPI_SUBTABLE_HEADER    Header;
+    UINT32                  ProximityDomain;
+    UINT32                  AcpiProcessorUid;
+    UINT32                  Flags;
+    UINT32                  ClockDomain;
+
+} ACPI_SRAT_GICC_AFFINITY;
+
+/* Flags for ACPI_SRAT_GICC_AFFINITY */
+
+#define ACPI_SRAT_GICC_ENABLED     (1)         /* 00: Use affinity structure */
+
+
 /* Reset to default packing */
 
 #pragma pack()
diff --git a/usr/src/uts/intel/sys/acpi/actbl2.h b/usr/src/uts/intel/sys/acpi/actbl2.h
index 70c6a09a3c..625d33fab9 100644
--- a/usr/src/uts/intel/sys/acpi/actbl2.h
+++ b/usr/src/uts/intel/sys/acpi/actbl2.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -52,8 +52,8 @@
  * These tables are not consumed directly by the ACPICA subsystem, but are
  * included here to support device drivers and the AML disassembler.
  *
- * The tables in this file are defined by third-party specifications, and are
- * not defined directly by the ACPI specification itself.
+ * Generally, the tables in this file are defined by third-party specifications,
+ * and are not defined directly by the ACPI specification itself.
  *
  ******************************************************************************/
 
@@ -65,18 +65,26 @@
  */
 #define ACPI_SIG_ASF            "ASF!"      /* Alert Standard Format table */
 #define ACPI_SIG_BOOT           "BOOT"      /* Simple Boot Flag Table */
+#define ACPI_SIG_CSRT           "CSRT"      /* Core System Resource Table */
+#define ACPI_SIG_DBG2           "DBG2"      /* Debug Port table type 2 */
 #define ACPI_SIG_DBGP           "DBGP"      /* Debug Port table */
 #define ACPI_SIG_DMAR           "DMAR"      /* DMA Remapping table */
 #define ACPI_SIG_HPET           "HPET"      /* High Precision Event Timer table */
 #define ACPI_SIG_IBFT           "IBFT"      /* iSCSI Boot Firmware Table */
+#define ACPI_SIG_IORT           "IORT"      /* IO Remapping Table */
 #define ACPI_SIG_IVRS           "IVRS"      /* I/O Virtualization Reporting Structure */
+#define ACPI_SIG_LPIT           "LPIT"      /* Low Power Idle Table */
 #define ACPI_SIG_MCFG           "MCFG"      /* PCI Memory Mapped Configuration table */
 #define ACPI_SIG_MCHI           "MCHI"      /* Management Controller Host Interface table */
+#define ACPI_SIG_MSDM           "MSDM"      /* Microsoft Data Management Table */
+#define ACPI_SIG_MTMR           "MTMR"      /* MID Timer table */
 #define ACPI_SIG_SLIC           "SLIC"      /* Software Licensing Description Table */
 #define ACPI_SIG_SPCR           "SPCR"      /* Serial Port Console Redirection table */
 #define ACPI_SIG_SPMI           "SPMI"      /* Server Platform Management Interface table */
 #define ACPI_SIG_TCPA           "TCPA"      /* Trusted Computing Platform Alliance table */
+#define ACPI_SIG_TPM2           "TPM2"      /* Trusted Platform Module 2.0 H/W interface table */
 #define ACPI_SIG_UEFI           "UEFI"      /* Uefi Boot Optimization Table */
+#define ACPI_SIG_VRTC           "VRTC"      /* Virtual Real Time Clock Table */
 #define ACPI_SIG_WAET           "WAET"      /* Windows ACPI Emulated devices Table */
 #define ACPI_SIG_WDAT           "WDAT"      /* Watchdog Action Table */
 #define ACPI_SIG_WDDT           "WDDT"      /* Watchdog Timer Description Table */
@@ -98,9 +106,15 @@
 #pragma pack(1)
 
 /*
- * Note about bitfields: The UINT8 type is used for bitfields in ACPI tables.
- * This is the only type that is even remotely portable. Anything else is not
- * portable, so do not use any other bitfield types.
+ * Note: C bitfields are not used for this reason:
+ *
+ * "Bitfields are great and easy to read, but unfortunately the C language
+ * does not specify the layout of bitfields in memory, which means they are
+ * essentially useless for dealing with packed data in on-disk formats or
+ * binary wire protocols." (Or ACPI tables and buffers.) "If you ask me,
+ * this decision was a design error in C. Ritchie could have picked an order
+ * and stuck with it." Norman Ramsey.
+ * See http://stackoverflow.com/a/1053662/41661
  */
 
 
@@ -262,6 +276,163 @@ typedef struct acpi_table_boot
 } ACPI_TABLE_BOOT;
 
 
+/*******************************************************************************
+ *
+ * CSRT - Core System Resource Table
+ *        Version 0
+ *
+ * Conforms to the "Core System Resource Table (CSRT)", November 14, 2011
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_csrt
+{
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+
+} ACPI_TABLE_CSRT;
+
+
+/* Resource Group subtable */
+
+typedef struct acpi_csrt_group
+{
+    UINT32                  Length;
+    UINT32                  VendorId;
+    UINT32                  SubvendorId;
+    UINT16                  DeviceId;
+    UINT16                  SubdeviceId;
+    UINT16                  Revision;
+    UINT16                  Reserved;
+    UINT32                  SharedInfoLength;
+
+    /* Shared data immediately follows (Length = SharedInfoLength) */
+
+} ACPI_CSRT_GROUP;
+
+/* Shared Info subtable */
+
+typedef struct acpi_csrt_shared_info
+{
+    UINT16                  MajorVersion;
+    UINT16                  MinorVersion;
+    UINT32                  MmioBaseLow;
+    UINT32                  MmioBaseHigh;
+    UINT32                  GsiInterrupt;
+    UINT8                   InterruptPolarity;
+    UINT8                   InterruptMode;
+    UINT8                   NumChannels;
+    UINT8                   DmaAddressWidth;
+    UINT16                  BaseRequestLine;
+    UINT16                  NumHandshakeSignals;
+    UINT32                  MaxBlockSize;
+
+    /* Resource descriptors immediately follow (Length = Group Length - SharedInfoLength) */
+
+} ACPI_CSRT_SHARED_INFO;
+
+/* Resource Descriptor subtable */
+
+typedef struct acpi_csrt_descriptor
+{
+    UINT32                  Length;
+    UINT16                  Type;
+    UINT16                  Subtype;
+    UINT32                  Uid;
+
+    /* Resource-specific information immediately follows */
+
+} ACPI_CSRT_DESCRIPTOR;
+
+
+/* Resource Types */
+
+#define ACPI_CSRT_TYPE_INTERRUPT    0x0001
+#define ACPI_CSRT_TYPE_TIMER        0x0002
+#define ACPI_CSRT_TYPE_DMA          0x0003
+
+/* Resource Subtypes */
+
+#define ACPI_CSRT_XRUPT_LINE        0x0000
+#define ACPI_CSRT_XRUPT_CONTROLLER  0x0001
+#define ACPI_CSRT_TIMER             0x0000
+#define ACPI_CSRT_DMA_CHANNEL       0x0000
+#define ACPI_CSRT_DMA_CONTROLLER    0x0001
+
+
+/*******************************************************************************
+ *
+ * DBG2 - Debug Port Table 2
+ *        Version 0 (Both main table and subtables)
+ *
+ * Conforms to "Microsoft Debug Port Table 2 (DBG2)", December 10, 2015
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_dbg2
+{
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+    UINT32                  InfoOffset;
+    UINT32                  InfoCount;
+
+} ACPI_TABLE_DBG2;
+
+
+typedef struct acpi_dbg2_header
+{
+    UINT32                  InfoOffset;
+    UINT32                  InfoCount;
+
+} ACPI_DBG2_HEADER;
+
+
+/* Debug Device Information Subtable */
+
+typedef struct acpi_dbg2_device
+{
+    UINT8                   Revision;
+    UINT16                  Length;
+    UINT8                   RegisterCount;      /* Number of BaseAddress registers */
+    UINT16                  NamepathLength;
+    UINT16                  NamepathOffset;
+    UINT16                  OemDataLength;
+    UINT16                  OemDataOffset;
+    UINT16                  PortType;
+    UINT16                  PortSubtype;
+    UINT16                  Reserved;
+    UINT16                  BaseAddressOffset;
+    UINT16                  AddressSizeOffset;
+    /*
+     * Data that follows:
+     *    BaseAddress (required) - Each in 12-byte Generic Address Structure format.
+     *    AddressSize (required) - Array of UINT32 sizes corresponding to each BaseAddress register.
+     *    Namepath    (required) - Null terminated string. Single dot if not supported.
+     *    OemData     (optional) - Length is OemDataLength.
+     */
+} ACPI_DBG2_DEVICE;
+
+/* Types for PortType field above */
+
+#define ACPI_DBG2_SERIAL_PORT       0x8000
+#define ACPI_DBG2_1394_PORT         0x8001
+#define ACPI_DBG2_USB_PORT          0x8002
+#define ACPI_DBG2_NET_PORT          0x8003
+
+/* Subtypes for PortSubtype field above */
+
+#define ACPI_DBG2_16550_COMPATIBLE  0x0000
+#define ACPI_DBG2_16550_SUBSET      0x0001
+#define ACPI_DBG2_ARM_PL011         0x0003
+#define ACPI_DBG2_ARM_SBSA_32BIT    0x000D
+#define ACPI_DBG2_ARM_SBSA_GENERIC  0x000E
+#define ACPI_DBG2_ARM_DCC           0x000F
+#define ACPI_DBG2_BCM2835           0x0010
+
+#define ACPI_DBG2_1394_STANDARD     0x0000
+
+#define ACPI_DBG2_USB_XHCI          0x0000
+#define ACPI_DBG2_USB_EHCI          0x0001
+
+
 /*******************************************************************************
  *
  * DBGP - Debug Port table
@@ -287,7 +458,7 @@ typedef struct acpi_table_dbgp
  *        Version 1
  *
  * Conforms to "Intel Virtualization Technology for Directed I/O",
- * Version 1.2, Sept. 2008
+ * Version 2.3, October 2014
  *
  ******************************************************************************/
 
@@ -303,6 +474,8 @@ typedef struct acpi_table_dmar
 /* Masks for Flags field above */
 
 #define ACPI_DMAR_INTR_REMAP        (1)
+#define ACPI_DMAR_X2APIC_OPT_OUT    (1<<1)
+#define ACPI_DMAR_X2APIC_MODE       (1<<2)
 
 
 /* DMAR subtable header */
@@ -320,9 +493,10 @@ enum AcpiDmarType
 {
     ACPI_DMAR_TYPE_HARDWARE_UNIT        = 0,
     ACPI_DMAR_TYPE_RESERVED_MEMORY      = 1,
-    ACPI_DMAR_TYPE_ATSR                 = 2,
-    ACPI_DMAR_HARDWARE_AFFINITY         = 3,
-    ACPI_DMAR_TYPE_RESERVED             = 4     /* 4 and greater are reserved */
+    ACPI_DMAR_TYPE_ROOT_ATS             = 2,
+    ACPI_DMAR_TYPE_HARDWARE_AFFINITY    = 3,
+    ACPI_DMAR_TYPE_NAMESPACE            = 4,
+    ACPI_DMAR_TYPE_RESERVED             = 5     /* 5 and greater are reserved */
 };
 
 
@@ -338,7 +512,7 @@ typedef struct acpi_dmar_device_scope
 
 } ACPI_DMAR_DEVICE_SCOPE;
 
-/* Values for EntryType in ACPI_DMAR_DEVICE_SCOPE */
+/* Values for EntryType in ACPI_DMAR_DEVICE_SCOPE - device types */
 
 enum AcpiDmarScopeType
 {
@@ -347,7 +521,8 @@ enum AcpiDmarScopeType
     ACPI_DMAR_SCOPE_TYPE_BRIDGE         = 2,
     ACPI_DMAR_SCOPE_TYPE_IOAPIC         = 3,
     ACPI_DMAR_SCOPE_TYPE_HPET           = 4,
-    ACPI_DMAR_SCOPE_TYPE_RESERVED       = 5     /* 5 and greater are reserved */
+    ACPI_DMAR_SCOPE_TYPE_NAMESPACE      = 5,
+    ACPI_DMAR_SCOPE_TYPE_RESERVED       = 6     /* 6 and greater are reserved */
 };
 
 typedef struct acpi_dmar_pci_path
@@ -359,7 +534,7 @@ typedef struct acpi_dmar_pci_path
 
 
 /*
- * DMAR Sub-tables, correspond to Type in ACPI_DMAR_HEADER
+ * DMAR Subtables, correspond to Type in ACPI_DMAR_HEADER
  */
 
 /* 0: Hardware Unit Definition */
@@ -424,6 +599,18 @@ typedef struct acpi_dmar_rhsa
 } ACPI_DMAR_RHSA;
 
 
+/* 4: ACPI Namespace Device Declaration Structure */
+
+typedef struct acpi_dmar_andd
+{
+    ACPI_DMAR_HEADER        Header;
+    UINT8                   Reserved[3];
+    UINT8                   DeviceNumber;
+    char                    DeviceName[1];
+
+} ACPI_DMAR_ANDD;
+
+
 /*******************************************************************************
  *
  * HPET - High Precision Event Timer table
@@ -572,6 +759,177 @@ typedef struct acpi_ibft_target
 } ACPI_IBFT_TARGET;
 
 
+/*******************************************************************************
+ *
+ * IORT - IO Remapping Table
+ *
+ * Conforms to "IO Remapping Table System Software on ARM Platforms",
+ * Document number: ARM DEN 0049B, October 2015
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_iort
+{
+    ACPI_TABLE_HEADER       Header;
+    UINT32                  NodeCount;
+    UINT32                  NodeOffset;
+    UINT32                  Reserved;
+
+} ACPI_TABLE_IORT;
+
+
+/*
+ * IORT subtables
+ */
+typedef struct acpi_iort_node
+{
+    UINT8                   Type;
+    UINT16                  Length;
+    UINT8                   Revision;
+    UINT32                  Reserved;
+    UINT32                  MappingCount;
+    UINT32                  MappingOffset;
+    char                    NodeData[1];
+
+} ACPI_IORT_NODE;
+
+/* Values for subtable Type above */
+
+enum AcpiIortNodeType
+{
+    ACPI_IORT_NODE_ITS_GROUP            = 0x00,
+    ACPI_IORT_NODE_NAMED_COMPONENT      = 0x01,
+    ACPI_IORT_NODE_PCI_ROOT_COMPLEX     = 0x02,
+    ACPI_IORT_NODE_SMMU                 = 0x03,
+    ACPI_IORT_NODE_SMMU_V3              = 0x04
+};
+
+
+typedef struct acpi_iort_id_mapping
+{
+    UINT32                  InputBase;          /* Lowest value in input range */
+    UINT32                  IdCount;            /* Number of IDs */
+    UINT32                  OutputBase;         /* Lowest value in output range */
+    UINT32                  OutputReference;    /* A reference to the output node */
+    UINT32                  Flags;
+
+} ACPI_IORT_ID_MAPPING;
+
+/* Masks for Flags field above for IORT subtable */
+
+#define ACPI_IORT_ID_SINGLE_MAPPING (1)
+
+
+typedef struct acpi_iort_memory_access
+{
+    UINT32                  CacheCoherency;
+    UINT8                   Hints;
+    UINT16                  Reserved;
+    UINT8                   MemoryFlags;
+
+} ACPI_IORT_MEMORY_ACCESS;
+
+/* Values for CacheCoherency field above */
+
+#define ACPI_IORT_NODE_COHERENT         0x00000001  /* The device node is fully coherent */
+#define ACPI_IORT_NODE_NOT_COHERENT     0x00000000  /* The device node is not coherent */
+
+/* Masks for Hints field above */
+
+#define ACPI_IORT_HT_TRANSIENT          (1)
+#define ACPI_IORT_HT_WRITE              (1<<1)
+#define ACPI_IORT_HT_READ               (1<<2)
+#define ACPI_IORT_HT_OVERRIDE           (1<<3)
+
+/* Masks for MemoryFlags field above */
+
+#define ACPI_IORT_MF_COHERENCY          (1)
+#define ACPI_IORT_MF_ATTRIBUTES         (1<<1)
+
+
+/*
+ * IORT node specific subtables
+ */
+typedef struct acpi_iort_its_group
+{
+    UINT32                  ItsCount;
+    UINT32                  Identifiers[1];         /* GIC ITS identifier arrary */
+
+} ACPI_IORT_ITS_GROUP;
+
+
+typedef struct acpi_iort_named_component
+{
+    UINT32                  NodeFlags;
+    UINT64                  MemoryProperties;       /* Memory access properties */
+    UINT8                   MemoryAddressLimit;     /* Memory address size limit */
+    char                    DeviceName[1];          /* Path of namespace object */
+
+} ACPI_IORT_NAMED_COMPONENT;
+
+
+typedef struct acpi_iort_root_complex
+{
+    UINT64                  MemoryProperties;       /* Memory access properties */
+    UINT32                  AtsAttribute;
+    UINT32                  PciSegmentNumber;
+
+} ACPI_IORT_ROOT_COMPLEX;
+
+/* Values for AtsAttribute field above */
+
+#define ACPI_IORT_ATS_SUPPORTED         0x00000001  /* The root complex supports ATS */
+#define ACPI_IORT_ATS_UNSUPPORTED       0x00000000  /* The root complex doesn't support ATS */
+
+
+typedef struct acpi_iort_smmu
+{
+    UINT64                  BaseAddress;            /* SMMU base address */
+    UINT64                  Span;                   /* Length of memory range */
+    UINT32                  Model;
+    UINT32                  Flags;
+    UINT32                  GlobalInterruptOffset;
+    UINT32                  ContextInterruptCount;
+    UINT32                  ContextInterruptOffset;
+    UINT32                  PmuInterruptCount;
+    UINT32                  PmuInterruptOffset;
+    UINT64                  Interrupts[1];          /* Interrupt array */
+
+} ACPI_IORT_SMMU;
+
+/* Values for Model field above */
+
+#define ACPI_IORT_SMMU_V1               0x00000000  /* Generic SMMUv1 */
+#define ACPI_IORT_SMMU_V2               0x00000001  /* Generic SMMUv2 */
+#define ACPI_IORT_SMMU_CORELINK_MMU400  0x00000002  /* ARM Corelink MMU-400 */
+#define ACPI_IORT_SMMU_CORELINK_MMU500  0x00000003  /* ARM Corelink MMU-500 */
+
+/* Masks for Flags field above */
+
+#define ACPI_IORT_SMMU_DVM_SUPPORTED    (1)
+#define ACPI_IORT_SMMU_COHERENT_WALK    (1<<1)
+
+
+typedef struct acpi_iort_smmu_v3
+{
+    UINT64                  BaseAddress;            /* SMMUv3 base address */
+    UINT32                  Flags;
+    UINT32                  Reserved;
+    UINT64                  VatosAddress;
+    UINT32                  Model;                 /* O: generic SMMUv3 */
+    UINT32                  EventGsiv;
+    UINT32                  PriGsiv;
+    UINT32                  GerrGsiv;
+    UINT32                  SyncGsiv;
+
+} ACPI_IORT_SMMU_V3;
+
+/* Masks for Flags field above */
+
+#define ACPI_IORT_SMMU_V3_COHACC_OVERRIDE   (1)
+#define ACPI_IORT_SMMU_V3_HTTU_OVERRIDE     (1<<1)
+
+
 /*******************************************************************************
  *
  * IVRS - I/O Virtualization Reporting Structure
@@ -772,7 +1130,65 @@ typedef struct acpi_ivrs_memory
 
 /*******************************************************************************
  *
- * MCFG - PCI Memory Mapped Configuration table and sub-table
+ * LPIT - Low Power Idle Table
+ *
+ * Conforms to "ACPI Low Power Idle Table (LPIT)" July 2014.
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_lpit
+{
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+
+} ACPI_TABLE_LPIT;
+
+
+/* LPIT subtable header */
+
+typedef struct acpi_lpit_header
+{
+    UINT32                  Type;               /* Subtable type */
+    UINT32                  Length;             /* Subtable length */
+    UINT16                  UniqueId;
+    UINT16                  Reserved;
+    UINT32                  Flags;
+
+} ACPI_LPIT_HEADER;
+
+/* Values for subtable Type above */
+
+enum AcpiLpitType
+{
+    ACPI_LPIT_TYPE_NATIVE_CSTATE    = 0x00,
+    ACPI_LPIT_TYPE_RESERVED         = 0x01      /* 1 and above are reserved */
+};
+
+/* Masks for Flags field above  */
+
+#define ACPI_LPIT_STATE_DISABLED    (1)
+#define ACPI_LPIT_NO_COUNTER        (1<<1)
+
+/*
+ * LPIT subtables, correspond to Type in ACPI_LPIT_HEADER
+ */
+
+/* 0x00: Native C-state instruction based LPI structure */
+
+typedef struct acpi_lpit_native
+{
+    ACPI_LPIT_HEADER        Header;
+    ACPI_GENERIC_ADDRESS    EntryTrigger;
+    UINT32                  Residency;
+    UINT32                  Latency;
+    ACPI_GENERIC_ADDRESS    ResidencyCounter;
+    UINT64                  CounterFrequency;
+
+} ACPI_LPIT_NATIVE;
+
+
+/*******************************************************************************
+ *
+ * MCFG - PCI Memory Mapped Configuration table and subtable
  *        Version 1
  *
  * Conforms to "PCI Firmware Specification", Revision 3.0, June 20, 2005
@@ -831,86 +1247,75 @@ typedef struct acpi_table_mchi
 
 /*******************************************************************************
  *
- * SLIC - Software Licensing Description Table
- *        Version 1
+ * MSDM - Microsoft Data Management table
  *
- * Conforms to "OEM Activation 2.0 for Windows Vista Operating Systems",
- * Copyright 2006
+ * Conforms to "Microsoft Software Licensing Tables (SLIC and MSDM)",
+ * November 29, 2011. Copyright 2011 Microsoft
  *
  ******************************************************************************/
 
-/* Basic SLIC table is only the common ACPI header */
+/* Basic MSDM table is only the common ACPI header */
 
-typedef struct acpi_table_slic
+typedef struct acpi_table_msdm
 {
     ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
 
-} ACPI_TABLE_SLIC;
+} ACPI_TABLE_MSDM;
 
 
-/* Common SLIC subtable header */
+/*******************************************************************************
+ *
+ * MTMR - MID Timer Table
+ *        Version 1
+ *
+ * Conforms to "Simple Firmware Interface Specification",
+ * Draft 0.8.2, Oct 19, 2010
+ * NOTE: The ACPI MTMR is equivalent to the SFI MTMR table.
+ *
+ ******************************************************************************/
 
-typedef struct acpi_slic_header
+typedef struct acpi_table_mtmr
 {
-    UINT32                  Type;
-    UINT32                  Length;
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
 
-} ACPI_SLIC_HEADER;
+} ACPI_TABLE_MTMR;
 
-/* Values for Type field above */
+/* MTMR entry */
 
-enum AcpiSlicType
+typedef struct acpi_mtmr_entry
 {
-    ACPI_SLIC_TYPE_PUBLIC_KEY           = 0,
-    ACPI_SLIC_TYPE_WINDOWS_MARKER       = 1,
-    ACPI_SLIC_TYPE_RESERVED             = 2    /* 2 and greater are reserved */
-};
+    ACPI_GENERIC_ADDRESS    PhysicalAddress;
+    UINT32                  Frequency;
+    UINT32                  Irq;
 
+} ACPI_MTMR_ENTRY;
 
-/*
- * SLIC Sub-tables, correspond to Type in ACPI_SLIC_HEADER
- */
-
-/* 0: Public Key Structure */
-
-typedef struct acpi_slic_key
-{
-    ACPI_SLIC_HEADER        Header;
-    UINT8                   KeyType;
-    UINT8                   Version;
-    UINT16                  Reserved;
-    UINT32                  Algorithm;
-    char                    Magic[4];
-    UINT32                  BitLength;
-    UINT32                  Exponent;
-    UINT8                   Modulus[128];
-
-} ACPI_SLIC_KEY;
 
+/*******************************************************************************
+ *
+ * SLIC - Software Licensing Description Table
+ *
+ * Conforms to "Microsoft Software Licensing Tables (SLIC and MSDM)",
+ * November 29, 2011. Copyright 2011 Microsoft
+ *
+ ******************************************************************************/
 
-/* 1: Windows Marker Structure */
+/* Basic SLIC table is only the common ACPI header */
 
-typedef struct acpi_slic_marker
+typedef struct acpi_table_slic
 {
-    ACPI_SLIC_HEADER        Header;
-    UINT32                  Version;
-    char                    OemId[ACPI_OEM_ID_SIZE];            /* ASCII OEM identification */
-    char                    OemTableId[ACPI_OEM_TABLE_ID_SIZE]; /* ASCII OEM table identification */
-    char                    WindowsFlag[8];
-    UINT32                  SlicVersion;
-    UINT8                   Reserved[16];
-    UINT8                   Signature[128];
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
 
-} ACPI_SLIC_MARKER;
+} ACPI_TABLE_SLIC;
 
 
 /*******************************************************************************
  *
  * SPCR - Serial Port Console Redirection table
- *        Version 1
+ *        Version 2
  *
  * Conforms to "Serial Port Console Redirection Table",
- * Version 1.00, January 11, 2002
+ * Version 1.03, August 10, 2015
  *
  ******************************************************************************/
 
@@ -944,6 +1349,8 @@ typedef struct acpi_table_spcr
 
 #define ACPI_SPCR_DO_NOT_DISABLE    (1)
 
+/* Values for Interface Type: See the definition of the DBG2 table */
+
 
 /*******************************************************************************
  *
@@ -992,21 +1399,103 @@ enum AcpiSpmiInterfaceTypes
 /*******************************************************************************
  *
  * TCPA - Trusted Computing Platform Alliance table
- *        Version 1
+ *        Version 2
  *
- * Conforms to "TCG PC Specific Implementation Specification",
- * Version 1.1, August 18, 2003
+ * Conforms to "TCG ACPI Specification, Family 1.2 and 2.0",
+ * December 19, 2014
+ *
+ * NOTE: There are two versions of the table with the same signature --
+ * the client version and the server version. The common PlatformClass
+ * field is used to differentiate the two types of tables.
  *
  ******************************************************************************/
 
-typedef struct acpi_table_tcpa
+typedef struct acpi_table_tcpa_hdr
 {
     ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+    UINT16                  PlatformClass;
+
+} ACPI_TABLE_TCPA_HDR;
+
+/*
+ * Values for PlatformClass above.
+ * This is how the client and server subtables are differentiated
+ */
+#define ACPI_TCPA_CLIENT_TABLE          0
+#define ACPI_TCPA_SERVER_TABLE          1
+
+
+typedef struct acpi_table_tcpa_client
+{
+    UINT32                  MinimumLogLength;   /* Minimum length for the event log area */
+    UINT64                  LogAddress;         /* Address of the event log area */
+
+} ACPI_TABLE_TCPA_CLIENT;
+
+typedef struct acpi_table_tcpa_server
+{
     UINT16                  Reserved;
-    UINT32                  MaxLogLength;       /* Maximum length for the event log area */
+    UINT64                  MinimumLogLength;   /* Minimum length for the event log area */
     UINT64                  LogAddress;         /* Address of the event log area */
+    UINT16                  SpecRevision;
+    UINT8                   DeviceFlags;
+    UINT8                   InterruptFlags;
+    UINT8                   GpeNumber;
+    UINT8                   Reserved2[3];
+    UINT32                  GlobalInterrupt;
+    ACPI_GENERIC_ADDRESS    Address;
+    UINT32                  Reserved3;
+    ACPI_GENERIC_ADDRESS    ConfigAddress;
+    UINT8                   Group;
+    UINT8                   Bus;                /* PCI Bus/Segment/Function numbers */
+    UINT8                   Device;
+    UINT8                   Function;
+
+} ACPI_TABLE_TCPA_SERVER;
+
+/* Values for DeviceFlags above */
+
+#define ACPI_TCPA_PCI_DEVICE            (1)
+#define ACPI_TCPA_BUS_PNP               (1<<1)
+#define ACPI_TCPA_ADDRESS_VALID         (1<<2)
 
-} ACPI_TABLE_TCPA;
+/* Values for InterruptFlags above */
+
+#define ACPI_TCPA_INTERRUPT_MODE        (1)
+#define ACPI_TCPA_INTERRUPT_POLARITY    (1<<1)
+#define ACPI_TCPA_SCI_VIA_GPE           (1<<2)
+#define ACPI_TCPA_GLOBAL_INTERRUPT      (1<<3)
+
+
+/*******************************************************************************
+ *
+ * TPM2 - Trusted Platform Module (TPM) 2.0 Hardware Interface Table
+ *        Version 4
+ *
+ * Conforms to "TCG ACPI Specification, Family 1.2 and 2.0",
+ * December 19, 2014
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_tpm2
+{
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+    UINT16                  PlatformClass;
+    UINT16                  Reserved;
+    UINT64                  ControlAddress;
+    UINT32                  StartMethod;
+
+    /* Platform-specific data follows */
+
+} ACPI_TABLE_TPM2;
+
+/* Values for StartMethod above */
+
+#define ACPI_TPM2_NOT_ALLOWED                       0
+#define ACPI_TPM2_START_METHOD                      2
+#define ACPI_TPM2_MEMORY_MAPPED                     6
+#define ACPI_TPM2_COMMAND_BUFFER                    7
+#define ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD  8
 
 
 /*******************************************************************************
@@ -1028,6 +1517,33 @@ typedef struct acpi_table_uefi
 } ACPI_TABLE_UEFI;
 
 
+/*******************************************************************************
+ *
+ * VRTC - Virtual Real Time Clock Table
+ *        Version 1
+ *
+ * Conforms to "Simple Firmware Interface Specification",
+ * Draft 0.8.2, Oct 19, 2010
+ * NOTE: The ACPI VRTC is equivalent to The SFI MRTC table.
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_vrtc
+{
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+
+} ACPI_TABLE_VRTC;
+
+/* VRTC entry */
+
+typedef struct acpi_vrtc_entry
+{
+    ACPI_GENERIC_ADDRESS    PhysicalAddress;
+    UINT32                  Irq;
+
+} ACPI_VRTC_ENTRY;
+
+
 /*******************************************************************************
  *
  * WAET - Windows ACPI Emulated devices Table
@@ -1204,4 +1720,3 @@ typedef struct acpi_table_wdrt
 #pragma pack()
 
 #endif /* __ACTBL2_H__ */
-
diff --git a/usr/src/uts/intel/sys/acpi/actbl3.h b/usr/src/uts/intel/sys/acpi/actbl3.h
index c5dd4184dd..ef40f19fc0 100644
--- a/usr/src/uts/intel/sys/acpi/actbl3.h
+++ b/usr/src/uts/intel/sys/acpi/actbl3.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -52,7 +52,8 @@
  * These tables are not consumed directly by the ACPICA subsystem, but are
  * included here to support device drivers and the AML disassembler.
  *
- * The tables in this file are fully defined within the ACPI specification.
+ * In general, the tables in this file are fully defined within the ACPI
+ * specification.
  *
  ******************************************************************************/
 
@@ -70,17 +71,17 @@
 #define ACPI_SIG_PCCT           "PCCT"      /* Platform Communications Channel Table */
 #define ACPI_SIG_PMTT           "PMTT"      /* Platform Memory Topology Table */
 #define ACPI_SIG_RASF           "RASF"      /* RAS Feature table */
+#define ACPI_SIG_STAO           "STAO"      /* Status Override table */
+#define ACPI_SIG_WPBT           "WPBT"      /* Windows Platform Binary Table */
+#define ACPI_SIG_XENV           "XENV"      /* Xen Environment table */
 
 #define ACPI_SIG_S3PT           "S3PT"      /* S3 Performance (sub)Table */
 #define ACPI_SIG_PCCS           "PCC"       /* PCC Shared Memory Region */
 
 /* Reserved table signatures */
 
-#define ACPI_SIG_CSRT           "CSRT"      /* Core System Resources Table */
-#define ACPI_SIG_DBG2           "DBG2"      /* Debug Port table 2 */
 #define ACPI_SIG_MATR           "MATR"      /* Memory Address Translation Table */
 #define ACPI_SIG_MSDM           "MSDM"      /* Microsoft Data Management Table */
-#define ACPI_SIG_WPBT           "WPBT"      /* Windows Platform Binary Table */
 
 /*
  * All tables must be byte-packed to match the ACPI specification, since
@@ -89,9 +90,15 @@
 #pragma pack(1)
 
 /*
- * Note about bitfields: The UINT8 type is used for bitfields in ACPI tables.
- * This is the only type that is even remotely portable. Anything else is not
- * portable, so do not use any other bitfield types.
+ * Note: C bitfields are not used for this reason:
+ *
+ * "Bitfields are great and easy to read, but unfortunately the C language
+ * does not specify the layout of bitfields in memory, which means they are
+ * essentially useless for dealing with packed data in on-disk formats or
+ * binary wire protocols." (Or ACPI tables and buffers.) "If you ask me,
+ * this decision was a design error in C. Ritchie could have picked an order
+ * and stuck with it." Norman Ramsey.
+ * See http://stackoverflow.com/a/1053662/41661
  */
 
 
@@ -118,6 +125,8 @@ typedef struct acpi_table_bgrt
 /*******************************************************************************
  *
  * DRTM - Dynamic Root of Trust for Measurement table
+ * Conforms to "TCG D-RTM Architecture" June 17 2013, Version 1.0.0
+ * Table version 1
  *
  ******************************************************************************/
 
@@ -136,29 +145,50 @@ typedef struct acpi_table_drtm
 
 } ACPI_TABLE_DRTM;
 
-/* 1) Validated Tables List */
+/* Flag Definitions for above */
+
+#define ACPI_DRTM_ACCESS_ALLOWED            (1)
+#define ACPI_DRTM_ENABLE_GAP_CODE           (1<<1)
+#define ACPI_DRTM_INCOMPLETE_MEASUREMENTS   (1<<2)
+#define ACPI_DRTM_AUTHORITY_ORDER           (1<<3)
+
+
+/* 1) Validated Tables List (64-bit addresses) */
 
-typedef struct acpi_drtm_vtl_list
+typedef struct acpi_drtm_vtable_list
 {
-    UINT32                  ValidatedTableListCount;
+    UINT32                  ValidatedTableCount;
+    UINT64                  ValidatedTables[1];
 
-} ACPI_DRTM_VTL_LIST;
+} ACPI_DRTM_VTABLE_LIST;
+
+/* 2) Resources List (of Resource Descriptors) */
+
+/* Resource Descriptor */
+
+typedef struct acpi_drtm_resource
+{
+    UINT8                   Size[7];
+    UINT8                   Type;
+    UINT64                  Address;
 
-/* 2) Resources List */
+} ACPI_DRTM_RESOURCE;
 
 typedef struct acpi_drtm_resource_list
 {
-    UINT32                  ResourceListCount;
+    UINT32                  ResourceCount;
+    ACPI_DRTM_RESOURCE      Resources[1];
 
 } ACPI_DRTM_RESOURCE_LIST;
 
 /* 3) Platform-specific Identifiers List */
 
-typedef struct acpi_drtm_id_list
+typedef struct acpi_drtm_dps_id
 {
-    UINT32                  IdListCount;
+    UINT32                  DpsIdLength;
+    UINT8                   DpsId[16];
 
-} ACPI_DRTM_ID_LIST;
+} ACPI_DRTM_DPS_ID;
 
 
 /*******************************************************************************
@@ -175,7 +205,7 @@ typedef struct acpi_table_fpdt
 } ACPI_TABLE_FPDT;
 
 
-/* FPDT subtable header */
+/* FPDT subtable header (Performance Record Structure) */
 
 typedef struct acpi_fpdt_header
 {
@@ -190,7 +220,7 @@ typedef struct acpi_fpdt_header
 enum AcpiFpdtType
 {
     ACPI_FPDT_TYPE_BOOT                 = 0,
-    ACPI_FPDT_TYPE_S3PERF               = 1,
+    ACPI_FPDT_TYPE_S3PERF               = 1
 };
 
 
@@ -200,33 +230,29 @@ enum AcpiFpdtType
 
 /* 0: Firmware Basic Boot Performance Record */
 
-typedef struct acpi_fpdt_boot
+typedef struct acpi_fpdt_boot_pointer
 {
     ACPI_FPDT_HEADER        Header;
     UINT8                   Reserved[4];
-    UINT64                  ResetEnd;
-    UINT64                  LoadStart;
-    UINT64                  StartupStart;
-    UINT64                  ExitServicesEntry;
-    UINT64                  ExitServicesExit;
+    UINT64                  Address;
 
-} ACPI_FPDT_BOOT;
+} ACPI_FPDT_BOOT_POINTER;
 
 
 /* 1: S3 Performance Table Pointer Record */
 
-typedef struct acpi_fpdt_s3pt_ptr
+typedef struct acpi_fpdt_s3pt_pointer
 {
     ACPI_FPDT_HEADER        Header;
     UINT8                   Reserved[4];
     UINT64                  Address;
 
-} ACPI_FPDT_S3PT_PTR;
+} ACPI_FPDT_S3PT_POINTER;
 
 
 /*
  * S3PT - S3 Performance Table. This table is pointed to by the
- * FPDT S3 Pointer Record above.
+ * S3 Pointer Record above.
  */
 typedef struct acpi_table_s3pt
 {
@@ -237,27 +263,21 @@ typedef struct acpi_table_s3pt
 
 
 /*
- * S3PT Subtables
+ * S3PT Subtables (Not part of the actual FPDT)
  */
-typedef struct acpi_s3pt_header
-{
-    UINT16                  Type;
-    UINT8                   Length;
-    UINT8                   Revision;
-
-} ACPI_S3PT_HEADER;
 
-/* Values for Type field above */
+/* Values for Type field in S3PT header */
 
 enum AcpiS3ptType
 {
     ACPI_S3PT_TYPE_RESUME               = 0,
     ACPI_S3PT_TYPE_SUSPEND              = 1,
+    ACPI_FPDT_BOOT_PERFORMANCE          = 2
 };
 
 typedef struct acpi_s3pt_resume
 {
-    ACPI_S3PT_HEADER        Header;
+    ACPI_FPDT_HEADER        Header;
     UINT32                  ResumeCount;
     UINT64                  FullResume;
     UINT64                  AverageResume;
@@ -266,44 +286,140 @@ typedef struct acpi_s3pt_resume
 
 typedef struct acpi_s3pt_suspend
 {
-    ACPI_S3PT_HEADER        Header;
+    ACPI_FPDT_HEADER        Header;
     UINT64                  SuspendStart;
     UINT64                  SuspendEnd;
 
 } ACPI_S3PT_SUSPEND;
 
 
+/*
+ * FPDT Boot Performance Record (Not part of the actual FPDT)
+ */
+typedef struct acpi_fpdt_boot
+{
+    ACPI_FPDT_HEADER        Header;
+    UINT8                   Reserved[4];
+    UINT64                  ResetEnd;
+    UINT64                  LoadStart;
+    UINT64                  StartupStart;
+    UINT64                  ExitServicesEntry;
+    UINT64                  ExitServicesExit;
+
+} ACPI_FPDT_BOOT;
+
+
 /*******************************************************************************
  *
- * GTDT - Generic Timer Description Table (ACPI 5.0)
- *        Version 1
+ * GTDT - Generic Timer Description Table (ACPI 5.1)
+ *        Version 2
  *
  ******************************************************************************/
 
 typedef struct acpi_table_gtdt
 {
     ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
-    UINT64                  Address;
-    UINT32                  Flags;
-    UINT32                  SecurePl1Interrupt;
-    UINT32                  SecurePl1Flags;
-    UINT32                  NonSecurePl1Interrupt;
-    UINT32                  NonSecurePl1Flags;
+    UINT64                  CounterBlockAddresss;
+    UINT32                  Reserved;
+    UINT32                  SecureEl1Interrupt;
+    UINT32                  SecureEl1Flags;
+    UINT32                  NonSecureEl1Interrupt;
+    UINT32                  NonSecureEl1Flags;
     UINT32                  VirtualTimerInterrupt;
     UINT32                  VirtualTimerFlags;
-    UINT32                  NonSecurePl2Interrupt;
-    UINT32                  NonSecurePl2Flags;
+    UINT32                  NonSecureEl2Interrupt;
+    UINT32                  NonSecureEl2Flags;
+    UINT64                  CounterReadBlockAddress;
+    UINT32                  PlatformTimerCount;
+    UINT32                  PlatformTimerOffset;
 
 } ACPI_TABLE_GTDT;
 
-/* Values for Flags field above */
+/* Flag Definitions: Timer Block Physical Timers and Virtual timers */
+
+#define ACPI_GTDT_INTERRUPT_MODE        (1)
+#define ACPI_GTDT_INTERRUPT_POLARITY    (1<<1)
+#define ACPI_GTDT_ALWAYS_ON             (1<<2)
+
+
+/* Common GTDT subtable header */
 
-#define ACPI_GTDT_MAPPED_BLOCK_PRESENT      1
+typedef struct acpi_gtdt_header
+{
+    UINT8                   Type;
+    UINT16                  Length;
 
-/* Values for all "TimerFlags" fields above */
+} ACPI_GTDT_HEADER;
 
-#define ACPI_GTDT_INTERRUPT_MODE            1
-#define ACPI_GTDT_INTERRUPT_POLARITY        2
+/* Values for GTDT subtable type above */
+
+enum AcpiGtdtType
+{
+    ACPI_GTDT_TYPE_TIMER_BLOCK      = 0,
+    ACPI_GTDT_TYPE_WATCHDOG         = 1,
+    ACPI_GTDT_TYPE_RESERVED         = 2    /* 2 and greater are reserved */
+};
+
+
+/* GTDT Subtables, correspond to Type in acpi_gtdt_header */
+
+/* 0: Generic Timer Block */
+
+typedef struct acpi_gtdt_timer_block
+{
+    ACPI_GTDT_HEADER        Header;
+    UINT8                   Reserved;
+    UINT64                  BlockAddress;
+    UINT32                  TimerCount;
+    UINT32                  TimerOffset;
+
+} ACPI_GTDT_TIMER_BLOCK;
+
+/* Timer Sub-Structure, one per timer */
+
+typedef struct acpi_gtdt_timer_entry
+{
+    UINT8                   FrameNumber;
+    UINT8                   Reserved[3];
+    UINT64                  BaseAddress;
+    UINT64                  El0BaseAddress;
+    UINT32                  TimerInterrupt;
+    UINT32                  TimerFlags;
+    UINT32                  VirtualTimerInterrupt;
+    UINT32                  VirtualTimerFlags;
+    UINT32                  CommonFlags;
+
+} ACPI_GTDT_TIMER_ENTRY;
+
+/* Flag Definitions: TimerFlags and VirtualTimerFlags above */
+
+#define ACPI_GTDT_GT_IRQ_MODE               (1)
+#define ACPI_GTDT_GT_IRQ_POLARITY           (1<<1)
+
+/* Flag Definitions: CommonFlags above */
+
+#define ACPI_GTDT_GT_IS_SECURE_TIMER        (1)
+#define ACPI_GTDT_GT_ALWAYS_ON              (1<<1)
+
+
+/* 1: SBSA Generic Watchdog Structure */
+
+typedef struct acpi_gtdt_watchdog
+{
+    ACPI_GTDT_HEADER        Header;
+    UINT8                   Reserved;
+    UINT64                  RefreshFrameAddress;
+    UINT64                  ControlFrameAddress;
+    UINT32                  TimerInterrupt;
+    UINT32                  TimerFlags;
+
+} ACPI_GTDT_WATCHDOG;
+
+/* Flag Definitions: TimerFlags above */
+
+#define ACPI_GTDT_WATCHDOG_IRQ_MODE         (1)
+#define ACPI_GTDT_WATCHDOG_IRQ_POLARITY     (1<<1)
+#define ACPI_GTDT_WATCHDOG_SECURE           (1<<2)
 
 
 /*******************************************************************************
@@ -314,10 +430,10 @@ typedef struct acpi_table_gtdt
  ******************************************************************************/
 
 #define ACPI_MPST_CHANNEL_INFO \
-    UINT16                  Reserved1; \
     UINT8                   ChannelId; \
-    UINT8                   Reserved2; \
-    UINT16                  PowerNodeCount;
+    UINT8                   Reserved1[3]; \
+    UINT16                  PowerNodeCount; \
+    UINT16                  Reserved2;
 
 /* Main table */
 
@@ -348,9 +464,8 @@ typedef struct acpi_mpst_power_node
     UINT32                  Length;
     UINT64                  RangeAddress;
     UINT64                  RangeLength;
-    UINT8                   NumPowerStates;
-    UINT8                   NumPhysicalComponents;
-    UINT16                  Reserved2;
+    UINT32                  NumPowerStates;
+    UINT32                  NumPhysicalComponents;
 
 } ACPI_MPST_POWER_NODE;
 
@@ -385,12 +500,13 @@ typedef struct acpi_mpst_component
 typedef struct acpi_mpst_data_hdr
 {
     UINT16                  CharacteristicsCount;
+    UINT16                  Reserved;
 
 } ACPI_MPST_DATA_HDR;
 
 typedef struct acpi_mpst_power_data
 {
-    UINT8                   Revision;
+    UINT8                   StructureId;
     UINT8                   Flags;
     UINT16                  Reserved1;
     UINT32                  AveragePower;
@@ -414,10 +530,10 @@ typedef struct acpi_mpst_shared
     UINT32                  Signature;
     UINT16                  PccCommand;
     UINT16                  PccStatus;
-    UINT16                  CommandRegister;
-    UINT16                  StatusRegister;
-    UINT16                  PowerStateId;
-    UINT16                  PowerNodeId;
+    UINT32                  CommandRegister;
+    UINT32                  StatusRegister;
+    UINT32                  PowerStateId;
+    UINT32                  PowerNodeId;
     UINT64                  EnergyConsumed;
     UINT64                  AveragePower;
 
@@ -435,8 +551,7 @@ typedef struct acpi_table_pcct
 {
     ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
     UINT32                  Flags;
-    UINT32                  Latency;
-    UINT32                  Reserved;
+    UINT64                  Reserved;
 
 } ACPI_TABLE_PCCT;
 
@@ -444,8 +559,18 @@ typedef struct acpi_table_pcct
 
 #define ACPI_PCCT_DOORBELL              1
 
+/* Values for subtable type in ACPI_SUBTABLE_HEADER */
+
+enum AcpiPcctType
+{
+    ACPI_PCCT_TYPE_GENERIC_SUBSPACE             = 0,
+    ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE          = 1,
+    ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2    = 2,    /* ACPI 6.1 */
+    ACPI_PCCT_TYPE_RESERVED                     = 3     /* 3 and greater are reserved */
+};
+
 /*
- * PCCT subtables
+ * PCCT Subtables, correspond to Type in ACPI_SUBTABLE_HEADER
  */
 
 /* 0: Generic Communications Subspace */
@@ -459,10 +584,62 @@ typedef struct acpi_pcct_subspace
     ACPI_GENERIC_ADDRESS    DoorbellRegister;
     UINT64                  PreserveMask;
     UINT64                  WriteMask;
+    UINT32                  Latency;
+    UINT32                  MaxAccessRate;
+    UINT16                  MinTurnaroundTime;
 
 } ACPI_PCCT_SUBSPACE;
 
 
+/* 1: HW-reduced Communications Subspace (ACPI 5.1) */
+
+typedef struct acpi_pcct_hw_reduced
+{
+    ACPI_SUBTABLE_HEADER    Header;
+    UINT32                  DoorbellInterrupt;
+    UINT8                   Flags;
+    UINT8                   Reserved;
+    UINT64                  BaseAddress;
+    UINT64                  Length;
+    ACPI_GENERIC_ADDRESS    DoorbellRegister;
+    UINT64                  PreserveMask;
+    UINT64                  WriteMask;
+    UINT32                  Latency;
+    UINT32                  MaxAccessRate;
+    UINT16                  MinTurnaroundTime;
+
+} ACPI_PCCT_HW_REDUCED;
+
+
+/* 2: HW-reduced Communications Subspace Type 2 (ACPI 6.1) */
+
+typedef struct acpi_pcct_hw_reduced_type2
+{
+    ACPI_SUBTABLE_HEADER    Header;
+    UINT32                  DoorbellInterrupt;
+    UINT8                   Flags;
+    UINT8                   Reserved;
+    UINT64                  BaseAddress;
+    UINT64                  Length;
+    ACPI_GENERIC_ADDRESS    DoorbellRegister;
+    UINT64                  PreserveMask;
+    UINT64                  WriteMask;
+    UINT32                  Latency;
+    UINT32                  MaxAccessRate;
+    UINT16                  MinTurnaroundTime;
+    ACPI_GENERIC_ADDRESS    DoorbellAckRegister;
+    UINT64                  AckPreserveMask;
+    UINT64                  AckWriteMask;
+
+} ACPI_PCCT_HW_REDUCED_TYPE2;
+
+
+/* Values for doorbell flags above */
+
+#define ACPI_PCCT_INTERRUPT_POLARITY    (1)
+#define ACPI_PCCT_INTERRUPT_MODE        (1<<1)
+
+
 /*
  * PCC memory structures (not part of the ACPI table)
  */
@@ -594,28 +771,67 @@ typedef struct acpi_rasf_shared_memory
     UINT32                  Signature;
     UINT16                  Command;
     UINT16                  Status;
-    UINT64                  RequestedAddress;
-    UINT64                  RequestedLength;
-    UINT64                  ActualAddress;
-    UINT64                  ActualLength;
-    UINT16                  Flags;
-    UINT8                   Speed;
+    UINT16                  Version;
+    UINT8                   Capabilities[16];
+    UINT8                   SetCapabilities[16];
+    UINT16                  NumParameterBlocks;
+    UINT32                  SetCapabilitiesStatus;
 
 } ACPI_RASF_SHARED_MEMORY;
 
+/* RASF Parameter Block Structure Header */
+
+typedef struct acpi_rasf_parameter_block
+{
+    UINT16                  Type;
+    UINT16                  Version;
+    UINT16                  Length;
+
+} ACPI_RASF_PARAMETER_BLOCK;
+
+/* RASF Parameter Block Structure for PATROL_SCRUB */
+
+typedef struct acpi_rasf_patrol_scrub_parameter
+{
+    ACPI_RASF_PARAMETER_BLOCK   Header;
+    UINT16                      PatrolScrubCommand;
+    UINT64                      RequestedAddressRange[2];
+    UINT64                      ActualAddressRange[2];
+    UINT16                      Flags;
+    UINT8                       RequestedSpeed;
+
+} ACPI_RASF_PATROL_SCRUB_PARAMETER;
+
 /* Masks for Flags and Speed fields above */
 
 #define ACPI_RASF_SCRUBBER_RUNNING      1
 #define ACPI_RASF_SPEED                 (7<<1)
+#define ACPI_RASF_SPEED_SLOW            (0<<1)
+#define ACPI_RASF_SPEED_MEDIUM          (4<<1)
+#define ACPI_RASF_SPEED_FAST            (7<<1)
 
 /* Channel Commands */
 
 enum AcpiRasfCommands
 {
-    ACPI_RASF_GET_RAS_CAPABILITIES      = 1,
-    ACPI_RASF_GET_PATROL_PARAMETERS     = 2,
-    ACPI_RASF_START_PATROL_SCRUBBER     = 3,
-    ACPI_RASF_STOP_PATROL_SCRUBBER      = 4
+    ACPI_RASF_EXECUTE_RASF_COMMAND      = 1
+};
+
+/* Platform RAS Capabilities */
+
+enum AcpiRasfCapabiliities
+{
+    ACPI_HW_PATROL_SCRUB_SUPPORTED      = 0,
+    ACPI_SW_PATROL_SCRUB_EXPOSED        = 1
+};
+
+/* Patrol Scrub Commands */
+
+enum AcpiRasfPatrolScrubCommands
+{
+    ACPI_RASF_GET_PATROL_PARAMETERS     = 1,
+    ACPI_RASF_START_PATROL_SCRUBBER     = 2,
+    ACPI_RASF_STOP_PATROL_SCRUBBER      = 3
 };
 
 /* Channel Command flags */
@@ -643,6 +859,65 @@ enum AcpiRasfStatus
 #define ACPI_RASF_STATUS                (0x1F<<3)
 
 
+/*******************************************************************************
+ *
+ * STAO - Status Override Table (_STA override) - ACPI 6.0
+ *        Version 1
+ *
+ * Conforms to "ACPI Specification for Status Override Table"
+ * 6 January 2015
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_stao
+{
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+    UINT8                   IgnoreUart;
+
+} ACPI_TABLE_STAO;
+
+
+/*******************************************************************************
+ *
+ * WPBT - Windows Platform Environment Table (ACPI 6.0)
+ *        Version 1
+ *
+ * Conforms to "Windows Platform Binary Table (WPBT)" 29 November 2011
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_wpbt
+{
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+    UINT32                  HandoffSize;
+    UINT64                  HandoffAddress;
+    UINT8                   Layout;
+    UINT8                   Type;
+    UINT16                  ArgumentsLength;
+
+} ACPI_TABLE_WPBT;
+
+
+/*******************************************************************************
+ *
+ * XENV - Xen Environment Table (ACPI 6.0)
+ *        Version 1
+ *
+ * Conforms to "ACPI Specification for Xen Environment Table" 4 January 2015
+ *
+ ******************************************************************************/
+
+typedef struct acpi_table_xenv
+{
+    ACPI_TABLE_HEADER       Header;             /* Common ACPI table header */
+    UINT64                  GrantTableAddress;
+    UINT64                  GrantTableSize;
+    UINT32                  EventInterrupt;
+    UINT8                   EventFlags;
+
+} ACPI_TABLE_XENV;
+
+
 /* Reset to default packing */
 
 #pragma pack()
diff --git a/usr/src/uts/intel/sys/acpi/actypes.h b/usr/src/uts/intel/sys/acpi/actypes.h
index 4a5188544e..395b915383 100644
--- a/usr/src/uts/intel/sys/acpi/actypes.h
+++ b/usr/src/uts/intel/sys/acpi/actypes.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -55,8 +55,6 @@
 #error ACPI_MACHINE_WIDTH not defined
 #endif
 
-/*! [Begin] no source code translation */
-
 /*
  * Data type ranges
  * Note: These macros are designed to be compiler independent as well as
@@ -124,13 +122,16 @@
  *
  ******************************************************************************/
 
+#ifndef ACPI_USE_SYSTEM_INTTYPES
+
 typedef unsigned char                   BOOLEAN;
 typedef unsigned char                   UINT8;
 typedef unsigned short                  UINT16;
+typedef short                           INT16;
 typedef COMPILER_DEPENDENT_UINT64       UINT64;
 typedef COMPILER_DEPENDENT_INT64        INT64;
 
-/*! [End] no source code translation !*/
+#endif /* ACPI_USE_SYSTEM_INTTYPES */
 
 /*
  * Value returned by AcpiOsGetThreadId. There is no standard "thread_id"
@@ -151,12 +152,12 @@ typedef COMPILER_DEPENDENT_INT64        INT64;
 
 #if ACPI_MACHINE_WIDTH == 64
 
-/*! [Begin] no source code translation (keep the typedefs as-is) */
+#ifndef ACPI_USE_SYSTEM_INTTYPES
 
 typedef unsigned int                    UINT32;
 typedef int                             INT32;
 
-/*! [End] no source code translation !*/
+#endif /* ACPI_USE_SYSTEM_INTTYPES */
 
 
 typedef INT64                           ACPI_NATIVE_INT;
@@ -190,19 +191,39 @@ typedef UINT64                          ACPI_PHYSICAL_ADDRESS;
 
 #elif ACPI_MACHINE_WIDTH == 32
 
-/*! [Begin] no source code translation (keep the typedefs as-is) */
+#ifndef ACPI_USE_SYSTEM_INTTYPES
 
 typedef unsigned int                    UINT32;
 typedef int                             INT32;
 
-/*! [End] no source code translation !*/
+#endif /* ACPI_USE_SYSTEM_INTTYPES */
 
 
 typedef INT32                           ACPI_NATIVE_INT;
 typedef UINT32                          ACPI_SIZE;
+
+#ifdef ACPI_32BIT_PHYSICAL_ADDRESS
+
+/*
+ * OSPMs can define this to shrink the size of the structures for 32-bit
+ * none PAE environment. ASL compiler may always define this to generate
+ * 32-bit OSPM compliant tables.
+ */
 typedef UINT32                          ACPI_IO_ADDRESS;
 typedef UINT32                          ACPI_PHYSICAL_ADDRESS;
 
+#else /* ACPI_32BIT_PHYSICAL_ADDRESS */
+
+/*
+ * It is reported that, after some calculations, the physical addresses can
+ * wrap over the 32-bit boundary on 32-bit PAE environment.
+ * https://bugzilla.kernel.org/show_bug.cgi?id=87971
+ */
+typedef UINT64                          ACPI_IO_ADDRESS;
+typedef UINT64                          ACPI_PHYSICAL_ADDRESS;
+
+#endif /* ACPI_32BIT_PHYSICAL_ADDRESS */
+
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
@@ -295,7 +316,7 @@ typedef UINT32                          ACPI_PHYSICAL_ADDRESS;
 /*
  * Some compilers complain about unused variables. Sometimes we don't want to
  * use all the variables (for example, _AcpiModuleName). This allows us
- * to to tell the compiler in a per-variable manner that a variable
+ * to tell the compiler in a per-variable manner that a variable
  * is unused
  */
 #ifndef ACPI_UNUSED_VAR
@@ -303,13 +324,69 @@ typedef UINT32                          ACPI_PHYSICAL_ADDRESS;
 #endif
 
 /*
- * All ACPICA functions that are available to the rest of the kernel are
- * tagged with this macro which can be defined as appropriate for the host.
+ * All ACPICA external functions that are available to the rest of the kernel
+ * are tagged with thes macros which can be defined as appropriate for the host.
+ *
+ * Notes:
+ * ACPI_EXPORT_SYMBOL_INIT is used for initialization and termination
+ * interfaces that may need special processing.
+ * ACPI_EXPORT_SYMBOL is used for all other public external functions.
  */
+#ifndef ACPI_EXPORT_SYMBOL_INIT
+#define ACPI_EXPORT_SYMBOL_INIT(Symbol)
+#endif
+
 #ifndef ACPI_EXPORT_SYMBOL
 #define ACPI_EXPORT_SYMBOL(Symbol)
 #endif
 
+/*
+ * Compiler/Clibrary-dependent debug initialization. Used for ACPICA
+ * utilities only.
+ */
+#ifndef ACPI_DEBUG_INITIALIZE
+#define ACPI_DEBUG_INITIALIZE()
+#endif
+
+
+/*******************************************************************************
+ *
+ * Configuration
+ *
+ ******************************************************************************/
+
+#ifdef ACPI_NO_MEM_ALLOCATIONS
+
+#define ACPI_ALLOCATE(a)                NULL
+#define ACPI_ALLOCATE_ZEROED(a)         NULL
+#define ACPI_FREE(a)
+#define ACPI_MEM_TRACKING(a)
+
+#else /* ACPI_NO_MEM_ALLOCATIONS */
+
+#ifdef ACPI_DBG_TRACK_ALLOCATIONS
+/*
+ * Memory allocation tracking (used by AcpiExec to detect memory leaks)
+ */
+#define ACPI_MEM_PARAMETERS             _COMPONENT, _AcpiModuleName, __LINE__
+#define ACPI_ALLOCATE(a)                AcpiUtAllocateAndTrack ((ACPI_SIZE) (a), ACPI_MEM_PARAMETERS)
+#define ACPI_ALLOCATE_ZEROED(a)         AcpiUtAllocateZeroedAndTrack ((ACPI_SIZE) (a), ACPI_MEM_PARAMETERS)
+#define ACPI_FREE(a)                    AcpiUtFreeAndTrack (a, ACPI_MEM_PARAMETERS)
+#define ACPI_MEM_TRACKING(a)            a
+
+#else
+/*
+ * Normal memory allocation directly via the OS services layer
+ */
+#define ACPI_ALLOCATE(a)                AcpiOsAllocate ((ACPI_SIZE) (a))
+#define ACPI_ALLOCATE_ZEROED(a)         AcpiOsAllocateZeroed ((ACPI_SIZE) (a))
+#define ACPI_FREE(a)                    AcpiOsFree (a)
+#define ACPI_MEM_TRACKING(a)
+
+#endif /* ACPI_DBG_TRACK_ALLOCATIONS */
+
+#endif /* ACPI_NO_MEM_ALLOCATIONS */
+
 
 /******************************************************************************
  *
@@ -327,6 +404,7 @@ typedef UINT32                          ACPI_PHYSICAL_ADDRESS;
 #define ACPI_PM1_REGISTER_WIDTH         16
 #define ACPI_PM2_REGISTER_WIDTH         8
 #define ACPI_PM_TIMER_WIDTH             32
+#define ACPI_RESET_REGISTER_WIDTH       8
 
 /* Names within the namespace are 4 bytes long */
 
@@ -346,7 +424,7 @@ typedef UINT32                          ACPI_PHYSICAL_ADDRESS;
 
 /* PM Timer ticks per second (HZ) */
 
-#define PM_TIMER_FREQUENCY              3579545
+#define ACPI_PM_TIMER_FREQUENCY         3579545
 
 
 /*******************************************************************************
@@ -381,6 +459,22 @@ typedef char *                          ACPI_STRING;    /* Null terminated ASCII
 typedef void *                          ACPI_HANDLE;    /* Actually a ptr to a NS Node */
 
 
+/* Time constants for timer calculations */
+
+#define ACPI_MSEC_PER_SEC               1000L
+
+#define ACPI_USEC_PER_MSEC              1000L
+#define ACPI_USEC_PER_SEC               1000000L
+
+#define ACPI_100NSEC_PER_USEC           10L
+#define ACPI_100NSEC_PER_MSEC           10000L
+#define ACPI_100NSEC_PER_SEC            10000000L
+
+#define ACPI_NSEC_PER_USEC              1000L
+#define ACPI_NSEC_PER_MSEC              1000000L
+#define ACPI_NSEC_PER_SEC               1000000000L
+
+
 /* Owner IDs are used to track namespace nodes for selective deletion */
 
 typedef UINT8                           ACPI_OWNER_ID;
@@ -444,22 +538,32 @@ typedef UINT64                          ACPI_INTEGER;
 #define ACPI_CAST_PTR(t, p)             ((t *) (ACPI_UINTPTR_T) (p))
 #define ACPI_CAST_INDIRECT_PTR(t, p)    ((t **) (ACPI_UINTPTR_T) (p))
 #define ACPI_ADD_PTR(t, a, b)           ACPI_CAST_PTR (t, (ACPI_CAST_PTR (UINT8, (a)) + (ACPI_SIZE)(b)))
+#define ACPI_SUB_PTR(t, a, b)           ACPI_CAST_PTR (t, (ACPI_CAST_PTR (UINT8, (a)) - (ACPI_SIZE)(b)))
 #define ACPI_PTR_DIFF(a, b)             (ACPI_SIZE) (ACPI_CAST_PTR (UINT8, (a)) - ACPI_CAST_PTR (UINT8, (b)))
 
 /* Pointer/Integer type conversions */
 
 #define ACPI_TO_POINTER(i)              ACPI_ADD_PTR (void, (void *) NULL,(ACPI_SIZE) i)
 #define ACPI_TO_INTEGER(p)              ACPI_PTR_DIFF (p, (void *) NULL)
-#define ACPI_OFFSET(d, f)               (ACPI_SIZE) ACPI_PTR_DIFF (&(((d *)0)->f), (void *) NULL)
+#define ACPI_OFFSET(d, f)               ACPI_PTR_DIFF (&(((d *) 0)->f), (void *) NULL)
 #define ACPI_PHYSADDR_TO_PTR(i)         ACPI_TO_POINTER(i)
 #define ACPI_PTR_TO_PHYSADDR(i)         ACPI_TO_INTEGER(i)
 
+/* Optimizations for 4-character (32-bit) ACPI_NAME manipulation */
+
 #ifndef ACPI_MISALIGNMENT_NOT_SUPPORTED
 #define ACPI_COMPARE_NAME(a,b)          (*ACPI_CAST_PTR (UINT32, (a)) == *ACPI_CAST_PTR (UINT32, (b)))
+#define ACPI_MOVE_NAME(dest,src)        (*ACPI_CAST_PTR (UINT32, (dest)) = *ACPI_CAST_PTR (UINT32, (src)))
 #else
-#define ACPI_COMPARE_NAME(a,b)          (!ACPI_STRNCMP (ACPI_CAST_PTR (char, (a)), ACPI_CAST_PTR (char, (b)), ACPI_NAME_SIZE))
+#define ACPI_COMPARE_NAME(a,b)          (!strncmp (ACPI_CAST_PTR (char, (a)), ACPI_CAST_PTR (char, (b)), ACPI_NAME_SIZE))
+#define ACPI_MOVE_NAME(dest,src)        (strncpy (ACPI_CAST_PTR (char, (dest)), ACPI_CAST_PTR (char, (src)), ACPI_NAME_SIZE))
 #endif
 
+/* Support for the special RSDP signature (8 characters) */
+
+#define ACPI_VALIDATE_RSDP_SIG(a)       (!strncmp (ACPI_CAST_PTR (char, (a)), ACPI_SIG_RSDP, 8))
+#define ACPI_MAKE_RSDP_SIG(dest)        (memcpy (ACPI_CAST_PTR (char, (dest)), ACPI_SIG_RSDP, 8))
+
 
 /*******************************************************************************
  *
@@ -478,6 +582,7 @@ typedef UINT64                          ACPI_INTEGER;
 #define ACPI_NO_ACPI_ENABLE             0x10
 #define ACPI_NO_DEVICE_INIT             0x20
 #define ACPI_NO_OBJECT_INIT             0x40
+#define ACPI_NO_FACS_INIT               0x80
 
 /*
  * Initialization state
@@ -519,13 +624,6 @@ typedef UINT64                          ACPI_INTEGER;
 #define ACPI_SLEEP_TYPE_MAX             0x7
 #define ACPI_SLEEP_TYPE_INVALID         0xFF
 
-/*
- * Sleep/Wake flags
- */
-#define ACPI_NO_OPTIONAL_METHODS        0x00 /* Do not execute any optional methods */
-#define ACPI_EXECUTE_GTS                0x01 /* For enter sleep interface */
-#define ACPI_EXECUTE_BFS                0x02 /* For leave sleep prep interface */
-
 /*
  * Standard notify values
  */
@@ -542,8 +640,10 @@ typedef UINT64                          ACPI_INTEGER;
 #define ACPI_NOTIFY_RESERVED            (UINT8) 0x0A
 #define ACPI_NOTIFY_LOCALITY_UPDATE     (UINT8) 0x0B
 #define ACPI_NOTIFY_SHUTDOWN_REQUEST    (UINT8) 0x0C
+#define ACPI_NOTIFY_AFFINITY_UPDATE     (UINT8) 0x0D
 
-#define ACPI_NOTIFY_MAX                 0x0C
+#define ACPI_GENERIC_NOTIFY_MAX         0x0D
+#define ACPI_SPECIFIC_NOTIFY_MAX        0x84
 
 /*
  * Types associated with ACPI names and objects. The first group of
@@ -575,6 +675,7 @@ typedef UINT32                          ACPI_OBJECT_TYPE;
 #define ACPI_TYPE_DEBUG_OBJECT          0x10
 
 #define ACPI_TYPE_EXTERNAL_MAX          0x10
+#define ACPI_NUM_TYPES                  (ACPI_TYPE_EXTERNAL_MAX + 1)
 
 /*
  * These are object types that do not map directly to the ACPI
@@ -596,10 +697,11 @@ typedef UINT32                          ACPI_OBJECT_TYPE;
 #define ACPI_TYPE_LOCAL_SCOPE           0x1B  /* 1 Name, multiple ObjectList Nodes */
 
 #define ACPI_TYPE_NS_NODE_MAX           0x1B  /* Last typecode used within a NS Node */
+#define ACPI_TOTAL_TYPES                (ACPI_TYPE_NS_NODE_MAX + 1)
 
 /*
  * These are special object types that never appear in
- * a Namespace node, only in an ACPI_OPERAND_OBJECT
+ * a Namespace node, only in an object of ACPI_OPERAND_OBJECT
  */
 #define ACPI_TYPE_LOCAL_EXTRA           0x1C
 #define ACPI_TYPE_LOCAL_DATA            0x1D
@@ -643,28 +745,26 @@ typedef UINT32                          ACPI_EVENT_TYPE;
  * The encoding of ACPI_EVENT_STATUS is illustrated below.
  * Note that a set bit (1) indicates the property is TRUE
  * (e.g. if bit 0 is set then the event is enabled).
- * +-------------+-+-+-+
- * |   Bits 31:3 |2|1|0|
- * +-------------+-+-+-+
- *          |     | | |
- *          |     | | +- Enabled?
- *          |     | +--- Enabled for wake?
- *          |     +----- Set?
- *          +----------- <Reserved>
+ * +-------------+-+-+-+-+-+
+ * |   Bits 31:5 |4|3|2|1|0|
+ * +-------------+-+-+-+-+-+
+ *          |     | | | | |
+ *          |     | | | | +- Enabled?
+ *          |     | | | +--- Enabled for wake?
+ *          |     | | +----- Status bit set?
+ *          |     | +------- Enable bit set?
+ *          |     +--------- Has a handler?
+ *          +--------------- <Reserved>
  */
 typedef UINT32                          ACPI_EVENT_STATUS;
 
 #define ACPI_EVENT_FLAG_DISABLED        (ACPI_EVENT_STATUS) 0x00
 #define ACPI_EVENT_FLAG_ENABLED         (ACPI_EVENT_STATUS) 0x01
 #define ACPI_EVENT_FLAG_WAKE_ENABLED    (ACPI_EVENT_STATUS) 0x02
-#define ACPI_EVENT_FLAG_SET             (ACPI_EVENT_STATUS) 0x04
-
-/*
- * General Purpose Events (GPE)
- */
-#define ACPI_GPE_INVALID                0xFF
-#define ACPI_GPE_MAX                    0xFF
-#define ACPI_NUM_GPE                    256
+#define ACPI_EVENT_FLAG_STATUS_SET      (ACPI_EVENT_STATUS) 0x04
+#define ACPI_EVENT_FLAG_ENABLE_SET      (ACPI_EVENT_STATUS) 0x08
+#define ACPI_EVENT_FLAG_HAS_HANDLER     (ACPI_EVENT_STATUS) 0x10
+#define ACPI_EVENT_FLAG_SET             ACPI_EVENT_FLAG_STATUS_SET
 
 /* Actions for AcpiSetGpe, AcpiGpeWakeup, AcpiHwLowSetGpe */
 
@@ -675,7 +775,7 @@ typedef UINT32                          ACPI_EVENT_STATUS;
 /*
  * GPE info flags - Per GPE
  * +-------+-+-+---+
- * |  7:4  |3|2|1:0|
+ * |  7:5  |4|3|2:0|
  * +-------+-+-+---+
  *     |    | |  |
  *     |    | |  +-- Type of dispatch:to method, handler, notify, or none
@@ -687,13 +787,15 @@ typedef UINT32                          ACPI_EVENT_STATUS;
 #define ACPI_GPE_DISPATCH_METHOD        (UINT8) 0x01
 #define ACPI_GPE_DISPATCH_HANDLER       (UINT8) 0x02
 #define ACPI_GPE_DISPATCH_NOTIFY        (UINT8) 0x03
-#define ACPI_GPE_DISPATCH_MASK          (UINT8) 0x03
+#define ACPI_GPE_DISPATCH_RAW_HANDLER   (UINT8) 0x04
+#define ACPI_GPE_DISPATCH_MASK          (UINT8) 0x07
+#define ACPI_GPE_DISPATCH_TYPE(flags)   ((UINT8) ((flags) & ACPI_GPE_DISPATCH_MASK))
 
-#define ACPI_GPE_LEVEL_TRIGGERED        (UINT8) 0x04
+#define ACPI_GPE_LEVEL_TRIGGERED        (UINT8) 0x08
 #define ACPI_GPE_EDGE_TRIGGERED         (UINT8) 0x00
-#define ACPI_GPE_XRUPT_TYPE_MASK        (UINT8) 0x04
+#define ACPI_GPE_XRUPT_TYPE_MASK        (UINT8) 0x08
 
-#define ACPI_GPE_CAN_WAKE               (UINT8) 0x08
+#define ACPI_GPE_CAN_WAKE               (UINT8) 0x10
 
 /*
  * Flags for GPE and Lock interfaces
@@ -731,8 +833,9 @@ typedef UINT8                           ACPI_ADR_SPACE_TYPE;
 #define ACPI_ADR_SPACE_IPMI             (ACPI_ADR_SPACE_TYPE) 7
 #define ACPI_ADR_SPACE_GPIO             (ACPI_ADR_SPACE_TYPE) 8
 #define ACPI_ADR_SPACE_GSBUS            (ACPI_ADR_SPACE_TYPE) 9
+#define ACPI_ADR_SPACE_PLATFORM_COMM    (ACPI_ADR_SPACE_TYPE) 10
 
-#define ACPI_NUM_PREDEFINED_REGIONS     10
+#define ACPI_NUM_PREDEFINED_REGIONS     11
 
 /*
  * Special Address Spaces
@@ -808,8 +911,7 @@ typedef UINT8                           ACPI_ADR_SPACE_TYPE;
 /* Sleep function dispatch */
 
 typedef ACPI_STATUS (*ACPI_SLEEP_FUNCTION) (
-    UINT8                   SleepState,
-    UINT8                   Flags);
+    UINT8                   SleepState);
 
 typedef struct acpi_sleep_functions
 {
@@ -897,8 +999,18 @@ typedef struct acpi_object_list
  * Miscellaneous common Data Structures used by the interfaces
  */
 #define ACPI_NO_BUFFER              0
-#define ACPI_ALLOCATE_BUFFER        (ACPI_SIZE) (-1)
-#define ACPI_ALLOCATE_LOCAL_BUFFER  (ACPI_SIZE) (-2)
+
+#ifdef ACPI_NO_MEM_ALLOCATIONS
+
+#define ACPI_ALLOCATE_BUFFER        (ACPI_SIZE) (0)
+#define ACPI_ALLOCATE_LOCAL_BUFFER  (ACPI_SIZE) (0)
+
+#else /* ACPI_NO_MEM_ALLOCATIONS */
+
+#define ACPI_ALLOCATE_BUFFER        (ACPI_SIZE) (-1)    /* Let ACPICA allocate buffer */
+#define ACPI_ALLOCATE_LOCAL_BUFFER  (ACPI_SIZE) (-2)    /* For internal use only (enables tracking) */
+
+#endif /* ACPI_NO_MEM_ALLOCATIONS */
 
 typedef struct acpi_buffer
 {
@@ -913,7 +1025,8 @@ typedef struct acpi_buffer
  */
 #define ACPI_FULL_PATHNAME              0
 #define ACPI_SINGLE_NAME                1
-#define ACPI_NAME_TYPE_MAX              1
+#define ACPI_FULL_PATHNAME_NO_TRAILING  2
+#define ACPI_NAME_TYPE_MAX              2
 
 
 /*
@@ -921,7 +1034,7 @@ typedef struct acpi_buffer
  */
 typedef struct acpi_predefined_names
 {
-    char                            *Name;
+    const char                      *Name;
     UINT8                           Type;
     char                            *Val;
 
@@ -988,6 +1101,10 @@ typedef void
  * Various handlers and callback procedures
  */
 typedef
+UINT32 (*ACPI_SCI_HANDLER) (
+    void                            *Context);
+
+typedef
 void (*ACPI_GBL_EVENT_HANDLER) (
     UINT32                          EventType,
     ACPI_HANDLE                     Device,
@@ -1111,23 +1228,27 @@ UINT32 (*ACPI_INTERFACE_HANDLER) (
 
 #define ACPI_UUID_LENGTH                16
 
+/* Length of 3-byte PCI class code values when converted back to a string */
+
+#define ACPI_PCICLS_STRING_SIZE         7   /* Includes null terminator */
+
 
 /* Structures used for device/processor HID, UID, CID */
 
-typedef struct acpi_device_id
+typedef struct acpi_pnp_device_id
 {
     UINT32                          Length;             /* Length of string + null */
     char                            *String;
 
-} ACPI_DEVICE_ID;
+} ACPI_PNP_DEVICE_ID;
 
-typedef struct acpi_device_id_list
+typedef struct acpi_pnp_device_id_list
 {
     UINT32                          Count;              /* Number of IDs in Ids array */
     UINT32                          ListSize;           /* Size of list, including ID strings */
-    ACPI_DEVICE_ID                  Ids[1];             /* ID array */
+    ACPI_PNP_DEVICE_ID              Ids[1];             /* ID array */
 
-} ACPI_DEVICE_ID_LIST;
+} ACPI_PNP_DEVICE_ID_LIST;
 
 /*
  * Structure returned from AcpiGetObjectInfo.
@@ -1139,15 +1260,16 @@ typedef struct acpi_device_info
     UINT32                          Name;               /* ACPI object Name */
     ACPI_OBJECT_TYPE                Type;               /* ACPI object Type */
     UINT8                           ParamCount;         /* If a method, required parameter count */
-    UINT8                           Valid;              /* Indicates which optional fields are valid */
+    UINT16                          Valid;              /* Indicates which optional fields are valid */
     UINT8                           Flags;              /* Miscellaneous info */
     UINT8                           HighestDstates[4];  /* _SxD values: 0xFF indicates not valid */
     UINT8                           LowestDstates[5];   /* _SxW values: 0xFF indicates not valid */
     UINT32                          CurrentStatus;      /* _STA value */
     UINT64                          Address;            /* _ADR value */
-    ACPI_DEVICE_ID                  HardwareId;         /* _HID value */
-    ACPI_DEVICE_ID                  UniqueId;           /* _UID value */
-    ACPI_DEVICE_ID_LIST             CompatibleIdList;   /* _CID list <must be last> */
+    ACPI_PNP_DEVICE_ID              HardwareId;         /* _HID value */
+    ACPI_PNP_DEVICE_ID              UniqueId;           /* _UID value */
+    ACPI_PNP_DEVICE_ID              ClassCode;          /* _CLS value */
+    ACPI_PNP_DEVICE_ID_LIST         CompatibleIdList;   /* _CID list <must be last> */
 
 } ACPI_DEVICE_INFO;
 
@@ -1157,13 +1279,14 @@ typedef struct acpi_device_info
 
 /* Flags for Valid field above (AcpiGetObjectInfo) */
 
-#define ACPI_VALID_STA                  0x01
-#define ACPI_VALID_ADR                  0x02
-#define ACPI_VALID_HID                  0x04
-#define ACPI_VALID_UID                  0x08
-#define ACPI_VALID_CID                  0x10
-#define ACPI_VALID_SXDS                 0x20
-#define ACPI_VALID_SXWS                 0x40
+#define ACPI_VALID_STA                  0x0001
+#define ACPI_VALID_ADR                  0x0002
+#define ACPI_VALID_HID                  0x0004
+#define ACPI_VALID_UID                  0x0008
+#define ACPI_VALID_CID                  0x0020
+#define ACPI_VALID_CLS                  0x0040
+#define ACPI_VALID_SXDS                 0x0100
+#define ACPI_VALID_SXWS                 0x0200
 
 /* Flags for _STA method */
 
@@ -1202,12 +1325,11 @@ typedef struct acpi_mem_space_context
  */
 typedef struct acpi_memory_list
 {
-    char                            *ListName;
+    const char                      *ListName;
     void                            *ListHead;
     UINT16                          ObjectSize;
     UINT16                          MaxDepth;
     UINT16                          CurrentDepth;
-    UINT16                          LinkOffset;
 
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
 
@@ -1225,4 +1347,59 @@ typedef struct acpi_memory_list
 } ACPI_MEMORY_LIST;
 
 
+/* Definitions of trace event types */
+
+typedef enum
+{
+    ACPI_TRACE_AML_METHOD,
+    ACPI_TRACE_AML_OPCODE,
+    ACPI_TRACE_AML_REGION
+
+} ACPI_TRACE_EVENT_TYPE;
+
+
+/* Definitions of _OSI support */
+
+#define ACPI_VENDOR_STRINGS                 0x01
+#define ACPI_FEATURE_STRINGS                0x02
+#define ACPI_ENABLE_INTERFACES              0x00
+#define ACPI_DISABLE_INTERFACES             0x04
+
+#define ACPI_DISABLE_ALL_VENDOR_STRINGS     (ACPI_DISABLE_INTERFACES | ACPI_VENDOR_STRINGS)
+#define ACPI_DISABLE_ALL_FEATURE_STRINGS    (ACPI_DISABLE_INTERFACES | ACPI_FEATURE_STRINGS)
+#define ACPI_DISABLE_ALL_STRINGS            (ACPI_DISABLE_INTERFACES | ACPI_VENDOR_STRINGS | ACPI_FEATURE_STRINGS)
+#define ACPI_ENABLE_ALL_VENDOR_STRINGS      (ACPI_ENABLE_INTERFACES | ACPI_VENDOR_STRINGS)
+#define ACPI_ENABLE_ALL_FEATURE_STRINGS     (ACPI_ENABLE_INTERFACES | ACPI_FEATURE_STRINGS)
+#define ACPI_ENABLE_ALL_STRINGS             (ACPI_ENABLE_INTERFACES | ACPI_VENDOR_STRINGS | ACPI_FEATURE_STRINGS)
+
+#define ACPI_OSI_WIN_2000               0x01
+#define ACPI_OSI_WIN_XP                 0x02
+#define ACPI_OSI_WIN_XP_SP1             0x03
+#define ACPI_OSI_WINSRV_2003            0x04
+#define ACPI_OSI_WIN_XP_SP2             0x05
+#define ACPI_OSI_WINSRV_2003_SP1        0x06
+#define ACPI_OSI_WIN_VISTA              0x07
+#define ACPI_OSI_WINSRV_2008            0x08
+#define ACPI_OSI_WIN_VISTA_SP1          0x09
+#define ACPI_OSI_WIN_VISTA_SP2          0x0A
+#define ACPI_OSI_WIN_7                  0x0B
+#define ACPI_OSI_WIN_8                  0x0C
+#define ACPI_OSI_WIN_10                 0x0D
+
+
+/* Definitions of file IO */
+
+#define ACPI_FILE_READING               0x01
+#define ACPI_FILE_WRITING               0x02
+#define ACPI_FILE_BINARY                0x04
+
+#define ACPI_FILE_BEGIN                 0x01
+#define ACPI_FILE_END                   0x02
+
+
+/* Definitions of getopt */
+
+#define ACPI_OPT_END                    -1
+
+
 #endif /* __ACTYPES_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/acutils.h b/usr/src/uts/intel/sys/acpi/acutils.h
index e9c9b95dda..7e53961e5b 100644
--- a/usr/src/uts/intel/sys/acpi/acutils.h
+++ b/usr/src/uts/intel/sys/acpi/acutils.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -50,7 +50,7 @@ extern const UINT8                      AcpiGbl_ResourceAmlSerialBusSizes[];
 
 /* Strings used by the disassembler and debugger resource dump routines */
 
-#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUGGER)
+#if defined(ACPI_DEBUG_OUTPUT) || defined (ACPI_DISASSEMBLER) || defined (ACPI_DEBUGGER)
 
 extern const char                       *AcpiGbl_BmDecode[];
 extern const char                       *AcpiGbl_ConfigDecode[];
@@ -88,6 +88,60 @@ extern const char                       *AcpiGbl_FcDecode[];
 extern const char                       *AcpiGbl_PtDecode[];
 #endif
 
+/*
+ * For the iASL compiler case, the output is redirected to stderr so that
+ * any of the various ACPI errors and warnings do not appear in the output
+ * files, for either the compiler or disassembler portions of the tool.
+ */
+#ifdef ACPI_ASL_COMPILER
+
+#include <stdio.h>
+
+#define ACPI_MSG_REDIRECT_BEGIN \
+    FILE                    *OutputFile = AcpiGbl_OutputFile; \
+    AcpiOsRedirectOutput (stderr);
+
+#define ACPI_MSG_REDIRECT_END \
+    AcpiOsRedirectOutput (OutputFile);
+
+#else
+/*
+ * non-iASL case - no redirection, nothing to do
+ */
+#define ACPI_MSG_REDIRECT_BEGIN
+#define ACPI_MSG_REDIRECT_END
+#endif
+
+/*
+ * Common error message prefixes
+ */
+#ifndef ACPI_MSG_ERROR
+#define ACPI_MSG_ERROR          "ACPI Error: "
+#endif
+#ifndef ACPI_MSG_EXCEPTION
+#define ACPI_MSG_EXCEPTION      "ACPI Exception: "
+#endif
+#ifndef ACPI_MSG_WARNING
+#define ACPI_MSG_WARNING        "ACPI Warning: "
+#endif
+#ifndef ACPI_MSG_INFO
+#define ACPI_MSG_INFO           "ACPI: "
+#endif
+
+#ifndef ACPI_MSG_BIOS_ERROR
+#define ACPI_MSG_BIOS_ERROR     "ACPI BIOS Error (bug): "
+#endif
+#ifndef ACPI_MSG_BIOS_WARNING
+#define ACPI_MSG_BIOS_WARNING   "ACPI BIOS Warning (bug): "
+#endif
+
+/*
+ * Common message suffix
+ */
+#define ACPI_MSG_SUFFIX \
+    AcpiOsPrintf (" (%8.8X/%s-%u)\n", ACPI_CA_VERSION, ModuleName, LineNumber)
+
+
 /* Types for Resource descriptor entries */
 
 #define ACPI_INVALID_RESOURCE           0
@@ -101,7 +155,7 @@ ACPI_STATUS (*ACPI_WALK_AML_CALLBACK) (
     UINT32                  Length,
     UINT32                  Offset,
     UINT8                   ResourceIndex,
-    void                    *Context);
+    void                    **Context);
 
 typedef
 ACPI_STATUS (*ACPI_PKG_CALLBACK) (
@@ -119,9 +173,10 @@ typedef struct acpi_pkg_info
 
 } ACPI_PKG_INFO;
 
+/* Object reference counts */
+
 #define REF_INCREMENT       (UINT16) 0
 #define REF_DECREMENT       (UINT16) 1
-#define REF_FORCE_DELETE    (UINT16) 2
 
 /* AcpiUtDumpBuffer */
 
@@ -130,6 +185,55 @@ typedef struct acpi_pkg_info
 #define DB_DWORD_DISPLAY    4
 #define DB_QWORD_DISPLAY    8
 
+
+/*
+ * utascii - ASCII utilities
+ */
+BOOLEAN
+AcpiUtValidNameseg (
+    char                    *Signature);
+
+BOOLEAN
+AcpiUtValidNameChar (
+    char                    Character,
+    UINT32                  Position);
+
+void
+AcpiUtCheckAndRepairAscii (
+    UINT8                   *Name,
+    char                    *RepairedName,
+    UINT32                  Count);
+
+
+/*
+ * utnonansi - Non-ANSI C library functions
+ */
+void
+AcpiUtStrupr (
+    char                    *SrcString);
+
+void
+AcpiUtStrlwr (
+    char                    *SrcString);
+
+int
+AcpiUtStricmp (
+    char                    *String1,
+    char                    *String2);
+
+ACPI_STATUS
+AcpiUtStrtoul64 (
+    char                    *String,
+    UINT32                  Base,
+    UINT32                  MaxIntegerByteWidth,
+    UINT64                  *RetInteger);
+
+/* Values for MaxIntegerByteWidth above */
+
+#define ACPI_MAX32_BYTE_WIDTH       4
+#define ACPI_MAX64_BYTE_WIDTH       8
+
+
 /*
  * utglobal - Global data structures and procedures
  */
@@ -139,25 +243,25 @@ AcpiUtInitGlobals (
 
 #if defined(ACPI_DEBUG_OUTPUT) || defined(ACPI_DEBUGGER)
 
-char *
+const char *
 AcpiUtGetMutexName (
     UINT32                  MutexId);
 
 const char *
 AcpiUtGetNotifyName (
-    UINT32                  NotifyValue);
-
+    UINT32                  NotifyValue,
+    ACPI_OBJECT_TYPE        Type);
 #endif
 
-char *
+const char *
 AcpiUtGetTypeName (
     ACPI_OBJECT_TYPE        Type);
 
-char *
+const char *
 AcpiUtGetNodeName (
     void                    *Object);
 
-char *
+const char *
 AcpiUtGetDescriptorName (
     void                    *Object);
 
@@ -165,15 +269,15 @@ const char *
 AcpiUtGetReferenceName (
     ACPI_OPERAND_OBJECT     *Object);
 
-char *
+const char *
 AcpiUtGetObjectTypeName (
     ACPI_OPERAND_OBJECT     *ObjDesc);
 
-char *
+const char *
 AcpiUtGetRegionName (
     UINT8                   SpaceId);
 
-char *
+const char *
 AcpiUtGetEventName (
     UINT32                  EventId);
 
@@ -182,6 +286,10 @@ AcpiUtHexToAsciiChar (
     UINT64                  Integer,
     UINT32                  Position);
 
+UINT8
+AcpiUtAsciiCharToHex (
+    int                     HexChar);
+
 BOOLEAN
 AcpiUtValidObjectType (
     ACPI_OBJECT_TYPE        Type);
@@ -199,111 +307,6 @@ AcpiUtSubsystemShutdown (
     void);
 
 
-/*
- * utclib - Local implementations of C library functions
- */
-#ifndef ACPI_USE_SYSTEM_CLIBRARY
-
-ACPI_SIZE
-AcpiUtStrlen (
-    const char              *String);
-
-char *
-AcpiUtStrcpy (
-    char                    *DstString,
-    const char              *SrcString);
-
-char *
-AcpiUtStrncpy (
-    char                    *DstString,
-    const char              *SrcString,
-    ACPI_SIZE               Count);
-
-int
-AcpiUtMemcmp (
-    const char              *Buffer1,
-    const char              *Buffer2,
-    ACPI_SIZE               Count);
-
-int
-AcpiUtStrncmp (
-    const char              *String1,
-    const char              *String2,
-    ACPI_SIZE               Count);
-
-int
-AcpiUtStrcmp (
-    const char              *String1,
-    const char              *String2);
-
-char *
-AcpiUtStrcat (
-    char                    *DstString,
-    const char              *SrcString);
-
-char *
-AcpiUtStrncat (
-    char                    *DstString,
-    const char              *SrcString,
-    ACPI_SIZE               Count);
-
-UINT32
-AcpiUtStrtoul (
-    const char              *String,
-    char                    **Terminator,
-    UINT32                  Base);
-
-char *
-AcpiUtStrstr (
-    char                    *String1,
-    char                    *String2);
-
-void *
-AcpiUtMemcpy (
-    void                    *Dest,
-    const void              *Src,
-    ACPI_SIZE               Count);
-
-void *
-AcpiUtMemset (
-    void                    *Dest,
-    UINT8                   Value,
-    ACPI_SIZE               Count);
-
-int
-AcpiUtToUpper (
-    int                     c);
-
-int
-AcpiUtToLower (
-    int                     c);
-
-extern const UINT8 _acpi_ctype[];
-
-#define _ACPI_XA     0x00    /* extra alphabetic - not supported */
-#define _ACPI_XS     0x40    /* extra space */
-#define _ACPI_BB     0x00    /* BEL, BS, etc. - not supported */
-#define _ACPI_CN     0x20    /* CR, FF, HT, NL, VT */
-#define _ACPI_DI     0x04    /* '0'-'9' */
-#define _ACPI_LO     0x02    /* 'a'-'z' */
-#define _ACPI_PU     0x10    /* punctuation */
-#define _ACPI_SP     0x08    /* space */
-#define _ACPI_UP     0x01    /* 'A'-'Z' */
-#define _ACPI_XD     0x80    /* '0'-'9', 'A'-'F', 'a'-'f' */
-
-#define ACPI_IS_DIGIT(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_DI))
-#define ACPI_IS_SPACE(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_SP))
-#define ACPI_IS_XDIGIT(c) (_acpi_ctype[(unsigned char)(c)] & (_ACPI_XD))
-#define ACPI_IS_UPPER(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_UP))
-#define ACPI_IS_LOWER(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO))
-#define ACPI_IS_PRINT(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO | _ACPI_UP | _ACPI_DI | _ACPI_SP | _ACPI_PU))
-#define ACPI_IS_ALPHA(c)  (_acpi_ctype[(unsigned char)(c)] & (_ACPI_LO | _ACPI_UP))
-
-#endif /* !ACPI_USE_SYSTEM_CLIBRARY */
-
-#define ACPI_IS_ASCII(c)  ((c) < 0x80)
-
-
 /*
  * utcopy - Object construction and conversion interfaces
  */
@@ -375,7 +378,7 @@ AcpiUtTracePtr (
     const char              *FunctionName,
     const char              *ModuleName,
     UINT32                  ComponentId,
-    void                    *Pointer);
+    const void              *Pointer);
 
 void
 AcpiUtTraceU32 (
@@ -391,7 +394,7 @@ AcpiUtTraceStr (
     const char              *FunctionName,
     const char              *ModuleName,
     UINT32                  ComponentId,
-    char                    *String);
+    const char              *String);
 
 void
 AcpiUtExit (
@@ -424,18 +427,37 @@ AcpiUtPtrExit (
     UINT32                  ComponentId,
     UINT8                   *Ptr);
 
+void
+AcpiUtStrExit (
+    UINT32                  LineNumber,
+    const char              *FunctionName,
+    const char              *ModuleName,
+    UINT32                  ComponentId,
+    const char              *String);
+
+void
+AcpiUtDebugDumpBuffer (
+    UINT8                   *Buffer,
+    UINT32                  Count,
+    UINT32                  Display,
+    UINT32                  ComponentId);
+
 void
 AcpiUtDumpBuffer (
     UINT8                   *Buffer,
     UINT32                  Count,
     UINT32                  Display,
-    UINT32                  componentId);
+    UINT32                  Offset);
 
+#ifdef ACPI_APPLICATION
 void
-AcpiUtDumpBuffer2 (
+AcpiUtDumpBufferToFile (
+    ACPI_FILE               File,
     UINT8                   *Buffer,
     UINT32                  Count,
-    UINT32                  Display);
+    UINT32                  Display,
+    UINT32                  BaseOffset);
+#endif
 
 void
 AcpiUtReportError (
@@ -452,6 +474,7 @@ AcpiUtReportWarning (
     char                    *ModuleName,
     UINT32                  LineNumber);
 
+
 /*
  * utdelete - Object deletion and reference counts
  */
@@ -482,13 +505,13 @@ AcpiUtDeleteInternalObjectList (
 ACPI_STATUS
 AcpiUtEvaluateObject (
     ACPI_NAMESPACE_NODE     *PrefixNode,
-    char                    *Path,
+    const char              *Path,
     UINT32                  ExpectedReturnBtypes,
     ACPI_OPERAND_OBJECT     **ReturnDesc);
 
 ACPI_STATUS
 AcpiUtEvaluateNumericObject (
-    char                    *ObjectName,
+    const char              *ObjectName,
     ACPI_NAMESPACE_NODE     *DeviceNode,
     UINT64                  *Value);
 
@@ -511,17 +534,22 @@ AcpiUtExecutePowerMethods (
 ACPI_STATUS
 AcpiUtExecute_HID (
     ACPI_NAMESPACE_NODE     *DeviceNode,
-    ACPI_DEVICE_ID          **ReturnId);
+    ACPI_PNP_DEVICE_ID      **ReturnId);
 
 ACPI_STATUS
 AcpiUtExecute_UID (
     ACPI_NAMESPACE_NODE     *DeviceNode,
-    ACPI_DEVICE_ID          **ReturnId);
+    ACPI_PNP_DEVICE_ID      **ReturnId);
 
 ACPI_STATUS
 AcpiUtExecute_CID (
     ACPI_NAMESPACE_NODE     *DeviceNode,
-    ACPI_DEVICE_ID_LIST     **ReturnCidList);
+    ACPI_PNP_DEVICE_ID_LIST **ReturnCidList);
+
+ACPI_STATUS
+AcpiUtExecute_CLS (
+    ACPI_NAMESPACE_NODE     *DeviceNode,
+    ACPI_PNP_DEVICE_ID      **ReturnId);
 
 
 /*
@@ -608,7 +636,7 @@ ACPI_STATUS
 AcpiUtInitializeInterfaces (
     void);
 
-void
+ACPI_STATUS
 AcpiUtInterfaceTerminate (
     void);
 
@@ -620,6 +648,10 @@ ACPI_STATUS
 AcpiUtRemoveInterface (
     ACPI_STRING             InterfaceName);
 
+ACPI_STATUS
+AcpiUtUpdateInterfaces (
+    UINT8                   Action);
+
 ACPI_INTERFACE_INFO *
 AcpiUtGetInterface (
     ACPI_STRING             InterfaceName);
@@ -629,6 +661,40 @@ AcpiUtOsiImplementation (
     ACPI_WALK_STATE         *WalkState);
 
 
+/*
+ * utpredef - support for predefined names
+ */
+const ACPI_PREDEFINED_INFO *
+AcpiUtGetNextPredefinedMethod (
+    const ACPI_PREDEFINED_INFO  *ThisName);
+
+const ACPI_PREDEFINED_INFO *
+AcpiUtMatchPredefinedMethod (
+    char                        *Name);
+
+void
+AcpiUtGetExpectedReturnTypes (
+    char                    *Buffer,
+    UINT32                  ExpectedBtypes);
+
+#if (defined ACPI_ASL_COMPILER || defined ACPI_HELP_APP)
+const ACPI_PREDEFINED_INFO *
+AcpiUtMatchResourceName (
+    char                        *Name);
+
+void
+AcpiUtDisplayPredefinedMethod (
+    char                        *Buffer,
+    const ACPI_PREDEFINED_INFO  *ThisName,
+    BOOLEAN                     MultiLine);
+
+UINT32
+AcpiUtGetResourceBitWidth (
+    char                    *Buffer,
+    UINT16                  Types);
+#endif
+
+
 /*
  * utstate - Generic state creation/cache routines
  */
@@ -667,13 +733,6 @@ AcpiUtCreateUpdateStateAndPush (
     UINT16                  Action,
     ACPI_GENERIC_STATE      **StateList);
 
-ACPI_STATUS
-AcpiUtCreatePkgStateAndPush (
-    void                    *InternalObject,
-    void                    *ExternalObject,
-    UINT16                  Index,
-    ACPI_GENERIC_STATE      **StateList);
-
 ACPI_GENERIC_STATE *
 AcpiUtCreateControlState (
     void);
@@ -700,10 +759,11 @@ AcpiUtShortDivide (
     UINT64                  *OutQuotient,
     UINT32                  *OutRemainder);
 
+
 /*
  * utmisc
  */
-const char *
+const ACPI_EXCEPTION_INFO *
 AcpiUtValidateException (
     ACPI_STATUS             Status);
 
@@ -711,17 +771,11 @@ BOOLEAN
 AcpiUtIsPciRootBridge (
     char                    *Id);
 
+#if (defined ACPI_ASL_COMPILER || defined ACPI_EXEC_APP || defined ACPI_NAMES_APP)
 BOOLEAN
 AcpiUtIsAmlTable (
     ACPI_TABLE_HEADER       *Table);
-
-ACPI_STATUS
-AcpiUtAllocateOwnerId (
-    ACPI_OWNER_ID           *OwnerId);
-
-void
-AcpiUtReleaseOwnerId (
-    ACPI_OWNER_ID           *OwnerId);
+#endif
 
 ACPI_STATUS
 AcpiUtWalkPackageTree (
@@ -730,47 +784,11 @@ AcpiUtWalkPackageTree (
     ACPI_PKG_CALLBACK       WalkCallback,
     void                    *Context);
 
-void
-AcpiUtStrupr (
-    char                    *SrcString);
-
-void
-AcpiUtStrlwr (
-    char                    *SrcString);
-
-int
-AcpiUtStricmp (
-    char                    *String1,
-    char                    *String2);
-
-void
-AcpiUtPrintString (
-    char                    *String,
-    UINT8                   MaxLength);
-
-BOOLEAN
-AcpiUtValidAcpiName (
-    UINT32                  Name);
-
-void
-AcpiUtRepairName (
-    char                    *Name);
-
-BOOLEAN
-AcpiUtValidAcpiChar (
-    char                    Character,
-    UINT32                  Position);
-
-ACPI_STATUS
-AcpiUtStrtoul64 (
-    char                    *String,
-    UINT32                  Base,
-    UINT64                  *RetInteger);
-
 /* Values for Base above (16=Hex, 10=Decimal) */
 
 #define ACPI_ANY_BASE        0
 
+
 UINT32
 AcpiUtDwordByteSwap (
     UINT32                  Value);
@@ -784,22 +802,36 @@ void
 AcpiUtDisplayInitPathname (
     UINT8                   Type,
     ACPI_NAMESPACE_NODE     *ObjHandle,
-    char                    *Path);
+    const char              *Path);
 #endif
 
 
+/*
+ * utownerid - Support for Table/Method Owner IDs
+ */
+ACPI_STATUS
+AcpiUtAllocateOwnerId (
+    ACPI_OWNER_ID           *OwnerId);
+
+void
+AcpiUtReleaseOwnerId (
+    ACPI_OWNER_ID           *OwnerId);
+
+
 /*
  * utresrc
  */
 ACPI_STATUS
 AcpiUtWalkAmlResources (
+    ACPI_WALK_STATE         *WalkState,
     UINT8                   *Aml,
     ACPI_SIZE               AmlLength,
     ACPI_WALK_AML_CALLBACK  UserFunction,
-    void                    *Context);
+    void                    **Context);
 
 ACPI_STATUS
 AcpiUtValidateResource (
+    ACPI_WALK_STATE         *WalkState,
     void                    *Aml,
     UINT8                   *ReturnIndex);
 
@@ -825,6 +857,46 @@ AcpiUtGetResourceEndTag (
     UINT8                   **EndTag);
 
 
+/*
+ * utstring - String and character utilities
+ */
+void
+AcpiUtPrintString (
+    char                    *String,
+    UINT16                  MaxLength);
+
+#if defined ACPI_ASL_COMPILER || defined ACPI_EXEC_APP
+void
+UtConvertBackslashes (
+    char                    *Pathname);
+#endif
+
+void
+AcpiUtRepairName (
+    char                    *Name);
+
+#if defined (ACPI_DEBUGGER) || defined (ACPI_APPLICATION)
+BOOLEAN
+AcpiUtSafeStrcpy (
+    char                    *Dest,
+    ACPI_SIZE               DestSize,
+    char                    *Source);
+
+BOOLEAN
+AcpiUtSafeStrcat (
+    char                    *Dest,
+    ACPI_SIZE               DestSize,
+    char                    *Source);
+
+BOOLEAN
+AcpiUtSafeStrncat (
+    char                    *Dest,
+    ACPI_SIZE               DestSize,
+    char                    *Source,
+    ACPI_SIZE               MaxTransferLength);
+#endif
+
+
 /*
  * utmutex - mutex support
  */
@@ -865,20 +937,6 @@ AcpiUtInitializeBuffer (
     ACPI_BUFFER             *Buffer,
     ACPI_SIZE               RequiredLength);
 
-void *
-AcpiUtAllocate (
-    ACPI_SIZE               Size,
-    UINT32                  Component,
-    const char              *Module,
-    UINT32                  Line);
-
-void *
-AcpiUtAllocateZeroed (
-    ACPI_SIZE               Size,
-    UINT32                  Component,
-    const char              *Module,
-    UINT32                  Line);
-
 #ifdef ACPI_DBG_TRACK_ALLOCATIONS
 void *
 AcpiUtAllocateAndTrack (
@@ -912,12 +970,13 @@ AcpiUtDumpAllocations (
 
 ACPI_STATUS
 AcpiUtCreateList (
-    char                    *ListName,
+    const char              *ListName,
     UINT16                  ObjectSize,
     ACPI_MEMORY_LIST        **ReturnCache);
 
 #endif /* ACPI_DBG_TRACK_ALLOCATIONS */
 
+
 /*
  * utaddress - address range check
  */
@@ -944,6 +1003,7 @@ void
 AcpiUtDeleteAddressLists (
     void);
 
+
 /*
  * utxferror - various error/warning output functions
  */
@@ -965,6 +1025,15 @@ AcpiUtPredefinedInfo (
     const char              *Format,
     ...);
 
+void ACPI_INTERNAL_VAR_XFACE
+AcpiUtPredefinedBiosError (
+    const char              *ModuleName,
+    UINT32                  LineNumber,
+    char                    *Pathname,
+    UINT8                   NodeFlags,
+    const char              *Format,
+    ...);
+
 void
 AcpiUtNamespaceError (
     const char              *ModuleName,
@@ -981,4 +1050,73 @@ AcpiUtMethodError (
     const char              *Path,
     ACPI_STATUS             LookupStatus);
 
+
+/*
+ * Utility functions for ACPI names and IDs
+ */
+const AH_PREDEFINED_NAME *
+AcpiAhMatchPredefinedName (
+    char                    *Nameseg);
+
+const AH_DEVICE_ID *
+AcpiAhMatchHardwareId (
+    char                    *Hid);
+
+const char *
+AcpiAhMatchUuid (
+    UINT8                   *Data);
+
+
+/*
+ * utprint - printf/vprintf output functions
+ */
+const char *
+AcpiUtScanNumber (
+    const char              *String,
+    UINT64                  *NumberPtr);
+
+const char *
+AcpiUtPrintNumber (
+    char                    *String,
+    UINT64                  Number);
+
+int
+AcpiUtVsnprintf (
+    char                    *String,
+    ACPI_SIZE               Size,
+    const char              *Format,
+    va_list                 Args);
+
+int
+AcpiUtSnprintf (
+    char                    *String,
+    ACPI_SIZE               Size,
+    const char              *Format,
+    ...);
+
+#ifdef ACPI_APPLICATION
+int
+AcpiUtFileVprintf (
+    ACPI_FILE               File,
+    const char              *Format,
+    va_list                 Args);
+
+int
+AcpiUtFilePrintf (
+    ACPI_FILE               File,
+    const char              *Format,
+    ...);
+#endif
+
+
+/*
+ * utuuid -- UUID support functions
+ */
+#if (defined ACPI_ASL_COMPILER || defined ACPI_EXEC_APP || defined ACPI_HELP_APP)
+void
+AcpiUtConvertStringToUuid (
+    char                    *InString,
+    UINT8                   *UuidBuffer);
+#endif
+
 #endif /* _ACUTILS_H */
diff --git a/usr/src/uts/intel/sys/acpi/acuuid.h b/usr/src/uts/intel/sys/acpi/acuuid.h
new file mode 100644
index 0000000000..5c42990ab9
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/acuuid.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+ *
+ * Name: acuuid.h - ACPI-related UUID/GUID definitions
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACUUID_H__
+#define __ACUUID_H__
+
+/*
+ * Note1: UUIDs and GUIDs are defined to be identical in ACPI.
+ *
+ * Note2: This file is standalone and should remain that way.
+ */
+
+/* Controllers */
+
+#define UUID_GPIO_CONTROLLER            "4f248f40-d5e2-499f-834c-27758ea1cd3f"
+#define UUID_USB_CONTROLLER             "ce2ee385-00e6-48cb-9f05-2edb927c4899"
+#define UUID_SATA_CONTROLLER            "e4db149b-fcfe-425b-a6d8-92357d78fc7f"
+
+/* Devices */
+
+#define UUID_PCI_HOST_BRIDGE            "33db4d5b-1ff7-401c-9657-7441c03dd766"
+#define UUID_I2C_DEVICE                 "3cdff6f7-4267-4555-ad05-b30a3d8938de"
+#define UUID_POWER_BUTTON               "dfbcf3c5-e7a5-44e6-9c1f-29c76f6e059c"
+
+/* Interfaces */
+
+#define UUID_DEVICE_LABELING            "e5c937d0-3553-4d7a-9117-ea4d19c3434d"
+#define UUID_PHYSICAL_PRESENCE          "3dddfaa6-361b-4eb4-a424-8d10089d1653"
+
+/* NVDIMM - NFIT table */
+
+#define UUID_VOLATILE_MEMORY            "7305944f-fdda-44e3-b16c-3f22d252e5d0"
+#define UUID_PERSISTENT_MEMORY          "66f0d379-b4f3-4074-ac43-0d3318b78cdb"
+#define UUID_CONTROL_REGION             "92f701f6-13b4-405d-910b-299367e8234c"
+#define UUID_DATA_REGION                "91af0530-5d86-470e-a6b0-0a2db9408249"
+#define UUID_VOLATILE_VIRTUAL_DISK      "77ab535a-45fc-624b-5560-f7b281d1f96e"
+#define UUID_VOLATILE_VIRTUAL_CD        "3d5abd30-4175-87ce-6d64-d2ade523c4bb"
+#define UUID_PERSISTENT_VIRTUAL_DISK    "5cea02c9-4d07-69d3-269f-4496fbe096f9"
+#define UUID_PERSISTENT_VIRTUAL_CD      "08018188-42cd-bb48-100f-5387d53ded3d"
+
+/* Miscellaneous */
+
+#define UUID_PLATFORM_CAPABILITIES      "0811b06e-4a27-44f9-8d60-3cbbc22e7b48"
+#define UUID_DYNAMIC_ENUMERATION        "d8c1a3a6-be9b-4c9b-91bf-c3cb81fc5daf"
+#define UUID_BATTERY_THERMAL_LIMIT      "4c2067e3-887d-475c-9720-4af1d3ed602e"
+#define UUID_THERMAL_EXTENSIONS         "14d399cd-7a27-4b18-8fb4-7cb7b9f4e500"
+#define UUID_DEVICE_PROPERTIES          "daffd814-6eba-4d8c-8a91-bc9bbf4aa301"
+
+
+#endif /* __AUUID_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/amlcode.h b/usr/src/uts/intel/sys/acpi/amlcode.h
index f778bb0780..a432c2b7de 100644
--- a/usr/src/uts/intel/sys/acpi/amlcode.h
+++ b/usr/src/uts/intel/sys/acpi/amlcode.h
@@ -7,7 +7,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -65,6 +65,7 @@
 #define AML_PACKAGE_OP              (UINT16) 0x12
 #define AML_VAR_PACKAGE_OP          (UINT16) 0x13     /* ACPI 2.0 */
 #define AML_METHOD_OP               (UINT16) 0x14
+#define AML_EXTERNAL_OP             (UINT16) 0x15     /* ACPI 6.0 */
 #define AML_DUAL_NAME_PREFIX        (UINT16) 0x2e
 #define AML_MULTI_NAME_PREFIX_OP    (UINT16) 0x2f
 #define AML_NAME_CHAR_SUBSEQ        (UINT16) 0x30
@@ -119,7 +120,7 @@
 #define AML_CREATE_WORD_FIELD_OP    (UINT16) 0x8b
 #define AML_CREATE_BYTE_FIELD_OP    (UINT16) 0x8c
 #define AML_CREATE_BIT_FIELD_OP     (UINT16) 0x8d
-#define AML_TYPE_OP                 (UINT16) 0x8e
+#define AML_OBJECT_TYPE_OP          (UINT16) 0x8e
 #define AML_CREATE_QWORD_FIELD_OP   (UINT16) 0x8f     /* ACPI 2.0 */
 #define AML_LAND_OP                 (UINT16) 0x90
 #define AML_LOR_OP                  (UINT16) 0x91
@@ -209,7 +210,6 @@
 #define AML_INT_RESERVEDFIELD_OP    (UINT16) 0x0031
 #define AML_INT_ACCESSFIELD_OP      (UINT16) 0x0032
 #define AML_INT_BYTELIST_OP         (UINT16) 0x0033
-#define AML_INT_STATICSTRING_OP     (UINT16) 0x0034
 #define AML_INT_METHODCALL_OP       (UINT16) 0x0035
 #define AML_INT_RETURN_VALUE_OP     (UINT16) 0x0036
 #define AML_INT_EVAL_SUBTREE_OP     (UINT16) 0x0037
@@ -241,7 +241,8 @@
 #define ARGP_TERMLIST               0x0F
 #define ARGP_WORDDATA               0x10
 #define ARGP_QWORDDATA              0x11
-#define ARGP_SIMPLENAME             0x12
+#define ARGP_SIMPLENAME             0x12 /* NameString | LocalTerm | ArgTerm */
+#define ARGP_NAME_OR_REF            0x13 /* For ObjectType only */
 
 /*
  * Resolved argument types for the AML Interpreter
@@ -280,14 +281,15 @@
 #define ARGI_TARGETREF              0x0F    /* Target, subject to implicit conversion */
 #define ARGI_FIXED_TARGET           0x10    /* Target, no implicit conversion */
 #define ARGI_SIMPLE_TARGET          0x11    /* Name, Local, Arg -- no implicit conversion */
+#define ARGI_STORE_TARGET           0x12    /* Target for store is TARGETREF + package objects */
 
 /* Multiple/complex types */
 
-#define ARGI_DATAOBJECT             0x12    /* Buffer, String, package or reference to a Node - Used only by SizeOf operator*/
-#define ARGI_COMPLEXOBJ             0x13    /* Buffer, String, or package (Used by INDEX op only) */
-#define ARGI_REF_OR_STRING          0x14    /* Reference or String (Used by DEREFOF op only) */
-#define ARGI_REGION_OR_BUFFER       0x15    /* Used by LOAD op only */
-#define ARGI_DATAREFOBJ             0x16
+#define ARGI_DATAOBJECT             0x13    /* Buffer, String, package or reference to a Node - Used only by SizeOf operator*/
+#define ARGI_COMPLEXOBJ             0x14    /* Buffer, String, or package (Used by INDEX op only) */
+#define ARGI_REF_OR_STRING          0x15    /* Reference or String (Used by DEREFOF op only) */
+#define ARGI_REGION_OR_BUFFER       0x16    /* Used by LOAD op only */
+#define ARGI_DATAREFOBJ             0x17
 
 /* Note: types above can expand to 0x1F maximum */
 
diff --git a/usr/src/uts/intel/sys/acpi/amlresrc.h b/usr/src/uts/intel/sys/acpi/amlresrc.h
index 6d85b8a2d0..960da1b310 100644
--- a/usr/src/uts/intel/sys/acpi/amlresrc.h
+++ b/usr/src/uts/intel/sys/acpi/amlresrc.h
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  *
  * Module Name: amlresrc.h - AML resource descriptors
@@ -6,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -123,6 +122,14 @@ typedef struct asl_resource_node
 
 } ASL_RESOURCE_NODE;
 
+typedef struct asl_resource_info
+{
+    ACPI_PARSE_OBJECT               *DescriptorTypeOp;  /* Resource descriptor parse node */
+    ACPI_PARSE_OBJECT               *MappingOp;         /* Used for mapfile support */
+    UINT32                          CurrentByteOffset;  /* Offset in resource template */
+
+} ASL_RESOURCE_INFO;
+
 
 /* Macros used to generate AML resource length fields */
 
@@ -575,5 +582,50 @@ typedef union aml_resource
 
 } AML_RESOURCE;
 
-#endif
 
+/* Interfaces used by both the disassembler and compiler */
+
+void
+MpSaveGpioInfo (
+    ACPI_PARSE_OBJECT       *Op,
+    AML_RESOURCE            *Resource,
+    UINT32                  PinCount,
+    UINT16                  *PinList,
+    char                    *DeviceName);
+
+void
+MpSaveSerialInfo (
+    ACPI_PARSE_OBJECT       *Op,
+    AML_RESOURCE            *Resource,
+    char                    *DeviceName);
+
+char *
+MpGetHidFromParseTree (
+    ACPI_NAMESPACE_NODE     *HidNode);
+
+char *
+MpGetHidViaNamestring (
+    char                    *DeviceName);
+
+char *
+MpGetConnectionInfo (
+    ACPI_PARSE_OBJECT       *Op,
+    UINT32                  PinIndex,
+    ACPI_NAMESPACE_NODE     **TargetNode,
+    char                    **TargetName);
+
+char *
+MpGetParentDeviceHid (
+    ACPI_PARSE_OBJECT       *Op,
+    ACPI_NAMESPACE_NODE     **TargetNode,
+    char                    **ParentDeviceName);
+
+char *
+MpGetDdnValue (
+    char                    *DeviceName);
+
+char *
+MpGetHidValue (
+    ACPI_NAMESPACE_NODE     *DeviceNode);
+
+#endif
diff --git a/usr/src/uts/intel/sys/acpi/platform/accygwin.h b/usr/src/uts/intel/sys/acpi/platform/accygwin.h
index 831f313987..518fc27d6b 100644
--- a/usr/src/uts/intel/sys/acpi/platform/accygwin.h
+++ b/usr/src/uts/intel/sys/acpi/platform/accygwin.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -50,6 +50,7 @@
 #define ACPI_USE_SYSTEM_CLIBRARY
 #define ACPI_USE_DO_WHILE_0
 #define ACPI_FLUSH_CPU_CACHE()
+
 /*
  * This is needed since sem_timedwait does not appear to work properly
  * on cygwin (always hangs forever).
@@ -89,4 +90,16 @@
 
 #include "acgcc.h"
 
+
+/*
+ * The vsnprintf/snprintf functions are defined by c99, but cygwin/gcc
+ * does not enable this prototype when the -ansi flag is set. Also related
+ * to __STRICT_ANSI__. So, we just declare the prototype here.
+ */
+int
+vsnprintf (char *s, size_t n, const char *format, va_list ap);
+
+int
+snprintf (char *s, size_t n, const char *format, ...);
+
 #endif /* __ACCYGWIN_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acdragonfly.h b/usr/src/uts/intel/sys/acpi/platform/acdragonfly.h
new file mode 100644
index 0000000000..73a1867f75
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/acdragonfly.h
@@ -0,0 +1,128 @@
+/******************************************************************************
+ *
+ * Name: acdragonfly.h - OS specific for DragonFly BSD
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACDRAGONFLY_H_
+#define __ACDRAGONFLY_H_
+
+#include <platform/acgcc.h>     /* DragonFly uses GCC */
+#include <sys/types.h>
+
+#ifdef __LP64__
+#define ACPI_MACHINE_WIDTH              64
+#else
+#define ACPI_MACHINE_WIDTH              32
+#define ACPI_USE_NATIVE_DIVIDE
+#endif
+
+#define ACPI_UINTPTR_T                  uintptr_t
+#define COMPILER_DEPENDENT_INT64        int64_t
+#define COMPILER_DEPENDENT_UINT64       uint64_t
+
+#define ACPI_USE_DO_WHILE_0
+#define ACPI_USE_SYSTEM_CLIBRARY
+
+#ifdef _KERNEL
+
+#include "opt_acpi.h"
+#include <sys/ctype.h>
+#include <sys/systm.h>
+#include <machine/acpica_machdep.h>
+#include <stdarg.h>
+
+#ifdef ACPI_DEBUG
+#define ACPI_DEBUG_OUTPUT       /* enable debug output */
+#ifdef DEBUGGER_THREADING
+#undef DEBUGGER_THREADING
+#endif /* DEBUGGER_THREADING */
+#define DEBUGGER_THREADING DEBUGGER_SINGLE_THREADED /* integrated with DDB */
+#include "opt_ddb.h"
+#ifdef DDB
+#define ACPI_DEBUGGER
+#endif /* DDB */
+#define ACPI_DISASSEMBLER
+#endif
+
+#ifdef ACPI_DEBUG_CACHE
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReleaseObject
+#define AcpiOsReleaseObject(Cache, Object) \
+        _AcpiOsReleaseObject((Cache), (Object), __func__, __LINE__)
+#endif
+
+#ifdef ACPI_DEBUG_LOCKS
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAcquireLock
+#define AcpiOsAcquireLock(Handle) \
+        _AcpiOsAcquireLock((Handle), __func__, __LINE__)
+#endif
+
+#ifdef ACPI_DEBUG_MEMMAP
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsMapMemory
+#define AcpiOsMapMemory(Where, Length) \
+        _AcpiOsMapMemory((Where), (Length), __func__, __LINE__)
+
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsUnmapMemory
+#define AcpiOsUnmapMemory(LogicalAddress, Size) \
+        _AcpiOsUnmapMemory((LogicalAddress), (Size), __func__, __LINE__)
+#endif
+
+/* XXX TBI */
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWaitEventsComplete
+#define AcpiOsWaitEventsComplete()
+
+#define USE_NATIVE_ALLOCATE_ZEROED
+
+#define ACPI_SPINLOCK   struct acpi_spinlock *
+struct acpi_spinlock;
+
+#define ACPI_CACHE_T    struct acpicache
+struct acpicache;
+
+#else /* _KERNEL */
+
+#define ACPI_USE_STANDARD_HEADERS
+
+#define ACPI_CAST_PTHREAD_T(pthread)    ((ACPI_THREAD_ID) ACPI_TO_INTEGER (pthread))
+#define ACPI_FLUSH_CPU_CACHE()
+
+#endif /* _KERNEL */
+
+#endif /* __ACDRAGONFLY_H_ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acdragonflyex.h b/usr/src/uts/intel/sys/acpi/platform/acdragonflyex.h
new file mode 100644
index 0000000000..e1043448fd
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/acdragonflyex.h
@@ -0,0 +1,84 @@
+/******************************************************************************
+ *
+ * Name: acdragonflyex.h - Extra OS specific defines, etc. for DragonFly BSD
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACDRAGONFLYEX_H__
+#define __ACDRAGONFLYEX_H__
+
+#ifdef _KERNEL
+
+#ifdef ACPI_DEBUG_CACHE
+ACPI_STATUS
+_AcpiOsReleaseObject (
+    ACPI_CACHE_T                *Cache,
+    void                        *Object,
+    const char                  *func,
+    int                         line);
+#endif
+
+#ifdef ACPI_DEBUG_LOCKS
+ACPI_CPU_FLAGS
+_AcpiOsAcquireLock (
+    ACPI_SPINLOCK               Spin,
+    const char                  *func,
+    int                         line);
+#endif
+
+#ifdef ACPI_DEBUG_MEMMAP
+void *
+_AcpiOsMapMemory (
+    ACPI_PHYSICAL_ADDRESS       Where,
+    ACPI_SIZE                   Length,
+    const char                  *caller,
+    int                         line);
+
+void
+_AcpiOsUnmapMemory (
+    void                        *LogicalAddress,
+    ACPI_SIZE                   Length,
+    const char                  *caller,
+    int                         line);
+#endif
+
+#endif /* _KERNEL */
+
+#endif /* __ACDRAGONFLYEX_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acefi.h b/usr/src/uts/intel/sys/acpi/platform/acefi.h
index bab6159381..1a9e7c402f 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acefi.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acefi.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -44,10 +44,162 @@
 #ifndef __ACEFI_H__
 #define __ACEFI_H__
 
-#include <efi.h>
-#include <efistdarg.h>
-#include <efilib.h>
+#include <stdarg.h>
+#if defined(_GNU_EFI)
+#include <stdint.h>
+#include <unistd.h>
+#endif
 
+#if defined(__x86_64__)
+#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7))
+#define USE_MS_ABI 1
+#endif
+#endif
+
+#ifdef _MSC_EXTENSIONS
+#define EFIAPI __cdecl
+#elif USE_MS_ABI
+#define EFIAPI __attribute__((ms_abi))
+#else
+#define EFIAPI
+#endif
+
+typedef uint8_t     UINT8;
+typedef uint16_t    UINT16;
+typedef int16_t     INT16;
+typedef uint32_t    UINT32;
+typedef int32_t     INT32;
+typedef uint64_t    UINT64;
+typedef int64_t     INT64;
+typedef uint8_t     BOOLEAN;
+typedef uint16_t    CHAR16;
+
+#define VOID        void
+
+#if defined(__ia64__) || defined(__x86_64__)
+
+#define ACPI_MACHINE_WIDTH          64
+
+#if defined(__x86_64__)
+
+/* for x86_64, EFI_FUNCTION_WRAPPER must be defined */
+
+#ifndef USE_MS_ABI
+#define USE_EFI_FUNCTION_WRAPPER
+#endif
+
+#ifdef _MSC_EXTENSIONS
+#pragma warning ( disable : 4731 )  /* Suppress warnings about modification of EBP */
+#endif
+
+#endif
+
+typedef uint64_t    UINTN;
+typedef int64_t     INTN;
+
+#define EFIERR(a)           (0x8000000000000000 | a)
+
+#else
+
+#define ACPI_MACHINE_WIDTH          32
+#define ACPI_USE_NATIVE_DIVIDE
+
+typedef uint32_t UINTN;
+typedef int32_t INTN;
+
+#define EFIERR(a)           (0x80000000 | a)
+
+#endif
+
+
+#ifdef USE_EFI_FUNCTION_WRAPPER
+#define __VA_NARG__(...)                        \
+  __VA_NARG_(_0, ## __VA_ARGS__, __RSEQ_N())
+#define __VA_NARG_(...)                         \
+  __VA_ARG_N(__VA_ARGS__)
+#define __VA_ARG_N(                             \
+  _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,N,...) N
+#define __RSEQ_N()                              \
+  10, 9,  8,  7,  6,  5,  4,  3,  2,  1,  0
+
+#define __VA_ARG_NSUFFIX__(prefix,...)                  \
+  __VA_ARG_NSUFFIX_N(prefix, __VA_NARG__(__VA_ARGS__))
+#define __VA_ARG_NSUFFIX_N(prefix,nargs)        \
+  __VA_ARG_NSUFFIX_N_(prefix, nargs)
+#define __VA_ARG_NSUFFIX_N_(prefix,nargs)       \
+  prefix ## nargs
+
+/* Prototypes of EFI cdecl -> stdcall trampolines */
+
+UINT64 efi_call0(void *func);
+UINT64 efi_call1(void *func, UINT64 arg1);
+UINT64 efi_call2(void *func, UINT64 arg1, UINT64 arg2);
+UINT64 efi_call3(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3);
+UINT64 efi_call4(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
+                 UINT64 arg4);
+UINT64 efi_call5(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
+                 UINT64 arg4, UINT64 arg5);
+UINT64 efi_call6(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
+                 UINT64 arg4, UINT64 arg5, UINT64 arg6);
+UINT64 efi_call7(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
+                 UINT64 arg4, UINT64 arg5, UINT64 arg6, UINT64 arg7);
+UINT64 efi_call8(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
+                 UINT64 arg4, UINT64 arg5, UINT64 arg6, UINT64 arg7,
+                 UINT64 arg8);
+UINT64 efi_call9(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
+                 UINT64 arg4, UINT64 arg5, UINT64 arg6, UINT64 arg7,
+                 UINT64 arg8, UINT64 arg9);
+UINT64 efi_call10(void *func, UINT64 arg1, UINT64 arg2, UINT64 arg3,
+                  UINT64 arg4, UINT64 arg5, UINT64 arg6, UINT64 arg7,
+                  UINT64 arg8, UINT64 arg9, UINT64 arg10);
+
+/* Front-ends to efi_callX to avoid compiler warnings */
+
+#define _cast64_efi_call0(f) \
+  efi_call0(f)
+#define _cast64_efi_call1(f,a1) \
+  efi_call1(f, (UINT64)(a1))
+#define _cast64_efi_call2(f,a1,a2) \
+  efi_call2(f, (UINT64)(a1), (UINT64)(a2))
+#define _cast64_efi_call3(f,a1,a2,a3) \
+  efi_call3(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3))
+#define _cast64_efi_call4(f,a1,a2,a3,a4) \
+  efi_call4(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4))
+#define _cast64_efi_call5(f,a1,a2,a3,a4,a5) \
+  efi_call5(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
+            (UINT64)(a5))
+#define _cast64_efi_call6(f,a1,a2,a3,a4,a5,a6) \
+  efi_call6(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
+            (UINT64)(a5), (UINT64)(a6))
+#define _cast64_efi_call7(f,a1,a2,a3,a4,a5,a6,a7) \
+  efi_call7(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
+            (UINT64)(a5), (UINT64)(a6), (UINT64)(a7))
+#define _cast64_efi_call8(f,a1,a2,a3,a4,a5,a6,a7,a8) \
+  efi_call8(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
+            (UINT64)(a5), (UINT64)(a6), (UINT64)(a7), (UINT64)(a8))
+#define _cast64_efi_call9(f,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
+  efi_call9(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
+            (UINT64)(a5), (UINT64)(a6), (UINT64)(a7), (UINT64)(a8), \
+            (UINT64)(a9))
+#define _cast64_efi_call10(f,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) \
+  efi_call10(f, (UINT64)(a1), (UINT64)(a2), (UINT64)(a3), (UINT64)(a4), \
+             (UINT64)(a5), (UINT64)(a6), (UINT64)(a7), (UINT64)(a8), \
+             (UINT64)(a9), (UINT64)(a10))
+
+/* main wrapper (va_num ignored) */
+
+#define uefi_call_wrapper(func,va_num,...)                        \
+  __VA_ARG_NSUFFIX__(_cast64_efi_call, __VA_ARGS__) (func , ##__VA_ARGS__)
+
+#else
+
+#define uefi_call_wrapper(func, va_num, ...) func(__VA_ARGS__)
+
+#endif
+
+/* AED EFI definitions */
+
+#if defined(_AED_EFI)
 
 /* _int64 works for both IA32 and IA64 */
 
@@ -71,5 +223,53 @@
 
 #pragma warning(disable:4142)
 
+#endif
+
+
+/* GNU EFI definitions */
+
+#if defined(_GNU_EFI)
+
+/* Using GCC for GNU EFI */
+
+#include "acgcc.h"
+
+#undef ACPI_USE_SYSTEM_CLIBRARY
+#undef ACPI_USE_STANDARD_HEADERS
+#undef ACPI_USE_NATIVE_DIVIDE
+#define ACPI_USE_SYSTEM_INTTYPES
+
+/*
+ * Math helpers
+ */
+#define ACPI_DIV_64_BY_32(n_hi, n_lo, d32, q32, r32) \
+    do {                                             \
+        UINT64 __n = ((UINT64) n_hi) << 32 | (n_lo); \
+        (q32) = DivU64x32 ((__n), (d32), &(r32));    \
+    } while (0)
+
+#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \
+    do {                                \
+        (n_lo) >>= 1;                   \
+        (n_lo) |= (((n_hi) & 1) << 31); \
+        (n_hi) >>= 1;                   \
+    } while (0)
+
+
+#endif
+
+struct _SIMPLE_TEXT_OUTPUT_INTERFACE;
+struct _SIMPLE_INPUT_INTERFACE;
+struct _EFI_FILE_IO_INTERFACE;
+struct _EFI_FILE_HANDLE;
+struct _EFI_BOOT_SERVICES;
+struct _EFI_SYSTEM_TABLE;
+
+extern struct _EFI_SYSTEM_TABLE         *ST;
+extern struct _EFI_BOOT_SERVICES        *BS;
+
+#define ACPI_FILE           struct _SIMPLE_TEXT_OUTPUT_INTERFACE *
+#define ACPI_FILE_OUT       ST->ConOut
+#define ACPI_FILE_ERR       ST->ConOut
 
 #endif /* __ACEFI_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acefiex.h b/usr/src/uts/intel/sys/acpi/platform/acefiex.h
new file mode 100644
index 0000000000..7df5012806
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/acefiex.h
@@ -0,0 +1,855 @@
+/******************************************************************************
+ *
+ * Name: acefiex.h - Extra OS specific defines, etc. for EFI
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACEFIEX_H__
+#define __ACEFIEX_H__
+
+
+#define EFI_ERROR(a)              (((INTN) a) < 0)
+#define EFI_SUCCESS                             0
+#define EFI_LOAD_ERROR                  EFIERR(1)
+#define EFI_INVALID_PARAMETER           EFIERR(2)
+#define EFI_UNSUPPORTED                 EFIERR(3)
+#define EFI_BAD_BUFFER_SIZE             EFIERR(4)
+#define EFI_BUFFER_TOO_SMALL            EFIERR(5)
+#define EFI_NOT_READY                   EFIERR(6)
+#define EFI_DEVICE_ERROR                EFIERR(7)
+#define EFI_WRITE_PROTECTED             EFIERR(8)
+#define EFI_OUT_OF_RESOURCES            EFIERR(9)
+#define EFI_VOLUME_CORRUPTED            EFIERR(10)
+#define EFI_VOLUME_FULL                 EFIERR(11)
+#define EFI_NO_MEDIA                    EFIERR(12)
+#define EFI_MEDIA_CHANGED               EFIERR(13)
+#define EFI_NOT_FOUND                   EFIERR(14)
+#define EFI_ACCESS_DENIED               EFIERR(15)
+#define EFI_NO_RESPONSE                 EFIERR(16)
+#define EFI_NO_MAPPING                  EFIERR(17)
+#define EFI_TIMEOUT                     EFIERR(18)
+#define EFI_NOT_STARTED                 EFIERR(19)
+#define EFI_ALREADY_STARTED             EFIERR(20)
+#define EFI_ABORTED                     EFIERR(21)
+#define EFI_PROTOCOL_ERROR              EFIERR(24)
+
+
+typedef UINTN EFI_STATUS;
+typedef VOID *EFI_HANDLE;
+typedef VOID *EFI_EVENT;
+
+typedef struct {
+    UINT32  Data1;
+    UINT16  Data2;
+    UINT16  Data3;
+    UINT8   Data4[8];
+} EFI_GUID;
+
+typedef struct _EFI_DEVICE_PATH {
+        UINT8                           Type;
+        UINT8                           SubType;
+        UINT8                           Length[2];
+} EFI_DEVICE_PATH;
+
+typedef UINT64          EFI_PHYSICAL_ADDRESS;
+typedef UINT64          EFI_VIRTUAL_ADDRESS;
+
+typedef enum {
+    AllocateAnyPages,
+    AllocateMaxAddress,
+    AllocateAddress,
+    MaxAllocateType
+} EFI_ALLOCATE_TYPE;
+
+typedef enum {
+    EfiReservedMemoryType,
+    EfiLoaderCode,
+    EfiLoaderData,
+    EfiBootServicesCode,
+    EfiBootServicesData,
+    EfiRuntimeServicesCode,
+    EfiRuntimeServicesData,
+    EfiConventionalMemory,
+    EfiUnusableMemory,
+    EfiACPIReclaimMemory,
+    EfiACPIMemoryNVS,
+    EfiMemoryMappedIO,
+    EfiMemoryMappedIOPortSpace,
+    EfiPalCode,
+    EfiMaxMemoryType
+} EFI_MEMORY_TYPE;
+
+/* possible caching types for the memory range */
+#define EFI_MEMORY_UC           0x0000000000000001
+#define EFI_MEMORY_WC           0x0000000000000002
+#define EFI_MEMORY_WT           0x0000000000000004
+#define EFI_MEMORY_WB           0x0000000000000008
+#define EFI_MEMORY_UCE          0x0000000000000010
+
+/* physical memory protection on range */
+#define EFI_MEMORY_WP           0x0000000000001000
+#define EFI_MEMORY_RP           0x0000000000002000
+#define EFI_MEMORY_XP           0x0000000000004000
+
+/* range requires a runtime mapping */
+#define EFI_MEMORY_RUNTIME      0x8000000000000000
+
+#define EFI_MEMORY_DESCRIPTOR_VERSION  1
+typedef struct {
+    UINT32                          Type;
+    UINT32                          Pad;
+    EFI_PHYSICAL_ADDRESS            PhysicalStart;
+    EFI_VIRTUAL_ADDRESS             VirtualStart;
+    UINT64                          NumberOfPages;
+    UINT64                          Attribute;
+} EFI_MEMORY_DESCRIPTOR;
+
+typedef struct _EFI_TABLE_HEARDER {
+    UINT64                      Signature;
+    UINT32                      Revision;
+    UINT32                      HeaderSize;
+    UINT32                      CRC32;
+    UINT32                      Reserved;
+} EFI_TABLE_HEADER;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNKNOWN_INTERFACE) (
+    void);
+
+
+/*
+ * Text output protocol
+ */
+#define SIMPLE_TEXT_OUTPUT_PROTOCOL \
+    { 0x387477c2, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_RESET) (
+    struct _SIMPLE_TEXT_OUTPUT_INTERFACE    *This,
+    BOOLEAN                                 ExtendedVerification);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_OUTPUT_STRING) (
+    struct _SIMPLE_TEXT_OUTPUT_INTERFACE    *This,
+    CHAR16                                  *String);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_TEST_STRING) (
+    struct _SIMPLE_TEXT_OUTPUT_INTERFACE    *This,
+    CHAR16                                  *String);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_QUERY_MODE) (
+    struct _SIMPLE_TEXT_OUTPUT_INTERFACE    *This,
+    UINTN                                   ModeNumber,
+    UINTN                                   *Columns,
+    UINTN                                   *Rows);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_MODE) (
+    struct _SIMPLE_TEXT_OUTPUT_INTERFACE    *This,
+    UINTN                                   ModeNumber);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_ATTRIBUTE) (
+    struct _SIMPLE_TEXT_OUTPUT_INTERFACE    *This,
+    UINTN                                   Attribute);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_CLEAR_SCREEN) (
+    struct _SIMPLE_TEXT_OUTPUT_INTERFACE    *This);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION) (
+    struct _SIMPLE_TEXT_OUTPUT_INTERFACE    *This,
+    UINTN                                   Column,
+    UINTN                                   Row);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_TEXT_ENABLE_CURSOR) (
+    struct _SIMPLE_TEXT_OUTPUT_INTERFACE    *This,
+    BOOLEAN                                 Enable);
+
+typedef struct {
+    INT32                           MaxMode;
+    INT32                           Mode;
+    INT32                           Attribute;
+    INT32                           CursorColumn;
+    INT32                           CursorRow;
+    BOOLEAN                         CursorVisible;
+} SIMPLE_TEXT_OUTPUT_MODE;
+
+typedef struct _SIMPLE_TEXT_OUTPUT_INTERFACE {
+    EFI_TEXT_RESET                  Reset;
+
+    EFI_TEXT_OUTPUT_STRING          OutputString;
+    EFI_TEXT_TEST_STRING            TestString;
+
+    EFI_TEXT_QUERY_MODE             QueryMode;
+    EFI_TEXT_SET_MODE               SetMode;
+    EFI_TEXT_SET_ATTRIBUTE          SetAttribute;
+
+    EFI_TEXT_CLEAR_SCREEN           ClearScreen;
+    EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
+    EFI_TEXT_ENABLE_CURSOR          EnableCursor;
+
+    SIMPLE_TEXT_OUTPUT_MODE         *Mode;
+} SIMPLE_TEXT_OUTPUT_INTERFACE;
+
+/*
+ * Text input protocol
+ */
+#define SIMPLE_TEXT_INPUT_PROTOCOL  \
+    { 0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef struct {
+    UINT16                              ScanCode;
+    CHAR16                              UnicodeChar;
+} EFI_INPUT_KEY;
+
+/*
+ * Baseline unicode control chars
+ */
+#define CHAR_NULL                       0x0000
+#define CHAR_BACKSPACE                  0x0008
+#define CHAR_TAB                        0x0009
+#define CHAR_LINEFEED                   0x000A
+#define CHAR_CARRIAGE_RETURN            0x000D
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_RESET) (
+    struct _SIMPLE_INPUT_INTERFACE              *This,
+    BOOLEAN                                     ExtendedVerification);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INPUT_READ_KEY) (
+    struct _SIMPLE_INPUT_INTERFACE              *This,
+    EFI_INPUT_KEY                               *Key);
+
+typedef struct _SIMPLE_INPUT_INTERFACE {
+    EFI_INPUT_RESET                     Reset;
+    EFI_INPUT_READ_KEY                  ReadKeyStroke;
+    EFI_EVENT                           WaitForKey;
+} SIMPLE_INPUT_INTERFACE;
+
+
+/*
+ * Simple file system protocol
+ */
+#define SIMPLE_FILE_SYSTEM_PROTOCOL \
+    { 0x964e5b22, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b} }
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_VOLUME_OPEN) (
+    struct _EFI_FILE_IO_INTERFACE               *This,
+    struct _EFI_FILE_HANDLE                     **Root);
+
+#define EFI_FILE_IO_INTERFACE_REVISION   0x00010000
+
+typedef struct _EFI_FILE_IO_INTERFACE {
+    UINT64                  Revision;
+    EFI_VOLUME_OPEN         OpenVolume;
+} EFI_FILE_IO_INTERFACE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_OPEN) (
+    struct _EFI_FILE_HANDLE                     *File,
+    struct _EFI_FILE_HANDLE                     **NewHandle,
+    CHAR16                                      *FileName,
+    UINT64                                      OpenMode,
+    UINT64                                      Attributes);
+
+/* Values for OpenMode used above */
+
+#define EFI_FILE_MODE_READ      0x0000000000000001
+#define EFI_FILE_MODE_WRITE     0x0000000000000002
+#define EFI_FILE_MODE_CREATE    0x8000000000000000
+
+/* Values for Attribute used above */
+
+#define EFI_FILE_READ_ONLY      0x0000000000000001
+#define EFI_FILE_HIDDEN         0x0000000000000002
+#define EFI_FILE_SYSTEM         0x0000000000000004
+#define EFI_FILE_RESERVIED      0x0000000000000008
+#define EFI_FILE_DIRECTORY      0x0000000000000010
+#define EFI_FILE_ARCHIVE        0x0000000000000020
+#define EFI_FILE_VALID_ATTR     0x0000000000000037
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_CLOSE) (
+    struct _EFI_FILE_HANDLE                     *File);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_DELETE) (
+    struct _EFI_FILE_HANDLE                     *File);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_READ) (
+    struct _EFI_FILE_HANDLE                     *File,
+    UINTN                                       *BufferSize,
+    VOID                                        *Buffer);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_WRITE) (
+    struct _EFI_FILE_HANDLE                     *File,
+    UINTN                                       *BufferSize,
+    VOID                                        *Buffer);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_POSITION) (
+    struct _EFI_FILE_HANDLE                     *File,
+    UINT64                                      Position);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_POSITION) (
+    struct _EFI_FILE_HANDLE                     *File,
+    UINT64                                      *Position);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_GET_INFO) (
+    struct _EFI_FILE_HANDLE                     *File,
+    EFI_GUID                                    *InformationType,
+    UINTN                                       *BufferSize,
+    VOID                                        *Buffer);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_SET_INFO) (
+    struct _EFI_FILE_HANDLE                     *File,
+    EFI_GUID                                    *InformationType,
+    UINTN                                       BufferSize,
+    VOID                                        *Buffer);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FILE_FLUSH) (
+    struct _EFI_FILE_HANDLE                     *File);
+
+
+#define EFI_FILE_HANDLE_REVISION         0x00010000
+
+typedef struct _EFI_FILE_HANDLE {
+    UINT64                  Revision;
+    EFI_FILE_OPEN           Open;
+    EFI_FILE_CLOSE          Close;
+    EFI_FILE_DELETE         Delete;
+    EFI_FILE_READ           Read;
+    EFI_FILE_WRITE          Write;
+    EFI_FILE_GET_POSITION   GetPosition;
+    EFI_FILE_SET_POSITION   SetPosition;
+    EFI_FILE_GET_INFO       GetInfo;
+    EFI_FILE_SET_INFO       SetInfo;
+    EFI_FILE_FLUSH          Flush;
+} EFI_FILE, *EFI_FILE_HANDLE;
+
+
+/*
+ * Loaded image protocol
+ */
+#define LOADED_IMAGE_PROTOCOL      \
+    { 0x5B1B31A1, 0x9562, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B} }
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_ENTRY_POINT) (
+    EFI_HANDLE                              ImageHandle,
+    struct _EFI_SYSTEM_TABLE                *SystemTable);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_LOAD) (
+    BOOLEAN                         BootPolicy,
+    EFI_HANDLE                      ParentImageHandle,
+    EFI_DEVICE_PATH                 *FilePath,
+    VOID                            *SourceBuffer,
+    UINTN                           SourceSize,
+    EFI_HANDLE                      *ImageHandle);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_START) (
+    EFI_HANDLE                      ImageHandle,
+    UINTN                           *ExitDataSize,
+    CHAR16                          **ExitData);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_EXIT) (
+    EFI_HANDLE                      ImageHandle,
+    EFI_STATUS                      ExitStatus,
+    UINTN                           ExitDataSize,
+    CHAR16                          *ExitData);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_IMAGE_UNLOAD) (
+    EFI_HANDLE                      ImageHandle);
+
+
+#define EFI_IMAGE_INFORMATION_REVISION      0x1000
+typedef struct {
+    UINT32                          Revision;
+    EFI_HANDLE                      ParentHandle;
+    struct _EFI_SYSTEM_TABLE        *SystemTable;
+    EFI_HANDLE                      DeviceHandle;
+    EFI_DEVICE_PATH                 *FilePath;
+    VOID                            *Reserved;
+    UINT32                          LoadOptionsSize;
+    VOID                            *LoadOptions;
+    VOID                            *ImageBase;
+    UINT64                          ImageSize;
+    EFI_MEMORY_TYPE                 ImageCodeType;
+    EFI_MEMORY_TYPE                 ImageDataType;
+    EFI_IMAGE_UNLOAD                Unload;
+
+} EFI_LOADED_IMAGE;
+
+
+/*
+ * EFI Memory
+ */
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_PAGES) (
+    EFI_ALLOCATE_TYPE               Type,
+    EFI_MEMORY_TYPE                 MemoryType,
+    UINTN                           NoPages,
+    EFI_PHYSICAL_ADDRESS            *Memory);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_PAGES) (
+    EFI_PHYSICAL_ADDRESS            Memory,
+    UINTN                           NoPages);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_GET_MEMORY_MAP) (
+    UINTN                           *MemoryMapSize,
+    EFI_MEMORY_DESCRIPTOR           *MemoryMap,
+    UINTN                           *MapKey,
+    UINTN                           *DescriptorSize,
+    UINT32                          *DescriptorVersion);
+
+#define NextMemoryDescriptor(Ptr,Size)  ((EFI_MEMORY_DESCRIPTOR *) (((UINT8 *) Ptr) + Size))
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_ALLOCATE_POOL) (
+    EFI_MEMORY_TYPE                 PoolType,
+    UINTN                           Size,
+    VOID                            **Buffer);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_FREE_POOL) (
+    VOID                            *Buffer);
+
+
+/*
+ * Protocol handler functions
+ */
+typedef enum {
+    EFI_NATIVE_INTERFACE,
+    EFI_PCODE_INTERFACE
+} EFI_INTERFACE_TYPE;
+
+typedef enum {
+    AllHandles,
+    ByRegisterNotify,
+    ByProtocol
+} EFI_LOCATE_SEARCH_TYPE;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE) (
+    EFI_HANDLE                      *Handle,
+    EFI_GUID                        *Protocol,
+    EFI_INTERFACE_TYPE              InterfaceType,
+    VOID                            *Interface);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE) (
+    EFI_HANDLE                      Handle,
+    EFI_GUID                        *Protocol,
+    VOID                            *OldInterface,
+    VOID                            *NewInterface);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE) (
+    EFI_HANDLE                      Handle,
+    EFI_GUID                        *Protocol,
+    VOID                            *Interface);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_HANDLE_PROTOCOL) (
+    EFI_HANDLE                      Handle,
+    EFI_GUID                        *Protocol,
+    VOID                            **Interface);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY) (
+    EFI_GUID                        *Protocol,
+    EFI_EVENT                       Event,
+    VOID                            **Registration);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE) (
+    EFI_LOCATE_SEARCH_TYPE          SearchType,
+    EFI_GUID                        *Protocol,
+    VOID                            *SearchKey,
+    UINTN                           *BufferSize,
+    EFI_HANDLE                      *Buffer);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_DEVICE_PATH) (
+    EFI_GUID                        *Protocol,
+    EFI_DEVICE_PATH                 **DevicePath,
+    EFI_HANDLE                      *Device);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE) (
+    EFI_GUID                        *Guid,
+    VOID                            *Table);
+
+#define EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL  0x00000001
+#define EFI_OPEN_PROTOCOL_GET_PROTOCOL        0x00000002
+#define EFI_OPEN_PROTOCOL_TEST_PROTOCOL       0x00000004
+#define EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER 0x00000008
+#define EFI_OPEN_PROTOCOL_BY_DRIVER           0x00000010
+#define EFI_OPEN_PROTOCOL_EXCLUSIVE           0x00000020
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL) (
+    EFI_HANDLE                      Handle,
+    EFI_GUID                        *Protocol,
+    VOID                            **Interface,
+    EFI_HANDLE                      AgentHandle,
+    EFI_HANDLE                      ControllerHandle,
+    UINT32                          Attributes);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CLOSE_PROTOCOL) (
+    EFI_HANDLE                      Handle,
+    EFI_GUID                        *Protocol,
+    EFI_HANDLE                      AgentHandle,
+    EFI_HANDLE                      ControllerHandle);
+
+typedef struct {
+    EFI_HANDLE                  AgentHandle;
+    EFI_HANDLE                  ControllerHandle;
+    UINT32                      Attributes;
+    UINT32                      OpenCount;
+} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION) (
+    EFI_HANDLE                      Handle,
+    EFI_GUID                        *Protocol,
+    EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,
+    UINTN                           *EntryCount);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_PROTOCOLS_PER_HANDLE) (
+    EFI_HANDLE                      Handle,
+    EFI_GUID                        ***ProtocolBuffer,
+    UINTN                           *ProtocolBufferCount);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_HANDLE_BUFFER) (
+    EFI_LOCATE_SEARCH_TYPE          SearchType,
+    EFI_GUID                        *Protocol,
+    VOID                            *SearchKey,
+    UINTN                           *NoHandles,
+    EFI_HANDLE                      **Buffer);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_LOCATE_PROTOCOL) (
+    EFI_GUID                        *Protocol,
+    VOID                            *Registration,
+    VOID                            **Interface);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    EFI_HANDLE                      *Handle,
+    ...);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES) (
+    EFI_HANDLE                      Handle,
+    ...);
+
+typedef
+EFI_STATUS
+(EFIAPI *EFI_CALCULATE_CRC32) (
+    VOID                            *Data,
+    UINTN                           DataSize,
+    UINT32                          *Crc32);
+
+typedef
+VOID
+(EFIAPI *EFI_COPY_MEM) (
+    VOID                            *Destination,
+    VOID                            *Source,
+    UINTN                           Length);
+
+typedef
+VOID
+(EFIAPI *EFI_SET_MEM) (
+    VOID                            *Buffer,
+    UINTN                           Size,
+    UINT8                           Value);
+
+/*
+ * EFI Boot Services Table
+ */
+#define EFI_BOOT_SERVICES_SIGNATURE     0x56524553544f4f42
+#define EFI_BOOT_SERVICES_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+
+typedef struct _EFI_BOOT_SERVICES {
+    EFI_TABLE_HEADER                Hdr;
+
+#if 0
+    EFI_RAISE_TPL                   RaiseTPL;
+    EFI_RESTORE_TPL                 RestoreTPL;
+#else
+    EFI_UNKNOWN_INTERFACE           RaiseTPL;
+    EFI_UNKNOWN_INTERFACE           RestoreTPL;
+#endif
+
+    EFI_ALLOCATE_PAGES              AllocatePages;
+    EFI_FREE_PAGES                  FreePages;
+    EFI_GET_MEMORY_MAP              GetMemoryMap;
+    EFI_ALLOCATE_POOL               AllocatePool;
+    EFI_FREE_POOL                   FreePool;
+
+#if 0
+    EFI_CREATE_EVENT                CreateEvent;
+    EFI_SET_TIMER                   SetTimer;
+    EFI_WAIT_FOR_EVENT              WaitForEvent;
+    EFI_SIGNAL_EVENT                SignalEvent;
+    EFI_CLOSE_EVENT                 CloseEvent;
+    EFI_CHECK_EVENT                 CheckEvent;
+#else
+    EFI_UNKNOWN_INTERFACE           CreateEvent;
+    EFI_UNKNOWN_INTERFACE           SetTimer;
+    EFI_UNKNOWN_INTERFACE           WaitForEvent;
+    EFI_UNKNOWN_INTERFACE           SignalEvent;
+    EFI_UNKNOWN_INTERFACE           CloseEvent;
+    EFI_UNKNOWN_INTERFACE           CheckEvent;
+#endif
+
+    EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
+    EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
+    EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
+    EFI_HANDLE_PROTOCOL             HandleProtocol;
+    EFI_HANDLE_PROTOCOL             PCHandleProtocol;
+    EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
+    EFI_LOCATE_HANDLE               LocateHandle;
+    EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
+    EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;
+
+    EFI_IMAGE_LOAD                  LoadImage;
+    EFI_IMAGE_START                 StartImage;
+    EFI_EXIT                        Exit;
+    EFI_IMAGE_UNLOAD                UnloadImage;
+
+#if 0
+    EFI_EXIT_BOOT_SERVICES          ExitBootServices;
+    EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
+    EFI_STALL                       Stall;
+    EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;
+#else
+    EFI_UNKNOWN_INTERFACE           ExitBootServices;
+    EFI_UNKNOWN_INTERFACE           GetNextMonotonicCount;
+    EFI_UNKNOWN_INTERFACE           Stall;
+    EFI_UNKNOWN_INTERFACE           SetWatchdogTimer;
+#endif
+
+#if 0
+    EFI_CONNECT_CONTROLLER          ConnectController;
+    EFI_DISCONNECT_CONTROLLER       DisconnectController;
+#else
+    EFI_UNKNOWN_INTERFACE           ConnectController;
+    EFI_UNKNOWN_INTERFACE           DisconnectController;
+#endif
+
+    EFI_OPEN_PROTOCOL               OpenProtocol;
+    EFI_CLOSE_PROTOCOL              CloseProtocol;
+    EFI_OPEN_PROTOCOL_INFORMATION   OpenProtocolInformation;
+    EFI_PROTOCOLS_PER_HANDLE        ProtocolsPerHandle;
+    EFI_LOCATE_HANDLE_BUFFER        LocateHandleBuffer;
+    EFI_LOCATE_PROTOCOL             LocateProtocol;
+    EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces;
+    EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;
+
+    EFI_CALCULATE_CRC32             CalculateCrc32;
+
+    EFI_COPY_MEM                    CopyMem;
+    EFI_SET_MEM                     SetMem;
+
+#if 0
+    EFI_CREATE_EVENT_EX             CreateEventEx;
+#else
+    EFI_UNKNOWN_INTERFACE           CreateEventEx;
+#endif
+} EFI_BOOT_SERVICES;
+
+
+/*
+ * EFI System Table
+ */
+
+/*
+ * EFI Configuration Table and GUID definitions
+ */
+#define ACPI_TABLE_GUID    \
+    { 0xeb9d2d30, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
+#define ACPI_20_TABLE_GUID  \
+    { 0x8868e871, 0xe4f1, 0x11d3, {0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
+
+typedef struct _EFI_CONFIGURATION_TABLE {
+    EFI_GUID                VendorGuid;
+    VOID                    *VendorTable;
+} EFI_CONFIGURATION_TABLE;
+
+
+#define EFI_SYSTEM_TABLE_SIGNATURE      0x5453595320494249
+#define EFI_SYSTEM_TABLE_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)
+
+typedef struct _EFI_SYSTEM_TABLE {
+    EFI_TABLE_HEADER                Hdr;
+
+    CHAR16                          *FirmwareVendor;
+    UINT32                          FirmwareRevision;
+
+    EFI_HANDLE                      ConsoleInHandle;
+    SIMPLE_INPUT_INTERFACE          *ConIn;
+
+    EFI_HANDLE                      ConsoleOutHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
+
+    EFI_HANDLE                      StandardErrorHandle;
+    SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;
+
+#if 0
+    EFI_RUNTIME_SERVICES            *RuntimeServices;
+#else
+    EFI_HANDLE                      *RuntimeServices;
+#endif
+    EFI_BOOT_SERVICES               *BootServices;
+
+    UINTN                           NumberOfTableEntries;
+    EFI_CONFIGURATION_TABLE         *ConfigurationTable;
+
+} EFI_SYSTEM_TABLE;
+
+
+/* GNU EFI definitions */
+
+#if defined(_GNU_EFI)
+
+/*
+ * This is needed to hide platform specific code from ACPICA
+ */
+UINT64
+DivU64x32 (
+    UINT64                  Dividend,
+    UINTN                   Divisor,
+    UINTN                   *Remainder);
+
+/*
+ * EFI specific prototypes
+ */
+EFI_STATUS
+efi_main (
+    EFI_HANDLE              Image,
+    EFI_SYSTEM_TABLE        *SystemTab);
+
+int
+acpi_main (
+    int                     argc,
+    char                    *argv[]);
+
+
+#endif
+
+extern EFI_GUID AcpiGbl_LoadedImageProtocol;
+extern EFI_GUID AcpiGbl_TextInProtocol;
+extern EFI_GUID AcpiGbl_TextOutProtocol;
+extern EFI_GUID AcpiGbl_FileSystemProtocol;
+
+#endif /* __ACEFIEX_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acenv.h b/usr/src/uts/intel/sys/acpi/platform/acenv.h
index 19ca03baac..99adf5f491 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acenv.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acenv.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -67,16 +67,29 @@
  *
  *****************************************************************************/
 
+/* Common application configuration. All single threaded except for AcpiExec. */
+
+#if (defined ACPI_ASL_COMPILER) || \
+    (defined ACPI_BIN_APP)      || \
+    (defined ACPI_DUMP_APP)     || \
+    (defined ACPI_HELP_APP)     || \
+    (defined ACPI_NAMES_APP)    || \
+    (defined ACPI_SRC_APP)      || \
+    (defined ACPI_XTRACT_APP)   || \
+    (defined ACPI_EXAMPLE_APP)
+#define ACPI_APPLICATION
+#define ACPI_SINGLE_THREADED
+#endif
+
 /* iASL configuration */
 
 #ifdef ACPI_ASL_COMPILER
-#define ACPI_APPLICATION
-#define ACPI_DISASSEMBLER
 #define ACPI_DEBUG_OUTPUT
 #define ACPI_CONSTANT_EVAL_ONLY
 #define ACPI_LARGE_NAMESPACE_NODE
 #define ACPI_DATA_TABLE_DISASSEMBLY
-#define ACPI_SINGLE_THREADED
+#define ACPI_32BIT_PHYSICAL_ADDRESS
+#define ACPI_DISASSEMBLER 1
 #endif
 
 /* AcpiExec configuration. Multithreaded with full AML debugger */
@@ -88,35 +101,50 @@
 #define ACPI_DBG_TRACK_ALLOCATIONS
 #endif
 
-/* AcpiNames configuration. Single threaded with debugger output enabled. */
+/* AcpiHelp configuration. Error messages disabled. */
+
+#ifdef ACPI_HELP_APP
+#define ACPI_NO_ERROR_MESSAGES
+#endif
+
+/* AcpiNames configuration. Debug output enabled. */
 
 #ifdef ACPI_NAMES_APP
-#define ACPI_DEBUGGER
-#define ACPI_APPLICATION
-#define ACPI_SINGLE_THREADED
+#define ACPI_DEBUG_OUTPUT
 #endif
 
-/*
- * AcpiBin/AcpiHelp/AcpiSrc configuration. All single threaded, with
- * no debug output.
- */
-#if (defined ACPI_BIN_APP)   || \
-    (defined ACPI_SRC_APP)   || \
-    (defined ACPI_XTRACT_APP)
-#define ACPI_APPLICATION
-#define ACPI_SINGLE_THREADED
+/* AcpiExec/AcpiNames/Example configuration. Native RSDP used. */
+
+#if (defined ACPI_EXEC_APP)     || \
+    (defined ACPI_EXAMPLE_APP)  || \
+    (defined ACPI_NAMES_APP)
+#define ACPI_USE_NATIVE_RSDP_POINTER
 #endif
 
-#ifdef ACPI_HELP_APP
-#define ACPI_DEBUG_OUTPUT
-#define ACPI_APPLICATION
-#define ACPI_SINGLE_THREADED
+/* AcpiDump configuration. Native mapping used if provided by the host */
+
+#ifdef ACPI_DUMP_APP
+#define ACPI_USE_NATIVE_MEMORY_MAPPING
+#define USE_NATIVE_ALLOCATE_ZEROED
 #endif
 
-/* Linkable ACPICA library */
+/* AcpiNames/Example configuration. Hardware disabled */
+
+#if (defined ACPI_EXAMPLE_APP)  || \
+    (defined ACPI_NAMES_APP)
+#define ACPI_REDUCED_HARDWARE 1
+#endif
+
+/* Linkable ACPICA library. Two versions, one with full debug. */
 
 #ifdef ACPI_LIBRARY
 #define ACPI_USE_LOCAL_CACHE
+#define ACPI_DEBUGGER 1
+#define ACPI_DISASSEMBLER 1
+
+#ifdef _DEBUG
+#define ACPI_DEBUG_OUTPUT
+#endif
 #endif
 
 /* Common for all ACPICA applications */
@@ -126,15 +154,14 @@
 #define ACPI_USE_LOCAL_CACHE
 #endif
 
-/* Common debug support */
+/* Common debug/disassembler support */
 
 #ifdef ACPI_FULL_DEBUG
-#define ACPI_DEBUGGER
 #define ACPI_DEBUG_OUTPUT
-#define ACPI_DISASSEMBLER
+#define ACPI_DEBUGGER 1
+#define ACPI_DISASSEMBLER 1
 #endif
 
-
 /*! [Begin] no source code translation */
 
 /******************************************************************************
@@ -147,6 +174,12 @@
 #if defined(_LINUX) || defined(__linux__)
 #include "aclinux.h"
 
+#elif defined(_APPLE) || defined(__APPLE__)
+#include "acmacosx.h"
+
+#elif defined(__DragonFly__)
+#include "acdragonfly.h"
+
 #elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 #include "acfreebsd.h"
 
@@ -180,6 +213,15 @@
 #elif defined(_AED_EFI)
 #include "acefi.h"
 
+#elif defined(_GNU_EFI)
+#include "acefi.h"
+
+#elif defined(__HAIKU__)
+#include "achaiku.h"
+
+#elif defined(__QNX__)
+#include "acqnx.h"
+
 #else
 
 /* Unknown environment */
@@ -259,6 +301,7 @@
 #define ACPI_INTERNAL_VAR_XFACE
 #endif
 
+
 /*
  * Debugger threading model
  * Use single threaded if the entire subsystem is contained in an application
@@ -268,11 +311,11 @@
  * multi-threaded if ACPI_APPLICATION is not set.
  */
 #ifndef DEBUGGER_THREADING
-#ifdef ACPI_APPLICATION
-#define DEBUGGER_THREADING          DEBUGGER_SINGLE_THREADED
+#if !defined (ACPI_APPLICATION) || defined (ACPI_EXEC_APP)
+#define DEBUGGER_THREADING          DEBUGGER_MULTI_THREADED
 
 #else
-#define DEBUGGER_THREADING          DEBUGGER_MULTI_THREADED
+#define DEBUGGER_THREADING          DEBUGGER_SINGLE_THREADED
 #endif
 #endif /* !DEBUGGER_THREADING */
 
@@ -289,15 +332,15 @@
  * ACPI_USE_STANDARD_HEADERS - Define this if linking to a C library and
  *      the standard header files may be used.
  *
- * The ACPICA subsystem only uses low level C library functions that do not call
- * operating system services and may therefore be inlined in the code.
+ * The ACPICA subsystem only uses low level C library functions that do not
+ * call operating system services and may therefore be inlined in the code.
  *
  * It may be necessary to tailor these include files to the target
  * generation environment.
  */
 #ifdef ACPI_USE_SYSTEM_CLIBRARY
 
-/* Use the standard C library headers. We want to keep these to a minimum */
+/* Use the standard C library headers. We want to keep these to a minimum. */
 
 #ifdef ACPI_USE_STANDARD_HEADERS
 
@@ -312,28 +355,6 @@
 
 /* We will be linking to the standard Clib functions */
 
-#define ACPI_STRSTR(s1,s2)      strstr((s1), (s2))
-#define ACPI_STRCHR(s1,c)       strchr((s1), (c))
-#define ACPI_STRLEN(s)          (ACPI_SIZE) strlen((s))
-#define ACPI_STRCPY(d,s)        (void) strcpy((d), (s))
-#define ACPI_STRNCPY(d,s,n)     (void) strncpy((d), (s), (ACPI_SIZE)(n))
-#define ACPI_STRNCMP(d,s,n)     strncmp((d), (s), (ACPI_SIZE)(n))
-#define ACPI_STRCMP(d,s)        strcmp((d), (s))
-#define ACPI_STRCAT(d,s)        (void) strcat((d), (s))
-#define ACPI_STRNCAT(d,s,n)     strncat((d), (s), (ACPI_SIZE)(n))
-#define ACPI_STRTOUL(d,s,n)     strtoul((d), (s), (ACPI_SIZE)(n))
-#define ACPI_MEMCMP(s1,s2,n)    memcmp((const char *)(s1), (const char *)(s2), (ACPI_SIZE)(n))
-#define ACPI_MEMCPY(d,s,n)      (void) memcpy((d), (s), (ACPI_SIZE)(n))
-#define ACPI_MEMSET(d,s,n)      (void) memset((d), (s), (ACPI_SIZE)(n))
-#define ACPI_TOUPPER(i)         toupper((int) (i))
-#define ACPI_TOLOWER(i)         tolower((int) (i))
-#define ACPI_IS_XDIGIT(i)       isxdigit((int) (i))
-#define ACPI_IS_DIGIT(i)        isdigit((int) (i))
-#define ACPI_IS_SPACE(i)        isspace((int) (i))
-#define ACPI_IS_UPPER(i)        isupper((int) (i))
-#define ACPI_IS_PRINT(i)        isprint((int) (i))
-#define ACPI_IS_ALPHA(i)        isalpha((int) (i))
-
 #else
 
 /******************************************************************************
@@ -364,29 +385,26 @@ typedef char *va_list;
 
 #define _Bnd(X, bnd)            (((sizeof (X)) + (bnd)) & (~(bnd)))
 #define va_arg(ap, T)           (*(T *)(((ap) += (_Bnd (T, _AUPBND))) - (_Bnd (T,_ADNBND))))
-#define va_end(ap)              (void) 0
+#define va_end(ap)              (ap = (va_list) NULL)
 #define va_start(ap, A)         (void) ((ap) = (((char *) &(A)) + (_Bnd (A,_AUPBND))))
 
 #endif /* va_arg */
 
 /* Use the local (ACPICA) definitions of the clib functions */
 
-#define ACPI_STRSTR(s1,s2)      AcpiUtStrstr ((s1), (s2))
-#define ACPI_STRCHR(s1,c)       AcpiUtStrchr ((s1), (c))
-#define ACPI_STRLEN(s)          (ACPI_SIZE) AcpiUtStrlen ((s))
-#define ACPI_STRCPY(d,s)        (void) AcpiUtStrcpy ((d), (s))
-#define ACPI_STRNCPY(d,s,n)     (void) AcpiUtStrncpy ((d), (s), (ACPI_SIZE)(n))
-#define ACPI_STRNCMP(d,s,n)     AcpiUtStrncmp ((d), (s), (ACPI_SIZE)(n))
-#define ACPI_STRCMP(d,s)        AcpiUtStrcmp ((d), (s))
-#define ACPI_STRCAT(d,s)        (void) AcpiUtStrcat ((d), (s))
-#define ACPI_STRNCAT(d,s,n)     AcpiUtStrncat ((d), (s), (ACPI_SIZE)(n))
-#define ACPI_STRTOUL(d,s,n)     AcpiUtStrtoul ((d), (s), (ACPI_SIZE)(n))
-#define ACPI_MEMCMP(s1,s2,n)    AcpiUtMemcmp((const char *)(s1), (const char *)(s2), (ACPI_SIZE)(n))
-#define ACPI_MEMCPY(d,s,n)      (void) AcpiUtMemcpy ((d), (s), (ACPI_SIZE)(n))
-#define ACPI_MEMSET(d,v,n)      (void) AcpiUtMemset ((d), (v), (ACPI_SIZE)(n))
-#define ACPI_TOUPPER(c)         AcpiUtToUpper ((int) (c))
-#define ACPI_TOLOWER(c)         AcpiUtToLower ((int) (c))
-
 #endif /* ACPI_USE_SYSTEM_CLIBRARY */
 
+#ifndef ACPI_FILE
+#ifdef ACPI_APPLICATION
+#include <stdio.h>
+#define ACPI_FILE              FILE *
+#define ACPI_FILE_OUT          stdout
+#define ACPI_FILE_ERR          stderr
+#else
+#define ACPI_FILE              void *
+#define ACPI_FILE_OUT          NULL
+#define ACPI_FILE_ERR          NULL
+#endif /* ACPI_APPLICATION */
+#endif /* ACPI_FILE */
+
 #endif /* __ACENV_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acenvex.h b/usr/src/uts/intel/sys/acpi/platform/acenvex.h
new file mode 100644
index 0000000000..02a46f148b
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/acenvex.h
@@ -0,0 +1,75 @@
+/******************************************************************************
+ *
+ * Name: acenvex.h - Extra host and compiler configuration
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACENVEX_H__
+#define __ACENVEX_H__
+
+/*! [Begin] no source code translation */
+
+/******************************************************************************
+ *
+ * Extra host configuration files. All ACPICA headers are included before
+ * including these files.
+ *
+ *****************************************************************************/
+
+#if defined(_LINUX) || defined(__linux__)
+#include "aclinuxex.h"
+
+#elif defined(WIN32)
+#include "acwinex.h"
+
+#elif defined(_AED_EFI)
+#include "acefiex.h"
+
+#elif defined(_GNU_EFI)
+#include "acefiex.h"
+
+#elif defined(__DragonFly__)
+#include "acdragonflyex.h"
+
+#endif
+
+/*! [End] no source code translation !*/
+
+#endif /* __ACENVEX_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acfreebsd.h b/usr/src/uts/intel/sys/acpi/platform/acfreebsd.h
index 98f972f373..a968e12cc2 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acfreebsd.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acfreebsd.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,12 +49,21 @@
 
 #include "acgcc.h"
 #include <sys/types.h>
-#include <machine/acpica_machdep.h>
+
+#ifdef __LP64__
+#define ACPI_MACHINE_WIDTH      64
+#else
+#define ACPI_MACHINE_WIDTH      32
+#endif
+
+#define COMPILER_DEPENDENT_INT64        int64_t
+#define COMPILER_DEPENDENT_UINT64       uint64_t
 
 #define ACPI_UINTPTR_T      uintptr_t
 
 #define ACPI_USE_DO_WHILE_0
 #define ACPI_USE_LOCAL_CACHE
+#define ACPI_USE_NATIVE_DIVIDE
 #define ACPI_USE_SYSTEM_CLIBRARY
 
 #ifdef _KERNEL
@@ -63,6 +72,7 @@
 #include <sys/param.h>
 #include <sys/systm.h>
 #include <sys/libkern.h>
+#include <machine/acpica_machdep.h>
 #include <machine/stdarg.h>
 
 #include "opt_acpi.h"
diff --git a/usr/src/uts/intel/sys/acpi/platform/acgcc.h b/usr/src/uts/intel/sys/acpi/platform/acgcc.h
index d2eafff395..7d703da3dc 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acgcc.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acgcc.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -48,7 +48,7 @@
 
 /* Function name is used for debug output. Non-ANSI, compiler-dependent */
 
-#define ACPI_GET_FUNCTION_NAME          __FUNCTION__
+#define ACPI_GET_FUNCTION_NAME          __func__
 
 /*
  * This macro is used to tag functions as "printf-like" because
@@ -59,9 +59,24 @@
 /*
  * Some compilers complain about unused variables. Sometimes we don't want to
  * use all the variables (for example, _AcpiModuleName). This allows us
- * to to tell the compiler warning in a per-variable manner that a variable
+ * to tell the compiler warning in a per-variable manner that a variable
  * is unused.
  */
 #define ACPI_UNUSED_VAR __attribute__ ((unused))
 
+/*
+ * Some versions of gcc implement strchr() with a buggy macro. So,
+ * undef it here. Prevents error messages of this form (usually from the
+ * file getopt.c):
+ *
+ * error: logical '&&' with non-zero constant will always evaluate as true
+ */
+#ifdef strchr
+#undef strchr
+#endif
+
+/* GCC supports __VA_ARGS__ in macros */
+
+#define COMPILER_VA_MACRO               1
+
 #endif /* __ACGCC_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/achaiku.h b/usr/src/uts/intel/sys/acpi/platform/achaiku.h
new file mode 100644
index 0000000000..10aa6a3f4a
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/achaiku.h
@@ -0,0 +1,106 @@
+/******************************************************************************
+ *
+ * Name: achaiku.h - OS specific defines, etc. for Haiku (www.haiku-os.org)
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACHAIKU_H__
+#define __ACHAIKU_H__
+
+#include "acgcc.h"
+#include <KernelExport.h>
+
+struct mutex;
+
+
+/* Host-dependent types and defines for user- and kernel-space ACPICA */
+
+#define ACPI_USE_SYSTEM_CLIBRARY
+#define ACPI_USE_STANDARD_HEADERS
+
+#define ACPI_MUTEX_TYPE             ACPI_OSL_MUTEX
+#define ACPI_MUTEX                  struct mutex *
+
+#define ACPI_USE_NATIVE_DIVIDE
+
+/* #define ACPI_THREAD_ID               thread_id */
+
+#define ACPI_SEMAPHORE              sem_id
+#define ACPI_SPINLOCK               spinlock *
+#define ACPI_CPU_FLAGS              cpu_status
+
+#define COMPILER_DEPENDENT_INT64    int64
+#define COMPILER_DEPENDENT_UINT64   uint64
+
+
+#ifdef B_HAIKU_64_BIT
+#define ACPI_MACHINE_WIDTH          64
+#else
+#define ACPI_MACHINE_WIDTH          32
+#endif
+
+
+#ifdef _KERNEL_MODE
+/* Host-dependent types and defines for in-kernel ACPICA */
+
+/* ACPICA cache implementation is adequate. */
+#define ACPI_USE_LOCAL_CACHE
+
+#define ACPI_FLUSH_CPU_CACHE() __asm __volatile("wbinvd");
+
+/* Based on FreeBSD's due to lack of documentation */
+extern int AcpiOsAcquireGlobalLock(uint32 *lock);
+extern int AcpiOsReleaseGlobalLock(uint32 *lock);
+
+#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq)    do {                \
+        (Acq) = AcpiOsAcquireGlobalLock(&((GLptr)->GlobalLock));    \
+} while (0)
+
+#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq)    do {                \
+        (Acq) = AcpiOsReleaseGlobalLock(&((GLptr)->GlobalLock));    \
+} while (0)
+
+#else /* _KERNEL_MODE */
+/* Host-dependent types and defines for user-space ACPICA */
+
+#error "We only support kernel mode ACPI atm."
+
+#endif /* _KERNEL_MODE */
+#endif /* __ACHAIKU_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acintel.h b/usr/src/uts/intel/sys/acpi/platform/acintel.h
index 46d238bedb..b8dda571f2 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acintel.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acintel.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/usr/src/uts/intel/sys/acpi/platform/aclinux.h b/usr/src/uts/intel/sys/acpi/platform/aclinux.h
index edfff150ed..bd45cdb14e 100644
--- a/usr/src/uts/intel/sys/acpi/platform/aclinux.h
+++ b/usr/src/uts/intel/sys/acpi/platform/aclinux.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -44,27 +44,81 @@
 #ifndef __ACLINUX_H__
 #define __ACLINUX_H__
 
+#ifdef __KERNEL__
+
+/* ACPICA external files should not include ACPICA headers directly. */
+
+#if !defined(BUILDING_ACPICA) && !defined(_LINUX_ACPI_H)
+#error "Please don't include <acpi/acpi.h> directly, include <linux/acpi.h> instead."
+#endif
+
+#endif
+
 /* Common (in-kernel/user-space) ACPICA configuration */
 
 #define ACPI_USE_SYSTEM_CLIBRARY
 #define ACPI_USE_DO_WHILE_0
-#define ACPI_MUTEX_TYPE             ACPI_BINARY_SEMAPHORE
 
 
 #ifdef __KERNEL__
 
+#define ACPI_USE_SYSTEM_INTTYPES
+
+/* Kernel specific ACPICA configuration */
+
+#ifdef CONFIG_ACPI_REDUCED_HARDWARE_ONLY
+#define ACPI_REDUCED_HARDWARE 1
+#endif
+
+#ifdef CONFIG_ACPI_DEBUGGER
+#define ACPI_DEBUGGER
+#endif
+
 #include <linux/string.h>
 #include <linux/kernel.h>
-#include <linux/module.h>
 #include <linux/ctype.h>
 #include <linux/sched.h>
-#include <asm/system.h>
-#include <asm/atomic.h>
-#include <asm/div64.h>
-#include <asm/acpi.h>
+#include <linux/atomic.h>
+#include <linux/math64.h>
 #include <linux/slab.h>
 #include <linux/spinlock_types.h>
-#include <asm/current.h>
+#ifdef EXPORT_ACPI_INTERFACES
+#include <linux/export.h>
+#endif
+#ifdef CONFIG_ACPI
+#include <asm/acenv.h>
+#endif
+
+#ifndef CONFIG_ACPI
+
+/* External globals for __KERNEL__, stubs is needed */
+
+#define ACPI_GLOBAL(t,a)
+#define ACPI_INIT_GLOBAL(t,a,b)
+
+/* Generating stubs for configurable ACPICA macros */
+
+#define ACPI_NO_MEM_ALLOCATIONS
+
+/* Generating stubs for configurable ACPICA functions */
+
+#define ACPI_NO_ERROR_MESSAGES
+#undef ACPI_DEBUG_OUTPUT
+
+/* External interface for __KERNEL__, stub is needed */
+
+#define ACPI_EXTERNAL_RETURN_STATUS(Prototype) \
+    static ACPI_INLINE Prototype {return(AE_NOT_CONFIGURED);}
+#define ACPI_EXTERNAL_RETURN_OK(Prototype) \
+    static ACPI_INLINE Prototype {return(AE_OK);}
+#define ACPI_EXTERNAL_RETURN_VOID(Prototype) \
+    static ACPI_INLINE Prototype {return;}
+#define ACPI_EXTERNAL_RETURN_UINT32(Prototype) \
+    static ACPI_INLINE Prototype {return(0);}
+#define ACPI_EXTERNAL_RETURN_PTR(Prototype) \
+    static ACPI_INLINE Prototype {return(NULL);}
+
+#endif /* CONFIG_ACPI */
 
 /* Host-dependent types and defines for in-kernel ACPICA */
 
@@ -76,6 +130,47 @@
 #define ACPI_SPINLOCK               spinlock_t *
 #define ACPI_CPU_FLAGS              unsigned long
 
+/* Use native linux version of AcpiOsAllocateZeroed */
+
+#define USE_NATIVE_ALLOCATE_ZEROED
+
+/*
+ * Overrides for in-kernel ACPICA
+ */
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsInitialize
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsTerminate
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAllocate
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAllocateZeroed
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsFree
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAcquireObject
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetThreadId
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCreateLock
+
+/*
+ * OSL interfaces used by debugger/disassembler
+ */
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadable
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWritable
+
+/*
+ * OSL interfaces used by utilities
+ */
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsRedirectOutput
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTableByName
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTableByIndex
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTableByAddress
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsOpenDirectory
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetNextFilename
+#define ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCloseDirectory
+
+#define ACPI_MSG_ERROR          KERN_ERR "ACPI Error: "
+#define ACPI_MSG_EXCEPTION      KERN_ERR "ACPI Exception: "
+#define ACPI_MSG_WARNING        KERN_WARNING "ACPI Warning: "
+#define ACPI_MSG_INFO           KERN_INFO "ACPI: "
+
+#define ACPI_MSG_BIOS_ERROR     KERN_ERR "ACPI BIOS Error (bug): "
+#define ACPI_MSG_BIOS_WARNING   KERN_WARNING "ACPI BIOS Warning (bug): "
+
 #else /* !__KERNEL__ */
 
 #include <stdarg.h>
@@ -84,21 +179,27 @@
 #include <ctype.h>
 #include <unistd.h>
 
+/* Define/disable kernel-specific declarators */
+
+#ifndef __init
+#define __init
+#endif
+
 /* Host-dependent types and defines for user-space ACPICA */
 
 #define ACPI_FLUSH_CPU_CACHE()
+#define ACPI_CAST_PTHREAD_T(Pthread) ((ACPI_THREAD_ID) (Pthread))
 
-#if defined(__ia64__) || defined(__x86_64__)
+#if defined(__ia64__)    || defined(__x86_64__) ||\
+    defined(__aarch64__) || defined(__PPC64__)
 #define ACPI_MACHINE_WIDTH          64
 #define COMPILER_DEPENDENT_INT64    long
 #define COMPILER_DEPENDENT_UINT64   unsigned long
-#define ACPI_CAST_PTHREAD_T(pthread) ((ACPI_THREAD_ID) (pthread))
 #else
 #define ACPI_MACHINE_WIDTH          32
 #define COMPILER_DEPENDENT_INT64    long long
 #define COMPILER_DEPENDENT_UINT64   unsigned long long
 #define ACPI_USE_NATIVE_DIVIDE
-#define ACPI_CAST_PTHREAD_T(pthread) ((ACPI_THREAD_ID) (UINT32) (void *) (pthread))
 #endif
 
 #ifndef __cdecl
@@ -111,51 +212,4 @@
 
 #include "acgcc.h"
 
-
-#ifdef __KERNEL__
-/*
- * Overrides for in-kernel ACPICA
- */
-static inline acpi_thread_id acpi_os_get_thread_id(void)
-{
-    return current;
-}
-
-/*
- * The irqs_disabled() check is for resume from RAM.
- * Interrupts are off during resume, just like they are for boot.
- * However, boot has  (system_state != SYSTEM_RUNNING)
- * to quiet __might_sleep() in kmalloc() and resume does not.
- */
-#include <acpi/actypes.h>
-static inline void *acpi_os_allocate(acpi_size size)
-{
-    return kmalloc(size, irqs_disabled() ? GFP_ATOMIC : GFP_KERNEL);
-}
-
-static inline void *acpi_os_allocate_zeroed(acpi_size size)
-{
-    return kzalloc(size, irqs_disabled() ? GFP_ATOMIC : GFP_KERNEL);
-}
-
-static inline void *acpi_os_acquire_object(acpi_cache_t * cache)
-{
-    return kmem_cache_zalloc(cache,
-        irqs_disabled() ? GFP_ATOMIC : GFP_KERNEL);
-}
-
-#define ACPI_ALLOCATE(a)        acpi_os_allocate(a)
-#define ACPI_ALLOCATE_ZEROED(a) acpi_os_allocate_zeroed(a)
-#define ACPI_FREE(a)            kfree(a)
-
-/* Used within ACPICA to show where it is safe to preempt execution */
-
-#define ACPI_PREEMPTION_POINT() \
-    do { \
-        if (!irqs_disabled()) \
-            cond_resched(); \
-    } while (0)
-
-#endif /* __KERNEL__ */
-
 #endif /* __ACLINUX_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/aclinuxex.h b/usr/src/uts/intel/sys/acpi/platform/aclinuxex.h
new file mode 100644
index 0000000000..c262e40819
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/aclinuxex.h
@@ -0,0 +1,158 @@
+/******************************************************************************
+ *
+ * Name: aclinuxex.h - Extra OS specific defines, etc. for Linux
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACLINUXEX_H__
+#define __ACLINUXEX_H__
+
+#ifdef __KERNEL__
+
+#ifndef ACPI_USE_NATIVE_DIVIDE
+
+#ifndef ACPI_DIV_64_BY_32
+#define ACPI_DIV_64_BY_32(n_hi, n_lo, d32, q32, r32) \
+    do { \
+        UINT64 (__n) = ((UINT64) n_hi) << 32 | (n_lo); \
+        (r32) = do_div ((__n), (d32)); \
+        (q32) = (UINT32) (__n); \
+    } while (0)
+#endif
+
+#ifndef ACPI_SHIFT_RIGHT_64
+#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \
+    do { \
+        (n_lo) >>= 1; \
+        (n_lo) |= (((n_hi) & 1) << 31); \
+        (n_hi) >>= 1; \
+    } while (0)
+#endif
+
+#endif
+
+/*
+ * Overrides for in-kernel ACPICA
+ */
+ACPI_STATUS __init AcpiOsInitialize (
+    void);
+
+ACPI_STATUS AcpiOsTerminate (
+    void);
+
+/*
+ * The irqs_disabled() check is for resume from RAM.
+ * Interrupts are off during resume, just like they are for boot.
+ * However, boot has  (system_state != SYSTEM_RUNNING)
+ * to quiet __might_sleep() in kmalloc() and resume does not.
+ */
+static inline void *
+AcpiOsAllocate (
+    ACPI_SIZE               Size)
+{
+    return kmalloc (Size, irqs_disabled () ? GFP_ATOMIC : GFP_KERNEL);
+}
+
+static inline void *
+AcpiOsAllocateZeroed (
+    ACPI_SIZE               Size)
+{
+    return kzalloc (Size, irqs_disabled () ? GFP_ATOMIC : GFP_KERNEL);
+}
+
+static inline void
+AcpiOsFree (
+    void                   *Memory)
+{
+    kfree (Memory);
+}
+
+static inline void *
+AcpiOsAcquireObject (
+    ACPI_CACHE_T           *Cache)
+{
+    return kmem_cache_zalloc (Cache,
+        irqs_disabled () ? GFP_ATOMIC : GFP_KERNEL);
+}
+
+static inline ACPI_THREAD_ID
+AcpiOsGetThreadId (
+    void)
+{
+    return (ACPI_THREAD_ID) (unsigned long) current;
+}
+
+/*
+ * When lockdep is enabled, the spin_lock_init() macro stringifies it's
+ * argument and uses that as a name for the lock in debugging.
+ * By executing spin_lock_init() in a macro the key changes from "lock" for
+ * all locks to the name of the argument of acpi_os_create_lock(), which
+ * prevents lockdep from reporting false positives for ACPICA locks.
+ */
+#define AcpiOsCreateLock(__Handle) \
+    ({ \
+        spinlock_t *Lock = ACPI_ALLOCATE(sizeof(*Lock)); \
+        if (Lock) { \
+            *(__Handle) = Lock; \
+            spin_lock_init(*(__Handle)); \
+        } \
+        Lock ? AE_OK : AE_NO_MEMORY; \
+    })
+
+static inline BOOLEAN
+AcpiOsReadable (
+    void                    *Pointer,
+    ACPI_SIZE               Length)
+{
+    return TRUE;
+}
+
+
+/*
+ * OSL interfaces added by Linux
+ */
+void
+EarlyAcpiOsUnmapMemory (
+    void __iomem            *Virt,
+    ACPI_SIZE               Size);
+
+#endif /* __KERNEL__ */
+
+#endif /* __ACLINUXEX_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acmacosx.h b/usr/src/uts/intel/sys/acpi/platform/acmacosx.h
new file mode 100644
index 0000000000..5d2ba41e82
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/acmacosx.h
@@ -0,0 +1,58 @@
+/******************************************************************************
+ *
+ * Name: acmacosx.h - OS specific defines, etc. for Mac OS X
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACMACOSX_H__
+#define __ACMACOSX_H__
+
+#include "aclinux.h"
+
+#ifdef __APPLE__
+#define sem_destroy         sem_close
+#define ACPI_USE_ALTERNATE_TIMEOUT
+#endif /* __APPLE__ */
+
+#ifdef __clang__
+#pragma clang diagnostic ignored "-Wformat-nonliteral"
+#endif
+
+#endif /* __ACMACOSX_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acmsvc.h b/usr/src/uts/intel/sys/acpi/platform/acmsvc.h
index b73a62caf1..e8c801f568 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acmsvc.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acmsvc.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -44,6 +44,14 @@
 #ifndef __ACMSVC_H__
 #define __ACMSVC_H__
 
+/* Note: do not include any C library headers here */
+
+/*
+ * Note: MSVC project files should define ACPI_DEBUGGER and ACPI_DISASSEMBLER
+ * as appropriate to enable editor functions like "Find all references".
+ * The editor isn't smart enough to dig through the include files to find
+ * out if these are actually defined.
+ */
 
 /*
  * Map low I/O functions for MS. This allows us to disable MS language
@@ -56,7 +64,6 @@
 #define stat            _stat
 #define fstat           _fstat
 #define mkdir           _mkdir
-#define strlwr          _strlwr
 #define O_RDONLY        _O_RDONLY
 #define O_BINARY        _O_BINARY
 #define O_CREAT         _O_CREAT
@@ -146,4 +153,43 @@
 #pragma warning( disable : 4295 ) /* needed for acpredef.h array */
 #endif
 
+
+/* Debug support. */
+
+#ifdef _DEBUG
+
+/*
+ * Debugging memory corruption issues with windows:
+ * Add #include <crtdbg.h> to accommon.h if necessary.
+ * Add _ASSERTE(_CrtCheckMemory()); where needed to test memory integrity.
+ * This can quickly localize the memory corruption.
+ */
+#define ACPI_DEBUG_INITIALIZE() \
+    _CrtSetDbgFlag (\
+        _CRTDBG_CHECK_ALWAYS_DF | \
+        _CRTDBG_ALLOC_MEM_DF | \
+        _CRTDBG_DELAY_FREE_MEM_DF | \
+        _CRTDBG_LEAK_CHECK_DF | \
+        _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
+
+#if 0
+/*
+ * _CrtSetBreakAlloc can be used to set a breakpoint at a particular
+ * memory leak, add to the macro above.
+ */
+Detected memory leaks!
+Dumping objects ->
+..\..\source\os_specific\service_layers\oswinxf.c(701) : {937} normal block at 0x002E9190, 40 bytes long.
+ Data: <                > 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+
+_CrtSetBreakAlloc (937);
+#endif
+
+#endif
+
+#if _MSC_VER > 1200 /* Versions above VC++ 6 */
+#define COMPILER_VA_MACRO               1
+#else
+#endif
+
 #endif /* __ACMSVC_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acmsvcex.h b/usr/src/uts/intel/sys/acpi/platform/acmsvcex.h
new file mode 100644
index 0000000000..f99a034a47
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/acmsvcex.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ * Name: acmsvcex.h - Extra VC specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACMSVCEX_H__
+#define __ACMSVCEX_H__
+
+/* Debug support. */
+
+#ifdef _DEBUG
+#define _CRTDBG_MAP_ALLOC /* Enables specific file/lineno for leaks */
+#include <crtdbg.h>
+#endif
+
+#endif /* __ACMSVCEX_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acnetbsd.h b/usr/src/uts/intel/sys/acpi/platform/acnetbsd.h
index 23b0e8c4c3..09259af3aa 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acnetbsd.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acnetbsd.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -48,6 +48,10 @@
 
 #include "acgcc.h"
 
+#define ACPI_UINTPTR_T          uintptr_t
+#define ACPI_USE_LOCAL_CACHE
+#define ACPI_CAST_PTHREAD_T(x)  ((ACPI_THREAD_ID) ACPI_TO_INTEGER (x))
+
 #ifdef _LP64
 #define ACPI_MACHINE_WIDTH      64
 #else
@@ -57,8 +61,10 @@
 #define COMPILER_DEPENDENT_INT64  int64_t
 #define COMPILER_DEPENDENT_UINT64 uint64_t
 
-#ifdef _KERNEL
+#if defined(_KERNEL) || defined(_STANDALONE)
+#ifdef _KERNEL_OPT
 #include "opt_acpi.h"           /* collect build-time options here */
+#endif /* _KERNEL_OPT */
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -88,26 +94,19 @@
 #endif /* DDB */
 #endif /* ACPI_DEBUG */
 
-static __inline int
-isprint(int ch)
-{
-        return(isspace(ch) || isascii(ch));
-}
-
-#else /* _KERNEL */
+#else /* defined(_KERNEL) || defined(_STANDALONE) */
 
 #include <ctype.h>
+#include <stdint.h>
 
 /* Not building kernel code, so use libc */
 #define ACPI_USE_STANDARD_HEADERS
 
 #define __cli()
 #define __sti()
+#define __cdecl
 
-/* XXX */
-#define __inline inline
-
-#endif /* _KERNEL */
+#endif /* defined(_KERNEL) || defined(_STANDALONE) */
 
 /* Always use NetBSD code over our local versions */
 #define ACPI_USE_SYSTEM_CLIBRARY
diff --git a/usr/src/uts/intel/sys/acpi/platform/acos2.h b/usr/src/uts/intel/sys/acpi/platform/acos2.h
index 0704c50161..419579bac0 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acos2.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acos2.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/usr/src/uts/intel/sys/acpi/platform/acqnx.h b/usr/src/uts/intel/sys/acpi/platform/acqnx.h
new file mode 100644
index 0000000000..76252f8668
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/acqnx.h
@@ -0,0 +1,74 @@
+/******************************************************************************
+ *
+ * Name: acqnx.h - OS specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACQNX_H__
+#define __ACQNX_H__
+
+/* QNX uses GCC */
+
+#include "acgcc.h"
+
+#define ACPI_UINTPTR_T          uintptr_t
+#define ACPI_USE_LOCAL_CACHE
+#define ACPI_CAST_PTHREAD_T(x)  ((ACPI_THREAD_ID) ACPI_TO_INTEGER (x))
+
+/* At present time (QNX 6.6) all supported architectures are 32 bits. */
+#define ACPI_MACHINE_WIDTH      32
+
+#define COMPILER_DEPENDENT_INT64  int64_t
+#define COMPILER_DEPENDENT_UINT64 uint64_t
+
+#include <ctype.h>
+#include <stdint.h>
+#include <sys/neutrino.h>
+
+#define ACPI_USE_STANDARD_HEADERS
+
+#define __cli() InterruptDisable();
+#define __sti() InterruptEnable();
+#define __cdecl
+
+#define ACPI_USE_SYSTEM_CLIBRARY
+#define ACPI_USE_NATIVE_DIVIDE
+
+#endif /* __ACQNX_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acsolaris.h b/usr/src/uts/intel/sys/acpi/platform/acsolaris.h
index b0cd8bfcf3..a210b07ae7 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acsolaris.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acsolaris.h
@@ -19,6 +19,7 @@
  * CDDL HEADER END
  */
 /*
+ * Copyright 2016 Joyent, Inc.
  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
@@ -36,6 +37,7 @@ extern "C" {
 #include <sys/varargs.h>
 #include <sys/cpu.h>
 #include <sys/thread.h>
+#include <sys/ctype.h>
 
 /* Function name used for debug output. */
 #define	ACPI_GET_FUNCTION_NAME	__func__
@@ -43,6 +45,7 @@ extern "C" {
 uint32_t __acpi_acquire_global_lock(void *);
 uint32_t __acpi_release_global_lock(void *);
 void	 __acpi_wbinvd(void);
+uint32_t acpi_strtoul(const char *, char **, int);
 
 #ifdef	_ILP32
 #define	ACPI_MACHINE_WIDTH	32
@@ -50,6 +53,9 @@ void	 __acpi_wbinvd(void);
 #define	ACPI_MACHINE_WIDTH	64
 #endif
 
+#define	toupper(x)	(islower(x) ? (x) - 'a' + 'A' : (x))
+#define	tolower(x)	(isupper(x) ? (x) - 'A' + 'a' : (x))
+
 #define	COMPILER_DEPENDENT_INT64	int64_t
 #define	COMPILER_DEPENDENT_UINT64	uint64_t
 
@@ -76,6 +82,8 @@ void	 __acpi_wbinvd(void);
 #define	ACPI_INTERNAL_XFACE
 #define	ACPI_INTERNAL_VAR_XFACE
 
+#define	strtoul(s, r, b)	acpi_strtoul(s, r, b)
+
 #define	ACPI_ASM_MACROS
 #define	BREAKPOINT3
 #define	ACPI_DISABLE_IRQS()	cli()
diff --git a/usr/src/uts/intel/sys/acpi/platform/acwin.h b/usr/src/uts/intel/sys/acpi/platform/acwin.h
index c7d4bcd386..dd5b334b23 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acwin.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acwin.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/usr/src/uts/intel/sys/acpi/platform/acwin64.h b/usr/src/uts/intel/sys/acpi/platform/acwin64.h
index 022baf050e..6481f46114 100644
--- a/usr/src/uts/intel/sys/acpi/platform/acwin64.h
+++ b/usr/src/uts/intel/sys/acpi/platform/acwin64.h
@@ -5,7 +5,7 @@
  *****************************************************************************/
 
 /*
- * Copyright (C) 2000 - 2012, Intel Corp.
+ * Copyright (C) 2000 - 2016, Intel Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -79,5 +79,6 @@
 
 #endif
 
+/*! [End] no source code translation !*/
 
 #endif /* __ACWIN_H__ */
diff --git a/usr/src/uts/intel/sys/acpi/platform/acwinex.h b/usr/src/uts/intel/sys/acpi/platform/acwinex.h
new file mode 100644
index 0000000000..8c8e21b250
--- /dev/null
+++ b/usr/src/uts/intel/sys/acpi/platform/acwinex.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Name: acwinex.h - Extra OS specific defines, etc.
+ *
+ *****************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef __ACWINEX_H__
+#define __ACWINEX_H__
+
+/* Windows uses VC */
+#ifdef _MSC_VER
+#include "acmsvcex.h"
+#endif
+
+#endif /* __ACWINEX_H__ */
-- 
2.21.0

