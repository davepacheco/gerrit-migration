From 63d7e3f65f8de7876695052654c4166acb3e8fd9 Mon Sep 17 00:00:00 2001
From: Robert Mustacchi <rm@joyent.com>
Date: Thu, 21 Apr 2016 13:58:50 +0000
Subject: [PATCH] OS-5679 fwflash for sd needs to handle partial writes

---
 usr/src/cmd/fwflash/Makefile.com              |   2 -
 usr/src/cmd/fwflash/Makefile.targ             |   4 +-
 usr/src/cmd/fwflash/common/fwflash.c          |  36 +-
 usr/src/cmd/fwflash/plugins/Makefile.targ     |   2 +
 .../cmd/fwflash/plugins/transport/common/sd.c | 383 ++++++++++++++----
 .../cmd/fwflash/plugins/vendor/sd-GENERIC.c   | 181 ++++++---
 usr/src/lib/scsi/libscsi/common/libscsi.h     |   2 +
 usr/src/lib/scsi/libscsi/common/scsi_engine.c |  13 +
 usr/src/lib/scsi/libscsi/mapfile-vers         |   1 +
 .../scsi/plugins/scsi/engines/uscsi/uscsi.c   |  36 +-
 usr/src/man/man7i/uscsi.7i                    |  31 +-
 .../common/io/scsi/adapters/mpt_sas/mptsas.c  |   2 +
 usr/src/uts/common/io/scsi/targets/sd.c       |  25 +-
 usr/src/uts/common/sys/scsi/impl/spc3_types.h |  24 ++
 usr/src/uts/common/sys/scsi/impl/uscsi.h      |   6 +
 15 files changed, 573 insertions(+), 175 deletions(-)

diff --git a/usr/src/cmd/fwflash/Makefile.com b/usr/src/cmd/fwflash/Makefile.com
index 5f0873b244..59e2bcdb36 100644
--- a/usr/src/cmd/fwflash/Makefile.com
+++ b/usr/src/cmd/fwflash/Makefile.com
@@ -26,8 +26,6 @@
 #
 # common rules for $SRC/cmd/fwflash
 
-CLOSED=			$(SRC)/../closed
-
 CERRWARN +=		-_gcc=-Wno-parentheses
 CERRWARN +=		-_gcc=-Wno-uninitialized
 CERRWARN +=		-_gcc=-Wno-address
diff --git a/usr/src/cmd/fwflash/Makefile.targ b/usr/src/cmd/fwflash/Makefile.targ
index b0da734aff..07b7b69c5d 100644
--- a/usr/src/cmd/fwflash/Makefile.targ
+++ b/usr/src/cmd/fwflash/Makefile.targ
@@ -28,6 +28,7 @@
 
 include $(SRC)/Makefile.master
 include $(SRC)/cmd/Makefile.cmd
+include $(SRC)/cmd/Makefile.ctf
 
 SRCS=		fwflash.c
 HDRS=		fwflash.h
@@ -65,7 +66,8 @@ $(PROG): install_h $(OBJS)
 	$(POST_PROCESS)
 
 %.o: $(SRCDIR)/%.c
-	$(COMPILE.c) $(CFLAGS) -o $@ $<
+	$(COMPILE.c) $(CFLAGS) -o $@ $<	
+	$(CTFCONVERT_O)
 
 
 all:	$(PROG)
diff --git a/usr/src/cmd/fwflash/common/fwflash.c b/usr/src/cmd/fwflash/common/fwflash.c
index 59c3588f24..9b783e8294 100644
--- a/usr/src/cmd/fwflash/common/fwflash.c
+++ b/usr/src/cmd/fwflash/common/fwflash.c
@@ -73,8 +73,8 @@ static int fwflash_in_write = 0;
 #define	FWFLASH_PROG_NAME	"fwflash"
 
 static int get_fileopts(char *options);
-static int flash_device_list();
-static int flash_load_plugins();
+static int flash_device_list(void);
+static int flash_load_plugins(void);
 static int fwflash_update(char *device, char *filename, int flags);
 static int fwflash_read_file(char *device, char *filename);
 static int fwflash_list_fw(char *class);
@@ -247,7 +247,7 @@ main(int argc, char **argv)
 
 
 static int
-flash_load_plugins()
+flash_load_plugins(void)
 {
 
 	int rval = FWFLASH_SUCCESS;
@@ -303,8 +303,8 @@ flash_load_plugins()
 		return (errno);
 	}
 
-	if ((plugdir = calloc(1, sizeof (struct dirent) + MAXPATHLEN + 1))
-	    == NULL) {
+	if ((plugdir = calloc(1, sizeof (struct dirent) + MAXPATHLEN + 1)) ==
+	    NULL) {
 		logmsg(MSG_ERROR,
 		    gettext("Unable to malloc %d bytes while "
 		    "trying to load plugins: %s\n"),
@@ -313,8 +313,8 @@ flash_load_plugins()
 		return (FWFLASH_FAILURE);
 	}
 
-	if ((fw_pluginlist = calloc(1, sizeof (struct fw_plugin)))
-	    == NULL) {
+	if ((fw_pluginlist = calloc(1, sizeof (struct fw_plugin))) ==
+	    NULL) {
 		logmsg(MSG_ERROR,
 		    gettext("Unable to malloc %d bytes while "
 		    "trying to load plugins: %s\n"),
@@ -345,8 +345,8 @@ flash_load_plugins()
 		    fwplugdirpath, plugdir->d_name);
 
 		/* start allocating storage */
-		if ((tmpelem = calloc(1, sizeof (struct pluginlist)))
-		    == NULL) {
+		if ((tmpelem = calloc(1, sizeof (struct pluginlist))) ==
+		    NULL) {
 			logmsg(MSG_ERROR,
 			    gettext("Unable to malloc %d bytes while "
 			    "trying to load plugins: %s\n"),
@@ -354,8 +354,8 @@ flash_load_plugins()
 			return (FWFLASH_FAILURE);
 		}
 
-		if ((tmpplug = calloc(1, sizeof (struct fw_plugin)))
-		    == NULL) {
+		if ((tmpplug = calloc(1, sizeof (struct fw_plugin))) ==
+		    NULL) {
 			logmsg(MSG_ERROR,
 			    gettext("Unable to malloc %d bytes while "
 			    "trying to load plugins: %s\n"),
@@ -370,8 +370,8 @@ flash_load_plugins()
 			continue; /* assume there are other plugins */
 		}
 
-		if ((tmpplug->filename = calloc(1, strlen(plugname) + 1))
-		    == NULL) {
+		if ((tmpplug->filename = calloc(1, strlen(plugname) + 1)) ==
+		    NULL) {
 			logmsg(MSG_ERROR,
 			    gettext("Unable to allocate %d bytes for plugin "
 			    "filename %s:%s\n"),
@@ -440,8 +440,8 @@ flash_load_plugins()
 			continue;
 		}
 
-		if ((sym = dlsym(tmpplug->handle, "plugin_version"))
-		    != NULL) {
+		if ((sym = dlsym(tmpplug->handle, "plugin_version")) !=
+		    NULL) {
 			if ((*(int *)sym) >= FWPLUGIN_VERSION_2) {
 				if ((sym = dlsym(tmpplug->handle,
 				    "fw_cleanup")) != NULL) {
@@ -462,8 +462,8 @@ flash_load_plugins()
 			}
 		}
 
-		if ((tmpelem->drvname = calloc(1, MAXMODCONFNAME))
-		    == NULL) {
+		if ((tmpelem->drvname = calloc(1, MAXMODCONFNAME)) ==
+		    NULL) {
 			logmsg(MSG_ERROR,
 			    gettext("Unable to allocate space for a"
 			    "drivername %s\n"),
@@ -784,7 +784,7 @@ cleanup:
  * which it handles.
  */
 static int
-flash_device_list()
+flash_device_list(void)
 {
 	int rv = FWFLASH_FAILURE;
 	int startidx = 0;
diff --git a/usr/src/cmd/fwflash/plugins/Makefile.targ b/usr/src/cmd/fwflash/plugins/Makefile.targ
index 8650ee545b..fc1229c219 100644
--- a/usr/src/cmd/fwflash/plugins/Makefile.targ
+++ b/usr/src/cmd/fwflash/plugins/Makefile.targ
@@ -61,6 +61,8 @@ $(SD-GENERIC_LIB):= SONAME = $(SD-GENERIC_LIB)
 $(HERMON-MELLANOX_LIB):= DYNFLAGS += -R/usr/lib/fwflash/identify 
 $(HERMON-MELLANOX_LIB):= LDLIBS += -L. $(ROOT)/usr/lib/fwflash/identify/hermon.so
 
+$(SD-GENERIC_LIB):= LDLIBS += -L$(ROOT)/usr/lib/scsi -lscsi
+
 
 .KEEP STATE:
 
diff --git a/usr/src/cmd/fwflash/plugins/transport/common/sd.c b/usr/src/cmd/fwflash/plugins/transport/common/sd.c
index 46faad0877..9c60294a89 100644
--- a/usr/src/cmd/fwflash/plugins/transport/common/sd.c
+++ b/usr/src/cmd/fwflash/plugins/transport/common/sd.c
@@ -26,6 +26,7 @@
 /*
  * sd / ssd (SCSI Direct-attached Device) specific functions.
  */
+
 #include <libnvpair.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -33,16 +34,20 @@
 #include <sys/types.h>
 #include <sys/sysmacros.h>
 #include <sys/queue.h>
+#include <sys/stat.h>
 #include <fcntl.h>
 #include <string.h>
 #include <errno.h>
 #include <scsi/libscsi.h>
+#include <sys/scsi/scsi_types.h>
 #include <libintl.h> /* for gettext(3c) */
 #include <fwflash/fwflash.h>
+#include <sys/debug.h>
+#include <umem.h>
 
 typedef struct sam4_statdesc {
-	int status;
-	char *message;
+	int sam_status;
+	char *sam_message;
 } sam4_statdesc_t;
 
 static sam4_statdesc_t sam4_status[] = {
@@ -57,8 +62,7 @@ static sam4_statdesc_t sam4_status[] = {
 	{ NULL, NULL }
 };
 
-#define	NSAM4_STATUS	\
-	(sizeof (sam4_status) / sizeof (sam4_status[0]))
+#define	NSAM4_STATUS	(sizeof (sam4_status) / sizeof (sam4_status[0]))
 
 #define	FW_SD_FREE_DEVPATH(devpath)	{	\
 		di_devfs_path_free((devpath));	\
@@ -100,27 +104,35 @@ static sam4_statdesc_t sam4_status[] = {
 		FW_SD_FREE_IDENT_PID((thisdev), (devpath))	\
 	}
 
-int errno;
+/*
+ * This is our default partial write size when we encounter a situation where we
+ * need to upgrade disks whose firmware image cannot be done in a single write.
+ * While in theory we should just use the maximum transfer size and make sure
+ * it's aligned, that's proven to be problematic for some Seagate disks. Hence
+ * we just make sure that if partial writes are required that this value fits in
+ * the required alignment and in the actual maximum transfer size.
+ */
+#define	FW_SD_PARTIAL_WRITE_SIZE	(64 * 1024)
+
+/*
+ * Declarations required for fwflash
+ */
 char drivername[] = "sd\0";
 int plugin_version = FWPLUGIN_VERSION_2;
 
-static char *devprefix = "/devices";
+/*
+ * Data provided by fwflash
+ */
 extern di_node_t rootnode;
 extern struct fw_plugin *self;
 extern struct vrfyplugin *verifier;
 extern int fwflash_debug;
 
-/* required functions for this plugin */
-int fw_readfw(struct devicelist *device, char *filename);
-int fw_writefw(struct devicelist *device);
-int fw_identify(int start);
-int fw_devinfo(struct devicelist *thisdev);
-void fw_cleanup(struct devicelist *thisdev);
+static char *sdfw_devprefix = "/devices";
 
-/* helper functions */
-static char *find_link(di_node_t bnode, char *acc_devname);
-static int link_cb(di_devlink_t devlink, void *arg);
-static int sd_idtfy_custmz(struct devicelist *device, char *sp);
+static char *sdfw_find_link(di_node_t bnode, char *acc_devname);
+static int sdfw_link_cb(di_devlink_t devlink, void *arg);
+static int sdfw_idtfy_custmz(struct devicelist *device, char *sp);
 
 /*
  * We don't currently support reading firmware from a disk. If we do eventually
@@ -141,17 +153,190 @@ fw_readfw(struct devicelist *flashdev, char *filename)
 	return (FWFLASH_SUCCESS);
 }
 
+
+static int
+sdfw_read_descriptor(struct devicelist *flashdev, libscsi_hdl_t *hdl,
+    libscsi_target_t *targ, uint8_t *align)
+{
+	spc3_read_buffer_cdb_t *rb_cdb;
+	size_t nwritten;
+	libscsi_action_t *action = NULL;
+	uint8_t descbuf[4];
+	sam4_status_t samstatus;
+
+	VERIFY(hdl != NULL);
+	VERIFY(targ != NULL);
+	VERIFY(align != NULL);
+
+	if ((action = libscsi_action_alloc(hdl, SPC3_CMD_READ_BUFFER,
+	    LIBSCSI_AF_READ, descbuf, sizeof (descbuf))) == NULL) {
+		logmsg(MSG_ERROR, "%s: failed to alloc scsi action: %s\n",
+		    flashdev->drvname, libscsi_errmsg(hdl));
+		return (FWFLASH_FAILURE);
+	}
+
+	rb_cdb = (spc3_read_buffer_cdb_t *)libscsi_action_get_cdb(action);
+
+	rb_cdb->rbc_mode = SPC3_RB_MODE_DESCRIPTOR;
+	rb_cdb->rbc_bufferid = 0;
+
+	rb_cdb->rbc_allocation_len[0] = 0;
+	rb_cdb->rbc_allocation_len[1] = 0;
+	rb_cdb->rbc_allocation_len[2] = 4;
+
+	if (libscsi_exec(action, targ) != 0) {
+		logmsg(MSG_ERROR, "%s: failed to execute SCSI buffer data read: %s\n",
+		    flashdev->drvname, libscsi_errmsg(hdl));
+		libscsi_action_free(action);
+		return (FWFLASH_FAILURE);
+	}
+
+	if ((samstatus = libscsi_action_get_status(action)) != SAM4_STATUS_GOOD) {
+		int i;
+		logmsg(MSG_ERROR, "%s: SCSI buffer data read failed:",
+		    flashdev->drvname);
+		for (i = 0; i < NSAM4_STATUS; i++) {
+			if (samstatus == sam4_status[i].sam_status) {
+				logmsg(MSG_ERROR, "%s\n", sam4_status[i].sam_message);
+				libscsi_action_free(action);
+				return (FWFLASH_FAILURE);
+			}
+		}
+		logmsg(MSG_ERROR, "unknown error: %d\n", samstatus);
+		libscsi_action_free(action);
+		return (FWFLASH_FAILURE);
+	}
+
+	if (libscsi_action_get_buffer(action, NULL, NULL, &nwritten) != 0) {
+		logmsg(MSG_ERROR, "%s: failed to get actual data size: %s\n",
+		    flashdev->drvname, libscsi_errmsg(hdl));
+		libscsi_action_free(action);
+		return (FWFLASH_FAILURE);
+	}
+	libscsi_action_free(action);
+
+	if (nwritten != sizeof (descbuf)) {
+		logmsg(MSG_ERROR, "%s: received a short read from the SCSI "
+		    "READ BUFFER command, expected %d bytes, read %d\n",
+		    flashdev->drvname, sizeof (descbuf), nwritten);
+	}
+
+	*align = descbuf[0];
+
+	return (FWFLASH_SUCCESS);
+}
+
+static int
+sdfw_write(struct devicelist *flashdev, libscsi_hdl_t *handle,
+    libscsi_target_t *target, size_t len, size_t off, void *buf)
+{
+	sam4_status_t samstatus;
+	libscsi_action_t *action = NULL;
+	spc3_write_buffer_cdb_t *wb_cdb;
+
+	logmsg(MSG_INFO, "%s: writing %d bytes of image %s at offset %d from "
+	    "address %p\n", flashdev->drvname, len, verifier->imgfile, off,
+	    buf);
+	logmsg(MSG_INFO, "%s: writing to buffer id %d\n",
+	    flashdev->drvname, verifier->flashbuf);
+
+	VERIFY3P(flashdev, !=, NULL);
+	VERIFY3P(handle, !=, NULL);
+	VERIFY3P(target, !=, NULL);
+	VERIFY3P(buf, !=, NULL);
+	VERIFY3S(len, >, 0);
+	VERIFY(off + len <= verifier->imgsize);
+
+	action = libscsi_action_alloc(handle, SPC3_CMD_WRITE_BUFFER,
+	    LIBSCSI_AF_WRITE | LIBSCSI_AF_RQSENSE | LIBSCSI_AF_ISOLATE, buf,
+	    len);
+	if (action == NULL) {
+		logmsg(MSG_ERROR, "%s: failed to alloc scsi action: %s\n",
+		    flashdev->drvname, libscsi_errmsg(handle));
+		goto err;
+	}
+
+	wb_cdb = (spc3_write_buffer_cdb_t *)libscsi_action_get_cdb(action);
+
+	wb_cdb->wbc_mode = SPC3_WB_MODE_DL_UCODE_OFFS_SAVE;
+
+	wb_cdb->wbc_buffer_offset[0] = (off >> 16) & 0xff;
+	wb_cdb->wbc_buffer_offset[1] = (off >> 8) & 0xff;
+	wb_cdb->wbc_buffer_offset[2] = off & 0xff;
+
+	wb_cdb->wbc_bufferid = verifier->flashbuf;
+
+	wb_cdb->wbc_parameter_list_len[0] = (len >> 16) & 0xff;
+	wb_cdb->wbc_parameter_list_len[1] = (len >> 8) & 0xff;
+	wb_cdb->wbc_parameter_list_len[2] = len & 0xff;
+
+	logmsg(MSG_INFO, "%s: spc3_write_buffer_cdb_t opcode: %d\n",
+	    flashdev->drvname, wb_cdb->wbc_opcode);
+
+	if (libscsi_exec(action, target) != 0) {
+		logmsg(MSG_ERROR, "%s: failed to execute SCSI WRITE BUFFER: %s\n",
+		    flashdev->drvname, libscsi_errmsg(handle));
+		goto err;
+	}
+
+	if ((samstatus = libscsi_action_get_status(action)) ==
+	    SAM4_STATUS_CHECK_CONDITION) {
+		uint64_t asc = 0, ascq = 0, key = 0;
+		const char *code, *keystr;
+
+		if (libscsi_action_parse_sense(action, &key, &asc, &ascq,
+		    NULL) != 0) {
+			logmsg(MSG_ERROR, "%s: failed to write firmware. "
+			    "Received CHECK_CONDITION that cannot be parsed.\n",
+			    flashdev->drvname);
+			goto err;
+		}
+
+		code = libscsi_sense_code_name(asc, ascq);
+		keystr = libscsi_sense_key_name(key);
+
+		logmsg(MSG_ERROR, "%s: failed to write firmware: received "
+		    "sense key %llu (%s) additional sense code 0x%llx/0x%llx "
+		    "(%s)\n", flashdev->drvname, key,
+		    keystr != NULL ? keystr : "<unknown>",
+		    asc, ascq, code != NULL ? code : "<unknown>");
+		goto err;
+	} else if (samstatus != SAM4_STATUS_GOOD) {
+		int i;
+
+		logmsg(MSG_ERROR, "%s: SCSI buffer data write failed:",
+		    flashdev->drvname);
+		for (i = 0; i < NSAM4_STATUS; i++) {
+			if (samstatus == sam4_status[i].sam_status) {
+				logmsg(MSG_ERROR, "%s\n", sam4_status[i].sam_message);
+				goto err;
+			}
+		}
+		logmsg(MSG_ERROR, "unknown error: %d\n", samstatus);
+		goto err;
+	} else {
+		logmsg(MSG_INFO, "%s: received STATUS GOOD\n",
+		    flashdev->drvname);
+	}
+
+	libscsi_action_free(action);
+	return (FWFLASH_SUCCESS);
+
+err:
+	if (action != NULL)
+		libscsi_action_free(action);
+	return (FWFLASH_FAILURE);
+}
+
 int
 fw_writefw(struct devicelist *flashdev)
 {
-	int rv;
-	int i = 0;
 	libscsi_hdl_t	*handle;
 	libscsi_target_t *target;
-	libscsi_action_t *action;
 	libscsi_errno_t serr;
-	spc3_write_buffer_cdb_t *wb_cdb;
-	sam4_status_t samstatus;
+	size_t maxxfer, nwrite;
+	uint8_t align;
+	int ret = FWFLASH_FAILURE;
 
 	if ((verifier == NULL) || (verifier->imgsize == 0) ||
 	    (verifier->fwimage == NULL)) {
@@ -168,8 +353,8 @@ fw_writefw(struct devicelist *flashdev)
 		return (FWFLASH_FAILURE);
 	}
 
-	if ((target = libscsi_open(handle, NULL, flashdev->access_devname))
-	    == NULL) {
+	if ((target = libscsi_open(handle, NULL, flashdev->access_devname)) ==
+	    NULL) {
 		logmsg(MSG_ERROR,
 		    gettext("%s: unable to open device %s\n"),
 		    flashdev->drvname, flashdev->access_devname);
@@ -177,55 +362,95 @@ fw_writefw(struct devicelist *flashdev)
 		return (FWFLASH_FAILURE);
 	}
 
-	action = libscsi_action_alloc(handle, SPC3_CMD_WRITE_BUFFER,
-	    LIBSCSI_AF_WRITE|LIBSCSI_AF_RQSENSE,
-	    (void *)verifier->fwimage, (size_t)verifier->imgsize);
+	if (libscsi_max_transfer(target, &maxxfer) != 0) {
+		logmsg(MSG_ERROR, gettext("%s: failed to determine device "
+		    "maximum transfer size: %s\n"), flashdev->drvname,
+		    libscsi_errmsg(handle));
+		goto err;
+	}
 
-	wb_cdb = (spc3_write_buffer_cdb_t *)libscsi_action_get_cdb(action);
+	if (sdfw_read_descriptor(flashdev, handle, target, &align) !=
+	    FWFLASH_SUCCESS) {
+		goto err;
+	}
 
-	wb_cdb->wbc_mode = SPC3_WB_MODE_DL_UCODE_SAVE;
-	wb_cdb->wbc_bufferid = verifier->flashbuf;
+	/*
+	 * Because we're requesting sense information, we need to take that into
+	 * account.
+	 */
+	maxxfer -= sizeof (struct scsi_arq_status);
 
-	wb_cdb->wbc_buffer_offset[0] = 0;
-	wb_cdb->wbc_buffer_offset[1] = 0;
-	wb_cdb->wbc_buffer_offset[2] = 0;
+	/*
+	 * If the maximum transfer size is less than the maximum image size then
+	 * we have to do some additional work. We need to read the descriptor
+	 * via a READ BUFFER command and make sure that we support the required
+	 * offset alignment. Note that a value of 0xff indicates that it doesn't support
+	 * it. Otherwise a value in align represents a required offset alignment
+	 * of 2^off. From there, we make sure that this works for our partial
+	 * write size and that our partial write size fits in the maximum
+	 * transfer size.
+	 */
+	if (maxxfer < verifier->imgsize) {
+		logmsg(MSG_INFO, "%s: Maximum transfer is %d, required "
+		    "alignment is 2^%d\n", flashdev->drvname, maxxfer, align);
+		if (FW_SD_PARTIAL_WRITE_SIZE > maxxfer) {
+			logmsg(MSG_ERROR, "%s: cannot write firmware image: "
+			    "HBA enforces a maximum transfer size of %d bytes, "
+			    "but the default partial transfer size is %d "
+			    "bytes\n", flashdev->drvname, maxxfer,
+			    FW_SD_PARTIAL_WRITE_SIZE);
+			goto err;
+		}
+		maxxfer = FW_SD_PARTIAL_WRITE_SIZE;
 
-	wb_cdb->wbc_parameter_list_len[0] =
-	    (verifier->imgsize & 0xff0000) >> 16;
-	wb_cdb->wbc_parameter_list_len[1] = (verifier->imgsize & 0xff00) >> 8;
-	wb_cdb->wbc_parameter_list_len[2] = (verifier->imgsize & 0xff);
+		if (ffsll(maxxfer) < align || align == 0xff) {
+			logmsg(MSG_ERROR, "%s: cannot write firmware image: "
+			    "device requires partial writes aligned to an "
+			    "unsupported value\n", flashdev->drvname);
+			goto err;
+		}
 
-	rv = libscsi_exec(action, target);
-	samstatus = libscsi_action_get_status(action);
+		logmsg(MSG_INFO, "%s: final transfer block size is %d\n",
+		    flashdev->drvname, maxxfer);
+	}
 
-	logmsg(MSG_INFO, "\nscsi_writebuffer: ret 0x%0x, samstatus 0x%0x\n",
-	    rv, samstatus);
+	logmsg(MSG_INFO, "%s: Writing out %d bytes to %s\n", flashdev->drvname,
+	    verifier->imgsize, flashdev->access_devname);
+	nwrite = 0;
+	for (;;) {
+		uintptr_t buf;
+		size_t towrite = MIN(maxxfer, verifier->imgsize - nwrite);
 
-	libscsi_action_free(action);
-	libscsi_close(handle, target);
-	libscsi_fini(handle);
+		if (towrite == 0)
+			break;
 
-	if (rv != FWFLASH_SUCCESS)
-		return (FWFLASH_FAILURE);
+		buf = (uintptr_t)verifier->fwimage;
+		buf += nwrite;
 
-	for (i = 0; i < NSAM4_STATUS; i++) {
-		if (sam4_status[i].status == samstatus) {
-			logmsg(MSG_ERROR, gettext("RETURN STATUS: %s\n"),
-			    (sam4_status[i].message));
-			break;
+		if (sdfw_write(flashdev, handle, target, towrite, nwrite,
+		    (void *)buf) != FWFLASH_SUCCESS) {
+			logmsg(MSG_ERROR, gettext("%s: failed to write to %s "
+			    "successfully: %s\n"), flashdev->drvname,
+			    flashdev->access_devname, libscsi_errmsg(handle));
+			goto err;
 		}
-	}
-	if (i == NSAM4_STATUS)
-		logmsg(MSG_ERROR, gettext("Status UNKNOWN\n"));
 
-	if (samstatus == SAM4_STATUS_GOOD) {
-		logmsg(MSG_ERROR, gettext("Note: For flash based disks "
-		    "(SSD, etc). You may need power off the system to wait a "
-		    "few minutes for supercap to fully discharge, then power "
-		    "on the system again to activate the new firmware\n"));
-		return (FWFLASH_SUCCESS);
+		nwrite += towrite;
 	}
-	return (FWFLASH_FAILURE);
+
+	logmsg(MSG_ERROR, gettext("Note: For flash based disks "
+	    "(SSD, etc). You may need power off the system to wait a "
+	    "few minutes for supercap to fully discharge, then power "
+	    "on the system again to activate the new firmware\n"));
+	ret = FWFLASH_SUCCESS;
+
+err:
+	if (target != NULL)
+		libscsi_close(handle, target);
+	if (handle != NULL)
+		libscsi_fini(handle);
+
+	return (ret);
 }
 
 /*
@@ -300,8 +525,8 @@ fw_identify(int start)
 			continue;
 		}
 
-		if ((newdev = calloc(1, sizeof (struct devicelist)))
-		    == NULL) {
+		if ((newdev = calloc(1, sizeof (struct devicelist))) ==
+		    NULL) {
 			logmsg(MSG_ERROR,
 			    gettext("%s: identification function unable "
 			    "to allocate space for device entry\n"),
@@ -311,8 +536,8 @@ fw_identify(int start)
 			return (FWFLASH_FAILURE);
 		}
 
-		if ((newdev->drvname = calloc(1, strlen(driver) + 1))
-		    == NULL) {
+		if ((newdev->drvname = calloc(1, strlen(driver) + 1)) ==
+		    NULL) {
 			logmsg(MSG_ERROR,
 			    gettext("%s: Unable to allocate space to store a "
 			    "driver name\n"), driver);
@@ -322,8 +547,8 @@ fw_identify(int start)
 		}
 		(void) strlcpy(newdev->drvname, driver, strlen(driver) + 1);
 
-		if ((newdev->classname = calloc(1, strlen(driver) + 1))
-		    == NULL) {
+		if ((newdev->classname = calloc(1, strlen(driver) + 1)) ==
+		    NULL) {
 			logmsg(MSG_ERROR,
 			    gettext("%s: Unable to allocate space for a class "
 			    "name\n"), drivername);
@@ -345,12 +570,12 @@ fw_identify(int start)
 
 		/* The slice number may be 2 or 0, we will try 2 first */
 		(void) snprintf(newdev->access_devname, MAXPATHLEN,
-		    "%s%s:c,raw", devprefix, devpath);
+		    "%s%s:c,raw", sdfw_devprefix, devpath);
 		if ((target = libscsi_open(handle, NULL,
 		    newdev->access_devname)) == NULL) {
 			/* try 0 for EFI label */
 			(void) snprintf(newdev->access_devname, MAXPATHLEN,
-			    "%s%s:a,raw", devprefix, devpath);
+			    "%s%s:a,raw", sdfw_devprefix, devpath);
 			if ((target = libscsi_open(handle, NULL,
 			    newdev->access_devname)) == NULL) {
 				logmsg(MSG_INFO,
@@ -362,7 +587,7 @@ fw_identify(int start)
 		}
 
 		/* and the /dev/rdsk/ name */
-		if ((newdev->addresses[0] = find_link(thisnode,
+		if ((newdev->addresses[0] = sdfw_find_link(thisnode,
 		    newdev->access_devname)) == NULL) {
 			libscsi_fini(handle);
 			FW_SD_FREE_ACC_NAME(newdev, devpath)
@@ -423,7 +648,7 @@ fw_identify(int start)
 				 * There is no SPACE character in the PID field
 				 * Customize strings for special SATA disks
 				 */
-				if (sd_idtfy_custmz(newdev, sp_temp)
+				if (sdfw_idtfy_custmz(newdev, sp_temp)
 				    != FWFLASH_SUCCESS) {
 					libscsi_close(handle, target);
 					libscsi_fini(handle);
@@ -483,8 +708,8 @@ fw_identify(int start)
 
 		/* Revision ID */
 		sp_temp = (char *)libscsi_revision(target);
-		if ((newdev->ident->revid = calloc(1, strlen(sp_temp) + 1))
-		    == NULL || sp_temp == NULL) {
+		if ((newdev->ident->revid = calloc(1, strlen(sp_temp) + 1)) ==
+		    NULL || sp_temp == NULL) {
 			logmsg(MSG_ERROR, gettext("%s: unable to get revision "
 			    "id of %s\n"), newdev->drvname,
 			    newdev->access_devname);
@@ -634,7 +859,7 @@ fw_cleanup(struct devicelist *thisdev)
  * Helper functions
  */
 static int
-link_cb(di_devlink_t devlink, void *arg)
+sdfw_link_cb(di_devlink_t devlink, void *arg)
 {
 	const char *result;
 
@@ -645,14 +870,14 @@ link_cb(di_devlink_t devlink, void *arg)
 		(void) strlcpy(arg, result, strlen(result) + 1);
 	}
 
-	logmsg(MSG_INFO, "\nlink_cb::linkdata->resultstr = %s\n",
+	logmsg(MSG_INFO, "\nsdfw_link_cb::linkdata->resultstr = %s\n",
 	    ((result != NULL) ? result : "(null)"));
 
 	return (DI_WALK_CONTINUE);
 }
 
 static char *
-find_link(di_node_t bnode, char *acc_devname)
+sdfw_find_link(di_node_t bnode, char *acc_devname)
 {
 	di_minor_t devminor = DI_MINOR_NIL;
 	di_devlink_handle_t hdl;
@@ -661,7 +886,7 @@ find_link(di_node_t bnode, char *acc_devname)
 
 	if (bnode == DI_NODE_NIL) {
 		logmsg(MSG_ERROR,
-		    gettext("find_link must be called with non-null "
+		    gettext("sdfw_find_link must be called with non-null "
 		    "di_node_t\n"));
 		return (NULL);
 	}
@@ -690,8 +915,8 @@ find_link(di_node_t bnode, char *acc_devname)
 	}
 
 	errno = 0;
-	if (di_devlink_walk(hdl, linkname, acc_devname + strlen(devprefix),
-	    DI_PRIMARY_LINK, (void *)cbresult, link_cb) < 0) {
+	if (di_devlink_walk(hdl, linkname, acc_devname + strlen(sdfw_devprefix),
+	    DI_PRIMARY_LINK, (void *)cbresult, sdfw_link_cb) < 0) {
 		logmsg(MSG_ERROR,
 		    gettext("Unable to walk devlink snapshot for %s: %s\n"),
 		    acc_devname, strerror(errno));
@@ -710,7 +935,7 @@ find_link(di_node_t bnode, char *acc_devname)
 }
 
 static int
-sd_idtfy_custmz(struct devicelist *device, char *sp)
+sdfw_idtfy_custmz(struct devicelist *device, char *sp)
 {
 	/* vid customization */
 	if (strncmp(sp, "ST", 2) == 0) {
diff --git a/usr/src/cmd/fwflash/plugins/vendor/sd-GENERIC.c b/usr/src/cmd/fwflash/plugins/vendor/sd-GENERIC.c
index d66339226f..eee80ba4d5 100644
--- a/usr/src/cmd/fwflash/plugins/vendor/sd-GENERIC.c
+++ b/usr/src/cmd/fwflash/plugins/vendor/sd-GENERIC.c
@@ -1,89 +1,136 @@
 /*
- * CDDL HEADER START
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
  *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
  */
+
 /*
- * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
+ * Copyright 2016 Joyent, Inc.
  */
 
+/*
+ * This is a general firmware flash plugin that does basic verification for
+ * devices backed by sd(7D).
+ * 
+ * Using the sd(7D) targ for firmware flashing uses the general SCSI WRITE
+ * BUFFER options with various modes to instruct the drive to download and
+ * install microcode (what SPC-3 calls firmware). To verify that something fits,
+ * we can use the READ BUFFER command with mode 03h to indicate that we want to
+ * buffer's descriptor. This gives us both the buffer's total size.
+ *
+ * Unfortunately it's impossible to know for certain if that size is supposed to
+ * be equivalent to microcode's. While a READ BUFFER Is supposed to return the
+ * same data as with a WRITE BUFFER command.
+ */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/sysmacros.h>
-#include <fcntl.h>
-#include <sys/condvar.h>
-#include <string.h>
-#include <strings.h>
-
-#include <sys/byteorder.h>
-
-#include <libintl.h> /* for gettext(3c) */
+#include <libintl.h>
 #include <fwflash/fwflash.h>
+#include <scsi/libscsi.h>
 
-char vendor[] = "GENERIC \0";
-
-/* MAXIMGSIZE = 1.4 * 1024 * 1024 bytes */
-/* Currently the largest firmware image size is 1.4 MB */
-/* 1468006 = 1.4 * 1024 * 1024 */
-#define	MAXIMGSIZE	((unsigned int)(1468006))
-
+/*
+ * The fwflash plugin interface is a bit odd for a modern committed interface
+ * and requires us to refer to data objects in the parent explicitly to get
+ * access to and set various information. It also doesn't allow us a means of
+ * setting data for our transport layer.
+ */
 extern struct vrfyplugin *verifier;
 
-/* required functions for this plugin */
-int vendorvrfy(struct devicelist *devicenode);
-
 /*
- * Important information about how this verification plugin works
- *
- * Direct-attached disks (sd instances) which support firmware
- * download accept image files up to 1.4 * 1024 * 1024 bytes in
- * size, and do their own verification of the image, rejecting the
- * file if it is not appropriate for them.
- *
- * All that we need to do here is set the various verifier fields
- * correctly, and check that the filesize as read from the filesystem
- * is less than 1.4 * 1024 * 1024 bytes.
+ * Declare the name of our vendor. This is required by the fwflash
+ * plugin interface. Note it must be a character array. Using a pointer may
+ * confuse the framework and its use of dlsym.
  */
+char vendor[] = "GENERIC";
 
 int
-vendorvrfy(struct devicelist *devicenode)
+vendorvrfy(struct devicelist *dvp)
 {
-	if (verifier->imgsize > MAXIMGSIZE) {
-		logmsg(MSG_ERROR,
-		    gettext("\nsd-GENERIC firmware image verifier: "
-		    "supplied filename %s exceeds maximum allowable "
-		    "size of %d bytes\n"),
-		    verifier->imgfile, MAXIMGSIZE);
+	libscsi_hdl_t *hdl = NULL;
+	libscsi_target_t *targ = NULL;
+	libscsi_action_t *act = NULL;
+	libscsi_errno_t serr;
+	spc3_read_buffer_cdb_t *rb_cdb;
+	uint8_t descbuf[4];
+	uint32_t size;
+
+	int ret = FWFLASH_FAILURE;
+
+	if ((hdl = libscsi_init(LIBSCSI_VERSION, &serr)) == NULL) {
+		logmsg(MSG_ERROR, gettext("%s: failed to initialize libscsi: %s\n"),
+		    verifier->vendor, libscsi_strerror(serr));
 		return (FWFLASH_FAILURE);
 	}
 
-	logmsg(MSG_INFO,
-	    "sd-GENERIC verifier for device\n"
-	    "vid %s, pid %s, rev %s\npath %s\n",
-	    devicenode->ident->vid,
-	    devicenode->ident->pid,
-	    devicenode->ident->revid,
-	    devicenode->addresses[0]);
+	if ((targ = libscsi_open(hdl, NULL, dvp->access_devname)) ==
+	    NULL) {
+		logmsg(MSG_ERROR,
+		    gettext("%s: unable to open device %s\n"),
+		    verifier->vendor, dvp->access_devname);
+		goto cleanup;
+	}
+
+	if ((act = libscsi_action_alloc(hdl, SPC3_CMD_READ_BUFFER,
+	    LIBSCSI_AF_READ, descbuf, sizeof (descbuf))) == NULL) {
+		logmsg(MSG_ERROR, "%s: failed to alloc scsi action: %s\n",
+		    verifier->vendor, libscsi_errmsg(hdl));
+		goto cleanup;
+	}
+
+	rb_cdb = (spc3_read_buffer_cdb_t *)libscsi_action_get_cdb(act);
+
+	rb_cdb->rbc_mode = SPC3_RB_MODE_DESCRIPTOR;
+	rb_cdb->rbc_bufferid = 0;
+
+	rb_cdb->rbc_allocation_len[0] = 0;
+	rb_cdb->rbc_allocation_len[1] = 0;
+	rb_cdb->rbc_allocation_len[2] = 4;
+
+	if (libscsi_exec(act, targ) != 0) {
+		logmsg(MSG_ERROR, "%s: failed to execute SCSI buffer descriptor read: %s\n",
+		    verifier->vendor, libscsi_errmsg(hdl));
+		goto cleanup;
+	}
+
+	if (libscsi_action_get_status(act) != SAM4_STATUS_GOOD) {
+		logmsg(MSG_ERROR, "%s: SCSI READ BUFFER command to determine "
+		    "maximum image size failed\n", verifier->vendor);
+		goto cleanup;
+	}
+
+	if (descbuf[0] == 0 && descbuf[1] == 0 && descbuf[2] == 0 &&
+	    descbuf[3] == 0) {
+		logmsg(MSG_ERROR, "%s: devices %s does not support firmware "
+		    "upgrade\n", verifier->vendor, dvp->access_devname);
+		goto cleanup;
+	}
+
+	size = (descbuf[1] << 16) | (descbuf[2] << 8) | descbuf[3];
+	logmsg(MSG_INFO, "%s: checking maximum image size %d against actual "
+	    "image size: %d\n", verifier->vendor, size, verifier->imgsize);
+	if (size < verifier->imgsize) {
+		logmsg(MSG_ERROR, gettext("%s: supplied firmware image %s "
+		    "exceeds maximum image size of %d\n"),
+		    verifier->vendor, verifier->imgfile, size);
+		goto cleanup;
+	}
+
+	logmsg(MSG_INFO, gettext("%s: successfully validated images %s\n"),
+	    verifier->vendor, verifier->imgfile);
+
 	verifier->flashbuf = 0;
+	ret = FWFLASH_SUCCESS;
+cleanup:
+	if (act != NULL)
+		libscsi_action_free(act);
+	if (targ != NULL)
+		libscsi_close(hdl, targ);
+	if (hdl != NULL)
+		libscsi_fini(hdl);
 
-	return (FWFLASH_SUCCESS);
+	return (ret);
 }
diff --git a/usr/src/lib/scsi/libscsi/common/libscsi.h b/usr/src/lib/scsi/libscsi/common/libscsi.h
index 4d57d1299c..d354969cd5 100644
--- a/usr/src/lib/scsi/libscsi/common/libscsi.h
+++ b/usr/src/lib/scsi/libscsi/common/libscsi.h
@@ -97,6 +97,7 @@ typedef struct libscsi_engine_ops {
 	void (*lseo_close)(libscsi_hdl_t *, void *);
 	int (*lseo_exec)(libscsi_hdl_t *, void *, libscsi_action_t *);
 	void (*lseo_target_name)(libscsi_hdl_t *, void *, char *, size_t);
+	int (*lseo_max_transfer)(libscsi_hdl_t *, void *, size_t *);
 } libscsi_engine_ops_t;
 
 typedef struct libscsi_engine {
@@ -116,6 +117,7 @@ extern libscsi_hdl_t *libscsi_get_handle(libscsi_target_t *);
 extern const char *libscsi_vendor(libscsi_target_t *);
 extern const char *libscsi_product(libscsi_target_t *);
 extern const char *libscsi_revision(libscsi_target_t *);
+extern int libscsi_max_transfer(libscsi_target_t *, size_t *);
 
 extern libscsi_errno_t libscsi_errno(libscsi_hdl_t *);
 extern const char *libscsi_errmsg(libscsi_hdl_t *);
diff --git a/usr/src/lib/scsi/libscsi/common/scsi_engine.c b/usr/src/lib/scsi/libscsi/common/scsi_engine.c
index 3c6d5ecee9..5b7fd0a3bb 100644
--- a/usr/src/lib/scsi/libscsi/common/scsi_engine.c
+++ b/usr/src/lib/scsi/libscsi/common/scsi_engine.c
@@ -616,3 +616,16 @@ libscsi_exec(libscsi_action_t *ap, libscsi_target_t *tp)
 
 	return (ret);
 }
+
+int
+libscsi_max_transfer(libscsi_target_t *tp, size_t *sizep)
+{
+	libscsi_hdl_t *hp = tp->lst_hdl;
+	if (tp->lst_engine->lse_ops->lseo_max_transfer == NULL) {
+		return (libscsi_error(hp, ESCSI_NOTSUP, "max transfer "
+		    "request not supported by engine"));
+	}
+
+	return (tp->lst_engine->lse_ops->lseo_max_transfer(hp, tp->lst_priv,
+	    sizep));
+}
diff --git a/usr/src/lib/scsi/libscsi/mapfile-vers b/usr/src/lib/scsi/libscsi/mapfile-vers
index 7e0d8e251c..067756f44b 100644
--- a/usr/src/lib/scsi/libscsi/mapfile-vers
+++ b/usr/src/lib/scsi/libscsi/mapfile-vers
@@ -71,6 +71,7 @@ SYMBOL_VERSION SUNWprivate_1.1 {
 		libscsi_vendor;
 		libscsi_product;
 		libscsi_revision;
+		libscsi_max_transfer;
 		libscsi_get_handle;
 
 		libscsi_alloc;
diff --git a/usr/src/lib/scsi/plugins/scsi/engines/uscsi/uscsi.c b/usr/src/lib/scsi/plugins/scsi/engines/uscsi/uscsi.c
index 06cdb0b339..235c5b42e0 100644
--- a/usr/src/lib/scsi/plugins/scsi/engines/uscsi/uscsi.c
+++ b/usr/src/lib/scsi/plugins/scsi/engines/uscsi/uscsi.c
@@ -24,8 +24,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <sys/types.h>
 #include <sys/scsi/impl/uscsi.h>
 #include <sys/scsi/generic/commands.h>
@@ -214,11 +212,43 @@ uscsi_target_name(libscsi_hdl_t *hp, void *private, char *buf, size_t len)
 	(void) snprintf(buf, len, "%s", dp->dev);
 }
 
+static int
+uscsi_max_transfer(libscsi_hdl_t *hp, void *private, size_t *sizep)
+{
+	uscsi_xfer_t xfer;
+	struct uscsi_dev *dp = (struct uscsi_dev *)private;
+
+	if (ioctl(dp->fd, USCSIMAXXFER, &xfer) < 0) {
+		ASSERT(errno != EFAULT);
+		switch (errno) {
+		case EINVAL:
+			return (libscsi_error(hp, ESCSI_BADCMD, "internal "
+			    "uscsi error"));
+		case EPERM:
+			return (libscsi_error(hp, ESCSI_PERM, "insufficient "
+			    "privileges "));
+		case ENOTTY:
+			return (libscsi_error(hp, ESCSI_NOTSUP, "max transfer "
+			    "request not supported on device"));
+		default:
+			return (libscsi_error(hp, ESCSI_SYS, "uscsi ioctl "
+			    "failed: %s", strerror(errno)));
+		}
+	}
+
+	if (xfer > SIZE_MAX)
+		xfer = SIZE_MAX;
+
+	*sizep = (size_t)xfer;
+	return (0);
+}
+
 static const libscsi_engine_ops_t uscsi_ops = {
 	.lseo_open = uscsi_open,
 	.lseo_close = uscsi_close,
 	.lseo_exec = uscsi_exec,
-	.lseo_target_name = uscsi_target_name
+	.lseo_target_name = uscsi_target_name,
+	.lseo_max_transfer = uscsi_max_transfer
 };
 
 static const libscsi_engine_t uscsi_engine = {
diff --git a/usr/src/man/man7i/uscsi.7i b/usr/src/man/man7i/uscsi.7i
index 3247f53cc1..9e7c44e116 100644
--- a/usr/src/man/man7i/uscsi.7i
+++ b/usr/src/man/man7i/uscsi.7i
@@ -349,6 +349,12 @@ See the \fBscsi_pkt\fR(9S) flag \fBFLAG_RENEGOTIATE_WIDE_SYNC\fR for more
 information.
 .RE
 
+The \fBuscsi_xfer_t\fR is a type definition that corresponds to a 64-bit
+unsigned integer. It should be used for the \fBUSCSIMAXXFER\fR ioctls. This is
+used for determinin the maximum transfer size that can be performed in a single
+\fBUSCSICMD\fR ioctl. If the SCSI request is larger than the specified size,
+then it may not work depending on the hardware platform.
+
 .SH IOCTLS
 .sp
 .LP
@@ -371,6 +377,21 @@ status, and Request Sense is enabled, the sense data itself is returned in
 Sense data transfer.
 .RE
 
+.sp
+.ne 2
+.na
+.B USCSIMAXXFER
+.ad
+.RS 12n
+The argument is a pointer to a \fBuscsi_xfer_t\fR value. The maximum transfer
+size that can be used with the \fBUSCSICMD\fR ioctl for the current device will
+be returned in the \fBuscsi_xfer_t\R.
+.sp
+.LP
+Not all devices which support the \fBUSCSICMD\fR ioctl also support the
+\fBUSCSIMAXXFER\fR ioctl.
+.RE
+
 .SH ERRORS
 .sp
 .ne 2
@@ -396,7 +417,8 @@ An error occurred during the execution of the command.
 \fB\fBEPERM\fR\fR
 .ad
 .RS 10n
-A process without root credentials tried to execute the \fBUSCSICMD\fR ioctl.
+A process without root credentials tried to execute the \fBUSCSICMD\fR or
+\fRUSCSIMAXXFER\fR ioctl.
 .RE
 
 .sp
@@ -405,8 +427,8 @@ A process without root credentials tried to execute the \fBUSCSICMD\fR ioctl.
 \fB\fBEFAULT\fR\fR
 .ad
 .RS 10n
-The \fBuscsi_cmd\fR itself, the \fBuscsi_cdb\fR, the \fBuscsi_buf\fR, or the
-\fBuscsi_rqbuf\fR point to an invalid address.
+The \fBuscsi_cmd\fR itself, the \fBuscsi_cdb\fR, the \fBuscsi_buf\fR,
+\fBuscsi_rqbuf\fR, or the \fBuscsi_xfer_t\fR point to an invalid address.
 .RE
 
 .SH ATTRIBUTES
@@ -450,7 +472,8 @@ number is used to send the command.
 The \fBuscsi\fR interface is not recommended for very large data transfers
 (typically more than 16MB). If the requested transfer size exceeds the maximum
 transfer size of the DMA engine, it will not be broken up into multiple
-transfers and DMA errors may result.
+transfers and DMA errors may result. The \fBUSCSIMAXXFER\fR ioctl can be used
+to determine the maximum size transfer.
 .sp
 .LP
 The \fBUSCSICMD\fR ioctl associates a \fBstruct uscsi_cmd\fR with a device by
diff --git a/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas.c b/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas.c
index dc5e8eafc9..b453b27c3b 100644
--- a/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas.c
+++ b/usr/src/uts/common/io/scsi/adapters/mpt_sas/mptsas.c
@@ -16407,6 +16407,8 @@ mptsas_addr_to_ptgt(mptsas_t *mpt, char *addr, mptsas_phymask_t phymask)
 static int
 mptsas_flush_led_status(mptsas_t *mpt, mptsas_target_t *ptgt)
 {
+	return (0);
+
 	uint32_t slotstatus = 0;
 
 	/* Build an MPI2 Slot Status based on our view of the world */
diff --git a/usr/src/uts/common/io/scsi/targets/sd.c b/usr/src/uts/common/io/scsi/targets/sd.c
index dc5dc22e37..acdc6c5cb5 100644
--- a/usr/src/uts/common/io/scsi/targets/sd.c
+++ b/usr/src/uts/common/io/scsi/targets/sd.c
@@ -14175,15 +14175,20 @@ sd_initpkt_for_uscsi(struct buf *bp, struct scsi_pkt **pktpp)
 
 	/*
 	 * Allocate the scsi_pkt for the command.
+	 *
 	 * Note: If PKT_DMA_PARTIAL flag is set, scsi_vhci binds a path
 	 *	 during scsi_init_pkt time and will continue to use the
 	 *	 same path as long as the same scsi_pkt is used without
-	 *	 intervening scsi_dma_free(). Since uscsi command does
+	 *	 intervening scsi_dmafree(). Since uscsi command does
 	 *	 not call scsi_dmafree() before retry failed command, it
 	 *	 is necessary to make sure PKT_DMA_PARTIAL flag is NOT
 	 *	 set such that scsi_vhci can use other available path for
 	 *	 retry. Besides, ucsci command does not allow DMA breakup,
 	 *	 so there is no need to set PKT_DMA_PARTIAL flag.
+	 *
+	 *	 More fundamentally, we can't support breaking up this DMA into
+	 *	 multiple windows on x86. There's no guarantee that like the
+	 *	 general I/O routines that these commands will be idempotent.
 	 */
 	if (uscmd->uscsi_rqlen > SENSE_LENGTH) {
 		pktp = scsi_init_pkt(SD_ADDRESS(un), NULL,
@@ -22408,6 +22413,7 @@ sdioctl(dev_t dev, int cmd, intptr_t arg, int flag, cred_t *cred_p, int *rval_p)
 		case MHIOCGRP_REGISTERANDIGNOREKEY:
 		case CDROMCLOSETRAY:
 		case USCSICMD:
+		case USCSIMAXXFER:
 			goto skip_ready_valid;
 		default:
 			break;
@@ -22844,6 +22850,23 @@ skip_ready_valid:
 		}
 		break;
 
+	case USCSIMAXXFER:
+		SD_TRACE(SD_LOG_IOCTL, un, "USCSICMD\n");
+		cr = ddi_get_cred();
+		if ((drv_priv(cred_p) != 0) && (drv_priv(cr) != 0)) {
+			err = EPERM;
+		} else {
+			const uscsi_xfer_t xfer = un->un_max_xfer_size;
+
+			if (ddi_copyout(&xfer, (void *)arg, sizeof (xfer),
+			    flag) != 0) {
+				err = EFAULT;
+			} else {
+				err = 0;
+			}
+		}
+		break;
+
 	case CDROMPAUSE:
 	case CDROMRESUME:
 		SD_TRACE(SD_LOG_IOCTL, un, "PAUSE-RESUME\n");
diff --git a/usr/src/uts/common/sys/scsi/impl/spc3_types.h b/usr/src/uts/common/sys/scsi/impl/spc3_types.h
index 456a0e336b..62531b8e0e 100644
--- a/usr/src/uts/common/sys/scsi/impl/spc3_types.h
+++ b/usr/src/uts/common/sys/scsi/impl/spc3_types.h
@@ -811,6 +811,30 @@ typedef struct spc3_persistent_reserve_in_cdb {
 	spc3_control_t pric_control;
 } spc3_persistent_reserve_in_cdb_t;
 
+/*
+ * SPC-3 6.15 READ BUFFER
+ */
+typedef struct spc3_read_buffer_cdb {
+	uint8_t rbc_opcode;
+	DECL_BITFIELD2(
+	    rbc_mode		:5,
+	    _reserved		:3);
+	uint8_t	rbc_bufferid;
+	uint8_t rbc_buffer_offset[3];
+	uint8_t rbc_allocation_len[3];
+	spc3_control_t rbc_control;
+} spc3_read_buffer_cdb_t;
+
+typedef enum spc3_read_buffer_mode {
+	SPC3_RB_MODE_COMB_HDR_DATA = 0x00,
+	SPC3_RB_MODE_VENDOR_SPECIFIC = 0x01,
+	SPC3_RB_MODE_DATA = 0x02,
+	SPC3_RB_MODE_DESCRIPTOR = 0x03,
+	SPC3_RB_MODE_ECHO_BUF = 0x0a,
+	SPC3_RB_MODE_ECHO_BUF_DESC = 0x0b,
+	SPC3_RB_MODE_ENABLE_EXPANDER_ECHO_BUF = 0x1a
+} spc3_read_buffer_mode_t;
+
 /*
  * SPC-3 6.16 READ MEDIA SERIAL NUMBER
  */
diff --git a/usr/src/uts/common/sys/scsi/impl/uscsi.h b/usr/src/uts/common/sys/scsi/impl/uscsi.h
index afce8ec081..f21b7f6156 100644
--- a/usr/src/uts/common/sys/scsi/impl/uscsi.h
+++ b/usr/src/uts/common/sys/scsi/impl/uscsi.h
@@ -185,11 +185,17 @@ struct uscsi_rqs32	{
 #define	RQS_OVR		0x01	/* RQS data has been overwritten */
 #define	RQS_VALID	0x02	/* RQS data is valid */
 
+/*
+ * Structure for USCSIMAXXFER ioctls
+ */
+typedef uint64_t	uscsi_xfer_t;
+
 /*
  * User SCSI io control command
  */
 #define	USCSIIOC	(0x04 << 8)
 #define	USCSICMD	(USCSIIOC|201) 	/* user scsi command */
+#define	USCSIMAXXFER	(USCSIIOC|202)	/* max request */
 
 #ifdef	_KERNEL
 
-- 
2.21.0

