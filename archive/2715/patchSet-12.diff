From a9aee7a57070eb7e260180390f7194d9e1adb765 Mon Sep 17 00:00:00 2001
From: Mike Zeller <mike.zeller@joyent.com>
Date: Mon, 23 Oct 2017 08:44:04 -0700
Subject: [PATCH] PUBAPI-1440 Want ListNetworkIPs and GetNetworkIP Reviewed by:
 Marsell Kukuljevic <marsell@joyent.com> Approved by: Marsell Kukuljevic
 <marsell@joyent.com>

---
 Makefile                  |   9 +-
 lib/endpoints/networks.js | 151 ++++++++++++++++++++++++
 test/networks.test.js     | 234 ++++++++++++++++++++++++++++++++++++--
 3 files changed, 379 insertions(+), 15 deletions(-)

diff --git a/Makefile b/Makefile
index 3878729..96706d3 100644
--- a/Makefile
+++ b/Makefile
@@ -51,14 +51,17 @@ NODE_PREBUILT_VERSION=v4.6.1
 ifeq ($(shell uname -s),SunOS)
 	NODE_PREBUILT_IMAGE=18b094b0-eb01-11e5-80c1-175dac7ddf02
 	NODE_PREBUILT_TAG=zone
+else
+	NPM=npm
+	NODE=node
+	NPM_EXEC=$(shell which npm)
+	NODE_EXEC=$(shell which node)
 endif
 
 
 include ./tools/mk/Makefile.defs
 ifeq ($(shell uname -s),SunOS)
 	include ./tools/mk/Makefile.node_prebuilt.defs
-else
-	include ./tools/mk/Makefile.node.defs
 endif
 include ./tools/mk/Makefile.smf.defs
 
@@ -222,8 +225,6 @@ plugins_test: provision_limits_plugin_test
 include ./tools/mk/Makefile.deps
 ifeq ($(shell uname -s),SunOS)
 	include ./tools/mk/Makefile.node_prebuilt.targ
-else
-	include ./tools/mk/Makefile.node.targ
 endif
 include ./tools/mk/Makefile.smf.targ
 include ./tools/mk/Makefile.targ
diff --git a/lib/endpoints/networks.js b/lib/endpoints/networks.js
index df124e3..d21e954 100644
--- a/lib/endpoints/networks.js
+++ b/lib/endpoints/networks.js
@@ -31,6 +31,8 @@ var IP_FIELDS = ['gateway', 'provision_end_ip', 'provision_start_ip',
     'resolvers', 'resolvers[0]', 'resolvers[1]', 'resolvers[2]',
     'resolvers[3]'];
 var MAX_RESOLVERS = 4;
+// Fields for Listing/Getting IPs
+var NETWORK_IP_FIELDS = ['ip', 'reserved', 'owner_uuid', 'belongs_to_uuid'];
 
 
 /*
@@ -45,6 +47,29 @@ function ensureFabricsEnabled(req, res, next) {
     return next();
 }
 
+/*
+ * Return an error if the network is not valid for the user
+ */
+function validateNetwork(req, res, next) {
+    var networkUuid = req.params.id;
+
+    var net = req.networks.find(function (n) {
+        return (n.uuid === networkUuid);
+    });
+
+    if (!net) {
+        return next(new ResourceNotFoundError('%s not found', networkUuid));
+    }
+
+    // Support for network pools is being tracked in PUBAPI-1441
+    if (Array.isArray(net.networks)) {
+        return next(new InvalidArgumentError(
+                        'network pools not supported'));
+    }
+
+    return next();
+}
+
 
 /*
  * Return request options suitable for making requests to other APIs
@@ -146,6 +171,30 @@ function translateNetwork(net) {
     return (obj);
 }
 
+function translateIp(ip, adminUuid) {
+    assert.object(ip, 'ip');
+    assert.uuid(adminUuid, 'admin uuid');
+
+    var obj = {};
+
+    NETWORK_IP_FIELDS.forEach(function (p) {
+        if (ip.hasOwnProperty(p)) {
+            obj[p] = ip[p];
+        }
+    });
+
+    obj.managed = (ip.belongs_to_type === "other" ||
+        ip.owner_uuid === adminUuid);
+
+    // Show users the IP but don't leak belongs_to_uuid or the admin uuid
+    if (obj.managed) {
+        delete obj.owner_uuid;
+        delete obj.belongs_to_uuid;
+    }
+
+    return (obj);
+}
+
 
 // --- Functions
 
@@ -215,6 +264,88 @@ function getNetwork(req, res, next) {
     return next();
 }
 
+function listNetworkIps(req, res, next) {
+    var napi = req.sdc.napi;
+    assert.ok(napi);
+
+    var adminUuid = req.config.ufds_admin_uuid;
+    assert.uuid(adminUuid, 'admin uuid');
+
+    var networkUuid = req.params.id;
+    //validNetwork should have already vaidated this exists
+    var net = req.networks.find(function findNetwork(n) {
+        return n.uuid === networkUuid;
+    });
+    assert.ok(net);
+
+    // If its a public network we need to filter by owner_uuid
+    var opts = net.hasOwnProperty('owner_uuids') ?
+        {} : { owner_uuid: req.account.uuid };
+
+    return napi.listIPs(networkUuid, opts, reqOpts(req),
+        function napiListIPs(err, ips) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        ips = ips.filter(function (ip) {
+            return ip.belongs_to_uuid || ip.reserved;
+        });
+
+        ips = ips.map(function translateIps(ip) {
+            return translateIp(ip, adminUuid);
+        });
+
+        req.log.debug({
+            ips: ips,
+            account: req.account.login
+        }, 'ListNetworkIPs done');
+
+        res.send(ips);
+        return next();
+    });
+}
+
+function getNetworkIp(req, res, next) {
+    var napi = req.sdc.napi;
+    assert.ok(napi);
+
+    var adminUuid = req.config.ufds_admin_uuid;
+    assert.uuid(adminUuid, 'admin uuid');
+
+    var networkUuid = req.params.id;
+    var _ip = req.params.ip_address;
+
+    //validNetwork should have already vaidated this exists
+    var net = req.networks.find(function findNetwork(n) {
+        return n.uuid === networkUuid;
+    });
+    assert.ok(net);
+
+    return napi.getIP(networkUuid, _ip, function napiGetIP(err, ip) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        // If its a public network we need to verify the owner_uuid
+        if (!net.hasOwnProperty('owner_uuids')) {
+            if (ip.owner_uuid !== req.account.uuid) {
+                return next(new ResourceNotFoundError('%s not found', _ip));
+            }
+        }
+
+        ip = translateIp(ip, adminUuid);
+
+        req.log.debug({
+            ip: ip,
+            account: req.account.login
+        }, 'GetNetworkIP done');
+
+        res.send(ip);
+        return next();
+    });
+}
+
 
 function listFabricVLANs(req, res, next) {
     assert.ok(req.account);
@@ -592,6 +723,26 @@ function mountNetworks(server, before, pre) {
         name: 'HeadNetwork'
     }, before, pre, getNetwork);
 
+    server.get({
+        path: '/:account/networks/:id/ips',
+        name: 'ListNetworkIPs'
+    }, before, pre, validateNetwork, listNetworkIps);
+
+    server.head({
+        path: '/:account/networks/:id/ips',
+        name: 'HeadNetworkIPs'
+    }, before, pre, validateNetwork, listNetworkIps);
+
+    server.get({
+        path: '/:account/networks/:id/ips/:ip_address',
+        name: 'GetNetworkIPs'
+    }, before, pre, validateNetwork, getNetworkIp);
+
+    server.head({
+        path: '/:account/networks/:id/ips/:ip_address',
+        name: 'HeadNetworkIPs'
+    }, before, pre, validateNetwork, getNetworkIp);
+
     return server;
 }
 
diff --git a/test/networks.test.js b/test/networks.test.js
index ac3bfc9..f244c73 100644
--- a/test/networks.test.js
+++ b/test/networks.test.js
@@ -21,13 +21,23 @@ var common = require('./common');
 var CLIENTS;
 var CLIENT;
 var SERVER;
+var OTHER;
 
 // Fixture names
 var NIC_TAG = 'sdccloudapitest_networks_nictag';
 var NETWORK1_NAME = 'sdccloudapitest_networks_network1';
 var NETWORK2_NAME = 'sdccloudapitest_networks_network2';
+var NETWORK3_NAME = 'sdccloudapitest_networks_network3';
 var POOL1_NAME = 'sdccloudapitest_networks_pool1';
 
+// Test variables
+var NO_SUCH_NETWORK_UUID = 'deaddead-c626-11e5-b674-334e7e514480';
+var RESERVED_IP = '10.99.92.25';
+var ZONE_IP1 = '10.99.90.52';
+var ZONE_IP2 = '10.99.90.53';
+var ZONE_UUID1 = 'c4311f24-de18-40b9-b57e-249f2aec7533';
+var ZONE_UUID2 = '5dd79db9-3d42-40a3-a600-7fa2984ff48c';
+
 
 // --- Helpers
 
@@ -61,6 +71,15 @@ function deleteFixtures(t, cb) {
                 next();
             });
         },
+        function deleteNetwork3(_, next) {
+            common.napiDeleteNetworkByName({
+                napi: CLIENT.napi,
+                name: NETWORK3_NAME
+            }, function (err) {
+                t.ifError(err, 'deleteNetwork3');
+                next();
+            });
+        },
         function deleteNicTag(_, next) {
             common.napiDeleteNicTagByName({
                 napi: CLIENT.napi,
@@ -106,6 +125,18 @@ function createFixtures(t, cb) {
                 next(err);
             });
         },
+        function mkTestNetwork3(_, next) {
+            var params = {
+                owner_uuids: [ CLIENT.account.uuid ],
+                gateway: '10.99.92.1'
+            };
+            createTestNetwork(NETWORK3_NAME, 92, params, function (err, net) {
+                t.ifError(err, 'createFixtures: ' + NETWORK3_NAME);
+                t.ok(net, 'createFixtures: network3');
+                fixtures.network3 = net;
+                next(err);
+            });
+        },
         function mkTestPool1(_, next) {
             var params = {
                 name: POOL1_NAME,
@@ -119,6 +150,50 @@ function createFixtures(t, cb) {
                 next(err);
             });
         },
+        function mkTestZoneIP1(_, next) {
+            var params = {
+                owner_uuid: CLIENT.account.uuid,
+                belongs_to_type: 'zone',
+                belongs_to_uuid: ZONE_UUID1
+            };
+            CLIENT.napi.updateIP(fixtures.network1.uuid, ZONE_IP1, params,
+                    function (err, ip) {
+                t.ifError(err, 'createFixtures: zone ip ' + ZONE_IP1);
+                t.ok(ip, 'createFixtures: reserved ip');
+                fixtures.ip2 = ip;
+                next(err);
+            });
+        },
+        /*
+         * Used to ensure a ListNetworkIPs doesn't leak other customers IPs
+         * on a public network
+         */
+        function mkTestZoneIP2(_, next) {
+            var params = {
+                owner_uuid: OTHER.account.uuid,
+                belongs_to_type: 'zone',
+                belongs_to_uuid: ZONE_UUID2
+            };
+            CLIENT.napi.updateIP(fixtures.network1.uuid, ZONE_IP2, params,
+                    function (err, ip) {
+                t.ifError(err, 'createFixtures: zone ip ' + ZONE_IP2);
+                t.ok(ip, 'createFixtures: reserved ip');
+                fixtures.ip3 = ip;
+                next(err);
+            });
+        },
+        function reserveIP(_, next) {
+            var params = {
+                reserved: true
+            };
+            CLIENT.napi.updateIP(fixtures.network3.uuid, RESERVED_IP, params,
+                    function (err, ip) {
+                t.ifError(err, 'createFixtures: reserved ip ' + RESERVED_IP);
+                t.ok(ip, 'createFixtures: reserved ip');
+                fixtures.ip1 = ip;
+                next(err);
+            });
+        },
         function getViewableNetworks(_, next) {
             CLIENT.napi.listNetworks({
                 provisionable_by: CLIENT.account.uuid
@@ -149,16 +224,21 @@ function createFixtures(t, cb) {
 }
 
 
-function createTestNetwork(name, octet, cb) {
-    var params = {
-        name: name,
-        vlan_id: 59,
-        subnet: '10.99.' + octet + '.0/24',
-        provision_start_ip: '10.99.' + octet + '.5',
-        provision_end_ip: '10.99.' + octet + '.250',
-        nic_tag: NIC_TAG
-    };
-    CLIENT.napi.createNetwork(params, cb);
+function createTestNetwork(name, octet, params, cb) {
+    if (typeof (params) === 'function') {
+        cb = params;
+        params = undefined;
+    }
+
+    var _params = params || {};
+    _params.name = name;
+    _params.vlan_id =  59;
+    _params.subnet = '10.99.' + octet + '.0/24';
+    _params.provision_start_ip = '10.99.' + octet + '.5';
+    _params.provision_end_ip = '10.99.' + octet + '.250';
+    _params.nic_tag = NIC_TAG;
+
+    CLIENT.napi.createNetwork(_params, cb);
 }
 
 
@@ -202,6 +282,7 @@ test('networks', function (tt) {
                     CLIENTS = clients;
                     CLIENT = clients.user;
                     SERVER = server;
+                    OTHER = clients.other;
                     next();
                 });
             },
@@ -307,7 +388,6 @@ test('networks', function (tt) {
 
 
     tt.test('  get network (404)', function (t) {
-        var NO_SUCH_NETWORK_UUID = 'deaddead-c626-11e5-b674-334e7e514480';
         CLIENT.get('/my/networks/' + NO_SUCH_NETWORK_UUID,
                 function (err, req, res, body) {
             common.checkNotFound(t, err, req, res, body);
@@ -315,6 +395,138 @@ test('networks', function (tt) {
         });
     });
 
+    tt.test('  get network ips (404)', function (t) {
+        var path = format('/my/networks/%s/ips', NO_SUCH_NETWORK_UUID);
+        CLIENT.get(path, function (err, req, res, body) {
+            common.checkNotFound(t, err, req, res, body);
+            t.end();
+        });
+    });
+
+    /*
+     *  On public networks we should only see provisioned ips owned
+     *  by the specific user.
+     */
+    tt.test('  get network ips (public)', function (t) {
+        var out = [
+            {
+                ip: ZONE_IP1,
+                reserved: false,
+                managed: false,
+                belongs_to_uuid: ZONE_UUID1,
+                owner_uuid: CLIENT.account.uuid
+            }
+        ];
+        var path = format('/my/networks/%s/ips', fixtures.network1.uuid);
+        CLIENT.get(path, function (err, req, res, body) {
+            t.ifError(err, 'GET /my/networks/' + fixtures.network1.uuid +
+                '/ips error');
+            t.equal(res.statusCode, 200, 'GET /my/networks/:uuid/ips status');
+            common.checkHeaders(t, res.headers);
+            t.ok(body, 'GET /my/networks/:uuid/ips body');
+            t.deepEqual(body, out, 'ListNetworkIPs shows only reserved and '
+                + 'provisioned ips OK');
+            t.end();
+        });
+    });
+
+    /*
+     *  On private networks we should see provisioned/reserved ips
+     *  as well as 'triton_protected' ips such as the broadcast/gateway
+     */
+    tt.test('  get network ips (owner)', function (t) {
+        var out = [
+            {
+                ip: '10.99.92.1',
+                managed: true,
+                reserved: true
+            },
+            {
+                ip: RESERVED_IP,
+                managed: false,
+                reserved: true
+            },
+            {
+                ip: '10.99.92.255',
+                managed: true,
+                reserved: true
+            }
+        ];
+        var path = format('/my/networks/%s/ips', fixtures.network3.uuid);
+        CLIENT.get(path, function (err, req, res, body) {
+            t.ifError(err, 'GET /my/networks/' + fixtures.network3.uuid +
+                '/ips error');
+            t.equal(res.statusCode, 200, 'GET /my/networks/:uuid/ips status');
+            common.checkHeaders(t, res.headers);
+            t.ok(body, 'GET /my/networks/:uuid/ips body');
+            t.deepEqual(body, out, 'ListNetworkIPs shows only reserved and '
+                + 'provisioned ips OK');
+            t.end();
+        });
+    });
+
+    tt.test('  get network ip (404)', function (t) {
+        var path = format('/my/networks/%s/ips/10.99.98.1',
+            fixtures.network3.uuid);
+        CLIENT.get(path, function (err, req, res, body) {
+            common.checkNotFound(t, err, req, res, body);
+            t.end();
+        });
+    });
+
+    // GET of owned IP on public network works
+    tt.test('  get ip on public network (owner)', function (t) {
+        var out = {
+            ip: ZONE_IP1,
+            managed: false,
+            reserved: false,
+            belongs_to_uuid: ZONE_UUID1,
+            owner_uuid: CLIENT.account.uuid
+        };
+        var path = format('/my/networks/%s/ips/%s', fixtures.network1.uuid,
+            ZONE_IP1);
+        CLIENT.get(path, function (err, req, res, body) {
+            t.ifError(err, 'GET /my/networks/' + fixtures.network1.uuid +
+                '/ips/' + ZONE_IP1 + ' error');
+            t.equal(res.statusCode, 200,
+                'GET /my/networks/:uuid/ips/:ip_address status');
+            common.checkHeaders(t, res.headers);
+            t.ok(body, 'GET /my/networks/:uuid/ips/:ip_address body');
+            t.deepEqual(body, out, 'GetNetworkIP works on owned IP');
+            t.end();
+        });
+    });
+
+    //  GET of unowned IP on a public network returns 404
+    tt.test('  get ip on public network (not owner)', function (t) {
+        var path = format('/my/networks/%s/ips/%s', fixtures.network1.uuid,
+            ZONE_IP2);
+        CLIENT.get(path, function (err, req, res, body) {
+            common.checkNotFound(t, err, req, res, body);
+            t.end();
+        });
+    });
+
+    // GET of IP on private network works
+    tt.test('  get ip on private network (owner)', function (t) {
+        var out = {
+            ip: RESERVED_IP,
+            reserved: true,
+            managed: false
+        };
+        var path = format('/my/networks/%s/ips/%s', fixtures.network3.uuid,
+            RESERVED_IP);
+        CLIENT.get(path, function (err, req, res, body) {
+            t.ifError(err, 'GET /my/networks/' + fixtures.network3.uuid +
+                '/ips/' + RESERVED_IP + ' error');
+            t.equal(res.statusCode, 200,
+                'GET /my/networks/:uuid/ips/:ip_address status');
+            common.checkHeaders(t, res.headers);
+            t.ok(body, 'GET /my/networks/:uuid/ips/:ip_address body');
+            t.deepEqual(body, out, 'GetNetworkIP works on private network');
+            t.end();
+        });
+    });
 
     tt.test('  teardown', function (t) {
         vasync.pipeline({ funcs: [
-- 
2.21.0

