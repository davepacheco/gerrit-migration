From c17fde15f1c8d35939053d7b7469d5e9955c1224 Mon Sep 17 00:00:00 2001
From: Mike Zeller <mike.zeller@joyent.com>
Date: Thu, 2 Nov 2017 13:01:19 -0700
Subject: [PATCH] PUBAPI-1440 Want ListNetworkIPs and GetNetworkIP

---
 docs/index.md             | 177 ++++++++++++++++++++++++++++
 lib/endpoints/networks.js | 189 ++++++++++++++++++++++++++++++
 test/networks.test.js     | 234 ++++++++++++++++++++++++++++++++++++--
 3 files changed, 589 insertions(+), 11 deletions(-)

diff --git a/docs/index.md b/docs/index.md
index 6e30006..74592f3 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -8312,7 +8312,184 @@ or
     }
 
 
+## ListNetworkIPs (GET /:login/networks/:id/ips)
 
+List a network's IPs. On a public network only IPs owned by the user will be
+returned.  On a private network all IPs that are either reserved or allocated
+will be returned.
+
+Note that not every network from [ListNetworks](#ListNetworks) will work. Some
+UUIDs are for pools which are not supported at this time.  However, every
+network UUID from [GetMachine](#GetMachine) and [GetNic](#GetNic) will work, as
+they are UUIDs for a specific network.
+
+The `reserved` field determines if the IP can be used automatically when
+provisioning a new instance. If `reserved` is set to true, then the IP will not
+be given out.
+
+The `managed` field in the IP object tells you if the IP is manged by Triton
+itself. An example of this is the gateway and broadcast IPs on a network.
+
+If the IP is associated with an instance then `owner_uuid` will be shown as
+well, so that on shared private networks it is clear who is using the IP.  The
+`belongs_to_uuid` field will tell you which instance owns the IP if any, and
+will only be present if that instance is owned by you.
+
+You can paginate this API by passing in `offset` and `limit`.  HTTP responses
+will contain the additional headers `x-resource-count` and `x-query-limit`.  If
+`x-resource-count` is less than `x-query-limit`, you're done, otherwise call the
+API again with `offset` set to `offset` + `limit` to fetch additional instances.
+
+### Inputs
+
+**Field**    | **Type** | **Description**
+------------ | -------- | ---------------
+limit        | Number   | Return a max of N IPs; default is 1000 (which is also the maximum allowable result set size)
+offset       | Number   | Get a `limit` number of IPs starting at this `offset`
+
+### Returns
+
+An array of IP objects.  IPs are:
+
+**Field**  | **Type**   | **Description**
+---------- | ---------- | ---------------
+ip         | String     | IP Address
+reserved   | Boolean    | Whether this IP is reserved or not
+managed    | Boolean    | True if the user cannot modify the IP via UpdateNetworkIP (example broadcast and gateway IPs)
+owner_uuid | UUID       | UUID of the owner that the instance is associated with (Optional)
+belongs_to_uuid | UUID  | UUID of the instance the IP is associated with (Optional)
+
+### Errors
+
+For all possible errors, see [CloudAPI HTTP Responses](#cloudapi-http-responses).
+
+**Error Code**   | **Description**
+---------------- | ---------------
+ResourceNotFound | If `:login` or `:id` does not exist
+
+### CLI Command
+
+    $ triton network ip list daeb93a2-532e-4bd4-8788-b6b30f10ac17
+
+#### Example Request
+
+    GET /my/networks/daeb93a2-532e-4bd4-8788-b6b30f10ac17/ips HTTP/1.1
+    authorization: Signature keyId="...
+    accept: application/json
+    accept-version: ~8
+    host: api.example.com
+
+#### Example Response
+
+    HTTP/1.1 200 OK
+    x-query-limit: 1000
+    x-resource-count: 4
+    Content-Type: application/json
+    Content-Length: 331
+    Access-Control-Allow-Origin: *
+    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, Api-Version, Response-Time
+    Access-Control-Allow-Methods: GET, HEAD
+    Access-Control-Expose-Headers: Api-Version, Request-Id, Response-Time
+    Connection: Keep-Alive
+    Content-MD5: +d/D0BiDjXGmeuxP93uZ5Q==
+    Date: Tue, 31 Oct 2017 20:49:11 GMT
+    Server: cloudapi/8.3.0
+    Api-Version: 8.0.0
+    Request-Id: fdbce926-fc33-456f-af3c-c39b59cd4066
+    Response-Time: 82
+
+    [
+      {
+        "ip": "192.168.128.1",
+        "reserved": true,
+        "managed": true
+      },
+      {
+        "ip": "192.168.128.4",
+        "reserved": true,
+        "managed": false
+      },
+      {
+        "ip": "192.168.128.5",
+        "reserved": false,
+        "owner_uuid": "7dfbbcda-4f62-cdf8-df31-d1e4d8d34c5e",
+        "belongs_to_uuid": "272a7a08-ddc7-c4b2-97bd-ae3257fd8eb9",
+        "managed": false
+      },
+      {
+        "ip": "192.168.131.255",
+        "reserved": true,
+        "managed": true
+      }
+    ]
+
+## GetNetworkIP (GET /:login/networks/:id/ips/:ip_address)
+
+Get a network's IP. On a public network you can only get an IP owned by you. On
+private network you can get an IP owned by any of the network's shared owners,
+however the `belongs_to_uuid` field will be omitted if you do not own the
+instance the IP is assocaited with.
+
+### Inputs
+
+* None
+
+### Returns
+
+An IP object:
+
+**Field**  | **Type**   | **Description**
+---------- | ---------- | ---------------
+ip         | String     | IP Address
+reserved   | Boolean    | Whether this IP is reserved or not
+managed    | Boolean    | True if the user cannot modify the IP via UpdateNetworkIP (example broadcast and gateway IPs)
+owner_uuid | UUID       | UUID of the owner that the instance is associated with (Optional)
+belongs_to_uuid | UUID  | UUID of the instance the IP is associated with (Optional)
+
+### Errors
+
+For all possible errors, see [CloudAPI HTTP Responses](#cloudapi-http-responses).
+
+**Error Code**   | **Description**
+---------------- | ---------------
+ResourceNotFound | If `:login`, `:id`, or `:ip_address` does not exist
+
+### CLI Command
+
+    $ triton network ip get daeb93a2-532e-4bd4-8788-b6b30f10ac17 192.168.128.5
+
+#### Example Request
+
+    GET /my/networks/daeb93a2-532e-4bd4-8788-b6b30f10ac17/ips/192.168.128.5 HTTP/1.1
+    authorization: Signature keyId="...
+    accept: application/json
+    accept-version: ~8
+    host: api.example.com
+
+#### Example Response
+
+    HTTP/1.1 200 OK
+    Content-Type: application/json
+    Content-Length: 164
+    Access-Control-Allow-Origin: *
+    Access-Control-Allow-Headers: Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, Api-Version, Response-Time
+    Access-Control-Allow-Methods: GET
+    Access-Control-Expose-Headers: Api-Version, Request-Id, Response-Time
+    Connection: Keep-Alive
+    Content-MD5: E65nD1+bNuM3eutsB/8lPw==
+    Date: Tue, 31 Oct 2017 20:54:03 GMT
+    Server: cloudapi/8.3.0
+    Api-Version: 8.0.0
+    Request-Id: a31097ad-6154-45a3-af08-e3dfddd70d22
+    Response-Time: 393
+
+    {
+      "ip": "192.168.128.5",
+      "reserved": false,
+      "owner_uuid": "7dfbbcda-4f62-cdf8-df31-d1e4d8d34c5e",
+      "belongs_to_uuid": "272a7a08-ddc7-c4b2-97bd-ae3257fd8eb9",
+      "managed": false
+    }
 
 # Nics
 
diff --git a/lib/endpoints/networks.js b/lib/endpoints/networks.js
index df124e3..867498f 100644
--- a/lib/endpoints/networks.js
+++ b/lib/endpoints/networks.js
@@ -31,6 +31,8 @@ var IP_FIELDS = ['gateway', 'provision_end_ip', 'provision_start_ip',
     'resolvers', 'resolvers[0]', 'resolvers[1]', 'resolvers[2]',
     'resolvers[3]'];
 var MAX_RESOLVERS = 4;
+// Fields for Listing/Getting IPs
+var NETWORK_IP_FIELDS = ['ip', 'reserved', 'owner_uuid', 'belongs_to_uuid'];
 
 
 /*
@@ -45,6 +47,29 @@ function ensureFabricsEnabled(req, res, next) {
     return next();
 }
 
+/*
+ * Return an error if the network is not valid for the user
+ */
+function validateNetworkForIps(req, res, next) {
+    var networkUuid = req.params.id;
+
+    var net = req.networks.find(function (n) {
+        return (n.uuid === networkUuid);
+    });
+
+    if (!net) {
+        return next(new ResourceNotFoundError('%s not found', networkUuid));
+    }
+
+    // Support for network pools is being tracked in PUBAPI-1441
+    if (Array.isArray(net.networks)) {
+        return next(new InvalidArgumentError('cannot get IPs in a network'
+            + ' pool: %s', net.uuid));
+    }
+
+    return next();
+}
+
 
 /*
  * Return request options suitable for making requests to other APIs
@@ -146,6 +171,56 @@ function translateNetwork(net) {
     return (obj);
 }
 
+/*
+ * Translate from an napi ip object to a cloudapi ip payload
+ *
+ * Fields exposed:
+ * - ip: always sent
+ * - reserved: always sent
+ * - managed: always sent (true when belongs_to_uuid == "other" ||
+ *   owner_uuid == adminUuid)
+ * - owner_uuid: only sent if the belongs_to_uuid field is set in the
+ *   napi object and it is not the adminUuid
+ * - belongs_to_uuid: if the field is set in napi, then we send it
+ *   only if the owner_uuid matches the uuid of the user making the request
+ *
+ *   Future fields:
+ *   - belongs_to_type: if/when napi becomes more descriptive providing
+ *   information like nat, router, volume etc
+ */
+function translateIp(ip, accountUuid, adminUuid) {
+    assert.object(ip, 'ip');
+    assert.uuid(accountUuid, 'accountUuid');
+    assert.uuid(adminUuid, 'adminUuid');
+
+    var obj = {};
+
+    NETWORK_IP_FIELDS.forEach(function (p) {
+        if (ip.hasOwnProperty(p)) {
+            obj[p] = ip[p];
+        }
+    });
+
+    obj.managed = (ip.belongs_to_type === "other" ||
+        ip.owner_uuid === adminUuid);
+
+    // Show users the IP but don't leak belongs_to_uuid or the admin uuid
+    if (obj.managed) {
+        delete obj.owner_uuid;
+        delete obj.belongs_to_uuid;
+    }
+
+    /*
+     * On networks with more than one owner we only expose belongs_to_uuid
+     * when the owner_uuid matches the user making the request
+     */
+    if (ip.owner_uuid !== accountUuid) {
+        delete obj.belongs_to_uuid;
+    }
+
+    return (obj);
+}
+
 
 // --- Functions
 
@@ -215,6 +290,100 @@ function getNetwork(req, res, next) {
     return next();
 }
 
+function listNetworkIps(req, res, next) {
+    var napi = req.sdc.napi;
+    assert.ok(napi);
+
+    var adminUuid = req.config.ufds_admin_uuid;
+    assert.uuid(adminUuid, 'admin uuid');
+
+    var networkUuid = req.params.id;
+    //validateNetwork should have already vaidated this exists
+    var net = req.networks.find(function findNetwork(n) {
+        return n.uuid === networkUuid;
+    });
+    assert.ok(net);
+
+    // If its a public network we need to filter by owner_uuid
+    var opts = net.hasOwnProperty('owner_uuids') ?
+        {} : { owner_uuid: req.account.uuid };
+
+    /*
+     * NAPI-437 We eventually would rather have napi support markers instead of
+     * offsets. These defaults currently map to napi's default limit and offset
+     * values
+     */
+    opts.limit = req.params.limit || 1000;
+    opts.offset = req.params.offset || 0;
+
+    return napi.listIPs(networkUuid, opts, reqOpts(req),
+        function napiListIPs(err, ips) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        ips = ips.filter(function (ip) {
+            return ip.belongs_to_uuid || ip.reserved;
+        });
+
+        ips = ips.map(function translateIps(ip) {
+            return translateIp(ip, req.account.uuid, adminUuid);
+        });
+
+        res.header('x-query-limit', opts.limit);
+        res.header('x-resource-count', ips.length);
+
+        req.log.debug({
+            ips: ips,
+            account: req.account.login
+        }, 'ListNetworkIPs done');
+
+        res.send(ips);
+        return next();
+    });
+}
+
+function getNetworkIp(req, res, next) {
+    var napi = req.sdc.napi;
+    assert.ok(napi);
+
+    var adminUuid = req.config.ufds_admin_uuid;
+    assert.uuid(adminUuid, 'admin uuid');
+
+    var networkUuid = req.params.id;
+    var _ip = req.params.ip_address;
+
+    //validateNetwork should have already vaidated this exists
+    var net = req.networks.find(function findNetwork(n) {
+        return n.uuid === networkUuid;
+    });
+    assert.ok(net);
+
+    return napi.getIP(networkUuid, _ip, function napiGetIP(err, ip) {
+        if (err) {
+            return next(translateErr(err));
+        }
+
+        // If its a public network we need to verify the owner_uuid
+        if (!net.hasOwnProperty('owner_uuids')) {
+            if (ip.owner_uuid !== req.account.uuid) {
+                return next(new ResourceNotFoundError('%s not found', _ip));
+            }
+        }
+
+        ip = translateIp(ip, req.account.uuid, adminUuid);
+
+        req.log.debug({
+            ip: ip,
+            networkUuid: networkUuid,
+            account: req.account.login
+        }, 'GetNetworkIP done');
+
+        res.send(ip);
+        return next();
+    });
+}
+
 
 function listFabricVLANs(req, res, next) {
     assert.ok(req.account);
@@ -592,6 +761,26 @@ function mountNetworks(server, before, pre) {
         name: 'HeadNetwork'
     }, before, pre, getNetwork);
 
+    server.get({
+        path: '/:account/networks/:id/ips',
+        name: 'ListNetworkIPs'
+    }, before, pre, validateNetworkForIps, listNetworkIps);
+
+    server.head({
+        path: '/:account/networks/:id/ips',
+        name: 'HeadNetworkIPs'
+    }, before, pre, validateNetworkForIps, listNetworkIps);
+
+    server.get({
+        path: '/:account/networks/:id/ips/:ip_address',
+        name: 'GetNetworkIPs'
+    }, before, pre, validateNetworkForIps, getNetworkIp);
+
+    server.head({
+        path: '/:account/networks/:id/ips/:ip_address',
+        name: 'HeadNetworkIPs'
+    }, before, pre, validateNetworkForIps, getNetworkIp);
+
     return server;
 }
 
diff --git a/test/networks.test.js b/test/networks.test.js
index ac3bfc9..f244c73 100644
--- a/test/networks.test.js
+++ b/test/networks.test.js
@@ -21,13 +21,23 @@ var common = require('./common');
 var CLIENTS;
 var CLIENT;
 var SERVER;
+var OTHER;
 
 // Fixture names
 var NIC_TAG = 'sdccloudapitest_networks_nictag';
 var NETWORK1_NAME = 'sdccloudapitest_networks_network1';
 var NETWORK2_NAME = 'sdccloudapitest_networks_network2';
+var NETWORK3_NAME = 'sdccloudapitest_networks_network3';
 var POOL1_NAME = 'sdccloudapitest_networks_pool1';
 
+// Test variables
+var NO_SUCH_NETWORK_UUID = 'deaddead-c626-11e5-b674-334e7e514480';
+var RESERVED_IP = '10.99.92.25';
+var ZONE_IP1 = '10.99.90.52';
+var ZONE_IP2 = '10.99.90.53';
+var ZONE_UUID1 = 'c4311f24-de18-40b9-b57e-249f2aec7533';
+var ZONE_UUID2 = '5dd79db9-3d42-40a3-a600-7fa2984ff48c';
+
 
 // --- Helpers
 
@@ -61,6 +71,15 @@ function deleteFixtures(t, cb) {
                 next();
             });
         },
+        function deleteNetwork3(_, next) {
+            common.napiDeleteNetworkByName({
+                napi: CLIENT.napi,
+                name: NETWORK3_NAME
+            }, function (err) {
+                t.ifError(err, 'deleteNetwork3');
+                next();
+            });
+        },
         function deleteNicTag(_, next) {
             common.napiDeleteNicTagByName({
                 napi: CLIENT.napi,
@@ -106,6 +125,18 @@ function createFixtures(t, cb) {
                 next(err);
             });
         },
+        function mkTestNetwork3(_, next) {
+            var params = {
+                owner_uuids: [ CLIENT.account.uuid ],
+                gateway: '10.99.92.1'
+            };
+            createTestNetwork(NETWORK3_NAME, 92, params, function (err, net) {
+                t.ifError(err, 'createFixtures: ' + NETWORK3_NAME);
+                t.ok(net, 'createFixtures: network3');
+                fixtures.network3 = net;
+                next(err);
+            });
+        },
         function mkTestPool1(_, next) {
             var params = {
                 name: POOL1_NAME,
@@ -119,6 +150,50 @@ function createFixtures(t, cb) {
                 next(err);
             });
         },
+        function mkTestZoneIP1(_, next) {
+            var params = {
+                owner_uuid: CLIENT.account.uuid,
+                belongs_to_type: 'zone',
+                belongs_to_uuid: ZONE_UUID1
+            };
+            CLIENT.napi.updateIP(fixtures.network1.uuid, ZONE_IP1, params,
+                    function (err, ip) {
+                t.ifError(err, 'createFixtures: zone ip ' + ZONE_IP1);
+                t.ok(ip, 'createFixtures: reserved ip');
+                fixtures.ip2 = ip;
+                next(err);
+            });
+        },
+        /*
+         * Used to ensure a ListNetworkIPs doesn't leak other customers IPs
+         * on a public network
+         */
+        function mkTestZoneIP2(_, next) {
+            var params = {
+                owner_uuid: OTHER.account.uuid,
+                belongs_to_type: 'zone',
+                belongs_to_uuid: ZONE_UUID2
+            };
+            CLIENT.napi.updateIP(fixtures.network1.uuid, ZONE_IP2, params,
+                    function (err, ip) {
+                t.ifError(err, 'createFixtures: zone ip ' + ZONE_IP2);
+                t.ok(ip, 'createFixtures: reserved ip');
+                fixtures.ip3 = ip;
+                next(err);
+            });
+        },
+        function reserveIP(_, next) {
+            var params = {
+                reserved: true
+            };
+            CLIENT.napi.updateIP(fixtures.network3.uuid, RESERVED_IP, params,
+                    function (err, ip) {
+                t.ifError(err, 'createFixtures: reserved ip ' + RESERVED_IP);
+                t.ok(ip, 'createFixtures: reserved ip');
+                fixtures.ip1 = ip;
+                next(err);
+            });
+        },
         function getViewableNetworks(_, next) {
             CLIENT.napi.listNetworks({
                 provisionable_by: CLIENT.account.uuid
@@ -149,16 +224,21 @@ function createFixtures(t, cb) {
 }
 
 
-function createTestNetwork(name, octet, cb) {
-    var params = {
-        name: name,
-        vlan_id: 59,
-        subnet: '10.99.' + octet + '.0/24',
-        provision_start_ip: '10.99.' + octet + '.5',
-        provision_end_ip: '10.99.' + octet + '.250',
-        nic_tag: NIC_TAG
-    };
-    CLIENT.napi.createNetwork(params, cb);
+function createTestNetwork(name, octet, params, cb) {
+    if (typeof (params) === 'function') {
+        cb = params;
+        params = undefined;
+    }
+
+    var _params = params || {};
+    _params.name = name;
+    _params.vlan_id =  59;
+    _params.subnet = '10.99.' + octet + '.0/24';
+    _params.provision_start_ip = '10.99.' + octet + '.5';
+    _params.provision_end_ip = '10.99.' + octet + '.250';
+    _params.nic_tag = NIC_TAG;
+
+    CLIENT.napi.createNetwork(_params, cb);
 }
 
 
@@ -202,6 +282,7 @@ test('networks', function (tt) {
                     CLIENTS = clients;
                     CLIENT = clients.user;
                     SERVER = server;
+                    OTHER = clients.other;
                     next();
                 });
             },
@@ -307,7 +388,6 @@ test('networks', function (tt) {
 
 
     tt.test('  get network (404)', function (t) {
-        var NO_SUCH_NETWORK_UUID = 'deaddead-c626-11e5-b674-334e7e514480';
         CLIENT.get('/my/networks/' + NO_SUCH_NETWORK_UUID,
                 function (err, req, res, body) {
             common.checkNotFound(t, err, req, res, body);
@@ -315,6 +395,138 @@ test('networks', function (tt) {
         });
     });
 
+    tt.test('  get network ips (404)', function (t) {
+        var path = format('/my/networks/%s/ips', NO_SUCH_NETWORK_UUID);
+        CLIENT.get(path, function (err, req, res, body) {
+            common.checkNotFound(t, err, req, res, body);
+            t.end();
+        });
+    });
+
+    /*
+     *  On public networks we should only see provisioned ips owned
+     *  by the specific user.
+     */
+    tt.test('  get network ips (public)', function (t) {
+        var out = [
+            {
+                ip: ZONE_IP1,
+                reserved: false,
+                managed: false,
+                belongs_to_uuid: ZONE_UUID1,
+                owner_uuid: CLIENT.account.uuid
+            }
+        ];
+        var path = format('/my/networks/%s/ips', fixtures.network1.uuid);
+        CLIENT.get(path, function (err, req, res, body) {
+            t.ifError(err, 'GET /my/networks/' + fixtures.network1.uuid +
+                '/ips error');
+            t.equal(res.statusCode, 200, 'GET /my/networks/:uuid/ips status');
+            common.checkHeaders(t, res.headers);
+            t.ok(body, 'GET /my/networks/:uuid/ips body');
+            t.deepEqual(body, out, 'ListNetworkIPs shows only reserved and '
+                + 'provisioned ips OK');
+            t.end();
+        });
+    });
+
+    /*
+     *  On private networks we should see provisioned/reserved ips
+     *  as well as 'triton_protected' ips such as the broadcast/gateway
+     */
+    tt.test('  get network ips (owner)', function (t) {
+        var out = [
+            {
+                ip: '10.99.92.1',
+                managed: true,
+                reserved: true
+            },
+            {
+                ip: RESERVED_IP,
+                managed: false,
+                reserved: true
+            },
+            {
+                ip: '10.99.92.255',
+                managed: true,
+                reserved: true
+            }
+        ];
+        var path = format('/my/networks/%s/ips', fixtures.network3.uuid);
+        CLIENT.get(path, function (err, req, res, body) {
+            t.ifError(err, 'GET /my/networks/' + fixtures.network3.uuid +
+                '/ips error');
+            t.equal(res.statusCode, 200, 'GET /my/networks/:uuid/ips status');
+            common.checkHeaders(t, res.headers);
+            t.ok(body, 'GET /my/networks/:uuid/ips body');
+            t.deepEqual(body, out, 'ListNetworkIPs shows only reserved and '
+                + 'provisioned ips OK');
+            t.end();
+        });
+    });
+
+    tt.test('  get network ip (404)', function (t) {
+        var path = format('/my/networks/%s/ips/10.99.98.1',
+            fixtures.network3.uuid);
+        CLIENT.get(path, function (err, req, res, body) {
+            common.checkNotFound(t, err, req, res, body);
+            t.end();
+        });
+    });
+
+    // GET of owned IP on public network works
+    tt.test('  get ip on public network (owner)', function (t) {
+        var out = {
+            ip: ZONE_IP1,
+            managed: false,
+            reserved: false,
+            belongs_to_uuid: ZONE_UUID1,
+            owner_uuid: CLIENT.account.uuid
+        };
+        var path = format('/my/networks/%s/ips/%s', fixtures.network1.uuid,
+            ZONE_IP1);
+        CLIENT.get(path, function (err, req, res, body) {
+            t.ifError(err, 'GET /my/networks/' + fixtures.network1.uuid +
+                '/ips/' + ZONE_IP1 + ' error');
+            t.equal(res.statusCode, 200,
+                'GET /my/networks/:uuid/ips/:ip_address status');
+            common.checkHeaders(t, res.headers);
+            t.ok(body, 'GET /my/networks/:uuid/ips/:ip_address body');
+            t.deepEqual(body, out, 'GetNetworkIP works on owned IP');
+            t.end();
+        });
+    });
+
+    //  GET of unowned IP on a public network returns 404
+    tt.test('  get ip on public network (not owner)', function (t) {
+        var path = format('/my/networks/%s/ips/%s', fixtures.network1.uuid,
+            ZONE_IP2);
+        CLIENT.get(path, function (err, req, res, body) {
+            common.checkNotFound(t, err, req, res, body);
+            t.end();
+        });
+    });
+
+    // GET of IP on private network works
+    tt.test('  get ip on private network (owner)', function (t) {
+        var out = {
+            ip: RESERVED_IP,
+            reserved: true,
+            managed: false
+        };
+        var path = format('/my/networks/%s/ips/%s', fixtures.network3.uuid,
+            RESERVED_IP);
+        CLIENT.get(path, function (err, req, res, body) {
+            t.ifError(err, 'GET /my/networks/' + fixtures.network3.uuid +
+                '/ips/' + RESERVED_IP + ' error');
+            t.equal(res.statusCode, 200,
+                'GET /my/networks/:uuid/ips/:ip_address status');
+            common.checkHeaders(t, res.headers);
+            t.ok(body, 'GET /my/networks/:uuid/ips/:ip_address body');
+            t.deepEqual(body, out, 'GetNetworkIP works on private network');
+            t.end();
+        });
+    });
 
     tt.test('  teardown', function (t) {
         vasync.pipeline({ funcs: [
-- 
2.21.0

