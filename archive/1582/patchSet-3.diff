From caea9f8b39e39eec32a56cac43585329fa2eea28 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Thu, 9 Mar 2017 20:22:46 +0000
Subject: [PATCH] OS-5973 simplify lx user-level nfs mount library usage

---
 .../lib/brand/lx/lx_brand/common/mount_nfs.c  | 1499 +++--------------
 usr/src/lib/libnsl/common/mapfile-vers        |    1 -
 usr/src/lib/libnsl/netselect/netselect.c      |   76 +-
 usr/src/uts/common/sys/netconfig.h            |    2 -
 4 files changed, 244 insertions(+), 1334 deletions(-)

diff --git a/usr/src/lib/brand/lx/lx_brand/common/mount_nfs.c b/usr/src/lib/brand/lx/lx_brand/common/mount_nfs.c
index 7903c153c4..24a688091e 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/mount_nfs.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/mount_nfs.c
@@ -12,22 +12,34 @@
 /*
  * NFS mount syscall support
  *
- * All of the Linux NFS mount RPC support is handled within the kernel whereas
- * on Illumos the NFS mount command performs the initial RPC calls to contact
- * the server's mountd, get the file handle, and negotiate security before
- * making the actual 'mount' syscall. Thus we emulate the Linux in-kernel
- * RPC behavior here using code that is partially based on the code from our
- * user-level NFS mount command. This code also includes the nullproc RPC
- * function calls
+ * The illumos NFS user-level mount code encapsulates a significant amount of
+ * functionality into librpc and libnsl. This includes a variety of functions
+ * to perform lookups in the various /etc configuration files. For v2/v3 in
+ * particular, the library code must make a call to the server's 'mountd' to
+ * obtain a file handle to pass into the mount(2) syscall. There can be a
+ * variety of calls to the server's 'rpcbind' made by the libraries during the
+ * preliminaries before calling mount(2). All of the logic for falling back
+ * when determining which version to use (when none is explicitly provided), as
+ * well as retries when the server is not responding, is encapsulated in the
+ * libraries.
  *
- * In addition to the code described above we also have brand-specific code to
- * convert the Linux mount arguments into our native format.
+ * For Linux, much of this functionality is also included in the user-level
+ * mount code, and thus not of concern to us at the Linux syscall level. The
+ * major difference is that the RPC to the 'mountd' to get the file handle for
+ * v2/v3 is made within the kernel as part of the mount(2) syscall. However,
+ * the Linux user-level code will perform all of the logical name lookups (e.g.
+ * hostname to IP address), will make the 'rpcbind' call to determine the
+ * server's 'mountd' protocol and port, and will handle the retry logic.
  *
- * Because libnsl (which we need to make RPCs) depends on the netconfig table
- * (which won't exist inside an lx zone) we provide a built-in default
- * netconfig table which we hook into libnsl via the brand callbacks. See
- *	_nsl_brand_set_hooks(lx_nsl_set_sz_func, lx_get_ent_func)
- * in lx_nfs_mount().
+ * Thus, when we reach our code here, we don't need to do any name lookups in
+ * any of the /etc files and we never need to call 'rpcbind'. We only need to
+ * make the RPC to get the file handle for v2/v3 mounts. We're still dependent
+ * on librpc/libnsl to make this RPC, but our overall complexity is much less
+ * than what is seen with the native mount library usage. In addition, we also
+ * have to convert the Linux mount arguments into our native format. Because
+ * we're really just making the RPC to get a file handle and reformatting the
+ * mount arguments, this code should be amenable to living in-kernel at some
+ * point.
  *
  * Finally, in most of the functions below, when the code refers to the
  * hostname we're really working with the IP addr that the Linux user-level
@@ -52,7 +64,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #define	NFSCLIENT
@@ -154,9 +166,9 @@ static nfs_map_opt_t nmo_tab[] = {
 	{"acregmax",	NULL,		MOUNT_OPT_PASTHRU},
 	{"acregmin",	NULL,		MOUNT_OPT_PASTHRU},
 	{"actimeo",	NULL,		MOUNT_OPT_PASTHRU},
-	{"bg",		NULL,		MOUNT_OPT_PASTHRU},
+	{"bg",		NULL,		MOUNT_OPT_IGNORE},
 	{"cto",		NULL,		MOUNT_OPT_IGNORE},
-	{"fg",		NULL,		MOUNT_OPT_PASTHRU},
+	{"fg",		NULL,		MOUNT_OPT_IGNORE},
 	{"fsc",		NULL,		MOUNT_OPT_IGNORE},
 	{"hard",	NULL,		MOUNT_OPT_PASTHRU},
 	{"intr",	NULL,		MOUNT_OPT_PASTHRU},
@@ -190,7 +202,7 @@ static nfs_map_opt_t nmo_tab[] = {
 	{"rdma",	"proto=rdma",	MOUNT_OPT_TOKEN},
 	{"resvport",	NULL,		MOUNT_OPT_IGNORE},
 	{"retrans",	NULL,		MOUNT_OPT_PASTHRU},
-	{"retry",	NULL,		MOUNT_OPT_PASTHRU},
+	{"retry",	NULL,		MOUNT_OPT_IGNORE},
 	{"rsize",	NULL,		MOUNT_OPT_PASTHRU},
 	{"sec",		NULL,		MOUNT_OPT_PASTHRU},
 	{"sharecache",	NULL,		MOUNT_OPT_IGNORE},
@@ -216,21 +228,9 @@ static nfs_map_opt_t nmo_tab[] = {
  * a particular value, either 2, 3, or 4 to indicate the version
  * number of choice.  If the server (or the client) do not support
  * the version indicated, then the mount attempt will be failed.
- *
- * nmd_nfsvers_to_use is the actual version number found to use.  It
- * is determined in get_fh by pinging the various versions of the
- * NFS service on the server to see which responds positively.
- *
- * nmd_nfsretry_vers is the version number set when we retry the mount
- * command with the version decremented from nmd_nfsvers_to_use.
- * nmd_nfsretry_vers is set from nmd_nfsvers_to_use when we retry the mount
- * for errors other than RPC errors; it helps us know why we are
- * retrying. It is an indication that the retry is due to non-RPC errors.
  */
 typedef struct nfs_mnt_data {
-	int		nmd_bg;
 	int		nmd_posix;
-	int		nmd_retries;
 	ushort_t	nmd_nfs_port;
 	char		*nmd_nfs_proto;
 	ushort_t	nmd_mnt_port;
@@ -240,8 +240,6 @@ typedef struct nfs_mnt_data {
 	int		nmd_sec_opt;	/* any security option ? */
 	rpcvers_t	nmd_mnt_vers;
 	rpcvers_t	nmd_nfsvers;
-	rpcvers_t	nmd_nfsvers_to_use;
-	rpcvers_t	nmd_nfsretry_vers;
 } nfs_mnt_data_t;
 
 /* number of transports to try */
@@ -254,75 +252,13 @@ typedef struct nfs_mnt_data {
 /* maximum length of RPC header for NFS messages */
 #define	NFS_RPC_HDR	432
 
-#define	NFS_ARGS_EXTB_secdata(args, secdata) \
-	{ (args)->nfs_args_ext = NFS_ARGS_EXTB, \
-	(args)->nfs_ext_u.nfs_extB.secdata = secdata; }
-
 extern int __clnt_bindresvport(CLIENT *);
 
-static int retry(struct mnttab *, int, nfs_mnt_data_t *);
-static int set_args(int *, struct nfs_args *, char *, struct mnttab *,
-    nfs_mnt_data_t *);
-static int get_fh(struct nfs_args *, char *, char *, int *,
-	struct netconfig **, nfs_mnt_data_t *);
-static int make_secure(struct nfs_args *, char *, struct netconfig *,
-	rpcvers_t, nfs_mnt_data_t *);
-static int mount_nfs(struct mnttab *, int, err_ret_t *, nfs_mnt_data_t *);
+static int set_args(int *, struct nfs_args *, char *, char *, nfs_mnt_data_t *);
+static int get_fh(struct nfs_args *, char *, char *, nfs_mnt_data_t *);
+static int make_secure(struct nfs_args *, nfs_mnt_data_t *);
 static int getaddr_nfs(struct nfs_args *, char *, struct netconfig **,
-	err_ret_t *, bool_t, nfs_mnt_data_t *);
-static struct netbuf *get_addr(char *, rpcprog_t, rpcvers_t,
-	struct netconfig **, char *, ushort_t, struct t_info *, err_ret_t *);
-static struct netbuf *get_the_addr(char *, rpcprog_t, rpcvers_t,
-	struct netconfig *, ushort_t, struct t_info *, err_ret_t *);
-
-static int lx_nsl_set_sz_func(void);
-static struct netconfig *lx_get_ent_func(int);
-
-/*
- * These are the defaults (range) for the client when determining
- * which NFS version to use when probing the server (see above).
- * These will only be used when the vers mount option is not used.
- */
-#define	vers_max_default NFS_VERSMAX_DEFAULT
-#define	vers_min_default NFS_VERSMIN_DEFAULT
-
-/*
- * The wnl/WNL* definitions come from cmd/fs.d/nfs/mount/webnfs.h. We
- * incorporate those here since the cmd src tree hierarchy is not built when
- * we're compiling the lib portion of the src tree and since these definitions
- * are a fundamental part of the protocol spec, there is no risk of these
- * changing (i.e. we're just like the Linux kernel here, which has these
- * built-in). We only need the bare minimum set of definitions to make RPCs to
- * the NFS server to negotiate the mount.
- */
-
-/* The timeout for our mount null proc pings is always 5 seconds. */
-static struct timeval TIMEOUT = { 5, 0 };
-#define	WNLPROC_NULL	0
-#define	WNLPROC3_NULL	0
-#define	WNLPROC4_NULL	0
-#define	WNL_FHSIZE	32
-
-static enum clnt_stat
-wnlproc_null_2(void *argp, void *clnt_res, CLIENT *clnt)
-{
-	return (clnt_call(clnt, WNLPROC_NULL, (xdrproc_t)xdr_void,
-	    (caddr_t)argp, (xdrproc_t)xdr_void, (caddr_t)clnt_res, TIMEOUT));
-}
-
-static enum clnt_stat
-wnlproc3_null_3(void *argp, void *clnt_res, CLIENT *clnt)
-{
-	return (clnt_call(clnt, WNLPROC3_NULL, (xdrproc_t)xdr_void,
-	    (caddr_t)argp, (xdrproc_t)xdr_void, (caddr_t)clnt_res, TIMEOUT));
-}
-
-static enum clnt_stat
-wnlproc4_null_4(void *argp, void *clnt_res, CLIENT *clnt)
-{
-	return (clnt_call(clnt, WNLPROC4_NULL, (xdrproc_t)xdr_void,
-	    (caddr_t)argp, (xdrproc_t)xdr_void, (caddr_t)clnt_res, TIMEOUT));
-}
+	nfs_mnt_data_t *);
 
 static void
 log_err(const char *fmt, ...)
@@ -363,105 +299,6 @@ i_add_option(char *option, char *buf, size_t buf_size)
 	return (0);
 }
 
-/*
- * We can return a negative error value which is the errno we need to return to
- * lx or we can return a positive error value which is primarily used to
- * indicate retry (otherwise we map to -EINVAL in the caller). Returning 0
- * indicates success.
- */
-static int
-mount_nfs(struct mnttab *mntp, int mntflags, err_ret_t *retry_error,
-    nfs_mnt_data_t *nmdp)
-{
-	struct nfs_args *argp = NULL;
-	struct netconfig *nconf = NULL;
-	int vers = 0;
-	int r = 0;
-	char *colonp;
-	char *path;
-	char *host;
-	char spec_buf[MAXPATHLEN + LX_NMD_MAXHOSTNAMELEN + 1];
-
-	mntp->mnt_fstype = MNTTYPE_NFS;
-
-	(void) strlcpy(spec_buf, mntp->mnt_special, sizeof (spec_buf));
-	colonp = strchr(spec_buf, ':');
-	if (colonp == NULL)
-		return (-EINVAL);
-
-	*colonp = '\0';
-	host = spec_buf;
-	path = colonp + 1;
-
-	argp = (struct nfs_args *)malloc(sizeof (*argp));
-	if (argp == NULL)
-		return (-ENOMEM);
-
-	(void) memset(argp, 0, sizeof (*argp));
-	(void) memset(&nmdp->nmd_nfs_sec, 0, sizeof (seconfig_t));
-	nmdp->nmd_sec_opt = 0;
-
-	/* returns a negative errno */
-	if ((r = set_args(&mntflags, argp, host, mntp, nmdp)) != 0)
-		goto out;
-
-	/* returns a negative errno or positive EAGAIN for retry */
-	r = get_fh(argp, host, path, &vers, &nconf, nmdp);
-	if (r != 0) {
-		/* All attempts failed */
-		goto out;
-	}
-
-	/*
-	 * Call to get_fh() above may have obtained the netconfig info and NULL
-	 * proc'd the server via a call to getaddr_nfs. This would only be the
-	 * case with v4.
-	 */
-	if (!(argp->flags & NFSMNT_KNCONF)) {
-		/* returns a negative errno or positive EAGAIN for retry */
-		r = getaddr_nfs(argp, host, &nconf, retry_error, TRUE, nmdp);
-		if (r != 0) {
-			goto out;
-		}
-	}
-
-	if (make_secure(argp, host, nconf, vers, nmdp) < 0) {
-		r = -EAGAIN;
-		goto out;
-	}
-
-	mntflags |= MS_DATA | MS_OPTIONSTR;
-
-	r = mount(mntp->mnt_special, mntp->mnt_mountp, mntflags,
-	    nmdp->nmd_fstype, argp, sizeof (*argp), mntp->mnt_mntopts,
-	    MAX_MNTOPT_STR);
-	if (r != 0)
-		r = -errno;
-out:
-	if (nconf != NULL)
-		freenetconfigent(nconf);
-	if (argp->fh)
-		free(argp->fh);
-	if (argp->pathconf)
-		free(argp->pathconf);
-	if (argp->knconf)
-		free(argp->knconf);
-	if (argp->addr) {
-		free(argp->addr->buf);
-		free(argp->addr);
-	}
-	nfs_free_secdata(argp->nfs_ext_u.nfs_extB.secdata);
-	if (argp->syncaddr) {
-		free(argp->syncaddr->buf);
-		free(argp->syncaddr);
-	}
-	if (argp->netname)
-		free(argp->netname);
-	free(argp);
-
-	return (r);
-}
-
 /*
  * These options were initially derived from uts/common/fs/nfs/nfs_dlinet.c
  * but have been extended to add additional Linux options.
@@ -592,7 +429,7 @@ convert_int(int *val, char *str)
 }
 
 static int
-set_args(int *mntflags, struct nfs_args *args, char *fshost, struct mnttab *mnt,
+set_args(int *mntflags, struct nfs_args *args, char *fshost, char *mntopts,
     nfs_mnt_data_t *nmdp)
 {
 	char *saveopt, *optstr, *opts, *newopts, *val;
@@ -607,8 +444,10 @@ set_args(int *mntflags, struct nfs_args *args, char *fshost, struct mnttab *mnt,
 	args->flags |= NFSMNT_NEWARGS;	/* using extented nfs_args structure */
 	args->hostname = fshost;
 
-	optstr = opts = strdup(mnt->mnt_mntopts);
-	oldlen = strlen(mnt->mnt_mntopts);
+	oldlen = strlen(mntopts);
+	optstr = opts = strdup(mntopts);
+	if (opts == NULL)
+		return (-ENOMEM);
 	/* sizeof (MNTOPT_XXX) includes one extra byte we may need for "," */
 	optlen = oldlen + sizeof (MNTOPT_XATTR) + 1;
 	if (optlen > MAX_MNTOPT_STR)
@@ -731,14 +570,13 @@ set_args(int *mntflags, struct nfs_args *args, char *fshost, struct mnttab *mnt,
 			args->flags |= NFSMNT_ACDIRMAX;
 			break;
 		case OPT_BG:
-			nmdp->nmd_bg++;
+			/* Ignored as does Linux kernel */
 			break;
 		case OPT_FG:
-			nmdp->nmd_bg = 0;
+			/* Ignored as does Linux kernel */
 			break;
 		case OPT_RETRY:
-			if (convert_int(&nmdp->nmd_retries, val) != 0)
-				goto badopt;
+			/* Ignored as does Linux kernel */
 			break;
 		case OPT_LLOCK:
 			args->flags |= NFSMNT_LLOCK;
@@ -779,7 +617,7 @@ set_args(int *mntflags, struct nfs_args *args, char *fshost, struct mnttab *mnt,
 				return (-EINVAL);
 			/*
 			 * We initialize the nfs_sec struct as if we had the
-			 * basic /etc/nffssec.conf file.
+			 * basic /etc/nfssec.conf file.
 			 */
 			if (strcmp(val, "none") == 0) {
 				(void) strlcpy(nmdp->nmd_nfs_sec.sc_name,
@@ -791,11 +629,6 @@ set_args(int *mntflags, struct nfs_args *args, char *fshost, struct mnttab *mnt,
 				    "sys", MAX_NAME_LEN);
 				nmdp->nmd_nfs_sec.sc_nfsnum =
 				    nmdp->nmd_nfs_sec.sc_rpcnum = 1;
-			} else if (strcmp(val, "dh") == 0) {
-				(void) strlcpy(nmdp->nmd_nfs_sec.sc_name,
-				    "dh", MAX_NAME_LEN);
-				nmdp->nmd_nfs_sec.sc_nfsnum =
-				    nmdp->nmd_nfs_sec.sc_rpcnum = 3;
 			} else {
 				return (-EINVAL);
 			}
@@ -860,7 +693,7 @@ set_args(int *mntflags, struct nfs_args *args, char *fshost, struct mnttab *mnt,
 		}
 		(void) strlcat(newopts, MNTOPT_XATTR, optlen);
 	}
-	(void) strlcpy(mnt->mnt_mntopts, newopts, oldlen);
+	(void) strlcpy(mntopts, newopts, oldlen);
 	free(newopts);
 	free(optstr);
 
@@ -872,742 +705,86 @@ set_args(int *mntflags, struct nfs_args *args, char *fshost, struct mnttab *mnt,
 	if (nmdp->nmd_nfsvers == NFS_VERSION && largefiles)
 		return (-EINVAL);
 
-	if (nmdp->nmd_nfsvers == NFS_V4 && nmdp->nmd_nfs_proto != NULL &&
-	    strncasecmp(nmdp->nmd_nfs_proto, NC_UDP, strlen(NC_UDP)) == 0)
-		return (-EINVAL);
-
-	return (0);
-
-badopt:
-	free(optstr);
-	return (-EINVAL);
-}
-
-/*
- *  NFS project private API.
- *
- *  Free an sec_data structure.
- *  Free the parts that nfs_clnt_secdata allocates.
- */
-void
-nfs_free_secdata(sec_data_t *secdata)
-{
-	dh_k4_clntdata_t *dkdata;
-
-	if (!secdata)
-		return;
-
-	switch (secdata->rpcflavor) {
-		case AUTH_UNIX:
-		case AUTH_NONE:
-			break;
-
-		case AUTH_DES:
-			/* LINTED pointer alignment */
-			dkdata = (dh_k4_clntdata_t *)secdata->data;
-			if (dkdata) {
-				if (dkdata->netname)
-					free(dkdata->netname);
-				if (dkdata->syncaddr.buf)
-					free(dkdata->syncaddr.buf);
-				free(dkdata);
-			}
-			break;
-
-		default:
-			break;
-	}
-
-	free(secdata);
-}
-
-/*
- *  Make an client side sec_data structure and fill in appropriate value
- *  based on its rpc security flavor.
- *
- *  It is caller's responsibility to allocate space for seconfig_t,
- *  and this routine will allocate space for the sec_data structure
- *  and related data field.
- *
- *  Return the sec_data_t on success.
- *  If fail, return NULL pointer.
- */
-sec_data_t *
-nfs_clnt_secdata(seconfig_t *secp, char *hostname, struct knetconfig *knconf,
-    struct netbuf *syncaddr, int flags)
-{
-	char netname[MAXNETNAMELEN+1];
-	sec_data_t *secdata;
-	dh_k4_clntdata_t *dkdata;
-
-	secdata = malloc(sizeof (sec_data_t));
-	if (!secdata)
-		return (NULL);
-
-	(void) memset(secdata, 0, sizeof (sec_data_t));
-
-	secdata->secmod = secp->sc_nfsnum;
-	secdata->rpcflavor = secp->sc_rpcnum;
-	secdata->uid = secp->sc_uid;
-	secdata->flags = flags;
-
-	/*
-	 *  Now, fill in the information for client side secdata :
-	 *
-	 *  For AUTH_UNIX, AUTH_DES
-	 *  hostname can be in the form of
-	 *    nodename or
-	 *    nodename.domain
-	 */
-	switch (secp->sc_rpcnum) {
-		case AUTH_UNIX:
-		case AUTH_NONE:
-			secdata->data = NULL;
-			break;
-
-		case AUTH_DES:
-			if (!host2netname(netname, hostname, NULL))
-				goto err_out;
-
-			dkdata = malloc(sizeof (dh_k4_clntdata_t));
-			if (!dkdata)
-				goto err_out;
-
-			(void) memset((char *)dkdata, 0,
-			    sizeof (dh_k4_clntdata_t));
-			if ((dkdata->netname = strdup(netname)) == NULL)
-				goto err_out;
-
-			dkdata->netnamelen = strlen(netname);
-			dkdata->knconf = knconf;
-			dkdata->syncaddr = *syncaddr;
-			dkdata->syncaddr.buf = malloc(syncaddr->len);
-			if (dkdata->syncaddr.buf == NULL)
-				goto err_out;
-
-			(void) memcpy(dkdata->syncaddr.buf, syncaddr->buf,
-			    syncaddr->len);
-			secdata->data = (caddr_t)dkdata;
-			break;
-
-		default:
-			goto err_out;
-	}
-
-	return (secdata);
-
-err_out:
-	free(secdata);
-	return (NULL);
-}
-
-static int
-make_secure(struct nfs_args *args, char *hostname, struct netconfig *nconf,
-    rpcvers_t vers, nfs_mnt_data_t *nmdp)
-{
-	sec_data_t *secdata;
-	int flags;
-	struct netbuf *syncaddr = NULL;
-	struct nd_addrlist *retaddrs = NULL;
-	char netname[MAXNETNAMELEN+1];
-
-	/*
-	 * check to see if any secure mode is requested.
-	 * if not, use default security mode.
-	 */
-	if (!nmdp->nmd_sec_opt) {
-		/* AUTH_UNIX is the default. */
-		(void) strlcpy(nmdp->nmd_nfs_sec.sc_name, "sys", MAX_NAME_LEN);
-		nmdp->nmd_nfs_sec.sc_nfsnum = 1;
-		args->flags |= NFSMNT_SECDEFAULT;
-	}
-
-	/*
-	 * Get the network address for the time service on the server.
-	 * If an RPC based time service is not available then try the
-	 * IP time service.
-	 *
-	 * This is for AUTH_DH processing. We will also pass down syncaddr
-	 * and netname for NFS V4 even if AUTH_DH is not requested right now.
-	 * NFS V4 does security negotiation in the kernel via SECINFO.
-	 * This information might be needed later in the kernel.
-	 */
-	flags = 0;
-	syncaddr = NULL;
-
-	if (nmdp->nmd_nfs_sec.sc_rpcnum == AUTH_DH || vers == NFS_V4) {
+	if (nmdp->nmd_nfsvers == NFS_V4) {
 		/*
-		 * If using nfsv4, we will not contact the remote RPCBINDer,
-		 * since it is possibly behind a firewall.
+		 * NFSv4 specifies the TCP protocol and port 2049 - default to
+		 * these. The user-level mount code is not expected to pass
+		 * these in, but if it did, validate the proto value.
 		 */
-		if (vers != NFS_V4)
-			syncaddr = get_the_addr(hostname, RPCBPROG, RPCBVERS,
-			    nconf, 0, NULL, NULL);
-
-		if (syncaddr != NULL) {
-			/* for flags in sec_data */
-			flags |= AUTH_F_RPCTIMESYNC;
-		} else {
-			/*
-			 * TBD:
-			 * For AUTH_DH (AUTH_DES) netdir_getbyname wants to
-			 * lookup the timeserver entry in the /etc/services
-			 * file (but our libnsl to do this won't work in Linux).
-			 * That entry is:
-			 *	timed    525/udp    timeserver
-			 * Since we haven't implemented the emulation for that
-			 * aspect of netdir_getbyname yet, we'll simply return
-			 * an error.
-			 */
-			struct nd_hostserv hs;
-			int error;
-
-			hs.h_host = hostname;
-			hs.h_serv = "timserver";
-
-			if (nmdp->nmd_nfs_sec.sc_rpcnum == AUTH_DH)
-				return (-1);
-
-			error = netdir_getbyname(nconf, &hs, &retaddrs);
-
-			if (error != ND_OK &&
-			    (nmdp->nmd_nfs_sec.sc_rpcnum == AUTH_DH))
-				return (-1);
-
-			if (error == ND_OK)
-				syncaddr = retaddrs->n_addrs;
-
-			/*
-			 * For NFS_V4 if AUTH_DH is negotiated later in the
-			 * kernel thru SECINFO, it will need syncaddr
-			 * and netname data.
-			 */
-			if (vers == NFS_V4 && syncaddr &&
-			    host2netname(netname, hostname, NULL)) {
-				args->syncaddr = malloc(sizeof (struct netbuf));
-				args->syncaddr->buf = malloc(syncaddr->len);
-				(void) memcpy(args->syncaddr->buf,
-				    syncaddr->buf, syncaddr->len);
-				args->syncaddr->len = syncaddr->len;
-				args->syncaddr->maxlen = syncaddr->maxlen;
-				args->netname = strdup(netname);
-				args->flags |= NFSMNT_SECURE;
-			}
-		}
-	}
-
-	/*
-	 * For the initial chosen flavor (any flavor defined in nfssec.conf),
-	 * the data will be stored in the sec_data structure via
-	 * nfs_clnt_secdata() and be passed to the kernel via nfs_args_*
-	 * extended data structure.
-	 */
-	if (!(secdata = nfs_clnt_secdata(&nmdp->nmd_nfs_sec, hostname,
-	    args->knconf, syncaddr, flags))) {
-		if (flags & AUTH_F_RPCTIMESYNC) {
-			free(syncaddr->buf);
-			free(syncaddr);
-		} else if (retaddrs)
-			netdir_free((void *)retaddrs, ND_ADDRLIST);
-		return (-1);
-	}
-
-	NFS_ARGS_EXTB_secdata(args, secdata);
-	if (flags & AUTH_F_RPCTIMESYNC) {
-		free(syncaddr->buf);
-		free(syncaddr);
-	} else if (retaddrs)
-		netdir_free((void *)retaddrs, ND_ADDRLIST);
-	return (0);
-}
-
-/*
- * Get the network address on "hostname" for program "prog"
- * with version "vers" by using the nconf configuration data
- * passed in.
- *
- * If the address of a netconfig pointer is null then
- * information is not sufficient and no netbuf will be returned.
- *
- * Finally, ping the null procedure of that service.
- *
- * A similar routine is also defined in ../../autofs/autod_nfs.c.
- * This is a potential routine to move to ../lib for common usage.
- */
-static struct netbuf *
-get_the_addr(char *hostname, rpcprog_t prog, rpcvers_t vers,
-    struct netconfig *nconf, ushort_t port, struct t_info *tinfo,
-    err_ret_t *error)
-{
-	struct netbuf *nb = NULL;
-	struct t_bind *tbind = NULL;
-	CLIENT *cl = NULL;
-	int fd = -1;
-	AUTH *ah = NULL;
-	AUTH *new_ah = NULL;
-	struct rpc_err r_err;
-	enum clnt_stat rc;
-
-	if (nconf == NULL)
-		return (NULL);
-
-	if ((fd = t_open(nconf->nc_device, O_RDWR, tinfo)) == -1)
-		goto done;
-
-	/* LINTED pointer alignment */
-	if ((tbind = (struct t_bind *)t_alloc(fd, T_BIND, T_ADDR)) == NULL)
-		goto done;
-
-	if (vers == NFS_V4) {
-		struct nd_hostserv hs;
-		struct nd_addrlist *retaddrs;
-		int retval;
-		hs.h_host = hostname;
-
-		/* NFS where vers==4 does not support UDP */
-		if (strncasecmp(nconf->nc_proto, NC_UDP,
-		    strlen(NC_UDP)) == 0) {
-			SET_ERR_RET(error, ERR_PROTO_UNSUPP, 0);
-			goto done;
-		}
-
-		if (port == 0)
-			hs.h_serv = "nfs";
-		else
-			hs.h_serv = NULL;
-
-		if ((retval = netdir_getbyname(nconf, &hs, &retaddrs))
-		    != ND_OK) {
-			/*
-			 * Carefully set the error value here. Want to signify
-			 * that the error was an unknown host.
-			 */
-			if (retval == ND_NOHOST) {
-				SET_ERR_RET(error, ERR_NOHOST, retval);
-			}
+		if (nmdp->nmd_nfs_proto == NULL) {
+			nmdp->nmd_nfs_proto = strdup(NC_TCP);
+			if (nmdp->nmd_nfs_proto == NULL)
+				return (-ENOMEM);
 
-			goto done;
+		} else if (strcmp(nmdp->nmd_nfs_proto, NC_TCP) != 0) {
+			return (-EINVAL);
 		}
-		(void) memcpy(tbind->addr.buf, retaddrs->n_addrs->buf,
-		    retaddrs->n_addrs->len);
-		tbind->addr.len = retaddrs->n_addrs->len;
-		netdir_free((void *)retaddrs, ND_ADDRLIST);
-		(void) netdir_options(nconf, ND_SET_RESERVEDPORT, fd, NULL);
 
 	} else {
-		if (rpcb_getaddr(prog, vers, nconf, &tbind->addr,
-		    hostname) == FALSE) {
-			goto done;
-		}
-	}
-
-	if (port) {
-		if (strcmp(nconf->nc_protofmly, NC_INET) == 0) {
-			/* LINTED alignment */
-			((struct sockaddr_in *)tbind->addr.buf)->sin_port
-			    = port;
-		} else if (strcmp(nconf->nc_protofmly, NC_INET6) == 0) {
-			/* LINTED alignment */
-			((struct sockaddr_in6 *)tbind->addr.buf)->sin6_port
-			    = port;
-		}
-
-	}
-
-	cl = clnt_tli_create(fd, nconf, &tbind->addr, prog, vers, 0, 0);
-	if (cl == NULL) {
 		/*
-		 * clnt_tli_create() returns either RPC_SYSTEMERROR,
-		 * RPC_UNKNOWNPROTO or RPC_TLIERROR. The RPC_TLIERROR translates
-		 * to "Misc. TLI error". This is not too helpful. Most likely
-		 * the connection to the remote server timed out, so this
-		 * error is at least less perplexing.
-		 * See: usr/src/cmd/rpcinfo/rpcinfo.c
+		 * The user-level mount code normally passes in the proto, but
+		 * if it didn't for some reason, use a sensible default.
+		 * Otherwise we normally just validate the proto value and we
+		 * only support TCP or UDP.
 		 */
-		if (rpc_createerr.cf_stat == RPC_TLIERROR) {
-			SET_ERR_RET(error, ERR_RPCERROR, RPC_PMAPFAILURE);
-		} else {
-			SET_ERR_RET(error, ERR_RPCERROR, rpc_createerr.cf_stat);
-		}
-		goto done;
-	}
-
-	ah = authsys_create_default();
-	if (ah != NULL)
-		cl->cl_auth = ah;
+		if (nmdp->nmd_nfs_proto == NULL) {
+			nmdp->nmd_nfs_proto = strdup(NC_TCP);
+			if (nmdp->nmd_nfs_proto == NULL)
+				return (-ENOMEM);
 
-	/*
-	 * NULL procedures need not have an argument or
-	 * result param.
-	 */
-	if (vers == NFS_VERSION)
-		rc = wnlproc_null_2(NULL, NULL, cl);
-	else if (vers == NFS_V3)
-		rc = wnlproc3_null_3(NULL, NULL, cl);
-	else
-		rc = wnlproc4_null_4(NULL, NULL, cl);
-
-	if (rc != RPC_SUCCESS) {
-		clnt_geterr(cl, &r_err);
-		if (strcmp(nconf->nc_protofmly, NC_LOOPBACK) == 0) {
-			switch (r_err.re_status) {
-			case RPC_TLIERROR:
-			case RPC_CANTRECV:
-			case RPC_CANTSEND:
-				r_err.re_status = RPC_PROGVERSMISMATCH;
-				break;
-			default:
-				break;
-			}
+		} else if (strcmp(nmdp->nmd_nfs_proto, NC_TCP) != 0 &&
+		    strcmp(nmdp->nmd_nfs_proto, NC_UDP) != 0) {
+			return (-EINVAL);
 		}
-		SET_ERR_RET(error, ERR_RPCERROR, r_err.re_status);
-		goto done;
 	}
 
 	/*
-	 * Make a copy of the netbuf to return
+	 * The user-level mount code only passes the port when it is
+	 * non-standard.
 	 */
-	nb = (struct netbuf *)malloc(sizeof (*nb));
-	if (nb == NULL)
-		goto done;
-
-	*nb = tbind->addr;
-	nb->buf = (char *)malloc(nb->maxlen);
-	if (nb->buf == NULL) {
-		free(nb);
-		nb = NULL;
-		goto done;
+	if (nmdp->nmd_nfs_port == 0) {
+		nmdp->nmd_nfs_port = NFS_PORT;
 	}
-	(void) memcpy(nb->buf, tbind->addr.buf, tbind->addr.len);
 
-done:
-	if (cl) {
-		if (ah != NULL) {
-			if (new_ah != NULL)
-				AUTH_DESTROY(ah);
-			AUTH_DESTROY(cl->cl_auth);
-			cl->cl_auth = NULL;
-		}
-		clnt_destroy(cl);
-		cl = NULL;
-	}
-	if (tbind) {
-		(void) t_free((char *)tbind, T_BIND);
-		tbind = NULL;
-	}
-	if (fd >= 0)
-		(void) t_close(fd);
-	return (nb);
-}
-
-static int
-check_nconf(struct netconfig *nconf, int nthtry, int *valid_proto)
-{
-	int	try_test = 0;
-	char	*proto = NULL;
-
-	if (nthtry == FIRST_TRY) {
-		try_test = ((nconf->nc_semantics == NC_TPI_COTS_ORD) ||
-		    (nconf->nc_semantics == NC_TPI_COTS));
-		proto = NC_TCP;
-	} else if (nthtry == SECOND_TRY) {
-		try_test = (nconf->nc_semantics == NC_TPI_CLTS);
-		proto = NC_UDP;
-	}
-
-	if (proto &&
-	    (strcmp(nconf->nc_protofmly, NC_INET) == 0 ||
-	    strcmp(nconf->nc_protofmly, NC_INET6) == 0) &&
-	    (strcmp(nconf->nc_proto, proto) == 0))
-		*valid_proto = TRUE;
-	else
-		*valid_proto = FALSE;
-
-	return (try_test);
-}
-
-static struct netconfig *
-netconfig_dup(struct netconfig *netconfigp)
-{
-	struct netconfig *nconf;
-
-	nconf = calloc(1, sizeof (struct netconfig));
-	if (nconf == NULL)
-		goto nomem;
-
-	if ((nconf->nc_netid = strdup(netconfigp->nc_netid)) == NULL)
-		goto nomem;
-
-	if ((nconf->nc_protofmly = strdup(netconfigp->nc_protofmly)) == NULL)
-		goto nomem;
-
-	if ((nconf->nc_proto = strdup(netconfigp->nc_proto)) == NULL)
-		goto nomem;
-
-	if ((nconf->nc_device = strdup(netconfigp->nc_device)) == NULL)
-		goto nomem;
-
-	nconf->nc_lookups = NULL;
-	nconf->nc_nlookups = netconfigp->nc_nlookups;
-	nconf->nc_flag = netconfigp->nc_flag;
-	nconf->nc_semantics = netconfigp->nc_semantics;
-	return (nconf);
+	return (0);
 
-nomem:
-	if (nconf != NULL) {
-		free(nconf->nc_netid);
-		free(nconf->nc_protofmly);
-		free(nconf->nc_proto);
-		free(nconf->nc_device);
-		free(nconf);
-	}
-	return (NULL);
+badopt:
+	free(optstr);
+	return (-EINVAL);
 }
 
-/*
- * Get a network address on "hostname" for program "prog"
- * with version "vers".  If the port number is specified (non zero)
- * then try for a TCP/UDP transport and set the port number of the
- * resulting IP address.
- *
- * If the address of a netconfig pointer was passed and
- * if it's not null, use it as the netconfig otherwise
- * assign the address of the netconfig that was used to
- * establish contact with the service.
- *
- * "error" refers to a more descriptive term when get_addr fails
- * and returns NULL: ERR_PROTO_NONE if no error introduced by
- * -o proto option, ERR_NETPATH if error found in NETPATH
- * environment variable, ERR_PROTO_INVALID if an unrecognized
- * protocol is specified by user, and ERR_PROTO_UNSUPP for a
- * recognized but invalid protocol (eg. ticlts, ticots, etc.).
- * "error" is ignored if get_addr returns non-NULL result.
- *
- */
-static struct netbuf *
-get_addr(char *hostname, rpcprog_t prog, rpcvers_t vers,
-    struct netconfig **nconfp, char *proto, ushort_t port,
-    struct t_info *tinfo, err_ret_t *error)
+static int
+make_secure(struct nfs_args *args, nfs_mnt_data_t *nmdp)
 {
-	struct netbuf *nb = NULL;
-	struct netconfig *nconf = NULL;
-	int nci;
-	int nthtry = FIRST_TRY;
-	err_ret_t errsave_nohost, errsave_rpcerr;
-
-	SET_ERR_RET(&errsave_nohost, ERR_PROTO_NONE, 0);
-	SET_ERR_RET(&errsave_rpcerr, ERR_PROTO_NONE, 0);
-
-	SET_ERR_RET(error, ERR_PROTO_NONE, 0);
-
-	if (nconfp && *nconfp)
-		return (get_the_addr(hostname, prog, vers, *nconfp, port,
-		    tinfo, error));
-	/*
-	 * No nconf passed in.
-	 *
-	 * First search for COTS, second for CLTS unless proto
-	 * is specified.  When we retry, we reset the
-	 * netconfig list so that we would search the whole list
-	 * all over again.
-	 */
-
-	/*
-	 * If proto is specified, then only search for the match,
-	 * otherwise try COTS first, if failed, try CLTS.
-	 */
-	if (proto) {
-		/* no matching proto name */
-		SET_ERR_RET(error, ERR_PROTO_INVALID, 0);
-
-		for (nci = 0; nci < N_NETCONF_ENTS; nci++) {
-			nconf = &nca[nci];
-			if (strcmp(nconf->nc_netid, proto) != 0)
-				continue;
-
-			/* may be unsupported */
-			SET_ERR_RET(error, ERR_PROTO_UNSUPP, 0);
-
-			nb = get_the_addr(hostname, prog, vers, nconf, port,
-			    tinfo, error);
-			if (nb != NULL)
-				break;
-
-			/* nb is NULL - deal with errors */
-			if (error) {
-				if (error->error_type == ERR_NOHOST) {
-					SET_ERR_RET(&errsave_nohost,
-					    error->error_type,
-					    error->error_value);
-				}
-				if (error->error_type == ERR_RPCERROR) {
-					SET_ERR_RET(&errsave_rpcerr,
-					    error->error_type,
-					    error->error_value);
-				}
-			}
-
-			/* continue with same protocol selection */
-			continue;
-		} /* end of while */
-
-		if (nci >= N_NETCONF_ENTS)
-			goto done;
-
-		if (nb == NULL &&
-		    (nb = get_the_addr(hostname, prog, vers, nconf, port,
-		    tinfo, error)) == NULL)
-			goto done;
-	} else {
-retry:
-		SET_ERR_RET(error, ERR_NETPATH, 0);
-		for (nci = 0; nci < N_NETCONF_ENTS; nci++) {
-			int	valid_proto;
-
-			nconf = &nca[nci];
-			SET_ERR_RET(error, ERR_PROTO_NONE, 0);
-
-			if (check_nconf(nconf, nthtry, &valid_proto)) {
-				if (port != 0 && valid_proto != TRUE)
-					continue;
-
-				nb = get_the_addr(hostname, prog, vers, nconf,
-				    port, tinfo, error);
-				if (nb != NULL)
-					break;
-
-				/* nb is NULL - deal with errors */
-				if (error) {
-					if (error->error_type == ERR_NOHOST) {
-						SET_ERR_RET(&errsave_nohost,
-						    error->error_type,
-						    error->error_value);
-					}
-
-					if (error->error_type == ERR_RPCERROR) {
-						SET_ERR_RET(&errsave_rpcerr,
-						    error->error_type,
-						    error->error_value);
-					}
-				}
-
-				/*
-				 * Continue the same search path in the
-				 * netconfig db until no more matched
-				 * nconf.
-				 */
-			}
-		}
-
-		if (nci >= N_NETCONF_ENTS) {
-			if (++nthtry <= MNT_PREF_LISTLEN)
-				goto retry;
-			goto done;
-		}
-
-	}
-	SET_ERR_RET(error, ERR_PROTO_NONE, 0);
+	sec_data_t *secdata;
 
 	/*
-	 * Got nconf and nb. Now dup the netconfig structure
-	 * and return it thru nconfp.
+	 * Check to see if any secure mode is requested. If not, use default
+	 * security mode. Note: we currently only support sec=none and sec=sys.
 	 */
-	*nconfp = netconfig_dup(nconf);
-	if (*nconfp == NULL) {
-		free(nb);
-		nb = NULL;
-	}
-done:
-	if (nb == NULL) {
-		/*
-		 * Check the saved errors. The RPC error has
-		 * precedence over the no host error.
-		 */
-		if (errsave_nohost.error_type != ERR_PROTO_NONE) {
-			SET_ERR_RET(error, errsave_nohost.error_type,
-			    errsave_nohost.error_value);
-		}
-
-		if (errsave_rpcerr.error_type != ERR_PROTO_NONE) {
-			SET_ERR_RET(error, errsave_rpcerr.error_type,
-			    errsave_rpcerr.error_value);
-		}
+	if (nmdp->nmd_sec_opt == 0) {
+		/* AUTH_UNIX is the default. */
+		(void) strlcpy(nmdp->nmd_nfs_sec.sc_name, "sys", MAX_NAME_LEN);
+		nmdp->nmd_nfs_sec.sc_nfsnum = nmdp->nmd_nfs_sec.sc_rpcnum = 1;
+		args->flags |= NFSMNT_SECDEFAULT;
 	}
 
-	return (nb);
-}
-
-static int
-lx_nsl_set_sz_func()
-{
-	return (N_NETCONF_ENTS);
-}
-
-static struct netconfig *
-lx_get_ent_func(int pos)
-{
-	struct netconfig *nconf;
+	secdata = malloc(sizeof (sec_data_t));
+	if (secdata == NULL)
+		return (-ENOMEM);
 
-	if (pos < 0 || pos >= N_NETCONF_ENTS)
-		return (NULL);
+	(void) memset(secdata, 0, sizeof (sec_data_t));
 
-	nconf = &nca[pos];
-	return (nconf);
-}
+	secdata->secmod = nmdp->nmd_nfs_sec.sc_nfsnum;
+	secdata->rpcflavor = nmdp->nmd_nfs_sec.sc_rpcnum;
+	secdata->uid = nmdp->nmd_nfs_sec.sc_uid;
+	secdata->flags = 0;
+	secdata->data = NULL;
 
-/*
- * Roughly based on the NFSv4 try_failover_table but used here for generic
- * errno translation.
- */
-static int
-rpcerr2errno(int rpcerr)
-{
-	switch (rpcerr) {
-	case RPC_INTR:
-		return (EINTR);
-	case RPC_TIMEDOUT:
-		return (ETIMEDOUT);
-	case RPC_VERSMISMATCH:
-	case RPC_PROGVERSMISMATCH:
-	case RPC_PROGUNAVAIL:
-	case RPC_PROCUNAVAIL:
-	case RPC_PMAPFAILURE:
-	case RPC_PROGNOTREGISTERED:
-		return (EPROTONOSUPPORT);
-	case RPC_AUTHERROR:
-		return (EACCES);
-	case RPC_UNKNOWNPROTO:
-	case RPC_UNKNOWNHOST:
-		return (EHOSTUNREACH);
-	case RPC_CANTENCODEARGS:
-	case RPC_CANTDECODERES:
-	case RPC_CANTDECODEARGS:
-	case RPC_CANTSEND:
-	case RPC_CANTRECV:
-		return (ECOMM);
-	case RPC_SYSTEMERROR:
-		return (ENOSR);
-	default:
-		return (EIO);
-	}
-}
+	args->nfs_args_ext = NFS_ARGS_EXTB;
+	args->nfs_ext_u.nfs_extB.secdata = secdata;
 
-static int
-err2errno(int err)
-{
-	assert(err != ERR_RPCERROR);
-	switch (err) {
-	case ERR_PROTO_NONE:
-	case ERR_PROTO_INVALID:
-	case ERR_PROTO_UNSUPP:
-		return (EPROTONOSUPPORT);
-	case ERR_NETPATH:
-		return (ENOSR);
-	case ERR_NOHOST:
-		return (EHOSTUNREACH);
-	default:
-		return (EIO);
-	}
+	return (0);
 }
 
 /*
@@ -1668,14 +845,13 @@ get_netbuf(struct netconfig *nconf, char *ip, ushort_t port)
 /*
  * Construct a CLIENT handle to talk to the mountd without having to contact
  * the rpcbind daemon on the server. This works for both the TCP and UDP cases,
- * but it is primarily intended to the handle the TCP case. Note that TCP is
- * never used by the native NFS mount client, even when the 'proto=tcp'
- * argument is given to the mount command. The native mount code always uses UDP
- * to get a file handle from the mountd.
+ * but it is primarily intended to the handle the TCP case. As an aside, note
+ * that TCP is never used by the native NFS mount client, even when the
+ * 'proto=tcp' argument is given to the mount command. The native mount code
+ * always uses UDP to get a file handle from the mountd.
  */
 static CLIENT *
-get_mountd_client(char *fshost, nfs_mnt_data_t *nmdp, rpcvers_t *vp,
-    int *fdp)
+get_mountd_client(char *fshost, nfs_mnt_data_t *nmdp, int *fdp)
 {
 	struct netconfig *nconf;
 	struct netbuf *srvaddr;
@@ -1685,7 +861,7 @@ get_mountd_client(char *fshost, nfs_mnt_data_t *nmdp, rpcvers_t *vp,
 	struct t_bind *tbind = NULL;
 	struct t_info tinfo;
 
-	*vp = vers = nmdp->nmd_mnt_vers;
+	vers = nmdp->nmd_mnt_vers;
 	*fdp = -1;
 
 	if ((nconf = get_netconf(nmdp->nmd_mnt_proto)) == NULL)
@@ -1740,19 +916,16 @@ get_fh_cleanup(CLIENT *cl, int fd, int err)
 		clnt_destroy(cl);
 	if (fd != -1)
 		(void) t_close(fd);
+	assert(err <= 0);
 	return (err);
 }
 
 /*
- * get fhandle of remote path from server's mountd
- *
- * Return a positive EAGAIN if the caller should retry and a -EAGAIN to
- * indicate a fatal (Linux-oriented) error condition. Return other negative
- * errno values to indicate different fatal errors.
+ * Get fhandle of remote path from server's mountd. This is only applicable to
+ * v2 or v3.
  */
 static int
-get_fh(struct nfs_args *args, char *fshost, char *fspath, int *versp,
-    struct netconfig **nconfp, nfs_mnt_data_t *nmdp)
+get_fh(struct nfs_args *args, char *fshost, char *fspath, nfs_mnt_data_t *nmdp)
 {
 	struct fhstatus fhs;
 	struct mountres3 mountres3;
@@ -1762,175 +935,36 @@ get_fh(struct nfs_args *args, char *fshost, char *fspath, int *versp,
 	CLIENT *cl = NULL;
 	int fd = -1;
 	enum clnt_stat rpc_stat;
-	rpcvers_t outvers = 0;
-	rpcvers_t vers_to_try;
-	rpcvers_t vers_min = vers_min_default;
 	int count, i, *auths;
 
 	bzero(&fhs, sizeof (fhs));
 	bzero(&mountres3, sizeof (mountres3));
 	bzero(&p, sizeof (p));
 
-	switch (nmdp->nmd_nfsvers) {
-	case 2: /* version 2 specified try that only */
-		vers_to_try = MOUNTVERS_POSIX;
-		vers_min = MOUNTVERS;
-		break;
-	case 3: /* version 3 specified try that only */
-		vers_to_try = MOUNTVERS3;
-		vers_min = MOUNTVERS3;
-		break;
-	case 4: /* version 4 specified try that only */
-		/*
-		 * This assignment is in the wrong version sequence.
-		 * The above are MOUNT program and this is NFS
-		 * program.  However, it happens to work out since the
-		 * two don't collide for NFSv4.
-		 */
-		vers_to_try = NFS_V4;
-		vers_min = NFS_V4;
-		break;
-	default: /* no version specified, start with default */
-		/*
-		 * If the retry version is set, use that. This will
-		 * be set if the last mount attempt returned any other
-		 * besides an RPC error.
-		 */
-		if (nmdp->nmd_nfsretry_vers)
-			vers_to_try = nmdp->nmd_nfsretry_vers;
-		else {
-			vers_to_try = vers_max_default;
-			vers_min = vers_min_default;
-		}
-
-		break;
-	}
-
 	/*
-	 * In the case of version 4, just NULL proc the server since
-	 * there is no MOUNT program.  If this fails, then decrease
-	 * vers_to_try and continue on with regular MOUNT program
-	 * processing.
+	 * The user-level mount code should have contacted the server's rpcbind
+	 * daemon and passed us the mount protocol and port.
 	 */
-	if (vers_to_try == NFS_V4) {
-		int savevers = nmdp->nmd_nfsvers_to_use;
-		err_ret_t error;
-		int retval;
-		SET_ERR_RET(&error, ERR_PROTO_NONE, 0);
-
-		/* Let's hope for the best */
-		nmdp->nmd_nfsvers_to_use = NFS_V4;
-		retval = getaddr_nfs(args, fshost, nconfp, &error,
-		    vers_min == NFS_V4, nmdp);
-
-		if (retval == RET_OK) {
-			*versp = nmdp->nmd_nfsvers_to_use = NFS_V4;
-			nmdp->nmd_fstype = MNTTYPE_NFS4;
-			args->fh = strdup(fspath);
-			if (args->fh == NULL) {
-				*versp = nmdp->nmd_nfsvers_to_use = savevers;
-				return (-EAGAIN);
-			}
-			return (0);
-		}
-		nmdp->nmd_nfsvers_to_use = savevers;
-
-		if (retval == RET_ERR && error.error_type == ERR_RPCERROR &&
-		    error.error_value == RPC_PROGVERSMISMATCH &&
-		    nmdp->nmd_nfsvers != 0) {
-			/*
-			 * We had an explicit vers=N mount request which locked
-			 * us in to that version, however the server does not
-			 * support that version (and responded to tell us that).
-			 */
-			return (-EPROTONOSUPPORT);
-		}
-
-		vers_to_try--;
-		/* If no more versions to try, let the user know. */
-		if (vers_to_try < vers_min) {
-			if (error.error_value == 0)
-				return (-EPROTONOSUPPORT);
-			return (-rpcerr2errno(error.error_value));
-		}
-
-		/*
-		 * If we are here, there are more versions to try but
-		 * there has been an error of some sort.  If it is not
-		 * an RPC error (e.g. host unknown), we just stop and
-		 * return the error since the other versions would see
-		 * the same error as well.
-		 */
-		if (retval == RET_ERR && error.error_type != ERR_RPCERROR)
-			return (-err2errno(error.error_type));
-	}
-
-	if (nmdp->nmd_mnt_port != 0 && nmdp->nmd_mnt_proto != NULL) {
-		/* We have the necessary info to skip the call to rpcbind. */
-		cl = get_mountd_client(fshost, nmdp, &outvers, &fd);
-	}
-
-	/*
-	 * If we cannot bypass the call to rpcbind then do the lookup of the
-	 * mountd via rpcbind now.
-	 */
-	if (cl == NULL) {
-		while ((cl = clnt_create_vers(fshost, MOUNTPROG, &outvers,
-		    vers_min, vers_to_try, NULL)) == NULL) {
-			if (rpc_createerr.cf_stat == RPC_UNKNOWNHOST)
-				return (-EAGAIN);
-
-			/*
-			 * We don't want to downgrade version on lost packets
-			 */
-			if ((rpc_createerr.cf_stat == RPC_TIMEDOUT) ||
-			    (rpc_createerr.cf_stat == RPC_PMAPFAILURE))
-				return (EAGAIN);
-
-			/*
-			 * Back off and try the previous version - patch to the
-			 * problem of version numbers not being contigous and
-			 * clnt_create_vers failing (SunOS4.1 clients & SGI
-			 * servers).
-			 * The problem happens with most non-Sun servers who
-			 * don't support mountd protocol #2. So, in case the
-			 * call fails, we re-try the call anyway.
-			 */
-			vers_to_try--;
-			if (vers_to_try < vers_min) {
-				if (rpc_createerr.cf_stat ==
-				    RPC_PROGVERSMISMATCH) {
-					return (-EAGAIN);
-				}
-
-				return (EAGAIN);
-			}
-		}
-	}
-
-	if (nmdp->nmd_posix && outvers < MOUNTVERS_POSIX) {
-		return (get_fh_cleanup(cl, fd, -EAGAIN));
+	if (nmdp->nmd_mnt_port == 0 || nmdp->nmd_mnt_proto == NULL ||
+	    nmdp->nmd_mnt_vers == 0) {
+		return (-EAGAIN);
 	}
 
-	/* This only re-binds UDP connections to a reserved port */
-	if (__clnt_bindresvport(cl) < 0) {
-		return (get_fh_cleanup(cl, fd, EAGAIN));
-	}
+	cl = get_mountd_client(fshost, nmdp, &fd);
+	if (cl == NULL)
+		return (-EAGAIN);
 
 	if ((cl->cl_auth = authsys_create_default()) == NULL) {
-		return (get_fh_cleanup(cl, fd, EAGAIN));
+		return (get_fh_cleanup(cl, fd, -EAGAIN));
 	}
 
-	switch (outvers) {
-	case MOUNTVERS:
-	case MOUNTVERS_POSIX:
-		*versp = nmdp->nmd_nfsvers_to_use = NFS_VERSION;
+	if (nmdp->nmd_mnt_vers == 2) {
 		rpc_stat = clnt_call(cl, MOUNTPROC_MNT, xdr_dirpath,
 		    (caddr_t)&fspath, xdr_fhstatus, (caddr_t)&fhs, timeout);
 		if (rpc_stat != RPC_SUCCESS) {
 			log_err("%s:%s: server not responding %s\n",
 			    fshost, fspath, clnt_sperror(cl, ""));
-			return (get_fh_cleanup(cl, fd, EAGAIN));
+			return (get_fh_cleanup(cl, fd, -EAGAIN));
 		}
 
 		if ((errno = fhs.fhs_status) != MNT_OK) {
@@ -1951,7 +985,7 @@ get_fh(struct nfs_args *args, char *fshost, char *fspath, int *versp,
 				log_err("%s:%s: server not responding %s\n",
 				    fshost, fspath, clnt_sperror(cl, ""));
 				free(args->fh);
-				return (get_fh_cleanup(cl, fd, EAGAIN));
+				return (get_fh_cleanup(cl, fd, -EAGAIN));
 			}
 			if (_PC_ISSET(_PC_ERROR, p.pc_mask)) {
 				free(args->fh);
@@ -1966,17 +1000,16 @@ get_fh(struct nfs_args *args, char *fshost, char *fspath, int *versp,
 			(void) memcpy((caddr_t)args->pathconf, (caddr_t)&p,
 			    sizeof (p));
 		}
-		break;
 
-	case MOUNTVERS3:
-		*versp = nmdp->nmd_nfsvers_to_use = NFS_V3;
+	} else { /* nmdp->nmd_mnt_vers == 3 */
+
 		rpc_stat = clnt_call(cl, MOUNTPROC_MNT, xdr_dirpath,
 		    (caddr_t)&fspath, xdr_mountres3, (caddr_t)&mountres3,
 		    timeout);
 		if (rpc_stat != RPC_SUCCESS) {
 			log_err("%s:%s: server not responding %s\n",
 			    fshost, fspath, clnt_sperror(cl, ""));
-			return (get_fh_cleanup(cl, fd, EAGAIN));
+			return (get_fh_cleanup(cl, fd, -EAGAIN));
 		}
 
 		/*
@@ -2000,19 +1033,11 @@ get_fh(struct nfs_args *args, char *fshost, char *fspath, int *versp,
 		nmdp->nmd_fstype = MNTTYPE_NFS3;
 
 		/*
-		 * Check the security flavor to be used.
-		 *
-		 * If "secure" or "sec=flavor" is a mount
-		 * option, check if the server supports the "flavor".
-		 * If the server does not support the flavor, return
-		 * error.
-		 *
-		 * If no mount option is given then look for default auth
-		 * (default auth entry in /etc/nfssec.conf) in the auth list
-		 * returned from server. If default auth not found, then use
-		 * the first supported security flavor (by the client) in the
-		 * auth list returned from the server.
-		 *
+		 * If "sec=flavor" is a mount option, check if the server
+		 * supports the "flavor". If the server does not support the
+		 * flavor, return error. It is unlikely that the server will
+		 * not support "none" or "sys", which are the only two flavors
+		 * we currently allow.
 		 */
 		auths =
 		    mountres3.mountres3_u.mountinfo.auth_flavors
@@ -2031,35 +1056,26 @@ get_fh(struct nfs_args *args, char *fshost, char *fspath, int *versp,
 					break;
 			}
 			if (i == count)
-				goto autherr;
+				return (get_fh_cleanup(cl, fd, -EAGAIN));
 		} else {
 			/* AUTH_UNIX is the default. */
 			(void) strlcpy(nmdp->nmd_nfs_sec.sc_name, "sys",
 			    MAX_NAME_LEN);
-			nmdp->nmd_nfs_sec.sc_nfsnum = 1;
+			nmdp->nmd_nfs_sec.sc_nfsnum =
+			    nmdp->nmd_nfs_sec.sc_rpcnum = 1;
 		}
-		break;
-	default:
-		return (get_fh_cleanup(cl, fd, -EAGAIN));
 	}
 
 	return (get_fh_cleanup(cl, fd, 0));
-
-autherr:
-	return (get_fh_cleanup(cl, fd, -EAGAIN));
 }
 
 /*
  * Fill in the address for the server's NFS service and fill in a knetconfig
  * structure for the transport that the service is available on.
- *
- * Return a positive EAGAIN if the caller should retry and a -EAGAIN to
- * indicate a fatal (Linux-oriented) error condition. Return other negative
- * errno values to indicate different fatal errors.
  */
 static int
 getaddr_nfs(struct nfs_args *args, char *fshost, struct netconfig **nconfp,
-    err_ret_t *error, bool_t print_rpcerror, nfs_mnt_data_t *nmdp)
+    nfs_mnt_data_t *nmdp)
 {
 	struct stat sb;
 	struct netconfig *nconf = NULL;
@@ -2067,86 +1083,25 @@ getaddr_nfs(struct nfs_args *args, char *fshost, struct netconfig **nconfp,
 	struct t_info tinfo;
 	err_ret_t addr_error;
 
-	SET_ERR_RET(error, ERR_PROTO_NONE, 0);
 	SET_ERR_RET(&addr_error, ERR_PROTO_NONE, 0);
 
-	if (nmdp->nmd_nfs_port != 0 && nmdp->nmd_nfs_proto != NULL) {
-		/* We have the necessary info to skip the call to rpcbind. */
-		nconf = get_netconf(nmdp->nmd_nfs_proto);
-		if (nconf != NULL) {
-			args->addr = get_netbuf(nconf, fshost,
-			    nmdp->nmd_nfs_port);
-
-			*nconfp = nconf;
-			tinfo.tsdu = 0;
-		}
-	}
-
-	if (args->addr == NULL) {
-		args->addr = get_addr(fshost, NFS_PROGRAM,
-		    nmdp->nmd_nfsvers_to_use, nconfp, nmdp->nmd_nfs_proto,
-		    htons(nmdp->nmd_nfs_port), &tinfo, &addr_error);
-	}
-
-	if (args->addr == NULL) {
-		switch (addr_error.error_type) {
-		case 0:
-			break;
-		case ERR_RPCERROR:
-			if (!print_rpcerror)
-				/* no error print at this time */
-				break;
-			log_err("%s NFS service not available %s\n", fshost,
-			    clnt_sperrno(addr_error.error_value));
-			break;
-		case ERR_NETPATH:
-			log_err("%s: Error in NETPATH.\n", fshost);
-			break;
-		case ERR_PROTO_INVALID:
-			log_err("%s: NFS service does not recognize "
-			    "protocol: %s.\n", fshost, nmdp->nmd_nfs_proto);
-			break;
-		case ERR_PROTO_UNSUPP:
-			if (nmdp->nmd_nfsvers ||
-			    nmdp->nmd_nfsvers_to_use == NFS_VERSMIN) {
-				log_err("%s: NFS service does"
-				    " not support protocol: %s.\n",
-				    fshost, nmdp->nmd_nfs_proto);
-			}
-			break;
-		case ERR_NOHOST:
-			log_err("%s: %s\n", fshost, "Unknown host");
-			break;
-		default:
-			/* case ERR_PROTO_NONE falls through */
-			log_err("%s: NFS service not responding\n", fshost);
-			break;
-		}
-
-		SET_ERR_RET(error,
-		    addr_error.error_type, addr_error.error_value);
-		if (addr_error.error_type == ERR_PROTO_NONE) {
-			return (EAGAIN);
-		} else if (addr_error.error_type == ERR_RPCERROR &&
-		    !IS_UNRECOVERABLE_RPC(addr_error.error_value)) {
-			return (EAGAIN);
-		} else if (nmdp->nmd_nfsvers == 0 &&
-		    addr_error.error_type == ERR_PROTO_UNSUPP &&
-		    nmdp->nmd_nfsvers_to_use != NFS_VERSMIN) {
-			/*
-			 * If no version is specified, and the error is due
-			 * to an unsupported transport, then decrement the
-			 * version and retry.
-			 */
-			return (EAGAIN);
-		} else if (addr_error.error_type != ERR_RPCERROR) {
-			return (-err2errno(addr_error.error_type));
-		} else {
-			return (-rpcerr2errno(addr_error.error_value));
-		}
-	}
-	nconf = *nconfp;
+	/*
+	 * Given the values passed in from the user-land mount command (or our
+	 * built-in defaults), we should have the necessary NFS host address
+	 * info. We have already validated that we have a supported
+	 * nmd_nfs_proto.
+	 */
+	assert(nmdp->nmd_nfs_port != 0);
+	assert(nmdp->nmd_nfs_proto != NULL);
+	nconf = get_netconf(nmdp->nmd_nfs_proto);
+	assert(nconf != NULL);
+	args->addr = get_netbuf(nconf, fshost, nmdp->nmd_nfs_port);
+	if (args->addr == NULL)
+		return (-ENOMEM);
+	*nconfp = nconf;
+	tinfo.tsdu = 0;
 
+	/* This shouldn't fail unless the zone is misconfigured */
 	if (stat(nconf->nc_device, &sb) < 0)
 		return (-ENOSR);
 
@@ -2173,57 +1128,6 @@ getaddr_nfs(struct nfs_args *args, char *fshost, struct netconfig **nconfp,
 	return (0);
 }
 
-static int
-retry(struct mnttab *mntp, int mntflags, nfs_mnt_data_t *nmdp)
-{
-	int delay = 5;
-	int count = nmdp->nmd_retries;
-	int r = -EAGAIN;
-	char *p;
-
-	if (nmdp->nmd_bg) {
-		if (fork() > 0)
-			return (0);
-	} else {
-		p = strchr(mntp->mnt_special, ':');
-		if (p != NULL)
-			*p = '\0';
-		log_err("%s: server not responding\n", mntp->mnt_special);
-		if (p != NULL)
-			*p = ':';
-	}
-
-	while (count--) {
-		err_ret_t retry_error;
-
-		if ((r = mount_nfs(mntp, mntflags, &retry_error, nmdp)) == 0)
-			return (0);
-
-		if (r != EAGAIN)
-			break;
-
-		if (count > 0) {
-			(void) sleep(delay);
-			delay *= 2;
-			if (delay > 120)
-				delay = 120;
-		}
-		p = strchr(mntp->mnt_special, ':');
-		if (p != NULL)
-			*p = '\0';
-		log_err("%s: server not responding\n", mntp->mnt_special);
-		if (p != NULL)
-			*p = ':';
-	}
-
-	if (!nmdp->nmd_nfsretry_vers)
-		log_err("giving up on: %s\n", mntp->mnt_mountp);
-
-	if (r > 0)
-		r = -EAGAIN;
-	return (r);
-}
-
 static int
 append_opt(char *optstr, int len, char *k, char *v)
 {
@@ -2423,31 +1327,29 @@ convert_nfs_arg_str(char *srcp, char *mntopts)
 int
 lx_nfs_mount(char *srcp, char *mntp, char *fst, int lx_flags, char *opts)
 {
-	struct mnttab mnt;
 	int r;
 	int il_flags = 0;
-	err_ret_t retry_error;
-	nfs_mnt_data_t nmd;
-
-	_nsl_brand_set_hooks(lx_nsl_set_sz_func, lx_get_ent_func);
+	nfs_mnt_data_t nmd, *nmdp = &nmd;
+	struct nfs_args *argp = NULL;
+	struct netconfig *nconf = NULL;
+	char *colonp;
+	char *path;
+	char *host;
+	char spec_buf[MAXPATHLEN + LX_NMD_MAXHOSTNAMELEN + 1];
 
 	bzero(&nmd, sizeof (nmd));
-	nmd.nmd_retries = BIGRETRY;
 	nmd.nmd_fstype = MNTTYPE_NFS;
 
 	/*
 	 * This will modify the special string so that the hostname passed
 	 * in will be replaced with the host address that the user-land code
-	 * looked up. Thus the rest of the code down the mount_nfs path will
-	 * be working with that IP address in places were it references the
-	 * 'hostname'. This also converts the opts string so that we'll be
-	 * dealing with Illumos options after this.
+	 * looked up. This also converts the opts string so that we'll be
+	 * dealing with illumos options after this.
 	 */
 	if ((r = convert_nfs_arg_str(srcp, opts)) < 0) {
 		return (r);
 	}
 
-
 	/* Linux seems to always allow overlay mounts */
 	il_flags |= MS_OVERLAY;
 
@@ -2479,40 +1381,79 @@ lx_nfs_mount(char *srcp, char *mntp, char *fst, int lx_flags, char *opts)
 	    ((r = i_add_option("noatime", opts, MAX_MNTOPT_STR)) != 0))
 		return (r);
 
-	mnt.mnt_special = srcp;
-	mnt.mnt_mountp = mntp;
-	mnt.mnt_mntopts = opts;
+	(void) strlcpy(spec_buf, srcp, sizeof (spec_buf));
+	colonp = strchr(spec_buf, ':');
+	if (colonp == NULL)
+		return (-EINVAL);
 
-	SET_ERR_RET(&retry_error, ERR_PROTO_NONE, 0);
-	r = mount_nfs(&mnt, il_flags, &retry_error, &nmd);
+	*colonp = '\0';
+	host = spec_buf;
+	path = colonp + 1;
 
-	/* A negative errno return means we're done. */
-	if (r < 0)
-		return (r);
+	argp = (struct nfs_args *)malloc(sizeof (*argp));
+	if (argp == NULL)
+		return (-ENOMEM);
+
+	(void) memset(argp, 0, sizeof (*argp));
+	(void) memset(&nmdp->nmd_nfs_sec, 0, sizeof (seconfig_t));
+	nmdp->nmd_sec_opt = 0;
 
-	if (r == EAGAIN && nmd.nmd_retries) {
+	/* returns a negative errno */
+	if ((r = set_args(&il_flags, argp, host, opts, nmdp)) != 0)
+		goto out;
+
+	if (nmdp->nmd_nfsvers == 4) {
 		/*
-		 * Check the error code from the last mount attempt. If it was
-		 * an RPC error, then retry as is. Otherwise we retry with the
-		 * nmd_nfsretry_vers set. It is set by decrementing
-		 * nmd_nfsvers_to_use.
+		 * In the case of version 4 there is no MOUNT program, thus no
+		 * need for an RPC to get a file handle.
 		 */
-		if (retry_error.error_type != 0) {
-			if (retry_error.error_type != ERR_RPCERROR) {
-				nmd.nmd_nfsretry_vers =
-				    nmd.nmd_nfsvers_to_use =
-				    nmd.nmd_nfsvers_to_use - 1;
-				if (nmd.nmd_nfsretry_vers < NFS_VERSMIN)
-					return (-EAGAIN);
-			}
+		nmdp->nmd_fstype = MNTTYPE_NFS4;
+		argp->fh = strdup(path);
+		if (argp->fh == NULL) {
+			r = -ENOMEM;
+			goto out;
 		}
-
-		r = retry(&mnt, il_flags, &nmd);
+	} else {
+		if ((r = get_fh(argp, host, path, nmdp)) < 0)
+			goto out;
 	}
 
-	/* Convert positve EAGAIN into a valid errno. */
-	if (r > 0)
-		return (-EAGAIN);
+	if ((r = getaddr_nfs(argp, host, &nconf, nmdp)) < 0)
+		goto out;
 
-	return (0);
+	if ((r = make_secure(argp, nmdp)) < 0)
+		goto out;
+
+	il_flags |= MS_DATA | MS_OPTIONSTR;
+
+	r = mount(srcp, mntp, il_flags, nmdp->nmd_fstype, argp, sizeof (*argp),
+	    opts, MAX_MNTOPT_STR);
+	if (r != 0)
+		r = -errno;
+out:
+	if (nconf != NULL)
+		freenetconfigent(nconf);
+	if (argp->fh)
+		free(argp->fh);
+	if (argp->pathconf)
+		free(argp->pathconf);
+	if (argp->knconf)
+		free(argp->knconf);
+	if (argp->addr) {
+		free(argp->addr->buf);
+		free(argp->addr);
+	}
+	if (argp->nfs_ext_u.nfs_extB.secdata)
+		free(argp->nfs_ext_u.nfs_extB.secdata);
+	if (argp->syncaddr) {
+		free(argp->syncaddr->buf);
+		free(argp->syncaddr);
+	}
+	if (argp->netname)
+		free(argp->netname);
+	free(argp);
+	if (nmdp->nmd_nfs_proto != NULL)
+		free(nmdp->nmd_nfs_proto);
+
+	return (r);
 }
diff --git a/usr/src/lib/libnsl/common/mapfile-vers b/usr/src/lib/libnsl/common/mapfile-vers
index 21d6ca76c6..1a8a5e65e2 100644
--- a/usr/src/lib/libnsl/common/mapfile-vers
+++ b/usr/src/lib/libnsl/common/mapfile-vers
@@ -468,7 +468,6 @@ $endif
 
 SYMBOL_VERSION SUNWprivate_1.5 {
     global:
- 	_nsl_brand_set_hooks;
 	clnt_create_service_timed;
 	inet_matchaddr;
 } SUNWprivate_1.4;
diff --git a/usr/src/lib/libnsl/netselect/netselect.c b/usr/src/lib/libnsl/netselect/netselect.c
index 8c21fc3d69..7790894c9e 100644
--- a/usr/src/lib/libnsl/netselect/netselect.c
+++ b/usr/src/lib/libnsl/netselect/netselect.c
@@ -70,9 +70,6 @@ static struct netconfig *netconfig_dup(struct netconfig *);
 
 extern const char __nsl_dom[];
 
-static int (*brand_get_sz)(void) = NULL;
-static struct netconfig *(*brand_get_net_ent)(int) = NULL;
-
 /*
  *	Static global variables used by the library procedures:
  *
@@ -258,14 +255,6 @@ freenetconfigent(struct netconfig *netp)
 	netconfig_free(netp);
 }
 
-void
-_nsl_brand_set_hooks(int (*set_sz_func)(void),
-    struct netconfig *(*get_ent_func)(int))
-{
-	brand_get_sz = set_sz_func;
-	brand_get_net_ent = get_ent_func;
-}
-
 /*
  *	getnetlist() reads the netconfig file and creates a
  *	NULL-terminated list of entries.
@@ -282,6 +271,7 @@ getnetlist(void)
 	int count;		/* the number of entries in file */
 	char nc_path[MAXPATHLEN];
 	const char *zroot = zone_get_nroot();
+	char line[BUFSIZ];	/* holds each line of NETCONFIG */
 
 	/*
 	 * If we are running in a branded zone, ensure we use the "/native"
@@ -290,24 +280,18 @@ getnetlist(void)
 	(void) snprintf(nc_path, sizeof (nc_path), "%s%s", zroot != NULL ?
 	    zroot : "", NETCONFIG);
 
-	if (brand_get_sz != NULL) {
-		count = brand_get_sz();
-	} else {
-		char line[BUFSIZ];	/* holds each line of NETCONFIG */
-
-		if ((fp = fopen(nc_path, "rF")) == NULL) {
-			nc_error = NC_OPENFAIL;
-			return (NULL);
-		}
+	if ((fp = fopen(nc_path, "rF")) == NULL) {
+		nc_error = NC_OPENFAIL;
+		return (NULL);
+	}
 
-		count = 0;
-		while (fgets(line, BUFSIZ, fp)) {
-			if (!(blank(line) || comment(line))) {
-				++count;
-			}
+	count = 0;
+	while (fgets(line, BUFSIZ, fp)) {
+		if (!(blank(line) || comment(line))) {
+			++count;
 		}
-		rewind(fp);
 	}
+	rewind(fp);
 
 	if (count == 0) {
 		nc_error = NC_NOTFOUND;
@@ -324,33 +308,21 @@ getnetlist(void)
 		return (NULL);
 	}
 
-	if (brand_get_net_ent != NULL) {
-		int i;
-
-		tpp = listpp;
-		for (i = 0; i < count; i++) {
-			*tpp = brand_get_net_ent(i);
-			tpp++;
-		}
-		*tpp = NULL;
-		nc_error = NC_NOMOREENTRIES;
-	} else {
-		/*
-		 *	The following loop fills in the list (loops until
-		 *	fgetnetconfig() returns a NULL) and counts the
-		 *	number of entries placed in the list.  Note that
-		 *	when the loop is completed, the last entry in the
-		 *	list will contain a NULL (signifying the end of
-		 *	the list).
-		 */
-		linenum = 0;
-		for (tpp = listpp; *tpp = fgetnetconfig(fp, NULL); tpp++)
-			;
-		(void) fclose(fp);
+	/*
+	 *	The following loop fills in the list (loops until
+	 *	fgetnetconfig() returns a NULL) and counts the
+	 *	number of entries placed in the list.  Note that
+	 *	when the loop is completed, the last entry in the
+	 *	list will contain a NULL (signifying the end of
+	 *	the list).
+	 */
+	linenum = 0;
+	for (tpp = listpp; *tpp = fgetnetconfig(fp, NULL); tpp++)
+		;
+	(void) fclose(fp);
 
-		if (nc_error != NC_NOMOREENTRIES) /* Something is screwed up */
-			netlist_free(&listpp);
-	}
+	if (nc_error != NC_NOMOREENTRIES) /* Something is screwed up */
+		netlist_free(&listpp);
 
 	return (listpp);
 }
diff --git a/usr/src/uts/common/sys/netconfig.h b/usr/src/uts/common/sys/netconfig.h
index 883c329aed..9bba7e9e88 100644
--- a/usr/src/uts/common/sys/netconfig.h
+++ b/usr/src/uts/common/sys/netconfig.h
@@ -148,8 +148,6 @@ extern int		endnetpath(void *);
 extern struct netconfig *getnetpath(void *);
 extern void		nc_perror(const char *);
 extern char		*nc_sperror(void);
-extern void		_nsl_brand_set_hooks(int (*)(void),
-			    struct netconfig *(*)(int));
 
 #ifdef	__cplusplus
 }
-- 
2.21.0

