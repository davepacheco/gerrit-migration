From 1ca3d570475a4be0ecd71f7a1c64f3f6db56c1ae Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Tue, 13 Mar 2018 21:09:12 +0000
Subject: [PATCH] NET-387 portolan command line asks for --vnet_id but really
 wants --vnet-id NET-390 portolan should support intra-DC cross vnet routing
 Reviewed by: Dan McDonald <danmcd@joyent.com> Approved by:

---
 bin/portolan                     | 158 ++++++++++++++++++-
 etc/svp-types.json               |  49 +++++-
 lib/backend/json.js              |   6 +-
 lib/backend/moray.js             | 246 +++++++++++++++++++++++++++--
 lib/client.js                    | 101 +++++++++++-
 lib/common.js                    | 132 +++++++++++++++-
 lib/framer.js                    |   7 +
 lib/moray.js                     |   2 +-
 lib/parser.js                    |  40 ++++-
 lib/serialize.js                 |  41 +++++
 lib/types.js                     |  67 ++++++--
 package.json                     |   4 +-
 src/libvarpd_svp_prot.h          |  61 ++++++--
 test/integration/backend.test.js | 259 ++++++++++++++++++++++++++++++-
 test/lib/mapping.js              |  97 +++++++++++-
 test/lib/request.js              |  96 +++++++++++-
 test/unit/types.test.js          |  19 +++
 17 files changed, 1332 insertions(+), 53 deletions(-)

diff --git a/bin/portolan b/bin/portolan
index 4de1039..9605e41 100755
--- a/bin/portolan
+++ b/bin/portolan
@@ -57,6 +57,18 @@ var OPTS = {
         help: 'IP address'
     },
 
+    srcip: {
+        names: [ 'srcip' ],
+        type: 'string',
+        help: 'source IP address'
+    },
+
+    dstip: {
+        names: [ 'dstip' ],
+        type: 'string',
+        help: 'destination IP address'
+    },
+
     mac: {
         names: [ 'mac' ],
         type: 'string',
@@ -70,11 +82,17 @@ var OPTS = {
     },
 
     vnet_id: {
-        names: [ 'vnet-id' ],
+        names: [ 'vnet-id', 'vnet_id' ],
         type: 'positiveInteger',
         help: 'Virtual network ID'
     },
 
+    vlan_id: {
+        names: [ 'vlan-id', 'vlan_id' ],
+        type: 'positiveInteger',
+        help: 'Virtual LAN ID'
+    },
+
     count: {
         names: [ 'count' ],
         type: 'positiveInteger',
@@ -85,6 +103,42 @@ var OPTS = {
         names: [ 'id', 'uuid' ],
         type: 'arrayOfString',
         help: 'array of log ids to remove'
+    },
+
+    r_dc_id: {
+        names: [ 'r_dc_id' ],
+        type: 'positiveInteger',
+        help: 'remote datacenter id'
+    },
+
+    r_vnet_id: {
+        names: [ 'r_vnet_id' ],
+        type: 'positiveInteger',
+        help: 'remote virtual network ID'
+    },
+
+    r_vlan_id: {
+        names: [ 'r_vlan_id' ],
+        type: 'positiveInteger',
+        help: 'remote vlan ID'
+    },
+
+    r_send_mac: {
+        names: [ 'r_send_mac' ],
+        type: 'string',
+        help: 'reply mac address'
+    },
+
+    subnet: {
+        names: [ 'subnet' ],
+        type: 'string',
+        help: 'local subnet'
+    },
+
+    r_subnet: {
+        names: [ 'r_subnet' ],
+        type: 'string',
+        help: 'remote subnet'
     }
 };
 
@@ -348,8 +402,8 @@ PortolanCLI.prototype['do_vl3-lookup'] =
 
 PortolanCLI.prototype['do_vl3-lookup'].options = [
     OPTS.host,
-    OPTS.ip,
     OPTS.port,
+    OPTS.ip,
     OPTS.vnet_id
 ];
 
@@ -359,6 +413,7 @@ PortolanCLI.prototype['do_log_req'] =
 
     try {
         var connOpts = translateOpts(opts, {
+            vnet_id: 'vnet_id',
             ip: 'ip',
             count: 'count'
         });
@@ -437,5 +492,104 @@ PortolanCLI.prototype['do_log_rm'].options = [
     OPTS.id
 ];
 
+/**
+ * Add an vnet route mapping
+ */
+PortolanCLI.prototype['do_add-vnetroute'] =
+    function _addVnetRoute(_subcmd, opts, _args, callback) {
+
+    var backendOpts;
+    try {
+        backendOpts = translateOpts(opts, {
+            vnet_id: 'vnet_id',
+            vlan_id: 'vlan_id',
+            subnet: 'subnet',
+            r_dc_id: 'r_dc_id',
+            r_vnet_id: 'r_vnet_id',
+            r_vlan_id: 'r_vlan_id',
+            r_subnet: 'r_subnet',
+            r_send_mac: 'r_send_mac'
+        });
+        mod_common.validate.opts(backendOpts);
+    } catch (optsErr) {
+        callback(optsErr);
+        return;
+    }
+
+    backendOpts.subnet = mod_common.IPv6SubObj(backendOpts.subnet);
+    backendOpts.r_subnet = mod_common.IPv6SubObj(backendOpts.r_subnet);
+    backendOpts.r_send_mac = mod_common.macToInt(backendOpts.r_send_mac);
+
+    mod_backend.addVnetRouteMapping(backendOpts, callback);
+};
+
+PortolanCLI.prototype['do_add-vnetroute'].options = [
+    OPTS.host,
+    OPTS.port,
+    OPTS.vnet_id,
+    OPTS.vlan_id,
+    OPTS.subnet,
+    OPTS.r_dc_id,
+    OPTS.r_vnet_id,
+    OPTS.r_vlan_id,
+    OPTS.r_subnet,
+    OPTS.r_send_mac
+];
+
+
+/**
+ * Do a VNET Route lookup
+ */
+PortolanCLI.prototype['do_vnetroute-lookup'] =
+    function _vnetRouteReq(_subcmd, opts, _args, callback) {
+
+    var connOpts;
+
+    try {
+        connOpts = translateOpts(opts, {
+            vnet_id: 'vnet_id',
+            vlan_id: 'vlan_id',
+            srcip: 'srcip',
+            dstip: 'dstip'
+        });
+        mod_common.validate.opts(connOpts);
+    } catch (optsErr) {
+        callback(optsErr);
+        return;
+    }
+
+    setClientOpts(opts, connOpts);
+    connOpts.srcip = mod_common.IPv6obj(connOpts.srcip);
+    connOpts.dstip = mod_common.IPv6obj(connOpts.dstip);
+
+    var client = mod_client.connect(connOpts, function _afterVl3Conn(err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        client.vnetRouteReq(connOpts, function (err2, res) {
+            if (err2) {
+                callback(err2);
+                return;
+            }
+
+            json(res);
+            callback();
+        });
+    });
+};
+
+PortolanCLI.prototype['do_vnetroute-lookup'].options = [
+    OPTS.host,
+    OPTS.port,
+    OPTS.vnet_id,
+    OPTS.vlan_id,
+    OPTS.srcip,
+    OPTS.dstip
+];
+
+// TODO: add vnetroute-remove
+
 var cli = new PortolanCLI();
 mod_cmdln.main(cli);
diff --git a/etc/svp-types.json b/etc/svp-types.json
index 7095730..ffc9f93 100644
--- a/etc/svp-types.json
+++ b/etc/svp-types.json
@@ -4,7 +4,14 @@
 		"created_at": 1430352621,
 		"derived_from": "src/types",
 		"ctf_version": 2,
-		"requested_types": [ "svp_req_t" , "svp_vl2_req_t" , "svp_vl2_ack_t" , "svp_vl3_req_t" , "svp_vl3_ack_t" , "svp_bulk_req_t" , "svp_bulk_ack_t" , "svp_log_req_t" , "svp_log_vl2_t" , "svp_log_vl3_t" , "svp_log_ack_t" , "svp_lrm_req_t" , "svp_lrm_ack_t" , "svp_shootdown_t" ]
+		"requested_types": [
+            "svp_req_t", "svp_vl2_req_t", "svp_vl2_ack_t",
+            "svp_vl3_req_t", "svp_vl3_ack_t", "svp_bulk_req_t",
+            "svp_bulk_ack_t", "svp_log_req_t", "svp_log_vl2_t",
+            "svp_log_vl3_t", "svp_log_ack_t", "svp_lrm_req_t",
+            "svp_lrm_ack_t", "svp_shootdown_t", "svp_route_req_t",
+            "svp_route_ack_t"
+        ]
 	},
 "data":
 	[
@@ -56,7 +63,7 @@
 		] },
 		{ "name": "svp_vl3_req_t", "typedef": "struct svp_vl3_req" },
 		{ "name": "svp_vl3_ack_t", "typedef": "struct svp_vl3_ack" },
-		{ "name": "struct svp_bulk_req", "struct": [
+        { "name": "struct svp_bulk_req", "struct": [
 			{ "name": "svbr_type", "type": "uint32_t" }
 		] },
 		{ "name": "svp_bulk_req_t", "typedef": "struct svp_bulk_req" },
@@ -95,6 +102,42 @@
 			{ "name": "svl3_vnetid", "type": "uint32_t" }
 		] },
 		{ "name": "svp_log_vl3_t", "typedef": "struct svp_log_vl3" },
-		{ "name": "svp_shootdown_t", "typedef": "struct svp_shootdown" }
+		{ "name": "struct svp_log_route", "struct": [
+			{ "name": "svlr_type", "type": "uint32_t" },
+			{ "name": "svlr_id", "type": "uint8_t [16]" },
+			{ "name": "svlr_src_vnetid", "type": "uint32_t" },
+			{ "name": "svlr_dst_vnetid", "type": "uint32_t" },
+			{ "name": "svlr_dcid", "type": "uint32_t" },
+			{ "name": "svlr_srcip", "type": "uint8_t [16]" },
+			{ "name": "svlr_dstip", "type": "uint8_t [16]" },
+			{ "name": "svlr_src_vlanid", "type": "uint16_t" },
+			{ "name": "svlr_dst_vlanid", "type": "uint16_t" },
+			{ "name": "svlr_src_prefixlen", "type": "uint8_t" },
+			{ "name": "svlr_dst_prefixlen", "type": "uint8_t" },
+			{ "name": "svlr_pad", "type": "uint8_t [2]" }
+		] },
+		{ "name": "svp_log_route_t", "typedef": "struct svp_log_route" },
+		{ "name": "svp_shootdown_t", "typedef": "struct svp_shootdown" },
+		{ "name": "struct svp_route_req", "struct": [
+			{ "name": "srr_vnetid", "type": "uint32_t" },
+			{ "name": "srr_vlanid", "type": "uint16_t" },
+			{ "name": "srr_pad", "type": "uint8_t [2]" },
+			{ "name": "srr_srcip", "type": "uint8_t [16]" },
+			{ "name": "srr_dstip", "type": "uint8_t [16]" }
+		] },
+		{ "name": "struct svp_route_ack", "struct": [
+			{ "name": "sra_status", "type": "uint32_t" },
+			{ "name": "sra_dcid", "type": "uint32_t" },
+			{ "name": "sra_vnetid", "type": "uint32_t" },
+			{ "name": "sra_vlanid", "type": "uint16_t" },
+			{ "name": "sra_port", "type": "uint16_t" },
+			{ "name": "sra_ul3ip", "type": "uint8_t [16]" },
+			{ "name": "sra_vl2_srcmac", "type": "uint8_t [6]" },
+			{ "name": "sra_vl2_dstmac", "type": "uint8_t [6]" },
+			{ "name": "sra_src_prefixlen", "type": "uint8_t" },
+			{ "name": "sra_dst_prefixlen", "type": "uint8_t" }
+		] },
+		{ "name": "svp_route_req_t", "typedef": "struct svp_route_req" },
+		{ "name": "svp_route_ack_t", "typedef": "struct svp_route_ack" }
 	]
 }
diff --git a/lib/backend/json.js b/lib/backend/json.js
index baaf92e..b45eaf9 100644
--- a/lib/backend/json.js
+++ b/lib/backend/json.js
@@ -58,7 +58,6 @@ var UNDERLAY_FILE = {
 };
 
 
-
 // --- Internal
 
 
@@ -177,6 +176,8 @@ JsonStore.prototype._transform = function _dssTransform(msg, _enc, callback) {
         return this.logReq(msg, callback);
     case types.svp_op.SVP_R_LOG_RM:
         return this.logRm(msg, callback);
+    case types.svp_op.SVP_R_ROUTE_REQ:
+        return this.routeReq(msg, callback);
     default:
         this.log.warn({ message: msg }, 'unsupported svp_type');
         // XXX: push some sort of error on here?
@@ -334,6 +335,9 @@ JsonStore.prototype.logRm = function _jsonLogRm(_msg, callback) {
     callback();
 };
 
+// TODO: JsonStore.prototype.routeReq
+
+
 // --- Exports
 
 
diff --git a/lib/backend/moray.js b/lib/backend/moray.js
index aed1a99..f40ca82 100644
--- a/lib/backend/moray.js
+++ b/lib/backend/moray.js
@@ -18,6 +18,7 @@ var assert = require('assert-plus');
 var clone = require('clone');
 var common = require('../common');
 var mod_moray = require('../moray');
+var mod_client = require('../client');
 var mod_portolan_moray = require('portolan-moray');
 var stream = require('stream');
 var types = require('../types');
@@ -54,6 +55,7 @@ function init(config, callback) {
     assert.object(config, 'config');
     assert.func(callback, 'callback');
 
+    SHARED.config = config;
     mod_moray.createClient(config, function _afterClient(err, client) {
         if (err) {
             callback(err);
@@ -277,17 +279,16 @@ MorayStore.prototype._op_svp_r_log_req =
             'logreq mapped cn ip');
 
         // This is an upper limit, based on the smallest possible size of logs.
-
-
         var limit = Math.floor(
             input.svp_msg.lr_count /
             Math.min(types.sizeof.SVP_LOG_VL2,
-                types.sizeof.SVP_LOG_VL3));
+                types.sizeof.SVP_LOG_VL3,
+                types.sizeof.SVP_LOG_ROUTE));
 
         log.debug({ input: input, bytes: input.svp_msg.lr_count,
             vl2: types.sizeof.SVP_LOG_VL2, vl3: types.sizeof.SVP_LOG_VL3,
-            limit: limit }, 'calculating log limit');
-
+            route: types.sizeof.SVP_LOG_ROUTE, limit: limit },
+            'calculating log limit');
 
         mod_portolan_moray.logReq({
             cnUuid: mapping.cn_uuid,
@@ -313,15 +314,23 @@ MorayStore.prototype._op_svp_r_log_req =
             };
 
             for (var i = 0; i < logs.length; i++) {
+                var log_type = logs[i].record.type;
+
+                /*
+                 * Skip any version incompatible records if client version is
+                 * too low.
+                 */
+                if (input.svp_ver < types.minver[log_type]) {
+                    continue;
+                }
+
                 // enforce the real limit based on actual logs returned.
                 bytes += types.sizeof[logs[i].record.type];
                 if (bytes > input.svp_msg.lr_count) {
                     break;
                 }
 
-                if (logs[i].record.type === 'SVP_LOG_VL3') {
-                    logs[i].record.ip = common.stringToIp(logs[i].record.ip);
-                }
+                translateRecord(logs[i].record);
                 output.svp_msg.log_data.push(logs[i]);
             }
 
@@ -359,6 +368,139 @@ MorayStore.prototype._op_svp_r_log_rm =
 };
 
 
+MorayStore.prototype._op_svp_r_route_req =
+    function _op_svp_r_route_req(input, log, callback) {
+
+    var self = this;
+    var r_ip = input.svp_msg.r_ip;
+    var ip = input.svp_msg.ip;
+    var vnet = input.svp_msg.vnet_id;
+    var vlan = input.svp_msg.vlan_id;
+    var output;
+    var client;
+
+    // TODO: how to handle limiting results and requiring a subsequent lookups
+    mod_portolan_moray.vnetRouteLookup({
+        log: log,
+        moray: self.moray,
+        src_vnet_id: vnet,
+        src_vlan_id: vlan
+    }, function (vrErr, routes) {
+        if (vrErr) {
+            log.error('Error looking up vnet route', input);
+            callback(vrErr);
+            return;
+        }
+
+        for (var r in routes) {
+            var route = routes[r];
+            if (!common.cidrContainsIP(route.subnet, ip) ||
+                !common.cidrContainsIP(route.r_subnet, r_ip)) {
+
+                continue;
+            }
+
+            var dst_prefixlen = common.cidrPrefixLen(route.r_subnet);
+            var src_prefixlen = common.cidrPrefixLen(route.subnet);
+
+            output = {
+                svp_msg: {
+                    sra_status: types.svp_status.SVP_S_OK,
+                    sra_dcid: route.r_dc_id,
+                    sra_vnetid: route.r_vnet_id,
+                    sra_vlanid: route.r_vlan_id,
+                    sra_dst_prefixlen: dst_prefixlen,
+                    sra_src_prefixlen: src_prefixlen,
+                    sra_vl2_srcmac: route.r_send_mac
+                },
+                svp_type: types.svp_op.SVP_R_ROUTE_ACK
+            };
+
+            break;
+        }
+
+        /* Vnet Route lookup failure. */
+        if (!output) {
+            callback(null, common.vnetRouteNotFoundMsg(input));
+            return;
+        }
+
+        /*
+         * When we implement cross-DC fabrics, this should be expanded to allow
+         * for connections to remote portolans.
+         */
+        var remote_req = {
+            op: types.svp_op.SVP_R_VL3_REQ,
+            payload: {
+                vl3_ip: r_ip,
+                vl3_vnetid: route.r_vnet_id
+            }
+        };
+
+        client = mod_client.connect({
+            host: 'localhost',
+            port: SHARED.config.port
+        }, function (cerr) {
+            if (cerr) {
+                log.error(cerr, 'failed to create portolan client');
+                callback(cerr);
+                return;
+            }
+
+            client.makeCall(remote_req, function (err, res) {
+                if (err) {
+                    callback(err);
+                    client.close();
+                    return;
+                }
+
+                var res_msg = res.svp_msg;
+
+                if (res_msg.vl3_status === types.svp_status.SVP_S_NOTFOUND) {
+                    log.debug('vnetroute failed to find corresponding vl3 for:',
+                        input);
+                    callback(null, common.vnetRouteNotFoundMsg(input));
+                    client.close();
+                    return;
+                }
+
+                output.svp_msg.sra_port = res_msg.vl3_port;
+                output.svp_msg.sra_ul3ip = res_msg.vl3_ip;
+                output.svp_msg.sra_vl2_dstmac = res_msg.vl3_mac;
+
+                log.debug('vnetroute received vl3 response:', res,
+                    'writing output:', output);
+                callback(null, output);
+                client.close();
+            });
+        });
+    });
+};
+
+function translateRecord(record) {
+    switch (record.type) {
+    case 'SVP_LOG_VL3':
+        record.ip = common.stringToIp(record.ip);
+        break;
+    case 'SVP_LOG_ROUTE':
+        record.srcip = common.stringToIp(record.srcip);
+        record.dstip = common.stringToIp(record.dstip);
+        break;
+    default:
+        break;
+    }
+}
+
+function addEventBatch(opts, func, callback) {
+    var batch = mod_portolan_moray[func](opts);
+    var moray = SHARED.moray;
+
+    moray.batch(batch, function (err, data) {
+        callback(err, data);
+        return;
+    });
+}
+
 // --- Backend manipulation
 
 
@@ -435,6 +577,84 @@ function removeUnderlayMapping(opts, callback) {
     return mod_portolan_moray.removeUnderlayMapping(newOpts, callback);
 }
 
+function addVl2CnEventBatch(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+    assert.number(opts.vnet_id, 'opts.vnet_id');
+    assert.number(opts.mac, 'opts.mac');
+
+    addEventBatch(opts, 'vl2CnEventBatch', callback);
+}
+
+function addVl3CnEventBatch(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+    assert.number(opts.vnet_id, 'opts.vnet_id');
+    assert.number(opts.mac, 'opts.mac');
+    assert.number(opts.vlan_id, 'opts.vlan_id');
+    assert.object(opts.ip, 'opts.ip');
+
+    opts.ip = common.ipToString(opts.ip);
+
+    addEventBatch(opts, 'vl3CnEventBatch', callback);
+}
+
+function addVnetRouteCnEventBatch(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+    assert.number(opts.src_vnet_id, 'opts.src_vnet_id');
+    assert.number(opts.dst_vnet_id, 'opts.dst_vnet_id');
+    assert.number(opts.dcid, 'opts.dcid');
+    assert.object(opts.srcip, 'opts.srcip');
+    assert.object(opts.dstip, 'opts.dstip');
+    assert.number(opts.src_vlan_id, 'opts.src_vlan_id');
+    assert.number(opts.dst_vlan_id, 'opts.src_vlan_id');
+    assert.number(opts.src_prefixlen, 'opts.src_prefixlen');
+    assert.number(opts.dst_prefixlen, 'opts.dst_prefixlen');
+
+    opts.srcip = common.ipToString(opts.srcip);
+    opts.dstip = common.ipToString(opts.dstip);
+
+    addEventBatch(opts, 'vnetRouteEventBatch', callback);
+}
+
+function addVnetRouteMapping(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+
+    var newOpts = clone(opts);
+    newOpts.subnet = common.cidrToString(opts.subnet);
+    newOpts.r_subnet = common.cidrToString(opts.r_subnet);
+    newOpts.moray = SHARED.moray;
+
+    return mod_portolan_moray.addVnetRouteMapping(newOpts, callback);
+}
+
+
+function updateVnetRouteMapping(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+
+    var newOpts = clone(opts);
+    newOpts.subnet = common.cidrToString(opts.subnet);
+    newOpts.r_subnet = common.cidrToString(opts.r_subnet);
+    newOpts.moray = SHARED.moray;
+
+    return mod_portolan_moray.updateVnetRouteMapping(newOpts, callback);
+}
+
+
+function removeVnetRouteMapping(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+
+    var newOpts = clone(opts);
+    newOpts.subnet = common.cidrToString(opts.subnet);
+    newOpts.r_subnet = common.cidrToString(opts.r_subnet);
+    newOpts.moray = SHARED.moray;
+
+    return mod_portolan_moray.removeVnetRouteMapping(newOpts, callback);
+}
 
 
 module.exports = {
@@ -448,5 +668,13 @@ module.exports = {
 
     addUnderlayMapping: addUnderlayMapping,
     updateUnderlayMapping: updateUnderlayMapping,
-    removeUnderlayMapping: removeUnderlayMapping
+    removeUnderlayMapping: removeUnderlayMapping,
+
+    addVnetRouteMapping: addVnetRouteMapping,
+    updateVnetRouteMapping: updateVnetRouteMapping,
+    removeVnetRouteMapping: removeVnetRouteMapping,
+
+    addVl2CnEventBatch: addVl2CnEventBatch,
+    addVl3CnEventBatch: addVl3CnEventBatch,
+    addVnetRouteCnEventBatch: addVnetRouteCnEventBatch
 };
diff --git a/lib/client.js b/lib/client.js
index c4124c5..489f90c 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -39,6 +39,22 @@ function PortolanClient(opts) {
 }
 
 
+/*
+ * This function, passes a request in the form of a JS object through the
+ * serializer, then to portolan as binary data, and parsers the response.  See
+ * the flow below:
+ *
+ * client: serialize request
+ * client: write request to portolan
+ *      portolan: Framer parses header
+ *      portolan: Parser parses payload
+ *      portolan: backend conducts get/set/update with moray or other backend
+ *      portolan: Serializes response
+ *      portolan: sends response
+ * client: Framer parses header
+ * client: Parser parses payload
+ * client: once('data', callback());
+ */
 PortolanClient.prototype._makeReq = function _makeReq(req, callback) {
     if (!this._serStream) {
         var strOpts = { log: this.log };
@@ -55,6 +71,19 @@ PortolanClient.prototype._makeReq = function _makeReq(req, callback) {
     this._serStream.write(req);
 };
 
+/*
+ * A wrapper around _makeReq to manage the per client id and make a raw call.
+ */
+PortolanClient.prototype.makeCall = function makeCall(req, callback) {
+    this._makeReq({
+        svp_id: this.id++,
+        svp_type: req.op,
+        svp_msg: req.payload
+    }, function (res) {
+        callback(null, res);
+        return;
+    });
+};
 
 PortolanClient.prototype.close = function _close() {
     this.client.end();
@@ -152,10 +181,12 @@ PortolanClient.prototype.logReq = function _clientLogReq(opts, callback) {
                     switch (prop) {
                     case 'svl2_type':
                     case 'svl3_type':
+                    case 'svlr_type':
                         obj.type = mod_types.svp_log_type_names[datum[prop]];
                         break;
                     case 'svl2_id':
                     case 'svl3_id':
+                    case 'svlr_id':
                         obj.id = mod_common.arrToUuid(datum[prop]);
                         break;
                     case 'svl2_mac':
@@ -165,15 +196,43 @@ PortolanClient.prototype.logReq = function _clientLogReq(opts, callback) {
                     case 'svl3_ip':
                         obj.ip = mod_common.ipToString(datum[prop]);
                         break;
+                    case 'svlr_srcip':
+                        obj.srcip = mod_common.ipToString(datum[prop]);
+                        break;
+                    case 'svlr_dstip':
+                        obj.dstip = mod_common.ipToString(datum[prop]);
+                        break;
                     case 'svl3_vlan':
                         obj.vlan = datum[prop];
                         break;
+                    case 'svlr_src_vlanid':
+                        obj.src_vlan = datum[prop];
+                        break;
+                    case 'svlr_dst_vlanid':
+                        obj.dst_vlan = datum[prop];
+                        break;
+                    case 'svlr_src_prefixlen':
+                        obj.src_prefixlen = datum[prop];
+                        break;
+                    case 'svlr_dst_prefixlen':
+                        obj.dst_prefixlen = datum[prop];
+                        break;
                     case 'svl2_vnetid':
                     case 'svl3_vnetid':
                         obj.vnet_id = datum[prop];
                         break;
+                    case 'svlr_src_vnetid':
+                        obj.src_vnet_id = datum[prop];
+                        break;
+                    case 'svlr_dst_vnetid':
+                        obj.dst_vnet_id = datum[prop];
+                        break;
                     case 'svl2_pad':
                     case 'svl3_pad':
+                    case 'svlr_pad':
+                        break;
+                    case 'svlr_dcid':
+                        obj.dcid = datum[prop];
                         break;
                     default:
                         self.log.warn({ datum: datum, property: prop },
@@ -218,6 +277,45 @@ PortolanClient.prototype.logRm = function _clientLogRm(opts, callback) {
     });
 };
 
+
+PortolanClient.prototype.vnetRouteReq =
+    function _clientVnetRouteReq(opts, callback) {
+
+    mod_assert.object(opts, 'opts');
+    mod_assert.number(opts.vnet_id, 'opts.vnet_id');
+    mod_assert.number(opts.vlan_id, 'opts.vlan_id');
+    mod_assert.object(opts.srcip, 'opts.srcip');
+    mod_assert.object(opts.dstip, 'opts.dstip');
+
+    this._makeReq({
+        svp_type: mod_types.svp_op.SVP_R_ROUTE_REQ,
+        svp_id: this.id++,
+        svp_msg: {
+            srr_vnetid: opts.vnet_id,
+            srr_vlanid: opts.vlan_id,
+            srr_srcip: opts.srcip,
+            srr_dstip: opts.dstip
+        }
+    }, function (data) {
+        var res = {
+            status: data.svp_msg.r_status,
+            status_str: mod_types.statusString(data.svp_msg.r_status),
+            r_dc_id: data.svp_msg.r_dc_id,
+            r_vnet_id: data.svp_msg.r_vnet_id,
+            r_vlan_id: data.svp_msg.r_vlan_id,
+            prefixlen: data.svp_msg.prefixlen,
+            r_prefixlen: data.svp_msg.r_prefixlen,
+            r_port: data.svp_msg.r_port,
+            r_ul3_ip: mod_common.ipToString(data.svp_msg.r_ul3_ip),
+            vl2_src_mac: mod_common.intToMac(data.svp_msg.vl2_src_mac),
+            vl2_dst_mac: mod_common.intToMac(data.svp_msg.vl2_dst_mac)
+        };
+
+        return callback(null, res);
+    });
+};
+
+
 // --- Exports
 
 
@@ -233,7 +331,7 @@ function connectClient(opts, callback) {
         level: process.env.LOG_LEVEL || 'fatal'
     });
 
-    var client =  mod_net.createConnection(opts, callback);
+    var client = mod_net.createConnection(opts, callback);
     client.on('error', callback);
 
     return new PortolanClient({
@@ -243,7 +341,6 @@ function connectClient(opts, callback) {
 }
 
 
-
 module.exports = {
     connect: connectClient
 };
diff --git a/lib/common.js b/lib/common.js
index 677f9e9..b8e29ac 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -14,6 +14,7 @@
 
 'use strict';
 
+// XXX: Switch to node-ip6addr
 var ipaddr = require('ipaddr.js');
 var types = require('./types');
 var fmt = require('util').format;
@@ -78,6 +79,33 @@ function createv6obj(ipStr) {
 }
 
 
+function createv6subobj(cidr) {
+    if (typeof (cidr) === 'object') {
+        return cidr;
+    }
+
+    var split = cidr.split('/');
+    var ip = split[0];
+    var prefixlen = parseInt(split[1], 10);
+    var ipStr;
+
+    var ipObj = ipaddr.process(ip);
+    if (ipObj.kind() === 'ipv4') {
+        if (prefixlen < 33) {
+            prefixlen += 96;
+        }
+        ipStr = ipObj.toIPv4MappedAddress().toString();
+    }
+
+    return ipaddr.parseCIDR(ipStr + '/' + prefixlen.toString());
+}
+
+
+function cidrToString(cidr) {
+    return (cidr.toString().replace(',', '/'));
+}
+
+
 function ipToString(ip) {
     return (ip.toString());
 }
@@ -95,6 +123,48 @@ function stringToIp(ip) {
     return (ipaddr.parse(ip));
 }
 
+/*
+ * Subnets are stored in IPv4 Mapped IPv6 format, so prefixlen
+ * should be > 96.
+ */
+function cidrPrefixLen(cidr) {
+    var subnet = cidr;
+    var addr;
+    var prefix;
+
+    if (typeof (subnet) === 'string') {
+        subnet = ipaddr.parseCIDR(subnet);
+    }
+
+    prefix = subnet[1];
+    addr = subnet[0];
+
+    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress() && prefix >= 96) {
+        // XXX  ASSERT(prefix > 32) ???
+        prefix -= 96;
+    }
+
+    return prefix;
+}
+
+function cidrContainsIP(cidr, ip) {
+    var addr = ip;
+    var subnet = ipaddr.parseCIDR(cidr);
+
+    if (typeof (ip) === 'string') {
+        addr = stringToIp(ip);
+    }
+
+    if (subnet[0].kind() === 'ipv6' &&
+        subnet[0].isIPv4MappedAddress() &&
+        subnet[1] < 33) {
+
+        subnet[1] += 96;
+    }
+
+    return addr.match(subnet);
+}
+
 /**
  * Convert an array of bytes to an integer
  */
@@ -221,6 +291,10 @@ function validateMac(mac) {
     });
 }
 
+function validateSubnet(subnet) {
+    ipaddr.parseCIDR(subnet);
+}
+
 /**
  * Validate options passed to backend functions
  */
@@ -229,6 +303,10 @@ function validateOpts(opts) {
         validateMac(opts.mac);
     }
 
+    if (opts.hasOwnProperty('r_send_mac')) {
+        validateMac(opts.r_send_mac);
+    }
+
     if (opts.hasOwnProperty('cn_uuid')) {
         validateCNID(opts.cn_uuid);
     }
@@ -236,6 +314,22 @@ function validateOpts(opts) {
     if (opts.hasOwnProperty('ip')) {
         validateIP(opts.ip);
     }
+
+    if (opts.hasOwnProperty('srcip')) {
+        validateIP(opts.srcip);
+    }
+
+    if (opts.hasOwnProperty('dstip')) {
+        validateIP(opts.dstip);
+    }
+
+    if (opts.hasOwnProperty('subnet')) {
+        validateSubnet(opts.subnet);
+    }
+
+    if (opts.hasOwnProperty('r_subnet')) {
+        validateSubnet(opts.r_subnet);
+    }
 }
 
 /**
@@ -269,6 +363,25 @@ function vl3NotFoundMsg(msg) {
     };
 }
 
+function vnetRouteNotFoundMsg(msg) {
+    return {
+        svp_type: types.svp_op.SVP_R_ROUTE_ACK,
+        svp_id: msg.svp_id,
+        svp_msg: {
+            sra_status: types.svp_status.SVP_S_NOTFOUND,
+            sra_dcid: 0,
+            sra_vnetid: 0,
+            sra_vlanid: 0,
+            sra_dst_prefixlen: 0,
+            sra_src_prefixlen: 0,
+            sra_vl2_srcmac: 0,
+            sra_port: 0,
+            sra_ul3ip: ipaddr.parse('::0'),
+            sra_vl2_dstmac: 0
+        }
+    };
+}
+
 var unspecAddr = ipaddr.parse('::');
 
 function fatalResponse(type) {
@@ -307,6 +420,18 @@ function fatalResponse(type) {
             },
             svp_type: types.svp_op.SVP_R_LOG_RM_ACK
         };
+    case types.svp_op.SVP_R_ROUTE_REQ:
+        return {
+            svp_msg: {
+                ra_status: types.svp_status.SVP_S_FATAL,
+                sra_vnetid: 0,
+                sra_vlanid: 0,
+                sra_prefixlen: 0,
+                sra_dcid: 0,
+                sra_vl2_src_mac: 0
+            },
+            svp_type: types.svp_op.SVP_R_ROUTE_ACK
+        };
     default:
         throw new Error('Unrecognized request message type');
     }
@@ -317,7 +442,11 @@ module.exports = {
     childLogger: createChildLogger,
     fatalResponse: fatalResponse,
     IPv6obj: createv6obj,
+    IPv6SubObj: createv6subobj,
     ipToString: ipToString,
+    cidrToString: cidrToString,
+    cidrPrefixLen: cidrPrefixLen,
+    cidrContainsIP: cidrContainsIP,
     ipv4StrTov6: ipv4StrTov6,
     stringToIp: stringToIp,
     macArrToInt: macArrToInt,
@@ -334,7 +463,8 @@ module.exports = {
         opts: validateOpts
     },
     vl2NotFoundMsg: vl2NotFoundMsg,
-    vl3NotFoundMsg: vl3NotFoundMsg
+    vl3NotFoundMsg: vl3NotFoundMsg,
+    vnetRouteNotFoundMsg: vnetRouteNotFoundMsg
 };
 
 function test() {
diff --git a/lib/framer.js b/lib/framer.js
index db04a5c..228eee6 100644
--- a/lib/framer.js
+++ b/lib/framer.js
@@ -96,6 +96,13 @@ SVPFramer.prototype._transform =
         log.debug({ msg_svp_req_hdr: msg.svp_req.hdr, msgCount: msgCount++ },
             'message header');
 
+        if (msg.svp_req.hdr.svp_ver !== mod_types.version) {
+            var set_ver = Math.min(msg.svp_req.hdr.svp_ver, mod_types.version);
+            log.warn({msg: msg, effective_version: set_ver},
+                'SVP version mismatch');
+            msg.svp_req.hdr.svp_ver = set_ver;
+        }
+
         // There is a distinction between what the message indicates as its
         // size, and the expected size of the message derived from ctypes.
         // We check the former here & the latter in the parser.
diff --git a/lib/moray.js b/lib/moray.js
index 7407171..57b9c57 100644
--- a/lib/moray.js
+++ b/lib/moray.js
@@ -33,7 +33,7 @@ function createMorayClient(config, callback) {
     var cfg = clone(config.moray);
     cfg.log = config.log.child({
         component: 'moray',
-        level: config.moray.logLevel || 'info'
+        level: config.logLevel || 'info'
     });
 
     var client = mod_moray.createClient(cfg);
diff --git a/lib/parser.js b/lib/parser.js
index 65f5f4d..df31fce 100644
--- a/lib/parser.js
+++ b/lib/parser.js
@@ -109,6 +109,7 @@ SVPparser.prototype._transform =
 
     var rec = {
         logOpts: logOpts,
+        svp_ver: msg.svp_req.hdr.svp_ver,
         svp_type: msg.svp_req.hdr.svp_op,
         svp_id: msg.svp_req.hdr.svp_id,
         svp_msg: { }
@@ -139,10 +140,8 @@ SVPparser.prototype._transform =
         break;
 
     case mod_types.svp_op.SVP_R_VL3_REQ:
-        // XXX: return error if sl3r_type is not 1 or 2
-        var ip = ipFromArr(payload.body.sl3r_ip);
         rec.svp_msg = {
-            vl3_ip: ip,
+            vl3_ip: ipFromArr(payload.body.sl3r_ip),
             vl3_vnet_id: payload.body.sl3r_vnetid
         };
         break;
@@ -206,8 +205,17 @@ SVPparser.prototype._transform =
                 { log: { type: logTypedef } }
             ], msg.svp_buf, offset).log;
 
-            if (la_record.svl3_ip) {
+            switch (mod_types.svp_log_type_names[logType]) {
+            case 'SVP_LOG_VL3':
                 la_record.svl3_ip = ipFromArr(la_record.svl3_ip);
+                break;
+            case 'SVP_LOG_ROUTE':
+                la_record.svlr_srcip = ipFromArr(la_record.svlr_srcip);
+                la_record.svlr_dstip = ipFromArr(la_record.svlr_dstip);
+                break;
+            default:
+                log.warn({la_record: la_record}, 'invalid record type');
+                break;
             }
 
             la_data.push(la_record);
@@ -253,6 +261,30 @@ SVPparser.prototype._transform =
         };
         break;
 
+    case mod_types.svp_op.SVP_R_ROUTE_REQ:
+        rec.svp_msg = {
+            vnet_id: payload.body.srr_vnetid,
+            vlan_id: payload.body.srr_vlanid,
+            ip: ipFromArr(payload.body.srr_srcip),
+            r_ip: ipFromArr(payload.body.srr_dstip)
+        };
+        break;
+
+    case mod_types.svp_op.SVP_R_ROUTE_ACK:
+        rec.svp_msg = {
+            r_status: payload.body.sra_status,
+            r_dc_id: payload.body.sra_dcid,
+            r_vnet_id: payload.body.sra_vnetid,
+            r_vlan_id: payload.body.sra_vlanid,
+            prefixlen: payload.body.sra_src_prefixlen,
+            r_prefixlen: payload.body.sra_dst_prefixlen,
+            r_port: payload.body.sra_port,
+            r_ul3_ip: ipFromArr(payload.body.sra_ul3ip),
+            vl2_src_mac: mod_common.macArrToInt(payload.body.sra_vl2_srcmac),
+            vl2_dst_mac: mod_common.macArrToInt(payload.body.sra_vl2_dstmac)
+        };
+        break;
+
     default:
         log.warn({ hdr: msg.svp_req.hdr, body: payload.body },
             'unknown message svp_op');
diff --git a/lib/serialize.js b/lib/serialize.js
index c990e40..a65a858 100644
--- a/lib/serialize.js
+++ b/lib/serialize.js
@@ -131,6 +131,9 @@ SVPserializer.prototype._transform =
                 common.uuidToArr(datum.id)
             ];
 
+            /*
+             * The record's key names come from portolan-moray's event handling.
+             */
             switch (svpLogType) {
             case types.svp_log_type.SVP_LOG_VL2:
                 record.push(common.intToMacArrayOfNums(datum.record.mac));
@@ -145,6 +148,19 @@ SVPserializer.prototype._transform =
                 record.push(datum.record.vnet_id);
                 break;
 
+            case types.svp_log_type.SVP_LOG_ROUTE:
+                record.push(datum.record.src_vnet_id);
+                record.push(datum.record.dst_vnet_id);
+                record.push(datum.record.dcid);
+                record.push(datum.record.srcip.toByteArray());
+                record.push(datum.record.dstip.toByteArray());
+                record.push(datum.record.src_vlan_id);
+                record.push(datum.record.dst_vlan_id);
+                record.push(datum.record.src_prefixlen);
+                record.push(datum.record.dst_prefixlen);
+                record.push([0, 0]); // padding
+                break;
+
             default:
                 // XXX - unrecoverable. Needs to err.
                 log.warn({ log_record: datum },
@@ -196,6 +212,31 @@ SVPserializer.prototype._transform =
         ];
         break;
 
+    case types.svp_op.SVP_R_ROUTE_ACK:
+        fixedPart = [
+            msg.svp_msg.sra_status,
+            msg.svp_msg.sra_dcid,
+            msg.svp_msg.sra_vnetid,
+            msg.svp_msg.sra_vlanid,
+            msg.svp_msg.sra_port,
+            msg.svp_msg.sra_ul3ip.toByteArray(),
+            common.intToMacArrayOfNums(msg.svp_msg.sra_vl2_srcmac),
+            common.intToMacArrayOfNums(msg.svp_msg.sra_vl2_dstmac),
+            msg.svp_msg.sra_src_prefixlen,
+            msg.svp_msg.sra_dst_prefixlen
+        ];
+        break;
+
+    case types.svp_op.SVP_R_ROUTE_REQ:
+        fixedPart = [
+            msg.svp_msg.srr_vnetid,
+            msg.svp_msg.srr_vlanid,
+            [ 0, 0 ], // padding
+            msg.svp_msg.srr_srcip.toByteArray(),
+            msg.svp_msg.srr_dstip.toByteArray()
+        ];
+        break;
+
     default:
         log.warn({ message: msg }, 'unknown message svp_type');
         return callback();
diff --git a/lib/types.js b/lib/types.js
index 4733df1..4c28333 100644
--- a/lib/types.js
+++ b/lib/types.js
@@ -20,8 +20,15 @@ var path = require('path');
 
 
 
+/*
+ * Bump version number whenever adding a new op_type or log_type.  Also, see
+ * minver below.
+ */
+var SVP_VER_ONE = 1;
+var SVP_VER_TWO = 2;
+var SVP_VER = SVP_VER_TWO;
+
 var VXLAN_PORT = 4789;
-var SVP_VER = 1;
 
 var op_types = {
     3: 'svp_vl2_req_t',
@@ -31,7 +38,10 @@ var op_types = {
     9: 'svp_log_req_t',
     10: 'svp_log_ack_t',
     11: 'svp_lrm_req_t',
-    12: 'svp_lrm_ack_t'
+    12: 'svp_lrm_ack_t',
+    13: 'svp_shootdown_t',
+    14: 'svp_route_req_t',
+    15: 'svp_route_ack_t'
 };
 
 var sizeof = {
@@ -47,8 +57,37 @@ var sizeof = {
     SVP_R_LOG_ACK: 4,
     SVP_LOG_VL2: 32,
     SVP_LOG_VL3: 44,
+    SVP_LOG_ROUTE: 72,
     SVP_R_LOG_RM: 4,
-    SVP_R_LOG_RM_ACK: 4
+    SVP_R_LOG_RM_ACK: 4,
+    SVP_R_SHOOTDOWN: 12,
+    SVP_R_ROUTE_REQ: 40,
+    SVP_R_ROUTE_ACK: 46
+};
+
+/*
+ * Minimum version compatibility.  If you're adding a new op_type or log type
+ * it should be added here as well with the version number.
+ */
+var minver = {
+    SVP_R_PING: SVP_VER_ONE,
+    SVP_R_PONG: SVP_VER_ONE,
+    SVP_REQ: SVP_VER_ONE,
+    SVP_VL2_REQ: SVP_VER_ONE,
+    SVP_VL2_ACK: SVP_VER_ONE,
+    SVP_R_VL2_REQ: SVP_VER_ONE,
+    SVP_R_VL3_REQ: SVP_VER_ONE,
+    SVP_R_VL3_ACK: SVP_VER_ONE,
+    SVP_R_LOG_REQ: SVP_VER_ONE,
+    SVP_R_LOG_ACK: SVP_VER_ONE,
+    SVP_LOG_VL2: SVP_VER_ONE,
+    SVP_LOG_VL3: SVP_VER_ONE,
+    SVP_LOG_ROUTE: SVP_VER_TWO,
+    SVP_R_LOG_RM: SVP_VER_ONE,
+    SVP_R_LOG_RM_ACK: SVP_VER_ONE,
+    SVP_R_SHOOTDOWN: SVP_VER_ONE,
+    SVP_R_ROUTE_REQ: SVP_VER_TWO,
+    SVP_R_ROUTE_ACK: SVP_VER_TWO
 };
 
 var sizeof_ops = {
@@ -61,7 +100,10 @@ var sizeof_ops = {
     9: sizeof.SVP_R_LOG_REQ,
     10: sizeof.SVP_R_LOG_ACK,
     11: sizeof.SVP_R_LOG_RM,
-    12: sizeof.SVP_R_LOG_RM_ACK
+    12: sizeof.SVP_R_LOG_RM_ACK,
+    13: sizeof.SVP_R_SHOOTDOWN,
+    14: sizeof.SVP_R_ROUTE_REQ,
+    15: sizeof.SVP_R_ROUTE_ACK
 };
 
 var svp_op = {
@@ -88,7 +130,9 @@ var svp_op_hex = {
     SVP_R_LOG_ACK: '0x0A',
     SVP_R_LOG_RM: '0x0B',
     SVP_R_LOG_RM_ACK: '0x0C',
-    SVP_R_SHOOTDOWN: '0x0D'
+    SVP_R_SHOOTDOWN: '0x0D',
+    SVP_R_ROUTE_REQ: '0x0E',
+    SVP_R_ROUTE_ACK: '0x0F'
 };
 
 var svp_status = {
@@ -111,22 +155,26 @@ var svp_vl3_type = {
 
 var svp_log_type = {
     SVP_LOG_VL2: 1,
-    SVP_LOG_VL3: 2
+    SVP_LOG_VL3: 2,
+    SVP_LOG_ROUTE: 3
 };
 
 var svp_log_typedef = {
     SVP_LOG_VL2: 'svp_log_vl2_t',
-    SVP_LOG_VL3: 'svp_log_vl3_t'
+    SVP_LOG_VL3: 'svp_log_vl3_t',
+    SVP_LOG_ROUTE: 'svp_log_route_t'
 };
 
 var svp_log_type_names = {
     1: 'SVP_LOG_VL2',
-    2: 'SVP_LOG_VL3'
+    2: 'SVP_LOG_VL3',
+    3: 'SVP_LOG_ROUTE'
 };
 
 var sizeof_logs = {
     1: sizeof.SVP_LOG_VL2,
-    2: sizeof.SVP_LOG_VL3
+    2: sizeof.SVP_LOG_VL3,
+    3: sizeof.SVP_LOG_ROUTE
 };
 
 var types = JSON.parse(fs.readFileSync(
@@ -161,6 +209,7 @@ function statusString(op) {
 
 
 module.exports = {
+    minver: minver,
     opInfo: opInfo,
     parser: parser,
     sizeof: sizeof,
diff --git a/package.json b/package.json
index 219721f..96fc2ac 100644
--- a/package.json
+++ b/package.json
@@ -11,13 +11,13 @@
         "cmdln": "3.0.1",
         "ctype": "0.5.3",
         "dtrace-provider": "0.3.1",
-        "ipaddr.js": "0.1.6",
+        "ipaddr.js": "1.6.0",
         "lomstream": "^1.1.0",
         "lru-cache": "2.5.0",
         "mkdirp": "0.5.0",
         "moray": "3.4.2",
         "node-uuid": "1.4.2",
-        "portolan-moray": "git+https://github.com/joyent/sdc-portolan-moray.git#7e2c4ca",
+        "portolan-moray": "git+https://github.com/joyent/sdc-portolan-moray.git#vpc",
         "tape": "3.0.3",
         "vasync": "1.6.2",
         "verror": "1.6.0",
diff --git a/src/libvarpd_svp_prot.h b/src/libvarpd_svp_prot.h
index 51ccdb6..beeacb0 100644
--- a/src/libvarpd_svp_prot.h
+++ b/src/libvarpd_svp_prot.h
@@ -90,7 +90,6 @@ typedef struct svp_vl2_ack {
 	uint8_t		sl2a_addr[16];
 } svp_vl2_ack_t;
 
-
 /*
  * A client issues the SVP_R_VL3_REQ request whenever it needs to perform a
  * VL3->VL2 lookup.  Note, that this also implicitly performs a VL2->UL3 lookup
@@ -119,6 +118,32 @@ typedef struct svp_vl3_ack {
 	uint8_t		sl3a_uip[16];
 } svp_vl3_ack_t;
 
+/*
+ * The client issues an SVP_R_ROUTE_REQ whenever it needs to learn which other
+ * fabrics it is attached to.
+ */
+typedef struct svp_route_req {
+    uint32_t    srr_vnetid;
+    uint16_t    srr_vlanid;
+    uint8_t     srr_pad [2];
+    uint8_t     srr_srcip [16];
+    uint8_t     srr_dstip [16];
+} svp_route_req_t;
+
+typedef struct svp_route_ack {
+    uint32_t    sra_status;
+    uint32_t    sra_dcid;
+    uint32_t    sra_vnetid;
+    uint16_t    sra_vlanid;
+    uint16_t    sra_port;
+    uint8_t     sra_ul3ip [16];
+    uint8_t     sra_vl2_srcmac [6];
+    uint8_t     sra_vl2_dstmac [6];
+    uint8_t     sra_src_prefixlen;
+    uint8_t     sra_dst_prefixlen;
+} svp_route_ack_t;
+
+
 /*
  * SVP_R_BULK_REQ requests a bulk dump of data. Currently we have two kinds of
  * data tables that we need to dump: VL3->VL2 mappings and VL2->UL3 mappings.
@@ -154,21 +179,22 @@ typedef struct svp_bulk_ack {
  */
 typedef struct svp_log_req {
 	uint32_t	svlr_count;
-	uint8_t	svlr_ip[16];
+	uint8_t     svlr_ip[16];
 } svp_log_req_t;
 
 /*
  * The server replies to a log request by sending a series of log entries.
- * These log entries may be a mixture of both vl2 and vl3 records. The reply is
- * a stream of bytes after the status message whose length is determined baseed
- * on the header itself. Each entry begins with a uint32_t that describes its
- * type and then is followed by the remaining data payload. The next entry
- * follows immediately which again begins with the uint32_t word that describes
- * what it should be.
+ * These log entries may be a mixture of vl2, vl3, and route records. The reply
+ * is a stream of bytes after the status message whose length is determined
+ * based on the header itself. Each entry begins with a uint32_t that
+ * describes its type and then is followed by the remaining data payload. The
+ * next entry follows immediately which again begins with the uint32_t word
+ * that describes what it should be.
  */
 typedef enum svp_log_type {
-	SVP_LOG_VL2	= 0x01,
-	SVP_LOG_VL3	= 0x02
+	SVP_LOG_VL2     = 0x01,
+	SVP_LOG_VL3     = 0x02,
+	SVP_LOG_ROUTE   = 0x03
 } svp_log_type_t;
 
 typedef struct svp_log_vl2 {
@@ -188,6 +214,21 @@ typedef struct svp_log_vl3 {
 	uint32_t	svl3_vnetid;
 } svp_log_vl3_t;
 
+typedef struct svp_log_route {
+    uint32_t    svlr_type;
+    uint8_t     svlr_id[16];
+    uint32_t    svlr_src_vnetid;
+    uint32_t    svlr_dst_vnetid;
+    uint32_t    svlr_dcid;
+    uint8_t     svlr_srcip[16];
+    uint8_t     svlr_dstip[16];
+    uint16_t    svlr_src_vlanid;
+    uint16_t    svlr_dst_vlanid;
+    uint8_t     svlr_src_prefixlen;
+    uint8_t     svlr_dst_prefixlen;
+    uint8_t     svlr_pad[2];
+} svp_log_route_t;
+
 typedef struct svp_log_ack {
 	uint32_t	svla_status;
 	uint8_t		svla_data[];
diff --git a/test/integration/backend.test.js b/test/integration/backend.test.js
index 7ea3c81..9780eac 100644
--- a/test/integration/backend.test.js
+++ b/test/integration/backend.test.js
@@ -29,6 +29,11 @@ var CNS = [
         cn_uuid: 'b4e5ff64-7b40-11e4-a6fa-d34c824a42cd',
         ip: '192.168.1.1',
         port: 123
+    },
+    {
+        cn_uuid: '356cee1f-c4d2-46a8-98e9-2361875a6aa4',
+        ip: '192.168.1.2',
+        port: 123
     }
 ];
 
@@ -51,6 +56,89 @@ var VMS = [
     }
 ];
 
+var ROUTES = [
+    {
+        vnet_id: 11111,
+        vlan_id: 1,
+        subnet: '192.168.111.0/24',
+        r_dc_id: 22,
+        r_vnet_id: 22222,
+        r_vlan_id: 2,
+        r_subnet: '192.168.222.0/24',
+        r_send_mac: '00:0a:95:ff:ff:ff'
+    },
+    {
+        vnet_id: 101010,
+        vlan_id: 10,
+        subnet: '192.168.100.0/24',
+        r_dc_id: 220,
+        r_vnet_id: 202020,
+        r_vlan_id: 20,
+        r_subnet: '192.168.200.0/24',
+        r_send_mac: '00:0a:59:ff:ff:ff'
+    },
+    {
+        vnet_id: 101010,
+        vlan_id: 10,
+        subnet: '192.168.100.0/24',
+        r_dc_id: 0,
+        r_vnet_id: 12340, // same as VMS[0]
+        r_vlan_id: 20,
+        r_subnet: '10.0.0.0/24', // same as VMS[0]
+        r_send_mac: '00:0a:59:ff:ff:ff'
+    }
+
+];
+
+
+var ROUTE_IPS = [
+    {
+        src: '192.168.111.1',
+        dst: '192.168.222.1'
+    },
+    {
+        src: '192.168.100.1',
+        dst: '192.168.200.1'
+    },
+    {
+        src: '192.168.100.1',
+        dst: VMS[0].ip // same as VMS[0]
+    }
+];
+
+var VL2EVENTS = [
+    {
+        vnetCns: CNS.map(function (c) { return c.cn_uuid; }),
+        vnet_id: 99999,
+        mac: '00:0a:99:ff:ff:ff'
+    }
+];
+
+var VL3EVENTS = [
+    {
+        vnetCns: CNS.map(function (c) { return c.cn_uuid; }),
+        vnet_id: 88888,
+        mac: '00:0a:88:ff:ff:ff',
+        vlan_id: 8,
+        ip: '88.88.88.88'
+    }
+];
+
+var ROUTE_EVENTS = [
+    {
+        vnetCns: CNS.map(function (c) { return c.cn_uuid; }),
+        src_vnet_id: 11111,
+        dst_vnet_id: 22222,
+        dcid: 2,
+        srcip: '11.11.11.11',
+        dstip: '22.22.22.22',
+        src_vlan_id: 1,
+        dst_vlan_id: 2,
+        src_prefixlen: 24,
+        dst_prefixlen: 24
+    }
+];
+
 var STATUS = mod_types.svp_status;
 
 
@@ -62,12 +150,18 @@ var STATUS = mod_types.svp_status;
 test('setup', function (t) {
     t.test('start server', mod_server.start);
 
-    t.test('add underlay mapping', function (t2) {
+    t.test('add underlay mapping 0', function (t2) {
         mod_mapping.addUnderlay(t2, {
             params: CNS[0]
         });
     });
 
+    t.test('add underlay mapping 1', function (t2) {
+        mod_mapping.addUnderlay(t2, {
+            params: CNS[1]
+        });
+    });
+
     t.test('add overlay mapping: VM 0', function (t2) {
         mod_mapping.addOverlay(t2, {
             params: VMS[0]
@@ -80,6 +174,45 @@ test('setup', function (t) {
             params: VMS[1]
         });
     });
+
+    t.test('add vnet route mapping 0', function (t2) {
+        mod_mapping.addVnetRoute(t2, {
+            params: ROUTES[0]
+        });
+    });
+
+    t.test('add vnet route mapping 1', function (t2) {
+        mod_mapping.addVnetRoute(t2, {
+            params: ROUTES[1]
+        });
+    });
+
+    t.test('add vnet route mapping 2', function (t2) {
+        mod_mapping.addVnetRoute(t2, {
+            params: ROUTES[2]
+        });
+    });
+
+    t.test('add vl2 event mapping 0', function (t2) {
+        mod_mapping.addEventMapping(t2, {
+            type: 'SVP_LOG_VL2',
+            params: VL2EVENTS[0]
+        });
+    });
+
+    t.test('add vl3 event mapping 0', function (t2) {
+        mod_mapping.addEventMapping(t2, {
+            type: 'SVP_LOG_VL3',
+            params: VL3EVENTS[0]
+        });
+    });
+
+    t.test('add route event mapping 0', function (t2) {
+        mod_mapping.addEventMapping(t2, {
+            type: 'SVP_LOG_ROUTE',
+            params: ROUTE_EVENTS[0]
+        });
+    });
 });
 
 
@@ -193,14 +326,128 @@ test('vl3', function (t) {
 
 });
 
+test('vnetRoute', function (t) {
+    t.test('vnet and vl3 mapping exists', function (t2) {
+        mod_req.vnetRoute(t2, {
+            params: {
+                vnet_id: ROUTES[2].vnet_id,
+                vlan_id: ROUTES[2].vlan_id,
+                srcip: ROUTE_IPS[2].src,
+                dstip: ROUTE_IPS[2].dst
+            },
+            exp: {
+                status: STATUS.SVP_S_OK,
+                status_str: mod_types.statusString(STATUS.SVP_S_OK),
+                r_dc_id: ROUTES[2].r_dc_id,
+                r_vnet_id: ROUTES[2].r_vnet_id,
+                r_vlan_id: ROUTES[2].r_vlan_id,
+                prefixlen: parseInt(ROUTES[2].subnet.split('/')[1], 10),
+                r_prefixlen: parseInt(ROUTES[2].r_subnet.split('/')[1], 10),
+                r_port: CNS[0].port,
+                r_ul3_ip: mod_common.ipv4StrTov6(CNS[0].ip),
+                vl2_src_mac: ROUTES[2].r_send_mac,
+                vl2_dst_mac: VMS[0].mac
+            }
+        });
+    });
 
-// XXX: log lookup tests:
-// - try to delete a record that doesn't exist
-// - double-delete a record
+    t.test('wrong vnet and vlan', function (t2) {
+        mod_req.vnetRoute(t2, {
+            params: {
+                vnet_id: 1111111111,
+                vlan_id: 9999,
+                srcip: ROUTE_IPS[2].src,
+                dstip: ROUTE_IPS[2].dst
+            },
+            exp: mod_req.vnetRouteNotFound()
+        });
+    });
 
+    t.test('wrong source ip/subnet', function (t2) {
+        mod_req.vnetRoute(t2, {
+            params: {
+                vnet_id: ROUTES[2].vnet_id,
+                vlan_id: ROUTES[2].vlan_id,
+                srcip: '10.10.10.10',
+                dstip: ROUTE_IPS[2].dst
+            },
+            exp: mod_req.vnetRouteNotFound()
+        });
+    });
 
+    t.test('correct source ip/subnet, w/o matching vl3 mapping', function (t2) {
+        mod_req.vnetRoute(t2, {
+            params: {
+                vnet_id: ROUTES[0].vnet_id,
+                vlan_id: ROUTES[0].vlan_id,
+                srcip: ROUTE_IPS[0].src,
+                dstip: ROUTE_IPS[0].dst
+            },
+            exp: mod_req.vnetRouteNotFound()
+        });
+    });
+});
 
-// XXX: remove mappings
+test('svp_log', function (t) {
 
+    t.test('svp_log_req', function (t2) {
+        mod_req.vlogs(t2, {
+            params: {
+                ip: CNS[1].ip,
+                count: mod_types.sizeof.SVP_LOG_ROUTE +
+                    mod_types.sizeof.SVP_LOG_VL3 +
+                    mod_types.sizeof.SVP_LOG_VL2
+            },
+            exp: {
+                la_data:
+                    [ {
+                        mac: VL2EVENTS[0].mac,
+                        type: 'SVP_LOG_VL2',
+                        vnet_id: VL2EVENTS[0].vnet_id
+                    }, {
+                        ip: mod_common.ipv4StrTov6(VL3EVENTS[0].ip),
+                        type: 'SVP_LOG_VL3',
+                        vlan: VL3EVENTS[0].vlan_id,
+                        vnet_id: VL3EVENTS[0].vnet_id
+                    }, {
+                        dcid: ROUTE_EVENTS[0].dcid,
+                        dst_vlan: ROUTE_EVENTS[0].dst_vlan_id,
+                        dst_vnet_id: ROUTE_EVENTS[0].dst_vnet_id,
+                        srcip: mod_common.ipv4StrTov6(ROUTE_EVENTS[0].srcip),
+                        dstip: mod_common.ipv4StrTov6(ROUTE_EVENTS[0].dstip),
+                        src_prefixlen: ROUTE_EVENTS[0].src_prefixlen,
+                        dst_prefixlen: ROUTE_EVENTS[0].dst_prefixlen,
+                        src_vlan: ROUTE_EVENTS[0].src_vlan_id,
+                        src_vnet_id: ROUTE_EVENTS[0].src_vnet_id,
+                        type: 'SVP_LOG_ROUTE'
+                    } ],
+                status: 0,
+                status_str: 'SVP_S_OK'
+            }
+        });
+    });
 
-test('teardown', mod_server.stop);
+    t.test('svp_log_VL2_req low count', function (t2) {
+        mod_req.vlogs(t2, {
+            params: {
+                ip: CNS[1].ip,
+                count: 3
+            },
+            exp: { la_data: [], status: 0, status_str: 'SVP_S_OK' }
+        });
+    });
+});
+
+// TODO:
+// log lookup tests:
+// - try to delete a record that doesn't exist
+// - double-delete a record
+// remove mappings
+// version mismatch
+// malformed request handling
+
+test('teardown', function (t) {
+    t.test('stop server', function (t2) {
+        mod_server.stop(t2);
+    });
+});
diff --git a/test/lib/mapping.js b/test/lib/mapping.js
index 62b37ed..41b87f5 100644
--- a/test/lib/mapping.js
+++ b/test/lib/mapping.js
@@ -13,6 +13,8 @@
 var assert = require('assert-plus');
 var mod_common = require('../../lib/common.js');
 var mod_moray = require('../../lib/backend/moray');
+var types = require('../../lib/types.js');
+var clone = require('clone');
 
 
 
@@ -66,8 +68,101 @@ function addUnderlayMapping(t, opts) {
 }
 
 
+function addEventMapping(t, opts) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.string(opts.type, 'opts.type');
+    assert.object(opts.params, 'opts.params');
+    assert.arrayOfString(opts.params.vnetCns, 'opts.params.vnetCns');
+
+    var func;
+    var val = clone(opts.params);
+    var logType = types.svp_log_type[opts.type];
+
+    switch (logType) {
+    case types.svp_log_type.SVP_LOG_VL2:
+        assert.string(opts.params.mac, 'opts.params.mac');
+        assert.number(opts.params.vnet_id, 'opts.params.vnet_id');
+
+        val.mac = mod_common.macToInt(opts.params.mac);
+        func = 'addVl2CnEventBatch';
+
+        break;
+    case types.svp_log_type.SVP_LOG_VL3:
+        assert.string(opts.params.ip, 'opts.params.ip');
+        assert.number(opts.params.vlan_id, 'opts.params.vlan');
+        assert.string(opts.params.mac, 'opts.params.mac');
+        assert.number(opts.params.vnet_id, 'opts.params.vnet_id');
+
+        val.mac = mod_common.macToInt(opts.params.mac);
+        val.ip = mod_common.IPv6obj(opts.params.ip);
+        func = 'addVl3CnEventBatch';
+
+        break;
+    case types.svp_log_type.SVP_LOG_ROUTE:
+        assert.number(opts.params.src_vnet_id, 'opts.params.src_vnet_id');
+        assert.number(opts.params.dst_vnet_id, 'opts.params.dst_vnet_id');
+        assert.number(opts.params.dcid, 'opts.params.dcid');
+        assert.string(opts.params.srcip, 'opts.params.srcip');
+        assert.string(opts.params.dstip, 'opts.params.dstip');
+        assert.number(opts.params.src_vlan_id, 'opts.params.src_vlan_id');
+        assert.number(opts.params.dst_vlan_id, 'opts.params.src_vlan_id');
+        assert.number(opts.params.src_prefixlen, 'opts.params.src_prefixlen');
+        assert.number(opts.params.dst_prefixlen, 'opts.params.dst_prefixlen');
+
+        val.srcip = mod_common.IPv6obj(opts.params.srcip);
+        val.dstip = mod_common.IPv6obj(opts.params.dstip);
+        func = 'addVnetRouteCnEventBatch';
+
+        break;
+    default:
+        t.notok('unknown svp_log_type', opts.type);
+        t.end();
+        return;
+    }
+
+    mod_moray[func](val, function _afterEventBatch(err) {
+        t.ifErr(err, 'add Event Mapping');
+        t.end();
+        return;
+    });
+}
+
+function addVnetRouteMapping(t, opts) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.object(opts.params, 'opts.params');
+    assert.number(opts.params.vnet_id, 'opts.params.vnet_id');
+    assert.number(opts.params.vlan_id, 'opts.params.vlan_id');
+    assert.string(opts.params.subnet, 'opts.params.subnet');
+    assert.number(opts.params.r_dc_id, 'opts.params.r_dc_id');
+    assert.number(opts.params.r_vnet_id, 'opts.params.r_vnet_id');
+    assert.number(opts.params.r_vlan_id, 'opts.params.r_vlan_id');
+    assert.string(opts.params.r_subnet, 'opts.params.r_subnet');
+    assert.string(opts.params.r_send_mac, 'opts.params.r_send_mac');
+
+    var val = {
+        vnet_id: opts.params.vnet_id,
+        vlan_id: opts.params.vlan_id,
+        subnet: mod_common.IPv6SubObj(opts.params.subnet),
+        r_dc_id: opts.params.r_dc_id,
+        r_vnet_id: opts.params.r_vnet_id,
+        r_vlan_id: opts.params.r_vlan_id,
+        r_subnet: mod_common.IPv6SubObj(opts.params.r_subnet),
+        r_send_mac: mod_common.macToInt(opts.params.r_send_mac)
+    };
+
+    mod_moray.addVnetRouteMapping(val, function _afterVnetRoute(err) {
+        t.ifErr(err, 'add vnet route mapping');
+        t.end();
+        return;
+    });
+}
+
 
 module.exports = {
     addOverlay: addOverlayMapping,
-    addUnderlay: addUnderlayMapping
+    addUnderlay: addUnderlayMapping,
+    addVnetRoute: addVnetRouteMapping,
+    addEventMapping: addEventMapping
 };
diff --git a/test/lib/request.js b/test/lib/request.js
index c69ad92..35d5639 100644
--- a/test/lib/request.js
+++ b/test/lib/request.js
@@ -97,6 +97,81 @@ function reqVL3(t, opts) {
     });
 }
 
+/**
+ * Make a vnetroute request
+ */
+function reqVnetRoute(t, opts) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.object(opts.exp, 'opts.exp');
+    assert.object(opts.params, 'opts.params');
+    assert.number(opts.params.vnet_id, 'opts.params.vnet_id');
+    assert.number(opts.params.vlan_id, 'opts.params.vlan_id');
+    assert.string(opts.params.srcip, 'opts.params.srcip');
+    assert.string(opts.params.dstip, 'opts.params.dstip');
+
+    mod_client.get(function (_, client) {
+        var params = {
+            vnet_id: opts.params.vnet_id,
+            vlan_id: opts.params.vlan_id,
+            srcip: mod_common.IPv6obj(opts.params.srcip),
+            dstip: mod_common.IPv6obj(opts.params.dstip)
+        };
+
+        client.vnetRouteReq(params, function _aftervnetRoute(err, res) {
+            t.ifErr(err, 'vnetRoute error');
+            if (err) {
+                return t.end();
+            }
+
+            // XXX: should we return an error code instead?
+            if (Object.keys(res).length === 0) {
+                res = vnetRouteNotFound();
+            }
+
+            t.deepEqual(res, opts.exp, 'vnetRoute res');
+            return t.end();
+        });
+    });
+}
+
+function reqVlogs(t, opts) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.object(opts.exp, 'opts.exp');
+    assert.object(opts.params, 'opts.params');
+    assert.string(opts.params.ip, 'opts.params.ip');
+    assert.number(opts.params.count, 'opts.params.count');
+
+    mod_client.get(function (_, client) {
+        var params = {
+            ip: mod_common.IPv6obj(opts.params.ip),
+            count: opts.params.count
+        };
+
+        client.logReq(params, function _afterlogReq(err, res) {
+            t.ifErr(err, 'logReq error');
+            if (err) {
+                return t.end();
+            }
+
+            /*
+             * Log record id's are created dynamically.  For now just test that
+             * they exist and are of the right type.  Then delete them and do a
+             * deep equal with the other fields.
+             */
+            for (var i = 0; i < res.la_data.length; i++) {
+                var record = res.la_data[i];
+                t.assert(record.id && typeof (record.id) === 'string',
+                    'record id');
+                delete res.la_data[i].id;
+            }
+
+            t.deepEqual(res, opts.exp, 'logReq res');
+            return t.end();
+        });
+    });
+}
 
 /**
  * Returns a client response for VL2 mapping not found
@@ -124,12 +199,29 @@ function vl3NotFound() {
     };
 }
 
-
+function vnetRouteNotFound() {
+    return {
+        status: STATUS.SVP_S_NOTFOUND,
+        status_str: mod_types.statusString(STATUS.SVP_S_NOTFOUND),
+        prefixlen: 0,
+        r_dc_id: 0,
+        r_port: 0,
+        r_prefixlen: 0,
+        r_ul3_ip: '::',
+        r_vlan_id: 0,
+        r_vnet_id: 0,
+        vl2_dst_mac: '00:00:00:00:00:00',
+        vl2_src_mac: '00:00:00:00:00:00'
+    };
+}
 
 module.exports = {
     ping: reqPing,
     vl2: reqVL2,
     vl2NotFound: vl2NotFound,
     vl3: reqVL3,
-    vl3NotFound: vl3NotFound
+    vl3NotFound: vl3NotFound,
+    vlogs: reqVlogs,
+    vnetRoute: reqVnetRoute,
+    vnetRouteNotFound: vnetRouteNotFound
 };
diff --git a/test/unit/types.test.js b/test/unit/types.test.js
index 315ae21..e9c35cb 100644
--- a/test/unit/types.test.js
+++ b/test/unit/types.test.js
@@ -89,6 +89,24 @@ test('opinfo', function (t) {
             op: svp_op.SVP_R_LOG_RM_ACK,
             sizeof: 4,
             type: 'svp_lrm_ack_t'
+        },
+        {
+            name: 'SVP_R_SHOOTDOWN',
+            op: svp_op.SVP_R_SHOOTDOWN,
+            sizeof: 12,
+            type: 'svp_shootdown_t'
+        },
+        {
+            name: 'SVP_R_ROUTE_REQ',
+            op: svp_op.SVP_R_ROUTE_REQ,
+            sizeof: 40,
+            type: 'svp_route_req_t'
+        },
+        {
+            name: 'SVP_R_ROUTE_ACK',
+            op: svp_op.SVP_R_ROUTE_ACK,
+            sizeof: 46,
+            type: 'svp_route_ack_t'
         }
     ];
 
@@ -99,6 +117,7 @@ test('opinfo', function (t) {
         t.equal(Object.keys(type).length, 4, 'keys');
 
         var opinfo = mod_types.opInfo(type.op);
+
         t.equal(opinfo.name, type.name, type.name + ' name');
         t.equal(opinfo.sizeof, type.sizeof, 'sizeof');
         t.equal(opinfo.sizeofReq, type.sizeof + req_size, 'sizeofReq');
-- 
2.21.0

