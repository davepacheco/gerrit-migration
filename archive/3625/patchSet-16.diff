From 850cd490a72960561e6592e6d506cfefbffe0c4d Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Tue, 13 Mar 2018 21:09:12 +0000
Subject: [PATCH] moray backend and mapping work bumped ipaddr.js version to
 1.6.0 started portolan command changes serializer, some integration tests,
 client, mapping and more test fixups begin setting up remote portolan module
 clean up remote.js, ipaddr functions added svp_route_log

---
 bin/portolan                     | 119 +++++++++++++++++++++++
 etc/svp-types.json               |  49 +++++++++-
 lib/backend/json.js              |   6 +-
 lib/backend/moray.js             | 162 +++++++++++++++++++++++++++++--
 lib/client.js                    |  70 ++++++++++++-
 lib/common.js                    | 109 ++++++++++++++++++++-
 lib/framer.js                    |   2 +
 lib/parser.js                    |  41 +++++++-
 lib/remote.js                    | 158 ++++++++++++++++++++++++++++++
 lib/serialize.js                 |  41 ++++++++
 lib/types.js                     |  32 ++++--
 package.json                     |   4 +-
 test/integration/backend.test.js | 110 +++++++++++++++++++++
 test/lib/mapping.js              |  34 ++++++-
 test/lib/request.js              |  57 ++++++++++-
 test/unit/types.test.js          |  19 ++++
 16 files changed, 982 insertions(+), 31 deletions(-)
 create mode 100644 lib/remote.js

diff --git a/bin/portolan b/bin/portolan
index 4de1039..97f5106 100755
--- a/bin/portolan
+++ b/bin/portolan
@@ -57,6 +57,12 @@ var OPTS = {
         help: 'IP address'
     },
 
+    r_ip: {
+        names: [ 'r_ip' ],
+        type: 'string',
+        help: 'remote IP address'
+    },
+
     mac: {
         names: [ 'mac' ],
         type: 'string',
@@ -86,6 +92,26 @@ var OPTS = {
         type: 'arrayOfString',
         help: 'array of log ids to remove'
     }
+
+    /*
+    r_dc_id: {
+        names: [ 'r_dc_id' ],
+        type: 'positiveInteger',
+        help: 'remote datacenter id'
+    },
+
+    r_vnet_id: {
+        names: [ 'r_vnet_id' ],
+        type: 'positiveInteger',
+        help: 'remote virtual network ID'
+    },
+
+    r_vlan_id: {
+        names: [ 'r_vlan_id' ],
+        type: 'positiveInteger',
+        help: 'remote vlan ID'
+    }
+    */
 };
 
 
@@ -437,5 +463,98 @@ PortolanCLI.prototype['do_log_rm'].options = [
     OPTS.id
 ];
 
+/**
+ * Add an vnet route mapping
+ */
+PortolanCLI.prototype['do_add-vnetroute'] =
+    function _addVnetRoute(_subcmd, opts, _args, callback) {
+
+    var backendOpts;
+    try {
+        backendOpts = translateOpts(opts, {
+            vnet_id: 'vnet_id',
+            vlan_id: 'vlan_id',
+            subnet: 'subnet',
+            r_dc_id: 'r_dc_id',
+            r_vnet_id: 'r_vnet_id',
+            r_vlan_id: 'r_vlan_id',
+            r_subnet: 'r_subnet',
+            r_send_mac: 'r_send_mac'
+        });
+        mod_common.validate.opts(backendOpts);
+    } catch (optsErr) {
+        callback(optsErr);
+        return;
+    }
+
+    backendOpts.subnet = mod_common.IPv6SubObj(backendOpts.subnet);
+    backendOpts.r_subnet = mod_common.IPv6SubObj(backendOpts.r_subnet);
+    backendOpts.r_send_mac = mod_common.macToInt(backendOpts.r_send_mac);
+
+    mod_backend.addVnetRouteMapping(backendOpts, callback);
+};
+
+PortolanCLI.prototype['do_add-vnetroute'].options = [
+    OPTS.vnet_id,
+    OPTS.vlan_id,
+    OPTS.subnet,
+    OPTS.r_dc_id,
+    OPTS.r_vnet_id,
+    OPTS.r_vlan_id,
+    OPTS.r_subnet,
+    OPTS.r_send_mac
+];
+
+/**
+ * Do a L3 lookup
+PortolanCLI.prototype['do_vnetroute-lookup'] =
+    function _vnetRouteReq(_subcmd, opts, _args, callback) {
+
+    // TODO
+    return;
+    var connOpts;
+    try {
+        connOpts = translateOpts(opts, {
+            // TODO
+            ip: 'ip',
+            vnet_id: 'vnet_id'
+        });
+        mod_common.validate.opts(connOpts);
+    } catch (optsErr) {
+        callback(optsErr);
+        return;
+    }
+
+    setClientOpts(opts, connOpts);
+    connOpts.ip = mod_common.IPv6obj(opts.ip);
+
+    var client = mod_client.connect(connOpts, function _afterVl3Conn(err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        client.vl3Req(connOpts, function (err2, res) {
+            if (err2) {
+                callback(err2);
+                return;
+            }
+
+            json(res);
+            callback();
+        });
+    });
+};
+
+PortolanCLI.prototype['do_vnetroute-lookup'].options = [
+    OPTS.host,
+    OPTS.ip,
+    OPTS.port,
+    OPTS.vnet_id
+];
+ */
+
+// TODO: add vnetroute-remove
+
 var cli = new PortolanCLI();
 mod_cmdln.main(cli);
diff --git a/etc/svp-types.json b/etc/svp-types.json
index 7095730..2658ee7 100644
--- a/etc/svp-types.json
+++ b/etc/svp-types.json
@@ -4,7 +4,14 @@
 		"created_at": 1430352621,
 		"derived_from": "src/types",
 		"ctf_version": 2,
-		"requested_types": [ "svp_req_t" , "svp_vl2_req_t" , "svp_vl2_ack_t" , "svp_vl3_req_t" , "svp_vl3_ack_t" , "svp_bulk_req_t" , "svp_bulk_ack_t" , "svp_log_req_t" , "svp_log_vl2_t" , "svp_log_vl3_t" , "svp_log_ack_t" , "svp_lrm_req_t" , "svp_lrm_ack_t" , "svp_shootdown_t" ]
+		"requested_types": [
+            "svp_req_t", "svp_vl2_req_t", "svp_vl2_ack_t",
+            "svp_vl3_req_t", "svp_vl3_ack_t", "svp_bulk_req_t",
+            "svp_bulk_ack_t", "svp_log_req_t", "svp_log_vl2_t",
+            "svp_log_vl3_t", "svp_log_ack_t", "svp_lrm_req_t",
+            "svp_lrm_ack_t", "svp_shootdown_t", "svp_route_req_t",
+            "svp_route_ack_t"
+        ]
 	},
 "data":
 	[
@@ -56,7 +63,7 @@
 		] },
 		{ "name": "svp_vl3_req_t", "typedef": "struct svp_vl3_req" },
 		{ "name": "svp_vl3_ack_t", "typedef": "struct svp_vl3_ack" },
-		{ "name": "struct svp_bulk_req", "struct": [
+        { "name": "struct svp_bulk_req", "struct": [
 			{ "name": "svbr_type", "type": "uint32_t" }
 		] },
 		{ "name": "svp_bulk_req_t", "typedef": "struct svp_bulk_req" },
@@ -95,6 +102,42 @@
 			{ "name": "svl3_vnetid", "type": "uint32_t" }
 		] },
 		{ "name": "svp_log_vl3_t", "typedef": "struct svp_log_vl3" },
-		{ "name": "svp_shootdown_t", "typedef": "struct svp_shootdown" }
+		{ "name": "struct svp_log_route", "struct": [
+			{ "name": "svlr_type", "type": "uint32_t" },
+			{ "name": "svlr_id", "type": "uint8_t [16]" },
+			{ "name": "svlr_src_vnetid", "type": "uint32_t" },
+			{ "name": "svlr_dst_vnetid", "type": "uint32_t" },
+			{ "name": "svlr_dcid", "type": "uint32_t" },
+			{ "name": "svlr_srcip", "type": "uint8_t [16]" },
+			{ "name": "svlr_dstip", "type": "uint8_t [16]" },
+			{ "name": "svlr_dst_vlanid", "type": "uint16_t" },
+			{ "name": "svlr_src_vlanid", "type": "uint16_t" },
+			{ "name": "svlr_src_prefixlen", "type": "uint8_t" },
+			{ "name": "svlr_dst_prefixlen", "type": "uint8_t" },
+			{ "name": "svlr_pad", "type": "uint8_t [2]" }
+		] },
+		{ "name": "svp_log_route_t", "typedef": "struct svp_log_route" },
+		{ "name": "svp_shootdown_t", "typedef": "struct svp_shootdown" },
+		{ "name": "struct svp_route_req", "struct": [
+			{ "name": "srr_vnetid", "type": "uint32_t" },
+			{ "name": "srr_vlanid", "type": "uint16_t" },
+			{ "name": "srr_pad", "type": "uint8_t [2]" },
+			{ "name": "srr_srcip", "type": "uint8_t [16]" },
+			{ "name": "srr_dstip", "type": "uint8_t [16]" }
+		] },
+		{ "name": "struct svp_route_ack", "struct": [
+			{ "name": "sra_status", "type": "uint32_t" },
+			{ "name": "sra_dcid", "type": "uint32_t" },
+			{ "name": "sra_vnetid", "type": "uint32_t" },
+			{ "name": "sra_vlanid", "type": "uint16_t" },
+			{ "name": "sra_port", "type": "uint16_t" },
+			{ "name": "sra_ul3ip", "type": "uint8_t [16]" },
+			{ "name": "sra_vl2_srcmac", "type": "uint8_t [6]" },
+			{ "name": "sra_vl2_dstmac", "type": "uint8_t [6]" },
+			{ "name": "sra_src_prefixlen", "type": "uint8_t" },
+			{ "name": "sra_dst_prefixlen", "type": "uint8_t" }
+		] },
+		{ "name": "svp_route_req_t", "typedef": "struct svp_route_req" },
+		{ "name": "svp_route_ack_t", "typedef": "struct svp_route_ack" }
 	]
 }
diff --git a/lib/backend/json.js b/lib/backend/json.js
index baaf92e..b45eaf9 100644
--- a/lib/backend/json.js
+++ b/lib/backend/json.js
@@ -58,7 +58,6 @@ var UNDERLAY_FILE = {
 };
 
 
-
 // --- Internal
 
 
@@ -177,6 +176,8 @@ JsonStore.prototype._transform = function _dssTransform(msg, _enc, callback) {
         return this.logReq(msg, callback);
     case types.svp_op.SVP_R_LOG_RM:
         return this.logRm(msg, callback);
+    case types.svp_op.SVP_R_ROUTE_REQ:
+        return this.routeReq(msg, callback);
     default:
         this.log.warn({ message: msg }, 'unsupported svp_type');
         // XXX: push some sort of error on here?
@@ -334,6 +335,9 @@ JsonStore.prototype.logRm = function _jsonLogRm(_msg, callback) {
     callback();
 };
 
+// TODO: JsonStore.prototype.routeReq
+
+
 // --- Exports
 
 
diff --git a/lib/backend/moray.js b/lib/backend/moray.js
index aed1a99..1fce30f 100644
--- a/lib/backend/moray.js
+++ b/lib/backend/moray.js
@@ -18,6 +18,7 @@ var assert = require('assert-plus');
 var clone = require('clone');
 var common = require('../common');
 var mod_moray = require('../moray');
+var mod_remote = require('../remote');
 var mod_portolan_moray = require('portolan-moray');
 var stream = require('stream');
 var types = require('../types');
@@ -54,6 +55,7 @@ function init(config, callback) {
     assert.object(config, 'config');
     assert.func(callback, 'callback');
 
+    mod_remote.init(config);
     mod_moray.createClient(config, function _afterClient(err, client) {
         if (err) {
             callback(err);
@@ -277,17 +279,16 @@ MorayStore.prototype._op_svp_r_log_req =
             'logreq mapped cn ip');
 
         // This is an upper limit, based on the smallest possible size of logs.
-
-
         var limit = Math.floor(
             input.svp_msg.lr_count /
             Math.min(types.sizeof.SVP_LOG_VL2,
-                types.sizeof.SVP_LOG_VL3));
+                types.sizeof.SVP_LOG_VL3,
+                types.sizeof.SVP_LOG_ROUTE));
 
         log.debug({ input: input, bytes: input.svp_msg.lr_count,
             vl2: types.sizeof.SVP_LOG_VL2, vl3: types.sizeof.SVP_LOG_VL3,
-            limit: limit }, 'calculating log limit');
-
+            route: types.sizeof.SVP_LOG_ROUTE, limit: limit },
+            'calculating log limit');
 
         mod_portolan_moray.logReq({
             cnUuid: mapping.cn_uuid,
@@ -319,9 +320,7 @@ MorayStore.prototype._op_svp_r_log_req =
                     break;
                 }
 
-                if (logs[i].record.type === 'SVP_LOG_VL3') {
-                    logs[i].record.ip = common.stringToIp(logs[i].record.ip);
-                }
+                translateRecord(logs[i].record);
                 output.svp_msg.log_data.push(logs[i]);
             }
 
@@ -359,6 +358,110 @@ MorayStore.prototype._op_svp_r_log_rm =
 };
 
 
+MorayStore.prototype._op_svp_r_route_req =
+    function _op_svp_r_route_req(input, log, callback) {
+
+    var self = this;
+    var r_ip = input.svp_msg.r_ip;
+    var ip = input.svp_msg.ip;
+    var vnet = input.svp_msg.vnet_id;
+    var vlan = input.svp_msg.vlan_id;
+    var output;
+
+    // TODO: add limit
+    // TODO: handle requiring a second lookup
+    mod_portolan_moray.vnetRouteLookup({
+        log: log,
+        moray: self.moray,
+        src_vnet_id: vnet,
+        src_vlan_id: vlan
+    }, function (vrErr, routes) {
+        if (vrErr) {
+            // TODO: add logging
+            callback(vrErr);
+            return;
+        }
+
+        for (var r in routes) {
+            var route = routes[r];
+            if (!common.cidrContainsIP(route.subnet, ip) ||
+                !common.cidrContainsIP(route.r_subnet, r_ip)) {
+
+                continue;
+            }
+
+            var dst_prefixlen = common.cidrPrefixLen(route.r_subnet);
+            var src_prefixlen = common.cidrPrefixLen(route.subnet);
+
+            output = {
+                svp_msg: {
+                    sra_status: types.svp_status.SVP_S_OK,
+                    sra_dcid: route.r_dc_id,
+                    sra_vnetid: route.r_vnet_id,
+                    sra_vlanid: route.r_vlan_id,
+                    sra_dst_prefixlen: dst_prefixlen,
+                    sra_src_prefixlen: src_prefixlen,
+                    sra_vl2_srcmac: route.r_send_mac
+                },
+                svp_type: types.svp_op.SVP_R_ROUTE_ACK
+            };
+
+            break;
+        }
+
+        /* Vnet Route lookup failure. */
+        if (!output) {
+            callback(null, common.vnetRouteNotFoundMsg(input));
+            return;
+        }
+
+        var remote_req = {
+            dcid: 0, // sra_dcid
+            op: types.svp_op.SVP_R_VL3_REQ,
+            payload: {
+                vl3_ip: r_ip,
+                vl3_vnetid: route.r_vnet_id
+            }
+        };
+
+        mod_remote.remoteCall(remote_req, function (err, res) {
+            if (err) {
+                callback(err);
+                return;
+            }
+
+            if (res.svp_msg.vl3_status === types.svp_status.SVP_S_NOTFOUND) {
+                log.debug('vnetroute failed to find corresponding vl3 for:',
+                    input);
+                callback(null, common.vnetRouteNotFoundMsg(input));
+                return;
+            }
+
+            output.svp_msg.sra_port = res.svp_msg.vl3_port;
+            output.svp_msg.sra_ul3ip = res.svp_msg.vl3_ip;
+            output.svp_msg.sra_vl2_dstmac = res.svp_msg.vl3_mac;
+
+            log.debug('vnetroute received vl3 response:', res,
+                'writing output:', output);
+            callback(null, output);
+        });
+    });
+};
+
+function translateRecord(record) {
+    switch (record.type) {
+    case 'SVP_LOG_VL3':
+        record.ip = common.stringToIp(record.ip);
+        break;
+    case 'SVP_LOG_ROUTE':
+        record.srcip = common.stringToIp(record.srcip);
+        record.dstip = common.stringToIp(record.dstip);
+        break;
+    default:
+        break;
+    }
+}
+
 // --- Backend manipulation
 
 
@@ -435,6 +538,43 @@ function removeUnderlayMapping(opts, callback) {
     return mod_portolan_moray.removeUnderlayMapping(newOpts, callback);
 }
 
+function addVnetRouteMapping(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+
+    var newOpts = clone(opts);
+    newOpts.subnet = common.cidrToString(opts.subnet);
+    newOpts.r_subnet = common.cidrToString(opts.r_subnet);
+    newOpts.moray = SHARED.moray;
+
+    return mod_portolan_moray.addVnetRouteMapping(newOpts, callback);
+}
+
+
+function updateVnetRouteMapping(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+
+    var newOpts = clone(opts);
+    newOpts.subnet = common.cidrToString(opts.subnet);
+    newOpts.r_subnet = common.cidrToString(opts.r_subnet);
+    newOpts.moray = SHARED.moray;
+
+    return mod_portolan_moray.updateVnetRouteMapping(newOpts, callback);
+}
+
+
+function removeVnetRouteMapping(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.func(callback, 'callback');
+
+    var newOpts = clone(opts);
+    newOpts.subnet = common.cidrToString(opts.subnet);
+    newOpts.r_subnet = common.cidrToString(opts.r_subnet);
+    newOpts.moray = SHARED.moray;
+
+    return mod_portolan_moray.removeVnetRouteMapping(newOpts, callback);
+}
 
 
 module.exports = {
@@ -448,5 +588,9 @@ module.exports = {
 
     addUnderlayMapping: addUnderlayMapping,
     updateUnderlayMapping: updateUnderlayMapping,
-    removeUnderlayMapping: removeUnderlayMapping
+    removeUnderlayMapping: removeUnderlayMapping,
+
+    addVnetRouteMapping: addVnetRouteMapping,
+    updateVnetRouteMapping: updateVnetRouteMapping,
+    removeVnetRouteMapping: removeVnetRouteMapping
 };
diff --git a/lib/client.js b/lib/client.js
index c4124c5..949d6f3 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -39,6 +39,22 @@ function PortolanClient(opts) {
 }
 
 
+/*
+ * This function, passes a request in the form of a JS object through the
+ * serializer, then to portolan as binary data, and parsers the response.  See
+ * the flow below:
+ *
+ * client: serialize request
+ * client: write request to portolan
+ *      portolan: Framer parses header
+ *      portolan: Parser parses payload
+ *      portolan: backend conducts get/set/update with moray or other backend
+ *      portolan: Serializes response
+ *      portolan: sends response
+ * client: Framer parses header
+ * client: Parser parses payload
+ * client: once('data', callback());
+ */
 PortolanClient.prototype._makeReq = function _makeReq(req, callback) {
     if (!this._serStream) {
         var strOpts = { log: this.log };
@@ -55,6 +71,19 @@ PortolanClient.prototype._makeReq = function _makeReq(req, callback) {
     this._serStream.write(req);
 };
 
+/*
+ * A wrapper around _makeReq to manage the per client id.
+ */
+PortolanClient.prototype.makeCall = function makeCall(req, callback) {
+    this._makeReq({
+        svp_id: this.id++,
+        svp_type: req.op,
+        svp_msg: req.payload
+    }, function (res) {
+        callback(null, res);
+        return;
+    });
+};
 
 PortolanClient.prototype.close = function _close() {
     this.client.end();
@@ -218,6 +247,45 @@ PortolanClient.prototype.logRm = function _clientLogRm(opts, callback) {
     });
 };
 
+
+PortolanClient.prototype.vnetRouteReq =
+    function _clientVnetRouteReq(opts, callback) {
+
+    mod_assert.object(opts, 'opts');
+    mod_assert.number(opts.vnet_id, 'opts.vnet_id');
+    mod_assert.number(opts.vlan_id, 'opts.vlan_id');
+    mod_assert.object(opts.ip, 'opts.ip');
+    mod_assert.object(opts.r_ip, 'opts.r_ip');
+
+    this._makeReq({
+        svp_type: mod_types.svp_op.SVP_R_ROUTE_REQ,
+        svp_id: this.id++,
+        svp_msg: {
+            srr_vnetid: opts.vnet_id,
+            srr_vlanid: opts.vlan_id,
+            srr_srcip: opts.ip,
+            srr_dstip: opts.r_ip
+        }
+    }, function (data) {
+        var res = {
+            status: data.svp_msg.r_status,
+            status_str: mod_types.statusString(data.svp_msg.r_status),
+            r_dc_id: data.svp_msg.r_dc_id,
+            r_vnet_id: data.svp_msg.r_vnet_id,
+            r_vlan_id: data.svp_msg.r_vlan_id,
+            prefixlen: data.svp_msg.prefixlen,
+            r_prefixlen: data.svp_msg.r_prefixlen,
+            r_port: data.svp_msg.r_port,
+            r_ul3_ip: mod_common.ipToString(data.svp_msg.r_ul3_ip),
+            vl2_src_mac: mod_common.intToMac(data.svp_msg.vl2_src_mac),
+            vl2_dst_mac: mod_common.intToMac(data.svp_msg.vl2_dst_mac)
+        };
+
+        return callback(null, res);
+    });
+};
+
+
 // --- Exports
 
 
@@ -233,7 +301,7 @@ function connectClient(opts, callback) {
         level: process.env.LOG_LEVEL || 'fatal'
     });
 
-    var client =  mod_net.createConnection(opts, callback);
+    var client = mod_net.createConnection(opts, callback);
     client.on('error', callback);
 
     return new PortolanClient({
diff --git a/lib/common.js b/lib/common.js
index 677f9e9..d097217 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -14,6 +14,7 @@
 
 'use strict';
 
+// XXX: Switch to node-ip6addr
 var ipaddr = require('ipaddr.js');
 var types = require('./types');
 var fmt = require('util').format;
@@ -78,6 +79,33 @@ function createv6obj(ipStr) {
 }
 
 
+function createv6subobj(cidr) {
+    if (typeof (cidr) === 'object') {
+        return cidr;
+    }
+
+    var split = cidr.split('/');
+    var ip = split[0];
+    var prefixlen = parseInt(split[1], 10);
+    var ipStr;
+
+    var ipObj = ipaddr.process(ip);
+    if (ipObj.kind() === 'ipv4') {
+        if (prefixlen < 33) {
+            prefixlen += 96;
+        }
+        ipStr = ipObj.toIPv4MappedAddress().toString();
+    }
+
+    return ipaddr.parseCIDR(ipStr + '/' + prefixlen.toString());
+}
+
+
+function cidrToString(cidr) {
+    return (cidr.toString().replace(',', '/'));
+}
+
+
 function ipToString(ip) {
     return (ip.toString());
 }
@@ -95,6 +123,48 @@ function stringToIp(ip) {
     return (ipaddr.parse(ip));
 }
 
+/*
+ * Subnets are stored in IPv4 Mapped IPv6 format, so prefixlen
+ * should be > 96.
+ */
+function cidrPrefixLen(cidr) {
+    var subnet = cidr;
+    var addr;
+    var prefix;
+
+    if (typeof (subnet) === 'string') {
+        subnet = ipaddr.parseCIDR(subnet);
+    }
+
+    prefix = subnet[1];
+    addr = subnet[0];
+
+    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress() && prefix >= 96) {
+        // XXX  ASSERT(prefix > 32) ???
+        prefix -= 96;
+    }
+
+    return prefix;
+}
+
+function cidrContainsIP(cidr, ip) {
+    var addr = ip;
+    var subnet = ipaddr.parseCIDR(cidr);
+
+    if (typeof (ip) === 'string') {
+        addr = stringToIp(ip);
+    }
+
+    if (subnet[0].kind() === 'ipv6' &&
+        subnet[0].isIPv4MappedAddress() &&
+        subnet[1] < 33) {
+
+        subnet[1] += 96;
+    }
+
+    return addr.match(subnet);
+}
+
 /**
  * Convert an array of bytes to an integer
  */
@@ -236,6 +306,7 @@ function validateOpts(opts) {
     if (opts.hasOwnProperty('ip')) {
         validateIP(opts.ip);
     }
+    // TODO add subnet, vnet, vlan, dc_id
 }
 
 /**
@@ -269,6 +340,25 @@ function vl3NotFoundMsg(msg) {
     };
 }
 
+function vnetRouteNotFoundMsg(msg) {
+    return {
+        svp_type: types.svp_op.SVP_R_ROUTE_ACK,
+        svp_id: msg.svp_id,
+        svp_msg: {
+            sra_status: types.svp_status.SVP_S_NOTFOUND,
+            sra_dcid: 0,
+            sra_vnetid: 0,
+            sra_vlanid: 0,
+            sra_dst_prefixlen: 0,
+            sra_src_prefixlen: 0,
+            sra_vl2_srcmac: 0,
+            sra_port: 0,
+            sra_ul3ip: ipaddr.parse('::0'),
+            sra_vl2_dstmac: 0
+        }
+    };
+}
+
 var unspecAddr = ipaddr.parse('::');
 
 function fatalResponse(type) {
@@ -307,6 +397,18 @@ function fatalResponse(type) {
             },
             svp_type: types.svp_op.SVP_R_LOG_RM_ACK
         };
+    case types.svp_op.SVP_R_ROUTE_REQ:
+        return {
+            svp_msg: {
+                ra_status: types.svp_status.SVP_S_FATAL,
+                sra_vnetid: 0,
+                sra_vlanid: 0,
+                sra_prefixlen: 0,
+                sra_dcid: 0,
+                sra_vl2_src_mac: 0
+            },
+            svp_type: types.svp_op.SVP_R_ROUTE_ACK
+        };
     default:
         throw new Error('Unrecognized request message type');
     }
@@ -317,7 +419,11 @@ module.exports = {
     childLogger: createChildLogger,
     fatalResponse: fatalResponse,
     IPv6obj: createv6obj,
+    IPv6SubObj: createv6subobj,
     ipToString: ipToString,
+    cidrToString: cidrToString,
+    cidrPrefixLen: cidrPrefixLen,
+    cidrContainsIP: cidrContainsIP,
     ipv4StrTov6: ipv4StrTov6,
     stringToIp: stringToIp,
     macArrToInt: macArrToInt,
@@ -334,7 +440,8 @@ module.exports = {
         opts: validateOpts
     },
     vl2NotFoundMsg: vl2NotFoundMsg,
-    vl3NotFoundMsg: vl3NotFoundMsg
+    vl3NotFoundMsg: vl3NotFoundMsg,
+    vnetRouteNotFoundMsg: vnetRouteNotFoundMsg
 };
 
 function test() {
diff --git a/lib/framer.js b/lib/framer.js
index db04a5c..0d69f7a 100644
--- a/lib/framer.js
+++ b/lib/framer.js
@@ -96,6 +96,8 @@ SVPFramer.prototype._transform =
         log.debug({ msg_svp_req_hdr: msg.svp_req.hdr, msgCount: msgCount++ },
             'message header');
 
+        // XXX: version check? msg.svp_req.hdr.svp_ver
+
         // There is a distinction between what the message indicates as its
         // size, and the expected size of the message derived from ctypes.
         // We check the former here & the latter in the parser.
diff --git a/lib/parser.js b/lib/parser.js
index 65f5f4d..5ebe354 100644
--- a/lib/parser.js
+++ b/lib/parser.js
@@ -44,6 +44,19 @@ function ipFromArr(arr) {
     ]);
 }
 
+function translateRecord(type, record) {
+    switch (type) {
+    case 'SVP_LOG_VL3':
+        record.svl3_ip = ipFromArr(record.svl3_ip);
+        break;
+    case 'SVP_LOG_ROUTE':
+        record.svlr_srcip = ipFromArr(record.svlr_srcip);
+        record.svlr_dstip = ipFromArr(record.svlr_dstip);
+        break;
+    default:
+        break;
+    }
+}
 
 
 // --- Exports
@@ -206,9 +219,7 @@ SVPparser.prototype._transform =
                 { log: { type: logTypedef } }
             ], msg.svp_buf, offset).log;
 
-            if (la_record.svl3_ip) {
-                la_record.svl3_ip = ipFromArr(la_record.svl3_ip);
-            }
+            translateRecord(logTypedef, la_record);
 
             la_data.push(la_record);
             offset += logSize;
@@ -253,6 +264,30 @@ SVPparser.prototype._transform =
         };
         break;
 
+    case mod_types.svp_op.SVP_R_ROUTE_REQ:
+        rec.svp_msg = {
+            vnet_id: payload.body.srr_vnetid,
+            vlan_id: payload.body.srr_vlanid,
+            ip: ipFromArr(payload.body.srr_srcip),
+            r_ip: ipFromArr(payload.body.srr_dstip)
+        };
+        break;
+
+    case mod_types.svp_op.SVP_R_ROUTE_ACK:
+        rec.svp_msg = {
+            r_status: payload.body.sra_status,
+            r_dc_id: payload.body.sra_dcid,
+            r_vnet_id: payload.body.sra_vnetid,
+            r_vlan_id: payload.body.sra_vlanid,
+            prefixlen: payload.body.sra_src_prefixlen,
+            r_prefixlen: payload.body.sra_dst_prefixlen,
+            r_port: payload.body.sra_port,
+            r_ul3_ip: ipFromArr(payload.body.sra_ul3ip),
+            vl2_src_mac: mod_common.macArrToInt(payload.body.sra_vl2_srcmac),
+            vl2_dst_mac: mod_common.macArrToInt(payload.body.sra_vl2_dstmac)
+        };
+        break;
+
     default:
         log.warn({ hdr: msg.svp_req.hdr, body: payload.body },
             'unknown message svp_op');
diff --git a/lib/remote.js b/lib/remote.js
new file mode 100644
index 0000000..ec06d94
--- /dev/null
+++ b/lib/remote.js
@@ -0,0 +1,158 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Remote Portolan
+ *
+ * 1. On startup and subsequently on a regular interval query dcapi to get
+ * information about the region specifically the DNS names of the DC remote
+ * portolans.
+ *
+ * 2. Maintain a cache of remote portolan clients these with cueball or
+ * something (little help here... perhaps future work, or atleast post POC/MVP).
+ *
+ * 3. Expose interfaces that will execute SVP operations on remote portolan
+ * given the datacenter ID.
+ */
+
+'use strict';
+
+var mod_assert = require('assert-plus');
+var mod_client = require('./client');
+// var config = require('../etc/config.json');
+
+var REMOTE = {};
+
+// TODO integrate DCAPI which will require an async callback.
+function RemotePortolan(opts) {
+    REMOTE.log = opts.log;
+
+    // TODO: fill out clients list with DCAPI
+    var clients = {
+        '0': {
+            host: 'localhost',
+            port: opts.port
+        },
+        '1': {
+            host: '10.99.99.34',
+            port: opts.port
+        }
+    };
+
+    REMOTE.clients = clients;
+    REMOTE.dcid_self = 0; // TODO, get my own dcid
+}
+
+function createClient(opts) {
+    mod_assert.string(opts.host, 'opts.host');
+    mod_assert.number(opts.port, 'opts.port');
+    // TODO
+}
+
+// EUNUSED
+function getLocalClient() {
+    return getClient(REMOTE.dcid_self);
+}
+
+function addClient(client) {
+
+    /* Already added */
+    if (client.dcid in REMOTE.clients) {
+        return;
+    }
+
+    REMOTE.clients[client.dcid] = {
+        host: client.host,
+        port: client.port
+    };
+}
+
+function getClient(opts, callback) {
+
+    var dcid = opts.dcid;
+    var client = REMOTE.clients[dcid];
+    var r_client;
+
+    if (!client) {
+        // TODO: proper error code
+        callback(new Error('ENOENT'));
+        return;
+    }
+
+    if (client.connection) {
+        callback(null, client.connection);
+        return;
+    }
+
+    var conf = {
+        host: client.host,
+        port: client.port,
+        log: opts.log || REMOTE.log
+    };
+
+    r_client = mod_client.connect(conf, function (err) {
+        if (err) {
+            throw err;
+        }
+
+        return;
+    });
+
+    // A client can be added but not connected.
+    // TODO: This will probably be managed by cueball.
+    REMOTE.clients[dcid].connection = r_client;
+    callback(null, r_client);
+}
+
+function closeClient(dcid) {
+    REMOTE.clients[dcid].connection.close();
+    delete REMOTE.clients[dcid].connection;
+}
+
+
+function remoteCall(req, callback) {
+
+    // TODO: asserts
+
+    var op = req.op;
+    var dcid = req.dcid || 0;
+    var payload = req.payload;
+
+    getClient({dcid: dcid}, function (err, client) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        client.makeCall({
+            op: op,
+            payload: payload
+        }, function (cerr, res) {
+            if (cerr) {
+                // TODO: logging
+                callback(cerr);
+                closeClient(dcid);
+                return;
+            }
+            callback(null, res);
+            closeClient(dcid);
+        });
+    });
+}
+
+module.exports = {
+    init: RemotePortolan,
+    addClient: addClient,
+    getClient: getClient,
+    getLocalClient: getLocalClient,
+    createClient: createClient,
+    closeClient: closeClient,
+    remoteCall: remoteCall
+};
diff --git a/lib/serialize.js b/lib/serialize.js
index c990e40..a65a858 100644
--- a/lib/serialize.js
+++ b/lib/serialize.js
@@ -131,6 +131,9 @@ SVPserializer.prototype._transform =
                 common.uuidToArr(datum.id)
             ];
 
+            /*
+             * The record's key names come from portolan-moray's event handling.
+             */
             switch (svpLogType) {
             case types.svp_log_type.SVP_LOG_VL2:
                 record.push(common.intToMacArrayOfNums(datum.record.mac));
@@ -145,6 +148,19 @@ SVPserializer.prototype._transform =
                 record.push(datum.record.vnet_id);
                 break;
 
+            case types.svp_log_type.SVP_LOG_ROUTE:
+                record.push(datum.record.src_vnet_id);
+                record.push(datum.record.dst_vnet_id);
+                record.push(datum.record.dcid);
+                record.push(datum.record.srcip.toByteArray());
+                record.push(datum.record.dstip.toByteArray());
+                record.push(datum.record.src_vlan_id);
+                record.push(datum.record.dst_vlan_id);
+                record.push(datum.record.src_prefixlen);
+                record.push(datum.record.dst_prefixlen);
+                record.push([0, 0]); // padding
+                break;
+
             default:
                 // XXX - unrecoverable. Needs to err.
                 log.warn({ log_record: datum },
@@ -196,6 +212,31 @@ SVPserializer.prototype._transform =
         ];
         break;
 
+    case types.svp_op.SVP_R_ROUTE_ACK:
+        fixedPart = [
+            msg.svp_msg.sra_status,
+            msg.svp_msg.sra_dcid,
+            msg.svp_msg.sra_vnetid,
+            msg.svp_msg.sra_vlanid,
+            msg.svp_msg.sra_port,
+            msg.svp_msg.sra_ul3ip.toByteArray(),
+            common.intToMacArrayOfNums(msg.svp_msg.sra_vl2_srcmac),
+            common.intToMacArrayOfNums(msg.svp_msg.sra_vl2_dstmac),
+            msg.svp_msg.sra_src_prefixlen,
+            msg.svp_msg.sra_dst_prefixlen
+        ];
+        break;
+
+    case types.svp_op.SVP_R_ROUTE_REQ:
+        fixedPart = [
+            msg.svp_msg.srr_vnetid,
+            msg.svp_msg.srr_vlanid,
+            [ 0, 0 ], // padding
+            msg.svp_msg.srr_srcip.toByteArray(),
+            msg.svp_msg.srr_dstip.toByteArray()
+        ];
+        break;
+
     default:
         log.warn({ message: msg }, 'unknown message svp_type');
         return callback();
diff --git a/lib/types.js b/lib/types.js
index 4733df1..2048fc6 100644
--- a/lib/types.js
+++ b/lib/types.js
@@ -31,7 +31,10 @@ var op_types = {
     9: 'svp_log_req_t',
     10: 'svp_log_ack_t',
     11: 'svp_lrm_req_t',
-    12: 'svp_lrm_ack_t'
+    12: 'svp_lrm_ack_t',
+    13: 'svp_shootdown_t',
+    14: 'svp_route_req_t',
+    15: 'svp_route_ack_t'
 };
 
 var sizeof = {
@@ -47,8 +50,12 @@ var sizeof = {
     SVP_R_LOG_ACK: 4,
     SVP_LOG_VL2: 32,
     SVP_LOG_VL3: 44,
+    SVP_LOG_ROUTE: 70,
     SVP_R_LOG_RM: 4,
-    SVP_R_LOG_RM_ACK: 4
+    SVP_R_LOG_RM_ACK: 4,
+    SVP_R_SHOOTDOWN: 12,
+    SVP_R_ROUTE_REQ: 40,
+    SVP_R_ROUTE_ACK: 46
 };
 
 var sizeof_ops = {
@@ -61,7 +68,10 @@ var sizeof_ops = {
     9: sizeof.SVP_R_LOG_REQ,
     10: sizeof.SVP_R_LOG_ACK,
     11: sizeof.SVP_R_LOG_RM,
-    12: sizeof.SVP_R_LOG_RM_ACK
+    12: sizeof.SVP_R_LOG_RM_ACK,
+    13: sizeof.SVP_R_SHOOTDOWN,
+    14: sizeof.SVP_R_ROUTE_REQ,
+    15: sizeof.SVP_R_ROUTE_ACK
 };
 
 var svp_op = {
@@ -88,7 +98,9 @@ var svp_op_hex = {
     SVP_R_LOG_ACK: '0x0A',
     SVP_R_LOG_RM: '0x0B',
     SVP_R_LOG_RM_ACK: '0x0C',
-    SVP_R_SHOOTDOWN: '0x0D'
+    SVP_R_SHOOTDOWN: '0x0D',
+    SVP_R_ROUTE_REQ: '0x0E',
+    SVP_R_ROUTE_ACK: '0x0F'
 };
 
 var svp_status = {
@@ -111,22 +123,26 @@ var svp_vl3_type = {
 
 var svp_log_type = {
     SVP_LOG_VL2: 1,
-    SVP_LOG_VL3: 2
+    SVP_LOG_VL3: 2,
+    SVP_LOG_ROUTE: 3
 };
 
 var svp_log_typedef = {
     SVP_LOG_VL2: 'svp_log_vl2_t',
-    SVP_LOG_VL3: 'svp_log_vl3_t'
+    SVP_LOG_VL3: 'svp_log_vl3_t',
+    SVP_LOG_ROUTE: 'svp_log_route_t'
 };
 
 var svp_log_type_names = {
     1: 'SVP_LOG_VL2',
-    2: 'SVP_LOG_VL3'
+    2: 'SVP_LOG_VL3',
+    3: 'SVP_LOG_ROUTE'
 };
 
 var sizeof_logs = {
     1: sizeof.SVP_LOG_VL2,
-    2: sizeof.SVP_LOG_VL3
+    2: sizeof.SVP_LOG_VL3,
+    3: sizeof.SVP_LOG_ROUTE
 };
 
 var types = JSON.parse(fs.readFileSync(
diff --git a/package.json b/package.json
index 219721f..96fc2ac 100644
--- a/package.json
+++ b/package.json
@@ -11,13 +11,13 @@
         "cmdln": "3.0.1",
         "ctype": "0.5.3",
         "dtrace-provider": "0.3.1",
-        "ipaddr.js": "0.1.6",
+        "ipaddr.js": "1.6.0",
         "lomstream": "^1.1.0",
         "lru-cache": "2.5.0",
         "mkdirp": "0.5.0",
         "moray": "3.4.2",
         "node-uuid": "1.4.2",
-        "portolan-moray": "git+https://github.com/joyent/sdc-portolan-moray.git#7e2c4ca",
+        "portolan-moray": "git+https://github.com/joyent/sdc-portolan-moray.git#vpc",
         "tape": "3.0.3",
         "vasync": "1.6.2",
         "verror": "1.6.0",
diff --git a/test/integration/backend.test.js b/test/integration/backend.test.js
index 7ea3c81..f4e7e67 100644
--- a/test/integration/backend.test.js
+++ b/test/integration/backend.test.js
@@ -51,6 +51,55 @@ var VMS = [
     }
 ];
 
+var ROUTES = [
+    {
+        vnet_id: 11111,
+        vlan_id: 1,
+        subnet: '192.168.111.0/24',
+        r_dc_id: 22,
+        r_vnet_id: 22222,
+        r_vlan_id: 2,
+        r_subnet: '192.168.222.0/24',
+        r_send_mac: '00:0a:95:ff:ff:ff'
+    },
+    {
+        vnet_id: 101010,
+        vlan_id: 10,
+        subnet: '192.168.100.0/24',
+        r_dc_id: 220,
+        r_vnet_id: 202020,
+        r_vlan_id: 20,
+        r_subnet: '192.168.200.0/24',
+        r_send_mac: '00:0a:59:ff:ff:ff'
+    },
+    {
+        vnet_id: 101010,
+        vlan_id: 10,
+        subnet: '192.168.100.0/24',
+        r_dc_id: 0,
+        r_vnet_id: 12340, // same as VMS[0]
+        r_vlan_id: 20,
+        r_subnet: '10.0.0.0/24', // same as VMS[0]
+        r_send_mac: '00:0a:59:ff:ff:ff'
+    }
+
+];
+
+var ROUTE_IPS = [
+    {
+        src: '192.168.111.1',
+        dst: '192.168.222.1'
+    },
+    {
+        src: '192.168.100.1',
+        dst: '192.168.200.1'
+    },
+    {
+        src: '192.168.100.1',
+        dst: VMS[0].ip // same as VMS[0]
+    }
+];
+
 var STATUS = mod_types.svp_status;
 
 
@@ -80,6 +129,24 @@ test('setup', function (t) {
             params: VMS[1]
         });
     });
+
+    t.test('add vnet route mapping 0', function (t2) {
+        mod_mapping.addVnetRoute(t2, {
+            params: ROUTES[0]
+        });
+    });
+
+    t.test('add vnet route mapping 1', function (t2) {
+        mod_mapping.addVnetRoute(t2, {
+            params: ROUTES[1]
+        });
+    });
+
+    t.test('add vnet route mapping 2', function (t2) {
+        mod_mapping.addVnetRoute(t2, {
+            params: ROUTES[2]
+        });
+    });
 });
 
 
@@ -193,6 +260,49 @@ test('vl3', function (t) {
 
 });
 
+test('vnetRoute', function (t) {
+    t.test('vnet and vl3 mapping exists', function (t2) {
+        mod_req.vnetRoute(t2, {
+            params: {
+                vnet_id: ROUTES[2].vnet_id,
+                vlan_id: ROUTES[2].vlan_id,
+                ip: ROUTE_IPS[2].src,
+                r_ip: ROUTE_IPS[2].dst
+            },
+            exp: {
+                status: STATUS.SVP_S_OK,
+                status_str: mod_types.statusString(STATUS.SVP_S_OK),
+                r_dc_id: ROUTES[2].r_dc_id,
+                r_vnet_id: ROUTES[2].r_vnet_id,
+                r_vlan_id: ROUTES[2].r_vlan_id,
+                prefixlen: parseInt(ROUTES[2].subnet.split('/')[1], 10),
+                r_prefixlen: parseInt(ROUTES[2].r_subnet.split('/')[1], 10),
+                r_port: CNS[0].port,
+                r_ul3_ip: mod_common.ipv4StrTov6(CNS[0].ip),
+                vl2_src_mac: ROUTES[2].r_send_mac,
+                vl2_dst_mac: VMS[0].mac
+            }
+        });
+    });
+
+
+    t.test('wrong source ip/subnet', function (t2) {
+        mod_req.vnetRoute(t2, {
+            params: {
+                vnet_id: ROUTES[2].vnet_id,
+                vlan_id: ROUTES[2].vlan_id,
+                ip: '10.10.10.10',
+                r_ip: ROUTE_IPS[2].dst
+            },
+            exp: mod_req.vnetRouteNotFound()
+        });
+    });
+
+// TODO others
+// vnetmapping exists but corresponding vl3 lookup doesnt > vnetRouteNotFound()
+// shootdowns?
+
+});
 
 // XXX: log lookup tests:
 // - try to delete a record that doesn't exist
diff --git a/test/lib/mapping.js b/test/lib/mapping.js
index 62b37ed..1b002a7 100644
--- a/test/lib/mapping.js
+++ b/test/lib/mapping.js
@@ -65,9 +65,41 @@ function addUnderlayMapping(t, opts) {
     });
 }
 
+function addVnetRouteMapping(t, opts) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.object(opts.params, 'opts.params');
+    assert.number(opts.params.vnet_id, 'opts.params.vnet_id');
+    assert.number(opts.params.vlan_id, 'opts.params.vlan_id');
+    assert.string(opts.params.subnet, 'opts.params.subnet');
+    assert.number(opts.params.r_dc_id, 'opts.params.r_dc_id');
+    assert.number(opts.params.r_vnet_id, 'opts.params.r_vnet_id');
+    assert.number(opts.params.r_vlan_id, 'opts.params.r_vlan_id');
+    assert.string(opts.params.r_subnet, 'opts.params.r_subnet');
+    assert.string(opts.params.r_send_mac, 'opts.params.r_send_mac');
+
+    var val = {
+        vnet_id: opts.params.vnet_id,
+        vlan_id: opts.params.vlan_id,
+        subnet: mod_common.IPv6SubObj(opts.params.subnet),
+        r_dc_id: opts.params.r_dc_id,
+        r_vnet_id: opts.params.r_vnet_id,
+        r_vlan_id: opts.params.r_vlan_id,
+        r_subnet: mod_common.IPv6SubObj(opts.params.r_subnet),
+        r_send_mac: mod_common.macToInt(opts.params.r_send_mac)
+    };
+
+    mod_moray.addVnetRouteMapping(val, function _afterVnetRoute(err) {
+        t.ifErr(err, 'add vnet route mapping');
+        t.end();
+        return;
+    });
+}
+
 
 
 module.exports = {
     addOverlay: addOverlayMapping,
-    addUnderlay: addUnderlayMapping
+    addUnderlay: addUnderlayMapping,
+    addVnetRoute: addVnetRouteMapping
 };
diff --git a/test/lib/request.js b/test/lib/request.js
index c69ad92..14f88c4 100644
--- a/test/lib/request.js
+++ b/test/lib/request.js
@@ -97,6 +97,43 @@ function reqVL3(t, opts) {
     });
 }
 
+/**
+ * Make a vnetroute request
+ */
+function reqVnetRoute(t, opts) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.object(opts.exp, 'opts.exp');
+    assert.object(opts.params, 'opts.params');
+    assert.number(opts.params.vnet_id, 'opts.params.vnet_id');
+    assert.number(opts.params.vlan_id, 'opts.params.vlan_id');
+    assert.string(opts.params.ip, 'opts.params.ip');
+    assert.string(opts.params.r_ip, 'opts.params.r_ip');
+
+    mod_client.get(function (_, client) {
+        var params = {
+            vnet_id: opts.params.vnet_id,
+            vlan_id: opts.params.vlan_id,
+            ip: mod_common.IPv6obj(opts.params.ip),
+            r_ip: mod_common.IPv6obj(opts.params.r_ip)
+        };
+
+        client.vnetRouteReq(params, function _aftervnetRoute(err, res) {
+            t.ifErr(err, 'vnetRoute error');
+            if (err) {
+                return t.end();
+            }
+
+            // XXX: should we return an error code instead?
+            if (Object.keys(res).length === 0) {
+                res = vnetRouteNotFound();
+            }
+
+            t.deepEqual(res, opts.exp, 'vnetRoute res');
+            return t.end();
+        });
+    });
+}
 
 /**
  * Returns a client response for VL2 mapping not found
@@ -124,12 +161,28 @@ function vl3NotFound() {
     };
 }
 
-
+function vnetRouteNotFound() {
+    return {
+        status: STATUS.SVP_S_NOTFOUND,
+        status_str: mod_types.statusString(STATUS.SVP_S_NOTFOUND),
+        prefixlen: 0,
+        r_dc_id: 0,
+        r_port: 0,
+        r_prefixlen: 0,
+        r_ul3_ip: '::',
+        r_vlan_id: 0,
+        r_vnet_id: 0,
+        vl2_dst_mac: '00:00:00:00:00:00',
+        vl2_src_mac: '00:00:00:00:00:00'
+    };
+}
 
 module.exports = {
     ping: reqPing,
     vl2: reqVL2,
     vl2NotFound: vl2NotFound,
     vl3: reqVL3,
-    vl3NotFound: vl3NotFound
+    vl3NotFound: vl3NotFound,
+    vnetRoute: reqVnetRoute,
+    vnetRouteNotFound: vnetRouteNotFound
 };
diff --git a/test/unit/types.test.js b/test/unit/types.test.js
index 315ae21..e9c35cb 100644
--- a/test/unit/types.test.js
+++ b/test/unit/types.test.js
@@ -89,6 +89,24 @@ test('opinfo', function (t) {
             op: svp_op.SVP_R_LOG_RM_ACK,
             sizeof: 4,
             type: 'svp_lrm_ack_t'
+        },
+        {
+            name: 'SVP_R_SHOOTDOWN',
+            op: svp_op.SVP_R_SHOOTDOWN,
+            sizeof: 12,
+            type: 'svp_shootdown_t'
+        },
+        {
+            name: 'SVP_R_ROUTE_REQ',
+            op: svp_op.SVP_R_ROUTE_REQ,
+            sizeof: 40,
+            type: 'svp_route_req_t'
+        },
+        {
+            name: 'SVP_R_ROUTE_ACK',
+            op: svp_op.SVP_R_ROUTE_ACK,
+            sizeof: 46,
+            type: 'svp_route_ack_t'
         }
     ];
 
@@ -99,6 +117,7 @@ test('opinfo', function (t) {
         t.equal(Object.keys(type).length, 4, 'keys');
 
         var opinfo = mod_types.opInfo(type.op);
+
         t.equal(opinfo.name, type.name, type.name + ' name');
         t.equal(opinfo.sizeof, type.sizeof, 'sizeof');
         t.equal(opinfo.sizeofReq, type.sizeof + req_size, 'sizeofReq');
-- 
2.21.0

