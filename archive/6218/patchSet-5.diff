commit fe8baaa2fff18a7ed1f23b5a09127206faa6d81f
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2019-05-10T19:08:59+00:00 (5 months ago)
    
    TRITON-1413 Move common patterns in net-agent into helper functions

diff --git a/lib/aggr-fsm.js b/lib/aggr-fsm.js
index a874297..9e3eac4 100644
--- a/lib/aggr-fsm.js
+++ b/lib/aggr-fsm.js
@@ -13,7 +13,6 @@
 var assert = require('assert-plus');
 var mod_common = require('./common');
 var mod_jsprim = require('jsprim');
-var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
 
 // --- Globals
@@ -89,10 +88,6 @@ function AggrFSM(opts) {
         aggr: this.name
     }, true);
 
-    this.pending = {
-        refresh: false,
-        update: false
-    };
     this.released = null;
 
     this.local = null;
@@ -104,9 +99,9 @@ function AggrFSM(opts) {
      */
     this.etag = undefined;
 
-    mod_mooremachine.FSM.call(this, 'init');
+    mod_common.CommonFSM.call(this);
 }
-mod_util.inherits(AggrFSM, mod_mooremachine.FSM);
+mod_util.inherits(AggrFSM, mod_common.CommonFSM);
 
 AggrFSM.prototype.state_init = function (S) {
     S.immediate(function () {
@@ -118,24 +113,14 @@ AggrFSM.prototype.state_init = function (S) {
  * Wait for external events to force us to recompare.
  */
 AggrFSM.prototype.state_waiting = function (S) {
-    S.on(this, 'setAsserted', function () {
-        S.gotoState('update');
-    });
-
-    S.on(this, 'refreshAsserted', function () {
-        S.gotoState('refresh');
-    });
+    S.gotoStateOn(this, 'setAsserted', 'update');
+    S.gotoStateOn(this, 'refreshAsserted', 'refresh');
+    S.gotoStateOn(this, 'releaseAsserted', 'release');
 
     /*
      * Refresh periodically.
      */
-    S.timeout(60 * 60 * 1000, function () {
-        S.gotoState('refresh');
-    });
-
-    S.on(this, 'releaseAsserted', function () {
-        S.gotoState('release');
-    });
+    S.gotoStateTimeout(60 * 60 * 1000, 'refresh');
 };
 
 AggrFSM.prototype.state_refresh = function (S) {
@@ -148,13 +133,8 @@ AggrFSM.prototype.state_refresh = function (S) {
         'update'
     ]);
 
-    S.on(self, 'refreshAsserted', function () {
-        S.gotoState('refresh');
-    });
-
-    S.on(self, 'releaseAsserted', function () {
-        S.gotoState('release');
-    });
+    S.gotoStateOn(self, 'refreshAsserted', 'refresh');
+    S.gotoStateOn(self, 'releaseAsserted', 'release');
 
     function afterGet(err, aggr, _, res) {
         if (err) {
@@ -170,9 +150,7 @@ AggrFSM.prototype.state_refresh = function (S) {
             self.log.warn(err,
                 'Failed to refresh aggregation information; ' +
                 'retrying in 5 seconds');
-            S.timeout(5000, function () {
-                S.gotoState('refresh');
-            });
+            S.gotoStateTimeout(5000, 'refresh');
             return;
         }
 
@@ -221,9 +199,7 @@ AggrFSM.prototype.state_create = function (S) {
             self.log.warn(err,
                 'Failed to create aggregation in NAPI; ' +
                 'scheduling state refresh');
-            S.timeout(5000, function () {
-                S.gotoState('refresh');
-            });
+            S.gotoStateTimeout(5000, 'refresh');
             return;
         }
 
@@ -256,9 +232,7 @@ AggrFSM.prototype.state_update = function (S) {
         return;
     }
 
-    S.on(this, 'refreshAsserted', function () {
-        S.gotoState('refresh');
-    });
+    S.gotoStateOn(this, 'refreshAsserted', 'refresh');
 
     S.gotoState('update.local');
 };
@@ -280,9 +254,7 @@ AggrFSM.prototype.state_update.local = function (S) {
         return;
     }
 
-    S.on(this, 'releaseAsserted', function () {
-        S.gotoState('release');
-    });
+    S.gotoStateOn(this, 'releaseAsserted', 'release');
 
     function afterUpdate(err) {
         if (err) {
@@ -417,9 +389,7 @@ AggrFSM.prototype.state_release.delete = function (S) {
                 return;
             }
 
-            S.timeout(5000, function () {
-                S.gotoState('release.delete');
-            });
+            S.gotoStateTimeout(5000, 'release.delete');
             return;
         }
 
@@ -446,9 +416,7 @@ AggrFSM.prototype.state_release.refresh = function (S) {
             self.log.warn(err,
                 'Failed to refresh aggregation information for release; ' +
                 'retrying in 5 seconds');
-            S.timeout(5000, function () {
-                S.gotoState('release.refresh');
-            });
+            S.gotoStateTimeout(5000, 'release.refresh');
             return;
         }
 
@@ -481,16 +449,7 @@ AggrFSM.prototype.setLocal = function (aggr) {
     var self = this;
 
     self.local = aggr;
-
-    if (self.pending.update) {
-        return;
-    }
-
-    self.pending.update = true;
-    setImmediate(function () {
-        self.pending.update = false;
-        self.emit('setAsserted');
-    });
+    self.emitDelayed('setAsserted', 0);
 };
 
 /**
@@ -512,15 +471,7 @@ AggrFSM.prototype.refresh = function (etag) {
         return;
     }
 
-    if (self.pending.refresh) {
-        return;
-    }
-
-    self.pending.refresh = true;
-    setImmediate(function () {
-        self.pending.refresh = false;
-        self.emit('refreshAsserted');
-    });
+    self.emitDelayed('refreshAsserted', 0);
 };
 
 AggrFSM.prototype.releaseFrom = function (belongs_to_uuid) {
diff --git a/lib/common.js b/lib/common.js
index fd3b9c9..f711a32 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -12,10 +12,27 @@
 
 var assert = require('assert-plus');
 var mod_jsprim = require('jsprim');
+var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
 
 // --- Exports
 
+
+/*
+ * Get monotonic time in milliseconds.
+ *
+ * Note that this is *not* the same as Date.now(), which returns the current
+ * wall clock time in milliseconds.
+ */
+function currentMillis() {
+    var time = process.hrtime();
+    var secs2ms = time[0] * 1000;
+    var ns2ms = time[1] / 1000000;
+
+    return (secs2ms + ns2ms);
+}
+
+
 function formatAggrId(cn_uuid, name) {
     assert.uuid(cn_uuid, 'cn_uuid');
     assert.string(name, 'name');
@@ -39,7 +56,56 @@ function hasChanged(fields, cur, old) {
 }
 
 
+/**
+ * This class encapsulates some of the common logic to net-agent's FSMs.
+ */
+function CommonFSM() {
+    this.pending = {};
+    this.last = {};
+
+    mod_mooremachine.FSM.call(this, 'init');
+}
+mod_util.inherits(CommonFSM, mod_mooremachine.FSM);
+
+/**
+ * Asynchronously emit event "name". If the event was last emitted within
+ * "delay" milliseconds, then we wait to emit it until we're clear of the
+ * window. Multiple calls to emitDelayed() for the same event will be
+ * coalesced into one emit.
+ */
+CommonFSM.prototype.emitDelayed = function emitCoalesced(name, delay) {
+    var self = this;
+    var wait = 0;
+
+    if (typeof (delay) !== 'number') {
+        delay = 0;
+    }
+
+    if (self.pending[name]) {
+        return;
+    }
+
+    if (self.last[name] === undefined) {
+        self.last[name] = 0;
+    }
+
+    var now = currentMillis();
+    var next = self.last[name] + delay;
+    if (next > now) {
+        wait = next - now;
+    }
+
+    self.pending[name] = true;
+    setTimeout(function () {
+        self.pending[name] = false;
+        self.last[name] = currentMillis();
+        self.emit(name);
+    }, wait);
+};
+
 module.exports = {
+    CommonFSM: CommonFSM,
+    currentMillis: currentMillis,
     formatAggrId: formatAggrId,
     hasChanged: hasChanged
 };
diff --git a/lib/inst-fsm.js b/lib/inst-fsm.js
index 03159d9..b0d3c01 100644
--- a/lib/inst-fsm.js
+++ b/lib/inst-fsm.js
@@ -11,8 +11,8 @@
 'use strict';
 
 var assert = require('assert-plus');
+var mod_common = require('./common');
 var mod_jsprim = require('jsprim');
-var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
 
 // --- Globals
@@ -66,19 +66,19 @@ function InstanceFSM(opts) {
         uuid: this.uuid
     }, true);
 
-    this.pending = {
-        refresh: false
-    };
-
     this.nics = {};
     this.vm = null;
     this.vmadm = opts.vmadm;
 
     this._update(opts.vm);
 
-    mod_mooremachine.FSM.call(this, 'update');
+    mod_common.CommonFSM.call(this);
 }
-mod_util.inherits(InstanceFSM, mod_mooremachine.FSM);
+mod_util.inherits(InstanceFSM, mod_common.CommonFSM);
+
+InstanceFSM.prototype.state_init = function (S) {
+    S.gotoState('update');
+};
 
 InstanceFSM.prototype.state_waiting = function (S) {
     S.validTransitions([
@@ -86,13 +86,8 @@ InstanceFSM.prototype.state_waiting = function (S) {
         'remove'
     ]);
 
-    S.on(this, 'updateAsserted', function () {
-        S.gotoState('update');
-    });
-
-    S.on(this, 'removeAsserted', function () {
-        S.gotoState('remove');
-    });
+    S.gotoStateOn(this, 'updateAsserted', 'update');
+    S.gotoStateOn(this, 'removeAsserted', 'remove');
 };
 
 InstanceFSM.prototype.state_update = function (S) {
@@ -109,9 +104,7 @@ InstanceFSM.prototype.state_update = function (S) {
         return;
     }
 
-    S.on(this, 'removeAsserted', function () {
-        S.gotoState('remove');
-    });
+    S.gotoStateOn(this, 'removeAsserted', 'remove');
 
     S.gotoState('update.wait');
 };
@@ -141,9 +134,7 @@ InstanceFSM.prototype.state_update.wait = function (S) {
         return;
     }
 
-    S.on(this, 'updateAsserted', function () {
-        S.gotoState('update');
-    });
+    S.gotoStateOn(this, 'updateAsserted', 'update');
 
     S.on(pending, 'stateChanged', function onStateChange() {
         if (pending.remote === null) {
@@ -246,9 +237,7 @@ InstanceFSM.prototype.state_remove = function (S) {
     self.nics = {};
     self.vm = null;
 
-    S.on(this, 'updateAsserted', function () {
-        S.gotoState('update');
-    });
+    S.gotoStateOn(this, 'updateAsserted', 'update');
 };
 
 
@@ -315,16 +304,7 @@ InstanceFSM.prototype.update = function (vm) {
     var self = this;
 
     self._update(vm);
-
-    if (self.pending.update) {
-        return;
-    }
-
-    self.pending.update = true;
-    setImmediate(function () {
-        self.pending.update = false;
-        self.emit('updateAsserted');
-    });
+    self.emitDelayed('updateAsserted', 0);
 };
 
 /**
diff --git a/lib/net-agent.js b/lib/net-agent.js
index 1b04a7e..4f328ae 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -75,9 +75,9 @@
 
 var assert = require('assert-plus');
 var mod_clients = require('sdc-clients');
+var mod_common = require('./common');
 var mod_cueball = require('cueball');
 var mod_jsprim = require('jsprim');
-var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
 var VError = require('verror');
 var vmadm = require('vmadm');
@@ -163,9 +163,9 @@ function NetAgent(options) {
     this.nics = {};
     this.nets = {};
 
-    mod_mooremachine.FSM.call(this, 'waiting');
+    mod_common.CommonFSM.call(this);
 }
-mod_util.inherits(NetAgent, mod_mooremachine.FSM);
+mod_util.inherits(NetAgent, mod_common.CommonFSM);
 
 NetAgent.prototype.start = function () {
     this.emit('startAsserted');
@@ -283,21 +283,17 @@ NetAgent.prototype.releaseAggr = function (name, belongs_to_uuid) {
     }
 };
 
-NetAgent.prototype.state_waiting = function (S) {
-    S.on(this, 'startAsserted', function () {
-        S.gotoState('init');
-    });
+NetAgent.prototype.state_init = function (S) {
+    S.gotoStateOn(this, 'startAsserted', 'starting');
 };
 
-NetAgent.prototype.state_init = function (S) {
-    S.on(this, 'stopAsserted', function () {
-        S.gotoState('stopping');
-    });
+NetAgent.prototype.state_starting = function (S) {
+    S.gotoStateOn(this, 'stopAsserted', 'stopping');
 
-    S.gotoState('init.determineEventSource');
+    S.gotoState('starting.determineEventSource');
 };
 
-NetAgent.prototype.state_init.determineEventSource = function (S) {
+NetAgent.prototype.state_starting.determineEventSource = function (S) {
     var self = this;
 
     determineEventSource({
@@ -306,20 +302,18 @@ NetAgent.prototype.state_init.determineEventSource = function (S) {
     }, function determinedEventSource(err, eventSource) {
         if (err) {
             self.log.error(err, 'error determining event source');
-            S.timeout(1000, function () {
-                S.gotoState('init.determineEventSource');
-            });
+            S.gotoStateTimeout(1000, 'starting.determineEventSource');
             return;
         }
 
         self.log.info('determined best eventSource: %s', eventSource);
         self.eventSource = eventSource;
 
-        S.gotoState('init.startWatcher');
+        S.gotoState('starting.startWatcher');
     });
 };
 
-NetAgent.prototype.state_init.startWatcher = function (S) {
+NetAgent.prototype.state_starting.startWatcher = function (S) {
     S.validTransitions([ 'running' ]);
 
     switch (this.eventSource) {
@@ -339,13 +333,9 @@ NetAgent.prototype.state_init.startWatcher = function (S) {
         throw new VError('unknown event source %j', this.eventSource);
     }
 
-    S.on(this.watcher, 'stateChanged', function (newState) {
-        if (newState === 'waiting') {
-            S.gotoState('running');
-        }
-    });
-
     this.watcher.start();
+
+    S.gotoState('running');
 };
 
 NetAgent.prototype.state_running = function (S) {
diff --git a/lib/net-fsm.js b/lib/net-fsm.js
index df20f4b..ceb436c 100644
--- a/lib/net-fsm.js
+++ b/lib/net-fsm.js
@@ -12,8 +12,6 @@
 
 var assert = require('assert-plus');
 var mod_common = require('./common');
-var mod_jsprim = require('jsprim');
-var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
 
 // --- Globals
@@ -40,6 +38,8 @@ var MAX_NIC_LISTENERS = 512;
 
 /**
  * The NetFSM is responsible for tracking changes related to a single network.
+ * We emit the "changed" event whenever fields responsible for VM and NIC
+ * configurations (DIFF_FIELDS) change so that the NICs can be updated.
  */
 function NetworkFSM(opts) {
     assert.object(opts, 'opts');
@@ -56,9 +56,9 @@ function NetworkFSM(opts) {
     this.old = null;
     this.cur = null;
 
-    mod_mooremachine.FSM.call(this, 'init');
+    mod_common.CommonFSM.call(this);
 }
-mod_util.inherits(NetworkFSM, mod_mooremachine.FSM);
+mod_util.inherits(NetworkFSM, mod_common.CommonFSM);
 
 NetworkFSM.prototype.state_init = function (S) {
     this.setMaxListeners(MAX_NIC_LISTENERS);
@@ -71,20 +71,16 @@ NetworkFSM.prototype.state_init = function (S) {
 NetworkFSM.prototype.state_waiting = function (S) {
     S.validTransitions([ 'refresh' ]);
 
-    if (!mod_jsprim.deepEqual(this.old, this.cur)) {
-        this.emit('updated', this.cur);
-    }
-
     /*
      * Refresh periodically.
      */
-    S.timeout(5 * 60 * 1000, function () {
-        S.gotoState('refresh');
-    });
+    S.gotoStateTimeout(5 * 60 * 1000, 'refresh');
 
-    S.on(this, 'refreshAsserted', function () {
-        S.gotoState('refresh');
-    });
+    S.gotoStateOn(this, 'refreshAsserted', 'refresh');
+
+    if (mod_common.hasChanged(DIFF_FIELDS, this.cur, this.old)) {
+        this.emitDelayed('changed', 0);
+    }
 };
 
 NetworkFSM.prototype.state_refresh = function (S) {
@@ -111,16 +107,10 @@ NetworkFSM.prototype.state_refresh = function (S) {
 
         self.cur = net;
 
-        if (mod_common.hasChanged(DIFF_FIELDS, self.cur, self.old)) {
-            self.emit('changed');
-        }
-
         S.gotoState('waiting');
     }
 
-    S.on(self, 'stopAsserted', function () {
-        S.gotoState('stopped');
-    });
+    S.gotoStateOn(self, 'stopAsserted', 'stopped');
 
     self.log.info('Refreshing network information');
     self.app.napi.getNetwork(self.uuid, S.callback(afterGet));
@@ -129,9 +119,7 @@ NetworkFSM.prototype.state_refresh = function (S) {
 NetworkFSM.prototype.state_stopped = function (S) {
     S.validTransitions([ 'refresh' ]);
 
-    S.on(this, 'refreshAsserted', function () {
-        S.gotoState('refresh');
-    });
+    S.gotoStateOn(this, 'refreshAsserted', 'refresh');
 };
 
 NetworkFSM.prototype.refresh = function () {
diff --git a/lib/nic-fsm.js b/lib/nic-fsm.js
index dd4c1bc..18b1d1d 100644
--- a/lib/nic-fsm.js
+++ b/lib/nic-fsm.js
@@ -13,7 +13,6 @@
 var assert = require('assert-plus');
 var mod_common = require('./common');
 var mod_jsprim = require('jsprim');
-var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
 
 // --- Globals
@@ -151,10 +150,6 @@ function NicFSM(opts) {
         mac: this.mac
     }, true);
 
-    this.pending = {
-        refresh: false,
-        update: false
-    };
     this.released = null;
 
     this.needVmUpdate = false;
@@ -170,9 +165,9 @@ function NicFSM(opts) {
 
     this.network = null;
 
-    mod_mooremachine.FSM.call(this, 'init');
+    mod_common.CommonFSM.call(this);
 }
-mod_util.inherits(NicFSM, mod_mooremachine.FSM);
+mod_util.inherits(NicFSM, mod_common.CommonFSM);
 
 NicFSM.prototype.state_init = function (S) {
     S.immediate(function () {
@@ -184,13 +179,9 @@ NicFSM.prototype.state_init = function (S) {
  * Wait for external events to force us to recompare.
  */
 NicFSM.prototype.state_waiting = function (S) {
-    S.on(this, 'setAsserted', function () {
-        S.gotoState('update');
-    });
-
-    S.on(this, 'refreshAsserted', function () {
-        S.gotoState('refresh');
-    });
+    S.gotoStateOn(this, 'setAsserted', 'update');
+    S.gotoStateOn(this, 'refreshAsserted', 'refresh');
+    S.gotoStateOn(this, 'releaseAsserted', 'release');
 
     /*
      * Refresh periodically.
@@ -200,18 +191,10 @@ NicFSM.prototype.state_waiting = function (S) {
      * to let us know when something important changes. If NIC-specific
      * properties like spoofing parameters change, we'll eventually fix them.
      */
-    S.timeout(60 * 60 * 1000, function () {
-        S.gotoState('refresh');
-    });
-
-    S.on(this, 'releaseAsserted', function () {
-        S.gotoState('release');
-    });
+    S.gotoStateTimeout(60 * 60 * 1000, 'refresh');
 
     if (this.network !== null) {
-        S.on(this.network, 'changed', function () {
-            S.gotoState('refresh');
-        });
+        S.gotoStateOn(this.network, 'changed', 'refresh');
     }
 };
 
@@ -225,13 +208,8 @@ NicFSM.prototype.state_refresh = function (S) {
         'update'
     ]);
 
-    S.on(self, 'refreshAsserted', function () {
-        S.gotoState('refresh');
-    });
-
-    S.on(self, 'releaseAsserted', function () {
-        S.gotoState('release');
-    });
+    S.gotoStateOn(self, 'refreshAsserted', 'refresh');
+    S.gotoStateOn(self, 'releaseAsserted', 'release');
 
     function afterGet(err, nic, _, res) {
         if (err) {
@@ -247,9 +225,7 @@ NicFSM.prototype.state_refresh = function (S) {
             self.log.warn(err,
                 'Failed to refresh NIC information; ' +
                 'retrying in 5 seconds');
-            S.timeout(5000, function () {
-                S.gotoState('refresh');
-            });
+            S.gotoStateTimeout(5000, 'refresh');
             return;
         }
 
@@ -298,9 +274,7 @@ NicFSM.prototype.state_create = function (S) {
             self.log.warn(err,
                 'Failed to create NIC in NAPI; ' +
                 'scheduling state refresh');
-            S.timeout(5000, function () {
-                S.gotoState('refresh');
-            });
+            S.gotoStateTimeout(5000, 'refresh');
             return;
         }
 
@@ -364,9 +338,7 @@ NicFSM.prototype.state_update = function (S) {
         return;
     }
 
-    S.on(this, 'refreshAsserted', function () {
-        S.gotoState('refresh');
-    });
+    S.gotoStateOn(this, 'refreshAsserted', 'refresh');
 
     S.gotoState('update.local');
 };
@@ -394,9 +366,7 @@ NicFSM.prototype.state_update.local = function (S) {
         return;
     }
 
-    S.on(this, 'releaseAsserted', function () {
-        S.gotoState('release');
-    });
+    S.gotoStateOn(this, 'releaseAsserted', 'release');
 
     function afterUpdate(err) {
         if (err) {
@@ -542,9 +512,7 @@ NicFSM.prototype.state_remove = function (S) {
         if (err) {
             self.log.error(err, 'Failed to update NIC on VM %s',
                 self.local.belongs_to_uuid);
-            S.timeout(5000, function () {
-                S.gotoState('remove');
-            });
+            S.gotoStateTimeout(5000, 'remove');
             return;
         }
 
@@ -607,9 +575,7 @@ NicFSM.prototype.state_release.delete = function (S) {
                 return;
             }
 
-            S.timeout(5000, function () {
-                S.gotoState('release.delete');
-            });
+            S.gotoStateTimeout(5000, 'release.delete');
             return;
         }
 
@@ -636,9 +602,7 @@ NicFSM.prototype.state_release.refresh = function (S) {
             self.log.warn(err,
                 'Failed to refresh NIC information for release; ' +
                 'retrying in 5 seconds');
-            S.timeout(5000, function () {
-                S.gotoState('release.refresh');
-            });
+            S.gotoStateTimeout(5000, 'release.refresh');
             return;
         }
 
@@ -667,16 +631,7 @@ NicFSM.prototype.setLocal = function (nic) {
     var self = this;
 
     self.local = nic;
-
-    if (self.pending.update) {
-        return;
-    }
-
-    self.pending.update = true;
-    setImmediate(function () {
-        self.pending.update = false;
-        self.emit('setAsserted');
-    });
+    self.emitDelayed('setAsserted', 0);
 };
 
 /**
@@ -704,15 +659,7 @@ NicFSM.prototype.refresh = function (etag) {
         return;
     }
 
-    if (self.pending.refresh) {
-        return;
-    }
-
-    self.pending.refresh = true;
-    setImmediate(function () {
-        self.pending.refresh = false;
-        self.emit('refreshAsserted');
-    });
+    self.emitDelayed('refreshAsserted', 0);
 };
 
 NicFSM.prototype.releaseFrom = function (belongs_to_uuid) {
diff --git a/lib/server-fsm.js b/lib/server-fsm.js
index 21602d3..fdaaf72 100644
--- a/lib/server-fsm.js
+++ b/lib/server-fsm.js
@@ -14,7 +14,6 @@ var assert = require('assert-plus');
 var mod_common = require('./common');
 var mod_forkexec = require('forkexec');
 var mod_jsprim = require('jsprim');
-var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
 
 // --- Globals
@@ -73,22 +72,20 @@ function ServerFSM(opts) {
      */
     this.loadSysinfo = opts.loadSysinfo || loadSysinfo;
 
-    mod_mooremachine.FSM.call(this, 'init');
+    mod_common.CommonFSM.call(this);
 }
-mod_util.inherits(ServerFSM, mod_mooremachine.FSM);
+mod_util.inherits(ServerFSM, mod_common.CommonFSM);
 
 ServerFSM.prototype.state_init = function (S) {
-    S.validTransitions([ 'refresh' ]);
-
-    S.gotoState('refresh');
+    S.immediate(function () {
+        S.gotoState('refresh');
+    });
 };
 
 ServerFSM.prototype.state_waiting = function (S) {
     S.validTransitions([ 'refresh' ]);
 
-    S.on(this, 'refreshAsserted', function () {
-        S.gotoState('refresh');
-    });
+    S.gotoStateOn(this, 'refreshAsserted', 'refresh');
 };
 
 ServerFSM.prototype.state_refresh = function (S) {
@@ -98,9 +95,7 @@ ServerFSM.prototype.state_refresh = function (S) {
 
     function retry(err) {
         self.log.error(err, 'failed to fetch new sysinfo');
-        S.timeout(5000, function () {
-            S.gotoState('refresh');
-        });
+        S.gotoStateTimeout(5000, 'refresh');
     }
 
     self.loadSysinfo(function _onSysinfo(err, sysinfo) {
diff --git a/lib/utils.js b/lib/utils.js
deleted file mode 100644
index 0697d1c..0000000
--- a/lib/utils.js
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2019 Joyent, Inc.
- */
-
-'use strict';
-
-/*
- * Get monotonic time in milliseconds.
- *
- * Note that this is *not* the same as Date.now(), which returns the current
- * wall clock time in milliseconds.
- */
-function currentMillis() {
-    var time = process.hrtime();
-    var secs2ms = time[0] * 1000;
-    var ns2ms = time[1] / 1000000;
-
-    return (secs2ms + ns2ms);
-}
-
-
-module.exports = {
-    currentMillis: currentMillis
-};
diff --git a/lib/vmadm-watcher-fsm.js b/lib/vmadm-watcher-fsm.js
index cf45ed8..34e6036 100644
--- a/lib/vmadm-watcher-fsm.js
+++ b/lib/vmadm-watcher-fsm.js
@@ -11,11 +11,9 @@
 'use strict';
 
 var assert = require('assert-plus');
-var mod_mooremachine = require('mooremachine');
+var mod_common = require('./common');
 var mod_util = require('util');
 
-var currentMillis = require('./utils').currentMillis;
-
 // --- Globals
 
 /*
@@ -58,22 +56,15 @@ function VmadmEventsFSM(opts) {
     self.stopWatcher = null;
     self.vmadm = opts.vmadm;
 
-    self.lastUpdate = 0;
-    self.pending = {
-        vmsUpdate: false
-    };
-
-    mod_mooremachine.FSM.call(self, 'waiting');
+    mod_common.CommonFSM.call(self);
 }
-mod_util.inherits(VmadmEventsFSM, mod_mooremachine.FSM);
+mod_util.inherits(VmadmEventsFSM, mod_common.CommonFSM);
 
-VmadmEventsFSM.prototype.state_waiting = function (S) {
-    S.on(this, 'startAsserted', function () {
-        S.gotoState('init');
-    });
+VmadmEventsFSM.prototype.state_init = function (S) {
+    S.gotoStateOn(this, 'startAsserted', 'setup');
 };
 
-/*
+/**
  * Create the `vmadm events` watcher which gets events for any VM change on the
  * system using vminfod.
  *
@@ -83,7 +74,7 @@ VmadmEventsFSM.prototype.state_waiting = function (S) {
  * latest known state of the VM.  This object is then passed to `app.updateVMs`
  * whenever any change on the system is seen.
  */
-VmadmEventsFSM.prototype.state_init = function (S) {
+VmadmEventsFSM.prototype.state_setup = function (S) {
     var self = this;
 
     self.vms = {};
@@ -96,75 +87,7 @@ VmadmEventsFSM.prototype.state_init = function (S) {
 
     // Called when a new event from `vmadm events` is seen
     function handler(ev) {
-        assert.object(ev, 'ev');
-        assert.optionalObject(ev.vm, 'ev.vm');
-        assert.string(ev.type, 'ev.type');
-        assert.uuid(ev.zonename, 'ev.zonename');
-
-        var needsUpdate = false;
-
-        self.log.trace({ev: ev}, 'saw event from "vmadm events"');
-
-        if (ev.vm && ev.vm.do_not_inventory) {
-            self.ignore[ev.zonename] = true;
-            self.log.debug('VM %s ignored - do_not_inventory set',
-                ev.zonename);
-        } else if (ev.vm && !ev.vm.do_not_inventory) {
-            delete self.ignore[ev.zonename];
-        }
-
-        switch (ev.type) {
-        case 'create':
-            assert.object(ev.vm, 'ev.vm');
-            assert(!self.vms.hasOwnProperty(ev.zonename), 'VM already created');
-
-            self.vms[ev.zonename] = ev.vm;
-            self.log.debug('VM %s created - setting needsUpdate', ev.zonename);
-            needsUpdate = true;
-            break;
-        case 'modify':
-            assert.object(ev.vm, 'ev.vm');
-            assert.arrayOfObject(ev.changes, 'ev.changes');
-            assert(self.vms.hasOwnProperty(ev.zonename), 'VM not found');
-
-            self.vms[ev.zonename] = ev.vm;
-
-            if (self.ignore[ev.zonename]) {
-                break;
-            }
-
-            var changes = ev.changes.filter(function (change) {
-                return (WATCHED_FIELDS.indexOf(change.path[0]) >= 0);
-            });
-
-            if (changes.length > 0) {
-                var keys = changes.map(function (change) {
-                    return change.prettyPath;
-                });
-                self.log.debug(
-                    'VM %s fields updated (%s) - setting needsUpdate',
-                    ev.zonename, keys.join(','));
-                needsUpdate = true;
-            }
-
-            break;
-        case 'delete':
-            delete self.vms[ev.zonename];
-            if (!self.ignore[ev.zonename]) {
-                self.log.debug('VM %s deleted - setting needsUpdate',
-                    ev.zonename);
-                needsUpdate = true;
-            }
-            delete self.ignore[ev.zonename];
-            break;
-        default:
-            assert.fail('unknown vmadm event type: ' + ev.type);
-            break;
-        }
-
-        if (needsUpdate) {
-            self._emitUpdate();
-        }
+        self.handleEvent(ev);
     }
 
     /*
@@ -176,10 +99,8 @@ VmadmEventsFSM.prototype.state_init = function (S) {
         if (err) {
             self.log.error(err, 'vmadm events failed to ready');
 
-            // Try again
-            S.timeout(1000, function () {
-                S.gotoState('init');
-            });
+            // Try again in a second.
+            S.gotoStateTimeout(1000, 'setup');
             return;
         }
 
@@ -201,9 +122,7 @@ VmadmEventsFSM.prototype.state_init = function (S) {
     S.on(self.emitter, 'error', function (err) {
         self.log.error(err, 'vmadm events error');
         self.emitter = null;
-        S.timeout(1000, function () {
-            S.gotoState('init');
-        });
+        S.gotoStateTimeout(1000, 'setup');
     });
 };
 
@@ -215,18 +134,11 @@ VmadmEventsFSM.prototype.state_running = function (S) {
         self.stopWatcher();
         self.stopWatcher = null;
         self.emitter = null;
-        S.timeout(1000, function () {
-            S.gotoState('init');
-        });
+        S.gotoStateTimeout(1000, 'setup');
     });
 
-    S.on(self, 'stopAsserted', function () {
-        S.gotoState('stopped');
-    });
-
-    S.on(self, 'restartAsserted', function () {
-        S.gotoState('init');
-    });
+    S.gotoStateOn(self, 'stopAsserted', 'stopped');
+    S.gotoStateOn(self, 'restartAsserted', 'setup');
 };
 
 VmadmEventsFSM.prototype.state_stopped = function (S) {
@@ -245,6 +157,86 @@ VmadmEventsFSM.prototype.stop = function () {
     self.emit('stopAsserted');
 };
 
+/**
+ * Given an individual event notification sent by vminfod, update our local
+ * copy of the CN's state.
+ */
+VmadmEventsFSM.prototype.handleEvent = function (ev) {
+    assert.object(ev, 'ev');
+    assert.optionalObject(ev.vm, 'ev.vm');
+    assert.string(ev.type, 'ev.type');
+    assert.uuid(ev.zonename, 'ev.zonename');
+
+    var self = this;
+    var needsUpdate = false;
+
+    self.log.trace({ev: ev}, 'saw event from "vmadm events"');
+
+    if (ev.vm && ev.vm.do_not_inventory) {
+        self.ignore[ev.zonename] = true;
+        self.log.debug('VM %s ignored - do_not_inventory set',
+            ev.zonename);
+    } else if (ev.vm && !ev.vm.do_not_inventory) {
+        delete self.ignore[ev.zonename];
+    }
+
+    switch (ev.type) {
+    case 'create':
+        assert.object(ev.vm, 'ev.vm');
+        assert(!self.vms.hasOwnProperty(ev.zonename), 'VM already created');
+
+        self.vms[ev.zonename] = ev.vm;
+        self.log.debug('VM %s created - setting needsUpdate', ev.zonename);
+        needsUpdate = true;
+        break;
+    case 'modify':
+        assert.object(ev.vm, 'ev.vm');
+        assert.arrayOfObject(ev.changes, 'ev.changes');
+        assert(self.vms.hasOwnProperty(ev.zonename), 'VM not found');
+
+        self.vms[ev.zonename] = ev.vm;
+
+        if (self.ignore[ev.zonename]) {
+            break;
+        }
+
+        var changes = ev.changes.filter(function (change) {
+            return (WATCHED_FIELDS.indexOf(change.path[0]) >= 0);
+        });
+
+        if (changes.length > 0) {
+            var keys = changes.map(function (change) {
+                return change.prettyPath;
+            });
+            self.log.debug(
+                'VM %s fields updated (%s) - setting needsUpdate',
+                ev.zonename, keys.join(','));
+            needsUpdate = true;
+        }
+
+        break;
+    case 'delete':
+        delete self.vms[ev.zonename];
+        if (!self.ignore[ev.zonename]) {
+            self.log.debug('VM %s deleted - setting needsUpdate',
+                ev.zonename);
+            needsUpdate = true;
+        }
+        delete self.ignore[ev.zonename];
+        break;
+    default:
+        assert.fail('unknown vmadm event type: ' + ev.type);
+        break;
+    }
+
+    if (needsUpdate) {
+        self._emitUpdate();
+    }
+};
+
+/**
+ * Return the current set of Triton-tracked VMs on this CN.
+ */
 VmadmEventsFSM.prototype.getCurrentVMs = function () {
     var self = this;
 
@@ -257,26 +249,11 @@ VmadmEventsFSM.prototype.getCurrentVMs = function () {
     return vms;
 };
 
+/**
+ * Schedule emitting the "vms-update" event sometime in the next 5 seconds.
+ */
 VmadmEventsFSM.prototype._emitUpdate = function () {
-    var self = this;
-    var wait = 0;
-
-    if (self.pending.vmsUpdate) {
-        return;
-    }
-
-    var now = currentMillis();
-    var next = self.lastUpdate + UPDATE_DELAY;
-    if (next > now) {
-        wait = next - now;
-    }
-
-    self.pending.vmsUpdate = true;
-    setTimeout(function () {
-        self.lastUpdate = currentMillis();
-        self.pending.vmsUpdate = false;
-        self.emit('vms-update');
-    }, wait);
+    this.emitDelayed('vms-update', UPDATE_DELAY);
 };
 
 
@@ -300,20 +277,12 @@ function VmadmWatcherFSM(opts) {
         vmadm: self.vmadm
     });
 
-    self.pending = {
-        refresh: false
-    };
-
-    mod_mooremachine.FSM.call(self, 'init');
+    mod_common.CommonFSM.call(self);
 }
-mod_util.inherits(VmadmWatcherFSM, mod_mooremachine.FSM);
+mod_util.inherits(VmadmWatcherFSM, mod_common.CommonFSM);
 
 VmadmWatcherFSM.prototype.state_init = function (S) {
-    var self = this;
-
-    S.on(self, 'startAsserted', function () {
-        S.gotoState('running');
-    });
+    S.gotoStateOn(this, 'startAsserted', 'running');
 };
 
 VmadmWatcherFSM.prototype.state_running = function (S) {
@@ -343,17 +312,7 @@ VmadmWatcherFSM.prototype.stop = function () {
 };
 
 VmadmWatcherFSM.prototype.refresh = function () {
-    var self = this;
-
-    if (self.pending.refresh) {
-        return;
-    }
-
-    self.pending.refresh = true;
-    setImmediate(function () {
-        self.pending.refresh = false;
-        self.emit('refreshAsserted');
-    });
+    this.emitDelayed('refreshAsserted', 0);
 };
 
 module.exports = VmadmWatcherFSM;
diff --git a/lib/watcher-fsm.js b/lib/watcher-fsm.js
index a38c4f2..3131762 100644
--- a/lib/watcher-fsm.js
+++ b/lib/watcher-fsm.js
@@ -12,12 +12,11 @@
 
 var assert = require('assert-plus');
 var mod_child = require('child_process');
+var mod_common = require('./common');
 var mod_fs = require('fs');
 var mod_jsprim = require('jsprim');
-var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
 
-var currentMillis = require('./utils').currentMillis;
 var LineStream = require('lstream');
 
 // --- Globals
@@ -72,9 +71,9 @@ function ZoneEventFSM(opts) {
     this.stdout = null;
     this.stderr = null;
 
-    mod_mooremachine.FSM.call(this, 'init');
+    mod_common.CommonFSM.call(this);
 }
-mod_util.inherits(ZoneEventFSM, mod_mooremachine.FSM);
+mod_util.inherits(ZoneEventFSM, mod_common.CommonFSM);
 
 ZoneEventFSM.prototype.state_init = function (S) {
     this.proc = mod_child.spawn(ZONEEVENT_CMD, ['-i', 'net-agent'], {
@@ -187,27 +186,18 @@ function WatcherFSM(opts) {
      */
     this.cfgwatcher = mod_fs.watch('/etc/zones', this.refresh.bind(this));
 
-    this.lastRefresh = 0;
-    this.pending = {
-        refresh: false
-    };
-
-    mod_mooremachine.FSM.call(this, 'init');
+    mod_common.CommonFSM.call(this);
 }
-mod_util.inherits(WatcherFSM, mod_mooremachine.FSM);
+mod_util.inherits(WatcherFSM, mod_common.CommonFSM);
 
 WatcherFSM.prototype.state_init = function (S) {
-    S.on(this, 'startAsserted', function () {
-        S.gotoState('refresh');
-    });
+    S.gotoStateOn(this, 'startAsserted', 'refresh');
 };
 
 WatcherFSM.prototype.state_waiting = function (S) {
     var self = this;
 
-    S.on(self, 'refreshAsserted', function doRefresh() {
-        S.gotoState('refresh');
-    });
+    S.gotoStateOn(self, 'refreshAsserted', 'refresh');
 
     function scheduleRefresh() {
         self.refresh();
@@ -225,8 +215,6 @@ WatcherFSM.prototype.state_waiting = function (S) {
 WatcherFSM.prototype.state_refresh = function (S) {
     var self = this;
 
-    self.lastRefresh = currentMillis();
-
     S.on(self, 'refreshAsserted', function () {
         /*
          * If we get a refresh event during a refresh, then that means that our
@@ -236,7 +224,6 @@ WatcherFSM.prototype.state_refresh = function (S) {
          */
         self.log.warn('rescheduling VM information refresh due to ' +
             'already running "vmadm lookup"');
-        self.lastRefresh = currentMillis();
         self.refresh();
     });
 
@@ -272,24 +259,7 @@ WatcherFSM.prototype.stop = function () {
 };
 
 WatcherFSM.prototype.refresh = function () {
-    var self = this;
-    var wait = 0;
-
-    if (self.pending.refresh) {
-        return;
-    }
-
-    var now = currentMillis();
-    var next = self.lastRefresh + REFRESH_DELAY;
-    if (next > now) {
-        wait = next - now;
-    }
-
-    self.pending.refresh = true;
-    setTimeout(function () {
-        self.pending.refresh = false;
-        self.emit('refreshAsserted');
-    }, wait);
+    this.emitDelayed('refreshAsserted', REFRESH_DELAY);
 };
 
 module.exports = WatcherFSM;
diff --git a/package.json b/package.json
index cd620e0..cde1a1f 100644
--- a/package.json
+++ b/package.json
@@ -12,7 +12,7 @@
         "jsprim": "1.4.1",
         "kang": "1.2.0",
         "lstream": "0.0.4",
-        "mooremachine": "2.2.0",
+        "mooremachine": "2.3.0",
         "restify": "4.3.0",
         "sdc-bunyan-serializers": "git+https://github.com/joyent/sdc-bunyan-serializers.git#aefc119",
         "sdc-clients": "^10.5.0",
