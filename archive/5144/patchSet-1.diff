commit 307a2252afe47fad8e6af0ed6549115e2c3c15e5 (refs/changes/44/5144/1)
Author: Josh Wilsdon <josh@wilsdon.ca>
Date:   2018-11-27T10:19:25-08:00 (11 months ago)
    
    TRITON-929 mockcloud should support "sdcadm experimental update-agents"

diff --git a/lib/cli/do_update_agents.js b/lib/cli/do_update_agents.js
index df8e90e..eb99f7e 100644
--- a/lib/cli/do_update_agents.js
+++ b/lib/cli/do_update_agents.js
@@ -21,6 +21,7 @@ var assert = require('assert-plus');
 const crypto = require('crypto');
 const mkdirp = require('mkdirp');
 const uuid = require('node-uuid');
+const semver = require('semver');
 const vasync = require('vasync');
 const ProgressBar = require('progbar').ProgressBar;
 const VError = require('verror');
@@ -32,6 +33,15 @@ const svcadm = require('../svcadm');
 const ur = require('../ur');
 
 
+// Number of concurrent calls to CNAPI. Pulled out of a hat.
+const CNAPI_CONCURRENT_UPDATES = 5;
+
+// These define which version of CNAPI and cn-agent support agents installation
+// using the ServerInstallAgentShar endpoint in CNAPI and related cn-agent task.
+const MIN_AGENTSSHAR_INSTALL_CNAPI_VERSION = '1.18.0';
+const MIN_AGENTSSHAR_INSTALL_CNAGENT_VERSION = '2.6.0';
+
+
 function sha1Path(filePath, cb) {
     const hash = crypto.createHash('sha1');
     const s = fs.createReadStream(filePath);
@@ -44,6 +54,121 @@ function sha1Path(filePath, cb) {
 }
 
 
+function installAgentsShar(serverUuid, url, opts, callback) {
+    assert.uuid(serverUuid, 'serverUuid');
+    assert.string(url, 'url');
+    assert.object(opts, 'opts');
+    assert.object(opts.cnapi, 'opts.cnapi');
+    assert.object(opts.log, 'opts.log');
+    assert.func(callback, 'callback');
+
+    opts.cnapi.post({
+        // restify/http opts
+        path: util.format('/servers/%s/install-agentsshar', serverUuid)
+    }, {
+        // payload
+        url: url
+    }, function calledInstallAgentsShar(err, res) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        // XXX TODO: on SmartOS, we can't just swap out cn-agent since that's
+        //           what we're running this through. How should we deal with
+        //           that?
+
+        opts.log.debug({
+            taskId: res.id,
+            serverUuid: serverUuid,
+            url: url
+        }, 'called install-agentsshar');
+
+        // Wait for task completion
+        waitUntilAgentTaskCompletes(res.id, {
+            cnapi: opts.cnapi,
+            log: opts.log
+        }, callback);
+    });
+}
+
+
+//
+// Poll the task and wait for:
+//
+//  a) CNAPI to return an error (callback will be called with that Error)
+//  b) status to become 'failure' (callback will be called with an Error)
+//  c) status to become 'complete' (callback will be called with no args)
+//  d) opts.timeout ms (default 10 mins) (callback will be called with an Error)
+//
+// Polling will be done by delaying retryFreq ms (default 1 second) between each
+// request for task info.
+//
+function waitUntilAgentTaskCompletes(taskid, opts, callback) {
+    assert.string(taskid, 'taskid');
+    assert.object(opts, 'opts');
+    assert.object(opts.cnapi, 'opts.cnapi');
+    assert.object(opts.log, 'opts.log');
+    assert.optionalNumber(opts.retryFreq, 'opts.retryFreq'); // in ms
+    assert.optionalNumber(opts.timeout, 'opts.timeout'); // in ms
+
+    var retryFreq = opts.retryFreq || 1000; // how much to delay between queries
+    var startTime = Date.now();
+    var timeout = opts.timeout || 600000; // ms after which to give up (10m)
+
+    function _waitTask() {
+        opts.cnapi.getTask(taskid, function _gotTask(err, task) {
+            if (err) {
+                opts.log.error({
+                    err: err,
+                    taskid: taskid
+                }, 'error loading cn-agent task from CNAPI');
+                callback(err);
+                return;
+            }
+
+            if (task.status === 'failure') {
+                opts.log.error({
+                    error: task.history[0].event.error.message,
+                    status: task.status,
+                    taskid: taskid
+                }, 'cn-agent task failed');
+
+                callback(new Error(util.format('cn-agent task %s failed: %s',
+                    taskid,
+                    task.history[0].event.error.message
+                )));
+            } else if (task.status === 'complete') {
+                opts.log.debug({
+                    status: task.status,
+                    taskid: taskid
+                }, 'cn-agent task completed successfully');
+                callback();
+            } else if ((Date.now() - startTime) < timeout) {
+                // Haven't timed out yet, try again after a delay
+                setTimeout(_waitTask, retryFreq);
+            } else {
+                // If we get here, we've timed out.
+                opts.log.error({
+                    elapsed: (Date.now() - startTime),
+                    startTime: startTime,
+                    taskid: taskid,
+                    timeout: timeout
+                }, 'timed out waiting for cn-agent task');
+
+                callback(new Error(util.format(
+                    'timed out after waiting (%d seconds) for cn-agent task',
+                    (timeout / 1000).toFixed(1))));
+            }
+        });
+    }
+
+    // Kick off the first poll (which will retry until timeout).
+    _waitTask();
+}
+
+
+
 /*
  * Fetch a given agent installer image (or if desired, latest), download it,
  * then deploy it on the selected servers.
@@ -327,34 +452,6 @@ UpdateAgents.prototype.exec = function exec(callback) {
     };
 
     vasync.pipeline({arg: context, funcs: [
-        /*
-         * Check for Ur availability first, as we cannot proceed without
-         * it:
-         */
-        function urDiscoveryGetReady(ctx, next) {
-            if (self.justDownload || self.justUpdateSymlink) {
-                next();
-                return;
-            }
-
-            self.sdcadm.getUrConnection(function (err, urconn) {
-                if (err) {
-                    self.log.debug({
-                        err: err
-                    }, 'ur error');
-                    next(new errors.InternalError({
-                        cause: err,
-                        message: 'ur not available (check RabbitMQ)'
-                    }));
-                    return;
-                }
-
-                self.log.debug('ur connected');
-                ctx.urconn = urconn;
-                next();
-            });
-        },
-
         function getChannelIfNeeded(_, next) {
             if (self.agentsshar === 'latest' ||
                 common.UUID_RE.test(self.agentsshar)) {
@@ -394,11 +491,41 @@ UpdateAgents.prototype.exec = function exec(callback) {
             }
             self.progress('Finding servers to update');
             // Get all servers to validate if unsetup servers are selected.
-            self.sdcadm.cnapi.listServers({}, function (err, servers) {
+            self.sdcadm.cnapi.listServers({
+                extras: 'agents'
+            }, function (err, servers, req, res) {
+                var aIdx;
+                var matches;
+                var s;
+                var sIdx;
+
                 if (err) {
                     next(err);
                     return;
                 }
+
+                if (res && res.headers && res.headers.server &&
+                    (matches = res.headers.server.match(/^cnapi\/(.*)$/))) {
+
+                    ctx.cnapiVersion = matches[1];
+                }
+
+                // We only care about cn-agent (because we're trying to
+                // determine whether we can use ServerInstallAgentShar), so
+                // we'll set server.cnAgentVersion and remove server.agents.
+                for (sIdx = 0; sIdx < servers.length; sIdx++) {
+                    s = servers[sIdx];
+                    if (s.agents) {
+                        for (aIdx = 0; aIdx < s.agents.length; aIdx++) {
+                            if (s.agents[aIdx].name === 'cn-agent') {
+                                s.cnAgentVersion = s.agents[aIdx].version;
+                                break;
+                            }
+                        }
+                        delete s.agents;
+                    }
+                }
+
                 ctx.allServers = servers;
                 next();
             });
@@ -461,28 +588,6 @@ UpdateAgents.prototype.exec = function exec(callback) {
             }
         },
 
-        function urDiscovery(ctx, next) {
-            if (self.justDownload || self.justUpdateSymlink) {
-                next();
-                return;
-            }
-
-            common.urDiscovery({
-                sdcadm: self.sdcadm,
-                progress: self.progress,
-                nodes: ctx.serversToUpdate.map(
-                    function (s) { return s.uuid; }),
-                urconn: ctx.urconn
-            }, function (err, urAvailServers) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-                ctx.urServersToUpdate = urAvailServers;
-                next();
-            });
-        },
-
         function earlyAbortForJustDownload(_, next) {
             if (self.justDownload && self.filepath) {
                 self.progress('Agentsshar is already downloaded to %s',
@@ -590,8 +695,182 @@ UpdateAgents.prototype.exec = function exec(callback) {
             steps.usbkey.removeOldAgentsShars(ctx, next);
         },
 
+        function findCnapiUpdatableServers(ctx, next) {
+            var idx;
+            var server;
+
+            ctx.cnapiUpdatableServers = [];
+            ctx.cnapiUpdatedServers = {};
+
+            if (!ctx.cnapiVersion || semver.lt(ctx.cnapiVersion,
+                MIN_AGENTSSHAR_INSTALL_CNAPI_VERSION)) {
+
+                self.progress('CNAPI is too old for ServerInstallAgentsShar, ' +
+                    'proceeding with Ur.');
+
+                next();
+                return;
+            }
+
+            for (idx = 0; idx < ctx.serversToUpdate.length; idx++) {
+                server = ctx.serversToUpdate[idx];
+                if (server.cnAgentVersion && semver.gte(server.cnAgentVersion,
+                    MIN_AGENTSSHAR_INSTALL_CNAGENT_VERSION)) {
+
+                    ctx.cnapiUpdatableServers.push(server);
+                }
+            }
+
+            next();
+        },
+        function updateCnapiUpdatableServers(ctx, next) {
+
+            // What we really want here is to do something like
+            // vasync.forEachParallel but with a limit on the number of
+            // concurrent executions. Since vasync does not support that, we'll
+            // instead use a vasync.queue which *does* support a concurrency
+            // value.
+
+            var bar;
+            var failures = [];
+            var queue;
+            var url = 'http://' + self.sdcadm.config.assets_admin_ip +
+                '/extra/agents/' + ctx.fname;
+
+            if (ctx.cnapiUpdatableServers.length > 0) {
+                self.progress(
+                    'Updating servers which support updates via CNAPI');
+                if (process.stderr.isTTY) {
+                    // Setup a progress bar if possible.
+                    bar = new ProgressBar({
+                        size: ctx.cnapiUpdatableServers.length,
+                        bytes: false,
+                        filename: 'Installing agentsshar (' +
+                            ctx.cnapiUpdatableServers.length + ' servers)'
+                    });
+                    bar.draw();
+                }
+            } else {
+                next();
+                return;
+            }
+
+            function _updateServerUsingCnapi(server, cb) {
+                //
+                // call cnapi
+                //
+                // POST /servers/<server.uuid>/install-agentsshar
+                //
+                //  { url: url }
+                //
+                installAgentsShar(server.uuid, url, {
+                    cnapi: self.sdcadm.cnapi,
+                    log: self.sdcadm.log
+                }, function _onInstalledAgentsShar(err) {
+                    if (!err) {
+                        // we succeeded, mark this server as updated
+                        ctx.cnapiUpdatedServers[server.uuid] = true;
+                    }
+                    // Update progress bar.
+                    if (bar) {
+                        bar.advance(1);
+                    }
+                    cb(err);
+                });
+            }
+
+            queue = vasync.queue(_updateServerUsingCnapi, CNAPI_CONCURRENT_UPDATES);
+
+            // Add all the updatable servers to the queue.
+            ctx.cnapiUpdatableServers.forEach(function _pushQueue(s) {
+                queue.push(s);
+            });
+
+            queue.once('end', function doneQueue(err) {
+                // End progress bar.
+                if (bar) {
+                    bar.end();
+                }
+                self.progress('Updated %d/%d servers successfully via CNAPI',
+                    Object.keys(ctx.cnapiUpdatedServers).length,
+                    ctx.cnapiUpdatableServers.length
+                );
+                next();
+            });
+
+            queue.close();
+        },
+        function removeAlreadyUpdatedServers(ctx, next) {
+            ctx.serversToUpdate =
+                ctx.serversToUpdate.filter(function _removeUpdated(s) {
+
+                return (ctx.cnapiUpdatedServers[s.uuid] !== true);
+            });
+
+            self.progress('%d servers remaining to update via Ur',
+                ctx.serversToUpdate.length);
+
+            next();
+        },
+
+        /*
+         * Check for Ur availability first, as we cannot proceed without
+         * it if we have servers left to update:
+         */
+        function urDiscoveryGetReady(ctx, next) {
+            if (self.justDownload || self.justUpdateSymlink ||
+                ctx.serversToUpdate.length === 0) {
+
+                next();
+                return;
+            }
+
+            self.sdcadm.getUrConnection(function (err, urconn) {
+                if (err) {
+                    self.log.debug({
+                        err: err
+                    }, 'ur error');
+                    next(new errors.InternalError({
+                        cause: err,
+                        message: 'ur not available (check RabbitMQ)'
+                    }));
+                    return;
+                }
+
+                self.log.debug('ur connected');
+                ctx.urconn = urconn;
+                next();
+            });
+        },
+
+        function urDiscovery(ctx, next) {
+            if (self.justDownload || self.justUpdateSymlink ||
+                ctx.serversToUpdate.length === 0) {
+
+                next();
+                return;
+            }
+
+            common.urDiscovery({
+                sdcadm: self.sdcadm,
+                progress: self.progress,
+                nodes: ctx.serversToUpdate.map(
+                    function (s) { return s.uuid; }),
+                urconn: ctx.urconn
+            }, function (err, urAvailServers) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                ctx.urServersToUpdate = urAvailServers;
+                next();
+            });
+        },
+
         function updateCNAgents(ctx, next) {
-            if (self.justDownload || self.justUpdateSymlink) {
+            if (self.justDownload || self.justUpdateSymlink ||
+                ctx.serversToUpdate.length === 0) {
+
                 next();
                 return;
             }
