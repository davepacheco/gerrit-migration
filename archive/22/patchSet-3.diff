From c4e5d41c57a4813f3900e6f5b082e3b046effe6c Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Wed, 29 Jun 2016 15:43:13 -0700
Subject: [PATCH] wip: new resolver fsm

---
 README.md                    | 118 +++++++++++++++++++------
 bin/cbresolve                |  17 ++--
 lib/resolver.js              | 161 ++++++++++++++++++++++++++++-------
 test/pool.test.js            |   3 +-
 test/resolver_for.test.js    |  12 +--
 test/resolver_static.test.js |   4 +-
 6 files changed, 242 insertions(+), 73 deletions(-)

diff --git a/README.md b/README.md
index c491a72..8c1a5e0 100644
--- a/README.md
+++ b/README.md
@@ -78,7 +78,7 @@ Parameters
   - `ping` -- optional String, URL path to use for health checking. Connection
     is considered still viable if this URL returns a non-5xx response code.
   - `pingInterval` -- optional Number, interval between health check pings
-  - `errorOnEmpty` -- optional Boolean, 
+  - `errorOnEmpty` -- optional Boolean
 
 ## Pool
 
@@ -91,19 +91,19 @@ parameters with which to create the default, DNS-based resolver.
 Parameters
 
 - `options` -- Object, with keys:
-  - `constructor` -- Function(backend) -> object, must open a new connection 
+  - `constructor` -- Function(backend) -> object, must open a new connection
     to the given backend and return it
   - `domain` -- String, name to look up to find backends.
   - `recovery` -- Object, a recovery spec (see below)
   - `service` -- optional String, name of SRV service (e.g. `_http._tcp`)
   - `defaultPort` -- optional Number, port to use for plain A/AAAA records
   - `resolvers` -- optional Array of String, either containing IP addresses to
-    use as nameservers, or a single string for Dynamic Resolver mode (default 
+    use as nameservers, or a single string for Dynamic Resolver mode (default
     uses system resolvers from `/etc/resolv.conf`)
   - `log` -- optional Object, a `bunyan`-style logger to use
   - `spares` -- optional Number, number of spares wanted in the pool per host
   - `maximum` -- optional Number, maximum number of connections per host
-  - `maxDNSConcurrency` -- optional Number, max number of DNS queries to issue 
+  - `maxDNSConcurrency` -- optional Number, max number of DNS queries to issue
     at once (default 5)
   - `checkTimeout` -- optional Number, milliseconds of idle time before
     running `checker` on a connection
@@ -143,9 +143,9 @@ Parameters
 - `callback` -- Function(err[, handle, connection]), parameters:
   - `err` -- an Error object, if the request could not be fulfilled or timed
     out
-  - `handle` -- Object, handle to be used to release the connection back to 
+  - `handle` -- Object, handle to be used to release the connection back to
     the pool when work is complete
-  - `connection` -- Object, the actual connection (as returned by the 
+  - `connection` -- Object, the actual connection (as returned by the
     `constructor` given to `new ConnectionPool()`)
 
 Returns either `undefined` (if the callback was called immediately), or a
@@ -166,26 +166,50 @@ Returns an Object with keys:
  - `handle` -- Object, handle to be used to release the connection
  - `connection` -- Object, actual connection
 
-## DNS-based Resolver
+## Resolver
 
-### `new mod_cueball.Resolver(options)`
+### `mod_cueball.Resolver` interface
 
-Creates a "resolver" -- an object which tracks a given service in DNS and
-emits events when backends are added or removed.
+An interface for all "resolvers", objects which take in some kind of
+configuration (e.g. a DNS name) and track a list of "backends" for that
+name. A "backend" is an IP/port pair that describes an endpoint that can
+be connected to to reach a given service.
 
-Parameters
+Resolver exposes the `mooremachine` FSM interface, with the following state
+graph:
 
-- `options` -- Object, with keys:
-  - `domain` -- String, name to look up to find backends
-  - `recovery` -- Object, a recovery spec (see below)
-  - `service` -- optional String, name of SRV service (e.g. `_http._tcp`)
-  - `defaultPort` -- optional Number, port to use for plain A/AAAA records
-  - `resolvers` -- optional Array of String, either containing IP addresses to
-    use as nameservers, or a single string for Dynamic Resolver mode (default 
-    uses system resolvers from `/etc/resolv.conf`)
-  - `log` -- optional Object, a `bunyan`-style logger to use
-  - `maxDNSConcurrency` -- optional Number, max number of DNS queries to issue 
-    at once (default 5)
+                    .start()          error
+            +-------+       +--------+       +------+
+    init -> |stopped| +---> |starting| +---> |failed|
+            +---+---+       +---+----+       +------+
+                ^               |               +
+                |               | ok            |
+                |               v               |
+            +---+----+      +---+---+           |
+            |stopping| <--+ |running|  <--------+
+            +--------+      +-------+       retry success
+                     .stop()
+
+Resolvers begin their life "stopped". When the user calls `.start()`, they
+begin the process of resolving the name/configuration they were given into
+backends.
+
+If the initial attempt to resolve the name/configuration fails, the Resolver
+enters the "failed" state, but continues retrying. If it succeeds, or if any
+later retry succeeds, it moves to the "running" state. The reason why the
+"failed" state exists is so that commandline tools and other short-lived
+processes can make use of it to decide when to "give up" on a name resolution.
+
+Once an attempt has succeeded, the Resolver will begin emitting `added` and
+`removed` events (see below) describing the backends that it has found.
+
+In the "running" state, the Resolver continues to monitor the source of its
+backends (e.g. in DNS by retrying once the TTL expires) and emitting these
+events when changes occur.
+
+Finally, when the `.stop()` method is called, the Resolver transitions to
+"stopping", stops monitoring and emitting events, and comes to rest in the
+"stopped" state where it started.
 
 ### `Resolver#start()`
 
@@ -197,9 +221,27 @@ the names given).
 Stops the resolver. No further events will be emitted unless `start()` is
 called again.
 
+### `Resolver#getLastError()`
+
+Returns the last error experienced by the Resolver. This is particularly useful
+when the Resolver is in the "failed" state, to produce a log message or user
+interface text.
+
+### `Resolver#getState()`
+
+Returns the current state of the Resolver as a string (see diagram above).
+
+Inherited from `mod_mooremachine.FSM`.
+
+### `Resolver#onState(state, cb)`
+
+Registers an event handler to run when the Resolver enters the given state.
+
+Inherited from `mod_mooremachine.FSM`.
+
 ### Event `Resolver->added(key, backend)`
 
-Emitted when a new backend has been found in DNS.
+Emitted when a new backend has been found.
 
 Parameters
  - `key` -- String, a unique key for this backend (will be referenced by any
@@ -211,11 +253,33 @@ Parameters
 
 ### Event `Resolver->removed(key)`
 
-Emitted when an existing backend has been removed from DNS.
+Emitted when an existing backend has been removed.
 
 Parameters
  - `key` -- String, unique key for this backend
 
+## DNS-based name resolver
+
+### `new mod_cueball.DNSResolver(options)`
+
+Creates a Resolver that looks up a name in DNS. This Resolver prefers SRV
+records if they are available, and falls back to A/AAAA records if they cannot
+be found.
+
+Parameters
+
+- `options` -- Object, with keys:
+  - `domain` -- String, name to look up to find backends
+  - `recovery` -- Object, a recovery spec (see below)
+  - `service` -- optional String, name of SRV service (e.g. `_http._tcp`)
+  - `defaultPort` -- optional Number, port to use for plain A/AAAA records
+  - `resolvers` -- optional Array of String, either containing IP addresses to
+    use as nameservers, or a single string for Dynamic Resolver mode (default
+    uses system resolvers from `/etc/resolv.conf`)
+  - `log` -- optional Object, a `bunyan`-style logger to use
+  - `maxDNSConcurrency` -- optional Number, max number of DNS queries to issue
+    at once (default 5)
+
 ## Static IP resolver
 
 ### `new mod_cueball.StaticIpResolver(options)`
@@ -336,7 +400,7 @@ before using.
 
 ## Recovery objects
 
-To specify the retry and timeout behaviour of Cueball DNS and pooled 
+To specify the retry and timeout behaviour of Cueball DNS and pooled
 connections, the "recovery spec object" is a required argument to most
 constructors in the API.
 
@@ -367,12 +431,12 @@ This specifies that DNS-related operations should have a timeout of 5 seconds,
 `connect()` while connecting to a new backend) should have a timeout of 2
 seconds, 3 retries and initial delay of 100ms.
 
-The `delay` field indicates a time to wait between retry attempts. After each 
+The `delay` field indicates a time to wait between retry attempts. After each
 failure, it will be doubled until it exceeds the value of `maxDelay`.
 
 The possible fields in one operation are:
  - `retries` finite Number >= 0, number of retry attempts
- - `timeout` finite Number > 0, milliseconds to wait before declaring an 
+ - `timeout` finite Number > 0, milliseconds to wait before declaring an
    attempt a failure
  - `maxTimeout` Number > `timeout` (can be `Infinity`), maximum value of
    `timeout` to be reached with exponential timeout increase
diff --git a/bin/cbresolve b/bin/cbresolve
index 0931766..21d6d18 100755
--- a/bin/cbresolve
+++ b/bin/cbresolve
@@ -208,7 +208,8 @@ function main()
 	cbrResolver.on('removed', cbrPrintRemoved);
 
 	if (!cbrFollow) {
-		cbrResolver.on('updated', cbrUpdated);
+		cbrResolver.onState('running', cbrRunning);
+		cbrResolver.onState('failed', cbrFailed);
 		process.on('exit', function (code) {
 			if (code === 0) {
 				mod_assert.ok(cbrDone, 'premature exit');
@@ -336,16 +337,22 @@ function cbrPrintRemoved(key)
  * Invoked in non-follow mode once the resolver has finished emitting the first
  * set of backends.
  */
-function cbrUpdated()
+function cbrRunning()
 {
 	mod_assert.ok(!cbrFollow);
 	cbrResolver.stop();
 	cbrDone = true;
+	mod_assert.ok(cbrNbackends > 0);
+}
 
-	if (cbrNbackends === 0) {
-		console.error('error: no backends found');
-		process.exit(1);
+function cbrFailed()
+{
+	if (process.env.DEBUG) {
+		console.error(cbrResolver.getLastError().stack);
+	} else {
+		console.error('error: %s', cbrResolver.getLastError().message);
 	}
+	process.exit(1);
 }
 
 main();
diff --git a/lib/resolver.js b/lib/resolver.js
index 35586a5..081c970 100644
--- a/lib/resolver.js
+++ b/lib/resolver.js
@@ -7,8 +7,12 @@
  */
 
 module.exports = {
-	Resolver: CueBallResolver,
+	/* This name is for compatibility with pre-0.4 cueball */
+	Resolver: CueBallDNSResolver,
+
+	DNSResolver: CueBallDNSResolver,
 	StaticIpResolver: CueBallStaticResolver,
+
 	resolverForIpOrDomain: resolverForIpOrDomain,
 
 	/* exposed for testing only */
@@ -28,6 +32,7 @@ const mod_bunyan = require('bunyan');
 const mod_ipaddr = require('ipaddr.js');
 const mod_fs = require('fs');
 const mod_crypto = require('crypto');
+const mod_verror = require('verror');
 
 const FSM = mod_mooremachine.FSM;
 const EventEmitter = mod_events.EventEmitter;
@@ -54,6 +59,90 @@ const EventEmitter = mod_events.EventEmitter;
  * whether the user provides a DNS hostname or an IP address.
  */
 
+function CueBallResolver(fsm, options) {
+	mod_assert.object(options, 'options');
+
+	mod_assert.object(fsm, 'fsm');
+	this.r_fsm = fsm;
+
+	this.r_fsm.on('added', this.emit.bind(this, 'added'));
+	this.r_fsm.on('removed', this.emit.bind(this, 'removed'));
+
+	mod_assert.optionalObject(options.log, 'options.log');
+	this.r_log = options.log || mod_bunyan.createLogger({
+		name: 'CueBallResolver'
+	});
+
+	FSM.call(this, 'stopped');
+}
+mod_util.inherits(CueBallResolver, FSM);
+
+CueBallResolver.prototype.start = function () {
+	this.emit('startAsserted');
+};
+
+CueBallResolver.prototype.stop = function () {
+	this.emit('stopAsserted');
+};
+
+CueBallResolver.prototype.count = function () {
+	return (this.r_fsm.count());
+};
+
+CueBallResolver.prototype.list = function () {
+	return (this.r_fsm.list());
+};
+
+CueBallResolver.prototype.getLastError = function () {
+	return (this.r_lastError);
+};
+
+CueBallResolver.prototype.state_stopped = function (on) {
+	var self = this;
+	on(this, 'startAsserted', function () {
+		self.gotoState('starting');
+	});
+};
+
+CueBallResolver.prototype.state_starting = function (on) {
+	var self = this;
+	this.r_fsm.start();
+	on(this.r_fsm, 'updated', function (err) {
+		if (err) {
+			self.r_lastError = err;
+			self.gotoState('failed');
+		} else {
+			self.gotoState('running');
+		}
+	});
+	on(this, 'stopAsserted', function () {
+		self.gotoState('stopping');
+	});
+};
+
+CueBallResolver.prototype.state_running = function (on) {
+	var self = this;
+	on(this, 'stopAsserted', function () {
+		self.gotoState('stopping');
+	});
+};
+
+CueBallResolver.prototype.state_failed = function (on) {
+	var self = this;
+	on(this.r_fsm, 'updated', function (err) {
+		if (!err)
+			self.gotoState('running');
+	});
+	on(this, 'stopAsserted', function () {
+		self.gotoState('stopping');
+	});
+};
+
+CueBallResolver.prototype.state_stopping = function (on) {
+	this.r_fsm.stop();
+	this.gotoState('stopped');
+};
+
 /*
  * DNS-based Resolver
  *
@@ -83,7 +172,7 @@ const EventEmitter = mod_events.EventEmitter;
  * zero impact just like any other service, by removing them from DNS and
  * waiting until traffic subsides.
  */
-function CueBallResolver(options) {
+function CueBallDNSResolver(options) {
 	mod_assert.object(options);
 	mod_assert.optionalArrayOfString(options.resolvers,
 	    'options.resolvers');
@@ -101,7 +190,7 @@ function CueBallResolver(options) {
 
 	mod_assert.optionalObject(options.log, 'options.log');
 	this.r_log = options.log || mod_bunyan.createLogger({
-		name: 'CueBallResolver'
+		name: 'CueBallDNSResolver'
 	});
 	this.r_log = this.r_log.child({domain: this.r_domain});
 
@@ -157,25 +246,27 @@ function CueBallResolver(options) {
 	this.r_stopping = false;
 
 	FSM.call(this, 'init');
+
+	return (new CueBallResolver(this, options));
 }
-mod_util.inherits(CueBallResolver, FSM);
+mod_util.inherits(CueBallDNSResolver, FSM);
 
-CueBallResolver.bootstrapResolvers = {};
+CueBallDNSResolver.bootstrapResolvers = {};
 
-CueBallResolver.prototype.start = function () {
+CueBallDNSResolver.prototype.start = function () {
 	this.emit('startAsserted');
 };
 
-CueBallResolver.prototype.stop = function (cb) {
+CueBallDNSResolver.prototype.stop = function (cb) {
 	this.r_stopping = true;
 	this.emit('stopAsserted');
 };
 
-CueBallResolver.prototype.count = function () {
+CueBallDNSResolver.prototype.count = function () {
 	return (Object.keys(this.r_backends).length);
 };
 
-CueBallResolver.prototype.list = function () {
+CueBallDNSResolver.prototype.list = function () {
 	var self = this;
 	var ret = {};
 	Object.keys(this.r_backends).forEach(function (k) {
@@ -184,7 +275,7 @@ CueBallResolver.prototype.list = function () {
 	return (ret);
 };
 
-CueBallResolver.prototype.state_init = function (on) {
+CueBallDNSResolver.prototype.state_init = function (on) {
 	var self = this;
 	this.r_stopping = false;
 	on(this, 'startAsserted', function () {
@@ -192,7 +283,7 @@ CueBallResolver.prototype.state_init = function (on) {
 	});
 };
 
-CueBallResolver.prototype.state_check_ns = function (on, once) {
+CueBallDNSResolver.prototype.state_check_ns = function (on, once) {
 	var self = this;
 	if (this.r_resolvers.length > 0) {
 		var notIp = this.r_resolvers.filter(function (r) {
@@ -204,16 +295,17 @@ CueBallResolver.prototype.state_check_ns = function (on, once) {
 		}
 		mod_assert.equal(notIp.length, 1);
 		this.r_resolvers = [];
-		this.r_bootstrap = CueBallResolver.bootstrapResolvers[notIp[0]];
+		this.r_bootstrap =
+		    CueBallDNSResolver.bootstrapResolvers[notIp[0]];
 		if (this.r_bootstrap === undefined) {
-			this.r_bootstrap = new CueBallResolver({
+			this.r_bootstrap = new CueBallDNSResolver({
 				domain: notIp[0],
 				service: '_dns._udp',
 				defaultPort: 53,
 				log: this.r_log,
 				recovery: this.r_recovery
 			});
-			CueBallResolver.bootstrapResolvers[notIp[0]] =
+			CueBallDNSResolver.bootstrapResolvers[notIp[0]] =
 			    this.r_bootstrap;
 		}
 		this.gotoState('bootstrap_ns');
@@ -238,7 +330,7 @@ CueBallResolver.prototype.state_check_ns = function (on, once) {
 	}
 };
 
-CueBallResolver.prototype.state_bootstrap_ns = function (on, once) {
+CueBallDNSResolver.prototype.state_bootstrap_ns = function (on, once) {
 	var self = this;
 	this.r_bootstrap.on('added', function (k, srv) {
 		self.r_bootstrapRes[k] = srv;
@@ -273,14 +365,14 @@ CueBallResolver.prototype.state_bootstrap_ns = function (on, once) {
 	}
 };
 
-CueBallResolver.prototype.state_srv = function () {
+CueBallDNSResolver.prototype.state_srv = function () {
 	var r = this.r_srvRetry;
 	r.delay = r.minDelay;
 	r.count = r.max;
 	this.gotoState('srv_try');
 };
 
-CueBallResolver.prototype.state_srv_try = function (on, once, timeout) {
+CueBallDNSResolver.prototype.state_srv_try = function (on, once, timeout) {
 	var self = this;
 
 	var name = this.r_service + '.' + this.r_domain;
@@ -327,7 +419,7 @@ CueBallResolver.prototype.state_srv_try = function (on, once, timeout) {
 	req.send();
 };
 
-CueBallResolver.prototype.state_srv_error = function (on, once, timeout) {
+CueBallDNSResolver.prototype.state_srv_error = function (on, once, timeout) {
 	var self = this;
 	var r = self.r_srvRetry;
 	if (--r.count > 0) {
@@ -362,13 +454,13 @@ CueBallResolver.prototype.state_srv_error = function (on, once, timeout) {
 	}
 };
 
-CueBallResolver.prototype.state_aaaa = function (on, once, timeout) {
+CueBallDNSResolver.prototype.state_aaaa = function (on, once, timeout) {
 	this.r_srvRem = this.r_srvs.slice();
 	this.r_nextV6 = undefined;
 	this.gotoState('aaaa_next');
 };
 
-CueBallResolver.prototype.state_aaaa_next = function () {
+CueBallDNSResolver.prototype.state_aaaa_next = function () {
 	var r = this.r_retry;
 	r.delay = r.minDelay;
 	r.count = r.max;
@@ -383,7 +475,7 @@ CueBallResolver.prototype.state_aaaa_next = function () {
 	}
 };
 
-CueBallResolver.prototype.state_aaaa_try = function (on, once, timeout) {
+CueBallDNSResolver.prototype.state_aaaa_try = function (on, once, timeout) {
 	var self = this;
 	var srv = this.r_srv;
 
@@ -416,7 +508,7 @@ CueBallResolver.prototype.state_aaaa_try = function (on, once, timeout) {
 	req.send();
 };
 
-CueBallResolver.prototype.state_aaaa_error = function (on, once, timeout) {
+CueBallDNSResolver.prototype.state_aaaa_error = function (on, once, timeout) {
 	var self = this;
 	var r = self.r_retry;
 	if (--r.count > 0) {
@@ -442,13 +534,13 @@ CueBallResolver.prototype.state_aaaa_error = function (on, once, timeout) {
 	}
 };
 
-CueBallResolver.prototype.state_a = function (on, once, timeout) {
+CueBallDNSResolver.prototype.state_a = function (on, once, timeout) {
 	this.r_srvRem = this.r_srvs.slice();
 	this.r_nextV4 = undefined;
 	this.gotoState('a_next');
 };
 
-CueBallResolver.prototype.state_a_next = function () {
+CueBallDNSResolver.prototype.state_a_next = function () {
 	var r = this.r_retry;
 	r.delay = r.minDelay;
 	r.count = r.max;
@@ -463,7 +555,7 @@ CueBallResolver.prototype.state_a_next = function () {
 	}
 };
 
-CueBallResolver.prototype.state_a_try = function (on, once, timeout) {
+CueBallDNSResolver.prototype.state_a_try = function (on, once, timeout) {
 	var self = this;
 	var srv = this.r_srv;
 
@@ -496,7 +588,7 @@ CueBallResolver.prototype.state_a_try = function (on, once, timeout) {
 	req.send();
 };
 
-CueBallResolver.prototype.state_a_error = function (on, once, timeout) {
+CueBallDNSResolver.prototype.state_a_error = function (on, once, timeout) {
 	var self = this;
 	var r = self.r_retry;
 	if (--r.count > 0) {
@@ -522,7 +614,7 @@ CueBallResolver.prototype.state_a_error = function (on, once, timeout) {
 	}
 };
 
-CueBallResolver.prototype.state_process = function () {
+CueBallDNSResolver.prototype.state_process = function () {
 	var self = this;
 
 	var oldBackends = this.r_backends;
@@ -548,10 +640,11 @@ CueBallResolver.prototype.state_process = function () {
 	var newKeys = Object.keys(newBackends);
 
 	if (newKeys.length === 0) {
-		this.r_log.warn(this.r_lastError, 'failed to find any ' +
-		    'backend records for (%s.)%s (more details in TRACE)',
+		var err = new mod_verror.VError(this.r_lastError,
+		    'failed to find any DNS records for (%s.)%s',
 		    this.r_service, this.r_domain);
-		this.emit('updated');
+		this.r_log.warn(err, 'finished processing');
+		this.emit('updated', err);
 		this.gotoState('sleep');
 		return;
 	}
@@ -580,7 +673,7 @@ CueBallResolver.prototype.state_process = function () {
 	this.gotoState('sleep');
 };
 
-CueBallResolver.prototype.state_sleep = function (on, once, timeout) {
+CueBallDNSResolver.prototype.state_sleep = function (on, once, timeout) {
 	var self = this;
 	var now = new Date();
 	var minDelay, state;
@@ -653,7 +746,7 @@ function TimeoutError(name) {
 }
 mod_util.inherits(TimeoutError, Error);
 
-CueBallResolver.prototype.resolve = function (domain, type, timeout) {
+CueBallDNSResolver.prototype.resolve = function (domain, type, timeout) {
 	var opts = {};
 	opts.domain = domain;
 	opts.type = type;
@@ -753,6 +846,8 @@ function CueBallStaticResolver(options) {
 	this.sr_state = 'idle';
 
 	EventEmitter.call(this);
+
+	return (new CueBallResolver(this, options));
 }
 
 mod_util.inherits(CueBallStaticResolver, EventEmitter);
@@ -891,7 +986,7 @@ function parseIpOrDomain(str)
 	ret = {};
 	if (mod_net.isIP(first) === 0) {
 		ret['kind'] = 'dns';
-		ret['cons'] = CueBallResolver;
+		ret['cons'] = CueBallDNSResolver;
 		/* XXX validate DNS domain? */
 		ret['config'] = {
 		    'domain': first
diff --git a/test/pool.test.js b/test/pool.test.js
index 4b3c011..9f2e954 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -31,6 +31,7 @@ function DummyResolver() {
 	resolver = this;
 	this.state = 'stopped';
 	mod_events.EventEmitter.call(this);
+	return (new mod_resolver.ResolverFSM(this, {}));
 }
 mod_util.inherits(DummyResolver, mod_events.EventEmitter);
 DummyResolver.prototype.start = function () {
@@ -225,8 +226,8 @@ mod_tape.test('spares are evenly balanced', function (t) {
 		},
 		recovery: recovery
 	});
+	t.ok(pool);
 	t.ok(resolver);
-	t.strictEqual(pool.p_resolver, resolver);
 
 	resolver.emit('added', 'b1', {});
 	resolver.emit('added', 'b2', {});
diff --git a/test/resolver_for.test.js b/test/resolver_for.test.js
index 7a2c694..ac421b3 100644
--- a/test/resolver_for.test.js
+++ b/test/resolver_for.test.js
@@ -78,7 +78,7 @@ mod_tape.test('parseIpOrDomain: hostname', function (t) {
 	result = mod_resolver.parseIpOrDomain('1.moray.emy-10.joyent.us');
 	t.ok(!(result instanceof Error));
 	t.equal(result.kind, 'dns');
-	t.equal(result.cons.name, 'CueBallResolver');
+	t.equal(result.cons.name, 'CueBallDNSResolver');
 	t.deepEqual(result.config, {
 	    'domain': '1.moray.emy-10.joyent.us'
 	});
@@ -86,7 +86,7 @@ mod_tape.test('parseIpOrDomain: hostname', function (t) {
 	result = mod_resolver.parseIpOrDomain('myservice');
 	t.ok(!(result instanceof Error));
 	t.equal(result.kind, 'dns');
-	t.equal(result.cons.name, 'CueBallResolver');
+	t.equal(result.cons.name, 'CueBallDNSResolver');
 	t.deepEqual(result.config, {
 	    'domain': 'myservice'
 	});
@@ -94,7 +94,7 @@ mod_tape.test('parseIpOrDomain: hostname', function (t) {
 	result = mod_resolver.parseIpOrDomain('myservice:1234');
 	t.ok(!(result instanceof Error));
 	t.equal(result.kind, 'dns');
-	t.equal(result.cons.name, 'CueBallResolver');
+	t.equal(result.cons.name, 'CueBallDNSResolver');
 	t.deepEqual(result.config, {
 	    'domain': 'myservice',
 	    'defaultPort': 1234
@@ -185,7 +185,8 @@ mod_tape.test('resolverForIpOrDomain: static IP', function (t) {
 	    'input': '127.0.0.1:2020'
 	});
 	t.ok(!(result instanceof Error));
-	t.ok(result instanceof mod_resolver.StaticIpResolver);
+	t.ok(result instanceof mod_resolver.ResolverFSM);
+	t.ok(result.r_fsm instanceof mod_resolver.StaticIpResolver);
 	list = result.list();
 	t.equal(1, Object.keys(list).length);
 	t.deepEqual(list[Object.keys(list)[0]], {
@@ -220,7 +221,8 @@ mod_tape.test('resolverForIpOrDomain: hostname', function (t) {
 	    }
 	});
 	t.ok(!(result instanceof Error));
-	t.ok(result instanceof mod_resolver.Resolver);
+	t.ok(result instanceof mod_resolver.ResolverFSM);
+	t.ok(result.r_fsm instanceof mod_resolver.DNSResolver);
 
 	result = mod_resolver.resolverForIpOrDomain({
 	    'input': '1.moray.emy-10.joyent.us:70000'
diff --git a/test/resolver_static.test.js b/test/resolver_static.test.js
index 2b950d1..cf7b99b 100644
--- a/test/resolver_static.test.js
+++ b/test/resolver_static.test.js
@@ -98,7 +98,7 @@ mod_tape.test('static resolver: no backends', function (t) {
 
 	nadded = 0;
 	resolver.on('added', function () { nadded++; });
-	resolver.on('updated', function () {
+	resolver.onState('running', function () {
 		t.equal(nadded, 0);
 		t.deepEqual(resolver.list(), {});
 		t.equal(resolver.count(), 0);
@@ -127,7 +127,7 @@ mod_tape.test('static resolver: several backends', function (t) {
 
 	found = [];
 	resolver.on('added', function (key, backend) { found.push(backend); });
-	resolver.on('updated', function () {
+	resolver.onState('running', function () {
 		var expected;
 
 		t.equal(resolver.count(), 3);
-- 
2.21.0

