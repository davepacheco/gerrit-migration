commit e1421055a1a38933323b6febc6f75e13a90e3866 (refs/changes/81/4481/1)
Author: Jason King <jason.king@joyent.com>
Date:   2018-07-03T17:52:35-05:00 (1 year, 3 months ago)
    
    don't mark pending VL2 entries valid from route response

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index db67401fae..a3ceaefb95 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -1336,13 +1336,18 @@ overlay_target_lookup_respond_vl3(const overlay_targ_resp_t *otr,
 	}
 
 	/*
-	 * Update the VL2 entry if it doesn't have a valid destination. This
-	 * can lead to a slightly strange corner case where an entry is both
-	 * valid and pending (if there is still an outstanding VL2 request).
-	 * In such a case, the VL2 response will just overwrite the destination
-	 * with the same results and clear the pending flag.
+	 * Update the VL2 entry if it doesn't have a valid destination, hasn't
+	 * been marked as dropping all packets, and doesn't have an existing
+	 * outstanding request.  If a route and VL2 request involving the
+	 * same VL2 destination are pending and the route response is processed
+	 * prior to the VL2 request, we will continue to queue (on the VL2
+	 * entry) until the VL2 response is received, even though we have
+	 * an answer from the route response.  If we set the valid flag
+	 * while there's still oustanding requests, it will cause problems
+	 * with the outstanding requests.
 	 */
-	if ((vl2_entry->ote_flags & (OVERLAY_ENTRY_F_VALID)) == 0) {
+	if ((vl2_entry->ote_flags & (OVERLAY_ENTRY_F_PENDING|
+	    OVERLAY_ENTRY_F_VALID|OVERLAY_ENTRY_F_DROP)) == 0) {
 		bcopy(&otr->otr_answer, &vl2_entry->ote_u.ote_vl2.otvl2_dest,
 		    sizeof (overlay_target_point_t));
 		vl2_entry->ote_vtime = gethrtime();
