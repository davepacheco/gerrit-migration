commit 66e9a856e7b215bb61f2bf43a6ceee10b9197953 (refs/changes/81/4481/2)
Author: Jason King <jason.king@joyent.com>
Date:   2018-07-03T23:03:33-05:00 (1 year, 3 months ago)
    
    don't mark pending VL2 entries valid from route response

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index db67401fae..45ad86df06 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -1336,13 +1336,18 @@ overlay_target_lookup_respond_vl3(const overlay_targ_resp_t *otr,
 	}
 
 	/*
-	 * Update the VL2 entry if it doesn't have a valid destination. This
-	 * can lead to a slightly strange corner case where an entry is both
-	 * valid and pending (if there is still an outstanding VL2 request).
-	 * In such a case, the VL2 response will just overwrite the destination
-	 * with the same results and clear the pending flag.
+	 * Update the VL2 entry if it doesn't have a valid destination, hasn't
+	 * been marked as dropping all packets, and doesn't have an existing
+	 * outstanding request.  If a route and VL2 request involving the
+	 * same VL2 destination are pending and the route response is processed
+	 * prior to the VL2 request, we will continue to queue (on the VL2
+	 * entry) until the VL2 response is received, even though we have
+	 * an answer from the route response.  If we set the valid flag
+	 * while there's still oustanding requests, it will cause problems
+	 * with the outstanding requests.
 	 */
-	if ((vl2_entry->ote_flags & (OVERLAY_ENTRY_F_VALID)) == 0) {
+	if ((vl2_entry->ote_flags & (OVERLAY_ENTRY_F_PENDING|
+	    OVERLAY_ENTRY_F_VALID|OVERLAY_ENTRY_F_DROP)) == 0) {
 		bcopy(&otr->otr_answer, &vl2_entry->ote_u.ote_vl2.otvl2_dest,
 		    sizeof (overlay_target_point_t));
 		vl2_entry->ote_vtime = gethrtime();
@@ -1418,6 +1423,20 @@ overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 	return (0);
 }
 
+static boolean_t
+overlay_target_for_varpd(overlay_dev_t *odd, mblk_t *mp)
+{
+	mac_header_info_t mhi;
+
+	/* We should have dropped runts prior to ever queueing */
+	VERIFY0(mac_vlan_header_info(odd->odd_mh, mp, &mhi));
+	if (mhi.mhi_bindsap == ETHERTYPE_ARP)
+		return (B_TRUE);
+
+	/* TODO: NDP packets */
+	return (B_FALSE);
+}
+
 static int
 overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 {
@@ -1442,8 +1461,15 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 
 	mutex_enter(&entry->ote_lock);
 
-	/* Safeguard against a confused varpd */
-	if (entry->ote_flags & OVERLAY_ENTRY_F_VALID) {
+	mp = entry->ote_chead;
+
+	/*
+	 * Safeguard against a confused varpd.  Packets specifically for
+	 * varpd may receive replies (e.g. ARP replies) that require us to
+	 * drop, even when the entry is valid.
+	 */
+	if ((entry->ote_flags & OVERLAY_ENTRY_F_VALID) &&
+	    !overlay_target_for_varpd(entry->ote_odd, mp)) {
 		entry->ote_flags &= ~OVERLAY_ENTRY_F_PENDING;
 		DTRACE_PROBE1(overlay__target__valid__drop,
 		    overlay_target_entry_t *, entry);
@@ -1451,7 +1477,6 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 		goto done;
 	}
 
-	mp = entry->ote_chead;
 	if (mp != NULL) {
 		entry->ote_chead = mp->b_next;
 		mp->b_next = NULL;
