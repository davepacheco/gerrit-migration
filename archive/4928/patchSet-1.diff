commit 62d15f35951d3224c84473abb25d8e8904ed2060 (refs/changes/28/4928/1)
Author: John Levon <john.levon@joyent.com>
Date:   2018-10-05T09:41:30+00:00 (1 year ago)
    
    OS-1111 Compute Node hanging, reset by ipmi diag

diff --git a/exception_lists/wscheck b/exception_lists/wscheck
index 0d06b13802..18afddc2b0 100644
--- a/exception_lists/wscheck
+++ b/exception_lists/wscheck
@@ -94,3 +94,5 @@ usr/src/uts/i86pc/io/vmm/x86.[ch]
 usr/src/uts/i86pc/sys/vmm.h
 usr/src/uts/i86pc/sys/vmm_dev.h
 usr/src/uts/i86pc/sys/vmm_instruction_emul.h
+
+usr/src/uts/common/io/qede/*
diff --git a/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_dcbx.c b/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_dcbx.c
index de7b5db08c..c325cdecf8 100644
--- a/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_dcbx.c
+++ b/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_dcbx.c
@@ -33,6 +33,10 @@
 * limitations under the License.
 */
 
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
 #include "bcm_osal.h"
 #include "ecore.h"
 #include "ecore_sp_commands.h"
@@ -241,7 +245,6 @@ ecore_dcbx_update_app_info(struct ecore_dcbx_results *p_data,
 {
 	enum ecore_pci_personality personality;
 	enum dcbx_protocol_type id;
-	char *name;
 	int i;
 
 	for (i = 0; i < OSAL_ARRAY_SIZE(ecore_dcbx_app_update); i++) {
@@ -251,7 +254,6 @@ ecore_dcbx_update_app_info(struct ecore_dcbx_results *p_data,
 			continue;
 
 		personality = ecore_dcbx_app_update[i].personality;
-		name = ecore_dcbx_app_update[i].name;
 
 		ecore_dcbx_set_params(p_data, p_hwfn, enable,
 				      prio, tc, type, personality);
@@ -999,7 +1001,7 @@ ecore_dcbx_mib_update_event(struct ecore_hwfn *p_hwfn, struct ecore_ptt *p_ptt,
 
 		rc = ecore_dcbx_process_mib_info(p_hwfn);
 		if (!rc) {
-			bool enabled;
+			bool enabled __unused;
 
 			/* reconfigure tcs of QM queues according
 			 * to negotiation results
diff --git a/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_mcp.c b/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_mcp.c
index e83225708d..a2450dc34c 100644
--- a/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_mcp.c
+++ b/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_mcp.c
@@ -33,6 +33,10 @@
 * limitations under the License.
 */
 
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
 #include "bcm_osal.h"
 #include "ecore.h"
 #include "ecore_status.h"
@@ -362,7 +366,7 @@ static enum _ecore_status_t ecore_do_mcp_cmd(struct ecore_hwfn *p_hwfn,
 {
 	u32 delay = CHIP_MCP_RESP_ITER_US;
 	u32 max_retries = ECORE_DRV_MB_MAX_RETRIES;
-	u32 seq, cnt = 1, actual_mb_seq;
+	u32 seq, cnt = 1, actual_mb_seq __unused;
 	enum _ecore_status_t rc = ECORE_SUCCESS;
 
 #ifndef ASIC_ONLY
@@ -1433,7 +1437,7 @@ static void ecore_mcp_send_protocol_stats(struct ecore_hwfn *p_hwfn,
 					  struct ecore_ptt *p_ptt,
 					  enum MFW_DRV_MSG_TYPE type)
 {
-	enum ecore_mcp_protocol_type stats_type;
+	enum ecore_mcp_protocol_type stats_type __unused;
 	union ecore_mcp_protocol_stats stats;
 	struct ecore_mcp_mb_params mb_params;
 	u32 hsi_param;
@@ -3128,7 +3132,6 @@ enum _ecore_status_t ecore_mcp_phy_sfp_read(struct ecore_hwfn *p_hwfn,
 					    u32 len, u8 *p_buf)
 {
 	struct ecore_mcp_nvm_params params;
-	enum _ecore_status_t rc;
 	u32 bytes_left, bytes_to_copy, buf_size;
 
 	OSAL_MEMSET(&params, 0, sizeof(struct ecore_mcp_nvm_params));
@@ -3153,7 +3156,7 @@ enum _ecore_status_t ecore_mcp_phy_sfp_read(struct ecore_hwfn *p_hwfn,
 			 DRV_MB_PARAM_TRANSCEIVER_OFFSET_SHIFT);
 		params.nvm_common.offset |=
 			(bytes_to_copy << DRV_MB_PARAM_TRANSCEIVER_SIZE_SHIFT);
-		rc = ecore_mcp_nvm_command(p_hwfn, p_ptt, &params);
+		(void) ecore_mcp_nvm_command(p_hwfn, p_ptt, &params);
 		if ((params.nvm_common.resp & FW_MSG_CODE_MASK) ==
 		    FW_MSG_CODE_TRANSCEIVER_NOT_PRESENT) {
 			return ECORE_NODEV;
@@ -3174,7 +3177,6 @@ enum _ecore_status_t ecore_mcp_phy_sfp_write(struct ecore_hwfn *p_hwfn,
 					     u32 len, u8 *p_buf)
 {
 	struct ecore_mcp_nvm_params params;
-	enum _ecore_status_t rc;
 	u32 buf_idx, buf_size;
 
 	OSAL_MEMSET(&params, 0, sizeof(struct ecore_mcp_nvm_params));
@@ -3197,7 +3199,7 @@ enum _ecore_status_t ecore_mcp_phy_sfp_write(struct ecore_hwfn *p_hwfn,
 			(buf_size << DRV_MB_PARAM_TRANSCEIVER_SIZE_SHIFT);
 		params.nvm_wr.buf_size = buf_size;
 		params.nvm_wr.buf = (u32 *)&p_buf[buf_idx];
-		rc = ecore_mcp_nvm_command(p_hwfn, p_ptt, &params);
+		(void) ecore_mcp_nvm_command(p_hwfn, p_ptt, &params);
 		if ((params.nvm_common.resp & FW_MSG_CODE_MASK) ==
 		    FW_MSG_CODE_TRANSCEIVER_NOT_PRESENT) {
 			return ECORE_NODEV;
diff --git a/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_phy.c b/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_phy.c
index b05d08881d..1bb37f7954 100644
--- a/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_phy.c
+++ b/usr/src/uts/common/io/qede/579xx/drivers/ecore/ecore_phy.c
@@ -33,6 +33,10 @@
 * limitations under the License.
 */
 
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
 #include "bcm_osal.h"
 #include "ecore.h"
 #include "reg_addr.h"
@@ -626,7 +630,7 @@ static int ecore_ah_e5_phy_mac_stat(struct ecore_hwfn *p_hwfn,
 				    struct ecore_ptt *p_ptt, u32 port,
 				    char *p_phy_result_buf)
 {
-	u32 length, reg_id, addr, data_hi, data_lo;
+	u32 length, reg_id, addr, data_hi __unused, data_lo;
 
 	length = OSAL_SPRINTF(p_phy_result_buf,
 			       "MAC stats for port %d (only non-zero)\n", port);
diff --git a/usr/src/uts/common/io/qede/qede_gld.c b/usr/src/uts/common/io/qede/qede_gld.c
index cb3dfaa7d7..f38e0f17cf 100644
--- a/usr/src/uts/common/io/qede/qede_gld.c
+++ b/usr/src/uts/common/io/qede/qede_gld.c
@@ -33,6 +33,9 @@
 * limitations under the License.
 */
 
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
 
 #include "qede.h"
 
@@ -1263,7 +1266,7 @@ static lb_property_t loopmodes[] = {
 static enum ioc_reply
 qede_set_loopback_mode(qede_t *qede, uint32_t mode)
 {
-	int ret, i = 0;
+	int i = 0;
 	struct ecore_dev *edev = &qede->edev;
 	struct ecore_hwfn *hwfn;
 	struct ecore_ptt *ptt = NULL;
@@ -1290,7 +1293,7 @@ qede_set_loopback_mode(qede_t *qede, uint32_t mode)
 
 		link_params->loopback_mode = ETH_LOOPBACK_NONE;
 		qede->loop_back_mode = QEDE_LOOP_NONE;
-		ret = ecore_mcp_set_link(hwfn, ptt, 1);
+		(void) ecore_mcp_set_link(hwfn, ptt, 1);
 		ecore_ptt_release(hwfn, ptt);
 
 		while (!qede->params.link_state && i < 5000) {
@@ -1311,7 +1314,7 @@ qede_set_loopback_mode(qede_t *qede, uint32_t mode)
 		i = 0;
 		link_params->loopback_mode = ETH_LOOPBACK_INT_PHY;
 		qede->loop_back_mode = QEDE_LOOP_INTERNAL;
-		ret = ecore_mcp_set_link(hwfn, ptt, 1);
+		(void) ecore_mcp_set_link(hwfn, ptt, 1);
 		ecore_ptt_release(hwfn, ptt);
 
 		while(!qede->params.link_state && i < 5000) {
@@ -1464,7 +1467,7 @@ qede_ioctl_rd_wr_nvram(qede_t *qede, mblk_t *mp)
 	qede_nvram_data_t *data1 = (qede_nvram_data_t *)(mp->b_cont->b_rptr); 
 	qede_nvram_data_t *data2, *next_data;
 	struct ecore_dev *edev = &qede->edev;
-	uint32_t ret = 0, hdr_size = 24, bytes_to_copy, copy_len = 0;
+	uint32_t hdr_size = 24, bytes_to_copy, copy_len = 0;
 	uint32_t copy_len1 = 0;
 	uint32_t addr = data1->off;
 	uint32_t size = data1->size, i, buf_size;
@@ -1482,14 +1485,13 @@ qede_ioctl_rd_wr_nvram(qede_t *qede, mblk_t *mp)
 			" in nvram read ioctl\n");
 			return (DDI_FAILURE);
 		}
-		ret = ecore_mcp_nvm_read(edev, addr, buf, data1->size);
+		(void) ecore_mcp_nvm_read(edev, addr, buf, data1->size);
 
 		copy_len = (MBLKL(mp->b_cont)) - hdr_size;
 		if(copy_len > size) {
 			(void) memcpy(data1->uabc, buf, size);
 			kmem_free(buf, size);
 			//OSAL_FREE(edev, buf);
-			ret = 0;
 			break;
 		}
 		(void) memcpy(data1->uabc, buf, copy_len);
@@ -1529,7 +1531,6 @@ qede_ioctl_rd_wr_nvram(qede_t *qede, mblk_t *mp)
 		addr = data1->off;
 		buf_size =  size; //data1->buf_size;
 		//buf_size =  data1->buf_size;
-		ret = 0;
 
 		switch(cmd2){
 		case START_NVM_WRITE:
@@ -1547,7 +1548,6 @@ qede_ioctl_rd_wr_nvram(qede_t *qede, mblk_t *mp)
 			qede->nvm_buf = buf;
 			qede->copy_len = 0;
 			//tmp_buf = buf + addr;
-			ret = 0;
 			break;
 			
 		case ACCUMULATE_NVM_BUF:
@@ -1569,7 +1569,6 @@ qede_ioctl_rd_wr_nvram(qede_t *qede, mblk_t *mp)
 				//qede->copy_len = qede->copy_len + buf_size;
 				cmn_err(CE_NOTE, 
 				    "buf_size from app = %x\n", copy_len);
-				ret = 0;
 				break;
 			}
 			(void) memcpy(tmp_buf, data1->uabc, copy_len);
@@ -1590,7 +1589,6 @@ qede_ioctl_rd_wr_nvram(qede_t *qede, mblk_t *mp)
 					    bytes_to_copy);
 					qede->copy_len = qede->copy_len + 
 					    bytes_to_copy;
-					ret = 0;
 					break;
 				}
 				(void) memcpy(tmp_buf, next_data->uabc, 
@@ -1602,12 +1600,10 @@ qede_ioctl_rd_wr_nvram(qede_t *qede, mblk_t *mp)
 				mp1 = mp1->b_cont;
 			}
 			qede->nvm_buf = tmp_buf;
-			ret = 0;
 			break;
 
 		case STOP_NVM_WRITE:
 			//qede->nvm_buf = tmp_buf;
-			ret = 0;
 			break;
 		case READ_BUF:
 			tmp_buf = (uint8_t *)qede->nvm_buf_start;
@@ -1616,13 +1612,12 @@ qede_ioctl_rd_wr_nvram(qede_t *qede, mblk_t *mp)
 				    "buff (%d) : %d\n", i, *tmp_buf);
 				tmp_buf ++;
 			}
-			ret = 0;
 			break;
 		}
 		break;
 	case QEDE_NVRAM_CMD_PUT_FILE_DATA:
 		tmp_buf = qede->nvm_buf_start;	
-		ret = ecore_mcp_nvm_write(edev, ECORE_PUT_FILE_DATA,
+		(void) ecore_mcp_nvm_write(edev, ECORE_PUT_FILE_DATA,
 			  addr, tmp_buf, size);
 		kmem_free(qede->nvm_buf_start, size);
 		//OSAL_FREE(edev, tmp_buf);
@@ -1631,24 +1626,23 @@ qede_ioctl_rd_wr_nvram(qede_t *qede, mblk_t *mp)
 		tmp_buf = NULL;
 		qede->nvm_buf = NULL;
 		qede->nvm_buf_start = NULL;
-		ret = 0;
 		break;
 
 	case QEDE_NVRAM_CMD_SET_SECURE_MODE:
-		ret = ecore_mcp_nvm_set_secure_mode(edev, addr);
+		(void) ecore_mcp_nvm_set_secure_mode(edev, addr);
 		break;
 
 	case QEDE_NVRAM_CMD_DEL_FILE:
-		ret = ecore_mcp_nvm_del_file(edev, addr);
+		(void) ecore_mcp_nvm_del_file(edev, addr);
 		break;
 
 	case QEDE_NVRAM_CMD_PUT_FILE_BEGIN:
-		ret = ecore_mcp_nvm_put_file_begin(edev, addr);
+		(void) ecore_mcp_nvm_put_file_begin(edev, addr);
 		break;
 
 	case QEDE_NVRAM_CMD_GET_NVRAM_RESP:
 		buf = kmem_zalloc(size, KM_SLEEP);
-		ret = ecore_mcp_nvm_resp(edev, buf);
+		(void) ecore_mcp_nvm_resp(edev, buf);
 		(void)memcpy(data1->uabc, buf, size);
 		kmem_free(buf, size);
 		break;
