From 28572576ef7a640bf185c90b185f007918c296d2 Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Fri, 18 May 2018 15:40:47 -0700
Subject: [PATCH] TRITON-52 x-DC image copy

---
 CHANGES.md                                   |   8 +
 docs/index.md                                |  51 ++-
 lib/images.js                                | 340 +++++++++++++++++--
 lib/storage.js                               |  20 ++
 package.json                                 |   2 +-
 sapi_manifests/imgapi/template               |   3 +
 test/{ => data}/fauxnodejs-1.4.0.dsmanifest  |   0
 test/{ => data}/fauxnodejs-1.4.0.imgmanifest |   0
 test/{ => data}/fauxnodejs-1.4.0.zfs.bz2     | Bin
 test/{ => data}/fauxubuntu.dsmanifest        |   0
 test/{ => data}/fauxubuntu.zfs.bz2           | Bin
 test/{ => data}/icon.jpg                     | Bin
 test/{ => data}/what_a_piece_of_junk.zfs.bz2 |   0
 13 files changed, 399 insertions(+), 25 deletions(-)
 rename test/{ => data}/fauxnodejs-1.4.0.dsmanifest (100%)
 rename test/{ => data}/fauxnodejs-1.4.0.imgmanifest (100%)
 rename test/{ => data}/fauxnodejs-1.4.0.zfs.bz2 (100%)
 rename test/{ => data}/fauxubuntu.dsmanifest (100%)
 rename test/{ => data}/fauxubuntu.zfs.bz2 (100%)
 rename test/{ => data}/icon.jpg (100%)
 rename test/{ => data}/what_a_piece_of_junk.zfs.bz2 (100%)

diff --git a/CHANGES.md b/CHANGES.md
index 20db701..3a46a88 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,13 @@
 # IMGAPI changelog
 
+## 4.4.0
+
+- TRITON-52 x-DC image copy. This adds a new apiImportImageFromDc endpoint, 
+  which will allow a user to copy an image between datacenters in the same
+  cloud. As an optimization, images that use the same Manta storage will be
+  able to take advantage of snap linking, instead of directly copying the
+  file bits, which greatly speeds up the image copying process.
+
 ## 4.3.0
 
 - TRITON-178 Add support for image creation with bhyve brand (requires platform
diff --git a/docs/index.md b/docs/index.md
index d2f2bd9..ce5e121 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -626,7 +626,7 @@ and relevant for images in an IMGAPI server that uses [channels](#channels).
 | [DeleteImageIcon](#DeleteImageIcon)               | DELETE /images/:uuid/icon                                  | Remove the image icon.                                                        |
 | [CreateImageFromVm](#CreateImageFromVm)           | POST /images?action=create-from-vm                         | Create a new (activated) image from an existing VM.                           |
 | [ExportImage](#ExportImage)                       | POST /images/:uuid?action=export                           | Exports an image to the specified Manta path.                                 |
-| [CopyRemoteImage](#CopyRemoteImage)               | POST /images/$uuid?action=copy-remote&dc=us-west-1         | **NYI (IMGAPI-278)** Copy one's own image from another DC in the same cloud.  |
+| [ImportFromDC](#ImportFromDC)                     | POST /images/$uuid?action=import-from-dc&dc=us-west-1      | Copy one's own image from another DC in the same cloud.  |
 | [AdminImportRemoteImage](#AdminImportRemoteImage) | POST /images/$uuid?action=import-remote&source=$imgapi-url | Import an image from another IMGAPI                                           |
 | [AdminImportImage](#AdminImportImage)             | POST /images/$uuid?action=import                           | Only for operators to import an image and maintain `uuid` and `published_at`. |
 | [AdminGetState](#AdminGetState)                   | GET /state                                                 | Dump internal server state (for dev/debugging)                                |
@@ -1899,6 +1899,55 @@ CLI tool:
     $ cat data.json | sdc-imgadm update f9bbbc9f-d281-be42-9651-72c6be875874
 
 
+## ImportFromDC (POST /images?action=import-from-dc&dc=)
+
+Import an image and all origin images (preserving the image `uuid` and
+`published_at` fields) from the provided datacenter `dc`.
+
+An end user cannot import an operator image from another DC (i.e. an image
+that is owned by admin).
+
+All usage of IMGAPI on behalf of end users is required to use `account=UUID`.
+
+### Query String Inputs
+
+| Field            | Type    | Required? | Notes |
+| ---------------- | ------- | --------- | ----- |
+| account          | UUID    | Yes       | The account UUID on behalf of whom this request is being made. If given and if relevant, authorization will be done for this account. It is expected that all calls originating from a user (e.g. from cloudapi) will provide this parameter. |
+| dc               | String  | Yes       | The DC name that holds the source image. |
+
+### Returns
+
+A Job object. The location of the workflow API where the status of the job can
+be polled is available in the workflow-api header of the response.
+
+### Errors
+
+See [Errors](#errors) section above.
+
+### Example
+
+Raw API tool (against an SDC's IMGAPI). This queues the creation of a new Image
+from an existing VM:
+
+    $ sdc-imgapi '/images/859eb57c-d969-4962-8a87-3e5980e237ee?action=import-from-dc&dc=us-west-1' \
+        -X POST --data-binary '{}'
+    HTTP/1.1 200 OK
+    Content-Type: application/json
+    Content-Length: 236
+    Date: Tue, 08 Jan 2018 20:04:01 GMT
+    Server: IMGAPI/1.0.0
+    workflow-api: http://workflow.coal.joyent.us
+    x-request-id: ed5f60d6-a66d-4ff5-9991-935a36636c8b
+    x-response-time: 236
+    x-server-name: 616a4e4b-7bdd-4d6b-87cb-7a4458dc08b0
+    Connection: keep-alive
+
+    {
+      "image_uuid": "859eb57c-d969-4962-8a87-3e5980e237ee",
+      "job_uuid": "ddc2ec53-2dd8-4b0d-a992-0a7cafda6e8d"
+    }
+
 
 ## AdminImportImage (POST /images/:uuid?action=import)
 
diff --git a/lib/images.js b/lib/images.js
index 4ded88d..6b30be8 100644
--- a/lib/images.js
+++ b/lib/images.js
@@ -782,7 +782,10 @@ function createImportImageJob(req, uuid, source, skipOwnerCheck, log, cb) {
                 return next(null, juuid);
             });
         }
-    ], cb);
+    ], function _createImportImageJobWaterfallCb(err, jobUuid) {
+        client.close();
+        cb(err, jobUuid);
+    });
 };
 
 
@@ -1594,6 +1597,17 @@ function apiListImages(req, res, next) {
 function apiGetImage(req, res, next) {
     var serialized = req._image.serialize(req._app.mode, req.getVersion(),
         req.inclAdminFields);
+
+    // TRITON-52 Include the manta file path.
+    if (req.inclAdminFields && req._image.files.length > 0 &&
+            req._image.files[0].stor === 'manta') {
+        var stor = req._app.getStor('manta');
+        if (stor) {
+            serialized.files[0].path = stor._storPathFromImageUuid(
+                req._image.uuid, 'file0');
+        }
+    }
+
     resSetEtag(req, res, serialized);
     res.send(serialized);
     next();
@@ -2201,6 +2215,7 @@ function apiAdminImportImageFromSource(req, res, cb) {
                 if (err) {
                     log.error(err, 'failed to get manifest for image %s',
                         uuid);
+                    client.close();
                     return next(new errors.RemoteSourceError(format('Unable ' +
                         'to get manifest for image %s. Error from remote: %s',
                         uuid, err.message || err.code)));
@@ -2208,6 +2223,7 @@ function apiAdminImportImageFromSource(req, res, cb) {
                 manifest = manifest_;
                 assert.ok(manifest.uuid, 'no uuid on image manifest: ' +
                     JSON.stringify(manifest));
+                client.close();
                 next();
             });
         },
@@ -2371,6 +2387,212 @@ function apiAdminImportRemoteImage(req, res, callback) {
 }
 
 
+/**
+ * Allow a user (or admin) to import an image that resides in another
+ * datacenter within the same cloud (e.g. an image that resides in a
+ * different JPC region, such as importing from us-west-1 into us-sw-1).
+ *
+ * This creates and returns a workflow 'import-remote-image' job.
+ */
+function apiImportImageFromDc(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req.log, 'req.log');
+    assert.object(req.params, 'req.params');
+    assert.object(req.query, 'req.query');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    if (req.query.action !== 'import-from-dc') {
+        return next();
+    }
+
+    var account = req.query.account;
+    var app = req._app;
+    var client;
+    var dc = req.query.dc;
+    var errs;
+    var log = req.log;
+    var source;
+    var uuid = req.params.uuid;
+
+    if (!UUID_RE.test(uuid)) {
+        errs = [ { field: 'uuid', code: 'Invalid' } ];
+        next(new errors.ValidationFailedError(
+            format('invalid image "uuid" (not a UUID): %s', uuid), errs));
+        return;
+    }
+
+    if (account && !UUID_RE.test(account)) {
+        errs = [ { field: 'account', code: 'Invalid' } ];
+        next(new errors.ValidationFailedError(
+            format('invalid image "account" (not a UUID): %s', account), errs));
+        return;
+    }
+
+    if (dc === undefined) {
+        errs = [ { field: 'dc', code: 'MissingParameter' } ];
+        next(new errors.ValidationFailedError('missing dc parameter', errs));
+        return;
+    }
+
+    if (!app.config.imgapiUrlFromDc ||
+            !app.config.imgapiUrlFromDc.hasOwnProperty(dc)) {
+        errs = [ { field: 'dc', code: 'Invalid' } ];
+        next(new errors.ValidationFailedError('unknown dc: ' + dc, errs));
+        return;
+    }
+
+    source = app.config.imgapiUrlFromDc[dc];
+    assert.string(source, 'source');
+
+    vasync.pipeline({ arg: {}, funcs: [
+        function checkImageExistsInRemoteDc(ctx, cb) {
+            log.debug({uuid: uuid},
+                'ImportDcImage: ensure image exists in remote DC');
+            client = new sdcClients.IMGAPI(utils.commonHttpClientOpts({
+                url: source,
+                log: log
+            }, req));
+            client.getImage(uuid, account, function (err, img) {
+                if (err) {
+                    // TODO: Should we wrap this error?
+                    cb(err);
+                    return;
+                }
+
+                // A user cannot import an admin image.
+                if (account && account !== app.config.adminUuid &&
+                        (img.owner === constants.UNSET_OWNER_UUID ||
+                        img.owner === app.config.adminUuid)) {
+                    cb(new errors.UnauthorizedError(
+                        'Cannot import an admin image.'));
+                    return;
+                }
+
+                ctx.image = img;
+                cb();
+            });
+        },
+
+        function checkIfImageExistsLocally(_, cb) {
+            log.debug({uuid: uuid},
+                'ImportDcImage: check if image already exists locally');
+            Image.get(app, uuid, log, function (err, img) {
+                if (!err) {
+                    assert.object(img, 'img');
+                    cb(new errors.ImageUuidAlreadyExistsError(uuid));
+                    return;
+                } else if (err.restCode !== 'ResourceNotFound') {
+                    cb(err);
+                    return;
+                }
+                cb();
+            });
+        },
+
+        // Find and validate each of the origin images:
+        // 1. must be activated or disabled (disabled means cannot provision)
+        // 2. must be owned by the given user (or admin, see 3)
+        // 3. admin owned images must already exist locally - as they cannot
+        //    be copied between DCs (unless the request is made by admin)
+        function lookupOriginImages(ctx, cb) {
+            // The images to clone, starting from the base.
+            if (!ctx.image.origin) {
+                cb();
+                return;
+            }
+
+            var maxOriginCount = 100;
+            var originImages = [];
+
+            function validateOneOriginImage(currentOrigin, subnext) {
+                client.getImage(currentOrigin, account,
+                        function _originGetImageCb(err, img) {
+                    if (err) {
+                        subnext(err);
+                        return;
+                    }
+                    // Note that we allow disabled origin images, as that just
+                    // means that the origin image is not provisionable.
+                    if (img.state === 'unactivated') {
+                        subnext(new errors.OriginIsNotActiveError(
+                            currentOrigin));
+                        return;
+                    }
+
+                    // Stop when an admin image is found - must check that the
+                    // same admin image exists in the local DC.
+                    if (img.owner === constants.UNSET_OWNER_UUID ||
+                            img.owner === app.config.adminUuid) {
+                        log.debug({uuid: uuid}, 'ImportDcImage: check admin ' +
+                            'origin image exists locally');
+                        Image.get(app, currentOrigin, log,
+                                function (err2) {
+                            if (err2) {
+                                if (err2.restCode === 'ResourceNotFound') {
+                                    subnext(new errors.ResourceNotFoundError(
+                                        format(
+                                            'Unable to import - admin origin ' +
+                                            'image %s does not exist in this ' +
+                                            'DC.'
+                                        )));
+                                    return;
+                                }
+                                subnext(err2);
+                                return;
+                            }
+                            subnext();
+                        });
+                        return;
+                    }
+
+                    originImages.push(img);
+                    // Follow the origin chain.
+                    if (img.origin) {
+                        if (originImages.length >= maxOriginCount) {
+                            subnext(new errors.InternalError(format(
+                                'Origin chain too long, exceeds %d images',
+                                maxOriginCount)));
+                            return;
+                        }
+                        validateOneOriginImage(img.origin, subnext);
+                        return;
+                    }
+                    subnext();
+                });
+            }
+
+            validateOneOriginImage(ctx.image.origin, cb);
+        },
+
+        function doImportFromDc(_, cb) {
+            var skipOwnerCheck = false;
+            log.debug({dc: dc, uuid: uuid, source: source},
+                'ImportDcImage: start import');
+            Image.createImportImageJob(req, uuid, source, skipOwnerCheck, log,
+                    function _createImportImageJobCb(err, jobUuid) {
+                if (err) {
+                        cb(err);
+                        return;
+                }
+
+                // Allow clients to know where is wfapi located
+                res.header('workflow-api', app.config.wfapi.url);
+                    log.warn('_importFromDcPipelineCb jobUuid: %s', jobUuid);
+                res.send({ image_uuid: uuid, job_uuid: jobUuid });
+                    cb(false);
+            });
+        }
+
+    ]}, function _importFromDcPipelineCb(err) {
+        if (client) {
+            client.close();
+        }
+        next(err);
+    });
+}
+
+
 function apiAdminImportDockerImage(req, res, next) {
     if (req.query.action !== 'import-docker-image') {
         return next();
@@ -2579,18 +2801,62 @@ function apiAddImageFileFromSource(req, res, next) {
         url: req.query.source,
         log: req.log
     }, req));
+
+    // Next handler that closes the IMGAPI client before running callback.
+    // TODO: Maybe better to move these calls into a vasync chain.
+    var _next = next;
+    function closeClientAndCallNext(err) {
+        client.close();
+        _next(err);
+    }
+    next = closeClientAndCallNext;
+
     // Get the image so we can get the manifest files details
-    client.getImage(uuid, addImageFileFromSource);
+    client.getImage(uuid, {inclAdminFields: true},
+        addImageFileFromSharedMantaSource);
 
-    function addImageFileFromSource(err, manifest) {
+    // TRITON-52 Check if the given IMGAPI source uses the same manta storage,
+    // if yes then the manta file can be snaplinked rather than bit-copied.
+    function addImageFileFromSharedMantaSource(err, manifest) {
         if (err) {
-            req.log.error(err, 'failed to get manifest for image %s',
+            req.log.error(err, 'apiAddImageFile: failed to get image %s',
                 uuid);
-            return next(new errors.RemoteSourceError(format('Unable ' +
+            next(new errors.RemoteSourceError(format('Unable ' +
                 'to get manifest for image %s. Error from remote: %s',
                 uuid, err.message || err.code)));
+            return;
+        }
+
+        var config = req._app.config;
+
+        if (manifest.files[0].path && config.imgapiUrlFromDc &&
+                Object.keys(config.imgapiUrlFromDc).some(function _urlSome(dc) {
+                     return config.imgapiUrlFromDc[dc] === req.query.source;
+                 })) {
+            var stor = req._app.getStor('manta');
+            if (!stor) {
+                addImageFileFromImgapiSource(manifest);
+                return;
+            }
+
+            // The image file can be manta snaplinked.
+            // Passing some vars onto `finishMoveImageFile`.
+            req.file = objCopy(manifest.files[0]);
+            req.file.stor = stor.type;
+            req.storage = stor.type;
+
+            assert.string(req.file.path, 'req.file.path');
+            req.mantaSnaplinkPath = req.file.path;
+            // Remove file.path - we don't want that saved in the metadata.
+            delete req.file.path;
+
+            next();
+            return;
         }
+        addImageFileFromImgapiSource(manifest);
+    }
 
+    function addImageFileFromImgapiSource(manifest) {
         var compression = manifest.files[0].compression;
         var sha1Param = manifest.files[0].sha1;
         var contentLength = manifest.files[0].size;
@@ -2698,32 +2964,59 @@ function apiAddImageFileFromSource(req, res, next) {
  * into its final (non-tmp) place.
  */
 function finishMoveImageFile(req, res, next) {
-    req.log.debug({image: req._image}, 'MoveImageFile: start');
+    assert.object(req, 'req');
+    assert.object(req.file, 'req.file');
+    assert.object(req._image, 'req._image');
+    assert.string(req.storage, 'req.storage');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    req.log.debug({uuid: req._image.uuid}, 'FinishMoveImageFile: start');
 
     if (req._image.activated) {
         return next(new errors.ImageAlreadyActivatedError(req._image.uuid));
     }
 
-    var stor = req._app.getStor(req.storage);
-    stor.moveImageFile(req._image, req.tmpFilename, req.filename,
-      function (mErr) {
-        if (mErr) {
-            return next(mErr);
+    vasync.pipeline({ funcs: [
+        function moveImageFile(_, cb) {
+            var stor = req._app.getStor(req.storage);
+            assert.object(stor, 'stor');
+            if (req.mantaSnaplinkPath) {
+                req.log.debug({uuid: req._image.uuid,
+                     mantaSnaplinkPath: req.mantaSnaplinkPath},
+                    'Snaplinking from existing manta file');
+                stor.snapLinkImageFileFromPath(req._image,
+                    req.mantaSnaplinkPath, cb);
+            } else {
+                assert.string(req.filename, 'req.filename');
+                assert.string(req.tmpFilename, 'req.tmpFilename');
+                stor.moveImageFile(req._image, req.tmpFilename, req.filename,
+                    cb);
+            }
+        },
+        function addImageFileDetails(_, cb) {
+            req._image.addFile(req._app, req.file, req.log, function (err) {
+                if (err) {
+                    req.log.error(err, 'error adding file info to Image');
+                    cb(new errors.InternalError(err, 'could not save image'));
+                    return;
+                }
+                cb();
+            });
         }
 
-        req._image.addFile(req._app, req.file, req.log, function (err2) {
-            if (err2) {
-                req.log.error(err2, 'error adding file info to Image');
-                return next(new errors.InternalError(err2,
-                    'could not save image'));
-            }
+    ]}, function _onFinishMoveImageFileCb(err) {
+        if (err) {
+            next(err);
+            return;
+        }
 
-            var serialized = req._image.serialize(req._app.mode,
-                    req.getVersion());
-            resSetEtag(req, res, serialized);
-            res.send(serialized);
-            next();
-        });
+        req.log.debug({uuid: req._image.uuid}, 'FinishMoveImageFile: success');
+
+        var serialized = req._image.serialize(req._app.mode, req.getVersion());
+        resSetEtag(req, res, serialized);
+        res.send(serialized);
+        next();
     });
 }
 
@@ -4102,6 +4395,7 @@ function mountApi(server, reqAuth, reqPassiveAuth) {
         apiAdminImportRemoteImage, // before `reqGetImage` b/c shouldn't be one
         apiAdminImportImage,       // before `reqGetImage` b/c shouldn't be one
         apiAdminImportImageFromSource,
+        apiImportImageFromDc,
         reqGetImage,               // add `req._image`, ensure access
         apiAdminChangeImageStor,
         reqEnsureAccountIsImageOwner,
diff --git a/lib/storage.js b/lib/storage.js
index db83ddf..c0e2679 100644
--- a/lib/storage.js
+++ b/lib/storage.js
@@ -663,6 +663,26 @@ function (image, toPath, callback) {
     this.client.ln(fromPath, toPath, callback);
 };
 
+MantaStorage.prototype.snapLinkImageFileFromPath =
+function (image, fromPath, callback) {
+    assert.object(image, 'image');
+    assert.string(image.uuid, 'image.uuid');
+    assert.string(fromPath, 'fromPath');
+    assert.func(callback, 'callback');
+
+    var self = this;
+    var toPath = this._storPathFromImageUuid(image.uuid, 'file0');
+    var toDir = path.dirname(toPath);
+
+    self.client.mkdirp(toDir, function _snapLinkMkdirpCb(err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        self.client.ln(fromPath, toPath, callback);
+    });
+};
+
 MantaStorage.prototype.createImageFileReadStream =
         function (image, filename, opts, callback) {
     assert.object(image, 'image');
diff --git a/package.json b/package.json
index ebd267e..139cadd 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "imgapi",
   "description": "Image API to manage images for SDC 7",
-  "version": "4.3.0",
+  "version": "4.4.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
diff --git a/sapi_manifests/imgapi/template b/sapi_manifests/imgapi/template
index ef9a862..070b952 100644
--- a/sapi_manifests/imgapi/template
+++ b/sapi_manifests/imgapi/template
@@ -48,6 +48,9 @@
 {{/IMGAPI_MANTA_URL}}
         "local"
     ],
+{{#IMGAPI_URL_FROM_DC}}
+    "imgapiUrlFromDc": {{{IMGAPI_URL_FROM_DC}}},
+{{/IMGAPI_URL_FROM_DC}}
     "wfapi": {
         "forceMd5Check": true,
         "workflows": ["create-from-vm", "import-remote-image"],
diff --git a/test/fauxnodejs-1.4.0.dsmanifest b/test/data/fauxnodejs-1.4.0.dsmanifest
similarity index 100%
rename from test/fauxnodejs-1.4.0.dsmanifest
rename to test/data/fauxnodejs-1.4.0.dsmanifest
diff --git a/test/fauxnodejs-1.4.0.imgmanifest b/test/data/fauxnodejs-1.4.0.imgmanifest
similarity index 100%
rename from test/fauxnodejs-1.4.0.imgmanifest
rename to test/data/fauxnodejs-1.4.0.imgmanifest
diff --git a/test/fauxnodejs-1.4.0.zfs.bz2 b/test/data/fauxnodejs-1.4.0.zfs.bz2
similarity index 100%
rename from test/fauxnodejs-1.4.0.zfs.bz2
rename to test/data/fauxnodejs-1.4.0.zfs.bz2
diff --git a/test/fauxubuntu.dsmanifest b/test/data/fauxubuntu.dsmanifest
similarity index 100%
rename from test/fauxubuntu.dsmanifest
rename to test/data/fauxubuntu.dsmanifest
diff --git a/test/fauxubuntu.zfs.bz2 b/test/data/fauxubuntu.zfs.bz2
similarity index 100%
rename from test/fauxubuntu.zfs.bz2
rename to test/data/fauxubuntu.zfs.bz2
diff --git a/test/icon.jpg b/test/data/icon.jpg
similarity index 100%
rename from test/icon.jpg
rename to test/data/icon.jpg
diff --git a/test/what_a_piece_of_junk.zfs.bz2 b/test/data/what_a_piece_of_junk.zfs.bz2
similarity index 100%
rename from test/what_a_piece_of_junk.zfs.bz2
rename to test/data/what_a_piece_of_junk.zfs.bz2
-- 
2.21.0

