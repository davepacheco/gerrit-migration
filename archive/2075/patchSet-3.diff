commit 8aed3d6843aaa89b90421fedf3be9c75d9b29e46 (refs/changes/75/2075/3)
Author: Marsell Kukuljevic <marsell@joyent.com>
Date:   2017-06-16T01:21:38+12:00 (2 years, 4 months ago)
    
    PUBAPI-1404: cloudapi test failures: "origNics and newNics should be the same"
    Reviewed by: Trent Mick <trent.mick@joyent.com>

diff --git a/test/nics.test.js b/test/nics.test.js
index d62ee38..dfc38d4 100644
--- a/test/nics.test.js
+++ b/test/nics.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 /*
@@ -638,7 +638,19 @@ function verifyUnchangedNics(t, mutator) {
                 belongs_to_type: 'zone'
             }, function (err2, newNics) {
                 t.ifError(err2, 'NAPI ListNics for newNics');
-                t.deepEqual(sortNics(origNics), sortNics(newNics),
+
+                // remove timestamps so they don't interfere when finding
+                // differences between arrays of objects
+                origNics.forEach(function (nic) {
+                    delete nic.modified_timestamp;
+                });
+
+                newNics.forEach(function (nic) {
+                    delete nic.modified_timestamp;
+                });
+
+                var changes = findObjectArrayChanges(origNics, newNics, 'mac');
+                t.deepEqual(changes, [],
                     'origNics and newNics should be the same');
                 t.end();
             });
@@ -647,79 +659,188 @@ function verifyUnchangedNics(t, mutator) {
 }
 
 
-function sortNics(nics) {
-    return nics.sort(function (a, b) {
-        return (a.mac > b.mac) ? 1 : -1;
+function findObjectArrayChanges(oldArr, newArr, key) {
+    var oldArrLookup = {};
+    oldArr.forEach(function (oldObj) {
+        var val = oldObj[key];
+        oldArrLookup[val] = oldObj;
     });
-}
 
+    var changes = [];
 
-function waitTilNicAdded(t, path) {
-    var count = 30;
+    newArr.forEach(function (newObj) {
+        var val = newObj[key];
+        var oldObj = oldArrLookup[val];
 
-    function check() {
-        count--;
-        if (count === 0) {
-            t.ifError(true, 'NIC did not provision in time');
-            return t.end();
+        // using JSON.stringify() here is an abusive hack to keep things simple,
+        // relying on on identical objects being serialized the same way each
+        // time; there is no inherent reason for this to happen, but in
+        // practice that's how it works out
+        if (!oldObj || JSON.stringify(newObj) !== JSON.stringify(oldObj)) {
+            changes.push({ original: oldObj, modified: newObj });
         }
 
-        return CLIENT.get(path, function (err, req, res, nic) {
-            t.ifError(err);
+        delete oldArrLookup[val];
+    });
 
-            if (nic.state === 'running') {
-                return t.end();
-            } else {
-                return setTimeout(check, 5000);
-            }
-        });
-    }
+    Object.keys(oldArrLookup).forEach(function (name) {
+        changes.push({ original: oldArrLookup[name], modified: null});
+    });
 
-    check();
+    return changes;
 }
 
 
 /*
  * Remove the given instance NIC and wait for its deletion.
  */
-function removeNic(t, instId, nic) {
+function removeNic(t, vmUuid, nic) {
     var mac  = nic.mac.replace(/\:/g, '');
-    var path = '/my/machines/' + instId + '/nics/' + mac;
+    var path = '/my/machines/' + vmUuid + '/nics/' + mac;
 
     CLIENT.del(path, function (err, req, res, body) {
-        t.ifError(err, 'RemoveNic with mac ' + mac + ' from vm ' + instId);
+        t.ifError(err, 'RemoveNic with mac ' + mac + ' from vm ' + vmUuid);
         t.equal(res.statusCode, 204, 'RemoveNic 204 statusCode');
         t.deepEqual(body, {}, 'RemoveNic "{}" body');
 
-        waitTilNicDeleted(t, path);
+        waitTilNicDeleted(t, vmUuid, nic.mac);
     });
 }
 
 
-function waitTilNicDeleted(t, apiPath) {
-    // Sometimes NICs take a very long time to delete due to long-reboot
-    // times that some zones experience
-    var count = 120;
+/*
+ * When a NIC is added to a VM, the VM is rebooted. This happens asynchronous to
+ * the job adding the NIC, and some time later, so we need ot create a
+ * synchronization barrier where all NICs have cycles from running to stopped,
+ * and back to running.  If we don't, it causes sporadic problems with later
+ * tests.
+ *
+ * We can't depend on the NIC state alone, because NIC states sometimes bounce
+ * more than once. Eliding the check for the VM restart causes more testing
+ * oddities down the tine.
+ *
+ * We use polling on the VM and NICs' states to ensure we are in a known state
+ * that won't conflict with later tests. Unfortuantely, neither NAPI or VMAPI
+ * currently provide enough data (nor are synchronised in any way) to determine
+ * when a VM or NIC restarted without resorting to polling. This leaves us
+ * vulnerable to timing problems. In practice polling works well enough, but if
+ * updates to NAPI or VMAPI are significantly delayed, or a VM or NIC
+ * transitions through multiple states (i.e. ABA) exceptionally fast, this will
+ * fall apart.
+ */
+function waitTilNicAdded(t, vmUuid, mac) {
+    waitTilVmRestarts(vmUuid, function (err) {
+        t.ifError(err, 'Restarted VM');
 
-    function check() {
-        count--;
-        if (count === 0) {
-            t.ifError(true, 'NIC did not delete in time');
+        waitTilNicsRestart(vmUuid, mac, function (err2, macPresent) {
+            t.ifError(err2, 'Restarted NICs');
+            t.ok(macPresent, 'Expect NIC ' + mac + ' to be found');
             t.end();
+        });
+    });
+}
+
+
+/*
+ * Wait until all NICs on a VM restart, then check that the NIC which was
+ * supposed to be deleted is actually gone.
+ */
+function waitTilNicDeleted(t, vmUuid, mac) {
+    waitTilNicsRestart(vmUuid, mac, function (err, macPresent) {
+        t.ifError(err, 'Restarted NICs');
+
+        /*
+         * If this fails, but the above check did not, dig out the task ID from
+         * the job and query CNAPI for details
+         */
+        t.ifError(macPresent, 'Expect NIC ' + mac + ' to be gone');
+
+        var path = '/my/machines/' + vmUuid + '/nics/' + mac.replace(/\:/g, '');
+        CLIENT.get(path, function (err2, req, res, nic) {
+            /*
+             * if this fails, the NIC was very likely added back into NAPI by
+             * an agent after the workflow deleted the NIC from NAPI, but before
+             * a CNAPI call originating from the workflow removed the actual
+             * NIC from the VM.
+             */
+            t.equal(err2.statusCode, 404, 'NIC ' + mac + ' gone from API');
+            t.end();
+        });
+    });
+}
+
+
+function waitTilVmRestarts(vmUuid, cb) {
+    var vmCount = 200;
+    var vmLatch = false;
+    var path = '/my/machines/' + vmUuid;
+
+    function poll() {
+        vmCount--;
+        if (vmCount === 0) {
+            cb(new Error('VM did not restart in time'));
             return;
         }
 
-        CLIENT.get(apiPath, function (err, req, res, nic) {
+        CLIENT.get(path, function (err, req, res, vm) {
             if (err) {
-                t.equal(err.statusCode, 404);
-                t.end();
-            } else {
-                setTimeout(check, 5000);
+                cb(err);
+                return;
+            }
+
+            if (!vmLatch || vm.state !== 'running') {
+                vmLatch = (vm.state !== 'running');
+            }
+
+            if (vmLatch && vm.state === 'running') {
+                cb();
+                return;
+            }
+
+            setTimeout(poll, 100);
+        });
+    }
+
+    poll();
+}
+
+
+function waitTilNicsRestart(vmUuid, mac, cb) {
+    var nicCount = 200;
+    var nicLatches = {};
+    var path = '/my/machines/' + vmUuid + '/nics';
+
+    function poll() {
+        nicCount--;
+        if (nicCount === 0) {
+            cb(new Error('NICs failed restart: ' + JSON.stringify(nicLatches)));
+            return;
+        }
+
+        CLIENT.get(path, function (err, req, res, nics) {
+            if (err) {
+                cb(err);
+                return;
             }
+
+            var barrier = true;
+            nics.forEach(function (nic) {
+                if (!nicLatches[nic.mac] || nic.state !== 'running') {
+                    nicLatches[nic.mac] = (nic.state !== 'running');
+                    barrier = false;
+                }
+            });
+
+            if (barrier) {
+                cb(null, nicLatches[mac]);
+                return;
+            }
+
+            setTimeout(poll, 100);
         });
     }
 
-    check();
+    poll();
 }
 
 
@@ -1136,7 +1257,7 @@ test('nics', function (tt) {
                 t.deepEqual(nic, nic2);
                 instNic = nic;
 
-                waitTilNicAdded(t, location);
+                waitTilNicAdded(t, fixtures.instId, nic.mac);
             });
         });
     });
@@ -1471,8 +1592,7 @@ test('nics', function (tt) {
 
                 t.deepEqual(nic, nic2);
                 instNic = nic;
-
-                waitTilNicAdded(t, location);
+                waitTilNicAdded(t, fixtures.instId, nic.mac);
             });
         });
     });
@@ -1503,8 +1623,7 @@ test('nics', function (tt) {
                 t.ok(location, 'AddNic Location header: ' + location);
                 instNic = nic;
                 t.ok(instNic, 'AddNic nic: ' + JSON.stringify(nic));
-
-                waitTilNicAdded(t, location);
+                waitTilNicAdded(t, fixtures.instId, nic.mac);
             });
         });
     });
