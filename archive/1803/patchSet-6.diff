From 15e6923259a63e0a59f52eaed60282df8fc013cf Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Wed, 26 Apr 2017 13:24:24 -0700
Subject: [PATCH] DOCKER-1020 Define "public" network using Docker label

---
 docs/api/commands/run.md            |   2 +
 docs/api/divergence.md              |  26 +++++
 docs/api/features/networks.md       |   7 ++
 lib/backends/sdc/build.js           |   4 +-
 lib/backends/sdc/containers.js      | 146 +++++++++++++++++-----------
 package.json                        |   2 +-
 test/integration/api-create.test.js | 116 +++++++++++++++++++++-
 test/integration/helpers.js         |  27 ++++-
 8 files changed, 267 insertions(+), 63 deletions(-)

diff --git a/docs/api/commands/run.md b/docs/api/commands/run.md
index 819dd90..970be3e 100644
--- a/docs/api/commands/run.md
+++ b/docs/api/commands/run.md
@@ -525,4 +525,6 @@ documentation](../features/placement.md) for details.
 ## Related
 
 - [`docker ps`](../commands/ps.md)
+- [`networks`](../features/networks.md) for external and overlay networking
+- [`CPU, memory and disk resource allocation`](../features/resources.md)
 - [`sdc-createmachine`](https://apidocs.joyent.com/cloudapi/#CreateMachine) and `POST /my/machines` in CloudAPI
diff --git a/docs/api/divergence.md b/docs/api/divergence.md
index 6028f47..2603cc0 100644
--- a/docs/api/divergence.md
+++ b/docs/api/divergence.md
@@ -151,3 +151,29 @@ users access to all their logs.
 
 For the operator of SDC Docker these additional logs will require some cleanup
 process for long-lived containers when Manta support is not available.
+
+
+## Container Labels
+
+Triton uses (and reserves) a number of custom container labels, to provide
+specific Triton features. These are:
+
+The `triton.*` namespace is reserved for Triton specific use cases, these label
+names are currently defined:
+
+* `triton.cns.disable` (boolean): Can be set on a container to tell the CNS
+  service to not serve records for this instance.
+* `triton.cns.services` (string): Comma-separated list of DNS-name strings
+  for the CNS service.
+* `triton.cns.reverse_ptr` (string): DNS reverse pointer for this container.
+  Used by the CNS service.
+* `triton.network.public` (string): Set on a container, used to specify the
+  external network name the instance will use.
+
+The `com.joyent.*` namespace is reserved for Joyent/Triton specific use cases,
+these label names are currently defined:
+
+* `com.joyent.package` (string): Set on a container, used to choose a specific
+  package for the container. The value can be a package name like
+  `g4-standard-1G`, a UUID, or the first 8 characters of a UUID
+  (short-UUID).
diff --git a/docs/api/features/networks.md b/docs/api/features/networks.md
index 5e939d0..08e5bec 100644
--- a/docs/api/features/networks.md
+++ b/docs/api/features/networks.md
@@ -46,6 +46,13 @@ exposes. For `-p`, this means all ports specified as arguments. Port remapping
 If fabric networking is not enabled, all docker containers are provisioned with
 a nic on the 'external' network by default.
 
+The external network used by a container can be changed by setting the
+`triton.network.public` label to the name of the desired external network, e.g.
+
+```
+docker run --label triton.network.public=external2
+```
+
 
 ## Related
 
diff --git a/lib/backends/sdc/build.js b/lib/backends/sdc/build.js
index 7a33c1c..e214f9b 100644
--- a/lib/backends/sdc/build.js
+++ b/lib/backends/sdc/build.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  *
  * Overview: Build an image, given a build context (tarball).
  */
@@ -174,7 +174,7 @@ function buildImage(opts, callback) {
             account: req.account,
             app: req.app,
             clientApiVersion: req.clientApiVersion,
-            fabricRequireExternal: true,  // use external network
+            requireExternalNetwork: true,  // use external network
             image: scratchImage,
             log: log,
             name: 'build_' + req_id,
diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index cf6d358..bc34df5 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -75,6 +75,9 @@ var MAX_VOLUMES_FROM = 2; // number of --volumes-from allowed
 // matches the value customers will see on their bills.
 var PACKAGE_SELECTION_LABEL = 'com.joyent.package';
 
+// Label name used to set the external (public) network for a container.
+var TRITON_PUBLIC_NETWORK_LABEL = 'triton.network.public';
+
 // These should match what PAPI uses for validating a package name
 var BAD_PKG_NAME_RE = /[\_\-\.][\_\-\.]/;
 var PKG_NAME_RE = /^[a-zA-Z0-9]([a-zA-Z0-9\_\-\.]+)?[a-zA-Z0-9]$/;
@@ -526,20 +529,32 @@ function addRulesToFWAPI(opts, rules, payload, callback) {
 }
 
 /**
- * Add networks to the payload. Dispatches to one of these supported networking
- * configurations:
- *   1. without fabrics configured: external networking only.
+ * Add network configurations (fabrics and external) to the payload.
+ *
+ *  Fabrics:
  *
- *   With fabrics enabled:
- *   2. 'bridge' or nothing specified provisions on the user's default network,
- *      potentially also with the external network.
- *   3. Specifying a network name will provision to the named *fabric* network.
- *   4. Specifying a network id (or portion) will provision to that *fabric*
- *      network.
+ *   When fabrics are enabled, the fabric network is selected in these ways:
+ *    1. When 'bridge' or nothing specified, will use the user's default network
+ *    2. Specifying a network name will provision to the named *fabric* network
+ *    3. Specifying a network id (or portion) will provision to that *fabric*
+ *       network
  *
  *   Docker resolves name/id collisions in the following way:
  *     - a name is preferred to a partial id
  *     - a full id is preferred to a name
+ *
+ *  External:
+ *
+ *   An external network is added in these cases:
+ *    1. opts.requireExternalNetwork is set, or
+ *    2. fabrics are *not* enabled, or
+ *    3. fabrics are enabled and the user wants to expose ports
+ *
+ *   The user can specify which external network is used by setting the
+ *   'triton.network.public' container label (tag), this specifies the external
+ *   network *name*, all other cases will use the default external network,
+ *   which for fabrics is opts.config.overlay.externalPool (uuid), or
+ *   opts.config.externalNetwork (string name) when there are no fabrics.
  */
 function addNetworksToPayload(opts, container, payload, callback) {
     assert.object(opts, 'opts');
@@ -547,38 +562,44 @@ function addNetworksToPayload(opts, container, payload, callback) {
     assert.object(opts.config.napi, 'opts.config.napi');
     assert.object(opts.log, 'opts.log');
     assert.object(opts.config.overlay, 'opts.config.overlay');
-
     assert.optionalString(opts.config.overlay.externalPool,
         'opts.config.overlay.externalPool');
     assert.optionalBool(opts.config.overlay.enabled,
         'opts.config.overlay.enabled');
+    assert.optionalBool(opts.requireExternalNetwork,
+        'opts.requireExternalNetwork');
     assert.func(callback, 'callback');
 
-    /*
-     * currently there are four network possibilities:
-     *  - no fabrics configured -> external network.
-     *  - fabrics configured and...
-     *    - 'bridge' or no network specified: default fabric
-     *    - 'fabric' name or id specified: that specific fabric
-     */
-    if (!opts.config.overlay.enabled) {
-        return externalNetworkByName(opts, payload, callback);
-    } else {
-        if (container.HostConfig.NetworkMode === 'bridge'
-            || container.HostConfig.NetworkMode === 'default'
-            || common.objEmpty(container.HostConfig.NetworkMode)) {
-            return defaultFabricNetwork(opts, payload, callback);
-        } else {
-            return namedNetwork(opts, container, payload, callback);
+    vasync.pipeline({ funcs: [
+        function addFabricNetworks(_, next) {
+            if (!opts.config.overlay.enabled) {
+                next();
+                return;
+            }
+            if (container.HostConfig.NetworkMode === 'bridge'
+                || container.HostConfig.NetworkMode === 'default'
+                || common.objEmpty(container.HostConfig.NetworkMode)) {
+                defaultFabricNetwork(opts, payload, next);
+            } else {
+                namedNetwork(opts, container, payload, next);
+            }
+        },
+
+        function addExternalNetwork(_, next) {
+            if (!opts.requireExternalNetwork && opts.config.overlay.enabled
+                && !publishingPorts(container)) {
+                next();
+                return;
+            }
+            externalNetworkByName(opts, container, payload, next);
         }
-    }
+    ]}, callback);
 }
 
 /*
- * When fabrics are not configured, we will use the named
- * network, defaulting to 'external'.
+ * Add the required external network to the payload.networks.
  */
-function externalNetworkByName(opts, payload, callback) {
+function externalNetworkByName(opts, container, payload, callback) {
     assert.object(opts.config, 'opts.config');
     assert.optionalString(opts.config.externalNetwork,
         'opts.config.externalNetwork');
@@ -588,8 +609,38 @@ function externalNetworkByName(opts, payload, callback) {
     assert.func(callback, 'callback');
 
     var log = opts.log;
+
+    var externalNetworkName;
+    var labels = container.Labels || {};
+    if (Object.prototype.hasOwnProperty.call(labels,
+        TRITON_PUBLIC_NETWORK_LABEL))
+    {
+        externalNetworkName = labels[TRITON_PUBLIC_NETWORK_LABEL];
+    }
+
+    if (!payload.hasOwnProperty('networks')) {
+        payload.networks = [];
+    } else {
+        // Ensure the external network is the *only* primary network.
+        payload.networks.forEach(function (nw) {
+            delete nw.primary;
+        });
+    }
+
+    // When fabrics are enabled and no external name has been specified, use the
+    // opts.config.overlay.externalPool uuid for the default external network.
+    if (!externalNetworkName && opts.config.overlay.enabled) {
+        assert.string(opts.config.overlay.externalPool,
+            'opts.config.overlay.externalPool');
+        payload.networks.push(
+            { uuid: opts.config.overlay.externalPool, primary: true });
+        callback();
+        return;
+    }
+
+    // Find the external network using the given (or default) network name.
     var listParams = {
-        name: opts.config.externalNetwork || 'external',
+        name: externalNetworkName || opts.config.externalNetwork || 'external',
         fabric: false,
         provisionable_by: opts.account.uuid
     };
@@ -617,7 +668,8 @@ function externalNetworkByName(opts, payload, callback) {
             return;
         }
 
-        payload.networks = [ { uuid: networks[0].uuid, primary: true} ];
+        payload.networks.push({uuid: networks[0].uuid, primary: true});
+
         callback();
         return;
     });
@@ -629,7 +681,7 @@ function externalNetworkByName(opts, payload, callback) {
  * network, stored in UFDS.
  *
  * Additionally, if the user is publishing ports or we have the
- * `fabricRequireExternal` option (currently used by docker build,
+ * `requireExternalNetwork` option (currently used by docker build,
  * see DOCKER-705), we will also attach to configured network pool
  * (typically the external/public pool).
  */
@@ -1965,28 +2017,6 @@ function buildVmPayload(opts, container, callback) {
             addNetworksToPayload(opts, container, payload, cb);
         },
 
-        function addExternalNet(_, cb) {
-            assert.object(opts.config, 'config');
-            assert.object(opts.config.overlay, 'config.overlay');
-            assert.bool(opts.config.overlay.enabled,
-                'config.overlay.enabled');
-            if (opts.config.overlay.enabled
-                && (publishingPorts(container) || opts.fabricRequireExternal)) {
-                assert.string(opts.config.overlay.externalPool,
-                    'opts.config.overlay.externalPool');
-                // external must be primary.
-                payload.networks.forEach(function (nw) {
-                    delete nw.primary;
-                });
-
-                payload.networks.push(
-                    { uuid: opts.config.overlay.externalPool, primary: true });
-            }
-
-            cb();
-            return;
-        },
-
         function handleVolumesFrom(_, cb) {
             // This must happen after we've added the owner_uuid to the payload.
             // ...and is where we add --volumes-from volumes.
@@ -2932,8 +2962,8 @@ function createContainer(opts, callback) {
     assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.account, 'opts.account');
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
-    assert.optionalBool(opts.fabricRequireExternal,
-                        'opts.fabricRequireExternal');
+    assert.optionalBool(opts.requireExternalNetwork,
+        'opts.requireExternalNetwork');
 
     var log = opts.log || this.log;
     var name = opts.name;
@@ -2956,7 +2986,7 @@ function createContainer(opts, callback) {
         buildVmPayload({
             app: opts.app,
             config: config,
-            fabricRequireExternal: opts.fabricRequireExternal,
+            requireExternalNetwork: opts.requireExternalNetwork,
             image: opts.image,
             log: log,
             req_id: opts.req_id,
diff --git a/package.json b/package.json
index d75c9e5..8d461e0 100644
--- a/package.json
+++ b/package.json
@@ -26,7 +26,7 @@
     "strsplit": "1.0.0",
     "tape": "^4.4.0",
     "trace-event": "1.2.0",
-    "triton-tags": "1.0.0",
+    "triton-tags": "1.1.4",
     "ufds": "1.2.0",
     "vasync": "1.6.3",
     "verror": "1.9.0",
diff --git a/test/integration/api-create.test.js b/test/integration/api-create.test.js
index 97dfe07..fa93c49 100644
--- a/test/integration/api-create.test.js
+++ b/test/integration/api-create.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -633,3 +633,117 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         }
     });
 });
+
+
+/*
+ * Tests for `docker run --label triton.network.public=foo`
+ *
+ * DOCKER-1020 Ensure we can provision to the external (public) network of our
+ * choice by setting the appropriate triton label.
+ */
+test('run external network (docker run --label triton.network.public=)',
+    function (tt) {
+
+    var externalNetwork;
+
+    tt.test('add external network', function (t) {
+        // create a new one.
+        var nwUuid = libuuid.create();
+        var nwParams = {
+            name: 'sdcdockertest_apicreate_external',
+            nic_tag: 'external',
+            subnet: '10.0.11.0/24',
+            provision_start_ip: '10.0.11.2',
+            provision_end_ip: '10.0.11.254',
+            uuid: nwUuid,
+            vlan_id: 5,
+            gateway: '10.0.11.1',
+            resolvers: ['8.8.8.8', '8.8.4.4']
+        };
+        h.getOrCreateExternalNetwork(NAPI, nwParams, function (err, network) {
+            t.ifErr(err, 'getOrCreateExternalNetwork');
+            externalNetwork = network;
+            t.end();
+        });
+    });
+
+    // Attempt a run with the external name, ensure the container is assigned
+    // the external network that was asked for.
+    tt.test('run with custom external network name', function (t) {
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: { Labels: { 'triton.network.public': externalNetwork.name }},
+            start: true
+        }, oncreate);
+
+        function oncreate(err, result) {
+            var extNic;
+            var nics = result.vm.nics;
+            if (FABRICS) {
+                // Expect two nics, one fabric and one external.
+                t.equal(nics.length, 2, 'two nics');
+                extNic = (nics[0].nic_tag === 'external' ? nics[0] : nics[1]);
+            } else {
+                t.equal(nics.length, 1, 'only one nic');
+                extNic = nics[0];
+            }
+            t.equal(extNic.network_uuid, externalNetwork.uuid,
+                'correct external network');
+            DOCKER_ALICE.del('/containers/' + result.id + '?force=1', ondelete);
+        }
+
+        function ondelete(err) {
+            t.ifErr(err, 'delete external network testing container');
+            t.end();
+        }
+    });
+
+    // Attempt a run with the external name whilst publishing ports, ensure the
+    // container is assigned the external network that was asked for.
+    tt.test('run custom external network name, published ports', function (t) {
+        h.createDockerContainer({
+            vmapiClient: VMAPI,
+            dockerClient: DOCKER_ALICE,
+            test: t,
+            extra: {
+                'HostConfig.PublishAllPorts': true,
+                Labels: { 'triton.network.public': externalNetwork.name }
+            },
+            start: true
+        }, oncreate);
+
+        function oncreate(err, result) {
+            var extNic;
+            var nics = result.vm.nics;
+            if (FABRICS) {
+                // Expect two nics, one fabric and one external.
+                t.equal(nics.length, 2, 'two nics');
+                extNic = (nics[0].nic_tag === 'external' ? nics[0] : nics[1]);
+            } else {
+                t.equal(nics.length, 1, 'one nic');
+                extNic = nics[0];
+            }
+            t.equal(extNic.network_uuid, externalNetwork.uuid,
+                'correct external network');
+            DOCKER_ALICE.del('/containers/' + result.id + '?force=1', ondelete);
+        }
+
+        function ondelete(err) {
+            t.ifErr(err, 'delete external network testing container');
+            t.end();
+        }
+    });
+
+    tt.test('external network cleanup', function (t) {
+        if (!externalNetwork) {
+            t.end();
+            return;
+        }
+        NAPI.deleteNetwork(externalNetwork.uuid, function (err) {
+            t.ifErr(err, 'external network deletion');
+            t.end();
+        });
+    });
+});
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index 5405801..47094d7 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -1793,6 +1793,30 @@ function getOrCreateFabricVLAN(client, userUuid, fabricParams, callback) {
     );
 }
 
+/*
+ * Gets or creates an external network for use in testing; based on the
+ * network *name*.
+ */
+function getOrCreateExternalNetwork(client, params, callback) {
+    assert.object(client, 'napi client');
+    assert.object(params, 'network params');
+
+    var listParams = {
+        name: params.name
+    };
+    client.listNetworks(listParams,
+        function (err, networks) {
+            if (err) {
+                return callback(err);
+            }
+            if (networks.length !== 0) {
+                return callback(null, networks[0]);
+            }
+            client.createNetwork(params, callback);
+        }
+    );
+}
+
 /*
  * Gets or creates a fabric network for use in testing; based on the
  * network *name*.
@@ -1879,6 +1903,7 @@ module.exports = {
     listContainers: listContainers,
     createDockerContainer: createDockerContainer,
     buildDockerContainer: buildDockerContainer,
+    getOrCreateExternalNetwork: getOrCreateExternalNetwork,
     getOrCreateFabricVLAN: getOrCreateFabricVLAN,
     getOrCreateFabricNetwork: getOrCreateFabricNetwork,
     getSortedPackages: getSortedPackages,
-- 
2.21.0

