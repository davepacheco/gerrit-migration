From b6e1a594f93e872981b2a61d32cdf065aa4c8af0 Mon Sep 17 00:00:00 2001
From: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date: Tue, 25 Jun 2019 09:49:00 -0600
Subject: [PATCH] MANTA-4299 Plumb request id into boray

---
 src/bucket.rs         | 386 ++----------------------------
 src/bucket/create.rs  | 116 +++++++++
 src/bucket/delete.rs  | 132 +++++++++++
 src/bucket/get.rs     |  96 ++++++++
 src/bucket/list.rs    | 105 +++++++++
 src/lib.rs            |  53 +++--
 src/object.rs         | 533 ++----------------------------------------
 src/object/create.rs  | 143 ++++++++++++
 src/object/delete.rs  | 126 ++++++++++
 src/object/get.rs     | 103 ++++++++
 src/object/list.rs    | 122 ++++++++++
 src/object/update.rs  | 136 +++++++++++
 tests/rpc_handlers.rs |  73 +++---
 13 files changed, 1190 insertions(+), 934 deletions(-)
 create mode 100644 src/bucket/create.rs
 create mode 100644 src/bucket/delete.rs
 create mode 100644 src/bucket/get.rs
 create mode 100644 src/bucket/list.rs
 create mode 100644 src/object/create.rs
 create mode 100644 src/object/delete.rs
 create mode 100644 src/object/get.rs
 create mode 100644 src/object/list.rs
 create mode 100644 src/object/update.rs

diff --git a/src/bucket.rs b/src/bucket.rs
index f5f27f1..6d219d1 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -6,287 +6,54 @@ use std::io::Error as IOError;
 use std::io::ErrorKind as IOErrorKind;
 
 use chrono;
-use cueball::connection_pool::ConnectionPool;
-use cueball::backend::Backend;
-use cueball_static_resolver::StaticIpResolver;
-use cueball_postgres_connection::PostgresConnection;
-use rust_fast::protocol::{FastMessage, FastMessageData};
 use serde_derive::{Deserialize, Serialize};
-use serde_json::{json, Value};
-use slog::{Logger, debug};
+use serde_json::Value;
 use uuid::Uuid;
 
 use crate::error::{BorayError, BorayErrorType};
-use crate::sql;
 use crate::util::Rows;
 
+pub mod create;
+pub mod delete;
+pub mod get;
+pub mod list;
+
 type Timestamptz = chrono::DateTime<chrono::Utc>;
 
 #[derive(Serialize, Deserialize)]
 pub struct GetBucketPayload {
-    pub owner     : Uuid,
-    pub name      : String,
-    pub vnode     : u64
+    pub owner      : Uuid,
+    pub name       : String,
+    pub vnode      : u64,
+    pub request_id : Uuid
 }
 
 type DeleteBucketPayload = GetBucketPayload;
 
 #[derive(Serialize, Deserialize, Debug)]
 pub struct BucketResponse {
-    pub id      : Uuid,
-    pub owner   : Uuid,
-    pub name    : String ,
-    pub created : Timestamptz
+    pub id         : Uuid,
+    pub owner      : Uuid,
+    pub name       : String ,
+    pub created    : Timestamptz
 }
 
-#[derive(Serialize, Deserialize)]
-pub struct CreateBucketPayload {
-    pub owner : Uuid,
-    pub name  : String,
-    pub vnode : u64
-}
 
-#[derive(Serialize, Deserialize)]
-pub struct ListBucketsPayload {
-    pub owner    : Uuid,
-    pub vnode    : u64,
-    pub prefix   : String,
-    pub order_by : String,
-    pub limit    : u64,
-    pub offset   : u64
-}
-
-fn array_wrap(v: Value) -> Value {
-    Value::Array(vec![v])
-}
-
-pub fn bucket_not_found() -> Value {
+pub(self) fn bucket_not_found() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
     serde_json::to_value(BorayError::new(BorayErrorType::BucketNotFound))
         .expect("failed to encode a BucketNotFound error")
 }
 
-pub fn bucket_already_exists() -> Value {
+pub(self) fn bucket_already_exists() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
     serde_json::to_value(BorayError::new(BorayErrorType::BucketAlreadyExists))
         .expect("failed to encode a BucketAlreadyExists error")
 }
 
-pub fn get_handler(msg_id: u32,
-                   args: &[Value],
-                   mut response: Vec<FastMessage>,
-                   pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                   log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling getbucket function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<GetBucketPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for getbucket function"))
-    };
-
-    // Make db request and form response
-    get(payload, pool)
-        .and_then(|maybe_resp| {
-            let method = String::from("getbucket");
-            match maybe_resp {
-                Some(resp) => {
-                    let value = array_wrap(serde_json::to_value(resp).unwrap());
-                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(msg);
-                    Ok(response)
-                },
-                None => {
-                    let value = array_wrap(bucket_not_found());
-                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(err_msg);
-                    Ok(response)
-                }
-            }
-        })
-        //TODO: Proper error handling
-        .map_err(|e| {
-            println!("Error: {}", e);
-            other_error("postgres error")
-        })
-}
-
-pub fn list_handler(msg_id: u32,
-                    args: &[Value],
-                    mut response: Vec<FastMessage>,
-                    pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                    log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling listbuckets function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<ListBucketsPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for listbuckets function"))
-    };
-
-    // TODO catch these as errors and return to the caller
-    assert!(payload.limit > 0);
-    assert!(payload.limit <= 1000);
-
-    match payload.order_by.as_ref() {
-        "created" | "name" => {},
-        _ => return Err(other_error("Unexpected value for payload.order_by"))
-    }
-
-    let prefix = format!("{}%", &payload.prefix);
-
-    // Make db request and form response
-    // TODO: make this call safe
-    let mut conn = pool.claim().unwrap();
-
-    let mut txn = (*conn).transaction().unwrap();
-    let list_sql = list_sql(payload.vnode, payload.limit,
-        payload.offset, &payload.order_by);
-
-    for row in sql::txn_query(sql::Method::BucketList, &mut txn, list_sql.as_str(),
-                              &[&payload.owner,
-                              &prefix]).unwrap().iter() {
-
-        let resp = BucketResponse {
-            id: row.get(0),
-            owner: row.get(1),
-            name: row.get(2),
-            created: row.get(3)
-        };
-
-        let value = array_wrap(serde_json::to_value(resp).unwrap());
-        let msg = FastMessage::data(msg_id, FastMessageData::new(String::from("listbuckets"), value));
-        response.push(msg);
-    }
-
-    Ok(response)
-}
-
-pub fn create_handler(msg_id: u32,
-                   args: &[Value],
-                   mut response: Vec<FastMessage>,
-                   pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                   log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling createbucket function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<CreateBucketPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for createbucket function"))
-    };
-
-    // Make db request and form response
-    create(payload, pool)
-        .and_then(|maybe_resp| {
-            let method = String::from("createbucket");
-            match maybe_resp {
-                Some(resp) => {
-                    let value = array_wrap(serde_json::to_value(resp).unwrap());
-                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(msg);
-                    Ok(response)
-                },
-                None => {
-                    let value = array_wrap(bucket_already_exists());
-                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(err_msg);
-                    Ok(response)
-                }
-            }
-        })
-        //TODO: Proper error handling
-        .map_err(|_e| other_error("postgres error"))
-}
-
-pub fn delete_handler(msg_id: u32,
-                      args: &[Value],
-                      mut response: Vec<FastMessage>,
-                      pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                      log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling deletebucket function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<DeleteBucketPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload \
-                                          for deletebucket function"))
-    };
-
-    // Make db request and form response
-    let response_msg: Result<FastMessage, IOError> =
-        delete(payload, pool)
-        .and_then(|affected_rows| {
-            let method = String::from("deletebucket");
-            if affected_rows > 0 {
-                let value = array_wrap(serde_json::to_value(affected_rows).unwrap());
-                let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                Ok(msg)
-            } else {
-                let value = array_wrap(bucket_not_found());
-                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                Ok(err_msg)
-            }
-        })
-        .or_else(|e| {
-            // TODO: Write a helper function to deconstruct the postgres::Error
-            // and populate meaningful name and message fields for the error
-            // dependent on the details of the postgres error.
-            let err_str = format!("{}", e);
-            let value = array_wrap(json!({
-                "name": "PostgresError",
-                "message": err_str
-            }));
-            let method = String::from("deletebucket");
-            let err_msg_data = FastMessageData::new(method, value);
-            let err_msg = FastMessage::error(msg_id, err_msg_data);
-            Ok(err_msg)
-        });
-
-    response.push(response_msg.unwrap());
-    Ok(response)
-}
-
-
-fn other_error(msg: &str) -> IOError {
-    IOError::new(IOErrorKind::Other, String::from(msg))
-}
-
-
-fn response(rows: Rows) -> Result<Option<BucketResponse>, IOError> {
+pub(self) fn response(rows: Rows) -> Result<Option<BucketResponse>, IOError> {
     if rows.is_empty() {
         Ok(None)
     } else if rows.len() == 1 {
@@ -306,122 +73,3 @@ fn response(rows: Rows) -> Result<Option<BucketResponse>, IOError> {
         Err(IOError::new(IOErrorKind::Other, err))
     }
 }
-
-fn get_sql(vnode: u64) -> String {
-    ["SELECT id, owner, name, created \
-      FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket WHERE owner = $1 \
-       AND name = $2"].concat()
-}
-
-fn create_sql(vnode: u64) -> String {
-    ["INSERT INTO manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket \
-       (id, owner, name) \
-       VALUES ($1, $2, $3) \
-       ON CONFLICT DO NOTHING \
-       RETURNING id, owner, name, created"].concat()
-}
-
-fn list_sql(vnode: u64, limit: u64, offset: u64, order_by: &str) -> String {
-    format!("SELECT id, owner, name, created
-        FROM manta_bucket_{}.manta_bucket
-        WHERE owner = $1 AND name like $2
-        ORDER BY {} ASC
-        LIMIT {}
-        OFFSET {}",
-        vnode, order_by, limit, offset)
-}
-
-fn get(payload: GetBucketPayload,
-       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-       -> Result<Option<BucketResponse>, IOError>
-{
-    let mut conn = pool.claim().unwrap();
-    let sql = get_sql(payload.vnode);
-
-    sql::query(sql::Method::BucketGet, &mut conn, sql.as_str(),
-               &[&payload.owner,
-               &payload.name])
-        .map_err(|e| {
-           let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
-        })
-        .and_then(response)
-}
-
-
-fn create(payload: CreateBucketPayload,
-       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-       -> Result<Option<BucketResponse>, IOError>
-{
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
-    let create_sql = create_sql(payload.vnode);
-
-    let insert_result =
-        sql::txn_query(sql::Method::BucketCreate, &mut txn, create_sql.as_str(),
-                       &[&Uuid::new_v4(),
-                       &payload.owner,
-                       &payload.name])
-        .map_err(|e| {
-           let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
-        })
-        .and_then(response);
-
-    txn.commit().unwrap();
-
-    insert_result
-}
-
-fn insert_delete_table_sql(vnode: u64) -> String {
-    let vnode_str = vnode.to_string();
-    ["INSERT INTO manta_bucket_",
-     &vnode_str,
-     &".manta_bucket_deleted_bucket \
-      (id, owner, name, created) \
-      SELECT id, owner, name, created \
-      FROM manta_bucket_",
-     &vnode_str,
-     &".manta_bucket \
-       WHERE owner = $1 \
-       AND name = $2"].concat()
-}
-
-fn delete_sql(vnode: u64) -> String {
-    ["DELETE FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket \
-       WHERE owner = $1 \
-       AND name = $2"].concat()
-}
-
-fn delete(payload: DeleteBucketPayload,
-          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-          -> Result<u64, IOError>
-{
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
-    let move_sql = insert_delete_table_sql(payload.vnode);
-    let delete_sql = delete_sql(payload.vnode);
-
-    sql::txn_execute(sql::Method::BucketDeleteMove, &mut txn, move_sql.as_str(),
-                     &[&payload.owner,
-                     &payload.name])
-        .and_then(|_moved_rows| {
-            sql::txn_execute(sql::Method::BucketDelete, &mut txn, delete_sql.as_str(),
-                             &[&payload.owner,
-                             &payload.name])
-        })
-        .and_then(|row_count| {
-            txn.commit().unwrap();
-            Ok(row_count)
-        })
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
-        })
-}
diff --git a/src/bucket/create.rs b/src/bucket/create.rs
new file mode 100644
index 0000000..54c2d28
--- /dev/null
+++ b/src/bucket/create.rs
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::io::Error as IOError;
+use std::io::ErrorKind as IOErrorKind;
+
+use serde_derive::{Deserialize, Serialize};
+use serde_json::Value;
+use slog::{Logger, debug};
+use uuid::Uuid;
+
+use cueball::backend::Backend;
+use cueball::connection_pool::ConnectionPool;
+use cueball_postgres_connection::PostgresConnection;
+use cueball_static_resolver::StaticIpResolver;
+use rust_fast::protocol::{FastMessage, FastMessageData};
+
+use crate::bucket::{
+    BucketResponse,
+    bucket_already_exists,
+    response
+};
+use crate::sql;
+use crate::util::{
+    array_wrap,
+    other_error
+};
+
+#[derive(Serialize, Deserialize)]
+pub struct CreateBucketPayload {
+    pub owner      : Uuid,
+    pub name       : String,
+    pub vnode      : u64,
+    pub request_id : Uuid
+}
+
+pub fn handler(msg_id: u32,
+               args: &[Value],
+               mut response: Vec<FastMessage>,
+               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling createbucket function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<CreateBucketPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for createbucket function"))
+    };
+
+    debug!(log, "parsed CreateBucketPayload, req_id: {}", payload.request_id);
+
+    // Make db request and form response
+    create(payload, pool)
+        .and_then(|maybe_resp| {
+            let method = String::from("createbucket");
+            match maybe_resp {
+                Some(resp) => {
+                    let value = array_wrap(serde_json::to_value(resp).unwrap());
+                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(msg);
+                    Ok(response)
+                },
+                None => {
+                    let value = array_wrap(bucket_already_exists());
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(err_msg);
+                    Ok(response)
+                }
+            }
+        })
+        //TODO: Proper error handling
+        .map_err(|_e| other_error("postgres error"))
+}
+
+fn create(payload: CreateBucketPayload,
+          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
+          -> Result<Option<BucketResponse>, IOError>
+{
+    let mut conn = pool.claim().unwrap();
+    let mut txn = (*conn).transaction().unwrap();
+    let create_sql = create_sql(payload.vnode);
+
+    let insert_result =
+        sql::txn_query(sql::Method::BucketCreate, &mut txn, create_sql.as_str(),
+                       &[&Uuid::new_v4(),
+                       &payload.owner,
+                       &payload.name])
+        .map_err(|e| {
+           let pg_err = format!("{}", e);
+            IOError::new(IOErrorKind::Other, pg_err)
+        })
+        .and_then(response);
+
+    txn.commit().unwrap();
+
+    insert_result
+}
+
+fn create_sql(vnode: u64) -> String {
+    ["INSERT INTO manta_bucket_",
+     &vnode.to_string(),
+     &".manta_bucket \
+       (id, owner, name) \
+       VALUES ($1, $2, $3) \
+       ON CONFLICT DO NOTHING \
+       RETURNING id, owner, name, created"].concat()
+}
diff --git a/src/bucket/delete.rs b/src/bucket/delete.rs
new file mode 100644
index 0000000..39d18a5
--- /dev/null
+++ b/src/bucket/delete.rs
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::io::Error as IOError;
+use std::io::ErrorKind as IOErrorKind;
+
+use slog::{Logger, debug};
+use serde_json::{json, Value};
+
+use cueball::backend::Backend;
+use cueball::connection_pool::ConnectionPool;
+use cueball_postgres_connection::PostgresConnection;
+use cueball_static_resolver::StaticIpResolver;
+use rust_fast::protocol::{FastMessage, FastMessageData};
+
+use crate::bucket::{
+    DeleteBucketPayload,
+    bucket_not_found
+};
+use crate::sql;
+use crate::util::{
+    array_wrap,
+    other_error
+};
+
+pub fn handler(msg_id: u32,
+               args: &[Value],
+               mut response: Vec<FastMessage>,
+               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling deletebucket function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<DeleteBucketPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload \
+                                          for deletebucket function"))
+    };
+
+    debug!(log, "parsed DeleteBucketPayload, req_id: {}", payload.request_id);
+
+    // Make db request and form response
+    let response_msg: Result<FastMessage, IOError> =
+        delete(payload, pool)
+        .and_then(|affected_rows| {
+            let method = String::from("deletebucket");
+            if affected_rows > 0 {
+                let value = array_wrap(serde_json::to_value(affected_rows).unwrap());
+                let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                Ok(msg)
+            } else {
+                let value = array_wrap(bucket_not_found());
+                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                Ok(err_msg)
+            }
+        })
+        .or_else(|e| {
+            // TODO: Write a helper function to deconstruct the postgres::Error
+            // and populate meaningful name and message fields for the error
+            // dependent on the details of the postgres error.
+            let err_str = format!("{}", e);
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": err_str
+            }));
+            let method = String::from("deletebucket");
+            let err_msg_data = FastMessageData::new(method, value);
+            let err_msg = FastMessage::error(msg_id, err_msg_data);
+            Ok(err_msg)
+        });
+
+    response.push(response_msg.unwrap());
+    Ok(response)
+}
+
+fn delete(payload: DeleteBucketPayload,
+          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
+          -> Result<u64, IOError>
+{
+    let mut conn = pool.claim().unwrap();
+    let mut txn = (*conn).transaction().unwrap();
+    let move_sql = insert_delete_table_sql(payload.vnode);
+    let delete_sql = delete_sql(payload.vnode);
+
+    sql::txn_execute(sql::Method::BucketDeleteMove, &mut txn, move_sql.as_str(),
+                     &[&payload.owner,
+                     &payload.name])
+        .and_then(|_moved_rows| {
+            sql::txn_execute(sql::Method::BucketDelete, &mut txn, delete_sql.as_str(),
+                             &[&payload.owner,
+                             &payload.name])
+        })
+        .and_then(|row_count| {
+            txn.commit().unwrap();
+            Ok(row_count)
+        })
+        .map_err(|e| {
+            let pg_err = format!("{}", e);
+            IOError::new(IOErrorKind::Other, pg_err)
+        })
+}
+
+fn insert_delete_table_sql(vnode: u64) -> String {
+    let vnode_str = vnode.to_string();
+    ["INSERT INTO manta_bucket_",
+     &vnode_str,
+     &".manta_bucket_deleted_bucket \
+      (id, owner, name, created) \
+      SELECT id, owner, name, created \
+      FROM manta_bucket_",
+     &vnode_str,
+     &".manta_bucket \
+       WHERE owner = $1 \
+       AND name = $2"].concat()
+}
+
+fn delete_sql(vnode: u64) -> String {
+    ["DELETE FROM manta_bucket_",
+     &vnode.to_string(),
+     &".manta_bucket \
+       WHERE owner = $1 \
+       AND name = $2"].concat()
+}
diff --git a/src/bucket/get.rs b/src/bucket/get.rs
new file mode 100644
index 0000000..ef12591
--- /dev/null
+++ b/src/bucket/get.rs
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::io::Error as IOError;
+use std::io::ErrorKind as IOErrorKind;
+
+use slog::{Logger, debug};
+use serde_json::Value;
+
+use cueball::backend::Backend;
+use cueball::connection_pool::ConnectionPool;
+use cueball_postgres_connection::PostgresConnection;
+use cueball_static_resolver::StaticIpResolver;
+use rust_fast::protocol::{FastMessage, FastMessageData};
+
+use crate::bucket::{GetBucketPayload, BucketResponse, bucket_not_found, response};
+use crate::util::{
+    array_wrap,
+    other_error
+};
+use crate::sql;
+
+pub fn handler(msg_id: u32,
+               args: &[Value],
+               mut response: Vec<FastMessage>,
+               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling getbucket function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<GetBucketPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for getbucket function"))
+    };
+
+    debug!(log, "parsed GetBucketPayload, req_id: {}", payload.request_id);
+
+    // Make db request and form response
+    get(payload, pool)
+        .and_then(|maybe_resp| {
+            let method = String::from("getbucket");
+            match maybe_resp {
+                Some(resp) => {
+                    let value = array_wrap(serde_json::to_value(resp).unwrap());
+                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(msg);
+                    Ok(response)
+                },
+                None => {
+                    let value = array_wrap(bucket_not_found());
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(err_msg);
+                    Ok(response)
+                }
+            }
+        })
+        //TODO: Proper error handling
+        .map_err(|e| {
+            println!("Error: {}", e);
+            other_error("postgres error")
+        })
+}
+
+fn get(payload: GetBucketPayload,
+       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
+       -> Result<Option<BucketResponse>, IOError>
+{
+    let mut conn = pool.claim().unwrap();
+    let sql = get_sql(payload.vnode);
+
+    sql::query(sql::Method::BucketGet, &mut conn, sql.as_str(),
+               &[&payload.owner,
+               &payload.name])
+        .map_err(|e| {
+           let pg_err = format!("{}", e);
+            IOError::new(IOErrorKind::Other, pg_err)
+        })
+        .and_then(response)
+}
+
+fn get_sql(vnode: u64) -> String {
+    ["SELECT id, owner, name, created \
+      FROM manta_bucket_",
+     &vnode.to_string(),
+     &".manta_bucket WHERE owner = $1 \
+       AND name = $2"].concat()
+}
diff --git a/src/bucket/list.rs b/src/bucket/list.rs
new file mode 100644
index 0000000..60489a5
--- /dev/null
+++ b/src/bucket/list.rs
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::io::Error as IOError;
+
+use serde_derive::{Deserialize, Serialize};
+use serde_json::Value;
+use slog::{Logger, debug};
+use uuid::Uuid;
+
+use cueball::backend::Backend;
+use cueball::connection_pool::ConnectionPool;
+use cueball_postgres_connection::PostgresConnection;
+use cueball_static_resolver::StaticIpResolver;
+use rust_fast::protocol::{FastMessage, FastMessageData};
+
+use crate::bucket::BucketResponse;
+use crate::sql;
+use crate::util::{
+    array_wrap,
+    other_error
+};
+
+#[derive(Serialize, Deserialize)]
+pub struct ListBucketsPayload {
+    pub owner      : Uuid,
+    pub vnode      : u64,
+    pub prefix     : String,
+    pub order_by   : String,
+    pub limit      : u64,
+    pub offset     : u64,
+    pub request_id : Uuid
+}
+
+pub fn handler(msg_id: u32,
+               args: &[Value],
+               mut response: Vec<FastMessage>,
+               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling listbuckets function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<ListBucketsPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for listbuckets function"))
+    };
+
+    debug!(log, "parsed ListBucketPayload, req_id: {}", payload.request_id);
+
+    // TODO catch these as errors and return to the caller
+    assert!(payload.limit > 0);
+    assert!(payload.limit <= 1000);
+
+    match payload.order_by.as_ref() {
+        "created" | "name" => {},
+        _ => return Err(other_error("Unexpected value for payload.order_by"))
+    }
+
+    let prefix = format!("{}%", &payload.prefix);
+
+    // Make db request and form response
+    // TODO: make this call safe
+    let mut conn = pool.claim().unwrap();
+
+    let mut txn = (*conn).transaction().unwrap();
+    let list_sql = list_sql(payload.vnode, payload.limit,
+        payload.offset, &payload.order_by);
+
+    for row in sql::txn_query(sql::Method::BucketList, &mut txn, list_sql.as_str(),
+                              &[&payload.owner,
+                              &prefix]).unwrap().iter() {
+
+        let resp = BucketResponse {
+            id: row.get(0),
+            owner: row.get(1),
+            name: row.get(2),
+            created: row.get(3)
+        };
+
+        let value = array_wrap(serde_json::to_value(resp).unwrap());
+        let msg = FastMessage::data(msg_id, FastMessageData::new(String::from("listbuckets"), value));
+        response.push(msg);
+    }
+
+    Ok(response)
+}
+
+fn list_sql(vnode: u64, limit: u64, offset: u64, order_by: &str) -> String {
+    format!("SELECT id, owner, name, created
+        FROM manta_bucket_{}.manta_bucket
+        WHERE owner = $1 AND name like $2
+        ORDER BY {} ASC
+        LIMIT {}
+        OFFSET {}",
+        vnode, order_by, limit, offset)
+}
diff --git a/src/lib.rs b/src/lib.rs
index 3a26601..5a4f269 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -10,18 +10,20 @@ pub mod opts;
 pub mod sql;
 
 pub mod util {
+    use std::collections::HashMap;
     use std::io::{Error, ErrorKind};
     use std::time::{Duration, Instant};
 
+    use postgres::error::Error as PGError;
+    use postgres::row::Row;
+    use serde_json::Value;
+    use slog::Logger;
+
     use cueball::connection_pool::ConnectionPool;
     use cueball::backend::Backend;
     use cueball_postgres_connection::PostgresConnection;
     use cueball_static_resolver::StaticIpResolver;
-    use postgres::error::Error as PGError;
-    use postgres::row::Row;
     use rust_fast::protocol::FastMessage;
-    use serde_json::Value;
-    use slog::Logger;
 
     use crate::bucket;
     use crate::metrics;
@@ -29,15 +31,8 @@ pub mod util {
 
     pub type Rows = Vec<Row>;
     pub type PostgresResult<T> = Result<T, PGError>;
-
-    pub fn other_error(msg: &str) -> Error {
-        Error::new(ErrorKind::Other, String::from(msg))
-    }
-
-    pub fn duration_to_seconds(d: Duration) -> f64 {
-        let nanos = f64::from(d.subsec_nanos()) / 1e9;
-        d.as_secs() as f64 + nanos
-    }
+    pub type Hstore = HashMap<String, Option<String>>;
+    pub type Timestamptz = chrono::DateTime<chrono::Utc>;
 
     pub fn msg_handler(msg: &FastMessage,
                        pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
@@ -58,24 +53,23 @@ pub mod util {
         let method = msg.data.m.name.as_str();
         let ret = match method {
             "getobject"    =>
-                object::get_handler(msg.id, &args, response, &pool, &log),
+                object::get::handler(msg.id, &args, response, &pool, &log),
             "createobject" =>
-                object::create_handler(msg.id, &args, response, &pool, &log),
+                object::create::handler(msg.id, &args, response, &pool, &log),
             "updateobject" =>
-                object::update_handler(msg.id, &args, response, &pool, &log),
+                object::update::handler(msg.id, &args, response, &pool, &log),
             "deleteobject" =>
-                object::delete_handler(msg.id, &args, response, &pool, &log),
-
+                object::delete::handler(msg.id, &args, response, &pool, &log),
             "listobjects"  =>
-                object::list_handler(msg.id, &args, response, &pool, &log),
+                object::list::handler(msg.id, &args, response, &pool, &log),
             "getbucket"    =>
-                bucket::get_handler(msg.id, &args, response, &pool, &log),
+                bucket::get::handler(msg.id, &args, response, &pool, &log),
             "createbucket" =>
-                bucket::create_handler(msg.id, &args, response, &pool, &log),
+                bucket::create::handler(msg.id, &args, response, &pool, &log),
             "deletebucket" =>
-                bucket::delete_handler(msg.id, &args, response, &pool, &log),
+                bucket::delete::handler(msg.id, &args, response, &pool, &log),
             "listbuckets"  =>
-                bucket::list_handler(msg.id, &args, response, &pool, &log),
+                bucket::list::handler(msg.id, &args, response, &pool, &log),
             _ => {
                 let err_msg = format!("Unsupported functon: {}", method);
                 return Err(Error::new(ErrorKind::Other, err_msg))
@@ -98,4 +92,17 @@ pub mod util {
 
         ret
     }
+
+    pub(crate) fn duration_to_seconds(d: Duration) -> f64 {
+        let nanos = f64::from(d.subsec_nanos()) / 1e9;
+        d.as_secs() as f64 + nanos
+    }
+
+    pub(crate) fn array_wrap(v: Value) -> Value {
+        Value::Array(vec![v])
+    }
+
+    pub(crate) fn other_error(msg: &str) -> Error {
+        Error::new(ErrorKind::Other, String::from(msg))
+    }
 }
diff --git a/src/object.rs b/src/object.rs
index dc72878..d5a1584 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -2,34 +2,41 @@
  * Copyright 2019 Joyent, Inc.
  */
 
-use std::collections::HashMap;
 use std::error::Error;
 use std::io::Error as IOError;
 use std::io::ErrorKind as IOErrorKind;
 use std::vec::Vec;
 
 use base64;
-use chrono;
 use postgres::types::{FromSql, IsNull, ToSql, Type};
 use tokio_postgres::{accepts, to_sql_checked};
 use serde_derive::{Deserialize, Serialize};
-use serde_json::{Value, json};
-use slog::{Logger, debug};
+use serde_json::Value;
 use uuid::Uuid;
 
-use cueball::connection_pool::ConnectionPool;
-use cueball::backend::Backend;
-use cueball_static_resolver::StaticIpResolver;
-use cueball_postgres_connection::PostgresConnection;
-use rust_fast::protocol::{FastMessage, FastMessageData};
-
 use crate::error::{BorayError, BorayErrorType};
-use crate::util::Rows;
-use crate::sql;
+use crate::util::{
+    Hstore,
+    Rows,
+    Timestamptz
+};
+
+pub mod create;
+pub mod delete;
+pub mod get;
+pub mod list;
+pub mod update;
 
-type Hstore = HashMap<String, Option<String>>;
-type Timestamptz = chrono::DateTime<chrono::Utc>;
+#[derive(Debug, Serialize, Deserialize)]
+pub struct GetObjectPayload {
+    pub owner      : Uuid,
+    pub bucket_id  : Uuid,
+    pub name       : String,
+    pub vnode      : u64,
+    pub request_id : Uuid
+}
 
+type DeleteObjectPayload = GetObjectPayload;
 
 /// A type that represents the information about the datacenter and storage node
 /// id of a copy of an object's data.
@@ -88,16 +95,6 @@ impl<'a> FromSql<'a> for StorageNodeIdentifier {
     accepts!(TEXT);
 }
 
-#[derive(Debug, Serialize, Deserialize)]
-pub struct GetObjectPayload {
-    pub owner     : Uuid,
-    pub bucket_id : Uuid,
-    pub name      : String,
-    pub vnode     : u64
-}
-
-type DeleteObjectPayload = GetObjectPayload;
-
 #[derive(Debug, Serialize, Deserialize)]
 pub struct ObjectResponse {
     pub id             : Uuid,
@@ -114,333 +111,14 @@ pub struct ObjectResponse {
     pub properties     : Option<Value>
 }
 
-#[derive(Debug, Serialize, Deserialize)]
-pub struct CreateObjectPayload {
-    pub owner          : Uuid,
-    pub bucket_id      : Uuid,
-    pub name           : String,
-    pub id             : Uuid,
-    pub vnode          : u64,
-    pub content_length : i64,
-    pub content_md5    : String,
-    pub content_type   : String,
-    pub headers        : Hstore,
-    pub sharks         : Vec<StorageNodeIdentifier>,
-    pub properties     : Option<Value>
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-pub struct UpdateObjectPayload {
-    pub owner          : Uuid,
-    pub bucket_id      : Uuid,
-    pub name           : String,
-    pub id             : Uuid,
-    pub vnode          : u64,
-    pub content_type   : String,
-    pub headers        : Hstore,
-    pub properties     : Option<Value>
-}
-
-#[derive(Debug, Serialize, Deserialize)]
-pub struct ListObjectsPayload {
-    pub owner     : Uuid,
-    pub bucket_id : Uuid,
-    pub vnode     : u64,
-    pub prefix    : String,
-    pub order_by  : String,
-    pub limit     : u64,
-    pub offset    : u64
-}
-
-pub fn object_not_found() -> Value {
+pub(self) fn object_not_found() -> Value {
     // The data for this JSON conversion is locally controlled
     // so unwrapping the result is ok here.
     serde_json::to_value(BorayError::new(BorayErrorType::ObjectNotFound))
         .expect("failed to encode a ObjectNotFound error")
 }
 
-pub fn get_handler(msg_id: u32,
-                   args: &[Value],
-                   mut response: Vec<FastMessage>,
-                   pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                      log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling getobject function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<GetObjectPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for getobject function"))
-    };
-
-    get(payload, pool)
-        .and_then(|maybe_resp| {
-            let method = String::from("getobject");
-            match maybe_resp {
-                Some(resp) => {
-                    let value = array_wrap(serde_json::to_value(resp).unwrap());
-                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(msg);
-                    Ok(response)
-                },
-                None => {
-                    let value = array_wrap(object_not_found());
-                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(err_msg);
-                    Ok(response)
-                }
-            }
-        })
-        //TODO: Proper error handling
-        .map_err(|e| {
-            println!("Error: {}", e);
-            other_error("postgres error")
-        })
-}
-
-pub fn list_handler(msg_id: u32,
-                    args: &[Value],
-                    mut response: Vec<FastMessage>,
-                    pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                    log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling listobjects function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<ListObjectsPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for listobjects function"))
-    };
-
-    // TODO catch these as errors and return to the caller
-    assert!(payload.limit > 0);
-    assert!(payload.limit <= 1000);
-
-    match payload.order_by.as_ref() {
-        "created" | "name" => {},
-        _ => return Err(other_error("Unexpected value for payload.order_by"))
-    }
-
-    let prefix = format!("{}%", &payload.prefix);
-
-    // Make db request and form response
-    // TODO: make this call safe
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
-    let list_sql = list_sql(payload.vnode, payload.limit, payload.offset,
-        &payload.order_by);
-
-    for row in sql::txn_query(sql::Method::ObjectList, &mut txn, list_sql.as_str(),
-                              &[&payload.owner,
-                              &payload.bucket_id,
-                              &prefix]).unwrap().iter() {
-
-        let content_md5_bytes: Vec<u8> = row.get(7);
-        let content_md5 = base64::encode(&content_md5_bytes);
-        let resp = ObjectResponse {
-            id             : row.get(0),
-            owner          : row.get(1),
-            bucket_id      : row.get(2),
-            name           : row.get(3),
-            created        : row.get(4),
-            modified       : row.get(5),
-            content_length : row.get(6),
-            content_md5,
-            content_type   : row.get(8),
-            headers        : row.get(9),
-            sharks         : row.get(10),
-            properties     : row.get(11),
-        };
-
-        let value = array_wrap(serde_json::to_value(resp).unwrap());
-        let msg = FastMessage::data(msg_id, FastMessageData::new(String::from("listobjects"), value));
-        response.push(msg);
-    }
-
-    Ok(response)
-}
-
-pub fn create_handler(msg_id: u32,
-                   args: &[Value],
-                   mut response: Vec<FastMessage>,
-                   pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                   log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling createobject function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<CreateObjectPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for createobject function"))
-    };
-
-    // Make db request and form response
-    create(payload, pool)
-        .and_then(|resp| {
-            let method = String::from("createobject");
-            let value = array_wrap(serde_json::to_value(resp).unwrap());
-            let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-            response.push(msg);
-            Ok(response)
-        })
-        //TODO: Proper error handling
-        .map_err(|_e| other_error("postgres error"))
-}
-
-pub fn update_handler(msg_id: u32,
-                      args: &[Value],
-                      mut response: Vec<FastMessage>,
-                      pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-                      log: &Logger) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling updateobject function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<UpdateObjectPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload for updateobject function"))
-    };
-
-    // Make db request and form response
-    // let response_msg: Result<FastMessage, IOError> =
-    update(payload, pool)
-        .and_then(|maybe_resp| {
-            let method = String::from("updateobject");
-            match maybe_resp {
-                Some(resp) => {
-                    let value = array_wrap(serde_json::to_value(resp).unwrap());
-                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(msg);
-                    Ok(response)
-                },
-                None => {
-                    let value = array_wrap(object_not_found());
-                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                    response.push(err_msg);
-                    Ok(response)
-                }
-            }
-        })
-        //TODO: Proper error handling
-        .map_err(|e| {
-            println!("Error: {}", e);
-            other_error("postgres error")
-        })
-}
-
-pub fn delete_handler(
-    msg_id: u32,
-    args: &[Value],
-    mut response: Vec<FastMessage>,
-    pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
-    log: &Logger
-) -> Result<Vec<FastMessage>, IOError> {
-    debug!(log, "handling deleteobject function request");
-
-    let arg0 = match &args[0] {
-        Value::Object(_) => &args[0],
-        _ => return Err(other_error("Expected JSON object"))
-    };
-
-    let data_clone = arg0.clone();
-    let payload_result: Result<DeleteObjectPayload, _> =
-        serde_json::from_value(data_clone);
-
-    let payload = match payload_result {
-        Ok(o) => o,
-        Err(_) => return Err(other_error("Failed to parse JSON data as payload \
-                                          for deleteobject function"))
-    };
-
-    // Make db request and form response
-    let response_msg: Result<FastMessage, IOError> =
-        delete(payload, pool)
-        .and_then(|affected_rows| {
-            let method = String::from("deleteobject");
-            if affected_rows > 0 {
-                let value = array_wrap(serde_json::to_value(affected_rows).unwrap());
-                let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                Ok(msg)
-            } else {
-                let value = array_wrap(object_not_found());
-                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
-                Ok(err_msg)
-            }
-        })
-        .or_else(|e| {
-            // TODO: Write a helper function to deconstruct the postgres::Error
-            // and populate meaningful name and message fields for the error
-            // dependent on the details of the postgres error.
-            let err_str = format!("{}", e);
-            let value = array_wrap(json!({
-                "name": "PostgresError",
-                "message": err_str
-            }));
-            let method = String::from("deleteobject");
-            let err_msg_data = FastMessageData::new(method, value);
-            let err_msg = FastMessage::error(msg_id, err_msg_data);
-            Ok(err_msg)
-        });
-
-    response.push(response_msg.unwrap());
-    Ok(response)
-}
-
-fn array_wrap(v: Value) -> Value {
-    Value::Array(vec![v])
-}
-
-fn other_error(msg: &str) -> IOError {
-    IOError::new(IOErrorKind::Other, String::from(msg))
-}
-
-fn get(payload: GetObjectPayload,
-       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-       -> Result<Option<ObjectResponse>, IOError>
-{
-    let mut conn = pool.claim().unwrap();
-    let sql = get_sql(payload.vnode);
-
-    sql::query(sql::Method::ObjectGet, &mut conn, sql.as_str(),
-               &[&payload.owner,
-               &payload.bucket_id,
-               &payload.name])
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
-        })
-        .and_then(response)
-}
-
-fn response(rows: Rows) -> Result<Option<ObjectResponse>, IOError> {
+pub(self) fn response(rows: Rows) -> Result<Option<ObjectResponse>, IOError> {
     if rows.is_empty() {
         Ok(None)
     } else if rows.len() == 1 {
@@ -470,94 +148,7 @@ fn response(rows: Rows) -> Result<Option<ObjectResponse>, IOError> {
     }
 }
 
-fn get_sql(vnode: u64) -> String {
-    ["SELECT id, owner, bucket_id, name, created, modified, content_length, \
-      content_md5, content_type, headers, sharks, properties \
-      FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket_object WHERE owner = $1 \
-       AND bucket_id = $2 \
-       AND name = $3"].concat()
-}
-
-fn list_sql(vnode: u64, limit: u64, offset: u64, order_by: &str) -> String {
-    format!("SELECT id, owner, bucket_id, name, created, modified, \
-        content_length, content_md5, content_type, headers, sharks, \
-        properties \
-        FROM manta_bucket_{}.manta_bucket_object
-        WHERE owner = $1 AND bucket_id = $2 AND name like $3
-        ORDER BY {} ASC
-        LIMIT {}
-        OFFSET {}",
-        vnode, order_by, limit, offset)
-}
-
-fn create(payload: CreateObjectPayload,
-       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-       -> Result<Option<ObjectResponse>, IOError>
-{
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
-    let create_sql = create_sql(payload.vnode);
-    let move_sql = insert_delete_table_sql(payload.vnode);
-    let content_md5_bytes = base64::decode(&payload.content_md5).unwrap();
-
-    sql::txn_execute(sql::Method::ObjectCreateMove, &mut txn, move_sql.as_str(),
-                     &[&payload.owner,
-                     &payload.bucket_id,
-                     &payload.name])
-        .and_then(|_moved_rows| {
-            sql::txn_query(sql::Method::ObjectCreate, &mut txn, create_sql.as_str(),
-                           &[&payload.id,
-                           &payload.owner,
-                           &payload.bucket_id,
-                           &payload.name,
-                           &payload.content_length,
-                           &content_md5_bytes,
-                           &payload.content_type,
-                           &payload.headers,
-                           &payload.sharks,
-                           &payload.properties])
-        })
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
-        })
-        .and_then(response)
-        .and_then(|response| {
-            txn.commit().unwrap();
-            Ok(response)
-        })
-}
-
-fn update(payload: UpdateObjectPayload,
-          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-          -> Result<Option<ObjectResponse>, IOError>
-{
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
-    let update_sql = update_sql(payload.vnode);
-
-    sql::txn_query(sql::Method::ObjectUpdate, &mut txn, update_sql.as_str(),
-                     &[&payload.content_type,
-                       &payload.headers,
-                       &payload.properties,
-                       &payload.owner,
-                       &payload.bucket_id,
-                       &payload.name])
-
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
-        })
-        .and_then(response)
-        .and_then(|response| {
-            txn.commit().unwrap();
-            Ok(response)
-        })
-}
-
-fn insert_delete_table_sql(vnode: u64) -> String {
+pub(self) fn insert_delete_table_sql(vnode: u64) -> String {
     let vnode_str = vnode.to_string();
     ["INSERT INTO manta_bucket_",
      &vnode_str,
@@ -575,79 +166,3 @@ fn insert_delete_table_sql(vnode: u64) -> String {
        AND bucket_id = $2 \
        AND name = $3"].concat()
 }
-
-fn create_sql(vnode: u64) -> String {
-    ["INSERT INTO manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket_object ( \
-       id, owner, bucket_id, name, content_length, content_md5, \
-       content_type, headers, sharks, properties) \
-       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) \
-       ON CONFLICT (owner, bucket_id, name) DO UPDATE \
-       SET id = EXCLUDED.id, \
-       created = current_timestamp, \
-       modified = current_timestamp, \
-       content_length = EXCLUDED.content_length, \
-       content_md5 = EXCLUDED.content_md5, \
-       content_type = EXCLUDED.content_type, \
-       headers = EXCLUDED.headers, \
-       sharks = EXCLUDED.sharks, \
-       properties = EXCLUDED.properties \
-       RETURNING id, owner, bucket_id, name, created, modified, \
-       content_length, content_md5, content_type, headers, \
-       sharks, properties"].concat()
-}
-
-fn update_sql(vnode: u64) -> String {
-    ["UPDATE manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket_object \
-       SET content_type = $1,
-       headers = $2, \
-       properties = $3, \
-       modified = current_timestamp \
-       WHERE owner = $4 \
-       AND bucket_id = $5 \
-       AND name = $6 \
-       RETURNING id, owner, bucket_id, name, created, modified, \
-       content_length, content_md5, content_type, headers, \
-       sharks, properties"].concat()
-}
-
-fn delete_sql(vnode: u64) -> String {
-    ["DELETE FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket_object \
-       WHERE owner = $1 \
-       AND bucket_id = $2 \
-       AND name = $3"].concat()
-}
-
-fn delete(payload: DeleteObjectPayload,
-          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
-          -> Result<u64, IOError>
-{
-    let mut conn = pool.claim().unwrap();
-    let mut txn = (*conn).transaction().unwrap();
-    let move_sql = insert_delete_table_sql(payload.vnode);
-    let delete_sql = delete_sql(payload.vnode);
-
-    sql::txn_execute(sql::Method::ObjectDeleteMove, &mut txn, move_sql.as_str(),
-                     &[&payload.owner,
-                     &payload.bucket_id,
-                     &payload.name])
-        .and_then(|_moved_rows| {
-            sql::txn_execute(sql::Method::ObjectDelete, &mut txn, delete_sql.as_str(),
-                             &[&payload.owner,
-                             &payload.bucket_id,
-                             &payload.name])
-        })
-        .and_then(|row_count| {
-            txn.commit().unwrap();
-            Ok(row_count)
-        })
-        .map_err(|e| {
-            let pg_err = format!("{}", e);
-            IOError::new(IOErrorKind::Other, pg_err)
-        })
-}
diff --git a/src/object/create.rs b/src/object/create.rs
new file mode 100644
index 0000000..36028d8
--- /dev/null
+++ b/src/object/create.rs
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::io::Error as IOError;
+use std::io::ErrorKind as IOErrorKind;
+use std::vec::Vec;
+
+use base64;
+use serde_derive::{Deserialize, Serialize};
+use serde_json::Value;
+use slog::{Logger, debug};
+use uuid::Uuid;
+
+use cueball::connection_pool::ConnectionPool;
+use cueball::backend::Backend;
+use cueball_static_resolver::StaticIpResolver;
+use cueball_postgres_connection::PostgresConnection;
+use rust_fast::protocol::{FastMessage, FastMessageData};
+
+use crate::object::{
+    ObjectResponse,
+    StorageNodeIdentifier,
+    insert_delete_table_sql,
+    response
+};
+use crate::sql;
+use crate::util::{
+    Hstore,
+    array_wrap,
+    other_error
+};
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct CreateObjectPayload {
+    pub owner          : Uuid,
+    pub bucket_id      : Uuid,
+    pub name           : String,
+    pub id             : Uuid,
+    pub vnode          : u64,
+    pub content_length : i64,
+    pub content_md5    : String,
+    pub content_type   : String,
+    pub headers        : Hstore,
+    pub sharks         : Vec<StorageNodeIdentifier>,
+    pub properties     : Option<Value>,
+    pub request_id     : Uuid
+}
+
+pub fn handler(msg_id: u32,
+                   args: &[Value],
+                   mut response: Vec<FastMessage>,
+                   pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+                   log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling createobject function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<CreateObjectPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for createobject function"))
+    };
+
+    debug!(log, "parsed CreateObjectPayload, req_id: {}", payload.request_id);
+    // Make db request and form response
+    create(payload, pool)
+        .and_then(|resp| {
+            let method = String::from("createobject");
+            let value = array_wrap(serde_json::to_value(resp).unwrap());
+            let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+            response.push(msg);
+            Ok(response)
+        })
+        //TODO: Proper error handling
+        .map_err(|_e| other_error("postgres error"))
+}
+
+fn create(payload: CreateObjectPayload,
+       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
+       -> Result<Option<ObjectResponse>, IOError>
+{
+    let mut conn = pool.claim().unwrap();
+    let mut txn = (*conn).transaction().unwrap();
+    let create_sql = create_sql(payload.vnode);
+    let move_sql = insert_delete_table_sql(payload.vnode);
+    let content_md5_bytes = base64::decode(&payload.content_md5).unwrap();
+
+    sql::txn_execute(sql::Method::ObjectCreateMove, &mut txn, move_sql.as_str(),
+                     &[&payload.owner,
+                     &payload.bucket_id,
+                     &payload.name])
+        .and_then(|_moved_rows| {
+            sql::txn_query(sql::Method::ObjectCreate, &mut txn, create_sql.as_str(),
+                           &[&payload.id,
+                           &payload.owner,
+                           &payload.bucket_id,
+                           &payload.name,
+                           &payload.content_length,
+                           &content_md5_bytes,
+                           &payload.content_type,
+                           &payload.headers,
+                           &payload.sharks,
+                           &payload.properties])
+        })
+        .map_err(|e| {
+            let pg_err = format!("{}", e);
+            IOError::new(IOErrorKind::Other, pg_err)
+        })
+        .and_then(response)
+        .and_then(|response| {
+            txn.commit().unwrap();
+            Ok(response)
+        })
+}
+
+fn create_sql(vnode: u64) -> String {
+    ["INSERT INTO manta_bucket_",
+     &vnode.to_string(),
+     &".manta_bucket_object ( \
+       id, owner, bucket_id, name, content_length, content_md5, \
+       content_type, headers, sharks, properties) \
+       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) \
+       ON CONFLICT (owner, bucket_id, name) DO UPDATE \
+       SET id = EXCLUDED.id, \
+       created = current_timestamp, \
+       modified = current_timestamp, \
+       content_length = EXCLUDED.content_length, \
+       content_md5 = EXCLUDED.content_md5, \
+       content_type = EXCLUDED.content_type, \
+       headers = EXCLUDED.headers, \
+       sharks = EXCLUDED.sharks, \
+       properties = EXCLUDED.properties \
+       RETURNING id, owner, bucket_id, name, created, modified, \
+       content_length, content_md5, content_type, headers, \
+       sharks, properties"].concat()
+}
diff --git a/src/object/delete.rs b/src/object/delete.rs
new file mode 100644
index 0000000..e08a7f7
--- /dev/null
+++ b/src/object/delete.rs
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::io::Error as IOError;
+use std::io::ErrorKind as IOErrorKind;
+use std::vec::Vec;
+
+use serde_json::{Value, json};
+use slog::{Logger, debug};
+
+use cueball::connection_pool::ConnectionPool;
+use cueball::backend::Backend;
+use cueball_static_resolver::StaticIpResolver;
+use cueball_postgres_connection::PostgresConnection;
+use rust_fast::protocol::{FastMessage, FastMessageData};
+
+use crate::object::{
+    DeleteObjectPayload,
+    insert_delete_table_sql,
+    object_not_found
+};
+use crate::sql;
+use crate::util::{
+    array_wrap,
+    other_error
+};
+
+pub fn handler(
+    msg_id: u32,
+    args: &[Value],
+    mut response: Vec<FastMessage>,
+    pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+    log: &Logger
+) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling deleteobject function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<DeleteObjectPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload \
+                                          for deleteobject function"))
+    };
+
+    debug!(log, "parsed DeleteObjectPayload, req_id: {}", payload.request_id);
+
+    // Make db request and form response
+    let response_msg: Result<FastMessage, IOError> =
+        delete(payload, pool)
+        .and_then(|affected_rows| {
+            let method = String::from("deleteobject");
+            if affected_rows > 0 {
+                let value = array_wrap(serde_json::to_value(affected_rows).unwrap());
+                let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                Ok(msg)
+            } else {
+                let value = array_wrap(object_not_found());
+                let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                Ok(err_msg)
+            }
+        })
+        .or_else(|e| {
+            // TODO: Write a helper function to deconstruct the postgres::Error
+            // and populate meaningful name and message fields for the error
+            // dependent on the details of the postgres error.
+            let err_str = format!("{}", e);
+            let value = array_wrap(json!({
+                "name": "PostgresError",
+                "message": err_str
+            }));
+            let method = String::from("deleteobject");
+            let err_msg_data = FastMessageData::new(method, value);
+            let err_msg = FastMessage::error(msg_id, err_msg_data);
+            Ok(err_msg)
+        });
+
+    response.push(response_msg.unwrap());
+    Ok(response)
+}
+
+fn delete(payload: DeleteObjectPayload,
+          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
+          -> Result<u64, IOError>
+{
+    let mut conn = pool.claim().unwrap();
+    let mut txn = (*conn).transaction().unwrap();
+    let move_sql = insert_delete_table_sql(payload.vnode);
+    let delete_sql = delete_sql(payload.vnode);
+
+    sql::txn_execute(sql::Method::ObjectDeleteMove, &mut txn, move_sql.as_str(),
+                     &[&payload.owner,
+                     &payload.bucket_id,
+                     &payload.name])
+        .and_then(|_moved_rows| {
+            sql::txn_execute(sql::Method::ObjectDelete, &mut txn, delete_sql.as_str(),
+                             &[&payload.owner,
+                             &payload.bucket_id,
+                             &payload.name])
+        })
+        .and_then(|row_count| {
+            txn.commit().unwrap();
+            Ok(row_count)
+        })
+        .map_err(|e| {
+            let pg_err = format!("{}", e);
+            IOError::new(IOErrorKind::Other, pg_err)
+        })
+}
+
+
+fn delete_sql(vnode: u64) -> String {
+    ["DELETE FROM manta_bucket_",
+     &vnode.to_string(),
+     &".manta_bucket_object \
+       WHERE owner = $1 \
+       AND bucket_id = $2 \
+       AND name = $3"].concat()
+}
diff --git a/src/object/get.rs b/src/object/get.rs
new file mode 100644
index 0000000..e2dc64c
--- /dev/null
+++ b/src/object/get.rs
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::io::Error as IOError;
+use std::io::ErrorKind as IOErrorKind;
+use std::vec::Vec;
+
+use serde_json::Value;
+use slog::{Logger, debug};
+
+use cueball::connection_pool::ConnectionPool;
+use cueball::backend::Backend;
+use cueball_static_resolver::StaticIpResolver;
+use cueball_postgres_connection::PostgresConnection;
+use rust_fast::protocol::{FastMessage, FastMessageData};
+
+use crate::object::{
+    GetObjectPayload,
+    ObjectResponse,
+    object_not_found,
+    response
+};
+use crate::sql;
+use crate::util::{
+    array_wrap,
+    other_error
+};
+
+pub fn handler(msg_id: u32,
+               args: &[Value],
+               mut response: Vec<FastMessage>,
+               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling getobject function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<GetObjectPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for getobject function"))
+    };
+
+    debug!(log, "parsed GetObjectPayload, req_id: {}", payload.request_id);
+    get(payload, pool)
+        .and_then(|maybe_resp| {
+            let method = String::from("getobject");
+            match maybe_resp {
+                Some(resp) => {
+                    let value = array_wrap(serde_json::to_value(resp).unwrap());
+                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(msg);
+                    Ok(response)
+                },
+                None => {
+                    let value = array_wrap(object_not_found());
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(err_msg);
+                    Ok(response)
+                }
+            }
+        })
+        //TODO: Proper error handling
+        .map_err(|e| {
+            println!("Error: {}", e);
+            other_error("postgres error")
+        })
+}
+
+fn get(payload: GetObjectPayload,
+       pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
+       -> Result<Option<ObjectResponse>, IOError>
+{
+    let mut conn = pool.claim().unwrap();
+    let sql = get_sql(payload.vnode);
+
+    sql::query(sql::Method::ObjectGet, &mut conn, sql.as_str(),
+               &[&payload.owner,
+               &payload.bucket_id,
+               &payload.name])
+        .map_err(|e| {
+            let pg_err = format!("{}", e);
+            IOError::new(IOErrorKind::Other, pg_err)
+        })
+        .and_then(response)
+}
+
+fn get_sql(vnode: u64) -> String {
+    ["SELECT id, owner, bucket_id, name, created, modified, content_length, \
+      content_md5, content_type, headers, sharks, properties \
+      FROM manta_bucket_",
+     &vnode.to_string(),
+     &".manta_bucket_object WHERE owner = $1 \
+       AND bucket_id = $2 \
+       AND name = $3"].concat()
+}
diff --git a/src/object/list.rs b/src/object/list.rs
new file mode 100644
index 0000000..fae9cea
--- /dev/null
+++ b/src/object/list.rs
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::io::Error as IOError;
+use std::vec::Vec;
+
+use base64;
+use serde_derive::{Deserialize, Serialize};
+use serde_json::Value;
+use slog::{Logger, debug};
+use uuid::Uuid;
+
+use cueball::connection_pool::ConnectionPool;
+use cueball::backend::Backend;
+use cueball_static_resolver::StaticIpResolver;
+use cueball_postgres_connection::PostgresConnection;
+use rust_fast::protocol::{FastMessage, FastMessageData};
+
+use crate::object::{
+    ObjectResponse
+};
+use crate::sql;
+use crate::util::{
+    array_wrap,
+    other_error
+};
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct ListObjectsPayload {
+    pub owner      : Uuid,
+    pub bucket_id  : Uuid,
+    pub vnode      : u64,
+    pub prefix     : String,
+    pub order_by   : String,
+    pub limit      : u64,
+    pub offset     : u64,
+    pub request_id : Uuid
+}
+
+pub fn handler(msg_id: u32,
+               args: &[Value],
+               mut response: Vec<FastMessage>,
+               pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+               log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling listobjects function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<ListObjectsPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for listobjects function"))
+    };
+
+    debug!(log, "parsed ListObjectPayload, req_id: {}", payload.request_id);
+
+    // TODO catch these as errors and return to the caller
+    assert!(payload.limit > 0);
+    assert!(payload.limit <= 1000);
+
+    match payload.order_by.as_ref() {
+        "created" | "name" => {},
+        _ => return Err(other_error("Unexpected value for payload.order_by"))
+    }
+
+    let prefix = format!("{}%", &payload.prefix);
+
+    // Make db request and form response
+    // TODO: make this call safe
+    let mut conn = pool.claim().unwrap();
+    let mut txn = (*conn).transaction().unwrap();
+    let list_sql = list_sql(payload.vnode, payload.limit, payload.offset,
+        &payload.order_by);
+
+    for row in sql::txn_query(sql::Method::ObjectList, &mut txn, list_sql.as_str(),
+                              &[&payload.owner,
+                              &payload.bucket_id,
+                              &prefix]).unwrap().iter() {
+
+        let content_md5_bytes: Vec<u8> = row.get(7);
+        let content_md5 = base64::encode(&content_md5_bytes);
+        let resp = ObjectResponse {
+            id             : row.get(0),
+            owner          : row.get(1),
+            bucket_id      : row.get(2),
+            name           : row.get(3),
+            created        : row.get(4),
+            modified       : row.get(5),
+            content_length : row.get(6),
+            content_md5,
+            content_type   : row.get(8),
+            headers        : row.get(9),
+            sharks         : row.get(10),
+            properties     : row.get(11),
+        };
+
+        let value = array_wrap(serde_json::to_value(resp).unwrap());
+        let msg = FastMessage::data(msg_id, FastMessageData::new(String::from("listobjects"), value));
+        response.push(msg);
+    }
+
+    Ok(response)
+}
+
+fn list_sql(vnode: u64, limit: u64, offset: u64, order_by: &str) -> String {
+    format!("SELECT id, owner, bucket_id, name, created, modified, \
+        content_length, content_md5, content_type, headers, sharks, \
+        properties \
+        FROM manta_bucket_{}.manta_bucket_object
+        WHERE owner = $1 AND bucket_id = $2 AND name like $3
+        ORDER BY {} ASC
+        LIMIT {}
+        OFFSET {}",
+        vnode, order_by, limit, offset)
+}
diff --git a/src/object/update.rs b/src/object/update.rs
new file mode 100644
index 0000000..573958d
--- /dev/null
+++ b/src/object/update.rs
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+use std::io::Error as IOError;
+use std::io::ErrorKind as IOErrorKind;
+use std::vec::Vec;
+
+use serde_derive::{Deserialize, Serialize};
+use serde_json::Value;
+use slog::{Logger, debug};
+use uuid::Uuid;
+
+use cueball::connection_pool::ConnectionPool;
+use cueball::backend::Backend;
+use cueball_static_resolver::StaticIpResolver;
+use cueball_postgres_connection::PostgresConnection;
+use rust_fast::protocol::{FastMessage, FastMessageData};
+
+use crate::object::{
+    ObjectResponse,
+    object_not_found,
+    response
+};
+use crate::sql;
+use crate::util::{
+    Hstore,
+    array_wrap,
+    other_error
+};
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct UpdateObjectPayload {
+    pub owner          : Uuid,
+    pub bucket_id      : Uuid,
+    pub name           : String,
+    pub id             : Uuid,
+    pub vnode          : u64,
+    pub content_type   : String,
+    pub headers        : Hstore,
+    pub properties     : Option<Value>,
+    pub request_id     : Uuid
+}
+
+pub fn handler(msg_id: u32,
+                      args: &[Value],
+                      mut response: Vec<FastMessage>,
+                      pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>,
+                      log: &Logger) -> Result<Vec<FastMessage>, IOError> {
+    debug!(log, "handling updateobject function request");
+
+    let arg0 = match &args[0] {
+        Value::Object(_) => &args[0],
+        _ => return Err(other_error("Expected JSON object"))
+    };
+
+    let data_clone = arg0.clone();
+    let payload_result: Result<UpdateObjectPayload, _> =
+        serde_json::from_value(data_clone);
+
+    let payload = match payload_result {
+        Ok(o) => o,
+        Err(_) => return Err(other_error("Failed to parse JSON data as payload for updateobject function"))
+    };
+
+    debug!(log, "parsed UpdateObjectPayload, req_id: {}", payload.request_id);
+
+    // Make db request and form response
+    // let response_msg: Result<FastMessage, IOError> =
+    update(payload, pool)
+        .and_then(|maybe_resp| {
+            let method = String::from("updateobject");
+            match maybe_resp {
+                Some(resp) => {
+                    let value = array_wrap(serde_json::to_value(resp).unwrap());
+                    let msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(msg);
+                    Ok(response)
+                },
+                None => {
+                    let value = array_wrap(object_not_found());
+                    let err_msg = FastMessage::data(msg_id, FastMessageData::new(method, value));
+                    response.push(err_msg);
+                    Ok(response)
+                }
+            }
+        })
+        //TODO: Proper error handling
+        .map_err(|e| {
+            println!("Error: {}", e);
+            other_error("postgres error")
+        })
+}
+
+fn update(payload: UpdateObjectPayload,
+          pool: &ConnectionPool<PostgresConnection, StaticIpResolver, impl FnMut(&Backend) -> PostgresConnection + Send + 'static>)
+          -> Result<Option<ObjectResponse>, IOError>
+{
+    let mut conn = pool.claim().unwrap();
+    let mut txn = (*conn).transaction().unwrap();
+    let update_sql = update_sql(payload.vnode);
+
+    sql::txn_query(sql::Method::ObjectUpdate, &mut txn, update_sql.as_str(),
+                     &[&payload.content_type,
+                       &payload.headers,
+                       &payload.properties,
+                       &payload.owner,
+                       &payload.bucket_id,
+                       &payload.name])
+
+        .map_err(|e| {
+            let pg_err = format!("{}", e);
+            IOError::new(IOErrorKind::Other, pg_err)
+        })
+        .and_then(response)
+        .and_then(|response| {
+            txn.commit().unwrap();
+            Ok(response)
+        })
+}
+
+fn update_sql(vnode: u64) -> String {
+    ["UPDATE manta_bucket_",
+     &vnode.to_string(),
+     &".manta_bucket_object \
+       SET content_type = $1,
+       headers = $2, \
+       properties = $3, \
+       modified = current_timestamp \
+       WHERE owner = $4 \
+       AND bucket_id = $5 \
+       AND name = $6 \
+       RETURNING id, owner, bucket_id, name, created, modified, \
+       content_length, content_md5, content_type, headers, \
+       sharks, properties"].concat()
+}
diff --git a/tests/rpc_handlers.rs b/tests/rpc_handlers.rs
index 83180af..ae81da7 100644
--- a/tests/rpc_handlers.rs
+++ b/tests/rpc_handlers.rs
@@ -102,19 +102,20 @@ fn verify_rpc_handlers() {
     let msg_id: u32 = 0x1;
     let owner_id = Uuid::new_v4();
     let bucket: String = "testbucket".into();
-
+    let request_id = Uuid::new_v4();
 
     // Try to read a bucket
     let get_bucket_payload = bucket::GetBucketPayload {
         owner: owner_id,
         name: bucket.clone(),
-        vnode: 0
+        vnode: 0,
+        request_id
     };
 
     let get_bucket_json = serde_json::to_value(get_bucket_payload).unwrap();
     let get_bucket_args = vec![get_bucket_json];
     let mut get_bucket_result =
-        bucket::get_handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        bucket::get::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -127,16 +128,17 @@ fn verify_rpc_handlers() {
                BorayError::new(BorayErrorType::BucketNotFound));
 
     // Create a bucket
-    let create_bucket_payload = bucket::CreateBucketPayload {
+    let create_bucket_payload = bucket::create::CreateBucketPayload {
         owner: owner_id,
         name: bucket.clone(),
-        vnode: 0
+        vnode: 0,
+        request_id
     };
 
     let create_bucket_json = serde_json::to_value(create_bucket_payload).unwrap();
     let create_bucket_args = vec![create_bucket_json];
     let mut create_bucket_result =
-        bucket::create_handler(msg_id, &create_bucket_args, vec![], &pool, &log);
+        bucket::create::handler(msg_id, &create_bucket_args, vec![], &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -150,7 +152,7 @@ fn verify_rpc_handlers() {
 
     // Read bucket again and make sure the resonse is returned successfully
     get_bucket_result =
-        bucket::get_handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        bucket::get::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -165,7 +167,7 @@ fn verify_rpc_handlers() {
     // Try to create same bucket again and verify a BucketAlreadyExists error is
     // returned
     create_bucket_result =
-        bucket::create_handler(msg_id, &create_bucket_args, vec![], &pool, &log);
+        bucket::create::handler(msg_id, &create_bucket_args, vec![], &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -182,7 +184,7 @@ fn verify_rpc_handlers() {
     // The get and delete bucket args are the same so we can reuse
     // get_bucket_args here.
     let mut delete_bucket_result =
-        bucket::delete_handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        bucket::delete::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
 
     assert!(delete_bucket_result.is_ok());
     let delete_bucket_response = delete_bucket_result.unwrap();
@@ -195,7 +197,7 @@ fn verify_rpc_handlers() {
 
     // Read bucket again and verify it's gone
     get_bucket_result =
-        bucket::get_handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        bucket::get::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
 
     assert!(get_bucket_result.is_ok());
     let get_bucket_response = get_bucket_result.unwrap();
@@ -209,7 +211,7 @@ fn verify_rpc_handlers() {
 
     // Attempt to delete a nonexistent bucket and verify an error is returned
     delete_bucket_result =
-        bucket::delete_handler(msg_id, &get_bucket_args, vec![], &pool, &log);
+        bucket::delete::handler(msg_id, &get_bucket_args, vec![], &pool, &log);
 
     assert!(delete_bucket_result.is_ok());
     let delete_bucket_response = delete_bucket_result.unwrap();
@@ -229,13 +231,14 @@ fn verify_rpc_handlers() {
         owner: owner_id,
         bucket_id,
         name: object.clone(),
-        vnode: 1
+        vnode: 1,
+        request_id
     };
 
     let get_object_json = serde_json::to_value(get_object_payload).unwrap();
     let get_object_args = vec![get_object_json];
     let mut get_object_result =
-        object::get_handler(msg_id, &get_object_args, vec![], &pool, &log);
+        object::get::handler(msg_id, &get_object_args, vec![], &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -260,7 +263,7 @@ fn verify_rpc_handlers() {
         Some("customheaderval2".to_string())
     );
 
-    let update_object_payload = object::UpdateObjectPayload {
+    let update_object_payload = object::update::UpdateObjectPayload {
         owner: owner_id,
         bucket_id,
         name: object.clone(),
@@ -269,12 +272,13 @@ fn verify_rpc_handlers() {
         content_type: "text/html".into(),
         headers: update_headers,
         properties: None,
+        request_id
     };
 
     let update_object_json = serde_json::to_value(update_object_payload).unwrap();
     let update_object_args = vec![update_object_json];
     let mut update_object_result =
-        object::update_handler(msg_id, &update_object_args, vec![], &pool, &log);
+        object::update::handler(msg_id, &update_object_args, vec![], &pool, &log);
 
     assert!(update_object_result.is_ok());
     let mut update_object_response = update_object_result.unwrap();
@@ -297,7 +301,7 @@ fn verify_rpc_handlers() {
         manta_storage_id: "3.stor.us-east.joyent.com".into(),
     };
 
-    let create_object_payload = object::CreateObjectPayload {
+    let create_object_payload = object::create::CreateObjectPayload {
         owner: owner_id,
         bucket_id,
         name: object.clone(),
@@ -309,12 +313,13 @@ fn verify_rpc_handlers() {
         headers: HashMap::new(),
         sharks: vec![shark1, shark2],
         properties: None,
+        request_id
     };
 
     let create_object_json = serde_json::to_value(create_object_payload).unwrap();
     let create_object_args = vec![create_object_json];
     let mut create_object_result =
-        object::create_handler(msg_id, &create_object_args, vec![], &pool, &log);
+        object::create::handler(msg_id, &create_object_args, vec![], &pool, &log);
 
     assert!(create_object_result.is_ok());
     let create_object_response = create_object_result.unwrap();
@@ -328,7 +333,7 @@ fn verify_rpc_handlers() {
 
     // Read object again and verify a successful response is returned
     get_object_result =
-        object::get_handler(msg_id, &get_object_args, vec![], &pool, &log);
+        object::get::handler(msg_id, &get_object_args, vec![], &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -344,7 +349,7 @@ fn verify_rpc_handlers() {
 
     // Update the object's metadata and verify it is successful
     update_object_result =
-        object::update_handler(msg_id, &update_object_args, vec![], &pool, &log);
+        object::update::handler(msg_id, &update_object_args, vec![], &pool, &log);
 
     assert!(update_object_result.is_ok());
     update_object_response = update_object_result.unwrap();
@@ -360,7 +365,7 @@ fn verify_rpc_handlers() {
 
     // Read object again and verify the metadata update
     get_object_result =
-        object::get_handler(msg_id, &get_object_args, vec![], &pool, &log);
+        object::get::handler(msg_id, &get_object_args, vec![], &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -379,7 +384,7 @@ fn verify_rpc_handlers() {
     // The get and delete object args are the same so we can reuse
     // get_object_args here.
     let mut delete_object_result =
-        object::delete_handler(msg_id, &get_object_args, vec![], &pool, &log);
+        object::delete::handler(msg_id, &get_object_args, vec![], &pool, &log);
 
     assert!(delete_object_result.is_ok());
     let delete_object_response = delete_object_result.unwrap();
@@ -393,7 +398,7 @@ fn verify_rpc_handlers() {
 
     // Read object again and verify it is not found
     get_object_result =
-        object::get_handler(msg_id, &get_object_args, vec![], &pool, &log);
+        object::get::handler(msg_id, &get_object_args, vec![], &pool, &log);
 
     assert!(get_object_result.is_ok());
     let get_object_response = get_object_result.unwrap();
@@ -407,7 +412,7 @@ fn verify_rpc_handlers() {
 
     // Delete the object again and verify it is not found
     delete_object_result =
-        object::delete_handler(msg_id, &get_object_args, vec![], &pool, &log);
+        object::delete::handler(msg_id, &get_object_args, vec![], &pool, &log);
 
     assert!(delete_object_result.is_ok());
     let delete_object_response = delete_object_result.unwrap();
@@ -421,19 +426,20 @@ fn verify_rpc_handlers() {
 
     // List buckets and confirm none are found
 
-    let list_buckets_payload = bucket::ListBucketsPayload {
+    let list_buckets_payload = bucket::list::ListBucketsPayload {
         owner: owner_id,
         vnode: 0,
         prefix: "testbucket".into(),
         order_by: "created".into(),
         limit: 1000,
-        offset: 0
+        offset: 0,
+        request_id
     };
 
     let list_buckets_json = serde_json::to_value(list_buckets_payload).unwrap();
     let list_buckets_args = vec![list_buckets_json];
     let mut list_buckets_result =
-        bucket::list_handler(msg_id, &list_buckets_args, vec![], &pool, &log);
+        bucket::list::handler(msg_id, &list_buckets_args, vec![], &pool, &log);
 
     assert!(list_buckets_result.is_ok());
     let list_buckets_response = list_buckets_result.unwrap();
@@ -441,7 +447,7 @@ fn verify_rpc_handlers() {
 
     // Create a bucket and list buckets again
     create_bucket_result =
-        bucket::create_handler(msg_id, &create_bucket_args, vec![], &pool, &log);
+        bucket::create::handler(msg_id, &create_bucket_args, vec![], &pool, &log);
 
     assert!(create_bucket_result.is_ok());
     let create_bucket_response = create_bucket_result.unwrap();
@@ -453,7 +459,7 @@ fn verify_rpc_handlers() {
     assert_eq!(create_bucket_response_result.unwrap().name, bucket);
 
     list_buckets_result =
-        bucket::list_handler(msg_id, &list_buckets_args, vec![], &pool, &log);
+        bucket::list::handler(msg_id, &list_buckets_args, vec![], &pool, &log);
 
     assert!(list_buckets_result.is_ok());
     let list_buckets_response = list_buckets_result.unwrap();
@@ -462,20 +468,21 @@ fn verify_rpc_handlers() {
 
     // List objects and confirm none are found
 
-    let list_objects_payload = object::ListObjectsPayload {
+    let list_objects_payload = object::list::ListObjectsPayload {
         owner: owner_id,
         bucket_id,
         vnode: 1,
         prefix: "testobject".into(),
         order_by: "created".into(),
         limit: 1000,
-        offset: 0
+        offset: 0,
+        request_id
     };
 
     let list_objects_json = serde_json::to_value(list_objects_payload).unwrap();
     let list_objects_args = vec![list_objects_json];
     let mut list_objects_result =
-        object::list_handler(msg_id, &list_objects_args, vec![], &pool, &log);
+        object::list::handler(msg_id, &list_objects_args, vec![], &pool, &log);
 
     assert!(list_objects_result.is_ok());
     let list_objects_response = list_objects_result.unwrap();
@@ -483,7 +490,7 @@ fn verify_rpc_handlers() {
 
     // Create an object and list objects again
     create_object_result =
-        object::create_handler(msg_id, &create_object_args, vec![], &pool, &log);
+        object::create::handler(msg_id, &create_object_args, vec![], &pool, &log);
 
     assert!(create_object_result.is_ok());
     let create_object_response = create_object_result.unwrap();
@@ -495,7 +502,7 @@ fn verify_rpc_handlers() {
     assert_eq!(create_object_response_result.unwrap().name, object);
 
     list_objects_result =
-        object::list_handler(msg_id, &list_objects_args, vec![], &pool, &log);
+        object::list::handler(msg_id, &list_objects_args, vec![], &pool, &log);
 
     assert!(list_objects_result.is_ok());
     let list_objects_response = list_objects_result.unwrap();
-- 
2.21.0

