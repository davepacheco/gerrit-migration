From 314246bf1949e18e9ae388096316a1c69ca29d46 Mon Sep 17 00:00:00 2001
From: "Pedro P. Candel" <pedro@joyent.com>
Date: Mon, 12 Sep 2016 18:22:12 +0200
Subject: [PATCH] TOOLS-1527 sdcadm history failures should never make a
 command fail Reviewed by: Trent Mick <trent.mick@joyent.com>

---
 lib/cli/do_history.js |  12 +-
 lib/history.js        | 286 +++++++++++++++++++++++++++++++-----------
 test/history.test.js  | 120 +++++++++++-------
 3 files changed, 292 insertions(+), 126 deletions(-)

diff --git a/lib/cli/do_history.js b/lib/cli/do_history.js
index 8d687a7..1eab205 100644
--- a/lib/cli/do_history.js
+++ b/lib/cli/do_history.js
@@ -5,9 +5,11 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 var errors = require('../errors');
+var common = require('../common');
+
 var tabula = require('tabula');
 
 var UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
@@ -35,7 +37,7 @@ function do_history(subcmd, opts, args, cb) {
             if (err) {
                 return cb(err);
             }
-            console.log(JSON.stringify(hist, null, 4));
+            console.log(JSON.stringify(hist, common.safeCycles(), 4));
             return cb();
         });
     }
@@ -70,7 +72,7 @@ function do_history(subcmd, opts, args, cb) {
         }
 
         if (opts.json) {
-            console.log(JSON.stringify(history, null, 4));
+            console.log(JSON.stringify(history, common.safeCycles(), 4));
         } else {
             var validFieldsMap = {};
             if (!history.length) {
@@ -88,7 +90,7 @@ function do_history(subcmd, opts, args, cb) {
                     }).join(',');
                 }
                 var row = {
-                    uuid: hst.uuid,
+                    uuid: hst.uuid || null,
                     changes: chgs,
                     started: (hst.started ?
                         new Date(hst.started).toJSON() : null),
@@ -98,7 +100,7 @@ function do_history(subcmd, opts, args, cb) {
                         (hst.error.message ?
                          hst.error.message.split('\n', 1)[0] :
                          hst.error) : null),
-                    user: hst.username ? hst.username : null
+                    user: hst.username || null
                 };
 
                 if (row.changes.length > 40) {
diff --git a/lib/history.js b/lib/history.js
index 578bc04..6a67fce 100644
--- a/lib/history.js
+++ b/lib/history.js
@@ -30,59 +30,169 @@ var errors = require('./errors');
 var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
 
 
+// --- History Class
+function History(opts) {
+    assert.object(opts, 'opts');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    this.sdcadm = opts.sdcadm;
+}
+
+History.prototype.init = function (cb) {
+    var self = this;
+
+    // It will not hurt to make sure the history dir exists:
+    self.wrkDir = '/var/sdcadm/history';
+    mkdirp(self.wrkDir, function (err) {
+        if (err) {
+            cb(new errors.InternalError({
+                message: 'error creating history work dir: ' + self.wrkDir,
+                cause: err
+            }));
+            return;
+        }
+        cb();
+        return;
+    });
+};
+
+
+/*
+ * Save history item to a file (mostly used to be able to deal with SAPI
+ * downtimes). When an attempt to save a bogus history item is made, the
+ * file will not be saved.
+ */
+History.prototype.saveToFile = function saveToFile(fname, history, cb) {
+    // Avoid saving bogus files:
+    if (!history) {
+        cb(null);
+        return;
+    }
 
+    var self = this;
 
-function saveHistoryToFile(fname, history, cb) {
     var s;
     try {
         s = JSON.stringify(history, common.safeCycles());
     } catch (e) {
-        s = '{}';
+        self.sdcadm.log.error({err: e}, 'Error saving history to file');
+        cb(null);
+        return;
     }
+
     fs.writeFile(fname, s, {
         encoding: 'utf8'
     }, function (err) {
         if (err) {
-            return cb(err);
+            cb(err);
+            return;
         }
-        return cb(null);
+        cb(null);
     });
-}
+};
+
+/*
+ * Attempt to read history from the file given by `fname`
+ *
+ * In case of validation error when reading from that file, the file will
+ * be removed so no future attempts or re-reading it will be made.
+ */
+History.prototype.readFromFile = function readHistoryFromFile(fname, cb) {
+    var self = this;
 
-function readHistoryFromFile(fname, cb) {
     fs.readFile(fname, {
         encoding: 'utf8'
     }, function (err, data) {
         if (err) {
-            return cb(err);
+            cb(err);
+            return;
+        }
+        var history;
+        try {
+            history = JSON.parse(data);
+        } catch (e) {
+            self.sdcadm.log.error({err: e}, 'Error reading history from file');
+            cb(e);
+            return;
         }
-        return cb(null, JSON.parse(data));
+
+        self.validateItem(history, function (err2) {
+            if (err2) {
+                self.sdcadm.log.error({err: err2}, 'Invalid history item');
+                fs.unlink(fname, function (fErr) {
+                    if (fErr) {
+                        self.sdcadm.log.error({
+                            err: fErr
+                        }, 'Error removing invalid history file');
+                    }
+                    cb(err2);
+                });
+            } else {
+                cb(null, history);
+            }
+        });
+
     });
-}
+};
 
-// --- History Class
-function History(opts) {
-    assert.object(opts, 'opts');
-    assert.object(opts.sdcadm, 'opts.sdcadm');
-    this.sdcadm = opts.sdcadm;
-}
 
-History.prototype.init = function (cb) {
-    var self = this;
+/*
+ * Ensure that whatever we are trying to read from or save to a History file
+ * contains only the expected history properties.
+ */
+History.prototype.validateItem = function validateItem(history, cb) {
 
-    // It will not hurt to make sure the history dir exists:
-    self.wrkDir = '/var/sdcadm/history';
-    mkdirp(self.wrkDir, function (err) {
-        if (err) {
-            return cb(new errors.InternalError({
-                message: 'error creating history work dir: ' + self.wrkDir,
-                cause: err
-            }));
+
+    if (!history || typeof (history) !== 'object') {
+        cb(new errors.ValidationError('history must be an object'));
+        return;
+    }
+
+    if (!history.changes || typeof (history.changes) !== 'object') {
+        cb(new errors.ValidationError('history.changes must be an object'));
+        return;
+    }
+
+    if (history.username) {
+        if (typeof (history.username) !== 'string') {
+            cb(new errors.ValidationError(
+                'history.username must be a string'));
+            return;
         }
-        return cb();
-    });
+    }
+
+    if (history.uuid) {
+        if (typeof (history.uuid) !== 'string') {
+            cb(new errors.ValidationError('history.uuid must be a string'));
+            return;
+        }
+        if (!UUID_RE.test(history.uuid)) {
+            cb(new errors.ValidationError('history.uuid is not a valid UUID'));
+            return;
+        }
+    }
+
+    if (history.started) {
+        var d  = new Date(history.started);
+        if (d.toJSON() === null) {
+            cb(new errors.ValidationError(
+                'history.started is not a valid date'));
+            return;
+        }
+    }
+
+    if (history.finished) {
+        var f  = new Date(history.finished);
+        if (f.toJSON() === null) {
+            cb(new errors.ValidationError(
+                'history.finished is not a valid date'));
+            return;
+        }
+    }
+
+    cb(null);
 };
 
+
 /*
  * Expects an object with, at least, a `changes` member. `started` and `uuid`
  * members will be added to the object when not present. Note that `uuid` must
@@ -109,10 +219,12 @@ History.prototype.saveHistory = function (history, cb) {
     if (history.uuid) {
         assert.string(history.uuid, 'history.uuid');
         if (!UUID_RE.test(history.uuid)) {
-            return cb(new errors.ValidationError({
+            self.sdcadm.log.error({err: new errors.ValidationError({
                 message: 'error validating history UUID',
                 cause: history.uuid + ' is not a valid UUID'
-            }));
+            })});
+            cb();
+            return;
         }
     } else {
         history.uuid = uuid();
@@ -121,10 +233,12 @@ History.prototype.saveHistory = function (history, cb) {
     if (history.started) {
         var d  = new Date(history.started);
         if (d.toJSON() === null) {
-            return cb(new errors.ValidationError({
+            self.sdcadm.log.error({err: new errors.ValidationError({
                 message: 'error validating history start time',
                 cause: history.started + ' is not a valid date'
-            }));
+            })});
+            cb();
+            return;
         }
         history.started = d.getTime();
     } else {
@@ -139,14 +253,17 @@ History.prototype.saveHistory = function (history, cb) {
             }, 'Error saving history to SAPI, saving to local file');
 
             var fname = path.join(self.wrkDir, history.uuid + '.json');
-            return saveHistoryToFile(fname, history, function (err2) {
+            self.saveToFile(fname, history, function (err2) {
                 if (err2) {
-                    return cb(new errors.InternalError({
+                    self.sdcadm.log.error({err: new errors.InternalError({
                         message: 'error saving file: ' + fname,
                         cause: err2
-                    }));
+                    })});
+                    cb();
+                    return;
                 }
-                return cb(null, history);
+                cb(null, history);
+                return;
             });
         }
 
@@ -154,7 +271,7 @@ History.prototype.saveHistory = function (history, cb) {
             history: hist
         }, 'History saved to SAPI');
 
-        return cb(null, history);
+        cb(null, history);
     });
 
 };
@@ -189,10 +306,12 @@ History.prototype.updateHistory = function (history, cb) {
     if (history.finished) {
         var d  = new Date(history.finished);
         if (d.toJSON() === null) {
-            return cb(new errors.ValidationError({
+            self.sdcadm.log.error({err: new errors.ValidationError({
                 message: 'error validating history finish time',
                 cause: history.finished + ' is not a valid date'
-            }));
+            })});
+            cb();
+            return;
         }
         history.finished = d.getTime();
     } else {
@@ -208,7 +327,7 @@ History.prototype.updateHistory = function (history, cb) {
 
             var fname = path.join(self.wrkDir, history.uuid + '.json');
 
-            return readHistoryFromFile(fname, function (err2, hist2) {
+            self.readFromFile(fname, function (err2, hist2) {
                 if (err2) {
                     self.sdcadm.log.info({
                         err: err2
@@ -223,28 +342,30 @@ History.prototype.updateHistory = function (history, cb) {
                     });
                 }
 
-                return saveHistoryToFile(fname, hist2, function (err3) {
+                self.saveToFile(fname, hist2, function (err3) {
                     if (err3) {
-                        return cb(new errors.InternalError({
+                        self.sdcadm.log.error({err: new errors.InternalError({
                             message: 'error saving file: ' + fname,
                             cause: err3
-                        }));
+                        })});
+                        cb();
+                        return;
                     }
-                    return cb(null, hist2);
+                    cb(null, hist2);
+                    return;
                 });
             });
         }
 
         // On success SAPI update, check if is there any pending history file
         // from previous invocations and we need to catch up:
-        return self.catchUp(function (err4) {
+        self.catchUp(function (err4) {
             if (err4) {
                 self.sdcadm.log.info({
                     err: err4
                 }, 'Error adding history to SAPI. Saved to local files.');
-                return cb(err4, hist);
             }
-            return cb(null, hist);
+            cb(null, hist);
         });
     });
 };
@@ -261,18 +382,21 @@ History.prototype.getHistory = function (id, cb) {
             }, 'Error reading history from SAPI, trying local files');
 
             var fname = path.join(self.wrkDir, id + '.json');
-            return readHistoryFromFile(fname, function (err, hist) {
+            self.readFromFile(fname, function (err, hist) {
                 if (err) {
-                    return cb(new errors.InternalError({
+                    cb(new errors.InternalError({
                         message: 'error reading file: ' + fname,
                         cause: err
                     }));
+                    return;
                 }
-                return cb(null, hist);
+                cb(null, hist);
+                return;
             });
         }
 
-        return cb(null, hist2);
+        cb(null, hist2);
+        return;
     });
 
 };
@@ -280,19 +404,20 @@ History.prototype.getHistory = function (id, cb) {
 History.prototype.listHistory = function (opts, cb) {
     var self = this;
 
-    return self.sdcadm.sapi.listHistory(opts, function (err, history) {
+    self.sdcadm.sapi.listHistory(opts, function (err, history) {
         if (err) {
             // Only when the error is not an options error, try reading from
             // file
-            return self._readHistoryDir(function (files) {
+            self._readHistoryDir(function (files) {
                 history = [];
                 vasync.forEachPipeline({
                     inputs: files,
                     func: function _readHistoryFile(item, next) {
                         var f = path.join(self.wrkDir, item);
-                        return readHistoryFromFile(f, function (err3, hist) {
+                        self.readFromFile(f, function (err3, hist) {
                             if (err3) {
-                                return next(err3);
+                                next(err3);
+                                return;
                             }
                             history.push(hist);
                             next();
@@ -300,17 +425,20 @@ History.prototype.listHistory = function (opts, cb) {
                     }
                 }, function (err2, results) {
                     if (err2) {
-                        return cb(new errors.InternalError({
+                        cb(new errors.InternalError({
                             message: 'error reading directory: ' + self.wrkDir,
                             cause: err2
                         }));
+                        return;
                     }
-                    return cb(null, history);
+                    cb(null, history);
+                    return;
                 });
             });
 
         } else {
-            return cb(null, history);
+            cb(null, history);
+            return;
         }
     });
 };
@@ -319,24 +447,25 @@ History.prototype.listHistory = function (opts, cb) {
 History.prototype.catchUp = function (cb) {
     var self = this;
 
-    return self._readHistoryDir(function (files) {
+    self._readHistoryDir(function (files) {
         if (files.length) {
             vasync.forEachPipeline({
                 inputs: files,
                 func: function _postHistoryToSAPI(item, next) {
                     var f = path.join(self.wrkDir, item);
-                    readHistoryFromFile(f, function (er, data) {
+                    self.readFromFile(f, function (er, data) {
                         if (er) {
-                            return next(er);
+                            next(er);
+                            return;
                         }
 
                         // Avoid raising an error b/c no file contents:
                         if (!data) {
-                            return next();
+                            next();
+                            return;
                         }
 
-                        return self._getOrCreateOnSAPI(data,
-                            function (er2, h) {
+                        self._getOrCreateOnSAPI(data, function (er2, h) {
                             if (er2) {
                                 self.sdcadm.log.info({
                                     err: er2
@@ -350,6 +479,7 @@ History.prototype.catchUp = function (cb) {
                                     }, 'Error removing file: %s', f);
                                 }
                                 next();
+                                return;
                             });
                         });
 
@@ -357,15 +487,14 @@ History.prototype.catchUp = function (cb) {
                 }
             }, function catchUpPipeline(err, results) {
                 if (err) {
-                    return cb(new errors.InternalError({
-                        message: 'error saving history to SAPI',
-                        cause: err
-                    }));
+                    self.sdcadm.log.error({
+                        err: err
+                    }, 'error saving history to SAPI');
                 }
-                return cb(null);
+                cb(null);
             });
         } else {
-            return cb(null);
+            cb(null);
         }
     });
 
@@ -374,14 +503,15 @@ History.prototype.catchUp = function (cb) {
 History.prototype._readHistoryDir = function (cb) {
     var self = this;
 
-    return fs.readdir(self.wrkDir, function (err, files) {
+    fs.readdir(self.wrkDir, function (err, files) {
         if (err) {
-            return cb(new errors.InternalError({
+            cb(new errors.InternalError({
                 message: 'error reading directory: ' + self.wrkDir,
                 cause: err
             }));
+            return;
         }
-        return cb(files);
+        cb(files);
     });
 };
 
@@ -396,17 +526,23 @@ History.prototype._getOrCreateOnSAPI = function (history, cb) {
 
     self.sdcadm.sapi.getHistory(history.uuid, function (err2, hist2) {
         if (err2) {
+            if (!history.started) {
+                history.started = new Date().getTime();
+            }
             self.sdcadm.sapi.addHistory(history, function (err, hist) {
                 if (err) {
                     self.sdcadm.log.info({
                         err: err
                     }, 'Error saving history to SAPI');
-                    return cb(err);
+                    cb(err);
+                    return;
                 }
-                return cb(null, hist);
+                cb(null, hist);
+                return;
             });
         } else {
-            return cb(null, hist2);
+            cb(null, hist2);
+            return;
         }
     });
 };
diff --git a/test/history.test.js b/test/history.test.js
index 9127d17..4fc035a 100644
--- a/test/history.test.js
+++ b/test/history.test.js
@@ -5,11 +5,14 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2016, Joyent, Inc.
  */
 
 
 var test = require('tape').test;
+var vasync = require('vasync');
+
+var fs = require('fs');
 var exec = require('child_process').exec;
 var common = require('./common');
 
@@ -47,59 +50,65 @@ test('sdcadm history', function (t) {
     var beforeUpdate = new Date();
     var afterUpdate;
 
-    function getOldHistory() {
-        exec('sdcadm history', function (err, stdout, stderr) {
-            t.ifError(err);
-            t.equal(stderr, '');
-
-            origHistory = parseHistory(stdout);
-            origHistory.shift(); // remove column titles
+    vasync.pipeline({
+        funcs: [
+            function getOldHistory(_, next) {
+                exec('sdcadm history', function (err, stdout, stderr) {
+                    t.ifError(err);
+                    t.equal(stderr, '');
 
-            updatePapi();
-        });
-    }
+                    origHistory = parseHistory(stdout);
+                    origHistory.shift(); // remove column titles
+                    next();
+                });
+            },
 
-    function updatePapi() {
-        var cmd = 'sdcadm update papi --force-same-image -y';
+            function updateOther(_, next) {
+                // A command that we can re-run as many times as we need
+                var cmd = 'sdcadm experimental update-other';
 
-        exec(cmd, function (err, stdout, stderr) {
-            t.ifError(err);
-            t.equal(stderr, '');
+                exec(cmd, function (err, stdout, stderr) {
+                    t.ifError(err);
+                    t.equal(stderr, '');
 
-            afterUpdate = new Date();
+                    afterUpdate = new Date();
+                    next();
+                });
+            },
 
-            getNewHistory();
-        });
-    }
+            function getNewHistory(_, next) {
+                exec('sdcadm history', function (err, stdout, stderr) {
+                    t.ifError(err);
+                    t.equal(stderr, '');
 
-    function getNewHistory() {
-        exec('sdcadm history', function (err, stdout, stderr) {
-            t.ifError(err);
-            t.equal(stderr, '');
+                    var newHistory = parseHistory(stdout);
+                    newHistory.shift(); // remove column titles
 
-            var newHistory = parseHistory(stdout);
-            newHistory.shift(); // remove column titles
+                    t.equal(origHistory.length + 1, newHistory.length);
 
-            t.equal(origHistory.length + 1, newHistory.length);
+                    var newest = newHistory[0];
+                    t.ok(newest);
 
-            var newest = newHistory[0];
-            t.ok(newest);
+                    HISTORY_UUID = newest[0];
+                    t.equal(newest[1], 'root');
 
-            HISTORY_UUID = newest[0];
-            t.equal(newest[1], 'root');
+                    t.ok(new Date(newest[2]) <= new Date(newest[3]));
+                    t.ok(new Date(newest[2]) >= beforeUpdate);
+                    t.ok(new Date(newest[3]) <= afterUpdate);
 
-            t.ok(new Date(newest[2]) <= new Date(newest[3]));
-            t.ok(new Date(newest[2]) >= beforeUpdate);
-            t.ok(new Date(newest[3]) <= afterUpdate);
+                    t.notEqual(newest[4].indexOf('update-service-cfg'), -1);
+                    t.equal(newest[5], '-');
 
-            t.equal(newest[4], 'update-service(papi)');
-            t.equal(newest[5], '-');
+                    next();
+                });
+            }
 
-            t.end();
-        });
-    }
+        ]
+    }, function (resErr) {
+        t.ifError(resErr);
+        t.end();
+    });
 
-    getOldHistory();
 });
 
 
@@ -116,7 +125,7 @@ test('sdcadm history --json', function (t) {
             t.ok(entry.uuid.match(common.UUID_RE), entry.uuid + ' is a UUID');
             t.ok(Array.isArray(entry.changes), 'changes is an array');
             // TODO: no username?
-            t.ok(entry.username == 'root' || !entry.username);
+            t.ok(entry.username === 'root' || !entry.username);
             t.ok(new Date(entry.started));
             t.ok(new Date(entry.finished));
         });
@@ -143,8 +152,7 @@ test('sdcadm history <uuid>', function (t) {
         t.equal(typeof (entry.started),  'number');
         t.equal(typeof (entry.finished), 'number');
         t.ok(Array.isArray(entry.changes));
-
-        t.equal(entry.changes[0].service.name, 'papi');
+        t.equal(entry.changes[entry.changes.length - 1].service.name, 'assets');
 
         t.end();
     });
@@ -208,9 +216,8 @@ test('sdcadm history --since', function (t) {
 
         var entries = parseHistory(stdout);
         entries.shift(); // remove column titles
-
         entries.forEach(function (entry) {
-            t.ok(entry[3] >= minimumDate);
+            t.ok(entry[2] >= minimumDate);
         });
 
         t.end();
@@ -235,4 +242,25 @@ test('sdcadm history --until', function (t) {
 
         t.end();
     });
-});
\ No newline at end of file
+});
+
+
+test('sdcadm history bogus files', function (t) {
+    // Create bogus file manually
+    var histDir = '/var/sdcadm/history/';
+    var fpath = histDir + '9887ef12-32f9-4a05-9e38-e99ca15a5758.json';
+
+    fs.writeFile(fpath, 'null', {
+        encoding: 'utf8'
+    }, function (ferr) {
+        t.ifError(ferr);
+
+        // Now verify that this will not cause any error:
+        var cmd = 'sdcadm experimental update-other';
+        exec(cmd, function (err, stdout, stderr) {
+            t.ifError(err, 'Execution error');
+            t.equal(stderr, '', 'Empty stderr');
+            t.end();
+        });
+    });
+});
-- 
2.21.0

