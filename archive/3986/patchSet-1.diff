commit 5235a58f51463cff820cae45b85dbcb1ef35b27f (refs/changes/86/3986/1)
Author: Jason King <jason.king@joyent.com>
Date:   2018-05-21T14:52:11-05:00 (1 year, 5 months ago)
    
    Overlay fabric router
    Have target cache use ARC
    Use VLAN_ID_MAX
    fix typo
    Address feedback 1

diff --git a/usr/src/lib/varpd/files/common/libvarpd_files.c b/usr/src/lib/varpd/files/common/libvarpd_files.c
index ba32b61586..38cd7b3519 100644
--- a/usr/src/lib/varpd/files/common/libvarpd_files.c
+++ b/usr/src/lib/varpd/files/common/libvarpd_files.c
@@ -145,11 +145,16 @@ typedef struct varpd_files {
 	char			*vaf_path;	/* WO */
 	uint64_t		vaf_nmisses;	/* Atomic */
 	uint64_t		vaf_narp;	/* Atomic */
+
+				/* These hold varpd_files_fabric_t's */
 	avl_tree_t		vaf_fabrics;	/* WO */
 	list_t			vaf_attached;	/* WO */
+
+				/* These hold varpd_files_if_t */
 	avl_tree_t		vaf_macs;	/* WO */
 	avl_tree_t		vaf_ips;	/* WO */
 	avl_tree_t		vaf_ndp;	/* WO */
+
 	uint64_t		vaf_vnet;	/* RO */
 	uint32_t		vaf_dcid;	/* RO */
 } varpd_files_t;
@@ -356,13 +361,11 @@ varpd_files_create(varpd_provider_handle_t *hdl, void **outp,
 	if (varpd_files_valid_dest(dest) == B_FALSE)
 		return (ENOTSUP);
 
-	vaf = umem_alloc(sizeof (varpd_files_t), UMEM_DEFAULT);
+	vaf = umem_zalloc(sizeof (varpd_files_t), UMEM_DEFAULT);
 	if (vaf == NULL)
 		return (ENOMEM);
 
-	bzero(vaf, sizeof (varpd_files_t));
 	vaf->vaf_dest = dest;
-	vaf->vaf_path = NULL;
 	vaf->vaf_hdl = hdl;
 	vaf->vaf_dcid = libvarpd_plugin_dcid(hdl);
 	vaf->vaf_vnet = libvarpd_plugin_vnetid(hdl);
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
index f52daa4fdf..f557f4cbc6 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
@@ -419,10 +419,9 @@ libvarpd_overlay_cache_get(varpd_instance_t *inst, const uint8_t *key,
     varpd_client_cache_entry_t *entry)
 {
 	int ret;
-	overlay_targ_cache_t cache;
+	overlay_targ_cache_t cache = { 0 };
 	varpd_impl_t *vip = inst->vri_impl;
 
-	bzero(&cache, sizeof (overlay_targ_cache_t));
 	cache.otc_linkid = inst->vri_linkid;
 	bcopy(key, cache.otc_entry.otce_mac.otm_mac, ETHERADDRL);
 
@@ -445,10 +444,9 @@ libvarpd_overlay_cache_set(varpd_instance_t *inst, uint32_t dcid,
     const uint8_t *key, const varpd_client_cache_entry_t *entry)
 {
 	int ret;
-	overlay_targ_cache_t cache;
+	overlay_targ_cache_t cache = { 0 };
 	varpd_impl_t *vip = inst->vri_impl;
 
-	bzero(&cache, sizeof (overlay_targ_cache_t));
 	cache.otc_linkid = inst->vri_linkid;
 	cache.otc_entry.otce_mac.otm_dcid = dcid;
 	bcopy(key, cache.otc_entry.otce_mac.otm_mac, ETHERADDRL);
diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index 1a01b3aecc..e51a218324 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -52,6 +52,11 @@
  */
 #define	OVERLAY_HSIZE	823
 
+/*
+ * The default size of each target cache.  This is also a complete strawman
+ * whose value could change as we gain better operational experience with
+ * overlay routing.
+ */
 #define	OVERLAY_CACHE_SIZE	512
 
 /*
@@ -187,9 +192,9 @@ overlay_ip_cmp(const void *a, const void *b)
 
 	if (l->otvl3_src_vlan != r->otvl3_src_vlan)
 		return (1);
-	if (bcmp(&l->otvl3_src, &r->otvl3_src, sizeof (l->otvl3_src)) != 0)
+	if (!IN6_ARE_ADDR_EQUAL(&l->otvl3_src, &r->otvl3_src))
 		return (1);
-	if (bcmp(&l->otvl3_dst, &r->otvl3_dst, sizeof (l->otvl3_src)) != 0)
+	if (!IN6_ARE_ADDR_EQUAL(&l->otvl3_dst, &r->otvl3_dst))
 		return (1);
 	return (0);
 }
@@ -411,10 +416,12 @@ overlay_get_vl3_ips(mblk_t *mp, struct in6_addr *src, struct in6_addr *dst)
 
 		switch (sap) {
 		case ETHERTYPE_IP:
+			ASSERT3U(IPH_HDR_VERSION(iphp), ==, IPV4_VERSION);
 			IN6_IPADDR_TO_V4MAPPED(iphp->ipha_src, src);
 			IN6_IPADDR_TO_V4MAPPED(iphp->ipha_dst, dst);
 			break;
 		case ETHERTYPE_IPV6:
+			ASSERT3U(IPH_HDR_VERSION(iphp), ==, IPV6_VERSION);
 			bcopy(&ip6hp->ip6_src, src, sizeof (*src));
 			bcopy(&ip6hp->ip6_dst, dst, sizeof (*dst));
 			break;
diff --git a/usr/src/uts/common/sys/overlay_impl.h b/usr/src/uts/common/sys/overlay_impl.h
index 2ab8c71c0a..d132f565d9 100644
--- a/usr/src/uts/common/sys/overlay_impl.h
+++ b/usr/src/uts/common/sys/overlay_impl.h
@@ -140,7 +140,7 @@ typedef struct overlay_target_entry overlay_target_entry_t;
 
 /*
  * For VL3 target entries, if we need to lock both the VL3 entry and the
- * (possibly shared with multiple VL3 entries) VL2 entry, we should always
+ * (possibly shared with multiple VL3 entries) VL2 entry, we must always
  * take the VL3 lock prior to the VL2 entry lock.
  */
 typedef struct overlay_target_vl3 {
diff --git a/usr/src/uts/common/sys/overlay_target.h b/usr/src/uts/common/sys/overlay_target.h
index f92d18c400..28303ff4bc 100644
--- a/usr/src/uts/common/sys/overlay_target.h
+++ b/usr/src/uts/common/sys/overlay_target.h
@@ -55,10 +55,11 @@ typedef struct overlay_target_mac {
 } overlay_target_mac_t;
 
 /*
- * The overlay_target_route_t represents the information necessary to send
- * packets to remote (routed) destinations.  Note: we currently only include
- * the L3 address prefix lengths since overlay can deduce the subnet address
- * from the original VL3 IP in the request + the prefix length in the reply.
+ * The overlay_target_route_t represents the fields of the packet that
+ * have to be modified to deliver a packet to remote (routed) destinations.
+ * All three values are always populated when a packet is routed, even if
+ * some of the overlay_target_route_t values end up being the same as the
+ * original values in the packet being routed.
  */
 typedef struct overlay_target_route {
 	uint64_t		otr_vnet;
