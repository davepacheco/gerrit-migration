From fd0a89598f72a8d64d1517be9e2ab884f87d8095 Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Thu, 5 Apr 2018 10:25:30 -0500
Subject: [PATCH] Overlay fabric router Have target cache use ARC Use
 VLAN_ID_MAX fix typo Address feedback 1 remove unused vars more DEBUG fixes

---
 usr/src/cmd/dladm/dladm.c                     |   57 +-
 usr/src/cmd/varpd/Makefile                    |    4 +-
 usr/src/cmd/vndadm/Makefile                   |    4 +-
 usr/src/lib/libdladm/common/libdloverlay.c    |    8 +-
 usr/src/lib/libdladm/common/libdloverlay.h    |    4 +-
 usr/src/lib/varpd/files/Makefile.com          |    2 +-
 .../lib/varpd/files/common/libvarpd_files.c   | 1460 ++++++++++-------
 usr/src/lib/varpd/libvarpd/Makefile           |    3 +-
 .../lib/varpd/libvarpd/common/libvarpd_arp.c  |    6 +-
 .../varpd/libvarpd/common/libvarpd_client.c   |   24 +-
 .../varpd/libvarpd/common/libvarpd_client.h   |    6 +-
 .../lib/varpd/libvarpd/common/libvarpd_door.c |    6 +-
 .../lib/varpd/libvarpd/common/libvarpd_impl.h |   15 +-
 .../varpd/libvarpd/common/libvarpd_overlay.c  |   36 +-
 .../varpd/libvarpd/common/libvarpd_provider.h |    4 +-
 usr/src/lib/varpd/svp/common/libvarpd_svp.c   |   19 +-
 usr/src/uts/common/Makefile.files             |    4 +-
 .../uts/common/io/overlay/overlay_target.c    |  826 ++++++++--
 usr/src/uts/common/io/overlay/sarc.c          |  668 ++++++++
 usr/src/uts/common/io/overlay/sarc_impl.h     |   67 +
 usr/src/uts/common/sys/overlay_impl.h         |   80 +-
 usr/src/uts/common/sys/overlay_target.h       |   49 +-
 usr/src/uts/common/sys/sarc.h                 |  179 ++
 23 files changed, 2710 insertions(+), 821 deletions(-)
 create mode 100644 usr/src/uts/common/io/overlay/sarc.c
 create mode 100644 usr/src/uts/common/io/overlay/sarc_impl.h
 create mode 100644 usr/src/uts/common/sys/sarc.h

diff --git a/usr/src/cmd/dladm/dladm.c b/usr/src/cmd/dladm/dladm.c
index e46ce50af7..ca66f66428 100644
--- a/usr/src/cmd/dladm/dladm.c
+++ b/usr/src/cmd/dladm/dladm.c
@@ -333,9 +333,9 @@ static cmd_t	cmds[] = {
 	    "    show-secobj      [-pP] [-o <field>,...] [<secobj>,...]\n" },
 	{ "init-linkprop",	do_init_linkprop,	NULL		},
 	{ "init-secobj",	do_init_secobj,		NULL		},
-	{ "create-vlan", 	do_create_vlan,
+	{ "create-vlan",	do_create_vlan,
 	    "    create-vlan      [-ft] -l <link> -v <vid> [link]"	},
-	{ "delete-vlan", 	do_delete_vlan,
+	{ "delete-vlan",	do_delete_vlan,
 	    "    delete-vlan      [-t] <link>"				},
 	{ "show-vlan",		do_show_vlan,
 	    "    show-vlan        [-pP] [-o <field>,..] [<link>]\n"	},
@@ -425,7 +425,7 @@ static cmd_t	cmds[] = {
 	{ "delete-overlay",	do_delete_overlay,
 	    "    delete-overlay   <overlay>"			},
 	{ "modify-overlay",	do_modify_overlay,
-	    "    modify-overlay   -d mac | -f | -s mac=ip:port "
+	    "    modify-overlay   -d [dcid/]mac | -f | -s [dcid/]mac=ip:port "
 	    "<overlay>"						},
 	{ "show-overlay",	do_show_overlay,
 	    "    show-overlay     [-f | -t] [[-p] -o <field>,...] "
@@ -10447,7 +10447,7 @@ do_show_overlay(int argc, char *argv[], const char *use)
 	int			i, opt;
 	datalink_id_t		linkid = DATALINK_ALL_LINKID;
 	dladm_status_t		status;
-	int 			(*funcp)(dladm_handle_t, datalink_id_t, void *);
+	int			(*funcp)(dladm_handle_t, datalink_id_t, void *);
 	char			*fields_str = NULL;
 	const ofmt_field_t	*fieldsp;
 	ofmt_status_t		oferr;
@@ -10516,11 +10516,49 @@ do_show_overlay(int argc, char *argv[], const char *use)
 	exit(err);
 }
 
+static void
+parse_overlay_mac(const char *s, uint32_t *dcidp, struct ether_addr *ep)
+{
+	const char *slash;
+
+	*dcidp = 0;
+
+	if ((slash = strchr(s, '/')) != NULL) {
+		unsigned long dcval = 0;
+		size_t slen = (size_t)(slash - s) + 1;
+
+		/*
+		 * If present the dcid must be at least 1 digit, and <=
+		 * UINT32_MAX (10 digits + 1 for NUL).
+		 */
+		if (slen < 2 || slen > 11)
+			die("invalid mac specification: %s\n", s);
+
+		char dcstr[slen];
+
+		(void) strlcpy(dcstr, s, slen);
+		errno = 0;
+		if ((dcval = strtoul(dcstr, NULL, 10)) == 0 && errno != 0)
+			die("invalid data center id: %s\n", dcstr);
+
+		if (dcval > UINT32_MAX)
+			die("data center id out of range: %s\n", dcstr);
+
+		*dcidp = (uint32_t) dcval;
+		/* Move s past '/' */
+		s = slash + 1;
+	}
+
+	if (ether_aton_r(s, ep) == NULL)
+		die("invalid mac specification: %s\n", s);
+}
+
 static void
 do_modify_overlay(int argc, char *argv[], const char *use)
 {
 	int			opt, ocnt = 0;
 	boolean_t		flush, set, delete;
+	uint32_t		dcid = 0;
 	struct ether_addr	e;
 	char			*dest;
 	datalink_id_t		linkid = DATALINK_ALL_LINKID;
@@ -10535,8 +10573,7 @@ do_modify_overlay(int argc, char *argv[], const char *use)
 				die_optdup('d');
 			delete = B_TRUE;
 			ocnt++;
-			if (ether_aton_r(optarg, &e) == NULL)
-				die("invalid mac address: %s\n", optarg);
+			parse_overlay_mac(optarg, &dcid, &e);
 			break;
 		case 'f':
 			if (flush == B_TRUE)
@@ -10555,8 +10592,7 @@ do_modify_overlay(int argc, char *argv[], const char *use)
 			if (dest == NULL)
 				die("malformed value, expected mac=dest, "
 				    "got: %s\n", optarg);
-			if (ether_aton_r(optarg, &e) == NULL)
-				die("invalid mac address: %s\n", optarg);
+			parse_overlay_mac(optarg, &dcid, &e);
 			break;
 		default:
 			die_opterr(optopt, opt, use);
@@ -10587,14 +10623,15 @@ do_modify_overlay(int argc, char *argv[], const char *use)
 	}
 
 	if (delete == B_TRUE) {
-		status = dladm_overlay_cache_delete(handle, linkid, &e);
+		status = dladm_overlay_cache_delete(handle, linkid, dcid, &e);
 		if (status != DLADM_STATUS_OK)
 			die_dlerr(status, "failed to flush target %s from "
 			    "overlay target cache %s", optarg, argv[optind]);
 	}
 
 	if (set == B_TRUE) {
-		status = dladm_overlay_cache_set(handle, linkid, &e, dest);
+		status = dladm_overlay_cache_set(handle, linkid, dcid, &e,
+		    dest);
 		if (status != DLADM_STATUS_OK)
 			die_dlerr(status, "failed to set target %s for overlay "
 			    "target cache %s", optarg, argv[optind]);
diff --git a/usr/src/cmd/varpd/Makefile b/usr/src/cmd/varpd/Makefile
index 215f23d29e..8c29829d40 100644
--- a/usr/src/cmd/varpd/Makefile
+++ b/usr/src/cmd/varpd/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright 2015 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 PROG= varpd
@@ -43,6 +43,8 @@ C99LMODE=	-Xc99=%all
 
 .KEEP_STATE:
 
+all: $(PROG)
+
 $(PROG): $(OBJS)
 	$(LINK.c) -o $@ $(OBJS) $(LDLIBS)
 	$(POST_PROCESS)
diff --git a/usr/src/cmd/vndadm/Makefile b/usr/src/cmd/vndadm/Makefile
index aa9c22d296..2b9ca6c3c1 100644
--- a/usr/src/cmd/vndadm/Makefile
+++ b/usr/src/cmd/vndadm/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2014 Joyent, Inc.  All rights reserved.
+# Copyright (c) 2018 Joyent, Inc.  All rights reserved.
 #
 
 PROG= vndadm
@@ -38,6 +38,8 @@ SUBDIRS = test
 
 .KEEP_STATE:
 
+all: $(PROG)
+
 $(PROG): $(OBJS)
 	$(LINK.c) -o $@ $(OBJS) $(LDLIBS)
 	$(POST_PROCESS)
diff --git a/usr/src/lib/libdladm/common/libdloverlay.c b/usr/src/lib/libdladm/common/libdloverlay.c
index e508c4a16f..9aabb05558 100644
--- a/usr/src/lib/libdladm/common/libdloverlay.c
+++ b/usr/src/lib/libdladm/common/libdloverlay.c
@@ -713,7 +713,7 @@ dladm_overlay_cache_flush(dladm_handle_t handle, datalink_id_t linkid)
 /* ARGSUSED */
 dladm_status_t
 dladm_overlay_cache_delete(dladm_handle_t handle, datalink_id_t linkid,
-    const struct ether_addr *key)
+    uint32_t dcid, const struct ether_addr *key)
 {
 	int ret;
 	uint64_t varpdid;
@@ -727,7 +727,7 @@ dladm_overlay_cache_delete(dladm_handle_t handle, datalink_id_t linkid,
 		return (dladm_errno2status(ret));
 	}
 
-	ret = libvarpd_c_instance_cache_delete(chdl, varpdid, key);
+	ret = libvarpd_c_instance_cache_delete(chdl, varpdid, dcid, key);
 	libvarpd_c_destroy(chdl);
 
 	return (dladm_errno2status(ret));
@@ -736,7 +736,7 @@ dladm_overlay_cache_delete(dladm_handle_t handle, datalink_id_t linkid,
 /* ARGSUSED */
 dladm_status_t
 dladm_overlay_cache_set(dladm_handle_t handle, datalink_id_t linkid,
-    const struct ether_addr *key, char *val)
+    uint32_t dcid, const struct ether_addr *key, char *val)
 {
 	int ret;
 	uint_t dest;
@@ -841,7 +841,7 @@ dladm_overlay_cache_set(dladm_handle_t handle, datalink_id_t linkid,
 	}
 
 send:
-	ret = libvarpd_c_instance_cache_set(chdl, varpdid, key, &vcp);
+	ret = libvarpd_c_instance_cache_set(chdl, varpdid, dcid, key, &vcp);
 
 	libvarpd_c_destroy(chdl);
 	return (dladm_errno2status(ret));
diff --git a/usr/src/lib/libdladm/common/libdloverlay.h b/usr/src/lib/libdladm/common/libdloverlay.h
index 3da3a34f46..89b4c2fcff 100644
--- a/usr/src/lib/libdladm/common/libdloverlay.h
+++ b/usr/src/lib/libdladm/common/libdloverlay.h
@@ -56,9 +56,9 @@ extern dladm_status_t dladm_overlay_status(dladm_handle_t, datalink_id_t,
 
 extern dladm_status_t dladm_overlay_cache_flush(dladm_handle_t, datalink_id_t);
 extern dladm_status_t dladm_overlay_cache_delete(dladm_handle_t, datalink_id_t,
-    const struct ether_addr *);
+    uint32_t, const struct ether_addr *);
 extern dladm_status_t dladm_overlay_cache_set(dladm_handle_t, datalink_id_t,
-    const struct ether_addr *, char *);
+    uint32_t, const struct ether_addr *, char *);
 extern dladm_status_t dladm_overlay_cache_get(dladm_handle_t, datalink_id_t,
     const struct ether_addr *, dladm_overlay_point_t *);
 
diff --git a/usr/src/lib/varpd/files/Makefile.com b/usr/src/lib/varpd/files/Makefile.com
index 1f6a7c03b1..2929486b22 100644
--- a/usr/src/lib/varpd/files/Makefile.com
+++ b/usr/src/lib/varpd/files/Makefile.com
@@ -22,7 +22,7 @@ include ../../../Makefile.lib
 include ../../Makefile.plugin
 
 LIBS =		$(DYNLIB)
-LDLIBS +=	-lc -lumem -lnvpair -lsocket -lnsl -lcmdutils
+LDLIBS +=	-lc -lumem -lnvpair -lsocket -lnsl -lcmdutils -lavl -lbunyan
 CPPFLAGS +=	-I../common
 
 LINTFLAGS +=	-erroff=E_BAD_PTR_CAST_ALIGN
diff --git a/usr/src/lib/varpd/files/common/libvarpd_files.c b/usr/src/lib/varpd/files/common/libvarpd_files.c
index 7571913844..90ef1c34ce 100644
--- a/usr/src/lib/varpd/files/common/libvarpd_files.c
+++ b/usr/src/lib/varpd/files/common/libvarpd_files.c
@@ -82,23 +82,33 @@
 #include <strings.h>
 #include <assert.h>
 #include <limits.h>
+#include <sys/avl.h>
+#include <sys/debug.h>
+#include <sys/list.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <libnvpair.h>
+#include <stddef.h>
 #include <unistd.h>
 #include <sys/mman.h>
 #include <sys/ethernet.h>
 #include <sys/socket.h>
+#include <sys/vlan.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 
 #include <libvarpd_files_json.h>
 
 #define	FABRIC_NAME_MAX	64
+struct varpd_files_attach;
+typedef struct varpd_files_attach varpd_files_attach_t;
+
 typedef struct varpd_files_fabric {
+	avl_node_t	vafs_avlnode;
+	list_node_t	vafs_attached_node;
+	varpd_files_attach_t *vafs_attach;
 	char		vafs_name[FABRIC_NAME_MAX];
-	nvlist_t	*vafs_nvl;
 	struct in6_addr	vafs_addr;
 	uint64_t	vafs_vnet;
 	uint32_t	vafs_dcid;
@@ -107,19 +117,44 @@ typedef struct varpd_files_fabric {
 	uint8_t		vafs_routermac[ETHERADDRL];
 } varpd_files_fabric_t;
 
-typedef struct varpd_files_attach {
-	varpd_files_fabric_t **vff_fabrics;
-} varpd_files_attach_t;
+struct varpd_files_attach {
+	list_node_t	vfa_node;
+	char		vfa_name[FABRIC_NAME_MAX];
+	list_t		vfa_fabrics;
+};
+
+typedef struct varpd_files_if {
+	avl_node_t	vfi_macnode;
+	avl_node_t	vfi_ipnode;
+	avl_node_t	vfi_ndpnode;
+	struct in6_addr	vfi_ip;
+	struct in6_addr vfi_llocalip;	/* IPv6 link local if specified */
+	uint64_t	vfi_vnet;
+	uint32_t	vfi_dcid;
+	uint16_t	vfi_vlan;
+	uint8_t		vfi_mac[ETHERADDRL];
+	uint8_t		vfi_dhcp[ETHERADDRL]; /* dhcp-proxy MAC address */
+	boolean_t	vfi_has_dhcp;
+	boolean_t	vfi_has_lladdr;
+	overlay_target_point_t vfi_dest;
+} varpd_files_if_t;
 
 typedef struct varpd_files {
 	overlay_plugin_dest_t	vaf_dest;	/* RO */
 	varpd_provider_handle_t	*vaf_hdl;	/* RO */
 	char			*vaf_path;	/* WO */
-	nvlist_t		*vaf_nvl;	/* WO */
 	uint64_t		vaf_nmisses;	/* Atomic */
 	uint64_t		vaf_narp;	/* Atomic */
-	varpd_files_fabric_t	*vaf_fabrics;	/* RO */
-	varpd_files_attach_t	*vaf_attach;	/* RO */
+
+				/* These hold varpd_files_fabric_t's */
+	avl_tree_t		vaf_fabrics;	/* WO */
+	list_t			vaf_attached;	/* WO */
+
+				/* These hold varpd_files_if_t */
+	avl_tree_t		vaf_macs;	/* WO */
+	avl_tree_t		vaf_ips;	/* WO */
+	avl_tree_t		vaf_ndp;	/* WO */
+
 	uint64_t		vaf_vnet;	/* RO */
 	uint32_t		vaf_dcid;	/* RO */
 } varpd_files_t;
@@ -128,6 +163,8 @@ static const char *varpd_files_props[] = {
 	"files/config"
 };
 
+static bunyan_logger_t *files_bunyan;
+
 /*
  * Try to convert a string to an IP address or IP address + prefix.  We first
  * try to convert as an IPv6 address, and if that fails, we try to convert as
@@ -203,6 +240,106 @@ str_to_ip(const char *s, struct in6_addr *v6, uint8_t *prefixlen)
 	return (0);
 }
 
+static int
+varpd_files_if_mac_avl(const void *a, const void *b)
+{
+	const varpd_files_if_t *l = a;
+	const varpd_files_if_t *r = b;
+	int i;
+
+	if (l->vfi_dcid < r->vfi_dcid)
+		return (-1);
+	if (l->vfi_dcid > r->vfi_dcid)
+		return (1);
+
+	for (i = 0; i < ETHERADDRL; i++) {
+		if (l->vfi_mac[i] < r->vfi_mac[i])
+			return (-1);
+		if (l->vfi_mac[i] > r->vfi_mac[i])
+			return (1);
+	}
+
+	return (0);
+}
+
+static int
+varpd_files_if_ip_avl(const void *a, const void *b)
+{
+	const varpd_files_if_t *l = a;
+	const varpd_files_if_t *r = b;
+	int i;
+
+	if (l->vfi_vnet < r->vfi_vnet)
+		return (-1);
+	if (l->vfi_vnet > r->vfi_vnet)
+		return (1);
+	if (l->vfi_vlan < r->vfi_vlan)
+		return (-1);
+	if (l->vfi_vlan > r->vfi_vlan)
+		return (1);
+	for (i = 0; i < sizeof (struct in6_addr); i++) {
+		if (l->vfi_ip.s6_addr[i] < r->vfi_ip.s6_addr[i])
+			return (-1);
+		if (l->vfi_ip.s6_addr[i] > r->vfi_ip.s6_addr[i])
+			return (1);
+	}
+	return (0);
+}
+
+static int
+varpd_files_if_ndp_avl(const void *a, const void *b)
+{
+	const varpd_files_if_t *l = a;
+	const varpd_files_if_t *r = b;
+	int i;
+
+	VERIFY(l->vfi_has_lladdr);
+	VERIFY(r->vfi_has_lladdr);
+
+	for (i = 0; i < sizeof (struct in6_addr); i++) {
+		if (l->vfi_llocalip.s6_addr[i] < r->vfi_llocalip.s6_addr[i])
+			return (-1);
+		if (l->vfi_llocalip.s6_addr[i] > r->vfi_llocalip.s6_addr[i])
+			return (1);
+	}
+	return (0);
+}
+
+static int
+varpd_files_fabric_avl(const void *a, const void *b)
+{
+	const varpd_files_fabric_t *l = a;
+	const varpd_files_fabric_t *r = b;
+	int i;
+
+	/*
+	 * Sort by dcid, vnet, vlan, subnet.  With subnet last, we can use
+	 * avl_nearest() to find the fabric for an IP (given the other pieces
+	 * of information).
+	 */
+	if (l->vafs_dcid < r->vafs_dcid)
+		return (-1);
+	if (l->vafs_dcid > r->vafs_dcid)
+		return (1);
+	if (l->vafs_vnet < r->vafs_vnet)
+		return (-1);
+	if (l->vafs_vnet > r->vafs_vnet)
+		return (1);
+	if (l->vafs_vlan < r->vafs_vlan)
+		return (-1);
+	if (l->vafs_vlan > r->vafs_vlan)
+		return (1);
+
+	for (i = 0; i < sizeof (struct in6_addr); i++) {
+		if (l->vafs_addr.s6_addr[i] < r->vafs_addr.s6_addr[i])
+			return (-1);
+		if (l->vafs_addr.s6_addr[i] > r->vafs_addr.s6_addr[i])
+			return (1);
+	}
+
+	return (0);
+}
+
 static boolean_t
 varpd_files_valid_dest(overlay_plugin_dest_t dest)
 {
@@ -224,413 +361,672 @@ varpd_files_create(varpd_provider_handle_t *hdl, void **outp,
 	if (varpd_files_valid_dest(dest) == B_FALSE)
 		return (ENOTSUP);
 
-	vaf = umem_alloc(sizeof (varpd_files_t), UMEM_DEFAULT);
+	vaf = umem_zalloc(sizeof (varpd_files_t), UMEM_DEFAULT);
 	if (vaf == NULL)
 		return (ENOMEM);
 
-	bzero(vaf, sizeof (varpd_files_t));
 	vaf->vaf_dest = dest;
-	vaf->vaf_path = NULL;
-	vaf->vaf_nvl = NULL;
 	vaf->vaf_hdl = hdl;
 	vaf->vaf_dcid = libvarpd_plugin_dcid(hdl);
+	vaf->vaf_vnet = libvarpd_plugin_vnetid(hdl);
+	avl_create(&vaf->vaf_macs, varpd_files_if_mac_avl,
+	    sizeof (varpd_files_if_t), offsetof(varpd_files_if_t, vfi_macnode));
+	avl_create(&vaf->vaf_ips, varpd_files_if_ip_avl,
+	    sizeof (varpd_files_if_t), offsetof(varpd_files_if_t, vfi_ipnode));
+	avl_create(&vaf->vaf_ndp, varpd_files_if_ndp_avl,
+	    sizeof (varpd_files_if_t), offsetof(varpd_files_if_t, vfi_ndpnode));
+	avl_create(&vaf->vaf_fabrics, varpd_files_fabric_avl,
+	    sizeof (varpd_files_fabric_t),
+	    offsetof(varpd_files_fabric_t, vafs_avlnode));
+	list_create(&vaf->vaf_attached, sizeof (varpd_files_attach_t),
+	    offsetof(varpd_files_attach_t, vfa_node));
 	*outp = vaf;
 	return (0);
 }
 
-static int varpd_files_normalize_remote(nvlist_t *, nvlist_t *);
+static varpd_files_fabric_t *
+varpd_files_fabric_getbyname(varpd_files_t *vaf, const char *name)
+{
+	varpd_files_fabric_t *fab = NULL;
+
+	for (fab = avl_first(&vaf->vaf_fabrics); fab != NULL;
+	    fab = AVL_NEXT(&vaf->vaf_fabrics, fab)) {
+		if (strcmp(fab->vafs_name, name) == 0)
+			return (fab);
+	}
+
+	return (NULL);
+}
 
 static int
-varpd_files_normalize_ethers(nvlist_t *nvl, nvlist_t *out, boolean_t is_sub)
+varpd_files_convert_attached(varpd_files_t *vaf, nvlist_t *att)
 {
+	nvlist_t *nvl = NULL;
+	nvpair_t *nvp = NULL;
 	int ret;
-	nvpair_t *pair;
 
-	for (pair = nvlist_next_nvpair(nvl, NULL); pair != NULL;
-	    pair = nvlist_next_nvpair(nvl, pair)) {
-		char *name, fname[ETHERADDRSTRL];
-		nvlist_t *data;
-		struct ether_addr ether, *e;
-		e = &ether;
+	while ((nvp = nvlist_next_nvpair(att, nvp)) != NULL) {
+		varpd_files_attach_t *att;
+		char **nets = NULL;
+		uint32_t i, n;
 
-		if (nvpair_type(pair) != DATA_TYPE_NVLIST) {
-			nvlist_free(out);
+		if (nvpair_type(nvp) != DATA_TYPE_NVLIST) {
+			(void) bunyan_error(files_bunyan,
+			    "attached fabric group value is not an nvlist",
+			    BUNYAN_T_STRING, "group", nvpair_name(nvp),
+			    BUNYAN_T_END);
 			return (EINVAL);
 		}
 
-		name = nvpair_name(pair);
-		if ((ret = nvpair_value_nvlist(pair, &data)) != 0) {
-			nvlist_free(out);
+		if ((ret = nvpair_value_nvlist(nvp, &nvl)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "unexpected error retrieving attached fabric group",
+			    BUNYAN_T_STRING, "group", nvpair_name(nvp),
+			    BUNYAN_T_STRING, "errmsg", strerror(ret),
+			    BUNYAN_T_END);
 			return (EINVAL);
 		}
 
-		/* Remote subnet */
-		if (!is_sub && strncmp(name, "remote-", 7) == 0) {
-			nvlist_t *rem;
-
-			ret = nvlist_alloc(&rem, NV_UNIQUE_NAME, 0);
-			if (ret != 0) {
-				nvlist_free(out);
-				return (EINVAL);
-			}
-
-			ret = varpd_files_normalize_remote(data, rem);
-			if (ret != 0) {
-				nvlist_free(out);
-				return (EINVAL);
-			}
+		if ((ret = nvlist_lookup_boolean(nvl, ".__json_array")) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "group value does not appear to be a JSON array",
+			    BUNYAN_T_STRING, "group", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			return (EINVAL);
+		}
 
-			ret = nvlist_add_nvlist(out, name, rem);
-			nvlist_free(rem);
-			if (ret != 0) {
-				nvlist_free(out);
-				return (EINVAL);
-			}
-			continue;
+		if ((ret = nvlist_lookup_uint32(nvl, "length", &n)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "unexpected error obtain group array length",
+			    BUNYAN_T_STRING, "group", nvpair_name(nvp),
+			    BUNYAN_T_STRING, "errmsg", strerror(ret),
+			    BUNYAN_T_END);
+			return (ret);
 		}
 
-		/* attached and local fabrics */
-		if (!is_sub && (strncmp(name, "attach-", 7) == 0 ||
-		    strncmp(name, "local-", 6) == 0)) {
-			if ((ret = nvlist_add_nvlist(out, name, data)) != 0) {
-				nvlist_free(out);
-				return (EINVAL);
-			}
-			continue;
+		if ((nets = calloc(n, sizeof (char *))) == NULL) {
+			(void) bunyan_error(files_bunyan,
+			    "out of memory", BUNYAN_T_END);
+			return (ENOMEM);
 		}
 
-		if (ether_aton_r(name, e) == NULL) {
-			nvlist_free(out);
-			return (EINVAL);
+		/*
+		 * Note, we are just storing references to the names in
+		 * nets, so we only need to call free(nets), and not on
+		 * each entry (e.g. free(nets[0])).  We strlcpy() it out,
+		 * so we don't need to worry about it going away before we
+		 * done with it.
+		 */
+		for (i = 0; i < n; i++) {
+			char buf[11];	/* largest uint32_t val + NUL */
+
+			(void) snprintf(buf, sizeof (buf), "%u", i);
+			ret = nvlist_lookup_string(nvl, buf, &nets[i]);
+			if (ret != 0) {
+				(void) bunyan_error(files_bunyan,
+				    "unexpected error lookup up group array "
+				    "value",
+				    BUNYAN_T_STRING, "group", nvpair_name(nvp),
+				    BUNYAN_T_UINT32, "index", i,
+				    BUNYAN_T_STRING, "errmsg", strerror(ret),
+				    BUNYAN_T_END);
+				free(nets);
+				return (ret);
+			}
 		}
 
-		if (ether_ntoa_r(e, fname) == NULL) {
-			nvlist_free(out);
+		if ((att = umem_zalloc(sizeof (*att), UMEM_DEFAULT)) == NULL) {
+			(void) bunyan_error(files_bunyan, "out of memory",
+			    BUNYAN_T_END);
+			free(nets);
 			return (ENOMEM);
 		}
 
-		if ((ret = nvlist_add_nvlist(out, fname, data)) != 0) {
-			nvlist_free(out);
-			return (EINVAL);
+		if (strlcpy(att->vfa_name, nvpair_name(nvp),
+		    sizeof (att->vfa_name)) >= sizeof (att->vfa_name)) {
+			(void) bunyan_error(files_bunyan,
+			    "attached fabric group name is too long",
+			    BUNYAN_T_STRING, "group", nvpair_name(nvp),
+			    BUNYAN_T_UINT32, "len",
+			    (uint32_t)strlen(nvpair_name(nvp)),
+			    BUNYAN_T_UINT32, "maxlen",
+			    (uint32_t)sizeof (att->vfa_name) - 1,
+			    BUNYAN_T_END);
+			umem_free(att, sizeof (*att));
+			free(nets);
+			return (EOVERFLOW);
 		}
-	}
 
-	return (0);
-}
+		list_create(&att->vfa_fabrics, sizeof (varpd_files_fabric_t),
+		    offsetof(varpd_files_fabric_t, vafs_attached_node));
 
-static int
-varpd_files_normalize_remote(nvlist_t *nvl, nvlist_t *out)
-{
-	nvlist_t *macs, *mout;
-	nvpair_t *pair;
-	int ret;
+		list_insert_tail(&vaf->vaf_attached, att);
 
-	for (pair = nvlist_next_nvpair(nvl, NULL); pair != NULL;
-	    pair = nvlist_next_nvpair(nvl, pair)) {
-		char *name;
+		for (i = 0; i < n; i++) {
+			varpd_files_fabric_t *fab;
 
-		name = nvpair_name(pair);
-
-		if (strcmp(name, "macs") == 0) {
-			if ((ret = nvpair_value_nvlist(pair, &macs)) != 0) {
-				nvlist_free(out);
-				return (EINVAL);
+			fab = varpd_files_fabric_getbyname(vaf, nets[i]);
+			if (fab == NULL) {
+				(void) bunyan_error(files_bunyan,
+				    "subnet name not found",
+				    BUNYAN_T_STRING, "subnet", nets[i],
+				    BUNYAN_T_STRING, "group", nvpair_name(nvp),
+				    BUNYAN_T_END);
+				free(nets);
+				return (ENOENT);
 			}
 
-			/* This entry is handled at the end */
-			continue;
-		}
+			if (fab->vafs_attach != NULL) {
+				(void) bunyan_error(files_bunyan,
+				    "subnet already attached to another group",
+				    BUNYAN_T_STRING, "subnet", nets[i],
+				    BUNYAN_T_STRING, "group", nvpair_name(nvp),
+				    BUNYAN_T_STRING, "existing_group",
+				    fab->vafs_attach->vfa_name,
+				    BUNYAN_T_END);
+				free(nets);
+				return (EBUSY);
+			}
 
-		if ((ret = nvlist_add_nvpair(out, pair)) != 0) {
-			nvlist_free(out);
-			return (EINVAL);
+			fab->vafs_attach = att;
+			list_insert_tail(&att->vfa_fabrics, fab);
 		}
-	}
-
-	if (macs == NULL) {
-		nvlist_free(out);
-		return (EINVAL);
-	}
-
-	if ((ret = nvlist_alloc(&mout, NV_UNIQUE_NAME, 0)) != 0) {
-		nvlist_free(out);
-		return (EINVAL);
-	}
-
-	if ((ret = varpd_files_normalize_ethers(macs, mout, B_TRUE)) != 0) {
-		/* mout is freed on error by varpd_files_normalize_ethers() */
-		nvlist_free(out);
-		return (EINVAL);
-	}
-
-	ret = nvlist_add_nvlist(out, "macs", mout);
-	nvlist_free(mout);
-	if (ret != 0) {
-		nvlist_free(out);
-		return (EINVAL);
+		free(nets);
 	}
 
 	return (0);
 }
 
 static int
-varpd_files_normalize_nvlist(varpd_files_t *vaf, nvlist_t *nvl)
+varpd_files_convert_fabrics(varpd_files_t *vaf, nvpair_t *fpair)
 {
+	nvlist_t *nvl = NULL;
+	nvpair_t *nvp = NULL;
 	int ret;
-	nvlist_t *out;
-	nvpair_t *pair;
 
-	if ((ret = nvlist_alloc(&out, NV_UNIQUE_NAME, 0)) != 0)
-		return (ret);
+	ASSERT(strcmp(nvpair_name(fpair), "fabrics") == 0);
 
-	if ((ret = varpd_files_normalize_ethers(nvl, out, B_FALSE)) != 0) {
-		/* varpd_files_normalize_ethers() frees out on error */
+	if (nvpair_type(fpair) != DATA_TYPE_NVLIST) {
+		(void) bunyan_error(files_bunyan,
+		    "'fabrics' value is not an nvlist", BUNYAN_T_END);
 		return (EINVAL);
 	}
 
-	vaf->vaf_nvl = out;
-	return (0);
-}
-
-static int
-varpd_files_add_local_subnet(varpd_files_t *vaf, varpd_files_fabric_t *net,
-    const char *name, nvlist_t *nvl)
-{
-	char *s;
-	int32_t vlan;
-	int ret;
-
-	net->vafs_dcid = vaf->vaf_dcid;
-	net->vafs_vnet = vaf->vaf_vnet;
-	net->vafs_nvl = vaf->vaf_nvl;
-
-	(void) strlcpy(net->vafs_name, name, sizeof (net->vafs_name));
-
-	if ((ret = nvlist_lookup_string(nvl, "prefix", &s)) != 0)
-		return (EINVAL);
-	if (str_to_ip(s, &net->vafs_addr, &net->vafs_prefixlen) != 0)
-		return (EINVAL);
-
-	if ((ret = nvlist_lookup_int32(nvl, "prefix", &vlan)) != 0)
-		return (EINVAL);
-	if (vlan < 0 || vlan > 4096)
-		return (EINVAL);
-	net->vafs_vlan = (uint16_t)vlan;
-
-	/* XXX: routermac */
-	return (0);
-}
-
-static int
-varpd_files_add_remote_subnet(varpd_files_fabric_t *net, const char *netname,
-    nvlist_t *nvl)
-{
-	nvpair_t *pair;
-	int ret;
-
-	(void) strlcpy(net->vafs_name, netname, sizeof (net->vafs_name));
+	if ((ret = nvpair_value_nvlist(fpair, &nvl)) != 0) {
+		(void) bunyan_error(files_bunyan,
+		    "unexpected error reading value of 'fabrics'",
+		    BUNYAN_T_STRING, "errmsg", strerror(errno),
+		    BUNYAN_T_END);
+		return (ret);
+	}
 
-	for (pair = nvlist_next_nvpair(nvl, NULL); pair != NULL;
-	    pair = nvlist_next_nvpair(nvl, pair)) {
-		char *name = nvpair_name(pair);
+	while ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {
+		struct in6_addr ip = { 0 };
+		varpd_files_fabric_t *fab = NULL;
+		varpd_files_if_t *vl2 = NULL;
+		nvlist_t *vnvl = NULL;
 		int32_t i32;
+		char *s;
 
-		if (strcmp(name, "dcid") == 0) {
-			if ((ret = nvpair_value_int32(pair, &i32)) != 0)
-				return (ret);
-
-			net->vafs_dcid = (uint32_t)i32;
-		} else if (strcmp(name, "prefix") == 0) {
-			char *s;
-
-			if ((ret = nvpair_value_string(pair, &s)) != 0)
-				return (ret);
-
-			if (str_to_ip(s, &net->vafs_addr,
-			    &net->vafs_prefixlen) != 0)
+		if (strcmp(nvpair_name(nvp), "attached-fabrics") == 0) {
+			if (nvpair_type(nvp) != DATA_TYPE_NVLIST) {
+				(void) bunyan_error(files_bunyan,
+				    "'attached-fabrics' value is not an nvlist",
+				    BUNYAN_T_END);
 				return (EINVAL);
-		} else if (strcmp(name, "vnet") == 0) {
-			if ((ret = nvpair_value_int32(pair, &i32)) != 0)
-				return (ret);
-			net->vafs_vnet = i32;
-		} else if (strcmp(name, "vlan") == 0) {
-			if ((ret = nvpair_value_int32(pair, &i32)) != 0)
-				return (ret);
-			if (i32 > 4096 || i32 < 0)
-				return (EINVAL);
-			net->vafs_vlan = i32;
-		} else if (strcmp(name, "macs") == 0) {
-			nvlist_t *macs;
-
-			if ((ret = nvpair_value_nvlist(pair, &macs)) != 0)
-				return (ret);
+			}
 
-			if ((ret = nvlist_dup(macs, &net->vafs_nvl, 0)) != 0)
+			if ((ret = nvpair_value_nvlist(nvp, &vnvl)) != 0) {
+				(void) bunyan_error(files_bunyan,
+				    "unexpected error in 'attached-fabrics' "
+				    "value",
+				    BUNYAN_T_STRING, "errmsg", strerror(ret),
+				    BUNYAN_T_END);
 				return (ret);
-		} else if (strcmp(name, "routermac") == 0) {
-			char *s;
-			struct ether_addr *e;
-			e = (struct ether_addr *)&net->vafs_routermac;
-
-			if ((ret = nvpair_value_string(pair, &s)) != 0)
+			}
+			ret = varpd_files_convert_attached(vaf, vnvl);
+			if (ret != 0) {
 				return (ret);
-
-			if (ether_aton_r(s, e) == NULL)
-				return (EINVAL);
-
-		}
-	}
-
-	return (0);
-}
-
-static void varpd_files_stop_fabrics(varpd_files_t *);
-
-static int
-varpd_files_start_fabrics(varpd_files_t *vaf)
-{
-	nvpair_t *pair;
-	size_t nfabric = 0;
-	int ret;
-
-	for (pair = nvlist_next_nvpair(vaf->vaf_nvl, NULL); pair != NULL;
-	    pair = nvlist_next_nvpair(vaf->vaf_nvl, pair)) {
-		char *name = nvpair_name(pair);
-
-		if (strncmp(name, "remote-", 7) != 0 &&
-		    strncmp(name, "attach-", 7) != 0)
+			}
 			continue;
+		}
 
-		nfabric++;
-	}
-
-	if (nfabric == 0)
-		return (0);
-
-	vaf->vaf_fabrics = calloc(nfabric + 1, sizeof (varpd_files_fabric_t));
-	if (vaf->vaf_fabrics == NULL)
-		return (ENOMEM);
+		if (nvpair_type(nvp) != DATA_TYPE_NVLIST) {
+			(void) bunyan_error(files_bunyan,
+			    "subnet value is not an nvlist",
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			return (EINVAL);
+		}
 
-	nfabric = 0;
-	for (pair = nvlist_next_nvpair(vaf->vaf_nvl, NULL); pair != NULL;
-	    pair = nvlist_next_nvpair(vaf->vaf_nvl, pair)) {
-		char *name = nvpair_name(pair);
-		boolean_t is_remote = B_FALSE;
-		boolean_t is_local = B_FALSE;
+		if ((ret = nvpair_value_nvlist(nvp, &vnvl)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "unexpected error reading subnet value",
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			return (ret);
+		}
 
-		if (strncmp(name, "remote-", 7) == 0)
-			is_remote = B_TRUE;
-		if (strncmp(name, "local-", 7) == 0)
-			is_local = B_TRUE;
+		if ((fab = umem_zalloc(sizeof (*fab), UMEM_DEFAULT)) == NULL) {
+			(void) bunyan_error(files_bunyan, "out of memory",
+			    BUNYAN_T_END);
+			return (ENOMEM);
+		}
+		/* Default to our vid if none is given */
+		fab->vafs_vnet = vaf->vaf_vnet;
+
+		if (strlcpy(fab->vafs_name, nvpair_name(nvp),
+		    sizeof (fab->vafs_name)) >= sizeof (fab->vafs_name)) {
+			(void) bunyan_error(files_bunyan,
+			    "subnet name is too long",
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_UINT32, "length",
+			    (uint32_t)strlen(nvpair_name(nvp)),
+			    BUNYAN_T_UINT32, "maxlen",
+			    (uint32_t)sizeof (fab->vafs_name) - 1,
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (EOVERFLOW);
+		}
 
-		if (!is_remote && !is_local)
-			continue;
+		if ((ret = nvlist_lookup_string(vnvl, "prefix", &s)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'prefix' value is missing from subnet",
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (EINVAL);
+		}
+		if ((ret = str_to_ip(s, &fab->vafs_addr,
+		    &fab->vafs_prefixlen)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "prefix value is not valid",
+			    BUNYAN_T_STRING, "prefix", s,
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (ret);
+		}
+		/* XXX: Make sure it's the subnet address */
+
+		if ((ret = nvlist_lookup_int32(vnvl, "vlan", &i32)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'vlan' value is missing",
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (EINVAL);
+		}
+		if (i32 < 0 || i32 > VLAN_ID_MAX) {
+			(void) bunyan_error(files_bunyan,
+			    "vlan value is out of range (0-4094)",
+			    BUNYAN_T_INT32, "vlan", i32,
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (ERANGE);
+		}
+		fab->vafs_vlan = (uint16_t)i32;
+
+		if ((ret = nvlist_lookup_string(vnvl, "routerip", &s)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'routerip' value is missing",
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (EINVAL);
+		}
+		if ((ret = str_to_ip(s, &ip, NULL)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'routerip' value is not an IP",
+			    BUNYAN_T_STRING, "routerip", s,
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (ret);
+		}
 
-		varpd_files_fabric_t *net = &vaf->vaf_fabrics[nfabric++];
-		nvlist_t *netnvl;
+		if ((ret = nvlist_lookup_string(vnvl, "routermac", &s)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'routermac' value is missing from subnet",
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (EINVAL);
+		}
+		if (ether_aton_r(s,
+		    (struct ether_addr *)fab->vafs_routermac) == NULL) {
+			(void) bunyan_error(files_bunyan,
+			    "'routermac' is not a valid MAC address",
+			    BUNYAN_T_STRING, "mac", s,
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (EINVAL);
+		}
 
-		if ((ret = nvpair_value_nvlist(pair, &netnvl)) != 0) {
-			varpd_files_stop_fabrics(vaf);
+		/*
+		 * XXX: Because of the quirks of javascript, representing
+		 * integers > INT32_MAX in json becomes dicey.  Should we
+		 * just use a string instead?
+		 */
+		switch (ret = nvlist_lookup_int32(vnvl, "dcid", &i32)) {
+		case 0:
+			fab->vafs_dcid = (uint32_t)i32;
+			break;
+		case ENOENT:
+			fab->vafs_dcid = vaf->vaf_dcid;
+			break;
+		default:
+			(void) bunyan_error(files_bunyan,
+			    "unexpected error processing 'dcid' value",
+			    BUNYAN_T_STRING, "errmsg", strerror(errno),
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
 			return (ret);
 		}
 
-		ret = is_remote ?
-		    varpd_files_add_remote_subnet(net, name, netnvl) :
-		    varpd_files_add_local_subnet(vaf, net, name, netnvl);
-
-		if (ret != 0) {
-			varpd_files_stop_fabrics(vaf);
+		switch (ret = nvlist_lookup_string(vnvl, "vid", &s)) {
+		case ENOENT:
+			fab->vafs_vnet = vaf->vaf_vnet;
+			break;
+		case 0:
+			errno = 0;
+			if ((fab->vafs_vnet = strtoul(s, NULL, 10)) != 0 ||
+			    errno == 0)
+				break;
+			ret = errno;
+			(void) bunyan_error(files_bunyan,
+			    "unable to parse 'vid' as a number",
+			    BUNYAN_T_STRING, "vid", s,
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (ret);
+		default:
+			(void) bunyan_error(files_bunyan,
+			    "unexpected error processing 'vid' value",
+			    BUNYAN_T_STRING, "errmsg", strerror(errno),
+			    BUNYAN_T_STRING, "subnet", nvpair_name(nvp),
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
 			return (ret);
 		}
-	}
 
-	return (0);
-}
+		/* Make sure router ip is in subnet */
+		if (!IN6_ARE_PREFIXEDADDR_EQUAL(&ip, &fab->vafs_addr,
+		    fab->vafs_prefixlen)) {
+			void *ipp = &fab->vafs_addr;
+			bunyan_type_t type =
+			    IN6_IS_ADDR_V4MAPPED(&fab->vafs_addr) ?
+			    BUNYAN_T_IP : BUNYAN_T_IP6;
+
+			(void) bunyan_error(files_bunyan,
+			    "'routerip' value is not within subnet",
+			    type, "routerip", ipp,
+			    BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (EINVAL);
+		}
 
-static varpd_files_fabric_t *
-varpd_files_fabric_getbyname(varpd_files_t *vaf, const char *name)
-{
-	varpd_files_fabric_t *fab = &vaf->vaf_fabrics[0];
+		/*
+		 * Add VL2 entry for overlay router on this fabric.
+		 * Use umem_zalloc so vl2->vfi_dest (UL3 address) is all zeros.
+		 */
+		if ((vl2 = umem_zalloc(sizeof (*vl2), UMEM_DEFAULT)) == NULL) {
+			(void) bunyan_error(files_bunyan,
+			    "out of memory", BUNYAN_T_END);
+			umem_free(fab, sizeof (*fab));
+			return (ENOMEM);
+		}
 
-	for (fab = &vaf->vaf_fabrics[0]; fab->vafs_name[0] != '\0'; fab++) {
-		if (strcmp(fab->vafs_name, name) != 0)
-			continue;
-		return (fab);
+		bcopy(&ip, &vl2->vfi_ip, sizeof (struct in6_addr));
+		bcopy(fab->vafs_routermac, vl2->vfi_mac, ETHERADDRL);
+		vl2->vfi_dcid = fab->vafs_dcid;
+		vl2->vfi_vnet = fab->vafs_vnet;
+		vl2->vfi_vlan = fab->vafs_vlan;
+		avl_add(&vaf->vaf_macs, vl2);
+		avl_add(&vaf->vaf_ips, vl2);
+
+		avl_add(&vaf->vaf_fabrics, fab);
 	}
 
-	return (NULL);
+	return (0);
 }
 
-static void
-varpd_files_stop_attached(varpd_files_t *vaf)
+static int
+varpd_files_convert_nvlist(varpd_files_t *vaf, nvlist_t *data, uint_t level)
 {
-	size_t i;
+	nvpair_t *nvp = NULL;
+	nvlist_t *nvl = NULL;
+	char *name;
+	int ret;
 
-	if (vaf->vaf_attach == NULL)
-		return;
+	while ((nvp = nvlist_next_nvpair(data, nvp)) != NULL) {
+		varpd_files_if_t *ifp = NULL;
+		char *s;
+		int32_t i32;
 
-	for (i = 0; vaf->vaf_attach[i].vff_fabrics != NULL; i++)
-		free(vaf->vaf_attach[i].vff_fabrics);
+		name = nvpair_name(nvp);
 
-	free(vaf->vaf_attach);
-	vaf->vaf_attach = NULL;
-}
+		(void) bunyan_debug(files_bunyan, "processing key",
+		    BUNYAN_T_STRING, "key", name,
+		    BUNYAN_T_END);
 
-static int
-varpd_files_start_attached(varpd_files_t *vaf)
-{
-	nvpair_t *pair;
-	size_t nattach = 0;
-	int ret;
+		if (nvpair_type(nvp) != DATA_TYPE_NVLIST) {
+			(void) bunyan_error(files_bunyan,
+			    "value is not a hash (nvlist)",
+			    BUNYAN_T_STRING, "key", name,
+			    BUNYAN_T_END);
+			return (EINVAL);
+		}
 
-	for (pair = nvlist_next_nvpair(vaf->vaf_nvl, NULL); pair != NULL;
-	    pair = nvlist_next_nvpair(vaf->vaf_nvl, pair)) {
-		char *name;
+		if ((ret = nvpair_value_nvlist(nvp, &nvl)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "unexpected error reading values for mac entry",
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_STRING, "errmsg", strerror(ret),
+			    BUNYAN_T_END);
+			return (ret);
+		}
 
-		name = nvpair_name(pair);
-		if (strncmp(name, "attach-", 7) != 0)
+		if (strcmp(name, "fabrics") == 0) {
+			if (level > 0) {
+				(void) bunyan_error(files_bunyan,
+				    "'fabrics' can only appear at the top-most "
+				    "level", BUNYAN_T_END);
+				return (EINVAL);
+			}
+			ret = varpd_files_convert_fabrics(vaf, nvp);
+			if (ret != 0) {
+				return (ret);
+			}
 			continue;
+		}
 
-		if (nvpair_type(pair) != DATA_TYPE_STRING_ARRAY)
+		if ((ifp = umem_zalloc(sizeof (*ifp), UMEM_DEFAULT)) == NULL) {
+			(void) bunyan_error(files_bunyan,
+			    "out of memory", BUNYAN_T_END);
+			return (ENOMEM);
+		}
+		ifp->vfi_dcid = vaf->vaf_dcid;
+
+		struct ether_addr *ep = (struct ether_addr *)ifp->vfi_mac;
+		if (ether_aton_r(name, ep) == NULL) {
+			(void) bunyan_error(files_bunyan, "invalid MAC address",
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
 			return (EINVAL);
+		}
 
-		nattach++;
-	}
+		if ((ret = nvlist_lookup_int32(nvl, "vlan", &i32)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'vlan' entry is missing",
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
+			return (ret);
+		}
+		if (i32 < 0 || i32 > VLAN_ID_MAX) {
+			(void) bunyan_error(files_bunyan,
+			    "vlan value is out of range (0-4094)",
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_INT32, "vlan", i32,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
+			return (ERANGE);
+		}
+		ifp->vfi_vlan = (uint16_t)i32;
+
+		if ((ret = nvlist_lookup_string(nvl, "arp", &s)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'arp' entry is missing",
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_STRING, "errmsg", strerror(ret),
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
+			return (ret);
+		}
+		if ((ret = str_to_ip(s, &ifp->vfi_ip, NULL)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'arp' value is not an IP address",
+			    BUNYAN_T_STRING, "arp", s,
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
+			return (ret);
+		}
 
-	if (nattach == 0)
-		return (0);
+		if ((ret = nvlist_lookup_string(nvl, "ip", &s)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'ip' entry is missing",
+			    BUNYAN_T_STRING, "ip", s,
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
+			return (ret);
+		}
+		if ((ret = str_to_ip(s, &ifp->vfi_dest.otp_ip, NULL)) != 0) {
+			(void) bunyan_error(files_bunyan,
+			    "'ip' value is not a IP address",
+			    BUNYAN_T_STRING, "ip", s,
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
+			return (ret);
+		}
 
-	if ((vaf->vaf_attach = calloc(nattach + 1,
-	    sizeof (varpd_files_attach_t))) == NULL)
-		return (ENOMEM);
+		if (vaf->vaf_dest & OVERLAY_PLUGIN_D_PORT) {
+			ret = nvlist_lookup_int32(nvl, "port", &i32);
+			if (ret != 0) {
+				(void) bunyan_error(files_bunyan,
+				    "'port' value is required, but is missing",
+				    BUNYAN_T_STRING, "mac", name,
+				    BUNYAN_T_END);
+				umem_free(ifp, sizeof (*ifp));
+				return (ret);
+			}
 
-	nattach = 0;
-	for (pair = nvlist_next_nvpair(vaf->vaf_nvl, NULL); pair != NULL;
-	    pair = nvlist_next_nvpair(vaf->vaf_nvl, pair)) {
-		varpd_files_attach_t *fa = &vaf->vaf_attach[nattach++];
-		char **fabrics = NULL;
-		uint_t i, nelem = 0;
+			if (i32 <= 0 || i32 > UINT16_MAX) {
+				(void) bunyan_error(files_bunyan,
+				    "'port' value is out of range (0-65535)",
+				    BUNYAN_T_INT32, "port", i32,
+				    BUNYAN_T_STRING, "mac", name,
+				    BUNYAN_T_END);
+				umem_free(ifp, sizeof (*ifp));
+				return (ERANGE);
+			}
+			ifp->vfi_dest.otp_port = i32;
+		}
 
-		if ((ret = nvpair_value_string_array(pair, &fabrics,
-		    &nelem)) != NULL) {
-			varpd_files_stop_attached(vaf);
+		switch (ret = nvlist_lookup_string(nvl, "ndp", &s)) {
+		case 0:
+			ret = str_to_ip(s, &ifp->vfi_llocalip, NULL);
+			if (ret != 0) {
+				(void) bunyan_error(files_bunyan,
+				    "'ndp' value is not an IP",
+				    BUNYAN_T_STRING, "ndp", s,
+				    BUNYAN_T_STRING, "mac", name,
+				    BUNYAN_T_END);
+				return (ret);
+			}
+			ifp->vfi_has_lladdr = B_TRUE;
+			break;
+		case ENOENT:
+			/* Ok if missing */
+			break;
+		default:
+			(void) bunyan_error(files_bunyan,
+			    "unexpected error processing 'ndp' value",
+			    BUNYAN_T_STRING, "errmsg", strerror(errno),
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
 			return (ret);
 		}
 
-		if ((fa = calloc(nelem + 1, sizeof (varpd_files_fabric_t *))) ==
-		    NULL) {
-			varpd_files_stop_attached(vaf);
-			return (ENOMEM);
+		switch (ret = nvlist_lookup_string(nvl, "dhcp-proxy", &s)) {
+		case 0:
+			ep = (struct ether_addr *)&ifp->vfi_dhcp;
+			if (ether_aton_r(s, ep) == NULL) {
+				(void) bunyan_error(files_bunyan,
+				    "value of 'dhcp-proxy' is not a "
+				    "MAC address",
+				    BUNYAN_T_STRING, "dhcp-proxy", s,
+				    BUNYAN_T_STRING, "mac", name,
+				    BUNYAN_T_END);
+				umem_free(ifp, sizeof (*ifp));
+				return (EINVAL);
+			}
+			ifp->vfi_has_dhcp = B_TRUE;
+			break;
+		case ENOENT:
+			/* Ok if missing */
+			break;
+		default:
+			(void) bunyan_error(files_bunyan,
+			    "unexpected error reading 'dhcp-proxy' value",
+			    BUNYAN_T_STRING, "errmsg", strerror(errno),
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
+			return (ret);
 		}
 
-		for (i = 0; i < nelem; i++) {
-			fa->vff_fabrics[i] =
-			    varpd_files_fabric_getbyname(vaf, fabrics[i]);
-			if (fa->vff_fabrics[i] == NULL) {
-				varpd_files_stop_attached(vaf);
-				return (ENOENT);
-			}
+		switch (ret = nvlist_lookup_string(nvl, "vid", &s)) {
+		case ENOENT:
+			ifp->vfi_vnet = vaf->vaf_vnet;
+			break;
+		case 0:
+			errno = 0;
+			if ((ifp->vfi_vnet = strtoul(s, NULL, 10)) != 0 ||
+			    errno == 0)
+				break;
+			ret = errno;
+			(void) bunyan_error(files_bunyan,
+			    "unable to parse 'vid' as a number",
+			    BUNYAN_T_STRING, "vid", s,
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
+			return (ret);
+		default:
+			(void) bunyan_error(files_bunyan,
+			    "unexpected error processing 'vid' value",
+			    BUNYAN_T_STRING, "errmsg", strerror(errno),
+			    BUNYAN_T_STRING, "mac", name,
+			    BUNYAN_T_END);
+			umem_free(ifp, sizeof (*ifp));
+			return (ret);
 		}
+
+		/* Make sure router ip is in subnet */
+		avl_add(&vaf->vaf_macs, ifp);
+		avl_add(&vaf->vaf_ips, ifp);
+		if (ifp->vfi_has_lladdr && (ifp->vfi_dcid == vaf->vaf_dcid))
+			avl_add(&vaf->vaf_ndp, ifp);
 	}
 
 	return (0);
@@ -644,17 +1040,29 @@ varpd_files_start(void *arg)
 	struct stat st;
 	nvlist_t *nvl;
 	varpd_files_t *vaf = arg;
+	nvlist_parse_json_error_t jerr = { 0 };
 
 	if (vaf->vaf_path == NULL)
 		return (EAGAIN);
 
-	if ((fd = open(vaf->vaf_path, O_RDONLY)) < 0)
+	if ((fd = open(vaf->vaf_path, O_RDONLY)) < 0) {
+		(void) bunyan_error(files_bunyan,
+		    "Cannot read destination data",
+		    BUNYAN_T_STRING, "path", vaf->vaf_path,
+		    BUNYAN_T_STRING, "errmsg", strerror(errno),
+		    BUNYAN_T_END);
 		return (errno);
+	}
 
 	if (fstat(fd, &st) != 0) {
 		ret = errno;
 		if (close(fd) != 0)
 			abort();
+		(void) bunyan_error(files_bunyan,
+		    "could not determine status of file (stat(2) failed)",
+		    BUNYAN_T_STRING, "path", vaf->vaf_path,
+		    BUNYAN_T_STRING, "errmsg", strerror(ret),
+		    BUNYAN_T_END);
 		return (ret);
 	}
 
@@ -664,64 +1072,74 @@ varpd_files_start(void *arg)
 		ret = errno;
 		if (close(fd) != 0)
 			abort();
+		(void) bunyan_error(files_bunyan,
+		    "could not load destination data (mmap(2) failed)",
+		    BUNYAN_T_STRING, "path", vaf->vaf_path,
+		    BUNYAN_T_STRING, "errmsg", strerror(errno),
+		    BUNYAN_T_END);
 		return (ret);
 	}
 
-	ret = nvlist_parse_json(maddr, st.st_size, &nvl,
-	    NVJSON_FORCE_INTEGER, NULL);
-	if (ret == 0) {
-		ret = varpd_files_normalize_nvlist(vaf, nvl);
+	if ((ret = nvlist_parse_json(maddr, st.st_size, &nvl,
+	    NVJSON_FORCE_INTEGER, &jerr)) != 0) {
+		(void) bunyan_error(files_bunyan,
+		    "could not parse destination JSON file",
+		    BUNYAN_T_STRING, "path", vaf->vaf_path,
+		    BUNYAN_T_STRING, "parse_msg", jerr.nje_message,
+		    BUNYAN_T_UINT32, "pos", (uint32_t)jerr.nje_pos,
+		    BUNYAN_T_INT32, "errno", (int32_t)jerr.nje_errno,
+		    BUNYAN_T_STRING, "errmsg", strerror(jerr.nje_errno),
+		    BUNYAN_T_END);
+	} else {
+		ret = varpd_files_convert_nvlist(vaf, nvl, 0);
 		nvlist_free(nvl);
 		nvl = NULL;
 	}
+
 	if (munmap(maddr, st.st_size) != 0)
 		abort();
 	if (close(fd) != 0)
 		abort();
-	if (ret != 0) {
-		nvlist_free(nvl);
-		return (ret);
-	}
-
-	if ((ret = varpd_files_start_fabrics(vaf)) != 0) {
-		nvlist_free(nvl);
-		return (ret);
-	}
-
-	if ((ret = varpd_files_start_attached(vaf)) != 0) {
-		varpd_files_stop_fabrics(vaf);
-		nvlist_free(nvl);
-		return (ret);
-	}
 
 	return (ret);
 }
 
 static void
-varpd_files_stop_fabrics(varpd_files_t *vaf)
+varpd_files_stop(void *arg)
 {
-	varpd_files_fabric_t *net = NULL;
+	varpd_files_t *vaf = arg;
+	varpd_files_if_t *vif;
+	varpd_files_attach_t *att;
+	varpd_files_fabric_t *fab;
 
-	if (vaf == NULL || vaf->vaf_fabrics == NULL)
-		return;
+	/*
+	 * VL2 data should appear in both trees, so free only after removed
+	 * from second tree.
+	 */
+	while ((vif = avl_first(&vaf->vaf_ips)) != NULL)
+		avl_remove(&vaf->vaf_ips, vif);
 
-	for (net = vaf->vaf_fabrics; net->vafs_name[0] != '\0'; net++) {
-		if (net->vafs_nvl != vaf->vaf_nvl)
-			nvlist_free(net->vafs_nvl);
+	while ((vif = avl_first(&vaf->vaf_macs)) != NULL) {
+		avl_remove(&vaf->vaf_macs, vif);
+		umem_free(vif, sizeof (*vif));
 	}
-	free(vaf->vaf_fabrics);
-	vaf->vaf_fabrics = NULL;
-}
 
+	/*
+	 * A fabric could be unattached, and not appear in any attachment
+	 * group.  Therefore, remove the fabrics from all the attached groups,
+	 * then free them after removing from the global list of fabrics.
+	 */
+	while ((att = list_remove_head(&vaf->vaf_attached)) != NULL) {
+		do {
+			fab = list_remove_head(&att->vfa_fabrics);
+		} while (fab != NULL);
+		umem_free(att, sizeof (*att));
+	}
 
-static void
-varpd_files_stop(void *arg)
-{
-	varpd_files_t *vaf = arg;
-
-	varpd_files_stop_fabrics(vaf);
-	nvlist_free(vaf->vaf_nvl);
-	vaf->vaf_nvl = NULL;
+	while ((fab = avl_first(&vaf->vaf_fabrics)) != NULL) {
+		avl_remove(&vaf->vaf_fabrics, fab);
+		umem_free(fab, sizeof (*fab));
+	}
 }
 
 static void
@@ -729,89 +1147,92 @@ varpd_files_destroy(void *arg)
 {
 	varpd_files_t *vaf = arg;
 
-	assert(vaf->vaf_nvl == NULL);
 	if (vaf->vaf_path != NULL) {
 		umem_free(vaf->vaf_path, strlen(vaf->vaf_path) + 1);
 		vaf->vaf_path = NULL;
 	}
+
+	avl_destroy(&vaf->vaf_fabrics);
+	avl_destroy(&vaf->vaf_macs);
+	avl_destroy(&vaf->vaf_ips);
+	list_destroy(&vaf->vaf_attached);
+
 	umem_free(vaf, sizeof (varpd_files_t));
 }
 
-static nvlist_t *
-varpd_files_lookup_l3subnet(varpd_files_t *vaf, varpd_files_attach_t *attach,
-    const struct in6_addr *dst, overlay_target_point_t *otp,
-    overlay_target_route_t *otr)
+static varpd_files_fabric_t *
+varpd_files_find_dstfab(varpd_files_t *vaf, varpd_files_attach_t *att,
+    const struct in6_addr *dst)
 {
 	varpd_files_fabric_t *net = NULL;
-	nvlist_t *macs = NULL;
-	size_t i;
-	boolean_t found = B_FALSE;
-
-	for (i = 0; attach->vff_fabrics[i] != NULL; i++) {
-		net = attach->vff_fabrics[i];
 
+	for (net = list_head(&att->vfa_fabrics); net != NULL;
+	    net = list_next(&att->vfa_fabrics, net)) {
 		if (IN6_ARE_PREFIXEDADDR_EQUAL(dst, &net->vafs_addr,
 		    net->vafs_prefixlen)) {
-			found = B_TRUE;
-			break;
+			return (net);
 		}
 	}
 
-	if (nvlist_lookup_nvlist(net->vafs_nvl, "macs", &macs) != 0)
-		return (NULL);
-
-	otr->otr_vnet = net->vafs_vnet;
-	otr->otr_vlan = net->vafs_vlan;
-	otr->otr_dcid = net->vafs_dcid;
-	otr->otr_dst_prefixlen = net->vafs_prefixlen;
-	bcopy(net->vafs_routermac, otr->otr_srcmac, ETHERADDRL);
-	return (macs);
+	return (NULL);
 }
 
 static varpd_files_attach_t *
 varpd_files_find_attach(varpd_files_t *vaf, const struct in6_addr *src,
     uint16_t vlan, overlay_target_route_t *otr)
 {
-	varpd_files_attach_t *attach;
 	varpd_files_fabric_t *fab;
-	size_t i;
+	varpd_files_fabric_t lookup = {
+		.vafs_vnet = vaf->vaf_vnet,
+		.vafs_dcid = vaf->vaf_dcid,
+		.vafs_vlan = vlan,
+		.vafs_addr = *src
+	};
+	avl_index_t where = 0;
 
-	if (vaf->vaf_attach == NULL)
+	/*
+	 * Since fabrics are sorted by subnet address last, any given IP
+	 * potentially in a fabric subnet should lie between two adjacent
+	 * fabric entries in the tree.  Find where such an IP would go in
+	 * the tree, and the entry before the insertion point should be the
+	 * fabric (if it is present).
+	 */
+	fab = avl_find(&vaf->vaf_fabrics, &lookup, &where);
+	if (fab != NULL) {
+		/*
+		 * Someone requested the subnet address.  E.g. if the fabric
+		 * is 192.168.10.0/24, someone asked for 192.168.10.0.  Treat
+		 * as not found.
+		 */
 		return (NULL);
+	}
 
-	for (attach = vaf->vaf_attach; attach->vff_fabrics != NULL; attach++) {
-		for (i = 0; attach->vff_fabrics[i] != NULL; i++) {
-			fab = attach->vff_fabrics[i];
+	fab = avl_nearest(&vaf->vaf_fabrics, where, AVL_BEFORE);
+	if (fab == NULL) {
+		return (NULL);
+	}
 
-			if (fab->vafs_dcid == vaf->vaf_dcid &&
-			    fab->vafs_vlan == vlan &&
-			    IN6_ARE_PREFIXEDADDR_EQUAL(src, &fab->vafs_addr,
-			    fab->vafs_prefixlen)) {
-				otr->otr_src_prefixlen = fab->vafs_prefixlen;
-				return (attach);
-			}
-			fab++;
-		}
+	/* Still must verify that the address lies in the range of the subnet */
+	if (!IN6_ARE_PREFIXEDADDR_EQUAL(&fab->vafs_addr, src,
+	   fab->vafs_prefixlen)) {
+		return (NULL);
 	}
 
-	return (NULL);
+	return (fab->vafs_attach);
 }
 
 static void
 varpd_files_lookup_l3(varpd_files_t *vaf, varpd_query_handle_t *qh,
     const overlay_targ_lookup_t *otl, overlay_target_point_t *otp,
-    overlay_target_route_t *otr)
+    overlay_target_route_t *otr, overlay_target_mac_t *otm)
 {
-	const struct in6_addr *dest_ip;
+	const struct in6_addr *dst_ip;
 	const struct in6_addr *src_ip;
-	struct in6_addr ul3 = { 0 };
 	varpd_files_attach_t *attach = NULL;
-	char *s;
-	nvlist_t *macs = NULL, *entry = NULL;
-	nvpair_t *pair = NULL;
-	int32_t prefixlen;
+	varpd_files_fabric_t *fab = NULL;
+	varpd_files_if_t *ifp = NULL;
 
-	dest_ip = &otl->otl_addru.otlu_l3.otl3_dstip;
+	dst_ip = &otl->otl_addru.otlu_l3.otl3_dstip;
 	src_ip = &otl->otl_addru.otlu_l3.otl3_srcip;
 
 	if ((attach = varpd_files_find_attach(vaf, src_ip, otl->otl_vlan,
@@ -820,65 +1241,30 @@ varpd_files_lookup_l3(varpd_files_t *vaf, varpd_query_handle_t *qh,
 		return;
 	}
 
-	if ((macs = varpd_files_lookup_l3subnet(vaf, attach, dest_ip,
-	    otp, otr)) == NULL) {
+	if ((fab = varpd_files_find_dstfab(vaf, attach, dst_ip)) == NULL) {
 		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
 		return;
 	}
 
-	for (pair = nvlist_next_nvpair(macs, NULL); pair != NULL;
-	    pair = nvlist_next_nvpair(macs, pair)) {
-		char *s;
-		struct in6_addr v6;
-
-		if (nvpair_value_nvlist(pair, &entry) != 0)
-			continue;
-
-		if (nvlist_lookup_string(entry, "arp", &s) != 0)
-			continue;
-
-		if (str_to_ip(s, &v6, NULL) != 0)
-			continue;
-
-		if (IN6_ARE_ADDR_EQUAL(dest_ip, &v6))
-			break;
-	}
+	varpd_files_if_t lookup = { 0 };
 
-	if (pair == NULL) {
-		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-		return;
-	}
+	lookup.vfi_vnet = fab->vafs_vnet;
+	lookup.vfi_vlan = fab->vafs_vlan;
+	bcopy(dst_ip, &lookup.vfi_ip, sizeof (struct in6_addr));
 
-	if (nvlist_lookup_string(entry, "ip", &s) != 0) {
+	if ((ifp = avl_find(&vaf->vaf_ips, &lookup, NULL)) == NULL) {
 		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
 		return;
 	}
 
-	if (str_to_ip(s, &ul3, NULL) != 0) {
-		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-		return;
-	}
-	bcopy(&ul3, &otp->otp_ip, sizeof (ul3));
+	otr->otr_vnet = fab->vafs_vnet;
+	otr->otr_vlan = fab->vafs_vlan;
+	bcopy(fab->vafs_routermac, otr->otr_srcmac, ETHERADDRL);
 
-	if (vaf->vaf_dest & OVERLAY_PLUGIN_D_PORT) {
-		int32_t port;
+	otm->otm_dcid = fab->vafs_dcid;
+	bcopy(ifp->vfi_mac, otm->otm_mac, ETHERADDRL);
 
-		if (nvlist_lookup_int32(entry, "port", &port) != 0) {
-			libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-			return;
-		}
-
-		otp->otp_port = port;
-	} else {
-		otp->otp_port = 0;
-	}
-
-	s = nvpair_name(pair);
-
-	if (ether_aton_r(s, (struct ether_addr *)otp->otp_mac) == NULL) {
-		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-		return;
-	}
+	bcopy(&ifp->vfi_dest, otp, sizeof (*otp));
 
 	libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_OK);
 }
@@ -886,13 +1272,13 @@ varpd_files_lookup_l3(varpd_files_t *vaf, varpd_query_handle_t *qh,
 static void
 varpd_files_lookup(void *arg, varpd_query_handle_t *qh,
     const overlay_targ_lookup_t *otl, overlay_target_point_t *otp,
-    overlay_target_route_t *otr)
+    overlay_target_route_t *otr, overlay_target_mac_t *otm)
 {
-	char macstr[ETHERADDRSTRL], *ipstr;
-	nvlist_t *nvl;
 	varpd_files_t *vaf = arg;
-	int32_t port;
 	static const uint8_t bcast[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+	varpd_files_if_t *ifp = NULL;
+	varpd_files_if_t lookup = { .vfi_dcid = vaf->vaf_dcid };
+
 
 	/* We don't support a default */
 	if (otl == NULL) {
@@ -904,15 +1290,16 @@ varpd_files_lookup(void *arg, varpd_query_handle_t *qh,
 	 * Shuffle off L3 lookups to their own codepath.
 	 */
 	if (otl->otl_l3req) {
-		varpd_files_lookup_l3(vaf, qh, otl, otp, otr);
+		varpd_files_lookup_l3(vaf, qh, otl, otp, otr, otm);
 		return;
 	}
 
 	/*
 	 * At this point, the traditional overlay_target_point_t is all that
-	 * needs filling in.  Zero-out the otr for safety.
+	 * needs filling in.  Zero-out the otr and otm for safety.
 	 */
 	bzero(otr, sizeof (*otr));
+	bzero(otm, sizeof (*otm));
 
 	if (otl->otl_addru.otlu_l2.otl2_sap == ETHERTYPE_ARP) {
 		libvarpd_plugin_proxy_arp(vaf->vaf_hdl, qh, otl);
@@ -928,28 +1315,15 @@ varpd_files_lookup(void *arg, varpd_query_handle_t *qh,
 
 	if (otl->otl_addru.otlu_l2.otl2_sap == ETHERTYPE_IP &&
 	    bcmp(otl->otl_addru.otlu_l2.otl2_dstaddr, bcast, ETHERADDRL) == 0) {
-		char *mac;
-		struct ether_addr a, *addr;
-
-		addr = &a;
-		if (ether_ntoa_r(
-		    (struct ether_addr *)otl->otl_addru.otlu_l2.otl2_srcaddr,
-		    macstr) == NULL) {
-			libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-			return;
-		}
+		bcopy(otl->otl_addru.otlu_l2.otl2_srcaddr, lookup.vfi_mac,
+		    ETHERADDRL);
 
-		if (nvlist_lookup_nvlist(vaf->vaf_nvl, macstr, &nvl) != 0) {
+		if ((ifp = avl_find(&vaf->vaf_macs, &lookup, NULL)) == NULL) {
 			libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
 			return;
 		}
 
-		if (nvlist_lookup_string(nvl, "dhcp-proxy", &mac) != 0) {
-			libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-			return;
-		}
-
-		if (ether_aton_r(mac, addr) == NULL) {
+		if (!ifp->vfi_has_dhcp) {
 			libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
 			return;
 		}
@@ -958,38 +1332,13 @@ varpd_files_lookup(void *arg, varpd_query_handle_t *qh,
 		return;
 	}
 
-	if (ether_ntoa_r(
-	    (struct ether_addr *)otl->otl_addru.otlu_l2.otl2_dstaddr,
-	    macstr) == NULL) {
-		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-		return;
-	}
-
-	if (nvlist_lookup_nvlist(vaf->vaf_nvl, macstr, &nvl) != 0) {
+	bcopy(otl->otl_addru.otlu_l2.otl2_dstaddr, lookup.vfi_mac, ETHERADDRL);
+	if ((ifp = avl_find(&vaf->vaf_macs, &lookup, NULL)) == NULL) {
 		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
 		return;
 	}
 
-	if (nvlist_lookup_int32(nvl, "port", &port) != 0) {
-		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-		return;
-	}
-
-	if (port <= 0 || port > UINT16_MAX) {
-		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-		return;
-	}
-	otp->otp_port = port;
-
-	if (nvlist_lookup_string(nvl, "ip", &ipstr) != 0) {
-		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-		return;
-	}
-
-	if (str_to_ip(ipstr, &otp->otp_ip, NULL) != 0) {
-		libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_DROP);
-		return;
-	}
+	bcopy(&ifp->vfi_dest, otp, sizeof (*otp));
 
 	libvarpd_plugin_query_reply(qh, VARPD_LOOKUP_OK);
 }
@@ -1126,12 +1475,17 @@ varpd_files_restore(nvlist_t *nvp, varpd_provider_handle_t *hdl,
 
 static void
 varpd_files_proxy_arp(void *arg, varpd_arp_handle_t *vah, int kind,
-    const struct sockaddr *sock, uint8_t *out)
+    const struct sockaddr *sock, uint16_t vlan, uint8_t *out)
 {
 	varpd_files_t *vaf = arg;
 	const struct sockaddr_in *ip;
 	const struct sockaddr_in6 *ip6;
-	nvpair_t *pair;
+	varpd_files_if_t *ifp = NULL;
+	varpd_files_if_t lookup = {
+		.vfi_vnet = vaf->vaf_vnet,
+		.vfi_dcid = vaf->vaf_dcid,
+		.vfi_vlan = vlan
+	};
 
 	if (kind != VARPD_QTYPE_ETHERNET) {
 		libvarpd_plugin_arp_reply(vah, VARPD_LOOKUP_DROP);
@@ -1145,56 +1499,23 @@ varpd_files_proxy_arp(void *arg, varpd_arp_handle_t *vah, int kind,
 
 	ip = (const struct sockaddr_in *)sock;
 	ip6 = (const struct sockaddr_in6 *)sock;
-	for (pair = nvlist_next_nvpair(vaf->vaf_nvl, NULL); pair != NULL;
-	    pair = nvlist_next_nvpair(vaf->vaf_nvl, pair)) {
-		char *mac, *ipstr;
-		nvlist_t *data;
-		struct in_addr ia;
-		struct in6_addr ia6;
-		struct ether_addr ether, *e;
-		e = &ether;
-
-		if (nvpair_type(pair) != DATA_TYPE_NVLIST)
-			continue;
-
-		mac = nvpair_name(pair);
-		if (nvpair_value_nvlist(pair, &data) != 0)
-			continue;
 
+	if (sock->sa_family == AF_INET) {
+		IN6_IPADDR_TO_V4MAPPED(ip->sin_addr.s_addr, &lookup.vfi_ip);
+		ifp = avl_find(&vaf->vaf_ips, &lookup, NULL);
+	} else {
+		bcopy(&ip6->sin6_addr, &lookup.vfi_llocalip,
+		    sizeof (struct in6_addr));
+		ifp = avl_find(&vaf->vaf_ndp, &lookup, NULL);
+	}
 
-		if (sock->sa_family == AF_INET) {
-			if (nvlist_lookup_string(data, "arp", &ipstr) != 0)
-				continue;
-
-			if (inet_pton(AF_INET, ipstr, &ia) != 1)
-				continue;
-
-			if (bcmp(&ia, &ip->sin_addr,
-			    sizeof (struct in_addr)) != 0)
-				continue;
-		} else {
-			if (nvlist_lookup_string(data, "ndp", &ipstr) != 0)
-				continue;
-
-			if (inet_pton(AF_INET6, ipstr, &ia6) != 1)
-				continue;
-
-			if (bcmp(&ia6, &ip6->sin6_addr,
-			    sizeof (struct in6_addr)) != 0)
-				continue;
-		}
-
-		if (ether_aton_r(mac, e) == NULL) {
-			libvarpd_plugin_arp_reply(vah, VARPD_LOOKUP_DROP);
-			return;
-		}
-
-		bcopy(e, out, ETHERADDRL);
-		libvarpd_plugin_arp_reply(vah, VARPD_LOOKUP_OK);
+	if (ifp == NULL) {
+		libvarpd_plugin_arp_reply(vah, VARPD_LOOKUP_DROP);
 		return;
 	}
 
-	libvarpd_plugin_arp_reply(vah, VARPD_LOOKUP_DROP);
+	bcopy(ifp->vfi_mac, out, ETHERADDRL);
+	libvarpd_plugin_arp_reply(vah, VARPD_LOOKUP_OK);
 }
 
 static void
@@ -1202,39 +1523,28 @@ varpd_files_proxy_dhcp(void *arg, varpd_dhcp_handle_t *vdh, int type,
     const overlay_targ_lookup_t *otl, uint8_t *out)
 {
 	varpd_files_t *vaf = arg;
-	nvlist_t *nvl;
-	char macstr[ETHERADDRSTRL], *mac;
-	struct ether_addr a, *addr;
+	varpd_files_if_t *ifp = NULL;
+	varpd_files_if_t lookup = {
+		.vfi_dcid = vaf->vaf_dcid,
+		.vfi_mac = *otl->otl_addru.otlu_l2.otl2_srcaddr
+	};
 
-	addr = &a;
 	if (type != VARPD_QTYPE_ETHERNET) {
 		libvarpd_plugin_dhcp_reply(vdh, VARPD_LOOKUP_DROP);
 		return;
 	}
 
-	if (ether_ntoa_r(
-	    (struct ether_addr *)otl->otl_addru.otlu_l2.otl2_srcaddr,
-	    macstr) == NULL) {
+	if ((ifp = avl_find(&vaf->vaf_macs, &lookup, NULL)) == NULL) {
 		libvarpd_plugin_dhcp_reply(vdh, VARPD_LOOKUP_DROP);
 		return;
 	}
 
-	if (nvlist_lookup_nvlist(vaf->vaf_nvl, macstr, &nvl) != 0) {
+	if (!ifp->vfi_has_dhcp) {
 		libvarpd_plugin_dhcp_reply(vdh, VARPD_LOOKUP_DROP);
 		return;
 	}
 
-	if (nvlist_lookup_string(nvl, "dhcp-proxy", &mac) != 0) {
-		libvarpd_plugin_dhcp_reply(vdh, VARPD_LOOKUP_DROP);
-		return;
-	}
-
-	if (ether_aton_r(mac, addr) == NULL) {
-		libvarpd_plugin_dhcp_reply(vdh, VARPD_LOOKUP_DROP);
-		return;
-	}
-
-	bcopy(addr, out, ETHERADDRL);
+	bcopy(ifp->vfi_dhcp, out, ETHERADDRL);
 	libvarpd_plugin_dhcp_reply(vdh, VARPD_LOOKUP_OK);
 }
 
@@ -1256,6 +1566,27 @@ static const varpd_plugin_ops_t varpd_files_ops = {
 	varpd_files_proxy_dhcp
 };
 
+static int
+files_bunyan_init(void)
+{
+	int ret;
+
+	if ((ret = bunyan_init("files", &files_bunyan)) != 0)
+		return (ret);
+	ret = bunyan_stream_add(files_bunyan, "stderr", BUNYAN_L_INFO,
+	    bunyan_stream_fd, (void *)STDERR_FILENO);
+	if (ret != 0)
+		bunyan_fini(files_bunyan);
+	return (ret);
+}
+
+static void
+files_bunyan_fini(void)
+{
+	if (files_bunyan != NULL)
+		bunyan_fini(files_bunyan);
+}
+
 #pragma init(varpd_files_init)
 static void
 varpd_files_init(void)
@@ -1263,9 +1594,14 @@ varpd_files_init(void)
 	int err;
 	varpd_plugin_register_t *vpr;
 
+	if (files_bunyan_init() != 0)
+		return;
+
 	vpr = libvarpd_plugin_alloc(VARPD_CURRENT_VERSION, &err);
-	if (vpr == NULL)
+	if (vpr == NULL) {
+		files_bunyan_fini();
 		return;
+	}
 
 	vpr->vpr_mode = OVERLAY_TARGET_DYNAMIC;
 	vpr->vpr_name = "files";
diff --git a/usr/src/lib/varpd/libvarpd/Makefile b/usr/src/lib/varpd/libvarpd/Makefile
index 2a4f8f070c..7fb91078e3 100644
--- a/usr/src/lib/varpd/libvarpd/Makefile
+++ b/usr/src/lib/varpd/libvarpd/Makefile
@@ -29,7 +29,8 @@ TYPELIST = \
 	varpd_persist_header_t \
 	overlay_targ_cache_entry_t \
 	overlay_targ_cache_t \
-	overlay_targ_cache_iter_t
+	overlay_targ_cache_iter_t \
+	overlay_targ_resp_t
 
 all :=		TARGET = all
 clean :=	TARGET = clean
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_arp.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_arp.c
index 5e0b66a4be..a32889e8a2 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_arp.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_arp.c
@@ -43,7 +43,7 @@ typedef struct varpd_arp_query {
 	varpd_query_handle_t		*vaq_query;
 	const overlay_targ_lookup_t	*vaq_otl;
 	ip6_t				*vaq_ip6;
-	nd_neighbor_solicit_t 		*vaq_ns;
+	nd_neighbor_solicit_t		*vaq_ns;
 } varpd_arp_query_t;
 
 typedef struct varpd_dhcp_query {
@@ -151,7 +151,7 @@ libvarpd_plugin_proxy_arp(varpd_provider_handle_t *hdl,
 
 	inst->vri_plugin->vpp_ops->vpo_arp(inst->vri_private,
 	    (varpd_arp_handle_t *)vaq, VARPD_QTYPE_ETHERNET,
-	    (struct sockaddr *)ip, vaq->vaq_lookup);
+	    (struct sockaddr *)ip, otl->otl_vlan, vaq->vaq_lookup);
 }
 
 static void
@@ -388,7 +388,7 @@ libvarpd_plugin_proxy_ndp(varpd_provider_handle_t *hdl,
 	vaq->vaq_ip6 = v6hdr;
 	inst->vri_plugin->vpp_ops->vpo_arp(inst->vri_private,
 	    (varpd_arp_handle_t *)vaq,  VARPD_QTYPE_ETHERNET,
-	    (struct sockaddr *)s6, vaq->vaq_lookup);
+	    (struct sockaddr *)s6, otl->otl_vlan, vaq->vaq_lookup);
 }
 
 static void
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_client.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_client.c
index b0fa907386..f57ff106d1 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_client.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_client.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -476,7 +476,7 @@ libvarpd_c_instance_cache_flush(varpd_client_handle_t *chp, uint64_t cid)
 
 int
 libvarpd_c_instance_cache_delete(varpd_client_handle_t *chp, uint64_t cid,
-    const struct ether_addr *key)
+    uint32_t dcid, const struct ether_addr *key)
 {
 	int ret;
 	varpd_client_arg_t carg;
@@ -489,6 +489,7 @@ libvarpd_c_instance_cache_delete(varpd_client_handle_t *chp, uint64_t cid,
 	carg.vca_command = VARPD_CLIENT_CACHE_DELETE;
 	carg.vca_errno = 0;
 	vctcap->vtca_id = cid;
+	vctcap->vtca_dcid = dcid;
 	bcopy(key, vctcap->vtca_key, ETHERADDRL);
 
 	ret = libvarpd_c_door_call(client, &carg, 0);
@@ -532,7 +533,8 @@ libvarpd_c_instance_cache_get(varpd_client_handle_t *chp, uint64_t cid,
 
 int
 libvarpd_c_instance_cache_set(varpd_client_handle_t *chp, uint64_t cid,
-    const struct ether_addr *key, const varpd_client_cache_entry_t *entry)
+    uint32_t dcid, const struct ether_addr *key,
+    const varpd_client_cache_entry_t *entry)
 {
 	int ret;
 	varpd_client_arg_t carg;
@@ -545,6 +547,7 @@ libvarpd_c_instance_cache_set(varpd_client_handle_t *chp, uint64_t cid,
 	carg.vca_command = VARPD_CLIENT_CACHE_SET;
 	carg.vca_errno = 0;
 	vctcap->vtca_id = cid;
+	vctcap->vtca_dcid = dcid;
 	bcopy(key, vctcap->vtca_key, ETHERADDRL);
 	bcopy(entry, &vctcap->vtca_entry, sizeof (varpd_client_cache_entry_t));
 
@@ -604,14 +607,17 @@ libvarpd_c_instance_cache_walk(varpd_client_handle_t *chp, uint64_t cid,
 
 		for (i = 0; i < vctwap->vtcw_count; i++) {
 			varpd_client_cache_entry_t ent;
+			overlay_targ_cache_entry_t *otce;
 
-			ent.vcp_flags = vctwap->vtcw_ents[i].otce_flags;
-			bcopy(vctwap->vtcw_ents[i].otce_dest.otp_mac,
-			    &ent.vcp_mac, ETHERADDRL);
-			ent.vcp_ip = vctwap->vtcw_ents[i].otce_dest.otp_ip;
-			ent.vcp_port = vctwap->vtcw_ents[i].otce_dest.otp_port;
+			otce = &vctwap->vtcw_ents[i];
+
+			ent.vcp_flags = otce->otce_flags;
+			bcopy(otce->otce_dest.otp_mac, &ent.vcp_mac,
+			    ETHERADDRL);
+			ent.vcp_ip = otce->otce_dest.otp_ip;
+			ent.vcp_port = otce->otce_dest.otp_port;
 			ret = func(chp, cid,
-			    (struct ether_addr *)vctwap->vtcw_ents[i].otce_mac,
+			    (struct ether_addr *)otce->otce_mac.otm_mac,
 			    &ent, arg);
 			if (ret != 0) {
 				ret = 0;
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_client.h b/usr/src/lib/varpd/libvarpd/common/libvarpd_client.h
index 459711b385..335385b262 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_client.h
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_client.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2015 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 #ifndef _LIBVARPD_CLIENT_H
@@ -73,11 +73,11 @@ extern int libvarpd_c_instance_target_mode(varpd_client_handle_t *, uint64_t,
     uint_t *, uint_t *);
 extern int libvarpd_c_instance_cache_flush(varpd_client_handle_t *, uint64_t);
 extern int libvarpd_c_instance_cache_delete(varpd_client_handle_t *, uint64_t,
-    const struct ether_addr *);
+    uint32_t, const struct ether_addr *);
 extern int libvarpd_c_instance_cache_get(varpd_client_handle_t *, uint64_t,
     const struct ether_addr *, varpd_client_cache_entry_t *);
 extern int libvarpd_c_instance_cache_set(varpd_client_handle_t *, uint64_t,
-    const struct ether_addr *, const varpd_client_cache_entry_t *);
+    uint32_t, const struct ether_addr *, const varpd_client_cache_entry_t *);
 
 typedef int (*varpd_client_cache_f)(varpd_client_handle_t *, uint64_t,
     const struct ether_addr *, const varpd_client_cache_entry_t *, void *);
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_door.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_door.c
index f684e031a8..d58445d1b7 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_door.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_door.c
@@ -288,7 +288,7 @@ libvarpd_door_f_delete(varpd_impl_t *vip, varpd_client_arg_t *vcap,
 	if (ihp == NULL)
 		return (ENOENT);
 	return (libvarpd_overlay_cache_delete((varpd_instance_t *)ihp,
-	    vtcap->vtca_key));
+	    vtcap->vtca_dcid, vtcap->vtca_key));
 }
 
 /* ARGSUSED */
@@ -321,7 +321,7 @@ libvarpd_door_f_set(varpd_impl_t *vip, varpd_client_arg_t *vcap,
 		return (ENOENT);
 
 	return (libvarpd_overlay_cache_set((varpd_instance_t *)ihp,
-	    vtcap->vtca_key, &vtcap->vtca_entry));
+	    vtcap->vtca_dcid, vtcap->vtca_key, &vtcap->vtca_entry));
 }
 
 /* ARGSUSED */
@@ -337,7 +337,7 @@ libvarpd_door_f_walk(varpd_impl_t *vip, varpd_client_arg_t *vcap,
 		return (ENOENT);
 
 	return (libvarpd_overlay_cache_walk_fill((varpd_instance_t *)ihp,
-	    &vctwp->vtcw_marker, &vctwp->vtcw_count, vctwp->vtcw_ents));
+	    vctwp->vtcw_marker, &vctwp->vtcw_count, vctwp->vtcw_ents));
 }
 
 static libvarpd_door_f *libvarpd_door_table[] = {
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h b/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h
index 01fe6908ba..594cf45913 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_impl.h
@@ -100,7 +100,7 @@ typedef struct varpd_client_instance_arg {
 
 typedef struct varpd_client_nprops_arg {
 	uint64_t	vcna_id;
-	uint_t		vcna_nprops;
+	uint_t		vcna_nprops __aligned(8);
 } varpd_client_nprops_arg_t;
 
 typedef struct varpd_client_propinfo_arg {
@@ -112,7 +112,7 @@ typedef struct varpd_client_propinfo_arg {
 	uint32_t	vcfa_psize;
 	char		vcfa_name[LIBVARPD_PROP_NAMELEN];
 	uint8_t		vcfa_default[LIBVARPD_PROP_SIZEMAX];
-	uint8_t		vcfa_poss[LIBVARPD_PROP_SIZEMAX];
+	uint8_t		vcfa_poss[LIBVARPD_PROP_SIZEMAX] __aligned(8);
 } varpd_client_propinfo_arg_t;
 
 typedef struct varpd_client_prop_arg {
@@ -136,6 +136,7 @@ typedef struct varpd_client_target_mode_arg {
 
 typedef struct varpd_client_target_cache_arg {
 	uint64_t	vtca_id;
+	uint32_t	vtca_dcid;
 	uint8_t		vtca_key[ETHERADDRL];
 	uint8_t		vtca_pad[2];
 	varpd_client_cache_entry_t vtca_entry;
@@ -143,7 +144,7 @@ typedef struct varpd_client_target_cache_arg {
 
 typedef struct varpd_client_target_walk_arg {
 	uint64_t	vtcw_id;
-	uint64_t	vtcw_marker;
+	uint64_t	vtcw_marker[2];
 	uint64_t	vtcw_count;
 	overlay_targ_cache_entry_t vtcw_ents[];
 } varpd_client_target_walk_arg_t;
@@ -227,12 +228,12 @@ typedef int (*libvarpd_overlay_iter_f)(varpd_impl_t *, datalink_id_t, void *);
 extern int libvarpd_overlay_iter(varpd_impl_t *, libvarpd_overlay_iter_f,
     void *);
 extern int libvarpd_overlay_cache_flush(varpd_instance_t *);
-extern int libvarpd_overlay_cache_delete(varpd_instance_t *, const uint8_t *);
-extern int libvarpd_overlay_cache_delete(varpd_instance_t *, const uint8_t *);
+extern int libvarpd_overlay_cache_delete(varpd_instance_t *, uint32_t,
+    const uint8_t *);
 extern int libvarpd_overlay_cache_get(varpd_instance_t *, const uint8_t *,
     varpd_client_cache_entry_t *);
-extern int libvarpd_overlay_cache_set(varpd_instance_t *, const uint8_t *,
-    const varpd_client_cache_entry_t *);
+extern int libvarpd_overlay_cache_set(varpd_instance_t *, uint32_t,
+    const uint8_t *, const varpd_client_cache_entry_t *);
 extern int libvarpd_overlay_cache_walk_fill(varpd_instance_t *, uint64_t *,
     uint64_t *, overlay_targ_cache_entry_t *);
 
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c b/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
index 060559124e..f557f4cbc6 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_overlay.c
@@ -255,6 +255,7 @@ libvarpd_overlay_lookup_handle(varpd_impl_t *vip)
 	vqp = umem_cache_alloc(vip->vdi_qcache, UMEM_DEFAULT);
 	otl = &vqp->vq_lookup;
 	otr = &vqp->vq_response;
+
 	/*
 	 * abort doesn't really help here that much, maybe we can instead try
 	 * and for a reap or something?
@@ -284,7 +285,7 @@ libvarpd_overlay_lookup_handle(varpd_impl_t *vip)
 
 	inst->vri_plugin->vpp_ops->vpo_lookup(inst->vri_private,
 	    (varpd_query_handle_t *)vqp, otl, &otr->otr_answer,
-	    &otr->otr_route);
+	    &otr->otr_route, &otr->otr_mac);
 }
 
 void
@@ -391,7 +392,8 @@ libvarpd_overlay_cache_flush(varpd_instance_t *inst)
 }
 
 int
-libvarpd_overlay_cache_delete(varpd_instance_t *inst, const uint8_t *key)
+libvarpd_overlay_cache_delete(varpd_instance_t *inst, uint32_t dcid,
+    const uint8_t *key)
 {
 	int ret;
 	overlay_targ_cache_t cache;
@@ -399,7 +401,8 @@ libvarpd_overlay_cache_delete(varpd_instance_t *inst, const uint8_t *key)
 
 	bzero(&cache, sizeof (overlay_targ_cache_t));
 	cache.otc_linkid = inst->vri_linkid;
-	bcopy(key, cache.otc_entry.otce_mac, ETHERADDRL);
+	cache.otc_entry.otce_mac.otm_dcid = dcid;
+	bcopy(key, cache.otc_entry.otce_mac.otm_mac, ETHERADDRL);
 
 	ret = ioctl(vip->vdi_overlayfd, OVERLAY_TARG_CACHE_REMOVE, &cache);
 	if (ret != 0 && errno == EFAULT)
@@ -416,12 +419,11 @@ libvarpd_overlay_cache_get(varpd_instance_t *inst, const uint8_t *key,
     varpd_client_cache_entry_t *entry)
 {
 	int ret;
-	overlay_targ_cache_t cache;
+	overlay_targ_cache_t cache = { 0 };
 	varpd_impl_t *vip = inst->vri_impl;
 
-	bzero(&cache, sizeof (overlay_targ_cache_t));
 	cache.otc_linkid = inst->vri_linkid;
-	bcopy(key, cache.otc_entry.otce_mac, ETHERADDRL);
+	bcopy(key, cache.otc_entry.otce_mac.otm_mac, ETHERADDRL);
 
 	ret = ioctl(vip->vdi_overlayfd, OVERLAY_TARG_CACHE_GET, &cache);
 	if (ret != 0 && errno == EFAULT)
@@ -438,16 +440,16 @@ libvarpd_overlay_cache_get(varpd_instance_t *inst, const uint8_t *key,
 }
 
 int
-libvarpd_overlay_cache_set(varpd_instance_t *inst, const uint8_t *key,
-    const varpd_client_cache_entry_t *entry)
+libvarpd_overlay_cache_set(varpd_instance_t *inst, uint32_t dcid,
+    const uint8_t *key, const varpd_client_cache_entry_t *entry)
 {
 	int ret;
-	overlay_targ_cache_t cache;
+	overlay_targ_cache_t cache = { 0 };
 	varpd_impl_t *vip = inst->vri_impl;
 
-	bzero(&cache, sizeof (overlay_targ_cache_t));
 	cache.otc_linkid = inst->vri_linkid;
-	bcopy(key, cache.otc_entry.otce_mac, ETHERADDRL);
+	cache.otc_entry.otce_mac.otm_dcid = dcid;
+	bcopy(key, cache.otc_entry.otce_mac.otm_mac, ETHERADDRL);
 	bcopy(&entry->vcp_mac, cache.otc_entry.otce_dest.otp_mac, ETHERADDRL);
 	cache.otc_entry.otce_flags = entry->vcp_flags;
 	cache.otc_entry.otce_dest.otp_ip = entry->vcp_ip;
@@ -481,7 +483,8 @@ libvarpd_overlay_cache_walk_fill(varpd_instance_t *inst, uint64_t *markerp,
 		return (ENOMEM);
 
 	iter->otci_linkid = inst->vri_linkid;
-	iter->otci_marker = *markerp;
+	iter->otci_marker[0] = markerp[0];
+	iter->otci_marker[1] = markerp[1];
 	iter->otci_count = *countp;
 	ret = ioctl(vip->vdi_overlayfd, OVERLAY_TARG_CACHE_ITER, iter);
 	if (ret != 0 && errno == EFAULT)
@@ -491,7 +494,8 @@ libvarpd_overlay_cache_walk_fill(varpd_instance_t *inst, uint64_t *markerp,
 		goto out;
 	}
 
-	*markerp = iter->otci_marker;
+	markerp[0] = iter->otci_marker[0];
+	markerp[1] = iter->otci_marker[1];
 	*countp = iter->otci_count;
 	bcopy(iter->otci_ents, ents,
 	    *countp * sizeof (overlay_targ_cache_entry_t));
@@ -525,18 +529,18 @@ libvarpd_inject_varp(varpd_provider_handle_t *vph, const uint8_t *mac,
     const overlay_target_point_t *otp)
 {
 	int ret;
-	overlay_targ_cache_t otc;
+	overlay_targ_cache_t otc = { 0 };
 	varpd_instance_t *inst = (varpd_instance_t *)vph;
 	varpd_impl_t *vip = inst->vri_impl;
 
 	if (otp == NULL) {
-		(void) libvarpd_overlay_cache_delete(inst, mac);
+		(void) libvarpd_overlay_cache_delete(inst, 0, mac);
 		return;
 	}
 
 	otc.otc_linkid = inst->vri_linkid;
 	otc.otc_entry.otce_flags = 0;
-	bcopy(mac, otc.otc_entry.otce_mac, ETHERADDRL);
+	bcopy(mac, otc.otc_entry.otce_mac.otm_mac, ETHERADDRL);
 	bcopy(otp, &otc.otc_entry.otce_dest, sizeof (overlay_target_point_t));
 
 	ret = ioctl(vip->vdi_overlayfd, OVERLAY_TARG_CACHE_SET, &otc);
diff --git a/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h b/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h
index 93749683df..78ea673192 100644
--- a/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h
+++ b/usr/src/lib/varpd/libvarpd/common/libvarpd_provider.h
@@ -316,11 +316,11 @@ typedef void (*varpd_plugin_destroy_f)(void *);
 typedef int (*varpd_plugin_default_f)(void *, overlay_target_point_t *);
 typedef void (*varpd_plugin_lookup_f)(void *, varpd_query_handle_t *,
     const overlay_targ_lookup_t *, overlay_target_point_t *,
-    overlay_target_route_t *);
+    overlay_target_route_t *, overlay_target_mac_t *);
 
 #define	VARPD_QTYPE_ETHERNET	0x0
 typedef void (*varpd_plugin_arp_f)(void *, varpd_arp_handle_t *, int,
-    const struct sockaddr *, uint8_t *);
+    const struct sockaddr *, uint16_t, uint8_t *);
 typedef void (*varpd_plugin_dhcp_f)(void *, varpd_dhcp_handle_t *, int,
     const overlay_targ_lookup_t *, uint8_t *);
 
diff --git a/usr/src/lib/varpd/svp/common/libvarpd_svp.c b/usr/src/lib/varpd/svp/common/libvarpd_svp.c
index efa209734b..a70a72dbc3 100644
--- a/usr/src/lib/varpd/svp/common/libvarpd_svp.c
+++ b/usr/src/lib/varpd/svp/common/libvarpd_svp.c
@@ -379,6 +379,7 @@ typedef struct svp_lookup {
 			varpd_query_handle_t	*svl_handle;
 			overlay_target_point_t	*svl_point;
 			overlay_target_route_t	*svl_route;
+			overlay_target_mac_t	*svl_mac;
 		} svl_route;
 	} svl_u;
 	svp_query_t				svl_query;
@@ -536,6 +537,7 @@ svp_route_lookup_cb(svp_t *svp, svp_status_t status, uint32_t dcid,
 	svp_lookup_t *svl = arg;
 	overlay_target_point_t *otp;
 	overlay_target_route_t *otr;
+	overlay_target_mac_t *otm;
 
 	if (status != SVP_S_OK) {
 		libvarpd_plugin_query_reply(svl->svl_u.svl_route.svl_handle,
@@ -545,7 +547,6 @@ svp_route_lookup_cb(svp_t *svp, svp_status_t status, uint32_t dcid,
 	}
 
 	otp = svl->svl_u.svl_route.svl_point;
-	bcopy(dstmac, otp->otp_mac, ETHERADDRL);
 	bcopy(ul3_addr, &otp->otp_ip, sizeof (struct in6_addr));
 	otp->otp_port = ul3_port;
 
@@ -553,9 +554,10 @@ svp_route_lookup_cb(svp_t *svp, svp_status_t status, uint32_t dcid,
 	otr->otr_vnet = vnetid;
 	otr->otr_vlan = vlan;
 	bcopy(srcmac, otr->otr_srcmac, ETHERADDRL);
-	otr->otr_dcid = dcid;
-	otr->otr_src_prefixlen = srcpfx;
-	otr->otr_dst_prefixlen = dstpfx;
+
+	otm = svl->svl_u.svl_route.svl_mac;
+	otm->otm_dcid = dcid;
+	bcopy(dstmac, otm->otm_mac, ETHERADDRL);
 
 	libvarpd_plugin_query_reply(svl->svl_u.svl_route.svl_handle,
 	    VARPD_LOOKUP_OK);
@@ -661,7 +663,7 @@ varpd_svp_destroy(void *arg)
 static void
 varpd_svp_lookup_l3(svp_t *svp, varpd_query_handle_t *vqh,
     const overlay_targ_lookup_t *otl, overlay_target_point_t *otp,
-    overlay_target_route_t *otr)
+    overlay_target_route_t *otr, overlay_target_mac_t *otm)
 {
 	svp_lookup_t *slp;
 	uint32_t type;
@@ -704,6 +706,7 @@ varpd_svp_lookup_l3(svp_t *svp, varpd_query_handle_t *vqh,
 	slp->svl_u.svl_route.svl_handle = vqh;
 	slp->svl_u.svl_route.svl_point = otp;
 	slp->svl_u.svl_route.svl_route = otr;
+	slp->svl_u.svl_route.svl_mac = otm;
 
 	svp_remote_route_lookup(svp, &slp->svl_query, src, dst,
 	    otl->otl_vnetid, (uint16_t)otl->otl_vlan, slp);
@@ -712,7 +715,7 @@ varpd_svp_lookup_l3(svp_t *svp, varpd_query_handle_t *vqh,
 static void
 varpd_svp_lookup(void *arg, varpd_query_handle_t *vqh,
     const overlay_targ_lookup_t *otl, overlay_target_point_t *otp,
-    overlay_target_route_t *otr)
+    overlay_target_route_t *otr, overlay_target_mac_t *otm)
 {
 	svp_lookup_t *slp;
 	svp_t *svp = arg;
@@ -721,7 +724,7 @@ varpd_svp_lookup(void *arg, varpd_query_handle_t *vqh,
 	 * Shuffle off L3 lookups to their own codepath.
 	 */
 	if (otl->otl_l3req) {
-		varpd_svp_lookup_l3(svp, vqh, otl, otp, otr);
+		varpd_svp_lookup_l3(svp, vqh, otl, otp, otr, otm);
 		return;
 	}
 	/*
@@ -1265,7 +1268,7 @@ varpd_svp_restore(nvlist_t *nvp, varpd_provider_handle_t *hdl,
 
 static void
 varpd_svp_arp(void *arg, varpd_arp_handle_t *vah, int type,
-    const struct sockaddr *sock, uint8_t *out)
+    const struct sockaddr *sock, uint16_t vlan __unused, uint8_t *out)
 {
 	svp_t *svp = arg;
 	svp_lookup_t *svl;
diff --git a/usr/src/uts/common/Makefile.files b/usr/src/uts/common/Makefile.files
index ad668b9e71..73031aafb7 100644
--- a/usr/src/uts/common/Makefile.files
+++ b/usr/src/uts/common/Makefile.files
@@ -25,7 +25,7 @@
 # Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
 # Copyright 2016 Garrett D'Amore <garrett@damore.org>
-# Copyright 2017 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 # Copyright 2016 OmniTI Computer Consulting, Inc.  All rights reserved.
 # Copyright 2016 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
 #
@@ -697,7 +697,7 @@ NET80211_OBJS += net80211.o net80211_proto.o net80211_input.o \
 VNIC_OBJS +=	vnic_ctl.o vnic_dev.o
 
 OVERLAY_OBJS +=	overlay.o overlay_fm.o overlay_mux.o overlay_plugin.o \
-		overlay_prop.o overlay_target.o
+		overlay_prop.o overlay_target.o sarc.o
 
 OVERLAY_VXLAN_OBJS +=	overlay_vxlan.o
 
diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index b605d36b8c..7924232441 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -20,6 +20,8 @@
  * uts/common/io/overlay/overlay.c
  */
 
+#include <inet/ip.h>
+#include <inet/ip6.h>
 #include <sys/types.h>
 #include <sys/ethernet.h>
 #include <sys/kmem.h>
@@ -51,6 +53,13 @@
  */
 #define	OVERLAY_HSIZE	823
 
+/*
+ * The default size of each target cache.  This is also a complete strawman
+ * whose value could change as we gain better operational experience with
+ * overlay routing.
+ */
+#define	OVERLAY_CACHE_SIZE	512
+
 /*
  * We use this data structure to keep track of what requests have been actively
  * allocated to a given instance so we know what to put back on the pending
@@ -141,20 +150,54 @@ overlay_entry_cache_destructor(void *buf, void *arg)
 	mutex_destroy(&ote->ote_lock);
 }
 
-/* TODO: we will need to modify these to hash/cmp DCID + MAC */
-
 static uint64_t
 overlay_mac_hash(const void *v)
 {
+	const overlay_target_mac_t *m = v;
+
 	uint32_t crc;
-	CRC32(crc, v, ETHERADDRL, -1U, crc32_table);
+	CRC32(crc, m->otm_mac, ETHERADDRL, -1U, crc32_table);
+	CRC32(crc, &m->otm_dcid, sizeof (uint32_t), crc, crc32_table);
 	return (crc);
 }
 
 static int
 overlay_mac_cmp(const void *a, const void *b)
 {
-	return (bcmp(a, b, ETHERADDRL));
+	const overlay_target_mac_t *l = a;
+	const overlay_target_mac_t *r = b;
+
+	if (l->otm_dcid != r->otm_dcid)
+		return (1);
+	return (bcmp(l->otm_mac, r->otm_mac, ETHERADDRL) != 0);
+}
+
+static uint64_t
+overlay_ip_hash(const void *v)
+{
+	const overlay_target_vl3_t *vl3 = v;
+
+	uint32_t crc;
+	CRC32(crc, &vl3->otvl3_src, sizeof (vl3->otvl3_src), -1U, crc32_table);
+	CRC32(crc, &vl3->otvl3_dst, sizeof (vl3->otvl3_dst), crc, crc32_table);
+	CRC32(crc, &vl3->otvl3_src_vlan, sizeof (vl3->otvl3_src_vlan), crc,
+	    crc32_table);
+	return (crc);
+}
+
+static int
+overlay_ip_cmp(const void *a, const void *b)
+{
+	const overlay_target_vl3_t *l = a;
+	const overlay_target_vl3_t *r = b;
+
+	if (l->otvl3_src_vlan != r->otvl3_src_vlan)
+		return (1);
+	if (!IN6_ARE_ADDR_EQUAL(&l->otvl3_src, &r->otvl3_src))
+		return (1);
+	if (!IN6_ARE_ADDR_EQUAL(&l->otvl3_dst, &r->otvl3_dst))
+		return (1);
+	return (0);
 }
 
 /* ARGSUSED */
@@ -164,7 +207,7 @@ overlay_target_entry_dtor(void *arg)
 	overlay_target_entry_t *ote = arg;
 
 	ote->ote_flags = 0;
-	bzero(ote->ote_addr, ETHERADDRL);
+	bzero(&ote->ote_u, sizeof (ote->ote_u));
 	ote->ote_ott = NULL;
 	ote->ote_odd = NULL;
 	freemsgchain(ote->ote_chead);
@@ -177,18 +220,46 @@ overlay_target_entry_dtor(void *arg)
 static int
 overlay_mac_avl(const void *a, const void *b)
 {
+	const overlay_target_entry_t *le = a;
+	const overlay_target_entry_t *re = b;
+	const overlay_target_mac_t *lm = &le->ote_u.ote_vl2.otvl2_mac;
+	const overlay_target_mac_t *rm = &re->ote_u.ote_vl2.otvl2_mac;
 	int i;
-	const overlay_target_entry_t *l, *r;
-	l = a;
-	r = b;
+
+	/* Order by DCID, then MAC */
+	if (lm->otm_dcid < rm->otm_dcid)
+		return (-1);
+	if (lm->otm_dcid > rm->otm_dcid)
+		return (1);
 
 	for (i = 0; i < ETHERADDRL; i++) {
-		if (l->ote_addr[i] > r->ote_addr[i])
+		if (lm->otm_mac[i] > rm->otm_mac[i])
 			return (1);
-		else if (l->ote_addr[i] < r->ote_addr[i])
+		else if (lm->otm_mac[i] < rm->otm_mac[i])
 			return (-1);
 	}
+	return (0);
+}
+
+static int
+overlay_ip_avl(const void *a, const void *b)
+{
+	const overlay_target_entry_t *l = a;
+	const overlay_target_entry_t *r = b;
+	const overlay_target_vl3_t *l_vl3 = &l->ote_u.ote_vl3;
+	const overlay_target_vl3_t *r_vl3 = &r->ote_u.ote_vl3;
+	int ret;
 
+	if ((ret = memcmp(&l_vl3->otvl3_src, &r_vl3->otvl3_src,
+	    sizeof (l_vl3->otvl3_src))) != 0)
+		return (ret);
+	if ((ret = memcmp(&l_vl3->otvl3_dst, &r_vl3->otvl3_dst,
+	    sizeof (l_vl3->otvl3_dst))) != 0)
+		return (ret);
+	if (l_vl3->otvl3_src_vlan < r_vl3->otvl3_src_vlan)
+		return (-1);
+	if (l_vl3->otvl3_src_vlan > r_vl3->otvl3_src_vlan)
+		return (1);
 	return (0);
 }
 
@@ -235,27 +306,43 @@ overlay_target_free(overlay_dev_t *odd)
 		return;
 
 	if (odd->odd_target->ott_mode == OVERLAY_TARGET_DYNAMIC) {
-		refhash_t *rp = odd->odd_target->ott_u.ott_dyn.ott_dhash;
+		sarc_t *cp = odd->odd_target->ott_u.ott_dyn.ott_dhash;
 		avl_tree_t *ap = &odd->odd_target->ott_u.ott_dyn.ott_tree;
+		sarc_t *cp3 = odd->odd_target->ott_u.ott_dyn.ott_l3dhash;
+		avl_tree_t *ap3 = &odd->odd_target->ott_u.ott_dyn.ott_l3tree;
 		overlay_target_entry_t *ote;
 
-		/* TODO: remove from L3 trees */
+		/*
+		 * Our VL3 AVL tree and hashtable contain the same elements,
+		 * therefore we should just remove it from the tree, but then
+		 * delete the entries when we remove them from the hash table
+		 * (which happens through the sarc dtor).
+		 */
+		while ((ote = avl_first(ap3)) != NULL)
+			avl_remove(ap3, ote);
+		avl_destroy(ap3);
+
+		for (ote = sarc_first(cp3); ote != NULL;
+		    ote = sarc_next(cp3, ote)) {
+			sarc_remove(cp3, ote);
+		}
+		sarc_destroy(cp3);
 
 		/*
 		 * Our AVL tree and hashtable contain the same elements,
 		 * therefore we should just remove it from the tree, but then
 		 * delete the entries when we remove them from the hash table
-		 * (which happens through the refhash dtor).
+		 * (which happens through the sarc dtor).
 		 */
 		while ((ote = avl_first(ap)) != NULL)
 			avl_remove(ap, ote);
 
 		avl_destroy(ap);
-		for (ote = refhash_first(rp); ote != NULL;
-		    ote = refhash_next(rp, ote)) {
-			refhash_remove(rp, ote);
+		for (ote = sarc_first(cp); ote != NULL;
+		    ote = sarc_next(cp, ote)) {
+			sarc_remove(cp, ote);
 		}
-		refhash_destroy(rp);
+		sarc_destroy(cp);
 	}
 
 	ASSERT(odd->odd_target->ott_ocount == 0);
@@ -304,7 +391,359 @@ overlay_target_quiesce(overlay_target_t *ott)
 }
 
 /*
- * This functions assumes that the destination mode is OVERLAY_PLUGIN_D_IP |
+ * Write the VL3 src/dst IP from the packet in mp into src and dst.  If the
+ * addresses are IPv4 addresses, they are written as mapped addresses.
+ */
+static int
+overlay_get_vl3_ips(mblk_t *mp, struct in6_addr *src, struct in6_addr *dst)
+{
+	uint16_t sap;
+
+	if (MBLKL(mp) >= sizeof (struct ether_vlan_header) + sizeof (ip6_t)) {
+		struct ether_vlan_header *eth =
+		    (struct ether_vlan_header *)mp->b_rptr;
+		ipha_t *iphp = (ipha_t *)(eth + 1);
+		ip6_t *ip6hp = (ip6_t *)(eth + 1);
+		sap = ntohs(eth->ether_tpid);
+
+		if (sap == ETHERTYPE_VLAN) {
+			sap = ntohs(eth->ether_type);
+		} else {
+			struct ether_header *e = (struct ether_header *)eth;
+
+			iphp = (ipha_t *)(e + 1);
+			ip6hp = (ip6_t *)(e + 1);
+		}
+
+		switch (sap) {
+		case ETHERTYPE_IP:
+			ASSERT3U(IPH_HDR_VERSION(iphp), ==, IPV4_VERSION);
+			IN6_IPADDR_TO_V4MAPPED(iphp->ipha_src, src);
+			IN6_IPADDR_TO_V4MAPPED(iphp->ipha_dst, dst);
+			break;
+		case ETHERTYPE_IPV6:
+			ASSERT3U(IPH_HDR_VERSION(iphp), ==, IPV6_VERSION);
+			bcopy(&ip6hp->ip6_src, src, sizeof (*src));
+			bcopy(&ip6hp->ip6_dst, dst, sizeof (*dst));
+			break;
+		default:
+			return (EINVAL);
+		}
+
+		return (0);
+	}
+
+#if 1
+	/* Temporary until mblk helpers are integrated */
+	return (EINVAL);
+#else
+	size_t soff, doff;
+	uint32_t v4s, v4d;
+	int i;
+
+	if (!mblk_read_uint16(mp, offsetof(struct ether_header, ether_type),
+	    &sap))
+		return (EINVAL);
+
+	if (sap == ETHERTYPE_VLAN) {
+		if (!mblk_read_uint16(mp,
+		    offsetof(struct ether_vlan_header, ether_type), &sap))
+			return (EINVAL);
+		soff = doff = sizeof (struct ether_vlan_header);
+	} else {
+		soff = doff = sizeof (struct ether_header);
+	}
+
+	switch (sap) {
+	case ETHERTYPE_IP:
+		soff += offsetof(ipha_t, ipha_src);
+		doff += offsetof(ipha_t, ipha_dst);
+
+		if (!mblk_read_uint32(mp, soff, &v4s) ||
+		    !mblk_read_uint32(mp, doff, &v4d))
+			return (EINVAL);
+		IN6_IPADDR_TO_V4MAPPED(&v4s, src);
+		IN6_IPADDR_TO_V4MAPPED(&v4d, dst);
+		break;
+	case ETHERTYPE_IPV6:
+		soff += offsetof(ip6_t, ip6_src);
+		doff += offsetof(ip6_6, ip6_dst);
+
+		for (i = 0; i < 4; i++) {
+			if (!mblk_read_uint32(mp, soff, &src->s6_addr32[i]) ||
+			    !mblk_read_uint32(mp, doff, &dst->s6_addr32[i]))
+				return (EINVAL);
+			soff += sizeof (uint32_t);
+			doff += sizeof (uint32_t);
+		}
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	return (0);
+#endif
+}
+
+static int
+overlay_route(overlay_dev_t *odd, mblk_t *mp,
+    const overlay_target_route_t *route, const overlay_target_mac_t *dst_mac)
+{
+	uint16_t tci;
+
+	if (MBLKL(mp) >= sizeof (struct ether_vlan_header)) {
+		struct ether_vlan_header *evh;
+
+		evh = (struct ether_vlan_header *)mp->b_rptr;
+		tci = ntohs(evh->ether_tci);
+
+		/*
+		 * Today we require all encapsulated frames to be vlan tagged.
+		 * If this is relaxed in the future, we will need to allow for
+		 * insertion and removal of the vlan tag as appropriate here.
+		 */
+		if (ntohs(evh->ether_tpid) != ETHERTYPE_VLAN)
+			return (OVERLAY_TARGET_DROP);
+
+		tci &= ~(VLAN_ID_MASK);
+		tci |= route->otr_vlan;
+		evh->ether_tci = htons(tci);
+		bcopy(dst_mac->otm_mac, &evh->ether_dhost, ETHERADDRL);
+		bcopy(route->otr_srcmac, &evh->ether_shost, ETHERADDRL);
+		return (OVERLAY_TARGET_OK);
+	}
+
+#if 1
+	/* Temporary until mblk helpers are integrated */
+	return (OVERLAY_TARGET_DROP);
+#else
+	size_t off;
+
+	off = offsetof(struct ether_vlan_header, ether_tpid);
+	if (!mblk_read_uint16(mp, off, &tci))
+		return (OVERLAY_TARGET_DROP);
+
+	tci = ntohs(evh->ether_tci);
+	tci &= ~(VLAN_ID_MASK);
+	tci |= route->otr_vlan;
+
+	if (!mblk_write_uint16(mp, off, tci))
+		return (OVERLAY_TARGET_DROP);
+
+	for (int i = 0; i < ETHERADDRL; i++) {
+		if (!mblk_write_uint8(mp, i, dst_msc->otm_mac[i]) ||
+		    !mblk_write_uint8(mp, i + ETHERADDRL, route->otr_srcmac[i]))
+			return (OVERLAY_TARGET_DROP);
+	}
+
+	return (OVERLAY_TARGET_OK);
+#endif
+}
+
+static int
+overlay_target_try_queue(overlay_target_entry_t *entry, mblk_t *mp)
+{
+	size_t mlen = msgsize(mp);
+
+	ASSERT(MUTEX_HELD(&entry->ote_lock));
+
+	if (mlen + entry->ote_mbsize > overlay_ent_size)
+		return (OVERLAY_TARGET_DROP);
+
+	if (entry->ote_ctail != NULL) {
+		ASSERT(entry->ote_ctail->b_next == NULL);
+		entry->ote_ctail->b_next = mp;
+		entry->ote_ctail = mp;
+	} else {
+		entry->ote_chead = mp;
+		entry->ote_ctail = mp;
+	}
+	entry->ote_mbsize += mlen;
+	if ((entry->ote_flags & OVERLAY_ENTRY_F_PENDING) == 0) {
+		entry->ote_flags |= OVERLAY_ENTRY_F_PENDING;
+		overlay_target_queue(entry);
+	}
+	return (OVERLAY_TARGET_ASYNC);
+}
+
+static int
+overlay_route_lookup_vl2(overlay_target_t *ott, overlay_target_entry_t *vl3e,
+    uint64_t *vidp, struct sockaddr_in6 *v6, socklen_t *slenp, mblk_t *mp)
+{
+	overlay_target_entry_t *vl2e;
+	overlay_target_vl2_t *vl2p;
+	int ret;
+
+	ASSERT(MUTEX_HELD(&vl3e->ote_lock));
+
+	mutex_enter(&ott->ott_lock);
+	if ((vl2e = sarc_lookup(ott->ott_u.ott_dyn.ott_dhash,
+	    &vl3e->ote_u.ote_vl3.otvl3_vl2)) != NULL) {
+		sarc_hold(ott->ott_u.ott_dyn.ott_dhash, vl2e);
+	}
+	mutex_exit(&ott->ott_lock);
+
+	if (vl2e == NULL) {
+		vl3e->ote_flags &= ~OVERLAY_ENTRY_F_VALID;
+		return (overlay_target_try_queue(vl3e, mp));
+	}
+
+	mutex_enter(&vl2e->ote_lock);
+	if (vl2e->ote_flags & (OVERLAY_ENTRY_F_DROP | OVERLAY_ENTRY_F_ROUTER)) {
+		mutex_exit(&vl2e->ote_lock);
+
+		mutex_enter(&ott->ott_lock);
+		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2e);
+		mutex_exit(&ott->ott_lock);
+
+		return (OVERLAY_TARGET_DROP);
+	}
+
+	/*
+	 * If the route is missing queue on the VL3 entry so a VL3->UL3
+	 * lookup is done (to get the route data).
+	 */
+	if ((vl2e->ote_flags & OVERLAY_ENTRY_F_HAS_ROUTE) == 0) {
+		mutex_exit(&vl2e->ote_lock);
+
+		mutex_enter(&ott->ott_lock);
+		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2e);
+		mutex_exit(&ott->ott_lock);
+
+		return (overlay_target_try_queue(vl3e, mp));
+	}
+
+	/*
+	 * If the VL2 target point is missing, we try to be a bit (though
+	 * hopefully not too) clever.  We can always queue on the VL3 entry
+	 * which will trigger a VL3->UL3 lookup request (as it is effectively
+	 * a superset of the VL2->UL3 lookup).  However, if we know we already
+	 * have an outstanding VL3->UL3 request, we queue on the VL2 entry and
+	 * avoid doing another redundant lookup.  We can also queue on the VL2
+	 * entry when it is a local (same vnet, same DC) destination -- we
+	 * currently cannot generate VL2->UL3 lookups for remote destinations,
+	 * only same vnet, same DC.  Queueing on the VL2 entry also allows
+	 * instances on the same vlan as the queued VL2 entry to piggy back on
+	 * the lookup request and avoid a redundant lookup.  However if the
+	 * VL2 entry is remote, we have to do a VL3->UL3 lookup.
+	 */
+	if ((vl2e->ote_flags & OVERLAY_ENTRY_F_VALID) == 0) {
+		overlay_target_entry_t *queue_e;
+
+		if ((vl2e->ote_flags & OVERLAY_ENTRY_F_PENDING) == 0 &&
+		    vl2e->ote_u.ote_vl2.otvl2_mac.otm_dcid !=
+		    vl2e->ote_odd->odd_dcid) {
+			queue_e = vl3e;
+		} else {
+			queue_e = vl2e;
+		}
+
+		ret = overlay_target_try_queue(queue_e, mp);
+		mutex_exit(&vl2e->ote_lock);
+
+		mutex_enter(&ott->ott_lock);
+		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2e);
+		mutex_exit(&ott->ott_lock);
+
+		return (ret);
+	}
+
+	ASSERT(vl2e->ote_flags & OVERLAY_ENTRY_F_VALID);
+
+	vl2p = &vl2e->ote_u.ote_vl2;
+
+	*vidp = vl2p->otvl2_route.otr_vnet;
+	bcopy(&vl2p->otvl2_dest.otp_ip, &v6->sin6_addr,
+	    sizeof (struct in6_addr));
+	v6->sin6_port = htons(vl2p->otvl2_dest.otp_port);
+	*slenp = sizeof (struct sockaddr_in6);
+
+	ret = overlay_route(vl2e->ote_odd, mp, &vl2p->otvl2_route,
+	    &vl2p->otvl2_mac);
+	mutex_exit(&vl2e->ote_lock);
+
+	mutex_enter(&ott->ott_lock);
+	sarc_rele(ott->ott_u.ott_dyn.ott_dhash, vl2e);
+	mutex_exit(&ott->ott_lock);
+
+	return (ret);
+}
+
+static int
+overlay_route_lookup(overlay_dev_t *odd, mblk_t *mp, uint16_t vlan,
+    struct sockaddr *sock, socklen_t *slenp, uint64_t *vidp)
+{
+	overlay_target_t *ott = odd->odd_target;
+	overlay_target_entry_t *entry;
+	struct sockaddr_in6 *v6 = (struct sockaddr_in6 *)sock;
+	overlay_target_vl3_t vl3 = { 0 };
+	int ret = OVERLAY_TARGET_DROP;
+
+	/* overlay_target_lookup() should have set this */
+	ASSERT3U(v6->sin6_family, ==, AF_INET6);
+
+	/* We should only be called for dynamic endpoints */
+	ASSERT3U(ott->ott_mode, ==, OVERLAY_TARGET_DYNAMIC);
+
+	vl3.otvl3_src_vlan = vlan;
+	if ((ret = overlay_get_vl3_ips(mp, &vl3.otvl3_src, &vl3.otvl3_dst))
+	    != OVERLAY_TARGET_OK)
+		return (OVERLAY_TARGET_DROP);
+
+	mutex_enter(&ott->ott_lock);
+	entry = sarc_lookup(ott->ott_u.ott_dyn.ott_l3dhash, &vl3);
+	if (entry == NULL) {
+		if ((entry = kmem_cache_alloc(overlay_entry_cache,
+		    KM_NOSLEEP | KM_NORMALPRI)) == NULL) {
+			mutex_exit(&ott->ott_lock);
+			return (OVERLAY_TARGET_DROP);
+		}
+
+		bcopy(&vl3, &entry->ote_u.ote_vl3, sizeof (vl3));
+		entry->ote_flags = OVERLAY_ENTRY_F_VL3;
+
+		entry->ote_chead = entry->ote_ctail = mp;
+		entry->ote_mbsize = msgsize(mp);
+		entry->ote_flags |= OVERLAY_ENTRY_F_PENDING;
+
+		entry->ote_ott = ott;
+		entry->ote_odd = odd;
+
+		sarc_insert(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+		avl_add(&ott->ott_u.ott_dyn.ott_l3tree, entry);
+		mutex_exit(&ott->ott_lock);
+		overlay_target_queue(entry);
+		return (OVERLAY_TARGET_ASYNC);
+	}
+	sarc_hold(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+	mutex_exit(&ott->ott_lock);
+
+	mutex_enter(&entry->ote_lock);
+	ASSERT(entry->ote_flags & OVERLAY_ENTRY_F_VL3);
+
+	if (entry->ote_flags & OVERLAY_ENTRY_F_DROP) {
+		ret = OVERLAY_TARGET_DROP;
+	} else if (entry->ote_flags & OVERLAY_ENTRY_F_ROUTER) {
+		/*
+		 * XXX: A packet with a dst IP of an overlay router.
+		 * Maybe generate an ICMP reply?  For now, we drop.
+		 */
+		ret = OVERLAY_TARGET_DROP;
+	} else if ((entry->ote_flags & OVERLAY_ENTRY_F_VALID) == 0) {
+		ret = overlay_target_try_queue(entry, mp);
+	} else {
+		ret = overlay_route_lookup_vl2(ott, entry, vidp, v6, slenp, mp);
+	}
+	mutex_exit(&entry->ote_lock);
+
+	mutex_enter(&ott->ott_lock);
+	sarc_rele(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+	mutex_exit(&ott->ott_lock);
+	return (ret);
+}
+
+/*
+ * This function assumes that the destination mode is OVERLAY_PLUGIN_D_IP |
  * OVERLAY_PLUGIN_D_PORT. As we don't have an implementation of anything else at
  * this time, say for NVGRE, we drop all packets that match this.
  */
@@ -315,11 +754,13 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 	int ret;
 	struct sockaddr_in6 *v6;
 	overlay_target_t *ott;
-	mac_header_info_t mhi;
 	overlay_target_entry_t *entry;
+	mac_header_info_t mhi;
+	overlay_target_mac_t omac;
 
 	ASSERT(odd->odd_target != NULL);
 
+	/* Default to our local vid, routing may change this if necessary */
 	*vidp = odd->odd_vid;
 
 	/*
@@ -349,80 +790,66 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 
 	ASSERT(ott->ott_mode == OVERLAY_TARGET_DYNAMIC);
 
-	/*
-	 * Note we only want the MAC address here, therefore we won't bother
-	 * using mac_vlan_header_info(). If any caller needs the vlan info at
-	 * this point, this should change to a call to mac_vlan_header_info().
-	 */
-	if (mac_header_info(odd->odd_mh, mp, &mhi) != 0)
+	if (mac_vlan_header_info(odd->odd_mh, mp, &mhi) != 0)
 		return (OVERLAY_TARGET_DROP);
 
+	omac.otm_dcid = odd->odd_dcid;
+	bcopy(mhi.mhi_daddr, omac.otm_mac, ETHERADDRL);
+
 	mutex_enter(&ott->ott_lock);
-	entry = refhash_lookup(ott->ott_u.ott_dyn.ott_dhash,
-	    mhi.mhi_daddr);
+	entry = sarc_lookup(ott->ott_u.ott_dyn.ott_dhash, &omac);
 	if (entry == NULL) {
+		overlay_target_vl2_t *vl2p;
+
 		entry = kmem_cache_alloc(overlay_entry_cache,
 		    KM_NOSLEEP | KM_NORMALPRI);
 		if (entry == NULL) {
 			mutex_exit(&ott->ott_lock);
 			return (OVERLAY_TARGET_DROP);
 		}
-		bcopy(mhi.mhi_daddr, entry->ote_addr, ETHERADDRL);
+
+		vl2p = &entry->ote_u.ote_vl2;
+		bcopy(mhi.mhi_daddr, vl2p->otvl2_mac.otm_mac, ETHERADDRL);
+		vl2p->otvl2_mac.otm_dcid = odd->odd_dcid;
+		vl2p->otvl2_route.otr_vnet = odd->odd_vid;
+		vl2p->otvl2_route.otr_vlan = VLAN_ID(mhi.mhi_tci);
+
 		entry->ote_chead = entry->ote_ctail = mp;
 		entry->ote_mbsize = msgsize(mp);
 		entry->ote_flags |= OVERLAY_ENTRY_F_PENDING;
+
 		entry->ote_ott = ott;
 		entry->ote_odd = odd;
-		refhash_insert(ott->ott_u.ott_dyn.ott_dhash, entry);
+
+		sarc_insert(ott->ott_u.ott_dyn.ott_dhash, entry);
 		avl_add(&ott->ott_u.ott_dyn.ott_tree, entry);
 		mutex_exit(&ott->ott_lock);
 		overlay_target_queue(entry);
 		return (OVERLAY_TARGET_ASYNC);
 	}
-	refhash_hold(ott->ott_u.ott_dyn.ott_dhash, entry);
+	sarc_hold(ott->ott_u.ott_dyn.ott_dhash, entry);
 	mutex_exit(&ott->ott_lock);
 
 	mutex_enter(&entry->ote_lock);
 	if (entry->ote_flags & OVERLAY_ENTRY_F_DROP) {
 		ret = OVERLAY_TARGET_DROP;
 	} else if (entry->ote_flags & OVERLAY_ENTRY_F_ROUTER) {
-		/* TODO: Lookup route info, adjust headers, and set vidp */
-		ret = OVERLAY_TARGET_DROP;
+		ret = overlay_route_lookup(odd, mp, VLAN_ID(mhi.mhi_tci), sock,
+		    slenp, vidp);
 	} else if (entry->ote_flags & OVERLAY_ENTRY_F_VALID) {
-		bcopy(&entry->ote_dest.otp_ip, &v6->sin6_addr,
-		    sizeof (struct in6_addr));
-		v6->sin6_port = htons(entry->ote_dest.otp_port);
+		overlay_target_point_t *otp = &entry->ote_u.ote_vl2.otvl2_dest;
+
+		bcopy(&otp->otp_ip, &v6->sin6_addr, sizeof (struct in6_addr));
+		v6->sin6_port = htons(otp->otp_port);
 		*slenp = sizeof (struct sockaddr_in6);
 		ret = OVERLAY_TARGET_OK;
 	} else {
-		size_t mlen = msgsize(mp);
-
-		if (mlen + entry->ote_mbsize > overlay_ent_size) {
-			ret = OVERLAY_TARGET_DROP;
-		} else {
-			if (entry->ote_ctail != NULL) {
-				ASSERT(entry->ote_ctail->b_next ==
-				    NULL);
-				entry->ote_ctail->b_next = mp;
-				entry->ote_ctail = mp;
-			} else {
-				entry->ote_chead = mp;
-				entry->ote_ctail = mp;
-			}
-			entry->ote_mbsize += mlen;
-			if ((entry->ote_flags &
-			    OVERLAY_ENTRY_F_PENDING) == 0) {
-				entry->ote_flags |=
-				    OVERLAY_ENTRY_F_PENDING;
-				overlay_target_queue(entry);
-			}
-			ret = OVERLAY_TARGET_ASYNC;
-		}
+		ret = overlay_target_try_queue(entry, mp);
 	}
 	mutex_exit(&entry->ote_lock);
 
 	mutex_enter(&ott->ott_lock);
-	refhash_rele(ott->ott_u.ott_dyn.ott_dhash, entry);
+	sarc_rele(ott->ott_u.ott_dyn.ott_dhash, entry);
 	mutex_exit(&ott->ott_lock);
 
 	return (ret);
@@ -453,6 +880,22 @@ overlay_target_info(overlay_target_hdl_t *thdl, void *arg)
 	return (0);
 }
 
+static sarc_ops_t overlay_sarc_l2_ops = {
+	.sao_hash = overlay_mac_hash,
+	.sao_cmp = overlay_mac_cmp,
+	.sao_dtor = overlay_target_entry_dtor,
+	.sao_fetch = sarc_nofetch,
+	.sao_evict = sarc_noevict
+};
+
+static sarc_ops_t overlay_sarc_l3_ops = {
+	.sao_hash = overlay_ip_hash,
+	.sao_cmp = overlay_ip_cmp,
+	.sao_dtor = overlay_target_entry_dtor,
+	.sao_fetch = sarc_nofetch,
+	.sao_evict = sarc_noevict
+};
+
 /* ARGSUSED */
 static int
 overlay_target_associate(overlay_target_hdl_t *thdl, void *arg)
@@ -510,14 +953,40 @@ overlay_target_associate(overlay_target_hdl_t *thdl, void *arg)
 		bcopy(&ota->ota_point, &ott->ott_u.ott_point,
 		    sizeof (overlay_target_point_t));
 	} else {
-		ott->ott_u.ott_dyn.ott_dhash = refhash_create(OVERLAY_HSIZE,
-		    overlay_mac_hash, overlay_mac_cmp,
-		    overlay_target_entry_dtor, sizeof (overlay_target_entry_t),
+		int ret;
+
+		ret = sarc_create(&ott->ott_u.ott_dyn.ott_dhash,
+		    OVERLAY_CACHE_SIZE, OVERLAY_HSIZE, &overlay_sarc_l2_ops,
+		    sizeof (overlay_target_entry_t),
 		    offsetof(overlay_target_entry_t, ote_reflink),
-		    offsetof(overlay_target_entry_t, ote_addr), KM_SLEEP);
+		    offsetof(overlay_target_entry_t, ote_u.ote_vl2.otvl2_mac),
+		    KM_SLEEP);
+		if (ret != 0) {
+			mutex_exit(&odd->odd_lock);
+			kmem_cache_free(overlay_target_cache, ott);
+			overlay_hold_rele(odd);
+			return (ret);
+		}
+
+		ret = sarc_create(&ott->ott_u.ott_dyn.ott_l3dhash,
+		    OVERLAY_CACHE_SIZE, OVERLAY_HSIZE, &overlay_sarc_l3_ops,
+		    sizeof (overlay_target_entry_t),
+		    offsetof(overlay_target_entry_t, ote_reflink),
+		    offsetof(overlay_target_entry_t, ote_u.ote_vl3), KM_SLEEP);
+		if (ret != 0) {
+			mutex_exit(&odd->odd_lock);
+			sarc_destroy(ott->ott_u.ott_dyn.ott_dhash);
+			kmem_cache_free(overlay_target_cache, ott);
+			overlay_hold_rele(odd);
+			return (ret);
+		}
+
 		avl_create(&ott->ott_u.ott_dyn.ott_tree, overlay_mac_avl,
 		    sizeof (overlay_target_entry_t),
 		    offsetof(overlay_target_entry_t, ote_avllink));
+		avl_create(&ott->ott_u.ott_dyn.ott_l3tree, overlay_ip_avl,
+		    sizeof (overlay_target_entry_t),
+		    offsetof(overlay_target_entry_t, ote_avllink));
 	}
 	mutex_enter(&odd->odd_lock);
 	if (odd->odd_flags & OVERLAY_F_VARPD) {
@@ -641,13 +1110,6 @@ again:
 		goto again;
 	}
 
-	/*
-	 * TODO: If VL3 request,
-	 *	set otl->otl_l3req
-	 *	Fill in otl_{src,dst}ip
-	 * Else
-	 *	clear otl->otl_l3req
-	 */
 	otl->otl_dlid = entry->ote_odd->odd_linkid;
 	otl->otl_reqid = (uintptr_t)entry;
 	otl->otl_varpdid = entry->ote_ott->ott_id;
@@ -655,10 +1117,23 @@ again:
 
 	otl->otl_hdrsize = mhi.mhi_hdrsize;
 	otl->otl_pktsize = msgsize(entry->ote_chead) - otl->otl_hdrsize;
-	bcopy(mhi.mhi_daddr, otl->otl_addru.otlu_l2.otl2_dstaddr, ETHERADDRL);
-	bcopy(mhi.mhi_saddr, otl->otl_addru.otlu_l2.otl2_srcaddr, ETHERADDRL);
-	otl->otl_addru.otlu_l2.otl2_dsttype = mhi.mhi_dsttype;
-	otl->otl_addru.otlu_l2.otl2_sap = mhi.mhi_bindsap;
+	if (entry->ote_flags & OVERLAY_ENTRY_F_VL3) {
+		overlay_targ_l3_t *l3p = &otl->otl_addru.otlu_l3;
+
+		otl->otl_l3req = B_TRUE;
+		bcopy(&entry->ote_u.ote_vl3.otvl3_src, &l3p->otl3_srcip,
+		    sizeof (struct in6_addr));
+		bcopy(&entry->ote_u.ote_vl3.otvl3_dst, &l3p->otl3_dstip,
+		    sizeof (struct in6_addr));
+	} else {
+		overlay_targ_l2_t *l2p = &otl->otl_addru.otlu_l2;
+
+		otl->otl_l3req = B_FALSE;
+		bcopy(mhi.mhi_daddr, l2p->otl2_dstaddr, ETHERADDRL);
+		bcopy(mhi.mhi_saddr, l2p->otl2_srcaddr, ETHERADDRL);
+		l2p->otl2_dsttype = mhi.mhi_dsttype;
+		l2p->otl2_sap = mhi.mhi_bindsap;
+	}
 	otl->otl_vlan = VLAN_ID(mhi.mhi_tci);
 	mutex_exit(&entry->ote_lock);
 
@@ -669,22 +1144,106 @@ again:
 	return (0);
 }
 
+static void
+overlay_target_lookup_respond_vl3(const overlay_targ_resp_t *otr,
+    overlay_target_entry_t *entry)
+{
+	overlay_target_entry_t *shared = NULL;
+	overlay_target_entry_t *vl2_entry;
+	overlay_target_t *ott = entry->ote_ott;
+	sarc_t *mhash = ott->ott_u.ott_dyn.ott_dhash;
+	hrtime_t now = gethrtime();
+
+	ASSERT(MUTEX_HELD(&entry->ote_lock));
+	ASSERT(entry->ote_flags & OVERLAY_ENTRY_F_VL3);
+
+	/*
+	 * A cross-{vlan,dc,vnet} packet with a destination VL3 of an overlay
+	 * router IP.  For now we drop these.
+	 */
+	if (entry->ote_flags & OVERLAY_ENTRY_F_ROUTER) {
+		entry->ote_flags &= ~OVERLAY_ENTRY_F_PENDING;
+		entry->ote_flags |= OVERLAY_ENTRY_F_DROP;
+		return;
+	}
+
+	bcopy(&otr->otr_mac, &entry->ote_u.ote_vl3.otvl3_vl2,
+	   sizeof (overlay_target_mac_t));
+
+	mutex_enter(&ott->ott_lock);
+	if ((shared = sarc_lookup(mhash, &otr->otr_mac)) != NULL)
+		sarc_hold(mhash, shared);
+	mutex_exit(&ott->ott_lock);
+
+	/*
+	 * Once we have the VL2 destination, we need to see if we already
+	 * have an existing VL2 entry we can reuse.  If not, we create a
+	 * fully-formed (i.e. valid) VL2 entry that we add to the cache.
+	 */
+	if (shared == NULL) {
+		vl2_entry = kmem_cache_alloc(overlay_entry_cache,
+		    KM_NOSLEEP | KM_NORMALPRI);
+		if (vl2_entry == NULL) {
+			/* XXX: drop */
+			return;
+		}
+
+		bcopy(&otr->otr_answer, &vl2_entry->ote_u.ote_vl2.otvl2_dest,
+		    sizeof (overlay_target_point_t));
+		bcopy(&otr->otr_mac, &vl2_entry->ote_u.ote_vl2.otvl2_mac,
+		    sizeof (overlay_target_mac_t));
+		bcopy(&otr->otr_route, &vl2_entry->ote_u.ote_vl2.otvl2_route,
+		    sizeof (overlay_target_route_t));
+		vl2_entry->ote_flags =
+		    OVERLAY_ENTRY_F_HAS_ROUTE | OVERLAY_ENTRY_F_VALID;
+		vl2_entry->ote_vtime = entry->ote_vtime = now;
+
+		mutex_enter(&ott->ott_lock);
+		if ((shared = sarc_lookup(mhash, &otr->otr_mac)) != NULL) {
+			overlay_target_entry_dtor(vl2_entry);
+			kmem_cache_free(overlay_entry_cache, vl2_entry);
+			sarc_hold(mhash, shared);
+
+			vl2_entry = shared;
+		} else {
+			sarc_insert(mhash, vl2_entry);
+			avl_add(&ott->ott_u.ott_dyn.ott_tree, vl2_entry);
+			sarc_hold(mhash, vl2_entry);
+		}
+		mutex_exit(&ott->ott_lock);
+	} else {
+		vl2_entry = shared;
+	}
+
+	mutex_enter(&vl2_entry->ote_lock);
+	if ((vl2_entry->ote_flags & (OVERLAY_ENTRY_F_HAS_ROUTE)) == 0) {
+		bcopy(&otr->otr_route, &vl2_entry->ote_u.ote_vl2.otvl2_route,
+		    sizeof (overlay_target_route_t));
+		vl2_entry->ote_flags |= OVERLAY_ENTRY_F_HAS_ROUTE;
+	}
+
+	/*
+	 * Update the VL2 entry if it doesn't have a valid destination. This
+	 * can lead to a slightly strange corner case where an entry is both
+	 * valid and pending (if there is still an outstanding VL2 request).
+	 * In such a case, the VL2 response will just overwrite the destination
+	 * with the same results and clear the pending flag.
+	 */
+	if ((vl2_entry->ote_flags & (OVERLAY_ENTRY_F_VALID)) == 0) {
+		bcopy(&otr->otr_answer, &vl2_entry->ote_u.ote_vl2.otvl2_dest,
+		    sizeof (overlay_target_point_t));
+		vl2_entry->ote_vtime = gethrtime();
+		vl2_entry->ote_flags |= OVERLAY_ENTRY_F_VALID;
+	}
+	mutex_exit(&vl2_entry->ote_lock);
+}
+
 static int
 overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 {
 	const overlay_targ_resp_t *otr = arg;
 	overlay_target_entry_t *entry;
 	mblk_t *mp;
-	boolean_t is_router = B_FALSE;
-
-	/*
-	 * If we ever support a protocol that uses MAC addresses as the UL
-	 * destination address, this check should probably include checking
-	 * that otp_mac is also all zeros.
-	 */
-	if (IN6_IS_ADDR_UNSPECIFIED(&otr->otr_answer.otp_ip) &&
-	    otr->otr_answer.otp_port == 0)
-		is_router = B_TRUE;
 
 	mutex_enter(&thdl->oth_lock);
 	for (entry = list_head(&thdl->oth_outstanding); entry != NULL;
@@ -701,26 +1260,39 @@ overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 	mutex_exit(&thdl->oth_lock);
 
 	mutex_enter(&entry->ote_lock);
-	bcopy(&otr->otr_answer, &entry->ote_dest,
-	    sizeof (overlay_target_point_t));
+
+	/*
+	 * If we ever support a protocol that uses MAC addresses as the UL
+	 * destination address, this check should probably include checking
+	 * that otp_mac is also all zeros.
+	 */
+	if (IN6_IS_ADDR_UNSPECIFIED(&otr->otr_answer.otp_ip) &&
+	    otr->otr_answer.otp_port == 0)
+		entry->ote_flags |= OVERLAY_ENTRY_F_ROUTER;
+
+	if ((entry->ote_flags & OVERLAY_ENTRY_F_VL3) == 0) {
+		bcopy(&otr->otr_answer, &entry->ote_u.ote_vl2.otvl2_dest,
+		    sizeof (overlay_target_point_t));
+		entry->ote_vtime = gethrtime();
+	} else {
+		overlay_target_lookup_respond_vl3(otr, entry);
+	}
+
 	entry->ote_flags &= ~OVERLAY_ENTRY_F_PENDING;
 	entry->ote_flags |= OVERLAY_ENTRY_F_VALID;
-	if (is_router)
-		entry->ote_flags |= OVERLAY_ENTRY_F_ROUTER;
+
 	mp = entry->ote_chead;
 	entry->ote_chead = NULL;
 	entry->ote_ctail = NULL;
 	entry->ote_mbsize = 0;
-	entry->ote_vtime = gethrtime();
 	mutex_exit(&entry->ote_lock);
 
 	/*
-	 * For now do an in-situ drain.
-	 *
-	 * TODO: overlay_m_tx() may need to perform remote fabric attachment
-	 * checks, which may leave mblk_t's left in the msg chain for
-	 * mblk_t's whose connectivity with the target entry are unknown.
-	 * This will then need to deal with the leftovers.
+	 * For now do an in-situ drain.  For VL3 entries, if we re-use
+	 * and existing VL2 entry, it is possible the VL2 lookup is still
+	 * pending (though should be rare).  In such instances, the packets
+	 * queued on the VL3 entry will get queued on the VL2 entry until
+	 * the VL2 entry is resolved.
 	 */
 	mp = overlay_m_tx(entry->ote_odd, mp);
 	freemsgchain(mp);
@@ -766,15 +1338,6 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 		goto done;
 	}
 
-	/*
-	 * TODO: This will need to be smarter.  This drop can only apply to
-	 * packets from the same source fabric as the first mblk_t in the
-	 * chain.  If the target exists, packets from other fabrics which
-	 * are chained to this target entry may be able to be sent (if we
-	 * already know they are attached), or we might need to query from
-	 * those other source fabrics if we don't know if the two are
-	 * attached.
-	 */
 	mp = entry->ote_chead;
 	if (mp != NULL) {
 		entry->ote_chead = mp->b_next;
@@ -1127,8 +1690,9 @@ overlay_target_cache_get(overlay_target_hdl_t *thdl, void *arg)
 		    sizeof (overlay_target_point_t));
 	} else {
 		overlay_target_entry_t *ote;
-		if ((ote = refhash_lookup(ott->ott_u.ott_dyn.ott_dhash,
-		    otc->otc_entry.otce_mac)) == NULL) {
+
+		if ((ote = sarc_lookup(ott->ott_u.ott_dyn.ott_dhash,
+		    &otc->otc_entry.otce_mac)) == NULL) {
 			ret = ENOENT;
 			goto done;
 		}
@@ -1143,7 +1707,7 @@ overlay_target_cache_get(overlay_target_hdl_t *thdl, void *arg)
 				    OVERLAY_TARGET_CACHE_ROUTER;
 			} else {
 				otc->otc_entry.otce_flags = 0;
-				bcopy(&ote->ote_dest,
+				bcopy(&ote->ote_u.ote_vl2.otvl2_dest,
 				    &otc->otc_entry.otce_dest,
 				    sizeof (overlay_target_point_t));
 			}
@@ -1198,17 +1762,20 @@ overlay_target_cache_set(overlay_target_hdl_t *thdl, void *arg)
 	mutex_enter(&ott->ott_lock);
 	mutex_exit(&odd->odd_lock);
 
-	ote = refhash_lookup(ott->ott_u.ott_dyn.ott_dhash,
-	    otc->otc_entry.otce_mac);
+	ote = sarc_lookup(ott->ott_u.ott_dyn.ott_dhash,
+	    &otc->otc_entry.otce_mac);
 	if (ote == NULL) {
+
 		ote = kmem_cache_alloc(overlay_entry_cache, KM_SLEEP);
-		bcopy(otc->otc_entry.otce_mac, ote->ote_addr, ETHERADDRL);
+
+		bcopy(&otc->otc_entry.otce_mac, &ote->ote_u.ote_vl2.otvl2_mac,
+		    sizeof (overlay_target_mac_t));
 		ote->ote_chead = ote->ote_ctail = NULL;
 		ote->ote_mbsize = 0;
 		ote->ote_ott = ott;
 		ote->ote_odd = odd;
 		mutex_enter(&ote->ote_lock);
-		refhash_insert(ott->ott_u.ott_dyn.ott_dhash, ote);
+		sarc_insert(ott->ott_u.ott_dyn.ott_dhash, ote);
 		avl_add(&ott->ott_u.ott_dyn.ott_tree, ote);
 	} else {
 		mutex_enter(&ote->ote_lock);
@@ -1220,7 +1787,7 @@ overlay_target_cache_set(overlay_target_hdl_t *thdl, void *arg)
 		ote->ote_flags |= OVERLAY_ENTRY_F_VALID;
 		if (otc->otc_entry.otce_flags & OVERLAY_TARGET_CACHE_ROUTER)
 			ote->ote_flags |= OVERLAY_ENTRY_F_ROUTER;
-		bcopy(&otc->otc_entry.otce_dest, &ote->ote_dest,
+		bcopy(&otc->otc_entry.otce_dest, &ote->ote_u.ote_vl2.otvl2_dest,
 		    sizeof (overlay_target_point_t));
 		mp = ote->ote_chead;
 		ote->ote_chead = NULL;
@@ -1271,8 +1838,11 @@ overlay_target_cache_remove(overlay_target_hdl_t *thdl, void *arg)
 	mutex_enter(&ott->ott_lock);
 	mutex_exit(&odd->odd_lock);
 
-	ote = refhash_lookup(ott->ott_u.ott_dyn.ott_dhash,
-	    otc->otc_entry.otce_mac);
+	if (otc->otc_entry.otce_mac.otm_dcid == 0)
+		otc->otc_entry.otce_mac.otm_dcid = odd->odd_dcid;
+
+	ote = sarc_lookup(ott->ott_u.ott_dyn.ott_dhash,
+	    &otc->otc_entry.otce_mac);
 	if (ote != NULL) {
 		mutex_enter(&ote->ote_lock);
 		ote->ote_flags &= ~OVERLAY_ENTRY_F_VALID_MASK;
@@ -1323,8 +1893,13 @@ overlay_target_cache_flush(overlay_target_hdl_t *thdl, void *arg)
 		ote->ote_flags &= ~OVERLAY_ENTRY_F_VALID_MASK;
 		mutex_exit(&ote->ote_lock);
 	}
-	ote = refhash_lookup(ott->ott_u.ott_dyn.ott_dhash,
-	    otc->otc_entry.otce_mac);
+
+	avl = &ott->ott_u.ott_dyn.ott_l3tree;
+	for (ote = avl_first(avl); ote != NULL; ote = AVL_NEXT(avl, ote)) {
+		mutex_enter(&ote->ote_lock);
+		ote->ote_flags &= ~OVERLAY_ENTRY_F_VALID_MASK;
+		mutex_exit(&ote->ote_lock);
+	}
 
 	mutex_exit(&ott->ott_lock);
 	overlay_hold_rele(odd);
@@ -1358,9 +1933,10 @@ overlay_target_cache_iter_copyin(const void *ubuf, void **outp, size_t *bsize,
 }
 
 typedef struct overlay_targ_cache_marker {
-	uint8_t		otcm_mac[ETHERADDRL];
+	overlay_target_mac_t otcm_mac;
 	uint16_t	otcm_done;
-} overlay_targ_cache_marker_t;
+} overlay_targ_cache_marker_t __aligned(8);
+CTASSERT(sizeof (overlay_targ_cache_marker_t) == 2 * sizeof (uint64_t));
 
 /* ARGSUSED */
 static int
@@ -1410,7 +1986,7 @@ overlay_target_cache_iter(overlay_target_hdl_t *thdl, void *arg)
 
 	if (ott->ott_mode == OVERLAY_TARGET_POINT) {
 		overlay_targ_cache_entry_t *out = &iter->otci_ents[0];
-		bzero(out->otce_mac, ETHERADDRL);
+		bzero(&out->otce_mac, sizeof (out->otce_mac));
 		out->otce_flags = 0;
 		bcopy(&ott->ott_u.ott_point, &out->otce_dest,
 		    sizeof (overlay_target_point_t));
@@ -1419,7 +1995,9 @@ overlay_target_cache_iter(overlay_target_hdl_t *thdl, void *arg)
 	}
 
 	avl = &ott->ott_u.ott_dyn.ott_tree;
-	bcopy(mark->otcm_mac, lookup.ote_addr, ETHERADDRL);
+	lookup.ote_u.ote_vl2.otvl2_mac.otm_dcid = odd->odd_dcid;
+	bcopy(&mark->otcm_mac, &lookup.ote_u.ote_vl2.otvl2_mac,
+	    sizeof (mark->otcm_mac));
 	ent = avl_find(avl, &lookup, &where);
 
 	/*
@@ -1444,19 +2022,21 @@ overlay_target_cache_iter(overlay_target_hdl_t *thdl, void *arg)
 			mutex_exit(&ent->ote_lock);
 			continue;
 		}
-		bcopy(ent->ote_addr, out->otce_mac, ETHERADDRL);
+		bcopy(&ent->ote_u.ote_vl2.otvl2_mac, &out->otce_mac,
+		    sizeof (out->otce_mac));
 		out->otce_flags = 0;
 		if (ent->ote_flags & OVERLAY_ENTRY_F_DROP)
 			out->otce_flags |= OVERLAY_TARGET_CACHE_DROP;
 		if (ent->ote_flags & OVERLAY_ENTRY_F_VALID)
-			bcopy(&ent->ote_dest, &out->otce_dest,
+			bcopy(&ent->ote_u.ote_vl2.otvl2_dest, &out->otce_dest,
 			    sizeof (overlay_target_point_t));
 		written++;
 		mutex_exit(&ent->ote_lock);
 	}
 
 	if (ent != NULL) {
-		bcopy(ent->ote_addr, mark->otcm_mac, ETHERADDRL);
+		bcopy(&ent->ote_u.ote_vl2.otvl2_mac, &mark->otcm_mac,
+		    sizeof (mark->otcm_mac));
 	} else {
 		mark->otcm_done = 1;
 	}
diff --git a/usr/src/uts/common/io/overlay/sarc.c b/usr/src/uts/common/io/overlay/sarc.c
new file mode 100644
index 0000000000..3c7b33ca8a
--- /dev/null
+++ b/usr/src/uts/common/io/overlay/sarc.c
@@ -0,0 +1,668 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+#include <sys/debug.h>
+#include <sys/errno.h>
+#include <sys/sysmacros.h>
+#ifdef _KERNEL
+#include <sys/types.h>
+#else
+#include <stddef.h>
+#include <stdint.h>
+#endif
+
+/*
+ * XXX: Until this code is integrated, it can be useful to be able to
+ * build this on it's own for testing, etc. on PIs that predate when
+ * the __unused macro was added.  If/once this code is integrated into
+ * illumos-joyent, this check can be removed.
+ */
+#ifndef __unused
+#define	__unused __attribute__((unused))
+#endif
+
+#ifdef _KERNEL
+#include <sys/kmem.h>
+#define	ZALLOC		kmem_zalloc
+#define	FREE		kmem_free
+#else
+#include <umem.h>
+#define	ZALLOC		umem_zalloc
+#define	FREE		umem_free
+#endif
+
+#include "sarc_impl.h"
+
+/*
+ * The *_overflow functions mimic the gcc/clang intrinsic functions.  Once
+ * we are using a newer compiler version to that includes these as intrisnics,
+ * these can be replaced with those versions.
+ */
+static int
+uadd_overflow(const size_t a, const size_t b, size_t *sump)
+{
+	*sump = a + b;
+	if (*sump < a || *sump < b)
+		return (1);
+	return (0);
+}
+
+#define	MUL_NO_OVERFLOW ((size_t)1 << (sizeof (size_t) * 4))
+
+static int
+umul_overflow(const size_t a, const size_t b, size_t *cp)
+{
+	*cp = a * b;
+
+	if ((a >= MUL_NO_OVERFLOW || b >= MUL_NO_OVERFLOW) &&
+	    a != 0 && b != 0 && SIZE_MAX / a < b)
+		return (1);
+
+	return (0);
+}
+
+void
+sarc_noevict(void *entry __unused)
+{
+}
+
+boolean_t
+sarc_nofetch(void *entry __unused)
+{
+	return (B_TRUE);
+}
+
+int
+sarc_create(sarc_t **sp, size_t c, size_t hsize, const sarc_ops_t *ops,
+    size_t obj_size, size_t link_off, size_t tag_off, int kmflags)
+{
+	sarc_t *sarc;
+	sarc_list_t *bucket;
+	size_t len = 0;
+	size_t i;
+
+	if (c < SARC_MIN_C)
+		return (EINVAL);
+
+	/* XXX: Maybe return EOVERFLOW instead? */
+	if (umul_overflow(sizeof (sarc_list_t), hsize, &len))
+		return (EINVAL);
+	if (uadd_overflow(sizeof (*sarc), len, &len))
+		return (EINVAL);
+
+	if ((sarc = ZALLOC(len, kmflags)) == NULL)
+		return (ENOMEM);
+
+	sarc->sarc_ops = *ops;
+	sarc->sarc_c = c;
+	sarc->sarc_p = c / 2;
+	sarc->sarc_nbuckets = hsize;
+	sarc->sarc_link_off = link_off;
+	sarc->sarc_tag_off = tag_off;
+	sarc->sarc_elsize = obj_size;
+
+	for (i = 0, bucket = sarc->sarc_bucket; i < hsize; i++, bucket++) {
+		list_create(&bucket->sal_list, obj_size, offsetof(sarc_link_t,
+		    sal_hash_link));
+	}
+
+	for (i = 0; i < SARC_NUM_LISTS; i++) {
+		list_create(&sarc->sarc_list[i].sal_list, obj_size,
+		    offsetof(sarc_link_t, sal_list_link));
+	}
+
+	*sp = sarc;
+	return (0);
+}
+
+void
+sarc_destroy(sarc_t *s)
+{
+	list_t *l;
+	sarc_link_t *lnk;
+	void *obj;
+	size_t i, len;
+
+	if (s == NULL)
+		return;
+
+	/* If creation succeeded, this calculation cannot overflow */
+	len = sizeof (*s) + s->sarc_nbuckets * sizeof (sarc_list_t);
+
+	for (i = 0; i < SARC_NUM_LISTS; i++) {
+		l = &s->sarc_list[i].sal_list;
+		for (;;) {
+			if ((lnk = list_remove_head(l)) == NULL)
+				break;
+		}
+	}
+
+	for (i = 0; i < s->sarc_nbuckets; i++) {
+		l = &s->sarc_bucket[i].sal_list;
+		for (;;) {
+			if ((lnk = list_remove_head(l)) == NULL)
+				break;
+			obj = link_to_obj(s, lnk);
+			s->sarc_ops.sao_dtor(obj);
+		}
+	}
+
+	FREE(s, len);
+}
+
+static void
+sarc_delete(sarc_t *s, sarc_link_t *lp)
+{
+	void *op = link_to_obj(s, lp);
+	void *tp = obj_to_tag(s, op);
+	uint_t n = s->sarc_ops.sao_hash(tp) % s->sarc_nbuckets;
+
+	ASSERT3U(s->sarc_bucket[n].sal_len, >, 0);
+	ASSERT(!list_is_empty(&s->sarc_bucket[n].sal_list));
+	ASSERT(!list_link_active(&lp->sal_list_link));
+	ASSERT(list_link_active(&lp->sal_hash_link));
+
+	list_remove(&s->sarc_bucket[n].sal_list, lp);
+	s->sarc_bucket[n].sal_len--;
+	s->sarc_ops.sao_dtor(op);
+}
+
+static sarc_link_t *
+sarc_lru_remove(sarc_t *s, sarc_flag_t list)
+{
+	sarc_link_t *lp;
+
+	ASSERT3S(list, >=, SARC_MRU);
+	ASSERT3S(list, <=, SARC_GMFU);
+
+	if ((lp = list_remove_tail(&s->sarc_list[list].sal_list)) != NULL)
+		s->sarc_list[list].sal_len--;
+
+	return (lp);
+}
+
+static void
+sarc_add(sarc_t *s, sarc_link_t *lp, sarc_flag_t which)
+{
+	sarc_list_t *slst;
+
+	ASSERT3S(which & ~SARC_LIST_MASK, ==, 0);
+	ASSERT(!list_link_active(&lp->sal_list_link));
+
+	slst = &s->sarc_list[which];
+	lp->sal_flags &= ~SARC_LIST_MASK;
+	lp->sal_flags |= which;
+	list_insert_head(&slst->sal_list, lp);
+	slst->sal_len++;
+}
+
+/*
+ * Evict an entry from the cache (MRU, MFU) and move it to the respective
+ * ghost list (MRU -> ghost MRU or MFU -> ghost MFU) to make room for a new
+ * entry.  This is the REPLACE procedure from the ARC paper where
+ * from_gmfu == (xt in B2)
+ */
+static void
+sarc_evict(sarc_t *s, boolean_t from_gmfu)
+{
+	sarc_link_t *lp;
+	sarc_flag_t dst;
+	size_t mru_len = s->sarc_list[SARC_MRU].sal_len;
+
+	if ((mru_len > 0) && ((mru_len > s->sarc_p) ||
+	    (from_gmfu && mru_len == s->sarc_p))) {
+		lp = sarc_lru_remove(s, SARC_MRU);
+		dst = SARC_GMRU;
+	} else {
+		lp = sarc_lru_remove(s, SARC_MFU);
+		dst = SARC_GMFU;
+	}
+
+	s->sarc_ops.sao_evict(link_to_obj(s, lp));
+	sarc_add(s, lp, dst);
+}
+
+static sarc_link_t *
+sarc_hash_lookup(sarc_t *s, const void *tp, sarc_list_t **lpp)
+{
+	uint_t n = s->sarc_ops.sao_hash(tp) % s->sarc_nbuckets;
+	sarc_link_t *lp;
+	sarc_list_t *bucket = &s->sarc_bucket[n];
+	list_t *l = &bucket->sal_list;
+	void *cmp;
+
+	if (lpp != NULL)
+		*lpp = bucket;
+
+	for (lp = list_head(l); lp != NULL; lp = list_next(l, lp)) {
+		cmp = obj_to_tag(s, link_to_obj(s, lp));
+
+		if (s->sarc_ops.sao_cmp(cmp, tp) == 0 &&
+		    !(lp->sal_flags & SARC_F_DEAD))
+			return (lp);
+	}
+
+	return (NULL);
+}
+
+int
+sarc_insert(sarc_t *s, void *obj)
+{
+	sarc_link_t *lp = obj_to_link(s, obj);
+	sarc_link_t *evict_lp = NULL;
+	sarc_list_t *bucket;
+	size_t mru_total;
+	size_t mfu_total;
+
+	/* Make sure there's no duplicates */
+	if (sarc_hash_lookup(s, obj_to_tag(s, obj), &bucket) != NULL)
+		return (EEXIST);
+
+	list_link_init(&lp->sal_hash_link);
+	list_link_init(&lp->sal_list_link);
+	lp->sal_refcnt = 0;
+	lp->sal_flags = 0;
+
+	list_insert_tail(&bucket->sal_list, lp);
+	bucket->sal_len++;
+
+	/* New entries always get put on the MRU */
+	lp->sal_flags = SARC_MRU;
+
+	mru_total = s->sarc_list[SARC_MRU].sal_len +
+	    s->sarc_list[SARC_GMRU].sal_len;
+	mfu_total = s->sarc_list[SARC_MFU].sal_len +
+	    s->sarc_list[SARC_GMFU].sal_len;
+
+	if (mru_total == s->sarc_c) {
+		if (s->sarc_list[SARC_MRU].sal_len < s->sarc_c) {
+			evict_lp = sarc_lru_remove(s, SARC_GMRU);
+			sarc_evict(s, B_FALSE);
+		} else {
+			evict_lp = sarc_lru_remove(s, SARC_MRU);
+		}
+	} else if ((mru_total < s->sarc_c) &&
+	    (mru_total + mfu_total >= s->sarc_c)) {
+		evict_lp = sarc_lru_remove(s, SARC_GMFU);
+		sarc_evict(s, B_FALSE);
+	}
+
+	if (evict_lp != NULL) {
+		if (evict_lp->sal_refcnt > 0) {
+			evict_lp->sal_flags |= SARC_F_DEAD;
+		} else {
+			sarc_delete(s, evict_lp);
+		}
+	}
+
+	/* New entries always go on the MRU */
+	sarc_add(s, lp, SARC_MRU);
+	return (0);
+}
+
+void *
+sarc_lookup(sarc_t *s, const void *tp)
+{
+	sarc_link_t *lp;
+	sarc_list_t *src;
+	void *obj;
+	size_t gmfu_len, gmru_len, ratio;
+	boolean_t from_ghost = B_FALSE;
+	boolean_t from_gmfu = B_FALSE;
+
+	if ((lp = sarc_hash_lookup(s, tp, NULL)) == NULL)
+		return (NULL);
+
+	obj = link_to_obj(s, lp);
+	src = SARC_LIST(s, lp);
+	gmfu_len = s->sarc_list[SARC_GMFU].sal_len;
+	gmru_len = s->sarc_list[SARC_GMRU].sal_len;
+
+	/*
+	 * If an entry has been found, it means it's been accessed
+	 * at least once, so it gets put at the head of the MFU list
+	 */
+	switch (lp->sal_flags & SARC_LIST_MASK) {
+	case SARC_MFU:
+		/*
+		 * While we'll end up removing the entry from the MFU and
+		 * then readding it back to the MFU, we want it moved to
+		 * the head of the MFU from whereever it's current position
+		 * is, so we cannot return early.
+		 */
+	case SARC_MRU:
+		from_ghost = B_FALSE;
+		break;
+	case SARC_GMRU:
+		/*
+		 * If we have a ghost MRU hit, we want to bias
+		 * towards more MRU, so adjust p accordingly
+		 */
+		if ((ratio = gmfu_len / gmru_len) == 0)
+			ratio = 1;
+		s->sarc_p = MIN(s->sarc_p + ratio, s->sarc_c);
+		from_ghost = B_TRUE;
+		break;
+	case SARC_GMFU:
+		/*
+		 * Simlarly, if there's a ghost MFU hit, we want to
+		 * bias towards more MFU, so adjust p accordingly
+		 */
+		if ((ratio = gmru_len / gmfu_len) == 0)
+			ratio = 1;
+		s->sarc_p = (s->sarc_p >= ratio) ? s->sarc_p - ratio : 0;
+		from_ghost = B_TRUE;
+		from_gmfu = B_TRUE;
+		break;
+	}
+
+	/* Remove from its current list */
+	ASSERT3U(src->sal_len, >, 0);
+	ASSERT(!list_is_empty(&src->sal_list));
+	list_remove(&src->sal_list, lp);
+	src->sal_len--;
+
+	if (from_ghost) {
+		/*
+		 * If we cannot fetch the data for a ghost entry, we don't
+		 * want to put it on the MRU list.  Instead just put it back
+		 * at the front of the list it was on.
+		 */
+		if (!s->sarc_ops.sao_fetch(obj)) {
+			list_insert_head(&src->sal_list, lp);
+			src->sal_len++;
+			return (obj);
+		}
+
+		/*
+		 * We have entries on the ghost list, it means the cache
+		 * (MRU, MFU) is full.  Bump something down to the ghost
+		 * list so we can move entry back into the cache.
+		 */
+		sarc_evict(s, from_gmfu);
+	}
+
+	sarc_add(s, lp, SARC_MFU);
+	return (obj);
+}
+
+/*
+ * Move the most recent entry in one of the ghost lists onto the tail of
+ * which and fetch.  If which is a ghost list, this is a no-op.  Returns
+ * B_TRUE if it was able to successfully resurrect an item, B_FALSE
+ * otherwise.
+ */
+static boolean_t
+sarc_resurrect(sarc_t *s, sarc_flag_t which)
+{
+	sarc_list_t *ghost_list, *dst;
+	sarc_link_t *exghost;
+
+	ASSERT3U(which & ~SARC_LIST_MASK, ==, 0);
+
+	dst = &s->sarc_list[which];
+	switch (which) {
+	case SARC_MRU:
+		ghost_list = &s->sarc_list[SARC_GMRU];
+		break;
+	case SARC_MFU:
+		ghost_list = &s->sarc_list[SARC_GMFU];
+		break;
+	default:
+		return (B_FALSE);
+	}
+	if (ghost_list->sal_len == 0)
+		return (B_FALSE);
+
+	exghost = list_remove_head(&ghost_list->sal_list);
+	if (!s->sarc_ops.sao_fetch(link_to_obj(s, exghost))) {
+		/* If we cannot fetch for some reason, just put it back */
+		list_insert_head(&ghost_list->sal_list, exghost);
+		return (B_FALSE);
+	}
+	ghost_list->sal_len--;
+
+	exghost->sal_flags &= ~SARC_LIST_MASK;
+	exghost->sal_flags |= which;
+	list_insert_tail(&dst->sal_list, exghost);
+	dst->sal_len++;
+
+	return (B_TRUE);
+}
+
+void
+sarc_remove(sarc_t *s, void *op)
+{
+	sarc_link_t *lp = obj_to_link(s, op);
+	sarc_list_t *lst = SARC_LIST(s, lp);
+
+	ASSERT(!list_is_empty(&lst->sal_list));
+	ASSERT3U(lst->sal_len, >, 0);
+	list_remove(&lst->sal_list, lp);
+	lst->sal_len--;
+
+	/*
+	 * For similar reasons as when we resize, if we're removing something
+	 * from the MRU or MFU list, we want to move an entry from the
+	 * respective ghost list so the ghost MRU:ghost MFU ratio (used to
+	 * determine how aggressively p is adjusted on ghost hits) stays
+	 * correct.  Since we're removing a single item, there's not much
+	 * we can do if we can't fetch the ghost item, so ignore the return
+	 * value.
+	 */
+	(void) sarc_resurrect(s, lp->sal_flags & SARC_LIST_MASK);
+
+	if (lp->sal_refcnt > 0) {
+		lp->sal_flags |= SARC_F_DEAD;
+	} else {
+		sarc_delete(s, lp);
+	}
+}
+
+void
+sarc_hold(sarc_t *s, void *op)
+{
+	sarc_link_t *lp = obj_to_link(s, op);
+
+	++lp->sal_refcnt;
+}
+
+void
+sarc_rele(sarc_t *s, void *op)
+{
+	sarc_link_t *lp = obj_to_link(s, op);
+
+	ASSERT3U(lp->sal_refcnt, >, 0);
+
+	if (--lp->sal_refcnt == 0 && (lp->sal_flags & SARC_F_DEAD))
+		sarc_remove(s, op);
+}
+
+int
+sarc_adjust_c(sarc_t *s, size_t new_c)
+{
+	sarc_link_t *lp = NULL;
+	size_t new_p = 0;
+	size_t mfu_tgt_len = 0;
+
+	/*
+	 * The original ARC paper doesn't cover this.  The most obvious
+	 * thing seems to scale p by the same ratio of old_c:new_c, and
+	 * if new_c < old_c, evict / delete entries as appropriate
+	 */
+	if (new_c < SARC_MIN_C)
+		return (EINVAL);
+
+	if (new_c == s->sarc_c)
+		return (0);
+
+	/*
+	 * new_p = p * (new_c/old_c).  Since we can't easily
+	 * use floating point if we're in the kernel, we try to
+	 * order the operations to preserve as much accuracy as
+	 * possible.  It does mean if new_c * p > SIZE_MAX, we
+	 * will fail the resize, however since the kernel is
+	 * 64-bit, that means new_c * p would be > 2^64 for
+	 * us to fail, so that seems unlikely to be legitimate.
+	 *
+	 * Since we are using integer math to resize p in proportion to the
+	 * change in c, it is possible the new value could result in a value
+	 * one less than if floating point + rounding was done (due to
+	 * truncation instead of rounding with integer division).  At the
+	 * moment, it doesn't seem like this should be a significant concern
+	 * as the value is p is constantly adjusted based on the access pattern
+	 * (i.e. hit rate) of the ghost caches.  If the value of p is off, it
+	 * should converge to the current 'correct' (best might be a better
+	 * description) value of p.  It should be expected that resizing the
+	 * cache is a somewhat disruptive operation in that it can lead to a
+	 * potentially large amount of cache eviction.
+	 */
+	if (umul_overflow(s->sarc_p, new_c, &new_p))
+		return (EOVERFLOW);
+	new_p /= s->sarc_c;
+	mfu_tgt_len = new_c - new_p;
+
+	if (new_c > s->sarc_c) {
+		/*
+		 * When increasing the size of the cache, we could just
+		 * update c and p, and leave the existing entries as is.
+		 * However, the ARC algorithm (at least as explained by
+		 * Megiddo and Modha) seems to implicitly assume that
+		 * if the ghost lists are populated, then their respective
+		 * real lists are 'full'.  Not having this seems like it
+		 * could distort the ideal value of p.  As such we want to
+		 * move as many entries from the ghost lists back into the
+		 * MFU and MRU caches as we can to keep adjustments to p
+		 * from being overly aggressive.
+		 */
+		while (s->sarc_list[SARC_MRU].sal_len < new_p) {
+			if (!sarc_resurrect(s, SARC_MRU))
+				break;
+		}
+
+		while (s->sarc_list[SARC_MFU].sal_len < mfu_tgt_len) {
+			if (!sarc_resurrect(s, SARC_MFU))
+				break;
+		}
+	} else {
+		/*
+		 * Move enough stuff from the MRU and MFU lists onto their
+		 * respective ghost lists.  Since p is the desired size of
+		 * the MRU list, c - p is the size of the MFU.  However,
+		 * the number of entries for a given list and it's ghost
+		 * counter part should also be <= c.  This means:
+		 *	p	Current maximum size of MRU
+		 *	c - p	Current maximum size of MFU
+		 *	c - p	Current maximum size of ghost MRU
+		 *	p	Current maximum size of ghost MFU
+		 *
+		 * Thus the new size of the ghost MRU is == mfu_tgt_len and
+		 * the new new size of the ghost MFU is p.  As we move entries
+		 * around, these limits might be exceeded (e.g. we may move
+		 * more than new_c - new_p entries from the MRU to the
+		 * ghost MFU, but only for the duration of the resize
+		 * operation -- everything should be within limits once we're
+		 * done.
+		 */
+		while (s->sarc_list[SARC_MRU].sal_len > new_p) {
+			if ((lp = sarc_lru_remove(s, SARC_MRU)) == NULL)
+				break;
+			s->sarc_ops.sao_evict(link_to_obj(s, lp));
+			sarc_add(s, lp, SARC_GMRU);
+		}
+		while (s->sarc_list[SARC_GMRU].sal_len > mfu_tgt_len) {
+			if ((lp = sarc_lru_remove(s, SARC_GMRU)) != NULL) {
+				if (lp->sal_refcnt > 0)
+					lp->sal_flags |= SARC_F_DEAD;
+				else
+					sarc_delete(s, lp);
+			} else {
+				break;
+			}
+		}
+
+		while (s->sarc_list[SARC_MFU].sal_len > mfu_tgt_len) {
+			if ((lp = sarc_lru_remove(s, SARC_MFU)) == NULL)
+				break;
+			s->sarc_ops.sao_evict(link_to_obj(s, lp));
+			sarc_add(s, lp, SARC_GMFU);
+		}
+		while (s->sarc_list[SARC_GMFU].sal_len > new_p) {
+			if ((lp = sarc_lru_remove(s, SARC_GMFU)) != NULL) {
+				if (lp->sal_refcnt > 0)
+					lp->sal_flags |= SARC_F_DEAD;
+				else
+					sarc_delete(s, lp);
+			} else {
+				break;
+			}
+		}
+	}
+
+	s->sarc_c = new_c;
+	s->sarc_p = new_p;
+	return (0);
+}
+
+void *
+sarc_first(sarc_t *s)
+{
+	sarc_link_t *lp = NULL;
+
+	for (int i = 0; i < SARC_NUM_LISTS; i++) {
+		sarc_list_t *slp = &s->sarc_list[i];
+
+		if ((lp = list_head(&slp->sal_list)) == NULL)
+			continue;
+
+		while (lp != NULL && ((lp->sal_flags & SARC_F_DEAD) != 0))
+			lp = list_next(&slp->sal_list, lp);
+
+		if (lp != NULL) {
+			++lp->sal_refcnt;
+			return (link_to_obj(s, lp));
+		}
+	}
+
+	return (lp);
+}
+
+void *
+sarc_next(sarc_t *s, void *op)
+{
+	sarc_link_t *lp;
+	int which;
+
+	lp = obj_to_link(s, op);
+	which = lp->sal_flags & SARC_LIST_MASK;
+
+	while (which < SARC_NUM_LISTS) {
+		sarc_list_t *slp = &s->sarc_list[which++];
+
+		while ((lp = list_next(&slp->sal_list, lp)) != NULL) {
+			if (!(lp->sal_flags & SARC_F_DEAD))
+				goto done;
+		}
+	}
+
+done:
+	sarc_rele(s, op);
+	if (lp == NULL)
+		return (NULL);
+
+	++lp->sal_refcnt;
+
+	return (link_to_obj(s, lp));
+}
diff --git a/usr/src/uts/common/io/overlay/sarc_impl.h b/usr/src/uts/common/io/overlay/sarc_impl.h
new file mode 100644
index 0000000000..236d1b1562
--- /dev/null
+++ b/usr/src/uts/common/io/overlay/sarc_impl.h
@@ -0,0 +1,67 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+#ifndef _SARC_IMPL_H
+#define	_SARC_IMPL_H
+
+#include <sys/debug.h>
+#include <sys/sarc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	SARC_NUM_LISTS	4	/* MRU, MFU, ghost MRU, ghost MFU */
+#define	SARC_LIST_MASK	0x3
+#define	SARC_MIN_C	10	/* Largely arbitrary minimum size */
+
+typedef struct sarc_list {
+	list_t	sal_list;
+	size_t	sal_len;	/* # of entries in list */
+} sarc_list_t;
+
+struct sarc {
+	sarc_ops_t	sarc_ops;		/* RO */
+	size_t		sarc_link_off;		/* RO */
+	size_t		sarc_tag_off;		/* RO */
+	size_t		sarc_nbuckets;		/* RO */
+	size_t		sarc_c;
+	size_t		sarc_p;
+	size_t		sarc_elsize;
+	sarc_list_t	sarc_list[SARC_NUM_LISTS];	/* MRU, MFU, etc */
+	sarc_list_t	sarc_bucket[];			/* hash buckets */
+};
+
+#define	SARC_LIST(_sarc, _lnk) \
+	(&(_sarc)->sarc_list[(_lnk)->sal_flags & SARC_LIST_MASK])
+
+#ifdef lint
+extern sarc_link_t *obj_to_link(sarc_t *, void *);
+extern void *link_to_obj(sarc_t *, sarc_link_t *);
+extern void *obj_to_tag(sarc_t *, void *);
+#else
+#define	obj_to_link(_s, _o)	\
+	((sarc_link_t *)(((char *)(_o)) + (_s)->sarc_link_off))
+#define	link_to_obj(_s, _l)	\
+	((void *)(((char *)(_l)) - (_s)->sarc_link_off))
+#define	obj_to_tag(_s, _o)	\
+	((void *)(((char *)(_o)) + (_s)->sarc_tag_off))
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SARC_IMPL_H */
diff --git a/usr/src/uts/common/sys/overlay_impl.h b/usr/src/uts/common/sys/overlay_impl.h
index 5fd81a11e7..d132f565d9 100644
--- a/usr/src/uts/common/sys/overlay_impl.h
+++ b/usr/src/uts/common/sys/overlay_impl.h
@@ -29,10 +29,11 @@
 #include <sys/avl.h>
 #include <sys/ksocket.h>
 #include <sys/socket.h>
-#include <sys/refhash.h>
 #include <sys/ethernet.h>
 #include <sys/list.h>
 
+#include "sarc.h"
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -81,42 +82,14 @@ typedef struct overlay_target {
 	union {					/* ott_lock */
 		overlay_target_point_t	ott_point;
 		struct overlay_target_dyn {
-			refhash_t	*ott_dhash;
-			refhash_t	*ott_l3dhash;
+			sarc_t		*ott_dhash;
+			sarc_t		*ott_l3dhash;
 			avl_tree_t	ott_tree;
-			/* XXX: Do we actually need a tree sorted by VL3? */
 			avl_tree_t	ott_l3tree;
 		} ott_dyn;
 	} ott_u;
 } overlay_target_t;
 
-/*
- * Initially at least, we represent a group of fabrics that are attached to
- * each other as a circular linked list.  Within an overlay_dev_t, we then
- * maintain a list of pointers into these lists for each fabric that's
- * present locally on the CN as we learn them:
- *
- */
-typedef struct overlay_fabric_attach {
-	struct overlay_fabric_attach *ofa_next;
-	struct in6_addr	ofa_addr;
-	uint32_t	ofa_dcid;
-	uint16_t	ofa_vlan;
-	uint8_t		ofa_prefixlen;
-	uint8_t		ofa_pad;
-} overlay_fabric_attach_t;
-
-/*
- * Since we have two different refhashes for an overlay_target_entry_t
- * (VL2 aka MAC address and VL3 aka IP address), we want to maintain
- * the refcount in only one place. We elect to use the ott_dhash
- * refhash to do so.
- */
-#define	OVERLAY_TARGET_ENTRY_HOLD(tgt, e) \
-	refhash_hold((tgt)->ott_u.ott_dyn.ott_dhash, e)
-#define	OVERLAY_TARGET_ENTRY_RELE(tgt, e) \
-	refhash_rele((tgt)->ott_u.ott_dyn.ott_dhash, e)
-
 typedef enum overlay_dev_flag {
 	OVERLAY_F_ACTIVATED	= 0x01, /* Activate ioctl completed */
 	OVERLAY_F_IN_MUX	= 0x02,	/* Currently in a mux */
@@ -147,7 +120,6 @@ typedef struct overlay_dev {
 	uint64_t	odd_vid;		/* RO if active else odd_lock */
 	avl_node_t	odd_muxnode;		/* managed by mux */
 	overlay_target_t *odd_target;		/* See big theory statement */
-	overlay_fabric_attach_t **odd_fattach;	/* protected by odd_lock */
 	uint32_t	odd_dcid;		/* RO if active else odd_lock */
 	uint8_t		odd_macaddr[ETHERADDRL]; /* RO same as odd_dcid */
 	char		odd_fmamsg[OVERLAY_STATUS_BUFLEN];	/* odd_lock */
@@ -157,30 +129,50 @@ typedef enum overlay_target_entry_flags {
 	OVERLAY_ENTRY_F_PENDING		= 0x01,	/* lookup in progress */
 	OVERLAY_ENTRY_F_VALID		= 0x02,	/* entry is currently valid */
 	OVERLAY_ENTRY_F_DROP		= 0x04,	/* always drop target */
-	OVERLAY_ENTRY_F_ROUTER		= 0x08, /* entry is for router */
-	OVERLAY_ENTRY_F_VALID_MASK	= 0x0e,
+	OVERLAY_ENTRY_F_ROUTER		= 0x08, /* VL2 router entry */
+	OVERLAY_ENTRY_F_HAS_ROUTE	= 0x10,
+	OVERLAY_ENTRY_F_VALID_MASK	= 0x1e,
+	OVERLAY_ENTRY_F_VL3		= 0x20, /* Is VL3 entry */
 } overlay_target_entry_flags_t;
 
-typedef struct overlay_target_entry {
+struct overlay_target_entry;
+typedef struct overlay_target_entry overlay_target_entry_t;
+
+/*
+ * For VL3 target entries, if we need to lock both the VL3 entry and the
+ * (possibly shared with multiple VL3 entries) VL2 entry, we must always
+ * take the VL3 lock prior to the VL2 entry lock.
+ */
+typedef struct overlay_target_vl3 {
+	struct in6_addr		otvl3_src;
+	struct in6_addr		otvl3_dst;
+	uint16_t		otvl3_src_vlan;
+	overlay_target_mac_t	otvl3_vl2;
+} overlay_target_vl3_t;
+
+typedef struct overlay_target_vl2 {
+	overlay_target_route_t	otvl2_route;
+	overlay_target_mac_t	otvl2_mac;
+	overlay_target_point_t	otvl2_dest;
+} overlay_target_vl2_t;
+
+struct overlay_target_entry {
 	kmutex_t		ote_lock;
-	refhash_link_t		ote_reflink;	/* hashtable link */
-	refhash_link_t		ote_l3_reflink;	/* IP hashtable link */
+	sarc_link_t		ote_reflink;	/* hashtable link */
 	avl_node_t		ote_avllink;	/* iteration link */
-	avl_node_t		ote_l3_avllink;	/* IP iteration link */
 	list_node_t		ote_qlink;
 	overlay_target_entry_flags_t ote_flags;	/* RW: state flags */
-	uint32_t		ote_dcid;
-	uint16_t		ote_vlan;	/* RO: VL3 vlan id */
-	uint8_t			ote_addr[ETHERADDRL];	/* RO: mac addr */
-	struct in6_addr		ote_ip;		/* RO: VL3 IP */
 	overlay_target_t	*ote_ott;	/* RO */
 	overlay_dev_t		*ote_odd;	/* RO */
-	overlay_target_point_t	ote_dest;	/* RW: destination */
 	mblk_t			*ote_chead;	/* RW: blocked mb chain head */
 	mblk_t			*ote_ctail;	/* RW: blocked mb chain tail */
 	size_t			ote_mbsize;	/* RW: outstanding mblk size */
 	hrtime_t		ote_vtime;	/* RW: valid timestamp */
-} overlay_target_entry_t;
+	union {
+		overlay_target_vl2_t	ote_vl2;
+		overlay_target_vl3_t	ote_vl3;
+	} ote_u;
+};
 
 #define	OVERLAY_CTL	"overlay"
 
diff --git a/usr/src/uts/common/sys/overlay_target.h b/usr/src/uts/common/sys/overlay_target.h
index 376d7e5495..28303ff4bc 100644
--- a/usr/src/uts/common/sys/overlay_target.h
+++ b/usr/src/uts/common/sys/overlay_target.h
@@ -31,29 +31,40 @@ extern "C" {
 
 /*
  * The overlay_target_point_t structure represents the destination where
- * encapsulated frames are sent.  Currently supported virtualization protocls
+ * encapsulated frames are sent.  Currently supported virtualization protocols
  * (i.e. vxlan) only use otp_ip and otp_port, but other methods might use
  * a L2 address instead of an L3 address to represent a destination.
  */
 typedef struct overlay_target_point {
-	uint8_t		otp_mac[ETHERADDRL];
 	struct in6_addr	otp_ip;
 	uint16_t	otp_port;
-} overlay_target_point_t;
+	uint8_t		otp_mac[ETHERADDRL];
+} overlay_target_point_t __aligned(8);
+
+/*
+ * An overlay_target_mac_t represents the overlay representation of a VL2 MAC
+ * address.  With the advent of cross-DC routing, it is possible to have
+ * duplicate MAC addresses in different data centers, so the data center id
+ * is necessary to uniquely identify a MAC address.
+ *
+ * XXX: In hindsight, using a uint16_t for the DCID might have been nicer.
+ */
+typedef struct overlay_target_mac {
+	uint32_t	otm_dcid;
+	uint8_t		otm_mac[ETHERADDRL];
+} overlay_target_mac_t;
 
 /*
- * The overlay_target_route_t represents the information necessary to send
- * packets to remote (routed) destinations.  Note: we currently only include
- * the L3 address prefix lengths since overlay can deduce the subnet address
- * from the original VL3 IP in the request + the prefix length in the reply.
+ * The overlay_target_route_t represents the fields of the packet that
+ * have to be modified to deliver a packet to remote (routed) destinations.
+ * All three values are always populated when a packet is routed, even if
+ * some of the overlay_target_route_t values end up being the same as the
+ * original values in the packet being routed.
  */
 typedef struct overlay_target_route {
-	uint64_t	otr_vnet;
-	uint16_t	otr_vlan;
-	uint8_t		otr_srcmac[ETHERADDRL];
-	uint32_t	otr_dcid;
-	uint8_t		otr_src_prefixlen;
-	uint8_t		otr_dst_prefixlen;
+	uint64_t		otr_vnet;
+	uint8_t			otr_srcmac[ETHERADDRL];
+	uint16_t		otr_vlan;
 } overlay_target_route_t;
 
 #define	OVERLAY_TARG_IOCTL	(('o' << 24) | ('v' << 16) | ('t' << 8))
@@ -203,9 +214,10 @@ typedef struct overlay_targ_lookup {
 
 
 typedef struct overlay_targ_resp {
-	uint64_t	otr_reqid;
-	overlay_target_point_t otr_answer;
-	overlay_target_route_t otr_route; /* Ignored for VL2->UL3 requests */
+	uint64_t		otr_reqid;
+	overlay_target_route_t	otr_route; /* Ignored for VL2->UL3 requests */
+	overlay_target_mac_t	otr_mac; /* Ignored for VL2->UL3 requests */
+	overlay_target_point_t	otr_answer;
 } overlay_targ_resp_t;
 
 typedef struct overlay_targ_pkt {
@@ -305,9 +317,8 @@ typedef struct overlay_targ_list {
 #define	OVERLAY_TARGET_CACHE_ROUTER	0x02
 
 typedef struct overlay_targ_cache_entry {
-	uint8_t			otce_mac[ETHERADDRL];
+	overlay_target_mac_t	otce_mac;
 	uint16_t		otce_flags;
-	uint32_t		otce_dcid;
 	overlay_target_point_t	otce_dest;
 } overlay_targ_cache_entry_t;
 
@@ -319,7 +330,7 @@ typedef struct overlay_targ_cache {
 typedef struct overlay_targ_cache_iter {
 	datalink_id_t			otci_linkid;
 	uint32_t			otci_pad;
-	uint64_t			otci_marker;
+	uint64_t			otci_marker[2];
 	uint16_t			otci_count;
 	overlay_targ_cache_entry_t	otci_ents[];
 } overlay_targ_cache_iter_t;
diff --git a/usr/src/uts/common/sys/sarc.h b/usr/src/uts/common/sys/sarc.h
new file mode 100644
index 0000000000..986bd6a80d
--- /dev/null
+++ b/usr/src/uts/common/sys/sarc.h
@@ -0,0 +1,179 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+#ifndef _SARC_H
+#define	_SARC_H
+
+/*
+ * SARC - A simplified implementation of the ARC algorithm for caches.
+ *
+ * This implements a cache that uses the adaptive replacement cache algorithm
+ * to manage the contents of the cache.  Like the original description of the
+ * ARC algorithm, it assumes each entry is fixed size.  Unlike the original
+ * description of the cache, it allows references to be held to entries,
+ * possibly beyond the lifetime of the entry in the cache.  Evicted entries
+ * that are still refheld at the time of eviction from the cache do not get
+ * counted towards it's size.  While the ZFS ARC merely looks for the next
+ * suitable entry when evicting refheld entries, it has mechanisms to also
+ * slow down the rate at which new data is added to the ZFS ARC.  Adding
+ * such mechanisms to this implementation would add additional complexity
+ * for any consumers.  Instead, it is dependent upon the user to only
+ * keep refheld entries for short periods of time to prevent the cache
+ * size from growing excessively large.  This implementation also does not
+ * currently implement any locking, so users must serialize access to any
+ * use of a given sarc_t with a mutex -- even lookup routines can cause
+ * movement of entries amongst the various lists that are maintined, so
+ * something such as rwlock would not work correctly.
+ */
+
+#include <sys/list.h>
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum sarc_flag {
+	SARC_MRU =	0x00,
+	SARC_MFU =	0x01,
+	SARC_GMRU =	0x02,
+	SARC_GMFU =	0x03,
+
+	SARC_F_DEAD =	0x04,
+} sarc_flag_t;
+
+typedef struct sarc_link {
+	list_node_t	sal_hash_link;	/* Hash chain bucket */
+	list_node_t	sal_list_link;	/* MRU, MFU, etc. list link */
+	uint_t		sal_refcnt;
+	sarc_flag_t	sal_flags;
+} sarc_link_t;
+
+struct sarc;
+typedef struct sarc sarc_t;
+
+typedef struct sarc_ops {
+	uint64_t	(*sao_hash)(const void *);
+	int		(*sao_cmp)(const void *, const void *);
+	void		(*sao_dtor)(void *);
+	boolean_t	(*sao_fetch)(void *);
+	void		(*sao_evict)(void *);
+} sarc_ops_t;
+
+/*
+ * The ARC algorithm maintains a cache of at most c items (divided into a
+ * MRU and MFU lists). The proportion of MRU:MFU entries can vary over time
+ * based on access patterns.  ARC utilizes a ghost cache (also of c items
+ * split between MRU and MFU) to detect changes in access patterns and
+ * adjust the split between MRU and MFU items.
+ *
+ * The expectation is that an entry being cached can itself be divided into
+ * some small identifying portion (that includes at least the hash tag) and
+ * the data being cached.   When a cache item moves to a ghost list, the
+ * evict operation is called on the entry to indicate the data portion can be
+ * freed while retaining the identifying portion of the entry.  When an entry
+ * on the ghost list moves back into the cache, the fetch op is called on the
+ * entry to reload the data that was released by the earlier evict operation.
+ *
+ * If the amount of data in an entry is small relative to the identifying
+ * information, there may not be much benefit in releasing any memory during
+ * an evict call.  Two conveinence functions (sarc_noevict() and sarc_nofetch())
+ * are provided for such instances.  These functions are effectively no-ops.
+ * When used, the ghost lists become more corporal and act effectively as a
+ * second level cache (also c sized), but does not otherwise effect the
+ * operation of the ARC algorithm.  It should be noted in such an instance the
+ * actual size of the cache will be 2c instead of c.
+ */
+extern void sarc_noevict(void *);
+extern boolean_t sarc_nofetch(void *);
+
+/*
+ * int sarc_create(sarcp, c, hsize, ops, objsize, link_off, tag_off, km_flags)
+ *
+ * sarcp	Contains newly allocated sarc_t instance
+ * c		Number of items the cache can hold
+ * ops		The functions that operate on entry for hashing, comparison, etc
+ * objsize	The size of each entry
+ * link_off	The offset of sarc_link_t within each entry
+ * tag_off	The offset of the tag field within each entry
+ * km_flags	The flags used when allocating the new sarc_t instance
+ *
+ * On success, sarc_create returns 0.  On failure, sarc_create can return:
+ * EINVAL	A parameter was not valid
+ * ENOMEM	No memory was available
+ */
+extern int sarc_create(sarc_t **, size_t, size_t, const sarc_ops_t *, size_t,
+    size_t, size_t, int);
+
+/* Destroys a sarc_t instance */
+extern void sarc_destroy(sarc_t *);
+
+/*
+ * Add an entry into the given cache.
+ *
+ * Returns:
+ *	0	Success
+ *	EINVAL	sarc_flag_t contained an invalid value
+ *	EEXIST	Entry already exists
+ */
+extern int sarc_insert(sarc_t *, void *);
+
+/*
+ * Lookup an entry in the cache with the given tag.  If found, the refheld
+ * object is returned. sarc_rele() should be called to release the reference.
+ * If not found, NULL is retured.
+ */
+extern void *sarc_lookup(sarc_t *, const void *);
+
+/*
+ * Remove an entry from the cache.  If the reference count is > 0, the dtor
+ * function call is deferred until the reference count is 0.  Once
+ * sarc_remove() is called on an entry, it is no longer returned in any
+ * lookup request, irrespective of its reference count.  Such an entry is also
+ * then ignored in any cache sizing calculations (such as when entries are
+ * moved between MRU, MFU, etc lists or when an entry is removed to make room
+ * for newer entries).
+ */
+extern void sarc_remove(sarc_t *, void *);
+
+/*
+ * Increment the reference count of an entry in the cache.  As lookups always
+ * return a refheld entry (when an entry is found), this is only needed to
+ * add additional holds on an entry are needed.
+ */
+extern void sarc_hold(sarc_t *, void *);
+
+/*
+ * Decrement the reference count of an entry in the cache.  This should be
+ * called for anything returned by sarc_lookup() to release the hold added
+ * by the lookup function.
+ */
+extern void sarc_rele(sarc_t *, void *);
+
+extern void *sarc_first(sarc_t *);
+extern void *sarc_next(sarc_t *, void *);
+
+/*
+ * Adjust the size of the cache.   May result in large amounts of entries
+ * being evicted at once.  May return EINVAL if the new size is below
+ * SARC_MIN_C (10).
+ */
+extern int sarc_adjust_c(sarc_t *, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SARC_H */
-- 
2.21.0

