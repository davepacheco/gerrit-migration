commit f5731a17cc8fbae47d292769b358b10c815289e3 (refs/changes/25/125/4)
Author: David Pacheco <dap@joyent.com>
Date:   2016-08-19T00:40:41+00:00 (3 years, 2 months ago)
    
    MORAY-347 moray testing process could be improved, documented
    Reviewed by: Cody Peter Mello <cody.mello@joyent.com>
    Reviewed by: Patrick Mooney <patrick.mooney@joyent.com>
    Approved by: Patrick Mooney <patrick.mooney@joyent.com>

diff --git a/Makefile b/Makefile
index 2ed8f88..cd868ad 100644
--- a/Makefile
+++ b/Makefile
@@ -27,14 +27,13 @@
 #
 NODE		:= ./build/node/bin/node
 BUNYAN		:= ./node_modules/.bin/bunyan
-FAUCET		:= ./node_modules/.bin/faucet
 JSONTOOL	:= ./node_modules/.bin/json
 
 #
 # Files
 #
 DOC_FILES	 = index.md
-JS_FILES	:= $(shell ls *.js) $(shell find lib test -name '*.js' | grep -v sql.js)
+JS_FILES	:= $(shell ls *.js) $(shell find lib -name '*.js' | grep -v sql.js)
 JSL_CONF_NODE	 = tools/jsl.node.conf
 JSL_FILES_NODE   = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
@@ -96,12 +95,8 @@ shrinkwrap: | $(NPM_EXEC)
 	$(NPM) shrinkwrap
 
 .PHONY: test
-test: $(FAUCET)
-	$(NODE) test/buckets.test.js | $(FAUCET)
-	$(NODE) test/objects.test.js | $(FAUCET)
-	$(NODE) test/sql.test.js | $(FAUCET)
-	$(NODE) test/integ.test.js | $(FAUCET)
-	$(NODE) test/arrays.test.js | $(FAUCET)
+test:
+	@echo See the separate moray-test-suite repository for testing.
 
 .PHONY: scripts
 scripts: deps/manta-scripts/.git
diff --git a/README.md b/README.md
index 46c8d0b..a5981fb 100644
--- a/README.md
+++ b/README.md
@@ -51,22 +51,19 @@ Which will open up Moray on port 2020.  You can now use the CLI in
 
 ## Testing
 
-Before run tests, you should consider point config file to a different DB
-than `moray`. There is a script at `tools/coal-test-env.sh` which will create
-a `moray_test` DB for you and run an additional `moray-test` instance listening
-at port `2222`. Just scping into GZ and executing it should work.
+For testing, see the separate
+[moray-test-suite](https://github.com/joyent/moray-test-suite) repository.  You
+will need to supply your own server configuration file.  You should consider
+pointing the config file to a different DB than `moray`. There is a script at
+`tools/coal-test-env.sh` which will create a `moray_test` DB for you and run an
+additional `moray-test` instance listening at port `2222`. Just scping into GZ
+and executing it should work.  You will need to configure the test suite
+appropriately (see the README.md in the moray-test-suite repository).
 
-Then, make sure your test file points to the right port:
-
-    MORAY_PORT=2222 make test
-
-To run tests on default `2020` port just do:
-
-    make test
 
 ## License
 
 This Source Code Form is subject to the terms of the Mozilla Public License, v.
 2.0.  For the full license text see LICENSE, or http://mozilla.org/MPL/2.0/.
 
-Copyright (c) 2014, Joyent, Inc.
+Copyright (c) 2016, Joyent, Inc.
diff --git a/package.json b/package.json
index f9c799a..44967cd 100644
--- a/package.json
+++ b/package.json
@@ -31,11 +31,6 @@
         "verror": "1.3.7",
         "xtend": "2.1.2"
     },
-    "devDependencies": {
-        "moray": "git+ssh://git@github.com:joyent/node-moray.git#master",
-        "tape": "2.14.0",
-        "faucet": "0.0.1"
-    },
     "sdcDependencies": {
         "config-agent": ">=1.2.0"
     },
diff --git a/test/arrays.test.js b/test/arrays.test.js
deleted file mode 100644
index efa9bc4..0000000
--- a/test/arrays.test.js
+++ /dev/null
@@ -1,787 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright 2016, Joyent, Inc.
- */
-
-var once = require('once');
-var tape = require('tape');
-var libuuid = require('libuuid');
-var vasync = require('vasync');
-
-var helper = require('./helper.js');
-
-
-
-///--- Globals
-
-var uuid = {
-    v1: libuuid.create,
-    v4: libuuid.create
-};
-
-var c; // client
-var server;
-var b; // bucket
-
-function test(name, setup) {
-    tape.test(name + ' - setup', function (t) {
-        b = 'moray_unit_test_' + uuid.v4().substr(0, 7);
-        helper.createServer(null, function (s) {
-            server = s;
-            c = helper.createClient();
-            c.on('connect', t.end.bind(t));
-        });
-    });
-
-    tape.test(name + ' - main', function (t) {
-        setup(t);
-    });
-
-    tape.test(name + ' - teardown', function (t) {
-    // May or may not exist, just blindly ignore
-        c.delBucket(b, function () {
-            c.once('close', function () {
-                helper.cleanupServer(server, function () {
-                    t.pass('closed');
-                    t.end();
-                });
-            });
-            c.close();
-        });
-    });
-}
-
-///--- Tests
-
-test('schema array, array value (string)', function (t) {
-    var k = uuid.v4();
-    var cfg = {
-        index: {
-            name: {
-                type: '[string]',
-                unique: false
-            }
-        }
-    };
-    var data = {
-        name: ['foo', 'bar', 'baz'],
-        ignoreme: 'foo'
-    };
-
-    vasync.pipeline({
-        funcs: [
-            function bucket(_, cb) {
-                c.putBucket(b, cfg, cb);
-            },
-            function object(_, cb) {
-                c.putObject(b, k, data, cb);
-            },
-            function find(_, cb) {
-                cb = once(cb);
-
-                var found = false;
-                var req = c.findObjects(b, '(name=foo)');
-                req.once('error', cb);
-                req.once('record', function (obj) {
-                    t.ok(obj);
-                    if (obj) {
-                        t.equal(obj.bucket, b);
-                        t.equal(obj.key, k);
-                        t.deepEqual(obj.value, data);
-                        t.ok(obj._id);
-                        t.ok(obj._etag);
-                        t.ok(obj._mtime);
-                        found = true;
-                    }
-                });
-                req.once('end', function () {
-                    t.ok(found);
-                    cb();
-                });
-            }
-        ],
-        arg: null
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('schema array, scalar value (string)', function (t) {
-    var k = uuid.v4();
-    var cfg = {
-        index: {
-            name: {
-                type: '[string]',
-                unique: false
-            }
-        }
-    };
-    var data = {
-        name: 'foo',
-        ignoreme: 'foo'
-    };
-
-    vasync.pipeline({
-        funcs: [
-            function bucket(_, cb) {
-                c.putBucket(b, cfg, cb);
-            },
-            function object(_, cb) {
-                c.putObject(b, k, data, cb);
-            },
-            function find(_, cb) {
-                cb = once(cb);
-
-                var found = false;
-                var req = c.findObjects(b, '(name=foo)');
-                req.once('error', cb);
-                req.once('record', function (obj) {
-                    t.ok(obj);
-                    if (obj) {
-                        t.equal(obj.bucket, b);
-                        t.equal(obj.key, k);
-                        // Moray converts back into an
-                        // array...
-                        data.name = [data.name];
-                        t.deepEqual(obj.value, data);
-                        t.ok(obj._id);
-                        t.ok(obj._etag);
-                        t.ok(obj._mtime);
-                        found = true;
-                    }
-                });
-                req.once('end', function () {
-                    t.ok(found);
-                    cb();
-                });
-            }
-        ],
-        arg: null
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-test('schema array, array value (inet)', function (t) {
-    var k = uuid.v4();
-    var cfg = {
-        index: {
-            ips: {
-                type: '[ip]',
-                unique: false
-            }
-        }
-    };
-    var data = {
-        ips: ['192.168.0.1', 'fd00::45'],
-        ignoreme: 'foo'
-    };
-
-    vasync.pipeline({
-        funcs: [
-            function bucket(_, cb) {
-                c.putBucket(b, cfg, cb);
-            },
-            function object(_, cb) {
-                c.putObject(b, k, data, cb);
-            },
-            function find4(_, cb) {
-                cb = once(cb);
-
-                var found = false;
-                var req = c.findObjects(b, '(ips=192.168.0.1)');
-                req.once('error', cb);
-                req.once('record', function (obj) {
-                    t.ok(obj);
-                    if (obj) {
-                        t.equal(obj.bucket, b);
-                        t.equal(obj.key, k);
-                        t.deepEqual(obj.value, data);
-                        t.ok(obj._id);
-                        t.ok(obj._etag);
-                        t.ok(obj._mtime);
-                        found = true;
-                    }
-                });
-                req.once('end', function () {
-                    t.ok(found);
-                    cb();
-                });
-            },
-            function find6(_, cb) {
-                cb = once(cb);
-
-                var found = false;
-                var req = c.findObjects(b, '(ips=fd00::045)');
-                req.once('error', cb);
-                req.once('record', function (obj) {
-                    t.ok(obj);
-                    if (obj) {
-                        t.equal(obj.bucket, b);
-                        t.equal(obj.key, k);
-                        t.deepEqual(obj.value, data);
-                        t.ok(obj._id);
-                        t.ok(obj._etag);
-                        t.ok(obj._mtime);
-                        found = true;
-                    }
-                });
-                req.once('end', function () {
-                    t.ok(found);
-                    cb();
-                });
-            }
-        ],
-        arg: null
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-test('schema array, array value (cidr)', function (t) {
-    var k = uuid.v4();
-    var cfg = {
-        index: {
-            networks: {
-                type: '[subnet]',
-                unique: false
-            }
-        }
-    };
-    var data = {
-        networks: ['10.10.0.0/16', 'fe80::/64'],
-        ignoreme: 'foo'
-    };
-
-    vasync.pipeline({
-        funcs: [
-            function bucket(_, cb) {
-                c.putBucket(b, cfg, cb);
-            },
-            function object(_, cb) {
-                c.putObject(b, k, data, cb);
-            },
-            function find4(_, cb) {
-                cb = once(cb);
-
-                var found = false;
-                var req = c.findObjects(b, '(networks=10.10.0.0/16)');
-                req.once('error', cb);
-                req.once('record', function (obj) {
-                    t.ok(obj);
-                    if (obj) {
-                        t.equal(obj.bucket, b);
-                        t.equal(obj.key, k);
-                        t.deepEqual(obj.value, data);
-                        t.ok(obj._id);
-                        t.ok(obj._etag);
-                        t.ok(obj._mtime);
-                        found = true;
-                    }
-                });
-                req.once('end', function () {
-                    t.ok(found);
-                    cb();
-                });
-            },
-            function find6(_, cb) {
-                cb = once(cb);
-
-                var found = false;
-                var req = c.findObjects(b, '(networks=fe80::0/64)');
-                req.once('error', cb);
-                req.once('record', function (obj) {
-                    t.ok(obj);
-                    if (obj) {
-                        t.equal(obj.bucket, b);
-                        t.equal(obj.key, k);
-                        t.deepEqual(obj.value, data);
-                        t.ok(obj._id);
-                        t.ok(obj._etag);
-                        t.ok(obj._mtime);
-                        found = true;
-                    }
-                });
-                req.once('end', function () {
-                    t.ok(found);
-                    cb();
-                });
-            }
-        ],
-        arg: null
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-test('schema array, array value (number)', function (t) {
-    var k = uuid.v4();
-    var cfg = {
-        index: {
-            id: {
-                type: '[number]',
-                unique: false
-            }
-        }
-    };
-    var data = {
-        id: [1, 2, 3],
-        ignoreme: 'foo'
-    };
-    var found = 0;
-
-    function checkObject(obj) {
-        t.ok(obj);
-        if (obj) {
-            t.equal(obj.bucket, b);
-            t.equal(obj.key, k);
-            t.deepEqual(obj.value, data);
-            t.ok(obj._id);
-            t.ok(obj._etag);
-            t.ok(obj._mtime);
-            found++;
-        }
-    }
-
-    vasync.pipeline({
-        funcs: [
-            function setup(_, cb) {
-                c.putBucket(b, cfg, function (err) {
-                    if (err) {
-                        cb(err);
-                    } else {
-                        c.putObject(b, k, data, cb);
-                    }
-                });
-            },
-            function eq(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(id=1)');
-                req.once('error', cb);
-                req.once('record', checkObject);
-                req.once('end', cb);
-            },
-            function gte(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(id>=3)');
-                req.once('error', cb);
-                req.once('record', checkObject);
-                req.once('end', cb);
-            },
-            function lte(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(id<=1)');
-                req.once('error', cb);
-                req.once('record', checkObject);
-                req.once('end', cb);
-            },
-            function presence(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(id=*)');
-                req.once('error', cb);
-                req.once('record', checkObject);
-                req.once('end', cb);
-            },
-            function and(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(&(id<=3)(id>=1))');
-                req.once('error', cb);
-                req.once('record', checkObject);
-                req.once('end', cb);
-            },
-            function or(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(|(id<=0)(id>=1))');
-                req.once('error', cb);
-                req.once('record', checkObject);
-                req.once('end', cb);
-            },
-            function not(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(!(id=0))');
-                req.once('error', cb);
-                req.once('record', checkObject);
-                req.once('end', cb);
-            }
-        ],
-        arg: null
-    }, function (err, results) {
-        t.ifError(err);
-        t.equal(found, results.operations.length - 1);
-        t.end();
-    });
-});
-
-
-test('schema array string, substring filter throws', function (t) {
-    var k = uuid.v4();
-    var cfg = {
-        index: {
-            name: {
-                type: '[string]',
-                unique: false
-            }
-        }
-    };
-    var data = {
-        name: ['foo', 'bar', 'baz'],
-        ignoreme: 'foo'
-    };
-
-    vasync.pipeline({
-        funcs: [
-            function setup(_, cb) {
-                c.putBucket(b, cfg, function (err) {
-                    if (err) {
-                        cb(err);
-                    } else {
-                        c.putObject(b, k, data, cb);
-                    }
-                });
-            },
-            function substr(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(name=f*)');
-                req.once('error', function (err) {
-                    t.ok(err);
-                    cb(err);
-                });
-                req.once('end', cb);
-            }
-        ],
-        arg: null
-    }, function (err, results) {
-        t.ok(err);
-        t.end();
-    });
-});
-
-
-test('schema array, array value (number), updates', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            id: {
-                type: '[number]',
-                unique: false
-            }
-        }
-    };
-    var data = {
-        id: [5, 6, 7],
-        ignoreme: 'foo'
-    };
-    var found = 0;
-
-    var objects = [];
-
-    objects.push({
-        bucket: b,
-        key: k,
-        value: data
-    });
-
-    objects.push({
-        bucket: b,
-        key: k,
-        value: {
-            id: [1, 2, 3]
-        }
-    });
-
-    function checkObject(obj) {
-        t.ok(obj);
-        if (obj) {
-            t.equal(obj.bucket, b);
-            t.equal(obj.key, k);
-            t.deepEqual(obj.value, {
-                id: [1, 2, 3]
-            });
-            t.ok(obj._id);
-            t.ok(obj._etag);
-            t.ok(obj._mtime);
-            found++;
-        }
-    }
-
-    vasync.pipeline({
-        funcs: [
-            function setup(_, cb) {
-                c.putBucket(b, cfg, function (err) {
-                    if (err) {
-                        cb(err);
-                    } else {
-                        c.batch(objects, cb);
-                    }
-                });
-            },
-            function eq(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(id=1)');
-                req.once('error', cb);
-                req.once('record', checkObject);
-                req.once('end', cb);
-            }
-        ],
-        arg: null
-    }, function (err, results) {
-        t.ifError(err);
-        t.equal(found, results.operations.length - 1);
-        t.end();
-    });
-});
-
-
-test('schema array, array value (string), updates', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            name: {
-                type: '[string]',
-                unique: false
-            }
-        }
-    };
-    var data = {
-        name: ['bar', 'foo', 'baz'],
-        ignoreme: 'foo'
-    };
-
-    var objects = [];
-
-    objects.push({
-        bucket: b,
-        key: k,
-        value: data
-    });
-
-    objects.push({
-        bucket: b,
-        key: k,
-        value: {
-            name: ['foo', 'bar', 'baz']
-        }
-    });
-
-    vasync.pipeline({
-        funcs: [
-            function setup(_, cb) {
-                c.putBucket(b, cfg, function (err) {
-                    if (err) {
-                        cb(err);
-                    } else {
-                        c.batch(objects, cb);
-                    }
-                });
-            },
-            function find(_, cb) {
-                cb = once(cb);
-
-                var found = false;
-                var req = c.findObjects(b, '(name=foo)');
-                req.once('error', cb);
-                req.once('record', function (obj) {
-                    t.ok(obj);
-                    if (obj) {
-                        t.equal(obj.bucket, b);
-                        t.equal(obj.key, k);
-                        t.deepEqual(obj.value, {
-                            name: ['foo', 'bar', 'baz']
-                        });
-                        t.ok(obj._id);
-                        t.ok(obj._etag);
-                        t.ok(obj._mtime);
-                        found = true;
-                    }
-                });
-                req.once('end', function () {
-                    t.ok(found);
-                    cb();
-                });
-            }
-        ],
-        arg: null
-    }, function (err, results) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('schema array, array value (boolean), updates', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            id: {
-                type: '[boolean]',
-                unique: false
-            }
-        }
-    };
-    var data = {
-        id: [true, false, true],
-        ignoreme: 'foo'
-    };
-    var found = 0;
-
-    var objects = [];
-
-    objects.push({
-        bucket: b,
-        key: k,
-        value: data
-    });
-
-    objects.push({
-        bucket: b,
-        key: k,
-        value: {
-            id: [false, false, false]
-        }
-    });
-
-    function checkObject(obj) {
-        t.ok(obj);
-        if (obj) {
-            t.equal(obj.bucket, b);
-            t.equal(obj.key, k);
-            t.deepEqual(obj.value, {
-                id: [false, false, false]
-            });
-            t.ok(obj._id);
-            t.ok(obj._etag);
-            t.ok(obj._mtime);
-            found++;
-        }
-    }
-
-    vasync.pipeline({
-        funcs: [
-            function setup(_, cb) {
-                c.putBucket(b, cfg, function (err) {
-                    if (err) {
-                        cb(err);
-                    } else {
-                        c.batch(objects, cb);
-                    }
-                });
-            },
-            function eq(_, cb) {
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(id=false)');
-                req.once('error', cb);
-                req.once('record', checkObject);
-                req.once('end', cb);
-            }
-        ],
-        arg: null
-    }, function (err, results) {
-        t.ifError(err);
-        t.equal(found, results.operations.length - 1);
-        t.end();
-    });
-});
-
-
-test('schema array, value (string) includes commas/curly braces', function (t) {
-    var cfg = {
-        index: {
-            name: {
-                type: '[string]',
-                unique: false
-            }
-        }
-    };
-    var data = {};
-
-    data[libuuid.create()] = {
-        name: ['{foo}', '{bar}', 'baz']
-    };
-    data[libuuid.create()] = {
-        name: ['{"foo": {"baz": "bar", "with": "commas"}}']
-    };
-    data['quotedkey'] = {
-        name: ['foo == "bar"', '"quoted"', '"bar" = baz']
-    };
-
-    vasync.pipeline({
-        funcs: [
-            function setup(_, cb) {
-                c.putBucket(b, cfg, function (err) {
-                    t.ifError(err);
-                    cb(err);
-                });
-            },
-            function putObjs(_, cb) {
-                var batchData = [];
-                Object.keys(data).forEach(function (key) {
-                    batchData.push({
-                        bucket: b,
-                        key: key,
-                        value: data[key]
-                    });
-                });
-                c.batch(batchData, function (err) {
-                    t.ifError(err);
-                    cb(err);
-                });
-            },
-            function checkObjs(_, cb) {
-                var count = 0;
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(name=*)');
-                req.once('error', cb);
-                req.on('record', function (row) {
-                    t.ok(data[row.key]);
-                    t.deepEqual(row.value, data[row.key]);
-                    count++;
-                });
-                req.once('end', function () {
-                    t.equal(count, Object.keys(data).length);
-                    cb();
-                });
-            },
-            function checkSearch(_, cb) {
-                var count = 0;
-                cb = once(cb);
-
-                var req = c.findObjects(b, '(name="quoted")');
-                req.once('error', cb);
-                req.on('record', function (row) {
-                    t.equal(row.key, 'quotedkey');
-                    count++;
-                });
-                req.once('end', function () {
-                    t.equal(count, 1);
-                    cb();
-                });
-            }
-        ],
-        arg: null
-    }, function (err, results) {
-        t.ifError(err);
-        t.end();
-    });
-
-});
diff --git a/test/buckets.test.js b/test/buckets.test.js
deleted file mode 100644
index a692bb1..0000000
--- a/test/buckets.test.js
+++ /dev/null
@@ -1,406 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var clone = require('clone');
-var tape = require('tape');
-var uuid = require('libuuid').create;
-
-var helper = require('./helper.js');
-
-
-
-///--- Globals
-
-var FULL_CFG = {
-    index: {
-        str: {
-            type: 'string'
-        },
-        str_u: {
-            type: 'string',
-            unique: true
-        },
-        num: {
-            type: 'number'
-        },
-        num_u: {
-            type: 'number',
-            unique: true
-        },
-        bool: {
-            type: 'boolean'
-        },
-        bool_u: {
-            type: 'boolean',
-            unique: true
-        },
-        ip: {
-            type: 'ip'
-        },
-        ip_u: {
-            type: 'ip',
-            unique: true
-        },
-        subnet: {
-            type: 'subnet'
-        },
-        subnet_u: {
-            type: 'subnet',
-            unique: true
-        }
-    },
-    pre: [function onePre(req, cb) { cb(); }],
-    post: [function onePost(req, cb) { cb(); }],
-    options: {}
-};
-
-var c; // client
-var server;
-var b; // bucket
-
-function test(name, setup) {
-    tape.test(name + ' - setup', function (t) {
-        b = 'moray_unit_test_' + uuid().substr(0, 7);
-        helper.createServer(null, function (s) {
-            server = s;
-            c = helper.createClient();
-            c.on('connect', t.end.bind(t));
-        });
-    });
-
-    tape.test(name + ' - main', function (t) {
-        setup(t);
-    });
-
-    tape.test(name + ' - teardown', function (t) {
-        // May or may not exist, just blindly ignore
-        c.delBucket(b, function () {
-            c.once('close', function () {
-                helper.cleanupServer(server, function () {
-                    t.pass('closed');
-                    t.end();
-                });
-            });
-            c.close();
-        });
-    });
-}
-
-
-///--- Helpers
-
-function assertBucket(t, bucket, cfg) {
-    t.ok(bucket);
-    if (!bucket)
-        return (undefined);
-    t.equal(bucket.name, b);
-    t.ok(bucket.mtime instanceof Date);
-    t.deepEqual(bucket.index, (cfg.index || {}));
-    t.ok(Array.isArray(bucket.pre));
-    t.ok(Array.isArray(bucket.post));
-    t.equal(bucket.pre.length, (cfg.pre || []).length);
-    t.equal(bucket.post.length, (cfg.post || []).length);
-
-    if (bucket.pre.length !== (cfg.pre || []).length ||
-        bucket.post.length !== (cfg.post || []).length)
-        return (undefined);
-    var i;
-    for (i = 0; i < bucket.pre.length; i++)
-        t.equal(bucket.pre[i].toString(), cfg.pre[i].toString());
-    for (i = 0; i < bucket.post.length; i++)
-        t.equal(bucket.post[i].toString(), cfg.post[i].toString());
-
-    return (undefined);
-}
-
-
-///--- tests
-
-
-test('create bucket stock config', function (t) {
-    c.createBucket(b, {}, function (err) {
-        t.ifError(err);
-        c.getBucket(b, function (err2, bucket) {
-            t.ifError(err2);
-            assertBucket(t, bucket, {});
-            c.listBuckets(function (err3, buckets) {
-                t.ifError(err3);
-                t.ok(buckets);
-                t.ok(buckets.length);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('create bucket loaded', function (t) {
-    c.createBucket(b, FULL_CFG, function (err) {
-        t.ifError(err);
-        c.getBucket(b, function (err2, bucket) {
-            t.ifError(err2);
-            assertBucket(t, bucket, FULL_CFG);
-            t.end();
-        });
-    });
-});
-
-
-test('update bucket', function (t) {
-    c.createBucket(b, FULL_CFG, function (err) {
-        t.ifError(err);
-        var cfg = clone(FULL_CFG);
-        cfg.index.foo = {
-            type: 'string',
-            unique: false
-        };
-        cfg.post.push(function two(req, cb) {
-            cb();
-        });
-        c.updateBucket(b, cfg, function (err2) {
-            t.ifError(err2);
-            c.getBucket(b, function (err3, bucket) {
-                t.ifError(err3);
-                assertBucket(t, bucket, cfg);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('update bucket (versioned ok 0->1)', function (t) {
-    c.createBucket(b, FULL_CFG, function (err) {
-        t.ifError(err);
-        var cfg = clone(FULL_CFG);
-        cfg.options.version = 1;
-        cfg.index.foo = {
-            type: 'string',
-            unique: false
-        };
-        cfg.post.push(function two(req, cb) {
-            cb();
-        });
-        c.updateBucket(b, cfg, function (err2) {
-            t.ifError(err2);
-            c.getBucket(b, function (err3, bucket) {
-                t.ifError(err3);
-                assertBucket(t, bucket, cfg);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('update bucket (versioned ok 1->2)', function (t) {
-    var cfg = clone(FULL_CFG);
-
-    cfg.options.version = 1;
-    c.createBucket(b, FULL_CFG, function (err) {
-        t.ifError(err);
-        cfg = clone(FULL_CFG);
-        cfg.options.version = 2;
-        cfg.index.foo = {
-            type: 'string',
-            unique: false
-        };
-        cfg.post.push(function two(req, cb) {
-            cb();
-        });
-        c.updateBucket(b, cfg, function (err2) {
-            t.ifError(err2);
-            c.getBucket(b, function (err3, bucket) {
-                t.ifError(err3);
-                assertBucket(t, bucket, cfg);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('update bucket (reindex tracked)', function (t) {
-    var cfg = clone(FULL_CFG);
-
-    cfg.options.version = 1;
-    c.createBucket(b, FULL_CFG, function (err) {
-        t.ifError(err);
-        cfg = clone(FULL_CFG);
-        cfg.options.version = 2;
-        cfg.index.foo = {
-            type: 'string',
-            unique: false
-        };
-        c.updateBucket(b, cfg, function (err2) {
-            t.ifError(err2);
-            c.getBucket(b, function (err3, bucket) {
-                t.ifError(err3);
-                assertBucket(t, bucket, cfg);
-                t.ok(bucket.reindex_active);
-                t.ok(bucket.reindex_active['2']);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('update bucket (reindex disabled)', function (t) {
-    var cfg = clone(FULL_CFG);
-
-    cfg.options.version = 1;
-    c.createBucket(b, FULL_CFG, function (err) {
-        t.ifError(err);
-        cfg = clone(FULL_CFG);
-        cfg.options.version = 2;
-        cfg.index.foo = {
-            type: 'string',
-            unique: false
-        };
-        var opts = {
-            no_reindex: true
-        };
-        c.updateBucket(b, cfg, opts, function (err2) {
-            t.ifError(err2);
-            c.getBucket(b, function (err3, bucket) {
-                t.ifError(err3);
-                assertBucket(t, bucket, cfg);
-                t.notOk(bucket.reindex_active);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('update bucket (null version, reindex disabled)', function (t) {
-    var cfg = clone(FULL_CFG);
-
-    cfg.options.version = 0;
-    c.createBucket(b, FULL_CFG, function (err) {
-        t.ifError(err);
-        cfg = clone(FULL_CFG);
-        cfg.options.version = 0;
-        cfg.index.foo = {
-            type: 'string',
-            unique: false
-        };
-        c.updateBucket(b, cfg, function (err2) {
-            t.ifError(err2);
-            c.getBucket(b, function (err3, bucket) {
-                t.ifError(err3);
-                assertBucket(t, bucket, cfg);
-                t.notOk(bucket.reindex_active);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('update bucket (versioned not ok 1 -> 0)', function (t) {
-    var cfg = clone(FULL_CFG);
-    cfg.options.version = 1;
-
-    c.createBucket(b, cfg, function (err) {
-        t.ifError(err);
-
-        cfg = clone(FULL_CFG);
-        cfg.options.version = 0;
-
-        cfg.index.foo = {
-            type: 'string',
-            unique: false
-        };
-        cfg.post.push(function two(req, cb) {
-            cb();
-        });
-
-        c.updateBucket(b, cfg, function (err2) {
-            t.ok(err2);
-            if (err2) {
-                t.equal(err2.name, 'BucketVersionError');
-                t.ok(err2.message);
-            }
-            t.end();
-        });
-    });
-});
-
-
-test('update bucket (versioned not ok 2 -> 1)', function (t) {
-    var cfg = clone(FULL_CFG);
-    cfg.options.version = 2;
-
-    c.createBucket(b, cfg, function (err) {
-        t.ifError(err);
-
-        cfg = clone(FULL_CFG);
-        cfg.options.version = 1;
-
-        cfg.index.foo = {
-            type: 'string',
-            unique: false
-        };
-        cfg.post.push(function two(req, cb) {
-            cb();
-        });
-
-        c.updateBucket(b, cfg, function (err2) {
-            t.ok(err2);
-            if (err2) {
-                t.equal(err2.name, 'BucketVersionError');
-                t.ok(err2.message);
-            }
-            t.end();
-        });
-    });
-});
-
-
-test('create bucket bad index type', function (t) {
-    c.createBucket(b, {index: {foo: 'foo'}}, function (err) {
-        t.ok(err);
-        t.equal(err.name, 'InvalidBucketConfigError');
-        t.ok(err.message);
-        t.end();
-    });
-});
-
-
-test('create bucket triggers not function', function (t) {
-    c.createBucket(b, {pre: ['foo']}, function (err) {
-        t.ok(err);
-        t.equal(err.name, 'NotFunctionError');
-        t.ok(err.message);
-        t.end();
-    });
-});
-
-
-test('get bucket 404', function (t) {
-    c.getBucket(uuid().substr(0, 7), function (err) {
-        t.ok(err);
-        t.equal(err.name, 'BucketNotFoundError');
-        t.ok(err.message);
-        t.end();
-    });
-});
-
-
-test('delete missing bucket', function (t) {
-    c.delBucket(uuid().substr(0, 7), function (err) {
-        t.ok(err);
-        t.equal(err.name, 'BucketNotFoundError');
-        t.ok(err.message);
-        t.end();
-    });
-});
diff --git a/test/helper.js b/test/helper.js
deleted file mode 100644
index 3d1b92e..0000000
--- a/test/helper.js
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var fs = require('fs');
-
-var bunyan = require('bunyan');
-var moray = require('moray'); // client
-var app = require('../lib');
-
-///--- API
-
-function createLogger(name, stream) {
-    var log = bunyan.createLogger({
-        level: (process.env.LOG_LEVEL || 'warn'),
-        name: name || process.argv[1],
-        stream: stream || process.stdout,
-        src: true,
-        serializers: bunyan.stdSerializers
-    });
-    return (log);
-}
-
-function createClient() {
-    var client = moray.createClient({
-        host: (process.env.MORAY_IP || '127.0.0.1'),
-        port: (parseInt(process.env.MORAY_PORT, 10) || 2020),
-        log: createLogger()
-    });
-    return (client);
-}
-
-function createServer(opts, cb) {
-    opts = opts || {};
-    if (!process.env.MORAY_IP) {
-        var configPath = process.env.MORAY_CONFIG ||
-            __dirname + '/../etc/config.standalone.json';
-        var config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
-        config.log = createLogger('moray-server');
-        if (opts.portOverride !== undefined) {
-            config.port = opts.portOverride;
-        }
-        var server = app.createServer(config);
-        server.once('ready', function () {
-            server.once('listening', cb.bind(null, server));
-            server.listen();
-        });
-    } else {
-        cb(null);
-    }
-}
-
-function cleanupServer(server, cb) {
-    if (server) {
-        server.once('close', cb);
-        server.close();
-    } else {
-        cb();
-    }
-}
-///--- Exports
-
-module.exports = {
-    createLogger: createLogger,
-    createClient: createClient,
-    createServer: createServer,
-    cleanupServer: cleanupServer
-};
diff --git a/test/integ.test.js b/test/integ.test.js
deleted file mode 100644
index 2410669..0000000
--- a/test/integ.test.js
+++ /dev/null
@@ -1,662 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var libuuid = require('libuuid');
-var tape = require('tape');
-var once = require('once');
-var vasync = require('vasync');
-
-var helper = require('./helper.js');
-
-
-
-///--- Globals
-
-var c; // client
-var server;
-var b; // bucket
-
-function test(name, setup) {
-    tape.test(name + ' - setup', function (t) {
-        b = 'moray_unit_test_' + libuuid.create().substr(0, 7);
-        helper.createServer(null, function (s) {
-            server = s;
-            c = helper.createClient();
-            c.on('connect', t.end.bind(t));
-        });
-    });
-
-    tape.test(name + ' - main', function (t) {
-        setup(t);
-    });
-
-    tape.test(name + ' - teardown', function (t) {
-        // May or may not exist, just blindly ignore
-        c.delBucket(b, function () {
-            c.on('close', function () {
-                helper.cleanupServer(server, function () {
-                    t.pass('closed');
-                    t.end();
-                });
-            });
-            c.close();
-        });
-    });
-}
-
-
-///--- Tests
-
-
-test('MANTA-117 single quotes not being escaped', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            name: {
-                type: 'string',
-                unique: true
-            }
-        }
-    };
-    var data = {
-        name: libuuid.create(),
-        chain: [ {
-            name: 'A Task',
-            timeout: 30,
-            retry: 3,
-            body: function (job, cb) {
-                return cb(null);
-            }.toString()
-        }],
-        timeout: 180,
-        onerror: [ {
-            name: 'Fallback task',
-            body: function (job, cb) {
-                return cb('Workflow error');
-            }.toString()
-        }]
-    };
-
-    Object.keys(data).forEach(function (p) {
-        if (typeof (data[p]) === 'object')
-            data[p] = JSON.stringify(data[p]);
-    });
-
-    c.putBucket(b, cfg, function (err1) {
-        t.ifError(err1);
-        c.putObject(b, k, data, function (err2) {
-            t.ifError(err2);
-            c.putObject(b, k, data, function (err3) {
-                t.ifError(err3);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('MANTA-328 numeric values in filters', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            num: {
-                type: 'number'
-            }
-        }
-    };
-    var data = {
-        num: 123
-    };
-
-    c.putBucket(b, cfg, function (err1) {
-        t.ifError(err1);
-        c.putObject(b, k, data, function (err2) {
-            t.ifError(err2);
-            var ok = false;
-            var f = '(num=123)';
-            var req = c.findObjects(b, f);
-            req.once('error', function (err) {
-                t.ifError(err);
-                t.end();
-            });
-            req.once('end', function () {
-                t.ok(ok);
-                t.end();
-            });
-            req.once('record', function (obj) {
-                t.ok(obj);
-                t.equal(obj.bucket, b);
-                t.equal(obj.key, k);
-                t.deepEqual(obj.value, data);
-                t.ok(obj._id);
-                t.ok(obj._etag);
-                t.ok(obj._mtime);
-                ok = true;
-            });
-        });
-    });
-});
-
-
-test('MANTA-328 numeric values in filters <=', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            num: {
-                type: 'number'
-            }
-        }
-    };
-    var data = {
-        num: 425
-    };
-
-    c.putBucket(b, cfg, function (err1) {
-        t.ifError(err1);
-        c.putObject(b, k, data, function (err2) {
-            t.ifError(err2);
-            var ok = false;
-            var f = '(num<=1024)';
-            var req = c.findObjects(b, f);
-            req.once('error', function (err) {
-                t.ifError(err);
-                t.end();
-            });
-            req.once('end', function () {
-                t.ok(ok);
-                t.end();
-            });
-            req.once('record', function (obj) {
-                t.ok(obj);
-                t.equal(obj.bucket, b);
-                t.equal(obj.key, k);
-                t.deepEqual(obj.value, data);
-                t.ok(obj._id);
-                t.ok(obj._etag);
-                t.ok(obj._mtime);
-                ok = true;
-            });
-        });
-    });
-});
-
-
-test('MANTA-328 numeric values in filters >=', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            num: {
-                type: 'number'
-            }
-        }
-    };
-    var data = {
-        num: 425
-    };
-
-    c.putBucket(b, cfg, function (err1) {
-        t.ifError(err1);
-        c.putObject(b, k, data, function (err2) {
-            t.ifError(err2);
-            var ok = false;
-            var f = '(num>=81)';
-            var req = c.findObjects(b, f);
-            req.once('error', function (err) {
-                t.ifError(err);
-                t.end();
-            });
-            req.once('end', function () {
-                t.ok(ok);
-                t.end();
-            });
-            req.once('record', function (obj) {
-                t.ok(obj);
-                t.equal(obj.bucket, b);
-                t.equal(obj.key, k);
-                t.deepEqual(obj.value, data);
-                t.ok(obj._id);
-                t.ok(obj._etag);
-                t.ok(obj._mtime);
-                ok = true;
-            });
-        });
-    });
-});
-
-
-test('MANTA-170 bogus filter', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            num: {
-                type: 'number'
-            }
-        }
-    };
-    var data = {
-        num: 425
-    };
-
-    c.putBucket(b, cfg, function (err1) {
-        t.ifError(err1);
-        c.putObject(b, k, data, function (err2) {
-            t.ifError(err2);
-            var f = '(num>81)';
-            var req = c.findObjects(b, f);
-            req.once('error', function (err) {
-                t.end();
-            });
-            req.once('end', function () {
-                t.ok(false);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('MANTA-680 boolean searches', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            b: {
-                type: 'boolean'
-            }
-        }
-    };
-    var data = {
-        b: true
-    };
-
-    c.putBucket(b, cfg, function (err1) {
-        t.ifError(err1);
-        c.putObject(b, k, data, function (err2) {
-            t.ifError(err2);
-            var f = '(b=true)';
-            var req = c.findObjects(b, f);
-            var ok = false;
-            req.once('record', function () {
-                ok = true;
-            });
-            req.once('end', function () {
-                t.ok(ok);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('some marlin query', function (t) {
-    var cfg = {
-        index: {
-            foo: {
-                type: 'string'
-            },
-            bar: {
-                type: 'string'
-            },
-            baz: {
-                type: 'string'
-            }
-        }
-    };
-    var found = false;
-
-    vasync.pipeline({
-        funcs: [
-            function bucket(_, cb) {
-                c.putBucket(b, cfg, cb);
-            },
-            function objects(_, cb) {
-                cb = once(cb);
-
-                var done = 0;
-                function _cb(err) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-                    if (++done === 10)
-                        cb();
-                }
-                for (var i = 0; i < 10; i++) {
-                    var data = {
-                        foo: '' + i,
-                        bar: '' + i,
-                        baz: '' + i
-                    };
-                    c.putObject(b, libuuid.create(), data, _cb);
-                }
-            },
-            function find(_, cb) {
-                cb = once(cb);
-                var f = '(&(!(|(foo=0)(foo=1)))(bar=8)(baz=8))';
-                var req = c.findObjects(b, f);
-                req.once('error', cb);
-                req.once('record', function (obj) {
-                    t.ok(obj);
-                    t.equal(obj.value.foo, '8');
-                    t.equal(obj.value.bar, '8');
-                    t.equal(obj.value.baz, '8');
-                    found = true;
-                });
-                req.once('end', cb);
-            }
-        ],
-        arg: null
-    }, function (err) {
-        t.ifError(err);
-        t.ok(found);
-        t.end();
-    });
-});
-
-
-test('MANTA-1726 batch+deleteMany+limit', function (t) {
-
-    vasync.pipeline({
-        funcs: [
-            function bucket(_, cb) {
-                var cfg = {
-                    index: {
-                        n: {
-                            type: 'number'
-                        }
-                    }
-                };
-                c.putBucket(b, cfg, once(cb));
-            },
-            function writeObjects(_, cb) {
-                cb = once(cb);
-
-                var done = 0;
-                for (var i = 0; i < 100; i++) {
-                    c.putObject(b, libuuid.create(), {n: i}, function (err) {
-                        if (err) {
-                            cb(err);
-                        } else if (++done === 100) {
-                            cb();
-                        }
-                    });
-                }
-            },
-            function batchDeleteMany(_, cb) {
-                cb = once(cb);
-
-                c.batch([
-                    {
-                        operation: 'deleteMany',
-                        bucket: b,
-                        filter: 'n>=0',
-                        options: {
-                            limit: 50
-                        }
-                    }
-                ], function (err, meta) {
-                    if (err) {
-                        cb(err);
-                    } else {
-                        t.ok(meta);
-                        meta = meta || {};
-                        t.ok((meta || {}).etags);
-                        meta.etags = meta.etags || [];
-                        t.ok(meta.etags.length);
-                        if (meta.etags.length)
-                            t.equal(meta.etags[0].count, 50);
-                        cb();
-                    }
-                });
-            }
-        ],
-        arg: null
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('MANTA-1726 batch+update+limit', function (t) {
-
-    vasync.pipeline({
-        funcs: [
-            function bucket(_, cb) {
-                var cfg = {
-                    index: {
-                        n: {
-                            type: 'number'
-                        }
-                    }
-                };
-                c.putBucket(b, cfg, once(cb));
-            },
-            function writeObjects(_, cb) {
-                cb = once(cb);
-
-                var done = 0;
-                for (var i = 0; i < 100; i++) {
-                    c.putObject(b, libuuid.create(), {n: i}, function (err) {
-                        if (err) {
-                            cb(err);
-                        } else if (++done === 100) {
-                            cb();
-                        }
-                    });
-                }
-            },
-            function batchUpdateMany(_, cb) {
-                cb = once(cb);
-
-                c.batch([
-                    {
-                        operation: 'update',
-                        bucket: b,
-                        filter: 'n>=0',
-                        options: {
-                            limit: 50
-                        },
-                        fields: {
-                            n: 10000
-                        }
-                    }
-                ], function (err, meta) {
-                    if (err) {
-                        cb(err);
-                    } else {
-                        t.ok(meta);
-                        meta = meta || {};
-                        t.ok((meta || {}).etags);
-                        meta.etags = meta.etags || [];
-                        t.ok(meta.etags.length);
-                        if (meta.etags.length)
-                            t.equal(meta.etags[0].count, 50);
-                        cb();
-                    }
-                });
-            }
-        ],
-        arg: null
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('MORAY-131 case insensitive match', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            str: {
-                type: 'string'
-            }
-        }
-    };
-    var data = {
-        str: 'MaRk'
-    };
-
-    c.putBucket(b, cfg, function (err1) {
-        t.ifError(err1);
-        c.putObject(b, k, data, function (err2) {
-            t.ifError(err2);
-            var f = '(str:caseIgnoreMatch:=mark)';
-            var req = c.findObjects(b, f);
-            var ok = false;
-            req.once('record', function () {
-                ok = true;
-            });
-            req.once('end', function () {
-                t.ok(ok);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('MORAY-131 case insensitive substrings match', function (t) {
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            str: {
-                type: 'string'
-            }
-        }
-    };
-    var data = {
-        str: 'MaRk'
-    };
-
-    c.putBucket(b, cfg, function (err1) {
-        t.ifError(err1);
-        c.putObject(b, k, data, function (err2) {
-            t.ifError(err2);
-            var f = '(str:caseIgnoreSubstringsMatch:=m*r*)';
-            var req = c.findObjects(b, f);
-            var ok = false;
-            req.once('record', function () {
-                ok = true;
-            });
-            req.once('end', function () {
-                t.ok(ok);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('MORAY-322 bucketCache shootdown during update', function (t) {
-    var server2;
-    var c2;
-    var k = libuuid.create();
-    var cfg = {
-        index: {
-            num: {
-                type: 'number'
-            }
-        },
-        options: {
-            version: 1
-        }
-    };
-
-    vasync.pipeline({
-        funcs: [
-            function setupServer(_, cb) {
-                cb = once(cb);
-                var opts = {
-                    portOverride: 2021
-                };
-                helper.createServer(opts, function (s) {
-                    server2 = s;
-                    c2 = helper.createClient();
-                    c2.once('error', cb);
-                    c2.once('connect', cb);
-                });
-            },
-            function setupBucket(_, cb) {
-                c.putBucket(b, cfg, cb);
-            },
-            function insert(_, cb) {
-                var data = {
-                    num: 10,
-                    new_num: 20
-                };
-                c.putObject(b, k, data, cb);
-            },
-            function primeCache(_, cb) {
-                c2.getObject(b, k, cb);
-            },
-            function bucketUpdate(_, cb) {
-                cfg.options.version = 2;
-                cfg.index.new_num = {
-                    type: 'number'
-                };
-                c.updateBucket(b, cfg, cb);
-            },
-            function reindexRow(_, cb) {
-                c.reindexObjects(b, 100, function (err, res) {
-                    t.ifError(err);
-                    t.equal(res.processed, 1);
-                    c.reindexObjects(b, 100, function (err2, res2) {
-                        t.ifError(err2);
-                        t.equal(res2.processed, 0);
-                        cb();
-                    });
-                });
-            },
-            function checkLocalIndex(_, cb) {
-                var filter = '(new_num=20)';
-                var found = 0;
-                var res = c.findObjects(b, filter, {});
-                res.on('error', cb);
-                res.on('record', function () {
-                    found++;
-                });
-                res.on('end', function () {
-                    t.equal(found, 1);
-                    cb();
-                });
-            },
-            function updateRow(_, cb) {
-                var data = {
-                    num: 10,
-                    new_num: 30
-                };
-                c2.putObject(b, k, data, cb);
-            },
-            function checkRemoteIndex(_, cb) {
-                cb = once(cb);
-                var filter = '(new_num=30)';
-                var found = 0;
-                var res = c2.findObjects(b, filter, {});
-                res.on('error', cb);
-                res.on('record', function () {
-                    found++;
-                });
-                res.on('end', function () {
-                    t.equal(found, 1);
-                    cb();
-                });
-            }
-        ],
-        arg: null
-    }, function (err, results) {
-        t.ifError(err);
-        c2.on('close', function () {
-            server2.close();
-        });
-        c2.close();
-        t.end();
-    });
-});
diff --git a/test/load/load.js b/test/load/load.js
deleted file mode 100644
index abe996d..0000000
--- a/test/load/load.js
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var assert = require('assert-plus');
-var bunyan = require('bunyan');
-var libuuid = require('libuuid');
-var moray = require('moray');
-
-
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-        level: (process.env.LOG_LEVEL || 'warn'),
-        name: 'moray_load_test',
-        stream: process.stdout,
-        src: true,
-        serializers: bunyan.stdSerializers
-});
-
-var CLIENT = moray.createClient({
-        host: (process.env.MORAY_IP || '127.0.0.1'),
-        port: (process.env.MORAY_PORT || 2020),
-        log: LOG
-});
-CLIENT.once('connect', main);
-
-var BNAME = 'moray_load_test';
-var SCHEMA = {
-        foo: { type: 'string' },
-        bar: { type: 'string', unique: true }
-};
-
-
-
-///--- Runners
-
-function put(i, cb) {
-        var k = libuuid.create().substr(0, 7);
-        var v = {
-                foo: libuuid.create(),
-                bar: libuuid.create()
-        };
-        CLIENT.putObject(BNAME, k, v, function (put_err, meta) {
-                if (put_err) {
-                        LOG.warn(put_err, 'putObject: failed');
-                        put(++i, cb);
-                        return;
-                }
-
-                CLIENT.getObject(BNAME, k, meta, function (get_err) {
-                        if (get_err)
-                                LOG.warn(get_err, 'getObject: failed');
-
-                        put(++i, cb);
-                });
-        });
-}
-
-
-
-
-///--- Mainline
-// Invoked only once the client is connected
-
-function main() {
-        CLIENT.putBucket(BNAME, SCHEMA, function (b_err) {
-                assert.ifError(b_err);
-
-                var done = 0;
-                function cb() {
-                        if (++done === 250)
-                                main();
-                }
-
-                for (var i = 0; i < 250; i++)
-                        put(1, cb);
-        });
-}
\ No newline at end of file
diff --git a/test/load/loop_and_kill.sh b/test/load/loop_and_kill.sh
deleted file mode 100755
index fc80975..0000000
--- a/test/load/loop_and_kill.sh
+++ /dev/null
@@ -1,20 +0,0 @@
-#
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-#
-
-#
-# Copyright (c) 2014, Joyent, Inc.
-#
-
-ctrl_c () {
-    echo ""
-    exit
-}
-
-trap ctrl_c SIGINT
-
-while [ true ] ; do
-    putobject -d '{"foo": "bar"}' foo bar ; getobject -s foo bar
-done
diff --git a/test/load/manta1027.js b/test/load/manta1027.js
deleted file mode 100644
index 9e2e889..0000000
--- a/test/load/manta1027.js
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var assert = require('assert');
-var bunyan = require('bunyan');
-var cluster = require('cluster');
-var moray = require('moray');
-
-assert.ok(process.env.MORAY_URL, 'specify MORAY_URL');
-
-var numCPUs = require('os').cpus().length;
-if (cluster.isMaster) {
-        // Fork workers.
-        for (var i = 0; i < numCPUs; i++) {
-                cluster.fork();
-        }
-
-        cluster.on('exit', function (worker, code, signal) {
-                console.log('worker ' + worker.process.pid + ' died');
-        });
-} else {
-        var client = moray.createClient({
-                log: bunyan.createLogger({
-                        level: 'warn',
-                        name: 'manta1027',
-                        stream: process.stdout,
-                        serializers: bunyan.stdSerializers
-                }),
-                url: process.env.MORAY_URL
-        });
-
-        client.once('connect', function () {
-                function put() {
-                        client.putObject('manta', '1027', {}, function (err) {
-                                if (err) {
-                                        console.error(err.stack);
-                                }
-                                put(i);
-                        });
-                }
-
-                var max = parseInt(process.env.MANTA1027_CONCURRENCY || 20, 10);
-                console.log('running...');
-                for (var ii = 0; ii < max; ii++) {
-                        put();
-                }
-        });
-}
diff --git a/test/objects.test.js b/test/objects.test.js
deleted file mode 100644
index cac72a8..0000000
--- a/test/objects.test.js
+++ /dev/null
@@ -1,2115 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2016, Joyent, Inc.
- */
-
-var clone = require('clone');
-var tape = require('tape');
-var once = require('once');
-var libuuid = require('libuuid');
-var vasync = require('vasync');
-var util = require('util');
-var net = require('net');
-
-var helper = require('./helper.js');
-
-
-
-///--- Globals
-
-var uuid = {
-    v1: libuuid.create,
-    v4: libuuid.create
-};
-
-var BUCKET_CFG = {
-    index: {
-        str: {
-            type: 'string'
-        },
-        str_u: {
-            type: 'string',
-            unique: true
-        },
-        str_2: {
-            type: 'string'
-        },
-        num: {
-            type: 'number'
-        },
-        num_u: {
-            type: 'number',
-            unique: true
-        },
-        bool: {
-            type: 'boolean'
-        },
-        bool_u: {
-            type: 'boolean',
-            unique: true
-        },
-        ip: {
-            type: 'ip'
-        },
-        ip_u: {
-            type: 'ip',
-            unique: true
-        },
-        subnet: {
-            type: 'subnet'
-        },
-        subnet_u: {
-            type: 'subnet',
-            unique: true
-        }
-    },
-    pre: [function (req, cb) {
-        var v = req.value;
-        if (v.pre)
-            v.pre = 'pre_overwrite';
-
-        cb();
-    }],
-    post: [function (req, cb) {
-        cb();
-    }],
-    options: {
-        version: 1,
-        trackModification: true,
-        guaranteeOrder: true
-    }
-};
-
-var c; // client
-var server;
-var b; // bucket
-
-function test(name, setup) {
-    tape.test(name + ' - setup', function (t) {
-        b = 'moray_unit_test_' + uuid.v4().substr(0, 7);
-        helper.createServer(null, function (s) {
-            server = s;
-            c = helper.createClient();
-            c.on('connect', function () {
-                c.createBucket(b, BUCKET_CFG, function (err) {
-                    t.ifError(err);
-                    t.end();
-                });
-            });
-        });
-    });
-
-    tape.test(name + ' - main', function (t) {
-        setup(t);
-    });
-
-    tape.test(name + ' - teardown', function (t) {
-        c.delBucket(b, function (err) {
-            t.ifError(err);
-            c.once('close', function () {
-                helper.cleanupServer(server, function () {
-                    t.pass('closed');
-                    t.end();
-                });
-            });
-            c.close();
-        });
-    });
-}
-
-
-///--- Helpers
-
-function assertObject(t, obj, k, v) {
-    t.ok(obj);
-    if (!obj)
-        return (undefined);
-
-    t.equal(obj.bucket, b);
-    t.equal(obj.key, k);
-    t.deepEqual(obj.value, v);
-    t.ok(obj._id);
-    t.ok(obj._etag);
-    t.ok(obj._mtime);
-    if (v.vnode) {
-        t.ok(obj.value.vnode);
-    }
-    return (undefined);
-}
-
-///--- Tests
-
-test('get object 404', function (t) {
-    c.getObject(b, uuid.v4().substr(0, 7), function (err) {
-        t.ok(err);
-        t.equal(err.name, 'ObjectNotFoundError');
-        t.ok(err.message);
-        t.end();
-    });
-});
-
-
-test('del object 404', function (t) {
-    c.delObject(b, uuid.v4().substr(0, 7), function (err) {
-        t.ok(err);
-        t.equal(err.name, 'ObjectNotFoundError');
-        t.ok(err.message);
-        t.end();
-    });
-});
-
-
-test('CRUD object', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hi',
-        vnode: 2
-    };
-    var v2 = {
-        str: 'hello world',
-        pre: 'hi'
-    };
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, function (err, meta) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(meta);
-                if (meta)
-                    t.ok(meta.etag);
-                return (cb());
-            });
-        }, function get(_, cb) {
-            c.getObject(b, k, function (err, obj) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(obj);
-                assertObject(t, obj, k, v);
-                return (cb());
-            });
-        }, function overwrite(_, cb) {
-            c.putObject(b, k, v2, cb);
-        }, function getAgain(_, cb) {
-            c.getObject(b, k, {noCache: true}, function (err, obj) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(obj);
-                v2.pre = 'pre_overwrite';
-                assertObject(t, obj, k, v2);
-                return (cb());
-            });
-        }, function del(_, cb) {
-            c.delObject(b, k, cb);
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('get object (cached)', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hi'
-    };
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, function (err, meta) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(meta);
-                if (meta)
-                    t.ok(meta.etag);
-                return (cb());
-            });
-        }, function get(_, cb) {
-            c.getObject(b, k, function (err, obj) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(obj);
-                assertObject(t, obj, k, v);
-                return (cb());
-            });
-        }, function getAgain(_, cb) {
-            c.getObject(b, k, function (err, obj) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(obj);
-                assertObject(t, obj, k, v);
-                return (cb());
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('CRUD objects unique indexes', function (t) {
-    var k = uuid.v4();
-    var k2 = uuid.v4();
-    var v = {
-        str_u: 'hi'
-    };
-    var v2 = {
-        str_u: 'hi'
-    };
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function putFail(_, cb) {
-            c.putObject(b, k2, v2, function (err) {
-                t.ok(err);
-                t.equal(err.name, 'UniqueAttributeError');
-                cb();
-            });
-        }, function delK1(_, cb) {
-            c.delObject(b, k, cb);
-        }, function putK2(_, cb) {
-            c.putObject(b, k2, v2, cb);
-        }, function delK2(_, cb) {
-            c.delObject(b, k2, cb);
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('put object w/etag ok', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hi'
-    };
-    var v2 = {
-        str: 'hello world'
-    };
-    var etag;
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function get(_, cb) {
-            c.getObject(b, k, function (err, obj) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(obj);
-                assertObject(t, obj, k, v);
-                etag = obj._etag;
-                return (cb());
-            });
-        }, function overwrite(_, cb) {
-            c.putObject(b, k, v2, {etag: etag}, cb);
-        }, function getAgain(_, cb) {
-            c.getObject(b, k, {noCache: true}, function (err, obj) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(obj);
-                assertObject(t, obj, k, v2);
-                return (cb());
-            });
-        }, function del(_, cb) {
-            c.delObject(b, k, cb);
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('del object w/etag ok', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hi'
-    };
-    var etag;
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function get(_, cb) {
-            c.getObject(b, k, function (err, obj) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(obj);
-                assertObject(t, obj, k, v);
-                etag = obj._etag;
-                return (cb());
-            });
-        }, function del(_, cb) {
-            c.delObject(b, k, {etag: etag}, cb);
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('put object w/etag conflict', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hi'
-    };
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function overwrite(_, cb) {
-            c.putObject(b, k, {}, {etag: 'foo'}, function (err) {
-                t.ok(err);
-                if (err)
-                    t.equal(err.name, 'EtagConflictError');
-                cb();
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-
-        t.end();
-    });
-});
-
-
-test('del object w/etag conflict', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hi'
-    };
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function drop(_, cb) {
-            c.delObject(b, k, {etag: 'foo'}, function (err) {
-                t.ok(err);
-                if (err) {
-                    t.equal(err.name, 'EtagConflictError');
-                    t.ok(err.context);
-                    if (err.context) {
-                        var ctx = err.context;
-                        t.equal(ctx.bucket, b);
-                        t.equal(ctx.key, k);
-                        t.equal(ctx.expected, 'foo');
-                        t.ok(ctx.actual);
-                    }
-                }
-                cb();
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-
-        t.end();
-    });
-});
-
-
-test('MANTA-980 - null etag support', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hi'
-    };
-    var v2 = {
-        str: 'hello world'
-    };
-    var etag;
-    var value;
-
-    function get_cb(cb) {
-        function _cb(err, obj) {
-            if (err) {
-                cb(err);
-                return;
-            }
-
-            t.ok(obj);
-            if (obj) {
-                assertObject(t, obj, k, value);
-                etag = obj._etag;
-            }
-            cb();
-        }
-        return (_cb);
-    }
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            value = v;
-            c.putObject(b, k, value, {etag: null}, cb);
-        }, function get(_, cb) {
-            c.getObject(b, k, get_cb(cb));
-        }, function overwrite(_, cb) {
-            value = v2;
-            c.putObject(b, k, value, {etag: etag}, cb);
-        }, function getAgain(_, cb) {
-            c.getObject(b, k, {noCache: true}, get_cb(cb));
-        }, function putFail(_, cb) {
-            c.putObject(b, k, v, {etag: null}, function (err) {
-                t.ok(err);
-                if (err) {
-                    t.equal(err.name, 'EtagConflictError');
-                    t.ok(err.context);
-                    t.equal(err.context.bucket, b);
-                    t.equal(err.context.key, k);
-                    t.equal(err.context.expected, 'null');
-                    t.equal(err.context.actual, etag);
-                }
-                cb();
-            });
-        }, function del(_, cb) {
-            c.delObject(b, k, {etag: etag}, cb);
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('find (like marlin)', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hello',
-        str_2: 'world'
-    };
-    var found = false;
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function find(_, cb) {
-            var f = '(&(str=hello)(!(str_2=usa)))';
-            var req = c.findObjects(b, f);
-            req.once('error', cb);
-            req.once('end', cb);
-            req.once('record', function (obj) {
-                t.ok(obj);
-                if (!obj)
-                    return (undefined);
-
-                t.equal(obj.bucket, b);
-                t.equal(obj.key, k);
-                t.deepEqual(obj.value, v);
-                t.ok(obj._id);
-                t.ok(obj._count);
-                t.equal(typeof (obj._count), 'number');
-                t.ok(obj._etag);
-                t.ok(obj._mtime);
-                found = true;
-                return (undefined);
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.ok(found);
-        t.end();
-    });
-});
-
-
-test('find _mtime', function (t) {
-    var k = uuid.v4();
-    var now = Date.now();
-    var v = {
-        str: 'hello',
-        str_2: 'world'
-    };
-    var found = false;
-
-    vasync.pipeline({
-        funcs: [ function wait(_, cb) {
-            /* this is sensitive to clock skew between hosts */
-            setTimeout(cb, 1000);
-        }, function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function find(_, cb) {
-            var f = '(_mtime>=' + now + ')';
-            var req = c.findObjects(b, f);
-            req.once('error', cb);
-            req.once('end', cb);
-            req.once('record', function (obj) {
-                t.ok(obj);
-                if (!obj)
-                    return (undefined);
-
-                t.equal(obj.bucket, b);
-                t.equal(obj.key, k);
-                t.deepEqual(obj.value, v);
-                t.ok(obj._id);
-                t.ok(obj._etag);
-                t.ok(obj._mtime);
-                found = true;
-                return (undefined);
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.ok(found);
-        t.end();
-    });
-});
-
-
-test('find _key', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hello',
-        str_2: 'world'
-    };
-    var found = false;
-
-    vasync.pipeline({
-        funcs: [ function wait(_, cb) {
-            setTimeout(cb, 500);
-        }, function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function find(_, cb) {
-            var f = '(_key=' + k + ')';
-            var req = c.findObjects(b, f);
-            req.once('error', cb);
-            req.once('end', cb);
-            req.once('record', function (obj) {
-                t.ok(obj);
-                if (!obj)
-                    return (undefined);
-
-                t.equal(obj.bucket, b);
-                t.equal(obj.key, k);
-                t.deepEqual(obj.value, v);
-                t.ok(obj._id);
-                t.ok(obj._etag);
-                t.ok(obj._mtime);
-                found = true;
-                return (undefined);
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.ok(found);
-        t.end();
-    });
-});
-
-
-test('find MANTA-156', function (t) {
-    var k = uuid.v4();
-    var v = {
-        num: 0,
-        num_u: 1
-    };
-    var found = false;
-
-    vasync.pipeline({
-        funcs: [ function wait(_, cb) {
-            setTimeout(cb, 500);
-        }, function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function find(_, cb) {
-            var f = '(num>=0)';
-            var req = c.findObjects(b, f);
-            req.once('error', cb);
-            req.once('end', cb);
-            req.once('record', function (obj) {
-                t.ok(obj);
-                if (!obj)
-                    return (undefined);
-
-                t.equal(obj.bucket, b);
-                t.equal(obj.key, k);
-                t.deepEqual(obj.value, v);
-                t.ok(obj._id);
-                t.ok(obj._etag);
-                t.ok(obj._mtime);
-                found = true;
-                return (undefined);
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.ok(found);
-        t.end();
-    });
-});
-
-
-test('non-indexed AND searches (MANTA-317)', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hello',
-        cow: 'moo'
-    };
-    var found = false;
-
-    vasync.pipeline({
-        funcs: [ function wait(_, cb) {
-            setTimeout(cb, 500);
-        }, function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function find(_, cb) {
-            var f = '(&(str=hello)(!(cow=woof)))';
-            var req = c.findObjects(b, f);
-            req.once('error', cb);
-            req.once('end', cb);
-            req.once('record', function (obj) {
-                t.ok(obj);
-                if (!obj)
-                    return (undefined);
-
-                t.equal(obj.bucket, b);
-                t.equal(obj.key, k);
-                t.deepEqual(obj.value, v);
-                t.ok(obj._id);
-                t.ok(obj._etag);
-                t.ok(obj._mtime);
-                found = true;
-                return (undefined);
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.ok(found);
-        t.end();
-    });
-});
-
-
-test('_txn_snap on update', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hi'
-    };
-    var txn;
-
-    vasync.pipeline({
-        funcs: [ function create(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function getOne(_, cb) {
-            c.getObject(b, k, {noCache: true}, function (err, obj) {
-                if (err) {
-                    cb(err);
-                } else {
-                    t.ok(obj);
-                    assertObject(t, obj, k, v);
-                    t.ok(obj._txn_snap);
-                    txn = obj._txn_snap;
-                    cb();
-                }
-            });
-        }, function update(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function getTwo(_, cb) {
-            c.getObject(b, k, {noCache: true}, function (err, obj) {
-                if (err) {
-                    cb(err);
-                } else {
-                    t.ok(obj);
-                    assertObject(t, obj, k, v);
-                    t.ok(obj._txn_snap);
-                    t.notEqual(txn, obj._txn_snap);
-                    t.ok(obj._txn_snap > txn);
-                    cb();
-                }
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-
-        t.end();
-    });
-});
-
-
-test('find _txn_snap', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hello',
-        str_2: 'world'
-    };
-    var found = false;
-
-    vasync.pipeline({
-        funcs: [ function wait(_, cb) {
-            setTimeout(cb, 500);
-        }, function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function find(_, cb) {
-            var f = '(&(_txn_snap>=1)(_id>=1))';
-            var req = c.findObjects(b, f);
-            req.once('error', cb);
-            req.once('end', cb);
-            req.once('record', function (obj) {
-                t.ok(obj);
-                if (!obj)
-                    return (undefined);
-
-                t.equal(obj.bucket, b);
-                t.equal(obj.key, k);
-                t.deepEqual(obj.value, v);
-                t.ok(obj._id);
-                t.ok(obj._etag);
-                t.ok(obj._mtime);
-                t.ok(obj._txn_snap);
-                found = true;
-                return (undefined);
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.ok(found);
-        t.end();
-    });
-});
-
-
-
-test('trackModification (MANTA-269)', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hi'
-    };
-    var id1;
-
-    vasync.pipeline({
-        funcs: [ function create(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function getOne(_, cb) {
-            c.getObject(b, k, {noCache: true}, function (err, obj) {
-                if (err) {
-                    cb(err);
-                } else {
-                    t.ok(obj);
-                    assertObject(t, obj, k, v);
-                    id1 = obj._id;
-                    cb();
-                }
-            });
-        }, function update(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function getTwo(_, cb) {
-            c.getObject(b, k, {noCache: true}, function (err, obj) {
-                if (err) {
-                    cb(err);
-                } else {
-                    t.ok(obj);
-                    assertObject(t, obj, k, v);
-                    t.notEqual(id1, obj._id);
-                    cb();
-                }
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-
-        t.end();
-    });
-});
-
-
-test('batch put objects', function (t) {
-    var requests = [
-        {
-            bucket: b,
-            key: uuid.v4(),
-            value: {
-                foo: 'bar'
-            }
-        },
-        {
-            bucket: b,
-            key: uuid.v4(),
-            value: {
-                bar: 'baz'
-            }
-        }
-    ];
-
-    c.batch(requests, function (err, meta) {
-        t.ifError(err);
-        t.ok(meta);
-        if (meta) {
-            t.ok(meta.etags);
-            if (meta.etags) {
-                t.ok(Array.isArray(meta.etags));
-                t.equal(meta.etags.length, 2);
-                meta.etags.forEach(function (e) {
-                    t.equal(b, e.bucket);
-                    t.ok(e.key);
-                    t.ok(e.etag);
-                });
-            }
-        }
-        c.getObject(b, requests[0].key, function (er2, obj) {
-            t.ifError(er2);
-            t.ok(obj);
-            if (obj)
-                t.deepEqual(obj.value, requests[0].value);
-
-            var r = requests[1];
-            c.getObject(b, r.key, function (err3, obj2) {
-                t.ifError(err3);
-                t.ok(obj2);
-                if (obj2)
-                    t.deepEqual(obj2.value, r.value);
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('batch put with bad _value', function (t) {
-    // In a future node-moray, this shouldn't even be possible, but for now it
-    // needs to be dealt with.
-    var k = uuid.v4();
-    var requests = [
-        {
-            bucket: b,
-            key: k,
-            value: {
-                foo: 'bar'
-            },
-            options: {
-                _value: '{"this":"is", "bs":[}'
-            }
-        }
-    ];
-
-    vasync.pipeline({
-        funcs: [
-            function prepBucket(_, cb) {
-                var cfg = clone(BUCKET_CFG);
-                // Simplify test by removing pre/post bucket actions
-                // (Required for positive verification)
-                delete cfg.pre;
-                delete cfg.post;
-                cfg.options.version = 2;
-                c.updateBucket(b, cfg, cb);
-            },
-            function put(_, cb) {
-                c.batch(requests, cb);
-            },
-            function checkValid(_, cb) {
-                c.getObject(b, k, cb);
-            },
-            function cleanup(_, cb) {
-                c.delObject(b, k, cb);
-            }
-        ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('batch delete object', function (t) {
-    var k = uuid.v4();
-    var v = { str: 'hi' };
-    var requests = [
-        {
-            operation: 'delete',
-            bucket: b,
-            key: k
-        }
-    ];
-
-    vasync.pipeline({
-        funcs: [
-            function put(_, cb) {
-                c.putObject(b, k, v, cb);
-            },
-            function checkPresent(_, cb) {
-                c.getObject(b, k, cb);
-            },
-            function batchDel(_, cb) {
-                c.batch(requests, cb);
-            },
-            function checkGone(_, cb) {
-                c.getObject(b, k, function (err) {
-                    t.ok(err);
-                    t.equal(err.name, 'ObjectNotFoundError');
-                    t.ok(err.message);
-                    cb();
-                });
-            }
-        ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-
-        t.end();
-    });
-});
-
-
-test('update objects no keys', function (t) {
-    var requests = [];
-    for (var i = 0; i < 10; i++) {
-        requests.push({
-            bucket: b,
-            key: uuid.v4().substr(0, 7),
-            value: {
-                num: 20,
-                num_u: i,
-                str: 'foo',
-                str_u: uuid.v4().substr(0, 7)
-            }
-        });
-    }
-
-    c.batch(requests, function (put_err) {
-        t.ifError(put_err);
-        if (put_err) {
-            t.end();
-            return;
-        }
-
-        c.updateObjects(b, {}, '(num>=20)', function (err) {
-            t.ok(err);
-            t.equal(err.name, 'FieldUpdateError');
-            t.end();
-        });
-    });
-});
-
-
-test('update objects ok', function (t) {
-    var requests = [];
-    for (var i = 0; i < 10; i++) {
-        requests.push({
-            bucket: b,
-            key: uuid.v4().substr(0, 7),
-            value: {
-                num: 20,
-                num_u: i,
-                str: 'foo',
-                str_u: uuid.v4().substr(0, 7)
-            }
-        });
-    }
-
-    c.batch(requests, function (put_err) {
-        t.ifError(put_err);
-        if (put_err) {
-            t.end();
-            return;
-        }
-
-        var fields = {str: 'bar'};
-        c.updateObjects(b, fields, '(num>=20)', function (err, meta) {
-            t.ifError(err);
-            t.ok(meta);
-            if (!meta) {
-                t.end();
-                return;
-            }
-            t.ok(meta.etag);
-
-            c.getObject(b, requests[0].key, function (err2, obj) {
-                t.ifError(err2);
-                t.ok(obj);
-                if (obj) {
-                    t.equal(obj.value.str, 'bar');
-                    t.equal(obj._etag, meta.etag);
-                }
-
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('update objects w/array (ufds - no effect)', function (t) {
-    var requests = [];
-    for (var i = 0; i < 10; i++) {
-        requests.push({
-            bucket: b,
-            key: uuid.v4().substr(0, 7),
-            value: {
-                str: ['foo']
-            }
-        });
-    }
-
-    c.batch(requests, function (put_err) {
-        t.ifError(put_err);
-        if (put_err) {
-            t.end();
-            return;
-        }
-
-        var fields = {str: 'bar'};
-        c.updateObjects(b, fields, '(str=foo)', function (err, meta) {
-            t.ifError(err);
-            t.ok(meta);
-            if (!meta) {
-                t.end();
-                return;
-            }
-            t.ok(meta.etag);
-
-            var k = requests[0].key;
-            var o = {noCache: true};
-            c.getObject(b, k, o, function (err2, obj) {
-                t.ifError(err2);
-                t.ok(obj);
-                if (obj) {
-                    t.ok(Array.isArray(obj.value.str));
-                    t.notOk(obj.value.str_u);
-                    t.equal(obj.value.str[0], 'foo');
-                    t.equal(obj._etag, meta.etag);
-                }
-
-                t.end();
-            });
-        });
-    });
-});
-
-
-test('batch put/update', function (t) {
-    var requests = [];
-    for (var i = 0; i < 10; i++) {
-        requests.push({
-            bucket: b,
-            key: uuid.v4().substr(0, 7),
-            value: {
-                num: 20,
-                num_u: i,
-                str: 'foo',
-                str_u: uuid.v4().substr(0, 7)
-            }
-        });
-    }
-
-    c.batch(requests, function (init_err) {
-        t.ifError(init_err);
-
-        var ops = [
-            {
-                bucket: b,
-                key: requests[0].key,
-                value: {
-                    num: 10,
-                    str: 'baz'
-                }
-            },
-            {
-                bucket: b,
-                operation: 'update',
-                fields: {
-                    str: 'bar'
-                },
-                filter: '(num_u>=5)'
-            }
-        ];
-        c.batch(ops, function (err, meta) {
-            t.ifError(err);
-            t.ok(meta);
-            t.ok(meta.etags);
-            var req = c.findObjects(b, '(num_u>=0)');
-            req.once('error', function (e) {
-                t.ifError(e);
-                t.end();
-            });
-            req.once('end', function () {
-                t.end();
-            });
-            req.on('record', function (r) {
-                t.equal(r.bucket, b);
-                t.ok(r.key);
-                var v = r.value;
-                if (v.num_u >= 5) {
-                    t.equal(v.str, 'bar');
-                } else if (r.key === requests[0].key) {
-                    t.equal(v.str, 'baz');
-                } else {
-                    t.equal(v.str, 'foo');
-                }
-            });
-        });
-    });
-});
-
-
-test('delete many objects ok', function (t) {
-    var requests = [];
-    for (var i = 0; i < 10; i++) {
-        requests.push({
-            bucket: b,
-            key: uuid.v4().substr(0, 7),
-            value: {
-                num: 20,
-                num_u: i,
-                str: 'foo',
-                str_u: uuid.v4().substr(0, 7)
-            }
-        });
-    }
-
-    c.batch(requests, function (put_err) {
-        t.ifError(put_err);
-        if (put_err) {
-            t.end();
-            return;
-        }
-
-        c.deleteMany(b, '(num>=20)', function (err) {
-            t.ifError(err);
-            t.end();
-        });
-    });
-});
-
-test('get tokens unsupported', function (t) {
-    c.getTokens(function (err, res) {
-        t.notOk(res);
-        t.ok(err);
-        t.end();
-    });
-});
-
-
-test('MORAY-147 (sqli)', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hello',
-        str_2: 'world'
-    };
-    var found = false;
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function find(_, cb) {
-            var f = '(&(str=hel\')(!(str_2=usa)))';
-            var req = c.findObjects(b, f);
-            req.once('error', cb);
-            req.once('end', cb);
-            req.once('record', function (obj) {
-                found = true;
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.ok(!found);
-        t.end();
-    });
-});
-
-
-
-test('MORAY-148 (foo=bar=*)', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hello=world',
-        str_2: 'world=hello'
-    };
-    var found = false;
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function find(_, cb) {
-            var f = '(|(str=hello=*)(str_2=world=*))';
-            var req = c.findObjects(b, f);
-            req.once('error', cb);
-            req.once('end', cb);
-            req.once('record', function (obj) {
-                found = true;
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.ok(found);
-        t.end();
-    });
-});
-
-
-test('MORAY-166: deleteMany with LIMIT', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hello=world'
-    };
-    var N = 35;
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            cb = once(cb);
-
-            var done = 0;
-            function _cb(err) {
-                if (err) {
-                    cb(err);
-                } else if (++done === N) {
-                    cb();
-                }
-            }
-
-            for (var i = 0; i < N; i++)
-                c.putObject(b, k + '' + i, v, _cb);
-
-        }, function delMany(_, cb) {
-            cb = once(cb);
-
-            var _opts = {
-                limit: Math.floor(N / 4)
-            };
-
-            (function drop() {
-                function _cb(err, meta) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-
-                    t.ok(meta);
-                    if (!meta) {
-                        cb(new Error('boom'));
-                        return;
-                    }
-                    t.ok(meta.count <= _opts.limit);
-                    if (meta.count > 0) {
-                        drop();
-                    } else {
-                        cb();
-                    }
-                }
-
-                c.deleteMany(b, '(str=*)', _opts, _cb);
-            })();
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-
-test('MORAY-166: update with LIMIT', function (t) {
-    var k = uuid.v4();
-    var v = {
-        str: 'hello=world'
-    };
-    var N = 35;
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            cb = once(cb);
-
-            var done = 0;
-            function _cb(err) {
-                if (err) {
-                    cb(err);
-                } else if (++done === N) {
-                    cb();
-                }
-            }
-
-            for (var i = 0; i < N; i++)
-                c.putObject(b, k + '' + i, v, _cb);
-
-        }, function updateMany(_, cb) {
-            cb = once(cb);
-
-            var _opts = {
-                limit: Math.floor(N / 4)
-            };
-
-            function _cb(err, meta) {
-                if (err) {
-                    cb(err);
-                    return;
-                }
-
-                t.ok(meta);
-                if (!meta) {
-                    cb(new Error('boom'));
-                    return;
-                }
-
-                t.equal(meta.count, _opts.limit);
-                cb();
-            }
-
-            c.updateObjects(b, {str: 'fo'}, '(str=*)', _opts, _cb);
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('MORAY-166: delete w/LIMIT in batch', function (t) {
-    var k = uuid.v4();
-
-    vasync.pipeline({
-        funcs: [
-            function putObjects(_, cb) {
-                cb = once(cb);
-                var barrier = vasync.barrier();
-                var vals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
-                vals.forEach(function (i) {
-                    barrier.start(i);
-                    var _k = k + i;
-                    var v = {
-                        num: i
-                    };
-
-                    c.putObject(b, _k, v, function (err) {
-                        if (err)
-                            cb(err);
-
-                        barrier.done(i);
-                    });
-                });
-
-                barrier.on('drain', cb);
-            },
-            function deleteObjects(_, cb) {
-                cb = once(cb);
-                c.batch([
-                    {
-                        operation: 'deleteMany',
-                        bucket: b,
-                        filter: 'num=*',
-                        options: {
-                            limit: 5
-                        }
-                    }
-                ], function (err, meta) {
-                    if (err) {
-                        cb(err);
-                        return;
-                    }
-                    t.ok(meta);
-                    t.equal(meta.etags[0].count, 5);
-                    cb();
-                });
-            }
-        ]
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('MORAY-175: overwrite with \' in name', function (t) {
-    var k = uuid.v4() + '\'foo';
-    var v = {
-        str: 'hi',
-        vnode: 2
-    };
-    var v2 = {
-        str: 'hello world',
-        pre: 'hi'
-    };
-
-    vasync.pipeline({
-        funcs: [ function create(_, cb) {
-            c.putObject(b, k, v, cb);
-        }, function overwrite(_, cb) {
-            c.putObject(b, k, v2, cb);
-        }, function getAgain(_, cb) {
-            c.getObject(b, k, function (err, obj) {
-                if (err) {
-                    cb(err);
-                } else {
-                    t.ok(obj);
-                    v2.pre = 'pre_overwrite';
-                    assertObject(t, obj, k, v2);
-                    cb();
-                }
-            });
-        } ],
-        arg: {}
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-
-test('reindex objects', function (t) {
-
-    var field = 'unindexed';
-    var COUNT = 1000;
-    var PAGESIZE = 100;
-    var records = [];
-    for (var i = 0; i < COUNT; i++) {
-        records.push(i);
-    }
-
-    vasync.pipeline({
-        funcs: [
-            function insertRecords(_, cb) {
-                vasync.forEachPipeline({
-                    func: function (id, callback) {
-                        var k = uuid.v4();
-                        var obj = {
-                            str: 'test'
-                        };
-                        obj[field] = id;
-                        c.putObject(b, k, obj, function (err, meta) {
-                            callback(err);
-                        });
-                    },
-                    inputs: records
-                }, function (err) {
-                    t.ifError(err);
-                    t.ok(true, 'insert records');
-                    cb(err);
-                });
-            },
-            function updateBucket(_, cb) {
-                var config = clone(BUCKET_CFG);
-                config.index[field] =  {type: 'number'};
-                config.options.version++;
-                c.updateBucket(b, config, function (err) {
-                    t.ifError(err);
-                    t.ok(true, 'update bucket');
-                    cb(err);
-                });
-            },
-            function reindexObjects(_, cb) {
-                var total = 0;
-                function runReindex() {
-                    c.reindexObjects(b, PAGESIZE, function (err, res) {
-                        if (err) {
-                            t.ifError(err);
-                            cb(err);
-                            return;
-                        }
-                        if (res.processed === 0) {
-                            t.equal(COUNT, total);
-                            cb();
-                        } else {
-                            total += res.processed;
-                            process.nextTick(runReindex);
-                        }
-                    });
-                }
-                runReindex();
-            },
-            function queryNewIndex(_, cb) {
-                var limit = COUNT / 2;
-                var filter = util.format('(%s<=%d)', field, limit);
-
-                var found = 0;
-                var opts = {
-                    noBucketCache: true
-                };
-                var res = c.findObjects(b, filter, opts);
-                res.on('error', cb);
-                res.on('record', function () {
-                    found++;
-                });
-                res.on('end', function () {
-                    // <= means limit+1
-                    t.equal(limit+1, found);
-                    cb();
-                });
-            }
-        ]
-    }, function (err) {
-        t.ifError(err);
-        t.end();
-    });
-});
-
-test('MORAY-291: add ip', function (t) {
-    var k = uuid.v4();
-    var v = {
-        ip: '192.168.1.10'
-    };
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, function (err, meta) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(meta);
-                if (meta)
-                    t.ok(meta.etag);
-                return (cb());
-            });
-        }, function get(_, cb) {
-            c.getObject(b, k, function (err, obj) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(obj);
-                assertObject(t, obj, k, v);
-                t.ok(obj.value.ip, 'has ip value');
-
-                if (obj.value.ip) {
-                    t.ok(net.isIPv4(obj.value.ip), 'ip value is IPv4');
-                    t.equal(obj.value.ip, v.ip, 'ip is correct');
-                }
-
-                return (cb());
-            });
-        }]
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-test('MORAY-291: add partial ip not ok', function (t) {
-    var k = uuid.v4();
-    var v = {
-        ip: '192.168'
-    };
-    var errmsg = 'index(ip) is of type ip';
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, function (err, meta) {
-                if (err) {
-                    t.ok(err, 'received an error');
-                    t.equal(err.message, errmsg, 'with the right message');
-                    return (cb());
-                }
-                t.notOk(false, 'did not error on bogus ip');
-                return (cb());
-            });
-        }]
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-test('MORAY-291: add ip/cidr not ok', function (t) {
-    var k = uuid.v4();
-    var v = {
-        ip: '192.168.1.10/24'
-    };
-    var errmsg = 'index(ip) is of type ip';
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, function (err, meta) {
-                if (err) {
-                    t.ok(err, 'received an error');
-                    t.equal(err.message, errmsg, 'with the right message');
-                    return (cb());
-                }
-                t.notOk(false, 'did not error on ip/cidr input');
-                return (cb());
-            });
-        }]
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-test('MORAY-291: add subnet', function (t) {
-    var k = uuid.v4();
-    var v = {
-        subnet: '192.168.1.0/24'
-    };
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, function (err, meta) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(meta);
-                if (meta)
-                    t.ok(meta.etag);
-                return (cb());
-            });
-        }, function get(_, cb) {
-            c.getObject(b, k, function (err, obj) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(obj);
-                t.ok(obj.value.subnet, 'has subnet value');
-
-                if (obj.value.ip) {
-                    t.equal(obj.value.subnet, v.subnet, 'subnet value correct');
-                }
-
-                return (cb());
-            });
-        }]
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-test('MORAY-291: invalid subnet', function (t) {
-    var k = uuid.v4();
-    var v = {
-        subnet: '192.168.1.10/24'
-    };
-    var errmsg = 'invalid cidr value: "' + v.subnet + '"';
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, function (err, meta) {
-                if (err) {
-                    t.ok(err, 'received an error');
-                    t.equal(err.message, errmsg, 'with the right message');
-                    return (cb());
-                }
-                t.notOk(false, 'did not error on bogus ip');
-                return (cb());
-            });
-        }]
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-test('MORAY-333: able to query on null subnet field', function (t) {
-    var k = uuid.v4();
-    var v = {
-        ip: '192.168.1.10'
-    };
-
-    vasync.pipeline({
-        funcs: [
-            function put(_, cb) {
-                c.putObject(b, k, v, function (err, meta) {
-                    if (err)
-                        return (cb(err));
-
-                    t.ok(meta);
-                    if (meta)
-                        t.ok(meta.etag);
-                    return (cb());
-                });
-            },
-            function query(_, cb) {
-                var f = '(|(subnet=10.0.0.0/8)(ip=192.168.1.10))';
-                var req = c.findObjects(b, f);
-                var ok = false;
-                req.once('error', function (err) {
-                    t.ifError(err, 'query error');
-                    t.end();
-                });
-                req.once('end', function () {
-                    t.ok(ok);
-                    t.end();
-                });
-                req.on('record', function (obj) {
-                    t.ok(obj, 'received an object from the query');
-                    assertObject(t, obj, k, v);
-                    ok = true;
-                });
-            }
-        ]
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-test('MORAY-333: able to query on null IP field', function (t) {
-    var k = uuid.v4();
-    var v = {
-        subnet: '192.168.0.0/16'
-    };
-
-    vasync.pipeline({
-        funcs: [
-            function put(_, cb) {
-                c.putObject(b, k, v, function (err, meta) {
-                    if (err)
-                        return (cb(err));
-
-                    t.ok(meta);
-                    if (meta)
-                        t.ok(meta.etag);
-                    return (cb());
-                });
-            },
-            function query(_, cb) {
-                var f = '(|(ip=1.2.3.4)(subnet=192.168.0.0/16))';
-                var req = c.findObjects(b, f);
-                var ok = false;
-                req.once('error', function (err) {
-                    t.ifError(err, 'query error');
-                    t.end();
-                });
-                req.once('end', function () {
-                    t.ok(ok);
-                    t.end();
-                });
-                req.on('record', function (obj) {
-                    t.ok(obj, 'received an object from the query');
-                    assertObject(t, obj, k, v);
-                    ok = true;
-                });
-            }
-        ]
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-
-// TODO: should create own bucket.
-test('MORAY-291: able to query on IP types', function (t) {
-    var k = uuid.v4();
-    var v = {
-        ip: '192.168.1.10'
-    };
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, function (err, meta) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(meta);
-                if (meta)
-                    t.ok(meta.etag);
-                return (cb());
-            });
-        }, function query(_, cb) {
-            var f = '(ip=192.168.1.10)';
-            var req = c.findObjects(b, f);
-            var ok = false;
-            req.once('error', function (err) {
-                t.ifError(err, 'query error');
-                t.end();
-            });
-            req.once('end', function () {
-                t.ok(ok);
-                t.end();
-            });
-            req.on('record', function (obj) {
-                t.ok(obj, 'received an object from the query');
-                assertObject(t, obj, k, v);
-                ok = true;
-            });
-        }]
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-// TODO: should create own bucket.
-test('MORAY-291: able to query <= on IP types', function (t) {
-    var k = uuid.v4();
-    var v = {
-        ip: '192.168.1.8'
-    };
-
-    vasync.pipeline({
-        funcs: [ function put(_, cb) {
-            c.putObject(b, k, v, function (err, meta) {
-                if (err)
-                    return (cb(err));
-
-                t.ok(meta);
-                if (meta)
-                    t.ok(meta.etag);
-                return (cb());
-            });
-        }, function query(_, cb) {
-            var f = '(ip<=192.168.1.9)';
-            var req = c.findObjects(b, f);
-            var ok = false;
-            req.once('error', function (err) {
-                t.ifError(err, 'query error');
-                t.end();
-            });
-            req.once('end', function () {
-                t.ok(ok);
-                t.end();
-            });
-            req.on('record', function (obj) {
-                t.ok(obj, 'received an object from the query');
-                assertObject(t, obj, k, v);
-                t.ok(obj.value.ip, 'has ip value');
-
-                if (obj.value.ip) {
-                    t.ok(net.isIPv4(obj.value.ip), 'ip value is IPv4');
-                    t.equal(obj.value.ip, v.ip, 'ip is correct');
-                }
-
-                ok = true;
-            });
-        }]
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-// TODO: other queries on IP types that we need: <=
-// TODO: queries on subnet types =, <=
-
-test('MORAY-298: presence filter works for all types', function (t) {
-    var recs = [
-        {
-            k: 'str',
-            v: 'string'
-        },
-        {
-            k: 'str_u',
-            v: 'unique string'
-        },
-        {
-            k: 'num',
-            v: 40
-        },
-        {
-            k: 'bool',
-            v: true
-        },
-        {
-            k: 'bool_u',
-            v: true
-        },
-        {
-            k: 'ip',
-            v: '192.168.5.2'
-        },
-        {
-            k: 'ip_u',
-            v: '192.168.5.3'
-        },
-        {
-            k: 'subnet',
-            v: '192.168.5.0/24'
-        },
-        {
-            k: 'subnet_u',
-            v: '192.168.6.0/24'
-        }
-    ];
-
-    vasync.forEachParallel({
-        inputs: recs,
-        func: function presence(rec, cb) {
-            var v = {};
-            v[rec.k] = rec.v;
-
-            c.putObject(b, rec.k, v, function (putErr, meta) {
-                var desc = ': ' + rec.k + '/' + rec.v;
-                var f = util.format('(%s=*)', rec.k);
-                var n = 0;
-                var req;
-
-                t.ifErr(putErr, 'put' + desc);
-                if (putErr)
-                    return (cb(putErr));
-
-                req = c.findObjects(b, f);
-
-                req.once('error', function (err) {
-                    t.ifError(err, 'query error' + desc);
-                    return (cb(err));
-                });
-
-                req.once('end', function () {
-                    t.equal(n, 1, '1 record returned' + desc);
-                    return (cb());
-                });
-
-                req.on('record', function (obj) {
-                    n++;
-                    t.equal(obj.value[rec.k], rec.v, 'value' + desc);
-                });
-
-                return req;
-            });
-        }
-    }, function (err) {
-        t.ifError(err, 'no errors');
-        t.end();
-    });
-});
-
-test('filter on unindexed fields', function (t) {
-    var v = {
-        str: 'required',
-        ui_str: 'value',
-        ui_num: 15,
-        ui_zero: 0,
-        ui_null: null
-    };
-    var k = uuid.v4();
-    var tests = {
-        // Equality:
-        '(ui_str=value)': true,
-        '(ui_str=bad)': false,
-        // '(ui_num=15)': true, ruined by strict types
-        '(ui_num=14)': false,
-        '(ui_num=0)': false,
-        // '(ui_zero=0)': true, ruined by strict types
-        '(ui_zero=1)': false,
-        // Presence:
-        '(ui_str=*)': true,
-        '(ui_num=*)': true,
-        '(ui_zero=*)': true,
-        '(ui_null=*)': false,
-        '(ui_bogus=*)': false,
-        // GE/LE:
-        '(ui_num>=15)': true,
-        '(ui_num>=0)': true,
-        '(ui_num>=16)': false,
-        '(ui_num<=15)': true,
-        '(ui_num<=0)': false,
-        '(ui_num<=16)': true,
-        '(ui_str>=value)': true,
-        '(ui_str>=valud)': true,
-        '(ui_str>=valuf)': false,
-        '(ui_str<=value)': true,
-        '(ui_str<=valud)': false,
-        '(ui_str<=valuf)': true,
-        // Substring:
-        '(ui_str=val*)': true,
-        '(ui_str=val*e)': true,
-        '(ui_str=*alue)': true,
-        '(ui_str=v*l*e)': true,
-        '(ui_str=n*ope)': false,
-        '(ui_str=*nope)': false,
-        '(ui_str=nope*)': false,
-        '(ui_str=no*p*e)': false,
-        // Ext:
-        '(ui_str:caseIgnoreMatch:=VALUE)': true,
-        '(ui_str:caseIgnoreMatch:=NOPE)': false,
-        '(ui_str:caseIgnoreSubstringsMatch:=V*LUE)': true,
-        '(ui_str:caseIgnoreSubstringsMatch:=N*PE)': false
-    };
-    c.putObject(b, k, v, function (putErr) {
-        if (putErr) {
-            t.ifError(putErr);
-            t.end();
-            return;
-        }
-        vasync.forEachParallel({
-            inputs: Object.keys(tests),
-            func: function filterCheck(f, cb) {
-                var found = false;
-                cb = once(cb);
-                var fixed = '(&(str=required)' + f + ')';
-                var res = c.findObjects(b, fixed);
-                res.once('error', function (err) {
-                    t.ifError(err);
-                    cb(err);
-                });
-                res.on('record', function (obj) {
-                    if (k !== obj.key)
-                        t.fail('invalid key');
-                    found = true;
-                });
-                res.once('end', function () {
-                    if (tests[f]) {
-                        t.ok(found, f + ' should find object');
-                    } else {
-                        t.notOk(found, f + ' should not find object');
-                    }
-                    cb();
-                });
-            }
-        }, function (err) {
-            t.ifError(err);
-            t.end();
-        });
-    });
-});
-
-test('MORAY-311: ext filters survive undefined fields', function (t) {
-    var v = {
-        num: 5
-    };
-    var k = uuid.v4();
-    var filters = [
-        '(&(num=5)(!(str:caseIgnoreSubstringsMatch:=*test*)))',
-        '(&(num=5)(!(str:caseIgnoreMatch:=*test*)))'
-    ];
-    c.putObject(b, k, v, function (putErr) {
-        if (putErr) {
-            t.ifError(putErr);
-            t.end();
-            return;
-        }
-        vasync.forEachParallel({
-            inputs: filters,
-            func: function filterCheck(f, cb) {
-                var found = false;
-                cb = once(cb);
-                var res = c.findObjects(b, f);
-                res.once('error', function (err) {
-                    t.ifError(err);
-                    cb(err);
-                });
-                res.on('record', function (obj) {
-                    t.equal(k, obj.key);
-                    found = true;
-                });
-                res.once('end', function () {
-                    t.ok(found);
-                    cb();
-                });
-            }
-        }, function (err) {
-            t.ifError(err);
-            t.end();
-        });
-    });
-});
diff --git a/test/sql.test.js b/test/sql.test.js
deleted file mode 100644
index a853b9b..0000000
--- a/test/sql.test.js
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var clone = require('clone');
-var tape = require('tape');
-var util = require('util');
-var uuid = require('libuuid').create;
-
-var helper = require('./helper.js');
-
-
-var c; // client
-var server;
-var table = 'moray_unit_test_' + uuid().substr(0, 7);
-var sql;
-var q;
-
-function test(name, setup) {
-    tape.test(name + ' - setup', function (t) {
-        helper.createServer(null, function (s) {
-            server = s;
-            c = helper.createClient();
-            c.on('connect', t.end.bind(t));
-        });
-    });
-
-    tape.test(name + ' - main', function (t) {
-        setup(t);
-    });
-
-    tape.test(name + ' - teardown', function (t) {
-        c.once('close', function () {
-            helper.cleanupServer(server, function () {
-                t.pass('closed');
-                t.end();
-            });
-        });
-        c.close();
-    });
-}
-
-
-test('sql - execute', function (t) {
-    sql = util.format('CREATE TABLE %s (value integer);', table);
-    q = c.sql(sql, [], {});
-    q.on('error', t.ifError.bind(t));
-    q.once('end', function () {
-        t.pass('create table success');
-        t.end();
-    });
-});
-
-test('sql - insert', function (t) {
-    sql = util.format('INSERT INTO %s (value) VALUES ($1);', table);
-    q = c.sql(sql, [5], {});
-    q.on('error', t.ifError.bind(t));
-    q.once('end', function () {
-        t.pass('insert success');
-        t.end();
-    });
-});
-
-test('sql - select', function (t) {
-    var count = 0;
-    sql = util.format('SELECT * FROM %s', table);
-    q = c.sql(sql, [], {});
-    q.on('error', t.ifError.bind(t));
-    q.on('record', function (row) {
-        t.equal(row.value, 5);
-        count++;
-    });
-    q.once('end', function () {
-        t.equal(count, 1);
-        t.end();
-    });
-});
-
-test('sql - fail', function (t) {
-    sql = 'BOGUS QUERY;';
-    q = c.sql(sql, [], {});
-    q.once('error', function (err) {
-        t.ok(err);
-        t.end();
-    });
-});
-
-test('sql - cleanup', function (t) {
-    sql = util.format('DROP TABLE %s;', table);
-    q = c.sql(sql, [], {});
-    q.on('error', t.ifError.bind(t));
-    q.once('end', function () {
-        t.pass('success');
-        t.end();
-    });
-});
