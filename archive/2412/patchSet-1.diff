commit 5ae62a107a7852f132481eb2f3d398d20ce035d8 (refs/changes/12/2412/1)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2017-08-15T18:08:38-07:00 (2 years, 2 months ago)
    
    VOLAPI-72 creating volume with unsupported size should result in error, not in volume being created with closest matching size

diff --git a/lib/endpoints/volumes.js b/lib/endpoints/volumes.js
index b65818c..0dda9f1 100644
--- a/lib/endpoints/volumes.js
+++ b/lib/endpoints/volumes.js
@@ -42,42 +42,6 @@ assert.number(DEFAULT_NFS_SHARED_VOLUME_PACKAGE_SIZE_IN_MBS,
 
 var VOLUME_TICKETS_SCOPE = 'nfs_volume';
 
-function _selectBestPackage(requestedSize, packagesList, options, callback) {
-    assert.number(requestedSize, 'requestedSize');
-    assert.arrayOfObject(packagesList, 'packagesList');
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.func(callback, 'callback');
-
-    var bestPackage;
-    var err;
-    var log = options.log;
-
-    packagesList.forEach(function updateBestPackage(candidatePackage) {
-        var candidateIsLargeEnough = candidatePackage.quota
-            >= requestedSize;
-        var candidateSmallerThanBest = bestPackage === undefined ||
-            candidatePackage.quota < bestPackage.quota;
-        var candidateFitsBetter = candidateIsLargeEnough &&
-            (bestPackage === undefined || candidateSmallerThanBest);
-
-        log.debug({package: candidatePackage}, 'considering package...');
-        if (candidateFitsBetter) {
-            log.debug({
-                package: candidatePackage,
-                oldBestFit: bestPackage
-            }, 'package is better fit than current best fit');
-            bestPackage = candidatePackage;
-        }
-    });
-
-    if (bestPackage === undefined) {
-        err = new Error('Could not find package');
-    }
-
-    callback(err, bestPackage);
-}
-
 //
 // opts is an object that must include at least:
 //
@@ -102,54 +66,6 @@ function getAllNfsSharedVolumesPackages(opts, callback) {
     });
 }
 
-function _getBestPackage(volumeParams, options, callback) {
-    assert.object(volumeParams, 'volumeParams');
-    assert.object(options, 'options');
-    assert.object(options.log, 'options.log');
-    assert.func(callback, 'callback');
-
-    var log = options.log;
-    var papiClient = options.papiClient;
-    assert.object(papiClient, 'papiClient');
-
-    var requestedSize = volumeParams.size;
-
-    if (requestedSize === undefined) {
-        requestedSize = DEFAULT_NFS_SHARED_VOLUME_PACKAGE_SIZE_IN_MBS;
-    }
-
-    var context = {};
-    vasync.pipeline({
-        funcs: [
-            function getNfsSharedVolumesPackages(ctx, next) {
-                getAllNfsSharedVolumesPackages({
-                    papiClient: papiClient
-                }, function onListDone(err, pkgs, count) {
-                    ctx.nfsSharedVolumesPkgs = pkgs;
-                    next(err);
-                });
-            },
-            function selectBestPackage(ctx, next) {
-                _selectBestPackage(requestedSize, ctx.nfsSharedVolumesPkgs,
-                    options, function onBestPackageSelected(err, bestPackage) {
-                        if (bestPackage !== undefined) {
-                            log.debug({package: bestPackage},
-                                'Best package found');
-                        } else {
-                            log.debug('Could not find best package');
-                        }
-
-                        ctx.bestPackage = bestPackage;
-                        next(err);
-                    });
-            }
-        ],
-        arg: context
-    }, function onBestPackageSelect(err) {
-        callback(err, context.bestPackage);
-    });
-}
-
 function _buildStorageVMPayload(volumeParams, storageVmUuid, imageUuid,
     billingPackage) {
     assert.object(volumeParams, 'volumeParams');
@@ -487,6 +403,57 @@ function createVolume(req, res, next) {
                 done(err);
             });
         },
+        function getStorageVmPackage(ctx, done) {
+            var getStorageVmPkgErr;
+            var requestedSize = req.params.size;
+
+            req.log.debug({volumeParams: volumeParams},
+                'Finding corresponding storage VM package');
+
+            getAllNfsSharedVolumesPackages({
+                papiClient: req._papiClient
+            }, function onListDone(getNfsVolPkgsErr, pkgs, count) {
+                var availableSizes;
+                var idx = 0;
+                var storageVmPkg;
+
+                if (getNfsVolPkgsErr || !pkgs || pkgs.length === 0) {
+                    done(new errors.InternalError(getNfsVolPkgsErr,
+                        'Could not get NFS volumes packages'));
+                    return;
+                }
+
+                availableSizes = pkgs.map(function getSizeFromPkg(pkg) {
+                    return pkg.quota;
+                });
+
+                for (idx = 0; idx < pkgs.length; ++idx) {
+                    storageVmPkg = pkgs[idx];
+                    if (storageVmPkg.quota === requestedSize) {
+                        req.log.debug({package: storageVmPkg},
+                                'Storage VM package found');
+                        ctx.storageVmPkg = storageVmPkg;
+                        break;
+                    }
+                }
+
+                if (ctx.storageVmPackage === undefined) {
+                    getStorageVmPkgErr =
+                        new errors.VolumeSizeNotAvailableError(requestedSize,
+                                availableSizes.sort(function numSort(a, b) {
+                                    if (a > b) {
+                                        return 1;
+                                    } else if (a < b) {
+                                        return -1;
+                                    }
+
+                                    return 0;
+                                }));
+                }
+
+                done(getStorageVmPkgErr);
+            });
+        },
         function loadVolumeReservations(ctx, done) {
             reservationModels.listVolumeReservations({
                 volumeName: volumeName,
@@ -574,33 +541,6 @@ function createVolume(req, res, next) {
 
             doLoadVolume();
         },
-        function getBestPackage(ctx, done) {
-            var options = {
-                log: req.log,
-                papiClient: req._papiClient
-            };
-
-            req.log.debug({volumeParams: volumeParams},
-                'Finding most suitable package');
-
-            _getBestPackage(volumeParams, options,
-                function onPackage(getPackageErr, bestPackage) {
-                    var err;
-
-                    if (!getPackageErr && bestPackage) {
-                        ctx.volumeObject.value.size = bestPackage.quota;
-                    }
-
-                    ctx.bestPackage = bestPackage;
-
-                    if (getPackageErr) {
-                        err = new errors.InternalError(getPackageErr,
-                            'Error when getting best package for volume');
-                    }
-
-                    done(err);
-                });
-        },
         /*
          * In order to avoid concurrent updates racing (recording the storage
          * VM's uuid in Moray and recording the storage VM's state changes in
@@ -619,13 +559,13 @@ function createVolume(req, res, next) {
         function createStorageVM(ctx, done) {
             assert.object(volumeParams, 'volumeParams');
             assert.uuid(CONFIG.nfsServerImageUuid, 'CONFIG.nfsServerImageUuid');
-            assert.object(ctx.bestPackage, 'ctx.bestPackage');
+            assert.object(ctx.storageVmPackage, 'ctx.storageVmPackage');
             assert.uuid(ctx.storageVmUuid, 'ctx.storageVmUuid');
 
             var storageVmPayload =
                 _buildStorageVMPayload(volumeParams, ctx.storageVmUuid,
                     CONFIG.nfsServerImageUuid,
-                    ctx.bestPackage);
+                    ctx.storageVmPackage);
             req.log.debug({vmPayload: storageVmPayload}, 'Creating storage VM');
 
             vmapiClient.createVm({
diff --git a/lib/errors.js b/lib/errors.js
index 4a88e1d..5ef6712 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -63,17 +63,32 @@ function ValidationError(causes) {
     restify.RestError.call(this, {
         restCode: 'ValidationError',
         statusCode: 409,
-        message: 'Validation error, causes: ' + causes,
+        message: 'Validation error, causes: ' + causes.join(', '),
         constructorOpt: ValidationError
     });
     this.name = 'ValidationError';
 }
 util.inherits(ValidationError, restify.RestError);
 
+function VolumeSizeNotAvailableError(size, availableSizes) {
+    assert.number(size, 'size');
+    assert.arrayOfNumber(availableSizes, 'availableSizes');
+    restify.RestError.call(this, {
+        restCode: 'VolumeSizeNotAvailable',
+        statusCode: 409,
+        message: 'Volume size ' + size + ' is not available. Available ' +
+            'sizes are: ' + availableSizes.join(', '),
+        constructorOpt: VolumeSizeNotAvailableError
+    });
+    this.name = 'VolumeSizeNotAvailableError';
+}
+util.inherits(VolumeSizeNotAvailableError, restify.RestError);
+
 module.exports = {
     InternalError: restify.InternalError,
     ValidationError: ValidationError,
     VolumeAlreadyExistsError: VolumeAlreadyExistsError,
     VolumeInUseError: VolumeInUseError,
-    VolumeNotFoundError: VolumeNotFoundError
+    VolumeNotFoundError: VolumeNotFoundError,
+    VolumeSizeNotAvailableError: VolumeSizeNotAvailableError
 };
\ No newline at end of file
diff --git a/test/integration/nfs-shared-volumes-creation-invalid-size.test.js b/test/integration/nfs-shared-volumes-creation-invalid-size.test.js
deleted file mode 100644
index b4aa17f..0000000
--- a/test/integration/nfs-shared-volumes-creation-invalid-size.test.js
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2016, Joyent, Inc.
- */
-
-var assert = require('assert-plus');
-var test = require('tape');
-var vasync = require('vasync');
-
-var configLoader = require('../../lib/config-loader');
-
-var clientsSetup = require('./lib/clients-setup');
-var resources = require('./lib/resources');
-var testVolumes = require('./lib/volumes');
-
-var CONFIG = configLoader.loadConfigSync();
-
-var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
-assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
-
-var CLIENTS;
-var NFS_SHARED_VOLUMES_NAMES_PREFIX = 'nfs-shared-volumes';
-var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
-
-var NETWORKS;
-
-test('setup', function (tt) {
-    tt.test('setup clients', function (t) {
-        clientsSetup.getApiClients(function onClientsSetup(err, clients) {
-            CLIENTS = clients;
-            t.end();
-        });
-    });
-
-    tt.test('setup networks', function (t) {
-        CLIENTS.napi.get('/networks',
-            function onListNetworks(err, networks) {
-                t.ifError(err);
-                t.ok(networks);
-                t.ok(Array.isArray(networks));
-                t.ok(networks.length > 1);
-                NETWORKS = networks;
-                t.end();
-            });
-    });
-});
-
-test('NFS shared volume creation with invalid size', function (tt) {
-    var volumeName =
-        resources.makeResourceName(NFS_SHARED_VOLUMES_NAMES_PREFIX);
-
-    tt.test('creating a nfs shared volume with invalid size should fail',
-        function (t) {
-            var INVALID_SIZES = ['invalid-size', '%$%#$%', '', 0, -42];
-
-            vasync.forEachParallel({
-                func: createVolumeWithInvalidSize,
-                inputs: INVALID_SIZES
-            }, function invalidSizesTested(err, results) {
-                t.end();
-            });
-
-            function createVolumeWithInvalidSize(invalidSize, callback) {
-                assert.func(callback, 'callback');
-
-                var expectedErrMsg = 'Validation error, causes: Error: ' +
-                    'Volume size: "' + invalidSize + '" is not a valid ' +
-                    'volume size';
-
-                var volumeParams = {
-                    name: volumeName,
-                    owner_uuid: UFDS_ADMIN_UUID,
-                    type: NFS_SHARED_VOLUMES_TYPE_NAME,
-                    networks: [NETWORKS[0].uuid],
-                    size: invalidSize
-                };
-
-                CLIENTS.volapi.createVolume(volumeParams,
-                    function onVolumeCreated(err, volume) {
-                        t.ok(err, 'volume creation should result in an error');
-                        t.ok(err.message.indexOf(expectedErrMsg) !== -1,
-                            'Error message should be: ' + expectedErrMsg);
-
-                        callback();
-                    });
-            }
-        });
-});
\ No newline at end of file
diff --git a/test/integration/nfs-shared-volumes-creation-size.test.js b/test/integration/nfs-shared-volumes-creation-size.test.js
new file mode 100644
index 0000000..fb1d913
--- /dev/null
+++ b/test/integration/nfs-shared-volumes-creation-size.test.js
@@ -0,0 +1,192 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var test = require('tape');
+var vasync = require('vasync');
+
+var configLoader = require('../../lib/config-loader');
+
+var clientsSetup = require('./lib/clients-setup');
+var resources = require('./lib/resources');
+var testVolumes = require('./lib/volumes');
+
+var CONFIG = configLoader.loadConfigSync();
+
+var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
+assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
+
+var CLIENTS;
+var NFS_SHARED_VOLUMES_NAMES_PREFIX = 'nfs-shared-volumes';
+var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
+var UFDS_ADMIN_FABRIC_NETWORK;
+
+test('setup', function (tt) {
+    tt.test('setup clients', function (t) {
+        clientsSetup.getApiClients(function onClientsSetup(err, clients) {
+            CLIENTS = clients;
+            t.end();
+        });
+    });
+
+    tt.test('setup networks', function (t) {
+        CLIENTS.napi.get('/networks?owner_uuid=' + UFDS_ADMIN_UUID +
+            '&fabric=true',
+            function onListNetworks(err, networks) {
+                t.ifError(err, 'listing fabric networks for owner ' +
+                    UFDS_ADMIN_UUID + ' should not error');
+                t.ok(networks, 'listing fabric networks for owner ' +
+                    UFDS_ADMIN_UUID + ' should result in a non-empty list of ' +
+                    'networks');
+                t.ok(Array.isArray(networks),
+                    'list of networks should be an array');
+                t.ok(networks.length === 1, 'owner ' + UFDS_ADMIN_UUID +
+                    ' should have only 1 fabric network');
+
+                UFDS_ADMIN_FABRIC_NETWORK = networks[0];
+
+                t.end();
+            });
+    });
+});
+
+test('NFS shared volume creation with invalid size', function (tt) {
+    var volumeName =
+        resources.makeResourceName(NFS_SHARED_VOLUMES_NAMES_PREFIX);
+
+    tt.test('creating a nfs shared volume with invalid size should fail',
+        function (t) {
+            var INVALID_SIZES = ['invalid-size', '%$%#$%', '', 0, -42];
+
+            vasync.forEachParallel({
+                func: createVolumeWithInvalidSize,
+                inputs: INVALID_SIZES
+            }, function invalidSizesTested(err, results) {
+                t.end();
+            });
+
+            function createVolumeWithInvalidSize(invalidSize, callback) {
+                assert.func(callback, 'callback');
+
+                var expectedErrMsg = 'Validation error, causes: Error: ' +
+                    'Volume size: "' + invalidSize + '" is not a valid ' +
+                    'volume size';
+
+                var volumeParams = {
+                    name: volumeName,
+                    owner_uuid: UFDS_ADMIN_UUID,
+                    type: NFS_SHARED_VOLUMES_TYPE_NAME,
+                    networks: [UFDS_ADMIN_FABRIC_NETWORK.uuid],
+                    size: invalidSize
+                };
+
+                CLIENTS.volapi.createVolume(volumeParams,
+                    function onVolumeCreated(err, volume) {
+                        t.ok(err, 'volume creation should result in an error');
+                        t.ok(err.message.indexOf(expectedErrMsg) !== -1,
+                            'Error message should be: ' + expectedErrMsg);
+
+                        callback();
+                    });
+            }
+        });
+});
+
+test('NFS shared volume creation with unavailable size', function (tt) {
+    var volumeName =
+        resources.makeResourceName(NFS_SHARED_VOLUMES_NAMES_PREFIX);
+
+    tt.test('creating nfs shared volume with unavailable size should fail',
+        function (t) {
+            vasync.pipeline({arg: {}, funcs: [
+                function getVolumeSizes(ctx, next) {
+                    CLIENTS.volapi.listVolumeSizes(
+                        function onListVolSizes(listVolSizesErr, volSizes) {
+                            t.ifError(listVolSizesErr,
+                                    'listing volume sizes should not error');
+
+                            if (listVolSizesErr) {
+                                next(listVolSizesErr);
+                                return;
+                            }
+
+                            t.ok(volSizes && volSizes.length > 0,
+                                'there should be at least one ' +
+                                    'available volume size');
+
+                            if (!volSizes || volSizes.length === 0) {
+                                next(new Error('Could not find vol sizes'));
+                            } else {
+                                ctx.availableSizes =
+                                    volSizes.map(function getSize(volSize) {
+                                        return volSize.size;
+                                    });
+                                next();
+                            }
+                        });
+                },
+                function createVolWithUnavailableSize(ctx, next) {
+                    var expectedErrorCode;
+                    var expectedErrMsg;
+                    var expectedErrorName;
+                    var volumeSizeTooBig;
+
+                    assert.arrayOfNumber(ctx.availableSizes,
+                            'ctx.availableSizes');
+
+                    ctx.availableSizes.sort(function numSort(a, b) {
+                        if (a > b) {
+                            return 1;
+                        } else if (a < b) {
+                            return -1;
+                        }
+
+                        return 0;
+                    });
+
+                    volumeSizeTooBig =
+                        ctx.availableSizes[ctx.availableSizes.length - 1] + 1;
+
+                    expectedErrorCode = 'VolumeSizeNotAvailable';
+                    expectedErrMsg = 'Volume size ' + volumeSizeTooBig +
+                        ' is not available';
+                    expectedErrorName = 'VolumeSizeNotAvailableError';
+
+                    var volumeParams = {
+                        name: volumeName,
+                        owner_uuid: UFDS_ADMIN_UUID,
+                        type: NFS_SHARED_VOLUMES_TYPE_NAME,
+                        networks: [UFDS_ADMIN_FABRIC_NETWORK.uuid],
+                        size: volumeSizeTooBig
+                    };
+
+                    CLIENTS.volapi.createVolume(volumeParams,
+                        function onVolumeCreated(err, volume) {
+                            t.ok(err,
+                                'volume creation should result in an error');
+                            t.ok(err.message.indexOf(expectedErrMsg) !== -1,
+                                'Error message should be: ' + expectedErrMsg);
+                            t.equal(err.restCode, expectedErrorCode,
+                                    'Error restCode should be ' +
+                                        expectedErrorCode);
+                            t.equal(err.body.code, expectedErrorCode,
+                                    'Error\'s body\'s code should be ' +
+                                        expectedErrorCode);
+                            t.equal(err.name, expectedErrorName,
+                                    'Error name should be ' +
+                                        expectedErrorName);
+                            next();
+                        });
+                }
+            ]}, function onTestDone() {
+                t.end();
+            });
+        });
+});
\ No newline at end of file
