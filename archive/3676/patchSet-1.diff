commit 1915facfcc2d2af10640b58563ca7da7a3a53e93 (refs/changes/76/3676/1)
Author: Josh Wilsdon <josh@wilsdon.ca>
Date:   2018-03-18T08:40:54-07:00 (1 year, 7 months ago)
    
    OS-6745 "vmadm stop" (without -F) is not implemented for bhyve

diff --git a/src/vm/node_modules/VM.js b/src/vm/node_modules/VM.js
index 6c0f3463..5fb5caf7 100644
--- a/src/vm/node_modules/VM.js
+++ b/src/vm/node_modules/VM.js
@@ -13828,24 +13828,23 @@ function doPwait(pid, log, callback)
     return (child);
 }
 
-function doDockerStop(vmobj, options, callback)
+function doTermStop(vmobj, options, callback)
 {
     var log = options.log;
     var err;
     var timer;
-    var unset_autoboot = 'set autoboot=false';
     var tracers_obj;
     var waiter;
 
     assert(vmobj.pid);
 
     if (process.env.EXPERIMENTAL_VMJS_TRACING) {
-        tracers_obj = traceUntilCallback('docker-stop', log, callback);
+        tracers_obj = traceUntilCallback('term-stop', log, callback);
         callback = tracers_obj.callback;
         log = tracers_obj.log;
     }
 
-    log.debug({vmobj_pid: vmobj.pid, timeout: options.timeout}, 'doDockerStop');
+    log.debug({vmobj_pid: vmobj.pid, timeout: options.timeout}, 'doTermStop');
 
     // From options, we use:
     // options.timeout
@@ -13870,89 +13869,83 @@ function doDockerStop(vmobj, options, callback)
         });
     }
 
-    zonecfg(vmobj.uuid, [unset_autoboot], {log: log},
-        function (zonecfg_err, fds) {
+    // if init has died but zone is still running, pid is reported to
+    // be 4294967295 (UINT32_MAX) so if we see that value, just halt the
+    // zone.
+    if (vmobj.pid === 4294967295) {
+        log.warn('PID is 4294967295, halting zone instead of killing init');
+        haltZone();
+        return;
+    }
 
-        if (zonecfg_err) {
-            log.warn({
-                err: zonecfg_err,
-                stdout: fds.stdout,
-                stderr: fds.stderr
-            }, 'Failed to ' + unset_autoboot + ' for ' + vmobj.uuid);
-            return;
-        }
+    // First, send the SIGTERM to the pid for init of the VM
+    log.info({vmobj_pid: vmobj.pid}, 'Sending SIGTERM to VM\'s init PID');
+    err = killSig(vmobj.pid, 'SIGTERM');
+    if (err && err.code === 'ESRCH') {
+        // process already doesn't exist
+        callback();
+        return;
+    } else if (err) {
+        /*
+         * kill(2) says this should be EPERM or EINVAL which are both
+         * programmer errors here.
+         */
+        callback(err);
+        return;
+    }
 
-        // if init has died but zone is still running, pid is reported to
-        // be 4294967295 (UINT32_MAX) so if we see that value, just halt the
-        // zone.
-        if (vmobj.pid === 4294967295) {
-            log.warn('PID is 4294967295, halting zone instead of killing init');
-            haltZone();
-            return;
-        }
+    /*
+     * We expect the stop to have completed within options.timeout seconds,
+     * if it hasn't we'll try SIGKILL and if that fails to kill the zone,
+     * we'll do a 'zoneadm halt'.
+     */
+    timer = setTimeout(function _timeoutAfterTerm() {
+        function _doHaltZone() {
+            if (waiter) {
+                waiter.kill();
+                waiter = null;
+            }
 
-        // First, send the SIGTERM to the pid for init of the VM
-        log.info({vmobj_pid: vmobj.pid}, 'Sending SIGTERM to VM\'s init PID');
-        err = killSig(vmobj.pid, 'SIGTERM');
-        if (err && err.code === 'ESRCH') {
-            // process already doesn't exist
-            callback();
-            return;
-        } else if (err) {
-            /*
-             * kill(2) says this should be EPERM or EINVAL which are both
-             * programmer errors here.
-             */
-            callback(err);
-            return;
+            haltZone(); // will call callback();
         }
 
-        /*
-         * We expect the stop to have completed within options.timeout seconds,
-         * if it hasn't we'll try SIGKILL and if that fails to kill the zone,
-         * we'll do a 'zoneadm halt'.
-         */
-        timer = setTimeout(function () {
+        if (options.killOnTimeout) {
             /*
-             * Hit timeout, do kill -KILL, ignore error since either process is
-             * gone and doPwait will notice and exit, or we'll timeout a second
-             * time.
+             * Hit timeout, do kill -KILL, ignore error since either process
+             * is gone and doPwait will notice and exit, or we'll timeout a
+             * second time.
              */
             log.info({vmobj_pid: vmobj.pid},
                 'Sending SIGKILL to VM\'s init PID');
             killSig(vmobj.pid, 'SIGKILL');
-
             /*
              * Sent kill -KILL, so process really should just exit. In case it
              * doesn't though set one more timer. If that expires, halt the
              * zone.
              */
-            timer = setTimeout(function () {
-                if (waiter) {
-                    waiter.kill();
-                    waiter = null;
-                }
-
-                log.warn({vmobj_pid: vmobj.pid}, 'SIGKILL does not seem to have'
-                    + ' stopped zone, attempting "zoneadm halt"');
-                haltZone(); // will call callback();
+            timer = setTimeout(function _timeoutAfterKill() {
+                log.warn({vmobj_pid: vmobj.pid}, 'SIGKILL does not seem to '
+                    + 'have stopped zone, attempting "zoneadm halt"');
+                _doHaltZone();
             }, (10 * 1000));
-        }, (options.timeout * 1000));
+        } else {
+            _doHaltZone();
+        }
+    }, (options.timeout * 1000));
 
-        /*
-         * This 'waiter' watches for the PID to exit and calls _onExit callback
-         * when it does. Can be immediately.
-         */
-        waiter = doPwait(vmobj.pid, log, function _onExit() {
-            if (timer) {
-                clearTimeout(timer);
-                timer = null;
-            }
+    /*
+     * This 'waiter' watches for the PID to exit and calls _onExit callback
+     * when it does. Can be immediately.
+     */
+    waiter = doPwait(vmobj.pid, log, function _onExit() {
+        if (timer) {
+            clearTimeout(timer);
+            timer = null;
+        }
 
-            // It's dead Jim!
-            log.debug({vmobj_pid: vmobj.pid}, 'pwait reports that init exited');
-            callback();
-        });
+        // It's dead Jim!
+        log.debug({vmobj_pid: vmobj.pid}, 'pwait reports that init exited');
+        callback();
     });
 }
 
@@ -14158,13 +14151,6 @@ exports.stop = function (uuid, options, callback)
                     cb();
                 }
             });
-        }, function _unsupportedBhyve(cb) {
-            if (vmobj.brand !== 'bhyve') {
-                cb();
-                return;
-            }
-            // TODO: support this.
-            cb(new Error('stop is not yet supported for bhyve without force'));
         }, function (cb) {
             var unset_autoboot = 'set autoboot=false';
 
@@ -14213,8 +14199,9 @@ exports.stop = function (uuid, options, callback)
                 if (!options.timeout) {
                     options.timeout = 10;
                 }
-                doDockerStop(vmobj, {
+                doTermStop(vmobj, {
                     log: log,
+                    killOnTimeout: true,
                     timeout: options.timeout
                 }, cb);
             } else if (BRAND_OPTIONS[vmobj.brand].features.use_vm_autoboot) {
@@ -14232,11 +14219,21 @@ exports.stop = function (uuid, options, callback)
                     timeout: options.timeout,
                     transition_to: options.transition_to
                 }, cb);
+            } else if (vmobj.brand === 'bhyve') {
+                if (!options.timeout) {
+                    options.timeout = 180;
+                }
+
+                doTermStop(vmobj, {
+                    log: log,
+                    killOnTimeout: false,
+                    timeout: options.timeout
+                }, cb);
             } else {
                 // timeout is not supported for non-KVM + non-docker
                 if (options.timeout) {
                     timeoutErr = new Error('Timeout option is only supported '
-                        + 'for KVM and docker containers.');
+                        + 'for bhyve, KVM and docker containers.');
                     log.warn({err: timeoutErr}, 'invalid timeout option');
                     cb(timeoutErr);
                     return;
