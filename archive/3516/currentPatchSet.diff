From bc6e5c6cabe4cb676770b8f1a31c9917ba55d358 Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Tue, 16 Jan 2018 22:51:54 +0000
Subject: [PATCH] OS-6667 want generic serial support for console, metadata,
 etc Reviewed by: Dan McDonald <danmcd@joyent.com> Reviewed by: Jerry Jelinek
 <jerry.jelinek@joyent.com> Approved by: Jerry Jelinek
 <jerry.jelinek@joyent.com>

---
 usr/src/cmd/Makefile                    |   1 -
 usr/src/cmd/bhyve/uart_emul.c           | 284 ++++++++-----------
 usr/src/cmd/bhyveconsole/Makefile       |  44 ---
 usr/src/cmd/bhyveconsole/bhyveconsole.c | 361 ------------------------
 usr/src/cmd/bhyveconsole/i386/Makefile  |  43 ---
 5 files changed, 113 insertions(+), 620 deletions(-)
 delete mode 100644 usr/src/cmd/bhyveconsole/Makefile
 delete mode 100644 usr/src/cmd/bhyveconsole/bhyveconsole.c
 delete mode 100644 usr/src/cmd/bhyveconsole/i386/Makefile

diff --git a/usr/src/cmd/Makefile b/usr/src/cmd/Makefile
index c6f19d5369..e69f940e11 100644
--- a/usr/src/cmd/Makefile
+++ b/usr/src/cmd/Makefile
@@ -481,7 +481,6 @@ i386_SUBDIRS=		\
 	acpihpd		\
 	addbadsec	\
 	bhyve		\
-	bhyveconsole	\
 	bhyvectl	\
 	biosdev		\
 	diskscan	\
diff --git a/usr/src/cmd/bhyve/uart_emul.c b/usr/src/cmd/bhyve/uart_emul.c
index 711e94430f..b1bf2dbfec 100644
--- a/usr/src/cmd/bhyve/uart_emul.c
+++ b/usr/src/cmd/bhyve/uart_emul.c
@@ -25,6 +25,8 @@
  * SUCH DAMAGE.
  *
  * $FreeBSD$
+ *
+ * Copyright (c) 2018, Joyent, Inc.
  */
 /*
  * This file and its contents are supplied under the terms of the
@@ -83,7 +85,7 @@ __FBSDID("$FreeBSD$");
 
 #define	COM1_BASE	0x3F8
 #define	COM1_IRQ	4
-#define	COM2_BASE      	0x2F8
+#define	COM2_BASE	0x2F8
 #define COM2_IRQ	3
 
 #define	DEFAULT_RCLK	1843200
@@ -105,10 +107,6 @@ __FBSDID("$FreeBSD$");
 static bool uart_stdio;		/* stdio in use for i/o */
 static struct termios tio_stdio_orig;
 
-#ifndef	__FreeBSD__
-static bool uart_bcons;		/* bhyveconsole in use for i/o */
-#endif
-
 static struct {
 	int	baseaddr;
 	int	irq;
@@ -155,12 +153,11 @@ struct uart_softc {
 
 	struct ttyfd tty;
 #ifndef	__FreeBSD__
-	bool	bcons;
+	bool	sock;
 	struct {
-		pid_t	clipid;
 		int	clifd;		/* console client unix domain socket */
 		int	servfd;		/* console server unix domain socket */
-	} usc_bcons;
+	} usc_sock;
 #endif
 
 	bool	thre_int_pending;	/* THRE interrupt pending */
@@ -174,7 +171,7 @@ struct uart_softc {
 static void uart_drain(int fd, enum ev_type ev, void *arg);
 #else
 static void uart_tty_drain(struct uart_softc *sc);
-static int uart_bcons_drain(struct uart_softc *sc);
+static int uart_sock_drain(struct uart_softc *sc);
 #endif
 
 static void
@@ -221,9 +218,9 @@ ttywrite(struct ttyfd *tf, unsigned char wb)
 
 #ifndef	__FreeBSD__
 static void
-bconswrite(struct uart_softc *sc, unsigned char wb)
+sockwrite(struct uart_softc *sc, unsigned char wb)
 {
-	(void) write(sc->usc_bcons.clifd, &wb, 1);
+	(void) write(sc->usc_sock.clifd, &wb, 1);
 }
 #endif
 
@@ -491,7 +488,7 @@ uart_tty_drain(struct uart_softc *sc)
 }
 
 static int
-uart_bcons_drain(struct uart_softc *sc)
+uart_sock_drain(struct uart_softc *sc)
 {
 	char ch;
 	int nbytes;
@@ -504,10 +501,10 @@ uart_bcons_drain(struct uart_softc *sc)
 	pthread_mutex_lock(&sc->mtx);
 
 	if ((sc->mcr & MCR_LOOPBACK) != 0) {
-		(void) read(sc->usc_bcons.clifd, &ch, 1);
+		(void) read(sc->usc_sock.clifd, &ch, 1);
 	} else {
-		for (;;) {
-			nbytes = read(sc->usc_bcons.clifd, &ch, 1);
+		while (rxfifo_available(sc)) {
+			nbytes = read(sc->usc_sock.clifd, &ch, 1);
 			if (nbytes == 0) {
 				ret = 1;
 				break;
@@ -565,8 +562,8 @@ uart_write(struct uart_softc *sc, int offset, uint8_t value)
 		} else if (sc->tty.opened) {
 			ttywrite(&sc->tty, value);
 #ifndef	__FreeBSD__
-		} else if (sc->bcons) {
-				bconswrite(sc, value);
+		} else if (sc->sock) {
+			sockwrite(sc, value);
 #endif
 		} /* else drop on floor */
 		sc->thre_int_pending = true;
@@ -765,165 +762,77 @@ uart_tty_thread(void *param)
 	return (NULL);
 }
 
-/*
- * Read the "ident" string from the client's descriptor; this routine also
- * tolerates being called with pid=NULL, for times when you want to "eat"
- * the ident string from a client without saving it.
- */
 static int
-get_client_ident(int clifd, pid_t *pid)
-{
-	char buf[BUFSIZ], *bufp;
-	size_t buflen = sizeof (buf);
-	char c = '\0';
-	int i = 0, r;
-
-	/* "eat up the ident string" case, for simplicity */
-	if (pid == NULL) {
-		while (read(clifd, &c, 1) == 1) {
-			if (c == '\n')
-				return (0);
-		}
-	}
-
-	bzero(buf, sizeof (buf));
-	while ((buflen > 1) && (r = read(clifd, &c, 1)) == 1) {
-		buflen--;
-		if (c == '\n')
-			break;
-
-		buf[i] = c;
-		i++;
-	}
-	if (r == -1)
-		return (-1);
-
-	/*
-	 * We've filled the buffer, but still haven't seen \n.  Keep eating
-	 * until we find it; we don't expect this to happen, but this is
-	 * defensive.
-	 */
-	if (c != '\n') {
-		while ((r = read(clifd, &c, sizeof (c))) > 0)
-			if (c == '\n')
-				break;
-	}
-
-	/*
-	 * Parse buffer for message of the form: IDENT <pid>
-	 */
-	bufp = buf;
-	if (strncmp(bufp, "IDENT ", 6) != 0)
-		return (-1);
-	bufp += 6;
-	errno = 0;
-	*pid = strtoll(bufp, &bufp, 10);
-	if (errno != 0)
-		return (-1);
-
-	return (0);
-}
-
-static int
-uart_bcons_accept_client(struct uart_softc *sc)
+uart_sock_accept_client(struct uart_softc *sc)
 {
 	int connfd;
 	struct sockaddr_un cliaddr;
 	socklen_t clilen;
-	pid_t pid;
 
 	clilen = sizeof (cliaddr);
-	connfd = accept(sc->usc_bcons.servfd,
-			(struct sockaddr *)&cliaddr, &clilen);
-	if (connfd == -1)
-		return (-1);
-	if (get_client_ident(connfd, &pid) == -1) {
-		(void) shutdown(connfd, SHUT_RDWR);
-		(void) close(connfd);
+	connfd = accept(sc->usc_sock.servfd, (struct sockaddr *)&cliaddr,
+	    &clilen);
+	if (connfd == -1) {
 		return (-1);
 	}
-
 	if (fcntl(connfd, F_SETFL, O_NONBLOCK) < 0) {
 		(void) shutdown(connfd, SHUT_RDWR);
 		(void) close(connfd);
 		return (-1);
 	}
-	(void) write(connfd, "OK\n", 3);
 
-	sc->usc_bcons.clipid = pid;
-	sc->usc_bcons.clifd = connfd;
-
-	printf("Connection from process ID %lu.\n", pid);
+	sc->usc_sock.clifd = connfd;
 
 	return (0);
 }
 
 static void
-uart_bcons_reject_client(struct uart_softc *sc)
+uart_sock_reject_client(struct uart_softc *sc)
 {
 	int connfd;
 	struct sockaddr_un cliaddr;
 	socklen_t clilen;
-	char nak[MAXPATHLEN];
 
 	clilen = sizeof (cliaddr);
-	connfd = accept(sc->usc_bcons.servfd,
+	connfd = accept(sc->usc_sock.servfd,
 			(struct sockaddr *)&cliaddr, &clilen);
 
-	/*
-	 * After hear its ident string, tell client to get lost.
-	 */
-	if (get_client_ident(connfd, NULL) == 0) {
-		(void) snprintf(nak, sizeof (nak), "%lu\n",
-		    sc->usc_bcons.clipid);
-		(void) write(connfd, nak, strlen(nak));
-	}
+	(void) fprintf(stderr, "Shutting down unexpected client connection\n");
 	(void) shutdown(connfd, SHUT_RDWR);
 	(void) close(connfd);
 }
 
-static int
-uart_bcons_client_event(struct uart_softc *sc)
+static void
+uart_sock_client_event(struct uart_softc *sc)
 {
 	int res;
 
-	res = uart_bcons_drain(sc);
+	res = uart_sock_drain(sc);
 	if (res < 0)
-		return (-1);
+		return;
 
 	if (res > 0) {
-		fprintf(stderr, "Closing connection with bhyve console\n");
-		(void) shutdown(sc->usc_bcons.clifd, SHUT_RDWR);
-		(void) close(sc->usc_bcons.clifd);
-		sc->usc_bcons.clifd = -1;
+		fprintf(stderr, "Closing connection with bhyve socket\n");
+		(void) shutdown(sc->usc_sock.clifd, SHUT_RDWR);
+		(void) close(sc->usc_sock.clifd);
+		sc->usc_sock.clifd = -1;
 	}
-
-	return (0);
 }
 
 static void
-uart_bcons_server_event(struct uart_softc *sc)
+uart_sock_server_event(struct uart_softc *sc)
 {
-#if notyet
-	int clifd;
-#endif
-
-	if (sc->usc_bcons.clifd != -1) {
+	if (sc->usc_sock.clifd != -1) {
 		/* we're already handling a client */
-		uart_bcons_reject_client(sc);
+		uart_sock_reject_client(sc);
 		return;
 	}
 
-	if (uart_bcons_accept_client(sc) == 0) {
-		pthread_mutex_lock(&bcons_wait_lock);
-		bcons_connected = B_TRUE;
-		pthread_cond_signal(&bcons_wait_done);
-		pthread_mutex_unlock(&bcons_wait_lock);
-	}
+	uart_sock_accept_client(sc);
 }
 
 static void *
-uart_bcons_thread(void *param)
+uart_sock_thread(void *param)
 {
 	struct uart_softc *sc = param;
 	struct pollfd pollfds[2];
@@ -937,8 +846,8 @@ uart_bcons_thread(void *param)
 	pollfds[1].events = pollfds[0].events;
 
 	for (;;) {
-		pollfds[0].fd = sc->usc_bcons.clifd;
-		pollfds[1].fd = sc->usc_bcons.servfd;
+		pollfds[0].fd = sc->usc_sock.clifd;
+		pollfds[1].fd = sc->usc_sock.servfd;
 		pollfds[0].revents = pollfds[1].revents = 0;
 
 		res = poll(pollfds,
@@ -954,8 +863,7 @@ uart_bcons_thread(void *param)
 		if (pollfds[0].revents) {
 			if (pollfds[0].revents &
 			    (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI)) {
-				if (uart_bcons_client_event(sc) < 0)
-					break;
+				uart_sock_client_event(sc);
 			} else {
 				break;
 			}
@@ -964,57 +872,56 @@ uart_bcons_thread(void *param)
 		/* event from server socket */
 		if (pollfds[1].revents) {
 			if (pollfds[1].revents & (POLLIN | POLLRDNORM)) {
-				uart_bcons_server_event(sc);
+				uart_sock_server_event(sc);
 			} else {
 				break;
 			}
 		}
 	}
 
-	if (sc->usc_bcons.clifd != -1) {
+	if (sc->usc_sock.clifd != -1) {
 		fprintf(stderr, "Closing connection with bhyve console\n");
-		(void) shutdown(sc->usc_bcons.clifd, SHUT_RDWR);
-		(void) close(sc->usc_bcons.clifd);
-		sc->usc_bcons.clifd = -1;
+		(void) shutdown(sc->usc_sock.clifd, SHUT_RDWR);
+		(void) close(sc->usc_sock.clifd);
+		sc->usc_sock.clifd = -1;
 	}
 
 	return (NULL);
 }
 
 static int
-init_bcons_sock(void)
+init_sock(const char *path)
 {
 	int servfd;
 	struct sockaddr_un servaddr;
 
-	if (mkdir(BHYVE_TMPDIR, S_IRWXU) < 0 && errno != EEXIST) {
-		fprintf(stderr, "bhyve console setup: "
-		    "could not mkdir %s", BHYVE_TMPDIR, strerror(errno));
-		return (-1);
-	}
-
 	bzero(&servaddr, sizeof (servaddr));
 	servaddr.sun_family = AF_UNIX;
-	(void) snprintf(servaddr.sun_path, sizeof (servaddr.sun_path),
-	    BHYVE_CONS_SOCKPATH, vmname);
+
+	if (strlcpy(servaddr.sun_path, path, sizeof (servaddr.sun_path)) >=
+	    sizeof (servaddr.sun_path)) {
+		(void) fprintf(stderr, "bhyve socket setup: path '%s' "
+		    "too long\n", path);
+		return (-1);
+	}
 
 	if ((servfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
-		fprintf(stderr, "bhyve console setup: "
-		    "could not create socket\n");
+		(void) fprintf(stderr, "bhyve socket setup: "
+		    "could not create socket: %s\n", strerror(errno));
 		return (-1);
 	}
 	(void) unlink(servaddr.sun_path);
 
 	if (bind(servfd, (struct sockaddr *)&servaddr,
 	    sizeof (servaddr)) == -1) {
-		fprintf(stderr, "bhyve console setup: "
-		    "could not bind to socket\n");
+		fprintf(stderr, "bhyve socket setup: "
+		    "could not bind to socket: %s\n", strerror(errno));
 		goto out;
         }
 
-        if (listen(servfd, 4) == -1) {
+        if (listen(servfd, 1) == -1) {
 		fprintf(stderr, "bhyve console setup: "
-		    "could not listen on socket");
+		    "could not listen on socket: %s\n", strerror(errno));
 		goto out;
         }
         return (servfd);
@@ -1024,7 +931,7 @@ out:
         (void) close(servfd);
         return (-1);
 }
-#endif
+#endif /* not __FreeBSD__ */
 
 int
 uart_legacy_alloc(int which, int *baseaddr, int *irq)
@@ -1077,6 +984,55 @@ uart_tty_backend(struct uart_softc *sc, const char *opts)
 	return (retval);
 }
 
+#ifndef __FreeBSD__
+static int
+uart_sock_backend(struct uart_softc *sc, const char *inopts)
+{
+	char *opts;
+	char *opt;
+	char *nextopt;
+	char *path = NULL;
+	int error;
+
+	if (strncmp(inopts, "socket,", 7) != 0) {
+		return (-1);
+	}
+	if ((opts = strdup(inopts + 7)) == NULL) {
+		return (-1);
+	}
+
+	nextopt = opts;
+	for (opt = strsep(&nextopt, ","); opt != NULL;
+	    opt = strsep(&nextopt, ",")) {
+		if (path == NULL && *opt == '/') {
+			path = opt;
+			continue;
+		}
+		/*
+		 * XXX check for server and client options here.  For now,
+		 * everything is a server
+		 */
+		free(opts);
+		return (-1);
+	}
+
+	sc->usc_sock.clifd = -1;
+	if ((sc->usc_sock.servfd = init_sock(path)) == -1) {
+		fprintf(stderr, "bhyve serial setup: socket initialization "
+		    "of '%s' failed\n", path);
+		free(opts);
+		return (-1);
+	}
+	error = pthread_create(NULL, NULL, uart_sock_thread, sc);
+	assert(error == 0);
+
+	sc->sock = true;
+	sc->tty.fd = -1;
+
+	return (0);
+}
+#endif /* not __FreeBSD__ */
+
 int
 uart_set_backend(struct uart_softc *sc, const char *opts)
 {
@@ -1096,36 +1052,22 @@ uart_set_backend(struct uart_softc *sc, const char *opts)
 		return (0);
 
 	if (strcmp("stdio", opts) == 0) {
-		if (!uart_stdio && !uart_bcons) {
+		if (!uart_stdio) {
 			sc->tty.fd = STDIN_FILENO;
 			sc->tty.opened = true;
 			uart_stdio = true;
 			retval = 0;
 		}
+#ifndef __FreeBSD__
+	} else if (strncmp("socket,", opts, 7) == 0) {
+		return (uart_sock_backend(sc, opts));
+#endif
 	} else if (uart_tty_backend(sc, opts) == 0) {
 		retval = 0;
-	} else if (strstr(opts, "bcons") != 0 && !uart_stdio && !uart_bcons) {
-		sc->bcons = true;
-		uart_bcons= true;
-
-		if (strstr(opts, "bcons,wait") != 0) {
-			bcons_wait = true;
-		}
-
-		sc->usc_bcons.clifd = -1;
-		if ((sc->usc_bcons.servfd = init_bcons_sock()) == -1) {
-			fprintf(stderr, "bhyve console setup: "
-			    "socket initialization failed\n");
-			return (-1);
-		}
-		error = pthread_create(NULL, NULL, uart_bcons_thread, sc);
-		assert(error == 0);
-
-		return (0);
 	}
 
 	/* Make the backend file descriptor non-blocking */
-	if (retval == 0)
+	if (retval == 0 && sc->tty.fd != -1)
 		retval = fcntl(sc->tty.fd, F_SETFL, O_NONBLOCK);
 
 #ifndef WITHOUT_CAPSICUM
diff --git a/usr/src/cmd/bhyveconsole/Makefile b/usr/src/cmd/bhyveconsole/Makefile
deleted file mode 100644
index 7ebdb8f60f..0000000000
--- a/usr/src/cmd/bhyveconsole/Makefile
+++ /dev/null
@@ -1,44 +0,0 @@
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright 2013 Pluribus Networks Inc.
-# Copyright 2017 Joyent, Inc.
-#
-
-include ../Makefile.cmd
-
-PROG=	bhyveconsole
-
-SUBDIRS= $(MACH)
-
-all	:=	TARGET = all
-install	:=	TARGET = install
-clean	:=	TARGET = clean
-clobber	:=	TARGET = clobber
-lint	:=	TARGET = lint
-
-.KEEP_STATE:
-
-all:	$(SUBDIRS)
-
-clean clobber lint:	$(SUBDIRS)
-
-install:	$(SUBDIRS)
-	-$(RM) $(ROOTUSRSBINPROG)
-	-$(LN) $(ISAEXEC) $(ROOTUSRSBINPROG)
-
-$(SUBDIRS):	FRC
-	@cd $@; pwd; $(MAKE) CW_NO_SHADOW=true __GNUC= $(TARGET)
-
-FRC:
-
-include ../Makefile.targ
diff --git a/usr/src/cmd/bhyveconsole/bhyveconsole.c b/usr/src/cmd/bhyveconsole/bhyveconsole.c
deleted file mode 100644
index 19cf472ee5..0000000000
--- a/usr/src/cmd/bhyveconsole/bhyveconsole.c
+++ /dev/null
@@ -1,361 +0,0 @@
-/*
- * This file and its contents are supplied under the terms of the
- * Common Development and Distribution License ("CDDL"), version 1.0.
- * You may only use this file in accordance with the terms of version
- * 1.0 of the CDDL.
- *
- * A full copy of the text of the CDDL should have accompanied this
- * source.  A copy of the CDDL is also available via the Internet at
- * http://www.illumos.org/license/CDDL.
- */
-
-/*
- * Copyright 2013 Pluribus Networks Inc.
- * Copyright 2017 Joyent, Inc.
- */
-
-#include <sys/param.h>
-#include <sys/signal.h>
-#include <sys/socket.h>
-#include <sys/termios.h>
-#include <assert.h>
-#include <errno.h>
-#include <libgen.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <strings.h>
-#include <unistd.h>
-#include <stdlib.h>
-
-#include <bhyve.h>
-
-static int masterfd;
-static struct termios save_termios;
-static int save_fd;
-
-static int nocmdchar = 0;
-static char cmdchar = '~';
-
-static const char *pname;
-
-#define	BCONS_BUFSIZ		8192
-
-static void
-usage(void)
-{
-	(void) fprintf(stderr, "usage: %s vmname\n", pname);
-	exit(2);
-}
-
-static void
-bcons_error(const char *fmt, ...)
-{
-	va_list alist;
-
-	(void) fprintf(stderr, "%s: ", pname);
-	va_start(alist, fmt);
-	(void) vfprintf(stderr, fmt, alist);
-	va_end(alist);
-	(void) fprintf(stderr, "\n");
-}
-
-static void
-bcons_perror(const char *str)
-{
-	const char *estr;
-
-	if ((estr = strerror(errno)) != NULL)
-		(void) fprintf(stderr, "%s: %s: %s\n", pname, str, estr);
-	else
-		(void) fprintf(stderr, "%s: %s: errno %d\n", pname, str, errno);
-}
-
-/*
- * Create the unix domain socket and call bhyve; handshake
- * with it to determine whether it will allow us to connect.
- */
-static int
-get_console(const char *vmname)
-{
-	int sockfd = -1;
-	struct sockaddr_un servaddr;
-	char clientid[MAXPATHLEN];
-	char handshake[MAXPATHLEN], c;
-	int msglen;
-	int i = 0, err = 0;
-
-	if ((sockfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
-		bcons_perror("could not create socket");
-		return (-1);
-	}
-
-	bzero(&servaddr, sizeof (servaddr));
-	servaddr.sun_family = AF_UNIX;
-	(void) snprintf(servaddr.sun_path, sizeof (servaddr.sun_path),
-	    BHYVE_CONS_SOCKPATH, vmname);
-
-	if (connect(sockfd, (struct sockaddr *)&servaddr,
-	    sizeof (servaddr)) == -1) {
-		bcons_perror("Could not connect to console server");
-		goto bad;
-	}
-	masterfd = sockfd;
-
-	msglen = snprintf(clientid, sizeof (clientid), "IDENT %lu\n",
-	    getpid());
-	assert(msglen > 0 && msglen < sizeof (clientid));
-
-	if (write(masterfd, clientid, msglen) != msglen) {
-		bcons_error("protocol error");
-		goto bad;
-	}
-
-	/*
-	 * Take care not to accumulate more than our fill, and leave room for
-	 * the NUL at the end.
-	 */
-	while ((err = read(masterfd, &c, 1)) == 1) {
-		if (i >= (sizeof (handshake) - 1))
-			break;
-		if (c == '\n')
-			break;
-		handshake[i] = c;
-		i++;
-	}
-	handshake[i] = '\0';
-
-	/*
-	 * If something went wrong during the handshake we bail; perhaps
-	 * the server died off.
-	 */
-	if (err == -1) {
-		bcons_perror("Could not connect to console server");
-		goto bad;
-	}
-
-	if (strncmp(handshake, "OK", sizeof (handshake)) == 0)
-		return (0);
-
-	bcons_error("Console is already in use by process ID %s.",
-	    handshake);
-bad:
-	(void) close(sockfd);
-	masterfd = -1;
-	return (-1);
-}
-
-/*
- * Place terminal into raw mode.
- */
-static int
-set_tty_rawmode(int fd)
-{
-	struct termios term;
-	if (tcgetattr(fd, &term) < 0) {
-		bcons_perror("failed to get user terminal settings");
-		return (-1);
-	}
-
-	/* Stash for later, so we can revert back to previous mode */
-	save_termios = term;
-	save_fd = fd;
-
-	/* disable 8->7 bit strip, start/stop, enable any char to restart */
-	term.c_iflag &= ~(ISTRIP|IXON|IXANY);
-	/* disable NL->CR, CR->NL, ignore CR, UPPER->lower */
-	term.c_iflag &= ~(INLCR|ICRNL|IGNCR|IUCLC);
-	/* disable output post-processing */
-	term.c_oflag &= ~OPOST;
-	/* disable canonical mode, signal chars, echo & extended functions */
-	term.c_lflag &= ~(ICANON|ISIG|ECHO|IEXTEN);
-
-	term.c_cc[VMIN] = 1;    /* byte-at-a-time */
-	term.c_cc[VTIME] = 0;
-
-	if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &term)) {
-		bcons_perror("failed to set user terminal to raw mode");
-		return (-1);
-	}
-
-	return (0);
-}
-
-/*
- * reset terminal settings for global environment
- */
-static void
-reset_tty(void)
-{
-	(void) tcsetattr(save_fd, TCSADRAIN, &save_termios);
-}
-
-/*
- * process_user_input watches the input stream for the escape sequence for
- * 'quit' (by default, tilde-period).  Because we might be fed just one
- * keystroke at a time, state associated with the user input (are we at the
- * beginning of the line?  are we locally echoing the next character?) is
- * maintained by beginning_of_line and local_echo across calls to the routine.
- *
- * This routine returns -1 when the 'quit' escape sequence has been issued,
- * or an error is encountered and 0 otherwise.
- */
-static int
-process_user_input(int out_fd, int in_fd)
-{
-	static boolean_t beginning_of_line = B_TRUE;
-	static boolean_t local_echo = B_FALSE;
-	char ibuf[BCONS_BUFSIZ];
-	int nbytes;
-	char *buf = ibuf;
-	char c;
-
-	nbytes = read(in_fd, ibuf, sizeof (ibuf));
-	if (nbytes == -1 && errno != EINTR)
-		return (-1);
-
-	if (nbytes == -1)	/* The read was interrupted. */
-		return (0);
-
-	for (c = *buf; nbytes > 0; c = *buf, --nbytes) {
-		buf++;
-		if (beginning_of_line && !nocmdchar) {
-			beginning_of_line = B_FALSE;
-			if (c == cmdchar) {
-				local_echo = B_TRUE;
-				continue;
-			}
-		} else if (local_echo) {
-			local_echo = B_FALSE;
-			if (c == '.') {
-				(void) write(STDOUT_FILENO, &cmdchar, 1);
-				(void) write(STDOUT_FILENO, &c, 1);
-				return (-1);
-			}
-		}
-
-		(void) write(out_fd, &c, 1);
-
-		beginning_of_line = (c == '\r' || c == '\n');
-	}
-
-	return (0);
-}
-
-static int
-process_output(int in_fd, int out_fd)
-{
-	int wrote = 0;
-	int cc;
-	char ibuf[BCONS_BUFSIZ];
-
-	cc = read(in_fd, ibuf, sizeof (ibuf));
-	if (cc == -1 && errno != EINTR)
-		return (-1);
-	if (cc == 0)	/* EOF */
-		return (-1);
-	if (cc == -1)	/* The read was interrupted. */
-		return (0);
-
-	do {
-		int len;
-
-		len = write(out_fd, ibuf + wrote, cc - wrote);
-		if (len == -1 && errno != EINTR)
-			return (-1);
-		if (len != -1)
-			wrote += len;
-	} while (wrote < cc);
-
-	return (0);
-}
-
-/*
- * This is the main I/O loop.
- */
-static void
-doio(void)
-{
-	struct pollfd pollfds[2];
-	const short read_ev = POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI;
-	int res;
-
-	/* read from vm and write to stdout */
-	pollfds[0].fd = masterfd;
-	pollfds[0].events = read_ev;
-
-	/* read from stdin and write to vm */
-	pollfds[1].fd = STDIN_FILENO;
-	pollfds[1].events = pollfds[0].events;
-
-	for (;;) {
-		pollfds[0].revents = pollfds[1].revents = 0;
-
-		res = poll(pollfds,
-		    sizeof (pollfds) / sizeof (struct pollfd), -1);
-
-		if (res == -1 && errno != EINTR) {
-			bcons_perror("poll failed");
-			/* we are hosed, close connection */
-			break;
-		}
-
-		/* event from master side stdout */
-		if (pollfds[0].revents) {
-			if (pollfds[0].revents &
-			    (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI)) {
-				if (process_output(masterfd, STDOUT_FILENO)
-				    != 0)
-					break;
-			} else {
-				break;
-			}
-		}
-
-		/* event from user stdin side */
-		if (pollfds[1].revents) {
-			if ((pollfds[1].revents & read_ev) != 0 &&
-			    process_user_input(masterfd, STDIN_FILENO) == 0) {
-				continue;
-			} else {
-				break;
-			}
-		}
-	}
-}
-
-int
-main(int argc, char **argv)
-{
-	char *vmname = NULL;
-
-	pname = basename(argv[0]);
-
-	if (argc == 2) {
-		vmname = argv[1];
-	} else {
-		usage();
-	}
-
-	/*
-	 * Make contact with bhyve
-	 */
-	if (get_console(vmname) == -1)
-		return (1);
-
-	(void) printf("[Connected to vm '%s' console]\n", vmname);
-
-	if (set_tty_rawmode(STDIN_FILENO) == -1) {
-		reset_tty();
-		bcons_perror("failed to set stdin pty to raw mode");
-		return (1);
-	}
-
-	/*
-	 * Run the I/O loop until we get disconnected.
-	 */
-	doio();
-	reset_tty();
-	(void) printf("\n[Connection to vm '%s' console closed]\n", vmname);
-
-	return (0);
-}
diff --git a/usr/src/cmd/bhyveconsole/i386/Makefile b/usr/src/cmd/bhyveconsole/i386/Makefile
deleted file mode 100644
index c4f317a9fa..0000000000
--- a/usr/src/cmd/bhyveconsole/i386/Makefile
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright 2013 Pluribus Networks Inc.
-#
-
-PROG=	bhyveconsole
-
-OBJS=	bhyveconsole.o
-
-SRCS=	$(OBJS:%.o=../%.c)
-
-include ../../Makefile.cmd
-
-CFLAGS	+= $(CCVERBOSE)
-LDLIBS += -lsocket
-
-.KEEP_STATE:
-
-%.o:	../%.c
-	$(COMPILE.c) $<
-
-all: $(PROG)
-
-$(PROG): $(OBJS)
-	$(LINK.c) $(OBJS) -o $@ $(LDLIBS)
-	$(POST_PROCESS)
-
-install: all $(ROOTUSRSBINPROG32)
-
-clean:
-	$(RM) $(OBJS)
-
-include ../../Makefile.targ
-- 
2.21.0

