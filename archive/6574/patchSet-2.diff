commit c13748f7de21dadfe2ed57e0d678fc02aa5e449d
Author: Isaac Davis <isaac.davis@joyent.com>
Date:   2019-07-09T01:31:27+00:00 (3 months ago)
    
    MANTA-4375 port manta-create-topology.sh to node
    MANTA-4376 expand manta-create-topology to support buckets

diff --git a/bin/manta-create-topology.sh b/bin/manta-create-topology.sh
index 4155afb..0f1dd49 100755
--- a/bin/manta-create-topology.sh
+++ b/bin/manta-create-topology.sh
@@ -6,145 +6,9 @@
 #
 
 #
-# Copyright (c) 2014, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
-echo ""
-export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
-
-set -o errexit
-set -o pipefail
-set -o xtrace
-
-function fatal {
-    echo "$(basename $0): fatal error: $*" >&2
-    exit 1
-}
-
-DIR=$(dirname $(dirname $0))
-VNODES=
-PORT=
-PNODES=
-MANIFEST_PNODES=
-RING_IMAGE="/var/tmp/$(uuid).ring.tar.gz"
-RING_IMAGE_MANIFEST="/var/tmp/$(uuid).ring.manifest.json"
-SAPI_URL=$(cat $DIR/etc/config.json | json sapi.url)
-[[ -n $SAPI_URL ]] || fatal "no SAPI_URL"
-CURRENT_RING_IMAGE=$(curl -s "$SAPI_URL/applications?name=manta&include_master=true"\
-    | json -Ha metadata.HASH_RING_IMAGE)
-POSEIDON_UUID=$(curl -s "$SAPI_URL/applications?name=manta&include_master=true"\
-    | json -Ha owner_uuid)
-[[ -n $POSEIDON_UUID ]] || fatal "no POSEIDON_UUID found"
-export SDC_IMGADM_URL=$(cat /opt/smartdc/manta-deployment/etc/config.json | json imgapi.url)
-[[ -n $SDC_IMGADM_URL ]] || fatal "no SDC_IMGAPI_URL found"
-RING_LOCATION_PREFIX=/var/tmp/$(uuid)/hash_ring
-RING_LOCATION=$RING_LOCATION_PREFIX/hash_ring
-mkdir -p $RING_LOCATION
-MANTA_APPLICATION=$(curl -s \
-    "$SAPI_URL/applications?name=manta&include_master=true" | json -Ha uuid)
-[[ -n $MANTA_APPLICATION ]] || fatal "no MANTA_APPLICATION found"
-IMAGE_UUID=$(uuid -v4)
-FORCE=0
-
-function usage() {
-    if [[ -n "$1" ]]
-    then
-        echo "error: $1"
-        echo ""
-    fi
-    echo "Usage:"
-    echo "  $0 -v <vnodes> -p <moray port>"
-    echo "Creates a consistent hash ring used by electric-moray. The ring is"
-    echo "created and uploaded to imgapi. The resulting img UUID is persisted"
-    echo "in SAPI on the Manta application as metadata.HASH_RING_IMAGE"
-    echo ""
-    echo "WARNING: Run this command with care, improper use such as generating "
-    echo "a bad ring or a different ring in production will result in the "
-    echo "corruption of Manta metadata."
-    exit 2
-}
-
-function fatal {
-    echo "$(basename $0): error: $1"
-    exit 1
-}
-
-function ring_exists {
-    echo "ring exists with uuid $CURRENT_RING_IMAGE"
-    exit 3
-}
-
-[[ -n $1 ]] || usage
-
-while getopts "hv:p:f" c; do
-    case "$c" in
-    h)
-        usage
-        ;;
-    f)
-        FORCE=1
-        ;;
-    v)
-        VNODES=$OPTARG
-        ;;
-    p)
-        PORT=$OPTARG
-        ;;
-    *)
-        usage "illegal option -- $OPTARG"
-        ;;
-    esac
-done
-shift $((OPTIND - 1))
-
-#
-# Mainline
-#
-
-# make sure no previous topology image exists
-if [[ $FORCE -eq 0 ]]
-then
-    if [[ -n $CURRENT_RING_IMAGE ]]
-    then
-        ring_exists
-    fi
-fi
-
-# get the index nodes, put them all on one line and prepend tcp:// to each node
-PNODES=$(for i in $( manta-shardadm list | \
-    grep Index | awk '{print $2}'); do echo tcp://$i:$PORT; done | tr -s '\n' ' ')
-[[ -n $PNODES ]] || fatal "no index shards found"
-MANIFEST_PNODES=$(echo $PNODES | tr ' ' '-'| tr -d ':' | tr -d '/')
-
-fash create -v $VNODES -l $RING_LOCATION -b leveldb -p "$PNODES"
-/usr/bin/tar -czf $RING_IMAGE -C $RING_LOCATION_PREFIX hash_ring
-cat <<HERE > $RING_IMAGE_MANIFEST
-{
-    "v": 2,
-    "uuid": "$IMAGE_UUID",
-    "owner": "$POSEIDON_UUID",
-    "name": "manta-hash-ring",
-    "version": "$(date +%Y%m%dT%H%m%SZ)",
-    "state": "active",
-    "public": false,
-    "published_at": "$(node -e 'console.log(new Date().toISOString())')",
-    "type": "other",
-    "os": "other",
-    "files": [
-    {
-        "sha1": "$(sha1sum $RING_IMAGE | tr -s ' '| cut -d ' ' -f1)",
-        "size": $(stat -c %s $RING_IMAGE),
-        "compression": "gzip"
-    }
-    ],
-    "description": "Manta Hash Ring"
-}
-HERE
-
-sdc-imgadm import -m $RING_IMAGE_MANIFEST -f $RING_IMAGE
-
-curl --connect-timeout 10 -fsS -i -H accept:application/json \
-    -H content-type:application/json\
-    --url "$SAPI_URL/applications/$MANTA_APPLICATION" \
-    -X PUT -d \
-    "{ \"action\": \"update\", \"metadata\": { \"HASH_RING_IMAGE\": \"$IMAGE_UUID\", \"HASH_RING_IMGAPI_SERVICE\": \"$SDC_IMGADM_URL\" } }"
+echo 'This script is deprecated.'
+echo 'Please use `manta-adm create-topology` instead.'
+exit 1
\ No newline at end of file
diff --git a/bin/manta-deploy-dev b/bin/manta-deploy-dev
index 4e5615c..4f412e1 100755
--- a/bin/manta-deploy-dev
+++ b/bin/manta-deploy-dev
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2018, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 #
@@ -83,11 +83,8 @@ manta-shardadm set -m "1.moray"
 manta-shardadm set -s "1.moray"
 
 set +o errexit
-manta-create-topology.sh -v $mdl_topo_size -p 2020
+manta-adm create-topology -v $mdl_topo_size -p 2020
 case "$?" in
-	3)
-		echo "hash ring already exists"
-		;;
 	0)
 		echo "successfully generated hash ring"
 		;;
diff --git a/cmd/manta-adm.js b/cmd/manta-adm.js
index a795f4d..6b6bfa3 100755
--- a/cmd/manta-adm.js
+++ b/cmd/manta-adm.js
@@ -7,7 +7,7 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -30,6 +30,10 @@
  *
  *     zk		view and manage configured nameserver instances
  *
+ *     accel-gc         configure accelerated garbage-collection
+ *
+ *     create-topology  generate a hash ring for electric-moray
+ *
  * NOTE: this file contains ONLY the CLI wrapper around the real functionality
  * contained in lib/adm.js.  Do NOT add deployment logic here.  It belongs in
  * the library that can eventually be consumed by other tools.
@@ -2320,6 +2324,86 @@ MantaAdmAlarmProbeGroup.prototype.do_list.options = [
     maCommonOptions.configFile
 ];
 
+MantaAdm.prototype.do_create_topology = function (subcmd, opts, args, callback)
+{
+	var self = this;
+
+	if (args.length > 0) {
+		callback(new Error('unexpected arguments'));
+		return;
+	}
+	if (!opts.t) {
+		callback(new VError('argument is required: --t'));
+		return;
+	}
+	if (opts.t !== 'directory' && opts.t !== 'buckets') {
+		callback(new VError('unsupported value for --t: %s. Valid ' +
+		    'values are "directory" and "buckets".', opts.t));
+		return;
+	}
+	if (!opts.v) {
+		callback(new VError('argument is required: --v'));
+		return;
+	}
+	if (!opts.p) {
+		callback(new VError('argument is required: --p'));
+		return;
+	}
+	var force = opts.f === true;
+
+	self.initAdm(opts, function initCb() {
+		var adm = self.madm_adm;
+		adm.createTopology({
+			buckets: opts.t === 'buckets',
+			vnodes: opts.v,
+			port: opts.p,
+			force: force
+		}, function createdTopology(err) {
+			if (err) {
+				fatal(err.message);
+			}
+			self.finiAdm();
+		});
+	});
+};
+
+MantaAdm.prototype.do_create_topology.help =
+    'Creates a consistent hash ring used by electric-moray.\n' +
+    'The ring is created and uploaded to imgapi. The resulting image UUID\n' +
+    'is persisted in SAPI on the Manta application as\n' +
+    'metadata.HASH_RING_IMAGE\n' +
+    '\n' +
+    'WARNING: Run this command with care. Improper use such as generating \n' +
+    'a bad ring or a different ring in production will result in the \n' +
+    'corruption of Manta metadata.\n' +
+    '\n' +
+    'Usage:\n' +
+    '  manta-adm create-topology -t <ring type> -v <vnodes> -p <moray port>\n';
+
+MantaAdm.prototype.do_create_topology.options = [
+    maCommonOptions.logFile,
+{
+    'names': [ 't' ],
+    'type': 'string',
+    'default': 'directory',
+    'helpArg': 'TYPE',
+    'help': 'Type of ring to create. Valid values are "directory" and "buckets"'
+}, {
+    'names': [ 'v' ],
+    'type': 'integer',
+    'helpArg': 'VNODES',
+    'help': 'Number of vnodes to include in the ring'
+}, {
+    'names': [ 'p' ],
+    'type': 'integer',
+    'helpArg': 'PORT',
+    'help': 'Port of moray/boray instances that electric-moray will connect to'
+}, {
+    'names': [ 'f' ],
+    'type': 'bool',
+    'help': 'force generation of new hash ring even if one already exists in ' +
+	'SAPI metadata'
+} ];
 
 /*
  * Named arguments:
diff --git a/lib/adm.js b/lib/adm.js
index 8dda76c..ba6dd5a 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -14,16 +14,25 @@
 
 var assert = require('assert');
 var assertplus = require('assert-plus');
+var crypto = require('crypto');
+var exec = require('child_process').exec;
 var extsprintf = require('extsprintf');
+var fash = require('fash');
 var fs = require('fs');
+var fstream = require('fstream');
 var jsprim = require('jsprim');
+var mkdirp = require('mkdirp');
 var net = require('net');
+var node_uuid = require('node-uuid');
 var path = require('path');
 var sprintf = require('sprintf-js').sprintf;
 var tab = require('tab');
+var tar = require('tar');
 var util = require('util');
 var vasync = require('vasync');
+var verror = require('verror');
 var wordwrap = require('wordwrap');
+var zlib = require('zlib');
 
 var VError = require('verror').VError;
 var MultiError = require('verror').MultiError;
@@ -4803,6 +4812,508 @@ maAdm.prototype.auditZkServers = function ()
 	return (rv);
 };
 
+/*
+ * The implementation of the `manta-adm create-topology` command. Generates a
+ * hash ring image, uploads it to the datacenter's imgapi, activates the image,
+ * and updates the HASH_RING_IMAGE property of the manta SAPI application.
+ * This function's 'opts' argument requires the following fields:
+ *
+ * - buckets: a boolean indicating whether the hash ring is for use by the
+ *   buckets subsystem. This will cause a few important changes in the generated
+ *   ring:
+ *   - The ring will be stored in imgapi as serialized json rather than a full
+ *     leveldb image
+ *   - The serialized json will have a vnodeToPnodeMap field tacked on to it
+ *     before uploading, as node-fash does not include such a field when
+ *     serializing
+ *   - The ring will be generated using the manta application's
+ *     BUCKETS_MORAY_SHARDS SAPI variable instead of the INDEX_MORAY_SHARDS SAPI
+ *     variable
+ *   - The image uuid will be stored in the manta application's SAPI metadata
+ *     using a buckets-specific SAPI variable, BUCKETS_HASH_RING_IMAGE, so the
+ *     regular ring image uuid doesn't get overwritten.
+ *
+ * - vnodes: The number of vnodes the hash ring will support
+ *
+ * - port: the port of the moray instances that electric-moray instances using
+ *   the hash ring should connect to
+ *
+ * - force: a boolean indicating whether a new hash ring should be generated
+ *   and uploaded even if one already exists
+ */
+maAdm.prototype.createTopology = function createTopology(opts, callback)
+{
+	var self = this;
+
+	assertplus.object(opts, 'opts');
+	assertplus.func(callback, 'callback');
+	assertplus.bool(opts.buckets, 'opts.buckets');
+	assertplus.number(opts.vnodes, 'opts.vnodes');
+	assertplus.number(opts.port, 'opts.port');
+	assertplus.bool(opts.force, 'opts.force');
+
+	var buckets = opts.buckets;
+	var vnodes = opts.vnodes;
+	var port = opts.port;
+	var force = opts.force;
+
+	var sapi = self.ma_sdc.SAPI;
+	var imgapi = self.ma_sdc.IMGAPI;
+
+	var uuid = node_uuid.v4();
+
+	function getMantaApp(ctx, next) {
+		sapi.listApplications({
+			name: 'manta',
+			include_master: 'true'
+		}, function gotMantaApp(err, apps) {
+			if (err) {
+				next(err);
+				return;
+			}
+			assertplus.equal(apps.length, 1, 'exactly one ' +
+			    'application should exist with name "manta"');
+			ctx.mantaApp = apps[0];
+			next();
+		});
+	}
+
+	/*
+	 * Bail here if a ring already appears to exist in SAPI. This function
+	 * does nothing if the 'force' option is true.
+	 */
+	function checkRingExists(ctx, next) {
+		assertplus.object(ctx.mantaApp, 'ctx.mantaApp');
+		var mantaApp = ctx.mantaApp;
+		var key = buckets ? common.BUCKETS_HASH_RING_IMAGE :
+		    common.HASH_RING_IMAGE;
+		if (mantaApp.metadata[key] && !force) {
+			next(new VError(
+			    'Hash ring image already exists in SAPI metadata'));
+			return;
+		}
+		next();
+	}
+
+	/*
+	 * Creates two directories under /var/tmp/<uuid>: one for the
+	 * hash ring and one for the serialized hash ring.
+	 *
+	 * We'll only need the serialized hash ring dir if 'buckets' is true,
+	 * but we'll need the regular hash ring dir either way.
+	 */
+	function createRingDirs(ctx, next) {
+		ctx.ringLocation = sprintf('/var/tmp/%s/hash_ring', uuid);
+		ctx.serializedRingLocation =
+		    sprintf('/var/tmp/%s/hash_ring_serialized', uuid);
+
+		vasync.forEachParallel({
+			func: mkdirp,
+			inputs: [ctx.ringLocation, ctx.serializedRingLocation]
+		}, function madeDirs(err) {
+			if (err) {
+				next(err);
+				return;
+			}
+			self.ma_log.info({
+				ringLocation: ctx.ringLocation,
+				serializedRingLocation:
+				    ctx.serializedRingLocation
+			}, 'made hash ring directories');
+			next();
+		});
+	}
+
+	/*
+	 * This function makes the ring in the ringLocation directory. It also
+	 * stores a serialized version of the ring in 'ctx'.
+	 */
+	function createRing(ctx, next) {
+		assertplus.string(ctx.ringLocation, 'ctx.ringLocation');
+		var ringLocation = ctx.ringLocation;
+
+		var key = buckets ? common.BUCKETS_SHARDS : common.INDEX_SHARDS;
+		var shards = ctx.mantaApp.metadata[key];
+		if (!shards) {
+			next(new VError('"%s" metadata not found for manta ' +
+			    'SAPI application.', key));
+			return;
+		}
+		var pnodes = ctx.mantaApp.metadata[key].map(
+		    function processShard(shard) {
+			return (sprintf('tcp://%s:%s', shard.host, port));
+		});
+
+		fash.create({
+			log: self.ma_log,
+			algorithm: 'sha-256',
+			pnodes: pnodes,
+			vnodes: vnodes,
+			backend: fash.BACKEND.LEVEL_DB,
+			location: ringLocation
+		}, function createdRing(err, ring) {
+			if (err) {
+				next(err);
+				return;
+			}
+			ring.serialize(function serialized(suberr,
+			    serializedRing) {
+				if (suberr) {
+					next(suberr);
+					return;
+				}
+				ctx.serializedRing = JSON.parse(serializedRing);
+				self.ma_log.info({
+					serializedRing: serializedRing
+				}, 'generated hash ring');
+				next();
+			});
+		});
+	}
+
+	/*
+	 * This function translates the serialized ring's pnodeToVnodeMap to
+	 * a vnodeToPnodeMap and hangs the new map off of the serialized
+	 * ring object. electric-boray will use this vnodeToPnodeMap.
+	 */
+	function createVnodeToPnodeMap(ctx, next) {
+		if (!buckets) {
+			next();
+			return;
+		}
+		assertplus.object(ctx.serializedRing, 'ctx.serializedRing');
+		var serializedRing = ctx.serializedRing;
+
+		serializedRing.vnodeToPnodeMap = {};
+		jsprim.forEachKey(serializedRing.pnodeToVnodeMap,
+		    function iterPnode(pnode) {
+			jsprim.forEachKey(serializedRing.pnodeToVnodeMap[pnode],
+			    function iterVnode(vnode) {
+				serializedRing.vnodeToPnodeMap[vnode] = {
+					pnode: pnode
+				};
+			});
+		});
+		next();
+	}
+
+	/*
+	 * This function writes the serialized ring json to a file on disk. Does
+	 * nothing if 'buckets' is false, because the serialized ring is only
+	 * used in the buckets subsystem.
+	 */
+	function writeSerializedRing(ctx, next) {
+		if (!buckets) {
+			next();
+			return;
+		}
+		assertplus.object(ctx.serializedRing, 'ctx.serializedRing');
+		assertplus.string(ctx.serializedRingLocation,
+		    'ctx.serializedRingLocation');
+		var serializedRing = JSON.stringify(ctx.serializedRing);
+		var serializedRingLocation = ctx.serializedRingLocation;
+		var serializedRingName = sprintf('%s/ring.json',
+		    serializedRingLocation);
+
+		fs.writeFile(serializedRingName, serializedRing,
+		    function wroteFile(err) {
+			if (err) {
+				next(err);
+				return;
+			}
+			self.ma_log.info({
+				serializedRing: serializedRing,
+				serializedRingLocation: serializedRingLocation
+			}, 'wrote serialized ring');
+			next();
+		});
+	}
+
+	/*
+	 * This function compresses the hash ring into a gzip file. If 'buckets'
+	 * is true, the serialized ring json is compressed. If 'buckets' is
+	 * false, the entire leveldb database directory is compressed instead.
+	 */
+	function compressRing(ctx, next) {
+
+		assertplus.string(ctx.ringLocation, 'ctx.ringLocation');
+		assertplus.string(ctx.serializedRingLocation,
+		    'ctx.serializedRingLocation');
+
+		var ringLocation = buckets ? ctx.serializedRingLocation :
+		    ctx.ringLocation;
+
+		ctx.ringImage = sprintf('/var/tmp/%s.ring.tar.gz', uuid);
+
+		var ringImageStream = fs.createWriteStream(ctx.ringImage);
+		ringImageStream.on('finish', function compressedRing() {
+			self.ma_log.info({
+				ringImage: ctx.ringImage
+			}, 'compressed hash ring image');
+			next();
+		});
+		ringImageStream.on('error', next);
+
+		var packer = tar.Pack({ noProprietary: true });
+		packer.on('error', next);
+
+		var gzip = zlib.createGzip();
+		gzip.on('error', next);
+
+		var reader = fstream.Reader({
+			path: ringLocation,
+			type: 'Directory'
+		});
+		reader.on('error', next);
+		reader.pipe(packer).pipe(gzip).pipe(ringImageStream);
+	}
+
+	function getManifest(ctx, next) {
+		assertplus.string(ctx.ringImage, 'ctx.ringImage');
+		assertplus.object(ctx.mantaApp, 'ctx.mantaApp');
+		var ringImage = ctx.ringImage;
+		var mantaApp = ctx.mantaApp;
+
+		var poseidonUuid = mantaApp.owner_uuid;
+
+		var isoDate = new Date().toISOString();
+		/*
+		 * For the version string, we remove the colons, dashes, and
+		 * sub-seconds from the ISO string. This produces an identical
+		 * result to $(date +%Y%m%dT%H%m%SZ) in bash.
+		 */
+		var versionDate = isoDate.replace(/[:-]/g, '').
+		    replace(/\.[0-9]{3}/g, '');
+
+		function getImageDigest(subctx, subnext) {
+			var shasum = crypto.createHash('sha1');
+			var s = fs.ReadStream(ringImage);
+			s.on('data', function update(d) {
+				shasum.update(d);
+			});
+			s.on('end', function finished() {
+				subctx.digest = shasum.digest('hex');
+				subnext();
+			});
+		}
+
+		function getSize(subctx, subnext) {
+			fs.stat(ringImage, function gotStats(err, stats) {
+				if (err) {
+					subnext(err);
+					return;
+				}
+				subctx.size = stats.size;
+				subnext();
+			});
+		}
+
+		function generateManifest(subctx, subnext) {
+			assertplus.string(subctx.digest, 'subctx.digest');
+			assertplus.number(subctx.size, 'subctx.size');
+			var digest = subctx.digest;
+			var size = subctx.size;
+
+			ctx.manifest = {
+				v: 2,
+				uuid: node_uuid.v4(),
+				owner: poseidonUuid,
+				name: 'manta-hash-ring',
+				version: versionDate,
+				state: 'active',
+				public: false,
+				published_at: isoDate,
+				type: 'other',
+				os: 'other',
+				files: [
+					{
+						sha1: digest,
+						size: size,
+						compression: 'gzip'
+					}
+				],
+				description: 'Manta Hash Ring'
+			};
+			self.ma_log.info({
+				manifest: ctx.manifest
+			}, 'generated image manifest');
+			subnext();
+		}
+
+		vasync.pipeline({
+			arg: {}, // subctx
+			funcs: [
+				getImageDigest,
+				getSize,
+				generateManifest
+			]
+		}, next);
+	}
+
+	function importImage(ctx, next) {
+		assertplus.object(ctx.manifest, 'ctx.manifest');
+		var manifest = ctx.manifest;
+
+		imgapi.adminImportImage(manifest,
+		    function importedImage(err, image) {
+			if (err) {
+				next(err);
+				return;
+			}
+			self.ma_log.info({
+				image: image
+			}, 'imported hash ring image');
+			next();
+		});
+	}
+
+	function addImageFile(ctx, next) {
+		assertplus.object(ctx.manifest, 'ctx.manifest');
+		assertplus.string(ctx.ringImage, 'ctx.ringImage');
+		var manifest = ctx.manifest;
+		var ringImage = ctx.ringImage;
+		var fileObj = manifest.files[0];
+
+		imgapi.addImageFile({
+			uuid: manifest.uuid,
+			file: ringImage,
+			size: fileObj.size,
+			compression: fileObj.compression,
+			sha1: fileObj.sha1,
+			storage: 'manta'
+		}, function addedImageFile(err, image) {
+			if (err) {
+				rollbackImageOnErr(manifest.uuid,
+				    function rolledback(suberr) {
+					if (suberr) {
+						next(new verror.MultiError([
+							err,
+							suberr
+						]));
+						return;
+					}
+					next(err);
+				});
+				return;
+			}
+			self.ma_log.info({
+				image: image
+			}, 'added file to hash ring image');
+			next();
+		});
+	}
+
+	function activateImage(ctx, next) {
+		assertplus.object(ctx.manifest, 'ctx.manifest');
+		var manifest = ctx.manifest;
+
+		imgapi.activateImage(manifest.uuid,
+		    function activatedImage(err) {
+			if (err) {
+				rollbackImageOnErr(manifest.uuid,
+				    function rolledback(suberr) {
+					if (suberr) {
+						next(new verror.MultiError([
+							err,
+							suberr
+						]));
+						return;
+					}
+					next(err);
+				});
+				return;
+			}
+			self.ma_log.info({
+				uuid: manifest.uuid
+			}, 'activated hash ring image');
+			next();
+		});
+	}
+
+	function writeSapiData(ctx, next) {
+		assertplus.object(ctx.manifest, 'ctx.manifest');
+		assertplus.object(ctx.mantaApp, 'ctx.mantaApp');
+		var manifest = ctx.manifest;
+		var mantaApp = ctx.mantaApp;
+
+		var updateObj = {
+			metadata: {}
+		};
+		var key = buckets ? common.BUCKETS_HASH_RING_IMAGE :
+		    common.HASH_RING_IMAGE;
+		updateObj.metadata[key] = manifest.uuid;
+		updateObj.metadata[common.HASH_RING_IMGAPI_SERVICE] =
+		    imgapi.url;
+
+		sapi.updateApplication(mantaApp.uuid, updateObj,
+		    function updatedMantaApp(err) {
+			if (err) {
+				rollbackImageOnErr(manifest.uuid,
+				    function rolledback(suberr) {
+					if (suberr) {
+						next(new verror.MultiError([
+							err,
+							suberr
+						]));
+						return;
+					}
+					next(err);
+				});
+				return;
+			}
+			self.ma_log.info({
+				metadata: updateObj.metadata
+			}, 'updated "manta" SAPI application');
+			next();
+		});
+	}
+
+	vasync.pipeline({
+		arg: {}, // ctx
+		funcs: [
+			getMantaApp,
+			checkRingExists,
+			createRingDirs,
+			createRing,
+			createVnodeToPnodeMap,
+			writeSerializedRing,
+			compressRing,
+			getManifest,
+			importImage,
+			addImageFile,
+			activateImage,
+			writeSapiData
+		]
+	}, callback);
+
+	/*
+	 * Helper function to delete a partially-created image upon failure to
+	 * finish the image creation process. If this function itself fails, it
+	 * is up to the caller to handle reporting both the error that prompted
+	 * this function to be called and the error returned by this function.
+	 */
+	function rollbackImageOnErr(imageUuid, cb) {
+		assertplus.uuid(imageUuid, 'imageUuid');
+		assertplus.func(cb, 'cb');
+
+		self.ma_log.info({
+			imageUuid: imageUuid
+		}, 'rollback partially imported image');
+
+		imgapi.deleteImage(imageUuid, {}, function deletedImage(err) {
+			if (err) {
+				cb(err);
+				return;
+			}
+			self.ma_log.info({
+				imageUuid: imageUuid,
+				channel: imgapi.channel
+			}, 'deleted image');
+			cb();
+		});
+	}
+};
+
 function fmtListDateTime(ts)
 {
 	if (ts === null) {
diff --git a/lib/common.js b/lib/common.js
index 68634ab..2f1094f 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -44,6 +44,7 @@ exports.STORAGE_SHARD = 'STORAGE_MORAY_SHARD';
 exports.INDEX_SHARDS = 'INDEX_MORAY_SHARDS';
 exports.BUCKETS_SHARDS = 'BUCKETS_MORAY_SHARDS';
 exports.HASH_RING_IMAGE = 'HASH_RING_IMAGE';
+exports.BUCKETS_HASH_RING_IMAGE = 'BUCKETS_HASH_RING_IMAGE';
 exports.HASH_RING_IMGAPI_SERVICE = 'HASH_RING_IMGAPI_SERVICE';
 
 exports.CONFIG_FILE_DEFAULT = path.join(__dirname, '..', 'etc', 'config.json');
diff --git a/lib/deploy.js b/lib/deploy.js
index d375926..10c6508 100644
--- a/lib/deploy.js
+++ b/lib/deploy.js
@@ -225,7 +225,7 @@ function Deployer(ilog)
 			    md[common.HASH_RING_IMGAPI_SERVICE].length === 0) {
 				message = 'cannot deploy zones before hash ' +
 				    'ring topology has been created ' +
-				    '(see manta-create-topology.sh)';
+				    '(see `manta-adm create-topology`)';
 				err = new Error(message);
 				log.error(err);
 				setImmediate(cb, err);
diff --git a/package.json b/package.json
index 6956625..c456dc2 100644
--- a/package.json
+++ b/package.json
@@ -14,10 +14,12 @@
         "extsprintf": "1.3.0",
         "fash": "2.5.0",
         "forkexec": "0.1.0",
+        "fstream": "1.0.12",
         "hogan.js": "2.0.0",
         "imgapi-cli": "git+https://github.com/joyent/sdc-imgapi-cli.git#5e2b2ae757",
         "jsprim": "^1.4.0",
         "js-yaml": "3.8.2",
+        "mkdirp": "0.5.1",
         "node-uuid": "1.4.0",
         "optimist": "0.3.5",
         "once": "1.3.0",
@@ -28,6 +30,7 @@
         "sdc-clients": "13.0.1",
         "sprintf-js": "0.0.7",
         "tab": "0.1.0",
+        "tar": "2.2.2",
         "triton-netconfig": "1.4.0",
         "ufds": "1.6.0",
         "urclient": "1.0.0",
