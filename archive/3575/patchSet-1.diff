From a4cdca68aa53769883fb11b68da89fed829810ea Mon Sep 17 00:00:00 2001
From: Marsell Kukuljevic <marsell@joyent.com>
Date: Fri, 9 Mar 2018 23:47:16 +1030
Subject: [PATCH] TRITON-167 Anti-affinity rules fail when no instances match
 the name TRITON-168 Regex anti-affinity rules fail unexpectedly

---
 lib/do_instance/do_create.js          | 178 +++++++++-----------------
 test/integration/cli-affinity.test.js |   6 +-
 2 files changed, 63 insertions(+), 121 deletions(-)

diff --git a/lib/do_instance/do_create.js b/lib/do_instance/do_create.js
index b2e9631..7d62583 100644
--- a/lib/do_instance/do_create.js
+++ b/lib/do_instance/do_create.js
@@ -92,34 +92,21 @@ function do_create(subcmd, opts, args, cb) {
         common.cliSetupTritonApi,
         /* BEGIN JSSTYLED */
         /*
-         * Parse --affinity options for validity to `ctx.affinities`.
-         * Later (in `resolveLocality`) we'll translate this to locality hints
-         * that CloudAPI speaks.
+         * Validate --affinity options.
          *
          * Some examples. Inspired by
          * <https://docs.docker.com/swarm/scheduler/filter/#how-to-write-filter-expressions>
          *
          *      instance==vm1
          *      container==vm1      # alternative to 'instance'
-         *      inst==vm1           # alternative to 'instance'
-         *      inst=vm1            # '=' is shortcut for '=='
          *      inst!=vm1           # '!='
          *      inst==~vm1          # '~' for soft/non-strict
          *      inst!=~vm1
          *
-         *      inst==vm*           # globbing (not yet supported)
-         *      inst!=/vm\d/        # regex (not yet supported)
+         *      inst==vm*           # globbing
+         *      inst!=/vm\d/        # regex
          *
-         *      some-tag!=db        # tags (not yet supported)
-         *
-         * Limitations:
-         * - no support for tags yet
-         * - no globbing or regex yet
-         * - we resolve name -> instance id *client-side* for now (until
-         *   CloudAPI supports that)
-         * - Triton doesn't support mixed strict and non-strict, so we error
-         *   out on that. We *could* just drop the non-strict, but that is
-         *   slightly different.
+         *      some-tag!=db        # tags
          */
         /* END JSSTYLED */
         function parseAffinity(ctx, next) {
@@ -128,63 +115,67 @@ function do_create(subcmd, opts, args, cb) {
                 return;
             }
 
+            var strict = [];
+            var nonStrict = [];
             var affinities = [];
 
-            // TODO: stricter rules on the value part
             // JSSTYLED
-            var affinityRe = /((instance|inst|container)(==~|!=~|==|!=|=~|=))?(.*?)$/;
+            var operatorRe = /(?:==~|!=~|==|!=|=~|=)/;
+
             for (var i = 0; i < opts.affinity.length; i++) {
-                var raw = opts.affinity[i];
-                var match = affinityRe.exec(raw);
-                if (!match) {
-                    next(new errors.UsageError(format('invalid affinity: "%s"',
-                        raw)));
+                var affinity = opts.affinity[i];
+                var operator = affinity.match(operatorRe);
+
+                if (!operator) {
+                    next(new errors.UsageError('affinity "' + affinity
+                        + '" does not have a valid operator (==~|!=~|==|!=)'));
                     return;
                 }
 
-                var key = match[2];
-                if ([undefined, 'inst', 'container'].indexOf(key) !== -1) {
-                    key = 'instance';
-                }
-                assert.equal(key, 'instance');
-                var op = match[3];
-                if ([undefined, '='].indexOf(op) !== -1) {
-                    op = '==';
+                operator = operator[0];
+
+                // for backward compat
+                if (operator === '=') {
+                    operator = '==';
+                } else if (operator === '=~') {
+                    operator = '==~';
                 }
-                var strict = true;
-                if (op[op.length - 1] === '~') {
-                    strict = false;
-                    op = op.slice(0, op.length - 1);
+
+                if (operator.match('~')) {
+                    nonStrict.push(affinity);
+                } else {
+                    strict.push(affinity);
                 }
-                var val = match[4];
 
                 // Guard against mixed strictness (Triton can't handle those).
-                if (affinities.length > 0) {
-                    var lastAff = affinities[affinities.length - 1];
-                    if (strict !== lastAff.strict) {
-                        next(new errors.TritonError(format('mixed strict and '
-                            + 'non-strict affinities are not supported: '
-                            + '%j (%s) and %j (%s)',
-                            lastAff.raw,
-                            (lastAff.strict ? 'strict' : 'non-strict'),
-                            raw, (strict ? 'strict' : 'non-strict'))));
-                        return;
-                    }
+                if (strict.length > 0 && nonStrict.length > 0) {
+                    next(new errors.TritonError(format('mixed strict and '
+                        + 'non-strict affinities are not supported: '
+                        + '%j (strict) and %j (non-strict)',
+                        strict[0], nonStrict[0])));
+                    return;
                 }
 
-                affinities.push({
-                    raw: raw,
-                    key: key,
-                    op: op,
-                    strict: strict,
-                    val: val
+                var operands = affinity.split(operatorRe).filter(function (t) {
+                    return t.length > 0;
                 });
-            }
 
-            if (affinities.length) {
-                log.trace({affinities: affinities}, 'affinities');
-                ctx.affinities = affinities;
-            }
+                if (operands.length !== 2) {
+                    next(new errors.UsageError('affinity "' + affinity
+                        + '" does not have exactly two operands'));
+                    return;
+                }
+
+                // for backward compat
+                if (operands[0] === 'inst') {
+                    operands[0] = 'instance';
+                }
+
+                affinities.push(operands[0] + operator + operands[1]);
+           }
+
+            ctx.affinity = affinities;
+
             next();
         },
 
@@ -223,65 +214,6 @@ function do_create(subcmd, opts, args, cb) {
 
             next();
         },
-
-        /*
-         * Determine `ctx.locality` according to what CloudAPI supports
-         * based on `ctx.affinities` parsed earlier.
-         */
-        function resolveLocality(ctx, next) {
-            if (!ctx.affinities) {
-                next();
-                return;
-            }
-
-            var strict;
-            var near = [];
-            var far = [];
-
-            vasync.forEachPipeline({
-                inputs: ctx.affinities,
-                func: function resolveAffinity(aff, nextAff) {
-                    assert.ok(['==', '!='].indexOf(aff.op) !== -1,
-                        'unexpected op: ' + aff.op);
-                    var nearFar = (aff.op == '==' ? near : far);
-
-                    strict = aff.strict;
-                    if (common.isUUID(aff.val)) {
-                        nearFar.push(aff.val);
-                        nextAff();
-                    } else {
-                        tritonapi.getInstance({
-                            id: aff.val,
-                            fields: ['id']
-                        }, function (err, inst) {
-                            if (err) {
-                                nextAff(err);
-                            } else {
-                                log.trace({val: aff.val, inst: inst.id},
-                                    'resolveAffinity');
-                                nearFar.push(inst.id);
-                                nextAff();
-                            }
-                        });
-                    }
-                }
-            }, function (err) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-
-                ctx.locality = {
-                    strict: strict
-                };
-                if (near.length > 0) ctx.locality.near = near;
-                if (far.length > 0) ctx.locality.far = far;
-                log.trace({locality: ctx.locality}, 'resolveLocality');
-
-                next();
-            });
-        },
-
         function loadMetadata(ctx, next) {
             mat.metadataFromOpts(opts, log, function (err, metadata) {
                 if (err) {
@@ -382,6 +314,16 @@ function do_create(subcmd, opts, args, cb) {
             if (ctx.locality) {
                 createOpts.locality = ctx.locality;
             }
+            if (ctx.affinity) {
+                createOpts.affinity = ctx.affinity;
+            }
+
+            if (ctx.locality && ctx.affinity) {
+                next(new errors.UsageError('cannot use locality and affinity'
+                    + 'at the same time'));
+                return;
+            }
+
             if (ctx.metadata) {
                 Object.keys(ctx.metadata).forEach(function (key) {
                     createOpts['metadata.'+key] = ctx.metadata[key];
diff --git a/test/integration/cli-affinity.test.js b/test/integration/cli-affinity.test.js
index 5533ce7..55e5bda 100644
--- a/test/integration/cli-affinity.test.js
+++ b/test/integration/cli-affinity.test.js
@@ -92,9 +92,9 @@ test('affinity (triton create -a RULE ...)', testOpts, function (tt) {
     // Test db1 being put on same server as db0.
     var db1Alias = ALIAS_PREFIX + '-db1';
     var db1;
-    tt.test('  setup: triton create -n db1 -a db0', function (t) {
-        var argv = ['create', '-wj', '-n', db1Alias, '-a', db0Alias,
-            imgId, pkgId];
+    tt.test('  setup: triton create -n db1 -a instance==db0', function (t) {
+        var argv = ['create', '-wj', '-n', db1Alias, '-a',
+            'instance==' + db0Alias, imgId, pkgId];
         h.safeTriton(t, argv, function (err, stdout) {
             var lines = h.jsonStreamParse(stdout);
             db1 = lines[1];
-- 
2.21.0

