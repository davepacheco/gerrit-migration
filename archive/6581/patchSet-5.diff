From bdad3d4a54783a379bd3ce059302cb66b308711d Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Wed, 10 Jul 2019 22:21:03 +0000
Subject: [PATCH] TRITON-1808 NAPI returns "deadlock detected" for conflicting
 requests Reviewed by: Jason King <jason.king@joyent.com> Reviewed by: Dave
 Eddy <dave.eddy@joyent.com> Approved by: Dave Eddy <dave.eddy@joyent.com>

---
 lib/models/nic/common.js | 65 ++++++++++++++++++++++++++++++++++++++--
 1 file changed, 62 insertions(+), 3 deletions(-)

diff --git a/lib/models/nic/common.js b/lib/models/nic/common.js
index 9a2185e..f0699f5 100644
--- a/lib/models/nic/common.js
+++ b/lib/models/nic/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -38,6 +38,46 @@ var getPoolIntersections = util_intersect.getPoolIntersections;
 
 // --- Internal helpers
 
+/**
+ * When we send a batch request to Moray, it executes the requested operations
+ * in the specified order. Since our transactions acquire row-level locks for
+ * each row that we touch, we need to make sure that they are always acquired
+ * in the same order, so that we don't end up with a lock order violation. If
+ * this happens, Postgres will send back the error "deadlock detected".
+ *
+ * It's alright for us to change the initial order that the requests were
+ * placed in the batch since none should share the same bucket/key pair; NAPI
+ * just needs to manipulate multiple objects in the same transaction.
+ *
+ * Note that we sort on the "bucket" in _descending_ alphabetical order. This
+ * is intentional, so that we get the following order when deleting a NIC in
+ * NAPI:
+ *
+ *   - napi_nics
+ *   - napi_networks (when deleting a fabric gateway NIC)
+ *   - napi_ips_*
+ *
+ * This ensures that we'll try to delete the NIC object before we try updating
+ * the network and IP objects, so that when we have racing DELETE requests we
+ * get an ObjectNotFoundError back from Moray, instead of an EtagConflictError.
+ *
+ * Requests in the batch that operate on the portolan_* buckets are kept in
+ * their original order in commitBatch() below. This is to preserve the order
+ * of the Portolan events we generate.
+ */
+function compareRequests(a, b) {
+    if (a.bucket < b.bucket) {
+        return 1;
+    } else if (a.bucket > b.bucket) {
+        return -1;
+    } else if (a.key < b.key) {
+        return -1;
+    } else if (a.key > b.key) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
 
 /**
  * If an owner_uuid has been specified, and we haven't been explicitly
@@ -484,9 +524,28 @@ function commitBatch(opts, callback) {
     assert.object(opts.log, 'opts.log');
     assert.arrayOfObject(opts.batch, 'opts.batch');
 
-    opts.log.info({ batch: opts.batch }, 'commitBatch: enter');
+    /*
+     * Split out the Portolan updates so that we preserve their
+     * current order.
+     */
+    var nbatch = [];
+    var pbatch = [];
+
+    opts.batch.forEach(function (r) {
+        if (r.bucket.indexOf('portolan') === -1) {
+            nbatch.push(r);
+        } else {
+            pbatch.push(r);
+        }
+    });
+
+    nbatch.sort(compareRequests);
+
+    var batch = nbatch.concat(pbatch);
+
+    opts.log.info({ batch: batch }, 'commitBatch: enter');
 
-    opts.app.moray.batch(opts.batch, function (err, res) {
+    opts.app.moray.batch(batch, function (err, res) {
         if (err) {
             opts.log.error(err, 'commitBatch error');
             callback(err);
-- 
2.21.0

