From ae1a71e6257d2775b331ca90501d7dbcea788bd5 Mon Sep 17 00:00:00 2001
From: Trent Mick <trentm@gmail.com>
Date: Mon, 17 Apr 2017 23:07:50 -0700
Subject: [PATCH] DOCKER-1037 WIP: try out prettier for automatic formatting

---
 Makefile                                   |    3 +
 lib/audit-logger.js                        |   37 +-
 lib/auth.js                                |  127 +-
 lib/backends/lxzone/containers.js          |  118 +-
 lib/backends/lxzone/imgadm.js              |   48 +-
 lib/backends/lxzone/index.js               |    1 -
 lib/backends/lxzone/sysinfo.js             |   51 +-
 lib/backends/sdc/affinity.js               |  646 +--
 lib/backends/sdc/build.js                  |  849 ++--
 lib/backends/sdc/containers.js             | 4154 ++++++++++++--------
 lib/backends/sdc/images.js                 | 1204 +++---
 lib/backends/sdc/index.js                  |    6 +-
 lib/backends/sdc/sysinfo.js                |   73 +-
 lib/backends/sdc/utils.js                  |  446 ++-
 lib/common.js                              |  311 +-
 lib/config-loader.js                       |    6 +-
 lib/connwatcher.js                         |   42 +-
 lib/constants.js                           |    1 -
 lib/docker.js                              |  181 +-
 lib/endpoints/_ping.js                     |    8 +-
 lib/endpoints/admin/image-tags.js          |   23 +-
 lib/endpoints/admin/images.js              |   25 +-
 lib/endpoints/admin/index.js               |    7 -
 lib/endpoints/admin/progress.js            |   13 +-
 lib/endpoints/auth.js                      |   58 +-
 lib/endpoints/build.js                     |   75 +-
 lib/endpoints/ca.js                        |    8 +-
 lib/endpoints/commit.js                    |   26 +-
 lib/endpoints/containers.js                | 1153 ++++--
 lib/endpoints/events.js                    |    8 +-
 lib/endpoints/exec.js                      |  104 +-
 lib/endpoints/images.js                    |  353 +-
 lib/endpoints/index.js                     |    7 -
 lib/endpoints/info.js                      |   35 +-
 lib/endpoints/version.js                   |   43 +-
 lib/errors.js                              |  126 +-
 lib/hijack.js                              |    6 +-
 lib/models/image-tag.js                    |  118 +-
 lib/models/image.js                        |  227 +-
 lib/models/index.js                        |   24 +-
 lib/models/link.js                         |   67 +-
 lib/moray.js                               |  301 +-
 lib/socket-manager.js                      |   22 +-
 lib/validate.js                            |  236 +-
 lib/wfapi/index.js                         |   81 +-
 lib/wfapi/workflows/pull-image.js          |  203 +-
 test/integration/api-build.test.js         |  829 ++--
 test/integration/api-create.test.js        |  591 +--
 test/integration/api-images.test.js        |  103 +-
 test/integration/api-info.test.js          |   31 +-
 test/integration/api-invalid.test.js       |   93 +-
 test/integration/api-start-stop.test.js    |  146 +-
 test/integration/apiversion.test.js        |   67 +-
 test/integration/cli-affinity.test.js      |  164 +-
 test/integration/cli-attach.test.js        |  186 +-
 test/integration/cli-commit.test.js        |   86 +-
 test/integration/cli-copy.test.js          |  660 ++--
 test/integration/cli-filters.test.js       |  159 +-
 test/integration/cli-image-tag.test.js     |   92 +-
 test/integration/cli-info.test.js          |   32 +-
 test/integration/cli-labels.test.js        |   76 +-
 test/integration/cli-links.test.js         |  347 +-
 test/integration/cli-local-volumes.test.js |  162 +-
 test/integration/cli-packagelabels.test.js |  643 +--
 test/integration/cli-pull.test.js          |   73 +-
 test/integration/cli-run-add-host.test.js  |   23 +-
 test/integration/cli-run-ports.test.js     |  287 +-
 test/integration/cli-search.test.js        |   45 +-
 test/integration/cli-triton-tags.test.js   |   60 +-
 test/integration/helpers.js                | 1934 +++++----
 test/lib/cli.js                            |  127 +-
 test/lib/common.js                         |  101 +-
 test/lib/vm.js                             |   83 +-
 test/unit/affinity.test.js                 |  252 +-
 test/unit/common.test.js                   |  130 +-
 test/unit/helpers.js                       |    2 -
 test/unit/ports.test.js                    |   47 +-
 77 files changed, 10910 insertions(+), 8382 deletions(-)

diff --git a/Makefile b/Makefile
index b8c770c..f686c72 100644
--- a/Makefile
+++ b/Makefile
@@ -104,6 +104,9 @@ check-docs:
 
 check:: check-docs
 
+fmt:
+	prettier --write --tab-width 4 --single-quote --no-bracket-spacing \
+		"{lib,test}/**/*.js"
 
 #
 # Packaging targets
diff --git a/lib/audit-logger.js b/lib/audit-logger.js
index e8abacd..f5c0486 100644
--- a/lib/audit-logger.js
+++ b/lib/audit-logger.js
@@ -13,7 +13,6 @@ var bunyan = require('bunyan');
 
 var HttpError = require('restify').HttpError;
 
-
 // Default maximum length for requests/responses body that are logged
 // is 10 KBs. This can be overriden with the option object passed
 // to auditLogger.
@@ -25,9 +24,11 @@ function getBodyToLog(body, options) {
     var maxLength = options.maxLength || DEFAULT_MAX_LOG_BODY_LENGTH;
 
     var loggedBody;
-    if (body && options.log !== false
-        && (!Buffer.isBuffer(body) || options.logBuffers === true))
-    {
+    if (
+        body &&
+        options.log !== false &&
+        (!Buffer.isBuffer(body) || options.logBuffers === true)
+    ) {
         loggedBody = body;
         if (loggedBody.length > maxLength)
             loggedBody = loggedBody.slice(0, maxLength) + '...';
@@ -48,7 +49,6 @@ function getResponseBodyToLog(res, responseOptions) {
     return getBodyToLog(body, responseOptions);
 }
 
-
 ///--- API
 
 /**
@@ -91,17 +91,15 @@ function auditLogger(options) {
         serializers: {
             err: errSerializer,
             req: function auditRequestSerializer(req) {
-                if (!req)
-                    return (false);
+                if (!req) return false;
 
                 var timers = {};
-                (req.timers || []).forEach(function (time) {
+                (req.timers || []).forEach(function(time) {
                     var t = time.time;
-                    var _t = Math.floor((1000000 * t[0])
-                        + (t[1] / 1000));
+                    var _t = Math.floor(1000000 * t[0] + t[1] / 1000);
                     timers[time.name] = _t;
                 });
-                return ({
+                return {
                     method: req.method,
                     url: req.url,
                     headers: req.headers,
@@ -110,26 +108,24 @@ function auditLogger(options) {
                     version: req.version(),
                     body: getBodyToLog(req.body, options.requestBody),
                     timers: timers
-                });
+                };
             },
             res: function auditResponseSerializer(res) {
-                if (!res)
-                    return (false);
+                if (!res) return false;
 
-                return ({
+                return {
                     statusCode: res.statusCode,
                     headers: res._headers,
                     trailer: res._trailer || false,
                     body: getResponseBodyToLog(res, options.responseBody)
-                });
+                };
             }
         }
     });
 
     function audit(req, res, route, err) {
         var latency = res.get('Response-Time');
-        if (typeof (latency) !== 'number')
-            latency = Date.now() - req._time;
+        if (typeof latency !== 'number') latency = Date.now() - req._time;
 
         // Censor passwords as best we can for audit logs.
         if (req.headers['x-registry-auth'] !== undefined) {
@@ -158,13 +154,12 @@ function auditLogger(options) {
 
         log.info(obj, 'handled: %d', res.statusCode);
 
-        return (true);
+        return true;
     }
 
-    return (audit);
+    return audit;
 }
 
-
 ///-- Exports
 
 module.exports = auditLogger;
diff --git a/lib/auth.js b/lib/auth.js
index 68fb2c7..ccc240f 100644
--- a/lib/auth.js
+++ b/lib/auth.js
@@ -40,7 +40,6 @@ var errors = require('./errors');
 
 var fmt = util.format;
 
-
 /**
  * This function is responsible for authentication for the docker service. It
  * parses the given key/fingerprints and compares them to what we have stored
@@ -74,8 +73,10 @@ function authTls(req, res, next) {
      * key.
      */
     if (cert.purposes && cert.purposes.indexOf('joyentDocker') !== -1) {
-        log.trace('found "joyentDocker" certificate purpose, will treat as '
-            + 'new-style certificate');
+        log.trace(
+            'found "joyentDocker" certificate purpose, will treat as ' +
+                'new-style certificate'
+        );
 
         if (cert.isExpired()) {
             /*
@@ -101,8 +102,12 @@ function authTls(req, res, next) {
                 log.info({err: e}, 'failed to parse CN= fingerprint in issuer');
             }
             if (fp === undefined) {
-                next(new errors.UnauthorizedError('Client certificate is not '
-                    + 'self-signed, and the issuer DN could not be parsed'));
+                next(
+                    new errors.UnauthorizedError(
+                        'Client certificate is not ' +
+                            'self-signed, and the issuer DN could not be parsed'
+                    )
+                );
                 return;
             }
         }
@@ -111,7 +116,7 @@ function authTls(req, res, next) {
     var account;
     var ufdsKey;
     var login = cert.subjects[0].cn;
-    var authFunctions = [ getMainAccount ];
+    var authFunctions = [getMainAccount];
 
     if (authCache.get(login) && authCache.get(login) === peerKeyFp) {
         log.debug('Cached authentication found token for %s', login);
@@ -121,13 +126,15 @@ function authTls(req, res, next) {
 
     // No support for account subusers at the moment
     function getMainAccount(_, cb) {
-        ufds.getUser(login, function (err, u) {
+        ufds.getUser(login, function(err, u) {
             if (err) {
                 if (err.restCode === 'ResourceNotFound') {
                     log.info({login: login, authn: true}, 'login not found');
                 } else {
-                    log.info({err: err, login: login, authn: true},
-                        'ufds.getUser err');
+                    log.info(
+                        {err: err, login: login, authn: true},
+                        'ufds.getUser err'
+                    );
                 }
                 cb(new errors.UnauthorizedError(err));
                 return;
@@ -139,10 +146,12 @@ function authTls(req, res, next) {
     }
 
     function getKey(_, cb) {
-        ufds.getKey(account, lookupFp, function (err, key) {
+        ufds.getKey(account, lookupFp, function(err, key) {
             if (err) {
-                log.info({err: err, login: login, authn: true},
-                    'ufds.getKey err');
+                log.info(
+                    {err: err, login: login, authn: true},
+                    'ufds.getKey err'
+                );
                 cb(new errors.UnauthorizedError(err));
                 return;
             }
@@ -156,8 +165,10 @@ function authTls(req, res, next) {
         try {
             key = sshpk.parseKey(ufdsKey.pkcs);
         } catch (err) {
-            log.error({err: err, login: login, key: ufdsKey.fingerprint},
-                'failed to parse pkcs key from UFDS');
+            log.error(
+                {err: err, login: login, key: ufdsKey.fingerprint},
+                'failed to parse pkcs key from UFDS'
+            );
             cb(new errors.UnauthorizedError());
             return;
         }
@@ -170,13 +181,15 @@ function authTls(req, res, next) {
             authCache.set(login, peerKeyFp);
             cb();
         } else {
-            log.info({login: login, authn: true},
-                'certificate verification failed');
+            log.info(
+                {login: login, authn: true},
+                'certificate verification failed'
+            );
             cb(new errors.UnauthorizedError());
         }
     }
 
-    vasync.pipeline({ funcs: authFunctions }, function (err) {
+    vasync.pipeline({funcs: authFunctions}, function(err) {
         if (err) {
             next(err);
             return;
@@ -187,20 +200,21 @@ function authTls(req, res, next) {
     });
 }
 
-
 function authXToken(keyapi, req, res, next) {
-    keyapi.detoken(req.header('x-auth-token'), function (err, tokobj) {
+    keyapi.detoken(req.header('x-auth-token'), function(err, tokobj) {
         if (err || !tokobj) {
             req.log.info({err: err, authn: true}, 'malformed auth token');
             next(new errors.UnauthorizedError(err));
-        } else if (tokobj.expires
-            && (Date.now() > new Date(tokobj.expires).getTime()))
-        {
+        } else if (
+            tokobj.expires && Date.now() > new Date(tokobj.expires).getTime()
+        ) {
             req.log.info({tokobj: tokobj, authn: true}, 'auth token expired');
             next(new errors.UnauthorizedError());
         } else {
-            req.app.ufds.getUser(tokobj.account.login,
-                    function getInfo(ufdsErr, account) {
+            req.app.ufds.getUser(tokobj.account.login, function getInfo(
+                ufdsErr,
+                account
+            ) {
                 if (ufdsErr) {
                     return next(ufdsErr);
                 }
@@ -211,7 +225,6 @@ function authXToken(keyapi, req, res, next) {
     });
 }
 
-
 /*
  * sdc-docker's "admin-only" mode for development. All images/containers will
  * belong to the admin user since there is no authentication from the client
@@ -220,14 +233,18 @@ function getAdminAccount(req, res, next) {
     var log = req.log;
     var ufds = req.app.ufds;
 
-    ufds.getUser('admin', function (err, u) {
+    ufds.getUser('admin', function(err, u) {
         if (err) {
             if (err.restCode === 'ResourceNotFound') {
-                log.info({login: 'admin', authn: true},
-                    'admin login not found');
+                log.info(
+                    {login: 'admin', authn: true},
+                    'admin login not found'
+                );
             } else {
-                log.info({login: 'admin', err: err, authn: true},
-                    'ufds.getUser err');
+                log.info(
+                    {login: 'admin', err: err, authn: true},
+                    'ufds.getUser err'
+                );
             }
             next(new errors.UnauthorizedError(err));
             return;
@@ -238,8 +255,6 @@ function getAdminAccount(req, res, next) {
     });
 }
 
-
-
 // ---- exports
 
 /**
@@ -276,18 +291,23 @@ function auth(config, log) {
                  * this DC.
                  */
                 var allowed_dcs = req.account.allowed_dcs;
-                if (accountAllowedDcs
-                    && (
-                        !allowed_dcs
-                        || (Array.isArray(allowed_dcs)
+                if (
+                    accountAllowedDcs &&
+                    (!allowed_dcs ||
+                        (Array.isArray(allowed_dcs)
                             ? allowed_dcs.indexOf(datacenterName) === -1
-                            : allowed_dcs !== datacenterName)
-                    ))
-                {
-                    req.log.info({account: req.account.uuid,
-                        login: req.account.login, authz: true,
-                        dc: datacenterName, allowed_dcs: allowed_dcs},
-                        'allowed_dcs does not include this dc');
+                            : allowed_dcs !== datacenterName))
+                ) {
+                    req.log.info(
+                        {
+                            account: req.account.uuid,
+                            login: req.account.login,
+                            authz: true,
+                            dc: datacenterName,
+                            allowed_dcs: allowed_dcs
+                        },
+                        'allowed_dcs does not include this dc'
+                    );
                     next(new errors.ForbiddenError(forbiddenMsg));
                 }
 
@@ -296,14 +316,24 @@ function auth(config, log) {
                  */
                 var disabled = req.account.disabled;
                 if (disabled === 'true' || disabled === true) {
-                    req.log.info({account: req.account.uuid,
-                        login: req.account.login, authz: true },
-                        'account is disabled');
+                    req.log.info(
+                        {
+                            account: req.account.uuid,
+                            login: req.account.login,
+                            authz: true
+                        },
+                        'account is disabled'
+                    );
                     next(new errors.ForbiddenError(forbiddenMsg));
                 }
 
-                req.log = req.log.child({account: req.account.uuid,
-                    login: req.account.login}, true);
+                req.log = req.log.child(
+                    {
+                        account: req.account.uuid,
+                        login: req.account.login
+                    },
+                    true
+                );
             }
 
             next(err);
@@ -325,7 +355,6 @@ function auth(config, log) {
     };
 }
 
-
 module.exports = {
     auth: auth
 };
diff --git a/lib/backends/lxzone/containers.js b/lib/backends/lxzone/containers.js
index c4f5e3c..355ee7e 100644
--- a/lib/backends/lxzone/containers.js
+++ b/lib/backends/lxzone/containers.js
@@ -16,8 +16,8 @@ var libuuid = require('libuuid');
 
 var VM_DEFAULT_KERNEL_VERSION = '3.13.0';
 var VM_DEFAULT_MAX_LWPS = 2000;
-var VM_DEFAULT_QUOTA = 100;     // GiB
-var VM_DEFAULT_MEMORY = 8192;   // MiB
+var VM_DEFAULT_QUOTA = 100; // GiB
+var VM_DEFAULT_MEMORY = 8192; // MiB
 var VM_DEFAULT_ZFS_IO_PRIORITY = 100;
 
 var VMADM_FIELDS = [
@@ -67,8 +67,7 @@ var VMADM_FIELDS = [
  * size – 1/True/true or 0/False/false, Show the containers sizes
  */
 
-function getVMs(log, options, callback)
-{
+function getVMs(log, options, callback) {
     var fields = options.fields;
     var filters = options.filters;
 
@@ -80,7 +79,7 @@ function getVMs(log, options, callback)
     args = args.concat(filters);
 
     log.debug(cmd + ' ' + args.join(' '));
-    execFile(cmd, args, function (error, stdout, stderr) {
+    execFile(cmd, args, function(error, stdout, stderr) {
         if (error) {
             log.error('Unable to get VM list');
             error.stdout = stdout;
@@ -100,11 +99,10 @@ function getVMs(log, options, callback)
     });
 }
 
-function getImageString(images, uuid)
-{
+function getImageString(images, uuid) {
     var found_image;
 
-    images.forEach(function (image) {
+    images.forEach(function(image) {
         if (image.manifest.uuid == uuid) {
             found_image = image.manifest;
         }
@@ -117,9 +115,8 @@ function getImageString(images, uuid)
     }
 }
 
-function vmobjToContainer(images, obj)
-{
-    assert(typeof (obj) == 'object');
+function vmobjToContainer(images, obj) {
+    assert(typeof obj == 'object');
 
     var container = {};
 
@@ -131,8 +128,9 @@ function vmobjToContainer(images, obj)
     }
 
     if (obj.create_timestamp) {
-        container.Created
-            = Math.floor((new Date(obj.create_timestamp)).getTime()/1000);
+        container.Created = Math.floor(
+            new Date(obj.create_timestamp).getTime() / 1000
+        );
     } else {
         container.Created = 0;
     }
@@ -161,7 +159,7 @@ function vmobjToContainer(images, obj)
 
     container.Image = getImageString(images, obj.image_uuid);
 
-    return (container);
+    return container;
 }
 
 function getContainers(options, callback) {
@@ -174,14 +172,14 @@ function getContainers(options, callback) {
         get_opts.filters.push('state=running');
     }
 
-    imgadm.getImages({log: log}, function (imgadm_err, images) {
+    imgadm.getImages({log: log}, function(imgadm_err, images) {
         // XXX we're ignoring imgadm_err
-        getVMs(log, get_opts, function (err, objects) {
+        getVMs(log, get_opts, function(err, objects) {
             var containers = [];
 
             assert(!err);
 
-            objects.forEach(function (obj) {
+            objects.forEach(function(obj) {
                 var container = vmobjToContainer(images, obj);
                 log.debug({container: container, obj: obj}, 'found container');
                 containers.push(container);
@@ -192,15 +190,13 @@ function getContainers(options, callback) {
     });
 }
 
-function ltrim(str, chars)
-{
+function ltrim(str, chars) {
     chars = chars || '\\s';
     str = str || '';
     return str.replace(new RegExp('^[' + chars + ']+', 'g'), '');
 }
 
 function buildVmadmPayload(container, callback) {
-
     var dockerid;
     var simple_map = {
         Hostname: 'hostname',
@@ -209,7 +205,7 @@ function buildVmadmPayload(container, callback) {
     };
     var payload = {};
 
-    Object.keys(simple_map).forEach(function (k) {
+    Object.keys(simple_map).forEach(function(k) {
         if (container.hasOwnProperty(k) && container[k].length > 0) {
             payload[simple_map[k]] = container[k];
         }
@@ -256,47 +252,45 @@ function buildVmadmPayload(container, callback) {
     payload.tmpfs = 0;
     payload.zfs_io_priority = VM_DEFAULT_ZFS_IO_PRIORITY;
 
-// {
-// "AttachStdin": false,
-// "AttachStdout": false,
-// "AttachStderr": false,
-// "PortSpecs": null,
-// "ExposedPorts": {},
-// "Tty": false,
-// "OpenStdin": false,
-// "StdinOnce": false,
-// "Volumes": {},
-// "Entrypoint": null,
-// "NetworkDisabled": false,
-// "OnBuild": null,
-// "SecurityOpt": null,
-// "HostConfig": {
-//   "Binds": null,
-//   "ContainerIDFile": "",
-//   "LxcConf": [],
-//   "Privileged": false,
-//   "PortBindings": {},
-//   "Links": null,
-//   "PublishAllPorts": false,
-//   "Dns": null,
-//   "DnsSearch": null,
-//   "ExtraHosts": null,
-//   "VolumesFrom": null,
-//   "Devices": [],
-//   "NetworkMode": "bridge",
-//   "CapAdd": null,
-//   "CapDrop": null,
-//   "RestartPolicy": {
-//     "Name": "",
-//     "MaximumRetryCount": 0
-//   }
-// }
+    // {
+    // "AttachStdin": false,
+    // "AttachStdout": false,
+    // "AttachStderr": false,
+    // "PortSpecs": null,
+    // "ExposedPorts": {},
+    // "Tty": false,
+    // "OpenStdin": false,
+    // "StdinOnce": false,
+    // "Volumes": {},
+    // "Entrypoint": null,
+    // "NetworkDisabled": false,
+    // "OnBuild": null,
+    // "SecurityOpt": null,
+    // "HostConfig": {
+    //   "Binds": null,
+    //   "ContainerIDFile": "",
+    //   "LxcConf": [],
+    //   "Privileged": false,
+    //   "PortBindings": {},
+    //   "Links": null,
+    //   "PublishAllPorts": false,
+    //   "Dns": null,
+    //   "DnsSearch": null,
+    //   "ExtraHosts": null,
+    //   "VolumesFrom": null,
+    //   "Devices": [],
+    //   "NetworkMode": "bridge",
+    //   "CapAdd": null,
+    //   "CapDrop": null,
+    //   "RestartPolicy": {
+    //     "Name": "",
+    //     "MaximumRetryCount": 0
+    //   }
+    // }
 
     callback(null, payload);
-
 }
 
-
 function createContainer(options, callback) {
     var log = options.log;
     var name = options.name;
@@ -305,9 +299,11 @@ function createContainer(options, callback) {
     // XXX TODO check that "name" is not already used
 
     payload.Name = name;
-    buildVmadmPayload(payload, function (err, vmadm_payload) {
-        log.debug({name: name, payload: payload, vmadm_payload: vmadm_payload},
-            'built payload');
+    buildVmadmPayload(payload, function(err, vmadm_payload) {
+        log.debug(
+            {name: name, payload: payload, vmadm_payload: vmadm_payload},
+            'built payload'
+        );
         callback(null, {});
     });
 }
diff --git a/lib/backends/lxzone/imgadm.js b/lib/backends/lxzone/imgadm.js
index 9201c06..f0b8f96 100644
--- a/lib/backends/lxzone/imgadm.js
+++ b/lib/backends/lxzone/imgadm.js
@@ -16,23 +16,20 @@ var child_process = require('child_process'),
     execFile = child_process.execFile;
 var format = require('util').format;
 
-
 // ---- globals
 
 var UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
 
-
 // ---- internal support stuff
 
 function objCopy(obj) {
     var copy = {};
-    Object.keys(obj).forEach(function (k) {
+    Object.keys(obj).forEach(function(k) {
         copy[k] = obj[k];
     });
     return copy;
 }
 
-
 // ---- main functionality
 
 /**
@@ -49,7 +46,7 @@ function getImage(options, callback) {
     assert.ok(options.uuid && UUID_RE.test(options.uuid), 'options.uuid');
     assert.ok(options.log, 'options.log');
 
-    var argv = ['/usr/sbin/imgadm', 'get',  options.uuid];
+    var argv = ['/usr/sbin/imgadm', 'get', options.uuid];
     var env = objCopy(process.env);
     // Get 'debug' level logging in imgadm >=2.6.0 without triggering trace
     // level logging in imgadm versions before that. Trace level logging is
@@ -60,15 +57,27 @@ function getImage(options, callback) {
         env: env
     };
     options.log.info('calling: ' + argv.join(' '));
-    execFile(argv[0], argv.slice(1), execOpts, function (err, stdout, stderr) {
+    execFile(argv[0], argv.slice(1), execOpts, function(err, stdout, stderr) {
         if (err) {
-            callback(new Error(format(
-                'Error getting image %s: %s', options.uuid, stderr.trim())));
+            callback(
+                new Error(
+                    format(
+                        'Error getting image %s: %s',
+                        options.uuid,
+                        stderr.trim()
+                    )
+                )
+            );
             return;
         }
-        options.log.info(format(
-            'got image %s: stdout=%s stderr=%s',
-            options.uuid, stdout.trim(), stderr.trim()));
+        options.log.info(
+            format(
+                'got image %s: stdout=%s stderr=%s',
+                options.uuid,
+                stdout.trim(),
+                stderr.trim()
+            )
+        );
         var image = JSON.parse(stdout.trim()).manifest;
         callback(null, image);
     });
@@ -91,20 +100,25 @@ function getImages(options, callback) {
         encoding: 'utf8'
     };
     options.log.info('calling: ' + argv.join(' '));
-    execFile(argv[0], argv.slice(1), execOpts, function (err, stdout, stderr) {
+    execFile(argv[0], argv.slice(1), execOpts, function(err, stdout, stderr) {
         if (err) {
-            callback(new Error(format(
-                'Error getting images: %s', stderr.trim())));
+            callback(
+                new Error(format('Error getting images: %s', stderr.trim()))
+            );
             return;
         }
-        options.log.info(format('got images: stdout=%s stderr=%s',
-            stdout.trim(), stderr.trim()));
+        options.log.info(
+            format(
+                'got images: stdout=%s stderr=%s',
+                stdout.trim(),
+                stderr.trim()
+            )
+        );
         var images = JSON.parse(stdout.trim());
         callback(null, images);
     });
 }
 
-
 // ---- exports
 
 module.exports = {
diff --git a/lib/backends/lxzone/index.js b/lib/backends/lxzone/index.js
index 192f008..b5de3e0 100644
--- a/lib/backends/lxzone/index.js
+++ b/lib/backends/lxzone/index.js
@@ -12,7 +12,6 @@ var assert = require('assert-plus');
 var containers = require('./containers');
 var sysinfo = require('./sysinfo');
 
-
 function LxZoneBackend(opts) {
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
diff --git a/lib/backends/lxzone/sysinfo.js b/lib/backends/lxzone/sysinfo.js
index f4d9912..f12cd04 100644
--- a/lib/backends/lxzone/sysinfo.js
+++ b/lib/backends/lxzone/sysinfo.js
@@ -12,33 +12,32 @@ var assert = require('assert');
 var imgadm = require('./imgadm');
 var containers = require('./containers');
 
-function getInfo(options, callback)
-{
-    containers.getContainers({log: options.log, all: true},
-        function (err, cont) {
-            imgadm.getImages(options, function (img_err, images) {
+function getInfo(options, callback) {
+    containers.getContainers({log: options.log, all: true}, function(
+        err,
+        cont
+    ) {
+        imgadm.getImages(options, function(img_err, images) {
+            var info = {
+                Containers: cont.length,
+                Images: images.length,
+                Driver: 'lxzone',
+                ExecutionDriver: 'lxzone-0.1',
+                KernelVersion: '3.12.0-1-amd64',
+                Debug: true,
+                NFd: 42,
+                NGoroutines: 42,
+                NEventsListener: 0,
+                InitPath: '/usr/bin/docker',
+                IndexServerAddress: ['https://index.docker.io/v1/'],
+                MemoryLimit: true,
+                SwapLimit: true,
+                IPv4Forwarding: true
+            };
 
-                var info = {
-                    'Containers': cont.length,
-                    'Images': images.length,
-                    'Driver': 'lxzone',
-                    'ExecutionDriver': 'lxzone-0.1',
-                    'KernelVersion': '3.12.0-1-amd64',
-                    'Debug': true,
-                    'NFd':  42,
-                    'NGoroutines': 42,
-                    'NEventsListener': 0,
-                    'InitPath': '/usr/bin/docker',
-                    'IndexServerAddress': ['https://index.docker.io/v1/'],
-                    'MemoryLimit': true,
-                    'SwapLimit': true,
-                    'IPv4Forwarding': true
-                };
-
-                callback(null, info);
-            });
-        }
-    );
+            callback(null, info);
+        });
+    });
 }
 
 module.exports = {
diff --git a/lib/backends/sdc/affinity.js b/lib/backends/sdc/affinity.js
index b35381a..27b8817 100644
--- a/lib/backends/sdc/affinity.js
+++ b/lib/backends/sdc/affinity.js
@@ -67,7 +67,6 @@ var XRegExp = require('xregexp');
 var common = require('../../common');
 var errors = require('../../errors');
 
-
 // ---- globals
 
 var FILTER_KEY_RE = /^[a-z_][a-z0-9\-_.]+$/i;
@@ -90,7 +89,6 @@ var FILTER_KEY_RE = /^[a-z_][a-z0-9\-_.]+$/i;
 // JSSTYLED
 var FILTER_VALUE_RE = /^[-a-z0-9:_\s.*/()?+[\]\\^$|]+$/i;
 
-
 // ---- internal support stuff
 
 /* BEGIN JSSTYLED */
@@ -121,7 +119,8 @@ function _affinitiesFromContainer(opts) {
     var labels = opts.container.Labels;
     if (labels && labels['com.docker.swarm.affinities']) {
         affinityStrs = affinityStrs.concat(
-            _affinityStrsFromLabel(labels['com.docker.swarm.affinities']));
+            _affinityStrsFromLabel(labels['com.docker.swarm.affinities'])
+        );
     }
 
     // Env, e.g.: [ 'affinity:foo==bar' ]
@@ -147,7 +146,7 @@ function _affinitiesFromContainer(opts) {
 
     // Side-effects.
     if (envIdxToDel.length > 0) {
-        envIdxToDel.reverse().forEach(function (idx) {
+        envIdxToDel.reverse().forEach(function(idx) {
             opts.container.Env.splice(idx, 1);
         });
         labels['com.docker.swarm.affinities'] = JSON.stringify(affinityStrs);
@@ -156,7 +155,6 @@ function _affinitiesFromContainer(opts) {
     return affinities;
 }
 
-
 /**
  * Parse a Swarm filter expression.
  * https://github.com/docker/swarm/blob/ee28008f/scheduler/filter/expr.go
@@ -193,9 +191,14 @@ function _parseFilterExpr(s) {
         }
         expr.key = s.slice(0, idx);
         if (!FILTER_KEY_RE.test(expr.key)) {
-            throw new errors.ValidationError(format(
-                'invalid key in filter expression: %j: %j does not match %s',
-                s, expr.key, FILTER_KEY_RE));
+            throw new errors.ValidationError(
+                format(
+                    'invalid key in filter expression: %j: %j does not match %s',
+                    s,
+                    expr.key,
+                    FILTER_KEY_RE
+                )
+            );
         }
         expr.operator = operators[i];
         expr.value = s.slice(idx + expr.operator.length);
@@ -206,13 +209,20 @@ function _parseFilterExpr(s) {
             expr.isSoft = false;
         }
         if (!FILTER_VALUE_RE.test(expr.value)) {
-            throw new errors.ValidationError(format(
-                'invalid value in filter expression: %j: %j does not match %s',
-                s, expr.value, FILTER_VALUE_RE));
+            throw new errors.ValidationError(
+                format(
+                    'invalid value in filter expression: %j: %j does not match %s',
+                    s,
+                    expr.value,
+                    FILTER_VALUE_RE
+                )
+            );
         }
-        if (expr.value.length >= 3 && expr.value[0] === '/'
-            && expr.value[expr.value.length - 1] === '/')
-        {
+        if (
+            expr.value.length >= 3 &&
+            expr.value[0] === '/' &&
+            expr.value[expr.value.length - 1] === '/'
+        ) {
             expr.valueType = 're';
             expr.valueRe = XRegExp(expr.value.slice(1, -1));
         } else if (expr.value.indexOf('*') !== -1) {
@@ -222,14 +232,24 @@ function _parseFilterExpr(s) {
         }
         return expr;
     }
-    throw new errors.ValidationError(format(
-        'could not find operator in filter expression: '
-        + 'expected one of %s: %j', operators.join(', '), s));
+    throw new errors.ValidationError(
+        format(
+            'could not find operator in filter expression: ' +
+                'expected one of %s: %j',
+            operators.join(', '),
+            s
+        )
+    );
 }
 
 function _strFromFilterExpr(expr) {
-    return format('%s%s%s%s', expr.key, expr.operator, expr.isSoft ? '~' : '',
-        expr.value);
+    return format(
+        '%s%s%s%s',
+        expr.key,
+        expr.operator,
+        expr.isSoft ? '~' : '',
+        expr.value
+    );
 }
 
 /**
@@ -245,19 +265,20 @@ function _affinityStrsFromLabel(label) {
     try {
         affinityStrs = JSON.parse(label);
     } catch (parseErr) {
-        throw new errors.ValidationError(format(
-            'invalid affinities label: %j: %s', label, parseErr));
+        throw new errors.ValidationError(
+            format('invalid affinities label: %j: %s', label, parseErr)
+        );
     }
 
     if (!Array.isArray(affinityStrs)) {
         throw new errors.ValidationError(
-            'affinities label is not an array: ' + label);
+            'affinities label is not an array: ' + label
+        );
     }
 
     return affinityStrs;
 }
 
-
 /*
  * Find the VM(s) matching the given 'affinity' (parsed by _parseFilterExpr).
  *
@@ -305,30 +326,32 @@ function _vmUuidsFromAffinity(opts, cb) {
     var vm;
     var vms;
 
-
     // A caching version of VMAPI 'ListVms?state=active&owner_uuid=$ownerUuid'.
-    var getAllActiveVms = function (vmsCb) {
+    var getAllActiveVms = function(vmsCb) {
         if (opts.cache.allActiveVms) {
             vmsCb(null, opts.cache.allActiveVms);
             return;
         }
-        opts.vmapi.listVms({
-            fields: 'uuid,alias,internal_metadata,docker',
-            owner_uuid: opts.ownerUuid,
-            state: 'active'
-        }, {
-            headers: {'x-request-id': log.fields.req_id}
-        }, function (err, allActiveVms) {
-            if (err) {
-                vmsCb(err);
-            } else {
-                opts.cache.allActiveVms = allActiveVms;
-                vmsCb(null, allActiveVms);
+        opts.vmapi.listVms(
+            {
+                fields: 'uuid,alias,internal_metadata,docker',
+                owner_uuid: opts.ownerUuid,
+                state: 'active'
+            },
+            {
+                headers: {'x-request-id': log.fields.req_id}
+            },
+            function(err, allActiveVms) {
+                if (err) {
+                    vmsCb(err);
+                } else {
+                    opts.cache.allActiveVms = allActiveVms;
+                    vmsCb(null, allActiveVms);
+                }
             }
-        });
+        );
     };
 
-
     // $tag=$value
     // $tag=$glob
     if (aff.key !== 'container' && aff.valueType !== 're') {
@@ -338,26 +361,34 @@ function _vmUuidsFromAffinity(opts, cb) {
             state: 'active',
             predicate: JSON.stringify({
                 or: [
-                    {eq: ['tag.' + aff.key,              aff.value]},
+                    {eq: ['tag.' + aff.key, aff.value]},
                     {eq: ['tag.docker:label:' + aff.key, aff.value]}
                 ]
             })
         };
-        opts.vmapi.listVms(query, {
-            headers: {'x-request-id': log.fields.req_id}
-        }, function (err, vms_) {
-            if (err) {
-                cb(err);
-                return;
+        opts.vmapi.listVms(
+            query,
+            {
+                headers: {'x-request-id': log.fields.req_id}
+            },
+            function(err, vms_) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                log.debug(
+                    {affinity: _strFromFilterExpr(aff), vms: vms_},
+                    '_vmUuidsFromAffinity'
+                );
+                var vmUuids = vms_.map(function(vm_) {
+                    return vm_.uuid;
+                });
+                cb(null, vmUuids);
             }
-            log.debug({affinity: _strFromFilterExpr(aff), vms: vms_},
-                '_vmUuidsFromAffinity');
-            var vmUuids = vms_.map(function (vm_) { return vm_.uuid; });
-            cb(null, vmUuids);
-        });
+        );
 
-    // $tag==/regex/
-    // Get a all '$key=*'-tagged VMs and post-filter with `valueRe`.
+        // $tag==/regex/
+        // Get a all '$key=*'-tagged VMs and post-filter with `valueRe`.
     } else if (aff.key !== 'container' && aff.valueType === 're') {
         query = {
             fields: 'uuid,alias,tags',
@@ -365,206 +396,251 @@ function _vmUuidsFromAffinity(opts, cb) {
             state: 'active',
             predicate: JSON.stringify({
                 or: [
-                    {eq: ['tag.' + aff.key,              '*']},
+                    {eq: ['tag.' + aff.key, '*']},
                     {eq: ['tag.docker:label:' + aff.key, '*']}
                 ]
             })
         };
-        opts.vmapi.listVms(query, {
-            headers: {'x-request-id': log.fields.req_id}
-        }, function (err, allVms) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            vms = [];
-            for (i = 0; i < allVms.length; i++) {
-                vm = allVms[i];
-
-                var tag = vm.tags[aff.key];
-                if (tag !== undefined && aff.valueRe.test(tag.toString())) {
-                    // Docker labels can only be strings. Triton VM tags can
-                    // also be booleans or numbers.
-                    vms.push(vm);
-                    continue;
+        opts.vmapi.listVms(
+            query,
+            {
+                headers: {'x-request-id': log.fields.req_id}
+            },
+            function(err, allVms) {
+                if (err) {
+                    cb(err);
+                    return;
                 }
-                var label = vm.tags['docker:label:' + aff.key];
-                if (label !== undefined && aff.valueRe.test(label)) {
-                    vms.push(vm);
-                    continue;
+                vms = [];
+                for (i = 0; i < allVms.length; i++) {
+                    vm = allVms[i];
+
+                    var tag = vm.tags[aff.key];
+                    if (tag !== undefined && aff.valueRe.test(tag.toString())) {
+                        // Docker labels can only be strings. Triton VM tags can
+                        // also be booleans or numbers.
+                        vms.push(vm);
+                        continue;
+                    }
+                    var label = vm.tags['docker:label:' + aff.key];
+                    if (label !== undefined && aff.valueRe.test(label)) {
+                        vms.push(vm);
+                        continue;
+                    }
                 }
+                log.debug(
+                    {affinity: _strFromFilterExpr(aff), vms: vms},
+                    '_vmUuidsFromAffinity'
+                );
+                var vmUuids = vms.map(function(vm_) {
+                    return vm_.uuid;
+                });
+                cb(null, vmUuids);
             }
-            log.debug({affinity: _strFromFilterExpr(aff), vms: vms},
-                '_vmUuidsFromAffinity');
-            var vmUuids = vms.map(function (vm_) { return vm_.uuid; });
-            cb(null, vmUuids);
-        });
+        );
 
-    // container==UUID
+        // container==UUID
     } else if (common.isUUID(aff.value)) {
         assert.equal(aff.key, 'container');
         cb(null, [aff.value]);
 
-    // container==<full 64-char docker id>
-    //
-    // Given a full 64-char docker id, Docker-docker will skip container
-    // *name* matching (at least that's what containers.js#findContainerIdMatch
-    // implies). We'll do the same here. Any other length means we need to
-    // consider name matching.
+        // container==<full 64-char docker id>
+        //
+        // Given a full 64-char docker id, Docker-docker will skip container
+        // *name* matching (at least that's what containers.js#findContainerIdMatch
+        // implies). We'll do the same here. Any other length means we need to
+        // consider name matching.
     } else if (/^[a-f0-9]{64}$/.test(aff.value)) {
         assert.equal(aff.key, 'container');
         var vmUuid = common.dockerIdToUuid(aff.value);
-        opts.vmapi.getVm({
-            uuid: vmUuid,
-            owner_uuid: opts.ownerUuid,
-            fields: 'uuid,alias,state,internal_metadata,docker'
-        }, {
-            headers: {'x-request-id': log.fields.req_id}
-        }, function (err, vm_) {
-            if (err && err.statusCode !== 404) {
-                cb(err);
-            } else if (!err && vm_ && vm_.docker
-                && ['destroyed', 'failed'].indexOf(vm_.state) === -1
-                && vm_.internal_metadata['docker:id'] === aff.value)
+        opts.vmapi.getVm(
             {
-                cb(null, [vmUuid]);
-            } else {
-                cb(null, []);
+                uuid: vmUuid,
+                owner_uuid: opts.ownerUuid,
+                fields: 'uuid,alias,state,internal_metadata,docker'
+            },
+            {
+                headers: {'x-request-id': log.fields.req_id}
+            },
+            function(err, vm_) {
+                if (err && err.statusCode !== 404) {
+                    cb(err);
+                } else if (
+                    !err &&
+                    vm_ &&
+                    vm_.docker &&
+                    ['destroyed', 'failed'].indexOf(vm_.state) === -1 &&
+                    vm_.internal_metadata['docker:id'] === aff.value
+                ) {
+                    cb(null, [vmUuid]);
+                } else {
+                    cb(null, []);
+                }
             }
-        });
-
-    // container=<name>
-    // container=<short docker id>
-    // container=<name glob> (simple '*'-globbing only)
-    // container=<name regex>
-    //
-    // List all active VMs (non-docker too) and pass to "containers.js"
-    // filter function to select a match.
+        );
+
+        // container=<name>
+        // container=<short docker id>
+        // container=<name glob> (simple '*'-globbing only)
+        // container=<name regex>
+        //
+        // List all active VMs (non-docker too) and pass to "containers.js"
+        // filter function to select a match.
     } else {
         assert.equal(aff.key, 'container');
 
         vms = [];
-        vasync.pipeline({funcs: [
-            /*
+        vasync.pipeline(
+            {
+                funcs: [
+                    /*
              * First attempt an exact name (aka alias) match as a quick out,
              * if possible.
              */
-            function attemptNameMatch(_, next) {
-                if (aff.valueType !== 'exact' && aff.valueType !== 'glob') {
-                    next();
-                    return;
-                }
-
-                opts.vmapi.listVms({
-                    fields: 'uuid,alias',
-                    owner_uuid: opts.ownerUuid,
-                    state: 'active',
-                    predicate: JSON.stringify({
-                        eq: ['alias', aff.value] // this supports simple glob
-                    })
-                }, {
-                    headers: {'x-request-id': log.fields.req_id}
-                }, function (err, vms_) {
-                    if (err) {
-                        next(err);
-                    } else {
-                        vms = vms_;
-                        next();
-                    }
-                });
-            },
-
-            function fullVmListSearch(_, next) {
-                if (vms.length) {
-                    // Already got results.
-                    next();
-                    return;
-                }
-
-                getAllActiveVms(function (err, allVms) {
-                    if (err) {
-                        next(err);
-                        return;
-                    }
+                    function attemptNameMatch(_, next) {
+                        if (
+                            aff.valueType !== 'exact' &&
+                            aff.valueType !== 'glob'
+                        ) {
+                            next();
+                            return;
+                        }
 
-                    switch (aff.valueType) {
-                    case 're':
-                        // Regex is only on container name, not id.
-                        for (i = 0; i < allVms.length; i++) {
-                            vm = allVms[i];
-                            if (vm.alias && aff.valueRe.test(vm.alias)) {
-                                vms.push(vm);
+                        opts.vmapi.listVms(
+                            {
+                                fields: 'uuid,alias',
+                                owner_uuid: opts.ownerUuid,
+                                state: 'active',
+                                predicate: JSON.stringify({
+                                    eq: ['alias', aff.value] // this supports simple glob
+                                })
+                            },
+                            {
+                                headers: {'x-request-id': log.fields.req_id}
+                            },
+                            function(err, vms_) {
+                                if (err) {
+                                    next(err);
+                                } else {
+                                    vms = vms_;
+                                    next();
+                                }
                             }
+                        );
+                    },
+
+                    function fullVmListSearch(_, next) {
+                        if (vms.length) {
+                            // Already got results.
+                            next();
+                            return;
                         }
-                        next();
-                        break;
-                    case 'glob':
-                        // Glob is only on container name, not id.
-                        var valueRe = new RegExp(
-                            '^' + XRegExp.escape(aff.value) + '$');
-                        for (i = 0; i < allVms.length; i++) {
-                            vm = allVms[i];
-                            if (vm.alias && valueRe.test(vm.alias)) {
-                                vms.push(vm);
+
+                        getAllActiveVms(function(err, allVms) {
+                            if (err) {
+                                next(err);
+                                return;
                             }
-                        }
-                        next();
-                        break;
-                    case 'exact':
-                        /*
+
+                            switch (aff.valueType) {
+                                case 're':
+                                    // Regex is only on container name, not id.
+                                    for (i = 0; i < allVms.length; i++) {
+                                        vm = allVms[i];
+                                        if (
+                                            vm.alias &&
+                                            aff.valueRe.test(vm.alias)
+                                        ) {
+                                            vms.push(vm);
+                                        }
+                                    }
+                                    next();
+                                    break;
+                                case 'glob':
+                                    // Glob is only on container name, not id.
+                                    var valueRe = new RegExp(
+                                        '^' + XRegExp.escape(aff.value) + '$'
+                                    );
+                                    for (i = 0; i < allVms.length; i++) {
+                                        vm = allVms[i];
+                                        if (
+                                            vm.alias && valueRe.test(vm.alias)
+                                        ) {
+                                            vms.push(vm);
+                                        }
+                                    }
+                                    next();
+                                    break;
+                                case 'exact':
+                                    /*
                          * This is a exact name match (preferred) or id prefix.
                          * If there are multiple id-prefix matches, we'll
                          * raise an ambiguity error.
                          */
-                        var exactErr;
-                        var idPrefixMatches = [];
-                        var nameMatch;
-                        for (i = 0; i < allVms.length; i++) {
-                            vm = allVms[i];
-                            if (vm.alias && vm.alias === aff.value) {
-                                nameMatch = vm;
-                                break;
+                                    var exactErr;
+                                    var idPrefixMatches = [];
+                                    var nameMatch;
+                                    for (i = 0; i < allVms.length; i++) {
+                                        vm = allVms[i];
+                                        if (
+                                            vm.alias && vm.alias === aff.value
+                                        ) {
+                                            nameMatch = vm;
+                                            break;
+                                        }
+                                        if (
+                                            vm.docker &&
+                                            vm.internal_metadata['docker:id'] &&
+                                            vm.internal_metadata[
+                                                'docker:id'
+                                            ].indexOf(aff.value) === 0
+                                        ) {
+                                            idPrefixMatches.push(vm);
+                                        }
+                                    }
+                                    if (nameMatch) {
+                                        vms.push(nameMatch);
+                                    } else if (idPrefixMatches.length > 1) {
+                                        exactErr = new errors.AmbiguousDockerContainerIdPrefixError(
+                                            aff.value,
+                                            idPrefixMatches
+                                        );
+                                    } else if (idPrefixMatches.length === 1) {
+                                        vms.push(idPrefixMatches[0]);
+                                    }
+                                    next(exactErr);
+                                    break;
+                                default:
+                                    next(
+                                        new Error(
+                                            'unknown affinity valueType: ' +
+                                                aff.valueType
+                                        )
+                                    );
+                                    break;
                             }
-                            if (vm.docker
-                                && vm.internal_metadata['docker:id']
-                                && vm.internal_metadata['docker:id'].indexOf(
-                                    aff.value) === 0)
-                            {
-                                idPrefixMatches.push(vm);
-                            }
-                        }
-                        if (nameMatch) {
-                            vms.push(nameMatch);
-                        } else if (idPrefixMatches.length > 1) {
-                            exactErr = new
-                                errors.AmbiguousDockerContainerIdPrefixError(
-                                    aff.value, idPrefixMatches);
-                        } else if (idPrefixMatches.length === 1) {
-                            vms.push(idPrefixMatches[0]);
-                        }
-                        next(exactErr);
-                        break;
-                    default:
-                        next(new Error('unknown affinity valueType: '
-                            + aff.valueType));
-                        break;
+                        });
                     }
-                });
-            }
-        ]}, function (err) {
-            if (err) {
-                cb(err);
-            } else {
-                log.debug({affinity: _strFromFilterExpr(aff), vms: vms},
-                    '_vmUuidsFromAffinity');
-                var vmUuids = vms.map(function (vm_) { return vm_.uuid; });
-                cb(null, vmUuids);
+                ]
+            },
+            function(err) {
+                if (err) {
+                    cb(err);
+                } else {
+                    log.debug(
+                        {affinity: _strFromFilterExpr(aff), vms: vms},
+                        '_vmUuidsFromAffinity'
+                    );
+                    var vmUuids = vms.map(function(vm_) {
+                        return vm_.uuid;
+                    });
+                    cb(null, vmUuids);
+                }
             }
-        });
+        );
     }
 }
 
-
 // ---- exports
 
 /**
@@ -656,9 +732,11 @@ function localityFromContainer(opts, cb) {
         }
     }
     if (haveHard && haveSoft) {
-        log.debug({softAffinities: softAffinities},
-            'localityFromContainer: mixed hard and soft affinities: '
-            + 'drop soft affinities');
+        log.debug(
+            {softAffinities: softAffinities},
+            'localityFromContainer: mixed hard and soft affinities: ' +
+                'drop soft affinities'
+        );
         affinities = hardAffinities;
     }
 
@@ -668,24 +746,27 @@ function localityFromContainer(opts, cb) {
 
     // TODO: Really want forEachParallel with concurrency.
     var cache = {};
-    vasync.forEachPipeline({
-        inputs: affinities,
-        func: function setLocalityFromAff(aff, next) {
-            if (aff.key === 'image') {
-                log.debug({affinity: aff}, 'ignore "image" affinity');
-                next();
-            } else {
-                _vmUuidsFromAffinity({
-                    affinity: aff,
-                    log: log,
-                    ownerUuid: opts.ownerUuid,
-                    vmapi: opts.vmapi,
-                    cache: cache
-                }, function (err, vmUuids) {
-                    if (err) {
-                        next(err);
-                    } else if (vmUuids.length === 0) {
-                        /*
+    vasync.forEachPipeline(
+        {
+            inputs: affinities,
+            func: function setLocalityFromAff(aff, next) {
+                if (aff.key === 'image') {
+                    log.debug({affinity: aff}, 'ignore "image" affinity');
+                    next();
+                } else {
+                    _vmUuidsFromAffinity(
+                        {
+                            affinity: aff,
+                            log: log,
+                            ownerUuid: opts.ownerUuid,
+                            vmapi: opts.vmapi,
+                            cache: cache
+                        },
+                        function(err, vmUuids) {
+                            if (err) {
+                                next(err);
+                            } else if (vmUuids.length === 0) {
+                                /*
                          * Either we drop the affinity or error out. If
                          * it is a strict '==', then we need to error out
                          * (no server will match). If it is non-strict, or
@@ -693,49 +774,66 @@ function localityFromContainer(opts, cb) {
                          *
                          * See some discussion in DAPI-306.
                          */
-                        if (!strict || aff.operator === '!=') {
-                            log.debug({affinity: aff},
-                                'drop affinity, no matching vms');
-                            next();
-                        } else if (aff.key !== 'container') {
-                            next(new errors.ResourceNotFoundError(format(
-                                'no active containers found matching tag '
-                                + '"%s=%s" for affinity "%s"',
-                                aff.key, aff.value, _strFromFilterExpr(aff))));
-                        } else {
-                            next(new errors.ResourceNotFoundError(format(
-                                'no active containers found matching "%s" '
-                                + 'for affinity "%s"',
-                                aff.value, _strFromFilterExpr(aff))));
-                        }
-                    } else {
-                        if (aff.operator === '==') {
-                            near = near.concat(vmUuids);
-                        } else {
-                            far = far.concat(vmUuids);
+                                if (!strict || aff.operator === '!=') {
+                                    log.debug(
+                                        {affinity: aff},
+                                        'drop affinity, no matching vms'
+                                    );
+                                    next();
+                                } else if (aff.key !== 'container') {
+                                    next(
+                                        new errors.ResourceNotFoundError(
+                                            format(
+                                                'no active containers found matching tag ' +
+                                                    '"%s=%s" for affinity "%s"',
+                                                aff.key,
+                                                aff.value,
+                                                _strFromFilterExpr(aff)
+                                            )
+                                        )
+                                    );
+                                } else {
+                                    next(
+                                        new errors.ResourceNotFoundError(
+                                            format(
+                                                'no active containers found matching "%s" ' +
+                                                    'for affinity "%s"',
+                                                aff.value,
+                                                _strFromFilterExpr(aff)
+                                            )
+                                        )
+                                    );
+                                }
+                            } else {
+                                if (aff.operator === '==') {
+                                    near = near.concat(vmUuids);
+                                } else {
+                                    far = far.concat(vmUuids);
+                                }
+                                next();
+                            }
                         }
-                        next();
-                    }
-                });
+                    );
+                }
+            }
+        },
+        function(err) {
+            if (err) {
+                cb(err);
+            } else if (!near.length && !far.length) {
+                cb();
+            } else {
+                var locality = {
+                    strict: strict
+                };
+                if (near.length > 0) locality.near = near;
+                if (far.length > 0) locality.far = far;
+                cb(null, locality);
             }
         }
-    }, function (err) {
-        if (err) {
-            cb(err);
-        } else if (!near.length && !far.length) {
-            cb();
-        } else {
-            var locality = {
-                strict: strict
-            };
-            if (near.length > 0) locality.near = near;
-            if (far.length > 0) locality.far = far;
-            cb(null, locality);
-        }
-    });
+    );
 }
 
-
 module.exports = {
     localityFromContainer: localityFromContainer
 };
diff --git a/lib/backends/sdc/build.js b/lib/backends/sdc/build.js
index 7a33c1c..7dec672 100644
--- a/lib/backends/sdc/build.js
+++ b/lib/backends/sdc/build.js
@@ -25,11 +25,8 @@ var errors = require('../../../lib/errors');
 var images = require('./images');
 var utils = require('./utils');
 
-
-
 //---- globals
 
-
 /**
  * Return an image object in the docker inspect format.
  */
@@ -72,11 +69,11 @@ function buildImage(opts, callback) {
     assert.string(opts.req_id, 'opts.req_id');
 
     var allDockerImages = [];
-    var baseImageId = null;         // Base image id our build is based on.
-    var baseImageIndexName = null;  // Base index_name our build is based on.
+    var baseImageId = null; // Base image id our build is based on.
+    var baseImageIndexName = null; // Base index_name our build is based on.
     var buildFinishedSuccessfully = false;
     var dockerOpts = opts.dockerOpts;
-    var finalImageId = null;  // Final docker image id for resulting image.
+    var finalImageId = null; // Final docker image id for resulting image.
     var log = opts.log;
     var previousErr;
     var rat = opts.rat;
@@ -93,20 +90,26 @@ function buildImage(opts, callback) {
     // happens.
     callback = once(callback);
 
-    vasync.pipeline({ funcs: [
-        buildGetScratchImage,
-        buildGetAllDockerImages,
-        buildCreateContainer,
-        buildGetVmObject,
-        buildCnapiDockerBuild,
-        buildSendContext,
-        buildFromContext
-    ]}, buildCleanup);
-
+    vasync.pipeline(
+        {
+            funcs: [
+                buildGetScratchImage,
+                buildGetAllDockerImages,
+                buildCreateContainer,
+                buildGetVmObject,
+                buildCnapiDockerBuild,
+                buildSendContext,
+                buildFromContext
+            ]
+        },
+        buildCleanup
+    );
 
     function buildGetScratchImage(_, cb) {
-        req.app.backend.getScratchImage(req,
-        function _getScratchImageCb(err, img) {
+        req.app.backend.getScratchImage(req, function _getScratchImageCb(
+            err,
+            img
+        ) {
             if (err) {
                 log.error(err, 'getScratchImage failure');
                 cb(err);
@@ -118,7 +121,6 @@ function buildImage(opts, callback) {
         });
     }
 
-
     function buildGetAllDockerImages(_, cb) {
         // If nocache is specified, there is no need to lookup all images, as
         // this list of images is *only* used for build caching.
@@ -150,31 +152,37 @@ function buildImage(opts, callback) {
                 };
                 getImageInInspectFormat(img.Id, inspectOpts, next);
             }
-            vasync.forEachPipeline({
-                'func': getImageDetails,
-                'inputs': imgs
-            }, function _getImageDetailsCb(err2, results) {
-                allDockerImages = results.successes;
-                cb(err2);
-            });
+            vasync.forEachPipeline(
+                {
+                    func: getImageDetails,
+                    inputs: imgs
+                },
+                function _getImageDetailsCb(err2, results) {
+                    allDockerImages = results.successes;
+                    cb(err2);
+                }
+            );
         });
     }
 
-
     function buildCreateContainer(_, cb) {
         var labels;
         try {
             labels = JSON.parse(dockerOpts.labels || '{}');
         } catch (ex) {
-            cb(new errors.DockerError(ex, 'Error parsing labels: '
-                + dockerOpts.labels));
+            cb(
+                new errors.DockerError(
+                    ex,
+                    'Error parsing labels: ' + dockerOpts.labels
+                )
+            );
             return;
         }
         var createOpts = {
             account: req.account,
             app: req.app,
             clientApiVersion: req.clientApiVersion,
-            fabricRequireExternal: true,  // use external network
+            fabricRequireExternal: true, // use external network
             image: scratchImage,
             log: log,
             name: 'build_' + req_id,
@@ -182,14 +190,16 @@ function buildImage(opts, callback) {
                 HostConfig: {
                     Memory: dockerOpts.memory
                 },
-                Cmd: [ '# nop (build setup)' ],
+                Cmd: ['# nop (build setup)'],
                 Labels: labels
             },
             req_id: req_id
         };
 
-        req.backend.createContainer(createOpts,
-        function _createContainerCb(err, result) {
+        req.backend.createContainer(createOpts, function _createContainerCb(
+            err,
+            result
+        ) {
             if (err) {
                 log.error(err, 'error calling createContainer');
                 cb(err);
@@ -202,19 +212,24 @@ function buildImage(opts, callback) {
         });
     }
 
-
     function buildGetVmObject(_, cb) {
         var getVmOpts = {
             log: log,
-            owner_uuid : req.account.uuid,
+            owner_uuid: req.account.uuid,
             req_id: req_id,
             vmapi: req.app.vmapi
         };
-        common.getVmByUuid(vmUuid, getVmOpts,
-        function _getVmByUuidCb(err, vmobj) {
+        common.getVmByUuid(vmUuid, getVmOpts, function _getVmByUuidCb(
+            err,
+            vmobj
+        ) {
             if (err) {
-                cb(new errors.DockerError(err,
-                    'problem retrieving build container'));
+                cb(
+                    new errors.DockerError(
+                        err,
+                        'problem retrieving build container'
+                    )
+                );
                 return;
             }
 
@@ -223,7 +238,6 @@ function buildImage(opts, callback) {
         });
     }
 
-
     function buildCnapiDockerBuild(_, cb) {
         var cnapi = req.app.cnapi;
         var cnapiBuildPayload = common.objCopy(dockerOpts);
@@ -245,34 +259,40 @@ function buildImage(opts, callback) {
         }
 
         cnapiBuildPayload.account_uuid = req.account.uuid;
-        cnapiBuildPayload.command = 'build';  // Command type.
+        cnapiBuildPayload.command = 'build'; // Command type.
         cnapiBuildPayload.imgapi_url = req.app.config.imgapi.url;
         cnapiBuildPayload.allDockerImages = allDockerImages;
 
         /* CNAPI, go build for us. */
-        cnapi.dockerBuild(vm.server_uuid, vmUuid,
-            { payload: cnapiBuildPayload },
+        cnapi.dockerBuild(
+            vm.server_uuid,
+            vmUuid,
+            {payload: cnapiBuildPayload},
             cnapiBuildOpts,
             function _dockerBuildCb(err, result) {
                 if (err) {
                     log.error(err, 'error calling cnapi.dockerBuild');
-                    cb(errors.cnapiErrorWrap(
-                        err, 'problem calling docker build'));
+                    cb(
+                        errors.cnapiErrorWrap(
+                            err,
+                            'problem calling docker build'
+                        )
+                    );
                     return;
                 }
 
                 socketOpts = result;
                 cb();
-            });
+            }
+        );
     }
 
-
     function buildSendContext(_, cb) {
         var host = socketOpts.host;
         var port = socketOpts.port;
         var cbCalled = false;
 
-        var contextSocket = net.createConnection({ host:host, port:port });
+        var contextSocket = net.createConnection({host: host, port: port});
 
         log.debug('build server running on host: ', host, 'port: ', port);
 
@@ -306,7 +326,6 @@ function buildImage(opts, callback) {
         res.socket.on('end', respEndListener);
     }
 
-
     function buildFromContext(_, cb) {
         var buildError;
         var buildEventStream;
@@ -317,10 +336,10 @@ function buildImage(opts, callback) {
         cb = once(cb);
 
         log.debug('build: creating second connection to cnapi');
-        var buildSocket = net.createConnection({ host: host, port: port });
-        buildSocket.setTimeout(60 * 60 * 1000);  // 60 minutes
+        var buildSocket = net.createConnection({host: host, port: port});
+        buildSocket.setTimeout(60 * 60 * 1000); // 60 minutes
 
-        var sendEventResponse = function (event, err, result) {
+        var sendEventResponse = function(event, err, result) {
             var response = {
                 messageId: event.messageId,
                 type: 'callback'
@@ -329,7 +348,7 @@ function buildImage(opts, callback) {
                 recordError(err, event.type + ' error');
                 response.error = err.message;
             }
-            if (typeof (result) !== 'undefined') {
+            if (typeof result !== 'undefined') {
                 response['result'] = result;
             }
             log.debug('response:', response);
@@ -398,77 +417,99 @@ function buildImage(opts, callback) {
                     break;
                 case 'stdout':
                     log.debug('Build stdout: %s', event.message);
-                    res.write(JSON.stringify({
-                        'stream': event.message
-                    }) + '\n');
+                    res.write(
+                        JSON.stringify({
+                            stream: event.message
+                        }) + '\n'
+                    );
                     break;
                 case 'image_reprovision':
                     assert.string(event.cmdName, 'event.cmdName');
                     assert.string(event.imageName, 'event.imageName');
                     pullAndReprovisionImage(
-                    {
-                        imageName: event.imageName,
-                        log: log,
-                        rat: rat,
-                        req: req,
-                        req_id: req_id,
-                        res: res,
-                        vm: vm
-                    }, function _pullReprovCb(err, result) {
-                        // Note: result.image is in docker inspect format.
-                        if (!err) {
-                            baseImageId = result.image.Id;
-                            baseImageIndexName = result.index_name;
-                            log.debug('reprovisioned to baseImageId: %j',
-                                baseImageId);
+                        {
+                            imageName: event.imageName,
+                            log: log,
+                            rat: rat,
+                            req: req,
+                            req_id: req_id,
+                            res: res,
+                            vm: vm
+                        },
+                        function _pullReprovCb(err, result) {
+                            // Note: result.image is in docker inspect format.
+                            if (!err) {
+                                baseImageId = result.image.Id;
+                                baseImageIndexName = result.index_name;
+                                log.debug(
+                                    'reprovisioned to baseImageId: %j',
+                                    baseImageId
+                                );
+                            }
+                            sendEventResponse(event, err, result);
                         }
-                        sendEventResponse(event, err, result);
-                    });
+                    );
                     break;
                 case 'image_create':
-                    createImage(event.payload, { rat: rat, req: req },
-                        function _imageCreateCb(err, result)
-                    {
-                        sendEventResponse(event, err, result);
-                    });
+                    createImage(
+                        event.payload,
+                        {rat: rat, req: req},
+                        function _imageCreateCb(err, result) {
+                            sendEventResponse(event, err, result);
+                        }
+                    );
                     break;
                 case 'run':
                     runBuildCommand(
-                    {
-                        dockerId: vmDockerId,
-                        log: log,
-                        req: req,
-                        req_id: req_id,
-                        res: res,
-                        vm: vm
-                    }, function _runCommandCb(err, result) {
-                        sendEventResponse(event, err, result);
-                    });
+                        {
+                            dockerId: vmDockerId,
+                            log: log,
+                            req: req,
+                            req_id: req_id,
+                            res: res,
+                            vm: vm
+                        },
+                        function _runCommandCb(err, result) {
+                            sendEventResponse(event, err, result);
+                        }
+                    );
                     break;
                 case 'build_finished':
                     finalImageId = event.finalId;
-                    vasync.pipeline({ funcs: [
-                        function _doAddBaseImageHead(_result, next) {
-                            addBaseImageHead(baseImageId, finalImageId,
-                            {
-                                baseImageIndexName: baseImageIndexName,
-                                req: req,
-                                scratchImage: scratchImage
-                            }, next);
+                    vasync.pipeline(
+                        {
+                            funcs: [
+                                function _doAddBaseImageHead(_result, next) {
+                                    addBaseImageHead(
+                                        baseImageId,
+                                        finalImageId,
+                                        {
+                                            baseImageIndexName: baseImageIndexName,
+                                            req: req,
+                                            scratchImage: scratchImage
+                                        },
+                                        next
+                                    );
+                                },
+                                function _doTagImage(_result, next) {
+                                    tagImage(
+                                        {
+                                            docker_id: finalImageId,
+                                            name: dockerOpts.tag,
+                                            req: req
+                                        },
+                                        next
+                                    );
+                                }
+                            ]
                         },
-                        function _doTagImage(_result, next) {
-                            tagImage({
-                                    docker_id: finalImageId,
-                                    name: dockerOpts.tag,
-                                    req: req
-                                }, next);
-                        }
-                    ]}, function buildFinishPipeCb(err) {
-                        if (!err) {
-                            buildFinishedSuccessfully = true;
+                        function buildFinishPipeCb(err) {
+                            if (!err) {
+                                buildFinishedSuccessfully = true;
+                            }
+                            sendEventResponse(event, err);
                         }
-                        sendEventResponse(event, err);
-                    });
+                    );
                     break;
                 default:
                     log.error('Unhandled build event: %j', event);
@@ -495,16 +536,19 @@ function buildImage(opts, callback) {
                 return;
             } else {
                 // Send the successfully built image message.
-                res.write(JSON.stringify({
-                    'stream': format('Successfully built %s\n',
-                        finalImageId.substr(0, 12))
-                }) + '\n');
+                res.write(
+                    JSON.stringify({
+                        stream: format(
+                            'Successfully built %s\n',
+                            finalImageId.substr(0, 12)
+                        )
+                    }) + '\n'
+                );
             }
             callback(cleanuperr);
         });
     }
 
-
     function recordError(err, logMessage) {
         log.error(err, logMessage);
         if (!previousErr) {
@@ -512,19 +556,21 @@ function buildImage(opts, callback) {
         }
     }
 
-
     function cleanup(err, cb) {
         if (vmUuid) {
             // Cleanup according to the user's cleanup rules.
             if ((!err && dockerOpts.rm) || dockerOpts.forcerm) {
                 // Ensure the vm is deleted.
                 log.debug('Removing the build container');
-                deleteVm(vmUuid, function (deleteErr) {
+                deleteVm(vmUuid, function(deleteErr) {
                     if (deleteErr) {
                         // Tell client we had a problem deleting the container.
-                        res.write(JSON.stringify({
-                            'stream': 'Error deleting container: ' + err.message
-                        }) + '\n');
+                        res.write(
+                            JSON.stringify({
+                                stream: 'Error deleting container: ' +
+                                    err.message
+                            }) + '\n'
+                        );
                     }
                     // Note that 'err' is deliberately ignored here, as 'err' is
                     // being handled in the buildCleanup function.
@@ -537,22 +583,27 @@ function buildImage(opts, callback) {
         cb();
     }
 
-
     function deleteVm(uuid, cb) {
         var vmapi = req.app.vmapi;
-        var deleteHeaders = { headers: { 'x-request-id': req_id } };
+        var deleteHeaders = {headers: {'x-request-id': req_id}};
         var deleteParams = {
             owner_uuid: req.account.uuid,
             sync: true,
             uuid: uuid
         };
         log.debug('Deleting container ' + uuid);
-        vmapi.deleteVm(deleteParams, deleteHeaders,
-        function _deleteVmCb(deleteErr, job) {
+        vmapi.deleteVm(deleteParams, deleteHeaders, function _deleteVmCb(
+            deleteErr,
+            job
+        ) {
             if (deleteErr) {
                 log.error(deleteErr, 'Error deleting container.');
-                return cb(errors.vmapiErrorWrap(
-                        deleteErr, 'problem deleting container'));
+                return cb(
+                    errors.vmapiErrorWrap(
+                        deleteErr,
+                        'problem deleting container'
+                    )
+                );
             }
 
             log.debug('Deletion was successful');
@@ -561,7 +612,6 @@ function buildImage(opts, callback) {
     }
 }
 
-
 function pullImage(opts, callback) {
     var imageName = opts.imageName;
     var log = opts.log;
@@ -589,7 +639,7 @@ function pullImage(opts, callback) {
         name: imageName,
         includeSmartos: false
     };
-    req.backend.imgFromName(imageOpts, function (err, image) {
+    req.backend.imgFromName(imageOpts, function(err, image) {
         if (err) {
             callback(err);
             return;
@@ -603,54 +653,61 @@ function pullImage(opts, callback) {
         var pullStream = new stream.Transform();
         pullStream.headersSent = true; // Fake it so it looks like a real res.
         pullStream._headerSent = true; // Fake it so it looks like a real res.
-        pullStream._transform = function (chunk, encoding, done) {
+        pullStream._transform = function(chunk, encoding, done) {
             res.write(chunk);
             done();
         };
         // Try and pull the image.
-        req.backend.pullImage({
-            app: req.app,
-            log: log,
-            rat: rat,
-            req: req,
-            req_id: opts.req_id,
-            res: pullStream,
-            wfapi: req.wfapi,
-            account: req.account
-        }, function (perr) {
-            // Cleanup the socket used.
-            req.app.sockets.removeSocket('job', rat.canonicalName);
-            if (perr) {
-                callback(perr);
-                return;
+        req.backend.pullImage(
+            {
+                app: req.app,
+                log: log,
+                rat: rat,
+                req: req,
+                req_id: opts.req_id,
+                res: pullStream,
+                wfapi: req.wfapi,
+                account: req.account
+            },
+            function(perr) {
+                // Cleanup the socket used.
+                req.app.sockets.removeSocket('job', rat.canonicalName);
+                if (perr) {
+                    callback(perr);
+                    return;
+                }
+                // Try again to lookup the image.
+                req.backend.imgFromName(imageOpts, callback);
             }
-            // Try again to lookup the image.
-            req.backend.imgFromName(imageOpts, callback);
-        });
+        );
     });
 }
 
-
 function reprovisionFromImageUuid(image_uuid, opts, callback) {
     var req = opts.req;
     var vm = opts.vm;
     var vmapi = req.app.vmapi;
 
-    vmapi.reprovisionVm({
-        image_uuid: image_uuid,
-        owner_uuid: req.account.uuid,
-        sync: true,
-        uuid: vm.uuid
-    }, {headers: {'x-request-id': opts.req_id}}, function (err, result) {
-        if (err) {
-            callback(errors.vmapiErrorWrap(err, 'problem creating container'));
-            return;
+    vmapi.reprovisionVm(
+        {
+            image_uuid: image_uuid,
+            owner_uuid: req.account.uuid,
+            sync: true,
+            uuid: vm.uuid
+        },
+        {headers: {'x-request-id': opts.req_id}},
+        function(err, result) {
+            if (err) {
+                callback(
+                    errors.vmapiErrorWrap(err, 'problem creating container')
+                );
+                return;
+            }
+            callback();
         }
-        callback();
-    });
+    );
 }
 
-
 /**
  * Ensure the given image exists (by trying to pull it down) and then
  * reprovision the container with that image.
@@ -665,41 +722,53 @@ function pullAndReprovisionImage(opts, callback) {
         // Warning: pullImage can return a null image, which means an error
         // occurred (e.g. the requested image was not found).
         if (!image) {
-            callback(new errors.DockerError(
-                'could not pull image: ' + opts.imageName));
+            callback(
+                new errors.DockerError(
+                    'could not pull image: ' + opts.imageName
+                )
+            );
             return;
         }
 
         // DOCKER-748: Ensure the tag and the base image are from the same repo.
-        var index_name = opts.rat && opts.rat.index.name || 'docker.io';
+        var index_name = (opts.rat && opts.rat.index.name) || 'docker.io';
         if (index_name !== image.index_name) {
-            opts.log.warn('Build failure - using different registries: %s, %s',
-                index_name, image.index_name);
-            callback(new errors.DockerError(format(
-                'Cannot build an image that references different registries '
-                + '(%s, %s)', index_name, image.index_name)));
+            opts.log.warn(
+                'Build failure - using different registries: %s, %s',
+                index_name,
+                image.index_name
+            );
+            callback(
+                new errors.DockerError(
+                    format(
+                        'Cannot build an image that references different registries ' +
+                            '(%s, %s)',
+                        index_name,
+                        image.index_name
+                    )
+                )
+            );
             return;
         }
 
-        reprovisionFromImageUuid(image.image_uuid, opts, function (rerr) {
+        reprovisionFromImageUuid(image.image_uuid, opts, function(rerr) {
             if (rerr) {
                 callback(rerr);
                 return;
             }
             var dockerId = image.docker_id;
             opts.index_name = image.index_name;
-            getImageInInspectFormat(dockerId, opts, function (ierr, iimg) {
+            getImageInInspectFormat(dockerId, opts, function(ierr, iimg) {
                 if (ierr) {
                     callback(ierr);
                     return;
                 }
-                callback(null, { image: iimg, index_name: image.index_name });
+                callback(null, {image: iimg, index_name: image.index_name});
             });
         });
     });
 }
 
-
 /**
  * Creates a new image (in both imgapi and sdc-docker).
  */
@@ -717,7 +786,7 @@ function createImage(payload, opts, callback) {
     var req = opts.req;
     var createOpts = {
         payload: {
-            head: (payload.finalId === payload.image.id),
+            head: payload.finalId === payload.image.id,
             heads: [payload.finalId],
             image: payload.image,
             size: payload.size,
@@ -731,7 +800,6 @@ function createImage(payload, opts, callback) {
     req.backend.createImage(createOpts, callback);
 }
 
-
 /**
  * Update all parent images of finalImageId to include a head reference to
  * finalImageId (for sdc-docker image model).
@@ -742,7 +810,7 @@ function addBaseImageHead(baseImageId, finalImageId, opts, callback) {
     assert.object(opts.req, 'opts.req');
     assert.object(opts.scratchImage, 'opts.scratchImage');
 
-    if (!baseImageId || (baseImageId === opts.scratchImage.id)) {
+    if (!baseImageId || baseImageId === opts.scratchImage.id) {
         callback();
         return;
     }
@@ -761,62 +829,86 @@ function addBaseImageHead(baseImageId, finalImageId, opts, callback) {
         index_name: opts.baseImageIndexName,
         includeSmartos: false
     };
-    req.backend.imgFromName(imageOpts, function (findErr, image) {
+    req.backend.imgFromName(imageOpts, function(findErr, image) {
         if (findErr) {
             callback(findErr);
             return;
         }
         if (!image) {
-            callback(new errors.DockerError(
-                'could not find base image: ' + baseImageId));
+            callback(
+                new errors.DockerError(
+                    'could not find base image: ' + baseImageId
+                )
+            );
             return;
         }
 
         // Update base image (and all base image parent images) to include the
         // new head reference.
-        req.backend.getImageHistory({
-            account: req.account,
-            app: req.app,
-            img: image,
-            log: log
-        }, function (histErr, history) {
-            if (histErr) {
-                callback(new errors.DockerError(histErr,
-                    'could not create image layer'));
-                return;
-            }
-
-            vasync.forEachPipeline({
-                inputs: history,
-                func: addImageHead
-            }, function (err) {
-                if (err) {
-                    callback(new errors.DockerError(err,
-                        'could not create image layer'));
+        req.backend.getImageHistory(
+            {
+                account: req.account,
+                app: req.app,
+                img: image,
+                log: log
+            },
+            function(histErr, history) {
+                if (histErr) {
+                    callback(
+                        new errors.DockerError(
+                            histErr,
+                            'could not create image layer'
+                        )
+                    );
                     return;
                 }
-                callback();
-            });
-
-            function addImageHead(img, next) {
-                log.debug('addImageHead img id: %s, head: %s',
-                    img.docker_id, finalImageId);
-                var addHeadOpts = {
-                    heads: [finalImageId],
-                    id: img.docker_id,
-                    index_name: img.index_name,
-                    req: req
-                };
 
-                req.log.debug(format('Adding %j to %j image heads',
-                    finalImageId, img.docker_id));
-                req.backend.addImageHeads(addHeadOpts, next);
+                vasync.forEachPipeline(
+                    {
+                        inputs: history,
+                        func: addImageHead
+                    },
+                    function(err) {
+                        if (err) {
+                            callback(
+                                new errors.DockerError(
+                                    err,
+                                    'could not create image layer'
+                                )
+                            );
+                            return;
+                        }
+                        callback();
+                    }
+                );
+
+                function addImageHead(img, next) {
+                    log.debug(
+                        'addImageHead img id: %s, head: %s',
+                        img.docker_id,
+                        finalImageId
+                    );
+                    var addHeadOpts = {
+                        heads: [finalImageId],
+                        id: img.docker_id,
+                        index_name: img.index_name,
+                        req: req
+                    };
+
+                    req.log.debug(
+                        format(
+                            'Adding %j to %j image heads',
+                            finalImageId,
+                            img.docker_id
+                        )
+                    );
+                    req.backend.addImageHeads(addHeadOpts, next);
+                }
             }
-        });
+        );
     });
 }
 
-
 /**
  * Tag - your it! Tag is applied to the sdc-docker image model.
  */
@@ -831,12 +923,16 @@ function tagImage(opts, callback) {
         return;
     }
 
-    opts.req.log.debug(format('Adding tag %j to image with docker id %j',
-                            opts.name, opts.docker_id));
+    opts.req.log.debug(
+        format(
+            'Adding tag %j to image with docker id %j',
+            opts.name,
+            opts.docker_id
+        )
+    );
     opts.req.backend.tagImage(opts, callback);
 }
 
-
 /**
  * Run the given run command inside of the container. This will start/stop the
  * container.
@@ -866,9 +962,9 @@ function runBuildCommand(opts, callback) {
 
     // Pipe attachContainer data back to the client.
     var attachStream = new stream.Writable();
-    attachStream._write = function (chunk, encoding, done) {
+    attachStream._write = function(chunk, encoding, done) {
         log.debug('runBuildCommand: attach wrote %j bytes', chunk.length);
-        res.write(JSON.stringify({ stream: String(chunk) }) + '\n');
+        res.write(JSON.stringify({stream: String(chunk)}) + '\n');
         done();
     };
 
@@ -885,58 +981,78 @@ function runBuildCommand(opts, callback) {
      *   waitContainer is then called to get the exit code.
      */
 
-    vasync.parallel({ funcs: [
-        function _attach(next) {
-            req.backend.attachContainer({
-                account: req.account,
-                app: req.app,
-                doNotEncodeData: true,  // Don't encode when writing to stream.
-                id: opts.dockerId,
-                log: log,
-                payload: payload,
-                req_id: opts.req_id,
-                socket: attachStream,
-                vm: opts.vm
-            }, function (err) {
-                log.debug('runBuildCommand: attachContainer finished, err: %j',
-                    err);
-                next(err);
-            });
-        },
+    vasync.parallel(
+        {
+            funcs: [
+                function _attach(next) {
+                    req.backend.attachContainer(
+                        {
+                            account: req.account,
+                            app: req.app,
+                            doNotEncodeData: true, // Don't encode when writing to stream.
+                            id: opts.dockerId,
+                            log: log,
+                            payload: payload,
+                            req_id: opts.req_id,
+                            socket: attachStream,
+                            vm: opts.vm
+                        },
+                        function(err) {
+                            log.debug(
+                                'runBuildCommand: attachContainer finished, err: %j',
+                                err
+                            );
+                            next(err);
+                        }
+                    );
+                },
 
-        function _start(next) {
-            req.backend.startContainer({
-                account: req.account,
-                app: req.app,
-                log: log,
-                req_id: opts.req_id,
-                vm: opts.vm
-            }, function (err) {
-                log.debug('runBuildCommand: startContainer finished, err: %j',
-                    err);
-                next(err);
-            });
-        }
-    ]}, function (err) {
-        if (err) {
-            callback(err);
-            return;
+                function _start(next) {
+                    req.backend.startContainer(
+                        {
+                            account: req.account,
+                            app: req.app,
+                            log: log,
+                            req_id: opts.req_id,
+                            vm: opts.vm
+                        },
+                        function(err) {
+                            log.debug(
+                                'runBuildCommand: startContainer finished, err: %j',
+                                err
+                            );
+                            next(err);
+                        }
+                    );
+                }
+            ]
+        },
+        function(err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            // Get return code from the run command.
+            req.backend.waitContainer(
+                {
+                    account: req.account,
+                    app: req.app,
+                    log: log,
+                    req_id: opts.req_id,
+                    vm: opts.vm
+                },
+                function(waitErr, exitCode) {
+                    log.debug(
+                        'runBuildCommand: container exit code: %j',
+                        exitCode
+                    );
+                    callback(waitErr, {exitCode: exitCode});
+                }
+            );
         }
-        // Get return code from the run command.
-        req.backend.waitContainer({
-            account: req.account,
-            app: req.app,
-            log: log,
-            req_id: opts.req_id,
-            vm: opts.vm
-        }, function (waitErr, exitCode) {
-            log.debug('runBuildCommand: container exit code: %j', exitCode);
-            callback(waitErr, { exitCode: exitCode });
-        });
-    });
+    );
 }
 
-
 /**
  * Commit (create) an image from a given container.
  *
@@ -963,12 +1079,12 @@ function commitImage(req, opts, callback) {
     assert.optionalString(opts.tag, 'opts.tag');
 
     var vm = req.vm;
-    assert.object(vm, 'vm');  // Should have been added by the backend.
+    assert.object(vm, 'vm'); // Should have been added by the backend.
 
     var baseImg;
     var baseImageId = vm.internal_metadata['docker:imageid'];
     var commitFinishedSuccessfully = false;
-    var finalImageId = null;  // Final docker image id for resulting image.
+    var finalImageId = null; // Final docker image id for resulting image.
     var log = req.log;
     var previousErr;
     var rat;
@@ -987,18 +1103,24 @@ function commitImage(req, opts, callback) {
         return;
     }
 
-    vasync.pipeline({ funcs: [
-        getScratchImage,
-        findContainerImage,
-        checkTagRepository,
-        startCnapiDockerCommit,
-        runCnapiDockerCommit
-    ]}, commitCleanup);
-
+    vasync.pipeline(
+        {
+            funcs: [
+                getScratchImage,
+                findContainerImage,
+                checkTagRepository,
+                startCnapiDockerCommit,
+                runCnapiDockerCommit
+            ]
+        },
+        commitCleanup
+    );
 
     function getScratchImage(_, cb) {
-        req.app.backend.getScratchImage(req,
-        function _getScratchImageCb(err, sImg) {
+        req.app.backend.getScratchImage(req, function _getScratchImageCb(
+            err,
+            sImg
+        ) {
             if (err) {
                 log.error(err, 'getScratchImage failure');
                 cb(err);
@@ -1016,7 +1138,9 @@ function commitImage(req, opts, callback) {
             app: req.app,
             log: log
         };
-        images.getDockerImageForUuid(vm.image_uuid, dockerImageOpts,
+        images.getDockerImageForUuid(
+            vm.image_uuid,
+            dockerImageOpts,
             function _dockerImageUuidCb(err, imgModel) {
                 baseImg = imgModel;
                 cb(err);
@@ -1027,9 +1151,16 @@ function commitImage(req, opts, callback) {
     function checkTagRepository(_, cb) {
         // DOCKER-748: Ensure the tag and the image are in the same repository.
         if (baseImg.index_name !== rat.index.name) {
-            cb(new errors.DockerError(format(
-                'Cannot create tag reference between different registries '
-                + '(%s, %s)', baseImg.index_name, rat.index.name)));
+            cb(
+                new errors.DockerError(
+                    format(
+                        'Cannot create tag reference between different registries ' +
+                            '(%s, %s)',
+                        baseImg.index_name,
+                        rat.index.name
+                    )
+                )
+            );
             return;
         }
         cb();
@@ -1056,14 +1187,16 @@ function commitImage(req, opts, callback) {
         }
 
         cnapiCommitPayload.account_uuid = req.account.uuid;
-        cnapiCommitPayload.command = 'commit';  // Command type.
+        cnapiCommitPayload.command = 'commit'; // Command type.
         cnapiCommitPayload.fromImage = utils.imgobjToInspect(baseImg);
         cnapiCommitPayload.fromImageUuid = vm.image_uuid;
         cnapiCommitPayload.imgapi_url = req.app.config.imgapi.url;
 
         /* CNAPI, commit the container to an image for us. */
-        cnapi.dockerBuild(vm.server_uuid, vm.uuid,
-            { payload: cnapiCommitPayload },
+        cnapi.dockerBuild(
+            vm.server_uuid,
+            vm.uuid,
+            {payload: cnapiCommitPayload},
             cnapiCommitOpts,
             function _dockerCommitCb(err, result) {
                 if (err) {
@@ -1078,7 +1211,6 @@ function commitImage(req, opts, callback) {
         );
     }
 
-
     function runCnapiDockerCommit(_, cb) {
         var commitError;
         var commitEventStream;
@@ -1088,11 +1220,11 @@ function commitImage(req, opts, callback) {
         // There is the potential to call cb twice, make sure it never happens.
         cb = once(cb);
 
-        var commitSocket = net.createConnection({ host: host, port: port });
-        commitSocket.setTimeout(10 * 60 * 1000);  // 10 minutes
+        var commitSocket = net.createConnection({host: host, port: port});
+        commitSocket.setTimeout(10 * 60 * 1000); // 10 minutes
         log.debug('commit: created socket connection to cnapi');
 
-        var sendEventResponse = function (event, err, result) {
+        var sendEventResponse = function(event, err, result) {
             var response = {
                 messageId: event.messageId,
                 type: 'callback'
@@ -1101,7 +1233,7 @@ function commitImage(req, opts, callback) {
                 recordError(err, event.type + ' error');
                 response.error = err.message;
             }
-            if (typeof (result) !== 'undefined') {
+            if (typeof result !== 'undefined') {
                 response['result'] = result;
             }
             log.debug('response:', response);
@@ -1116,68 +1248,86 @@ function commitImage(req, opts, callback) {
         commitEventStream = new LineStream();
         commitSocket.pipe(commitEventStream);
 
-        commitEventStream.on('readable', function commitEventStreamOnReadable()
-        {
-            var line;
-            var event;
-            while ((line = commitEventStream.read()) != null) {
-                log.debug('commit: got commit event:', String(line));
-                try {
-                    event = JSON.parse(line);
-                } catch (e) {
-                    log.error('Commit: invalid json: %s - ignoring', line);
-                    continue;
-                }
-                switch (event.type) {
-                    case 'end':
-                        if (event.error) {
-                            // Will be passed to callback `cb`.
-                            commitError = new Error(event.error);
-                        }
-                        break;
-                    case 'message':
-                    case 'stdout':
-                        log.info('Commit event message: %s', event.message);
-                        break;
-                    case 'image_create':
-                        createImage(event.payload, { rat: rat, req: req },
-                            function _imageCreateCb(err, result)
-                        {
-                            sendEventResponse(event, err, result);
-                        });
-                        break;
-                    case 'commit_finished':
-                        finalImageId = event.finalId;
-                        vasync.pipeline({ funcs: [
-                            function _doAddBaseImageHead(_result, next) {
-                                addBaseImageHead(baseImageId, finalImageId,
-                                {
-                                    baseImageIndexName: baseImg.index_name,
-                                    req: req,
-                                    scratchImage: scratchImage
-                                }, next);
-                            },
-                            function _doTagImage(_result, next) {
-                                tagImage({
-                                        docker_id: finalImageId,
-                                        name: opts.tag,
-                                        req: req
-                                    }, next);
-                            }
-                        ]}, function commitFinishPipeCb(err) {
-                            if (!err) {
-                                commitFinishedSuccessfully = true;
+        commitEventStream.on(
+            'readable',
+            function commitEventStreamOnReadable() {
+                var line;
+                var event;
+                while ((line = commitEventStream.read()) != null) {
+                    log.debug('commit: got commit event:', String(line));
+                    try {
+                        event = JSON.parse(line);
+                    } catch (e) {
+                        log.error('Commit: invalid json: %s - ignoring', line);
+                        continue;
+                    }
+                    switch (event.type) {
+                        case 'end':
+                            if (event.error) {
+                                // Will be passed to callback `cb`.
+                                commitError = new Error(event.error);
                             }
-                            sendEventResponse(event, err);
-                        });
-                        break;
-                    default:
-                        log.error('Unhandled commit event: %j', event);
-                        break;
+                            break;
+                        case 'message':
+                        case 'stdout':
+                            log.info('Commit event message: %s', event.message);
+                            break;
+                        case 'image_create':
+                            createImage(
+                                event.payload,
+                                {rat: rat, req: req},
+                                function _imageCreateCb(err, result) {
+                                    sendEventResponse(event, err, result);
+                                }
+                            );
+                            break;
+                        case 'commit_finished':
+                            finalImageId = event.finalId;
+                            vasync.pipeline(
+                                {
+                                    funcs: [
+                                        function _doAddBaseImageHead(
+                                            _result,
+                                            next
+                                        ) {
+                                            addBaseImageHead(
+                                                baseImageId,
+                                                finalImageId,
+                                                {
+                                                    baseImageIndexName: baseImg.index_name,
+                                                    req: req,
+                                                    scratchImage: scratchImage
+                                                },
+                                                next
+                                            );
+                                        },
+                                        function _doTagImage(_result, next) {
+                                            tagImage(
+                                                {
+                                                    docker_id: finalImageId,
+                                                    name: opts.tag,
+                                                    req: req
+                                                },
+                                                next
+                                            );
+                                        }
+                                    ]
+                                },
+                                function commitFinishPipeCb(err) {
+                                    if (!err) {
+                                        commitFinishedSuccessfully = true;
+                                    }
+                                    sendEventResponse(event, err);
+                                }
+                            );
+                            break;
+                        default:
+                            log.error('Unhandled commit event: %j', event);
+                            break;
+                    }
                 }
-
             }
-        });
+        );
 
         commitEventStream.on('close', function _eventStreamCloseCb() {
             log.debug('commit: commitEventStream.close - closing socket');
@@ -1197,7 +1347,6 @@ function commitImage(req, opts, callback) {
         });
     }
 
-
     function commitCleanup(err, results) {
         log.debug('commit: final callback, err: %j', err);
         if (err) {
@@ -1216,7 +1365,6 @@ function commitImage(req, opts, callback) {
         callback(null, finalImageId);
     }
 
-
     function recordError(err, logMessage) {
         log.error(err, logMessage);
         if (!previousErr) {
@@ -1225,7 +1373,6 @@ function commitImage(req, opts, callback) {
     }
 }
 
-
 // ---- exports
 
 module.exports = {
diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index cf6d358..052cecb 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -37,7 +37,6 @@ var Link = require('../../models/link');
 var utils = require('./utils');
 var validate = require('../../validate');
 
-
 //---- globals
 
 var format = util.format;
@@ -79,7 +78,6 @@ var PACKAGE_SELECTION_LABEL = 'com.joyent.package';
 var BAD_PKG_NAME_RE = /[\_\-\.][\_\-\.]/;
 var PKG_NAME_RE = /^[a-zA-Z0-9]([a-zA-Z0-9\_\-\.]+)?[a-zA-Z0-9]$/;
 
-
 //---- internal support routines
 
 function getCnapiClient(config) {
@@ -130,7 +128,6 @@ function getPapiClient(config) {
     return _papiClientCache;
 }
 
-
 /**
  * Return rules that expose each specified port individually for a given
  * account and protocol.
@@ -139,9 +136,15 @@ function generateExposeRules(account, vm, proto, ports, cb) {
     var protoRules = [];
 
     if (ports.length > MAX_EXPOSED_PORTS) {
-        return cb(new errors.DockerError(util.format(
-            'publish port: only support exposing %d %s ports',
-            MAX_EXPOSED_PORTS, proto.toUpperCase())));
+        return cb(
+            new errors.DockerError(
+                util.format(
+                    'publish port: only support exposing %d %s ports',
+                    MAX_EXPOSED_PORTS,
+                    proto.toUpperCase()
+                )
+            )
+        );
     }
 
     // Each FWAPI rule only supports 8 ports
@@ -154,8 +157,12 @@ function generateExposeRules(account, vm, proto, ports, cb) {
         protoRules.push({
             enabled: true,
             owner_uuid: account.uuid,
-            rule: util.format('FROM any to vm %s ALLOW %s (port %s)',
-                vm, proto, rulePorts.sort().join(' AND port ')),
+            rule: util.format(
+                'FROM any to vm %s ALLOW %s (port %s)',
+                vm,
+                proto,
+                rulePorts.sort().join(' AND port ')
+            ),
             uuid: libuuid.create()
         });
     }
@@ -164,8 +171,7 @@ function generateExposeRules(account, vm, proto, ports, cb) {
 }
 
 function port2str(port) {
-    if (port.hasOwnProperty('start')
-        && port.hasOwnProperty('end')) {
+    if (port.hasOwnProperty('start') && port.hasOwnProperty('end')) {
         return String(port.start) + '-' + String(port.end);
     } else {
         return String(port);
@@ -180,9 +186,15 @@ function generateExposeRange(account, vm, proto, ports, cb) {
 
     ports = utils.compressPorts(ports);
     if (ports.length > MAX_EXPOSED_PORTS) {
-        return cb(new errors.DockerError(util.format(
-            'publish port: only support exposing %d %s port ranges',
-            MAX_EXPOSED_PORTS, proto.toUpperCase())));
+        return cb(
+            new errors.DockerError(
+                util.format(
+                    'publish port: only support exposing %d %s port ranges',
+                    MAX_EXPOSED_PORTS,
+                    proto.toUpperCase()
+                )
+            )
+        );
     }
 
     // Each FWAPI rule only supports 8 ports
@@ -195,8 +207,12 @@ function generateExposeRange(account, vm, proto, ports, cb) {
         protoRules.push({
             enabled: true,
             owner_uuid: account.uuid,
-            rule: util.format('FROM any to vm %s ALLOW %s ports %s',
-                vm, proto, rulePorts.map(port2str).join(',')),
+            rule: util.format(
+                'FROM any to vm %s ALLOW %s ports %s',
+                vm,
+                proto,
+                rulePorts.map(port2str).join(',')
+            ),
             uuid: libuuid.create()
         });
     }
@@ -204,15 +220,17 @@ function generateExposeRange(account, vm, proto, ports, cb) {
     return cb(null, protoRules);
 }
 
-
 /**
  * List networks in NAPI, filtering by params
  */
 function listNetworks(opts, params, callback) {
     var napi = getNapiClient(opts.config.napi);
 
-    napi.listNetworks(params, {headers: {'x-request-id': opts.req_id}},
-        callback);
+    napi.listNetworks(
+        params,
+        {headers: {'x-request-id': opts.req_id}},
+        callback
+    );
 }
 
 /**
@@ -226,8 +244,12 @@ function listNetworks(opts, params, callback) {
 function addExposeFirewallRules(opts, payload, callback) {
     var fwapi = getFwapiClient(opts.config.fwapi);
     var listParams = {
-        fields: ['parsed.action', 'parsed.ports', 'parsed.protocol',
-            'parsed.tags'],
+        fields: [
+            'parsed.action',
+            'parsed.ports',
+            'parsed.protocol',
+            'parsed.tags'
+        ],
         owner_uuid: opts.account.uuid,
         tag: 'sdc_docker'
     };
@@ -235,29 +257,33 @@ function addExposeFirewallRules(opts, payload, callback) {
         headers: {'x-request-id': opts.req_id}
     };
 
-    fwapi.listRules(listParams, listOpts, function (listErr, rules) {
+    fwapi.listRules(listParams, listOpts, function(listErr, rules) {
         var parsed;
         var rulesToAdd = [];
         var tcpRuleFound;
         var udpRuleFound;
 
         if (listErr) {
-            callback(errors.fwapiErrorWrap(listErr,
-                'problem listing firewall rules'));
+            callback(
+                errors.fwapiErrorWrap(listErr, 'problem listing firewall rules')
+            );
             return;
         }
 
-        opts.log.debug({ rules: rules }, 'rules found');
+        opts.log.debug({rules: rules}, 'rules found');
 
         // Try to find rules that allow traffic on all ports between docker
         // VMs.  We're looking for two: one for TCP and one for UDP.
         for (var r in rules) {
             parsed = rules[r].parsed;
 
-            if (!parsed || !parsed.hasOwnProperty('ports')
-                    || !parsed.hasOwnProperty('protocol')
-                    || !parsed.hasOwnProperty('fromtags')
-                    || !parsed.hasOwnProperty('totags')) {
+            if (
+                !parsed ||
+                !parsed.hasOwnProperty('ports') ||
+                !parsed.hasOwnProperty('protocol') ||
+                !parsed.hasOwnProperty('fromtags') ||
+                !parsed.hasOwnProperty('totags')
+            ) {
                 continue;
             }
 
@@ -269,8 +295,9 @@ function addExposeFirewallRules(opts, payload, callback) {
                 continue;
             }
 
-            if (!parsed.fromtags.sdc_docker
-                    || !parsed.fromtags.sdc_docker.all) {
+            if (
+                !parsed.fromtags.sdc_docker || !parsed.fromtags.sdc_docker.all
+            ) {
                 continue;
             }
 
@@ -280,15 +307,19 @@ function addExposeFirewallRules(opts, payload, callback) {
 
             if (parsed.protocol === 'tcp' && !tcpRuleFound) {
                 tcpRuleFound = true;
-                opts.log.debug({ rule: rules[r] },
-                    'TCP docker expose rule found: not adding');
+                opts.log.debug(
+                    {rule: rules[r]},
+                    'TCP docker expose rule found: not adding'
+                );
                 addRulesToPayload(payload, rules[r]);
             }
 
             if (parsed.protocol === 'udp' && !udpRuleFound) {
                 udpRuleFound = true;
-                opts.log.debug({ rule: rules[r] },
-                    'UDP docker expose rule found: not adding');
+                opts.log.debug(
+                    {rule: rules[r]},
+                    'UDP docker expose rule found: not adding'
+                );
                 addRulesToPayload(payload, rules[r]);
             }
         }
@@ -298,8 +329,7 @@ function addExposeFirewallRules(opts, payload, callback) {
             rulesToAdd.push({
                 enabled: true,
                 owner_uuid: opts.account.uuid,
-                rule:
-                    'FROM tag sdc_docker TO tag sdc_docker ALLOW tcp PORT all'
+                rule: 'FROM tag sdc_docker TO tag sdc_docker ALLOW tcp PORT all'
             });
         }
 
@@ -308,8 +338,7 @@ function addExposeFirewallRules(opts, payload, callback) {
             rulesToAdd.push({
                 enabled: true,
                 owner_uuid: opts.account.uuid,
-                rule:
-                    'FROM tag sdc_docker TO tag sdc_docker ALLOW udp PORT all'
+                rule: 'FROM tag sdc_docker TO tag sdc_docker ALLOW udp PORT all'
             });
         }
 
@@ -336,7 +365,7 @@ function addPublishFirewallRules(opts, container, img, payload, callback) {
     var e;
     var exposed;
     var hostConf = container.HostConfig;
-    var imageExposedPorts = img.config && img.config.ExposedPorts || {};
+    var imageExposedPorts = (img.config && img.config.ExposedPorts) || {};
     var publishAllPorts = hostConf.PublishAllPorts;
     var log = opts.log;
     var exposedPorts = {
@@ -368,7 +397,7 @@ function addPublishFirewallRules(opts, container, img, payload, callback) {
         // If it's not being bound/published, note it, and we're done.
         if (!bound && !publishAllPorts) {
             if (unpublishedPorts[proto].indexOf(portNum) === -1) {
-                    unpublishedPorts[proto].push(portNum);
+                unpublishedPorts[proto].push(portNum);
             }
             return;
         }
@@ -381,22 +410,31 @@ function addPublishFirewallRules(opts, container, img, payload, callback) {
 
         exposedPorts[proto].push(portNum);
         if (exposedPorts[proto].length > MAX_PROCESSED_PORTS) {
-            throw new errors.DockerError(util.format(
-                'only support processing %d %s ports',
-                MAX_EXPOSED_PORTS, proto.toUpperCase()));
+            throw new errors.DockerError(
+                util.format(
+                    'only support processing %d %s ports',
+                    MAX_EXPOSED_PORTS,
+                    proto.toUpperCase()
+                )
+            );
         }
 
         if (bound) {
-            if (portVal && portVal[0] && portVal[0].HostPort
-                    && portVal[0].HostPort !== split[0]) {
+            if (
+                portVal &&
+                portVal[0] &&
+                portVal[0].HostPort &&
+                portVal[0].HostPort !== split[0]
+            ) {
                 throw new errors.DockerError(
-                    'remapping of port numbers not allowed');
+                    'remapping of port numbers not allowed'
+                );
             }
         }
     }
 
     exposed = imageExposedPorts;
-    log.info({ exposed: exposed }, 'image ExposedPorts');
+    log.info({exposed: exposed}, 'image ExposedPorts');
 
     try {
         // This has been done for hostConf.PortBindings already in
@@ -412,20 +450,20 @@ function addPublishFirewallRules(opts, container, img, payload, callback) {
         try {
             addPort(e, exposed[e], false);
         } catch (addErr) {
-            callback(new errors.DockerError(
-                'Image ExposedPorts: ' + addErr.message));
+            callback(
+                new errors.DockerError('Image ExposedPorts: ' + addErr.message)
+            );
             return;
         }
     }
 
     exposed = hostConf.PortBindings || {};
-    log.info({ exposed: exposed }, 'image HostConfig.PortBindings');
+    log.info({exposed: exposed}, 'image HostConfig.PortBindings');
     for (e in exposed) {
         try {
             addPort(e, exposed[e], true);
         } catch (addErr) {
-            callback(new errors.DockerError(
-                'publish port: ' + addErr.message));
+            callback(new errors.DockerError('publish port: ' + addErr.message));
             return;
         }
     }
@@ -434,49 +472,65 @@ function addPublishFirewallRules(opts, container, img, payload, callback) {
         payload.internal_metadata['docker:publish_all_ports'] = true;
     }
 
-    vasync.forEachPipeline({
-        'inputs': ['tcp', 'udp'],
-        'func': function (portProto, cb) {
-            var unpbKey = 'docker:' + portProto + '_unpublished_ports';
-            if (unpublishedPorts[portProto].length > 0) {
-                payload.internal_metadata[unpbKey] =
-                    JSON.stringify(unpublishedPorts[portProto]);
-            }
+    vasync.forEachPipeline(
+        {
+            inputs: ['tcp', 'udp'],
+            func: function(portProto, cb) {
+                var unpbKey = 'docker:' + portProto + '_unpublished_ports';
+                if (unpublishedPorts[portProto].length > 0) {
+                    payload.internal_metadata[unpbKey] = JSON.stringify(
+                        unpublishedPorts[portProto]
+                    );
+                }
 
-            // The "bound ports" don't actually affect any connectivity between
-            // hosts, since we don't remap ports or have the concept of a host
-            // that we're binding to - they're just for populating
-            // HostConfig.PortBindings correctly.
+                // The "bound ports" don't actually affect any connectivity between
+                // hosts, since we don't remap ports or have the concept of a host
+                // that we're binding to - they're just for populating
+                // HostConfig.PortBindings correctly.
 
-            var ports = exposedPorts[portProto];
+                var ports = exposedPorts[portProto];
 
-            if (ports.length === 0) {
-                return cb(null, []);
-            }
+                if (ports.length === 0) {
+                    return cb(null, []);
+                }
 
-            // Generate firewall rules. If port ranges are available, use them
-            if (opts.config.fwrule_version > 1) {
-                return generateExposeRange(opts.account, payload.uuid,
-                    portProto, ports, cb);
-            } else {
-                return generateExposeRules(opts.account, payload.uuid,
-                    portProto, ports, cb);
+                // Generate firewall rules. If port ranges are available, use them
+                if (opts.config.fwrule_version > 1) {
+                    return generateExposeRange(
+                        opts.account,
+                        payload.uuid,
+                        portProto,
+                        ports,
+                        cb
+                    );
+                } else {
+                    return generateExposeRules(
+                        opts.account,
+                        payload.uuid,
+                        portProto,
+                        ports,
+                        cb
+                    );
+                }
+            }
+        },
+        function(err, results) {
+            if (err) {
+                callback(err);
+                return;
             }
-        }
-    }, function (err, results) {
-        if (err) {
-            callback(err);
-            return;
-        }
 
-        var addToFWAPI = Array.prototype.concat.apply([], results.successes);
-        log.info({ rules: addToFWAPI }, 'Publishing firewall rules');
+            var addToFWAPI = Array.prototype.concat.apply(
+                [],
+                results.successes
+            );
+            log.info({rules: addToFWAPI}, 'Publishing firewall rules');
 
-        addRulesToFWAPI(opts, addToFWAPI, payload, callback);
-    });
+            addRulesToFWAPI(opts, addToFWAPI, payload, callback);
+        }
+    );
 }
 
-
 /**
  * Create the given rules in FWAPI.  If successful, adds them to the payload.
  */
@@ -489,40 +543,50 @@ function addRulesToFWAPI(opts, rules, payload, callback) {
     var fwapi = getFwapiClient(opts.config.fwapi);
 
     function _addFwRule(rule, cb) {
-        fwapi.createRule(rule, {
-            headers: {'x-request-id': opts.req_id}
-        }, function (createErr, created) {
-            if (createErr) {
-                opts.log.error({ err: createErr, rule: rule },
-                    'Error creating firewall rule');
+        fwapi.createRule(
+            rule,
+            {
+                headers: {'x-request-id': opts.req_id}
+            },
+            function(createErr, created) {
+                if (createErr) {
+                    opts.log.error(
+                        {err: createErr, rule: rule},
+                        'Error creating firewall rule'
+                    );
+                }
+
+                if (created) {
+                    opts.log.info({rule: created}, 'Created firewall rule');
+                }
+
+                cb(createErr, created);
+                return;
             }
+        );
+    }
 
-            if (created) {
-                opts.log.info({ rule: created }, 'Created firewall rule');
+    vasync.forEachParallel(
+        {
+            func: _addFwRule,
+            inputs: rules
+        },
+        function(vErr, results) {
+            if (vErr) {
+                callback(
+                    errors.fwapiErrorWrap(vErr, 'problem adding firewall rules')
+                );
+                return;
             }
 
-            cb(createErr, created);
-            return;
-        });
-    }
+            if (results.successes.length !== 0) {
+                addRulesToPayload(payload, results.successes);
+            }
 
-    vasync.forEachParallel({
-        func: _addFwRule,
-        inputs: rules
-    }, function (vErr, results) {
-        if (vErr) {
-            callback(errors.fwapiErrorWrap(vErr,
-                'problem adding firewall rules'));
+            callback();
             return;
         }
-
-        if (results.successes.length !== 0) {
-            addRulesToPayload(payload, results.successes);
-        }
-
-        callback();
-        return;
-    });
+    );
 }
 
 /**
@@ -548,10 +612,14 @@ function addNetworksToPayload(opts, container, payload, callback) {
     assert.object(opts.log, 'opts.log');
     assert.object(opts.config.overlay, 'opts.config.overlay');
 
-    assert.optionalString(opts.config.overlay.externalPool,
-        'opts.config.overlay.externalPool');
-    assert.optionalBool(opts.config.overlay.enabled,
-        'opts.config.overlay.enabled');
+    assert.optionalString(
+        opts.config.overlay.externalPool,
+        'opts.config.overlay.externalPool'
+    );
+    assert.optionalBool(
+        opts.config.overlay.enabled,
+        'opts.config.overlay.enabled'
+    );
     assert.func(callback, 'callback');
 
     /*
@@ -564,9 +632,11 @@ function addNetworksToPayload(opts, container, payload, callback) {
     if (!opts.config.overlay.enabled) {
         return externalNetworkByName(opts, payload, callback);
     } else {
-        if (container.HostConfig.NetworkMode === 'bridge'
-            || container.HostConfig.NetworkMode === 'default'
-            || common.objEmpty(container.HostConfig.NetworkMode)) {
+        if (
+            container.HostConfig.NetworkMode === 'bridge' ||
+            container.HostConfig.NetworkMode === 'default' ||
+            common.objEmpty(container.HostConfig.NetworkMode)
+        ) {
             return defaultFabricNetwork(opts, payload, callback);
         } else {
             return namedNetwork(opts, container, payload, callback);
@@ -580,8 +650,10 @@ function addNetworksToPayload(opts, container, payload, callback) {
  */
 function externalNetworkByName(opts, payload, callback) {
     assert.object(opts.config, 'opts.config');
-    assert.optionalString(opts.config.externalNetwork,
-        'opts.config.externalNetwork');
+    assert.optionalString(
+        opts.config.externalNetwork,
+        'opts.config.externalNetwork'
+    );
     assert.object(opts.account, 'opts.account');
     assert.string(opts.account.uuid, 'opts.account.uuid');
     assert.object(payload, 'payload');
@@ -594,30 +666,47 @@ function externalNetworkByName(opts, payload, callback) {
         provisionable_by: opts.account.uuid
     };
 
-    log.debug({ listParams: listParams },
-        format('Networks: fabrics not configured, using network %s',
-        listParams.name));
+    log.debug(
+        {listParams: listParams},
+        format(
+            'Networks: fabrics not configured, using network %s',
+            listParams.name
+        )
+    );
 
-    listNetworks(opts, listParams, function (err, networks) {
-        log.debug({ err: err, res: networks },
-            format('Networks: listNetworks result for %s', listParams.name));
+    listNetworks(opts, listParams, function(err, networks) {
+        log.debug(
+            {err: err, res: networks},
+            format('Networks: listNetworks result for %s', listParams.name)
+        );
 
         if (err) {
-            callback(errors.napiErrorWrap(err,
-                format('Networks: problem listing network %s',
-                    listParams.name)));
+            callback(
+                errors.napiErrorWrap(
+                    err,
+                    format(
+                        'Networks: problem listing network %s',
+                        listParams.name
+                    )
+                )
+            );
             return;
         }
 
         if (networks.length < 1) {
-            log.error({ networks: networks, params: listParams },
-                format('Networks: network %s provisionable by %s not found',
-                    listParams.name, listParams.provisionable_by));
+            log.error(
+                {networks: networks, params: listParams},
+                format(
+                    'Networks: network %s provisionable by %s not found',
+                    listParams.name,
+                    listParams.provisionable_by
+                )
+            );
             callback(new errors.NetworkNotFoundError(listParams.name));
             return;
         }
 
-        payload.networks = [ { uuid: networks[0].uuid, primary: true} ];
+        payload.networks = [{uuid: networks[0].uuid, primary: true}];
         callback();
         return;
     });
@@ -637,8 +726,10 @@ function defaultFabricNetwork(opts, payload, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
     assert.object(opts.app.config, 'opts.app.config');
-    assert.string(opts.app.config.datacenterName,
-        'opts.app.config.datacenterName');
+    assert.string(
+        opts.app.config.datacenterName,
+        'opts.app.config.datacenterName'
+    );
     assert.object(opts.log, 'opt.log');
     assert.object(payload, 'payload');
     assert.func(callback, 'callback');
@@ -648,17 +739,23 @@ function defaultFabricNetwork(opts, payload, callback) {
 
     log.debug('Networks: using default fabric network');
 
-    opts.app.ufds.getDcLocalConfig(opts.account.uuid, dc, function (err, conf) {
-        log.debug({err: err, conf: conf, account: opts.account.uuid},
-            'Networks: get DC local config');
+    opts.app.ufds.getDcLocalConfig(opts.account.uuid, dc, function(err, conf) {
+        log.debug(
+            {err: err, conf: conf, account: opts.account.uuid},
+            'Networks: get DC local config'
+        );
 
         if (err || !conf || !conf.defaultnetwork) {
-            callback(errors.ufdsErrorWrap(err,
-                'Networks: could not get default network'));
+            callback(
+                errors.ufdsErrorWrap(
+                    err,
+                    'Networks: could not get default network'
+                )
+            );
             return;
         }
 
-        payload.networks = [ { uuid: conf.defaultnetwork, primary: true } ];
+        payload.networks = [{uuid: conf.defaultnetwork, primary: true}];
 
         callback();
         return;
@@ -678,10 +775,15 @@ function namedNetwork(opts, container, payload, callback) {
     assert.object(opts.log, 'opts.log');
     assert.object(container, 'container');
     assert.object(container.HostConfig, 'container.HostConfig');
-    assert.string(container.HostConfig.NetworkMode,
-        'container.HostConfig.NetworkMode');
-    assert.notEqual(container.HostConfig.NetworkMode, '',
-        'NetworkMode is empty');
+    assert.string(
+        container.HostConfig.NetworkMode,
+        'container.HostConfig.NetworkMode'
+    );
+    assert.notEqual(
+        container.HostConfig.NetworkMode,
+        '',
+        'NetworkMode is empty'
+    );
     assert.func(callback, 'callback');
 
     // need to search on networks by: name, fabric-true, owner_uuid
@@ -694,153 +796,195 @@ function namedNetwork(opts, container, payload, callback) {
     // 1. exact id match
     // 2. exact name match
     // 3. partial id match
-    vasync.parallel({
-        funcs: [
-            function byExactId(cb) {
-                // length === 64, and 0..31 === 32..63, or it's an 'impossible'
-                // id under our double-uuid convention, and we can skip it.
-                if (query.substr(0, 32) !== query.substr(32)) {
-                    log.debug({ query: query },
-                        'Networks: impossible exactId: %s, skipping', query);
-                    setImmediate(cb, null, []);
-                    return;
-                }
-                var uuid = utils.shortNetworkIdToUuidPrefix(query);
-
-                // XXX - ldapEscape required to work around NAPI-367
-                var listParams = {
-                    uuid: utils.ldapEscape(uuid),
-                    fabric: true,
-                    owner_uuid: opts.account.uuid
-                };
+    vasync.parallel(
+        {
+            funcs: [
+                function byExactId(cb) {
+                    // length === 64, and 0..31 === 32..63, or it's an 'impossible'
+                    // id under our double-uuid convention, and we can skip it.
+                    if (query.substr(0, 32) !== query.substr(32)) {
+                        log.debug(
+                            {query: query},
+                            'Networks: impossible exactId: %s, skipping',
+                            query
+                        );
+                        setImmediate(cb, null, []);
+                        return;
+                    }
+                    var uuid = utils.shortNetworkIdToUuidPrefix(query);
 
-                napi.listNetworks(listParams,
-                    { headers: { 'x-request-id': opts.req_id }}, cb);
-            },
-            function byName(cb) {
-                var listParams = {
-                    name: query,
-                    fabric: true,
-                    owner_uuid: opts.account.uuid
-                };
+                    // XXX - ldapEscape required to work around NAPI-367
+                    var listParams = {
+                        uuid: utils.ldapEscape(uuid),
+                        fabric: true,
+                        owner_uuid: opts.account.uuid
+                    };
 
-                log.debug({ listParams: listParams },
-                    format('Networks: searching for network %s',
-                        listParams.name));
+                    napi.listNetworks(
+                        listParams,
+                        {headers: {'x-request-id': opts.req_id}},
+                        cb
+                    );
+                },
+                function byName(cb) {
+                    var listParams = {
+                        name: query,
+                        fabric: true,
+                        owner_uuid: opts.account.uuid
+                    };
 
-                napi.listNetworks(listParams,
-                    { headers: {'x-request-id': opts.req_id }}, cb);
-            },
-            function byDockerId(cb) {
-                // we assume the 'double uuid' convention for networks here,
-                // that is, dockerId = (uuid + uuid).replace(/-/g, '').
-                // So if we have a query.length > 31, 32... must be a prefix of
-                // 0..31. If not, the id supplied is impossible in our system.
-                if (query.length >= 32) {
-                    // this must be a prefix of the first half of the input
-                    var secondHalf = query.substr(32);
-                    var firstHalf = query.substr(0, 31);
-
-                    if (secondHalf.length >= firstHalf.length
-                        || secondHalf !==
-                        firstHalf.substr(0, secondHalf.length)) {
-
-                        log.info({ query: query },
-                            'Networks: impossible network id %s, skipping',
-                            query);
-                        setImmediate(cb, null, []);
-                        return;
+                    log.debug(
+                        {listParams: listParams},
+                        format(
+                            'Networks: searching for network %s',
+                            listParams.name
+                        )
+                    );
+
+                    napi.listNetworks(
+                        listParams,
+                        {headers: {'x-request-id': opts.req_id}},
+                        cb
+                    );
+                },
+                function byDockerId(cb) {
+                    // we assume the 'double uuid' convention for networks here,
+                    // that is, dockerId = (uuid + uuid).replace(/-/g, '').
+                    // So if we have a query.length > 31, 32... must be a prefix of
+                    // 0..31. If not, the id supplied is impossible in our system.
+                    if (query.length >= 32) {
+                        // this must be a prefix of the first half of the input
+                        var secondHalf = query.substr(32);
+                        var firstHalf = query.substr(0, 31);
+
+                        if (
+                            secondHalf.length >= firstHalf.length ||
+                            secondHalf !==
+                                firstHalf.substr(0, secondHalf.length)
+                        ) {
+                            log.info(
+                                {query: query},
+                                'Networks: impossible network id %s, skipping',
+                                query
+                            );
+                            setImmediate(cb, null, []);
+                            return;
+                        }
                     }
-                }
 
-                // To perform the search, we transform the provided query to
-                // a (potentially partial) UUID, and perform a wildcard search
-                // on it.
-                // XXX - ldapEscape required to work around NAPI-367
-                var uuidSearchStr = utils.ldapEscape(
-                    utils.shortNetworkIdToUuidPrefix(query)) + '*';
-
-                var listParams = {
-                    uuid: uuidSearchStr,
-                    fabric: true,
-                    owner_uuid: opts.account.uuid
-                };
+                    // To perform the search, we transform the provided query to
+                    // a (potentially partial) UUID, and perform a wildcard search
+                    // on it.
+                    // XXX - ldapEscape required to work around NAPI-367
+                    var uuidSearchStr =
+                        utils.ldapEscape(
+                            utils.shortNetworkIdToUuidPrefix(query)
+                        ) + '*';
+
+                    var listParams = {
+                        uuid: uuidSearchStr,
+                        fabric: true,
+                        owner_uuid: opts.account.uuid
+                    };
 
-                log.debug({ listParams: listParams },
-                    format('Networks: searching for network %s',
-                        listParams.uuid));
+                    log.debug(
+                        {listParams: listParams},
+                        format(
+                            'Networks: searching for network %s',
+                            listParams.uuid
+                        )
+                    );
+
+                    napi.listNetworks(
+                        listParams,
+                        {headers: {'x-request-id': opts.req_id}},
+                        cb
+                    );
+                }
+            ]
+        },
+        function _listedNetworks(err, results) {
+            // results.operations is ordered per the funcs array provided
+            // to vasync.parallel (see vasync docs). We can tolerate partial
+            // errors as long as they are lower in the preference chain.
+            // IOW, we callback with the err/result of the most-preferred
+            // search, and log any additional errors.
+            var bestMatch = results.operations.reduce(
+                function(acc, op) {
+                    if (acc.err || acc.result) {
+                        return acc;
+                    }
+                    if (op.err) {
+                        acc.err = op.err;
+                        return acc;
+                    }
+                    // all match funcs are listNetworks, contract is to return an
+                    // err (handled above) or array.
+                    switch (op.result.length) {
+                        case 0:
+                            break;
+                        case 1:
+                            acc.result = op.result[0];
+                            break;
+                        default:
+                            acc.err = new errors.AmbiguousDockerNetworkIdPrefixError(
+                                query
+                            );
+                            break;
+                    }
+                    return acc;
+                },
+                {err: null, result: null}
+            );
 
-                napi.listNetworks(listParams,
-                    { headers: {'x-request-id': opts.req_id }}, cb);
-            }
-        ]
-    }, function _listedNetworks(err, results) {
-        // results.operations is ordered per the funcs array provided
-        // to vasync.parallel (see vasync docs). We can tolerate partial
-        // errors as long as they are lower in the preference chain.
-        // IOW, we callback with the err/result of the most-preferred
-        // search, and log any additional errors.
-        var bestMatch = results.operations.reduce(function (acc, op) {
-            if (acc.err || acc.result) {
-                return acc;
-            }
-            if (op.err) {
-                acc.err = op.err;
-                return acc;
-            }
-            // all match funcs are listNetworks, contract is to return an
-            // err (handled above) or array.
-            switch (op.result.length) {
-            case 0:
-                break;
-            case 1:
-                acc.result = op.result[0];
-                break;
-            default:
-                acc.err = new errors.AmbiguousDockerNetworkIdPrefixError(query);
-                break;
+            if (bestMatch.err) {
+                // found an error before a result.
+                log.error(
+                    {err: bestMatch.err, query: query},
+                    format('Networks: Error finding network to match %s', query)
+                );
+                callback(bestMatch.err);
+                return;
             }
-            return acc;
-        }, { err: null, result: null });
-
-        if (bestMatch.err) {
-            // found an error before a result.
-            log.error({ err: bestMatch.err, query: query },
-                format('Networks: Error finding network to match %s', query));
-            callback(bestMatch.err);
-            return;
-        }
 
-        if (!bestMatch.err && !bestMatch.result) {
-            log.info({ query: query, user: opts.account.uuid },
-                format('Networks: no results for query %s', query));
-            callback(new errors.NetworkNotFoundError(query));
-            return;
-        }
+            if (!bestMatch.err && !bestMatch.result) {
+                log.info(
+                    {query: query, user: opts.account.uuid},
+                    format('Networks: no results for query %s', query)
+                );
+                callback(new errors.NetworkNotFoundError(query));
+                return;
+            }
 
-        if (!bestMatch.err && err) {
-            // found result before an error, but did have errs.
-            log.warn({ err: err },
-                'Networks: non-critical error searching NAPI');
-        }
+            if (!bestMatch.err && err) {
+                // found result before an error, but did have errs.
+                log.warn(
+                    {err: err},
+                    'Networks: non-critical error searching NAPI'
+                );
+            }
 
-        log.debug({ network: bestMatch.result }, 'Networks: chose %s/%s',
-            bestMatch.result.name, bestMatch.result.uuid);
+            log.debug(
+                {network: bestMatch.result},
+                'Networks: chose %s/%s',
+                bestMatch.result.name,
+                bestMatch.result.uuid
+            );
 
-        payload.networks = [ { uuid: bestMatch.result.uuid, primary: true } ];
-        log.debug({ payload: payload }, format('Networks: built payload'));
+            payload.networks = [{uuid: bestMatch.result.uuid, primary: true}];
+            log.debug({payload: payload}, format('Networks: built payload'));
 
-        callback();
-        return;
-    });
+            callback();
+            return;
+        }
+    );
 }
 
-
 /**
  * Add a rule or rules to payload.firewall_rules
  */
 function addRulesToPayload(payload, rules) {
-    var rulesArr = util.isArray(rules) ? rules : [ rules ];
+    var rulesArr = util.isArray(rules) ? rules : [rules];
 
     if (!payload.firewall_rules) {
         payload.firewall_rules = [];
@@ -849,10 +993,11 @@ function addRulesToPayload(payload, rules) {
     payload.firewall_rules = payload.firewall_rules.concat(
         // Clean up any rules with extra parsed data (from doing listRules
         // with extra fields)
-        rulesArr.map(function (r) {
+        rulesArr.map(function(r) {
             delete r.parsed;
             return r;
-        }));
+        })
+    );
 }
 
 /**
@@ -893,7 +1038,7 @@ function getLinkDetails(opts, configLinks, vm_payload, callback) {
         // Add environment variables from the linked container.
         if (im['docker:env']) {
             targetEnvArray = JSON.parse(im['docker:env']);
-            targetEnvArray.forEach(function (e) {
+            targetEnvArray.forEach(function(e) {
                 var targetEnvName = e.split('=', 1)[0];
                 // Ignore a few variables that are added during docker build
                 // (and not really relevant to linked containers).
@@ -920,7 +1065,7 @@ function getLinkDetails(opts, configLinks, vm_payload, callback) {
         }
 
         // Add network ports and /etc/hosts entry.
-        vmobj.nics.forEach(function (nic) {
+        vmobj.nics.forEach(function(nic) {
             // Look for network tag with a '/' in it - as that signifies an
             // internal network, which containers can best communicate over.
             if (bestMatch === null || nic.nic_tag.indexOf('/') >= 0) {
@@ -935,22 +1080,25 @@ function getLinkDetails(opts, configLinks, vm_payload, callback) {
              * ones have only one which lists unpublished ports, and we use
              * firewall rules for information about published ones.
              */
-            ['tcp', 'udp'].forEach(function (proto) {
+            ['tcp', 'udp'].forEach(function(proto) {
                 var imKey = 'docker:' + proto + '_all_ports';
                 if (im[imKey]) {
-                    JSON.parse(im[imKey]).forEach(function (port) {
+                    JSON.parse(im[imKey]).forEach(function(port) {
                         addLinkedNetworkPortsToEnv(bestMatch, proto, port);
                     });
                     hasAllPorts = true;
                 }
             });
             if (!hasAllPorts) {
-                utils.getPublishedPorts({ log: log, vm: vmobj }, fwrules,
-                    addLinkedNetworkPortsToEnv.bind(null, bestMatch));
-                ['tcp', 'udp'].forEach(function (proto) {
+                utils.getPublishedPorts(
+                    {log: log, vm: vmobj},
+                    fwrules,
+                    addLinkedNetworkPortsToEnv.bind(null, bestMatch)
+                );
+                ['tcp', 'udp'].forEach(function(proto) {
                     var imKey = 'docker:' + proto + '_unpublished_ports';
                     if (im[imKey]) {
-                        JSON.parse(im[imKey]).forEach(function (port) {
+                        JSON.parse(im[imKey]).forEach(function(port) {
                             addLinkedNetworkPortsToEnv(bestMatch, proto, port);
                         });
                     }
@@ -966,7 +1114,7 @@ function getLinkDetails(opts, configLinks, vm_payload, callback) {
         var bestMatch = null;
         var hosts = '';
 
-        vmobj.nics.forEach(function (nic) {
+        vmobj.nics.forEach(function(nic) {
             // Look for network tag with a '/' in it - as that signifies an
             // internal network, which containers can best communicate over.
             if (bestMatch === null || nic.nic_tag.indexOf('/') >= 0) {
@@ -976,10 +1124,15 @@ function getLinkDetails(opts, configLinks, vm_payload, callback) {
 
         if (bestMatch) {
             // There are three host entries per linked vm.
-            hosts += bestMatch.ip + '\t'
-                    + link.alias + ' '
-                    + vmobj.hostname + ' '
-                    + vmobj.alias + '\n';
+            hosts +=
+                bestMatch.ip +
+                '\t' +
+                link.alias +
+                ' ' +
+                vmobj.hostname +
+                ' ' +
+                vmobj.alias +
+                '\n';
         }
 
         return hosts;
@@ -994,64 +1147,81 @@ function getLinkDetails(opts, configLinks, vm_payload, callback) {
         var alias;
         var idx = linkconfig.indexOf(':');
         if (idx <= 0) {
-            return cb(new errors.DockerError(
-                    'Invalid link config entry found: ' + linkconfig
-                    + ', expected to find a colan character.'));
+            return cb(
+                new errors.DockerError(
+                    'Invalid link config entry found: ' +
+                        linkconfig +
+                        ', expected to find a colan character.'
+                )
+            );
         }
         target = linkconfig.slice(0, idx);
-        alias = linkconfig.slice(idx+1);
+        alias = linkconfig.slice(idx + 1);
 
         // Find machines matching these targets.
-        getVmById(target, {
-            log: log,
-            req_id: opts.req_id,
-            account: opts.account,
-            vmapi: opts.app.vmapi
-        }, function (find_err, vmobj) {
-
-            if (find_err) {
-                return cb(new errors.DockerError(
-                        'Could not get container for ' + target));
-            }
+        getVmById(
+            target,
+            {
+                log: log,
+                req_id: opts.req_id,
+                account: opts.account,
+                vmapi: opts.app.vmapi
+            },
+            function(find_err, vmobj) {
+                if (find_err) {
+                    return cb(
+                        new errors.DockerError(
+                            'Could not get container for ' + target
+                        )
+                    );
+                }
 
-            log.debug('found link target: %s, uuid: %s', target, vmobj.uuid);
+                log.debug(
+                    'found link target: %s, uuid: %s',
+                    target,
+                    vmobj.uuid
+                );
+
+                // Found container, store a link.
+                var link = {
+                    owner_uuid: opts.account.uuid,
+                    container_uuid: vm_payload.uuid,
+                    container_name: vm_payload.alias,
+                    target_uuid: vmobj.uuid,
+                    target_name: target,
+                    alias: alias
+                };
 
-            // Found container, store a link.
-            var link = {
-                owner_uuid: opts.account.uuid,
-                container_uuid: vm_payload.uuid,
-                container_name: vm_payload.alias,
-                target_uuid: vmobj.uuid,
-                target_name: target,
-                alias: alias
-            };
-
-            fwapi.getVMrules(vmobj.uuid, function (fwErr, fwrules) {
-                if (fwErr) {
-                    log.error(fwErr, 'firewall rules in getLinkDetails');
-                    cb(fwErr);
-                    return;
-                }
+                fwapi.getVMrules(vmobj.uuid, function(fwErr, fwrules) {
+                    if (fwErr) {
+                        log.error(fwErr, 'firewall rules in getLinkDetails');
+                        cb(fwErr);
+                        return;
+                    }
 
-                var envArray = getLinkEnvForVm(link, vmobj, fwrules);
-                var hosts = getLinkHostnamesForVm(link, vmobj);
-                var result = { link: link, envArray: envArray, hosts: hosts };
+                    var envArray = getLinkEnvForVm(link, vmobj, fwrules);
+                    var hosts = getLinkHostnamesForVm(link, vmobj);
+                    var result = {link: link, envArray: envArray, hosts: hosts};
 
-                cb(null, result);
-            });
-        });
+                    cb(null, result);
+                });
+            }
+        );
     }
 
-    vasync.forEachParallel({
-        'func': getLinkDetail,
-        'inputs': configLinks
-    }, function (err, results) {
-        if (err) {
-            callback(err);
-            return;
+    vasync.forEachParallel(
+        {
+            func: getLinkDetail,
+            inputs: configLinks
+        },
+        function(err, results) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            callback(null, results.successes);
         }
-        callback(null, results.successes);
-    });
+    );
 }
 
 /**
@@ -1062,7 +1232,7 @@ function applyLinksToMetadata(im, linkDetails) {
     var envArray = [];
 
     // Merge all link entries into one env and host setting.
-    linkDetails.forEach(function (details) {
+    linkDetails.forEach(function(details) {
         envArray = envArray.concat(details.envArray);
         hosts += details.hosts;
     });
@@ -1085,15 +1255,18 @@ function storeLinks(opts, linkDetails, callback) {
         Link.create(opts.app, opts.log, linkDetail.link, cb);
     }
 
-    vasync.forEachParallel({
-        'func': createLink,
-        'inputs': linkDetails
-    }, function (err) {
-        if (err) {
-            return callback(err);
+    vasync.forEachParallel(
+        {
+            func: createLink,
+            inputs: linkDetails
+        },
+        function(err) {
+            if (err) {
+                return callback(err);
+            }
+            callback();
         }
-        callback();
-    });
+    );
 }
 
 function deleteLinks(opts, cb) {
@@ -1108,7 +1281,7 @@ function deleteLinks(opts, cb) {
     var linksToDelete = [];
 
     function findLinkCallbackWrapper(callback) {
-        return function (err, links) {
+        return function(err, links) {
             if (err) {
                 log.warn('Error finding links for %s: %s', opts.vm.uuid, err);
             } else if (links && links.length > 0) {
@@ -1118,37 +1291,57 @@ function deleteLinks(opts, cb) {
         };
     }
 
-    vasync.pipeline({ funcs: [
-        function findTargettingLinks(_, next) {
-            // Find links whose target container is being deleted.
-            var params = {
-                owner_uuid: opts.account.uuid,
-                target_uuid: opts.vm.uuid
-            };
-            Link.find(opts.app, log, params, findLinkCallbackWrapper(next));
-        },
-        function findSourceLinks(_, next) {
-            // Find links for the container being deleted.
-            var params = {
-                owner_uuid: opts.account.uuid,
-                container_uuid: opts.vm.uuid
-            };
-            Link.find(opts.app, log, params, findLinkCallbackWrapper(next));
-        },
-        function delLinks(_, next) {
-            // Delete the links we found.
-            log.info({links: linksToDelete},
-                'deleteLinks: found ' + linksToDelete.length + ' links');
-            vasync.forEachParallel({
-                func: function delSingleLink(link, done) {
-                    Link.del(opts.app, log, link, done);
+    vasync.pipeline(
+        {
+            funcs: [
+                function findTargettingLinks(_, next) {
+                    // Find links whose target container is being deleted.
+                    var params = {
+                        owner_uuid: opts.account.uuid,
+                        target_uuid: opts.vm.uuid
+                    };
+                    Link.find(
+                        opts.app,
+                        log,
+                        params,
+                        findLinkCallbackWrapper(next)
+                    );
+                },
+                function findSourceLinks(_, next) {
+                    // Find links for the container being deleted.
+                    var params = {
+                        owner_uuid: opts.account.uuid,
+                        container_uuid: opts.vm.uuid
+                    };
+                    Link.find(
+                        opts.app,
+                        log,
+                        params,
+                        findLinkCallbackWrapper(next)
+                    );
                 },
-                inputs: linksToDelete
-            }, next);
+                function delLinks(_, next) {
+                    // Delete the links we found.
+                    log.info(
+                        {links: linksToDelete},
+                        'deleteLinks: found ' + linksToDelete.length + ' links'
+                    );
+                    vasync.forEachParallel(
+                        {
+                            func: function delSingleLink(link, done) {
+                                Link.del(opts.app, log, link, done);
+                            },
+                            inputs: linksToDelete
+                        },
+                        next
+                    );
+                }
+            ]
+        },
+        function onDeleteLinksDone(delLinksErr) {
+            cb(delLinksErr);
         }
-    ]}, function onDeleteLinksDone(delLinksErr) {
-        cb(delLinksErr);
-    });
+    );
 }
 
 function renameLinks(opts, newName, callback) {
@@ -1159,12 +1352,15 @@ function renameLinks(opts, newName, callback) {
 
     var log = opts.log;
 
-    vasync.waterfall([
-        _findContainerLinks,
-        _updateContainerLinks,
-        _findTargetLinks,
-        _updateTargetLinks
-    ], _done);
+    vasync.waterfall(
+        [
+            _findContainerLinks,
+            _updateContainerLinks,
+            _findTargetLinks,
+            _updateTargetLinks
+        ],
+        _done
+    );
 
     function _findContainerLinks(next) {
         // Find all links this container uses.
@@ -1176,8 +1372,11 @@ function renameLinks(opts, newName, callback) {
     }
 
     function _updateContainerName(link, next) {
-        log.debug('updating link container name from [%s] to [%s]',
-                    link.container_name, newName);
+        log.debug(
+            'updating link container name from [%s] to [%s]',
+            link.container_name,
+            newName
+        );
         link.container_name = newName;
         link.save(opts.app, next);
     }
@@ -1187,12 +1386,15 @@ function renameLinks(opts, newName, callback) {
             return next();
         }
         // Update all links this container uses.
-        vasync.forEachParallel({
-            func: _updateContainerName,
-            inputs: links
-        }, function (err, results) {
-            next(err);
-        });
+        vasync.forEachParallel(
+            {
+                func: _updateContainerName,
+                inputs: links
+            },
+            function(err, results) {
+                next(err);
+            }
+        );
     }
 
     function _findTargetLinks(next) {
@@ -1205,8 +1407,11 @@ function renameLinks(opts, newName, callback) {
     }
 
     function _updateTargetName(link, next) {
-        log.debug('updating link target name from [%s] to [%s]',
-                    link.target_name, newName);
+        log.debug(
+            'updating link target name from [%s] to [%s]',
+            link.target_name,
+            newName
+        );
         link.target_name = newName;
         link.save(opts.app, next);
     }
@@ -1216,12 +1421,15 @@ function renameLinks(opts, newName, callback) {
             return next();
         }
         // Update all links this container is referenced by.
-        vasync.forEachParallel({
-            func: _updateTargetName,
-            inputs: links
-        }, function (err, results) {
-            next(err);
-        });
+        vasync.forEachParallel(
+            {
+                func: _updateTargetName,
+                inputs: links
+            },
+            function(err, results) {
+                next(err);
+            }
+        );
     }
 
     function _done(err) {
@@ -1262,7 +1470,7 @@ function getMemoryTarget(opts, container) {
         log.warn({memory: memory}, 'using default memory value');
     }
 
-    return (memory);
+    return memory;
 }
 
 /*
@@ -1293,59 +1501,78 @@ function getClosestMemoryPackage(opts, pkgs, memory /* MiB */, callback) {
     var log = opts.log;
 
     pkgs.forEach(function _considerPkg(pkg) {
-        if (pkg.owner_uuids && (pkg.owner_uuids.length > 0)) {
+        if (pkg.owner_uuids && pkg.owner_uuids.length > 0) {
             if (!opts.account || !opts.account.uuid) {
-                log.warn({candidate: pkg}, 'skipping candidate because'
-                    + ' cannot identify owner');
+                log.warn(
+                    {candidate: pkg},
+                    'skipping candidate because' + ' cannot identify owner'
+                );
                 return;
             } else if (pkg.owner_uuids.indexOf(opts.account.uuid) === -1) {
-                log.debug({
-                    account_uuid: opts.account.uuid,
-                    candidate: pkg
-                }, 'skipping candidate because owner does not match');
+                log.debug(
+                    {
+                        account_uuid: opts.account.uuid,
+                        candidate: pkg
+                    },
+                    'skipping candidate because owner does not match'
+                );
                 return;
             }
         }
 
         if (!pkg.active) {
-            log.info({
-                account_uuid: opts.account.uuid,
-                candidate: pkg
-            }, 'skipping candidate because package is not active');
+            log.info(
+                {
+                    account_uuid: opts.account.uuid,
+                    candidate: pkg
+                },
+                'skipping candidate because package is not active'
+            );
             return;
         }
 
         if (pkg.max_physical_memory >= memory) {
             if (!candidate.hasOwnProperty('max_physical_memory')) {
                 candidate = pkg;
-                log.trace({
-                    account: opts.account.uuid,
-                    candidate: candidate,
-                    target_memory: memory
-                }, 'initial candidate');
-            } else if (pkg.max_physical_memory
-                < candidate.max_physical_memory) {
-
+                log.trace(
+                    {
+                        account: opts.account.uuid,
+                        candidate: candidate,
+                        target_memory: memory
+                    },
+                    'initial candidate'
+                );
+            } else if (
+                pkg.max_physical_memory < candidate.max_physical_memory
+            ) {
                 candidate = pkg;
-                log.trace({
-                    account: opts.account.uuid,
-                    candidate: candidate,
-                    target_memory: memory
-                }, 'new candidate');
+                log.trace(
+                    {
+                        account: opts.account.uuid,
+                        candidate: candidate,
+                        target_memory: memory
+                    },
+                    'new candidate'
+                );
             }
         } else {
-            log.trace({
-                account: opts.account.uuid,
-                candidate: pkg,
-                target_memory: memory
-            }, 'unacceptable candidate');
+            log.trace(
+                {
+                    account: opts.account.uuid,
+                    candidate: pkg,
+                    target_memory: memory
+                },
+                'unacceptable candidate'
+            );
         }
     });
 
     if (!candidate.uuid) {
-        callback(new errors.NoSufficientPackageError({
-            memory: common.humanSizeFromBytes(memory * (1024 * 1024))
-        }));
+        callback(
+            new errors.NoSufficientPackageError({
+                memory: common.humanSizeFromBytes(memory * (1024 * 1024))
+            })
+        );
         return;
     }
 
@@ -1395,9 +1622,10 @@ function getSpecifiedPackage(opts, pkgs, specifiedPackage, callback) {
         pkgs.forEach(function _onEachPkg(pkg) {
             if (pkg.name === specifiedPackage) {
                 nameMatches.push(pkg.uuid);
-            } else if (specifiedPackage.match(/^[0-9a-f]{8}$/)
-                && (pkg.uuid.substr(0, 8) === specifiedPackage)) {
-
+            } else if (
+                specifiedPackage.match(/^[0-9a-f]{8}$/) &&
+                pkg.uuid.substr(0, 8) === specifiedPackage
+            ) {
                 uuidMatches.push(pkg.uuid);
             } else if (pkg.uuid === specifiedPackage) {
                 uuidMatches.push(pkg.uuid);
@@ -1421,8 +1649,10 @@ function getSpecifiedPackage(opts, pkgs, specifiedPackage, callback) {
         return;
     }
 
-    log.error({specifiedPackage: specifiedPackage, pkgs: pkgs},
-        'unable to find specified package');
+    log.error(
+        {specifiedPackage: specifiedPackage, pkgs: pkgs},
+        'unable to find specified package'
+    );
     callback(new errors.NoSufficientPackageError(constraint));
 }
 
@@ -1461,35 +1691,57 @@ function buildPackageFilter(opts) {
     if (opts.specifiedPackage) {
         if (common.isUUID(opts.specifiedPackage)) {
             // if specifiedPackage is a UUID, we'll just look that up directly.
-            filter = '(&(active=true)'
-                + '(|(owner_uuids=' + opts.ownerUuid + ')(!(owner_uuids=*)))'
-                + '(uuid=' + opts.specifiedPackage +'))';
+            filter =
+                '(&(active=true)' +
+                '(|(owner_uuids=' +
+                opts.ownerUuid +
+                ')(!(owner_uuids=*)))' +
+                '(uuid=' +
+                opts.specifiedPackage +
+                '))';
         } else if (opts.specifiedPackage.match(/^[0-9a-f]{8}$/)) {
             // could be either a short ID or (if the operator is crazy) a
             // package named something like 'cafebabe'. So we need to do the
             // gross thing and get potentially multiple results here.
             // When there are multiple, the correct result will be selected
             // by getSpecfiedPackage().
-            filter = '(&(active=true)'
-                + '(|(owner_uuids=' + opts.ownerUuid + ')(!(owner_uuids=*)))'
-                + '(|(name=' + opts.specifiedPackage +')'
-                + '(uuid=' + opts.specifiedPackage + '-*)))';
+            filter =
+                '(&(active=true)' +
+                '(|(owner_uuids=' +
+                opts.ownerUuid +
+                ')(!(owner_uuids=*)))' +
+                '(|(name=' +
+                opts.specifiedPackage +
+                ')' +
+                '(uuid=' +
+                opts.specifiedPackage +
+                '-*)))';
         } else {
             // if it's not a uuid or potentially a short-ID we'll only lookup by
             // name.
-            filter = '(&(active=true)'
-                + '(|(owner_uuids=' + opts.ownerUuid + ')(!(owner_uuids=*)))'
-                + '(name=' + opts.specifiedPackage +'))';
+            filter =
+                '(&(active=true)' +
+                '(|(owner_uuids=' +
+                opts.ownerUuid +
+                ')(!(owner_uuids=*)))' +
+                '(name=' +
+                opts.specifiedPackage +
+                '))';
         }
     } else {
         // If no package is specified, we grab all packages with the config-
         // specified package prefix.
-        filter = '(&(active=true)'
-            + '(|(owner_uuids=' + opts.ownerUuid + ')(!(owner_uuids=*)))'
-            + '(name=' + opts.packagePrefix + '*))';
+        filter =
+            '(&(active=true)' +
+            '(|(owner_uuids=' +
+            opts.ownerUuid +
+            ')(!(owner_uuids=*)))' +
+            '(name=' +
+            opts.packagePrefix +
+            '*))';
     }
 
-    return (filter);
+    return filter;
 }
 
 /*
@@ -1522,20 +1774,31 @@ function getPackage(opts, container, callback) {
     var papi = getPapiClient(opts.config.papi);
     var specifiedPackage;
 
-    if (container.Labels
-        && container.Labels.hasOwnProperty(PACKAGE_SELECTION_LABEL)) {
-
+    if (
+        container.Labels &&
+        container.Labels.hasOwnProperty(PACKAGE_SELECTION_LABEL)
+    ) {
         // If the user has specified a PACKAGE_SELECTION_LABEL= label, we're
         // only going to try that. The -m and any defaults will be ignored.
         specifiedPackage = container.Labels[PACKAGE_SELECTION_LABEL];
-        log.debug({package: specifiedPackage}, PACKAGE_SELECTION_LABEL
-            + ' specified');
-
-        if (specifiedPackage.match(BAD_PKG_NAME_RE)
-            || !specifiedPackage.match(PKG_NAME_RE)) {
+        log.debug(
+            {package: specifiedPackage},
+            PACKAGE_SELECTION_LABEL + ' specified'
+        );
+
+        if (
+            specifiedPackage.match(BAD_PKG_NAME_RE) ||
+            !specifiedPackage.match(PKG_NAME_RE)
+        ) {
             // invalid package name, this is an error
-            callback(new errors.DockerError('invalid value for '
-                + PACKAGE_SELECTION_LABEL + ': ' + specifiedPackage));
+            callback(
+                new errors.DockerError(
+                    'invalid value for ' +
+                        PACKAGE_SELECTION_LABEL +
+                        ': ' +
+                        specifiedPackage
+                )
+            );
             return;
         }
     }
@@ -1550,52 +1813,66 @@ function getPackage(opts, container, callback) {
 
     // If the first argument to papi.list is a string, it assumes that it is a
     // filter option and encodes it and does filter=<encoded string>
-    papi.list(filter, {
-        headers: {'x-request-id': opts.req_id}
-    }, function _choosePackage(err, pkgs, count) {
-        var memory;
-
-        // log results but remap pkgs to just uuid+name to avoid spamming logs
-        log.debug({
-            count: count,
-            err: err,
-            pkgs: pkgs.map(function _mapPkgs(pkg) {
-                return ({name: pkg.name, uuid: pkg.uuid});
-            })
-        }, 'PAPI.list results');
+    papi.list(
+        filter,
+        {
+            headers: {'x-request-id': opts.req_id}
+        },
+        function _choosePackage(err, pkgs, count) {
+            var memory;
+
+            // log results but remap pkgs to just uuid+name to avoid spamming logs
+            log.debug(
+                {
+                    count: count,
+                    err: err,
+                    pkgs: pkgs.map(function _mapPkgs(pkg) {
+                        return {name: pkg.name, uuid: pkg.uuid};
+                    })
+                },
+                'PAPI.list results'
+            );
 
-        if (err) {
-            callback(new errors.papiErrorWrap(err, 'problem listing packages'));
-            return;
-        }
+            if (err) {
+                callback(
+                    new errors.papiErrorWrap(err, 'problem listing packages')
+                );
+                return;
+            }
 
-        if (count === 0) {
-            callback(new errors.DockerError('no packages match parameters'));
-            return;
-        }
+            if (count === 0) {
+                callback(
+                    new errors.DockerError('no packages match parameters')
+                );
+                return;
+            }
 
-        // We got the list of existing packages, and we know whether the user
-        // specified a specific package, or whether we're going to choose one
-        // for them based on the memory value they passed in (or the default
-        // memory value). So now we dispatch to the appropriate caller which
-        // will call the callback with:
-        //
-        //  callback(err, package_uuid)
-        //
-
-        if (specifiedPackage) {
-            getSpecifiedPackage(opts, pkgs, specifiedPackage, callback);
-        } else {
-            memory = getMemoryTarget(opts, container);
+            // We got the list of existing packages, and we know whether the user
+            // specified a specific package, or whether we're going to choose one
+            // for them based on the memory value they passed in (or the default
+            // memory value). So now we dispatch to the appropriate caller which
+            // will call the callback with:
+            //
+            //  callback(err, package_uuid)
+            //
+
+            if (specifiedPackage) {
+                getSpecifiedPackage(opts, pkgs, specifiedPackage, callback);
+            } else {
+                memory = getMemoryTarget(opts, container);
 
-            log.info({
-                account: opts.account.uuid,
-                memory: memory
-            }, 'looking for minimal package that meets parameters');
+                log.info(
+                    {
+                        account: opts.account.uuid,
+                        memory: memory
+                    },
+                    'looking for minimal package that meets parameters'
+                );
 
-            getClosestMemoryPackage(opts, pkgs, memory /* MiB */, callback);
+                getClosestMemoryPackage(opts, pkgs, memory /* MiB */, callback);
+            }
         }
-    });
+    );
 }
 
 function listDockerVms(opts, callback) {
@@ -1613,42 +1890,49 @@ function listDockerVms(opts, callback) {
     if (opts.one || opts.all) {
         params.predicate = JSON.stringify({
             and: [
-                { eq: [ 'docker', true ] },
-                { and:
-                    [
-                        { ne: [ 'state', 'failed' ] },
-                        { ne: [ 'state', 'destroyed' ] }
+                {eq: ['docker', true]},
+                {
+                    and: [
+                        {ne: ['state', 'failed']},
+                        {ne: ['state', 'destroyed']}
                     ]
                 },
-                { eq: [ 'owner_uuid', opts.account.uuid ] }
+                {eq: ['owner_uuid', opts.account.uuid]}
             ]
         });
     } else {
         params.predicate = JSON.stringify({
             and: [
-                { eq: [ 'docker', true ] },
-                { eq: [ 'state', 'running' ] },
-                { eq: [ 'owner_uuid', opts.account.uuid ] }
+                {eq: ['docker', true]},
+                {eq: ['state', 'running']},
+                {eq: ['owner_uuid', opts.account.uuid]}
             ]
         });
     }
 
-    opts.vmapi.listVms(params, {
-        headers: {'x-request-id': opts.req_id}
-    }, function _listVmsCb(err, vms, _req, _res) {
-        if (err) {
-            opts.log.error(err, 'Error retrieving Virtual Machines');
-            return callback(errors.vmapiErrorWrap(
-                err, 'problem retrieving virtual machines'));
-        }
+    opts.vmapi.listVms(
+        params,
+        {
+            headers: {'x-request-id': opts.req_id}
+        },
+        function _listVmsCb(err, vms, _req, _res) {
+            if (err) {
+                opts.log.error(err, 'Error retrieving Virtual Machines');
+                return callback(
+                    errors.vmapiErrorWrap(
+                        err,
+                        'problem retrieving virtual machines'
+                    )
+                );
+            }
 
-        opts.log.debug('Found ' + vms.length + ' VMs');
-        callback(null, vms);
-    });
+            opts.log.debug('Found ' + vms.length + ' VMs');
+            callback(null, vms);
+        }
+    );
 }
 
-function ltrim(str, chars)
-{
+function ltrim(str, chars) {
     chars = chars || '\\s';
     str = str || '';
     return str.replace(new RegExp('^[' + chars + ']+', 'g'), '');
@@ -1704,7 +1988,7 @@ function buildVmPayload(opts, container, callback) {
     var restartPolicy;
     var volumesFrom;
 
-    Object.keys(simple_map).forEach(function (k) {
+    Object.keys(simple_map).forEach(function(k) {
         if (container.hasOwnProperty(k) && container[k].length > 0) {
             payload[simple_map[k]] = container[k];
         }
@@ -1726,7 +2010,7 @@ function buildVmPayload(opts, container, callback) {
     };
 
     payload.tags = {
-        'sdc_docker': true
+        sdc_docker: true
     };
 
     if (container.Cmd) {
@@ -1734,8 +2018,9 @@ function buildVmPayload(opts, container, callback) {
     }
 
     if (container.Entrypoint) {
-        payload.internal_metadata['docker:entrypoint']
-            = JSON.stringify(container.Entrypoint);
+        payload.internal_metadata['docker:entrypoint'] = JSON.stringify(
+            container.Entrypoint
+        );
     }
 
     if (container.Tty) {
@@ -1760,8 +2045,9 @@ function buildVmPayload(opts, container, callback) {
 
     if (container.Env) {
         if (container.Env.length > 0) {
-            payload.internal_metadata['docker:env'] =
-                JSON.stringify(container.Env);
+            payload.internal_metadata['docker:env'] = JSON.stringify(
+                container.Env
+            );
         }
     }
 
@@ -1773,8 +2059,9 @@ function buildVmPayload(opts, container, callback) {
         payload.internal_metadata['docker:workdir'] = container.WorkingDir;
     }
 
-    restartPolicy = container.RestartPolicy
-        || container.HostConfig && container.HostConfig.RestartPolicy;
+    restartPolicy =
+        container.RestartPolicy ||
+        (container.HostConfig && container.HostConfig.RestartPolicy);
     if (restartPolicy && restartPolicy.Name) {
         if (restartPolicy.Name === 'always') {
             payload.internal_metadata['docker:restartpolicy'] = 'always';
@@ -1783,8 +2070,8 @@ function buildVmPayload(opts, container, callback) {
                 payload.internal_metadata['docker:restartpolicy'] =
                     'on-failure:' + restartPolicy.MaximumRetryCount.toString();
             } else {
-                payload.internal_metadata['docker:restartpolicy']
-                    = 'on-failure';
+                payload.internal_metadata['docker:restartpolicy'] =
+                    'on-failure';
             }
         }
     }
@@ -1792,70 +2079,73 @@ function buildVmPayload(opts, container, callback) {
     // This was already validated in lib/validate.js
     if (container.HostConfig && container.HostConfig.LogConfig) {
         if (container.HostConfig.LogConfig.Type.length > 0) {
-            payload.internal_metadata['docker:logdriver']
-                = container.HostConfig.LogConfig.Type;
+            payload.internal_metadata['docker:logdriver'] =
+                container.HostConfig.LogConfig.Type;
         } else {
             payload.internal_metadata['docker:logdriver'] = 'json-file';
         }
 
-        logDriver
-            = common.LOG_DRIVERS[payload.internal_metadata['docker:logdriver']];
+        logDriver =
+            common.LOG_DRIVERS[payload.internal_metadata['docker:logdriver']];
 
         if (container.HostConfig.LogConfig.Config) {
             logConfig = container.HostConfig.LogConfig.Config;
         }
 
         if (logDriver.default_opts) {
-            Object.keys(logDriver.default_opts).forEach(
-                function _applyDefaultOpt(opt) {
-                    if (!logConfig.hasOwnProperty(opt)) {
-                        if (logDriver.default_opts[opt] === '{{.ID}}') {
-                            logConfig[opt] = dockerid.substr(0, 12);
-                        } else {
-                            logConfig[opt] = logDriver.default_opts[opt];
-                        }
+            Object.keys(
+                logDriver.default_opts
+            ).forEach(function _applyDefaultOpt(opt) {
+                if (!logConfig.hasOwnProperty(opt)) {
+                    if (logDriver.default_opts[opt] === '{{.ID}}') {
+                        logConfig[opt] = dockerid.substr(0, 12);
+                    } else {
+                        logConfig[opt] = logDriver.default_opts[opt];
                     }
                 }
-            );
+            });
         }
 
         // Special-case default for syslog driver, default to port 514
         if (payload.internal_metadata['docker:logdriver'] === 'syslog') {
             if (logConfig['syslog-address'].split(':').length === 2) {
-                logConfig['syslog-address']
-                    = logConfig['syslog-address'] + ':514';
+                logConfig['syslog-address'] =
+                    logConfig['syslog-address'] + ':514';
             }
         }
 
         // Special-case for fluentd-tag markup tags
         if (payload.internal_metadata['docker:logdriver'] === 'fluentd') {
             if (logConfig['fluentd-tag']) {
-                logConfig['fluentd-tag'].replace(/{{.ID}}/g,
-                    dockerid.substr(0, 12));
+                logConfig['fluentd-tag'].replace(
+                    /{{.ID}}/g,
+                    dockerid.substr(0, 12)
+                );
                 logConfig['fluentd-tag'].replace(/{{.FullID}}/g, dockerid);
                 logConfig['fluentd-tag'].replace(/{{.Name}}/g, payload.alias);
             }
         }
 
-        if (payload.internal_metadata['docker:logdriver'] === 'json-file'
-            && logConfig.hasOwnProperty('max-size')) {
-
+        if (
+            payload.internal_metadata['docker:logdriver'] === 'json-file' &&
+            logConfig.hasOwnProperty('max-size')
+        ) {
             // the value was already validated, so we know it looks like:
             //
             // /^[0-9]+([kmg])$/ with [kmg] being optional
             //
             switch (logConfig['max-size'].slice(-1)) {
                 case 'k':
-                    logMaxSize = Number(logConfig['max-size'].slice(0, -1))
-                        * 1000;
+                    logMaxSize =
+                        Number(logConfig['max-size'].slice(0, -1)) * 1000;
                     break;
                 case 'm':
-                    logMaxSize = Number(logConfig['max-size'].slice(0, -1))
-                        * 1000000;
+                    logMaxSize =
+                        Number(logConfig['max-size'].slice(0, -1)) * 1000000;
                     break;
                 case 'g':
-                    logMaxSize = Number(logConfig['max-size'].slice(0, -1))
-                        * 1000000000;
+                    logMaxSize =
+                        Number(logConfig['max-size'].slice(0, -1)) * 1000000000;
                     break;
                 default:
                     logMaxSize = Number(logConfig['max-size']);
@@ -1863,29 +2153,36 @@ function buildVmPayload(opts, container, callback) {
             }
         }
 
-        payload.internal_metadata['docker:logconfig']
-            = JSON.stringify(logConfig);
+        payload.internal_metadata['docker:logconfig'] = JSON.stringify(
+            logConfig
+        );
     }
 
     payload.zlog_max_size = logMaxSize;
 
-    if (container.HostConfig && container.HostConfig.Dns
-        && Array.isArray(container.HostConfig.Dns)
-        && (container.HostConfig.Dns.length > 0)) {
-
+    if (
+        container.HostConfig &&
+        container.HostConfig.Dns &&
+        Array.isArray(container.HostConfig.Dns) &&
+        container.HostConfig.Dns.length > 0
+    ) {
         payload.resolvers = container.HostConfig.Dns;
     }
-    if (container.HostConfig && container.HostConfig.DnsSearch
-        && Array.isArray(container.HostConfig.DnsSearch)
-        && (container.HostConfig.DnsSearch.length > 0)) {
-
-        payload.internal_metadata['docker:dnssearch']
-            = JSON.stringify(container.HostConfig.DnsSearch);
+    if (
+        container.HostConfig &&
+        container.HostConfig.DnsSearch &&
+        Array.isArray(container.HostConfig.DnsSearch) &&
+        container.HostConfig.DnsSearch.length > 0
+    ) {
+        payload.internal_metadata['docker:dnssearch'] = JSON.stringify(
+            container.HostConfig.DnsSearch
+        );
     }
 
     if (container.HostConfig.ExtraHosts) {
-        payload.internal_metadata['docker:extraHosts']
-            = JSON.stringify(container.HostConfig.ExtraHosts);
+        payload.internal_metadata['docker:extraHosts'] = JSON.stringify(
+            container.HostConfig.ExtraHosts
+        );
     }
 
     payload.autoboot = false; // because docker does create & start separately
@@ -1911,13 +2208,11 @@ function buildVmPayload(opts, container, callback) {
      * the zone's dataset but not in the zoneroot, and we'll mount that into the
      * container at /container/file.
      */
-    binds = container.Binds
-        || container.HostConfig && container.HostConfig.Binds;
+    binds =
+        container.Binds || (container.HostConfig && container.HostConfig.Binds);
     if (binds && binds.length > 0) {
-        log.error({host_volumes: binds},
-            'host volumes are not supported');
-        callback(new errors.DockerError(
-            'host volumes are not supported'));
+        log.error({host_volumes: binds}, 'host volumes are not supported');
+        callback(new errors.DockerError('host volumes are not supported'));
         return;
     }
 
@@ -1960,388 +2255,482 @@ function buildVmPayload(opts, container, callback) {
      * }
      */
 
-    vasync.pipeline({funcs: [
-        function handleNetworks(_, cb) {
-            addNetworksToPayload(opts, container, payload, cb);
-        },
+    vasync.pipeline(
+        {
+            funcs: [
+                function handleNetworks(_, cb) {
+                    addNetworksToPayload(opts, container, payload, cb);
+                },
 
-        function addExternalNet(_, cb) {
-            assert.object(opts.config, 'config');
-            assert.object(opts.config.overlay, 'config.overlay');
-            assert.bool(opts.config.overlay.enabled,
-                'config.overlay.enabled');
-            if (opts.config.overlay.enabled
-                && (publishingPorts(container) || opts.fabricRequireExternal)) {
-                assert.string(opts.config.overlay.externalPool,
-                    'opts.config.overlay.externalPool');
-                // external must be primary.
-                payload.networks.forEach(function (nw) {
-                    delete nw.primary;
-                });
+                function addExternalNet(_, cb) {
+                    assert.object(opts.config, 'config');
+                    assert.object(opts.config.overlay, 'config.overlay');
+                    assert.bool(
+                        opts.config.overlay.enabled,
+                        'config.overlay.enabled'
+                    );
+                    if (
+                        opts.config.overlay.enabled &&
+                        (publishingPorts(container) ||
+                            opts.fabricRequireExternal)
+                    ) {
+                        assert.string(
+                            opts.config.overlay.externalPool,
+                            'opts.config.overlay.externalPool'
+                        );
+                        // external must be primary.
+                        payload.networks.forEach(function(nw) {
+                            delete nw.primary;
+                        });
 
-                payload.networks.push(
-                    { uuid: opts.config.overlay.externalPool, primary: true });
-            }
+                        payload.networks.push({
+                            uuid: opts.config.overlay.externalPool,
+                            primary: true
+                        });
+                    }
 
-            cb();
-            return;
-        },
+                    cb();
+                    return;
+                },
 
-        function handleVolumesFrom(_, cb) {
-            // This must happen after we've added the owner_uuid to the payload.
-            // ...and is where we add --volumes-from volumes.
+                function handleVolumesFrom(_, cb) {
+                    // This must happen after we've added the owner_uuid to the payload.
+                    // ...and is where we add --volumes-from volumes.
 
-            var get_opts = {
-                account: opts.account,
-                log: log,
-                req_id: opts.req_id,
-                vmapi: opts.vmapi
-            };
-            var vf_containers = [];
-
-            function _addContainerVolumes(source, next) {
-                /* JSSTYLED */
-                var data_volume_regex = /\/volumes\/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$/;
-                var id;
-                var msg;
-                var readonly = false;
-
-                // source can be an id or id:<rw:ro>
-                if (source.match(/:ro$/)) {
-                    readonly = true;
-                }
-                id = source.replace(/:r[ow]$/, '');
+                    var get_opts = {
+                        account: opts.account,
+                        log: log,
+                        req_id: opts.req_id,
+                        vmapi: opts.vmapi
+                    };
+                    var vf_containers = [];
+
+                    function _addContainerVolumes(source, next) {
+                        /* JSSTYLED */
+                        var data_volume_regex = /\/volumes\/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})$/;
+                        var id;
+                        var msg;
+                        var readonly = false;
+
+                        // source can be an id or id:<rw:ro>
+                        if (source.match(/:ro$/)) {
+                            readonly = true;
+                        }
+                        id = source.replace(/:r[ow]$/, '');
 
-                // get container
-                getVmById(id, get_opts, function (err, vmobj) {
-                    if (err) {
-                        next(err);
-                        return;
-                    }
-
-                    // First check the owner. Other checks might be cheaper to
-                    // do first, but we don't want to leak information about
-                    // other customers' VMs, so we fail on this first.
-                    if (vmobj.owner_uuid !== payload.owner_uuid) {
-                        msg = 'Owners do not match, cannot --volumes-from';
-                        log.error({
-                            source_owner: vmobj.owner_uuid,
-                            target_owner: payload.owner_uuid
-                        }, msg);
-                        next(new errors.DockerError(msg));
-                        return;
-                    }
+                        // get container
+                        getVmById(id, get_opts, function(err, vmobj) {
+                            if (err) {
+                                next(err);
+                                return;
+                            }
 
-                    if (!vmobj.docker) {
-                        msg = 'Container is not a "docker" container, cannot '
-                            + '--volumes-from';
-                        next(new errors.DockerError(msg));
-                        return;
-                    }
+                            // First check the owner. Other checks might be cheaper to
+                            // do first, but we don't want to leak information about
+                            // other customers' VMs, so we fail on this first.
+                            if (vmobj.owner_uuid !== payload.owner_uuid) {
+                                msg =
+                                    'Owners do not match, cannot --volumes-from';
+                                log.error(
+                                    {
+                                        source_owner: vmobj.owner_uuid,
+                                        target_owner: payload.owner_uuid
+                                    },
+                                    msg
+                                );
+                                next(new errors.DockerError(msg));
+                                return;
+                            }
 
-                    if (vmobj.filesystems) {
-                        vmobj.filesystems.forEach(function (f) {
-                            // if the filesystem entry doesn't look like a
-                            // volume, or if it's a volume that isn't under
-                            // this VM's zonepath, we'll skip it.
-                            if (f.source.match(data_volume_regex)
-                                && (f.source.indexOf(vmobj.zonepath) === 0)) {
+                            if (!vmobj.docker) {
+                                msg =
+                                    'Container is not a "docker" container, cannot ' +
+                                    '--volumes-from';
+                                next(new errors.DockerError(msg));
+                                return;
+                            }
 
-                                if (readonly) {
-                                    f.options = ['ro'];
-                                }
+                            if (vmobj.filesystems) {
+                                vmobj.filesystems.forEach(function(f) {
+                                    // if the filesystem entry doesn't look like a
+                                    // volume, or if it's a volume that isn't under
+                                    // this VM's zonepath, we'll skip it.
+                                    if (
+                                        f.source.match(data_volume_regex) &&
+                                        f.source.indexOf(vmobj.zonepath) === 0
+                                    ) {
+                                        if (readonly) {
+                                            f.options = ['ro'];
+                                        }
 
-                                payload.filesystems.push(f);
+                                        payload.filesystems.push(f);
+                                    }
+                                });
                             }
-                        });
-                    }
 
-                    vf_containers.push(vmobj.uuid);
+                            vf_containers.push(vmobj.uuid);
 
-                    next();
-                });
-            }
+                            next();
+                        });
+                    }
 
-            volumesFrom = container.VolumesFrom
-                || container.HostConfig && container.HostConfig.VolumesFrom;
-            if (volumesFrom) {
-                if (volumesFrom.length > MAX_VOLUMES_FROM) {
-                    log.error({volumes_from: volumesFrom}, 'too many '
-                        + '--volumes-from options: max ' + MAX_VOLUMES_FROM);
-                    cb(new errors.DockerError('too many --volumes-from: max '
-                        + MAX_VOLUMES_FROM));
-                    return;
-                }
+                    volumesFrom =
+                        container.VolumesFrom ||
+                        (container.HostConfig &&
+                            container.HostConfig.VolumesFrom);
+                    if (volumesFrom) {
+                        if (volumesFrom.length > MAX_VOLUMES_FROM) {
+                            log.error(
+                                {volumes_from: volumesFrom},
+                                'too many ' +
+                                    '--volumes-from options: max ' +
+                                    MAX_VOLUMES_FROM
+                            );
+                            cb(
+                                new errors.DockerError(
+                                    'too many --volumes-from: max ' +
+                                        MAX_VOLUMES_FROM
+                                )
+                            );
+                            return;
+                        }
 
-                // vf is an array of container "names"
+                        // vf is an array of container "names"
+
+                        vasync.forEachParallel(
+                            {
+                                func: _addContainerVolumes,
+                                inputs: volumesFrom
+                            },
+                            function(err) {
+                                if (err) {
+                                    // `forEachParallel` returns a `verror.MultiError`
+                                    // which only shows the message from the first error.
+                                    var msg = err.ase_errors
+                                        .map(function(e) {
+                                            return e.message;
+                                        })
+                                        .join(', ');
+                                    cb(new errors.DockerError(err, msg));
+                                    return;
+                                }
 
-                vasync.forEachParallel({
-                    'func': _addContainerVolumes,
-                    'inputs': volumesFrom
-                }, function (err) {
-                    if (err) {
-                        // `forEachParallel` returns a `verror.MultiError`
-                        // which only shows the message from the first error.
-                        var msg = err.ase_errors.map(
-                            function (e) { return e.message; }).join(', ');
-                        cb(new errors.DockerError(err, msg));
+                                payload.internal_metadata[
+                                    'docker:volumesfrom'
+                                ] = JSON.stringify(vf_containers);
+                                cb();
+                            }
+                        );
                         return;
                     }
-
-                    payload.internal_metadata['docker:volumesfrom']
-                        = JSON.stringify(vf_containers);
                     cb();
-                });
-                return;
-            }
-            cb();
-        },
+                },
 
-        function handleVolumes(_, cb) {
-            var existing = {};
+                function handleVolumes(_, cb) {
+                    var existing = {};
 
-            /*
+                    /*
              * Regular -v /data volumes, we'll create a new ZFS dataset for
              * these. Happens after HostVolumes and VolumesFrom so that we can
              * give those priority.
              */
-            if (!container.Volumes) {
-                cb();
-                return;
-            }
-
-            if (payload.filesystems) {
-                payload.filesystems.forEach(function (f) {
-                    existing[f.target] = true;
-                });
-            }
+                    if (!container.Volumes) {
+                        cb();
+                        return;
+                    }
 
-            if (Object.keys(container.Volumes).length > MAX_DATA_VOLUMES) {
-                log.error({data_volumes: container.Volumes},
-                    'too many data volumes: max ' + MAX_DATA_VOLUMES);
-                cb(new errors.DockerError('too many data volumes: max '
-                    + MAX_DATA_VOLUMES));
-                return;
-            }
+                    if (payload.filesystems) {
+                        payload.filesystems.forEach(function(f) {
+                            existing[f.target] = true;
+                        });
+                    }
 
-            Object.keys(container.Volumes).forEach(function (v) {
-                // v will be something like: `/dir` and container.Volumes[v]
-                // will be an object with options.
+                    if (
+                        Object.keys(container.Volumes).length > MAX_DATA_VOLUMES
+                    ) {
+                        log.error(
+                            {data_volumes: container.Volumes},
+                            'too many data volumes: max ' + MAX_DATA_VOLUMES
+                        );
+                        cb(
+                            new errors.DockerError(
+                                'too many data volumes: max ' + MAX_DATA_VOLUMES
+                            )
+                        );
+                        return;
+                    }
 
-                if (existing[v]) {
-                    log.warn(v + ' already added by VolumesFrom or HostVolume '
-                        + 'not adding new volume');
-                    return;
-                }
-                _addDataVolume(v);
-            });
+                    Object.keys(container.Volumes).forEach(function(v) {
+                        // v will be something like: `/dir` and container.Volumes[v]
+                        // will be an object with options.
+
+                        if (existing[v]) {
+                            log.warn(
+                                v +
+                                    ' already added by VolumesFrom or HostVolume ' +
+                                    'not adding new volume'
+                            );
+                            return;
+                        }
+                        _addDataVolume(v);
+                    });
 
-            cb();
-        },
+                    cb();
+                },
 
-        /*
+                /*
          * Determine locality hints from Docker Swarm's syntaxes for
          * container "affinities".
          */
-        function addLocalityHintsFromAffinities(_, cb) {
-            affinity.localityFromContainer({
-                log: opts.log,
-                vmapi: opts.vmapi,
-                ownerUuid: opts.account.uuid,
-                container: container
-            }, function (err, locality) {
-                if (err) {
-                    cb(err);
-                    return;
-                }
-                if (locality) {
-                    payload.locality = locality;
-                }
-                cb();
-            });
-        },
+                function addLocalityHintsFromAffinities(_, cb) {
+                    affinity.localityFromContainer(
+                        {
+                            log: opts.log,
+                            vmapi: opts.vmapi,
+                            ownerUuid: opts.account.uuid,
+                            container: container
+                        },
+                        function(err, locality) {
+                            if (err) {
+                                cb(err);
+                                return;
+                            }
+                            if (locality) {
+                                payload.locality = locality;
+                            }
+                            cb();
+                        }
+                    );
+                },
 
-        /**
+                /**
          * Add VM payload tags for image and container labels.
          *
          * - package-selection label is special (handled separately below)
          * - "triton." tags are parsed/validated and added without a prefix
          * - all others are added with "docker:label:" prefix
          */
-        function vmTagsFromLabels(_, cb) {
-            assert.object(payload.tags, 'payload.tags');
+                function vmTagsFromLabels(_, cb) {
+                    assert.object(payload.tags, 'payload.tags');
 
-            var labels = [];
-            if (imgConfig.Labels) {
-                Object.keys(imgConfig.Labels).forEach(function (k) {
-                    labels.push([k, imgConfig.Labels[k]]);
-                });
-            }
-            if (container.Labels) {
-                Object.keys(container.Labels).forEach(function (k) {
-                    labels.push([k, container.Labels[k]]);
-                });
-            }
+                    var labels = [];
+                    if (imgConfig.Labels) {
+                        Object.keys(imgConfig.Labels).forEach(function(k) {
+                            labels.push([k, imgConfig.Labels[k]]);
+                        });
+                    }
+                    if (container.Labels) {
+                        Object.keys(container.Labels).forEach(function(k) {
+                            labels.push([k, container.Labels[k]]);
+                        });
+                    }
 
-            var labelErrs = [];
-            vasync.forEachPipeline({
-                inputs: labels,
-                func: function handleLabel(label, next) {
-                    var key = label[0];
-                    var val = label[1];
-
-                    if (typeof (val) !== 'string') {
-                        labelErrs.push(new errors.ValidationError(format(
-                            'label "%s" value is not a string: %j',
-                            key, val)));
-                        next();
-                    } else if (key === PACKAGE_SELECTION_LABEL) {
-                        /*
+                    var labelErrs = [];
+                    vasync.forEachPipeline(
+                        {
+                            inputs: labels,
+                            func: function handleLabel(label, next) {
+                                var key = label[0];
+                                var val = label[1];
+
+                                if (typeof val !== 'string') {
+                                    labelErrs.push(
+                                        new errors.ValidationError(
+                                            format(
+                                                'label "%s" value is not a string: %j',
+                                                key,
+                                                val
+                                            )
+                                        )
+                                    );
+                                    next();
+                                } else if (key === PACKAGE_SELECTION_LABEL) {
+                                    /*
                          * PACKAGE_SELECTION_LABEL is a special label. It gets
                          * consumed here and doesn't end up in the user's list.
                          * It is handled below in `selectPackage()`.
                          */
-                        next();
-                    } else if (triton_tags.isTritonTag(key)) {
-                        triton_tags.parseTritonTagStr(key, val,
-                                function (err, parsed) {
+                                    next();
+                                } else if (triton_tags.isTritonTag(key)) {
+                                    triton_tags.parseTritonTagStr(
+                                        key,
+                                        val,
+                                        function(err, parsed) {
+                                            if (err) {
+                                                labelErrs.push(err);
+                                            } else {
+                                                payload.tags[key] = parsed;
+                                            }
+                                            next();
+                                        }
+                                    );
+                                } else {
+                                    payload.tags[
+                                        common.LABELTAG_PREFIX + key
+                                    ] = val;
+                                    next();
+                                }
+                            }
+                        },
+                        function(err) {
                             if (err) {
-                                labelErrs.push(err);
+                                cb(err);
+                            } else if (labelErrs.length > 0) {
+                                cb(
+                                    new errors.ValidationError(
+                                        util.format(
+                                            'invalid label%s: %s',
+                                            labelErrs.length === 1 ? '' : 's',
+                                            labelErrs
+                                                .map(function(e) {
+                                                    return e.message;
+                                                })
+                                                .join('; ')
+                                        )
+                                    )
+                                );
                             } else {
-                                payload.tags[key] = parsed;
+                                log.trace(
+                                    {labels: labels, tags: payload.tags},
+                                    'buildVmPayload: vmTagsFromLabel'
+                                );
+                                cb();
                             }
-                            next();
-                        });
-                    } else {
-                        payload.tags[common.LABELTAG_PREFIX + key] = val;
-                        next();
-                    }
-                }
-            }, function (err) {
-                if (err) {
-                    cb(err);
-                } else if (labelErrs.length > 0) {
-                    cb(new errors.ValidationError(util.format(
-                        'invalid label%s: %s',
-                        (labelErrs.length === 1 ? '' : 's'),
-                        labelErrs.map(function (e) { return e.message; })
-                            .join('; '))));
-                } else {
-                    log.trace({labels: labels, tags: payload.tags},
-                        'buildVmPayload: vmTagsFromLabel');
-                    cb();
-                }
-            });
-        },
-
-        function selectPackage(_, cb) {
-            getPackage(opts, container, function (err, package_uuid) {
-                if (!err) {
-                    payload.billing_id = package_uuid;
-                }
-                cb(err);
-            });
-        },
-
-
-        function addImageData(_, cb) {
-            payload.image_uuid = opts.image.image_uuid;
-
-            if (opts.image.os === 'smartos') {
-                payload.brand = 'joyent-minimal';
-                payload.init_name = '/usr/vm/sbin/dockerinit';
-            } else {
-                payload.brand = 'lx';
-                payload.init_name = '/native/usr/vm/sbin/dockerinit';
-                payload.internal_metadata['docker:noipmgmtd'] = true;
-                payload.kernel_version = VM_DEFAULT_KERNEL_VERSION;
-            }
-
-            if (imgConfig.Image) {
-                payload.internal_metadata['docker:imageid'] =
-                    opts.image.docker_id;
-            }
-            if (container.Image) {
-                // the original name the user passed
-                payload.internal_metadata['docker:imagename'] = container.Image;
-            }
-
-            if (!payload.internal_metadata['docker:entrypoint']
-                && !payload.internal_metadata['docker:cmd'] && imgConfig.Cmd) {
-
-                payload.internal_metadata['docker:cmd'] =
-                    JSON.stringify(imgConfig.Cmd);
-            }
-            if (!payload.internal_metadata['docker:entrypoint']
-                && imgConfig.Entrypoint) {
-
-                payload.internal_metadata['docker:entrypoint'] =
-                    JSON.stringify(imgConfig.Entrypoint);
-            }
-            if (imgConfig.Env) {
-                var existing;
-                if (payload.internal_metadata['docker:env']) {
-                    existing = JSON.parse(payload
-                        .internal_metadata['docker:env']);
-                } else {
-                    existing = [];
-                }
-                payload.internal_metadata['docker:env'] =
-                    JSON.stringify(imgConfig.Env.concat(existing));
-            }
-            if (imgConfig.Volumes) {
-                Object.keys(imgConfig.Volumes).forEach(function (v) {
-                    var exists = false;
+                        }
+                    );
+                },
 
-                    payload.filesystems.forEach(function (f) {
-                        if (f.target === v) {
-                            exists = true;
+                function selectPackage(_, cb) {
+                    getPackage(opts, container, function(err, package_uuid) {
+                        if (!err) {
+                            payload.billing_id = package_uuid;
                         }
+                        cb(err);
                     });
+                },
+
+                function addImageData(_, cb) {
+                    payload.image_uuid = opts.image.image_uuid;
 
-                    if (exists) {
-                        log.warn({volume: v}, 'volume specified both in payload'
-                            + ' and image, ignoring volume from image');
+                    if (opts.image.os === 'smartos') {
+                        payload.brand = 'joyent-minimal';
+                        payload.init_name = '/usr/vm/sbin/dockerinit';
                     } else {
-                        _addDataVolume(v);
+                        payload.brand = 'lx';
+                        payload.init_name = '/native/usr/vm/sbin/dockerinit';
+                        payload.internal_metadata['docker:noipmgmtd'] = true;
+                        payload.kernel_version = VM_DEFAULT_KERNEL_VERSION;
                     }
-                });
-            }
-            if (!payload.internal_metadata['docker:workdir']
-                && imgConfig.WorkingDir) {
-
-                payload.internal_metadata['docker:workdir'] =
-                    imgConfig.WorkingDir;
-            }
-            if (!payload.internal_metadata['docker:user'] && imgConfig.User) {
-                payload.internal_metadata['docker:user'] = imgConfig.User;
-            }
 
-            cb();
+                    if (imgConfig.Image) {
+                        payload.internal_metadata['docker:imageid'] =
+                            opts.image.docker_id;
+                    }
+                    if (container.Image) {
+                        // the original name the user passed
+                        payload.internal_metadata['docker:imagename'] =
+                            container.Image;
+                    }
 
-        }, function (_, cb) {
-            addExposeFirewallRules(opts, payload, cb);
+                    if (
+                        !payload.internal_metadata['docker:entrypoint'] &&
+                        !payload.internal_metadata['docker:cmd'] &&
+                        imgConfig.Cmd
+                    ) {
+                        payload.internal_metadata[
+                            'docker:cmd'
+                        ] = JSON.stringify(imgConfig.Cmd);
+                    }
+                    if (
+                        !payload.internal_metadata['docker:entrypoint'] &&
+                        imgConfig.Entrypoint
+                    ) {
+                        payload.internal_metadata[
+                            'docker:entrypoint'
+                        ] = JSON.stringify(imgConfig.Entrypoint);
+                    }
+                    if (imgConfig.Env) {
+                        var existing;
+                        if (payload.internal_metadata['docker:env']) {
+                            existing = JSON.parse(
+                                payload.internal_metadata['docker:env']
+                            );
+                        } else {
+                            existing = [];
+                        }
+                        payload.internal_metadata[
+                            'docker:env'
+                        ] = JSON.stringify(imgConfig.Env.concat(existing));
+                    }
+                    if (imgConfig.Volumes) {
+                        Object.keys(imgConfig.Volumes).forEach(function(v) {
+                            var exists = false;
 
-        }, function (_, cb) {
-            addPublishFirewallRules(opts, container, opts.image, payload, cb);
+                            payload.filesystems.forEach(function(f) {
+                                if (f.target === v) {
+                                    exists = true;
+                                }
+                            });
+
+                            if (exists) {
+                                log.warn(
+                                    {volume: v},
+                                    'volume specified both in payload' +
+                                        ' and image, ignoring volume from image'
+                                );
+                            } else {
+                                _addDataVolume(v);
+                            }
+                        });
+                    }
+                    if (
+                        !payload.internal_metadata['docker:workdir'] &&
+                        imgConfig.WorkingDir
+                    ) {
+                        payload.internal_metadata['docker:workdir'] =
+                            imgConfig.WorkingDir;
+                    }
+                    if (
+                        !payload.internal_metadata['docker:user'] &&
+                        imgConfig.User
+                    ) {
+                        payload.internal_metadata['docker:user'] =
+                            imgConfig.User;
+                    }
 
-        }, function ensureDefaultInternalMetadata(_, cb) {
-            if (!payload.internal_metadata['docker:cmd']) {
-                payload.internal_metadata['docker:cmd'] = '[]';
-            }
-            if (!payload.internal_metadata['docker:entrypoint']) {
-                payload.internal_metadata['docker:entrypoint'] = '[]';
-            }
-            if (!payload.internal_metadata['docker:env']) {
-                payload.internal_metadata['docker:env'] = '[]';
-            }
-            cb();
+                    cb();
+                },
+                function(_, cb) {
+                    addExposeFirewallRules(opts, payload, cb);
+                },
+                function(_, cb) {
+                    addPublishFirewallRules(
+                        opts,
+                        container,
+                        opts.image,
+                        payload,
+                        cb
+                    );
+                },
+                function ensureDefaultInternalMetadata(_, cb) {
+                    if (!payload.internal_metadata['docker:cmd']) {
+                        payload.internal_metadata['docker:cmd'] = '[]';
+                    }
+                    if (!payload.internal_metadata['docker:entrypoint']) {
+                        payload.internal_metadata['docker:entrypoint'] = '[]';
+                    }
+                    if (!payload.internal_metadata['docker:env']) {
+                        payload.internal_metadata['docker:env'] = '[]';
+                    }
+                    cb();
+                }
+            ]
+        },
+        function(err, results) {
+            log.debug({err: err, payload: payload}, 'buildVmPayload done');
+            callback(err, payload);
         }
-    ]}, function (err, results) {
-        log.debug({err: err, payload: payload},
-            'buildVmPayload done');
-        callback(err, payload);
-    });
+    );
 }
 
 /*
@@ -2364,7 +2753,7 @@ function findContainerIdMatch(id, objects) {
         partial: []
     };
 
-    objects.forEach(function (obj) {
+    objects.forEach(function(obj) {
         var dockerId = obj.internal_metadata['docker:id'];
 
         if (dockerId === undefined) {
@@ -2373,11 +2762,10 @@ function findContainerIdMatch(id, objects) {
 
         if (id.length === 64 && dockerId === id) {
             matches.full.push(obj);
-        // Alias match
-        } else if (id.length > 0 && obj.alias.length > 0
-            && id === obj.alias) {
+            // Alias match
+        } else if (id.length > 0 && obj.alias.length > 0 && id === obj.alias) {
             matches.alias.push(obj);
-        // Partial id match
+            // Partial id match
         } else if (id.length > 0 && dockerId.substr(0, id.length) === id) {
             matches.partial.push(obj);
         }
@@ -2396,7 +2784,6 @@ function findContainerIdMatch(id, objects) {
     return match;
 }
 
-
 /*
  * Find this container id from the list of all docker containers.
  */
@@ -2410,7 +2797,7 @@ function getVmById(id, opts, callback) {
     var log = opts.log;
     opts.one = true;
 
-    listDockerVms(opts, function (err, objects) {
+    listDockerVms(opts, function(err, objects) {
         if (err) {
             callback(err);
             return;
@@ -2421,8 +2808,11 @@ function getVmById(id, opts, callback) {
             callback(null, match);
         } else {
             log.error('findUuidForId(' + id + '): not found');
-            callback(new restify.ResourceNotFoundError(
-                'container "' + id + '" not found'));
+            callback(
+                new restify.ResourceNotFoundError(
+                    'container "' + id + '" not found'
+                )
+            );
         }
     });
 }
@@ -2435,29 +2825,39 @@ function loadPackages(opts, callback) {
     assert.string(opts.reqId, 'opts.reqId');
 
     // only active packages that belong to this owner, or have no owner
-    var filter = '(&(active=true)'
-        + '(|(owner_uuids=' + opts.ownerUuid + ')'
-        + '(!(owner_uuids=*))))';
+    var filter =
+        '(&(active=true)' +
+        '(|(owner_uuids=' +
+        opts.ownerUuid +
+        ')' +
+        '(!(owner_uuids=*))))';
     var log = opts.log;
     var papi = getPapiClient(opts.papiConfig);
 
     // TODO: DOCKER-687 is open for adding support for caching here.
 
-    papi.list(filter, {
-        headers: {'x-request-id': opts.reqId}
-    }, function _loadedPackages(err, pkgs, count) {
-        // log results but remap pkgs to just uuid+name to avoid spamming logs
-        log.debug({
-            count: count,
-            err: err,
-            owner: opts.ownerUuid,
-            pkgs: pkgs.map(function _mapPkgs(pkg) {
-                return ({name: pkg.name, uuid: pkg.uuid});
-            })
-        }, 'PAPI.list results');
+    papi.list(
+        filter,
+        {
+            headers: {'x-request-id': opts.reqId}
+        },
+        function _loadedPackages(err, pkgs, count) {
+            // log results but remap pkgs to just uuid+name to avoid spamming logs
+            log.debug(
+                {
+                    count: count,
+                    err: err,
+                    owner: opts.ownerUuid,
+                    pkgs: pkgs.map(function _mapPkgs(pkg) {
+                        return {name: pkg.name, uuid: pkg.uuid};
+                    })
+                },
+                'PAPI.list results'
+            );
 
-        callback(err, pkgs, count);
-    });
+            callback(err, pkgs, count);
+        }
+    );
 }
 
 //---- exported SdcBackend methods
@@ -2473,29 +2873,37 @@ function getContainerCount(opts, callback) {
     var params = {
         predicate: JSON.stringify({
             and: [
-                { eq: [ 'docker', true ] },
-                { and:
-                    [
-                        { ne: [ 'state', 'failed' ] },
-                        { ne: [ 'state', 'destroyed' ] }
+                {eq: ['docker', true]},
+                {
+                    and: [
+                        {ne: ['state', 'failed']},
+                        {ne: ['state', 'destroyed']}
                     ]
                 },
-                { eq: [ 'owner_uuid', opts.account.uuid ] }
+                {eq: ['owner_uuid', opts.account.uuid]}
             ]
         })
     };
 
-    vmapi.countVms(params, {
-        headers: {'x-request-id': opts.req_id}
-    }, function _countVmsCb(err, vmcount, _req, _res) {
-        if (err) {
-            opts.log.error(err, 'Error retrieving Virtual Machine count');
-            return callback(errors.vmapiErrorWrap(
-                err, 'problem retrieving virtual machine count'));
-        }
+    vmapi.countVms(
+        params,
+        {
+            headers: {'x-request-id': opts.req_id}
+        },
+        function _countVmsCb(err, vmcount, _req, _res) {
+            if (err) {
+                opts.log.error(err, 'Error retrieving Virtual Machine count');
+                return callback(
+                    errors.vmapiErrorWrap(
+                        err,
+                        'problem retrieving virtual machine count'
+                    )
+                );
+            }
 
-        callback(null, vmcount);
-    });
+            callback(null, vmcount);
+        }
+    );
 }
 
 /*
@@ -2517,56 +2925,68 @@ function getContainersForVms(opts, callback) {
     var vmobjs = opts.vmobjs;
 
     function _containerForVmObj(vmobj, cb) {
-        fwapi.getVMrules(vmobj.uuid, {
-            owner_uuid: vmobj.owner_uuid
-        }, function (err, fwrules) {
-            if (err) {
-                callback(err);
-                return;
-            }
+        fwapi.getVMrules(
+            vmobj.uuid,
+            {
+                owner_uuid: vmobj.owner_uuid
+            },
+            function(err, fwrules) {
+                if (err) {
+                    callback(err);
+                    return;
+                }
 
-            utils.vmobjToContainer({
-                clientApiVersion: opts.clientApiVersion,
-                app: opts.app,
-                log: opts.log
-            }, vmobj, fwrules, function _addPkgLabel(e, container) {
-                if (!e) {
-                    if (pkgmapUtoN.hasOwnProperty(vmobj.billing_id)) {
-                        // We've got the package available, so attach to the
-                        // object.
-                        container.Labels['com.joyent.package']
-                            = pkgmapUtoN[vmobj.billing_id];
-                    } else {
-                        // Somehow we don't know the name of this package
-                        // even though we preloaded the packages earlier.
-                        // Possible scenarios include:
-                        //
-                        //  * package has changed owner since provisioning
-                        //  * package has been deactivated
-                        //
-                        // in any case, we'll not fail the whole 'docker ps'
-                        // for this and instead we'll just use '<unknown>'.
-                        container.Labels['com.joyent.package']
-                            = '<unknown>';
+                utils.vmobjToContainer(
+                    {
+                        clientApiVersion: opts.clientApiVersion,
+                        app: opts.app,
+                        log: opts.log
+                    },
+                    vmobj,
+                    fwrules,
+                    function _addPkgLabel(e, container) {
+                        if (!e) {
+                            if (pkgmapUtoN.hasOwnProperty(vmobj.billing_id)) {
+                                // We've got the package available, so attach to the
+                                // object.
+                                container.Labels['com.joyent.package'] =
+                                    pkgmapUtoN[vmobj.billing_id];
+                            } else {
+                                // Somehow we don't know the name of this package
+                                // even though we preloaded the packages earlier.
+                                // Possible scenarios include:
+                                //
+                                //  * package has changed owner since provisioning
+                                //  * package has been deactivated
+                                //
+                                // in any case, we'll not fail the whole 'docker ps'
+                                // for this and instead we'll just use '<unknown>'.
+                                container.Labels['com.joyent.package'] =
+                                    '<unknown>';
+                            }
+                        }
+                        cb(e, container);
                     }
-                }
-                cb(e, container);
-            });
-        });
+                );
+            }
+        );
     }
 
     // Take all the VM objects we found that matched the filters and turn
     // them into docker container objects.
-    vasync.forEachPipeline({
-        'func': _containerForVmObj,
-        'inputs': vmobjs
-    }, function (err, results) {
-        if (err) {
-            callback(err);
-            return;
+    vasync.forEachPipeline(
+        {
+            func: _containerForVmObj,
+            inputs: vmobjs
+        },
+        function(err, results) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            callback(null, results.successes);
         }
-        callback(null, results.successes);
-    });
+    );
 }
 
 function getContainers(opts, callback) {
@@ -2610,319 +3030,393 @@ function getContainers(opts, callback) {
         }
     }
 
-    vasync.pipeline({arg: {}, funcs: [
-        function _listDockerVms(stash, cb) {
-            listDockerVms({
-                log: log,
-                req_id: opts.req_id,
-                account: opts.account,
-                vmapi: vmapi,
-                all: opts.all
-            }, function _sortAndStashVms(getvm_err, objects) {
-
-                if (getvm_err) {
-                    cb(getvm_err);
-                    return;
-                }
+    vasync.pipeline(
+        {
+            arg: {},
+            funcs: [
+                function _listDockerVms(stash, cb) {
+                    listDockerVms(
+                        {
+                            log: log,
+                            req_id: opts.req_id,
+                            account: opts.account,
+                            vmapi: vmapi,
+                            all: opts.all
+                        },
+                        function _sortAndStashVms(getvm_err, objects) {
+                            if (getvm_err) {
+                                cb(getvm_err);
+                                return;
+                            }
 
-                // Containers are sorted newest (0) to oldest (n).
-                objects.sort(function _cmpVmByCreation(entry1, entry2) {
-                    if (entry1.create_timestamp > entry2.create_timestamp) {
-                        return -1;
-                    } else if (entry1.create_timestamp
-                        < entry2.create_timestamp) {
-                        return 1;
-                    }
-                    return 0;
-                });
+                            // Containers are sorted newest (0) to oldest (n).
+                            objects.sort(function _cmpVmByCreation(
+                                entry1,
+                                entry2
+                            ) {
+                                if (
+                                    entry1.create_timestamp >
+                                    entry2.create_timestamp
+                                ) {
+                                    return -1;
+                                } else if (
+                                    entry1.create_timestamp <
+                                    entry2.create_timestamp
+                                ) {
+                                    return 1;
+                                }
+                                return 0;
+                            });
 
-                stash.objects = objects;
-                cb();
-            });
-        }, function _filterSince(stash, cb) {
-            var match;
-            var objects = stash.objects;
+                            stash.objects = objects;
+                            cb();
+                        }
+                    );
+                },
+                function _filterSince(stash, cb) {
+                    var match;
+                    var objects = stash.objects;
 
-            if (!opts.since) {
-                cb();
-                return;
-            }
+                    if (!opts.since) {
+                        cb();
+                        return;
+                    }
 
-            objects = stash.objects;
+                    objects = stash.objects;
 
-            match = findContainerIdMatch(opts.since, objects);
-            if (!match) {
-                cb(new errors.DockerError('Could not find container with name '
-                    + 'or id ' + opts.since));
-                return;
-            }
+                    match = findContainerIdMatch(opts.since, objects);
+                    if (!match) {
+                        cb(
+                            new errors.DockerError(
+                                'Could not find container with name ' +
+                                    'or id ' +
+                                    opts.since
+                            )
+                        );
+                        return;
+                    }
 
-            stash.objects = objects.slice(0, objects.indexOf(match));
+                    stash.objects = objects.slice(0, objects.indexOf(match));
 
-            cb();
-        }, function _filterBefore(stash, cb) {
-            var match;
-            var objects = stash.objects;
+                    cb();
+                },
+                function _filterBefore(stash, cb) {
+                    var match;
+                    var objects = stash.objects;
 
-            if (!opts.before) {
-                cb();
-                return;
-            }
+                    if (!opts.before) {
+                        cb();
+                        return;
+                    }
 
-            match = findContainerIdMatch(opts.before, objects);
-            if (!match) {
-                cb(new errors.DockerError('Could not find container with name '
-                    + 'or id ' + opts.before));
-                return;
-            }
-            stash.objects = objects.slice(objects.indexOf(match) + 1);
+                    match = findContainerIdMatch(opts.before, objects);
+                    if (!match) {
+                        cb(
+                            new errors.DockerError(
+                                'Could not find container with name ' +
+                                    'or id ' +
+                                    opts.before
+                            )
+                        );
+                        return;
+                    }
+                    stash.objects = objects.slice(objects.indexOf(match) + 1);
 
-            cb();
-        }, function _preloadPackages(stash, cb) {
-            var filteringOnPkgs = false;
-            var i;
-            var invalidPackageName;
-            var labelFilters;
-            var labelSplit;
-
-            if (filters && filters.hasOwnProperty('label')) {
-                labelFilters = filters['label'];
-                assert.array(labelFilters, 'labelFilters');
-
-                for (i = 0; i < labelFilters.length; i++) {
-                    labelSplit = labelFilters[i].split('=', 2);
-                    if (labelSplit[0] === PACKAGE_SELECTION_LABEL) {
-                        filteringOnPkgs = true;
-                        if (labelSplit[1].match(BAD_PKG_NAME_RE)
-                            || !labelSplit[1].match(PKG_NAME_RE)) {
-                            // invalid package name, this is an error
-                            invalidPackageName = labelSplit[1];
+                    cb();
+                },
+                function _preloadPackages(stash, cb) {
+                    var filteringOnPkgs = false;
+                    var i;
+                    var invalidPackageName;
+                    var labelFilters;
+                    var labelSplit;
+
+                    if (filters && filters.hasOwnProperty('label')) {
+                        labelFilters = filters['label'];
+                        assert.array(labelFilters, 'labelFilters');
+
+                        for (i = 0; i < labelFilters.length; i++) {
+                            labelSplit = labelFilters[i].split('=', 2);
+                            if (labelSplit[0] === PACKAGE_SELECTION_LABEL) {
+                                filteringOnPkgs = true;
+                                if (
+                                    labelSplit[1].match(BAD_PKG_NAME_RE) ||
+                                    !labelSplit[1].match(PKG_NAME_RE)
+                                ) {
+                                    // invalid package name, this is an error
+                                    invalidPackageName = labelSplit[1];
+                                }
+                            }
                         }
                     }
-                }
-            }
 
-            if (invalidPackageName) {
-                cb(new errors.DockerError('invalid value for '
-                    + PACKAGE_SELECTION_LABEL + ': ' + invalidPackageName));
-                return;
-            }
-
-            loadPackages({
-                log: log,
-                ownerUuid: opts.account.uuid,
-                papiConfig: opts.app.config.papi,
-                reqId: opts.req_id
-            }, function _loadPkgs(err, pkgs, count) {
-                if (err) {
-                    cb(new errors.papiErrorWrap(err,
-                        'problem listing packages'));
-                    return;
-                }
-
-                if (count === 0 && filteringOnPkgs === true) {
-                    // We're trying to filter on packages and none matched the
-                    // filter/
-                    cb(new errors.DockerError('no packages match '
-                        + 'selection'));
-                    return;
-                } else if (count === 0) {
-                    // Not trying to filter on packages, but couldn't find any
-                    // available to this user.
-                    cb(new errors.DockerError('no packages available to this '
-                        + 'user'));
-                    return;
-                }
+                    if (invalidPackageName) {
+                        cb(
+                            new errors.DockerError(
+                                'invalid value for ' +
+                                    PACKAGE_SELECTION_LABEL +
+                                    ': ' +
+                                    invalidPackageName
+                            )
+                        );
+                        return;
+                    }
 
-                // make maps name -> uuid and uuid -> name
-                pkgs.forEach(function _mapPkg(pkg) {
-                    pkgmapNtoU[pkg.name] = pkg.uuid;
-                    pkgmapUtoN[pkg.uuid] = pkg.name;
-                });
+                    loadPackages(
+                        {
+                            log: log,
+                            ownerUuid: opts.account.uuid,
+                            papiConfig: opts.app.config.papi,
+                            reqId: opts.req_id
+                        },
+                        function _loadPkgs(err, pkgs, count) {
+                            if (err) {
+                                cb(
+                                    new errors.papiErrorWrap(
+                                        err,
+                                        'problem listing packages'
+                                    )
+                                );
+                                return;
+                            }
 
-                cb();
-            });
-        }, function _filterFilter(stash, cb) {
-            var filterErr;
-            var objects = stash.objects;
+                            if (count === 0 && filteringOnPkgs === true) {
+                                // We're trying to filter on packages and none matched the
+                                // filter/
+                                cb(
+                                    new errors.DockerError(
+                                        'no packages match ' + 'selection'
+                                    )
+                                );
+                                return;
+                            } else if (count === 0) {
+                                // Not trying to filter on packages, but couldn't find any
+                                // available to this user.
+                                cb(
+                                    new errors.DockerError(
+                                        'no packages available to this ' +
+                                            'user'
+                                    )
+                                );
+                                return;
+                            }
 
-            if (!filters) {
-                cb();
-                return;
-            }
+                            // make maps name -> uuid and uuid -> name
+                            pkgs.forEach(function _mapPkg(pkg) {
+                                pkgmapNtoU[pkg.name] = pkg.uuid;
+                                pkgmapUtoN[pkg.uuid] = pkg.name;
+                            });
 
-            Object.keys(filters).forEach(function _filterField(field) {
-                var labelFilters;
-                var val = filters[field];
-                var val_to_sdc_status;
-
-                log.debug('filter on field %s, value: %j', field, val);
-                if (field == 'status') {
-                    val_to_sdc_status = {
-                        'created': 'provisioning',
-                        'running': 'running',
-                        'restarting': 'restarting',
-                        'paused': 'paused',
-                        'exited': 'stopped'
-                    };
-                    // val is an *array* of acceptable values, map to
-                    // the sdc value and check if this entry matches
-                    // any of the requested values.
-                    val.map(function _mapStatuses(v) {
-                        var sdcStatus = val_to_sdc_status[v];
-                        if (typeof (sdcStatus) === 'undefined') {
-                            filterErr = new errors.DockerError(
-                                'Unrecognised filter value for status');
-                            return null;
+                            cb();
                         }
-                        objects = objects.filter(
-                            function _filterState(entry) {
-                                return entry.state === sdcStatus;
-                            }
-                        );
-                    });
-                } else if (field == 'exited') {
-                    // val is an *array* of acceptable return codes as
-                    // *strings*, so convert exit_status to string and
-                    // compare with the requested values.
-                    objects = objects.filter(function _filterExited(entry) {
-                        return val.indexOf(String(entry.exit_status)) >= 0;
-                    });
-                } else if (field == 'id') {
-                    // val is an *array* of acceptable docker id's
-                    // *strings*, so find any containers matching
-                    // the requested values.
-                    objects = objects.filter(function _filterId(entry) {
-                        var id = entry.internal_metadata['docker:id'];
-                        for (var i = 0; i < val.length; i++) {
-                            if (id.match(val[i])) {
-                                return true;
-                            }
-                        }
-                        return false;
-                    });
-                } else if (field == 'name') {
-                    // val is an *array* of acceptable docker name's
-                    // *strings*, so find any containers matching
-                    // the requested values.
-                    objects = objects.filter(function _filterName(entry) {
-                        for (var i = 0; i < val.length; i++) {
-                            if (entry.alias.match(val[i]) !== null) {
-                                return true;
-                            }
-                        }
-                        return false;
-                    });
-                } else if (field == 'label') {
-                    labelFilters = val;
-
-                    // labelFilters is an *array* of acceptable docker name's
-                    // *strings*, so find any containers matching *all* of the
-                    // requested values.
-                    for (var j = 0; j < labelFilters.length; j++) {
-                        // val[i] is either 'key' or 'key=value'
-                        var labelK; // key
-                        var labelV; // value
-                        var labelSplit = labelFilters[j].split('=', 2);
-                        var wantedTag = common.LABELTAG_PREFIX
-                            + labelSplit[0];
-
-                        labelK = labelSplit[0];
-                        labelV = labelSplit[1];
-
-                        objects = objects
-                            .filter(function _filterLabel(entry) {
-                            var pkg;
-                            var tag;
-                            var tags;
-
-                            if (labelK === PACKAGE_SELECTION_LABEL) {
-                                // should be a package name/uuid/short-UUID
-                                pkg = labelV;
-
-                                log.debug('filtering package');
-
-                                if (entry.billing_id === pkg) {
-                                    // matches UUID directly
-                                    return true;
-                                } else if (pkg.match(/^[0-9a-f]{8}$/)
-                                    && entry.billing_id.substr(0, 8)
-                                    === pkg) {
-                                    // matched short-UUID
-                                    return true;
-                                } else {
-                                    assert.object(pkgmapNtoU, 'pkgmapNtoU');
+                    );
+                },
+                function _filterFilter(stash, cb) {
+                    var filterErr;
+                    var objects = stash.objects;
 
-                                    if (pkgmapNtoU[pkg] && pkgmapNtoU[pkg]
-                                        === entry.billing_id) {
-                                        // this package matches the uuid of
-                                        // this VM
+                    if (!filters) {
+                        cb();
+                        return;
+                    }
+
+                    Object.keys(filters).forEach(function _filterField(field) {
+                        var labelFilters;
+                        var val = filters[field];
+                        var val_to_sdc_status;
+
+                        log.debug('filter on field %s, value: %j', field, val);
+                        if (field == 'status') {
+                            val_to_sdc_status = {
+                                created: 'provisioning',
+                                running: 'running',
+                                restarting: 'restarting',
+                                paused: 'paused',
+                                exited: 'stopped'
+                            };
+                            // val is an *array* of acceptable values, map to
+                            // the sdc value and check if this entry matches
+                            // any of the requested values.
+                            val.map(function _mapStatuses(v) {
+                                var sdcStatus = val_to_sdc_status[v];
+                                if (typeof sdcStatus === 'undefined') {
+                                    filterErr = new errors.DockerError(
+                                        'Unrecognised filter value for status'
+                                    );
+                                    return null;
+                                }
+                                objects = objects.filter(function _filterState(
+                                    entry
+                                ) {
+                                    return entry.state === sdcStatus;
+                                });
+                            });
+                        } else if (field == 'exited') {
+                            // val is an *array* of acceptable return codes as
+                            // *strings*, so convert exit_status to string and
+                            // compare with the requested values.
+                            objects = objects.filter(function _filterExited(
+                                entry
+                            ) {
+                                return (
+                                    val.indexOf(String(entry.exit_status)) >= 0
+                                );
+                            });
+                        } else if (field == 'id') {
+                            // val is an *array* of acceptable docker id's
+                            // *strings*, so find any containers matching
+                            // the requested values.
+                            objects = objects.filter(function _filterId(entry) {
+                                var id = entry.internal_metadata['docker:id'];
+                                for (var i = 0; i < val.length; i++) {
+                                    if (id.match(val[i])) {
+                                        return true;
+                                    }
+                                }
+                                return false;
+                            });
+                        } else if (field == 'name') {
+                            // val is an *array* of acceptable docker name's
+                            // *strings*, so find any containers matching
+                            // the requested values.
+                            objects = objects.filter(function _filterName(
+                                entry
+                            ) {
+                                for (var i = 0; i < val.length; i++) {
+                                    if (entry.alias.match(val[i]) !== null) {
                                         return true;
                                     }
                                 }
-                            } else if (entry.tags) {
-                                tags = Object.keys(entry.tags);
-
-                                for (var k = 0; k < tags.length; k++) {
-                                    tag = tags[k];
-                                    if (tag === wantedTag) {
-                                        if (!labelV
-                                            || entry.tags[tag] == labelV) {
+                                return false;
+                            });
+                        } else if (field == 'label') {
+                            labelFilters = val;
+
+                            // labelFilters is an *array* of acceptable docker name's
+                            // *strings*, so find any containers matching *all* of the
+                            // requested values.
+                            for (var j = 0; j < labelFilters.length; j++) {
+                                // val[i] is either 'key' or 'key=value'
+                                var labelK; // key
+                                var labelV; // value
+                                var labelSplit = labelFilters[j].split('=', 2);
+                                var wantedTag =
+                                    common.LABELTAG_PREFIX + labelSplit[0];
+
+                                labelK = labelSplit[0];
+                                labelV = labelSplit[1];
+
+                                objects = objects.filter(function _filterLabel(
+                                    entry
+                                ) {
+                                    var pkg;
+                                    var tag;
+                                    var tags;
+
+                                    if (labelK === PACKAGE_SELECTION_LABEL) {
+                                        // should be a package name/uuid/short-UUID
+                                        pkg = labelV;
+
+                                        log.debug('filtering package');
+
+                                        if (entry.billing_id === pkg) {
+                                            // matches UUID directly
                                             return true;
+                                        } else if (
+                                            pkg.match(/^[0-9a-f]{8}$/) &&
+                                            entry.billing_id.substr(0, 8) ===
+                                                pkg
+                                        ) {
+                                            // matched short-UUID
+                                            return true;
+                                        } else {
+                                            assert.object(
+                                                pkgmapNtoU,
+                                                'pkgmapNtoU'
+                                            );
+
+                                            if (
+                                                pkgmapNtoU[pkg] &&
+                                                pkgmapNtoU[pkg] ===
+                                                    entry.billing_id
+                                            ) {
+                                                // this package matches the uuid of
+                                                // this VM
+                                                return true;
+                                            }
+                                        }
+                                    } else if (entry.tags) {
+                                        tags = Object.keys(entry.tags);
+
+                                        for (var k = 0; k < tags.length; k++) {
+                                            tag = tags[k];
+                                            if (tag === wantedTag) {
+                                                if (
+                                                    !labelV ||
+                                                    entry.tags[tag] == labelV
+                                                ) {
+                                                    return true;
+                                                }
+                                            }
                                         }
                                     }
-                                }
+                                    return false;
+                                });
                             }
-                            return false;
-                        });
+                        } else {
+                            log.warn('Unhandled docker filter name:', field);
+                        }
+                    });
+
+                    if (filterErr) {
+                        cb(filterErr);
+                        return;
                     }
-                } else {
-                    log.warn('Unhandled docker filter name:', field);
-                }
-            });
 
-            if (filterErr) {
-                cb(filterErr);
-                return;
-            }
+                    stash.objects = objects;
+                    cb();
+                },
+                function _limitResults(stash, cb) {
+                    var objects = stash.objects;
 
-            stash.objects = objects;
-            cb();
-        }, function _limitResults(stash, cb) {
-            var objects = stash.objects;
+                    if (opts.limit > 0) {
+                        objects = objects.slice(0, opts.limit);
+                    }
+
+                    // last cb in chain, so we pass objects to results
+                    cb(null, objects);
+                }
+            ]
+        },
+        function _pipelineCb(err, results) {
+            var objects;
 
-            if (opts.limit > 0) {
-                objects = objects.slice(0, opts.limit);
+            if (err) {
+                callback(err);
+                return;
             }
 
-            // last cb in chain, so we pass objects to results
-            cb(null, objects);
-        }
-    ]}, function _pipelineCb(err, results) {
-        var objects;
+            // We get the objects from the last callback in the chain which passes
+            // it to cb() for us to collect.
+            objects = results.successes.pop();
+            assert.array(objects);
 
-        if (err) {
-            callback(err);
-            return;
+            // Turn the objects into containers, then call callback with:
+            //
+            //  callback(err, containers);
+            //
+            getContainersForVms(
+                {
+                    app: opts.app,
+                    clientApiVersion: opts.clientApiVersion,
+                    log: log,
+                    pkgmapUtoN: pkgmapUtoN,
+                    vmobjs: objects
+                },
+                callback
+            );
         }
-
-        // We get the objects from the last callback in the chain which passes
-        // it to cb() for us to collect.
-        objects = results.successes.pop();
-        assert.array(objects);
-
-        // Turn the objects into containers, then call callback with:
-        //
-        //  callback(err, containers);
-        //
-        getContainersForVms({
-            app: opts.app,
-            clientApiVersion: opts.clientApiVersion,
-            log: log,
-            pkgmapUtoN: pkgmapUtoN,
-            vmobjs: objects
-        }, callback);
-    });
+    );
 }
 
 function createContainer(opts, callback) {
@@ -2932,8 +3426,10 @@ function createContainer(opts, callback) {
     assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.account, 'opts.account');
     assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
-    assert.optionalBool(opts.fabricRequireExternal,
-                        'opts.fabricRequireExternal');
+    assert.optionalBool(
+        opts.fabricRequireExternal,
+        'opts.fabricRequireExternal'
+    );
 
     var log = opts.log || this.log;
     var name = opts.name;
@@ -2943,49 +3439,53 @@ function createContainer(opts, callback) {
     var vm_payload;
     var linkDetails;
 
-    vasync.waterfall([
-        _buildPayload,
-        _addLinks,
-        _createVm,
-        _saveLinks
-    ], _done);
-
-    function _buildPayload(cb) {
-        // XXX check that "name" is not already used? VMAPI also does that.
-        container.Name = name;
-        buildVmPayload({
-            app: opts.app,
-            config: config,
-            fabricRequireExternal: opts.fabricRequireExternal,
-            image: opts.image,
-            log: log,
-            req_id: opts.req_id,
-            account: opts.account,
-            vmapi: vmapi,
-            clientApiVersion: opts.clientApiVersion
-        }, container, function (err, _vm_payload) {
-            if (err) {
-                return cb(err);
-            }
-            vm_payload = _vm_payload;
-            if (vm_payload.internal_metadata['docker:entrypoint'] === '[]'
-                && vm_payload.internal_metadata['docker:cmd'] === '[]') {
-
-                // Container must have *some* command to run or it cannot boot.
-                log.error({
-                    container: container,
-                    vm_payload: vm_payload
-                }, 'missing both Cmd and Entrypoint');
-                cb(new errors.DockerError('No command specified'));
-                return;
+    vasync.waterfall([_buildPayload, _addLinks, _createVm, _saveLinks], _done);
+
+    function _buildPayload(cb) {
+        // XXX check that "name" is not already used? VMAPI also does that.
+        container.Name = name;
+        buildVmPayload(
+            {
+                app: opts.app,
+                config: config,
+                fabricRequireExternal: opts.fabricRequireExternal,
+                image: opts.image,
+                log: log,
+                req_id: opts.req_id,
+                account: opts.account,
+                vmapi: vmapi,
+                clientApiVersion: opts.clientApiVersion
+            },
+            container,
+            function(err, _vm_payload) {
+                if (err) {
+                    return cb(err);
+                }
+                vm_payload = _vm_payload;
+                if (
+                    vm_payload.internal_metadata['docker:entrypoint'] ===
+                        '[]' &&
+                    vm_payload.internal_metadata['docker:cmd'] === '[]'
+                ) {
+                    // Container must have *some* command to run or it cannot boot.
+                    log.error(
+                        {
+                            container: container,
+                            vm_payload: vm_payload
+                        },
+                        'missing both Cmd and Entrypoint'
+                    );
+                    cb(new errors.DockerError('No command specified'));
+                    return;
+                }
+                cb();
             }
-            cb();
-        });
+        );
     }
 
     function _addLinks(cb) {
         var configLinks = container.HostConfig.Links;
-        getLinkDetails(opts, configLinks, vm_payload, function (err, details) {
+        getLinkDetails(opts, configLinks, vm_payload, function(err, details) {
             linkDetails = details || [];
             if (err) {
                 return cb(err);
@@ -2996,19 +3496,27 @@ function createContainer(opts, callback) {
     }
 
     function _createVm(cb) {
-        log.debug({container: container, vm_payload: vm_payload},
-            'built payload');
+        log.debug(
+            {container: container, vm_payload: vm_payload},
+            'built payload'
+        );
 
-        vmapi.createVm({
-            payload: vm_payload,
-            sync: true
-        }, {headers: {'x-request-id': opts.req_id}}, function (err, res) {
-            if (err) {
-                cb(errors.vmapiErrorWrap(err, 'problem creating container'));
-                return;
+        vmapi.createVm(
+            {
+                payload: vm_payload,
+                sync: true
+            },
+            {headers: {'x-request-id': opts.req_id}},
+            function(err, res) {
+                if (err) {
+                    cb(
+                        errors.vmapiErrorWrap(err, 'problem creating container')
+                    );
+                    return;
+                }
+                cb();
             }
-            cb();
-        });
+        );
     }
 
     function _saveLinks(cb) {
@@ -3019,7 +3527,7 @@ function createContainer(opts, callback) {
         if (err) {
             return callback(err);
         }
-        callback(null, { DockerId: vm_payload.internal_metadata['docker:id'] });
+        callback(null, {DockerId: vm_payload.internal_metadata['docker:id']});
     }
 }
 
@@ -3037,7 +3545,7 @@ function stopContainer(opts, callback) {
     var timeout = opts.timeout;
     var vmapi = opts.app.vmapi;
 
-    var stopHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var stopHeaders = {headers: {'x-request-id': opts.req_id}};
     var stopParams = {
         context: opts.context,
         creator_uuid: opts.creator_uuid,
@@ -3052,11 +3560,12 @@ function stopContainer(opts, callback) {
     log.debug('stopParams: ' + JSON.stringify(stopParams));
     stopParams.log = log;
 
-    vmapi.stopVm(stopParams, stopHeaders, function (stop_err, job) {
+    vmapi.stopVm(stopParams, stopHeaders, function(stop_err, job) {
         if (stop_err) {
             log.error(stop_err, 'Error stopping container.');
-            callback(errors.vmapiErrorWrap(
-                stop_err, 'problem stopping container'));
+            callback(
+                errors.vmapiErrorWrap(stop_err, 'problem stopping container')
+            );
             return;
         }
 
@@ -3079,7 +3588,7 @@ function restartContainer(opts, callback) {
     var timeout = opts.timeout;
     var vmapi = opts.app.vmapi;
 
-    var restartHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var restartHeaders = {headers: {'x-request-id': opts.req_id}};
     var restartParams = {
         context: opts.context,
         creator_uuid: opts.creator_uuid,
@@ -3092,7 +3601,7 @@ function restartContainer(opts, callback) {
     };
 
     // First, check if vm needs updating, if so pass an 'update' param.
-    checkForContainerUpdate(opts, function (err, update) {
+    checkForContainerUpdate(opts, function(err, update) {
         if (err) {
             return callback(err);
         }
@@ -3105,12 +3614,18 @@ function restartContainer(opts, callback) {
         log.debug('restartParams: ' + JSON.stringify(restartParams));
         restartParams.log = log;
 
-        vmapi.rebootVm(restartParams, restartHeaders,
-                        function (restart_err, job) {
+        vmapi.rebootVm(restartParams, restartHeaders, function(
+            restart_err,
+            job
+        ) {
             if (restart_err) {
                 log.error(restart_err, 'Error restarting container.');
-                callback(errors.vmapiErrorWrap(
-                    restart_err, 'problem restarting container'));
+                callback(
+                    errors.vmapiErrorWrap(
+                        restart_err,
+                        'problem restarting container'
+                    )
+                );
                 return;
             }
 
@@ -3127,14 +3642,16 @@ function killContainer(opts, callback) {
     assert.object(opts.account, 'opts.account');
 
     if (opts.signal) {
-        assert.ok((['string', 'number'].indexOf(typeof (opts.signal)) !== -1),
-            'opts.signal');
+        assert.ok(
+            ['string', 'number'].indexOf(typeof opts.signal) !== -1,
+            'opts.signal'
+        );
     }
 
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
 
-    var killHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var killHeaders = {headers: {'x-request-id': opts.req_id}};
     var killParams = {
         context: opts.context,
         creator_uuid: opts.creator_uuid,
@@ -3149,9 +3666,7 @@ function killContainer(opts, callback) {
         opts.signal = 'SIGKILL';
     }
 
-    if ((typeof (opts.signal) === 'string')
-        && (opts.signal.match(/^[0-9]+$/))) {
-
+    if (typeof opts.signal === 'string' && opts.signal.match(/^[0-9]+$/)) {
         // An integer signal being sent as a string. Fix it.
         killParams.signal = Number(opts.signal);
     } else {
@@ -3161,12 +3676,15 @@ function killContainer(opts, callback) {
     log.debug('killParams: ' + JSON.stringify(killParams));
     killParams.log = log;
 
-    vmapi.killVm(killParams, killHeaders, function (kill_err, job) {
+    vmapi.killVm(killParams, killHeaders, function(kill_err, job) {
         if (kill_err) {
             // caller must log
-            callback(errors.vmapiErrorWrap(
-                kill_err,
-                'problem sending signal to container'));
+            callback(
+                errors.vmapiErrorWrap(
+                    kill_err,
+                    'problem sending signal to container'
+                )
+            );
             return;
         }
 
@@ -3191,11 +3709,12 @@ function checkForContainerUpdate(opts, callback) {
         owner_uuid: opts.account.uuid,
         container_uuid: opts.vm.uuid
     };
-    Link.find(opts.app, log, params, function (err, links) {
+    Link.find(opts.app, log, params, function(err, links) {
         if (err) {
             log.error(err, 'Error finding links');
-            return callback(errors.vmapiErrorWrap(err,
-                'problem starting container'));
+            return callback(
+                errors.vmapiErrorWrap(err, 'problem starting container')
+            );
         }
 
         var im = opts.vm.internal_metadata;
@@ -3208,11 +3727,11 @@ function checkForContainerUpdate(opts, callback) {
 
         log.debug('checkForContainerUpdate links: ', links);
 
-        configLinks = links.map(function (link) {
+        configLinks = links.map(function(link) {
             return link.host_config;
         });
 
-        getLinkDetails(opts, configLinks, opts.vm, function (linkErr, details) {
+        getLinkDetails(opts, configLinks, opts.vm, function(linkErr, details) {
             if (linkErr) {
                 return callback(linkErr);
             }
@@ -3223,10 +3742,11 @@ function checkForContainerUpdate(opts, callback) {
             applyLinksToMetadata(newIm, details);
 
             // Compare the links and create an update if they are different.
-            if (newIm['docker:linkHosts'] !== im['docker:linkHosts']
-                || newIm['docker:linkEnv'] !== im['docker:linkEnv'])
-            {
-                update = { 'set_internal_metadata': newIm };
+            if (
+                newIm['docker:linkHosts'] !== im['docker:linkHosts'] ||
+                newIm['docker:linkEnv'] !== im['docker:linkEnv']
+            ) {
+                update = {set_internal_metadata: newIm};
             }
 
             callback(null, update);
@@ -3234,7 +3754,6 @@ function checkForContainerUpdate(opts, callback) {
     });
 }
 
-
 function startContainer(opts, callback) {
     assert.object(opts, 'opts');
     assert.optionalObject(opts.log, 'opts.log');
@@ -3244,7 +3763,7 @@ function startContainer(opts, callback) {
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
 
-    var startHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var startHeaders = {headers: {'x-request-id': opts.req_id}};
     var startParams = {
         context: opts.context,
         creator_uuid: opts.creator_uuid,
@@ -3256,7 +3775,7 @@ function startContainer(opts, callback) {
     };
 
     // First, check if vm needs updating, if so pass an 'update' param.
-    checkForContainerUpdate(opts, function (err, update) {
+    checkForContainerUpdate(opts, function(err, update) {
         if (err) {
             return callback(err);
         }
@@ -3269,11 +3788,15 @@ function startContainer(opts, callback) {
         log.debug('startParams: ' + JSON.stringify(startParams));
         startParams.log = log;
 
-        vmapi.startVm(startParams, startHeaders, function (start_err, job) {
+        vmapi.startVm(startParams, startHeaders, function(start_err, job) {
             if (start_err) {
                 log.error(start_err, 'Error starting container.');
-                return callback(errors.vmapiErrorWrap(start_err,
-                    'problem starting container'));
+                return callback(
+                    errors.vmapiErrorWrap(
+                        start_err,
+                        'problem starting container'
+                    )
+                );
             }
 
             log.debug({job: job}, 'created start job');
@@ -3282,7 +3805,6 @@ function startContainer(opts, callback) {
     });
 }
 
-
 function deleteContainer(opts, callback) {
     assert.object(opts, 'opts');
     assert.bool(opts.force, 'opts.force');
@@ -3295,7 +3817,7 @@ function deleteContainer(opts, callback) {
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
 
-    var deleteHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var deleteHeaders = {headers: {'x-request-id': opts.req_id}};
     var deleteParams = {
         context: opts.context,
         creator_uuid: opts.creator_uuid,
@@ -3311,17 +3833,24 @@ function deleteContainer(opts, callback) {
 
     // Sanity check for accidently deleting a container via link.
     if (opts.link) {
-        callback(new errors.DockerError(
-            new Error(), 'Conflict, cannot remove the default name '
-            + 'of the container'));
+        callback(
+            new errors.DockerError(
+                new Error(),
+                'Conflict, cannot remove the default name ' + 'of the container'
+            )
+        );
         return;
     }
 
     if (!opts.force && opts.vm.state === 'running') {
-        callback(new errors.DockerError(
-            new Error(), 'Conflict, You cannot remove a running '
-            +  'container. Stop the container before attempting removal '
-            + 'or use -f'));
+        callback(
+            new errors.DockerError(
+                new Error(),
+                'Conflict, You cannot remove a running ' +
+                    'container. Stop the container before attempting removal ' +
+                    'or use -f'
+            )
+        );
         return;
     }
 
@@ -3329,82 +3858,111 @@ function deleteContainer(opts, callback) {
     // be that a deletion after it is provisioned, or cancelling the provision
     // and deleting it (i.e. interruptible provision job).
     if (opts.vm.state === 'provisioning') {
-        callback(new errors.DockerError(util.format(
-            'Conflict, cannot currently remove a provisioning '
-            +  'container (id %s).', opts.id)));
+        callback(
+            new errors.DockerError(
+                util.format(
+                    'Conflict, cannot currently remove a provisioning ' +
+                        'container (id %s).',
+                    opts.id
+                )
+            )
+        );
         return;
     }
 
     // Sanity check for deleting a container sharing its volumes.
-    listDockerVms({
-        log: log,
-        req_id: opts.req_id,
-        account: opts.account,
-        vmapi: vmapi,
-        all: true
-    }, function (getvm_err, objects) {
-        if (getvm_err) {
-            callback(getvm_err);
-            return;
-        }
-
-        // NOTE: The only case where we shouldn't have opts.vm.zonepath is when
-        //       the VM is still being provisioned. In which case it shouldn't
-        //       have any other containers using it for --volumes-from.
-        if (opts.vm.filesystems && opts.vm.filesystems.length > 0
-            && opts.vm.zonepath)
+    listDockerVms(
         {
-            data_prefix = path.join(opts.vm.zonepath, 'volumes') + '/';
-            opts.vm.filesystems.forEach(function (f) {
-                if (f.source.substr(0, data_prefix.length) === data_prefix) {
-                    data_volumes.push(f.source);
-                }
-            });
-        }
-        if (data_volumes.length > 0) {
-            log.info({'uuid': opts.vm.uuid, volumes: data_volumes}, 'VM has'
-                + ' local data volumes, checking other containers for '
-                + '--volumes-from');
-            objects.forEach(function (v) {
-                if (v.server_uuid !== opts.vm.server_uuid) {
-                    return;
-                }
-                if (!v.filesystems || v.uuid === opts.vm.uuid) {
-                    return;
-                }
-                v.filesystems.forEach(function (f) {
-                    data_volumes.forEach(function (d) {
-                        if (d === f.source) {
-                            if (volume_users.indexOf(v.alias) === -1) {
-                                volume_users.push(v.alias);
+            log: log,
+            req_id: opts.req_id,
+            account: opts.account,
+            vmapi: vmapi,
+            all: true
+        },
+        function(getvm_err, objects) {
+            if (getvm_err) {
+                callback(getvm_err);
+                return;
+            }
+
+            // NOTE: The only case where we shouldn't have opts.vm.zonepath is when
+            //       the VM is still being provisioned. In which case it shouldn't
+            //       have any other containers using it for --volumes-from.
+            if (
+                opts.vm.filesystems &&
+                opts.vm.filesystems.length > 0 &&
+                opts.vm.zonepath
+            ) {
+                data_prefix = path.join(opts.vm.zonepath, 'volumes') + '/';
+                opts.vm.filesystems.forEach(function(f) {
+                    if (
+                        f.source.substr(0, data_prefix.length) === data_prefix
+                    ) {
+                        data_volumes.push(f.source);
+                    }
+                });
+            }
+            if (data_volumes.length > 0) {
+                log.info(
+                    {uuid: opts.vm.uuid, volumes: data_volumes},
+                    'VM has' +
+                        ' local data volumes, checking other containers for ' +
+                        '--volumes-from'
+                );
+                objects.forEach(function(v) {
+                    if (v.server_uuid !== opts.vm.server_uuid) {
+                        return;
+                    }
+                    if (!v.filesystems || v.uuid === opts.vm.uuid) {
+                        return;
+                    }
+                    v.filesystems.forEach(function(f) {
+                        data_volumes.forEach(function(d) {
+                            if (d === f.source) {
+                                if (volume_users.indexOf(v.alias) === -1) {
+                                    volume_users.push(v.alias);
+                                }
                             }
-                        }
+                        });
                     });
                 });
-            });
-        }
+            }
 
-        if (volume_users.length !== 0) {
-            callback(new errors.DockerError('Error deleting container: '
-                + opts.vm.alias + ' is sharing its volume(s) with '
-                + volume_users.join(', ') + '.'));
-            return;
-        }
+            if (volume_users.length !== 0) {
+                callback(
+                    new errors.DockerError(
+                        'Error deleting container: ' +
+                            opts.vm.alias +
+                            ' is sharing its volume(s) with ' +
+                            volume_users.join(', ') +
+                            '.'
+                    )
+                );
+                return;
+            }
 
-        vmapi.deleteVm(deleteParams, deleteHeaders,
-            function _deleteVmCb(deleteErr, job) {
+            vmapi.deleteVm(deleteParams, deleteHeaders, function _deleteVmCb(
+                deleteErr,
+                job
+            ) {
                 if (deleteErr) {
                     log.error(deleteErr, 'Error deleting container.');
-                    callback(errors.vmapiErrorWrap(deleteErr,
-                        'problem deleting container'));
+                    callback(
+                        errors.vmapiErrorWrap(
+                            deleteErr,
+                            'problem deleting container'
+                        )
+                    );
                     return;
                 } else {
                     log.info({job: job}, 'Container deleted successfully');
 
                     deleteLinks(opts, function onDeleteLinks(delLinksErr) {
                         if (delLinksErr) {
-                            log.error({err: delLinksErr},
-                                'Error when deleting links');
+                            log.error(
+                                {err: delLinksErr},
+                                'Error when deleting links'
+                            );
                         } else {
                             log.debug('Successfully deleted links');
                         }
@@ -3417,13 +3975,12 @@ function deleteContainer(opts, callback) {
                          */
                         callback();
                     });
-
                 }
             });
-    });
+        }
+    );
 }
 
-
 function deleteLink(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
@@ -3443,42 +4000,64 @@ function deleteLink(opts, callback) {
     // container_uuid.
     function onFindLink(err, links) {
         if (err) {
-            log.error('Error finding link for container %s, link %s: %s',
-                    opts.vm.uuid, linkAlias, err);
-            callback(new errors.DockerError(err,
-                    'Unable to find link: ' + opts.vm.alias + '/' + linkAlias));
+            log.error(
+                'Error finding link for container %s, link %s: %s',
+                opts.vm.uuid,
+                linkAlias,
+                err
+            );
+            callback(
+                new errors.DockerError(
+                    err,
+                    'Unable to find link: ' + opts.vm.alias + '/' + linkAlias
+                )
+            );
             return;
         }
         if (!links) {
-            callback(new errors.DockerError(new Error(),
-                    'Unable to find link: ' + opts.vm.alias + '/' + linkAlias));
+            callback(
+                new errors.DockerError(
+                    new Error(),
+                    'Unable to find link: ' + opts.vm.alias + '/' + linkAlias
+                )
+            );
             return;
         }
         // Delete the link(s) found.
-        vasync.forEachParallel({
-            func: function delLink(link, done) {
-                Link.del(opts.app, log, link, done);
+        vasync.forEachParallel(
+            {
+                func: function delLink(link, done) {
+                    Link.del(opts.app, log, link, done);
+                },
+                inputs: links
             },
-            inputs: links
-        }, function onLinksDeleted(delLinksErr) {
-            if (!delLinksErr) {
-                log.debug('Deleted %d link(s) for link name [%s/%s]',
-                    links.length, opts.vm.alias, linkAlias);
-            } else {
-                log.error({err: delLinksErr},
-                    'Error when deleting %d link(s) for link name [%s/%s]',
-                        links.length, opts.vm.alias, linkAlias);
-            }
+            function onLinksDeleted(delLinksErr) {
+                if (!delLinksErr) {
+                    log.debug(
+                        'Deleted %d link(s) for link name [%s/%s]',
+                        links.length,
+                        opts.vm.alias,
+                        linkAlias
+                    );
+                } else {
+                    log.error(
+                        {err: delLinksErr},
+                        'Error when deleting %d link(s) for link name [%s/%s]',
+                        links.length,
+                        opts.vm.alias,
+                        linkAlias
+                    );
+                }
 
-            callback(delLinksErr);
-        });
+                callback(delLinksErr);
+            }
+        );
     }
 
     // Fetch links for this container.
     Link.find(opts.app, log, params, onFindLink);
 }
 
-
 function inspectContainer(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
@@ -3498,67 +4077,90 @@ function inspectContainer(opts, callback) {
     var papi = getPapiClient(opts.app.config.papi);
 
     function _loadFwapiData(cb) {
-        fwapi.getVMrules(opts.vm.uuid, {
-            owner_uuid: opts.vm.owner_uuid
-        }, function _loadedFwrules(err, fwrules) {
-            if (err) {
-                cb(err);
-                return;
+        fwapi.getVMrules(
+            opts.vm.uuid,
+            {
+                owner_uuid: opts.vm.owner_uuid
+            },
+            function _loadedFwrules(err, fwrules) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                opts.log.debug(fwrules, 'firewall rules during inspect');
+                vmData.fwrules = fwrules;
+                cb();
             }
-            opts.log.debug(fwrules, 'firewall rules during inspect');
-            vmData.fwrules = fwrules;
-            cb();
-        });
+        );
     }
 
     // preload the package data so that we can add the com.joyent.package label.
     function _loadPapiData(cb) {
-        var pkgFilter = '(&(active=true)(uuid=' + opts.vm.billing_id + ')'
-            + '(|(owner_uuids=' + opts.vm.owner_uuid + ')(!(owner_uuids=*))))';
-
-        papi.list(pkgFilter, {
-            headers: {'x-request-id': opts.req_id}
-        }, function _loadedPackages(err, pkgs, count) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            opts.log.debug({pkgs: pkgs, vm_uuid: opts.vm.uuid},
-                'packages loaded for inspect');
+        var pkgFilter =
+            '(&(active=true)(uuid=' +
+            opts.vm.billing_id +
+            ')' +
+            '(|(owner_uuids=' +
+            opts.vm.owner_uuid +
+            ')(!(owner_uuids=*))))';
+
+        papi.list(
+            pkgFilter,
+            {
+                headers: {'x-request-id': opts.req_id}
+            },
+            function _loadedPackages(err, pkgs, count) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                opts.log.debug(
+                    {pkgs: pkgs, vm_uuid: opts.vm.uuid},
+                    'packages loaded for inspect'
+                );
+
+                if (count === 1) {
+                    vmData.pkg = {
+                        name: pkgs[0].name,
+                        uuid: pkgs[0].uuid
+                    };
+                } else {
+                    opts.log.error(
+                        {pkgs: pkgs, count: count, vm: opts.vm},
+                        'did not find one package for VM'
+                    );
+                    vmData.pkg = {};
+                }
 
-            if (count === 1) {
-                vmData.pkg = {
-                    name: pkgs[0].name,
-                    uuid: pkgs[0].uuid
-                };
-            } else {
-                opts.log.error({pkgs: pkgs, count: count, vm: opts.vm},
-                    'did not find one package for VM');
-                vmData.pkg = {};
+                cb();
             }
-
-            cb();
-        });
+        );
     }
 
-    vasync.parallel({
-        funcs: [
-            _loadFwapiData,
-            _loadPapiData
-        ]
-    }, function _inspectDataLoaded(err, results) {
-        if (err) {
-            opts.log.error({err: err}, 'failed to preload inspect data');
-            callback(new errors.DockerError(
-                'Unable to load data for container'));
-            return;
+    vasync.parallel(
+        {
+            funcs: [_loadFwapiData, _loadPapiData]
+        },
+        function _inspectDataLoaded(err, results) {
+            if (err) {
+                opts.log.error({err: err}, 'failed to preload inspect data');
+                callback(
+                    new errors.DockerError('Unable to load data for container')
+                );
+                return;
+            }
+            utils.vmobjToInspect(
+                {
+                    clientApiVersion: opts.clientApiVersion,
+                    app: opts.app,
+                    log: opts.log
+                },
+                opts.vm,
+                vmData,
+                callback
+            );
         }
-        utils.vmobjToInspect({
-            clientApiVersion: opts.clientApiVersion,
-            app: opts.app,
-            log: opts.log
-        }, opts.vm, vmData, callback);
-    });
+    );
 }
 
 function psContainer(opts, callback) {
@@ -3569,33 +4171,24 @@ function psContainer(opts, callback) {
 
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
-    var procOpts = { uuid: opts.vm.uuid };
-    var procHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var procOpts = {uuid: opts.vm.uuid};
+    var procHeaders = {headers: {'x-request-id': opts.req_id}};
 
-    vmapi.getVmProc(procOpts, procHeaders, function (getErr, vmproc) {
+    vmapi.getVmProc(procOpts, procHeaders, function(getErr, vmproc) {
         if (getErr) {
             log.error(getErr, 'Error getting container processes.');
-            return callback(errors.cnapiErrorWrap(
-                getErr, null, { id: opts.id }));
+            return callback(errors.cnapiErrorWrap(getErr, null, {id: opts.id}));
         }
 
         // format matches Ubuntu 14.04 + docker 1.3.2
         var psdata = {
-            Titles: [
-                'UID',
-                'PID',
-                'PPID',
-                'C',
-                'STIME',
-                'TTY',
-                'TIME',
-                'CMD'
-            ], Processes: []
+            Titles: ['UID', 'PID', 'PPID', 'C', 'STIME', 'TTY', 'TIME', 'CMD'],
+            Processes: []
         };
 
         log.debug({proc: vmproc, uuid: opts.vm.uuid}, 'container /proc');
 
-        vmproc.forEach(function (p) {
+        vmproc.forEach(function(p) {
             psdata.Processes.push([
                 p.psinfo.pr_euid.toString(),
                 p.psinfo.pr_pid.toString(),
@@ -3621,11 +4214,11 @@ function waitContainer(opts, callback) {
     var log = opts.log || this.log;
     var vmapi = opts.app.vmapi;
 
-    var waitHeaders = { headers: { 'x-request-id': opts.req_id } };
-    var waitOpts = { uuid: opts.vm.uuid };
+    var waitHeaders = {headers: {'x-request-id': opts.req_id}};
+    var waitOpts = {uuid: opts.vm.uuid};
 
     function waitVm() {
-        vmapi.getVm(waitOpts, waitHeaders, function (getErr, vm) {
+        vmapi.getVm(waitOpts, waitHeaders, function(getErr, vm) {
             if (getErr) {
                 log.error(getErr, 'Error getting container.');
                 return callback(getErr);
@@ -3640,7 +4233,6 @@ function waitContainer(opts, callback) {
     waitVm();
 }
 
-
 // These are the params passed given the CLI options:
 //
 // exec -i:
@@ -3669,7 +4261,7 @@ function execContainer(opts, callback) {
     assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.account, 'opts.account');
 
-    _runCreateSocket(opts, function (err, cmdId, socketData) {
+    _runCreateSocket(opts, function(err, cmdId, socketData) {
         if (err) {
             callback(err);
             return;
@@ -3680,7 +4272,6 @@ function execContainer(opts, callback) {
     });
 }
 
-
 function execStart(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
@@ -3691,7 +4282,7 @@ function execStart(opts, callback) {
     assert.object(opts.account, 'opts.account');
     assert.object(opts.socket, 'opts.socket');
 
-    _runExec(opts, function (err, socketData) {
+    _runExec(opts, function(err, socketData) {
         if (err) {
             callback(err);
             return;
@@ -3702,7 +4293,6 @@ function execStart(opts, callback) {
     });
 }
 
-
 function _runCreateSocket(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
@@ -3714,38 +4304,40 @@ function _runCreateSocket(opts, callback) {
     var log = opts.log;
     var payload = opts.payload;
 
-    dockerExec({
-        log: log,
-        id: opts.id,
-        payload: payload,
-        req_id: opts.req_id,
-        cnapi: opts.app.cnapi,
-        vm: opts.vm
-    }, function (execErr, obj) {
-        if (execErr) {
-            callback(execErr);
-            return;
-        }
+    dockerExec(
+        {
+            log: log,
+            id: opts.id,
+            payload: payload,
+            req_id: opts.req_id,
+            cnapi: opts.app.cnapi,
+            vm: opts.vm
+        },
+        function(execErr, obj) {
+            if (execErr) {
+                callback(execErr);
+                return;
+            }
 
-        var cmdId = common.generateDockerId();
-        var socketData = { command: payload };
+            var cmdId = common.generateDockerId();
+            var socketData = {command: payload};
 
-        // When -d is passed, we don't need to connect to any TCP
-        // server afterwards
-        if (payload.Detach) {
-            callback(null, cmdId, socketData);
-            return;
-        }
+            // When -d is passed, we don't need to connect to any TCP
+            // server afterwards
+            if (payload.Detach) {
+                callback(null, cmdId, socketData);
+                return;
+            }
 
-        // Stash the address of the temporary TCP server
-        socketData.host = obj.host;
-        socketData.port = obj.port;
+            // Stash the address of the temporary TCP server
+            socketData.host = obj.host;
+            socketData.port = obj.port;
 
-        callback(null, cmdId, socketData);
-    });
+            callback(null, cmdId, socketData);
+        }
+    );
 }
 
-
 var STREAM_TYPES = {
     stdin: 0,
     stdout: 1,
@@ -3769,7 +4361,6 @@ function _encodeToDockerRawStream(type, data) {
     return message;
 }
 
-
 /**
  * This lstream parser allows sdc-docker to parse any message coming from
  * the transient cn-agent sockets.
@@ -3782,17 +4373,17 @@ function _createLinestreamParser(opts, toSocket) {
     assert.optionalBool(opts.noCloseOnSocketEnd, 'noCloseOnSocketEnd');
     assert.object(toSocket, 'toSocket');
 
-    var encodeData = !(opts.doNotEncodeData);
-    var lstream = new LineStream({ encoding: 'utf8' });
-    lstream.on('error', function (err) {
-        opts.log.error({ err: err }, 'LineStream threw an error');
+    var encodeData = !opts.doNotEncodeData;
+    var lstream = new LineStream({encoding: 'utf8'});
+    lstream.on('error', function(err) {
+        opts.log.error({err: err}, 'LineStream threw an error');
     });
 
     /**
      * Ensure the lstream instance does not hit its high watermark and stop
      * emitting 'line' events.
      */
-    lstream.on('readable', function () {
+    lstream.on('readable', function() {
         var line;
         while ((line = lstream.read()) != null) {
             line = line.trim();
@@ -3801,7 +4392,8 @@ function _createLinestreamParser(opts, toSocket) {
             } catch (e) {
                 opts.log.error(
                     '_createLinestreamParser: invalid json: %s - ignoring',
-                    data);
+                    data
+                );
                 continue;
             }
 
@@ -3812,7 +4404,8 @@ function _createLinestreamParser(opts, toSocket) {
                 if (!opts.noCloseOnSocketEnd) {
                     toSocket.end();
                 }
-            } else { // else stderr or stdout
+            } else {
+                // else stderr or stdout
                 var data = parsed.data;
                 if (encodeData) {
                     data = _encodeToDockerRawStream(parsed.type, parsed.data);
@@ -3825,7 +4418,6 @@ function _createLinestreamParser(opts, toSocket) {
     return lstream;
 }
 
-
 function _runExec(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
@@ -3844,7 +4436,7 @@ function _runExec(opts, callback) {
     var clientSocket = opts.socket;
 
     var cmdString = socketData.command.Cmd.join(' ');
-    var serverSocket = net.createConnection({ host: host, port: port });
+    var serverSocket = net.createConnection({host: host, port: port});
 
     // Store a reference to the exec socket for future resizes
     socketData.socket = serverSocket;
@@ -3860,17 +4452,21 @@ function _runExec(opts, callback) {
     }
 
     function writeEnd(stream, writeCb) {
-        var data = JSON.stringify({
-            type: 'end'
-        }) + '\r\n';
+        var data =
+            JSON.stringify({
+                type: 'end'
+            }) + '\r\n';
 
         stream.write(data, writeCb);
     }
 
     function _endSocket(error) {
         if (error) {
-            opts.log.error('client socket %s threw an error %s',
-                cmdString, error.toString());
+            opts.log.error(
+                'client socket %s threw an error %s',
+                cmdString,
+                error.toString()
+            );
         }
         serverSocket.end();
         cb(error, socketData);
@@ -3882,15 +4478,18 @@ function _runExec(opts, callback) {
 
     // error can happen before connect too (eg. ECONNREFUSED)
     serverSocket.on('error', function _onServerSocketError(error) {
-        opts.log.error('serverSocket for %s threw an error %s',
-            cmdString, error.toString());
+        opts.log.error(
+            'serverSocket for %s threw an error %s',
+            cmdString,
+            error.toString()
+        );
 
         cb(error);
     });
 
     function setupListeners() {
         if (socketData.command.AttachStdin) {
-            clientSocket.on('data', function (chunk) {
+            clientSocket.on('data', function(chunk) {
                 var type = socketData.command.Tty ? 'tty' : 'stdin';
                 writeData(serverSocket, {
                     type: type,
@@ -3899,9 +4498,9 @@ function _runExec(opts, callback) {
             });
         }
 
-        clientSocket.on('end', function () {
+        clientSocket.on('end', function() {
             if (!serverSocket.destroyed) {
-                writeEnd(serverSocket, function () {
+                writeEnd(serverSocket, function() {
                     opts.log.info('clientSocket has closed its stdin');
                 });
             }
@@ -3910,26 +4509,31 @@ function _runExec(opts, callback) {
         clientSocket.on('error', endSocket);
         clientSocket.on('timeout', endSocket);
 
-        serverSocket.on('close', function (had_error) {
-            opts.log.debug('serverSocket %s closed, had_error=%s',
-                cmdString, had_error);
+        serverSocket.on('close', function(had_error) {
+            opts.log.debug(
+                'serverSocket %s closed, had_error=%s',
+                cmdString,
+                had_error
+            );
 
             endSocket();
         });
 
-        serverSocket.on('end', function () {
+        serverSocket.on('end', function() {
             opts.log.debug('serverSocket %s end', cmdString);
         });
 
-        var lstream = _createLinestreamParser({
-            log: opts.log,
-            socketData: socketData
-        }, clientSocket);
+        var lstream = _createLinestreamParser(
+            {
+                log: opts.log,
+                socketData: socketData
+            },
+            clientSocket
+        );
         serverSocket.pipe(lstream);
     }
 }
 
-
 function _runAttach(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
@@ -3953,11 +4557,14 @@ function _runAttach(opts, callback) {
 
     var serverSocket = socketData.socket;
     if (!serverSocket) {
-        serverSocket = net.createConnection({ host: host, port: port });
+        serverSocket = net.createConnection({host: host, port: port});
         serverSocket.on('connect', setupListeners);
-        serverSocket.on('error', function (error) {
-            opts.log.debug('attach for %s threw an error %',
-                cmdString, error.toString());
+        serverSocket.on('error', function(error) {
+            opts.log.debug(
+                'attach for %s threw an error %',
+                cmdString,
+                error.toString()
+            );
 
             cb(error);
         });
@@ -3983,9 +4590,10 @@ function _runAttach(opts, callback) {
         }
 
         function writeEnd(stream, writeCb) {
-            var data = JSON.stringify({
-                type: 'end'
-            }) + '\r\n';
+            var data =
+                JSON.stringify({
+                    type: 'end'
+                }) + '\r\n';
 
             stream.write(data, writeCb);
         }
@@ -3994,27 +4602,36 @@ function _runAttach(opts, callback) {
         // if defined outside of this scope
         function _endSocket(error) {
             if (error) {
-                opts.log.error('client socket %s threw an error %s',
-                    cmdString, error.toString());
+                opts.log.error(
+                    'client socket %s threw an error %s',
+                    cmdString,
+                    error.toString()
+                );
                 serverSocket.end();
                 cb(error);
                 return;
             }
-            waitContainer({
-                account: opts.account,
-                app: opts.app,
-                log: opts.log,
-                req_id: opts.req_id,
-                vm: opts.vm
-            }, function (err, statusCode) {
-                if (err) {
-                    opts.log.error(err, 'error waiting for container to stop');
-                    lstream.end();
-                    return;
+            waitContainer(
+                {
+                    account: opts.account,
+                    app: opts.app,
+                    log: opts.log,
+                    req_id: opts.req_id,
+                    vm: opts.vm
+                },
+                function(err, statusCode) {
+                    if (err) {
+                        opts.log.error(
+                            err,
+                            'error waiting for container to stop'
+                        );
+                        lstream.end();
+                        return;
+                    }
+                    serverSocket.end();
+                    cb(error);
                 }
-                serverSocket.end();
-                cb(error);
-            });
+            );
         }
 
         var endSocket = once(_endSocket);
@@ -4035,15 +4652,19 @@ function _runAttach(opts, callback) {
             var resizeData = opts.app.sockets.popResize(opts.id);
 
             if (resizeData) {
-                writeData(serverSocket, {
-                    type: 'tty',
-                    resize: resizeData
-                }, function () {
-                    writeData(serverSocket, {
+                writeData(
+                    serverSocket,
+                    {
                         type: 'tty',
-                        data: chunk.toString()
-                    });
-                });
+                        resize: resizeData
+                    },
+                    function() {
+                        writeData(serverSocket, {
+                            type: 'tty',
+                            data: chunk.toString()
+                        });
+                    }
+                );
             } else {
                 writeData(serverSocket, {
                     type: 'tty',
@@ -4056,8 +4677,8 @@ function _runAttach(opts, callback) {
             clientSocket.on('data', onData);
         }
 
-        clientSocket.on('end', function () {
-            writeEnd(serverSocket, function () {
+        clientSocket.on('end', function() {
+            writeEnd(serverSocket, function() {
                 opts.log.info('clientSocket has closed its stdin');
             });
         });
@@ -4065,28 +4686,33 @@ function _runAttach(opts, callback) {
         clientSocket.on('error', endSocket);
         clientSocket.on('timeout', endSocket);
 
-        serverSocket.on('close', function (had_error) {
-            opts.log.debug('attach %s closed, had_error=%s',
-                cmdString, had_error);
+        serverSocket.on('close', function(had_error) {
+            opts.log.debug(
+                'attach %s closed, had_error=%s',
+                cmdString,
+                had_error
+            );
 
             endSocket();
         });
 
-        serverSocket.on('end', function () {
+        serverSocket.on('end', function() {
             opts.log.debug('attach %s end', cmdString);
         });
 
-        var lstream = _createLinestreamParser({
-            doNotEncodeData: opts.doNotEncodeData,
-            noCloseOnSocketEnd: true,
-            log: opts.log,
-            socketData: socketData
-        }, clientSocket);
+        var lstream = _createLinestreamParser(
+            {
+                doNotEncodeData: opts.doNotEncodeData,
+                noCloseOnSocketEnd: true,
+                log: opts.log,
+                socketData: socketData
+            },
+            clientSocket
+        );
         serverSocket.pipe(lstream);
     }
 }
 
-
 function execResize(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
@@ -4097,15 +4723,15 @@ function execResize(opts, callback) {
     assert.number(opts.h, 'opts.h');
 
     var socket = opts.socketData.socket;
-    var data = JSON.stringify({
-        type: 'tty',
-        resize: { w: opts.w, h: opts.h }
-    }) + '\r\n';
+    var data =
+        JSON.stringify({
+            type: 'tty',
+            resize: {w: opts.w, h: opts.h}
+        }) + '\r\n';
 
     socket.write(data, callback);
 }
 
-
 /*
  * attachContainer resuses _runAttach and _runCreateSocket
  */
@@ -4124,13 +4750,12 @@ function attachContainer(opts, callback) {
     var log = opts.log;
     var socketData = opts.app.sockets.getSocket('attach', opts.id);
 
-    vasync.pipeline({
-        funcs: [
-            createSocket,
-            attach
-        ]
-    }, callback);
-
+    vasync.pipeline(
+        {
+            funcs: [createSocket, attach]
+        },
+        callback
+    );
 
     function createSocket(_, next) {
         if (socketData) {
@@ -4139,7 +4764,7 @@ function attachContainer(opts, callback) {
             return;
         }
 
-        _runCreateSocket(opts, function (err, cmdId, data) {
+        _runCreateSocket(opts, function(err, cmdId, data) {
             if (err) {
                 log.error({err: err}, 'backend.attachContainer error');
                 next(err);
@@ -4152,7 +4777,7 @@ function attachContainer(opts, callback) {
     }
 
     function attach(_, next) {
-        _runAttach(opts, function (execErr) {
+        _runAttach(opts, function(execErr) {
             // Cleanup regardless of the error
             opts.app.sockets.removeSocket('attach', opts.id);
             opts.socket.end();
@@ -4168,7 +4793,6 @@ function attachContainer(opts, callback) {
     }
 }
 
-
 /*
  * Rename a container.
  */
@@ -4179,33 +4803,38 @@ function renameContainer(opts, callback) {
     assert.object(opts.account, 'opts.account');
 
     if (!utils.isValidDockerConatinerName(opts.name)) {
-        callback(new errors.DockerError(
-                'Error when allocating new name: Invalid container name ('
-                + opts.name + ')'));
+        callback(
+            new errors.DockerError(
+                'Error when allocating new name: Invalid container name (' +
+                    opts.name +
+                    ')'
+            )
+        );
         return;
     }
 
     var log = opts.log;
     var vmapi = opts.app.vmapi;
 
-    var renameHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var renameHeaders = {headers: {'x-request-id': opts.req_id}};
     var renameParams = {
-        uuid : opts.vm.uuid,
-        owner_uuid : opts.account.uuid,
-        sync : true,
-        payload : {
-            'alias': opts.name
+        uuid: opts.vm.uuid,
+        owner_uuid: opts.account.uuid,
+        sync: true,
+        payload: {
+            alias: opts.name
         }
     };
 
     log.debug({renameParams: renameParams}, 'rename parameters');
     renameParams.log = log;
 
-    vmapi.updateVm(renameParams, renameHeaders, function (rename_err, job) {
+    vmapi.updateVm(renameParams, renameHeaders, function(rename_err, job) {
         if (rename_err) {
             log.error(rename_err, 'Error renaming container.');
-            callback(errors.vmapiErrorWrap(rename_err,
-                            'problem renaming container'));
+            callback(
+                errors.vmapiErrorWrap(rename_err, 'problem renaming container')
+            );
             return;
         }
 
@@ -4216,7 +4845,6 @@ function renameContainer(opts, callback) {
     });
 }
 
-
 /*
  * Resize a container TTY.
  *
@@ -4231,11 +4859,10 @@ function resizeContainer(opts, callback) {
     assert.number(opts.w, 'opts.w');
     assert.number(opts.h, 'opts.h');
 
-    opts.app.sockets.pushResize(opts.id, { w: opts.w, h: opts.h });
+    opts.app.sockets.pushResize(opts.id, {w: opts.w, h: opts.h});
     callback();
 }
 
-
 /*
  * containerLogs resuses _runExec and _runCreateSocket
  */
@@ -4250,7 +4877,7 @@ function containerLogs(opts, callback) {
 
     var log = opts.log;
 
-    _runCreateSocket(opts, function (err, cmdId, socketData) {
+    _runCreateSocket(opts, function(err, cmdId, socketData) {
         if (err) {
             log.error({err: err}, 'backend.containerLogs error');
             callback(err);
@@ -4260,7 +4887,7 @@ function containerLogs(opts, callback) {
         opts.cmdId = cmdId;
         opts.socketData = socketData;
 
-        _runExec(opts, function (execErr) {
+        _runExec(opts, function(execErr) {
             opts.socket.end();
 
             if (execErr) {
@@ -4274,7 +4901,6 @@ function containerLogs(opts, callback) {
     });
 }
 
-
 function dockerExec(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.payload, 'opts.payload');
@@ -4285,36 +4911,50 @@ function dockerExec(opts, callback) {
     var e;
     var log = opts.log;
     var cnapi = opts.cnapi;
-    var execHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var execHeaders = {headers: {'x-request-id': opts.req_id}};
 
     if (!opts.vm || !opts.vm.uuid) {
         e = new errors.DockerError(new Error(), 'VM is still provisioning');
-        log.error({vm: opts.vm, err: e},
-            'dockerExec() called with missing VM parameters');
+        log.error(
+            {vm: opts.vm, err: e},
+            'dockerExec() called with missing VM parameters'
+        );
         callback(e);
         return;
     } else if (!opts.vm.server_uuid) {
         e = new errors.DockerError(new Error(), 'VM is still provisioning');
-        log.error({vm: opts.vm, err: e},
-            'dockerExec() called with missing VM server_uuid');
+        log.error(
+            {vm: opts.vm, err: e},
+            'dockerExec() called with missing VM server_uuid'
+        );
         callback(e);
         return;
     }
 
-    cnapi.dockerExec(opts.vm.server_uuid, opts.vm.uuid, {
-        command: opts.payload
-    }, execHeaders, function _execCb(execErr, res) {
-        if (execErr) {
-            log.error(execErr, 'Error calling docker-exec');
-            return callback(errors.cnapiErrorWrap(
-                execErr, 'problem executing command', { id: opts.id }));
-        }
+    cnapi.dockerExec(
+        opts.vm.server_uuid,
+        opts.vm.uuid,
+        {
+            command: opts.payload
+        },
+        execHeaders,
+        function _execCb(execErr, res) {
+            if (execErr) {
+                log.error(execErr, 'Error calling docker-exec');
+                return callback(
+                    errors.cnapiErrorWrap(
+                        execErr,
+                        'problem executing command',
+                        {id: opts.id}
+                    )
+                );
+            }
 
-        return callback(null, res);
-    });
+            return callback(null, res);
+        }
+    );
 }
 
-
 function copyContainer(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
@@ -4326,24 +4966,26 @@ function copyContainer(opts, callback) {
     var log = opts.log;
     var payload = opts.payload;
 
-    dockerCopy({
-        log: log,
-        payload: payload,
-        req_id: opts.req_id,
-        account: opts.account,
-        cnapi: opts.app.cnapi,
-        vm: opts.vm
-    }, function (copyErr, stream) {
-        if (copyErr) {
-            callback(copyErr);
-            return;
-        }
+    dockerCopy(
+        {
+            log: log,
+            payload: payload,
+            req_id: opts.req_id,
+            account: opts.account,
+            cnapi: opts.app.cnapi,
+            vm: opts.vm
+        },
+        function(copyErr, stream) {
+            if (copyErr) {
+                callback(copyErr);
+                return;
+            }
 
-        callback(null, stream);
-    });
+            callback(null, stream);
+        }
+    );
 }
 
-
 function dockerCopy(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.payload, 'opts.payload');
@@ -4354,34 +4996,41 @@ function dockerCopy(opts, callback) {
 
     var log = opts.log;
     var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var copyHeaders = {headers: {'x-request-id': opts.req_id}};
 
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        payload: opts.payload,
-        mode: 'read'
-    }, copyHeaders, onCopy);
+    cnapi.dockerCopy(
+        opts.vm.server_uuid,
+        opts.vm.uuid,
+        {
+            payload: opts.payload,
+            mode: 'read'
+        },
+        copyHeaders,
+        onCopy
+    );
 
     function onCopy(copyErr, res) {
         if (copyErr) {
             if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
+                return callback(
+                    new errors.NotImplementedError('copy on stopped container')
+                );
             }
             log.error(copyErr, 'error calling docker-copy');
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
+            return callback(
+                errors.cnapiErrorWrap(copyErr, 'problem calling docker copy')
+            );
         }
 
         var host = res.host;
         var port = res.port;
 
-        var copySocket = net.createConnection({ host: host, port: port });
+        var copySocket = net.createConnection({host: host, port: port});
 
         callback(null, copySocket);
     }
 }
 
-
 /**
  * Sends a task to the cn-agent on a compute node which starts a TCP server on
  * the compute node and then returns to us the server's address and port. We
@@ -4398,35 +5047,43 @@ function containerArchiveReadStream(opts, callback) {
 
     var log = opts.log;
     var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var copyHeaders = {headers: {'x-request-id': opts.req_id}};
 
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        path: opts.path,
-        mode: 'read'
-    }, copyHeaders, onCopy);
+    cnapi.dockerCopy(
+        opts.vm.server_uuid,
+        opts.vm.uuid,
+        {
+            path: opts.path,
+            mode: 'read'
+        },
+        copyHeaders,
+        onCopy
+    );
 
     function onCopy(copyErr, res) {
         if (copyErr) {
             log.error(copyErr, 'error calling docker-copy');
             if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
+                return callback(
+                    new errors.NotImplementedError('copy on stopped container')
+                );
             }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
+            return callback(
+                errors.cnapiErrorWrap(copyErr, 'problem calling docker copy')
+            );
         }
 
         var host = res.host;
         var port = res.port;
 
-        var copySocket = net.createConnection({ host: host, port: port });
+        var copySocket = net.createConnection({host: host, port: port});
 
         callback(null, copySocket, {
-            containerPathStat: res.containerPathStat });
+            containerPathStat: res.containerPathStat
+        });
     }
 }
 
-
 /**
  * Sends a task to the cn-agent on a compute node which starts a TCP server on
  * the compute node and then returns to us the server's address and port. We
@@ -4442,7 +5099,7 @@ function containerArchiveWriteStream(opts, callback) {
 
     var log = opts.log;
     var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var copyHeaders = {headers: {'x-request-id': opts.req_id}};
 
     var copyOpts = {
         path: opts.path,
@@ -4454,29 +5111,35 @@ function containerArchiveWriteStream(opts, callback) {
     }
 
     cnapi.dockerCopy(
-        opts.vm.server_uuid, opts.vm.uuid, copyOpts, copyHeaders, onCopy);
+        opts.vm.server_uuid,
+        opts.vm.uuid,
+        copyOpts,
+        copyHeaders,
+        onCopy
+    );
 
     function onCopy(copyErr, res) {
         if (copyErr) {
             log.error(copyErr, 'error calling docker-copy');
             if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
+                return callback(
+                    new errors.NotImplementedError('copy on stopped container')
+                );
             }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
+            return callback(
+                errors.cnapiErrorWrap(copyErr, 'problem calling docker copy')
+            );
         }
 
         var host = res.host;
         var port = res.port;
 
-        var copySocket = net.createConnection({ host: host, port: port });
+        var copySocket = net.createConnection({host: host, port: port});
 
         callback(null, copySocket);
     }
 }
 
-
 /**
  * Sends a task to cn-agent on a server and have it stat a file within the
  * container.
@@ -4492,29 +5155,36 @@ function containerArchiveStat(opts, callback) {
 
     var log = opts.log;
     var cnapi = opts.cnapi;
-    var copyHeaders = { headers: { 'x-request-id': opts.req_id } };
+    var copyHeaders = {headers: {'x-request-id': opts.req_id}};
 
-    cnapi.dockerCopy(opts.vm.server_uuid, opts.vm.uuid, {
-        path: opts.path,
-        mode: 'stat'
-    }, copyHeaders, onCopy);
+    cnapi.dockerCopy(
+        opts.vm.server_uuid,
+        opts.vm.uuid,
+        {
+            path: opts.path,
+            mode: 'stat'
+        },
+        copyHeaders,
+        onCopy
+    );
 
     function onCopy(copyErr, res) {
         if (copyErr) {
             log.error(copyErr, 'error calling docker-copy');
             if (copyErr.restCode === 'VmNotRunning') {
-                return callback(new errors.NotImplementedError(
-                    'copy on stopped container'));
+                return callback(
+                    new errors.NotImplementedError('copy on stopped container')
+                );
             }
-            return callback(errors.cnapiErrorWrap(
-                copyErr, 'problem calling docker copy'));
+            return callback(
+                errors.cnapiErrorWrap(copyErr, 'problem calling docker copy')
+            );
         }
 
-        callback(null, { containerPathStat: res.containerPathStat });
+        callback(null, {containerPathStat: res.containerPathStat});
     }
 }
 
-
 function containerStats(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
@@ -4524,29 +5194,35 @@ function containerStats(opts, callback) {
 
     var log = opts.log;
     var cnapi = opts.app.cnapi;
-    var headers = { headers: { 'x-request-id': opts.req_id } };
+    var headers = {headers: {'x-request-id': opts.req_id}};
 
-    cnapi.dockerStats(opts.vm.server_uuid, opts.vm.uuid, {
-        payload: opts.payload
-    }, headers, function (err, res) {
-        if (err) {
-            log.error(err, 'error calling docker-stats');
-            return callback(errors.cnapiErrorWrap(
-                err, 'problem calling docker stats'));
-        }
+    cnapi.dockerStats(
+        opts.vm.server_uuid,
+        opts.vm.uuid,
+        {
+            payload: opts.payload
+        },
+        headers,
+        function(err, res) {
+            if (err) {
+                log.error(err, 'error calling docker-stats');
+                return callback(
+                    errors.cnapiErrorWrap(err, 'problem calling docker stats')
+                );
+            }
 
-        var host = res.host;
-        var port = res.port;
+            var host = res.host;
+            var port = res.port;
 
-        log.debug('containerStats server on host: ', host, 'port: ', port);
+            log.debug('containerStats server on host: ', host, 'port: ', port);
 
-        var statsSocket = net.createConnection({ host: host, port: port });
+            var statsSocket = net.createConnection({host: host, port: port});
 
-        callback(null, statsSocket);
-    });
+            callback(null, statsSocket);
+        }
+    );
 }
 
-
 module.exports = {
     attachContainer: attachContainer,
     containerLogs: containerLogs,
diff --git a/lib/backends/sdc/images.js b/lib/backends/sdc/images.js
index 81eb54e..4867bec 100644
--- a/lib/backends/sdc/images.js
+++ b/lib/backends/sdc/images.js
@@ -53,8 +53,6 @@ var ImageTag = require('../../models/image-tag');
 var errors = require('../../../lib/errors');
 var utils = require('./utils');
 
-
-
 //---- globals
 
 var _vmapiClientCache; // set in `getVmapiClient`
@@ -70,7 +68,6 @@ function getVmapiClient(config) {
     return _vmapiClientCache;
 }
 
-
 /**
  * Convert a docker image json layer (as given from docker hub) into a
  * sdc-docker Image model structure.
@@ -91,14 +88,14 @@ function dockerImageJsonToModel(imageJson, opts) {
         comment: imageJson.comment || '',
         created: new Date(imageJson.created).getTime(),
         docker_id: imageJson.id,
-        head: (opts.head || false),
-        heads: (opts.heads || []),
+        head: opts.head || false,
+        heads: opts.heads || [],
         image_uuid: opts.image_uuid,
         index_name: opts.index_name,
         owner_uuid: opts.owner_uuid,
         private: true,
-        size: (opts.size || 0),
-        virtual_size: (opts.virtual_size || 0)
+        size: opts.size || 0,
+        virtual_size: opts.virtual_size || 0
     };
 
     if (imageJson.comment) {
@@ -117,7 +114,6 @@ function dockerImageJsonToModel(imageJson, opts) {
     return modelObj;
 }
 
-
 /**
  * Get all the images available to the given account.
  *
@@ -162,14 +158,14 @@ function listImages(opts, callback) {
     }
     funcs.push(listDockerImages);
 
-    vasync.parallel({funcs: funcs}, function (err) {
+    vasync.parallel({funcs: funcs}, function(err) {
         if (err) {
             callback(err);
             return;
         }
 
         // Images are sorted newest (0) to oldest (n).
-        dockerImages.sort(function (entry1, entry2) {
+        dockerImages.sort(function(entry1, entry2) {
             return entry2.Created - entry1.Created;
         });
 
@@ -183,44 +179,49 @@ function listImages(opts, callback) {
             state: 'active'
         };
 
-        app.imgapi.listImages(filters, {
-            headers: {'x-request-id': opts.req_id}
-        }, function (err, images) {
-            var results = [];
+        app.imgapi.listImages(
+            filters,
+            {
+                headers: {'x-request-id': opts.req_id}
+            },
+            function(err, images) {
+                var results = [];
 
-            if (err) {
-                next(err);
-                return;
-            }
+                if (err) {
+                    next(err);
+                    return;
+                }
 
-            images.forEach(function (img) {
-                var dockerImage = {};
-                var origin = img.origin || '';
-
-                dockerImage.RepoTags = [img.uuid];
-                dockerImage.Id = (img.uuid + img.uuid).replace(/-/g, '');
-                dockerImage.ParentId = (origin + origin).replace(/-/g, '');
-                dockerImage.Created = Math.floor((new Date(img.published_at))
-                    .getTime() / 1000);
-                // Note: Slightly different semantics. This is showing the
-                // (possibly compressed) image file size. Good enough.
-                dockerImage.Size = img.files[0].size;
-                // Note: this doesn't handle ancestry size.
-                dockerImage.VirtualSize = img.files[0].size;
-
-                results.push(dockerImage);
-            });
+                images.forEach(function(img) {
+                    var dockerImage = {};
+                    var origin = img.origin || '';
+
+                    dockerImage.RepoTags = [img.uuid];
+                    dockerImage.Id = (img.uuid + img.uuid).replace(/-/g, '');
+                    dockerImage.ParentId = (origin + origin).replace(/-/g, '');
+                    dockerImage.Created = Math.floor(
+                        new Date(img.published_at).getTime() / 1000
+                    );
+                    // Note: Slightly different semantics. This is showing the
+                    // (possibly compressed) image file size. Good enough.
+                    dockerImage.Size = img.files[0].size;
+                    // Note: this doesn't handle ancestry size.
+                    dockerImage.VirtualSize = img.files[0].size;
+
+                    results.push(dockerImage);
+                });
 
-            log.trace({imgs: results}, 'listImages: listSmartOSImages');
-            dockerImages = dockerImages.concat(results);
-            next();
-        });
+                log.trace({imgs: results}, 'listImages: listSmartOSImages');
+                dockerImages = dockerImages.concat(results);
+                next();
+            }
+        );
     }
 
     function imageFilter(img) {
         var isMatch = true;
 
-        Object.keys(imageFilters).forEach(function (field) {
+        Object.keys(imageFilters).forEach(function(field) {
             var val = imageFilters[field];
             log.debug('filtering image on field ' + field + ', value ' + val);
             if (field === 'dangling') {
@@ -235,22 +236,27 @@ function listImages(opts, callback) {
                 // check if image matches *all* of the requested values.
                 var imgLabelsObj = img.config.Labels || {};
                 var imgLabelNames = Object.keys(imgLabelsObj);
-                if (!val.every(function (wantedLabelData) {
-                    // wantedLabelData is in format 'key=value'
-                    var split = wantedLabelData.split('=', 2);
-                    var wantedLabel = split[0];
-                    var wantedValue = split[1];
-                    return imgLabelNames.some(function (imgLabelName) {
-                        return imgLabelName === wantedLabel
-                                && imgLabelsObj[imgLabelName] === wantedValue;
-                    });
-                })) {
+                if (
+                    !val.every(function(wantedLabelData) {
+                        // wantedLabelData is in format 'key=value'
+                        var split = wantedLabelData.split('=', 2);
+                        var wantedLabel = split[0];
+                        var wantedValue = split[1];
+                        return imgLabelNames.some(function(imgLabelName) {
+                            return (
+                                imgLabelName === wantedLabel &&
+                                imgLabelsObj[imgLabelName] === wantedValue
+                            );
+                        });
+                    })
+                ) {
                     isMatch = false;
                 }
             } else {
                 log.warn('Unhandled image filter name:', field);
-                throw new errors.DockerError(format(
-                            'Invalid filter \'%s\'', field));
+                throw new errors.DockerError(
+                    format("Invalid filter '%s'", field)
+                );
             }
         });
 
@@ -258,14 +264,14 @@ function listImages(opts, callback) {
     }
 
     function listDockerImages(next) {
-        var params = { owner_uuid: opts.account.uuid };
+        var params = {owner_uuid: opts.account.uuid};
         var results = [];
 
         if (!opts.all) {
             params.head = true;
         }
 
-        Image.list(app, log, params, function (err, imgs) {
+        Image.list(app, log, params, function(err, imgs) {
             if (err) {
                 next(err);
                 return;
@@ -273,7 +279,7 @@ function listImages(opts, callback) {
 
             // Filter images when requested by the client.
             if (!common.objEmpty(imageFilters)) {
-                log.debug({ 'imageFilters': imageFilters}, 'filtering images');
+                log.debug({imageFilters: imageFilters}, 'filtering images');
                 try {
                     imgs = imgs.filter(imageFilter);
                 } catch (e) {
@@ -282,22 +288,24 @@ function listImages(opts, callback) {
                 }
             }
 
-            vasync.forEachParallel({
-                func: getTags,
-                inputs: imgs
-            }, function (getErr) {
-                if (getErr) {
-                    next(getErr);
-                    return;
-                }
+            vasync.forEachParallel(
+                {
+                    func: getTags,
+                    inputs: imgs
+                },
+                function(getErr) {
+                    if (getErr) {
+                        next(getErr);
+                        return;
+                    }
 
-                log.trace({imgs: results}, 'listImages: listDockerImages');
-                dockerImages = dockerImages.concat(results);
-                next();
-            });
+                    log.trace({imgs: results}, 'listImages: listDockerImages');
+                    dockerImages = dockerImages.concat(results);
+                    next();
+                }
+            );
         });
 
-
         function pushImage(img, repoTags) {
             assert.optionalArrayOfString(repoTags, 'repoTags');
 
@@ -305,12 +313,12 @@ function listImages(opts, callback) {
             // is the config for the container that created the image.
             var imgConfig = img.config || {};
             var dockerImage = {
-                RepoTags: (repoTags && repoTags.length
-                    ? repoTags : ['<none>:<none>']),
+                RepoTags: repoTags && repoTags.length
+                    ? repoTags
+                    : ['<none>:<none>'],
                 Id: img.docker_id,
                 IndexName: img.index_name,
-                Created: Math.floor((new Date(img.created))
-                            .getTime() / 1000),
+                Created: Math.floor(new Date(img.created).getTime() / 1000),
                 Cmd: imgConfig.Cmd,
                 Env: imgConfig.Env,
                 Entrypoint: imgConfig.Entrypoint,
@@ -341,13 +349,13 @@ function listImages(opts, callback) {
                 index_name: img.index_name,
                 docker_id: img.docker_id
             };
-            ImageTag.list(app, log, getParams, function (err, imgTag) {
+            ImageTag.list(app, log, getParams, function(err, imgTag) {
                 if (err) {
                     cb(err);
                     return;
                 }
                 if (imgTag) {
-                    var repoTags = imgTag.map(function (it) {
+                    var repoTags = imgTag.map(function(it) {
                         return it.repo + ':' + it.tag;
                     });
                     pushImage(serialized, repoTags);
@@ -360,7 +368,6 @@ function listImages(opts, callback) {
     }
 }
 
-
 /**
  * Gets an image -- an Image model object -- from (account, indexName, imgId).
  *
@@ -383,14 +390,20 @@ function imgFromImgInfo(opts, callback) {
         index_name: opts.indexName,
         docker_id: opts.imgId
     };
-    Image.list(opts.app, opts.log, filter, function (err, imgs) {
+    Image.list(opts.app, opts.log, filter, function(err, imgs) {
         if (err) {
             callback(err);
             return;
         } else if (!imgs.length) {
-            callback(new errors.ResourceNotFoundError(format(
-                'No such image id (from registry %s): %s', opts.indexName,
-                opts.imgId)));
+            callback(
+                new errors.ResourceNotFoundError(
+                    format(
+                        'No such image id (from registry %s): %s',
+                        opts.indexName,
+                        opts.imgId
+                    )
+                )
+            );
             return;
         }
         assert.equal(imgs.length, 1);
@@ -398,7 +411,6 @@ function imgFromImgInfo(opts, callback) {
     });
 }
 
-
 /**
  * Find the img (an 'Image' model object instance) for the named Docker
  * image (and for the given account).
@@ -467,176 +479,208 @@ function imgFromName(opts, callback) {
     var imgIsGone = false;
 
     var imgapiOpts = common.objCopy(opts.app.config.imgapi);
-    imgapiOpts.headers = { 'x-request-id': log.fields.req_id };
+    imgapiOpts.headers = {'x-request-id': log.fields.req_id};
     var imgapi = new IMGAPI(imgapiOpts);
 
-    vasync.pipeline({funcs: [
-        function findUuidInImgapi(_, next) {
-            if (!opts.includeSmartos || !common.isUUID(name)) {
-                next();
-                return;
-            }
-
-            var acct = opts.account.uuid;
-            var getOpts = {
-                os: 'smartos',
-                state: 'active'
-            };
-            imgapi.getImage(name, acct, getOpts, function (err, imgapiImg) {
-                if (err) {
-                    if (err.statusCode === 404) {
+    vasync.pipeline(
+        {
+            funcs: [
+                function findUuidInImgapi(_, next) {
+                    if (!opts.includeSmartos || !common.isUUID(name)) {
                         next();
-                    } else {
-                        next(err);
+                        return;
                     }
-                    return;
-                }
-                log.debug({imgName: name, imgapiImg: imgapiImg},
-                    'imgFromName: findUuidInImgapi');
-                // A faux `Image` model object for this IMGAPI image.
-                img = {
-                    image_uuid: imgapiImg.uuid,
-                    os: imgapiImg.os
-                };
-                next(true);  /* early abort */
-            });
-        },
 
-        function findByName(_, next) {
-            var filter = [
-                {repo: name, owner_uuid: opts.account.uuid, tag: tag}
-            ];
-            if (opts.index_name) {
-                filter[0].index_name = opts.index_name;
-            }
-            ImageTag.list(opts.app, log, filter, function (err, imgTags) {
-                if (err) {
-                    next(err);
-                } else if (imgTags.length === 0) {
-                    next();
-                } else {
-                    imgTag = imgTags[0];
-                    // We can calculate the imgUuid from the ImageTag fields.
-                    imgUuid = imgmanifest.imgUuidFromDockerInfo({
-                        id: imgTag.docker_id,
-                        indexName: drc.parseRepo(imgTag.repo).index.name
+                    var acct = opts.account.uuid;
+                    var getOpts = {
+                        os: 'smartos',
+                        state: 'active'
+                    };
+                    imgapi.getImage(name, acct, getOpts, function(
+                        err,
+                        imgapiImg
+                    ) {
+                        if (err) {
+                            if (err.statusCode === 404) {
+                                next();
+                            } else {
+                                next(err);
+                            }
+                            return;
+                        }
+                        log.debug(
+                            {imgName: name, imgapiImg: imgapiImg},
+                            'imgFromName: findUuidInImgapi'
+                        );
+                        // A faux `Image` model object for this IMGAPI image.
+                        img = {
+                            image_uuid: imgapiImg.uuid,
+                            os: imgapiImg.os
+                        };
+                        next(true); /* early abort */
                     });
-                    log.debug({imgName: name, imgTag: imgTag, imgUuid: imgUuid},
-                        'imgFromName: findByName');
-                    next();
-                }
-            });
-        },
-
-        function findImage(_, next) {
-            var filter = [];
-            if (imgUuid) {
-                // We've found an imgTag, get the `Image` for it.
-                filter.push(
-                    {image_uuid: imgUuid, owner_uuid: opts.account.uuid});
-            } else if (/^[0-9a-f]+$/.test(name) && name.length <= 64) {
-                // Else, could possibly be an imgId, search for that.
-                if (name.length === 64) {
-                    filter.push(
-                        {docker_id: name, owner_uuid: opts.account.uuid});
-                } else {
-                    filter.push(
-                        {docker_id: name + '*', owner_uuid: opts.account.uuid});
-                }
-            } else {
-                next();
-                return;
-            }
-            if (opts.index_name) {
-                filter[0].index_name = opts.index_name;
-            }
-
-            Image.list(opts.app, log, filter, function (err, imgs) {
-                if (err || imgs.length === 0) {
-                    /*jsl:pass*/
-                } else if (imgs.length === 1) {
-                    img = imgs[0];
-                    log.debug({imgName: name, img: img},
-                        'imgFromName: findImage');
-                } else {
-                    var imgIds = {};
-                    var indexNames = [];
-                    for (var i = 0; i < imgs.length; i++) {
-                        var ix = imgs[i];
-                        imgIds[ix.docker_id] = true;
-                        indexNames.push(ix.index_name);
+                },
+
+                function findByName(_, next) {
+                    var filter = [
+                        {repo: name, owner_uuid: opts.account.uuid, tag: tag}
+                    ];
+                    if (opts.index_name) {
+                        filter[0].index_name = opts.index_name;
                     }
-                    if (Object.keys(imgIds).length === 1) {
-                        assert.ok(indexNames.length > 1);
-                        /*
+                    ImageTag.list(opts.app, log, filter, function(
+                        err,
+                        imgTags
+                    ) {
+                        if (err) {
+                            next(err);
+                        } else if (imgTags.length === 0) {
+                            next();
+                        } else {
+                            imgTag = imgTags[0];
+                            // We can calculate the imgUuid from the ImageTag fields.
+                            imgUuid = imgmanifest.imgUuidFromDockerInfo({
+                                id: imgTag.docker_id,
+                                indexName: drc.parseRepo(imgTag.repo).index.name
+                            });
+                            log.debug(
+                                {
+                                    imgName: name,
+                                    imgTag: imgTag,
+                                    imgUuid: imgUuid
+                                },
+                                'imgFromName: findByName'
+                            );
+                            next();
+                        }
+                    });
+                },
+
+                function findImage(_, next) {
+                    var filter = [];
+                    if (imgUuid) {
+                        // We've found an imgTag, get the `Image` for it.
+                        filter.push({
+                            image_uuid: imgUuid,
+                            owner_uuid: opts.account.uuid
+                        });
+                    } else if (/^[0-9a-f]+$/.test(name) && name.length <= 64) {
+                        // Else, could possibly be an imgId, search for that.
+                        if (name.length === 64) {
+                            filter.push({
+                                docker_id: name,
+                                owner_uuid: opts.account.uuid
+                            });
+                        } else {
+                            filter.push({
+                                docker_id: name + '*',
+                                owner_uuid: opts.account.uuid
+                            });
+                        }
+                    } else {
+                        next();
+                        return;
+                    }
+                    if (opts.index_name) {
+                        filter[0].index_name = opts.index_name;
+                    }
+
+                    Image.list(opts.app, log, filter, function(err, imgs) {
+                        if (err || imgs.length === 0) {
+                            /*jsl:pass*/
+                        } else if (imgs.length === 1) {
+                            img = imgs[0];
+                            log.debug(
+                                {imgName: name, img: img},
+                                'imgFromName: findImage'
+                            );
+                        } else {
+                            var imgIds = {};
+                            var indexNames = [];
+                            for (var i = 0; i < imgs.length; i++) {
+                                var ix = imgs[i];
+                                imgIds[ix.docker_id] = true;
+                                indexNames.push(ix.index_name);
+                            }
+                            if (Object.keys(imgIds).length === 1) {
+                                assert.ok(indexNames.length > 1);
+                                /*
                          * We have multiple hits for a single imgId, this is
                          * ambiguity case #2 described above.
                          */
-                        err = new errors.AmbiguousDockerImageIdError(
-                            name, indexNames);
-                    }
-                }
-                next(err);
-            });
-        },
-
-        function isImageInImgapi(_, next) {
-            if (!img) {
-                return next(true); // early abort
-            }
-
-            imgapi.getImage(img.image_uuid, function (err, imgapiImg) {
-                if (err) {
-                    if (err.statusCode === 404) {
-                        imgIsGone = true;
-                        next();
-                    } else {
+                                err = new errors.AmbiguousDockerImageIdError(
+                                    name,
+                                    indexNames
+                                );
+                            }
+                        }
                         next(err);
+                    });
+                },
+
+                function isImageInImgapi(_, next) {
+                    if (!img) {
+                        return next(true); // early abort
                     }
-                } else {
-                    next(true); // early abort
-                }
-            });
-        },
 
-        /*
+                    imgapi.getImage(img.image_uuid, function(err, imgapiImg) {
+                        if (err) {
+                            if (err.statusCode === 404) {
+                                imgIsGone = true;
+                                next();
+                            } else {
+                                next(err);
+                            }
+                        } else {
+                            next(true); // early abort
+                        }
+                    });
+                },
+
+                /*
          * If we get here then we found an `img`, but it isn't in IMGAPI
          * (`imgIsGone`). We need to clear these refs from the sdc-docker DB.
          */
-        function delImgRef(_, next) {
-            assert.ok(img);
-            assert.ok(imgIsGone);
+                function delImgRef(_, next) {
+                    assert.ok(img);
+                    assert.ok(imgIsGone);
+
+                    log.debug(
+                        {imgIsGone: imgIsGone, img: img},
+                        'imgFromName: delImgRef'
+                    );
+                    Image.del(opts.app, log, img, next);
+                },
+                function delImgTagRef(_, next) {
+                    assert.ok(imgIsGone);
+                    if (!imgTag) {
+                        return next();
+                    }
 
-            log.debug({imgIsGone: imgIsGone, img: img},
-                'imgFromName: delImgRef');
-            Image.del(opts.app, log, img, next);
+                    log.debug(
+                        {imgIsGone: imgIsGone, imgTag: imgTag},
+                        'imgFromName: delImgTagRef'
+                    );
+                    ImageTag.del(opts.app, log, imgTag, next);
+                }
+            ]
         },
-        function delImgTagRef(_, next) {
-            assert.ok(imgIsGone);
-            if (!imgTag) {
-                return next();
+        function(err) {
+            if (err === true) {
+                /* the signal for an early abort */
+                err = null;
+            }
+            if (err) {
+                callback(err);
+            } else if (imgIsGone) {
+                callback(null);
+            } else {
+                callback(null, img, imgTag);
             }
-
-            log.debug({imgIsGone: imgIsGone, imgTag: imgTag},
-                'imgFromName: delImgTagRef');
-            ImageTag.del(opts.app, log, imgTag, next);
-        }
-
-    ]}, function (err) {
-        if (err === true) { /* the signal for an early abort */
-            err = null;
-        }
-        if (err) {
-            callback(err);
-        } else if (imgIsGone) {
-            callback(null);
-        } else {
-            callback(null, img, imgTag);
         }
-    });
+    );
 }
 
-
 /**
  * Return the docker `Image` model for the given IMGAPI uuid.
  *
@@ -661,35 +705,44 @@ function getDockerImageForUuid(image_uuid, opts, callback) {
     var imgapi = opts.app.imgapi;
     var log = opts.log;
 
-    vasync.pipeline({arg: {}, funcs: [
-        findImage,
-        checkImageInImgapi
-    ]}, function (err) {
-        if (err) {
-            callback(err);
-            return;
+    vasync.pipeline(
+        {
+            arg: {},
+            funcs: [findImage, checkImageInImgapi]
+        },
+        function(err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            callback(null, img);
         }
-        callback(null, img);
-    });
+    );
 
     // Find the image in the sdc-docker database.
     function findImage(_, next) {
-        var filter = [
-            {image_uuid: image_uuid, owner_uuid: opts.account.uuid}
-        ];
-        Image.list(opts.app, log, filter, function (err, imgs) {
+        var filter = [{image_uuid: image_uuid, owner_uuid: opts.account.uuid}];
+        Image.list(opts.app, log, filter, function(err, imgs) {
             if (err) {
                 next(err);
                 return;
             }
             if (imgs.length === 0) {
-                next(new errors.ResourceNotFoundError(
-                    'No image with image_uuid: ' + image_uuid));
+                next(
+                    new errors.ResourceNotFoundError(
+                        'No image with image_uuid: ' + image_uuid
+                    )
+                );
                 return;
             }
             if (imgs.length > 1) {
-                next(new errors.DockerError('Error - multiple images found '
-                    + 'with the same image_uuid: ' + image_uuid));
+                next(
+                    new errors.DockerError(
+                        'Error - multiple images found ' +
+                            'with the same image_uuid: ' +
+                            image_uuid
+                    )
+                );
                 return;
             }
             img = imgs[0];
@@ -701,11 +754,14 @@ function getDockerImageForUuid(image_uuid, opts, callback) {
     // Check that the image is also in imgapi.
     function checkImageInImgapi(_, next) {
         assert.object(img, 'img');
-        imgapi.getImage(image_uuid, function (err, imgapiImg) {
+        imgapi.getImage(image_uuid, function(err, imgapiImg) {
             if (err) {
                 if (err.statusCode === 404) {
-                    next(new errors.ResourceNotFoundError(
-                        'No imgapi image with image_uuid: ' + image_uuid));
+                    next(
+                        new errors.ResourceNotFoundError(
+                            'No imgapi image with image_uuid: ' + image_uuid
+                        )
+                    );
                     return;
                 }
                 next(err);
@@ -716,7 +772,6 @@ function getDockerImageForUuid(image_uuid, opts, callback) {
     }
 }
 
-
 /**
  * Return the history of the given image. This is an ordered array of
  * `Image` model instances starting from the given image, followed by its
@@ -750,25 +805,27 @@ function getImageHistory(opts, callback) {
             return;
         }
 
-        imgFromImgInfo({
-            app: opts.app,
-            log: opts.log,
-            account: opts.account,
-            indexName: img.index_name,
-            imgId: img.parent
-        }, function (err, parentImg) {
-            if (err) {
-                callback(err, history);
-            } else {
-                addAndGetNextItem(parentImg);
+        imgFromImgInfo(
+            {
+                app: opts.app,
+                log: opts.log,
+                account: opts.account,
+                indexName: img.index_name,
+                imgId: img.parent
+            },
+            function(err, parentImg) {
+                if (err) {
+                    callback(err, history);
+                } else {
+                    addAndGetNextItem(parentImg);
+                }
             }
-        });
+        );
     }
 
     addAndGetNextItem(opts.img);
 }
 
-
 /**
  * Find the special scratch docker image and callback with the image details.
  *
@@ -787,15 +844,17 @@ function getScratchImage(req, callback) {
     var imgapi = app.imgapi;
     var log = req.log;
     var imageJsonPath = path.normalize(
-        __dirname + '/../../../etc/scratch_image.json');
+        __dirname + '/../../../etc/scratch_image.json'
+    );
     var imageTarPath = path.normalize(
-        __dirname + '/../../../etc/scratch_image.tar');
+        __dirname + '/../../../etc/scratch_image.tar'
+    );
     var imageJson = JSON.parse(fs.readFileSync(imageJsonPath, 'utf8'));
     var req_id = req.getId();
 
     var rat = {
         localName: '',
-        index: { name: 'docker.io' }
+        index: {name: 'docker.io'}
     };
 
     // Determine if the scratch image has been imported into IMGAPI.
@@ -804,27 +863,35 @@ function getScratchImage(req, callback) {
         indexName: rat.index.name
     });
 
-    vasync.pipeline({arg: {}, funcs: [
-        imgapiFindScratchImage,
-        imgapiCreateScratchImage,
-        imgapiImportScratchImage,
-        imgapiActivateScratchImage
-    ]}, function (err) {
-        if (err === true) { /* the signal for an early abort */
-            err = null;
-        }
-        if (err) {
-            callback(err);
-            return;
+    vasync.pipeline(
+        {
+            arg: {},
+            funcs: [
+                imgapiFindScratchImage,
+                imgapiCreateScratchImage,
+                imgapiImportScratchImage,
+                imgapiActivateScratchImage
+            ]
+        },
+        function(err) {
+            if (err === true) {
+                /* the signal for an early abort */
+                err = null;
+            }
+            if (err) {
+                callback(err);
+                return;
+            }
+            var result = imageJsonToModel();
+            callback(null, result);
         }
-        var result = imageJsonToModel();
-        callback(null, result);
-    });
+    );
 
     function imgapiFindScratchImage(ctx, next) {
-        imgapi.getImage(imageUuid, function (err, imgapiImg) {
+        imgapi.getImage(imageUuid, function(err, imgapiImg) {
             if (err) {
-                if (err.statusCode === 404) { // no such image
+                if (err.statusCode === 404) {
+                    // no such image
                     next();
                 } else {
                     next(err);
@@ -832,7 +899,7 @@ function getScratchImage(req, callback) {
                 return;
             }
             log.debug('getScratchImage: found scratch image in IMGAPI');
-            next(true);  /* early abort */
+            next(true); /* early abort */
         });
     }
 
@@ -842,16 +909,16 @@ function getScratchImage(req, callback) {
             req: req
         };
         log.debug('getScratchImage: creating new scratch image in IMGAPI');
-        createImgapiDockerImage(imageJson, opts, function (err, imgapiImg) {
+        createImgapiDockerImage(imageJson, opts, function(err, imgapiImg) {
             next(err);
         });
     }
 
     function imgapiImportScratchImage(ctx, next) {
         var opts = {
-            'compression': 'none',
+            compression: 'none',
             file: imageTarPath,
-            headers: { 'x-request-id': req_id },
+            headers: {'x-request-id': req_id},
             uuid: imageUuid
         };
         log.debug('getScratchImage: importing scratch image file into IMGAPI');
@@ -860,7 +927,7 @@ function getScratchImage(req, callback) {
 
     function imgapiActivateScratchImage(ctx, next) {
         var opts = {
-            headers: { 'x-request-id': req_id }
+            headers: {'x-request-id': req_id}
         };
         log.debug('getScratchImage: imgapi.activateImage');
         imgapi.activateImage(imageUuid, undefined, opts, next);
@@ -880,7 +947,6 @@ function getScratchImage(req, callback) {
     }
 }
 
-
 /* BEGIN JSSTYLED */
 /*
  * Exploring `docker rmi ...` behaviour:
@@ -994,28 +1060,36 @@ function deleteImage(opts, callback) {
     var changes = [];
     log.debug({imgName: opts.name}, 'deleteImage');
 
-    vasync.pipeline({arg: {}, funcs: [
-        getImg,
-        ensureIsHeadImage,
-        getImgTags,
-        checkTagReferences,
-        verifyNotInUse,
-        getImgsToDelete,
-        getDatacenterRefcount,
-        untagHeads,
-        deleteImgs
-    ]}, function (err) {
-        callback(err, changes);
-    });
-
+    vasync.pipeline(
+        {
+            arg: {},
+            funcs: [
+                getImg,
+                ensureIsHeadImage,
+                getImgTags,
+                checkTagReferences,
+                verifyNotInUse,
+                getImgsToDelete,
+                getDatacenterRefcount,
+                untagHeads,
+                deleteImgs
+            ]
+        },
+        function(err) {
+            callback(err, changes);
+        }
+    );
 
     function getImg(ctx, cb) {
-        imgFromName(opts, function (err, img, imgTag) {
+        imgFromName(opts, function(err, img, imgTag) {
             if (err) {
                 cb(err);
             } else if (!img) {
-                cb(new errors.ResourceNotFoundError(
-                    'No such image: ' + opts.name));
+                cb(
+                    new errors.ResourceNotFoundError(
+                        'No such image: ' + opts.name
+                    )
+                );
             } else {
                 log.debug({img: img, imgTag: imgTag}, 'deleteImage: getImg');
                 ctx.img = img;
@@ -1030,12 +1104,17 @@ function deleteImage(opts, callback) {
 
     function ensureIsHeadImage(ctx, cb) {
         if (ctx.img.head !== true) {
-            var heads = ctx.img.heads.map(function (imgId) {
-                return imgId.substr(0, 12);
-            }).join(', ');
-            var message = format('Conflict, %s wasn\'t deleted because it '
-                + 'is an intermediate layer being referenced by %s',
-                ctx.img.docker_id.substr(0, 12), heads);
+            var heads = ctx.img.heads
+                .map(function(imgId) {
+                    return imgId.substr(0, 12);
+                })
+                .join(', ');
+            var message = format(
+                "Conflict, %s wasn't deleted because it " +
+                    'is an intermediate layer being referenced by %s',
+                ctx.img.docker_id.substr(0, 12),
+                heads
+            );
             cb(new errors.DockerError(message));
         } else {
             cb();
@@ -1054,7 +1133,7 @@ function deleteImage(opts, callback) {
             docker_id: ctx.img.docker_id,
             owner_uuid: opts.account.uuid
         };
-        ImageTag.list(app, log, filter, function (err, imgTags) {
+        ImageTag.list(app, log, filter, function(err, imgTags) {
             if (err) {
                 cb(err);
                 return;
@@ -1070,14 +1149,27 @@ function deleteImage(opts, callback) {
         //   2) there is only one tag (or less) referencing this image
         // else we can only remove the given tag (when the tag name is supplied)
         // leaving the image (and any other tags) there.
-        log.debug({docker_id: ctx.img.docker_id, givenName: opts.name,
-            imgTags: ctx.imgTags}, 'deleteImage: checkTagReferences');
+        log.debug(
+            {
+                docker_id: ctx.img.docker_id,
+                givenName: opts.name,
+                imgTags: ctx.imgTags
+            },
+            'deleteImage: checkTagReferences'
+        );
         var givenName = opts.name;
         if (ctx.img.docker_id.substr(0, givenName.length) === givenName) {
             if (!opts.force && ctx.imgTags.length > 1) {
-                cb(new errors.DockerError(format('conflict: unable to delete '
-                    + '%s (must be forced) - image is referenced in one or '
-                    + 'more repositories', givenName)));
+                cb(
+                    new errors.DockerError(
+                        format(
+                            'conflict: unable to delete ' +
+                                '%s (must be forced) - image is referenced in one or ' +
+                                'more repositories',
+                            givenName
+                        )
+                    )
+                );
                 return;
             }
         } else if (ctx.imgTags.length > 1) {
@@ -1103,84 +1195,107 @@ function deleteImage(opts, callback) {
         // running VMusing the image
         var query = {
             docker: true,
-            state: (opts.force ? 'running' : 'active'),
+            state: opts.force ? 'running' : 'active',
             image_uuid: ctx.img.image_uuid,
             owner_uuid: opts.account.uuid
         };
 
-        vmapi.listVms(query, {
-            headers: {'x-request-id': opts.req_id}
-        }, function (vmapiErr, vms) {
-            if (vmapiErr) {
-                cb(errors.vmapiErrorWrap(vmapiErr,
-                    'could not delete image'));
-                return;
-            } else if (vms.length === 0) {
-                cb();
-                return;
-            }
+        vmapi.listVms(
+            query,
+            {
+                headers: {'x-request-id': opts.req_id}
+            },
+            function(vmapiErr, vms) {
+                if (vmapiErr) {
+                    cb(
+                        errors.vmapiErrorWrap(
+                            vmapiErr,
+                            'could not delete image'
+                        )
+                    );
+                    return;
+                } else if (vms.length === 0) {
+                    cb();
+                    return;
+                }
 
-            vms.sort(function (a, b) {
-                if (a.state < b.state)
-                    return -1;
-                if (a.state > b.state)
-                    return 1;
-                return 0;
-            });
+                vms.sort(function(a, b) {
+                    if (a.state < b.state) return -1;
+                    if (a.state > b.state) return 1;
+                    return 0;
+                });
 
-            var forceStr = opts.force ? 'force ' : '';
-            var messageFormat;
-            // If the vm is state=incomplete, we might not have
-            // internal_metadata.
-            var sId = utils.vmUuidToShortDockerId(vms[0].uuid);
-            if (vms[0].state === 'running') {
-                messageFormat = 'Conflict, cannot %sdelete %s because '
-                    + 'the running container %s is using it, stop it and '
-                    + 'use -f to force';
-            } else {
-                messageFormat = 'Conflict, cannot %sdelete %s because '
-                    + 'the container %s is using it, use -f to force';
-            }
-            var message = format(messageFormat, forceStr,
-                opts.name, sId);
+                var forceStr = opts.force ? 'force ' : '';
+                var messageFormat;
+                // If the vm is state=incomplete, we might not have
+                // internal_metadata.
+                var sId = utils.vmUuidToShortDockerId(vms[0].uuid);
+                if (vms[0].state === 'running') {
+                    messageFormat =
+                        'Conflict, cannot %sdelete %s because ' +
+                        'the running container %s is using it, stop it and ' +
+                        'use -f to force';
+                } else {
+                    messageFormat =
+                        'Conflict, cannot %sdelete %s because ' +
+                        'the container %s is using it, use -f to force';
+                }
+                var message = format(messageFormat, forceStr, opts.name, sId);
 
-            cb(new errors.DockerError(message));
-        });
+                cb(new errors.DockerError(message));
+            }
+        );
     }
 
     function getImgsToDelete(ctx, cb) {
-        getImageHistory({
-            app: app,
-            log: log,
-            img: ctx.img,
-            account: opts.account
-        }, function (err, history) {
-            if (err) {
-                if (history && Array.isArray(history) && history.length > 0) {
-                    /*
-                     * If we got a partial history, then carry on with the
-                     * delete. We don't want missing ancestry (e.g. due to
-                     * DOCKER-709) to block the user from deleting this
-                     * image.
-                     *
-                     * Only avenues to client-side output are 'Untagged' and
-                     * 'Deleted' keys.
-                     */
-                    log.warn({err: err, docker_id: ctx.img.docker_id},
-                        'deleteImage: getImgsToDelete: partial history');
-                    changes.push({ Deleted: format(
-                        'warning: %s missing some history: %s',
-                        opts.name, err) });
+        getImageHistory(
+            {
+                app: app,
+                log: log,
+                img: ctx.img,
+                account: opts.account
+            },
+            function(err, history) {
+                if (err) {
+                    if (
+                        history && Array.isArray(history) && history.length > 0
+                    ) {
+                        /*
+                         * If we got a partial history, then carry on with the
+                         * delete. We don't want missing ancestry (e.g. due to
+                         * DOCKER-709) to block the user from deleting this
+                         * image.
+                         *
+                         * Only avenues to client-side output are 'Untagged' and
+                         * 'Deleted' keys.
+                         */
+                        log.warn(
+                            {err: err, docker_id: ctx.img.docker_id},
+                            'deleteImage: getImgsToDelete: partial history'
+                        );
+                        changes.push({
+                            Deleted: format(
+                                'warning: %s missing some history: %s',
+                                opts.name,
+                                err
+                            )
+                        });
+                        ctx.imgsToDelete = history;
+                        cb();
+                    } else {
+                        cb(
+                            new errors.DockerError(
+                                err,
+                                'could not delete image'
+                            )
+                        );
+                    }
+                } else {
                     ctx.imgsToDelete = history;
                     cb();
-                } else {
-                    cb(new errors.DockerError(err, 'could not delete image'));
                 }
-            } else {
-                ctx.imgsToDelete = history;
-                cb();
             }
-        });
+        );
     }
 
     // Get all images that are ready to be deleted from IMGAPI.
@@ -1190,7 +1305,7 @@ function deleteImage(opts, callback) {
             docker_id: ctx.img.docker_id,
             limit: 1
         };
-        Image.datacenterRefcount(app, log, params, function (err, count) {
+        Image.datacenterRefcount(app, log, params, function(err, count) {
             if (err) {
                 cb(new errors.DockerError(err, 'could not delete image'));
                 return;
@@ -1203,25 +1318,31 @@ function deleteImage(opts, callback) {
     function untagHeads(ctx, cb) {
         log.debug({imgTags: ctx.imgTags}, 'deleteImage: untagHeads');
 
-        vasync.forEachPipeline({
-            inputs: ctx.imgTags,
-            func: function untagOne(imgTag, nextImgTag) {
-                if (DRY_RUN) {
-                    changes.push({ Untagged: imgTag.repo + ':' + imgTag.tag });
-                    nextImgTag();
-                    return;
-                }
-                ImageTag.del(app, log, imgTag, function (err) {
-                    if (err) {
-                        nextImgTag(err);
-                    } else {
+        vasync.forEachPipeline(
+            {
+                inputs: ctx.imgTags,
+                func: function untagOne(imgTag, nextImgTag) {
+                    if (DRY_RUN) {
                         changes.push({
-                            Untagged: imgTag.repo + ':' + imgTag.tag });
+                            Untagged: imgTag.repo + ':' + imgTag.tag
+                        });
                         nextImgTag();
+                        return;
                     }
-                });
-            }
-        }, cb);
+                    ImageTag.del(app, log, imgTag, function(err) {
+                        if (err) {
+                            nextImgTag(err);
+                        } else {
+                            changes.push({
+                                Untagged: imgTag.repo + ':' + imgTag.tag
+                            });
+                            nextImgTag();
+                        }
+                    });
+                }
+            },
+            cb
+        );
     }
 
     function deleteImgs(ctx, cb) {
@@ -1230,16 +1351,19 @@ function deleteImage(opts, callback) {
             return;
         }
 
-        vasync.forEachPipeline({
-            inputs: ctx.imgsToDelete,
-            func: deleteOneImg
-        }, function (err) {
-            if (err) {
-                cb(new errors.DockerError(err, 'could not delete image'));
-                return;
+        vasync.forEachPipeline(
+            {
+                inputs: ctx.imgsToDelete,
+                func: deleteOneImg
+            },
+            function(err) {
+                if (err) {
+                    cb(new errors.DockerError(err, 'could not delete image'));
+                    return;
+                }
+                cb();
             }
-            cb();
-        });
+        );
 
         /*
          * `true` if we hit `ImageHasDependentImagesError` error from IMGAPI,
@@ -1255,23 +1379,28 @@ function deleteImage(opts, callback) {
          * from IMGAPI.
          */
         function deleteOneImg(img, nextImg) {
-            log.debug({imgId: img.docker_id, indexName: img.index_name},
-                'deleteImage: deleteOneImg');
+            log.debug(
+                {imgId: img.docker_id, indexName: img.index_name},
+                'deleteImage: deleteOneImg'
+            );
             if (DRY_RUN) {
-                changes.push({ Deleted: img.docker_id });
+                changes.push({Deleted: img.docker_id});
                 nextImg();
                 return;
             }
 
             if (img.refcount > 1) {
-                log.debug({imgId: img.docker_id, indexName: img.index_name},
-                    'deleteImage: remove %s from heads', ctx.img.docker_id);
+                log.debug(
+                    {imgId: img.docker_id, indexName: img.index_name},
+                    'deleteImage: remove %s from heads',
+                    ctx.img.docker_id
+                );
                 var update = {
                     owner_uuid: img.owner_uuid,
                     index_name: img.index_name,
                     docker_id: img.docker_id,
                     // Update:
-                    heads: img.params.heads.filter(function (id) {
+                    heads: img.params.heads.filter(function(id) {
                         return id !== ctx.img.docker_id;
                     })
                 };
@@ -1286,42 +1415,54 @@ function deleteImage(opts, callback) {
                 }
                 Image.update(app, log, update, nextImg);
             } else {
-                log.debug({imgId: img.docker_id, indexName: img.index_name},
-                    'deleteImage: delete image', ctx.img.docker_id);
-                Image.del(app, log, img, function (delErr) {
+                log.debug(
+                    {imgId: img.docker_id, indexName: img.index_name},
+                    'deleteImage: delete image',
+                    ctx.img.docker_id
+                );
+                Image.del(app, log, img, function(delErr) {
                     if (delErr) {
                         nextImg(delErr);
                         return;
                     }
-                    changes.push({ Deleted: img.docker_id });
+                    changes.push({Deleted: img.docker_id});
 
-                    var isLastRef = (ctx.dcRefcount[img.docker_id]
-                                            !== undefined);
+                    var isLastRef = ctx.dcRefcount[img.docker_id] !== undefined;
                     if (!isLastRef || hitImageHasDependentImagesError) {
                         nextImg();
                         return;
                     }
 
-                    log.debug({imgUuid: img.image_uuid},
-                        'deleteImage: delete imgapi image (last ref)');
-                    app.imgapi.deleteImage(img.image_uuid, {
-                        headers: {'x-request-id': opts.req_id}
-                    }, function (err) {
-                        if (err && err.restCode === 'ImageHasDependentImages') {
-                            hitImageHasDependentImagesError = true;
-                            log.info({imgUuid: img.image_uuid},
-                                'deleteImage: hit ImageHasDependentImages');
-                            err = null;
+                    log.debug(
+                        {imgUuid: img.image_uuid},
+                        'deleteImage: delete imgapi image (last ref)'
+                    );
+                    app.imgapi.deleteImage(
+                        img.image_uuid,
+                        {
+                            headers: {'x-request-id': opts.req_id}
+                        },
+                        function(err) {
+                            if (
+                                err &&
+                                err.restCode === 'ImageHasDependentImages'
+                            ) {
+                                hitImageHasDependentImagesError = true;
+                                log.info(
+                                    {imgUuid: img.image_uuid},
+                                    'deleteImage: hit ImageHasDependentImages'
+                                );
+                                err = null;
+                            }
+                            nextImg(err);
                         }
-                        nextImg(err);
-                    });
+                    );
                 });
             }
         }
     }
 }
 
-
 /**
  * Inspect an image.
  *
@@ -1337,12 +1478,13 @@ function inspectImage(opts, callback) {
     assert.object(opts.log, 'opts.log');
     assert.optionalString(opts.index_name, 'opts.index_name');
 
-    imgFromName(opts, function (err, img) {
+    imgFromName(opts, function(err, img) {
         if (err) {
             callback(err);
         } else if (!img) {
-            callback(new errors.ResourceNotFoundError(
-                'No such image: ' + opts.name));
+            callback(
+                new errors.ResourceNotFoundError('No such image: ' + opts.name)
+            );
         } else {
             // Get tags and return inspect info.
             var filter = [
@@ -1351,7 +1493,7 @@ function inspectImage(opts, callback) {
             if (opts.index_name) {
                 filter[0].index_name = opts.index_name;
             }
-            ImageTag.list(opts.app, opts.log, filter, function (err2, imgTags) {
+            ImageTag.list(opts.app, opts.log, filter, function(err2, imgTags) {
                 if (err2) {
                     callback(err2);
                     return;
@@ -1363,12 +1505,11 @@ function inspectImage(opts, callback) {
     });
 }
 
-
 function pullImage(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
     assert.object(opts.log, 'opts.log');
-    assert.object(opts.rat, 'opts.rat');  // rat === Repo And Tag/Digest
+    assert.object(opts.rat, 'opts.rat'); // rat === Repo And Tag/Digest
     assert.object(opts.req, 'opts.req');
     assert.string(opts.req_id, 'opts.req_id');
     assert.object(opts.res, 'opts.res');
@@ -1406,8 +1547,14 @@ function pullImage(opts, callback) {
         } else if (opts.rat.tag) {
             imgName += ':' + opts.rat.tag;
         }
-        opts.req.log.info({err: err, imgName: imgName,
-            jobUuid: job && job.uuid}, 'imageCreate job error');
+        opts.req.log.info(
+            {
+                err: err,
+                imgName: imgName,
+                jobUuid: job && job.uuid
+            },
+            'imageCreate job error'
+        );
 
         /*
          * `recognized: false` is log.info'd below to indicated `docker pull`
@@ -1424,8 +1571,8 @@ function pullImage(opts, callback) {
              * `ENOTFOUND` code comes from docker-registry-client - through
              * old IMGAPI versions.
              */
-            err.code === 'RemoteSourceError' || err.code === 'ENOTFOUND')
-        {
+            err.code === 'RemoteSourceError' || err.code === 'ENOTFOUND'
+        ) {
             /* BEGIN JSSTYLED */
             /*
              * Docker-docker:
@@ -1442,8 +1589,11 @@ function pullImage(opts, callback) {
              * err={ [Error: getaddrinfo ENOTFOUND] code: 'ENOTFOUND' }
              */
             /* END JSSTYLED */
-            errmsg = format('Error pulling image: (%s) %s host not found',
-                err.code, opts.rat.index.name);
+            errmsg = format(
+                'Error pulling image: (%s) %s host not found',
+                err.code,
+                opts.rat.index.name
+            );
         } else if (
             /*
              * --- UnauthorizedError
@@ -1456,11 +1606,12 @@ function pullImage(opts, callback) {
              * --- ResourceNotFoundError
              * E.g.: `docker pull quay.io/no-such-user`
              */
-            err.code === 'UnauthorizedError' || /* newer IMGAPI */
-            err.code === 'UNAUTHORIZED' || /* older IMGAPI */
-            err.code === 'ResourceNotFound' || /* newer IMGAPI */
-            err.code === 'NotFoundError')      /* older IMGAPI */
-        {
+            err.code === 'UnauthorizedError' /* newer IMGAPI */ ||
+            err.code === 'UNAUTHORIZED' /* older IMGAPI */ ||
+            err.code === 'ResourceNotFound' /* newer IMGAPI */ ||
+            err.code === 'NotFoundError'
+        ) {
+            /* older IMGAPI */
             errmsg = format('Error: image %s not found', imgName);
         } else if (
             /*
@@ -1468,8 +1619,8 @@ function pullImage(opts, callback) {
              * `DownloadError` code comes from docker-registry-client - through
              * old IMGAPI versions.
              */
-            err.code === 'Download' || err.code === 'DownloadError')
-        {
+            err.code === 'Download' || err.code === 'DownloadError'
+        ) {
             errmsg = format('Error downloading %s: %s', imgName, err.message);
         } else if (
             /*
@@ -1477,15 +1628,20 @@ function pullImage(opts, callback) {
              * `ConnectTimeoutError` code comes from docker-registry-client -
              * through old IMGAPI versions.
              */
-            err.code === 'ConnectTimeoutError'
-            || err.code === 'RemoteSourceError')
-        {
-            errmsg = format('Timeout connecting to host %s',
-                opts.rat.index.name);
+            err.code === 'ConnectTimeoutError' ||
+            err.code === 'RemoteSourceError'
+        ) {
+            errmsg = format(
+                'Timeout connecting to host %s',
+                opts.rat.index.name
+            );
         } else if (err.code === 'NotImplemented') {
             // E.g. OAuth auth to a Docker Registry before DOCKER-771.
-            errmsg = format('Could not pull from registry %s: %s',
-                opts.rat.index.name, err.message);
+            errmsg = format(
+                'Could not pull from registry %s: %s',
+                opts.rat.index.name,
+                err.message
+            );
         } else {
             /*
              * E.g.: {"errors":[{"code":"UNAUTHORIZED",
@@ -1513,20 +1669,32 @@ function pullImage(opts, callback) {
                      */
                     errmsg = format('Error: image %s not found', imgName);
                 } else {
-                    errmsg = format('Error pulling image: (%s) %s',
-                        code, regErr.errors[0].message);
+                    errmsg = format(
+                        'Error pulling image: (%s) %s',
+                        code,
+                        regErr.errors[0].message
+                    );
                 }
             } else {
-                var errmsgs = regErr.errors.map(function (e) {
-                    return format('(%s) %s', e.code, e.message); })
+                var errmsgs = regErr.errors
+                    .map(function(e) {
+                        return format('(%s) %s', e.code, e.message);
+                    })
                     .join(', ');
                 errmsg = format('Error pulling image: %s', errmsgs);
             }
         }
 
-        opts.req.log.info({err: err, imgName: imgName,
-            jobUuid: job && job.uuid, recognized: recognized, errmsg: errmsg},
-            'pullImage error');
+        opts.req.log.info(
+            {
+                err: err,
+                imgName: imgName,
+                jobUuid: job && job.uuid,
+                recognized: recognized,
+                errmsg: errmsg
+            },
+            'pullImage error'
+        );
 
         /*
          * Note: docker/pkg/jsonmessage/jsonmessage.go describes an optional
@@ -1535,7 +1703,7 @@ function pullImage(opts, callback) {
          */
         errmsg += ' (' + opts.req_id + ')';
         var payload = {
-            error: errmsg,  // deprecated field
+            error: errmsg, // deprecated field
             errorDetail: {
                 message: errmsg
             }
@@ -1545,12 +1713,12 @@ function pullImage(opts, callback) {
         opts.res.end();
     }
 
-    vasync.pipeline({
-        funcs: [
-            createPullJob,
-            waitForPullJob
-        ]
-    }, callback);
+    vasync.pipeline(
+        {
+            funcs: [createPullJob, waitForPullJob]
+        },
+        callback
+    );
 
     function createPullJob(_, next) {
         var jobOpts = {
@@ -1561,7 +1729,7 @@ function pullImage(opts, callback) {
             regConfig: opts.req.headers['x-registry-config']
         };
 
-        opts.wfapi.createPullImageJob(jobOpts, function (err, juuid) {
+        opts.wfapi.createPullImageJob(jobOpts, function(err, juuid) {
             if (err) {
                 errorAndEnd(err);
                 next();
@@ -1581,7 +1749,7 @@ function pullImage(opts, callback) {
     }
 
     function waitForPullJob(_, next) {
-        common.waitForJob(opts.wfapi, jobUuid, function (err, job) {
+        common.waitForJob(opts.wfapi, jobUuid, function(err, job) {
             if (err) {
                 errorAndEnd(err, job);
             }
@@ -1591,7 +1759,6 @@ function pullImage(opts, callback) {
     }
 }
 
-
 /**
  * Create new (unactivated) docker image in imgapi and return it through the
  * callback.
@@ -1610,21 +1777,22 @@ function createImgapiDockerImage(imageJson, opts, callback) {
         repo: opts.rat
     });
     var imageOpts = {
-        headers: { 'x-request-id': opts.req.getId() }
+        headers: {'x-request-id': opts.req.getId()}
     };
     opts.req.log.debug({manifest: manifest}, 'createImage manifest');
-    opts.req.app.imgapi.adminImportImage(manifest, imageOpts,
-        function _adminImportImageCb(err, img)
-    {
-        if (err) {
-            callback(err);
-            return;
+    opts.req.app.imgapi.adminImportImage(
+        manifest,
+        imageOpts,
+        function _adminImportImageCb(err, img) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            callback(null, img);
         }
-        callback(null, img);
-    });
+    );
 }
 
-
 /**
  * Create new (unactivated) docker image - in imgapi and sdc-docker image model.
  *
@@ -1638,8 +1806,10 @@ function createImage(opts, callback) {
     assert.optionalBool(opts.payload.head, 'opts.payload.head');
     assert.optionalArrayOfString(opts.payload.heads, 'opts.payload.heads');
     assert.number(opts.payload.size, 'opts.payload.size');
-    assert.optionalNumber(opts.payload.virtual_size,
-                        'opts.payload.virtual_size');
+    assert.optionalNumber(
+        opts.payload.virtual_size,
+        'opts.payload.virtual_size'
+    );
     assert.optionalObject(opts.rat, 'opts.rat');
     assert.object(opts.req, 'opts.req');
 
@@ -1652,17 +1822,20 @@ function createImage(opts, callback) {
         // Empty repo/tag.
         rat = {
             localName: '',
-            index: { name: 'docker.io' }
+            index: {name: 'docker.io'}
         };
     }
 
-    vasync.pipeline({arg: {}, funcs: [
-        createImgapiImage,
-        createSdcDockerImageLayer
-    ]}, function _createImagePipelineCb(err, results) {
-        // Pass the sdc docker Image object back.
-        callback(err, results.successes[results.successes.length - 1]);
-    });
+    vasync.pipeline(
+        {
+            arg: {},
+            funcs: [createImgapiImage, createSdcDockerImageLayer]
+        },
+        function _createImagePipelineCb(err, results) {
+            // Pass the sdc docker Image object back.
+            callback(err, results.successes[results.successes.length - 1]);
+        }
+    );
 
     // Create imgapi image object.
     function createImgapiImage(ctx, next) {
@@ -1671,7 +1844,7 @@ function createImage(opts, callback) {
             rat: rat,
             req: req
         };
-        createImgapiDockerImage(imageJson, imgOpts, function (err, imgapiImg) {
+        createImgapiDockerImage(imageJson, imgOpts, function(err, imgapiImg) {
             if (!err) {
                 ctx.image_uuid = imgapiImg.uuid;
             }
@@ -1696,7 +1869,6 @@ function createImage(opts, callback) {
     }
 }
 
-
 /**
  * Update an image heads reference to include the given docker id.
  *
@@ -1723,12 +1895,13 @@ function addImageHeads(opts, callback) {
         index_name: opts.index_name,
         name: id
     };
-    req.backend.imgFromName(imageOpts, function (err, img) {
+    req.backend.imgFromName(imageOpts, function(err, img) {
         if (err) {
             callback(err);
         } else if (!img) {
-            callback(new errors.ResourceNotFoundError(
-                'No image found with id' + id));
+            callback(
+                new errors.ResourceNotFoundError('No image found with id' + id)
+            );
         } else {
             var heads = img.heads || [];
             opts.heads.forEach(function headForEach(headId) {
@@ -1736,18 +1909,22 @@ function addImageHeads(opts, callback) {
                     heads.push(headId);
                 }
             });
-            Image.update(req.app, req.log, {
-                owner_uuid: img.owner_uuid,
-                index_name: img.index_name,
-                docker_id: img.docker_id,
-                // Update:
-                heads: heads
-            }, callback);
+            Image.update(
+                req.app,
+                req.log,
+                {
+                    owner_uuid: img.owner_uuid,
+                    index_name: img.index_name,
+                    docker_id: img.docker_id,
+                    // Update:
+                    heads: heads
+                },
+                callback
+            );
         }
     });
 }
 
-
 /**
  * Tags an image (given by docker_id) with the given name.
  *
@@ -1780,23 +1957,24 @@ function tagImage(opts, callback) {
         owner_uuid: req.account.uuid,
         repo: rat.localName,
         tag: rat.tag
-
     };
     ImageTag.create(req.app, req.log, params, callback);
 }
 
-
 function getImageCount(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
     assert.optionalObject(opts.log, 'opts.log');
     assert.object(opts.account, 'opts.account');
 
-    Image.imageCount(opts.app, opts.log, {owner_uuid: opts.account.uuid},
-        callback);
+    Image.imageCount(
+        opts.app,
+        opts.log,
+        {owner_uuid: opts.account.uuid},
+        callback
+    );
 }
 
-
 // ---- exports
 
 module.exports = {
diff --git a/lib/backends/sdc/index.js b/lib/backends/sdc/index.js
index 6cf17d9..b2cd582 100644
--- a/lib/backends/sdc/index.js
+++ b/lib/backends/sdc/index.js
@@ -19,8 +19,6 @@ var containers = require('./containers');
 var sysinfo = require('./sysinfo');
 var images = require('./images');
 
-
-
 function SdcBackend(opts) {
     assert.object(opts, 'opts');
     assert.object(opts.log, 'opts.log');
@@ -60,8 +58,7 @@ SdcBackend.prototype.containerArchiveReadStream =
     containers.containerArchiveReadStream;
 SdcBackend.prototype.containerArchiveWriteStream =
     containers.containerArchiveWriteStream;
-SdcBackend.prototype.containerArchiveStat =
-    containers.containerArchiveStat;
+SdcBackend.prototype.containerArchiveStat = containers.containerArchiveStat;
 
 // images.js
 SdcBackend.prototype.addImageHeads = images.addImageHeads;
@@ -80,5 +77,4 @@ SdcBackend.prototype.tagImage = images.tagImage;
 SdcBackend.prototype.buildImage = build.buildImage;
 SdcBackend.prototype.commitImage = build.commitImage;
 
-
 module.exports = SdcBackend;
diff --git a/lib/backends/sdc/sysinfo.js b/lib/backends/sdc/sysinfo.js
index ba002df..bdc073b 100644
--- a/lib/backends/sdc/sysinfo.js
+++ b/lib/backends/sdc/sysinfo.js
@@ -16,7 +16,6 @@ var VERSION = require('../../../package.json').version;
 
 var cachedZoneSysInfo = null;
 
-
 /**
  * Return result of '/usr/bin/sysinfo' as an object.
  *
@@ -33,7 +32,7 @@ function getZoneSysInfo(opts, callback) {
     var cmd = '/usr/bin/sysinfo';
 
     log.debug('running command: ', cmd);
-    execFile(cmd, null, function (error, stdout, stderr) {
+    execFile(cmd, null, function(error, stdout, stderr) {
         if (error) {
             log.error('Unable to run sysinfo');
             error.stdout = stdout;
@@ -66,9 +65,7 @@ function getInfo(opts, callback) {
     var info = {
         Architecture: 'x86_64',
         Driver: 'sdc',
-        DriverStatus: [
-            ['SDCAccount', opts.account && opts.account.login]
-        ],
+        DriverStatus: [['SDCAccount', opts.account && opts.account.login]],
         ExecutionDriver: 'sdc-' + VERSION,
         // Kernel version same as lxzone.
         KernelVersion: '3.12.0-1-amd64',
@@ -79,33 +76,36 @@ function getInfo(opts, callback) {
         Name: self.config.datacenterName,
 
         // IndexServerAddress changed (from array to string in ver 1.18).
-        IndexServerAddress: (opts.clientApiVersion < 1.18 ?
-                            ['https://index.docker.io/v1/'] :
-                            'https://index.docker.io/v1/'),
+        IndexServerAddress: opts.clientApiVersion < 1.18
+            ? ['https://index.docker.io/v1/']
+            : 'https://index.docker.io/v1/',
         MemoryLimit: true,
         SwapLimit: true,
         IPv4Forwarding: true
     };
 
-    var countContainers = function (cb) {
-        self.getContainerCount({
-            app: opts.app,
-            log: log,
-            req_id: opts.req_id,
-            account: opts.account
-        }, function (cErr, num) {
-            if (cErr) {
-                log.warn(cErr, 'error listing containers for Info');
-                // Stumble on.
-            } else {
-                info.Containers = num;
+    var countContainers = function(cb) {
+        self.getContainerCount(
+            {
+                app: opts.app,
+                log: log,
+                req_id: opts.req_id,
+                account: opts.account
+            },
+            function(cErr, num) {
+                if (cErr) {
+                    log.warn(cErr, 'error listing containers for Info');
+                    // Stumble on.
+                } else {
+                    info.Containers = num;
+                }
+                cb();
             }
-            cb();
-        });
+        );
     };
 
-    var countImages = function (cb) {
-        self.getImageCount(opts, function (iErr, num) {
+    var countImages = function(cb) {
+        self.getImageCount(opts, function(iErr, num) {
             if (iErr) {
                 log.warn(iErr, 'error listing images for Info');
                 // Stumble on.
@@ -116,8 +116,8 @@ function getInfo(opts, callback) {
         });
     };
 
-    var setId = function (cb) {
-        getZoneSysInfo({ log: log }, function (err, zoneinfo) {
+    var setId = function(cb) {
+        getZoneSysInfo({log: log}, function(err, zoneinfo) {
             if (err) {
                 log.warn(err, 'error calling getZoneSysInfo');
                 // Stumble on.
@@ -128,17 +128,18 @@ function getInfo(opts, callback) {
         });
     };
 
-    vasync.parallel({ funcs: [
-        countContainers,
-        countImages,
-        setId
-    ]}, function (err) {
-        if (err) {
-            callback(err);
-            return;
+    vasync.parallel(
+        {
+            funcs: [countContainers, countImages, setId]
+        },
+        function(err) {
+            if (err) {
+                callback(err);
+                return;
+            }
+            callback(null, info);
         }
-        callback(null, info);
-    });
+    );
 }
 
 module.exports = {
diff --git a/lib/backends/sdc/utils.js b/lib/backends/sdc/utils.js
index b69511e..34780d3 100644
--- a/lib/backends/sdc/utils.js
+++ b/lib/backends/sdc/utils.js
@@ -19,8 +19,6 @@ var common = require('../../common');
 var constants = require('../../constants');
 var Link = require('../../models/link');
 
-
-
 function vmUuidToShortDockerId(uuid) {
     return uuid.replace(/-/g, '').slice(0, 12);
 }
@@ -37,22 +35,22 @@ function shortNetworkIdToUuidPrefix(id) {
     // appropriate starting group.
 
     switch (Math.ceil(id.substr(0, 32).length / 4)) {
-    case 8: // 'abcdabcd-abcd-abcd-abcd-abcdabcdabcd'
-    case 7: // 'abcdabcd-abcd-abcd-abcd-abcdabcd'
-    case 6: // 'abcdabcd-abcd-abcd-abcd-abcd'
-        partial = '-' + id.substr(20, 12) + partial; /*jsl:fallthru*/
-    case 5: // 'abcdabcd-abcd-abcd-abcd'
-        partial = '-' + id.substr(16, 4) + partial;  /*jsl:fallthru*/
-    case 4: // 'abcdabcd-abcd-abcd'
-        partial = '-' + id.substr(12, 4) + partial;  /*jsl:fallthru*/
-    case 3: // 'abcdabcd-abcd'
-        partial = '-' + id.substr(8, 4) + partial;   /*jsl:fallthru*/
-    case 2: // 'abcdabcd'
-    case 1: // 'abcd'
-        partial = id.substr(0, 8) + partial;         /*jsl:fallthru*/
-    case 0:
-    default:
-        break;
+        case 8: // 'abcdabcd-abcd-abcd-abcd-abcdabcdabcd'
+        case 7: // 'abcdabcd-abcd-abcd-abcd-abcdabcd'
+        case 6: // 'abcdabcd-abcd-abcd-abcd-abcd'
+            partial = '-' + id.substr(20, 12) + partial; /*jsl:fallthru*/
+        case 5: // 'abcdabcd-abcd-abcd-abcd'
+            partial = '-' + id.substr(16, 4) + partial; /*jsl:fallthru*/
+        case 4: // 'abcdabcd-abcd-abcd'
+            partial = '-' + id.substr(12, 4) + partial; /*jsl:fallthru*/
+        case 3: // 'abcdabcd-abcd'
+            partial = '-' + id.substr(8, 4) + partial; /*jsl:fallthru*/
+        case 2: // 'abcdabcd'
+        case 1: // 'abcd'
+            partial = id.substr(0, 8) + partial; /*jsl:fallthru*/
+        case 0:
+        default:
+            break;
     }
     return partial;
 }
@@ -76,19 +74,24 @@ function dockerLabelsFromVmTags(tags) {
     var labels = {};
     const LABELTAG_PREFIX = common.LABELTAG_PREFIX;
 
-    var strFromLabelVal = function (val) {
-        if (!expectedTypes[typeof (val)]) {
-            throw new Error(format(
-                'unexpected VM tag value type: val=%j, type=%j',
-                val, typeof (val)));
+    var strFromLabelVal = function(val) {
+        if (!expectedTypes[typeof val]) {
+            throw new Error(
+                format(
+                    'unexpected VM tag value type: val=%j, type=%j',
+                    val,
+                    typeof val
+                )
+            );
         }
         return val.toString();
     };
 
-    Object.keys(tags).forEach(function (key) {
+    Object.keys(tags).forEach(function(key) {
         if (key.substr(0, LABELTAG_PREFIX.length) === LABELTAG_PREFIX) {
-            labels[key.substr(LABELTAG_PREFIX.length)]
-                = strFromLabelVal(tags[key]);
+            labels[key.substr(LABELTAG_PREFIX.length)] = strFromLabelVal(
+                tags[key]
+            );
         }
     });
 
@@ -96,7 +99,7 @@ function dockerLabelsFromVmTags(tags) {
      * Add the 'triton.' tags last so they 'win' over (obsolete, legacy)
      * 'docker:label:triton.'.
      */
-    Object.keys(tags).forEach(function (key) {
+    Object.keys(tags).forEach(function(key) {
         if (triton_tags.isTritonTag(key)) {
             labels[key] = strFromLabelVal(tags[key]);
         }
@@ -105,18 +108,21 @@ function dockerLabelsFromVmTags(tags) {
     return labels;
 }
 
-
 function getPublishingRules(opts, fwrules) {
     var log = opts.log;
     var uuid = opts.vm.uuid;
-    return fwrules.reduce(function (published, rule) {
+    return fwrules.reduce(function(published, rule) {
         var fwrule;
         try {
             fwrule = new mod_fwrule.FwRule(rule);
         } catch (e) {
-            log.error(e, {
-                rule: rule
-            }, 'Failed to parse rule while producing inspect info');
+            log.error(
+                e,
+                {
+                    rule: rule
+                },
+                'Failed to parse rule while producing inspect info'
+            );
             return published;
         }
 
@@ -125,10 +131,12 @@ function getPublishingRules(opts, fwrules) {
             return published;
         }
 
-        if (fwrule.action !== 'allow'
-            || fwrule.to.vms.indexOf(uuid) === -1
-            || fwrule.ports.indexOf('all') !== -1
-            || fwrule.from.wildcards.indexOf('any') === -1) {
+        if (
+            fwrule.action !== 'allow' ||
+            fwrule.to.vms.indexOf(uuid) === -1 ||
+            fwrule.ports.indexOf('all') !== -1 ||
+            fwrule.from.wildcards.indexOf('any') === -1
+        ) {
             return published;
         }
 
@@ -166,13 +174,17 @@ function getNormalizedFilters(filters) {
         val = filters[name];
         if (Array.isArray(val)) {
             newFilters[name] = val; // Nothing to convert.
-        } else if (typeof (val) === 'object') {
+        } else if (typeof val === 'object') {
             // Convert to an array of keys.
             newFilters[name] = Object.keys(val);
         } else {
-            return new Error(format(
-                'invalid filter "%s" - expected an array or object, got: %j',
-                name, val));
+            return new Error(
+                format(
+                    'invalid filter "%s" - expected an array or object, got: %j',
+                    name,
+                    val
+                )
+            );
         }
     }
 
@@ -180,11 +192,12 @@ function getNormalizedFilters(filters) {
 }
 
 function getPublishedPorts(opts, fwrules, cb) {
-    getPublishingRules(opts, fwrules).forEach(function (fwrule) {
-        fwrule.ports.forEach(function (pbPort) {
+    getPublishingRules(opts, fwrules).forEach(function(fwrule) {
+        fwrule.ports.forEach(function(pbPort) {
             var curr, end;
-            if (pbPort.hasOwnProperty('start')
-                && pbPort.hasOwnProperty('end')) {
+            if (
+                pbPort.hasOwnProperty('start') && pbPort.hasOwnProperty('end')
+            ) {
                 end = pbPort.end;
                 for (curr = pbPort.start; curr <= end; curr++) {
                     cb(fwrule.protocol, curr);
@@ -196,7 +209,6 @@ function getPublishedPorts(opts, fwrules, cb) {
     });
 }
 
-
 /*
  * Get the Docker-compatible human-readable description of the container state.
  *
@@ -218,7 +230,7 @@ function _containerStatusFromVmobj(opts) {
         uptime = Math.floor((now - boot_timestamp) / 1000);
         status = 'Up ' + common.humanDuration(uptime);
     } else if (vmobj.state == 'provisioning' && vmobj.create_timestamp) {
-        uptime = Math.floor((now - (new Date(vmobj.create_timestamp))) / 1000);
+        uptime = Math.floor((now - new Date(vmobj.create_timestamp)) / 1000);
         status = 'Provisioning ' + common.humanDuration(uptime);
     } else if (vmobj.state == 'stopped') {
         /*
@@ -235,16 +247,23 @@ function _containerStatusFromVmobj(opts) {
          *    container is stopped. See RFD 30 to have a better answer
          *    for this.
          */
-        if (vmobj.hasOwnProperty('exit_status')
-            && vmobj.hasOwnProperty('exit_timestamp'))
-        {
-            exittime
-                = Math.floor((now - (new Date(vmobj.exit_timestamp))) / 1000);
-            status = 'Exited (' + vmobj.exit_status + ') '
-                + common.humanDuration(exittime) + ' ago';
-        } else if (vmobj.internal_metadata
-            && vmobj.internal_metadata.hasOwnProperty('docker:restartcount'))
-        {
+        if (
+            vmobj.hasOwnProperty('exit_status') &&
+            vmobj.hasOwnProperty('exit_timestamp')
+        ) {
+            exittime = Math.floor(
+                (now - new Date(vmobj.exit_timestamp)) / 1000
+            );
+            status =
+                'Exited (' +
+                vmobj.exit_status +
+                ') ' +
+                common.humanDuration(exittime) +
+                ' ago';
+        } else if (
+            vmobj.internal_metadata &&
+            vmobj.internal_metadata.hasOwnProperty('docker:restartcount')
+        ) {
             status = 'Exited';
         } else {
             status = 'Created';
@@ -258,9 +277,7 @@ function _containerStatusFromVmobj(opts) {
     return status;
 }
 
-
-function vmobjToContainer(opts, obj, fwrules, callback)
-{
+function vmobjToContainer(opts, obj, fwrules, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.app, 'opts.app');
     assert.object(opts.log, 'opts.log');
@@ -285,15 +302,15 @@ function vmobjToContainer(opts, obj, fwrules, callback)
     }
 
     if (obj.create_timestamp) {
-        container.Created
-            = Math.floor((new Date(obj.create_timestamp)).getTime()/1000);
+        container.Created = Math.floor(
+            new Date(obj.create_timestamp).getTime() / 1000
+        );
     } else {
         container.Created = 0;
     }
 
     if (im && im['docker:entrypoint']) {
-        cmd = cmd.concat(
-            JSON.parse(im['docker:entrypoint']));
+        cmd = cmd.concat(JSON.parse(im['docker:entrypoint']));
     }
     if (im && im['docker:cmd']) {
         cmd = cmd.concat(JSON.parse(im['docker:cmd']));
@@ -304,11 +321,11 @@ function vmobjToContainer(opts, obj, fwrules, callback)
     //
     /* JSSTYLED */
     // https://github.com/docker/docker/blob/3ec695924009421f9b1f79368e9e5b1e3e2ca94f/daemon/list.go#L127-L141
-    cmd.slice(1).forEach(function (arg) {
+    cmd.slice(1).forEach(function(arg) {
         if (arg.indexOf(' ') === -1) {
             quoted_args.push(arg);
         } else {
-            quoted_args.push('\'' + arg + '\'');
+            quoted_args.push("'" + arg + "'");
         }
     });
     container.Command = cmd.slice(0, 1).concat(quoted_args).join(' ');
@@ -319,8 +336,8 @@ function vmobjToContainer(opts, obj, fwrules, callback)
     container.Status = _containerStatusFromVmobj({vmobj: obj, log: log});
 
     // `docker ps` shows the image REPO[:TAG], or the short imageId.
-    container.Image = im['docker:imagename'] || im['docker:imageid']
-        || '<none>';
+    container.Image =
+        im['docker:imagename'] || im['docker:imageid'] || '<none>';
 
     // Add container labels from vm.tags:
     container.Labels = dockerLabelsFromVmTags(obj.tags || {});
@@ -332,28 +349,30 @@ function vmobjToContainer(opts, obj, fwrules, callback)
     container.Ports = [];
 
     // Add the exposed ports:
-    getPublishedPorts({ log: log, vm: obj }, fwrules, function (proto, port) {
+    getPublishedPorts({log: log, vm: obj}, fwrules, function(proto, port) {
         container.Ports.push({
-            'IP': '0.0.0.0',
+            IP: '0.0.0.0',
             // sdc-docker doesn't allow a different port mapping.
-            'PrivatePort': port,
-            'PublicPort': port,
-            'Type': proto
+            PrivatePort: port,
+            PublicPort: port,
+            Type: proto
         });
         seenPorts[proto].push(port);
     });
 
     // Add the unpublished ports:
-    ['tcp', 'udp'].forEach(function (proto) {
+    ['tcp', 'udp'].forEach(function(proto) {
         var imName = 'docker:' + proto + '_unpublished_ports';
         if (im[imName]) {
             var unpublishedPorts = JSON.parse(im[imName]);
-            unpublishedPorts.forEach(function (port) {
-                if (seenPorts.hasOwnProperty(proto)
-                    && seenPorts[proto].indexOf(port) === -1) {
+            unpublishedPorts.forEach(function(port) {
+                if (
+                    seenPorts.hasOwnProperty(proto) &&
+                    seenPorts[proto].indexOf(port) === -1
+                ) {
                     container.Ports.push({
-                        'PrivatePort': port,
-                        'Type': proto
+                        PrivatePort: port,
+                        Type: proto
                     });
                     seenPorts[proto].push(port);
                 }
@@ -367,11 +386,11 @@ function vmobjToContainer(opts, obj, fwrules, callback)
             owner_uuid: obj.owner_uuid,
             target_uuid: obj.uuid
         };
-        Link.find(opts.app, opts.log, params, function (err, links) {
+        Link.find(opts.app, opts.log, params, function(err, links) {
             if (err) {
                 return callback(err);
             }
-            links.forEach(function (l) {
+            links.forEach(function(l) {
                 container.Names.push(l.ps_config);
             });
 
@@ -383,7 +402,6 @@ function vmobjToContainer(opts, obj, fwrules, callback)
     _addLinkNames();
 }
 
-
 /*
  * Converts a dotted IPv4 address (eg: 1.2.3.4) to its integer value
  *
@@ -395,10 +413,12 @@ function addressToNumber(addr) {
     }
 
     var octets = addr.split('.');
-    return Number(octets[0]) * 16777216
-        + Number(octets[1]) * 65536
-        + Number(octets[2]) * 256
-        + Number(octets[3]);
+    return (
+        Number(octets[0]) * 16777216 +
+        Number(octets[1]) * 65536 +
+        Number(octets[2]) * 256 +
+        Number(octets[3])
+    );
 }
 
 /*
@@ -459,28 +479,28 @@ function vmobjToInspect(opts, obj, vmData, callback) {
     }
 
     container.Config = {
-        'AttachStderr': im['docker:attach_stderr'] || false,
-        'AttachStdin': im['docker:attach_stdin'] || false,
-        'AttachStdout': im['docker:attach_stdout'] || false,
-        'CpuShares': obj.cpu_shares,
-        'Cpuset': '',
-        'Domainname': obj.dns_domain || '',
-        'ExposedPorts': null,
-        'Hostname': obj.hostname || '',
-        'Image': im['docker:imagename'] || im['docker:imageid'] || '<none>',
-        'MacAddress': '',
-        'Memory': obj.max_physical_memory * (1024 * 1024),
-        'MemorySwap': obj.max_swap * (1024 * 1024),
-        'NetworkDisabled': false,
-        'OnBuild': null,
-        'OpenStdin': im['docker:open_stdin'] || false,
-        'PortSpecs': null,
-        'SecurityOpt': null,
-        'StdinOnce': false,
-        'Tty': im['docker:tty'] || false,
-        'User': im['docker:user'] || '',
-        'Volumes': {},
-        'WorkingDir': im['docker:workdir'] || ''
+        AttachStderr: im['docker:attach_stderr'] || false,
+        AttachStdin: im['docker:attach_stdin'] || false,
+        AttachStdout: im['docker:attach_stdout'] || false,
+        CpuShares: obj.cpu_shares,
+        Cpuset: '',
+        Domainname: obj.dns_domain || '',
+        ExposedPorts: null,
+        Hostname: obj.hostname || '',
+        Image: im['docker:imagename'] || im['docker:imageid'] || '<none>',
+        MacAddress: '',
+        Memory: obj.max_physical_memory * (1024 * 1024),
+        MemorySwap: obj.max_swap * (1024 * 1024),
+        NetworkDisabled: false,
+        OnBuild: null,
+        OpenStdin: im['docker:open_stdin'] || false,
+        PortSpecs: null,
+        SecurityOpt: null,
+        StdinOnce: false,
+        Tty: im['docker:tty'] || false,
+        User: im['docker:user'] || '',
+        Volumes: {},
+        WorkingDir: im['docker:workdir'] || ''
     };
 
     if (im && im['docker:cmd']) {
@@ -514,37 +534,37 @@ function vmobjToInspect(opts, obj, vmData, callback) {
     container.ExecDriver = 'sdc-0.1';
 
     container.HostConfig = {
-        'Binds': [],
-        'CapAdd': null,
-        'CapDrop': null,
-        'ContainerIDFile': '',
-        'Devices': [],
-        'Dns': null,
-        'DnsSearch': null,
-        'ExtraHosts': null,
-        'IpcMode': '',
-        'Links': null,
-        'LogConfig': {
-            'Type': 'json-file',
-            'Config': {}
+        Binds: [],
+        CapAdd: null,
+        CapDrop: null,
+        ContainerIDFile: '',
+        Devices: [],
+        Dns: null,
+        DnsSearch: null,
+        ExtraHosts: null,
+        IpcMode: '',
+        Links: null,
+        LogConfig: {
+            Type: 'json-file',
+            Config: {}
         },
-        'LxcConf': [],
-        'NetworkMode': 'bridge',
-        'PortBindings': {},
-        'Privileged': false,
-        'PublishAllPorts': false,
-        'RestartPolicy': {
-            'MaximumRetryCount': 0,
-            'Name': ''
+        LxcConf: [],
+        NetworkMode: 'bridge',
+        PortBindings: {},
+        Privileged: false,
+        PublishAllPorts: false,
+        RestartPolicy: {
+            MaximumRetryCount: 0,
+            Name: ''
         },
-        'VolumesFrom': null
+        VolumesFrom: null
     };
 
     container.Volumes = {};
     container.VolumesRW = {};
 
     if (obj.filesystems) {
-        obj.filesystems.forEach(function (f) {
+        obj.filesystems.forEach(function(f) {
             var m_data = f.source.match(data_volume_regex);
             var m_host = f.source.match(host_volume_regex);
             var im_hostvols;
@@ -562,15 +582,17 @@ function vmobjToInspect(opts, obj, vmData, callback) {
             } else if (f.type === 'lofs' && m_host) {
                 container.Volumes[f.target] = {};
                 // pull out the URL for the host volume.
-                if (obj.internal_metadata
-                    .hasOwnProperty('docker:hostvolumes')) {
-
-                    im_hostvols = JSON.parse(obj
-                        .internal_metadata['docker:hostvolumes']);
+                if (
+                    obj.internal_metadata.hasOwnProperty('docker:hostvolumes')
+                ) {
+                    im_hostvols = JSON.parse(
+                        obj.internal_metadata['docker:hostvolumes']
+                    );
 
                     if (im_hostvols[f.target] && im_hostvols[f.target].source) {
-                        container.HostConfig.Binds.push(im_hostvols[f.target]
-                            .source + ':' + f.target);
+                        container.HostConfig.Binds.push(
+                            im_hostvols[f.target].source + ':' + f.target
+                        );
                     }
                 }
             }
@@ -580,12 +602,13 @@ function vmobjToInspect(opts, obj, vmData, callback) {
     if (obj.internal_metadata && obj.internal_metadata['docker:volumesfrom']) {
         vf = JSON.parse(obj.internal_metadata['docker:volumesfrom']);
 
-        vf.forEach(function (vf_uuid) {
+        vf.forEach(function(vf_uuid) {
             if (!container.HostConfig.VolumesFrom) {
                 container.HostConfig.VolumesFrom = [];
             }
             container.HostConfig.VolumesFrom.push(
-                vmUuidToShortDockerId(vf_uuid));
+                vmUuidToShortDockerId(vf_uuid)
+            );
         });
     }
 
@@ -607,12 +630,11 @@ function vmobjToInspect(opts, obj, vmData, callback) {
         container.HostConfig.Dns = obj.resolvers;
     }
 
-    if (obj.internal_metadata
-        && obj.internal_metadata['docker:dnssearch']) {
-
+    if (obj.internal_metadata && obj.internal_metadata['docker:dnssearch']) {
         try {
-            container.HostConfig.DnsSearch
-                = JSON.parse(obj.internal_metadata['docker:dnssearch']);
+            container.HostConfig.DnsSearch = JSON.parse(
+                obj.internal_metadata['docker:dnssearch']
+            );
         } catch (e) {
             log.warn({err: e}, 'Failed to parse docker:dnssearch');
         }
@@ -620,19 +642,24 @@ function vmobjToInspect(opts, obj, vmData, callback) {
 
     if (obj.internal_metadata && obj.internal_metadata['docker:extraHosts']) {
         try {
-            container.HostConfig.ExtraHosts
-                = JSON.parse(obj.internal_metadata['docker:extraHosts']);
+            container.HostConfig.ExtraHosts = JSON.parse(
+                obj.internal_metadata['docker:extraHosts']
+            );
         } catch (e) {
-            log.warn({err: e,
-                containerId: container.Id,
-                extraHosts: obj.internal_metadata['docker:extraHosts']},
-                'Failed to parse docker:extraHosts');
+            log.warn(
+                {
+                    err: e,
+                    containerId: container.Id,
+                    extraHosts: obj.internal_metadata['docker:extraHosts']
+                },
+                'Failed to parse docker:extraHosts'
+            );
         }
     }
 
-    if (obj.internal_metadata
-        && obj.internal_metadata['docker:restartpolicy']) {
-
+    if (
+        obj.internal_metadata && obj.internal_metadata['docker:restartpolicy']
+    ) {
         restartpolicy = obj.internal_metadata['docker:restartpolicy'];
         if (restartpolicy === 'always') {
             container.HostConfig.RestartPolicy.Name = 'always';
@@ -641,41 +668,54 @@ function vmobjToInspect(opts, obj, vmData, callback) {
             if (parts[0] === 'on-failure') {
                 if (parts.length === 1) {
                     container.HostConfig.RestartPolicy.Name = 'on-failure';
-                } else if ((parts.length === 2) && (!isNaN(Number(parts[1])))) {
+                } else if (parts.length === 2 && !isNaN(Number(parts[1]))) {
                     container.HostConfig.RestartPolicy.Name = 'on-failure';
-                    container.HostConfig.RestartPolicy.MaximumRetryCount
-                        = Number(parts[1]);
+                    container.HostConfig.RestartPolicy.MaximumRetryCount = Number(
+                        parts[1]
+                    );
                 } else {
-                    log.warn('ignoring broken on-failure on container(%s): %s',
-                        container.Id, restartpolicy);
+                    log.warn(
+                        'ignoring broken on-failure on container(%s): %s',
+                        container.Id,
+                        restartpolicy
+                    );
                 }
             } else {
-                log.warn('ignoring unknown restartpolicy on container(%s): %s',
-                    container.Id, restartpolicy);
+                log.warn(
+                    'ignoring unknown restartpolicy on container(%s): %s',
+                    container.Id,
+                    restartpolicy
+                );
             }
         }
     }
 
-    if (obj.internal_metadata && obj.internal_metadata['docker:restartcount']
-        && !isNaN(Number(obj.internal_metadata['docker:restartcount']))) {
-
-        container.RestartCount
-            = Number(obj.internal_metadata['docker:restartcount']);
+    if (
+        obj.internal_metadata &&
+        obj.internal_metadata['docker:restartcount'] &&
+        !isNaN(Number(obj.internal_metadata['docker:restartcount']))
+    ) {
+        container.RestartCount = Number(
+            obj.internal_metadata['docker:restartcount']
+        );
     } else {
         container.RestartCount = 0;
     }
 
     if (obj.internal_metadata && obj.internal_metadata['docker:logdriver']) {
-        container.HostConfig.LogConfig.Type
-            = obj.internal_metadata['docker:logdriver'];
+        container.HostConfig.LogConfig.Type =
+            obj.internal_metadata['docker:logdriver'];
         if (obj.internal_metadata['docker:logconfig']) {
             try {
-                logConfig
-                    = JSON.parse(obj.internal_metadata['docker:logconfig']);
+                logConfig = JSON.parse(
+                    obj.internal_metadata['docker:logconfig']
+                );
                 container.HostConfig.LogConfig.Config = logConfig;
             } catch (e) {
-                log.warn({err: e, obj: obj},
-                    'unable to parse docker:logconfig');
+                log.warn(
+                    {err: e, obj: obj},
+                    'unable to parse docker:logconfig'
+                );
             }
         }
     }
@@ -688,20 +728,20 @@ function vmobjToInspect(opts, obj, vmData, callback) {
 
     // default to empty
     container.NetworkSettings = {
-        'PortMapping': null,
-        'Ports': {}
+        PortMapping: null,
+        Ports: {}
     };
 
-    obj.nics.forEach(function (nic) {
+    obj.nics.forEach(function(nic) {
         if (nic.primary) {
             container.NetworkSettings = {
-                'Bridge': nic.interface,
-                'Gateway': nic.gateway,
-                'IPAddress': nic.ip,
-                'IPPrefixLen': netmaskToBits(nic.netmask),
-                'MacAddress': nic.mac,
-                'PortMapping': null,
-                'Ports': {}
+                Bridge: nic.interface,
+                Gateway: nic.gateway,
+                IPAddress: nic.ip,
+                IPPrefixLen: netmaskToBits(nic.netmask),
+                MacAddress: nic.mac,
+                PortMapping: null,
+                Ports: {}
             };
         }
     });
@@ -710,12 +750,12 @@ function vmobjToInspect(opts, obj, vmData, callback) {
         container.HostConfig.PublishAllPorts = true;
     }
 
-    ['tcp', 'udp'].forEach(function (proto) {
+    ['tcp', 'udp'].forEach(function(proto) {
         var imName = 'docker:' + proto + '_unpublished_ports';
         if (im[imName]) {
             var unpublishedPorts = JSON.parse(im[imName]);
             container.Config.ExposedPorts = {};
-            unpublishedPorts.forEach(function (port) {
+            unpublishedPorts.forEach(function(port) {
                 var portStr = format('%d/%s', port, proto);
                 container.Config.ExposedPorts[portStr] = {};
                 container.NetworkSettings.Ports[portStr] = null;
@@ -728,15 +768,15 @@ function vmobjToInspect(opts, obj, vmData, callback) {
 
         container.NetworkSettings.Ports[portStr] = [
             {
-                'HostIp': '0.0.0.0',
-                'HostPort': cp.toString()
+                HostIp: '0.0.0.0',
+                HostPort: cp.toString()
             }
         ];
 
         container.HostConfig.PortBindings[portStr] = [
             {
-                'HostIp': '',
-                'HostPort': cp.toString()
+                HostIp: '',
+                HostPort: cp.toString()
             }
         ];
 
@@ -747,21 +787,21 @@ function vmobjToInspect(opts, obj, vmData, callback) {
         container.Config.ExposedPorts[portStr] = {};
     }
 
-    getPublishedPorts({ log: log, vm: obj }, fwrules, addPublishedPort);
+    getPublishedPorts({log: log, vm: obj}, fwrules, addPublishedPort);
 
     container.ProcessLabel = '';
     container.ResolvConfPath = '/etc/resolv.conf';
 
     container.State = {
-        'Error': '', // TODO: fill this in when error available
-        'ExitCode': obj.exit_status || 0,
-        'FinishedAt': obj.exit_timestamp || '0001-01-01T00:00:00Z',
-        'OOMKilled': false,
-        'Paused': false,
-        'Pid': obj.pid || 0,
-        'Restarting': false,
-        'Running': ((obj.state === 'running') ? true : false),
-        'StartedAt': obj.boot_timestamp || '0001-01-01T00:00:00Z'
+        Error: '', // TODO: fill this in when error available
+        ExitCode: obj.exit_status || 0,
+        FinishedAt: obj.exit_timestamp || '0001-01-01T00:00:00Z',
+        OOMKilled: false,
+        Paused: false,
+        Pid: obj.pid || 0,
+        Restarting: false,
+        Running: obj.state === 'running' ? true : false,
+        StartedAt: obj.boot_timestamp || '0001-01-01T00:00:00Z'
     };
 
     /*
@@ -809,12 +849,12 @@ function vmobjToInspect(opts, obj, vmData, callback) {
             owner_uuid: obj.owner_uuid,
             container_uuid: obj.uuid
         };
-        Link.find(opts.app, log, params, function (err, links) {
+        Link.find(opts.app, log, params, function(err, links) {
             if (err) {
                 return callback(err);
             }
             if (links && links.length > 0) {
-                container.HostConfig.Links = links.map(function (l) {
+                container.HostConfig.Links = links.map(function(l) {
                     return l.inspect_config;
                 });
             }
@@ -857,7 +897,7 @@ function imgobjToInspect(obj, imgTags) {
 
     // Add image tags if available.
     if (imgTags && imgTags.length > 0) {
-        dockerImage.RepoTags = imgTags.map(function (it) {
+        dockerImage.RepoTags = imgTags.map(function(it) {
             return it.repo + ':' + it.tag;
         });
     }
@@ -896,15 +936,15 @@ function compressPorts(ports) {
         if (start === 0) {
             start = port;
             end = port;
-        } else if ((end + 1) === port) {
+        } else if (end + 1 === port) {
             end = port;
         } else {
-            ranges.push(start === end ? start : { start: start, end: end });
+            ranges.push(start === end ? start : {start: start, end: end});
             start = port;
             end = port;
         }
     }
-    ranges.push(start === end ? start : { start: start, end: end });
+    ranges.push(start === end ? start : {start: start, end: end});
 
     return ranges;
 }
diff --git a/lib/common.js b/lib/common.js
index 75a864a..5734c77 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -43,7 +43,7 @@ var LOG_DRIVERS;
  */
 // TODO: add min_platform for each driver when these are supported.
 LOG_DRIVERS = {
-    'fluentd': {
+    fluentd: {
         default_opts: {
             'fluentd-tag': '{{.ID}}'
         },
@@ -53,7 +53,7 @@ LOG_DRIVERS = {
             'fluentd-tag': 'string'
         }
     },
-    'gelf': {
+    gelf: {
         default_opts: {
             'gelf-tag': '{{.ID}}'
         },
@@ -69,7 +69,7 @@ LOG_DRIVERS = {
             'max-file': 'positiveinteger'
         }
     },
-    'syslog': {
+    syslog: {
         default_opts: {
             'syslog-facility': 'daemon',
             'syslog-tag': '{{.ID}}'
@@ -77,43 +77,62 @@ LOG_DRIVERS = {
         opts: {
             'syslog-address': 'syslogAddress',
             'syslog-facility': [
-                '0', 'kern',
-                '1', 'user',
-                '2', 'mail',
-                '3', 'daemon',
-                '4', 'auth',
-                '5', 'syslog',
-                '6', 'lpr',
-                '7', 'news',
-                '8', 'uucp',
+                '0',
+                'kern',
+                '1',
+                'user',
+                '2',
+                'mail',
+                '3',
+                'daemon',
+                '4',
+                'auth',
+                '5',
+                'syslog',
+                '6',
+                'lpr',
+                '7',
+                'news',
+                '8',
+                'uucp',
                 '9',
-                '10', 'authpriv',
-                '11', 'ftp',
+                '10',
+                'authpriv',
+                '11',
+                'ftp',
                 '12',
                 '13',
                 '14',
-                '15', 'cron',
-                '16', 'local0',
-                '17', 'local1',
-                '18', 'local2',
-                '19', 'local3',
-                '20', 'local4',
-                '21', 'local5',
-                '22', 'local6',
-                '23', 'local7'
+                '15',
+                'cron',
+                '16',
+                'local0',
+                '17',
+                'local1',
+                '18',
+                'local2',
+                '19',
+                'local3',
+                '20',
+                'local4',
+                '21',
+                'local5',
+                '22',
+                'local6',
+                '23',
+                'local7'
             ],
             'syslog-tag': 'string'
         },
         opts_help: {
-            'syslog-facility': 'one of: kern,user,mail,daemon,auth,syslog,lpr,'
-                + 'news,uucp,authpriv,ftp,cron,local[0-7] or [0-23]'
+            'syslog-facility': 'one of: kern,user,mail,daemon,auth,syslog,lpr,' +
+                'news,uucp,authpriv,ftp,cron,local[0-7] or [0-23]'
         },
         required_opts: ['syslog-address']
     },
-    'none': {}
+    none: {}
 };
 
-
 /**
  * Given a duration in seconds, return a human-friendly string.
  */
@@ -148,7 +167,6 @@ function humanDuration(seconds) {
     return sprintf('%0.6f years', years);
 }
 
-
 /**
  * Adapted from <http://stackoverflow.com/a/18650828> but using
  * `docker run --memory MEMORY` suffixes.
@@ -161,12 +179,10 @@ function humanSizeFromBytes(bytes) {
     }
     var i = Number(Math.floor(Math.log(bytes) / Math.log(1024)));
     var s = String(bytes / Math.pow(1024, i));
-    var precision0 = (s.indexOf('.') === -1
-        ? s : s.slice(0, s.indexOf('.')));
+    var precision0 = s.indexOf('.') === -1 ? s : s.slice(0, s.indexOf('.'));
     return sprintf('%s%s', precision0, sizes[i]);
 }
 
-
 /**
  * Parse a Docker Remote API boolean query param string into a boolean.
  *
@@ -185,10 +201,10 @@ function humanSizeFromBytes(bytes) {
 var _falseValues = {
     '': true,
     '0': true,
-    'no': true,
-    'none': true,
-    'false': true,
-    'False': true
+    no: true,
+    none: true,
+    false: true,
+    False: true
 };
 function boolFromQueryParam(param) {
     if (param === undefined) {
@@ -204,7 +220,6 @@ function boolFromQueryParam(param) {
     }
 }
 
-
 var STREAM_TYPES = {
     stdin: 0,
     stdout: 1,
@@ -236,7 +251,6 @@ function generateDockerId() {
     return (libuuid.create() + libuuid.create()).replace(/-/g, '');
 }
 
-
 /**
  * Helps formatting a JSON progress message that a docker client will understand
  * and properly format when running docker pull or docker import
@@ -250,7 +264,6 @@ function formatProgress(args) {
     return progress;
 }
 
-
 /**
  * Writes a JSON progress object to an HTTP response object. Docker
  * expects a progressDetail object even if it's empty
@@ -269,7 +282,6 @@ function writeStatus(res, progress) {
     res.write(JSON.stringify(formatProgress(progress)));
 }
 
-
 /*
  * Wait for a job to complete. Callback with an error if the job fails
  * (execution of 'failed' or 'canceled'). The returned error attempts to
@@ -279,7 +291,7 @@ function waitForJob(wfClient, job_uuid, cb) {
     assert.string(job_uuid, 'job_uuid');
     assert.func(cb, 'cb');
 
-    pollJob(wfClient, job_uuid, function (err, job) {
+    pollJob(wfClient, job_uuid, function(err, job) {
         if (err) {
             /*jsl:pass*/
         } else if (job.execution === 'failed') {
@@ -289,8 +301,9 @@ function waitForJob(wfClient, job_uuid, cb) {
                  * WFAPI will set `<result>.error.{message,name}`. We'll carry
                  * through 'name' as a possible error code.
                  */
-                err = new Error(result.error.message
-                    || JSON.stringify(result.error));
+                err = new Error(
+                    result.error.message || JSON.stringify(result.error)
+                );
                 if (result.error.name) {
                     err.code = result.error.name;
                 } else if (result.error.body && result.error.body.code) {
@@ -306,7 +319,6 @@ function waitForJob(wfClient, job_uuid, cb) {
     });
 }
 
-
 /*
  * Poll a job until it reaches a completed state:
  * - execution='succeeded':
@@ -319,12 +331,12 @@ function pollJob(client, job_uuid, cb) {
     var attempts = 0;
     var errs = 0;
 
-    var timeout = 1000;  // 1 second
-    var limit = 720;     // 1 hour
+    var timeout = 1000; // 1 second
+    var limit = 720; // 1 hour
     var completedStates = ['succeeded', 'failed', 'canceled'];
 
-    var poll = function () {
-        client.getJob(job_uuid, function (err, job) {
+    var poll = function() {
+        client.getJob(job_uuid, function(err, job) {
             attempts++;
 
             if (err) {
@@ -349,7 +361,6 @@ function pollJob(client, job_uuid, cb) {
     poll();
 }
 
-
 /*
  * Returns a handler that will prevent logging successful GET requests
  * because their response bodies can be too big in many cases
@@ -358,14 +369,17 @@ function filteredAuditLog(req, res, route, err) {
     var logResponseBody = true;
 
     // Successful GET res bodies are uninteresting and *big*.
-    if ((req.method === 'GET') && Math.floor(res.statusCode/100) === 2)
+    if (req.method === 'GET' && Math.floor(res.statusCode / 100) === 2)
         logResponseBody = false;
 
     auditLogger({
-        log: req.log.child({
-            component: 'audit',
-            route: route && route.name
-        }, true),
+        log: req.log.child(
+            {
+                component: 'audit',
+                route: route && route.name
+            },
+            true
+        ),
 
         responseBody: {
             log: logResponseBody
@@ -373,7 +387,6 @@ function filteredAuditLog(req, res, route, err) {
     })(req, res, route, err);
 }
 
-
 /*
  * Returns a handler that will log uncaught exceptions properly
  */
@@ -393,17 +406,22 @@ function uncaughtHandler(req, res, route, err) {
      *
      *      {"code":"InternalError","message":"Internal error"}
      */
-    req.log.error({err: err, route: route && route.name,
-        req: req}, 'Uncaught exception');
+    req.log.error(
+        {
+            err: err,
+            route: route && route.name,
+            req: req
+        },
+        'Uncaught exception'
+    );
 }
 
-
 /*
  * Handler for checking if the required servics are online before serving
  * any request
  */
 function checkServices(req, res, next) {
-    req.app.connWatcher.checkAvailability(function (err) {
+    req.app.connWatcher.checkAvailability(function(err) {
         if (err) {
             return next(err);
         }
@@ -411,7 +429,6 @@ function checkServices(req, res, next) {
     });
 }
 
-
 function checkReadonlyMode(req, res, next) {
     if (!req.app.config.readOnly) {
         next();
@@ -423,8 +440,9 @@ function checkReadonlyMode(req, res, next) {
         if (req.app.config.dcMaintUtcEta) {
             res.setHeader('Retry-After', req.app.config.dcMaintUtcEta);
         }
-        var msg = req.app.config.dcMaintMessage
-            || 'docker service is currently in read-only mode for maintenance';
+        var msg =
+            req.app.config.dcMaintMessage ||
+            'docker service is currently in read-only mode for maintenance';
         return next(new restify.ServiceUnavailableError(msg));
     }
 
@@ -448,22 +466,32 @@ function reqClientApiVersion(req, res, next) {
     if (apiversion.match(/^\/v[0-9\.]+$/)) {
         apiversion = apiversion.slice(2);
 
-        if (constants.MIN_API_VERSION
-            && apiversion < constants.MIN_API_VERSION)
-        {
-            return next(new restify.InvalidVersionError(
-                'client API version (' + apiversion
-                + ') is less than the minimum required API version ('
-                + constants.MIN_API_VERSION + ')'));
+        if (
+            constants.MIN_API_VERSION && apiversion < constants.MIN_API_VERSION
+        ) {
+            return next(
+                new restify.InvalidVersionError(
+                    'client API version (' +
+                        apiversion +
+                        ') is less than the minimum required API version (' +
+                        constants.MIN_API_VERSION +
+                        ')'
+                )
+            );
         }
 
-        if (constants.MAX_API_VERSION
-            && apiversion > constants.MAX_API_VERSION)
-        {
-            return next(new restify.InvalidVersionError(
-                'client API version (' + apiversion
-                + ') is greater than the maximum allowed API version ('
-                + constants.MAX_API_VERSION + ')'));
+        if (
+            constants.MAX_API_VERSION && apiversion > constants.MAX_API_VERSION
+        ) {
+            return next(
+                new restify.InvalidVersionError(
+                    'client API version (' +
+                        apiversion +
+                        ') is greater than the maximum allowed API version (' +
+                        constants.MAX_API_VERSION +
+                        ')'
+                )
+            );
         }
 
         log.trace({apiversion: apiversion}, 'request has ok API version');
@@ -471,16 +499,23 @@ function reqClientApiVersion(req, res, next) {
         return next();
     }
 
-    log.warn({apiversion: apiversion, req: req},
-        'request has invalid API version');
-
-    return next(new restify.InvalidVersionError(
-        'client and server don\'t have same API version '
-        + '(client : ' + apiversion + ', server: '
-        + constants.API_VERSION + ')'));
+    log.warn(
+        {apiversion: apiversion, req: req},
+        'request has invalid API version'
+    );
+
+    return next(
+        new restify.InvalidVersionError(
+            "client and server don't have same API version " +
+                '(client : ' +
+                apiversion +
+                ', server: ' +
+                constants.API_VERSION +
+                ')'
+        )
+    );
 }
 
-
 /**
  * Checks that an account has the approved_for_provisioning flag set. If not,
  * it returns an HTTP unauthorized error to the callback.
@@ -490,8 +525,10 @@ function checkApprovedForProvisioning(req, res, next) {
     var approved = account.approved_for_provisioning;
 
     if (approved !== 'true' && approved !== true) {
-        var errMsg = account.login + ' does not have permission to pull or '
-            + 'provision';
+        var errMsg =
+            account.login +
+            ' does not have permission to pull or ' +
+            'provision';
         next(new restify.NotAuthorizedError(errMsg));
         return;
     }
@@ -499,7 +536,6 @@ function checkApprovedForProvisioning(req, res, next) {
     next();
 }
 
-
 /**
  * Returns true if the object has no keys
  */
@@ -540,16 +576,20 @@ function isUUID(str) {
 function dockerIdToUuid(dockerId) {
     var out;
 
-    out = dockerId.substr(0, 8) + '-'
-        + dockerId.substr(8, 4) + '-'
-        + dockerId.substr(12, 4) + '-'
-        + dockerId.substr(16, 4) + '-'
-        + dockerId.substr(20, 12);
-
-    return (out);
+    out =
+        dockerId.substr(0, 8) +
+        '-' +
+        dockerId.substr(8, 4) +
+        '-' +
+        dockerId.substr(12, 4) +
+        '-' +
+        dockerId.substr(16, 4) +
+        '-' +
+        dockerId.substr(20, 12);
+
+    return out;
 }
 
-
 /**
  * Return vm object (as described by vmapi) given the vm uuid.
  *
@@ -579,7 +619,7 @@ function getVmByUuid(uuid, opts, callback) {
         req_id: opts.req_id
     };
 
-    opts.vmapi.getVm(getVmParams, getVmOpts, function (err, vm) {
+    opts.vmapi.getVm(getVmParams, getVmOpts, function(err, vm) {
         if (err) {
             opts.log.error(err, 'Error getting container.');
             return callback(err);
@@ -603,10 +643,14 @@ function getVm(req, res, next) {
         vmapi: req.app.vmapi
     };
 
-    req.backend.getVmById(req.params.id, opts, function (err, vmobj) {
+    req.backend.getVmById(req.params.id, opts, function(err, vmobj) {
         if (err) {
-            next(new errors.DockerError(err, format('No such container: %s',
-                req.params.id)));
+            next(
+                new errors.DockerError(
+                    err,
+                    format('No such container: %s', req.params.id)
+                )
+            );
             return;
         }
 
@@ -615,7 +659,6 @@ function getVm(req, res, next) {
     });
 }
 
-
 /*
  * Restify handler to set `req.image` to the docker image named by
  * `req.body.Image`. `req.image` is a instance of the `Image` model.
@@ -627,14 +670,17 @@ function reqImage(req, res, next) {
         account: req.account,
         name: req.body.Image
     };
-    req.backend.imgFromName(opts, function (err, img) {
+    req.backend.imgFromName(opts, function(err, img) {
         if (err) {
             next(err);
         } else if (!img) {
-            next(new errors.ResourceNotFoundError(
-                // Note: Error message must match the docker remote api, of
-                // 'No such image...', see DOCKER-409.
-                'No such image: ' + req.body.Image));
+            next(
+                new errors.ResourceNotFoundError(
+                    // Note: Error message must match the docker remote api, of
+                    // 'No such image...', see DOCKER-409.
+                    'No such image: ' + req.body.Image
+                )
+            );
         } else {
             req.image = img;
             next();
@@ -662,14 +708,17 @@ function reqImageIncludeSmartos(req, res, next) {
         name: req.body.Image,
         includeSmartos: true
     };
-    req.backend.imgFromName(opts, function (err, img) {
+    req.backend.imgFromName(opts, function(err, img) {
         if (err) {
             next(err);
         } else if (!img) {
-            next(new errors.ResourceNotFoundError(
-                // Note: Error message must match the docker remote api, of
-                // 'No such image...', see DOCKER-409.
-                'No such image: ' + req.body.Image));
+            next(
+                new errors.ResourceNotFoundError(
+                    // Note: Error message must match the docker remote api, of
+                    // 'No such image...', see DOCKER-409.
+                    'No such image: ' + req.body.Image
+                )
+            );
         } else {
             req.image = img;
             next();
@@ -677,7 +726,6 @@ function reqImageIncludeSmartos(req, res, next) {
     });
 }
 
-
 /*
  * Restify handler to set `req.regAuth` from the x-registry-auth request
  * header, if any.
@@ -686,18 +734,24 @@ function reqRegAuth(req, res, next) {
     req.regAuth = null;
     if (req.headers['x-registry-auth']) {
         try {
-            req.regAuth = JSON.parse(new Buffer(
-                req.headers['x-registry-auth'], 'base64').toString('utf8'));
+            req.regAuth = JSON.parse(
+                new Buffer(req.headers['x-registry-auth'], 'base64').toString(
+                    'utf8'
+                )
+            );
         } catch (e) {
-            req.log.info(e,
-                format('invalid x-registry-auth header: %j (ignoring)',
-                    req.header['x-registry-auth']));
+            req.log.info(
+                e,
+                format(
+                    'invalid x-registry-auth header: %j (ignoring)',
+                    req.header['x-registry-auth']
+                )
+            );
         }
     }
     next();
 }
 
-
 /*
  * Add common (restify) HTTP client options to the given `clientOpts`.
  * Existing fields in `clientOpts` win. E.g. this function typically sets
@@ -720,10 +774,10 @@ function httpClientOpts(clientOpts, req) {
 
     // headers.request-id
     if (req && req.getId()) {
-        var req_id = (clientOpts.headers
-            ? clientOpts.headers['request-id']
-                || clientOpts.headers['x-request-id']
-            : undefined);
+        var req_id = clientOpts.headers
+            ? clientOpts.headers['request-id'] ||
+                  clientOpts.headers['x-request-id']
+            : undefined;
         if (!req_id) {
             if (!clientOpts.headers) {
                 clientOpts.headers = {};
@@ -751,16 +805,15 @@ function httpClientOpts(clientOpts, req) {
  *  (apiVersionCmp(a, b) < 0)  // ensure a < b
  *
  */
-function apiVersionCmp(A, B)
-{
+function apiVersionCmp(A, B) {
     var a = A;
     var aMatch;
     var b = B;
     var bMatch;
     var re = /^([0-9]+)\.([0-9]+)$/;
 
-    if (typeof (a) === 'number') {
-        if ((a % 1) !== 0) {
+    if (typeof a === 'number') {
+        if (a % 1 !== 0) {
             // we have a 1.xxx
             a = a.toString();
         } else {
@@ -768,8 +821,8 @@ function apiVersionCmp(A, B)
             a = a.toFixed(1);
         }
     }
-    if (typeof (b) === 'number') {
-        if ((b % 1) !== 0) {
+    if (typeof b === 'number') {
+        if (b % 1 !== 0) {
             b = b.toString();
         } else {
             b = b.toFixed(1);
@@ -787,16 +840,16 @@ function apiVersionCmp(A, B)
 
     // They match!
     if (a === b) {
-        return (0);
+        return 0;
     }
 
     // compare major versions
     if (Number(aMatch[1]) !== Number(bMatch[1])) {
-        return (Number(aMatch[1]) - Number(bMatch[1]));
+        return Number(aMatch[1]) - Number(bMatch[1]);
     }
 
     // compare minor versions
-    return (Number(aMatch[2]) - Number(bMatch[2]));
+    return Number(aMatch[2]) - Number(bMatch[2]);
 }
 
 module.exports = {
diff --git a/lib/config-loader.js b/lib/config-loader.js
index f1e8be5..cab25af 100644
--- a/lib/config-loader.js
+++ b/lib/config-loader.js
@@ -32,8 +32,10 @@ function loadConfigSync(opts) {
     }
     assert.arrayOfString(config.enabledLogDrivers, 'config.enabledLogDrivers');
     config.enabledLogDrivers.forEach(function _checkLogDriver(driver) {
-        assert.ok(common.LOG_DRIVERS.hasOwnProperty(driver),
-            'config.enabledLogDrivers.' + driver + ' is not a valid driver');
+        assert.ok(
+            common.LOG_DRIVERS.hasOwnProperty(driver),
+            'config.enabledLogDrivers.' + driver + ' is not a valid driver'
+        );
     });
 
     if (config.hasOwnProperty('fwrule_version')) {
diff --git a/lib/connwatcher.js b/lib/connwatcher.js
index 1e8539b..20284c4 100644
--- a/lib/connwatcher.js
+++ b/lib/connwatcher.js
@@ -25,7 +25,7 @@ ConnectionStatusWatcher.prototype.register = function register(opts) {
     assert.func(opts.init, 'opts.init');
     assert.optionalFunc(opts.isAvaiable, 'opts.init');
 
-    opts.init(function (err, connection) {
+    opts.init(function(err, connection) {
         self.connections[opts.name] = {
             connection: connection,
             available: false
@@ -44,17 +44,20 @@ ConnectionStatusWatcher.prototype.register = function register(opts) {
 
     function ping() {
         schedulePing();
-        opts.ping(self.connections[opts.name].connection, function (err) {
+        opts.ping(self.connections[opts.name].connection, function(err) {
             if (err) {
-                self.log.error({ err: err }, 'error pinging %s', opts.name);
+                self.log.error({err: err}, 'error pinging %s', opts.name);
                 self.connections[opts.name].available = false;
                 return;
             }
 
             if (!self.connections[opts.name].available) {
-                self.log.error({ err: err },
-                    '%s appears to have recovered and is responding to '
-                    + 'pings without error', opts.name);
+                self.log.error(
+                    {err: err},
+                    '%s appears to have recovered and is responding to ' +
+                        'pings without error',
+                    opts.name
+                );
             }
 
             self.connections[opts.name].available = true;
@@ -63,15 +66,16 @@ ConnectionStatusWatcher.prototype.register = function register(opts) {
     }
 
     function schedulePing() {
-        self.connections[opts.name].interval = setTimeout(function () {
+        self.connections[opts.name].interval = setTimeout(function() {
             ping();
         }, opts.pingIntervalSecs * 1000);
     }
 };
 
-
-ConnectionStatusWatcher.prototype.checkAvailability =
-function checkAvailability(names, callback) {
+ConnectionStatusWatcher.prototype.checkAvailability = function checkAvailability(
+    names,
+    callback
+) {
     var self = this;
 
     if (!callback) {
@@ -83,24 +87,30 @@ function checkAvailability(names, callback) {
         names = Object.keys(self.connections);
     }
 
-    var notAvailable = names.filter(function (name) {
+    var notAvailable = names.filter(function(name) {
         if (self.connections[name].hasOwnProperty('isAvailable')) {
             return !self.connections[name].isAvailable(
-                self.connections[name].connection);
+                self.connections[name].connection
+            );
         } else {
             return !self.connections[name].available;
         }
     });
 
     if (notAvailable.length) {
-        callback(new errors.ServiceDegradedError(
-            new Error('connection(s) to ' + notAvailable.join(', ')
-            + ' not available')));
+        callback(
+            new errors.ServiceDegradedError(
+                new Error(
+                    'connection(s) to ' +
+                        notAvailable.join(', ') +
+                        ' not available'
+                )
+            )
+        );
         return;
     }
 
     callback();
 };
 
-
 module.exports = ConnectionStatusWatcher;
diff --git a/lib/constants.js b/lib/constants.js
index a2bc17d..6abac81 100644
--- a/lib/constants.js
+++ b/lib/constants.js
@@ -1,5 +1,4 @@
 module.exports = {
-
     // The docker server version reported for 'docker version'.
     SERVER_VERSION: '1.9.0',
 
diff --git a/lib/docker.js b/lib/docker.js
index d1d05f7..f1a0f5a 100644
--- a/lib/docker.js
+++ b/lib/docker.js
@@ -46,18 +46,16 @@ var SocketManager = require('./socket-manager');
 var wfapi = require('./wfapi');
 var configLoader = require('./config-loader');
 
-
 //---- globals
 
 var TLS_KEY = '/data/tls/key.pem';
 var TLS_CERT = '/data/tls/cert.pem';
 
-var VERSION = JSON.parse(fs.readFileSync(path.normalize(
-    __dirname + '/../package.json'), 'utf8')).version;
+var VERSION = JSON.parse(
+    fs.readFileSync(path.normalize(__dirname + '/../package.json'), 'utf8')
+).version;
 var request_seq_id = 0;
 
-
-
 //---- the App
 
 function App(opts) {
@@ -77,17 +75,16 @@ function App(opts) {
 
     // TODO make the other clients accessible via req.app
 
-    self.sockets = new SocketManager({ log: self.log });
+    self.sockets = new SocketManager({log: self.log});
     self.initAuthCache();
 
     if (self.config.readOnly) {
-        self.log.warn(
-            'starting in read-only mode');
+        self.log.warn('starting in read-only mode');
     }
 
-    var server = self.server = self.setupServer();
+    var server = (self.server = self.setupServer());
 
-    server.server.on('upgrade', function (oldreq, socket, body) {
+    server.server.on('upgrade', function(oldreq, socket, body) {
         self.log.info('Socket has been upgraded');
 
         // Unfortunately there's no way of detecting the docker client's
@@ -100,7 +97,7 @@ function App(opts) {
         }
     });
 
-    server.use(function (req, res, next) {
+    server.use(function(req, res, next) {
         // Headers we want for all responses.
         res.on('header', function onHeader() {
             var now = Date.now();
@@ -111,8 +108,10 @@ function App(opts) {
 
             // DOCKER-617: Set a server version to be compatible with docker.
             // As the docker/docker tests require this header.
-            res.header('Server', fmt('Triton/%s (linux)',
-                                    constants.SERVER_VERSION));
+            res.header(
+                'Server',
+                fmt('Triton/%s (linux)', constants.SERVER_VERSION)
+            );
         });
 
         req.app = self;
@@ -123,18 +122,21 @@ function App(opts) {
     });
 
     server.use(restify.requestLogger());
-    server.use(function (req, res, next) {
+    server.use(function(req, res, next) {
         req.trace = trace_event.createBunyanTracer({
             log: req.log
         });
         if (req.route) {
             request_seq_id = (request_seq_id + 1) % 1000;
-            req.trace.seq_id = (req.time() * 1000) + request_seq_id;
-            req.trace.begin({name: req.route.name, req_seq: req.trace.seq_id});
+            req.trace.seq_id = req.time() * 1000 + request_seq_id;
+            req.trace.begin({
+                name: req.route.name,
+                req_seq: req.trace.seq_id
+            });
         }
         next();
     });
-    server.on('after', function (req, res, route, err) {
+    server.on('after', function(req, res, route, err) {
         if (route) {
             req.trace.end({name: route.name, req_seq: req.trace.seq_id});
         }
@@ -145,7 +147,7 @@ function App(opts) {
     endpoints.register(server, self.log, [
         common.checkReadonlyMode,
         common.checkServices,
-        auth.auth(self.config, self.log),  /* sets `req.account` */
+        auth.auth(self.config, self.log) /* sets `req.account` */,
         common.reqClientApiVersion
     ]);
 
@@ -162,13 +164,13 @@ App.prototype.setupConnections = function setupConnections() {
     // Set up our dependencies
     self.connWatcher.register({
         name: 'cnapi',
-        init: function (cb) {
+        init: function(cb) {
             var cnapi = new CNAPI(self.config.cnapi);
             cb(null, cnapi);
         },
         pingIntervalSecs: 10,
-        ping: function (cnapi, cb) {
-            cnapi.ping(function (err) {
+        ping: function(cnapi, cb) {
+            cnapi.ping(function(err) {
                 if (err) {
                     cb(new verror.VError(err, 'could not ping CNAPI'));
                     return;
@@ -180,13 +182,13 @@ App.prototype.setupConnections = function setupConnections() {
 
     self.connWatcher.register({
         name: 'vmapi',
-        init: function (cb) {
+        init: function(cb) {
             var vmapi = new VMAPI(self.config.vmapi);
             cb(null, vmapi);
         },
         pingIntervalSecs: 10,
-        ping: function (vmapi, cb) {
-            vmapi.ping(function (err) {
+        ping: function(vmapi, cb) {
+            vmapi.ping(function(err) {
                 if (err) {
                     cb(new verror.VError(err, 'could not ping VMAPI'));
                     return;
@@ -198,13 +200,13 @@ App.prototype.setupConnections = function setupConnections() {
 
     self.connWatcher.register({
         name: 'imgapi',
-        init: function (cb) {
+        init: function(cb) {
             var imgapi = new IMGAPI(self.config.imgapi);
             cb(null, imgapi);
         },
         pingIntervalSecs: 10,
-        ping: function (imgapi, cb) {
-            imgapi.ping(function (err) {
+        ping: function(imgapi, cb) {
+            imgapi.ping(function(err) {
                 if (err) {
                     cb(new verror.VError(err, 'could not ping IMGAPI'));
                     return;
@@ -216,41 +218,42 @@ App.prototype.setupConnections = function setupConnections() {
 
     self.connWatcher.register({
         name: 'wfapi',
-        init: function (cb) {
+        init: function(cb) {
             var wfclient = new wfapi(self.config.wfapi, self.log);
-            wfclient.connect(function () {
+            wfclient.connect(function() {
                 self.log.info('wfapi is ready');
             });
             cb(null, wfclient);
         },
-        isAvailable: function (wfclient) {
+        isAvailable: function(wfclient) {
             return wfclient.connected;
         }
     });
 
     self.connWatcher.register({
         name: 'moray',
-        init: function (cb) {
+        init: function(cb) {
             var morayClient = self.createMorayClient();
             cb(null, morayClient);
         },
-        isAvailable: function () {
-            return self.connWatcher.connections.moray
-                && self.connWatcher.connections.moray.connection.connected;
+        isAvailable: function() {
+            return (
+                self.connWatcher.connections.moray &&
+                self.connWatcher.connections.moray.connection.connected
+            );
         }
     });
 
-    self.createUfdsClient(self.config.ufds, function (err, ufds) {
+    self.createUfdsClient(self.config.ufds, function(err, ufds) {
         if (err) {
-            self.log.error({ err: err }, 'ufds error');
+            self.log.error({err: err}, 'ufds error');
             return;
         }
         self.ufds = ufds;
     });
 };
 
-
-App.prototype.setupServer = function () {
+App.prototype.setupServer = function() {
     var self = this;
 
     var serverOpts = {
@@ -265,7 +268,7 @@ App.prototype.setupServer = function () {
              * ordering.
              */
             'text/plain; q=0.3': errors.formatErrOrText,
-            'application/json': function (req, res, body, cb) {
+            'application/json': function(req, res, body, cb) {
                 if (body instanceof Error) {
                     res.setHeader('content-type', 'text/plain');
                     return errors.formatErrOrText(req, res, body, cb);
@@ -291,13 +294,13 @@ App.prototype.setupServer = function () {
 
 App.prototype.setupAdminSever = function listen(callback) {
     var self = this;
-    var admin = self.admin = restify.createServer({
+    var admin = (self.admin = restify.createServer({
         log: self.log,
         name: 'docker-admin',
         version: self.version
-    });
+    }));
 
-    admin.use(function (req, res, next) {
+    admin.use(function(req, res, next) {
         // Headers we want for all responses.
         res.on('header', function onHeader() {
             var now = Date.now();
@@ -318,41 +321,52 @@ App.prototype.setupAdminSever = function listen(callback) {
     admin.use(restify.bodyParser());
     admin.on('after', common.filteredAuditLog);
     admin.on('uncaughtException', common.uncaughtHandler);
-    adminEndpoints.register(admin, self.log, [ common.checkServices ]);
+    adminEndpoints.register(admin, self.log, [common.checkServices]);
 };
 
-App.prototype.listen = function (callback) {
+App.prototype.listen = function(callback) {
     var self = this;
     var adminIp = self.getAdminIp();
     var useTls = self.config.useTls;
     var serverPort = useTls ? self.config.port + 1 : self.config.port;
     var serverType = useTls ? 'https' : 'http';
 
-    vasync.pipeline({
-        funcs: [
-            function startPublicServer(_, next) {
-                self.server.listen(serverPort, next);
-            },
-            function startAdminServer(_, next) {
-                self.admin.listen(80, adminIp, next);
+    vasync.pipeline(
+        {
+            funcs: [
+                function startPublicServer(_, next) {
+                    self.server.listen(serverPort, next);
+                },
+                function startAdminServer(_, next) {
+                    self.admin.listen(80, adminIp, next);
+                }
+            ]
+        },
+        function(err, results) {
+            if (err) {
+                self.log.error(err, 'Error starting server');
+            } else {
+                var addr = self.server.address();
+                var adminAddr = self.admin.address();
+                self.log.info(
+                    'Started %s docker.js server on <%s://%s:%s>',
+                    serverType.toUpperCase(),
+                    serverType,
+                    addr.address,
+                    addr.port
+                );
+                self.log.info(
+                    'Started admin server on <http://%s:%s>',
+                    adminAddr.address,
+                    adminAddr.port
+                );
             }
-        ]
-    }, function (err, results) {
-        if (err) {
-            self.log.error(err, 'Error starting server');
-        } else {
-            var addr = self.server.address();
-            var adminAddr = self.admin.address();
-            self.log.info('Started %s docker.js server on <%s://%s:%s>',
-                serverType.toUpperCase(), serverType, addr.address, addr.port);
-            self.log.info('Started admin server on <http://%s:%s>',
-                adminAddr.address, adminAddr.port);
         }
-    });
+    );
 };
 
 App.prototype.close = function close(callback) {
-    this.server.on('close', function () {
+    this.server.on('close', function() {
         callback();
     });
     this.server.close();
@@ -386,15 +400,15 @@ App.prototype.createMorayClient = function createMorayClient() {
         self.moray = client;
         self.initMoray();
 
-        client.on('close', function () {
+        client.on('close', function() {
             client.log.error('moray: closed');
         });
 
-        client.on('connect', function () {
+        client.on('connect', function() {
             client.log.info('moray: reconnected');
         });
 
-        client.on('error', function (err) {
+        client.on('error', function(err) {
             client.log.warn(err, 'moray: error (reconnecting)');
         });
     }
@@ -413,10 +427,13 @@ App.prototype.createMorayClient = function createMorayClient() {
         } else {
             level = 'error';
         }
-        client.log[level]({
+        client.log[level](
+            {
                 attempt: number,
                 delay: delay
-        }, 'moray: connection attempted');
+            },
+            'moray: connection attempted'
+        );
     }
 
     client.once('connect', onMorayConnect);
@@ -431,22 +448,22 @@ App.prototype.createMorayClient = function createMorayClient() {
  * in options. callback will be called either with Error - cb(err) - or
  * with the recently instantiated client object: cb(null, ufds_client)
  */
-App.prototype.createUfdsClient = function (options, callback) {
+App.prototype.createUfdsClient = function(options, callback) {
     options.log = this.log;
     var ufds = new UFDS(options);
 
-    ufds.once('connect', function () {
+    ufds.once('connect', function() {
         ufds.removeAllListeners('error');
-        ufds.on('error', function (err) {
+        ufds.on('error', function(err) {
             options.log.error(err, 'UFDS disconnected');
         });
-        ufds.on('connect', function () {
+        ufds.on('connect', function() {
             options.log.info('UFDS reconnected');
         });
         callback(null, ufds);
     });
 
-    ufds.once('error', function (err) {
+    ufds.once('error', function(err) {
         // You are screwed. It's likely that the bind credentials were bad.
         // Treat this as fatal and move on:
         options.log.error({err: err}, 'UFDS connection error');
@@ -457,7 +474,7 @@ App.prototype.createUfdsClient = function (options, callback) {
 /*
  * Gets the admin IP address for the sdc-docker server
  */
-App.prototype.getAdminIp = function () {
+App.prototype.getAdminIp = function() {
     var interfaces = os.networkInterfaces();
     var ip;
     var ifs = interfaces['net0'];
@@ -474,17 +491,16 @@ App.prototype.getAdminIp = function () {
     return ip;
 };
 
-
 /**
  * Initializes moray buckets
  */
-App.prototype.initMoray = function () {
+App.prototype.initMoray = function() {
     var self = this;
     var att = 1;
     var timeout = null;
 
     function modelInitRetry() {
-        models.init(self, function (err) {
+        models.init(self, function(err) {
             if (timeout) {
                 clearTimeout(timeout);
             }
@@ -503,7 +519,6 @@ App.prototype.initMoray = function () {
     modelInitRetry();
 };
 
-
 /*
  * Initializes authentication cache as a LRU cache.
  *
@@ -511,7 +526,7 @@ App.prototype.initMoray = function () {
  * used by that user (as a String). If we have recently seen this user use
  * the exact same key we avoid looking it up in UFDS again.
  */
-App.prototype.initAuthCache = function () {
+App.prototype.initAuthCache = function() {
     var cacheOptions = this.config.authCache || {};
 
     if (cacheOptions.max === undefined) {
@@ -524,10 +539,11 @@ App.prototype.initAuthCache = function () {
     this.authCache = LRU(cacheOptions);
 };
 
-
 function addFluentdHost(log, host) {
     var evtLogger = new EffluentLogger({
-        filter: function _evtFilter(obj) { return (!!obj.evt); },
+        filter: function _evtFilter(obj) {
+            return !!obj.evt;
+        },
         host: host,
         log: log,
         port: 24224,
@@ -539,7 +555,6 @@ function addFluentdHost(log, host) {
     });
 }
 
-
 //---- mainline
 
 function main() {
diff --git a/lib/endpoints/_ping.js b/lib/endpoints/_ping.js
index f7112b4..e955fcd 100644
--- a/lib/endpoints/_ping.js
+++ b/lib/endpoints/_ping.js
@@ -10,8 +10,6 @@
 
 var restify = require('restify');
 
-
-
 /**
  * GET /_ping
  */
@@ -26,19 +24,15 @@ function ping(req, res, next) {
     next();
 }
 
-
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
     // Note: '_ping' ignores the 'before' argument to avoid running the
     //       authentication methods.
-    http.get({ path: /^(\/v[^\/]+)?\/_ping$/, name: 'Ping' }, ping);
+    http.get({path: /^(\/v[^\/]+)?\/_ping$/, name: 'Ping'}, ping);
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/admin/image-tags.js b/lib/endpoints/admin/image-tags.js
index 2250aab..4b45424 100644
--- a/lib/endpoints/admin/image-tags.js
+++ b/lib/endpoints/admin/image-tags.js
@@ -13,7 +13,6 @@ var ImageTag = require('../../models/image-tag');
 
 var UNSET_OWNER_UUID = '00000000-0000-0000-0000-000000000000';
 
-
 /**
  * GET /admin/image_tags
  */
@@ -29,7 +28,7 @@ function adminListImageTags(req, res, next) {
         params.tag = req.query.tag;
     }
 
-    ImageTag.list(req.app, req.log, params, function (err, tags) {
+    ImageTag.list(req.app, req.log, params, function(err, tags) {
         if (err) {
             next(err);
             return;
@@ -45,7 +44,6 @@ function adminListImageTags(req, res, next) {
     });
 }
 
-
 /**
  * POST /admin/image_tags
  */
@@ -55,7 +53,7 @@ function adminCreateImageTag(req, res, next) {
         params.owner_uuid = req.app.config.adminUuid;
     }
 
-    ImageTag.create(req.app, req.log, params, function (err, tag) {
+    ImageTag.create(req.app, req.log, params, function(err, tag) {
         if (err) {
             next(err);
             return;
@@ -66,19 +64,22 @@ function adminCreateImageTag(req, res, next) {
     });
 }
 
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.get({ path: '/admin/image_tags', name: 'AdminListImageTags' },
-        before, adminListImageTags);
-    http.post({ path: '/admin/image_tags', name: 'AdminCreateImageTag' },
-        before, adminCreateImageTag);
+    http.get(
+        {path: '/admin/image_tags', name: 'AdminListImageTags'},
+        before,
+        adminListImageTags
+    );
+    http.post(
+        {path: '/admin/image_tags', name: 'AdminCreateImageTag'},
+        before,
+        adminCreateImageTag
+    );
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/admin/images.js b/lib/endpoints/admin/images.js
index 9c2a215..149e33d 100644
--- a/lib/endpoints/admin/images.js
+++ b/lib/endpoints/admin/images.js
@@ -12,7 +12,6 @@ var Image = require('../../models/image');
 
 var UNSET_OWNER_UUID = '00000000-0000-0000-0000-000000000000';
 
-
 /**
  * GET /admin/images
  */
@@ -28,7 +27,7 @@ function adminListImages(req, res, next) {
         params.docker_id = req.query.docker_id;
     }
 
-    Image.list(req.app, req.log, params, function (err, images) {
+    Image.list(req.app, req.log, params, function(err, images) {
         if (err) {
             next(err);
             return;
@@ -44,7 +43,6 @@ function adminListImages(req, res, next) {
     });
 }
 
-
 /**
  * POST /admin/images?action=create
  * POST /admin/images?action=update
@@ -56,8 +54,8 @@ function adminCreateImage(req, res, next) {
         params.owner_uuid = req.app.config.adminUuid;
     }
 
-    var fn = (req.query.action === 'update' ? Image.update : Image.create);
-    fn.call(Image, req.app, req.log, params, function (err, img) {
+    var fn = req.query.action === 'update' ? Image.update : Image.create;
+    fn.call(Image, req.app, req.log, params, function(err, img) {
         if (err) {
             next(err);
         } else {
@@ -67,19 +65,22 @@ function adminCreateImage(req, res, next) {
     });
 }
 
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.get({ path: '/admin/images', name: 'AdminListImages' },
-        before, adminListImages);
-    http.post({ path: '/admin/images', name: 'AdminCreateImage' },
-        before, adminCreateImage);
+    http.get(
+        {path: '/admin/images', name: 'AdminListImages'},
+        before,
+        adminListImages
+    );
+    http.post(
+        {path: '/admin/images', name: 'AdminCreateImage'},
+        before,
+        adminCreateImage
+    );
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/admin/index.js b/lib/endpoints/admin/index.js
index 749b440..5f9d89d 100644
--- a/lib/endpoints/admin/index.js
+++ b/lib/endpoints/admin/index.js
@@ -8,7 +8,6 @@
  * Copyright (c) 2014, Joyent, Inc.
  */
 
-
 /*
  * Endpoints are in their own individual files, in a directory structure
  * that roughly matches their routes, eg:
@@ -20,12 +19,8 @@ var toRegister = {
     '/admin/image_tags': require('./image-tags')
 };
 
-
-
 // --- Exports
 
-
-
 /*
  * Register all endpoints with the restify server
  */
@@ -36,8 +31,6 @@ function registerEndpoints(http, log, before) {
     }
 }
 
-
-
 module.exports = {
     register: registerEndpoints
 };
diff --git a/lib/endpoints/admin/progress.js b/lib/endpoints/admin/progress.js
index c984018..bbc3654 100644
--- a/lib/endpoints/admin/progress.js
+++ b/lib/endpoints/admin/progress.js
@@ -10,8 +10,6 @@
 
 var restify = require('restify');
 
-
-
 /**
  * POST /admin/progress
  */
@@ -31,18 +29,17 @@ function adminProgress(req, res, next) {
     return next();
 }
 
-
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.post({ path: '/admin/progress', name: 'AdminProgress' },
-        before, adminProgress);
+    http.post(
+        {path: '/admin/progress', name: 'AdminProgress'},
+        before,
+        adminProgress
+    );
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/auth.js b/lib/endpoints/auth.js
index 457ecb0..44f53e0 100644
--- a/lib/endpoints/auth.js
+++ b/lib/endpoints/auth.js
@@ -16,8 +16,6 @@ var restify = require('restify');
 var common = require('../common');
 var errors = require('../errors');
 
-
-
 /**
  * POST /auth
  *
@@ -53,40 +51,46 @@ function auth(req, res, next) {
         return next(new errors.ValidationError(errs.join(', ')));
     }
 
-    drc.login(common.httpClientOpts({
-        indexName: req.body.serveraddress,
-        log: log,
-        insecure: req.app.config.dockerRegistryInsecure,
-        // auth info:
-        username: req.body.username,
-        password: req.body.password,
-        // `email` is optional (required for *v1* Registry API)
-        email: req.body.email
-    }, req), function (err, result) {
-        if (err) {
-            next(err);
-        } else {
-            var body = {
-                Status: result.status
-            };
-            res.send(body);
-            next();
+    drc.login(
+        common.httpClientOpts(
+            {
+                indexName: req.body.serveraddress,
+                log: log,
+                insecure: req.app.config.dockerRegistryInsecure,
+                // auth info:
+                username: req.body.username,
+                password: req.body.password,
+                // `email` is optional (required for *v1* Registry API)
+                email: req.body.email
+            },
+            req
+        ),
+        function(err, result) {
+            if (err) {
+                next(err);
+            } else {
+                var body = {
+                    Status: result.status
+                };
+                res.send(body);
+                next();
+            }
         }
-    });
+    );
 }
 
-
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.post({ path: /^(\/v[^\/]+)?\/auth$/, name: 'Auth' },
-        before, restify.bodyParser(), auth);
+    http.post(
+        {path: /^(\/v[^\/]+)?\/auth$/, name: 'Auth'},
+        before,
+        restify.bodyParser(),
+        auth
+    );
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/build.js b/lib/endpoints/build.js
index a5ad4b2..fd20648 100644
--- a/lib/endpoints/build.js
+++ b/lib/endpoints/build.js
@@ -17,7 +17,6 @@ var drc = require('docker-registry-client');
 var common = require('../common');
 var errors = require('../errors');
 
-
 /**
  * Format the error message - ensures the req_id is in the error string.
  */
@@ -70,8 +69,10 @@ function build(req, res, next) {
     if (dockerOpts.dockerfile) {
         dockerOpts.dockerfile = path.normalize(dockerOpts.dockerfile);
         if (dockerOpts.dockerfile.substr(0, 2) === '..') {
-            var msg = util.format('Forbidden path outside the build context: '
-                + req.query.dockerfile);
+            var msg = util.format(
+                'Forbidden path outside the build context: ' +
+                    req.query.dockerfile
+            );
             next(new errors.DockerError(msg));
             return;
         }
@@ -84,47 +85,51 @@ function build(req, res, next) {
      */
     req.connection.setTimeout(60 * 60 * 1000);
 
-    res.writeHead(200, { 'Content-Type': 'application/json' });
-
-    req.backend.buildImage({
-        dockerOpts: dockerOpts,
-        log: log,
-        rat: rat,
-        req: req,
-        req_id: req.getId(),
-        res: res,
-        wfapi: req.wfapi
-    }, function (err) {
-        if (err) {
-            log.error('docker build error', err);
-            var errorMessage = formatErrorMessage(err.message, req.getId());
-            var event = {
-                error: errorMessage,
-                errorDetail: {
-                    message: errorMessage
-                }
-            };
-            res.write(JSON.stringify(event) + '\n');
-        } else {
-            log.debug('docker build finished successfully');
+    res.writeHead(200, {'Content-Type': 'application/json'});
+
+    req.backend.buildImage(
+        {
+            dockerOpts: dockerOpts,
+            log: log,
+            rat: rat,
+            req: req,
+            req_id: req.getId(),
+            res: res,
+            wfapi: req.wfapi
+        },
+        function(err) {
+            if (err) {
+                log.error('docker build error', err);
+                var errorMessage = formatErrorMessage(err.message, req.getId());
+                var event = {
+                    error: errorMessage,
+                    errorDetail: {
+                        message: errorMessage
+                    }
+                };
+                res.write(JSON.stringify(event) + '\n');
+            } else {
+                log.debug('docker build finished successfully');
+            }
+
+            res.end();
+            next(true);
         }
-
-        res.end();
-        next(true);
-    });
+    );
 }
 
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.post({ path: /^(\/v[^\/]+)?\/build$/, name: 'Build' },
-        before, restify.queryParser({mapParams: false}), build);
+    http.post(
+        {path: /^(\/v[^\/]+)?\/build$/, name: 'Build'},
+        before,
+        restify.queryParser({mapParams: false}),
+        build
+    );
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/ca.js b/lib/endpoints/ca.js
index ae83d8b..4d2c605 100644
--- a/lib/endpoints/ca.js
+++ b/lib/endpoints/ca.js
@@ -10,8 +10,6 @@
 
 var fs = require('fs');
 
-
-
 /**
  * GET /ca.pem
  */
@@ -22,18 +20,14 @@ function caPem(req, res, next) {
     next();
 }
 
-
-
 /**
  * Register all endpoints with the restify server.
  */
 function register(http, before) {
     // Note: 'ca.pem' ignores the 'before' argument to avoid performing auth.
-    http.get({ path: '/ca.pem', name: 'CA' }, caPem);
+    http.get({path: '/ca.pem', name: 'CA'}, caPem);
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/commit.js b/lib/endpoints/commit.js
index c404a65..bff518b 100644
--- a/lib/endpoints/commit.js
+++ b/lib/endpoints/commit.js
@@ -13,7 +13,6 @@ var restify = require('restify');
 var common = require('../common');
 var errors = require('../errors');
 
-
 /**
  * POST /commit
  *
@@ -33,7 +32,7 @@ function commit(req, res, next) {
     // There can either be one single change (string) or multiple (array of
     // string) changes - convert to always be an array.
     var changes = req.query.changes || [];
-    if (changes && typeof (changes) === 'string') {
+    if (changes && typeof changes === 'string') {
         changes = [changes];
     }
 
@@ -55,14 +54,14 @@ function commit(req, res, next) {
      */
     req.connection.setTimeout(10 * 60 * 1000);
 
-    req.backend.commitImage(req, commitOpts, function (err, imageId) {
+    req.backend.commitImage(req, commitOpts, function(err, imageId) {
         if (err) {
             res.send(err);
         } else {
             log.debug('docker commit finished successfully');
             // Note: Docker returns sha256: {"Id":"sha256:93c3e0ca32...1453a"}
-            res.status(201);  // Okay - image was committed.
-            res.write(JSON.stringify({'Id': imageId}) + '\n');
+            res.status(201); // Okay - image was committed.
+            res.write(JSON.stringify({Id: imageId}) + '\n');
         }
 
         res.end();
@@ -70,26 +69,25 @@ function commit(req, res, next) {
     });
 }
 
-
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-
     function reqParamsId(req, res, next) {
         req.params.id = req.query.container;
         next();
     }
 
-    http.post({ path: /^(\/v[^\/]+)?\/commit$/, name: 'Commit' },
-        before, restify.queryParser({mapParams: false}),
-        reqParamsId, common.getVm, commit);
-
+    http.post(
+        {path: /^(\/v[^\/]+)?\/commit$/, name: 'Commit'},
+        before,
+        restify.queryParser({mapParams: false}),
+        reqParamsId,
+        common.getVm,
+        commit
+    );
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/containers.js b/lib/endpoints/containers.js
index e135b78..5c6a266 100644
--- a/lib/endpoints/containers.js
+++ b/lib/endpoints/containers.js
@@ -17,64 +17,231 @@ var errors = require('../errors');
 var getVm = common.getVm;
 var validate = require('../validate');
 
-
-
 // ---- internal support stuff
 
-function generateContainerName()
-{
+function generateContainerName() {
     /* JSSTYLED */
     // This is the same as from https://github.com/docker/docker/blob/290222c3ddbdfb871f7fa088b8c724b9970a75ba/pkg/namesgenerator/names-generator.go
 
     var left = [
-        'admiring', 'adoring', 'agitated', 'amazing', 'angry', 'awesome',
-        'backstabbing', 'berserk', 'big', 'boring', 'clever', 'cocky',
-        'compassionate', 'condescending', 'cranky', 'desperate', 'determined',
-        'distracted', 'dreamy', 'drunk', 'ecstatic', 'elated', 'elegant',
-        'evil', 'fervent', 'focused', 'furious', 'gigantic', 'gloomy', 'goofy',
-        'grave', 'happy', 'high', 'hopeful', 'hungry', 'insane', 'jolly',
-        'jovial', 'kickass', 'lonely', 'loving', 'mad', 'modest', 'naughty',
-        'nauseous', 'nostalgic', 'pedantic', 'pensive', 'prickly', 'reverent',
-        'romantic', 'sad', 'serene', 'sharp', 'sick', 'silly', 'sleepy',
-        'small', 'stoic', 'stupefied', 'suspicious', 'tender', 'thirsty',
-        'tiny', 'trusting'
+        'admiring',
+        'adoring',
+        'agitated',
+        'amazing',
+        'angry',
+        'awesome',
+        'backstabbing',
+        'berserk',
+        'big',
+        'boring',
+        'clever',
+        'cocky',
+        'compassionate',
+        'condescending',
+        'cranky',
+        'desperate',
+        'determined',
+        'distracted',
+        'dreamy',
+        'drunk',
+        'ecstatic',
+        'elated',
+        'elegant',
+        'evil',
+        'fervent',
+        'focused',
+        'furious',
+        'gigantic',
+        'gloomy',
+        'goofy',
+        'grave',
+        'happy',
+        'high',
+        'hopeful',
+        'hungry',
+        'insane',
+        'jolly',
+        'jovial',
+        'kickass',
+        'lonely',
+        'loving',
+        'mad',
+        'modest',
+        'naughty',
+        'nauseous',
+        'nostalgic',
+        'pedantic',
+        'pensive',
+        'prickly',
+        'reverent',
+        'romantic',
+        'sad',
+        'serene',
+        'sharp',
+        'sick',
+        'silly',
+        'sleepy',
+        'small',
+        'stoic',
+        'stupefied',
+        'suspicious',
+        'tender',
+        'thirsty',
+        'tiny',
+        'trusting'
     ];
     var invalid = ['boring_wozniak'];
     var right = [
-        'albattani', 'allen', 'almeida', 'archimedes', 'ardinghelli',
-        'aryabhata', 'austin', 'babbage', 'banach', 'bardeen', 'bartik',
-        'bassi', 'bell', 'bhabha', 'bhaskara', 'blackwell', 'bohr', 'booth',
-        'borg', 'bose', 'boyd', 'brahmagupta', 'brattain', 'brown', 'carson',
-        'chandrasekhar', 'colden', 'cori', 'cray', 'curie', 'darwin', 'davinci',
-        'dijkstra', 'dubinsky', 'easley', 'einstein', 'elion', 'engelbart',
-        'euclid', 'euler', 'fermat', 'fermi', 'feynman', 'franklin', 'galileo',
-        'gates', 'goldberg', 'goldstine', 'golick', 'goodall', 'hamilton',
-        'hawking', 'heisenberg', 'heyrovsky', 'hodgkin', 'hoover', 'hopper',
-        'hugle', 'hypatia', 'jang', 'jennings', 'jepsen', 'joliot', 'jones',
-        'kalam', 'kare', 'keller', 'khorana', 'kilby', 'kirch', 'knuth',
-        'kowalevski', 'lalande', 'lamarr', 'leakey', 'leavitt', 'lichterman',
-        'liskov', 'lovelace', 'lumiere', 'mahavira', 'mayer', 'mccarthy',
-        'mcclintock', 'mcilroy', 'mclean', 'mcnulty', 'meitner', 'meninsky',
-        'mestorf', 'mirzakhani', 'morse', 'newton', 'nobel', 'noether',
-        'northcutt', 'noyce', 'panini', 'pare', 'pasteur', 'payne', 'perlman',
-        'pike', 'poincare', 'poitras', 'ptolemy', 'raman', 'ramanujan',
-        'ride', 'ritchie', 'roentgen', 'rosalind', 'saha', 'sammet', 'shaw',
-        'shockley', 'sinoussi', 'snyder', 'spence', 'stallman', 'swanson',
-        'swartz', 'swirles', 'tesla', 'thompson', 'torvalds', 'turing',
-        'varahamihira', 'visvesvaraya', 'wescoff', 'williams', 'wilson',
-        'wing', 'wozniak', 'wright', 'yalow', 'yonath'
+        'albattani',
+        'allen',
+        'almeida',
+        'archimedes',
+        'ardinghelli',
+        'aryabhata',
+        'austin',
+        'babbage',
+        'banach',
+        'bardeen',
+        'bartik',
+        'bassi',
+        'bell',
+        'bhabha',
+        'bhaskara',
+        'blackwell',
+        'bohr',
+        'booth',
+        'borg',
+        'bose',
+        'boyd',
+        'brahmagupta',
+        'brattain',
+        'brown',
+        'carson',
+        'chandrasekhar',
+        'colden',
+        'cori',
+        'cray',
+        'curie',
+        'darwin',
+        'davinci',
+        'dijkstra',
+        'dubinsky',
+        'easley',
+        'einstein',
+        'elion',
+        'engelbart',
+        'euclid',
+        'euler',
+        'fermat',
+        'fermi',
+        'feynman',
+        'franklin',
+        'galileo',
+        'gates',
+        'goldberg',
+        'goldstine',
+        'golick',
+        'goodall',
+        'hamilton',
+        'hawking',
+        'heisenberg',
+        'heyrovsky',
+        'hodgkin',
+        'hoover',
+        'hopper',
+        'hugle',
+        'hypatia',
+        'jang',
+        'jennings',
+        'jepsen',
+        'joliot',
+        'jones',
+        'kalam',
+        'kare',
+        'keller',
+        'khorana',
+        'kilby',
+        'kirch',
+        'knuth',
+        'kowalevski',
+        'lalande',
+        'lamarr',
+        'leakey',
+        'leavitt',
+        'lichterman',
+        'liskov',
+        'lovelace',
+        'lumiere',
+        'mahavira',
+        'mayer',
+        'mccarthy',
+        'mcclintock',
+        'mcilroy',
+        'mclean',
+        'mcnulty',
+        'meitner',
+        'meninsky',
+        'mestorf',
+        'mirzakhani',
+        'morse',
+        'newton',
+        'nobel',
+        'noether',
+        'northcutt',
+        'noyce',
+        'panini',
+        'pare',
+        'pasteur',
+        'payne',
+        'perlman',
+        'pike',
+        'poincare',
+        'poitras',
+        'ptolemy',
+        'raman',
+        'ramanujan',
+        'ride',
+        'ritchie',
+        'roentgen',
+        'rosalind',
+        'saha',
+        'sammet',
+        'shaw',
+        'shockley',
+        'sinoussi',
+        'snyder',
+        'spence',
+        'stallman',
+        'swanson',
+        'swartz',
+        'swirles',
+        'tesla',
+        'thompson',
+        'torvalds',
+        'turing',
+        'varahamihira',
+        'visvesvaraya',
+        'wescoff',
+        'williams',
+        'wilson',
+        'wing',
+        'wozniak',
+        'wright',
+        'yalow',
+        'yonath'
     ];
     var name;
 
-    while (!name || (invalid.indexOf(name) !== -1)) {
-        name = left[Math.floor(Math.random() * left.length)]
-            + '_' + right[Math.floor(Math.random() * right.length)];
+    while (!name || invalid.indexOf(name) !== -1) {
+        name =
+            left[Math.floor(Math.random() * left.length)] +
+            '_' +
+            right[Math.floor(Math.random() * right.length)];
     }
 
-    return (name);
+    return name;
 }
 
-
 // ---- endpoint handlers
 
 /**
@@ -101,7 +268,7 @@ function containerList(req, res, next) {
         options.all = true;
     }
 
-    req.backend.getContainers(options, function (err, containers) {
+    req.backend.getContainers(options, function(err, containers) {
         if (err) {
             if (!(err instanceof errors.DockerError)) {
                 log.error({err: err}, 'Problem loading containers');
@@ -116,7 +283,6 @@ function containerList(req, res, next) {
     });
 }
 
-
 /**
  * POST /containers/create
  */
@@ -145,14 +311,16 @@ function containerCreate(req, res, next) {
         create_opts.name = generateContainerName();
     }
 
-    req.backend.createContainer(create_opts, function (err, container) {
+    req.backend.createContainer(create_opts, function(err, container) {
         if (err) {
             if (err.code === 'EMISSINGIMAGE') {
                 next(new restify.ResourceNotFoundError(err, 'image not found'));
                 return;
             }
-            log.error({container: container, err: err},
-                'createContainer error');
+            log.error(
+                {container: container, err: err},
+                'createContainer error'
+            );
             next(err);
             return;
         }
@@ -165,7 +333,6 @@ function containerCreate(req, res, next) {
     });
 }
 
-
 /**
  * GET /containers/:id/json
  */
@@ -184,7 +351,7 @@ function containerInspect(req, res, next) {
 
     req.log.debug({req: req}, 'req');
 
-    req.backend.inspectContainer(options, function (err, container) {
+    req.backend.inspectContainer(options, function(err, container) {
         if (err) {
             log.error({err: err}, 'backend.inspectContainer failed.');
             next(new errors.DockerError(err, 'problem inspecting container'));
@@ -196,7 +363,6 @@ function containerInspect(req, res, next) {
     });
 }
 
-
 /**
  * GET /containers/:id/top
  */
@@ -204,28 +370,30 @@ function containerTop(req, res, next) {
     var id = req.params.id;
     var log = req.log;
 
-    req.backend.psContainer({
-        account: req.account,
-        app: req.app,
-        fields: req.query.fields,
-        id: id,
-        log: log,
-        ps_args: req.query.ps_args,
-        req_id: req.getId(),
-        vm: req.vm
-    }, function (err, psdata) {
-        if (err) {
-            log.error({err: err}, 'backend.psContainer failed.');
-            next(err);
-            return;
-        }
+    req.backend.psContainer(
+        {
+            account: req.account,
+            app: req.app,
+            fields: req.query.fields,
+            id: id,
+            log: log,
+            ps_args: req.query.ps_args,
+            req_id: req.getId(),
+            vm: req.vm
+        },
+        function(err, psdata) {
+            if (err) {
+                log.error({err: err}, 'backend.psContainer failed.');
+                next(err);
+                return;
+            }
 
-        res.send(psdata);
-        next();
-    });
+            res.send(psdata);
+            next();
+        }
+    );
 }
 
-
 /**
  * GET /containers/:id/logs
  *
@@ -258,18 +426,22 @@ function containerLogs(req, res, next) {
      */
     req.connection.setTimeout(60 * 60 * 1000);
 
-    req.socket.write('HTTP/1.1 200 OK\r\nContent-Type: '
-        + 'application/vnd.docker.raw-stream\r\n\r\n');
+    req.socket.write(
+        'HTTP/1.1 200 OK\r\nContent-Type: ' +
+            'application/vnd.docker.raw-stream\r\n\r\n'
+    );
 
-    req.backend.containerLogs({
-        account: req.account,
-        app: req.app,
-        log: log,
-        payload: payload,
-        req_id: req.getId(),
-        socket: req.socket,
-        vm: req.vm
-    }, function (err) {
+    req.backend.containerLogs(
+        {
+            account: req.account,
+            app: req.app,
+            log: log,
+            payload: payload,
+            req_id: req.getId(),
+            socket: req.socket,
+            vm: req.vm
+        },
+        function(err) {
             if (err) {
                 log.error({err: err}, 'backend.containerLogs error');
                 next(err);
@@ -281,7 +453,6 @@ function containerLogs(req, res, next) {
     );
 }
 
-
 /**
  * GET /containers/:id/stats
  */
@@ -301,15 +472,17 @@ function containerStats(req, res, next) {
      */
     req.connection.setTimeout(60 * 60 * 1000);
 
-    req.backend.containerStats({
-        account: req.account,
-        app: req.app,
-        log: log,
-        payload: payload,
-        req_id: req.getId(),
-        socket: req.socket,
-        vm: req.vm
-    }, function (err, statsSocket) {
+    req.backend.containerStats(
+        {
+            account: req.account,
+            app: req.app,
+            log: log,
+            payload: payload,
+            req_id: req.getId(),
+            socket: req.socket,
+            vm: req.vm
+        },
+        function(err, statsSocket) {
             if (err) {
                 log.error({err: err}, 'backend.containerStats error');
                 next(err);
@@ -317,7 +490,7 @@ function containerStats(req, res, next) {
             }
 
             // Close the statsSocket when the response socket is ended.
-            res.socket.on('end', function () {
+            res.socket.on('end', function() {
                 log.debug('containerStats got res.end - closing stats socket');
                 statsSocket.destroy();
             });
@@ -329,7 +502,6 @@ function containerStats(req, res, next) {
     );
 }
 
-
 /**
  * GET /containers/:id/changes
  */
@@ -338,7 +510,6 @@ function containerChanges(req, res, next) {
     return next(new errors.NotImplementedError('changes'));
 }
 
-
 /**
  * GET /containers/:id/export
  */
@@ -347,7 +518,6 @@ function containerExport(req, res, next) {
     return next(new errors.NotImplementedError('export'));
 }
 
-
 /**
  * POST /containers/:id/resize
  */
@@ -357,24 +527,26 @@ function containerResize(req, res, next) {
 
     log.debug({req: req}, 'req');
 
-    req.backend.resizeContainer({
-        app: req.app,
-        id: id,
-        log: log,
-        w: Number(req.query.w),
-        h: Number(req.query.h)
-    }, function (err) {
-        if (err) {
-            next(err);
-            return;
-        }
+    req.backend.resizeContainer(
+        {
+            app: req.app,
+            id: id,
+            log: log,
+            w: Number(req.query.w),
+            h: Number(req.query.h)
+        },
+        function(err) {
+            if (err) {
+                next(err);
+                return;
+            }
 
-        res.send(200);
-        next();
-    });
+            res.send(200);
+            next();
+        }
+    );
 }
 
-
 /**
  * POST /containers/:id/start
  */
@@ -383,25 +555,27 @@ function containerStart(req, res, next) {
 
     req.log.debug({req: req}, 'req');
 
-    req.backend.startContainer({
-        account: req.account,
-        app: req.app,
-        log: log,
-        req_id: req.getId(),
-        vm: req.vm
-    }, function (err) {
-        if (err) {
-            log.error({err: err}, 'backend.startContainer failed.');
-            next(new errors.DockerError(err, 'problem starting container'));
-            return;
-        }
+    req.backend.startContainer(
+        {
+            account: req.account,
+            app: req.app,
+            log: log,
+            req_id: req.getId(),
+            vm: req.vm
+        },
+        function(err) {
+            if (err) {
+                log.error({err: err}, 'backend.startContainer failed.');
+                next(new errors.DockerError(err, 'problem starting container'));
+                return;
+            }
 
-        res.send(204);
-        next();
-    });
+            res.send(204);
+            next();
+        }
+    );
 }
 
-
 /**
  * POST /containers/:id/stop[?t=:timeout]
  */
@@ -418,8 +592,9 @@ function containerStop(req, res, next) {
     if (req.query.hasOwnProperty('t')) {
         t = Number(req.query.t);
         if (isNaN(t) || (req.query.t && req.query.t.length === 0)) {
-            tErr = new errors.ValidationError('stop timeout parameter must be '
-                + 'an integer');
+            tErr = new errors.ValidationError(
+                'stop timeout parameter must be ' + 'an integer'
+            );
             log.error({err: tErr, t: t}, 'timeout parameter is not an integer');
             next(tErr);
             return;
@@ -432,26 +607,28 @@ function containerStop(req, res, next) {
     // it assumes we should wait forever.
     t = Math.floor(t);
 
-    req.backend.stopContainer({
-        account: req.account,
-        app: req.app,
-        log: log,
-        req_id: req.getId(),
-        timeout: t,
-        vm: req.vm
-    }, function (err) {
-        if (err) {
-            log.error({err: err}, 'backend.stopContainer failed.');
-            next(new errors.DockerError(err, 'problem stopping container'));
-            return;
-        }
+    req.backend.stopContainer(
+        {
+            account: req.account,
+            app: req.app,
+            log: log,
+            req_id: req.getId(),
+            timeout: t,
+            vm: req.vm
+        },
+        function(err) {
+            if (err) {
+                log.error({err: err}, 'backend.stopContainer failed.');
+                next(new errors.DockerError(err, 'problem stopping container'));
+                return;
+            }
 
-        res.send(204);
-        next();
-    });
+            res.send(204);
+            next();
+        }
+    );
 }
 
-
 /**
  * POST /containers/:id/restart
  */
@@ -464,26 +641,30 @@ function containerRestart(req, res, next) {
         t = 10;
     }
 
-    req.backend.restartContainer({
-        account: req.account,
-        app: req.app,
-        log: log,
-        req_id: req.getId(),
-        timeout: t,
-        vm: req.vm
-    }, function (err) {
-        if (err) {
-            log.error({err: err}, 'backend.restartContainer failed.');
-            next(new errors.DockerError(err, 'problem restarting container'));
-            return;
-        }
+    req.backend.restartContainer(
+        {
+            account: req.account,
+            app: req.app,
+            log: log,
+            req_id: req.getId(),
+            timeout: t,
+            vm: req.vm
+        },
+        function(err) {
+            if (err) {
+                log.error({err: err}, 'backend.restartContainer failed.');
+                next(
+                    new errors.DockerError(err, 'problem restarting container')
+                );
+                return;
+            }
 
-        res.send(204);
-        next();
-    });
+            res.send(204);
+            next();
+        }
+    );
 }
 
-
 /**
  * POST /containers/:id/kill
  */
@@ -491,28 +672,36 @@ function containerKill(req, res, next) {
     var log = req.log;
     var signal = req.query.signal;
 
-    req.backend.killContainer({
-        account: req.account,
-        app: req.app,
-        log: log,
-        req_id: req.getId(),
-        signal: signal,
-        vm: req.vm
-    }, function (err) {
-        if (err) {
-            log.error({err: err, signal: signal},
-                'backend.killContainer failed.');
-            next(new errors.DockerError(
-                err, 'problem sending signal to container'));
-            return;
-        }
+    req.backend.killContainer(
+        {
+            account: req.account,
+            app: req.app,
+            log: log,
+            req_id: req.getId(),
+            signal: signal,
+            vm: req.vm
+        },
+        function(err) {
+            if (err) {
+                log.error(
+                    {err: err, signal: signal},
+                    'backend.killContainer failed.'
+                );
+                next(
+                    new errors.DockerError(
+                        err,
+                        'problem sending signal to container'
+                    )
+                );
+                return;
+            }
 
-        res.send(204);
-        next();
-    });
+            res.send(204);
+            next();
+        }
+    );
 }
 
-
 /**
  * DELETE /containers/:id
  */
@@ -521,28 +710,30 @@ function containerDelete(req, res, next) {
     var force = common.boolFromQueryParam(req.query.force);
     var link = common.boolFromQueryParam(req.query.link);
 
-    req.backend.deleteContainer({
-        account: req.account,
-        app: req.app,
-        force: force,
-        link: link,
-        log: log,
-        req_id: req.getId(),
-        id: req.params.id,
-        vm: req.vm
-    }, function (err) {
-        if (err) {
-            log.error({err: err}, 'backend.deleteContainer failed.');
-            next(err);
-            return;
-        }
+    req.backend.deleteContainer(
+        {
+            account: req.account,
+            app: req.app,
+            force: force,
+            link: link,
+            log: log,
+            req_id: req.getId(),
+            id: req.params.id,
+            vm: req.vm
+        },
+        function(err) {
+            if (err) {
+                log.error({err: err}, 'backend.deleteContainer failed.');
+                next(err);
+                return;
+            }
 
-        res.send(204);
-        next();
-    });
+            res.send(204);
+            next();
+        }
+    );
 }
 
-
 /**
  * DELETE /containers/:id/:link
  */
@@ -550,24 +741,26 @@ function linkDelete(req, res, next) {
     var link = req.params.link;
     var log = req.log;
 
-    req.backend.deleteLink({
-        app: req.app,
-        link: link,
-        log: log,
-        vm: req.vm
-    }, function (err) {
-        if (err) {
-            log.error({err: err}, 'backend.deleteLink failed.');
-            next(err);
-            return;
-        }
+    req.backend.deleteLink(
+        {
+            app: req.app,
+            link: link,
+            log: log,
+            vm: req.vm
+        },
+        function(err) {
+            if (err) {
+                log.error({err: err}, 'backend.deleteLink failed.');
+                next(err);
+                return;
+            }
 
-        res.send(204);
-        next();
-    });
+            res.send(204);
+            next();
+        }
+    );
 }
 
-
 /**
  * POST /containers/:id/pause
  */
@@ -576,7 +769,6 @@ function containerPause(req, res, next) {
     return next(new errors.NotImplementedError('pause'));
 }
 
-
 /**
  * POST /containers/:id/unpause
  */
@@ -585,7 +777,6 @@ function containerUnPause(req, res, next) {
     return next(new errors.NotImplementedError('unpause'));
 }
 
-
 /**
  * POST /containers/:id/attach
  *
@@ -622,19 +813,23 @@ function containerAttach(req, res, next) {
      */
     req.connection.setTimeout(60 * 60 * 1000);
 
-    req.socket.write('HTTP/1.1 101 UPGRADED\r\nContent-Type: '
-        + 'application/vnd.docker.raw-stream\r\n\r\n');
+    req.socket.write(
+        'HTTP/1.1 101 UPGRADED\r\nContent-Type: ' +
+            'application/vnd.docker.raw-stream\r\n\r\n'
+    );
 
-    req.backend.attachContainer({
-        account: req.account,
-        app: req.app,
-        id: id,
-        log: log,
-        payload: payload,
-        req_id: req.getId(),
-        socket: req.socket,
-        vm: req.vm
-    }, function (err) {
+    req.backend.attachContainer(
+        {
+            account: req.account,
+            app: req.app,
+            id: id,
+            log: log,
+            payload: payload,
+            req_id: req.getId(),
+            socket: req.socket,
+            vm: req.vm
+        },
+        function(err) {
             if (err) {
                 log.error({err: err}, 'backend.attachContainer error');
                 next(err);
@@ -646,33 +841,38 @@ function containerAttach(req, res, next) {
     );
 }
 
-
 /**
  * POST /containers/:id/wait
  */
 function containerWait(req, res, next) {
     var log = req.log;
 
-    req.backend.waitContainer({
-        account: req.account,
-        app: req.app,
-        log: log,
-        req_id: req.getId(),
-        vm: req.vm
-    }, function (err, statusCode) {
-        if (err) {
-            log.error({err: err}, 'backend.waitContainer failed.');
-            next(new errors.DockerError(
-                err, 'problem waiting for container to stop'));
-            return;
-        }
+    req.backend.waitContainer(
+        {
+            account: req.account,
+            app: req.app,
+            log: log,
+            req_id: req.getId(),
+            vm: req.vm
+        },
+        function(err, statusCode) {
+            if (err) {
+                log.error({err: err}, 'backend.waitContainer failed.');
+                next(
+                    new errors.DockerError(
+                        err,
+                        'problem waiting for container to stop'
+                    )
+                );
+                return;
+            }
 
-        res.send({ StatusCode: statusCode });
-        next();
-    });
+            res.send({StatusCode: statusCode});
+            next();
+        }
+    );
 }
 
-
 /**
  * POST /containers/:id/copy
  */
@@ -687,14 +887,14 @@ function containerCopy(req, res, next) {
         app: req.app,
         cnapi: req.app.cnapi,
         log: log,
-        payload: { path: req.params.Resource },
+        payload: {path: req.params.Resource},
         req_id: req.getId(),
         res: res,
         req: req,
         vm: req.vm
     };
 
-    req.backend.copyContainer(opts, function (err, copySocket) {
+    req.backend.copyContainer(opts, function(err, copySocket) {
         if (err) {
             if (err.statusCode === 404) {
                 // Unwrap the error, `docker cp` < 1.8.0 treats a 404 as a
@@ -702,27 +902,32 @@ function containerCopy(req, res, next) {
                 return next(new errors.DockerError('file not found'));
             } else {
                 return next(
-                    new errors.DockerError(err, 'problem copying file'));
+                    new errors.DockerError(err, 'problem copying file')
+                );
             }
         }
 
-        copySocket.on('connect', function () {
+        copySocket.on('connect', function() {
             res.setHeader('content-type', 'application/tar');
 
             var error;
 
-            copySocket.on('error', function (e) {
+            copySocket.on('error', function(e) {
                 error = e;
 
                 opts.log.debug(
-                    'copySocket for %s threw an error %', opts.vm.uuid,
-                    error.toString());
+                    'copySocket for %s threw an error %',
+                    opts.vm.uuid,
+                    error.toString()
+                );
             });
 
-            copySocket.on('error', function (e) {
+            copySocket.on('error', function(e) {
                 opts.log.error(
                     'archive read stream for %s threw an error %',
-                    opts.vm.uuid, e.message);
+                    opts.vm.uuid,
+                    e.message
+                );
             });
 
             copySocket.pipe(res);
@@ -731,7 +936,6 @@ function containerCopy(req, res, next) {
     });
 }
 
-
 /**
  * GET /containers/:id/archive
  */
@@ -756,18 +960,20 @@ function containerReadArchive(req, res, next) {
             return next(err);
         }
 
-        var statHeader = new Buffer(JSON.stringify(
-            extras.containerPathStat)).toString('base64');
+        var statHeader = new Buffer(
+            JSON.stringify(extras.containerPathStat)
+        ).toString('base64');
 
-
-        readSocket.on('connect', function () {
+        readSocket.on('connect', function() {
             res.setHeader('content-type', 'application/tar');
             res.setHeader('x-docker-container-path-stat', statHeader);
 
-            readSocket.on('error', function (e) {
+            readSocket.on('error', function(e) {
                 opts.log.error(
                     'archive read stream for %s threw an error %',
-                    opts.vm.uuid, e.message);
+                    opts.vm.uuid,
+                    e.message
+                );
             });
 
             readSocket.pipe(res);
@@ -776,7 +982,6 @@ function containerReadArchive(req, res, next) {
     }
 }
 
-
 /**
  * PUT /containers/:id/archive
  */
@@ -800,32 +1005,42 @@ function containerWriteArchive(req, res, next) {
     }
 
     req.backend.containerArchiveWriteStream(
-        opts, onContainerArchiveWriteStream);
+        opts,
+        onContainerArchiveWriteStream
+    );
 
     function onContainerArchiveWriteStream(err, archiveSocket) {
         if (err) {
             return next(err);
         }
 
-        archiveSocket.on('connect', function () {
+        archiveSocket.on('connect', function() {
             res.setHeader('content-type', 'text/plain');
             req.pipe(archiveSocket);
 
             var error;
-            archiveSocket.on('error', function (e) {
+            archiveSocket.on('error', function(e) {
                 error = e;
                 opts.log.error(
                     'archive read stream for %s threw an error %',
-                    opts.vm.uuid, error.toString());
+                    opts.vm.uuid,
+                    error.toString()
+                );
             });
 
-            archiveSocket.on('close', function (hadError) {
+            archiveSocket.on('close', function(hadError) {
                 opts.log.debug(
-                    'copySocket (write) closed, hadError=%s', hadError);
+                    'copySocket (write) closed, hadError=%s',
+                    hadError
+                );
 
                 if (hadError) {
-                    res.send(new error.DockerError(
-                        error, 'problem copying to container'));
+                    res.send(
+                        new error.DockerError(
+                            error,
+                            'problem copying to container'
+                        )
+                    );
                 } else {
                     res.send(200);
                 }
@@ -836,7 +1051,6 @@ function containerWriteArchive(req, res, next) {
     }
 }
 
-
 /**
  * HEAD /containers/:id/archive
  */
@@ -859,8 +1073,9 @@ function containerStatArchive(req, res, next) {
             return next(err);
         }
 
-        var statHeader = new Buffer(JSON.stringify(
-            extras.containerPathStat)).toString('base64');
+        var statHeader = new Buffer(
+            JSON.stringify(extras.containerPathStat)
+        ).toString('base64');
 
         res.setHeader('x-docker-container-path-stat', statHeader);
 
@@ -869,7 +1084,6 @@ function containerStatArchive(req, res, next) {
     });
 }
 
-
 /**
  * POST /containers/:id/exec
  */
@@ -879,28 +1093,29 @@ function containerExec(req, res, next) {
 
     req.log.debug({req: req}, 'req');
 
-    req.backend.execContainer({
-        account: req.account,
-        app: req.app,
-        id: id,
-        log: log,
-        payload: req.body,
-        req_id: req.getId(),
-        vm: req.vm
-    }, function (err, cmdId, socketData) {
+    req.backend.execContainer(
+        {
+            account: req.account,
+            app: req.app,
+            id: id,
+            log: log,
+            payload: req.body,
+            req_id: req.getId(),
+            vm: req.vm
+        },
+        function(err, cmdId, socketData) {
             if (err) {
                 log.error({err: err}, 'backend.execContainer error');
                 next(err);
                 return;
             }
 
-            res.send({ Id: cmdId });
+            res.send({Id: cmdId});
             next();
         }
     );
 }
 
-
 /**
  * POST /containers/:id/rename?name=
  */
@@ -910,21 +1125,23 @@ function containerRename(req, res, next) {
 
     log.debug({req: req}, 'req');
 
-    req.backend.renameContainer({
-        account: req.account,
-        app: req.app,
-        log: log,
-        name: name,
-        req_id: req.getId(),
-        vm: req.vm
-    }, function (err, cmdId, socketData) {
+    req.backend.renameContainer(
+        {
+            account: req.account,
+            app: req.app,
+            log: log,
+            name: name,
+            req_id: req.getId(),
+            vm: req.vm
+        },
+        function(err, cmdId, socketData) {
             if (err) {
                 log.error({err: err}, 'backend.execContainer error');
                 next(err);
                 return;
             }
 
-            res.send({ Id: cmdId });
+            res.send({Id: cmdId});
             next();
         }
     );
@@ -934,7 +1151,6 @@ function containerRename(req, res, next) {
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-
     function reqParamsId(req, res, next) {
         req.params.id = unescape(req.params[1]);
         next();
@@ -956,140 +1172,337 @@ function register(http, before) {
     var queryParser = restify.queryParser(queryParserOpts);
 
     // Match: '/:apiversion/containers/json'
-    http.get({ path: /^(\/v[^\/]+)?\/containers\/json$/,
-        name: 'ContainerList' }, before,
-        queryParser, containerList);
+    http.get(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/json$/,
+            name: 'ContainerList'
+        },
+        before,
+        queryParser,
+        containerList
+    );
 
     // Match: '/:apiversion/containers/create'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/create$/,
-        name: 'ContainerCreate' },
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/create$/,
+            name: 'ContainerCreate'
+        },
         before,
         restify.bodyParser(),
         validate.createContainer,
         common.checkApprovedForProvisioning,
         common.reqImageIncludeSmartos,
         queryParser,
-        containerCreate);
+        containerCreate
+    );
 
     // Match: '/:apiversion/containers/:id/json'
-    http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/json$/,
-        name: 'ContainerInspect' }, before, reqParamsId, getVm,
-        containerInspect);
+    http.get(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/json$/,
+            name: 'ContainerInspect'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        containerInspect
+    );
 
     // Match: '/:apiversion/containers/:id/top'
-    http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/top$/,
-        name: 'ContainerTop' }, before, reqParamsId, getVm,
-        queryParser, containerTop);
+    http.get(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/top$/,
+            name: 'ContainerTop'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        queryParser,
+        containerTop
+    );
 
     // Match: '/:apiversion/containers/:id/logs'
-    http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/logs$/,
-        name: 'ContainerLogs' }, before, reqParamsId, getVm,
-        queryParser, containerLogs);
+    http.get(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/logs$/,
+            name: 'ContainerLogs'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        queryParser,
+        containerLogs
+    );
 
     // Match: '/:apiversion/containers/:id/stats'
-    http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/stats$/,
-        name: 'ContainerStats' }, before, reqParamsId, getVm,
-        queryParser, containerStats);
+    http.get(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/stats$/,
+            name: 'ContainerStats'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        queryParser,
+        containerStats
+    );
 
     // Match: '/:apiversion/containers/:id/changes'
-    http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/changes$/,
-        name: 'ContainerChanges' }, before, reqParamsId, getVm,
-        containerChanges);
+    http.get(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/changes$/,
+            name: 'ContainerChanges'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        containerChanges
+    );
 
     // Match: '/:apiversion/containers/:id/export'
-    http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/export$/,
-        name: 'ContainerExport' }, before, reqParamsId, getVm, containerExport);
+    http.get(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/export$/,
+            name: 'ContainerExport'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        containerExport
+    );
 
     // Match: '/:apiversion/containers/:id/resize'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/resize$/,
-        name: 'ContainerResize' }, before, reqParamsId, getVm,
-        queryParser, containerResize);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/resize$/,
+            name: 'ContainerResize'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        queryParser,
+        containerResize
+    );
 
     // Match: '/:apiversion/containers/:id/start'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/start$/,
-        name: 'ContainerStart' }, before, reqParamsId, getVm, containerStart);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/start$/,
+            name: 'ContainerStart'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        containerStart
+    );
 
     // Match: '/:apiversion/containers/:id/stop'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/stop$/,
-        name: 'ContainerStop' }, before, reqParamsId, getVm,
-        queryParser, containerStop);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/stop$/,
+            name: 'ContainerStop'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        queryParser,
+        containerStop
+    );
 
     // Match: '/:apiversion/containers/:id/restart'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/restart$/,
-        name: 'ContainerRestart' }, before, reqParamsId, getVm,
-        containerRestart);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/restart$/,
+            name: 'ContainerRestart'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        containerRestart
+    );
 
     // Match: '/:apiversion/containers/:id/kill'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/kill$/,
-        name: 'ContainerKill' }, before, reqParamsId, getVm, containerKill);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/kill$/,
+            name: 'ContainerKill'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        containerKill
+    );
 
     // Match: '/:apiversion/containers/:id/pause'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/pause$/,
-        name: 'ContainerPause' }, before, reqParamsId, getVm, containerPause);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/pause$/,
+            name: 'ContainerPause'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        containerPause
+    );
 
     // Match: '/:apiversion/containers/:id/unpause'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/unpause$/,
-        name: 'ContainerUnPause' }, before, reqParamsId, getVm,
-        containerUnPause);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/unpause$/,
+            name: 'ContainerUnPause'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        containerUnPause
+    );
 
     // Match: '/:apiversion/containers/:id/attach'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/attach$/,
-        name: 'ContainerAttach' }, before, reqParamsId, getVm,
-        queryParser, containerAttach);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/attach$/,
+            name: 'ContainerAttach'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        queryParser,
+        containerAttach
+    );
 
     // Match: '/:apiversion/containers/:id/wait'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/wait$/,
-        name: 'ContainerWait' }, before, reqParamsId, getVm, containerWait);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/wait$/,
+            name: 'ContainerWait'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        containerWait
+    );
 
     // Match: '/:apiversion/containers/:id'
-    http.del({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)$/,
-        name: 'ContainerDelete' }, before, reqParamsId, getVm,
-        queryParser, containerDelete);
+    http.del(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)$/,
+            name: 'ContainerDelete'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        queryParser,
+        containerDelete
+    );
 
     // Match: '/:apiversion/containers/:id/link'
-    http.del({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/([^\/]+)$/,
-        name: 'LinkDelete' }, before, reqParamsId, reqParamsLink, getVm,
-        linkDelete);
+    http.del(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/([^\/]+)$/,
+            name: 'LinkDelete'
+        },
+        before,
+        reqParamsId,
+        reqParamsLink,
+        getVm,
+        linkDelete
+    );
     // Support docker 1.6, which adds an extra slash after 'containers':
     // Match: '/:apiversion/containers//:id/link'
-    http.del({ path: /^(\/v[^\/]+)?\/containers\/\/([^\/]+)\/([^\/]+)$/,
-        name: 'LinkDeleteAlt' }, before, reqParamsId, reqParamsLink, getVm,
-        linkDelete);
+    http.del(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/\/([^\/]+)\/([^\/]+)$/,
+            name: 'LinkDeleteAlt'
+        },
+        before,
+        reqParamsId,
+        reqParamsLink,
+        getVm,
+        linkDelete
+    );
 
     // Pre-v1.20 remote api `docker cp` calls out to /copy
     // Match: '/:apiversion/containers/:id/copy'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/copy$/,
-        name: 'ContainerCopy' }, before, reqParamsId, restify.bodyParser(),
-        getVm, containerCopy);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/copy$/,
+            name: 'ContainerCopy'
+        },
+        before,
+        reqParamsId,
+        restify.bodyParser(),
+        getVm,
+        containerCopy
+    );
 
     // Match: '/:apiversion/containers/:id/archive'
-    http.get({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/archive$/,
-        name: 'ContainerReadArchive' }, before, reqParamsId, getVm,
+    http.get(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/archive$/,
+            name: 'ContainerReadArchive'
+        },
+        before,
+        reqParamsId,
+        getVm,
         queryParser,
-        validate.archiveReadStream, containerReadArchive);
+        validate.archiveReadStream,
+        containerReadArchive
+    );
 
     // Match: '/:apiversion/containers/:id/archive'
-    http.put({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/archive$/,
-        name: 'ContainerWriteArchive' }, before, reqParamsId, getVm,
+    http.put(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/archive$/,
+            name: 'ContainerWriteArchive'
+        },
+        before,
+        reqParamsId,
+        getVm,
         queryParser,
-        validate.archiveWriteStream, containerWriteArchive);
+        validate.archiveWriteStream,
+        containerWriteArchive
+    );
 
     // Match: '/:apiversion/containers/:id/archive'
-    http.head({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/archive$/,
-        name: 'ContainerStatArchive' }, before, reqParamsId, getVm,
+    http.head(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/archive$/,
+            name: 'ContainerStatArchive'
+        },
+        before,
+        reqParamsId,
+        getVm,
         queryParser,
-        validate.archiveReadStream, containerStatArchive);
-
+        validate.archiveReadStream,
+        containerStatArchive
+    );
 
     // Match: '/:apiversion/containers/:id/exec'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/exec$/,
-        name: 'ContainerExec' }, before, reqParamsId, getVm,
-        restify.bodyParser(), containerExec);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/exec$/,
+            name: 'ContainerExec'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        restify.bodyParser(),
+        containerExec
+    );
 
     // Match: '/:apiversion/containers/:id/rename'
-    http.post({ path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/rename$/,
-        name: 'ContainerRename' }, before, reqParamsId, getVm,
-        queryParser, containerRename);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/containers\/([^\/]+)\/rename$/,
+            name: 'ContainerRename'
+        },
+        before,
+        reqParamsId,
+        getVm,
+        queryParser,
+        containerRename
+    );
 }
 
 module.exports = {
diff --git a/lib/endpoints/events.js b/lib/endpoints/events.js
index 5fb439d..256a336 100644
--- a/lib/endpoints/events.js
+++ b/lib/endpoints/events.js
@@ -11,8 +11,6 @@
 var restify = require('restify');
 var errors = require('../errors');
 
-
-
 /**
  * GET /events
  */
@@ -20,17 +18,13 @@ function events(req, res, next) {
     return next(new errors.NotImplementedError('events'));
 }
 
-
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.get({ path: /^(\/v[^\/]+)?\/events$/, name: 'Events' }, events);
+    http.get({path: /^(\/v[^\/]+)?\/events$/, name: 'Events'}, events);
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/exec.js b/lib/endpoints/exec.js
index ab071c8..26458b7 100644
--- a/lib/endpoints/exec.js
+++ b/lib/endpoints/exec.js
@@ -10,8 +10,6 @@
 
 var restify = require('restify');
 
-
-
 /**
  * POST /exec/:id/start
  *
@@ -47,17 +45,21 @@ function execStart(req, res, next) {
     req.connection.setTimeout(60 * 60 * 1000);
 
     // At this moment req.socket is already hijacked
-    req.socket.write('HTTP/1.1 101 UPGRADED\r\nContent-Type: '
-        + 'application/vnd.docker.raw-stream\r\n\r\n');
-
-    req.backend.execStart({
-        cmdId: id,
-        app: req.app,
-        log: log,
-        socketData: socketData,
-        account: req.account,
-        socket: req.socket
-    }, function (err) {
+    req.socket.write(
+        'HTTP/1.1 101 UPGRADED\r\nContent-Type: ' +
+            'application/vnd.docker.raw-stream\r\n\r\n'
+    );
+
+    req.backend.execStart(
+        {
+            cmdId: id,
+            app: req.app,
+            log: log,
+            socketData: socketData,
+            account: req.account,
+            socket: req.socket
+        },
+        function(err) {
             if (err) {
                 log.error({err: err}, 'backend.execStart error');
                 next(err);
@@ -69,7 +71,6 @@ function execStart(req, res, next) {
     );
 }
 
-
 /**
  * POST /exec/:id/resize
  */
@@ -84,27 +85,31 @@ function execResize(req, res, next) {
         next(restify.ResourceNotFoundError('no such exec instance'));
         return;
     } else if (!socketData.command.Tty) {
-        req.log.info('Attempting to resize exec %s with no AttachStdin '
-            + 'and no Tty', id);
+        req.log.info(
+            'Attempting to resize exec %s with no AttachStdin ' + 'and no Tty',
+            id
+        );
         res.send(200);
         next();
         return;
     }
 
-    req.backend.execResize({
-        app: req.app,
-        log: log,
-        account: req.account,
-        socketData: socketData,
-        w: Number(req.query.w),
-        h: Number(req.query.h)
-    }, function () {
-        res.send(200);
-        next();
-    });
+    req.backend.execResize(
+        {
+            app: req.app,
+            log: log,
+            account: req.account,
+            socketData: socketData,
+            w: Number(req.query.w),
+            h: Number(req.query.h)
+        },
+        function() {
+            res.send(200);
+            next();
+        }
+    );
 }
 
-
 /**
  * POST /exec/:id/json
  *
@@ -122,37 +127,54 @@ function execInspect(req, res, next) {
         return;
     }
 
-    var running = (socketData.command.Detach ? true : false);
+    var running = socketData.command.Detach ? true : false;
     req.app.sockets.removeSocket('exec', id);
-    res.send({ Running: running, ExitCode: socketData.ExitCode });
+    res.send({Running: running, ExitCode: socketData.ExitCode});
 
     next();
 }
 
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-
     function reqParamsId(req, res, next) {
         req.params.id = unescape(req.params[1]);
         next();
     }
 
-    http.post({ path: /^(\/v[^\/]+)?\/exec\/([^\/]+)\/start$/,
-        name: 'ExecStart' }, before, reqParamsId, execStart);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/exec\/([^\/]+)\/start$/,
+            name: 'ExecStart'
+        },
+        before,
+        reqParamsId,
+        execStart
+    );
 
-    http.post({ path: /^(\/v[^\/]+)?\/exec\/([^\/]+)\/resize$/,
-        name: 'ExecResize' }, before, reqParamsId,
-        restify.queryParser({mapParams: false}), execResize);
+    http.post(
+        {
+            path: /^(\/v[^\/]+)?\/exec\/([^\/]+)\/resize$/,
+            name: 'ExecResize'
+        },
+        before,
+        reqParamsId,
+        restify.queryParser({mapParams: false}),
+        execResize
+    );
 
-    http.get({ path: /^(\/v[^\/]+)?\/exec\/([^\/]+)\/json$/,
-    	name: 'ExecInspect' }, before, reqParamsId, execInspect);
+    http.get(
+        {
+            path: /^(\/v[^\/]+)?\/exec\/([^\/]+)\/json$/,
+            name: 'ExecInspect'
+        },
+        before,
+        reqParamsId,
+        execInspect
+    );
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/images.js b/lib/endpoints/images.js
index 5d3f081..f03ae5e 100644
--- a/lib/endpoints/images.js
+++ b/lib/endpoints/images.js
@@ -19,12 +19,10 @@ var writeProgress = common.writeProgress;
 var writeStatus = common.writeStatus;
 var errors = require('../errors');
 
-
 // --- globals
 
 var p = console.log; //XXX
 
-
 // --- endpoint handlers
 
 /**
@@ -43,7 +41,7 @@ function imageList(req, res, next) {
     options.skip_smartos = true;
     options.account = req.account;
 
-    req.backend.listImages(options, function (err, images) {
+    req.backend.listImages(options, function(err, images) {
         if (err) {
             log.error({err: err}, 'Problem loading images');
             next(new errors.DockerError(err, 'problem loading images'));
@@ -55,7 +53,6 @@ function imageList(req, res, next) {
     });
 }
 
-
 /**
  * `POST /images/create`, i.e. `docker pull` or `docker import`
  *
@@ -90,9 +87,11 @@ function imageCreate(req, res, next) {
         return;
     }
     // TODO(DOCKER-587): is this `all = ...` accurate with digest in play?
-    var all = (!req.query.tag
-        && rat.tag && rat.tag === 'latest'
-        && req.query.fromImage.slice(-':latest'.length) !== ':latest');
+    var all =
+        !req.query.tag &&
+        rat.tag &&
+        rat.tag === 'latest' &&
+        req.query.fromImage.slice(-':latest'.length) !== ':latest';
     if (all) {
         next(new errors.NotImplementedError('docker pull -a'));
         return;
@@ -101,74 +100,80 @@ function imageCreate(req, res, next) {
         rat.tag = req.query.tag;
     }
 
-
     res.status(200);
     res.header('Content-Type', 'application/json');
 
-    req.backend.pullImage({
-        app: req.app,
-        log: log,
-        rat: rat,
-        req: req,
-        req_id: req.getId(),
-        res: res,
-        wfapi: req.wfapi,
-        account: req.account
-    }, function () {
-        // XXX NOTHING returned from this??? No 'err'?
-        req.app.sockets.removeSocket('job', rat.canonicalName);
-        res.end();
-        next(false); // XXX need this early abort?
-    });
+    req.backend.pullImage(
+        {
+            app: req.app,
+            log: log,
+            rat: rat,
+            req: req,
+            req_id: req.getId(),
+            res: res,
+            wfapi: req.wfapi,
+            account: req.account
+        },
+        function() {
+            // XXX NOTHING returned from this??? No 'err'?
+            req.app.sockets.removeSocket('job', rat.canonicalName);
+            res.end();
+            next(false); // XXX need this early abort?
+        }
+    );
 }
 
-
 /**
  * `GET /images/:name/json`, called eventually from `docker inspect ...`
  *
  * `:name` can be name[:tag] (tag defaults to "latest") or id.
  */
 function imageInspect(req, res, next) {
-    req.backend.inspectImage({
-        app: req.app,
-        account: req.account,
-        name: req.params.name,
-        log: req.log
-    }, function (err, image) {
-        if (err) {
-            next(err);
-            return;
+    req.backend.inspectImage(
+        {
+            app: req.app,
+            account: req.account,
+            name: req.params.name,
+            log: req.log
+        },
+        function(err, image) {
+            if (err) {
+                next(err);
+                return;
+            }
+            res.send(image);
+            next();
         }
-        res.send(image);
-        next();
-    });
+    );
 }
 
-
 /**
  * `GET /images/:name/history`, `docker history`
  *
  * Note: req.image is already populated by the reqImage() handler.
  */
 function imageHistory(req, res, next) {
-    req.backend.getImageHistory({
-        app: req.app,
-        account: req.account,
-        img: req.image,
-        log: req.log
-    }, function (histErr, history) {
-        if (histErr) {
-            next(histErr);
-            return;
+    req.backend.getImageHistory(
+        {
+            app: req.app,
+            account: req.account,
+            img: req.image,
+            log: req.log
+        },
+        function(histErr, history) {
+            if (histErr) {
+                next(histErr);
+                return;
+            }
+            var historyItems = history.map(function(i) {
+                return i.toHistoryItem();
+            });
+            res.send(historyItems);
+            next();
         }
-        var historyItems = history.map(
-            function (i) { return i.toHistoryItem(); });
-        res.send(historyItems);
-        next();
-    });
+    );
 }
 
-
 /**
  * POST /images/:name/push
  */
@@ -176,7 +181,6 @@ function imagePush(req, res, next) {
     return next(new errors.NotImplementedError('image push'));
 }
 
-
 /**
  * GET /images/:name/changes
  */
@@ -184,7 +188,6 @@ function imageChanges(req, res, next) {
     return next(new errors.NotImplementedError('image changes'));
 }
 
-
 /**
  * GET /images/:name/tag
  *
@@ -206,52 +209,62 @@ function imageTag(req, res, next) {
 
     // DOCKER-748: Ensure the tag and the image are in the same repository.
     if (req.image.index_name !== rat.index.name) {
-        next(new errors.DockerError(format(
-            'Cannot create tag reference between different registries (%s, %s)',
-            req.image.index_name, rat.index.name)));
+        next(
+            new errors.DockerError(
+                format(
+                    'Cannot create tag reference between different registries (%s, %s)',
+                    req.image.index_name,
+                    rat.index.name
+                )
+            )
+        );
         return;
     }
 
-    req.backend.tagImage({
-        docker_id: req.image.docker_id,
-        name: repoAndTag,
-        req: req
-    }, function (err, history) {
-        if (err) {
-            req.log.error({err: err}, 'backend.imageTag failed');
-            next(err);
-            return;
+    req.backend.tagImage(
+        {
+            docker_id: req.image.docker_id,
+            name: repoAndTag,
+            req: req
+        },
+        function(err, history) {
+            if (err) {
+                req.log.error({err: err}, 'backend.imageTag failed');
+                next(err);
+                return;
+            }
+            res.status(201); // Okay - tag was created.
+            res.end();
+            next();
         }
-        res.status(201);  // Okay - tag was created.
-        res.end();
-        next();
-    });
+    );
 }
 
-
 /**
  * DELETE /images/:name
  */
 function imageDelete(req, res, next) {
-    req.backend.deleteImage({
-        app: req.app,
-        log: req.log,
-        req_id: req.getId(),
-        account: req.account,
-        name: req.params.name,
-        force: common.boolFromQueryParam(req.query.force)
-    }, function (err, history) {
-        if (err) {
-            req.log.error({err: err}, 'backend.imageDelete failed');
-            next(err);
-            return;
+    req.backend.deleteImage(
+        {
+            app: req.app,
+            log: req.log,
+            req_id: req.getId(),
+            account: req.account,
+            name: req.params.name,
+            force: common.boolFromQueryParam(req.query.force)
+        },
+        function(err, history) {
+            if (err) {
+                req.log.error({err: err}, 'backend.imageDelete failed');
+                next(err);
+                return;
+            }
+            res.send(history);
+            next();
         }
-        res.send(history);
-        next();
-    });
+    );
 }
 
-
 /**
  * `GET /images/search?term=TERM`, `docker search`.
  *
@@ -277,17 +290,29 @@ function imageSearch(req, res, next) {
      */
     var term = repo.index.official ? repo.localName : repo.remoteName;
 
-    var regClient = drc.createClientV1(common.httpClientOpts({
-        name: repo.canonicalName,
-        log: log,
-        insecure: req.app.config.dockerRegistryInsecure,
-        username: req.regAuth && req.regAuth.username,
-        password: req.regAuth && req.regAuth.password
-    }, req));
-    regClient.search({term: term}, function (err, body) {
+    var regClient = drc.createClientV1(
+        common.httpClientOpts(
+            {
+                name: repo.canonicalName,
+                log: log,
+                insecure: req.app.config.dockerRegistryInsecure,
+                username: req.regAuth && req.regAuth.username,
+                password: req.regAuth && req.regAuth.password
+            },
+            req
+        )
+    );
+    regClient.search({term: term}, function(err, body) {
         regClient.close();
-        log.info({repo: repo.canonicalName, term: term, err: err,
-            num_results: body && body.num_results}, 'search results');
+        log.info(
+            {
+                repo: repo.canonicalName,
+                term: term,
+                err: err,
+                num_results: body && body.num_results
+            },
+            'search results'
+        );
         if (err) {
             next(err);
             return;
@@ -297,7 +322,6 @@ function imageSearch(req, res, next) {
     });
 }
 
-
 /**
  * GET /images/:name/get
  */
@@ -305,7 +329,6 @@ function imageGet(req, res, next) {
     return next(new errors.NotImplementedError('image get'));
 }
 
-
 /**
  * POST /images/:name/load
  */
@@ -313,47 +336,58 @@ function imageLoad(req, res, next) {
     return next(new errors.NotImplementedError('image load'));
 }
 
-
-
 // --- exports
 
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-
     function reqParamsName(req, res, next) {
         req.params.name = unescape(req.params[1]);
         next();
     }
 
     function reqImage(req, res, next) {
-        req.backend.imgFromName({
-            app: req.app,
-            account: req.account,
-            log: req.log,
-            name: req.params.name
-        }, function (err, img) {
-            if (err) {
-                next(err);
-                return;
-            }
-            if (!img) {
-                next(new errors.ResourceNotFoundError(
-                    'No such image: ' + req.params.name));
-                return;
+        req.backend.imgFromName(
+            {
+                app: req.app,
+                account: req.account,
+                log: req.log,
+                name: req.params.name
+            },
+            function(err, img) {
+                if (err) {
+                    next(err);
+                    return;
+                }
+                if (!img) {
+                    next(
+                        new errors.ResourceNotFoundError(
+                            'No such image: ' + req.params.name
+                        )
+                    );
+                    return;
+                }
+                req.image = img;
+                next();
             }
-            req.image = img;
-            next();
-        });
+        );
     }
 
-    http.get({ path: /^(\/v[^\/]+)?\/images\/json$/, name: 'ImageList' },
-        before, restify.queryParser({mapParams: false}), imageList);
+    http.get(
+        {path: /^(\/v[^\/]+)?\/images\/json$/, name: 'ImageList'},
+        before,
+        restify.queryParser({mapParams: false}),
+        imageList
+    );
 
-    http.post({ path: /^(\/v[^\/]+)?\/images\/create$/, name: 'ImageCreate' },
-            before, common.checkApprovedForProvisioning,
-            restify.queryParser({mapParams: false}), imageCreate);
+    http.post(
+        {path: /^(\/v[^\/]+)?\/images\/create$/, name: 'ImageCreate'},
+        before,
+        common.checkApprovedForProvisioning,
+        restify.queryParser({mapParams: false}),
+        imageCreate
+    );
 
     /*
      * Match '/:apiversion/images/:name/json' where ':name' can have one
@@ -361,49 +395,76 @@ function register(http, before) {
      * repo name.
      */
     http.get(
-        { path: /^(\/v[^\/]+)?\/images\/(.*?)\/json$/, name: 'ImageInspect' },
-        reqParamsName, before, imageInspect);
+        {path: /^(\/v[^\/]+)?\/images\/(.*?)\/json$/, name: 'ImageInspect'},
+        reqParamsName,
+        before,
+        imageInspect
+    );
 
     // Match '/:apiversion/images/:name/history' where ':name' can include '/'.
     http.get(
-        { path: /^(\/v[^\/]+)?\/images\/(.*?)\/history$/,
-            name: 'ImageHistory' },
-        reqParamsName, before, reqImage, imageHistory);
+        {
+            path: /^(\/v[^\/]+)?\/images\/(.*?)\/history$/,
+            name: 'ImageHistory'
+        },
+        reqParamsName,
+        before,
+        reqImage,
+        imageHistory
+    );
 
     // Match '/:apiversion/images/:name/push' where ':name' can include '/'.
     http.post(
-        { path: /^(\/v[^\/]+)?\/images\/(.*?)\/push$/, name: 'ImagePush' },
-        reqParamsName, before, imagePush);
+        {path: /^(\/v[^\/]+)?\/images\/(.*?)\/push$/, name: 'ImagePush'},
+        reqParamsName,
+        before,
+        imagePush
+    );
 
     // Match '/:apiversion/images/:name/tag' where ':name' can include '/'.
     http.post(
-        { path: /^(\/v[^\/]+)?\/images\/(.*?)\/tag$/, name: 'ImageTag' },
-        reqParamsName, before, reqImage,
-        restify.queryParser({mapParams: false}), imageTag);
+        {path: /^(\/v[^\/]+)?\/images\/(.*?)\/tag$/, name: 'ImageTag'},
+        reqParamsName,
+        before,
+        reqImage,
+        restify.queryParser({mapParams: false}),
+        imageTag
+    );
 
     // Match '/:apiversion/images/:name' where ':name' can include '/'.
     http.del(
-        { path: /^(\/v[^\/]+)?\/images\/(.*?)$/, name: 'ImageDelete' },
-        reqParamsName, before,
-        restify.queryParser({mapParams: false}), imageDelete);
+        {path: /^(\/v[^\/]+)?\/images\/(.*?)$/, name: 'ImageDelete'},
+        reqParamsName,
+        before,
+        restify.queryParser({mapParams: false}),
+        imageDelete
+    );
 
-    http.get({ path: /^(\/v[^\/]+)?\/images\/search$/, name: 'ImageSearch' },
-        before, restify.queryParser({mapParams: false}),
-        common.reqRegAuth, imageSearch);
+    http.get(
+        {path: /^(\/v[^\/]+)?\/images\/search$/, name: 'ImageSearch'},
+        before,
+        restify.queryParser({mapParams: false}),
+        common.reqRegAuth,
+        imageSearch
+    );
 
     // Match '/:apiversion/images/:name/get' where ':name' can include '/'.
     http.get(
-        { path: /^(\/v[^\/]+)?\/images\/(.*?)\/get$/, name: 'ImageGet' },
-        reqParamsName, before, imageGet);
+        {path: /^(\/v[^\/]+)?\/images\/(.*?)\/get$/, name: 'ImageGet'},
+        reqParamsName,
+        before,
+        imageGet
+    );
 
     // Match '/:apiversion/images/:name/load' where ':name' can include '/'.
     http.post(
-        { path: /^(\/v[^\/]+)?\/images\/(.*?)\/load$/, name: 'ImageLoad' },
-        reqParamsName, before, imageLoad);
+        {path: /^(\/v[^\/]+)?\/images\/(.*?)\/load$/, name: 'ImageLoad'},
+        reqParamsName,
+        before,
+        imageLoad
+    );
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/index.js b/lib/endpoints/index.js
index 46afc2b..42f8d04 100644
--- a/lib/endpoints/index.js
+++ b/lib/endpoints/index.js
@@ -8,7 +8,6 @@
  * Copyright (c) 2014, Joyent, Inc.
  */
 
-
 /*
  * Endpoints are in their own individual files, in a directory structure
  * that roughly matches their routes, eg:
@@ -28,12 +27,8 @@ var toRegister = {
     '/version': require('./version')
 };
 
-
-
 // --- Exports
 
-
-
 /*
  * Register all endpoints with the restify server
  */
@@ -44,8 +39,6 @@ function registerEndpoints(http, log, before) {
     }
 }
 
-
-
 module.exports = {
     register: registerEndpoints
 };
diff --git a/lib/endpoints/info.js b/lib/endpoints/info.js
index 5dc7fbc..67a8c44 100644
--- a/lib/endpoints/info.js
+++ b/lib/endpoints/info.js
@@ -8,38 +8,35 @@
  * Copyright (c) 2015, Joyent, Inc.
  */
 
-
 /**
  * GET /$version/info
  */
 function info(req, res, next) {
-    req.backend.getInfo({
-        clientApiVersion: req.clientApiVersion,
-        app: req.app,
-        log: req.log,
-        req_id: req.getId(),
-        account: req.account
-    }, function (err, sysinfo) {
-        if (err) {
-            return next(err);
+    req.backend.getInfo(
+        {
+            clientApiVersion: req.clientApiVersion,
+            app: req.app,
+            log: req.log,
+            req_id: req.getId(),
+            account: req.account
+        },
+        function(err, sysinfo) {
+            if (err) {
+                return next(err);
+            }
+            res.send(sysinfo);
+            next();
         }
-        res.send(sysinfo);
-        next();
-    });
+    );
 }
 
-
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.get({ path: /^(\/v[^\/]+)?\/info$/, name: 'Info' },
-        before, info);
+    http.get({path: /^(\/v[^\/]+)?\/info$/, name: 'Info'}, before, info);
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/endpoints/version.js b/lib/endpoints/version.js
index c39322a..ac4fc83 100644
--- a/lib/endpoints/version.js
+++ b/lib/endpoints/version.js
@@ -16,22 +16,19 @@ var errors = require('../errors');
 var common = require('../common');
 var constants = require('../constants');
 
-
 var dockerArchFromArch = {
-    'x64': 'amd64',
-    'ia32': 'i386'
+    x64: 'amd64',
+    ia32: 'i386'
 };
 
 var dockerOsFromPlatform = {
-    'darwin': 'darwin',
-    'linux': 'linux',
-    'sunos': 'solaris'
+    darwin: 'darwin',
+    linux: 'linux',
+    sunos: 'solaris'
 };
 
 var buildInfo; // loaded lazily
 
-
-
 /**
  * GET /$v/version
  *
@@ -47,37 +44,37 @@ function version(req, res, next) {
     }
     var dockerOs = dockerOsFromPlatform[os.platform()];
     if (!dockerOs) {
-        return next(new errors.DockerError(
-            'unknown platform:' + os.platform()));
+        return next(
+            new errors.DockerError('unknown platform:' + os.platform())
+        );
     }
     buildInfo = require(path.resolve(__dirname, '../../etc/build.json'));
     var v = {
-        'ApiVersion': constants.API_VERSION,
-        'Arch': dockerArch,
-        'BuildTime': buildInfo.date,
-        'GitCommit': buildInfo.commit,
-        'GoVersion': 'node' + process.version.slice(1),
+        ApiVersion: constants.API_VERSION,
+        Arch: dockerArch,
+        BuildTime: buildInfo.date,
+        GitCommit: buildInfo.commit,
+        GoVersion: 'node' + process.version.slice(1),
         // XXX shell out to `uname` for this? Then *cache* that.
         //  'KernelVersion': '3.13.0-36-generic',
-        'Os': dockerOs,
-        'Version': constants.SERVER_VERSION
+        Os: dockerOs,
+        Version: constants.SERVER_VERSION
     };
     res.send(v);
     next();
 }
 
-
-
 /**
  * Register all endpoints with the restify server
  */
 function register(http, before) {
-    http.get({ path: /^(\/v[^\/]+)?\/version$/, name: 'Version' },
-        before, version);
+    http.get(
+        {path: /^(\/v[^\/]+)?\/version$/, name: 'Version'},
+        before,
+        version
+    );
 }
 
-
-
 module.exports = {
     register: register
 };
diff --git a/lib/errors.js b/lib/errors.js
index 6003ac4..0caba6b 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -96,16 +96,12 @@ var assert = require('assert-plus');
 var restify = require('restify');
 var util = require('util');
 
-
-
 // ---- globals
 
 var p = console.warn;
 var fmt = util.format;
 var RestError = restify.RestError;
 
-
-
 // ---- exported functions
 
 /**
@@ -124,7 +120,7 @@ function formatErrOrText(req, res, body, cb) {
 
         // Update `res._body` for the audit logger.
         res._body = body;
-    } else if (typeof (body) === 'object') {
+    } else if (typeof body === 'object') {
         body = JSON.stringify(body);
     } else {
         body = body.toString();
@@ -139,8 +135,6 @@ function formatErrOrText(req, res, body, cb) {
     return cb(null, body);
 }
 
-
-
 // ---- specialized base restify error classes
 
 /**
@@ -157,8 +151,6 @@ function UnauthorizedError(cause) {
 }
 util.inherits(UnauthorizedError, restify.UnauthorizedError);
 
-
-
 // ---- SDC Docker-specific error class hierarchy
 
 /**
@@ -177,7 +169,6 @@ function _DockerBaseError(opts) {
 }
 util.inherits(_DockerBaseError, RestError);
 
-
 /**
  * The generic catch-all error to throw if there isn't a specific error class.
  *
@@ -205,7 +196,6 @@ DockerError.statusCode = 500;
 DockerError.description =
     'Encountered an internal error while fulfilling request.';
 
-
 /**
  * TODO(trentm): call this just "TimeoutError"?
  */
@@ -224,7 +214,6 @@ CommandTimeoutError.restCode = 'CommandTimeout';
 CommandTimeoutError.statusCode = 500;
 CommandTimeoutError.description = 'Timed-out waiting for request response.';
 
-
 /**
  * When there isn't an available package that is big enough for the
  * requested container constraints (memory, cpu-shares).
@@ -235,9 +224,12 @@ CommandTimeoutError.description = 'Timed-out waiting for request response.';
 function NoSufficientPackageError(constraints) {
     assert.object(constraints, 'constraints');
 
-    var msg = 'no package supports the given container constraints: '
-        + Object.keys(constraints).map(
-            function (c) { return fmt('%s=%s', c, constraints[c]); })
+    var msg =
+        'no package supports the given container constraints: ' +
+        Object.keys(constraints)
+            .map(function(c) {
+                return fmt('%s=%s', c, constraints[c]);
+            })
             .join(', ');
     _DockerBaseError.call(this, {
         restCode: this.constructor.restCode,
@@ -252,7 +244,6 @@ NoSufficientPackageError.statusCode = 422;
 NoSufficientPackageError.description =
     'No package in the DC supports the requested container constraints.';
 
-
 function NotImplementedError(feature) {
     _DockerBaseError.call(this, {
         restCode: this.constructor.restCode,
@@ -267,7 +258,6 @@ NotImplementedError.statusCode = 400;
 NotImplementedError.description =
     'Attempt to use a feature that is not yet implemented';
 
-
 function ValidationError(cause, message) {
     if (message === undefined) {
         message = cause;
@@ -288,15 +278,17 @@ ValidationError.restCode = 'Validation';
 ValidationError.statusCode = 422;
 ValidationError.description = 'Invalid request payload';
 
-
 function AmbiguousDockerImageIdError(imgId, registries) {
     assert.string(imgId, 'imgId');
     assert.arrayOfString(registries, 'registries');
 
-    var message = fmt('image id "%s" does not unambiguously identify a '
-        + 'single image because it has been pulled from multiple '
-        + 'registries: %s; use "repo:tag" if possible', imgId,
-        registries.join(', '));
+    var message = fmt(
+        'image id "%s" does not unambiguously identify a ' +
+            'single image because it has been pulled from multiple ' +
+            'registries: %s; use "repo:tag" if possible',
+        imgId,
+        registries.join(', ')
+    );
     _DockerBaseError.call(this, {
         restCode: this.constructor.restCode,
         statusCode: this.constructor.statusCode,
@@ -308,9 +300,8 @@ AmbiguousDockerImageIdError.prototype.name = 'AmbiguousDockerImageIdError';
 AmbiguousDockerImageIdError.restCode = 'AmbiguousDockerImageId';
 AmbiguousDockerImageIdError.statusCode = 422;
 AmbiguousDockerImageIdError.description =
-    'A Docker image id does not unique identify an image because the '
-    + 'same Docker id is pulled from multiple registries';
-
+    'A Docker image id does not unique identify an image because the ' +
+    'same Docker id is pulled from multiple registries';
 
 /*
  * An error to return when a given Docker container ID prefix is required to
@@ -333,10 +324,10 @@ function AmbiguousDockerContainerIdPrefixError(idPrefix, ids) {
     });
 }
 util.inherits(AmbiguousDockerContainerIdPrefixError, _DockerBaseError);
-AmbiguousDockerContainerIdPrefixError.prototype.name
-    = 'AmbiguousDockerContainerIdPrefixError';
-AmbiguousDockerContainerIdPrefixError.restCode
-    = 'AmbiguousDockerContainerIdPrefix';
+AmbiguousDockerContainerIdPrefixError.prototype.name =
+    'AmbiguousDockerContainerIdPrefixError';
+AmbiguousDockerContainerIdPrefixError.restCode =
+    'AmbiguousDockerContainerIdPrefix';
 AmbiguousDockerContainerIdPrefixError.statusCode = 404;
 AmbiguousDockerContainerIdPrefixError.description =
     'A Docker container id prefix matches more than one container.';
@@ -352,9 +343,13 @@ function AmbiguousDockerNetworkIdPrefixError(idPrefix, networks) {
 
     var message = fmt('multiple networks match prefix %s', idPrefix);
     if (networks && networks.length > 0) {
-        message += ': ' + networks.map(function (net) {
-            return fmt('%s/%s', net.name, net.uuid);
-        }).join(', ');
+        message +=
+            ': ' +
+            networks
+                .map(function(net) {
+                    return fmt('%s/%s', net.name, net.uuid);
+                })
+                .join(', ');
     }
     _DockerBaseError.call(this, {
         restCode: this.constructor.restCode,
@@ -363,13 +358,12 @@ function AmbiguousDockerNetworkIdPrefixError(idPrefix, networks) {
     });
 }
 util.inherits(AmbiguousDockerNetworkIdPrefixError, _DockerBaseError);
-AmbiguousDockerNetworkIdPrefixError.prototype.name
-    = 'AmbiguousDockerNetworkIdPrefixError';
-AmbiguousDockerNetworkIdPrefixError.restCode
-    = 'AmbiguousDockerNetworkIdPrefix';
+AmbiguousDockerNetworkIdPrefixError.prototype.name =
+    'AmbiguousDockerNetworkIdPrefixError';
+AmbiguousDockerNetworkIdPrefixError.restCode = 'AmbiguousDockerNetworkIdPrefix';
 AmbiguousDockerNetworkIdPrefixError.statusCode = 404;
-AmbiguousDockerNetworkIdPrefixError.description
-    = 'A Docker network id prefix matches more than one network.';
+AmbiguousDockerNetworkIdPrefixError.description =
+    'A Docker network id prefix matches more than one network.';
 
 /*
  * Network not found.
@@ -406,11 +400,14 @@ function ExposedSDCError(cause, message) {
     var body = cause.body || {};
     assert.optionalString(body.message, 'cause.body.message');
 
-    var fullMsg = fmt('%s: %s', message,
-        body.message || cause.message || cause.toString());
+    var fullMsg = fmt(
+        '%s: %s',
+        message,
+        body.message || cause.message || cause.toString()
+    );
     if (body.errors) {
         var errMsgs = [];
-        body.errors.forEach(function (e) {
+        body.errors.forEach(function(e) {
             if (e.message) {
                 errMsgs.push(fmt('"%s" (%s) %s', e.field, e.code, e.message));
             } else {
@@ -420,7 +417,6 @@ function ExposedSDCError(cause, message) {
         fullMsg += ': ' + errMsgs.join(', ');
     }
 
-
     _DockerBaseError.call(this, {
         cause: cause,
         message: fullMsg,
@@ -433,7 +429,6 @@ function ExposedSDCError(cause, message) {
 }
 util.inherits(ExposedSDCError, _DockerBaseError);
 
-
 /**
  * Error to indicate we are "at capacity" and no servers can accomodate the
  * container requirements.
@@ -457,8 +452,6 @@ DockerNoComputeResourcesError.restCode = 'DockerNoComputeResourcesError';
 DockerNoComputeResourcesError.statusCode = 409;
 DockerNoComputeResourcesError.description = 'No compute resources available.';
 
-
-
 /**
  * Error to indicate the server hosting the container we wish to "volumes-from"
  * into our container is unable to meet the resource requirements specified by
@@ -470,8 +463,8 @@ DockerNoComputeResourcesError.description = 'No compute resources available.';
  */
 function VolumeServerNoResourcesError(cause) {
     var message =
-        'No compute resources available on the '
-        + 'host containing the mounted volume.';
+        'No compute resources available on the ' +
+        'host containing the mounted volume.';
     _DockerBaseError.call(this, {
         restCode: this.constructor.restCode,
         statusCode: (cause && cause.statusCode) || this.constructor.statusCode,
@@ -486,7 +479,6 @@ VolumeServerNoResourcesError.statusCode = 409;
 VolumeServerNoResourcesError.description =
     'No compute resources available on the host containing the mounted volume';
 
-
 /**
  * Error to indicate an upstream service dependency is presently unreachable,
  * preventing the sdc-docker service from being able to to confidently execute
@@ -497,8 +489,7 @@ VolumeServerNoResourcesError.description =
  *      new ServiceDegradedError(cause);
  */
 function ServiceDegradedError(cause) {
-    var message =
-        'service is currently unavailable';
+    var message = 'service is currently unavailable';
     _DockerBaseError.call(this, {
         restCode: this.constructor.restCode,
         statusCode: (cause && cause.statusCode) || this.constructor.statusCode,
@@ -507,14 +498,12 @@ function ServiceDegradedError(cause) {
     });
 }
 util.inherits(ServiceDegradedError, _DockerBaseError);
-ServiceDegradedError.prototype.name =
-    'ServiceDegradedError';
+ServiceDegradedError.prototype.name = 'ServiceDegradedError';
 ServiceDegradedError.restCode = 'ServiceUnavailableError';
 ServiceDegradedError.statusCode = 503;
 ServiceDegradedError.description =
     'An upstream service or dependency is currently unreachable';
 
-
 function DockerContainerNotRunningError(cause, message) {
     _DockerBaseError.call(this, {
         restCode: this.constructor.restCode,
@@ -524,17 +513,15 @@ function DockerContainerNotRunningError(cause, message) {
     });
 }
 util.inherits(DockerContainerNotRunningError, _DockerBaseError);
-DockerContainerNotRunningError.prototype.name
-    = 'DockerContainerNotRunningError';
+DockerContainerNotRunningError.prototype.name =
+    'DockerContainerNotRunningError';
 DockerContainerNotRunningError.restCode = 'DockerContainerNotRunning';
 DockerContainerNotRunningError.statusCode = 409;
-DockerContainerNotRunningError.description
-    = 'Operation attempted on container which is not running';
-
+DockerContainerNotRunningError.description =
+    'Operation attempted on container which is not running';
 
 function FileNotFoundError(cause) {
-    var message =
-        'no such file or directory';
+    var message = 'no such file or directory';
     _DockerBaseError.call(this, {
         restCode: this.constructor.restCode,
         statusCode: (cause && cause.statusCode) || this.constructor.statusCode,
@@ -548,10 +535,8 @@ FileNotFoundError.restCode = 'FileNotFound';
 FileNotFoundError.statusCode = 404;
 FileNotFoundError.description = 'no such file or directory';
 
-
 function PathNotDirectoryError(cause) {
-    var message =
-        'path was not to a directory';
+    var message = 'path was not to a directory';
     _DockerBaseError.call(this, {
         restCode: this.constructor.restCode,
         statusCode: (cause && cause.statusCode) || this.constructor.statusCode,
@@ -565,7 +550,6 @@ PathNotDirectoryError.restCode = 'PathNotDirectory';
 PathNotDirectoryError.statusCode = 404;
 PathNotDirectoryError.description = 'path was not to a directory';
 
-
 // ---- wrappers for API responses
 
 function vmapiErrorWrap(cause, message) {
@@ -584,14 +568,12 @@ function vmapiErrorWrap(cause, message) {
 
         case 'VolumeServerNoResourcesError':
             return new VolumeServerNoResourcesError();
-
         /* By default don't expose internal error message details. */
         default:
             return new DockerError(cause, message);
     }
 }
 
-
 function cnapiErrorWrap(cause, message, extra) {
     assert.optionalObject(extra, 'extra');
 
@@ -618,15 +600,14 @@ function cnapiErrorWrap(cause, message, extra) {
                 message = 'Container is not running';
             }
             return new DockerContainerNotRunningError(cause, message);
-
         /* Others */
 
+
         default:
             return new DockerError(cause, message);
     }
 }
 
-
 function fwapiErrorWrap(cause, message) {
     if (!cause) {
         return cause;
@@ -642,7 +623,6 @@ function fwapiErrorWrap(cause, message) {
     }
 }
 
-
 function papiErrorWrap(cause, message) {
     if (!cause) {
         return cause;
@@ -658,7 +638,6 @@ function papiErrorWrap(cause, message) {
     }
 }
 
-
 function imgapiErrorWrap(cause, message) {
     if (!cause) {
         return cause;
@@ -674,7 +653,6 @@ function imgapiErrorWrap(cause, message) {
     }
 }
 
-
 function napiErrorWrap(cause, message) {
     if (!cause) {
         return cause;
@@ -690,7 +668,6 @@ function napiErrorWrap(cause, message) {
     }
 }
 
-
 function ufdsErrorWrap(cause, message) {
     if (!cause) {
         return cause;
@@ -706,8 +683,6 @@ function ufdsErrorWrap(cause, message) {
     }
 }
 
-
-
 // ---- exports
 
 module.exports = {
@@ -730,8 +705,7 @@ module.exports = {
     ServiceDegradedError: ServiceDegradedError,
     DockerContainerNotRunningError: DockerContainerNotRunningError,
     AmbiguousDockerImageIdError: AmbiguousDockerImageIdError,
-    AmbiguousDockerContainerIdPrefixError:
-        AmbiguousDockerContainerIdPrefixError,
+    AmbiguousDockerContainerIdPrefixError: AmbiguousDockerContainerIdPrefixError,
     AmbiguousDockerNetworkIdPrefixError: AmbiguousDockerNetworkIdPrefixError,
     FileNotFoundError: FileNotFoundError,
     NetworkNotFoundError: NetworkNotFoundError,
diff --git a/lib/hijack.js b/lib/hijack.js
index 8bd5657..80f8004 100644
--- a/lib/hijack.js
+++ b/lib/hijack.js
@@ -12,7 +12,7 @@ var assert = require('assert-plus');
 var uv = process.binding('uv');
 
 var HIJACK_ROUTES = {
-    'POST': [
+    POST: [
         new RegExp('\/v[0-9\.]+\/exec\/[a-z0-9]+\/start'),
         new RegExp('\/v[0-9\.]+\/containers\/[a-z0-9]+\/attach')
     ]
@@ -30,7 +30,7 @@ function canHijack(req) {
     }
 
     // Should match only one route
-    var matches = hijackRoutes.filter(function (regex) {
+    var matches = hijackRoutes.filter(function(regex) {
         return regex.test(req.url);
     });
 
@@ -41,7 +41,6 @@ function canHijack(req) {
     return true;
 }
 
-
 /*
  * Node doesn't really support half-close connections with tls, but
  * docker insists upon them. We override the onread implementations for
@@ -62,7 +61,6 @@ function setHalfClose(log, req, socket) {
     }
 }
 
-
 module.exports = {
     canHijack: canHijack,
     setHalfClose: setHalfClose
diff --git a/lib/models/image-tag.js b/lib/models/image-tag.js
index 1ec59de..676a27b 100644
--- a/lib/models/image-tag.js
+++ b/lib/models/image-tag.js
@@ -23,8 +23,6 @@ var vasync = require('vasync');
 
 var moray = require('../moray');
 
-
-
 // --- Globals
 
 var BUCKET = {
@@ -33,15 +31,15 @@ var BUCKET = {
     schema: {
         index: {
             // The 64-char Docker image ID
-            docker_id: { type: 'string' },
-            owner_uuid: { type: 'string' },
+            docker_id: {type: 'string'},
+            owner_uuid: {type: 'string'},
             /*
              * The "localName" for the Docker repo. See
              * // JSSTYLED
              * <https://github.com/joyent/node-docker-registry-client/tree/master#names>
              */
-            repo: { type: 'string' },
-            tag: { type: 'string' },
+            repo: {type: 'string'},
+            tag: {type: 'string'},
             /*
              * Storing the index name (a.k.a. the registry host) is somewhat
              * redundant (the 'repo' effective has this information too), we
@@ -49,14 +47,12 @@ var BUCKET = {
              * search by `(img.owner_uuid, img.index_name, img.docker_id)`
              * to find all tags pointing to that image.
              */
-            index_name: { type: 'string' }
+            index_name: {type: 'string'}
         }
     },
     version: 5
 };
 
-
-
 // --- Helpers
 
 function objectKey(params) {
@@ -67,7 +63,6 @@ function objectKey(params) {
     return fmt('%s,%s,%s', params.owner_uuid, params.repo, params.tag);
 }
 
-
 // --- ImageTag object
 
 /**
@@ -83,33 +78,28 @@ function ImageTag(params) {
 
     this.params = params;
 
-    this.__defineGetter__('owner_uuid', function () {
+    this.__defineGetter__('owner_uuid', function() {
         return this.params.owner_uuid;
     });
-    this.__defineGetter__('index_name', function () {
+    this.__defineGetter__('index_name', function() {
         return this.params.index_name;
     });
-    this.__defineGetter__('repo', function () {
+    this.__defineGetter__('repo', function() {
         return this.params.repo;
     });
-    this.__defineGetter__('tag', function () {
+    this.__defineGetter__('tag', function() {
         return this.params.tag;
     });
-    this.__defineGetter__('docker_id', function () {
+    this.__defineGetter__('docker_id', function() {
         return this.params.docker_id;
     });
 }
 
-
 /**
  * Returns the raw form of the image tag suitable for storing in moray,
  * which is the same as the serialized form
  */
-ImageTag.prototype.toJSON =
-    ImageTag.prototype.raw =
-    ImageTag.prototype.serialize =
-    function ()
-{
+ImageTag.prototype.toJSON = ImageTag.prototype.raw = ImageTag.prototype.serialize = function() {
     return {
         owner_uuid: this.params.owner_uuid,
         index_name: this.params.index_name,
@@ -119,8 +109,6 @@ ImageTag.prototype.toJSON =
     };
 };
 
-
-
 // --- Exported functions
 
 /**
@@ -131,7 +119,7 @@ function createImageTag(app, log, params, callback) {
 
     var imgTag = new ImageTag(params);
     var key = objectKey(params);
-    app.moray.putObject(BUCKET.name, key, imgTag.raw(), function (err) {
+    app.moray.putObject(BUCKET.name, key, imgTag.raw(), function(err) {
         if (err) {
             return callback(err);
         }
@@ -139,7 +127,6 @@ function createImageTag(app, log, params, callback) {
     });
 }
 
-
 /**
  * Lists all image tags
  */
@@ -150,13 +137,16 @@ function listImageTags(app, log, params, callback) {
         params = '(docker_id=*)';
     }
 
-    moray.listObjs({
-        filter: params,
-        log: log,
-        bucket: BUCKET,
-        model: ImageTag,
-        moray: app.moray
-    }, callback);
+    moray.listObjs(
+        {
+            filter: params,
+            log: log,
+            bucket: BUCKET,
+            model: ImageTag,
+            moray: app.moray
+        },
+        callback
+    );
 }
 
 /**
@@ -168,7 +158,6 @@ function deleteImageTag(app, log, params, callback) {
     moray.delObj(app.moray, BUCKET, key, callback);
 }
 
-
 /**
  * Every funtion should just take care of replacing the column with a new
  * value, or just return if it doesn't apply. When an updated object needs
@@ -193,7 +182,6 @@ var migrations = [
     }
 ];
 
-
 /*
  * This migration will update all object keys from
  *   owner_uuid-docker_id to owner_uuid-docker_id-tag
@@ -218,18 +206,20 @@ function _migrateTagStringToArray(opts) {
     delete value['name']; // missed this in east3b
 
     // Add new object and delete old one
-    batch.push({
-        bucket: BUCKET.name,
-        key: newKey,
-        value: value
-    }, {
-        bucket: BUCKET.name,
-        operation: 'delete',
-        key: key
-    });
+    batch.push(
+        {
+            bucket: BUCKET.name,
+            key: newKey,
+            value: value
+        },
+        {
+            bucket: BUCKET.name,
+            operation: 'delete',
+            key: key
+        }
+    );
 }
 
-
 /*
  * This migration will update the `repo` column value to
  * be the localName value from parseRepo(). This migration
@@ -252,7 +242,6 @@ function _migrateRepoToLocalName(opts) {
     });
 }
 
-
 /*
  * This migration will update all object keys from:
  *
@@ -284,15 +273,18 @@ function _migrateKeyToIncludeRepo(opts) {
 
     // Add new object and delete old one.
     assert.ok(newKey !== key);
-    batch.push({
-        bucket: BUCKET.name,
-        key: newKey,
-        value: value
-    }, {
-        bucket: BUCKET.name,
-        operation: 'delete',
-        key: key
-    });
+    batch.push(
+        {
+            bucket: BUCKET.name,
+            key: newKey,
+            value: value
+        },
+        {
+            bucket: BUCKET.name,
+            operation: 'delete',
+            key: key
+        }
+    );
 }
 
 /*
@@ -316,7 +308,7 @@ function _migrateAddIndexName(opts) {
  * Initializes the image tags bucket
  */
 function initImageTagsBucket(app, callback) {
-    moray.initBucket(app.moray, BUCKET, function (err, updated, fromBucket) {
+    moray.initBucket(app.moray, BUCKET, function(err, updated, fromBucket) {
         if (err) {
             callback(err);
             return;
@@ -324,19 +316,21 @@ function initImageTagsBucket(app, callback) {
 
         // Run migrations when the bucket needed to be updated
         if (updated) {
-            moray.migrateObjects({
-                app: app,
-                bucket: BUCKET,
-                fromBucket: fromBucket,
-                migrations: migrations
-            }, callback);
+            moray.migrateObjects(
+                {
+                    app: app,
+                    bucket: BUCKET,
+                    fromBucket: fromBucket,
+                    migrations: migrations
+                },
+                callback
+            );
         } else {
             callback();
         }
     });
 }
 
-
 module.exports = {
     create: createImageTag,
     del: deleteImageTag,
diff --git a/lib/models/image.js b/lib/models/image.js
index b0dab77..8547559 100644
--- a/lib/models/image.js
+++ b/lib/models/image.js
@@ -22,8 +22,6 @@ var vasync = require('vasync');
 var ImageTag = require('./image-tag');
 var moray = require('../moray');
 
-
-
 // --- Globals
 
 var BUCKET = {
@@ -31,21 +29,19 @@ var BUCKET = {
     name: 'docker_images',
     schema: {
         index: {
-            docker_id: { type: 'string' },
-            head: { type: 'boolean' },
-            image_uuid: { type: 'string' },
-            index_name: { type: 'string' },
-            owner_uuid: { type: 'string' },
-            parent: { type: 'string' },
+            docker_id: {type: 'string'},
+            head: {type: 'boolean'},
+            image_uuid: {type: 'string'},
+            index_name: {type: 'string'},
+            owner_uuid: {type: 'string'},
+            parent: {type: 'string'},
             // The array of head docker_ids whose history includes this id.
-            heads: { type: '[string]' }
+            heads: {type: '[string]'}
         }
     },
     version: 4
 };
 
-
-
 // --- Helpers
 
 function objectKey(params) {
@@ -53,16 +49,16 @@ function objectKey(params) {
     assert.string(params.index_name, 'params.index_name');
     assert.string(params.docker_id, 'params.docker_id');
 
-    return format('%s-%s-%s',
+    return format(
+        '%s-%s-%s',
         params.owner_uuid,
         params.index_name,
-        params.docker_id);
+        params.docker_id
+    );
 }
 
-
 // --- Image object
 
-
 /**
  * Image model constructor
  */
@@ -84,8 +80,7 @@ function Image(params) {
     assert.optionalString(params.author, 'params.author');
 
     this.params = params;
-    if (!this.params.heads)
-        this.params.heads = [];
+    if (!this.params.heads) this.params.heads = [];
     if (this.params.architecture === undefined) {
         this.params.architecture = '';
     }
@@ -100,71 +95,66 @@ function Image(params) {
     }
 
     // Accessor for computing the moray object key
-    this.__defineGetter__('key', function () {
+    this.__defineGetter__('key', function() {
         return objectKey(this.params);
     });
 
-    this.__defineGetter__('author', function () {
+    this.__defineGetter__('author', function() {
         return this.params.author;
     });
-    this.__defineGetter__('architecture', function () {
+    this.__defineGetter__('architecture', function() {
         return this.params.architecture;
     });
-    this.__defineGetter__('comment', function () {
+    this.__defineGetter__('comment', function() {
         return this.params.comment;
     });
-    this.__defineGetter__('config', function () {
+    this.__defineGetter__('config', function() {
         // Warning: `config` can be null on base Docker images.
         return this.params.config;
     });
-    this.__defineGetter__('container_config', function () {
+    this.__defineGetter__('container_config', function() {
         return this.params.container_config;
     });
-    this.__defineGetter__('created', function () {
+    this.__defineGetter__('created', function() {
         return this.params.created;
     });
-    this.__defineGetter__('docker_id', function () {
+    this.__defineGetter__('docker_id', function() {
         return this.params.docker_id;
     });
-    this.__defineGetter__('head', function () {
+    this.__defineGetter__('head', function() {
         return this.params.head;
     });
-    this.__defineGetter__('heads', function () {
+    this.__defineGetter__('heads', function() {
         return this.params.heads;
     });
-    this.__defineGetter__('image_uuid', function () {
+    this.__defineGetter__('image_uuid', function() {
         return this.params.image_uuid;
     });
-    this.__defineGetter__('index_name', function () {
+    this.__defineGetter__('index_name', function() {
         return this.params.index_name;
     });
-    this.__defineGetter__('owner_uuid', function () {
+    this.__defineGetter__('owner_uuid', function() {
         return this.params.owner_uuid;
     });
-    this.__defineGetter__('parent', function () {
+    this.__defineGetter__('parent', function() {
         return this.params.parent;
     });
-    this.__defineGetter__('private', function () {
+    this.__defineGetter__('private', function() {
         return this.params.private;
     });
-    this.__defineGetter__('refcount', function () {
+    this.__defineGetter__('refcount', function() {
         return this.params.heads.length;
     });
-    this.__defineGetter__('size', function () {
+    this.__defineGetter__('size', function() {
         return this.params.size;
     });
 }
 
-
 /**
  * Returns the raw form of the image suitable for storing in moray,
  * which is the same as the serialized form
  */
-Image.prototype.toJSON =
-    Image.prototype.raw =
-    Image.prototype.serialize =
-    function ()
-{
+Image.prototype.toJSON = Image.prototype.raw = Image.prototype.serialize = function() {
     return {
         author: this.params.author,
         architecture: this.params.architecture,
@@ -185,13 +175,12 @@ Image.prototype.toJSON =
     };
 };
 
-
 Image.prototype.toHistoryItem = function toHistoryItem() {
     var createdBy = '';
     if (this.container_config && this.container_config.Cmd) {
         createdBy = this.container_config.Cmd.join(' ');
     }
-    var created = Math.floor((new Date(this.created)).getTime() / 1000);
+    var created = Math.floor(new Date(this.created).getTime() / 1000);
     return {
         Id: this.docker_id,
         Created: created,
@@ -200,18 +189,16 @@ Image.prototype.toHistoryItem = function toHistoryItem() {
     };
 };
 
-
-
 // --- Exported functions
 
 /**
  * Creates a image
  */
 function createImage(app, log, params, callback) {
-    log.debug({ params: params }, 'createImage: entry');
+    log.debug({params: params}, 'createImage: entry');
 
     var image = new Image(params);
-    app.moray.putObject(BUCKET.name, image.key, image.raw(), function (err) {
+    app.moray.putObject(BUCKET.name, image.key, image.raw(), function(err) {
         if (err) {
             return callback(err);
         }
@@ -220,7 +207,6 @@ function createImage(app, log, params, callback) {
     });
 }
 
-
 /**
  * Lists all images
  */
@@ -231,37 +217,41 @@ function listImages(app, log, params, callback) {
         params = '(docker_id=*)';
     }
 
-    moray.listObjs({
-        filter: params,
-        log: log,
-        bucket: BUCKET,
-        model: Image,
-        moray: app.moray
-    }, callback);
+    moray.listObjs(
+        {
+            filter: params,
+            log: log,
+            bucket: BUCKET,
+            model: Image,
+            moray: app.moray
+        },
+        callback
+    );
 }
 
-
 /**
  * Updates an image
  */
 function updateImage(app, log, params, callback) {
     log.debug({params: params}, 'updateImage: entry');
     var key = objectKey(params);
-    moray.updateObj({
-        moray: app.moray,
-        bucket: BUCKET,
-        key: key,
-        val: params
-    }, function (err, rec) {
-        if (err) {
-            return callback(err);
+    moray.updateObj(
+        {
+            moray: app.moray,
+            bucket: BUCKET,
+            key: key,
+            val: params
+        },
+        function(err, rec) {
+            if (err) {
+                return callback(err);
+            }
+
+            return callback(null, new Image(rec.value));
         }
-
-        return callback(null, new Image(rec.value));
-    });
+    );
 }
 
-
 /**
  * Deletes an image
  */
@@ -271,7 +261,6 @@ function deleteImage(app, log, params, callback) {
     moray.delObj(app.moray, BUCKET, key, callback);
 }
 
-
 /**
  * Gets the datacenter refcount for each layer in the ancestry of the given
  * docker_id and index_name. When the refcount is 1, it means "we" are
@@ -313,15 +302,18 @@ function datacenterRefcount(app, log, params, callback) {
     var client = app.moray;
 
     var query = format(
-        'select docker_id, count(docker_id) from %s '
-            + 'where docker_id in ('
-                + 'select docker_id from %s '
-                + 'where \'%s\'=any(heads) '
-                + 'and index_name=\'%s\''
-            + ') '
-            + 'and index_name=\'%s\' '
-            + 'group by docker_id',
-        BUCKET.name, BUCKET.name, params.docker_id, params.index_name,
+        'select docker_id, count(docker_id) from %s ' +
+            'where docker_id in (' +
+            'select docker_id from %s ' +
+            "where '%s'=any(heads) " +
+            "and index_name='%s'" +
+            ') ' +
+            "and index_name='%s' " +
+            'group by docker_id',
+        BUCKET.name,
+        BUCKET.name,
+        params.docker_id,
+        params.index_name,
         params.index_name
     );
     if (params.limit) {
@@ -332,22 +324,28 @@ function datacenterRefcount(app, log, params, callback) {
     var req = client.sql(query);
     var oncecb = once(callback);
 
-    req.on('record', function (rec) {
+    req.on('record', function(rec) {
         count[rec.docker_id] = Number(rec.count);
     });
 
-    req.on('error', function (err) {
+    req.on('error', function(err) {
         oncecb(err);
     });
 
-    req.on('end', function () {
-        log.debug({docker_id: params.docker_id, index_name: params.index_name,
-            limit: params.limit, count: count}, 'datacenterRefcount');
+    req.on('end', function() {
+        log.debug(
+            {
+                docker_id: params.docker_id,
+                index_name: params.index_name,
+                limit: params.limit,
+                count: count
+            },
+            'datacenterRefcount'
+        );
         oncecb(null, count);
     });
 }
 
-
 /**
  * Returns the number of docker image layers owned by the given owner uuid.
  */
@@ -356,8 +354,9 @@ function imageCount(app, log, params, callback) {
     assert.string(params.owner_uuid, 'params.owner_uuid');
 
     var query = format(
-        'select count(*) from %s where owner_uuid = \'%s\'',
-        BUCKET.name, params.owner_uuid
+        "select count(*) from %s where owner_uuid = '%s'",
+        BUCKET.name,
+        params.owner_uuid
     );
 
     var client = app.moray;
@@ -365,21 +364,20 @@ function imageCount(app, log, params, callback) {
     var req = client.sql(query);
     var oncecb = once(callback);
 
-    req.on('record', function (rec) {
+    req.on('record', function(rec) {
         count = Number(rec.count);
     });
 
-    req.on('error', function (err) {
+    req.on('error', function(err) {
         oncecb(err);
     });
 
-    req.on('end', function () {
+    req.on('end', function() {
         log.debug({owner_uuid: params.owner_uuid, count: count}, 'imageCount');
         oncecb(null, count);
     });
 }
 
-
 /**
  * Every funtion should just take care of replacing the column with a new
  * value, or just return if it doesn't apply. When an updated object needs
@@ -400,7 +398,6 @@ var migrations = [
     }
 ];
 
-
 /*
  * This migration will populate the index_name column values. We cheat here
  * knowing that before this migration the only index_name from which
@@ -425,7 +422,6 @@ function _addIndexName(opts) {
     });
 }
 
-
 /*
  * This migration will update the image_uuid values on every docker_image
  *   with a new UUID computed from docker_id and index_name
@@ -450,7 +446,6 @@ function _updateImageUuids(opts) {
     });
 }
 
-
 /*
  * This migration will update all object keys from
  *   owner_uuid-docker_id to owner_uuid-index_name-docker_id
@@ -468,27 +463,33 @@ function _updateKeysPrivateRegistries(opts) {
     }
 
     // TODO Image.prototype.key
-    var newKey = format('%s-%s-%s', value.owner_uuid,
-        value.index_name, value.docker_id);
+    var newKey = format(
+        '%s-%s-%s',
+        value.owner_uuid,
+        value.index_name,
+        value.docker_id
+    );
 
     // Add new object and delete old one
-    batch.push({
-        bucket: BUCKET.name,
-        key: newKey,
-        value: value
-    }, {
-        bucket: BUCKET.name,
-        operation: 'delete',
-        key: key
-    });
+    batch.push(
+        {
+            bucket: BUCKET.name,
+            key: newKey,
+            value: value
+        },
+        {
+            bucket: BUCKET.name,
+            operation: 'delete',
+            key: key
+        }
+    );
 }
 
-
 /**
  * Initializes the images bucket
  */
 function initImagesBucket(app, callback) {
-    moray.initBucket(app.moray, BUCKET, function (err, updated, fromBucket) {
+    moray.initBucket(app.moray, BUCKET, function(err, updated, fromBucket) {
         if (err) {
             callback(err);
             return;
@@ -496,19 +497,21 @@ function initImagesBucket(app, callback) {
 
         // Run migrations when the bucket needed to be updated
         if (updated) {
-            moray.migrateObjects({
-                app: app,
-                bucket: BUCKET,
-                fromBucket: fromBucket,
-                migrations: migrations
-            }, callback);
+            moray.migrateObjects(
+                {
+                    app: app,
+                    bucket: BUCKET,
+                    fromBucket: fromBucket,
+                    migrations: migrations
+                },
+                callback
+            );
         } else {
             callback();
         }
     });
 }
 
-
 module.exports = {
     create: createImage,
     del: deleteImage,
diff --git a/lib/models/index.js b/lib/models/index.js
index a77e086..46bf39c 100644
--- a/lib/models/index.js
+++ b/lib/models/index.js
@@ -17,29 +17,23 @@ var image_tag = require('./image-tag');
 var link = require('./link');
 var vasync = require('vasync');
 
-
-
 // --- Exports
 
-
-
 /**
  * Initialize models
  */
 function initializeModels(app, callback) {
-    vasync.forEachParallel({
-        inputs: [
-            image,
-            image_tag,
-            link
-        ],
-        func: function _initModel(mod, cb) {
-            mod.init(app, cb);
-        }
-    }, callback);
+    vasync.forEachParallel(
+        {
+            inputs: [image, image_tag, link],
+            func: function _initModel(mod, cb) {
+                mod.init(app, cb);
+            }
+        },
+        callback
+    );
 }
 
-
 module.exports = {
     init: initializeModels
 };
diff --git a/lib/models/link.js b/lib/models/link.js
index 343692e..7d962a7 100644
--- a/lib/models/link.js
+++ b/lib/models/link.js
@@ -15,39 +15,32 @@
 var assert = require('assert-plus');
 var moray = require('../moray');
 
-
 // --- Globals
 
-
-
 var BUCKET = {
     desc: 'docker links',
     name: 'docker_links',
     schema: {
         index: {
             // Owning user
-            owner_uuid: { type: 'string' },
+            owner_uuid: {type: 'string'},
             // The container who will use the link.
-            container_uuid: { type: 'string' },
-            container_name: { type: 'string' },
+            container_uuid: {type: 'string'},
+            container_name: {type: 'string'},
             // The target container name the link is pointed at.
-            target_uuid: { type: 'string' },
-            target_name: { type: 'string' },
+            target_uuid: {type: 'string'},
+            target_name: {type: 'string'},
             // The alias name to use in the container.
-            alias: { type: 'string' }
+            alias: {type: 'string'}
         }
     },
     version: 1
 };
 
-
-
 // --- Helpers
 
-
 // --- Link object
 
-
 /**
  * Link model constructor
  */
@@ -125,17 +118,22 @@ Object.defineProperty(Link.prototype, 'ps_config', {
 
 Object.defineProperty(Link.prototype, 'inspect_config', {
     get: function inspect_config() {
-        return '/' + this.target_name + ':/'
-                + this.container_name + '/' + this.alias;
+        return (
+            '/' +
+            this.target_name +
+            ':/' +
+            this.container_name +
+            '/' +
+            this.alias
+        );
     }
 });
 
-
 /**
  * Returns the raw form of the link suitable for storing in moray,
  * which is the same as the serialized form
  */
-Link.prototype.raw = Link.prototype.serialize = function () {
+Link.prototype.raw = Link.prototype.serialize = function() {
     return {
         owner_uuid: this.params.owner_uuid,
         container_uuid: this.params.container_uuid,
@@ -146,16 +144,12 @@ Link.prototype.raw = Link.prototype.serialize = function () {
     };
 };
 
-Link.prototype.save = function (app, callback) {
+Link.prototype.save = function(app, callback) {
     app.moray.putObject(BUCKET.name, this.key, this.raw(), callback);
 };
 
-
-
 // --- Exported functions
 
-
-
 /**
  * Creates one link.
  *
@@ -182,10 +176,10 @@ function createLink(app, log, params, callback) {
     assert.string(params.target_name, 'params.target_name');
     assert.string(params.alias, 'params.alias');
 
-    log.debug({ params: params }, 'createLink: entry');
+    log.debug({params: params}, 'createLink: entry');
 
     var link = new Link(params);
-    app.moray.putObject(BUCKET.name, link.key, link.raw(), function (err) {
+    app.moray.putObject(BUCKET.name, link.key, link.raw(), function(err) {
         if (err) {
             return callback(err);
         }
@@ -194,7 +188,6 @@ function createLink(app, log, params, callback) {
     });
 }
 
-
 /**
  * Find all links for given owner_uuid and optional (target_uuid,
  * container_uuid, alias) search criteria.
@@ -220,16 +213,18 @@ function findLinks(app, log, params, callback) {
 
     log.trace(params, 'findLinks: entry');
 
-    moray.listObjs({
-        filter: params,
-        log: log,
-        bucket: BUCKET,
-        model: Link,
-        moray: app.moray
-    }, callback);
+    moray.listObjs(
+        {
+            filter: params,
+            log: log,
+            bucket: BUCKET,
+            model: Link,
+            moray: app.moray
+        },
+        callback
+    );
 }
 
-
 /**
  * Deletes one link.
  *
@@ -253,12 +248,11 @@ function deleteLink(app, log, params, callback) {
 
     log.debug(params, 'deleteLink: entry');
 
-    var lkey = params.owner_uuid + '-' + params.container_uuid + '-'
-                + params.alias;
+    var lkey =
+        params.owner_uuid + '-' + params.container_uuid + '-' + params.alias;
     moray.delObj(app.moray, BUCKET, lkey, callback);
 }
 
-
 /**
  * Initializes the links bucket
  */
@@ -266,7 +260,6 @@ function initLinksBucket(app, callback) {
     moray.initBucket(app.moray, BUCKET, callback);
 }
 
-
 module.exports = {
     create: createLink,
     del: deleteLink,
diff --git a/lib/moray.js b/lib/moray.js
index bcfaade..ef33b7c 100644
--- a/lib/moray.js
+++ b/lib/moray.js
@@ -20,14 +20,13 @@ var verror = require('verror');
 var VError = verror.VError;
 var vasync = require('vasync');
 
-
 // --- Helpers
 
 /**
  * Turn a value into an array, unless it is one already.
  */
 function arrayify(obj) {
-    if (typeof (obj) === 'object') {
+    if (typeof obj === 'object') {
         return obj;
     }
 
@@ -38,7 +37,6 @@ function arrayify(obj) {
     return obj.split(',');
 }
 
-
 /**
  * Returns true if the hash is empty
  */
@@ -52,11 +50,8 @@ function hashEmpty(hash) {
     return true;
 }
 
-
 // --- Exports
 
-
-
 /**
  * Creates an LDAP filter based on the parmeters in inObj, only allowing
  * searching by indexes in bucket.schema.index
@@ -69,7 +64,7 @@ function ldapFilter(inObj, bucket) {
         return '';
     }
 
-    if (typeof (inObj) === 'string') {
+    if (typeof inObj === 'string') {
         return inObj;
     }
 
@@ -84,7 +79,7 @@ function ldapFilter(inObj, bucket) {
     var filterBy = [];
     if (Array.isArray(inObj)) {
         filterBy.push('(|');
-        inObj.forEach(function (_inObj) {
+        inObj.forEach(function(_inObj) {
             filterBy.push(ldapFilter(_inObj, bucket));
         });
         filterBy.push(')');
@@ -92,7 +87,6 @@ function ldapFilter(inObj, bucket) {
     }
 
     filterBy = Object.keys(inObj).reduce(function reduce(arr, i) {
-
         if (bucket && !bucket.schema.index.hasOwnProperty(i)) {
             // XXX: should error out here if trying to search by a non-indexed
             // property
@@ -100,28 +94,28 @@ function ldapFilter(inObj, bucket) {
         }
 
         // Comma-separated values: turn them into a list
-        if (typeof (inObj[i]) === 'string' && inObj[i].indexOf(',') !== -1) {
+        if (typeof inObj[i] === 'string' && inObj[i].indexOf(',') !== -1) {
             /* JSSTYLED */
             inObj[i] = inObj[i].split(/\s*,\s*/);
         }
 
-        if (typeof (inObj[i]) === 'object') {
+        if (typeof inObj[i] === 'object') {
             arr.push('(|');
             for (var j in inObj[i]) {
-                if (typeof (inObj[i][j]) === 'number') {
+                if (typeof inObj[i][j] === 'number') {
                     arr.push(util.format('(%s=%d)', i, inObj[i][j]));
                 } else {
                     // XXX: allow this outside of arrays?
                     if (inObj[i][j].substr(0, 1) === '!') {
-                        arr.push(util.format('(!(%s=%s))', i,
-                            inObj[i][j].substr(1)));
+                        arr.push(
+                            util.format('(!(%s=%s))', i, inObj[i][j].substr(1))
+                        );
                     } else {
                         arr.push(util.format('(%s=%s)', i, inObj[i][j]));
                     }
                 }
             }
             arr.push(')');
-
         } else {
             arr.push(util.format('(%s=%s)', i, inObj[i]));
         }
@@ -137,7 +131,6 @@ function ldapFilter(inObj, bucket) {
     return filterBy.join('');
 }
 
-
 /**
  * Initializes a bucket in moray
  *
@@ -153,68 +146,100 @@ function initBucket(moray, bucket, callback) {
     assert.object(bucket.schema, 'bucket.schema');
     assert.number(bucket.version, 'bucket.version');
 
-    moray.getBucket(bucket.name, function (err, oldBucket) {
+    moray.getBucket(bucket.name, function(err, oldBucket) {
         if (err) {
             if (VError.hasCauseWithName(err, 'BucketNotFoundError')) {
-                moray.log.info(bucket.schema, 'initBucket: creating bucket %s',
-                    bucket.name);
-                return moray.createBucket(bucket.name, bucket.schema,
-                    function (err2, res) {
-                        if (err2) {
-                            moray.log.error(err2,
-                                'initBucket: error creating bucket %s',
-                                bucket.name);
-                        } else {
-                            moray.log.info(bucket.schema,
-                                'initBucket: successfully created bucket %s',
-                                bucket.name);
-                        }
-
-                        return callback(err2, res);
+                moray.log.info(
+                    bucket.schema,
+                    'initBucket: creating bucket %s',
+                    bucket.name
+                );
+                return moray.createBucket(bucket.name, bucket.schema, function(
+                    err2,
+                    res
+                ) {
+                    if (err2) {
+                        moray.log.error(
+                            err2,
+                            'initBucket: error creating bucket %s',
+                            bucket.name
+                        );
+                    } else {
+                        moray.log.info(
+                            bucket.schema,
+                            'initBucket: successfully created bucket %s',
+                            bucket.name
+                        );
+                    }
+
+                    return callback(err2, res);
                 });
             }
 
-            moray.log.error(err, 'initBucket: error getting bucket %s',
-                bucket.name);
+            moray.log.error(
+                err,
+                'initBucket: error getting bucket %s',
+                bucket.name
+            );
             return callback(err);
         }
 
         var prevVersion = oldBucket.options.version;
         if (prevVersion >= bucket.version) {
-            moray.log.info({ bucketName: bucket.name, schema: bucket.schema,
-                oldVersion: prevVersion, version: bucket.version },
-                'initBucket: bucket version '
-                + 'already up to date: not updating');
+            moray.log.info(
+                {
+                    bucketName: bucket.name,
+                    schema: bucket.schema,
+                    oldVersion: prevVersion,
+                    version: bucket.version
+                },
+                'initBucket: bucket version ' +
+                    'already up to date: not updating'
+            );
             return callback(null, false, oldBucket);
         }
 
-        moray.log.info('initBucket: bucket %s needs to be updated',
-            bucket.name);
-        bucket.schema.options = { version: bucket.version };
-
-        moray.updateBucket(bucket.name, bucket.schema, { noCache: true },
-        function (err3) {
-            if (err3) {
-                moray.log.error(err3, 'Error updating bucket %s', bucket.name);
-                return callback(err3);
-            }
-
-            reindexBucket(moray, bucket, function (idxErr) {
-                if (idxErr) {
-                    moray.log.error(idxErr, 'Error reindexing bucket %s',
-                        bucket.name);
-                    return callback(idxErr);
+        moray.log.info(
+            'initBucket: bucket %s needs to be updated',
+            bucket.name
+        );
+        bucket.schema.options = {version: bucket.version};
+
+        moray.updateBucket(
+            bucket.name,
+            bucket.schema,
+            {noCache: true},
+            function(err3) {
+                if (err3) {
+                    moray.log.error(
+                        err3,
+                        'Error updating bucket %s',
+                        bucket.name
+                    );
+                    return callback(err3);
                 }
 
-                moray.log.info('initBucket: successfully reindexed %s bucket',
-                    bucket.name);
-                return callback(null, true, oldBucket);
-            });
-        });
+                reindexBucket(moray, bucket, function(idxErr) {
+                    if (idxErr) {
+                        moray.log.error(
+                            idxErr,
+                            'Error reindexing bucket %s',
+                            bucket.name
+                        );
+                        return callback(idxErr);
+                    }
+
+                    moray.log.info(
+                        'initBucket: successfully reindexed %s bucket',
+                        bucket.name
+                    );
+                    return callback(null, true, oldBucket);
+                });
+            }
+        );
     });
 }
 
-
 /**
  * Reindexes all objects in the bucket if it has been updated
  *
@@ -234,23 +259,28 @@ function reindexBucket(moray, bucket, callback) {
     var processed = rowsPerCall;
 
     async.whilst(
-        function () { return processed > 0; },
-        function (cb) {
-            moray.reindexObjects(bucket.name, rowsPerCall, { noCache: true },
-            function (err, res) {
-                if (err) {
-                    return cb(err);
-                }
+        function() {
+            return processed > 0;
+        },
+        function(cb) {
+            moray.reindexObjects(
+                bucket.name,
+                rowsPerCall,
+                {noCache: true},
+                function(err, res) {
+                    if (err) {
+                        return cb(err);
+                    }
 
-                processed = res.processed;
-                cb();
-            });
+                    processed = res.processed;
+                    cb();
+                }
+            );
         },
         callback
     );
 }
 
-
 /**
  * Deletes an object from moray
  *
@@ -260,17 +290,21 @@ function reindexBucket(moray, bucket, callback) {
  * @param callback {Function} `function (err, netObj)`
  */
 function delObj(moray, bucket, key, callback) {
-    moray.delObject(bucket.name, key, function (err) {
+    moray.delObject(bucket.name, key, function(err) {
         if (err && VError.hasCauseWithName(err, 'ObjectNotFoundError')) {
-            return callback(new restify.ResourceNotFoundError(err,
-                '%s not found', bucket.desc));
+            return callback(
+                new restify.ResourceNotFoundError(
+                    err,
+                    '%s not found',
+                    bucket.desc
+                )
+            );
         }
 
         return callback(err);
     });
 }
 
-
 /**
  * Gets an object from moray
  *
@@ -280,11 +314,16 @@ function delObj(moray, bucket, key, callback) {
  * @param callback {Function} `function (err, netObj)`
  */
 function getObj(moray, bucket, key, callback) {
-    moray.getObject(bucket.name, key, function (err, res) {
+    moray.getObject(bucket.name, key, function(err, res) {
         if (err) {
             if (VError.hasCauseWithName(err, 'ObjectNotFoundError')) {
-                return callback(new restify.ResourceNotFoundError(err,
-                    '%s not found', bucket.desc));
+                return callback(
+                    new restify.ResourceNotFoundError(
+                        err,
+                        '%s not found',
+                        bucket.desc
+                    )
+                );
             }
 
             return callback(err);
@@ -294,7 +333,6 @@ function getObj(moray, bucket, key, callback) {
     });
 }
 
-
 /**
  * Lists objects in moray
  *
@@ -317,10 +355,9 @@ function listObjs(opts, callback) {
     }
 
     var filter = ldapFilter(opts.filter, opts.bucket) || opts.defaultFilter;
-    opts.log.trace({ params: opts.filter, filter: filter }, 'LDAP filter');
+    opts.log.trace({params: opts.filter, filter: filter}, 'LDAP filter');
 
-    var req = opts.moray.findObjects(opts.bucket.name,
-        filter, listOpts);
+    var req = opts.moray.findObjects(opts.bucket.name, filter, listOpts);
 
     req.on('error', function _onListErr(err) {
         return callback(err);
@@ -336,7 +373,6 @@ function listObjs(opts, callback) {
     });
 }
 
-
 /**
  * Updates an object in moray
  *
@@ -352,18 +388,22 @@ function listObjs(opts, callback) {
 function updateObj(opts, callback) {
     // XXX: should assert opts.* here
     if (opts.replace) {
-        return opts.moray.putObject(opts.bucket.name, opts.key, opts.val,
-            function (err2) {
-            if (err2) {
-                return callback(err2);
-            }
+        return opts.moray.putObject(
+            opts.bucket.name,
+            opts.key,
+            opts.val,
+            function(err2) {
+                if (err2) {
+                    return callback(err2);
+                }
 
-            // Return an object in similar form to getObject()
-            return callback(null, { value: opts.val });
-        });
+                // Return an object in similar form to getObject()
+                return callback(null, {value: opts.val});
+            }
+        );
     }
 
-    getObj(opts.moray, opts.bucket, opts.key, function (err, res) {
+    getObj(opts.moray, opts.bucket, opts.key, function(err, res) {
         if (err) {
             return callback(err);
         }
@@ -376,8 +416,9 @@ function updateObj(opts, callback) {
             }
         }
 
-        opts.moray.putObject(opts.bucket.name, opts.key, res.value,
-            function (err2) {
+        opts.moray.putObject(opts.bucket.name, opts.key, res.value, function(
+            err2
+        ) {
             if (err2) {
                 return callback(err2);
             }
@@ -387,7 +428,6 @@ function updateObj(opts, callback) {
     });
 }
 
-
 /**
  * Converts an array to a scalar value suitable for indexed fields in
  * moray, since array types can't be indexed on properly.
@@ -396,7 +436,6 @@ function arrayToVal(arr) {
     return ',' + arr.join(',') + ',';
 }
 
-
 /**
  * Converts an moray indexed array value as returned by arraytoVal() to a
  * real array object.
@@ -406,7 +445,7 @@ function valToArray(params, key) {
         return;
     }
 
-    if (typeof (params[key]) === 'object') {
+    if (typeof params[key] === 'object') {
         return;
     }
 
@@ -418,7 +457,6 @@ function valToArray(params, key) {
     params[key] = arrayify(params[key].replace(/^,/, '').replace(/,$/, ''));
 }
 
-
 /*
  * Migration function to update rows in a bucket
  */
@@ -434,35 +472,43 @@ function migrateObjects(opts, callback) {
     var log = app.log;
     var migrations = opts.migrations;
 
-    vasync.forEachPipeline({
-        func: migrateVersion,
-        inputs: migrations
-    }, function (err) {
-        if (err) {
-            log.error(err, 'Could not migrate bucket %s', bucket.name);
-            callback(err);
-            return;
-        }
+    vasync.forEachPipeline(
+        {
+            func: migrateVersion,
+            inputs: migrations
+        },
+        function(err) {
+            if (err) {
+                log.error(err, 'Could not migrate bucket %s', bucket.name);
+                callback(err);
+                return;
+            }
 
-        callback();
-    });
+            callback();
+        }
+    );
 
     function migrateVersion(migration, cb) {
         var fromVersion = opts.fromBucket.options.version;
         var toVersion = migration.version;
 
         if (fromVersion >= toVersion) {
-            log.info('Migration %s (version: %s) for bucket %s does not '
-                + 'need to run. Current bucket version is (version: %s)',
-                migration.fn.name, toVersion, bucket.name, fromVersion);
+            log.info(
+                'Migration %s (version: %s) for bucket %s does not ' +
+                    'need to run. Current bucket version is (version: %s)',
+                migration.fn.name,
+                toVersion,
+                bucket.name,
+                fromVersion
+            );
             cb();
             return;
         }
 
-        if (migration.pre && typeof (migration.pre) === 'function') {
+        if (migration.pre && typeof migration.pre === 'function') {
             // What context should be passed to pre functions?
-            var preOpts = { app: app, migration: migration };
-            migration.pre.call(null, preOpts, function (err, context) {
+            var preOpts = {app: app, migration: migration};
+            migration.pre.call(null, preOpts, function(err, context) {
                 if (err) {
                     cb(err);
                     return;
@@ -480,11 +526,11 @@ function migrateObjects(opts, callback) {
         var batch = [];
         var req = app.moray.sql('select * from ' + bucket.name);
 
-        req.once('error', function (err) {
+        req.once('error', function(err) {
             cb(err);
         });
 
-        req.on('record', function (obj) {
+        req.on('record', function(obj) {
             var key = obj._key;
             var value = JSON.parse(obj._value);
             fn.call(null, {
@@ -496,25 +542,30 @@ function migrateObjects(opts, callback) {
             });
         });
 
-        req.on('end', function () {
-            app.moray.batch(batch, function (bErr) {
+        req.on('end', function() {
+            app.moray.batch(batch, function(bErr) {
                 if (bErr) {
-                    log.error(bErr, 'Migration function %s failed for '
-                        + 'bucket %s', fn.name, bucket.name);
+                    log.error(
+                        bErr,
+                        'Migration function %s failed for ' + 'bucket %s',
+                        fn.name,
+                        bucket.name
+                    );
                     cb(bErr);
                     return;
                 }
 
-                log.info('Migration function %s succeeded for '
-                        + 'bucket %s', fn.name, bucket.name);
+                log.info(
+                    'Migration function %s succeeded for ' + 'bucket %s',
+                    fn.name,
+                    bucket.name
+                );
                 cb();
             });
         });
     }
 }
 
-
-
 module.exports = {
     arrayToVal: arrayToVal,
     delObj: delObj,
diff --git a/lib/socket-manager.js b/lib/socket-manager.js
index 8ac4205..d29baa4 100644
--- a/lib/socket-manager.js
+++ b/lib/socket-manager.js
@@ -16,9 +16,9 @@
 var assert = require('assert-plus');
 
 var SOCKET_TYPES = {
-    'attach': true,
-    'exec': true,
-    'job': true
+    attach: true,
+    exec: true,
+    job: true
 };
 
 /*
@@ -55,8 +55,7 @@ function SocketManager(opts) {
     this.resizes = {};
 }
 
-
-SocketManager.prototype.setSocket = function (type, id, data) {
+SocketManager.prototype.setSocket = function(type, id, data) {
     assert.ok(SOCKET_TYPES[type], 'socket type');
     assert.string(id, 'socket identifier');
     assert.object(data, 'socket data');
@@ -65,24 +64,21 @@ SocketManager.prototype.setSocket = function (type, id, data) {
     return data;
 };
 
-
-SocketManager.prototype.getSocket = function (type, id) {
+SocketManager.prototype.getSocket = function(type, id) {
     assert.ok(SOCKET_TYPES[type], 'socket type');
     assert.string(id, 'socket identifier');
 
     return this.sockets[type][id];
 };
 
-
-SocketManager.prototype.removeSocket = function (type, id) {
+SocketManager.prototype.removeSocket = function(type, id) {
     assert.ok(SOCKET_TYPES[type], 'socket type');
     assert.string(id, 'socket identifier');
 
     delete this.sockets[type][id];
 };
 
-
-SocketManager.prototype.pushResize = function (id, resize) {
+SocketManager.prototype.pushResize = function(id, resize) {
     assert.string(id, 'socket identifier');
     assert.object(resize, 'resize object');
     assert.number(resize.w, 'resize columns');
@@ -92,8 +88,7 @@ SocketManager.prototype.pushResize = function (id, resize) {
     return resize;
 };
 
-
-SocketManager.prototype.popResize = function (id) {
+SocketManager.prototype.popResize = function(id) {
     assert.string(id, 'socket identifier');
 
     var resize = this.resizes[id];
@@ -101,5 +96,4 @@ SocketManager.prototype.popResize = function (id) {
     return resize;
 };
 
-
 module.exports = SocketManager;
diff --git a/lib/validate.js b/lib/validate.js
index 396c76b..779b326 100644
--- a/lib/validate.js
+++ b/lib/validate.js
@@ -25,15 +25,12 @@ var fmt = require('util').format;
  */
 var MAX_LOG_CONFIG_LEN = 1024;
 
-
 // --- Internal
 
-
 function typeErr(name, type) {
     return new errors.ValidationError(fmt('"%s" must be %s', name, type));
 }
 
-
 function undef(arg) {
     if (arg === null || arg === undefined) {
         return true;
@@ -42,14 +39,12 @@ function undef(arg) {
     return false;
 }
 
-
 function assertObject(arg, name) {
-    if (typeof (arg) !== 'object' || Array.isArray(arg)) {
+    if (typeof arg !== 'object' || Array.isArray(arg)) {
         throw typeErr(name, 'an object');
     }
 }
 
-
 function assertOptionalArrayOfString(arg, name) {
     if (undef(arg)) {
         return;
@@ -61,24 +56,22 @@ function assertOptionalArrayOfString(arg, name) {
     }
 
     for (var e in arg) {
-        if (typeof (arg[e]) !== 'string') {
+        if (typeof arg[e] !== 'string') {
             throw typeErr(name, type);
         }
     }
 }
 
-
 function assertOptionalBool(arg, name) {
     if (undef(arg)) {
         return;
     }
 
-    if (typeof (arg) !== 'boolean') {
+    if (typeof arg !== 'boolean') {
         throw typeErr(name, 'a boolean');
     }
 }
 
-
 function assertOptionalObject(arg, name) {
     if (undef(arg)) {
         return;
@@ -87,7 +80,6 @@ function assertOptionalObject(arg, name) {
     assertObject(arg, name);
 }
 
-
 function assertOptionalString(arg, name) {
     if (undef(arg)) {
         return;
@@ -96,7 +88,6 @@ function assertOptionalString(arg, name) {
     assertString(arg, name);
 }
 
-
 /* Ensures <value> exists in <array> */
 function assertArrayValue(array, value, name, help) {
     if (array.indexOf(value) === -1) {
@@ -108,21 +99,18 @@ function assertArrayValue(array, value, name, help) {
     }
 }
 
-
 function assertPositiveInteger(arg, name) {
     if (!arg.match(/^[0-9]+$/) || Number(arg) < 1) {
         throw typeErr(name, 'a positive integer');
     }
 }
 
-
 function assertPositiveIntegerSize(arg, name) {
     if (!arg.match(/^[0-9]+[kmg]$/) || Number(arg.slice(0, -1)) < 1) {
         throw typeErr(name, 'a positive integer size ([0-9+][k|m|g])');
     }
 }
 
-
 function validHost(arg) {
     /*
      * host must be [a-z0-9\-\.] and not:
@@ -131,24 +119,27 @@ function validHost(arg) {
      *  * end with '-' or '.'
      *  * contain two of '-' or '.' in a row
      */
-    if (!arg.match(/^[a-z0-9\-\.]+$/)
-        || arg.match(/^[\.\-]/)
-        || arg.match(/[.\-]$/)
-        || arg.match(/[.\-][.\-]/)) {
-
+    if (
+        !arg.match(/^[a-z0-9\-\.]+$/) ||
+        arg.match(/^[\.\-]/) ||
+        arg.match(/[.\-]$/) ||
+        arg.match(/[.\-][.\-]/)
+    ) {
         return false;
     }
 
     return true;
 }
 
-
 function assertSyslogAddress(arg, name) {
     var split = arg.split(':');
 
     function _throwInvalidSyslogAddress(extra) {
-        throw typeErr(name, 'a syslog address "<udp|tcp>://<host>[:port]"'
-            + (extra ? ' (' + extra + ')' : ''));
+        throw typeErr(
+            name,
+            'a syslog address "<udp|tcp>://<host>[:port]"' +
+                (extra ? ' (' + extra + ')' : '')
+        );
     }
 
     if (split.length < 2 || split.length > 3) {
@@ -174,13 +165,15 @@ function assertSyslogAddress(arg, name) {
     }
 }
 
-
 function assertFluentdAddress(arg, name) {
     var split = arg.split(':');
 
     function throwInvalidFluentdAddress(extra) {
-        throw typeErr(name, 'a fluentd address "<host>:<port>"'
-            + (extra ? ' (' + extra + ')' : ''));
+        throw typeErr(
+            name,
+            'a fluentd address "<host>:<port>"' +
+                (extra ? ' (' + extra + ')' : '')
+        );
     }
 
     if (split.length !== 2) {
@@ -196,13 +189,15 @@ function assertFluentdAddress(arg, name) {
     }
 }
 
-
 function assertGelfAddress(arg, name) {
     var split = arg.split(':');
 
     function _throwInvalidGelfAddress(extra) {
-        throw typeErr(name, 'a gelf address "udp://<host>:<port>"'
-            + (extra ? ' (' + extra + ')' : ''));
+        throw typeErr(
+            name,
+            'a gelf address "udp://<host>:<port>"' +
+                (extra ? ' (' + extra + ')' : '')
+        );
     }
 
     if (split.length !== 3) {
@@ -242,19 +237,23 @@ function assertNetworkMode(networkMode, name) {
 
     if (networkMode === 'host' || networkMode === 'none') {
         throw new errors.NotImplementedError(
-            fmt('NetworkMode %s is not supported', networkMode));
+            fmt('NetworkMode %s is not supported', networkMode)
+        );
     }
 
     if (networkMode.match(/^container:/)) {
         throw new errors.NotImplementedError(
-            'Container networking is not supported');
+            'Container networking is not supported'
+        );
     }
 }
 
 function assertNetworkingParams(config) {
-    if (!config.NetworkMode
-        || config.NetworkMode === 'bridge'
-        || config.NetworkMode === 'default') {
+    if (
+        !config.NetworkMode ||
+        config.NetworkMode === 'bridge' ||
+        config.NetworkMode === 'default'
+    ) {
         return;
     }
 
@@ -277,66 +276,79 @@ function assertPortBindings(bindings, name) {
         var split = b.split('/');
 
         if (split.length !== 2) {
-            throw new errors.ValidationError(fmt(
-                '%s: port specification incorrect: must be "number/protocol"',
-                name));
+            throw new errors.ValidationError(
+                fmt(
+                    '%s: port specification incorrect: must be "number/protocol"',
+                    name
+                )
+            );
         }
 
         portNum = Number(split[0]);
         if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
-            throw new errors.ValidationError(fmt('%s: invalid port number',
-                name));
+            throw new errors.ValidationError(
+                fmt('%s: invalid port number', name)
+            );
         }
 
         if (split[1] !== 'tcp' && split[1] !== 'udp') {
-            throw new errors.ValidationError(fmt(
-                '%s: unknown protocol: must be tcp or udp', name));
+            throw new errors.ValidationError(
+                fmt('%s: unknown protocol: must be tcp or udp', name)
+            );
         }
     }
 }
 
-
 function assertLogConfigOpt(driver, option, value) {
     var help;
 
     switch (common.LOG_DRIVERS[driver].opts[option]) {
         case 'string':
-            assertString(value, fmt('log opt \'%s\'', option));
+            assertString(value, fmt("log opt '%s'", option));
             break;
         case 'positiveinteger':
-            assertPositiveInteger(value, fmt('log opt \'%s\'', option));
+            assertPositiveInteger(value, fmt("log opt '%s'", option));
             break;
         case 'positiveintegersize':
-            assertPositiveIntegerSize(value, fmt('log opt \'%s\'', option));
+            assertPositiveIntegerSize(value, fmt("log opt '%s'", option));
             break;
         case 'syslogAddress':
-            assertSyslogAddress(value, fmt('log opt \'%s\'', option));
+            assertSyslogAddress(value, fmt("log opt '%s'", option));
             break;
         case 'fluentdAddress':
-            assertFluentdAddress(value, fmt('log opt \'%s\'', option));
+            assertFluentdAddress(value, fmt("log opt '%s'", option));
             break;
         case 'gelfAddress':
-            assertGelfAddress(value, fmt('log opt \'%s\'', option));
+            assertGelfAddress(value, fmt("log opt '%s'", option));
             break;
         default:
             if (Array.isArray(common.LOG_DRIVERS[driver].opts[option])) {
-                if (common.LOG_DRIVERS[driver].opts_help
-                    && common.LOG_DRIVERS[driver].opts_help[option]) {
-
-                        help = common.LOG_DRIVERS[driver].opts_help[option];
+                if (
+                    common.LOG_DRIVERS[driver].opts_help &&
+                    common.LOG_DRIVERS[driver].opts_help[option]
+                ) {
+                    help = common.LOG_DRIVERS[driver].opts_help[option];
                 } else {
                     help = undefined;
                 }
-                assertArrayValue(common.LOG_DRIVERS[driver].opts[option], value,
-                    fmt('log opt \'%s\'', option), help);
+                assertArrayValue(
+                    common.LOG_DRIVERS[driver].opts[option],
+                    value,
+                    fmt("log opt '%s'", option),
+                    help
+                );
                 break;
             }
-            throw new errors.InternalError(fmt('unable to validate option '
-                + '\'%s\' for %s driver', option, driver));
+            throw new errors.InternalError(
+                fmt(
+                    'unable to validate option ' + "'%s' for %s driver",
+                    option,
+                    driver
+                )
+            );
     }
 }
 
-
 function assertLogConfig(logconfig, name, config) {
     var config_len;
     var driver;
@@ -358,22 +370,35 @@ function assertLogConfig(logconfig, name, config) {
     // write to metadata.
     config_len = JSON.stringify(driver_config);
     if (config_len > MAX_LOG_CONFIG_LEN) {
-        throw new errors.ValidationError(fmt('value for log opts too long, '
-            + 'must be < %d (was %d)', name, MAX_LOG_CONFIG_LEN, config_len));
+        throw new errors.ValidationError(
+            fmt(
+                'value for log opts too long, ' + 'must be < %d (was %d)',
+                name,
+                MAX_LOG_CONFIG_LEN,
+                config_len
+            )
+        );
     }
 
-    if (!config.hasOwnProperty('enabledLogDrivers')
-        || (config.enabledLogDrivers.indexOf(driver) === -1)) {
-
-        throw new errors.ValidationError(fmt('unsupported log driver: %s',
-            driver));
+    if (
+        !config.hasOwnProperty('enabledLogDrivers') ||
+        config.enabledLogDrivers.indexOf(driver) === -1
+    ) {
+        throw new errors.ValidationError(
+            fmt('unsupported log driver: %s', driver)
+        );
     }
 
     if (common.LOG_DRIVERS[driver].required_opts) {
         common.LOG_DRIVERS[driver].required_opts.forEach(function _reqOpt(opt) {
             if (!driver_config[opt]) {
-                throw new errors.ValidationError(fmt('missing required log opt '
-                    + '\'%s\' for log driver: %s', opt, driver));
+                throw new errors.ValidationError(
+                    fmt(
+                        'missing required log opt ' + "'%s' for log driver: %s",
+                        opt,
+                        driver
+                    )
+                );
             }
         });
     }
@@ -383,33 +408,29 @@ function assertLogConfig(logconfig, name, config) {
         // LOG_DRIVERS[driver].opts
         Object.keys(driver_config).forEach(function _checkOpt(opt) {
             if (!common.LOG_DRIVERS[driver].opts.hasOwnProperty(opt)) {
-
-                throw new errors.ValidationError(fmt('unknown log opt: \'%s\''
-                    + ' for %s driver', opt, driver));
+                throw new errors.ValidationError(
+                    fmt("unknown log opt: '%s'" + ' for %s driver', opt, driver)
+                );
             } else {
                 // This is a valid option, ensure it's got the correct value
                 assertLogConfigOpt(driver, opt, driver_config[opt]);
             }
         });
     } else if (Object.keys(driver_config).length > 0) {
-        throw new errors.ValidationError(fmt('log driver: %s does not support'
-            + ' options', driver));
+        throw new errors.ValidationError(
+            fmt('log driver: %s does not support' + ' options', driver)
+        );
     }
 }
 
-
 function assertString(arg, name) {
-    if (typeof (arg) !== 'string') {
+    if (typeof arg !== 'string') {
         throw typeErr(name, 'a string');
     }
 }
 
-
-
 // --- Exports
 
-
-
 function validateCreateContainer(req, res, next) {
     var config = req.app.config;
     var container = req.body;
@@ -428,37 +449,55 @@ function validateCreateContainer(req, res, next) {
         assertOptionalArrayOfString(container.Env, 'Env');
         assertOptionalArrayOfString(container.Entrypoint, 'Entrypoint');
 
-        assertOptionalArrayOfString(container.HostConfig.Links,
-            'HostConfig.Links');
-        assertOptionalArrayOfString(container.HostConfig.ExtraHosts,
-            'HostConfig.Entrypoint');
-        assertOptionalBool(container.HostConfig.PublishAllPorts,
-            'HostConfig.PublishAllPorts');
-        assertOptionalObject(container.HostConfig.PortBindings,
-            'HostConfig.PortBindings');
-        assertOptionalObject(container.HostConfig.LogConfig,
-            'HostConfig.LogConfig');
-        assertOptionalString(container.HostConfig.NetworkMode,
-            'HostConfig.NetworkMode');
+        assertOptionalArrayOfString(
+            container.HostConfig.Links,
+            'HostConfig.Links'
+        );
+        assertOptionalArrayOfString(
+            container.HostConfig.ExtraHosts,
+            'HostConfig.Entrypoint'
+        );
+        assertOptionalBool(
+            container.HostConfig.PublishAllPorts,
+            'HostConfig.PublishAllPorts'
+        );
+        assertOptionalObject(
+            container.HostConfig.PortBindings,
+            'HostConfig.PortBindings'
+        );
+        assertOptionalObject(
+            container.HostConfig.LogConfig,
+            'HostConfig.LogConfig'
+        );
+        assertOptionalString(
+            container.HostConfig.NetworkMode,
+            'HostConfig.NetworkMode'
+        );
 
         if (container.HostConfig.NetworkMode) {
-            assertNetworkMode(container.HostConfig.NetworkMode,
-                'HostConfig.NetworkMode');
+            assertNetworkMode(
+                container.HostConfig.NetworkMode,
+                'HostConfig.NetworkMode'
+            );
         }
 
         // ensures mutually-compatible networking params.
         assertNetworkingParams(container.HostConfig);
 
         if (container.HostConfig.PortBindings) {
-            assertPortBindings(container.HostConfig.PortBindings,
-                'HostConfig.PortBindings');
+            assertPortBindings(
+                container.HostConfig.PortBindings,
+                'HostConfig.PortBindings'
+            );
         }
 
         if (container.HostConfig.LogConfig) {
-            assertLogConfig(container.HostConfig.LogConfig,
-                'HostConfig.LogConfig', config);
+            assertLogConfig(
+                container.HostConfig.LogConfig,
+                'HostConfig.LogConfig',
+                config
+            );
         }
-
     } catch (assertErr) {
         return next(assertErr);
     }
@@ -466,7 +505,6 @@ function validateCreateContainer(req, res, next) {
     return next();
 }
 
-
 function validateArchiveReadStream(req, res, next) {
     try {
         assertString(req.query.path, 'path');
@@ -477,8 +515,6 @@ function validateArchiveReadStream(req, res, next) {
     next();
 }
 
-
-
 function validateArchiveWriteStream(req, res, next) {
     try {
         assertString(req.query.path, 'path');
@@ -489,8 +525,6 @@ function validateArchiveWriteStream(req, res, next) {
     next();
 }
 
-
-
 module.exports = {
     assert: {
         portBindings: assertPortBindings
diff --git a/lib/wfapi/index.js b/lib/wfapi/index.js
index 480e960..38fcfc1 100644
--- a/lib/wfapi/index.js
+++ b/lib/wfapi/index.js
@@ -18,17 +18,15 @@ var assert = require('assert-plus');
 var WfClient = require('wf-client');
 var async = require('async');
 
-
 // Workflows
 
 var WORKFLOW_PATH = __dirname + '/workflows/';
 
-
 /*
  * WFAPI Constructor
  */
 function Wfapi(options, log) {
-    this.log = log.child({ component: 'wfapi' }, true);
+    this.log = log.child({component: 'wfapi'}, true);
     options.path = WORKFLOW_PATH;
     options.log = this.log;
 
@@ -37,11 +35,10 @@ function Wfapi(options, log) {
     this.connected = false;
 }
 
-
 /*
  * Wait until wfapi is online before proceeding to create workflows
  */
-Wfapi.prototype.connect = function () {
+Wfapi.prototype.connect = function() {
     var self = this;
     self.log.debug('Loading the WFAPI workflows...');
 
@@ -50,32 +47,34 @@ Wfapi.prototype.connect = function () {
     // Don't proceed with initializing workflows until we have connected.
     function init() {
         async.until(
-            function () { return self.connected; },
-            function (cb) {
+            function() {
+                return self.connected;
+            },
+            function(cb) {
                 setTimeout(cb, 1000);
             },
-            function () {
-                self.client.initWorkflows(function (error) {
+            function() {
+                self.client.initWorkflows(function(error) {
                     if (error) {
                         self.log.error(error, 'Error initializing workflows');
                         init();
                     }
                     self.log.info('All workflows have been loaded');
                 });
-            });
+            }
+        );
     }
 
     init();
 };
 
-
 /*
  * Ping until wfapi is online
  */
-Wfapi.prototype.startAvailabilityWatcher = function () {
+Wfapi.prototype.startAvailabilityWatcher = function() {
     var self = this;
 
-    setInterval(function () {
+    setInterval(function() {
         pingWorkflow();
     }, 10000);
 
@@ -83,7 +82,7 @@ Wfapi.prototype.startAvailabilityWatcher = function () {
         var client = self.client;
 
         // Try to get a fake workflow, check the error code if any.
-        client.ping(function (error) {
+        client.ping(function(error) {
             if (error) {
                 if (self.connected) {
                     self.log.error('Workflow appears to be unavailable');
@@ -92,32 +91,33 @@ Wfapi.prototype.startAvailabilityWatcher = function () {
                 if (error.syscall === 'connect') {
                     self.connected = false;
                     self.log.error(
-                        'Failed to connect to Workflow API (%s)', error.code);
+                        'Failed to connect to Workflow API (%s)',
+                        error.code
+                    );
                     return;
                 }
 
                 self.connected = false;
-                self.log.error({ error: error }, 'Ping failed');
+                self.log.error({error: error}, 'Ping failed');
 
                 return;
             }
 
             if (!self.connected) {
-                client.getWorkflow(
-                    'workflow-check',
-                    function (err, val) {
-                        if (err.statusCode !== 404)
-                        {
-                            self.log.warn(err,
-                                'Workflow API Error: %d',
-                                err.statusCode);
-                            return;
-                        }
-                        if (!self.connected) {
-                            self.connected = true;
-                            self.log.info('Connected to Workflow API');
-                        }
-                    });
+                client.getWorkflow('workflow-check', function(err, val) {
+                    if (err.statusCode !== 404) {
+                        self.log.warn(
+                            err,
+                            'Workflow API Error: %d',
+                            err.statusCode
+                        );
+                        return;
+                    }
+                    if (!self.connected) {
+                        self.connected = true;
+                        self.log.info('Connected to Workflow API');
+                    }
+                });
             }
         });
     }
@@ -125,25 +125,22 @@ Wfapi.prototype.startAvailabilityWatcher = function () {
     pingWorkflow();
 };
 
-
 /*
  * Pings WFAPI by getting the provision workflow
  */
-Wfapi.prototype.ping = function (callback) {
-    this.client.ping(function (err, pong) {
+Wfapi.prototype.ping = function(callback) {
+    this.client.ping(function(err, pong) {
         return callback(err);
     });
 };
 
-
-
 /*
  * Queues a pull-image job.
  *
  * @param options {Object} Required.
  * @param cb {Function} `function (err, jobUuid)`
  */
-Wfapi.prototype.createPullImageJob = function (options, cb) {
+Wfapi.prototype.createPullImageJob = function(options, cb) {
     var self = this;
     assert.object(options, 'options');
     assert.object(options.rat, 'options.rat');
@@ -161,9 +158,9 @@ Wfapi.prototype.createPullImageJob = function (options, cb) {
         regAuth: options.regAuth,
         regConfig: options.regConfig
     };
-    var jobOpts = { headers: { 'x-request-id': options.req_id } };
+    var jobOpts = {headers: {'x-request-id': options.req_id}};
 
-    self.client.createJob(params.task, params, jobOpts, function (err, job) {
+    self.client.createJob(params.task, params, jobOpts, function(err, job) {
         if (err) {
             return cb(err);
         }
@@ -173,12 +170,11 @@ Wfapi.prototype.createPullImageJob = function (options, cb) {
     });
 };
 
-
 /*
  * Retrieves a job from WFAPI.
  */
-Wfapi.prototype.getJob = function (jobUuid, cb) {
-    this.client.getJob(jobUuid, function (err, job) {
+Wfapi.prototype.getJob = function(jobUuid, cb) {
+    this.client.getJob(jobUuid, function(err, job) {
         if (err) {
             cb(err);
             return;
@@ -188,5 +184,4 @@ Wfapi.prototype.getJob = function (jobUuid, cb) {
     });
 };
 
-
 module.exports = Wfapi;
diff --git a/lib/wfapi/workflows/pull-image.js b/lib/wfapi/workflows/pull-image.js
index cbae6ba..8f207bb 100644
--- a/lib/wfapi/workflows/pull-image.js
+++ b/lib/wfapi/workflows/pull-image.js
@@ -8,7 +8,6 @@
  * Copyright 2016, Joyent, Inc.
  */
 
-
 // This is not really needed, but javascriptlint will complain otherwise:
 var assert = require('assert-plus');
 var restify = require('restify');
@@ -32,7 +31,7 @@ function pullImageLayers(job, cb) {
     var dockerAdminiUrl = parsedUrl.protocol + '//' + parsedUrl.hostname;
     var dockerAdmin = restify.createJsonClient({
         url: dockerAdminiUrl,
-        headers: { 'x-request-id': job.params.req_id }
+        headers: {'x-request-id': job.params.req_id}
     });
     var imgapi = new sdcClients.IMGAPI({url: imgapiUrl});
 
@@ -56,8 +55,11 @@ function pullImageLayers(job, cb) {
             next();
         } else {
             // type 'progress' or 'status'
-            if (data.type == 'progress'
-                && data.payload && !data.payload.progressDetail) {
+            if (
+                data.type == 'progress' &&
+                data.payload &&
+                !data.payload.progressDetail
+            ) {
                 data.payload.progressDetail = {};
             }
             dockerAdmin.post('/admin/progress', data, next);
@@ -86,65 +88,68 @@ function pullImageLayers(job, cb) {
             docker_id: imgId
         };
 
-        dockerAdmin.get({
-            path: '/admin/images',
-            query: query
-        }, function (err, req, res, images) {
-            if (err) {
-                next(err);
-                return;
-            }
-
-            var action;
-            var heads;
-
-            if (images.length) {
-                // Layer already exists:
-                // 1) check if this pull is already refcounted and return
-                // 2) update the refcount for this image
-                var image = images[0];
-                if (image.heads.indexOf(job.params.head) !== -1) {
-                    next();
+        dockerAdmin.get(
+            {
+                path: '/admin/images',
+                query: query
+            },
+            function(err, req, res, images) {
+                if (err) {
+                    next(err);
                     return;
                 }
 
-                action = 'update';
-                image.heads.push(job.params.head);
-                heads = image.heads;
-            } else {
-                action = 'create';
-                heads = [ job.params.head ];
-            }
+                var action;
+                var heads;
+
+                if (images.length) {
+                    // Layer already exists:
+                    // 1) check if this pull is already refcounted and return
+                    // 2) update the refcount for this image
+                    var image = images[0];
+                    if (image.heads.indexOf(job.params.head) !== -1) {
+                        next();
+                        return;
+                    }
+
+                    action = 'update';
+                    image.heads.push(job.params.head);
+                    heads = image.heads;
+                } else {
+                    action = 'create';
+                    heads = [job.params.head];
+                }
 
-            var layer = {
-                author: imgJson.author,
-                created: new Date(imgJson.created).getTime(),
-                docker_id: imgId,
-                heads: heads,
-                image_uuid: data.image.uuid,
-                index_name: job.params.rat.index.name,
-                owner_uuid: job.params.account_uuid,
-                size: size,
-                virtual_size: virtualSize,
-                private: data.private
-            };
-
-            if (imgJson.container_config) {
-                layer.container_config = imgJson.container_config;
-            }
-            if (imgJson.config) {
-                layer.config = imgJson.config;
-            }
-            if (imgJson.parent) {
-                layer.parent = imgJson.parent;
-            }
-            if (job.params.head === imgId) {
-                layer.head = true;
-            }
+                var layer = {
+                    author: imgJson.author,
+                    created: new Date(imgJson.created).getTime(),
+                    docker_id: imgId,
+                    heads: heads,
+                    image_uuid: data.image.uuid,
+                    index_name: job.params.rat.index.name,
+                    owner_uuid: job.params.account_uuid,
+                    size: size,
+                    virtual_size: virtualSize,
+                    private: data.private
+                };
+
+                if (imgJson.container_config) {
+                    layer.container_config = imgJson.container_config;
+                }
+                if (imgJson.config) {
+                    layer.config = imgJson.config;
+                }
+                if (imgJson.parent) {
+                    layer.parent = imgJson.parent;
+                }
+                if (job.params.head === imgId) {
+                    layer.head = true;
+                }
 
-            var path = '/admin/images?action=' + action;
-            dockerAdmin.post(path, layer, next);
-        });
+                var path = '/admin/images?action=' + action;
+                dockerAdmin.post(path, layer, next);
+            }
+        );
     }
 
     var opts = {
@@ -158,24 +163,24 @@ function pullImageLayers(job, cb) {
          * It is sdc-docker code that gates access to all the images.
          */
         public: false,
-        headers: { 'x-request-id': job.params.req_id }
+        headers: {'x-request-id': job.params.req_id}
     };
 
-    imgapi.adminImportDockerImage(opts, function (connectErr, res) {
+    imgapi.adminImportDockerImage(opts, function(connectErr, res) {
         if (connectErr) {
             job.log.info('adminImportDockerImage error %s', connectErr);
             cb(connectErr);
             return;
         }
 
-        var lstream = new LineStream({ encoding: 'utf8' });
+        var lstream = new LineStream({encoding: 'utf8'});
 
-        lstream.on('error', function (lerr) {
+        lstream.on('error', function(lerr) {
             job.log.info('LineStream threw an error %s', lerr);
             cb(lerr);
         });
 
-        lstream.on('readable', function () {
+        lstream.on('readable', function() {
             var line;
             while ((line = lstream.read()) != null) {
                 line = line.trim();
@@ -189,7 +194,7 @@ function pullImageLayers(job, cb) {
             queue.close();
 
             // Wait for queue to finish before ending the task
-            queue.on('end', function () {
+            queue.on('end', function() {
                 if (queueError) {
                     cb(queueError);
                 } else {
@@ -213,7 +218,7 @@ function tagHeadImage(job, cb) {
     var dockerAdminUrl = parsedUrl.protocol + '//' + parsedUrl.hostname;
     var dockerAdmin = restify.createJsonClient({
         url: dockerAdminUrl,
-        headers: { 'x-request-id': job.params.req_id }
+        headers: {'x-request-id': job.params.req_id}
     });
 
     var data = {
@@ -224,7 +229,7 @@ function tagHeadImage(job, cb) {
         docker_id: job.params.head
     };
 
-    dockerAdmin.post('/admin/image_tags', data, function (createErr) {
+    dockerAdmin.post('/admin/image_tags', data, function(createErr) {
         if (createErr) {
             cb(createErr);
             return;
@@ -234,39 +239,43 @@ function tagHeadImage(job, cb) {
     });
 }
 
-
-var workflow = module.exports = {
+var workflow = (module.exports = {
     name: 'pull-image-' + VERSION,
     version: VERSION,
-    chain: [ {
-        name: 'pull_image_layers',
-        timeout: 3600,
-        retry: 1,
-        body: pullImageLayers,
-        modules: {
-            assert: 'assert-plus',
-            LineStream: 'lstream',
-            restify: 'restify',
-            sdcClients: 'sdc-clients',
-            urlModule: 'url',
-            vasync: 'vasync'
-        }
-    }, {
-        name: 'tag_head_image',
-        timeout: 20,
-        retry: 1,
-        body: tagHeadImage,
-        modules: {
-            restify: 'restify',
-            urlModule: 'url'
+    chain: [
+        {
+            name: 'pull_image_layers',
+            timeout: 3600,
+            retry: 1,
+            body: pullImageLayers,
+            modules: {
+                assert: 'assert-plus',
+                LineStream: 'lstream',
+                restify: 'restify',
+                sdcClients: 'sdc-clients',
+                urlModule: 'url',
+                vasync: 'vasync'
+            }
+        },
+        {
+            name: 'tag_head_image',
+            timeout: 20,
+            retry: 1,
+            body: tagHeadImage,
+            modules: {
+                restify: 'restify',
+                urlModule: 'url'
+            }
         }
-    }],
+    ],
     timeout: 3620,
-    onerror: [ {
-        name: 'On error',
-        modules: {},
-        body: function (job, cb) {
-            return cb('Error executing job');
+    onerror: [
+        {
+            name: 'On error',
+            modules: {},
+            body: function(job, cb) {
+                return cb('Error executing job');
+            }
         }
-    }]
-};
+    ]
+});
diff --git a/test/integration/api-build.test.js b/test/integration/api-build.test.js
index 5ccd8d3..f1f6817 100644
--- a/test/integration/api-build.test.js
+++ b/test/integration/api-build.test.js
@@ -33,12 +33,11 @@ var ALICE;
 var DOCKER_ALICE; // Regular JSON restify client.
 var DOCKER_ALICE_HTTP; // For sending non-JSON payload
 
-
 function createTarStream(fileAndContents) {
     var pack = tar.pack();
 
-    Object.keys(fileAndContents).forEach(function (name) {
-        pack.entry({ name: name }, fileAndContents[name]);
+    Object.keys(fileAndContents).forEach(function(name) {
+        pack.entry({name: name}, fileAndContents[name]);
     });
 
     pack.finalize();
@@ -46,11 +45,9 @@ function createTarStream(fileAndContents) {
     return pack;
 }
 
-
-test('setup', function (tt) {
-
-    tt.test('docker env', function (t) {
-        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        h.initDockerEnv(t, STATE, {}, function(err, accounts) {
             t.ifErr(err);
 
             ALICE = accounts.alice;
@@ -59,474 +56,550 @@ test('setup', function (tt) {
         });
     });
 
-    tt.test('docker client init', function (t) {
-        vasync.parallel({ funcs: [
-            function createAliceHttp(done) {
-                h.createDockerRemoteClient({user: ALICE},
-                    function (err, client) {
-                        t.ifErr(err, 'docker client init for alice');
-                        done(err, client);
-                    });
+    tt.test('docker client init', function(t) {
+        vasync.parallel(
+            {
+                funcs: [
+                    function createAliceHttp(done) {
+                        h.createDockerRemoteClient({user: ALICE}, function(
+                            err,
+                            client
+                        ) {
+                            t.ifErr(err, 'docker client init for alice');
+                            done(err, client);
+                        });
+                    }
+                ]
+            },
+            function allDone(err, results) {
+                t.ifError(err, 'docker client init should be successful');
+                DOCKER_ALICE = results.operations[0].result;
+                t.end();
             }
-        ]}, function allDone(err, results) {
-            t.ifError(err, 'docker client init should be successful');
-            DOCKER_ALICE = results.operations[0].result;
-            t.end();
-        });
+        );
     });
 
-    tt.test('docker client http init', function (t) {
-        vasync.parallel({ funcs: [
-            function createAliceHttp(done) {
-                h.createDockerRemoteClient({user: ALICE, clientType: 'http'},
-                    function (err, client) {
-                        t.ifErr(err, 'docker client init for alice/http');
-                        done(err, client);
-                    });
+    tt.test('docker client http init', function(t) {
+        vasync.parallel(
+            {
+                funcs: [
+                    function createAliceHttp(done) {
+                        h.createDockerRemoteClient(
+                            {user: ALICE, clientType: 'http'},
+                            function(err, client) {
+                                t.ifErr(
+                                    err,
+                                    'docker client init for alice/http'
+                                );
+                                done(err, client);
+                            }
+                        );
+                    }
+                ]
+            },
+            function allDone(err, results) {
+                t.ifError(err, 'docker client http init should be successful');
+                DOCKER_ALICE_HTTP = results.operations[0].result;
+                t.end();
             }
-        ]}, function allDone(err, results) {
-            t.ifError(err, 'docker client http init should be successful');
-            DOCKER_ALICE_HTTP = results.operations[0].result;
-            t.end();
-        });
+        );
     });
 });
 
-test('api: build', function (tt) {
-    tt.test('docker build with busybox build context', function (t) {
+test('api: build', function(tt) {
+    tt.test('docker build with busybox build context', function(t) {
         var dockerImageId = null;
         var tarStream;
 
-        vasync.waterfall([
-
-            function createTar(next) {
-                var fileAndContents = {
-                    'Dockerfile': 'FROM busybox\n'
-                                + 'LABEL sdcdockertest=true\n'
-                };
-                tarStream = createTarStream(fileAndContents);
-                next();
-            },
-
-            function buildContainer(next) {
-                h.buildDockerContainer({
-                    dockerClient: DOCKER_ALICE_HTTP,
-                    params: {
-                        'labels': '{"gone":"fishing"}',
-                        'rm': 'true'  // Remove container after it's built.
-                    },
-                    test: t,
-                    tarball: tarStream
-                }, onbuild);
-
-                function onbuild(err, result) {
-                    t.ifError(err, 'build finished');
-                    next(err, result);
-                }
-            },
-
-            function checkResults(result, next) {
-                if (!result || !result.body) {
-                    next(new Error('build generated no output!?'));
-                    return;
-                }
+        vasync.waterfall(
+            [
+                function createTar(next) {
+                    var fileAndContents = {
+                        Dockerfile: 'FROM busybox\n' +
+                            'LABEL sdcdockertest=true\n'
+                    };
+                    tarStream = createTarStream(fileAndContents);
+                    next();
+                },
 
-                var output = result.body;
-                var hasLabel = output.indexOf('LABEL sdcdockertest=true') >= 0;
-                t.ok(hasLabel, format(
-                    'output contains LABEL sdcdockertest=true: output=%j',
-                    output));
+                function buildContainer(next) {
+                    h.buildDockerContainer(
+                        {
+                            dockerClient: DOCKER_ALICE_HTTP,
+                            params: {
+                                labels: '{"gone":"fishing"}',
+                                rm: 'true' // Remove container after it's built.
+                            },
+                            test: t,
+                            tarball: tarStream
+                        },
+                        onbuild
+                    );
+
+                    function onbuild(err, result) {
+                        t.ifError(err, 'build finished');
+                        next(err, result);
+                    }
+                },
 
-                var hasSuccess = output.indexOf('Successfully built') >= 0;
-                t.ok(hasSuccess, 'output contains Successfully built');
+                function checkResults(result, next) {
+                    if (!result || !result.body) {
+                        next(new Error('build generated no output!?'));
+                        return;
+                    }
 
-                if (hasSuccess) {
-                    var reg = new RegExp('Successfully built (\\w+)');
-                    dockerImageId = output.match(reg)[1];
-                }
+                    var output = result.body;
+                    var hasLabel =
+                        output.indexOf('LABEL sdcdockertest=true') >= 0;
+                    t.ok(
+                        hasLabel,
+                        format(
+                            'output contains LABEL sdcdockertest=true: output=%j',
+                            output
+                        )
+                    );
+
+                    var hasSuccess = output.indexOf('Successfully built') >= 0;
+                    t.ok(hasSuccess, 'output contains Successfully built');
 
-                next();
-            },
+                    if (hasSuccess) {
+                        var reg = new RegExp('Successfully built (\\w+)');
+                        dockerImageId = output.match(reg)[1];
+                    }
 
-            function inspectImage(next) {
-                DOCKER_ALICE.get('/images/' + dockerImageId + '/json',
-                        function (err, req, res, img) {
-                    t.ok(img, 'inspect image');
-                    t.deepEqual(img.Config.Labels,
-                        {'gone': 'fishing', 'sdcdockertest': 'true'});
                     next();
-                });
-            },
-
-            function removeBuiltImage(next) {
-                t.ok(dockerImageId, 'Got the docker image id');
-                DOCKER_ALICE.del('/images/' + dockerImageId, next);
-            }
+                },
 
-        ], function allDone(err) {
-            t.ifErr(err);
+                function inspectImage(next) {
+                    DOCKER_ALICE.get(
+                        '/images/' + dockerImageId + '/json',
+                        function(err, req, res, img) {
+                            t.ok(img, 'inspect image');
+                            t.deepEqual(img.Config.Labels, {
+                                gone: 'fishing',
+                                sdcdockertest: 'true'
+                            });
+                            next();
+                        }
+                    );
+                },
 
-            t.end();
-        });
+                function removeBuiltImage(next) {
+                    t.ok(dockerImageId, 'Got the docker image id');
+                    DOCKER_ALICE.del('/images/' + dockerImageId, next);
+                }
+            ],
+            function allDone(err) {
+                t.ifErr(err);
 
+                t.end();
+            }
+        );
     });
 });
 
-
 /**
  * DOCKER-662: Ensure no conflicts with same images in different repositories.
  */
-test('api: build image conflicts', function (tt) {
+test('api: build image conflicts', function(tt) {
     var imageName1 =
         'docker.io/joyentunsupported/triton_alpine_inherit_test:latest';
     var imageName2 = 'quay.io/joyent/triton_alpine_inherit_test:latest';
 
     // Pull the docker.io alpine image.
-    tt.test('pull docker.io alpine test image', function (t) {
-        h.ensureImage({
-            name: imageName1,
-            user: ALICE
-        }, function (err) {
-            t.error(err, 'getting docker.io alpine test image');
-            t.end();
-        });
+    tt.test('pull docker.io alpine test image', function(t) {
+        h.ensureImage(
+            {
+                name: imageName1,
+                user: ALICE
+            },
+            function(err) {
+                t.error(err, 'getting docker.io alpine test image');
+                t.end();
+            }
+        );
     });
 
     // Pull something that uses the same alpine image in a different repository.
-    tt.test('pull quay.io alpine test image', function (t) {
-        h.ensureImage({
-            name: imageName2,
-            user: ALICE
-        }, function (err) {
-            t.error(err, 'getting quay.io alpine test image');
-            t.end();
-        });
+    tt.test('pull quay.io alpine test image', function(t) {
+        h.ensureImage(
+            {
+                name: imageName2,
+                user: ALICE
+            },
+            function(err) {
+                t.error(err, 'getting quay.io alpine test image');
+                t.end();
+            }
+        );
     });
 
     // TODO: Assert two alpine images share the same history.
 
-    tt.test('docker build own alpine image', function (t) {
+    tt.test('docker build own alpine image', function(t) {
         var dockerImageId = null;
         var tarStream;
 
-        vasync.waterfall([
-
-            function createTar(next) {
-                var fileAndContents = {
-                    'Dockerfile': 'FROM ' + imageName1 + '\n'
-                                + 'LABEL sdcdockertest_conflict=yes\n'
-                };
-                tarStream = createTarStream(fileAndContents);
-                next();
-            },
-
-            function buildContainer(next) {
-                h.buildDockerContainer({
-                    dockerClient: DOCKER_ALICE_HTTP,
-                    params: {
-                        'rm': 'true'  // Remove container after it's built.
-                    },
-                    test: t,
-                    tarball: tarStream
-                }, onbuild);
-
-                function onbuild(err, result) {
-                    t.ifError(err, 'built successfully');
-                    next(err, result);
-                }
-            },
-
-            function checkResults(result, next) {
-                if (!result || !result.body) {
-                    next(new Error('build generated no output!?'));
-                    return;
-                }
-
-                var output = result.body;
-                var hasSuccess = output.indexOf('Successfully built') >= 0;
-                t.ok(hasSuccess, 'output should contain: Successfully built');
-
-                if (hasSuccess) {
-                    var reg = new RegExp('Successfully built (\\w+)');
-                    dockerImageId = output.match(reg)[1];
-                } else {
-                    t.fail('Output: ' + output);
-                }
+        vasync.waterfall(
+            [
+                function createTar(next) {
+                    var fileAndContents = {
+                        Dockerfile: 'FROM ' +
+                            imageName1 +
+                            '\n' +
+                            'LABEL sdcdockertest_conflict=yes\n'
+                    };
+                    tarStream = createTarStream(fileAndContents);
+                    next();
+                },
 
-                next();
-            },
+                function buildContainer(next) {
+                    h.buildDockerContainer(
+                        {
+                            dockerClient: DOCKER_ALICE_HTTP,
+                            params: {
+                                rm: 'true' // Remove container after it's built.
+                            },
+                            test: t,
+                            tarball: tarStream
+                        },
+                        onbuild
+                    );
+
+                    function onbuild(err, result) {
+                        t.ifError(err, 'built successfully');
+                        next(err, result);
+                    }
+                },
 
-            function removeBuiltImage(next) {
-                t.ok(dockerImageId, 'got the built docker image id');
-                DOCKER_ALICE.del('/images/' + dockerImageId, next);
-            }
+                function checkResults(result, next) {
+                    if (!result || !result.body) {
+                        next(new Error('build generated no output!?'));
+                        return;
+                    }
 
-        ], function allDone(err) {
-            t.ifErr(err);
-            t.end();
-        });
+                    var output = result.body;
+                    var hasSuccess = output.indexOf('Successfully built') >= 0;
+                    t.ok(
+                        hasSuccess,
+                        'output should contain: Successfully built'
+                    );
 
-    });
+                    if (hasSuccess) {
+                        var reg = new RegExp('Successfully built (\\w+)');
+                        dockerImageId = output.match(reg)[1];
+                    } else {
+                        t.fail('Output: ' + output);
+                    }
 
-    // Cleanup images we pulled down.
+                    next();
+                },
 
-    tt.test('delete docker.io alpine test image', function (t) {
-        DOCKER_ALICE.del('/images/' + encodeURIComponent(imageName1),
-            function (err) {
+                function removeBuiltImage(next) {
+                    t.ok(dockerImageId, 'got the built docker image id');
+                    DOCKER_ALICE.del('/images/' + dockerImageId, next);
+                }
+            ],
+            function allDone(err) {
                 t.ifErr(err);
                 t.end();
             }
         );
     });
 
-    tt.test('delete quay.io alpine test image', function (t) {
-        DOCKER_ALICE.del('/images/' + encodeURIComponent(imageName2),
-            function (err) {
-                t.ifErr(err);
-                t.end();
-            }
-        );
+    // Cleanup images we pulled down.
+
+    tt.test('delete docker.io alpine test image', function(t) {
+        DOCKER_ALICE.del('/images/' + encodeURIComponent(imageName1), function(
+            err
+        ) {
+            t.ifErr(err);
+            t.end();
+        });
     });
 
+    tt.test('delete quay.io alpine test image', function(t) {
+        DOCKER_ALICE.del('/images/' + encodeURIComponent(imageName2), function(
+            err
+        ) {
+            t.ifErr(err);
+            t.end();
+        });
+    });
 });
 
-
 /**
  * DOCKER-748: Cannot build an image that references multiple registries.
  */
-test('api: build across multiple registries', function (tt) {
+test('api: build across multiple registries', function(tt) {
     var imageName = 'quay.io/joyent/triton_alpine_inherit_test:latest';
     var newTagName = 'quay.io/joyent/newtag:latest';
 
     // Pull the docker.io alpine image.
-    tt.test('pull quay.io alpine test image', function (t) {
-        h.ensureImage({
-            name: imageName,
-            user: ALICE
-        }, function (err) {
-            t.error(err, 'getting docker.io alpine test image');
-            t.end();
-        });
+    tt.test('pull quay.io alpine test image', function(t) {
+        h.ensureImage(
+            {
+                name: imageName,
+                user: ALICE
+            },
+            function(err) {
+                t.error(err, 'getting docker.io alpine test image');
+                t.end();
+            }
+        );
     });
 
-    tt.test('docker build from alpine image (cross registry)', function (t) {
+    tt.test('docker build from alpine image (cross registry)', function(t) {
         var tarStream;
 
-        vasync.waterfall([
-
-            function createTar(next) {
-                var fileAndContents = {
-                    'Dockerfile': 'FROM ' + imageName + '\n'
-                                + 'LABEL something=true\n'
-                };
-                tarStream = createTarStream(fileAndContents);
-                next();
-            },
+        vasync.waterfall(
+            [
+                function createTar(next) {
+                    var fileAndContents = {
+                        Dockerfile: 'FROM ' +
+                            imageName +
+                            '\n' +
+                            'LABEL something=true\n'
+                    };
+                    tarStream = createTarStream(fileAndContents);
+                    next();
+                },
 
-            function buildContainer(next) {
-                h.buildDockerContainer({
-                    dockerClient: DOCKER_ALICE_HTTP,
-                    params: {
-                        'rm': 'true'  // Remove container after it's built.
-                    },
-                    test: t,
-                    tarball: tarStream
-                }, onbuild);
-
-                function onbuild(err, result) {
-                    t.ifErr(err, 'build should not error on post');
-                    var msg = result.body;
-                    if (msg.indexOf('different registries') === -1) {
-                        t.fail('expected a "different registries" error '
-                            + 'message, got: "' + msg + '"');
+                function buildContainer(next) {
+                    h.buildDockerContainer(
+                        {
+                            dockerClient: DOCKER_ALICE_HTTP,
+                            params: {
+                                rm: 'true' // Remove container after it's built.
+                            },
+                            test: t,
+                            tarball: tarStream
+                        },
+                        onbuild
+                    );
+
+                    function onbuild(err, result) {
+                        t.ifErr(err, 'build should not error on post');
+                        var msg = result.body;
+                        if (msg.indexOf('different registries') === -1) {
+                            t.fail(
+                                'expected a "different registries" error ' +
+                                    'message, got: "' +
+                                    msg +
+                                    '"'
+                            );
+                        }
+                        next();
                     }
-                    next();
                 }
+            ],
+            function allDone(err) {
+                t.ifErr(err);
+                t.end();
             }
-
-        ], function allDone(err) {
-            t.ifErr(err);
-            t.end();
-        });
-
+        );
     });
 
     // Test that can still build using the same index.
-    tt.test('docker build from alpine image (same registry)', function (t) {
+    tt.test('docker build from alpine image (same registry)', function(t) {
         var tarStream;
 
-        vasync.waterfall([
-
-            function createTar(next) {
-                var fileAndContents = {
-                    'Dockerfile': 'FROM ' + imageName + '\n'
-                                + 'LABEL something=true\n'
-                };
-                tarStream = createTarStream(fileAndContents);
-                next();
-            },
-
-            function buildContainer(next) {
-                h.buildDockerContainer({
-                    dockerClient: DOCKER_ALICE_HTTP,
-                    params: {
-                        't': newTagName,
-                        'rm': 'true'  // Remove container after it's built.
-                    },
-                    test: t,
-                    tarball: tarStream
-                }, onbuild);
-
-                function onbuild(err, result) {
-                    t.ifErr(err, 'build should not error on post');
-                    var msg = result.body;
-
-                    var hasSuccess = msg.indexOf('Successfully built') >= 0;
-                    t.ok(hasSuccess, 'output contains Successfully built');
+        vasync.waterfall(
+            [
+                function createTar(next) {
+                    var fileAndContents = {
+                        Dockerfile: 'FROM ' +
+                            imageName +
+                            '\n' +
+                            'LABEL something=true\n'
+                    };
+                    tarStream = createTarStream(fileAndContents);
+                    next();
+                },
 
-                    // Delete the built image.
-                    if (hasSuccess) {
-                        DOCKER_ALICE.del('/images/' + escape(newTagName), next);
-                    } else {
-                        next();
+                function buildContainer(next) {
+                    h.buildDockerContainer(
+                        {
+                            dockerClient: DOCKER_ALICE_HTTP,
+                            params: {
+                                t: newTagName,
+                                rm: 'true' // Remove container after it's built.
+                            },
+                            test: t,
+                            tarball: tarStream
+                        },
+                        onbuild
+                    );
+
+                    function onbuild(err, result) {
+                        t.ifErr(err, 'build should not error on post');
+                        var msg = result.body;
+
+                        var hasSuccess = msg.indexOf('Successfully built') >= 0;
+                        t.ok(hasSuccess, 'output contains Successfully built');
+
+                        // Delete the built image.
+                        if (hasSuccess) {
+                            DOCKER_ALICE.del(
+                                '/images/' + escape(newTagName),
+                                next
+                            );
+                        } else {
+                            next();
+                        }
                     }
                 }
-            }
-
-        ], function allDone(err) {
-            t.ifErr(err);
-            t.end();
-        });
-
-    });
-
-    // Cleanup images we pulled down.
-
-    tt.test('delete quay.io alpine test image', function (t) {
-        DOCKER_ALICE.del('/images/' + encodeURIComponent(imageName),
-            function (err) {
+            ],
+            function allDone(err) {
                 t.ifErr(err);
                 t.end();
             }
         );
     });
 
+    // Cleanup images we pulled down.
+
+    tt.test('delete quay.io alpine test image', function(t) {
+        DOCKER_ALICE.del('/images/' + encodeURIComponent(imageName), function(
+            err
+        ) {
+            t.ifErr(err);
+            t.end();
+        });
+    });
 });
 
+test('build with packagelabel', function(tt) {
+    var imageLabels = {fireworks: 'awesome'};
+
+    vasync.pipeline(
+        {
+            arg: {},
+            funcs: [
+                function getSmallestPackage(ctx, next) {
+                    h.getSortedPackages(function(err, pkgs) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        tt.ok(pkgs.length >= 1, 'Must be at least one pkg');
+                        var smallestPkg = pkgs[0];
+                        tt.ok(smallestPkg.name, 'smallestPkg.name');
+                        ctx.allLabels = {
+                            'com.joyent.package': smallestPkg.name,
+                            fireworks: 'awesome'
+                        };
+                        next();
+                    });
+                },
 
-test('build with packagelabel', function (tt) {
+                function createTar(ctx, next) {
+                    var fileAndContents = {
+                        Dockerfile: 'FROM busybox\n' +
+                            'LABEL fireworks=awesome\n' +
+                            'RUN true\n'
+                    };
+                    ctx.tarStream = createTarStream(fileAndContents);
+                    next();
+                },
 
-    var imageLabels = { 'fireworks': 'awesome' };
+                function buildWithPackageLabel(ctx, next) {
+                    h.buildDockerContainer(
+                        {
+                            dockerClient: DOCKER_ALICE_HTTP,
+                            params: {
+                                labels: JSON.stringify(ctx.allLabels),
+                                rm: 'false' // Don't remove container after it's built.
+                            },
+                            test: tt,
+                            tarball: ctx.tarStream
+                        },
+                        onbuild
+                    );
+
+                    function onbuild(err, result) {
+                        tt.ifError(err, 'build finished');
+                        ctx.result = result;
+                        next(err, result);
+                    }
+                },
 
-    vasync.pipeline({ arg: {}, funcs: [
+                function checkResults(ctx, next) {
+                    if (!ctx.result || !ctx.result.body) {
+                        next(new Error('build generated no output!?'));
+                        return;
+                    }
 
-        function getSmallestPackage(ctx, next) {
-            h.getSortedPackages(function (err, pkgs) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-                tt.ok(pkgs.length >= 1, 'Must be at least one pkg');
-                var smallestPkg = pkgs[0];
-                tt.ok(smallestPkg.name, 'smallestPkg.name');
-                ctx.allLabels = {
-                    'com.joyent.package': smallestPkg.name,
-                    'fireworks': 'awesome'
-                };
-                next();
-            });
-        },
+                    var reg;
+                    var output = ctx.result.body;
+                    var hasLabel =
+                        output.indexOf('LABEL fireworks=awesome') >= 0;
+                    tt.ok(
+                        hasLabel,
+                        format(
+                            'output contains "LABEL fireworks=awesome": output=%j',
+                            output
+                        )
+                    );
+
+                    var hasRunningIn = output.indexOf('Running in ') >= 0;
+                    tt.ok(hasRunningIn, 'output contains "Running in"');
+                    if (hasRunningIn) {
+                        reg = new RegExp('Running in (\\w+)');
+                        ctx.containerId = output.match(reg)[1];
+                        tt.ok(ctx.containerId, 'Found containerId');
+                    }
 
-        function createTar(ctx, next) {
-            var fileAndContents = {
-                'Dockerfile': 'FROM busybox\n'
-                            + 'LABEL fireworks=awesome\n'
-                            + 'RUN true\n'
-            };
-            ctx.tarStream = createTarStream(fileAndContents);
-            next();
-        },
+                    var hasSuccess = output.indexOf('Successfully built') >= 0;
+                    tt.ok(hasSuccess, 'output contains Successfully built');
+                    if (hasSuccess) {
+                        reg = new RegExp('Successfully built (\\w+)');
+                        ctx.dockerImageId = output.match(reg)[1];
+                        tt.ok(ctx.dockerImageId, 'Found dockerImageId');
+                    }
 
-        function buildWithPackageLabel(ctx, next) {
-            h.buildDockerContainer({
-                dockerClient: DOCKER_ALICE_HTTP,
-                params: {
-                    'labels': JSON.stringify(ctx.allLabels),
-                    'rm': 'false'  // Don't remove container after it's built.
+                    next();
                 },
-                test: tt,
-                tarball: ctx.tarStream
-            }, onbuild);
-
-            function onbuild(err, result) {
-                tt.ifError(err, 'build finished');
-                ctx.result = result;
-                next(err, result);
-            }
-        },
-
-        function checkResults(ctx, next) {
-            if (!ctx.result || !ctx.result.body) {
-                next(new Error('build generated no output!?'));
-                return;
-            }
-
-            var reg;
-            var output = ctx.result.body;
-            var hasLabel = output.indexOf('LABEL fireworks=awesome') >= 0;
-            tt.ok(hasLabel, format(
-                'output contains "LABEL fireworks=awesome": output=%j',
-                output));
-
-            var hasRunningIn = output.indexOf('Running in ') >= 0;
-            tt.ok(hasRunningIn, 'output contains "Running in"');
-            if (hasRunningIn) {
-                reg = new RegExp('Running in (\\w+)');
-                ctx.containerId = output.match(reg)[1];
-                tt.ok(ctx.containerId, 'Found containerId');
-            }
-
-            var hasSuccess = output.indexOf('Successfully built') >= 0;
-            tt.ok(hasSuccess, 'output contains Successfully built');
-            if (hasSuccess) {
-                reg = new RegExp('Successfully built (\\w+)');
-                ctx.dockerImageId = output.match(reg)[1];
-                tt.ok(ctx.dockerImageId, 'Found dockerImageId');
-            }
 
-            next();
-        },
+                function inspectBuildContainer(ctx, next) {
+                    DOCKER_ALICE.get(
+                        '/containers/' + ctx.containerId + '/json',
+                        function(err, req, res, container) {
+                            tt.ok(container, 'inspect container');
+                            tt.deepEqual(
+                                container.Config.Labels,
+                                ctx.allLabels
+                            );
+                            next();
+                        }
+                    );
+                },
 
-        function inspectBuildContainer(ctx, next) {
-            DOCKER_ALICE.get('/containers/' + ctx.containerId + '/json',
-                    function (err, req, res, container) {
-                tt.ok(container, 'inspect container');
-                tt.deepEqual(container.Config.Labels, ctx.allLabels);
-                next();
-            });
-        },
+                // Make sure that the image does not include 'com.joyent.package' label.
+                function inspectBuiltImage(ctx, next) {
+                    DOCKER_ALICE.get(
+                        '/images/' + ctx.dockerImageId + '/json',
+                        function(err, req, res, img) {
+                            tt.ok(img, 'inspect image');
+                            tt.deepEqual(img.Config.Labels, imageLabels);
+                            next();
+                        }
+                    );
+                },
 
-        // Make sure that the image does not include 'com.joyent.package' label.
-        function inspectBuiltImage(ctx, next) {
-            DOCKER_ALICE.get('/images/' + ctx.dockerImageId + '/json',
-                    function (err, req, res, img) {
-                tt.ok(img, 'inspect image');
-                tt.deepEqual(img.Config.Labels, imageLabels);
-                next();
-            });
-        },
+                function removeBuiltImage(ctx, next) {
+                    tt.ok(ctx.dockerImageId, 'Got the docker image id');
+                    DOCKER_ALICE.del('/images/' + ctx.dockerImageId, next);
+                },
 
-        function removeBuiltImage(ctx, next) {
-            tt.ok(ctx.dockerImageId, 'Got the docker image id');
-            DOCKER_ALICE.del('/images/' + ctx.dockerImageId, next);
+                function removeBuildContainer(ctx, next) {
+                    DOCKER_ALICE.del('/containers/' + ctx.containerId, next);
+                }
+            ]
         },
-
-        function removeBuildContainer(ctx, next) {
-            DOCKER_ALICE.del('/containers/' + ctx.containerId, next);
+        function _inspectedContainers(err) {
+            tt.ifError(err, 'build with packagelabel');
+            tt.end();
         }
-
-    ]}, function _inspectedContainers(err) {
-        tt.ifError(err, 'build with packagelabel');
-        tt.end();
-    });
+    );
 });
diff --git a/test/integration/api-create.test.js b/test/integration/api-create.test.js
index 97dfe07..51a5525 100644
--- a/test/integration/api-create.test.js
+++ b/test/integration/api-create.test.js
@@ -24,8 +24,6 @@ var constants = require('../../lib/constants');
 
 var h = require('./helpers');
 
-
-
 // --- Globals
 var BYTES_IN_MB = 1024 * 1024;
 var ALICE;
@@ -40,53 +38,55 @@ var VMAPI;
 var NAPI;
 var FABRICS = false;
 
-
 // --- Tests
 
-
-test('setup', function (tt) {
-
-    tt.test('docker env', function (t) {
-        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        h.initDockerEnv(t, STATE, {}, function(err, accounts) {
             t.ifErr(err);
 
             ALICE = accounts.alice;
-            BOB   = accounts.bob;
+            BOB = accounts.bob;
 
             t.end();
         });
     });
 
-
-    tt.test('docker client init', function (t) {
-        vasync.parallel({ funcs: [
-            function createAliceJson(done) {
-                h.createDockerRemoteClient({user: ALICE},
-                    function (err, client) {
-                        t.ifErr(err, 'docker client init for alice');
-                        done(err, client);
+    tt.test('docker client init', function(t) {
+        vasync.parallel(
+            {
+                funcs: [
+                    function createAliceJson(done) {
+                        h.createDockerRemoteClient({user: ALICE}, function(
+                            err,
+                            client
+                        ) {
+                            t.ifErr(err, 'docker client init for alice');
+                            done(err, client);
+                        });
+                    },
+                    function createBobJson(done) {
+                        h.createDockerRemoteClient({user: BOB}, function(
+                            err,
+                            client
+                        ) {
+                            t.ifErr(err, 'docker client init for bob');
+                            return done(err, client);
+                        });
                     }
-                );
+                ]
             },
-            function createBobJson(done) {
-                h.createDockerRemoteClient({user: BOB},
-                    function (err, client) {
-                        t.ifErr(err, 'docker client init for bob');
-                        return done(err, client);
-                    }
-                );
+            function allDone(err, results) {
+                t.ifError(err, 'docker client init should be successful');
+                DOCKER_ALICE = results.operations[0].result;
+                DOCKER_BOB = results.operations[1].result;
+                t.end();
             }
-        ]}, function allDone(err, results) {
-            t.ifError(err, 'docker client init should be successful');
-            DOCKER_ALICE = results.operations[0].result;
-            DOCKER_BOB = results.operations[1].result;
-            t.end();
-        });
+        );
     });
 
-
-    tt.test('vmapi client init', function (t) {
-        h.createVmapiClient(function (err, client) {
+    tt.test('vmapi client init', function(t) {
+        h.createVmapiClient(function(err, client) {
             t.ifErr(err, 'vmapi client');
             VMAPI = client;
             t.end();
@@ -94,71 +94,74 @@ test('setup', function (tt) {
     });
 
     // init the napi client to create a fabric to test against.
-    tt.test('napi client init', function (t) {
-        h.createNapiClient(function (err, client) {
+    tt.test('napi client init', function(t) {
+        h.createNapiClient(function(err, client) {
             t.ifErr(err, 'napi client');
             NAPI = client;
             t.end();
         });
     });
 
-    tt.test('pull nginx image', function (t) {
-        h.ensureImage({
-            name: 'nginx:latest',
-            user: ALICE
-        }, function (err) {
-            t.error(err, 'should be no error pulling image');
-            t.end();
-        });
+    tt.test('pull nginx image', function(t) {
+        h.ensureImage(
+            {
+                name: 'nginx:latest',
+                user: ALICE
+            },
+            function(err) {
+                t.error(err, 'should be no error pulling image');
+                t.end();
+            }
+        );
     });
 });
 
-test('api: create with non-string label values (DOCKER-737)', function (t) {
+test('api: create with non-string label values (DOCKER-737)', function(t) {
     var payload = {
         // Boilerplate
-        'Hostname': '',
-        'Domainname': '',
-        'User': '',
-        'Memory': 0,
-        'MemorySwap': 0,
-        'CpuShares': 0,
-        'Cpuset': '',
-        'AttachStdin': false,
-        'AttachStdout': false,
-        'AttachStderr': false,
-        'PortSpecs': null,
-        'ExposedPorts': {},
-        'Tty': false,
-        'OpenStdin': false,
-        'StdinOnce': false,
-        'Env': [],
-        'Cmd': null,
-        'Image': 'nginx',
-        'Volumes': {},
-        'WorkingDir': '',
-        'Entrypoint': null,
-        'NetworkDisabled': false,
-        'OnBuild': null,
-        'SecurityOpt': null,
-        'HostConfig': {
-            'Binds': null,
-            'ContainerIDFile': '',
-            'LxcConf': [],
-            'Privileged': false,
-            'PortBindings': {},
-            'Links': null,
-            'PublishAllPorts': false,
-            'Dns': null,
-            'DnsSearch': null,
-            'ExtraHosts': null,
-            'VolumesFrom': null,
-            'Devices': [],
-            'NetworkMode': 'bridge',
-            'CapAdd': null,
-            'CapDrop': null,
-            'RestartPolicy': {
-                'Name': '',
-                'MaximumRetryCount': 0
+        Hostname: '',
+        Domainname: '',
+        User: '',
+        Memory: 0,
+        MemorySwap: 0,
+        CpuShares: 0,
+        Cpuset: '',
+        AttachStdin: false,
+        AttachStdout: false,
+        AttachStderr: false,
+        PortSpecs: null,
+        ExposedPorts: {},
+        Tty: false,
+        OpenStdin: false,
+        StdinOnce: false,
+        Env: [],
+        Cmd: null,
+        Image: 'nginx',
+        Volumes: {},
+        WorkingDir: '',
+        Entrypoint: null,
+        NetworkDisabled: false,
+        OnBuild: null,
+        SecurityOpt: null,
+        HostConfig: {
+            Binds: null,
+            ContainerIDFile: '',
+            LxcConf: [],
+            Privileged: false,
+            PortBindings: {},
+            Links: null,
+            PublishAllPorts: false,
+            Dns: null,
+            DnsSearch: null,
+            ExtraHosts: null,
+            VolumesFrom: null,
+            Devices: [],
+            NetworkMode: 'bridge',
+            CapAdd: null,
+            CapDrop: null,
+            RestartPolicy: {
+                Name: '',
+                MaximumRetryCount: 0
             }
         },
 
@@ -172,27 +175,31 @@ test('api: create with non-string label values (DOCKER-737)', function (t) {
     DOCKER_ALICE.post(
         '/' + apiVersion + '/containers/create',
         payload,
-        function (err, req, res) {
+        function(err, req, res) {
             t.ok(err, 'expect err from container create');
             /* JSSTYLED */
             var errRe = /^\(Validation\) invalid labels: label "foo" value is not a string: true; label "anum" value is not a string: 3.14/;
-            t.ok(errRe.exec(err.message), format('err.message matches %s: %j',
-                errRe, err.message));
+            t.ok(
+                errRe.exec(err.message),
+                format('err.message matches %s: %j', errRe, err.message)
+            );
             t.end();
-        });
+        }
+    );
 });
 
-
-test('api: create', function (tt) {
-
+test('api: create', function(tt) {
     var created;
 
-    tt.test('docker create', function (t) {
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t
-        }, oncreate);
+    tt.test('docker create', function(t) {
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             t.ifErr(err, 'create container');
@@ -201,7 +208,7 @@ test('api: create', function (tt) {
         }
     });
 
-    tt.test('docker rm', function (t) {
+    tt.test('docker rm', function(t) {
         DOCKER_ALICE.del('/containers/' + created.id, ondel);
 
         function ondel(err, res, req, body) {
@@ -210,25 +217,30 @@ test('api: create', function (tt) {
         }
     });
 
-    tt.test('docker create without approved_for_provisioning', function (t) {
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_BOB,
-            // we expect errors here, so stub this out
-            test: {
-                deepEqual: stub,
-                equal: stub,
-                error: stub,
-                ok: stub
-            }
-        }, oncreate);
+    tt.test('docker create without approved_for_provisioning', function(t) {
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_BOB,
+                // we expect errors here, so stub this out
+                test: {
+                    deepEqual: stub,
+                    equal: stub,
+                    error: stub,
+                    ok: stub
+                }
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             t.ok(err, 'should not create without approved_for_provisioning');
             t.equal(err.statusCode, 403);
 
-            var expected = BOB.login + ' does not have permission to pull or '
-                + 'provision';
+            var expected =
+                BOB.login +
+                ' does not have permission to pull or ' +
+                'provision';
             t.ok(err.message.match(expected));
 
             t.end();
@@ -237,24 +249,31 @@ test('api: create', function (tt) {
         function stub() {}
     });
 
-    tt.test('docker create without memory override', function (t) {
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t
-        }, oncreate);
+    tt.test('docker create without memory override', function(t) {
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             t.ifErr(err, 'create container');
             created = result;
-            t.equal(created.vm.ram, CONFIG.defaultMemory,
-                    'VM with default memory specs should be created with '
-                    + CONFIG.defaultMemory + ' MBs of RAM');
+            t.equal(
+                created.vm.ram,
+                CONFIG.defaultMemory,
+                'VM with default memory specs should be created with ' +
+                    CONFIG.defaultMemory +
+                    ' MBs of RAM'
+            );
             t.end();
         }
     });
 
-    tt.test('docker rm', function (t) {
+    tt.test('docker rm', function(t) {
         DOCKER_ALICE.del('/containers/' + created.id, ondel);
 
         function ondel(err, res, req, body) {
@@ -263,28 +282,33 @@ test('api: create', function (tt) {
         }
     });
 
-    tt.test('docker create with 2GB memory', function (t) {
+    tt.test('docker create with 2GB memory', function(t) {
         var MEMORY_IN_MBS = CONFIG.defaultMemory * 2;
         var memory = MEMORY_IN_MBS * BYTES_IN_MB;
 
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t,
-            extra: { 'HostConfig.Memory': memory }
-        }, oncreate);
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t,
+                extra: {'HostConfig.Memory': memory}
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             t.ifErr(err, 'create container');
             created = result;
-            t.equal(created.vm.ram, MEMORY_IN_MBS,
-                    'VM should be created with ' + MEMORY_IN_MBS
-                    + 'MBs of RAM');
+            t.equal(
+                created.vm.ram,
+                MEMORY_IN_MBS,
+                'VM should be created with ' + MEMORY_IN_MBS + 'MBs of RAM'
+            );
             t.end();
         }
     });
 
-    tt.test('docker rm', function (t) {
+    tt.test('docker rm', function(t) {
         DOCKER_ALICE.del('/containers/' + created.id, ondel);
 
         function ondel(err, res, req, body) {
@@ -293,26 +317,32 @@ test('api: create', function (tt) {
         }
     });
 
-    tt.test('docker create with invalid memory',
-            function (t) {
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t,
-            extra: { 'HostConfig.Memory': 'Foo' }
-        }, oncreate);
+    tt.test('docker create with invalid memory', function(t) {
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t,
+                extra: {'HostConfig.Memory': 'Foo'}
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             t.ifErr(err, 'create container');
             created = result;
-            t.equal(created.vm.ram, CONFIG.defaultMemory,
-                    'VM should be created with ' + CONFIG.defaultMemory
-                    + 'MBs of RAM');
+            t.equal(
+                created.vm.ram,
+                CONFIG.defaultMemory,
+                'VM should be created with ' +
+                    CONFIG.defaultMemory +
+                    'MBs of RAM'
+            );
             t.end();
         }
     });
 
-    tt.test('docker rm', function (t) {
+    tt.test('docker rm', function(t) {
         DOCKER_ALICE.del('/containers/' + created.id, ondel);
 
         function ondel(err, res, req, body) {
@@ -322,16 +352,18 @@ test('api: create', function (tt) {
     });
 });
 
-
-test('api: create with env var that has no value (DOCKER-741)', function (tt) {
-    tt.test('create empty-env-var container', function (t) {
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t,
-            extra: { 'Env': ['ENV_NO_VALUE'] },
-            start: true  // Will start the container after creating.
-        }, oncreate);
+test('api: create with env var that has no value (DOCKER-741)', function(tt) {
+    tt.test('create empty-env-var container', function(t) {
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t,
+                extra: {Env: ['ENV_NO_VALUE']},
+                start: true // Will start the container after creating.
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             t.ifErr(err, 'create empty-env-var container');
@@ -346,26 +378,27 @@ test('api: create with env var that has no value (DOCKER-741)', function (tt) {
     });
 });
 
-test('ensure fabrics enabled', function (tt) {
-    tt.test('fabric configuration', function (t) {
+test('ensure fabrics enabled', function(tt) {
+    tt.test('fabric configuration', function(t) {
         var listOpts = {};
         var listParams = {};
-        NAPI.listFabricVLANs(ALICE.account.uuid, listOpts, listParams,
-            function (err, vlans) {
-                if (err) {
-                    FABRICS = false;
-                    if (err.restCode !== 'PreconditionRequiredError') {
-                        t.ifErr(err);
-                    }
-                } else {
-                    FABRICS = true;
+        NAPI.listFabricVLANs(ALICE.account.uuid, listOpts, listParams, function(
+            err,
+            vlans
+        ) {
+            if (err) {
+                FABRICS = false;
+                if (err.restCode !== 'PreconditionRequiredError') {
+                    t.ifErr(err);
                 }
-                t.end();
+            } else {
+                FABRICS = true;
+            }
+            t.end();
         });
     });
 });
 
-
 /*
  * Tests for `docker run --net`
  *
@@ -385,7 +418,7 @@ test('ensure fabrics enabled', function (tt) {
  * - delete fabric networks
  * - delete fabric vlan
  */
-test('create with NetworkMode (docker run --net=)', function (tt) {
+test('create with NetworkMode (docker run --net=)', function(tt) {
     // set fabric status
 
     var fVlan;
@@ -399,15 +432,18 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         return;
     }
 
-    tt.test('fabric vlan setup', function (t) {
+    tt.test('fabric vlan setup', function(t) {
         // create a new one.
         var fabricParams = {
             name: 'sdcdockertest_apicreate_vlan4',
             description: 'integration test fixture',
             vlan_id: 4
         };
-        h.getOrCreateFabricVLAN(NAPI, ALICE.account.uuid, fabricParams,
-            function (err, vlan) {
+        h.getOrCreateFabricVLAN(
+            NAPI,
+            ALICE.account.uuid,
+            fabricParams,
+            function(err, vlan) {
                 t.ifErr(err, 'create fabric vlan');
                 fVlan = vlan;
                 t.end();
@@ -416,7 +452,7 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         );
     });
 
-    tt.test('fabric network setup', function (t) {
+    tt.test('fabric network setup', function(t) {
         var nw1uuid = libuuid.create();
 
         // nw2's name is deliberately ambiguous with a short version of nw1's
@@ -457,54 +493,75 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
             resolvers: ['8.8.8.8', '8.8.4.4']
         };
 
-        vasync.pipeline({
-            funcs: [
-                function fnw1(_, cb) {
-                    h.getOrCreateFabricNetwork(NAPI, ALICE.account.uuid,
-                        fVlan.vlan_id, nw1params, function (err, network) {
-                            if (err) {
-                                return cb(err);
+        vasync.pipeline(
+            {
+                funcs: [
+                    function fnw1(_, cb) {
+                        h.getOrCreateFabricNetwork(
+                            NAPI,
+                            ALICE.account.uuid,
+                            fVlan.vlan_id,
+                            nw1params,
+                            function(err, network) {
+                                if (err) {
+                                    return cb(err);
+                                }
+                                nw2params.name = network.uuid
+                                    .replace(/-/g, '')
+                                    .substr(0, 12);
+                                nw3params.name = (network.uuid +
+                                    network.uuid).replace(/-/g, '');
+                                return cb(null, network);
                             }
-                            nw2params.name =
-                                network.uuid.replace(/-/g, '').substr(0, 12);
-                            nw3params.name = (network.uuid + network.uuid)
-                                .replace(/-/g, '');
-                            return cb(null, network);
-                        }
-                    );
-                },
-                function fnw2(_, cb) {
-                    h.getOrCreateFabricNetwork(NAPI, ALICE.account.uuid,
-                        fVlan.vlan_id, nw2params, cb);
-                },
-                function fnw3(_, cb) {
-                    h.getOrCreateFabricNetwork(NAPI, ALICE.account.uuid,
-                        fVlan.vlan_id, nw3params, cb);
+                        );
+                    },
+                    function fnw2(_, cb) {
+                        h.getOrCreateFabricNetwork(
+                            NAPI,
+                            ALICE.account.uuid,
+                            fVlan.vlan_id,
+                            nw2params,
+                            cb
+                        );
+                    },
+                    function fnw3(_, cb) {
+                        h.getOrCreateFabricNetwork(
+                            NAPI,
+                            ALICE.account.uuid,
+                            fVlan.vlan_id,
+                            nw3params,
+                            cb
+                        );
+                    }
+                ]
+            },
+            function(err, results) {
+                t.ifErr(err, 'create networks');
+                if (err) {
+                    t.end();
+                    return;
                 }
-            ]
-        }, function (err, results) {
-            t.ifErr(err, 'create networks');
-            if (err) {
+                fNetwork1 = results.operations[0].result;
+                fNetwork2 = results.operations[1].result;
+                fNetwork3 = results.operations[2].result;
+
                 t.end();
-                return;
             }
-            fNetwork1 = results.operations[0].result;
-            fNetwork2 = results.operations[1].result;
-            fNetwork3 = results.operations[2].result;
-
-            t.end();
-        });
+        );
     });
 
     // attempt a create with a name.
-    tt.test('create with a network name', function (t) {
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t,
-            extra: { 'HostConfig.NetworkMode': fNetwork1.name },
-            start: true
-        }, oncreate);
+    tt.test('create with a network name', function(t) {
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t,
+                extra: {'HostConfig.NetworkMode': fNetwork1.name},
+                start: true
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             t.ifErr(err, 'create NetworkMode: networkName');
@@ -519,16 +576,19 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         }
     });
 
-    tt.test('create with a complete network id', function (t) {
+    tt.test('create with a complete network id', function(t) {
         var fullId = (fNetwork1.uuid + fNetwork1.uuid).replace(/-/g, '');
 
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t,
-            extra: { 'HostConfig.NetworkMode': fullId },
-            start: true
-        }, oncreate);
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t,
+                extra: {'HostConfig.NetworkMode': fullId},
+                start: true
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             var nics = result.vm.nics;
@@ -543,17 +603,20 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         }
     });
 
-    tt.test('create with partial network id', function (t) {
+    tt.test('create with partial network id', function(t) {
         var partialId = (fNetwork1.uuid + fNetwork1.uuid).replace(/-/g, '');
         partialId = partialId.substr(0, 10);
 
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t,
-            extra: { 'HostConfig.NetworkMode': partialId },
-            start: true
-        }, oncreate);
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t,
+                extra: {'HostConfig.NetworkMode': partialId},
+                start: true
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             var nics = result.vm.nics;
@@ -568,16 +631,19 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         }
     });
 
-    tt.test('prefer name over partial id', function (t) {
+    tt.test('prefer name over partial id', function(t) {
         // fNetwork2 is named using a partial id from fNetwork1.
 
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t,
-            extra: { 'HostConfig.NetworkMode': fNetwork2.name },
-            start: true
-        }, oncreate);
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t,
+                extra: {'HostConfig.NetworkMode': fNetwork2.name},
+                start: true
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             var nics = result.vm.nics;
@@ -592,16 +658,19 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
         }
     });
 
-    tt.test('prefer full id over name', function (t) {
+    tt.test('prefer full id over name', function(t) {
         // fNetwork3 is named with the full dockerId of fNetwork1.
 
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t,
-            extra: { 'HostConfig.NetworkMode': fNetwork3.name },
-            start: true
-        }, oncreate);
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t,
+                extra: {'HostConfig.NetworkMode': fNetwork3.name},
+                start: true
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             var nics = result.vm.nics;
@@ -614,18 +683,20 @@ test('create with NetworkMode (docker run --net=)', function (tt) {
             t.ifErr(err, 'delete network testing container');
             t.end();
         }
-
     });
 
-    tt.test('create with a network that doesn\'t exist', function (t) {
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER_ALICE,
-            test: t,
-            extra: { 'HostConfig.NetworkMode': 'netmodefoobar' },
-            expectedErr: '(Error) network netmodefoobar not found',
-            start: true
-        }, oncreate);
+    tt.test("create with a network that doesn't exist", function(t) {
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER_ALICE,
+                test: t,
+                extra: {'HostConfig.NetworkMode': 'netmodefoobar'},
+                expectedErr: '(Error) network netmodefoobar not found',
+                start: true
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             t.ok(err, 'should err on create');
diff --git a/test/integration/api-images.test.js b/test/integration/api-images.test.js
index a27aec1..6ca96bf 100644
--- a/test/integration/api-images.test.js
+++ b/test/integration/api-images.test.js
@@ -19,8 +19,6 @@ var util = require('util');
 
 var h = require('./helpers');
 
-
-
 // --- Globals
 
 var ALICE;
@@ -31,30 +29,26 @@ var STATE = {
     log: require('../lib/log')
 };
 
-
 // --- Tests
 
-
-test('setup', function (tt) {
-
-    tt.test('docker env', function (t) {
-        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        h.initDockerEnv(t, STATE, {}, function(err, accounts) {
             t.ifErr(err);
 
             ALICE = accounts.alice;
-            BOB   = accounts.bob;
+            BOB = accounts.bob;
 
             t.end();
         });
     });
 
-
-    tt.test('docker client init', function (t) {
-        h.createDockerRemoteClient({user: ALICE}, function (err, client) {
+    tt.test('docker client init', function(t) {
+        h.createDockerRemoteClient({user: ALICE}, function(err, client) {
             t.ifErr(err, 'docker client init');
             DOCKER_ALICE = client;
 
-            h.createDockerRemoteClient({user: BOB}, function (err2, client2) {
+            h.createDockerRemoteClient({user: BOB}, function(err2, client2) {
                 t.ifErr(err2, 'docker client init for bob');
                 DOCKER_BOB = client2;
 
@@ -62,62 +56,59 @@ test('setup', function (tt) {
             });
         });
     });
-
 });
 
-
-test('docker images', function (tt) {
-
-    tt.test('list images', function (t) {
-        DOCKER_ALICE.get('/images/json',
-                function (err, req, res, images) {
+test('docker images', function(tt) {
+    tt.test('list images', function(t) {
+        DOCKER_ALICE.get('/images/json', function(err, req, res, images) {
             t.ok(images, 'images array');
             t.end();
         });
     });
 
-
-    tt.test('pull ubuntu image', function (t) {
-        h.ensureImage({
-            name: 'ubuntu:latest',
-            user: ALICE
-        }, function (err) {
-            console.log('ubuntu pull err: ', err);
-            t.error(err, 'should be no error pulling image');
-            t.end();
-        });
+    tt.test('pull ubuntu image', function(t) {
+        h.ensureImage(
+            {
+                name: 'ubuntu:latest',
+                user: ALICE
+            },
+            function(err) {
+                console.log('ubuntu pull err: ', err);
+                t.error(err, 'should be no error pulling image');
+                t.end();
+            }
+        );
     });
 
-
-    tt.test('ensure ubuntu image is in the list', function (t) {
-        DOCKER_ALICE.get('/images/json',
-                function (err, req, res, images) {
+    tt.test('ensure ubuntu image is in the list', function(t) {
+        DOCKER_ALICE.get('/images/json', function(err, req, res, images) {
             t.error(err, 'should be no error retrieving images');
             t.ok(images.length, 'images array should not be empty');
-            t.ok(images.map(function (image) {
-                return -1 !== image.RepoTags.indexOf('ubuntu:latest');
-            }).length, 'should be able to find image');
+            t.ok(
+                images.map(function(image) {
+                    return -1 !== image.RepoTags.indexOf('ubuntu:latest');
+                }).length,
+                'should be able to find image'
+            );
 
             t.end();
         });
     });
 
-
     // Ensure an image can be inspected when the name is uri decoded/encoded.
-    tt.test('inspect ubuntu image', function (t) {
+    tt.test('inspect ubuntu image', function(t) {
         var url = '/images/ubuntu:latest/json';
-        DOCKER_ALICE.get(url, function (err, req, res) {
+        DOCKER_ALICE.get(url, function(err, req, res) {
             t.error(err, 'get ubuntu:latest image');
             url = url.replace(':', '%3A');
-            DOCKER_ALICE.get(url, function (err2, req2, res2) {
+            DOCKER_ALICE.get(url, function(err2, req2, res2) {
                 t.error(err2, 'get encoded ubuntu%3Alatest image');
                 t.end();
             });
         });
     });
 
-
-    tt.test('delete image', function (t) {
+    tt.test('delete image', function(t) {
         DOCKER_ALICE.del('/images/ubuntu', ondel);
         function ondel(err, req, res) {
             t.error(err, 'should be no error retrieving images');
@@ -125,38 +116,40 @@ test('docker images', function (tt) {
         }
     });
 
-
-    tt.test('ensure image is gone', function (t) {
-        DOCKER_ALICE.get('/images/json',
-                function (err, req, res, images) {
+    tt.test('ensure image is gone', function(t) {
+        DOCKER_ALICE.get('/images/json', function(err, req, res, images) {
             t.error(err, 'should be no error retrieving images');
 
             t.ok(images, 'images array');
-            var found = images.map(function (image) {
+            var found = images.map(function(image) {
                 return -1 !== image.RepoTags.indexOf('ubuntu:latest');
             });
 
             t.deepEqual(
-                found.filter(function (i) { return i; }),
+                found.filter(function(i) {
+                    return i;
+                }),
                 [],
-                'ubuntu image should have been deleted');
+                'ubuntu image should have been deleted'
+            );
             t.end();
         });
     });
 
-    tt.test('pull image without approved_for_provisioning', function (t) {
+    tt.test('pull image without approved_for_provisioning', function(t) {
         var url = '/images/create?fromImage=ubuntu%3Alatest';
-        DOCKER_BOB.post(url, function (err, req, res) {
+        DOCKER_BOB.post(url, function(err, req, res) {
             t.ok(err, 'should not pull without approved_for_provisioning');
 
             t.equal(err.statusCode, 403);
 
-            var expected = BOB.login + ' does not have permission to pull or '
-                + 'provision';
+            var expected =
+                BOB.login +
+                ' does not have permission to pull or ' +
+                'provision';
             t.ok(err.message.match(expected));
 
             t.end();
         });
     });
-
 });
diff --git a/test/integration/api-info.test.js b/test/integration/api-info.test.js
index a029dce..0c8f267 100644
--- a/test/integration/api-info.test.js
+++ b/test/integration/api-info.test.js
@@ -20,8 +20,6 @@ var vasync = require('vasync');
 
 var h = require('./helpers');
 
-
-
 // --- Globals
 
 var ALICE;
@@ -30,14 +28,14 @@ var STATE = {
     log: require('../lib/log')
 };
 
-
 // --- Tests
 
-
-test('setup', function (tt) {
-    tt.test('docker env', function (t) {
-        h.getDockerEnv(t, STATE, {account: 'sdcdockertest_alice'},
-                function (err, env) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        h.getDockerEnv(t, STATE, {account: 'sdcdockertest_alice'}, function(
+            err,
+            env
+        ) {
             t.ifErr(err, 'docker env: alice');
             t.ok(env, 'have a DockerEnv for alice');
             ALICE = env;
@@ -47,9 +45,8 @@ test('setup', function (tt) {
         });
     });
 
-
-    tt.test('client init', function (t) {
-        h.createDockerRemoteClient({user: ALICE}, function (err, client) {
+    tt.test('client init', function(t) {
+        h.createDockerRemoteClient({user: ALICE}, function(err, client) {
             t.ifErr(err, 'docker client init');
             CLIENT = client;
             t.end();
@@ -57,18 +54,16 @@ test('setup', function (tt) {
     });
 });
 
-
-test('api: info', function (tt) {
-    tt.test('/info', function (t) {
-        CLIENT.get('/info', function (err, res, req, body) {
+test('api: info', function(tt) {
+    tt.test('/info', function(t) {
+        CLIENT.get('/info', function(err, res, req, body) {
             h.assertInfo(t, body);
             t.end();
         });
     });
 
-
-    tt.test('/info', function (t) {
-        CLIENT.get('/info', function (err, res, req, body) {
+    tt.test('/info', function(t) {
+        CLIENT.get('/info', function(err, res, req, body) {
             h.assertInfo(t, body);
             t.end();
         });
diff --git a/test/integration/api-invalid.test.js b/test/integration/api-invalid.test.js
index 6d82d54..baef3b5 100644
--- a/test/integration/api-invalid.test.js
+++ b/test/integration/api-invalid.test.js
@@ -18,8 +18,6 @@ var vasync = require('vasync');
 
 var h = require('./helpers');
 
-
-
 // --- Globals
 
 var ALICE;
@@ -35,21 +33,22 @@ var STATE = {
 };
 var STR = {
     portNum: '(Validation) HostConfig.PortBindings: invalid port number',
-    portSpec:
-        '(Validation) HostConfig.PortBindings: port specification incorrect: '
-        + 'must be "number/protocol"',
-    proto: '(Validation) HostConfig.PortBindings: unknown protocol: '
-        + 'must be tcp or udp',
-    tcp: fmt('publish port: only support exposing %d TCP ports',
-        constants.MAX_EXPOSED_PORTS),
-    udp: fmt('publish port: only support exposing %d UDP ports',
-        constants.MAX_EXPOSED_PORTS)
+    portSpec: '(Validation) HostConfig.PortBindings: port specification incorrect: ' +
+        'must be "number/protocol"',
+    proto: '(Validation) HostConfig.PortBindings: unknown protocol: ' +
+        'must be tcp or udp',
+    tcp: fmt(
+        'publish port: only support exposing %d TCP ports',
+        constants.MAX_EXPOSED_PORTS
+    ),
+    udp: fmt(
+        'publish port: only support exposing %d UDP ports',
+        constants.MAX_EXPOSED_PORTS
+    )
 };
 
-
 // --- Helpers
 
-
 /**
  * Generate a HostConfig.PortBindings property with the maximum number of
  * ports + 1
@@ -61,17 +60,17 @@ function maxPorts(proto) {
         ports[(30 + i).toString() + '/' + proto] = {};
     }
 
-    return [ ports ];
+    return [ports];
 }
 
-
 // --- Tests
 
-test('setup', function (tt) {
-
-    tt.test('docker env', function (t) {
-        h.getDockerEnv(t, STATE, {account: 'sdcdockertest_alice'},
-                function (err, env) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        h.getDockerEnv(t, STATE, {account: 'sdcdockertest_alice'}, function(
+            err,
+            env
+        ) {
             t.ifErr(err, 'docker env: alice');
             t.ok(env, 'have a DockerEnv for alice');
             ALICE = env;
@@ -80,86 +79,87 @@ test('setup', function (tt) {
         });
     });
 
-
-    tt.test('vmapi client', function (t) {
-        h.createVmapiClient(function (err, client) {
+    tt.test('vmapi client', function(t) {
+        h.createVmapiClient(function(err, client) {
             t.error(err, 'vmapi client err');
             CLIENTS.vmapi = client;
             return t.end();
         });
     });
 
-
-    tt.test('docker client', function (t) {
-        h.createDockerRemoteClient({user: ALICE}, function (err, client) {
+    tt.test('docker client', function(t) {
+        h.createDockerRemoteClient({user: ALICE}, function(err, client) {
             t.error(err, 'docker client err');
             CLIENTS.docker = client;
             return t.end();
         });
     });
-
 });
 
-
-test('create', function (t) {
+test('create', function(t) {
     var invalid = [
         {
             prop: 'Image',
             err: fmt(FMT.str, 'Image'),
-            inputs: [ null, 1, [], {} ]
+            inputs: [null, 1, [], {}]
         },
         {
             prop: 'Name',
             err: fmt(FMT.str, 'Name'),
-            inputs: [ 1, [], {} ]
+            inputs: [1, [], {}]
         },
         {
             prop: 'Cmd',
             err: fmt(FMT.arrayOfStr, 'Cmd'),
-            inputs: [ 'asdf', 1, {}, [ 1 ], [ 'asdf', {} ] ]
+            inputs: ['asdf', 1, {}, [1], ['asdf', {}]]
         },
         {
             prop: 'Env',
             err: fmt(FMT.arrayOfStr, 'Env'),
-            inputs: [ 'asdf', 1, {}, [ 1 ], [ 'asdf', {} ] ]
+            inputs: ['asdf', 1, {}, [1], ['asdf', {}]]
         },
         {
             prop: 'Entrypoint',
             err: fmt(FMT.arrayOfStr, 'Entrypoint'),
-            inputs: [ 'asdf', 1, {}, [ 1 ], [ 'asdf', {} ] ]
+            inputs: ['asdf', 1, {}, [1], ['asdf', {}]]
         },
         {
             prop: 'HostConfig',
             err: fmt(FMT.obj, 'HostConfig'),
-            inputs: [ 'asdf', 1, [], [ 1 ], [ 'asdf', {} ] ]
+            inputs: ['asdf', 1, [], [1], ['asdf', {}]]
         },
         {
             prop: 'HostConfig.PublishAllPorts',
             err: fmt(FMT.bool, 'HostConfig.PublishAllPorts'),
-            inputs: [ 'asdf', 1, [], {} ]
+            inputs: ['asdf', 1, [], {}]
         },
         {
             prop: 'HostConfig.PortBindings',
             err: fmt(FMT.obj, 'HostConfig.PortBindings'),
-            inputs: [ 'asdf', 1, [] ]
+            inputs: ['asdf', 1, []]
         },
 
         // PortBindings with invalid port formats
         {
             prop: 'HostConfig.PortBindings',
             err: STR.portSpec,
-            inputs: [ { 'foo': {} } ]
+            inputs: [{foo: {}}]
         },
         {
             prop: 'HostConfig.PortBindings',
             err: STR.portNum,
-            inputs: [ { 'a/foo': {} }, { '0/udp': {} }, { '-1/udp': {} },
-                { 'a/tcp': {} }, { '65536/tcp': {} } ]
+            inputs: [
+                {'a/foo': {}},
+                {'0/udp': {}},
+                {'-1/udp': {}},
+                {'a/tcp': {}},
+                {'65536/tcp': {}}
+            ]
         },
         {
             prop: 'HostConfig.PortBindings',
             err: STR.proto,
-            inputs: [ { '32/foo': {} } ]
+            inputs: [{'32/foo': {}}]
         },
 
         // Too many ports (not to be confused with "too many cooks")
@@ -175,7 +175,6 @@ test('create', function (t) {
         }
     ];
 
-
     function createInvalid(params, expErr, t2) {
         var arg = {
             dockerClient: CLIENTS.docker,
@@ -190,12 +189,14 @@ test('create', function (t) {
         });
     }
 
-    invalid.forEach(function (item) {
-        item.inputs.forEach(function (val) {
+    invalid.forEach(function(item) {
+        item.inputs.forEach(function(val) {
             var params = {};
             params[item.prop] = val;
-            t.test(item.prop + '=' + JSON.stringify(val),
-                createInvalid.bind(null, params, item.err));
+            t.test(
+                item.prop + '=' + JSON.stringify(val),
+                createInvalid.bind(null, params, item.err)
+            );
         });
     });
 });
diff --git a/test/integration/api-start-stop.test.js b/test/integration/api-start-stop.test.js
index e8d4163..a9b2f15 100644
--- a/test/integration/api-start-stop.test.js
+++ b/test/integration/api-start-stop.test.js
@@ -21,8 +21,6 @@ var vasync = require('vasync');
 
 var h = require('./helpers');
 
-
-
 // --- Globals
 
 var ALICE;
@@ -32,15 +30,14 @@ var STATE = {
 };
 var VMAPI;
 
-
 // --- Tests
 
-
-test('setup', function (tt) {
-
-    tt.test('docker env', function (t) {
-        h.getDockerEnv(t, STATE, {account: 'sdcdockertest_alice'},
-                function (err, env) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        h.getDockerEnv(t, STATE, {account: 'sdcdockertest_alice'}, function(
+            err,
+            env
+        ) {
             t.ifErr(err, 'docker env: alice');
             t.ok(env, 'have a DockerEnv for alice');
             ALICE = env;
@@ -49,37 +46,35 @@ test('setup', function (tt) {
         });
     });
 
-
-    tt.test('docker client init', function (t) {
-        h.createDockerRemoteClient({user: ALICE}, function (err, client) {
+    tt.test('docker client init', function(t) {
+        h.createDockerRemoteClient({user: ALICE}, function(err, client) {
             t.ifErr(err, 'docker client init');
             DOCKER = client;
             t.end();
         });
     });
 
-
-    tt.test('vmapi client init', function (t) {
-        h.createVmapiClient(function (err, client) {
+    tt.test('vmapi client init', function(t) {
+        h.createVmapiClient(function(err, client) {
             t.ifErr(err, 'vmapi client');
             VMAPI = client;
             t.end();
         });
     });
-
 });
 
-
-test('api: create', function (tt) {
-
+test('api: create', function(tt) {
     var id;
 
-    tt.test('docker create', function (t) {
-        h.createDockerContainer({
-            vmapiClient: VMAPI,
-            dockerClient: DOCKER,
-            test: t
-        }, oncreate);
+    tt.test('docker create', function(t) {
+        h.createDockerContainer(
+            {
+                vmapiClient: VMAPI,
+                dockerClient: DOCKER,
+                test: t
+            },
+            oncreate
+        );
 
         function oncreate(err, result) {
             t.ifErr(err, 'create container');
@@ -88,8 +83,7 @@ test('api: create', function (tt) {
         }
     });
 
-
-    tt.test('start container', function (t) {
+    tt.test('start container', function(t) {
         // Attempt to start new container
         DOCKER.post('/containers/' + id + '/start', onpost);
         function onpost(err, res, req, body) {
@@ -98,35 +92,36 @@ test('api: create', function (tt) {
         }
     });
 
-
-    tt.test('confirm container started', function (t) {
-        h.listContainers({
-            all: true,
-            dockerClient: DOCKER,
-            test: t
-        }, function (err, containers) {
-            t.error(err);
-
-            var found = containers.filter(function (c) {
-                if (c.Id === id) {
-                    return true;
+    tt.test('confirm container started', function(t) {
+        h.listContainers(
+            {
+                all: true,
+                dockerClient: DOCKER,
+                test: t
+            },
+            function(err, containers) {
+                t.error(err);
+
+                var found = containers.filter(function(c) {
+                    if (c.Id === id) {
+                        return true;
+                    }
+                });
+
+                t.equal(found.length, 1, 'found our container');
+
+                var matched = found[0].Status.match(/^Up /);
+                t.ok(matched, 'container is started');
+                if (!matched) {
+                    t.equal(found[0].Status, 'Status for debugging');
                 }
-            });
-
-            t.equal(found.length, 1, 'found our container');
 
-            var matched = found[0].Status.match(/^Up /);
-            t.ok(matched, 'container is started');
-            if (!matched) {
-                t.equal(found[0].Status, 'Status for debugging');
+                t.end();
             }
-
-            t.end();
-        });
+        );
     });
 
-
-    tt.test('stop container', function (t) {
+    tt.test('stop container', function(t) {
         // Attempt to stop new container
         DOCKER.post('/containers/' + id + '/stop', onpost);
         function onpost(err, res, req, body) {
@@ -135,33 +130,34 @@ test('api: create', function (tt) {
         }
     });
 
-
-    tt.test('confirm container stopped', function (t) {
-        h.listContainers({
-            all: true,
-            dockerClient: DOCKER,
-            test: t
-        }, function (err, containers) {
-            t.error(err);
-
-            var found = containers.filter(function (c) {
-                if (c.Id === id) {
-                    return true;
+    tt.test('confirm container stopped', function(t) {
+        h.listContainers(
+            {
+                all: true,
+                dockerClient: DOCKER,
+                test: t
+            },
+            function(err, containers) {
+                t.error(err);
+
+                var found = containers.filter(function(c) {
+                    if (c.Id === id) {
+                        return true;
+                    }
+                });
+
+                var matched = found[0].Status.match(/^Exited /);
+                t.ok(matched, 'container is stopped');
+                if (!matched) {
+                    t.equal(found[0].Status, 'Status for debugging');
                 }
-            });
 
-            var matched = found[0].Status.match(/^Exited /);
-            t.ok(matched, 'container is stopped');
-            if (!matched) {
-                t.equal(found[0].Status, 'Status for debugging');
+                t.end();
             }
-
-            t.end();
-        });
+        );
     });
 
-
-    tt.test('delete container', function (t) {
+    tt.test('delete container', function(t) {
         DOCKER.del('/containers/' + id, ondel);
 
         function ondel(err, res, req, body) {
@@ -169,8 +165,4 @@ test('api: create', function (tt) {
             t.end();
         }
     });
-
-
-
-
 });
diff --git a/test/integration/apiversion.test.js b/test/integration/apiversion.test.js
index d0c67a4..06fe55c 100644
--- a/test/integration/apiversion.test.js
+++ b/test/integration/apiversion.test.js
@@ -16,51 +16,44 @@ var constants = require('../../lib/constants');
 var h = require('./helpers');
 var test = require('tape');
 
-
-
 // --- Globals
 
-
 var DOCKER_ALICE;
 var STATE = {
     log: require('../lib/log')
 };
 
-
 // --- Tests
 
-
-test('setup', function (tt) {
-
-    tt.test('docker env', function (t) {
-        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        h.initDockerEnv(t, STATE, {}, function(err, accounts) {
             t.ifErr(err);
-            h.createDockerRemoteClient({user: accounts.alice},
-                function (err2, client) {
-                    t.ifErr(err2, 'docker client init');
-                    DOCKER_ALICE = client;
-                    t.end();
-                }
-            );
+            h.createDockerRemoteClient({user: accounts.alice}, function(
+                err2,
+                client
+            ) {
+                t.ifErr(err2, 'docker client init');
+                DOCKER_ALICE = client;
+                t.end();
+            });
         });
     });
 
     //tt.test('DockerEnv: alice init', cli.init);
 });
 
-test('apiversion', function (tt) {
-
+test('apiversion', function(tt) {
     function testVersionHandling(apiversion, opts) {
-        var verPrefix = apiversion ? ('/' + apiversion) : '';
+        var verPrefix = apiversion ? '/' + apiversion : '';
         var infoPath = verPrefix + '/info';
         var containersPath = verPrefix + '/containers/json';
         var imagesPath = verPrefix + '/images/json';
         var versionPath = verPrefix + '/version';
 
-        tt.test('apiversion ' + infoPath, function (t) {
+        tt.test('apiversion ' + infoPath, function(t) {
             // docker info
-            DOCKER_ALICE.get(infoPath,
-                    function (err, req, res, info) {
+            DOCKER_ALICE.get(infoPath, function(err, req, res, info) {
                 if (opts && opts.shouldFail) {
                     t.ok(err, 'expected request to fail');
                     t.end();
@@ -72,10 +65,14 @@ test('apiversion', function (tt) {
             });
         });
 
-        tt.test('apiversion ' + containersPath, function (t) {
+        tt.test('apiversion ' + containersPath, function(t) {
             // docker ps
-            DOCKER_ALICE.get(containersPath,
-                    function (err, req, res, containers) {
+            DOCKER_ALICE.get(containersPath, function(
+                err,
+                req,
+                res,
+                containers
+            ) {
                 if (opts && opts.shouldFail) {
                     t.ok(err, 'expected request to fail');
                     t.end();
@@ -87,10 +84,9 @@ test('apiversion', function (tt) {
             });
         });
 
-        tt.test('apiversion ' + imagesPath, function (t) {
+        tt.test('apiversion ' + imagesPath, function(t) {
             // docker images
-            DOCKER_ALICE.get(imagesPath,
-                    function (err, req, res, images) {
+            DOCKER_ALICE.get(imagesPath, function(err, req, res, images) {
                 if (opts && opts.shouldFail) {
                     t.ok(err, 'expected request to fail');
                     t.end();
@@ -102,10 +98,9 @@ test('apiversion', function (tt) {
             });
         });
 
-        tt.test('apiversion ' + versionPath, function (t) {
+        tt.test('apiversion ' + versionPath, function(t) {
             // docker version
-            DOCKER_ALICE.get(versionPath,
-                    function (err, req, res, verInfo) {
+            DOCKER_ALICE.get(versionPath, function(err, req, res, verInfo) {
                 if (opts && opts.shouldFail) {
                     t.ok(err, 'expected request to fail');
                     t.end();
@@ -118,12 +113,12 @@ test('apiversion', function (tt) {
         });
     }
 
-    testVersionHandling();        // no version
-    testVersionHandling('v1.14', { shouldFail: true }); // unsupported version
-    testVersionHandling('v1.19', { shouldFail: true }); // unsupported version
+    testVersionHandling(); // no version
+    testVersionHandling('v1.14', {shouldFail: true}); // unsupported version
+    testVersionHandling('v1.19', {shouldFail: true}); // unsupported version
     testVersionHandling('v' + constants.MIN_API_VERSION); // min ver
     testVersionHandling('v' + constants.API_VERSION); // current ver
     testVersionHandling('v9.99'); // future version
-    testVersionHandling('1.14', { shouldFail: true });   // invalid version
-    testVersionHandling('golden', { shouldFail: true }); // invalid version
+    testVersionHandling('1.14', {shouldFail: true}); // invalid version
+    testVersionHandling('golden', {shouldFail: true}); // invalid version
 });
diff --git a/test/integration/cli-affinity.test.js b/test/integration/cli-affinity.test.js
index 7b44222..7c2c47f 100644
--- a/test/integration/cli-affinity.test.js
+++ b/test/integration/cli-affinity.test.js
@@ -21,79 +21,108 @@ var vasync = require('vasync');
 var cli = require('../lib/cli');
 var vm = require('../lib/vm');
 
-
 // --- Globals
 
 var CONTAINER_PREFIX = 'sdcdockertest_affinity_';
 
-
 // --- Tests
 
-test('setup', function (tt) {
+test('setup', function(tt) {
     tt.test('  test CLI init', cli.init);
     tt.test('  vmapi client init', vm.init);
 });
 
-
-test('affinities a la Swarm', function (tt) {
+test('affinities a la Swarm', function(tt) {
     // This should fail: no container with name 'sdcdockertest_affinity_*'.
-    tt.test('  docker run -e "affinity:container==' + CONTAINER_PREFIX
-            + '*" ... (container, ==, fail)', function (t) {
-        var containerName = CONTAINER_PREFIX + libuuid.create().split('-')[0];
-        t.ok(containerName, 'containerName: ' + containerName);
-        var args = format('-e \'affinity:container==' + CONTAINER_PREFIX
-            + '*\' -d --name %s alpine sleep 3600', containerName);
-        cli.run(t, {
-            args: args,
-            // JSSTYLED
-            expectedErr: /\(ResourceNotFound\) no active containers found matching "sdcdockertest_affinity_\*" for affinity "container==sdcdockertest_affinity_\*"/
-        }, function (err) {
-            t.end();
-        });
-    });
+    tt.test(
+        '  docker run -e "affinity:container==' +
+            CONTAINER_PREFIX +
+            '*" ... (container, ==, fail)',
+        function(t) {
+            var containerName =
+                CONTAINER_PREFIX + libuuid.create().split('-')[0];
+            t.ok(containerName, 'containerName: ' + containerName);
+            var args = format(
+                "-e 'affinity:container==" +
+                    CONTAINER_PREFIX +
+                    "*' -d --name %s alpine sleep 3600",
+                containerName
+            );
+            cli.run(
+                t,
+                {
+                    args: args,
+                    // JSSTYLED
+                    expectedErr: /\(ResourceNotFound\) no active containers found matching "sdcdockertest_affinity_\*" for affinity "container==sdcdockertest_affinity_\*"/
+                },
+                function(err) {
+                    t.end();
+                }
+            );
+        }
+    );
 
     // This should work: no container with name 'sdcdockertest_affinity_*'.
     // This behaviour was changed in DAPI-306.
-    tt.test('  docker run -e "affinity:container!=' + CONTAINER_PREFIX
-            + '*" ... (container, !=)', function (t) {
-        var containerName = CONTAINER_PREFIX + libuuid.create().split('-')[0];
-        t.ok(containerName, 'containerName: ' + containerName);
-        var args = format('-e \'affinity:container!=' + CONTAINER_PREFIX
-            + '*\' -d --name %s alpine sleep 3600', containerName);
-        cli.run(t, {args: args}, function (err, id) {
-            t.ifErr(err, 'docker run error');
-            t.ok(id, 'id');
-            t.end();
-        });
-    });
+    tt.test(
+        '  docker run -e "affinity:container!=' +
+            CONTAINER_PREFIX +
+            '*" ... (container, !=)',
+        function(t) {
+            var containerName =
+                CONTAINER_PREFIX + libuuid.create().split('-')[0];
+            t.ok(containerName, 'containerName: ' + containerName);
+            var args = format(
+                "-e 'affinity:container!=" +
+                    CONTAINER_PREFIX +
+                    "*' -d --name %s alpine sleep 3600",
+                containerName
+            );
+            cli.run(t, {args: args}, function(err, id) {
+                t.ifErr(err, 'docker run error');
+                t.ok(id, 'id');
+                t.end();
+            });
+        }
+    );
 
     // This should fail: no container with label foo=bar2.
-    tt.test('  docker run -e "affinity:foo==bar2" ... (label, ==, fail)',
-            function (t) {
-        var containerName = CONTAINER_PREFIX + libuuid.create().split('-')[0];
-        t.ok(containerName, 'containerName: ' + containerName);
-        var args = format(
-            '-e \'affinity:foo==bar2\' -d --name %s alpine sleep 3600',
-            containerName);
-        cli.run(t, {
-            args: args,
-            expectedErr: 'Error response from daemon: (ResourceNotFound) '
-                + 'no active containers found matching tag "foo=bar2" for '
-                + 'affinity "foo==bar2"'
-        }, function (err) {
-            t.end();
-        });
-    });
+    tt.test(
+        '  docker run -e "affinity:foo==bar2" ... (label, ==, fail)',
+        function(t) {
+            var containerName =
+                CONTAINER_PREFIX + libuuid.create().split('-')[0];
+            t.ok(containerName, 'containerName: ' + containerName);
+            var args = format(
+                "-e 'affinity:foo==bar2' -d --name %s alpine sleep 3600",
+                containerName
+            );
+            cli.run(
+                t,
+                {
+                    args: args,
+                    expectedErr: 'Error response from daemon: (ResourceNotFound) ' +
+                        'no active containers found matching tag "foo=bar2" for ' +
+                        'affinity "foo==bar2"'
+                },
+                function(err) {
+                    t.end();
+                }
+            );
+        }
+    );
 
     // This should work: no container with label foo=bar2, but *soft* affinity.
-    tt.test('  docker run -e "affinity:foo==~bar2" ... (label, ==~)',
-            function (t) {
+    tt.test('  docker run -e "affinity:foo==~bar2" ... (label, ==~)', function(
+        t
+    ) {
         var containerName = CONTAINER_PREFIX + libuuid.create().split('-')[0];
         t.ok(containerName, 'containerName: ' + containerName);
         var args = format(
-            '-e \'affinity:foo==~bar2\' -d --name %s alpine sleep 3600',
-            containerName);
-        cli.run(t, {args: args}, function (err, id) {
+            "-e 'affinity:foo==~bar2' -d --name %s alpine sleep 3600",
+            containerName
+        );
+        cli.run(t, {args: args}, function(err, id) {
             t.ifErr(err, 'docker run error');
             t.ok(id, 'id');
             t.end();
@@ -102,22 +131,24 @@ test('affinities a la Swarm', function (tt) {
 
     // This should work: no container with label foo=bar1.
     var containerId;
-    tt.test('  docker run -e "affinity:foo!=bar1" ... (label, !=)',
-            function (t) {
+    tt.test('  docker run -e "affinity:foo!=bar1" ... (label, !=)', function(
+        t
+    ) {
         var containerName = CONTAINER_PREFIX + libuuid.create().split('-')[0];
         t.ok(containerName, 'containerName: ' + containerName);
         var args = format(
-            '-e \'affinity:foo!=bar1\' --label foo=bar2 -d '
-                + '--name %s alpine sleep 3600',
-            containerName);
-        cli.run(t, {args: args}, function (err, id) {
+            "-e 'affinity:foo!=bar1' --label foo=bar2 -d " +
+                '--name %s alpine sleep 3600',
+            containerName
+        );
+        cli.run(t, {args: args}, function(err, id) {
             t.ifErr(err, 'docker run error');
             t.ok(id, 'id');
             containerId = id;
             t.end();
         });
     });
-    tt.test('  have "com.docker.swarm.affinities" label', function (t) {
+    tt.test('  have "com.docker.swarm.affinities" label', function(t) {
         cli.inspect(t, {
             id: containerId,
             partialExp: {
@@ -125,7 +156,7 @@ test('affinities a la Swarm', function (tt) {
                     Labels: {
                         'com.joyent.package': '*',
                         'com.docker.swarm.affinities': '["foo!=bar1"]',
-                        'foo': 'bar2'
+                        foo: 'bar2'
                     }
                 }
             }
@@ -134,14 +165,16 @@ test('affinities a la Swarm', function (tt) {
 
     // Now this one should work: we *do* have a container with label foo=bar2
     // (created in previous step).
-    tt.test('  docker run -e "affinity:foo==bar2" ... (label, ==)',
-            function (t) {
+    tt.test('  docker run -e "affinity:foo==bar2" ... (label, ==)', function(
+        t
+    ) {
         var containerName = CONTAINER_PREFIX + libuuid.create().split('-')[0];
         t.ok(containerName, 'containerName: ' + containerName);
         var args = format(
-            '-e \'affinity:foo==bar2\' -d --name %s alpine sleep 3600',
-            containerName);
-        cli.run(t, {args: args}, function (err, id) {
+            "-e 'affinity:foo==bar2' -d --name %s alpine sleep 3600",
+            containerName
+        );
+        cli.run(t, {args: args}, function(err, id) {
             t.ifErr(err, 'docker run error');
             t.ok(id, 'id');
             t.end();
@@ -149,5 +182,4 @@ test('affinities a la Swarm', function (tt) {
     });
 });
 
-
 test('teardown', cli.rmAllCreated);
diff --git a/test/integration/cli-attach.test.js b/test/integration/cli-attach.test.js
index ab76357..5a84e25 100644
--- a/test/integration/cli-attach.test.js
+++ b/test/integration/cli-attach.test.js
@@ -19,7 +19,6 @@ var cli = require('../lib/cli');
 var configLoader = require('../../lib/config-loader.js');
 var h = require('./helpers');
 
-
 // --- Globals
 
 var CONTAINER_PREFIX = 'sdcdockertest_';
@@ -30,14 +29,13 @@ var STATE = {
 };
 var ALICE;
 
-
 /**
  * Setup
  */
 
-test('setup', function (tt) {
-    tt.test('docker env', function (t) {
-        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        h.initDockerEnv(t, STATE, {}, function(err, accounts) {
             t.ifErr(err);
 
             ALICE = accounts.alice;
@@ -48,82 +46,102 @@ test('setup', function (tt) {
 
     tt.test('DockerEnv: alice init', cli.init);
 
-    tt.test('pull nginx image', function (t) {
-        h.ensureImage({
-            name: 'nginx:latest',
-            user: ALICE
-        }, function (err) {
-            t.error(err, 'should be no error pulling image');
-            t.end();
-        });
+    tt.test('pull nginx image', function(t) {
+        h.ensureImage(
+            {
+                name: 'nginx:latest',
+                user: ALICE
+            },
+            function(err) {
+                t.error(err, 'should be no error pulling image');
+                t.end();
+            }
+        );
     });
 });
 
-
 /**
  * Tests
  */
 
-test('test status code on attach exiting with implicit 0', function (tt) {
+test('test status code on attach exiting with implicit 0', function(tt) {
     removeTestContainers(tt);
-    tt.test('create container ' + container, function (t) {
+    tt.test('create container ' + container, function(t) {
         t.plan(4);
         var cmd = 'sleep 20; echo done';
 
-        cli.run(t, {
-            args: '-d --name ' + container + ' -d ubuntu bash -c "' + cmd + '"'
-        },
-        function (err, id) {
-            t.ifErr(err, 'docker run ' + container);
-
-            cli.attach(t, { args: id },
-            function (attachErr) {
-                t.ifErr(attachErr, 'attach should have not returned an error');
-                t.end();
-            });
-        });
+        cli.run(
+            t,
+            {
+                args: '-d --name ' +
+                    container +
+                    ' -d ubuntu bash -c "' +
+                    cmd +
+                    '"'
+            },
+            function(err, id) {
+                t.ifErr(err, 'docker run ' + container);
+
+                cli.attach(t, {args: id}, function(attachErr) {
+                    t.ifErr(
+                        attachErr,
+                        'attach should have not returned an error'
+                    );
+                    t.end();
+                });
+            }
+        );
     });
 });
 
-
-test('test status code on attach exiting with 2', function (tt) {
+test('test status code on attach exiting with 2', function(tt) {
     removeTestContainers(tt);
-    tt.test('create container ' + container, function (t) {
+    tt.test('create container ' + container, function(t) {
         t.plan(5);
         var cmd = 'sleep 20; exit 2';
 
-        cli.run(t, {
-            args: '-d --name ' + container + ' -d ubuntu bash -c "' + cmd + '"'
-        },
-        function (err, id) {
-            t.ifErr(err, 'docker run ' + container);
-
-            cli.attach(t, { args: id },
-            function (attachErr) {
-                t.ok(attachErr, 'attach should have returned an error');
-                t.equal(attachErr.cause().code, 2,
-                        'attach error status code should match');
-                t.end();
-            });
-        });
+        cli.run(
+            t,
+            {
+                args: '-d --name ' +
+                    container +
+                    ' -d ubuntu bash -c "' +
+                    cmd +
+                    '"'
+            },
+            function(err, id) {
+                t.ifErr(err, 'docker run ' + container);
+
+                cli.attach(t, {args: id}, function(attachErr) {
+                    t.ok(attachErr, 'attach should have returned an error');
+                    t.equal(
+                        attachErr.cause().code,
+                        2,
+                        'attach error status code should match'
+                    );
+                    t.end();
+                });
+            }
+        );
     });
 });
 
-
-test('test status code on exec exiting with implicit 0',
-function (tt) {
+test('test status code on exec exiting with implicit 0', function(tt) {
     removeTestContainers(tt);
-    tt.test('create container ' + container, function (t) {
+    tt.test('create container ' + container, function(t) {
         t.plan(4);
 
         var cmd = 'echo yolo';
 
-        cli.run(t, { args: '-d --name ' + container + ' -d nginx'  },
-        function (err, id) {
+        cli.run(t, {args: '-d --name ' + container + ' -d nginx'}, function(
+            err,
+            id
+        ) {
             t.ifErr(err, 'docker run ' + container);
 
-            cli.docker('exec ' + id + ' bash -c "' + cmd + '"',
-            function (execErr) {
+            cli.docker('exec ' + id + ' bash -c "' + cmd + '"', function(
+                execErr
+            ) {
                 t.ifErr(execErr, 'docker exec ' + container);
                 t.end();
             });
@@ -131,21 +149,22 @@ function (tt) {
     });
 });
 
-
-test('test status code on exec exiting with 2',
-function (tt) {
+test('test status code on exec exiting with 2', function(tt) {
     removeTestContainers(tt);
-    tt.test('create container ' + container, function (t) {
+    tt.test('create container ' + container, function(t) {
         t.plan(5);
 
         var cmd = 'exit 2';
 
-        cli.run(t, { args: '-d --name ' + container + ' -d nginx'  },
-        function (err, id) {
+        cli.run(t, {args: '-d --name ' + container + ' -d nginx'}, function(
+            err,
+            id
+        ) {
             t.ifErr(err, 'docker run ' + container);
 
-            cli.docker('exec ' + id + ' bash -c "' + cmd + '"',
-            function (execErr) {
+            cli.docker('exec ' + id + ' bash -c "' + cmd + '"', function(
+                execErr
+            ) {
                 t.ok(execErr, 'docker exec ' + container);
                 t.equal(execErr.cause().code, 2);
                 t.end();
@@ -154,44 +173,47 @@ function (tt) {
     });
 });
 
-
 /**
  * Cleanup
  */
 
-test('container cleanup', function (tt) {
+test('container cleanup', function(tt) {
     removeTestContainers(tt);
 });
 
-
 /**
  * Support functions
  */
 
 function removeTestContainers(tt) {
-    tt.test('remove old containers', function (t) {
-        cli.ps(t, {args: '-a'}, function (err, entries) {
+    tt.test('remove old containers', function(t) {
+        cli.ps(t, {args: '-a'}, function(err, entries) {
             t.ifErr(err, 'docker ps');
 
-            var oldContainers = entries.filter(function (entry) {
-                return (entry.names.substr(0, CONTAINER_PREFIX.length)
-                        === CONTAINER_PREFIX);
+            var oldContainers = entries.filter(function(entry) {
+                return (
+                    entry.names.substr(0, CONTAINER_PREFIX.length) ===
+                    CONTAINER_PREFIX
+                );
             });
 
-            vasync.forEachParallel({
-                inputs: oldContainers,
-                func: function _delOne(entry, cb) {
-                    cli.rm(t, {args: '-f ' + entry.container_id},
-                            function (err2)
-                    {
-                        t.ifErr(err2, 'rm container ' + entry.container_id);
-                        cb();
-                    });
+            vasync.forEachParallel(
+                {
+                    inputs: oldContainers,
+                    func: function _delOne(entry, cb) {
+                        cli.rm(t, {args: '-f ' + entry.container_id}, function(
+                            err2
+                        ) {
+                            t.ifErr(err2, 'rm container ' + entry.container_id);
+                            cb();
+                        });
+                    }
+                },
+                function(forEachErr) {
+                    tt.ifErr(forEachErr);
+                    t.end();
                 }
-            }, function (forEachErr) {
-                tt.ifErr(forEachErr);
-                t.end();
-            });
+            );
         });
     });
 }
diff --git a/test/integration/cli-commit.test.js b/test/integration/cli-commit.test.js
index 16286e9..ad0fd12 100644
--- a/test/integration/cli-commit.test.js
+++ b/test/integration/cli-commit.test.js
@@ -34,80 +34,96 @@ var STATE = {
 var CONTAINER_PREFIX = 'sdcdockertest_commit_';
 var IMAGE_NAME = 'busybox';
 var IMAGE_PREFIX = 'sdcdockertest-commit';
-var TP = 'api: commit: ';  // Test prefix.
-
-test(TP + 'setup', function (tt) {
+var TP = 'api: commit: '; // Test prefix.
 
+test(TP + 'setup', function(tt) {
     tt.test('DockerEnv: alice init', cli.init);
 
     // Ensure the busybox image is around.
-    tt.test(TP + 'pull busybox image', function (t) {
+    tt.test(TP + 'pull busybox image', function(t) {
         cli.pull(t, {
             image: 'busybox:latest'
         });
     });
 });
 
-
-test(TP + 'test add file', function (tt) {
-
+test(TP + 'test add file', function(tt) {
     var commitImageTag = common.makeImageName(IMAGE_PREFIX);
     var containerName = common.makeContainerName(CONTAINER_PREFIX);
 
-    tt.test('run ' + IMAGE_NAME + ' container', function (t) {
-        var runArgs = format('--name %s %s sh -c "echo hello > '
-            + '/newfile.txt"', containerName, IMAGE_NAME);
+    tt.test('run ' + IMAGE_NAME + ' container', function(t) {
+        var runArgs = format(
+            '--name %s %s sh -c "echo hello > ' + '/newfile.txt"',
+            containerName,
+            IMAGE_NAME
+        );
         cli.run(t, {args: runArgs}, t.end.bind(t)); // Err handled in cli.run
     });
 
-    tt.test('commit ' + IMAGE_NAME + ' container', function (t) {
-        var args = format('--author "cli tests" --message "Beer is great" '
-            + '--change "LABEL test=1" %s %s', containerName, commitImageTag);
+    tt.test('commit ' + IMAGE_NAME + ' container', function(t) {
+        var args = format(
+            '--author "cli tests" --message "Beer is great" ' +
+                '--change "LABEL test=1" %s %s',
+            containerName,
+            commitImageTag
+        );
         cli.commit(t, {args: args}, t.end.bind(t)); // Err handled in commit
     });
 
     // Cleanup out test container and committed image.
-    tt.test('delete ' + IMAGE_NAME + ' container', function (t) {
+    tt.test('delete ' + IMAGE_NAME + ' container', function(t) {
         cli.rm(t, {args: containerName}, t.end.bind(t)); // Err handled in rm
     });
 
     // Inspect committed image metadata.
-    tt.test('inspect committed image', function (t) {
-        cli.inspect(t, {
-            id: commitImageTag
-        }, function (err, img) {
-            if (img) {
-                t.equal(img.Author, 'cli tests');
-                t.equal(img.Comment, 'Beer is great');
-                t.deepEqual(img.Config.Labels, {'test': '1'});
+    tt.test('inspect committed image', function(t) {
+        cli.inspect(
+            t,
+            {
+                id: commitImageTag
+            },
+            function(err, img) {
+                if (img) {
+                    t.equal(img.Author, 'cli tests');
+                    t.equal(img.Comment, 'Beer is great');
+                    t.deepEqual(img.Config.Labels, {test: '1'});
+                }
+                t.end();
             }
-            t.end();
-        });
+        );
     });
 
     // Run the committed image and verify the 'newfile.txt' contents.
-    tt.test('verify created image', function (t) {
-        var runArgs = format('--rm --name %s %s sh -c "cat /newfile.txt"',
+    tt.test('verify created image', function(t) {
+        var runArgs = format(
+            '--rm --name %s %s sh -c "cat /newfile.txt"',
             common.makeContainerName(CONTAINER_PREFIX + 'verify_'),
-            commitImageTag);
-        cli.run(t, {args: runArgs}, function (err, result) {
+            commitImageTag
+        );
+        cli.run(t, {args: runArgs}, function(err, result) {
             // err is already tested in cli.run() call
             if (!err) {
-                t.ok(result.stdout.indexOf('hello') >= 0,
-                    'newfile.txt content is "hello"');
+                t.ok(
+                    result.stdout.indexOf('hello') >= 0,
+                    'newfile.txt content is "hello"'
+                );
             }
             t.end();
         });
     });
 
-    tt.test('delete committed image', function (t) {
+    tt.test('delete committed image', function(t) {
         cli.rmi(t, {args: commitImageTag}, t.end.bind(t)); // Err handled in rmi
     });
 
     // Ensure base busybox image is still around (and wasn't deleted).
-    tt.test('inspect busybox image', function (t) {
-        cli.inspect(t, {
-            id: IMAGE_NAME
-        }, t.end.bind(t) /* err checked by cli.inspect */);
+    tt.test('inspect busybox image', function(t) {
+        cli.inspect(
+            t,
+            {
+                id: IMAGE_NAME
+            },
+            t.end.bind(t) /* err checked by cli.inspect */
+        );
     });
 });
diff --git a/test/integration/cli-copy.test.js b/test/integration/cli-copy.test.js
index 470ed3e..6ac8733 100644
--- a/test/integration/cli-copy.test.js
+++ b/test/integration/cli-copy.test.js
@@ -92,7 +92,6 @@ var ALICE;
  */
 /* END JSSTYLED */
 
-
 // --- Globals
 
 var log = require('../lib/log');
@@ -106,20 +105,18 @@ var CONTAINER_NAME_NGINX2 = CONTAINER_PREFIX + 'nginx2';
 var CONTAINER_NAME_ALPINE = CONTAINER_PREFIX + 'alpine';
 
 var CONTAINERS_TO_CREATE = [
-    { name: CONTAINER_NAME_NGINX,  image: 'nginx' },
-    { name: CONTAINER_NAME_NGINX2, image: 'nginx' },
-    { name: CONTAINER_NAME_ALPINE, image: 'alpine', cmd: 'sleep 1000000' }
+    {name: CONTAINER_NAME_NGINX, image: 'nginx'},
+    {name: CONTAINER_NAME_NGINX2, image: 'nginx'},
+    {name: CONTAINER_NAME_ALPINE, image: 'alpine', cmd: 'sleep 1000000'}
 ];
 
-
-
 /**
  * Setup
  */
 
-test('setup', function (tt) {
-    tt.test('docker env', function (t) {
-        h.initDockerEnv(t, STATE, {}, function (err, accounts) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        h.initDockerEnv(t, STATE, {}, function(err, accounts) {
             t.ifErr(err);
 
             ALICE = accounts.alice;
@@ -131,53 +128,59 @@ test('setup', function (tt) {
     tt.test('DockerEnv: alice init', cli.init);
     tt.test('vmapi client', vm.init);
 
-    tt.test('pull nginx image', function (t) {
-        h.ensureImage({
-            name: 'nginx:latest',
-            user: ALICE
-        }, function (err) {
-            t.error(err, 'should be no error pulling image');
-            t.end();
-        });
+    tt.test('pull nginx image', function(t) {
+        h.ensureImage(
+            {
+                name: 'nginx:latest',
+                user: ALICE
+            },
+            function(err) {
+                t.error(err, 'should be no error pulling image');
+                t.end();
+            }
+        );
     });
 });
 
-
-test('test initialization', function (tt) {
+test('test initialization', function(tt) {
     removeTestContainers(tt);
 
-    vasync.forEachParallel({
-        inputs: CONTAINERS_TO_CREATE,
-        func: function (create, next) {
-            var name = create.name;
-            var image = create.image;
-            var cmd = create.cmd;
-
-            tt.test('create container ' + name, function (t) {
-                t.plan(3);
-
-                var args = sprintf(
-                    '-d --name %s %s %s', name, image, cmd || '');
-                cli.run(t, { args: args},
-                function (err, id) {
-                    t.ifErr(err, 'docker run ' + name);
-                    t.end();
-                    next();
+    vasync.forEachParallel(
+        {
+            inputs: CONTAINERS_TO_CREATE,
+            func: function(create, next) {
+                var name = create.name;
+                var image = create.image;
+                var cmd = create.cmd;
+
+                tt.test('create container ' + name, function(t) {
+                    t.plan(3);
+
+                    var args = sprintf(
+                        '-d --name %s %s %s',
+                        name,
+                        image,
+                        cmd || ''
+                    );
+                    cli.run(t, {args: args}, function(err, id) {
+                        t.ifErr(err, 'docker run ' + name);
+                        t.end();
+                        next();
+                    });
                 });
-            });
+            }
+        },
+        function(err) {
+            tt.end();
         }
-    }, function (err) {
-        tt.end();
-    });
+    );
 });
 
-
-
 /**
  * Tests ---------------------------------------------------------------------
  */
 
-test('copy out of container file with funky name', function (tt) {
+test('copy out of container file with funky name', function(tt) {
     /**
      * Test that we can copy in and copy out files that have variety of
      * characters, some of which could be considered "problematic".  Previous
@@ -205,69 +208,81 @@ test('copy out of container file with funky name', function (tt) {
     var localFn = remoteDir + '/local.txt';
     var contents = 'here come dat boi';
 
-    vasync.waterfall([
-        function (next) {
-            createLocalFile(localFn, contents, next);
-        },
-        function (next) {
-            copyFilesIn(localFn, remoteDir, next);
-        },
-        function (next) {
-            copyFilesOutAndCheckContents(remoteDir, contents, next);
+    vasync.waterfall(
+        [
+            function(next) {
+                createLocalFile(localFn, contents, next);
+            },
+            function(next) {
+                copyFilesIn(localFn, remoteDir, next);
+            },
+            function(next) {
+                copyFilesOutAndCheckContents(remoteDir, contents, next);
+            }
+        ],
+        function(err) {
+            tt.ifErr(err, 'no errors copying files out with funky name');
+            tt.end();
         }
-    ],
-    function (err) {
-        tt.ifErr(err, 'no errors copying files out with funky name');
-        tt.end();
-    });
-
+    );
 
     function createLocalFile(local, fileContents, cb) {
         var cmd = sprintf('echo "%s" > %s', fileContents, local);
-        cli.exec(cmd, function (execErr) {
+        cli.exec(cmd, function(execErr) {
             tt.ifErr(execErr, 'creating file to be copied');
             cb(execErr);
         });
     }
 
-
     function copyFilesIn(local, remote, cb) {
-        vasync.forEachPipeline({
-            inputs: remoteFilenames,
-            func: function (filename, next) {
-                copyFileIn(tt, local,
-                            remote + filename, CONTAINER_NAME_ALPINE, next);
+        vasync.forEachPipeline(
+            {
+                inputs: remoteFilenames,
+                func: function(filename, next) {
+                    copyFileIn(
+                        tt,
+                        local,
+                        remote + filename,
+                        CONTAINER_NAME_ALPINE,
+                        next
+                    );
+                }
+            },
+            function(err) {
+                tt.ifErr(err, 'no error copying test files into container');
+                cb();
             }
-        }, function (err) {
-            tt.ifErr(err, 'no error copying test files into container');
-            cb();
-        });
+        );
     }
 
-
     function copyFilesOutAndCheckContents(remote, fileContents, cb) {
-        vasync.forEachPipeline({
-            inputs: remoteFilenames,
-            func: function (filename, next) {
-                copyFileOutGetContents(
-                    tt, remote + filename, filename, CONTAINER_NAME_ALPINE,
-                    onCopyOut);
-
-                function onCopyOut(err, str) {
-                    tt.equal(str, fileContents, 'file contents matched');
-                    next();
+        vasync.forEachPipeline(
+            {
+                inputs: remoteFilenames,
+                func: function(filename, next) {
+                    copyFileOutGetContents(
+                        tt,
+                        remote + filename,
+                        filename,
+                        CONTAINER_NAME_ALPINE,
+                        onCopyOut
+                    );
+
+                    function onCopyOut(err, str) {
+                        tt.equal(str, fileContents, 'file contents matched');
+                        next();
+                    }
                 }
+            },
+            function(err) {
+                tt.ifErr(err, 'no errors copying out and checking test files');
+                cb();
             }
-        }, function (err) {
-            tt.ifErr(err, 'no errors copying out and checking test files');
-            cb();
-        });
+        );
     }
-
 });
 
-
-test('copy out of container file placement', function (tt) {
+test('copy out of container file placement', function(tt) {
     var directoryName = 'local-dir-' + process.pid;
     var testcases = [
         {
@@ -317,66 +332,68 @@ test('copy out of container file placement', function (tt) {
     }
     tt.plan(plan);
 
-    vasync.waterfall([
-        initializeFixtures,
-        executeTestCases
-    ],
-    function (err) {
+    vasync.waterfall([initializeFixtures, executeTestCases], function(err) {
         tt.end();
     });
 
     function initializeFixtures(callback) {
-        vasync.waterfall([
-            function createDir(next) {
-                cli.exec(sprintf('mkdir -p %s', directoryName),
-                function (err, stdout, stderr) {
-                    tt.ifErr(err, 'creating test directory');
-                    tt.comment('created ' + directoryName);
-                    next(err);
-                });
+        vasync.waterfall(
+            [
+                function createDir(next) {
+                    cli.exec(sprintf('mkdir -p %s', directoryName), function(
+                        err,
+                        stdout,
+                        stderr
+                    ) {
+                        tt.ifErr(err, 'creating test directory');
+                        tt.comment('created ' + directoryName);
+                        next(err);
+                    });
+                }
+            ],
+            function(err) {
+                tt.ifErr(err);
+                callback(err);
             }
-        ],
-        function (err) {
-            tt.ifErr(err);
-            callback(err);
-        });
+        );
     }
 
     function executeTestCases(callback) {
-        vasync.forEachPipeline({
-            inputs: testcases,
-            func: executeCopyOutTestcase
-        },
-        function (err) {
-            callback(err);
-        });
+        vasync.forEachPipeline(
+            {
+                inputs: testcases,
+                func: executeCopyOutTestcase
+            },
+            function(err) {
+                callback(err);
+            }
+        );
     }
 
     function executeCopyOutTestcase(tc, callback) {
         var src = tc.src;
         var dst = tc.dst;
         var result = tc.result;
-        var args = sprintf(
-            'cp %s:%s %s',
-            CONTAINER_NAME_NGINX, src, dst);
+        var args = sprintf('cp %s:%s %s', CONTAINER_NAME_NGINX, src, dst);
         tt.comment(args);
-        var execOpts = { encoding: 'binary' };
-        cli.docker(args, { execOpts: execOpts }, onDocker);
+        var execOpts = {encoding: 'binary'};
+        cli.docker(args, {execOpts: execOpts}, onDocker);
         function onDocker(err, stdout, stderr) {
             tt.ifErr(err, 'no `docker copy` error');
 
             // TODO better mechanism for checking existence of resulting file
-            cli.exec(sprintf('ls %s', result), function (execErr) {
-                tt.ifErr(execErr,
-                    'checking for existence of resulting docker copy file');
+            cli.exec(sprintf('ls %s', result), function(execErr) {
+                tt.ifErr(
+                    execErr,
+                    'checking for existence of resulting docker copy file'
+                );
                 callback();
             });
         }
     }
 });
 
-
-test('copy a file out of running container', function (tt) {
+test('copy a file out of running container', function(tt) {
     tt.plan(7);
     var fnbase = '/var/tmp';
     var fn = 'copyout.test';
@@ -385,37 +402,47 @@ test('copy a file out of running container', function (tt) {
 
     var hash;
 
-    vasync.waterfall([
-        function (next) {
-            createCopyOutFile(tt, remotefn, CONTAINER_NAME_NGINX,
-            function (err, sha1) {
-                tt.ifErr(err, 'creating copy out file');
-                hash = sha1;
-                tt.comment('hash was ' + hash);
-                next();
-            });
-        },
-        function (next) {
-            copyFileOut(tt, remotefn, fn, CONTAINER_NAME_NGINX,
-            function (err) {
-                tt.ifErr(err, 'copying file out');
-                next();
-            });
-        },
-        function (next) {
-            checkFileCopiedOut(tt, remotefn, hash, CONTAINER_NAME_NGINX,
-            function (err) {
-                tt.ifErr(err, 'copying file out');
-                next();
-            });
+    vasync.waterfall(
+        [
+            function(next) {
+                createCopyOutFile(tt, remotefn, CONTAINER_NAME_NGINX, function(
+                    err,
+                    sha1
+                ) {
+                    tt.ifErr(err, 'creating copy out file');
+                    hash = sha1;
+                    tt.comment('hash was ' + hash);
+                    next();
+                });
+            },
+            function(next) {
+                copyFileOut(tt, remotefn, fn, CONTAINER_NAME_NGINX, function(
+                    err
+                ) {
+                    tt.ifErr(err, 'copying file out');
+                    next();
+                });
+            },
+            function(next) {
+                checkFileCopiedOut(
+                    tt,
+                    remotefn,
+                    hash,
+                    CONTAINER_NAME_NGINX,
+                    function(err) {
+                        tt.ifErr(err, 'copying file out');
+                        next();
+                    }
+                );
+            }
+        ],
+        function(err) {
+            tt.end();
         }
-    ], function (err) {
-        tt.end();
-    });
+    );
 });
 
-
-test('copy a file out of stopped container', function (tt) {
+test('copy a file out of stopped container', function(tt) {
     tt.plan(9);
 
     var fnbase = '/var/tmp';
@@ -425,37 +452,42 @@ test('copy a file out of stopped container', function (tt) {
 
     var hash;
 
-    vasync.waterfall([
-        function (next) {
-            createCopyOutFile(tt, remotefn, CONTAINER_NAME_NGINX2,
-            function (err, sha1) {
-                tt.ifErr(err, 'creating copy out file');
-                hash = sha1;
-                next();
-            });
-        },
-        function (next) {
-            stopContainer(tt, CONTAINER_NAME_NGINX2,
-            function (err) {
-                tt.ifErr(err, 'stopping copy out container');
-                next();
-            });
-        },
-        function (next) {
-            copyFileOut(tt, remotefn, fn, CONTAINER_NAME_NGINX2,
-            function (err, sha1) {
-                tt.ifErr(err, 'copying file out');
-                tt.equal(sha1, hash);
-                next();
-            });
+    vasync.waterfall(
+        [
+            function(next) {
+                createCopyOutFile(tt, remotefn, CONTAINER_NAME_NGINX2, function(
+                    err,
+                    sha1
+                ) {
+                    tt.ifErr(err, 'creating copy out file');
+                    hash = sha1;
+                    next();
+                });
+            },
+            function(next) {
+                stopContainer(tt, CONTAINER_NAME_NGINX2, function(err) {
+                    tt.ifErr(err, 'stopping copy out container');
+                    next();
+                });
+            },
+            function(next) {
+                copyFileOut(tt, remotefn, fn, CONTAINER_NAME_NGINX2, function(
+                    err,
+                    sha1
+                ) {
+                    tt.ifErr(err, 'copying file out');
+                    tt.equal(sha1, hash);
+                    next();
+                });
+            }
+        ],
+        function(err) {
+            tt.end();
         }
-    ], function (err) {
-        tt.end();
-    });
+    );
 });
 
-
-test('copy a file into running container', function (tt) {
+test('copy a file into running container', function(tt) {
     var cliVer = process.env.DOCKER_CLI_VERSION;
     if (cliVer && semver.lt(cliVer, '1.8.0')) {
         tt.skip('Docker copy out not supported in client ' + cliVer);
@@ -473,36 +505,48 @@ test('copy a file into running container', function (tt) {
 
     var hash;
 
-    vasync.waterfall([
-        function (next) {
-            createCopyInFile(tt, localfn, function (err, sha1) {
-                tt.ifErr(err, 'creating copy in file (running container)');
-                hash = sha1;
-                tt.comment('running container file sha1 ' + sha1);
-                next();
-            });
-        },
-        function (next) {
-            copyFileIn(tt, localfn, remotefn, CONTAINER_NAME_NGINX,
-            function (err) {
-                tt.ifErr(err, 'copying file in');
-                next();
-            });
-        },
-        function (next) {
-            checkFileCopiedIn(tt, remotefn, CONTAINER_NAME_NGINX, hash,
-            function (err) {
-                tt.ifErr(err, 'checking file copied in');
-                next();
-            });
+    vasync.waterfall(
+        [
+            function(next) {
+                createCopyInFile(tt, localfn, function(err, sha1) {
+                    tt.ifErr(err, 'creating copy in file (running container)');
+                    hash = sha1;
+                    tt.comment('running container file sha1 ' + sha1);
+                    next();
+                });
+            },
+            function(next) {
+                copyFileIn(
+                    tt,
+                    localfn,
+                    remotefn,
+                    CONTAINER_NAME_NGINX,
+                    function(err) {
+                        tt.ifErr(err, 'copying file in');
+                        next();
+                    }
+                );
+            },
+            function(next) {
+                checkFileCopiedIn(
+                    tt,
+                    remotefn,
+                    CONTAINER_NAME_NGINX,
+                    hash,
+                    function(err) {
+                        tt.ifErr(err, 'checking file copied in');
+                        next();
+                    }
+                );
+            }
+        ],
+        function(err) {
+            tt.end();
         }
-    ], function (err) {
-        tt.end();
-    });
+    );
 });
 
-
-test('copy a file into stopped container', function (tt) {
+test('copy a file into stopped container', function(tt) {
     var cliVer = process.env.DOCKER_CLI_VERSION;
     if (cliVer && semver.lt(cliVer, '1.8.0')) {
         tt.skip('Docker copy out not supported in client ' + cliVer);
@@ -520,103 +564,115 @@ test('copy a file into stopped container', function (tt) {
 
     var hash;
 
-    vasync.waterfall([
-        function (next) {
-            createCopyInFile(tt, localfn, function (err, sha1) {
-                tt.ifErr(err, 'creating copy in file (stopped container)');
-                hash = sha1;
-                next();
-            });
-        },
-        function (next) {
-            stopContainer(tt, CONTAINER_NAME_NGINX2, function (err) {
-                tt.ifErr(err, 'error stopping container');
-                next();
-            });
-        },
-        function (next) {
-            copyFileIn(tt, localfn, remotefn, CONTAINER_NAME_NGINX2,
-            function (err) {
-                tt.ifErr(err, 'copying file in');
-                next();
-            });
-        },
-        function (next) {
-            startContainer(tt, CONTAINER_NAME_NGINX2, function (err) {
-                tt.ifErr(err, 'error stopping container');
-                next();
-            });
-        },
-        function (next) {
-            checkFileCopiedIn(tt, remotefn, CONTAINER_NAME_NGINX2, hash,
-            function (err) {
-                tt.ifErr(err, 'checking file copied in');
-                next();
-            });
+    vasync.waterfall(
+        [
+            function(next) {
+                createCopyInFile(tt, localfn, function(err, sha1) {
+                    tt.ifErr(err, 'creating copy in file (stopped container)');
+                    hash = sha1;
+                    next();
+                });
+            },
+            function(next) {
+                stopContainer(tt, CONTAINER_NAME_NGINX2, function(err) {
+                    tt.ifErr(err, 'error stopping container');
+                    next();
+                });
+            },
+            function(next) {
+                copyFileIn(
+                    tt,
+                    localfn,
+                    remotefn,
+                    CONTAINER_NAME_NGINX2,
+                    function(err) {
+                        tt.ifErr(err, 'copying file in');
+                        next();
+                    }
+                );
+            },
+            function(next) {
+                startContainer(tt, CONTAINER_NAME_NGINX2, function(err) {
+                    tt.ifErr(err, 'error stopping container');
+                    next();
+                });
+            },
+            function(next) {
+                checkFileCopiedIn(
+                    tt,
+                    remotefn,
+                    CONTAINER_NAME_NGINX2,
+                    hash,
+                    function(err) {
+                        tt.ifErr(err, 'checking file copied in');
+                        next();
+                    }
+                );
+            }
+        ],
+        function(err) {
+            tt.end();
         }
-    ], function (err) {
-        tt.end();
-    });
+    );
 });
 
-
 /**
  * Cleanup.
  */
-test('copy container cleanup', function (tt) {
+test('copy container cleanup', function(tt) {
     removeTestContainers(tt);
 });
 
-
-
 /**
  * Support functions
  */
 
 function stopContainer(tt, containerName, callback) {
-    cli.stop(tt, { args: containerName }, function (err) {
+    cli.stop(tt, {args: containerName}, function(err) {
         tt.ifErr(err, 'stopping container');
         callback(err);
     });
 }
 
-
 function startContainer(tt, containerName, callback) {
-    cli.start(tt, { args: containerName }, function (err) {
+    cli.start(tt, {args: containerName}, function(err) {
         tt.ifErr(err, 'starting container');
         callback(err);
     });
 }
 
-
 function removeTestContainers(tt) {
-    tt.test('remove old containers', function (t) {
-        cli.ps(t, {args: '-a'}, function (err, entries) {
+    tt.test('remove old containers', function(t) {
+        cli.ps(t, {args: '-a'}, function(err, entries) {
             t.ifErr(err, 'docker ps');
 
-            var oldContainers = entries.filter(function (entry) {
-                return (entry.names.substr(0, CONTAINER_PREFIX.length)
-                        === CONTAINER_PREFIX);
+            var oldContainers = entries.filter(function(entry) {
+                return (
+                    entry.names.substr(0, CONTAINER_PREFIX.length) ===
+                    CONTAINER_PREFIX
+                );
             });
 
-            vasync.forEachParallel({
-                inputs: oldContainers,
-                func: function _delOne(entry, cb) {
-                    cli.rm(t, {args: '-f ' + entry.container_id},
-                            function (err2)
-                    {
-                        t.ifErr(err2, 'rm container ' + entry.container_id);
-                        cb();
-                    });
+            vasync.forEachParallel(
+                {
+                    inputs: oldContainers,
+                    func: function _delOne(entry, cb) {
+                        cli.rm(t, {args: '-f ' + entry.container_id}, function(
+                            err2
+                        ) {
+                            t.ifErr(err2, 'rm container ' + entry.container_id);
+                            cb();
+                        });
+                    }
+                },
+                function() {
+                    t.end();
                 }
-            }, function () {
-                t.end();
-            });
+            );
         });
     });
 }
 
-
 /**
  * Copy out test auxillary support functions
  */
@@ -637,25 +693,32 @@ function createCopyOutFile(tt, remotefn, containerName, callback) {
     }
 }
 
-
 function copyFileOut(tt, remotefn, localfn, containerName, callback) {
     var args = sprintf(
         'cp "%s:%s" - | tar xOf - "%s"',
-        containerName, remotefn, localfn);
-    var execOpts = { maxBuffer: 1024*1024+1, encoding: 'binary' };
-    cli.docker(args, { execOpts: execOpts }, onDocker);
+        containerName,
+        remotefn,
+        localfn
+    );
+    var execOpts = {maxBuffer: 1024 * 1024 + 1, encoding: 'binary'};
+    cli.docker(args, {execOpts: execOpts}, onDocker);
     function onDocker(err, stdout, stderr) {
         tt.ifErr(err);
         var str = stdout.toString();
-        var hash =
-            crypto.createHash('sha1').update(str, 'binary').digest('hex');
+        var hash = crypto
+            .createHash('sha1')
+            .update(str, 'binary')
+            .digest('hex');
         callback(err, hash);
     }
 }
 
 function checkFileCopiedOut(tt, remotefn, hash, containerName, callback) {
-    var args = sprintf('exec %s /native/usr/bin/sum -x sha1 %s',
-                        containerName, remotefn);
+    var args = sprintf(
+        'exec %s /native/usr/bin/sum -x sha1 %s',
+        containerName,
+        remotefn
+    );
     cli.docker(args, onDocker);
     function onDocker(err, stdout, stderr) {
         tt.ifErr(err);
@@ -665,26 +728,26 @@ function checkFileCopiedOut(tt, remotefn, hash, containerName, callback) {
     }
 }
 
-
 function createCopyInFile(tt, localfn, callback) {
     var hash;
     var cmd = sprintf(
-        'dd if=/dev/urandom of=%s '
-        + 'count=1024 bs=1024 >/dev/null && '
-        + '/native/usr/bin/sum -x sha1 %s | awk "{ print $1 }"',
-        localfn, localfn);
-    cli.exec(cmd, function (err, stdout, stderr) {
+        'dd if=/dev/urandom of=%s ' +
+            'count=1024 bs=1024 >/dev/null && ' +
+            '/native/usr/bin/sum -x sha1 %s | awk "{ print $1 }"',
+        localfn,
+        localfn
+    );
+    cli.exec(cmd, function(err, stdout, stderr) {
         tt.ifErr(err);
         hash = stdout.toString();
         callback(err, hash);
     });
 }
 
-
 function copyFileIn(tt, localfn, remotefn, containerName, callback) {
     var args = sprintf('cp %s "%s:%s"', localfn, containerName, remotefn);
-    var execOpts = { maxBuffer: 1024*1024*2, encoding: 'binary' };
-    cli.docker(args, { execOpts: execOpts }, onDocker);
+    var execOpts = {maxBuffer: 1024 * 1024 * 2, encoding: 'binary'};
+    cli.docker(args, {execOpts: execOpts}, onDocker);
     function onDocker(err, stdout, stderr) {
         tt.ifErr(err);
         callback(err);
@@ -692,9 +755,11 @@ function copyFileIn(tt, localfn, remotefn, containerName, callback) {
 }
 
 function checkFileCopiedIn(tt, remotefn, containerName, hash, callback) {
-    var args =
-        sprintf('exec %s /native/usr/bin/sum -x sha1 %s',
-                containerName, remotefn);
+    var args = sprintf(
+        'exec %s /native/usr/bin/sum -x sha1 %s',
+        containerName,
+        remotefn
+    );
     cli.docker(args, onDocker);
     function onDocker(err, stdout, stderr) {
         tt.ifErr(err);
@@ -705,12 +770,21 @@ function checkFileCopiedIn(tt, remotefn, containerName, hash, callback) {
     }
 }
 
-function
-copyFileOutGetContents(tt, remotefn, extractfn, containerName, callback) {
-    var args = sprintf('cp "%s:%s" - | tar xOf - "%s"',
-        containerName, remotefn, extractfn);
-    var execOpts = { maxBuffer: 1024*1024+1, encoding: 'binary' };
-    cli.docker(args, { execOpts: execOpts }, onDocker);
+function copyFileOutGetContents(
+    tt,
+    remotefn,
+    extractfn,
+    containerName,
+    callback
+) {
+    var args = sprintf(
+        'cp "%s:%s" - | tar xOf - "%s"',
+        containerName,
+        remotefn,
+        extractfn
+    );
+    var execOpts = {maxBuffer: 1024 * 1024 + 1, encoding: 'binary'};
+    cli.docker(args, {execOpts: execOpts}, onDocker);
     function onDocker(err, stdout, stderr) {
         tt.ifErr(err);
         var str = stdout.toString().trim();
diff --git a/test/integration/cli-filters.test.js b/test/integration/cli-filters.test.js
index 2caac65..4b98c84 100644
--- a/test/integration/cli-filters.test.js
+++ b/test/integration/cli-filters.test.js
@@ -20,68 +20,77 @@ var cli = require('../lib/cli');
 var common = require('../lib/common');
 var vm = require('../lib/vm');
 
-
 // --- Globals
 
 var CLIENTS = {};
 var CONTAINER_PREFIX = 'sdcdockertest_filters_';
 var IMAGE_NAME = 'joyentunsupported/busybox_with_label_test';
 
-
-
 // --- Tests
 
-test('setup', function (tt) {
-
+test('setup', function(tt) {
     tt.test('DockerEnv: alice init', cli.init);
 
     tt.test('vmapi client', vm.init);
 });
 
-
 function checkContainerFiltering(tt, args, expectedNames) {
-    tt.test('container filtering', function (t) {
-        cli.ps(t, {args: args}, function (err, containers) {
+    tt.test('container filtering', function(t) {
+        cli.ps(t, {args: args}, function(err, containers) {
             t.ifErr(err, 'docker ps ' + args);
             t.equal(containers.length, expectedNames.length, 'Container count');
-            var gotNames = containers.map(function (c) { return c.names; });
-            t.deepEqual(gotNames.sort(), expectedNames.sort(),
-                'Container names');
+            var gotNames = containers.map(function(c) {
+                return c.names;
+            });
+            t.deepEqual(
+                gotNames.sort(),
+                expectedNames.sort(),
+                'Container names'
+            );
             t.end();
         });
     });
 }
 
-
-test('container filters', function (tt) {
+test('container filters', function(tt) {
     var containerName1 = common.makeContainerName(CONTAINER_PREFIX);
     var containerName2 = common.makeContainerName(CONTAINER_PREFIX);
 
-    tt.test('create container 1', function (t) {
-        var runArgs = format('-d --name %s --label fishing=true %s sleep 3600',
-            containerName1, IMAGE_NAME);
-        cli.run(t, {args: runArgs}, function (err, id) {
+    tt.test('create container 1', function(t) {
+        var runArgs = format(
+            '-d --name %s --label fishing=true %s sleep 3600',
+            containerName1,
+            IMAGE_NAME
+        );
+        cli.run(t, {args: runArgs}, function(err, id) {
             t.ifErr(err, 'docker run ' + IMAGE_NAME);
             t.end();
         });
     });
 
-    tt.test('create container 2', function (t) {
-        var runArgs = format('-d --name %s --label fishing=fun %s sleep 3600',
-            containerName2, IMAGE_NAME);
-        cli.run(t, {args: runArgs}, function (err, id) {
+    tt.test('create container 2', function(t) {
+        var runArgs = format(
+            '-d --name %s --label fishing=fun %s sleep 3600',
+            containerName2,
+            IMAGE_NAME
+        );
+        cli.run(t, {args: runArgs}, function(err, id) {
             t.ifErr(err, 'docker run ' + IMAGE_NAME);
             t.end();
         });
     });
 
     // Filtering on the container label that comes from the image.
-    checkContainerFiltering(tt, '--filter label=todd=cool',
-        [containerName1, containerName2]);
+    checkContainerFiltering(tt, '--filter label=todd=cool', [
+        containerName1,
+        containerName2
+    ]);
 
     // Filtering on just the label name.
-    checkContainerFiltering(tt, '--filter label=fishing',
-        [containerName1, containerName2]);
+    checkContainerFiltering(tt, '--filter label=fishing', [
+        containerName1,
+        containerName2
+    ]);
 
     // Filtering on just the label name and value, which exists.
     checkContainerFiltering(tt, '--filter label=fishing=fun', [containerName2]);
@@ -90,63 +99,83 @@ test('container filters', function (tt) {
     checkContainerFiltering(tt, '--filter label=fishing=notfun', []);
 
     // Filtering on the container name prefix.
-    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX,
-        [containerName1, containerName2]);
+    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX, [
+        containerName1,
+        containerName2
+    ]);
 
     // Filtering on the full container name.
-    checkContainerFiltering(tt, '--filter name=' + containerName1,
-        [containerName1]);
+    checkContainerFiltering(tt, '--filter name=' + containerName1, [
+        containerName1
+    ]);
 
     // Filtering using multiple filters matching both containers.
-    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX
-        + ' --filter label=fishing'
-        + ' --filter label=todd=cool',
-        [containerName1, containerName2]);
+    checkContainerFiltering(
+        tt,
+        '--filter name=' +
+            CONTAINER_PREFIX +
+            ' --filter label=fishing' +
+            ' --filter label=todd=cool',
+        [containerName1, containerName2]
+    );
 
     // Filtering using multiple filters matching just one container.
-    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX
-        + ' --filter label=fishing=fun'
-        + ' --filter label=todd=cool',
-        [containerName2]);
-
-    tt.test('stop container 1', function (t) {
-        cli.stop(t, {args: containerName1}, function (err) {
+    checkContainerFiltering(
+        tt,
+        '--filter name=' +
+            CONTAINER_PREFIX +
+            ' --filter label=fishing=fun' +
+            ' --filter label=todd=cool',
+        [containerName2]
+    );
+
+    tt.test('stop container 1', function(t) {
+        cli.stop(t, {args: containerName1}, function(err) {
             t.ifErr(err, 'docker stop ' + containerName1);
             t.end();
         });
     });
 
     // Filtering against running/stopped containers.
-    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX,
-        [containerName2]);
+    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX, [
+        containerName2
+    ]);
 
     // Filtering against running/stopped containers.
-    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX
-        + ' --filter status=exited',
-        [containerName1]);
+    checkContainerFiltering(
+        tt,
+        '--filter name=' + CONTAINER_PREFIX + ' --filter status=exited',
+        [containerName1]
+    );
 
     // Filtering against running/stopped containers.
-    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX
-        + ' --filter status=running',
-        [containerName2]);
+    checkContainerFiltering(
+        tt,
+        '--filter name=' + CONTAINER_PREFIX + ' --filter status=running',
+        [containerName2]
+    );
 
     // Filtering using limit - should match running/stopped containers.
-    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX
-        + ' -n=10',
-        [containerName1, containerName2]);
+    checkContainerFiltering(
+        tt,
+        '--filter name=' + CONTAINER_PREFIX + ' -n=10',
+        [containerName1, containerName2]
+    );
 
     // Filtering using negative limit - should only match running containers.
-    checkContainerFiltering(tt, '--filter name=' + CONTAINER_PREFIX
-        + ' -n=-10',
-        [containerName2]);
+    checkContainerFiltering(
+        tt,
+        '--filter name=' + CONTAINER_PREFIX + ' -n=-10',
+        [containerName2]
+    );
 });
 
-
-test('image filters', function (tt) {
-    tt.test('filter on image label', function (t) {
-        cli.images(t, {args: '--filter label=todd=cool'},
-            function (err, images)
-        {
+test('image filters', function(tt) {
+    tt.test('filter on image label', function(t) {
+        cli.images(t, {args: '--filter label=todd=cool'}, function(
+            err,
+            images
+        ) {
             t.ifErr(err, 'docker images --filter');
             t.equal(images.length, 1, 'Check one image returned');
             t.equal(images[0].repository, IMAGE_NAME, 'Check image name');
@@ -154,10 +183,11 @@ test('image filters', function (tt) {
         });
     });
 
-    tt.test('filter on nonexistant image label', function (t) {
-        cli.images(t, {args: '--filter label=todd=notcool'},
-            function (err, images)
-        {
+    tt.test('filter on nonexistant image label', function(t) {
+        cli.images(t, {args: '--filter label=todd=notcool'}, function(
+            err,
+            images
+        ) {
             t.ifErr(err, 'docker images nonexistant --filter');
             t.deepEqual(images, []);
             t.end();
@@ -165,5 +195,4 @@ test('image filters', function (tt) {
     });
 });
 
-
 test('teardown', cli.rmAllCreated);
diff --git a/test/integration/cli-image-tag.test.js b/test/integration/cli-image-tag.test.js
index a57f312..7883251 100644
--- a/test/integration/cli-image-tag.test.js
+++ b/test/integration/cli-image-tag.test.js
@@ -17,11 +17,8 @@ var vm = require('../lib/vm');
 var test = require('tape');
 var vasync = require('vasync');
 
-
-
 // --- Globals
 
-
 var CLIENTS = {};
 var TAG_PREFIX = 'sdcdockertest_tag_';
 var IMAGE_NAME = 'busybox';
@@ -29,9 +26,12 @@ var IMAGE_NAME = 'busybox';
 // --- Helpers
 
 function cleanupTags(tt) {
-    tt.test('image tag cleanup', function (t) {
-        cli.docker('images | grep ' + TAG_PREFIX + ' | awk "{ print \\$1 }"',
-            {}, onComplete);
+    tt.test('image tag cleanup', function(t) {
+        cli.docker(
+            'images | grep ' + TAG_PREFIX + ' | awk "{ print \\$1 }"',
+            {},
+            onComplete
+        );
         function onComplete(err, stdout, stderr) {
             t.ifErr(err);
             var ids = stdout.split(/(\r?\n)/g).join(' ').trim();
@@ -50,35 +50,34 @@ function cleanupTags(tt) {
 
 // --- Tests
 
-
-test('setup', function (tt) {
+test('setup', function(tt) {
     tt.test('DockerEnv: alice init', cli.init);
     cleanupTags(tt);
 });
 
-
-test('tag image', function (tt) {
-
+test('tag image', function(tt) {
     var tagName = TAG_PREFIX + 'altbox';
 
-    tt.test('pull busybox image', function (t) {
+    tt.test('pull busybox image', function(t) {
         cli.pull(t, {
             image: 'busybox:latest'
         });
     });
 
-
-    tt.test('inspect busybox image', function (t) {
-        cli.inspect(t, {
-            id: 'busybox:latest'
-        }, function (err, img) {
-            t.end();
-        });
+    tt.test('inspect busybox image', function(t) {
+        cli.inspect(
+            t,
+            {
+                id: 'busybox:latest'
+            },
+            function(err, img) {
+                t.end();
+            }
+        );
     });
 
-
     // Tag the image.
-    tt.test('tag busybox image', function (t) {
+    tt.test('tag busybox image', function(t) {
         cli.docker('tag busybox ' + tagName, {}, onComplete);
         function onComplete(err, stdout, stderr) {
             t.ifErr(err);
@@ -86,53 +85,58 @@ test('tag image', function (tt) {
         }
     });
 
-
     // Check that the tagged image is available.
-    tt.test('inspect tagged image', function (t) {
-        cli.inspect(t, {
-            id: tagName + ':latest'
-        }, function (err, img) {
-            t.ifErr(err, 'Found tagged image');
-            t.end();
-        });
+    tt.test('inspect tagged image', function(t) {
+        cli.inspect(
+            t,
+            {
+                id: tagName + ':latest'
+            },
+            function(err, img) {
+                t.ifErr(err, 'Found tagged image');
+                t.end();
+            }
+        );
     });
 
-
     cleanupTags(tt);
 
-
     // Check that the original busybox image is *still* available after deleting
     // the `altbox` tag.
-    tt.test('inspect busybox image again', function (t) {
-        cli.inspect(t, {
-            id: 'busybox:latest'
-        }, function (err, img) {
-            t.end();
-        });
+    tt.test('inspect busybox image again', function(t) {
+        cli.inspect(
+            t,
+            {
+                id: 'busybox:latest'
+            },
+            function(err, img) {
+                t.end();
+            }
+        );
     });
 });
 
-
 /**
  * DOCKER-748: Cannot build an image that references multiple registries.
  */
-test('DOCKER-748: tag between different registries', function (tt) {
-
+test('DOCKER-748: tag between different registries', function(tt) {
     var tagName = 'quay.io/joyent/' + TAG_PREFIX + 'altbox';
 
-    tt.test('pull busybox image', function (t) {
+    tt.test('pull busybox image', function(t) {
         cli.pull(t, {
             image: 'busybox:latest'
         });
     });
 
     // Tag the image.
-    tt.test('tag busybox image', function (t) {
+    tt.test('tag busybox image', function(t) {
         cli.docker('tag busybox ' + tagName, {}, onComplete);
         function onComplete(err, stdout, stderr) {
             t.assert(err);
-            t.assert(String(err).indexOf('different registries') >= 0,
-                'should be a "different registries" error message');
+            t.assert(
+                String(err).indexOf('different registries') >= 0,
+                'should be a "different registries" error message'
+            );
             t.end();
         }
     });
diff --git a/test/integration/cli-info.test.js b/test/integration/cli-info.test.js
index d58219c..70a1488 100644
--- a/test/integration/cli-info.test.js
+++ b/test/integration/cli-info.test.js
@@ -15,8 +15,6 @@
 var h = require('./helpers');
 var test = require('tape');
 
-
-
 // --- Globals
 
 var log = require('../lib/log');
@@ -25,15 +23,14 @@ var state = {
 };
 var alice;
 
-
-
 // --- Tests
 
-test('docker info', function (tt) {
-
-    tt.test('setup', function (t) {
-        h.getDockerEnv(t, state, {account: 'sdcdockertest_alice'},
-                function (err, env) {
+test('docker info', function(tt) {
+    tt.test('setup', function(t) {
+        h.getDockerEnv(t, state, {account: 'sdcdockertest_alice'}, function(
+            err,
+            env
+        ) {
             t.ifErr(err);
             t.ok(env, 'have a DockerEnv for alice');
             alice = env;
@@ -41,16 +38,19 @@ test('docker info', function (tt) {
         });
     });
 
-    tt.test('docker info (alice)', function (t) {
-        alice.docker('info', function (err, stdout, stderr) {
+    tt.test('docker info (alice)', function(t) {
+        alice.docker('info', function(err, stdout, stderr) {
             t.ifErr(err, 'docker info');
             t.ok(/^Storage Driver: sdc$/m.test(stdout), 'Storage Driver: sdc');
-            t.ok(/SDCAccount: sdcdockertest_alice$/m.test(stdout),
-                'SDCAccount: sdcdockertest_alice');
-            t.ok(/Operating System: SmartDataCenter$/m.test(stdout),
-                'Operating System');
+            t.ok(
+                /SDCAccount: sdcdockertest_alice$/m.test(stdout),
+                'SDCAccount: sdcdockertest_alice'
+            );
+            t.ok(
+                /Operating System: SmartDataCenter$/m.test(stdout),
+                'Operating System'
+            );
             t.end();
         });
     });
-
 });
diff --git a/test/integration/cli-labels.test.js b/test/integration/cli-labels.test.js
index 5b7670f..c5d4e14 100644
--- a/test/integration/cli-labels.test.js
+++ b/test/integration/cli-labels.test.js
@@ -20,49 +20,45 @@ var cli = require('../lib/cli');
 var common = require('../lib/common');
 var vm = require('../lib/vm');
 
-
 // --- Globals
 
 var CLIENTS = {};
 var CONTAINER_PREFIX = 'sdcdockertest_labels_';
 var IMAGE_NAME = 'joyentunsupported/busybox_with_label_test';
 
-
-
 // --- Tests
 
-test('setup', function (tt) {
-
+test('setup', function(tt) {
     tt.test('DockerEnv: alice init', cli.init);
 
     tt.test('vmapi client', vm.init);
 });
 
-
-test('labels', function (tt) {
+test('labels', function(tt) {
     var containerId;
 
-    tt.test('simple label', function (t) {
-        var runArgs = format('-d --label foo=bar --name %s '
-            + '--label "elem=something with a space" busybox sleep 3600',
-            common.makeContainerName(CONTAINER_PREFIX));
-        cli.run(t, {args: runArgs}, function (err, id) {
+    tt.test('simple label', function(t) {
+        var runArgs = format(
+            '-d --label foo=bar --name %s ' +
+                '--label "elem=something with a space" busybox sleep 3600',
+            common.makeContainerName(CONTAINER_PREFIX)
+        );
+        cli.run(t, {args: runArgs}, function(err, id) {
             t.ifErr(err, 'docker run --label foo=bar busybox');
             containerId = id;
             t.end();
         });
     });
 
-
-    tt.test('simple label check', function (t) {
+    tt.test('simple label check', function(t) {
         cli.inspect(t, {
             id: containerId,
             partialExp: {
                 Config: {
                     Labels: {
                         'com.joyent.package': '*',
-                        'foo': 'bar',
-                        'elem': 'something with a space'
+                        foo: 'bar',
+                        elem: 'something with a space'
                     }
                 }
             }
@@ -70,28 +66,28 @@ test('labels', function (tt) {
     });
 });
 
-
-test('labels on container', function (tt) {
-
+test('labels on container', function(tt) {
     var containerId;
     var expectedLabels = {
         'com.joyent.package': '*',
-        'foo': 'bar',  // from the command line
-        'todd': 'cool' // from the image
+        foo: 'bar', // from the command line
+        todd: 'cool' // from the image
     };
 
-    tt.test('container label', function (t) {
-        var runArgs = format('-d --name %s --label foo=bar %s sleep 3600',
-            common.makeContainerName(CONTAINER_PREFIX), IMAGE_NAME);
-        cli.run(t, {args: runArgs}, function (err, id) {
+    tt.test('container label', function(t) {
+        var runArgs = format(
+            '-d --name %s --label foo=bar %s sleep 3600',
+            common.makeContainerName(CONTAINER_PREFIX),
+            IMAGE_NAME
+        );
+        cli.run(t, {args: runArgs}, function(err, id) {
             t.ifErr(err, 'docker run --label foo=bar ' + IMAGE_NAME);
             containerId = id;
             t.end();
         });
     });
 
-
-    tt.test('container label check', function (t) {
+    tt.test('container label check', function(t) {
         cli.inspect(t, {
             id: containerId,
             partialExp: {
@@ -102,9 +98,8 @@ test('labels on container', function (tt) {
         });
     });
 
-
-    tt.test('label ps check', function (t) {
-        cli.ps(t, {args: '-a'}, function (err, entries) {
+    tt.test('label ps check', function(t) {
+        cli.ps(t, {args: '-a'}, function(err, entries) {
             t.ifErr(err, 'docker ps');
             for (var i = 0; i < entries.length; i++) {
                 if (entries[i].Id === containerId) {
@@ -117,34 +112,34 @@ test('labels on container', function (tt) {
     });
 });
 
-
 /**
  * Test adding a label with the same name as one on the image, 'todd', and
  * ensure the one added on the container "wins".
  */
-test('labels conflict', function (tt) {
-
+test('labels conflict', function(tt) {
     var containerId;
 
-    tt.test('conflicting label', function (t) {
-        var runArgs = format('-d --name %s --label todd=notcool %s sleep 3600',
-            common.makeContainerName(CONTAINER_PREFIX), IMAGE_NAME);
-        cli.run(t, {args: runArgs}, function (err, id) {
+    tt.test('conflicting label', function(t) {
+        var runArgs = format(
+            '-d --name %s --label todd=notcool %s sleep 3600',
+            common.makeContainerName(CONTAINER_PREFIX),
+            IMAGE_NAME
+        );
+        cli.run(t, {args: runArgs}, function(err, id) {
             t.ifErr(err, 'docker run --label todd=notcool ' + IMAGE_NAME);
             containerId = id;
             t.end();
         });
     });
 
-
-    tt.test('conflicting label check', function (t) {
+    tt.test('conflicting label check', function(t) {
         cli.inspect(t, {
             id: containerId,
             partialExp: {
                 Config: {
                     Labels: {
                         'com.joyent.package': '*',
-                        'todd': 'notcool'
+                        todd: 'notcool'
                     }
                 }
             }
@@ -152,5 +147,4 @@ test('labels conflict', function (tt) {
     });
 });
 
-
 test('teardown', cli.rmAllCreated);
diff --git a/test/integration/cli-links.test.js b/test/integration/cli-links.test.js
index 5fd13d6..532fab9 100644
--- a/test/integration/cli-links.test.js
+++ b/test/integration/cli-links.test.js
@@ -17,173 +17,186 @@ var vm = require('../lib/vm');
 var test = require('tape');
 var vasync = require('vasync');
 
-
-
 // --- Globals
 
-
 var CLIENTS = {};
 var CONTAINER_PREFIX = 'sdcdockertest_link_';
 
-
 // --- Helpers
 
-
 // --- Tests
 
-
-test('setup', function (tt) {
-
+test('setup', function(tt) {
     tt.test('DockerEnv: alice init', cli.init);
 
     tt.test('vmapi client', vm.init);
 });
 
-
-test('delete old vms', function (tt) {
-
-    tt.test('remove old containers', function (t) {
-        cli.ps(t, {args: '-a'}, function (err, entries) {
+test('delete old vms', function(tt) {
+    tt.test('remove old containers', function(t) {
+        cli.ps(t, {args: '-a'}, function(err, entries) {
             t.ifErr(err, 'docker ps');
 
-            var oldContainers = entries.filter(function (entry) {
-                return (entry.names.substr(0, CONTAINER_PREFIX.length)
-                        === CONTAINER_PREFIX);
+            var oldContainers = entries.filter(function(entry) {
+                return (
+                    entry.names.substr(0, CONTAINER_PREFIX.length) ===
+                    CONTAINER_PREFIX
+                );
             });
 
-            vasync.forEachParallel({
-                inputs: oldContainers,
-                func: function _delOne(entry, cb) {
-                    cli.rm(t, {args: '-f ' + entry.container_id},
-                            function (err2)
-                    {
-                        t.ifErr(err2, 'rm container ' + entry.container_id);
-                        cb();
-                    });
+            vasync.forEachParallel(
+                {
+                    inputs: oldContainers,
+                    func: function _delOne(entry, cb) {
+                        cli.rm(t, {args: '-f ' + entry.container_id}, function(
+                            err2
+                        ) {
+                            t.ifErr(err2, 'rm container ' + entry.container_id);
+                            cb();
+                        });
+                    }
+                },
+                function() {
+                    t.end();
                 }
-            }, function () {
-                t.end();
-            });
+            );
         });
     });
 });
 
-
-test('linked env', function (tt) {
-
+test('linked env', function(tt) {
     var nginxName = CONTAINER_PREFIX + 'nginx';
-    tt.test('linked env: create custom nginx -p 80:80', function (t) {
-        cli.run(t, { args: '-d --name ' + nginxName + ' -e FOO=BAR -e BAT=BAZZA'
-                    + ' -p 80:80 nginx' });
+    tt.test('linked env: create custom nginx -p 80:80', function(t) {
+        cli.run(t, {
+            args: '-d --name ' +
+                nginxName +
+                ' -e FOO=BAR -e BAT=BAZZA' +
+                ' -p 80:80 nginx'
+        });
     });
 
-
     var bboxName = CONTAINER_PREFIX + 'bbox';
-    tt.test('linked env: create busybox with nginx link', function (t) {
-        cli.run(t, { args: '-d --name ' + bboxName
-                    + ' --link ' + nginxName + ':ngx'
-                    + ' busybox top' });
+    tt.test('linked env: create busybox with nginx link', function(t) {
+        cli.run(t, {
+            args: '-d --name ' +
+                bboxName +
+                ' --link ' +
+                nginxName +
+                ':ngx' +
+                ' busybox top'
+        });
     });
 
-
-    tt.test('linked env: VMAPI tags', function (t) {
-        vm.get(t, {
-            id: cli.lastCreated,
-            partialExp: {
-                tags: {
-                    sdc_docker: true
+    tt.test('linked env: VMAPI tags', function(t) {
+        vm.get(
+            t,
+            {
+                id: cli.lastCreated,
+                partialExp: {
+                    tags: {
+                        sdc_docker: true
+                    }
                 }
-            }
-        }, function (err, vmobj) {
-            if (err) {
-                return;
-            }
-
-            var im = vmobj.internal_metadata;
-            var linkEnv = JSON.parse(im['docker:linkEnv'] || '[]');
-
-            var expectedLinkEnv = [
-                'NGX_NAME=/' + bboxName + '/ngx',
-                'NGX_ENV_FOO=BAR',
-                'NGX_ENV_BAT=BAZZA'
-            ];
-            expectedLinkEnv.forEach(function (e) {
-                if (linkEnv.indexOf(e) == -1) {
-                    t.fail('env var ' + e + ' not found in '
-                            + im['docker:linkEnv']);
+            },
+            function(err, vmobj) {
+                if (err) {
+                    return;
                 }
-            });
 
-            // Regular expressions (to cope with the ip address):
-            var expectedPortEnvNames = [
-                'NGX_PORT_80_TCP=tcp://(.*?):80',
-                'NGX_PORT_80_TCP_ADDR=[0-9.]*',
-                'NGX_PORT_80_TCP_PORT=80',
-                'NGX_PORT_80_TCP_PROTO=tcp',
-                'NGX_PORT_443_TCP=tcp://(.*?):443',
-                'NGX_PORT_443_TCP_ADDR=[0-9.]*',
-                'NGX_PORT_443_TCP_PORT=443',
-                'NGX_PORT_443_TCP_PROTO=tcp'
-            ];
-            var privateIpRegex = new RegExp('(^10\\.)'
-                                        + '|(^172\\.1[6-9]\\.)'
-                                        + '|(^172\\.2[0-9]\\.)'
-                                        + '|(^172\\.3[0-1]\\.)'
-                                        + '|(^192\\.168\\.)');
-            expectedPortEnvNames.forEach(function (e) {
-                var match;
-                for (var i = 0; i < linkEnv.length; i++) {
-                    match = linkEnv[i].match(e);
-                    if (match) {
-                        // Check that the the tcp address is internal.
-                        if ((e.indexOf('tcp://') > 0)
-                            && (!match[1].match(privateIpRegex)))
-                        {
-                            t.fail('linked env is not using a private ip: '
-                                    + linkEnv[i]);
+                var im = vmobj.internal_metadata;
+                var linkEnv = JSON.parse(im['docker:linkEnv'] || '[]');
+
+                var expectedLinkEnv = [
+                    'NGX_NAME=/' + bboxName + '/ngx',
+                    'NGX_ENV_FOO=BAR',
+                    'NGX_ENV_BAT=BAZZA'
+                ];
+                expectedLinkEnv.forEach(function(e) {
+                    if (linkEnv.indexOf(e) == -1) {
+                        t.fail(
+                            'env var ' +
+                                e +
+                                ' not found in ' +
+                                im['docker:linkEnv']
+                        );
+                    }
+                });
+
+                // Regular expressions (to cope with the ip address):
+                var expectedPortEnvNames = [
+                    'NGX_PORT_80_TCP=tcp://(.*?):80',
+                    'NGX_PORT_80_TCP_ADDR=[0-9.]*',
+                    'NGX_PORT_80_TCP_PORT=80',
+                    'NGX_PORT_80_TCP_PROTO=tcp',
+                    'NGX_PORT_443_TCP=tcp://(.*?):443',
+                    'NGX_PORT_443_TCP_ADDR=[0-9.]*',
+                    'NGX_PORT_443_TCP_PORT=443',
+                    'NGX_PORT_443_TCP_PROTO=tcp'
+                ];
+                var privateIpRegex = new RegExp(
+                    '(^10\\.)' +
+                        '|(^172\\.1[6-9]\\.)' +
+                        '|(^172\\.2[0-9]\\.)' +
+                        '|(^172\\.3[0-1]\\.)' +
+                        '|(^192\\.168\\.)'
+                );
+                expectedPortEnvNames.forEach(function(e) {
+                    var match;
+                    for (var i = 0; i < linkEnv.length; i++) {
+                        match = linkEnv[i].match(e);
+                        if (match) {
+                            // Check that the the tcp address is internal.
+                            if (
+                                e.indexOf('tcp://') > 0 &&
+                                !match[1].match(privateIpRegex)
+                            ) {
+                                t.fail(
+                                    'linked env is not using a private ip: ' +
+                                        linkEnv[i]
+                                );
+                            }
+                            return;
                         }
-                        return;
                     }
-                }
-                t.fail('env var ' + e + ' not found in '
-                        + im['docker:linkEnv']);
-            });
+                    t.fail(
+                        'env var ' + e + ' not found in ' + im['docker:linkEnv']
+                    );
+                });
 
-            var linkHosts = im['docker:linkHosts'] || '';
-            // Regular expressions:
-            var expectedHosts = [
-                '\\b' + 'ngx' + '\\b',
-                '\\b' + nginxName + '\\b'
-            ];
-            expectedHosts.forEach(function (e) {
-                if (!linkHosts.match(e)) {
-                    t.fail('host ' + e + ' not found in ' + linkHosts);
-                }
-            });
+                var linkHosts = im['docker:linkHosts'] || '';
+                // Regular expressions:
+                var expectedHosts = [
+                    '\\b' + 'ngx' + '\\b',
+                    '\\b' + nginxName + '\\b'
+                ];
+                expectedHosts.forEach(function(e) {
+                    if (!linkHosts.match(e)) {
+                        t.fail('host ' + e + ' not found in ' + linkHosts);
+                    }
+                });
 
-            t.end();
-        });
+                t.end();
+            }
+        );
     });
 
-
-    tt.test('link inspect', function (t) {
+    tt.test('link inspect', function(t) {
         cli.inspect(t, {
             id: bboxName,
             partialExp: {
                 HostConfig: {
-                    Links: [
-                        '/' + nginxName + ':/' + bboxName + '/ngx'
-                    ]
+                    Links: ['/' + nginxName + ':/' + bboxName + '/ngx']
                 }
             }
         });
     });
 
-
-    tt.test('link removal', function (t) {
-        cli.docker('rm --link /' + bboxName + '/ngx',
-                    function (err, stdout, stderr)
-        {
+    tt.test('link removal', function(t) {
+        cli.docker('rm --link /' + bboxName + '/ngx', function(
+            err,
+            stdout,
+            stderr
+        ) {
             t.ifErr(err, 'docker rm --link');
 
             cli.inspect(t, {
@@ -198,30 +211,33 @@ test('linked env', function (tt) {
     });
 });
 
-
-test('link rename', function (tt) {
-
+test('link rename', function(tt) {
     var targName = CONTAINER_PREFIX + 'target';
     var contName = CONTAINER_PREFIX + 'link_container';
     var targNameRenamed = targName + '_r';
     var contNameRenamed = contName + '_r';
 
-    tt.test(' create link_target', function (t) {
-        cli.run(t, { args: '-d --name ' + targName + ' busybox top' });
+    tt.test(' create link_target', function(t) {
+        cli.run(t, {args: '-d --name ' + targName + ' busybox top'});
     });
 
-
-    tt.test(' create link_container', function (t) {
-        cli.run(t, { args: '-d --name ' + contName
-                    + ' --link ' + targName + ':target'
-                    + ' busybox top' });
+    tt.test(' create link_container', function(t) {
+        cli.run(t, {
+            args: '-d --name ' +
+                contName +
+                ' --link ' +
+                targName +
+                ':target' +
+                ' busybox top'
+        });
     });
 
-
-    tt.test(' rename target', function (t) {
-        cli.docker('rename ' + targName + ' ' + targNameRenamed,
-                    function (err, stdout, stderr)
-        {
+    tt.test(' rename target', function(t) {
+        cli.docker('rename ' + targName + ' ' + targNameRenamed, function(
+            err,
+            stdout,
+            stderr
+        ) {
             t.ifErr(err, 'docker rename');
 
             cli.inspect(t, {
@@ -237,11 +253,12 @@ test('link rename', function (tt) {
         });
     });
 
-
-    tt.test(' rename container', function (t) {
-        cli.docker('rename ' + contName + ' ' + contNameRenamed,
-                    function (err, stdout, stderr)
-        {
+    tt.test(' rename container', function(t) {
+        cli.docker('rename ' + contName + ' ' + contNameRenamed, function(
+            err,
+            stdout,
+            stderr
+        ) {
             t.ifErr(err, 'docker rename');
 
             cli.inspect(t, {
@@ -249,8 +266,12 @@ test('link rename', function (tt) {
                 partialExp: {
                     HostConfig: {
                         Links: [
-                            '/' + targNameRenamed + ':'
-                            + '/' + contNameRenamed + '/target'
+                            '/' +
+                                targNameRenamed +
+                                ':' +
+                                '/' +
+                                contNameRenamed +
+                                '/target'
                         ]
                     }
                 }
@@ -258,40 +279,40 @@ test('link rename', function (tt) {
         });
     });
 
-
-    tt.test(' restart container', function (t) {
-        cli.docker('restart ' + contNameRenamed,
-                    function (err, stdout, stderr)
-        {
+    tt.test(' restart container', function(t) {
+        cli.docker('restart ' + contNameRenamed, function(err, stdout, stderr) {
             t.ifErr(err, 'docker restart');
 
-            cli.docker('exec ' + contNameRenamed + ' sh -c export',
-                        function (err2, stdout2, stderr2)
-            {
+            cli.docker('exec ' + contNameRenamed + ' sh -c export', function(
+                err2,
+                stdout2,
+                stderr2
+            ) {
                 t.ifErr(err2, 'docker exec export');
 
-                var envName = 'TARGET_NAME=\'/' + contNameRenamed + '/target\'';
+                var envName = "TARGET_NAME='/" + contNameRenamed + "/target'";
                 if (stdout2.indexOf(envName) === -1) {
                     t.fail('env var ' + envName + ' not found in\n' + stdout2);
                 }
 
-                cli.docker('exec ' + contNameRenamed + ' cat /etc/hosts',
-                            function (err3, stdout3, stderr3)
-                {
-                    t.ifErr(err3, 'docker exec cat');
+                cli.docker(
+                    'exec ' + contNameRenamed + ' cat /etc/hosts',
+                    function(err3, stdout3, stderr3) {
+                        t.ifErr(err3, 'docker exec cat');
 
-                    var hostName = targNameRenamed;
-                    if (stdout3.indexOf(hostName) === -1) {
-                        t.fail('host ' + hostName + ' not found in\n'
-                                + stdout3);
-                    }
+                        var hostName = targNameRenamed;
+                        if (stdout3.indexOf(hostName) === -1) {
+                            t.fail(
+                                'host ' + hostName + ' not found in\n' + stdout3
+                            );
+                        }
 
-                    t.end();
-                });
+                        t.end();
+                    }
+                );
             });
         });
     });
 });
 
-
 test('teardown', cli.rmAllCreated);
diff --git a/test/integration/cli-local-volumes.test.js b/test/integration/cli-local-volumes.test.js
index 7c43f22..95cdc02 100644
--- a/test/integration/cli-local-volumes.test.js
+++ b/test/integration/cli-local-volumes.test.js
@@ -25,9 +25,9 @@ var STATE = {
     log: require('../lib/log')
 };
 
-test('setup', function (tt) {
-    tt.test('docker env', function (t) {
-        dockerTestsHelper.initDockerEnv(t, STATE, {}, function (err, accounts) {
+test('setup', function(tt) {
+    tt.test('docker env', function(t) {
+        dockerTestsHelper.initDockerEnv(t, STATE, {}, function(err, accounts) {
             t.ifErr(err);
 
             ALICE = accounts.alice;
@@ -38,70 +38,112 @@ test('setup', function (tt) {
 
     tt.test('DockerEnv: alice init', cli.init);
 
-    tt.test('pull nginx image', function (t) {
-        dockerTestsHelper.ensureImage({
-            name: 'nginx:latest',
-            user: ALICE
-        }, function (err) {
-            t.error(err, 'should be no error pulling image');
-            t.end();
-        });
+    tt.test('pull nginx image', function(t) {
+        dockerTestsHelper.ensureImage(
+            {
+                name: 'nginx:latest',
+                user: ALICE
+            },
+            function(err) {
+                t.error(err, 'should be no error pulling image');
+                t.end();
+            }
+        );
     });
 });
 
-test('docker local volumes', function (tt) {
-    var containerWithLocalVolName =
-        common.makeContainerName('local-volume-test-container-with-local-vol');
-    var mountingContainerName =
-        common.makeContainerName('local-volume-test-mounting-container');
+test('docker local volumes', function(tt) {
+    var containerWithLocalVolName = common.makeContainerName(
+        'local-volume-test-container-with-local-vol'
+    );
+    var mountingContainerName = common.makeContainerName(
+        'local-volume-test-mounting-container'
+    );
 
-    tt.test('creating container with local volume should succeed',
-        function (t) {
-            cli.run(t, {
-                args: '--name ' + containerWithLocalVolName + ' -v /data '
-                    + 'nginx:latest /bin/sh -c "touch /data/foo.txt && ls '
-                    + '/data"'
-            }, function onContainerRun(err, output) {
-                t.ifErr(err,
-                    'creating container with local volume should not error');
-                t.equal(output.stdout, 'foo.txt\n',
-                    'output should equal newly created file');
+    tt.test('creating container with local volume should succeed', function(t) {
+        cli.run(
+            t,
+            {
+                args: '--name ' +
+                    containerWithLocalVolName +
+                    ' -v /data ' +
+                    'nginx:latest /bin/sh -c "touch /data/foo.txt && ls ' +
+                    '/data"'
+            },
+            function onContainerRun(err, output) {
+                t.ifErr(
+                    err,
+                    'creating container with local volume should not error'
+                );
+                t.equal(
+                    output.stdout,
+                    'foo.txt\n',
+                    'output should equal newly created file'
+                );
                 t.end();
-            });
+            }
+        );
     });
 
-    tt.test('mounting local volume from another container should succeed',
-        function (t) {
-        cli.run(t, {
-            args: '--name ' + mountingContainerName + ' --volumes-from='
-                + containerWithLocalVolName + ' nginx:latest ls /data'
-        }, function onContainerRun(err, output) {
-            t.ifErr(err,
-                'creating container with volume mounted with --volumes-from '
-                    + 'should not error');
-            t.equal(output.stdout, 'foo.txt\n', 'Output should equal newly '
-                + 'created file');
-            t.end();
-        });
-    });
-
-    tt.test('deleting container with volume mounted via --volumes-from should '
-        + 'work', function (t) {
-        cli.rm(t, {args: mountingContainerName},
-            function onContainerDeleted(err, stdout, stderr) {
-                t.ifErr(err, 'deleting container with volume mounted via '
-                    + '--volumes-from should succeed');
-                t.end();
-            });
-        });
+    tt.test(
+        'mounting local volume from another container should succeed',
+        function(t) {
+            cli.run(
+                t,
+                {
+                    args: '--name ' +
+                        mountingContainerName +
+                        ' --volumes-from=' +
+                        containerWithLocalVolName +
+                        ' nginx:latest ls /data'
+                },
+                function onContainerRun(err, output) {
+                    t.ifErr(
+                        err,
+                        'creating container with volume mounted with --volumes-from ' +
+                            'should not error'
+                    );
+                    t.equal(
+                        output.stdout,
+                        'foo.txt\n',
+                        'Output should equal newly ' + 'created file'
+                    );
+                    t.end();
+                }
+            );
+        }
+    );
 
-    tt.test('deleting container with local volume should work',
-        function (t) {
-            cli.rm(t, {args: containerWithLocalVolName},
+    tt.test(
+        'deleting container with volume mounted via --volumes-from should ' +
+            'work',
+        function(t) {
+            cli.rm(
+                t,
+                {args: mountingContainerName},
                 function onContainerDeleted(err, stdout, stderr) {
-                    t.ifErr(err, 'deleting container with local volume should '
-                        + 'succeed');
+                    t.ifErr(
+                        err,
+                        'deleting container with volume mounted via ' +
+                            '--volumes-from should succeed'
+                    );
                     t.end();
-                });
-        });
-});
\ No newline at end of file
+                }
+            );
+        }
+    );
+
+    tt.test('deleting container with local volume should work', function(t) {
+        cli.rm(
+            t,
+            {args: containerWithLocalVolName},
+            function onContainerDeleted(err, stdout, stderr) {
+                t.ifErr(
+                    err,
+                    'deleting container with local volume should ' + 'succeed'
+                );
+                t.end();
+            }
+        );
+    });
+});
diff --git a/test/integration/cli-packagelabels.test.js b/test/integration/cli-packagelabels.test.js
index d296275..a681146 100644
--- a/test/integration/cli-packagelabels.test.js
+++ b/test/integration/cli-packagelabels.test.js
@@ -21,8 +21,6 @@ var vm = require('../lib/vm');
 var test = require('tape');
 var vasync = require('vasync');
 
-
-
 // --- Globals
 
 var IMAGE_NAME = 'busybox';
@@ -36,7 +34,6 @@ var packageB;
 var packageC;
 var papi;
 
-
 // --- Disable these tests if too old
 
 if (cliVersion) {
@@ -52,19 +49,20 @@ if (cliVersion) {
     }
 }
 
-
 // --- Tests
 
-test('note if we are skipping due to old CLI version', function (tt) {
+test('note if we are skipping due to old CLI version', function(tt) {
     if (opts.skip) {
-        tt.comment('skipping tests because CLI version is < 1.8: it is '
-            + process.env.DOCKER_CLI_VERSION);
+        tt.comment(
+            'skipping tests because CLI version is < 1.8: it is ' +
+                process.env.DOCKER_CLI_VERSION
+        );
     }
     tt.end();
 });
 
-test('setup docker environment/cli', opts, function (tt) {
-    h.createPapiClient(function (err, _papi) {
+test('setup docker environment/cli', opts, function(tt) {
+    h.createPapiClient(function(err, _papi) {
         tt.ifErr(err, 'create PAPI client');
         papi = _papi;
         tt.test('DockerEnv: alice init', cli.init);
@@ -72,8 +70,8 @@ test('setup docker environment/cli', opts, function (tt) {
     });
 });
 
-test('find packages for test', opts, function (tt) {
-    h.getSortedPackages(function (err, pkgs) {
+test('find packages for test', opts, function(tt) {
+    h.getSortedPackages(function(err, pkgs) {
         tt.ifErr(err, 'getSortedPackages');
         tt.ok(pkgs.length >= 2, 'need at least 2 packages, got ' + pkgs.length);
 
@@ -92,96 +90,124 @@ test('find packages for test', opts, function (tt) {
  * be provisionable by our test user. Later on we'll attempt to provision with
  * it which should fail.
  */
-test('create package with bogus owner', opts, function (tt) {
-    papi.add({
-        active: true,
-        cpu_cap: 100,
-        default: false,
-        max_lwps: 1000,
-        max_physical_memory: 64,
-        max_swap: 128,
-        name: 'docker-test-packageC',
-        owner_uuids: [libuuid.create()],
-        quota: 10240,
-        uuid: libuuid.create(),
-        version: '42.0.0',
-        zfs_io_priority: 100
-    }, {}, function _papiAddCb(err, pkg) {
-        tt.ifError(err, 'create packageC' + (err ? '' : ' ' + pkg.uuid));
-        if (!err) {
-            packageC = pkg;
+test('create package with bogus owner', opts, function(tt) {
+    papi.add(
+        {
+            active: true,
+            cpu_cap: 100,
+            default: false,
+            max_lwps: 1000,
+            max_physical_memory: 64,
+            max_swap: 128,
+            name: 'docker-test-packageC',
+            owner_uuids: [libuuid.create()],
+            quota: 10240,
+            uuid: libuuid.create(),
+            version: '42.0.0',
+            zfs_io_priority: 100
+        },
+        {},
+        function _papiAddCb(err, pkg) {
+            tt.ifError(err, 'create packageC' + (err ? '' : ' ' + pkg.uuid));
+            if (!err) {
+                packageC = pkg;
+            }
+            tt.end();
         }
-        tt.end();
-    });
+    );
 });
 
-test('create test containers', opts, function (tt) {
-    var vms = [ {
-        name: CONTAINER_PREFIX + 'pkgA_byname',
-        pkgLabel: '--label com.joyent.package=' + packageA.name,
-        packageName: packageA.name
-    }, {
-        name: CONTAINER_PREFIX + 'pkgA_byuuid',
-        pkgLabel: '--label com.joyent.package=' + packageA.uuid,
-        packageName: packageA.name
-    }, {
-        name: CONTAINER_PREFIX + 'pkgA_byshort',
-        pkgLabel: '--label com.joyent.package=' + packageA.uuid.substr(0, 8),
-        packageName: packageA.name
-    }, {
-        name: CONTAINER_PREFIX + 'pkgB_byuuid',
-        pkgLabel: '--label com.joyent.package=' + packageB.uuid,
-        packageName: packageB.name
-    }];
-
-    vasync.forEachPipeline({
-        inputs: vms,
-        func: function _createContainer(vmspec, cb) {
-            var cmdline = '--name ' + vmspec.name + ' ' + vmspec.pkgLabel
-                + ' ' + IMAGE_NAME + ' sleep 3600';
-
-            cli.create(tt, {args: cmdline}, function (err, id) {
-                tt.ifErr(err, 'expect no error for create');
-                if (!err) {
-                    tt.ok(true, 'created ' + id);
-                    containers[vmspec.name] = {
-                        dockerId: id,
-                        packageName: vmspec.packageName
-                    };
-                }
-                cb(err);
-            });
+test('create test containers', opts, function(tt) {
+    var vms = [
+        {
+            name: CONTAINER_PREFIX + 'pkgA_byname',
+            pkgLabel: '--label com.joyent.package=' + packageA.name,
+            packageName: packageA.name
+        },
+        {
+            name: CONTAINER_PREFIX + 'pkgA_byuuid',
+            pkgLabel: '--label com.joyent.package=' + packageA.uuid,
+            packageName: packageA.name
+        },
+        {
+            name: CONTAINER_PREFIX + 'pkgA_byshort',
+            pkgLabel: '--label com.joyent.package=' +
+                packageA.uuid.substr(0, 8),
+            packageName: packageA.name
+        },
+        {
+            name: CONTAINER_PREFIX + 'pkgB_byuuid',
+            pkgLabel: '--label com.joyent.package=' + packageB.uuid,
+            packageName: packageB.name
         }
-    }, function _createdContainers(err) {
-        tt.ifError(err, 'created containers');
-        tt.end();
-    });
-});
+    ];
 
-test('inspect test containers', opts, function (tt) {
-    vasync.forEachPipeline({
-        inputs: Object.keys(containers),
-        func: function _inspectContainer(cname, cb) {
-            var container = containers[cname];
-
-            cli.inspect(tt, {
-                id: container.dockerId,
-                compareMessage: 'expect label com.joyent.package='
-                    + container.packageName,
-                partialExp: {
-                    Config: {
-                        Labels: {'com.joyent.package': container.packageName}
+    vasync.forEachPipeline(
+        {
+            inputs: vms,
+            func: function _createContainer(vmspec, cb) {
+                var cmdline =
+                    '--name ' +
+                    vmspec.name +
+                    ' ' +
+                    vmspec.pkgLabel +
+                    ' ' +
+                    IMAGE_NAME +
+                    ' sleep 3600';
+
+                cli.create(tt, {args: cmdline}, function(err, id) {
+                    tt.ifErr(err, 'expect no error for create');
+                    if (!err) {
+                        tt.ok(true, 'created ' + id);
+                        containers[vmspec.name] = {
+                            dockerId: id,
+                            packageName: vmspec.packageName
+                        };
                     }
-                }
-            }, cb);
+                    cb(err);
+                });
+            }
+        },
+        function _createdContainers(err) {
+            tt.ifError(err, 'created containers');
+            tt.end();
         }
-    }, function _inspectedContainers(err) {
-        tt.ifError(err, 'inspected containers');
-        tt.end();
-    });
+    );
 });
 
-test('test ps filtering on package', opts, function (tt) {
+test('inspect test containers', opts, function(tt) {
+    vasync.forEachPipeline(
+        {
+            inputs: Object.keys(containers),
+            func: function _inspectContainer(cname, cb) {
+                var container = containers[cname];
+
+                cli.inspect(
+                    tt,
+                    {
+                        id: container.dockerId,
+                        compareMessage: 'expect label com.joyent.package=' +
+                            container.packageName,
+                        partialExp: {
+                            Config: {
+                                Labels: {
+                                    'com.joyent.package': container.packageName
+                                }
+                            }
+                        }
+                    },
+                    cb
+                );
+            }
+        },
+        function _inspectedContainers(err) {
+            tt.ifError(err, 'inspected containers');
+            tt.end();
+        }
+    );
+});
+
+test('test ps filtering on package', opts, function(tt) {
     var expectedResults = {};
 
     // for each key in expectedResults, we'll check that all the containers with
@@ -204,130 +230,177 @@ test('test ps filtering on package', opts, function (tt) {
     expectedResults[packageB.uuid] = packageB.name;
     expectedResults[packageB.uuid.substr(0, 8)] = packageB.name;
 
-    vasync.forEachPipeline({
-        inputs: Object.keys(expectedResults),
-        func: function _performFilteredPs(pkg, cb) {
-            var argstring = '--filter "label=com.joyent.package=' + pkg + '"'
-                + ' --all';
-
-            cli.ps(tt, {
-                args: argstring
-            }, function (err, entries) {
-                var createdContainers = [];
-                var expectedContainers = [];
-                var foundContainers = [];
-
-                if (err) {
-                    cb(err);
-                    return;
-                }
-
-                createdContainers = Object.keys(containers).map(function (k) {
-                    return containers[k].dockerId.substr(0, 12);
-                });
-
-                expectedContainers = Object.keys(containers).map(function (k) {
-                    // first we make an array of the *values*
-                    // container: "[pkgA_byname] [object Object]"
-                    return (containers[k]);
-                }).filter(function (container) {
-                    // then we filter out those that don't have the package
-                    // we're looking for.
-                    if (container.packageName === expectedResults[pkg]) {
-                        return true;
-                    }
-                    return false;
-                }).map(function (container) {
-                    // then we turn into array of just shortened Ids
-                    return container.dockerId.substr(0, 12);
-                }).sort();
-
-                foundContainers = entries.map(function (entry) {
-                    // map the entries we found to an array of short Ids
-                    return entry.container_id;
-                }).filter(function (container) {
-                    // filter out those we didn't create
-                    if (createdContainers.indexOf(container) !== -1) {
-                        return true;
+    vasync.forEachPipeline(
+        {
+            inputs: Object.keys(expectedResults),
+            func: function _performFilteredPs(pkg, cb) {
+                var argstring =
+                    '--filter "label=com.joyent.package=' +
+                    pkg +
+                    '"' +
+                    ' --all';
+
+                cli.ps(
+                    tt,
+                    {
+                        args: argstring
+                    },
+                    function(err, entries) {
+                        var createdContainers = [];
+                        var expectedContainers = [];
+                        var foundContainers = [];
+
+                        if (err) {
+                            cb(err);
+                            return;
+                        }
+
+                        createdContainers = Object.keys(
+                            containers
+                        ).map(function(k) {
+                            return containers[k].dockerId.substr(0, 12);
+                        });
+
+                        expectedContainers = Object.keys(containers)
+                            .map(function(k) {
+                                // first we make an array of the *values*
+                                // container: "[pkgA_byname] [object Object]"
+                                return containers[k];
+                            })
+                            .filter(function(container) {
+                                // then we filter out those that don't have the package
+                                // we're looking for.
+                                if (
+                                    container.packageName ===
+                                    expectedResults[pkg]
+                                ) {
+                                    return true;
+                                }
+                                return false;
+                            })
+                            .map(function(container) {
+                                // then we turn into array of just shortened Ids
+                                return container.dockerId.substr(0, 12);
+                            })
+                            .sort();
+
+                        foundContainers = entries
+                            .map(function(entry) {
+                                // map the entries we found to an array of short Ids
+                                return entry.container_id;
+                            })
+                            .filter(function(container) {
+                                // filter out those we didn't create
+                                if (
+                                    createdContainers.indexOf(container) !== -1
+                                ) {
+                                    return true;
+                                }
+                                return false;
+                            })
+                            .sort();
+
+                        tt.deepEqual(
+                            foundContainers,
+                            expectedContainers,
+                            'should only ' +
+                                'see containers with package ' +
+                                expectedResults[pkg]
+                        );
+
+                        cb();
                     }
-                    return false;
-                }).sort();
-
-                tt.deepEqual(foundContainers, expectedContainers, 'should only '
-                    + 'see containers with package ' + expectedResults[pkg]);
-
-                cb();
-            });
+                );
+            }
+        },
+        function _performedFilteredPs(err) {
+            tt.ifError(err, 'performed filtered ps tests');
+            tt.end();
         }
-    }, function _performedFilteredPs(err) {
-        tt.ifError(err, 'performed filtered ps tests');
-        tt.end();
-    });
+    );
 });
 
-test('test creation w/ invalid package names', opts, function (tt) {
-    var invalidPrefix = 'Error response from daemon: invalid value for '
-        + 'com.joyent.package: ';
+test('test creation w/ invalid package names', opts, function(tt) {
+    var invalidPrefix =
+        'Error response from daemon: invalid value for ' +
+        'com.joyent.package: ';
     var labels = [];
-    var nonexistErr = 'Error response from daemon: no packages match '
-        + 'parameters';
+    var nonexistErr =
+        'Error response from daemon: no packages match ' + 'parameters';
 
     labels = [
         {
             name: '_bacon', // leading underscore invalid
             errPrefix: invalidPrefix
-        }, {
+        },
+        {
             name: 'bacon-', // trailing '-' is invalid
             errPrefix: invalidPrefix
-        }, {
+        },
+        {
             name: 'bacon!', // '!' is invalid
             errPrefix: invalidPrefix
-        }, {
+        },
+        {
             name: '💩', // non-ASCII should not be allowed
             errPrefix: invalidPrefix
-        }, {
+        },
+        {
             name: '	', // tabs -- like poo -- are not allowed
             errPrefix: invalidPrefix
-        }, {
+        },
+        {
             name: '.', // can't start or end with '.'
             errPrefix: invalidPrefix
-        }, {
+        },
+        {
             name: '', // empty name should be invalid
             errPrefix: invalidPrefix
-        }, {
+        },
+        {
             name: 'hello--world', // consecutive '-' not allowed
             errPrefix: invalidPrefix
-        }, {
+        },
+        {
             name: 'package-that-does-not-exist',
             errString: nonexistErr
         }
     ];
 
-    vasync.forEachPipeline({
-        inputs: labels,
-        func: function _createContainer(label, cb) {
-            var cmdline = '--label com.joyent.package="' + label.name + '" '
-                + IMAGE_NAME + ' sleep 3600';
-
-            cli.create(tt, {
-                args: cmdline,
-                expectedErr: (
-                    label.errString
-                    ? label.errString
-                    : label.errPrefix + label.name
-                )
-            }, function (err, id) {
-                tt.ok(err, 'expected error for create');
-                cb();
-            });
+    vasync.forEachPipeline(
+        {
+            inputs: labels,
+            func: function _createContainer(label, cb) {
+                var cmdline =
+                    '--label com.joyent.package="' +
+                    label.name +
+                    '" ' +
+                    IMAGE_NAME +
+                    ' sleep 3600';
+
+                cli.create(
+                    tt,
+                    {
+                        args: cmdline,
+                        expectedErr: label.errString
+                            ? label.errString
+                            : label.errPrefix + label.name
+                    },
+                    function(err, id) {
+                        tt.ok(err, 'expected error for create');
+                        cb();
+                    }
+                );
+            }
+        },
+        function _createdContainers(err) {
+            tt.ifError(err, 'tried to create containers');
+            tt.end();
         }
-    }, function _createdContainers(err) {
-        tt.ifError(err, 'tried to create containers');
-        tt.end();
-    });
+    );
 });
 
-test('test lookup w/ invalid package names', opts, function (tt) {
+test('test lookup w/ invalid package names', opts, function(tt) {
     var labels = [
         '_bacon', // leading underscore invalid
         'bacon-', // trailing '-' is invalid
@@ -337,34 +410,49 @@ test('test lookup w/ invalid package names', opts, function (tt) {
         'hello--world' // consecutive '-' not allowed
     ];
 
-    vasync.forEachPipeline({
-        inputs: labels,
-        func: function _lookupContainer(label, cb) {
-            var argstring = '--format "{{.ID}}:\t{{.Labels}}" '
-                + '--filter "label=com.joyent.package=' + label + '" '
-                + ' --all';
-
-            cli.ps(tt, {
-                args: argstring,
-                expectedErr: 'Error response from daemon: invalid value for '
-                    + 'com.joyent.package: ' + label
-            }, function (err, entries) {
-                tt.ok(err, 'expected error for ps (' + label + ')');
-                tt.equal(entries, undefined, 'expected no entries in output');
-                cb();
-            });
+    vasync.forEachPipeline(
+        {
+            inputs: labels,
+            func: function _lookupContainer(label, cb) {
+                var argstring =
+                    '--format "{{.ID}}:\t{{.Labels}}" ' +
+                    '--filter "label=com.joyent.package=' +
+                    label +
+                    '" ' +
+                    ' --all';
+
+                cli.ps(
+                    tt,
+                    {
+                        args: argstring,
+                        expectedErr: 'Error response from daemon: invalid value for ' +
+                            'com.joyent.package: ' +
+                            label
+                    },
+                    function(err, entries) {
+                        tt.ok(err, 'expected error for ps (' + label + ')');
+                        tt.equal(
+                            entries,
+                            undefined,
+                            'expected no entries in output'
+                        );
+                        cb();
+                    }
+                );
+            }
+        },
+        function _lookedupContainers(err) {
+            tt.ifError(err, 'tried to lookup containers w/ filter');
+            tt.end();
         }
-    }, function _lookedupContainers(err) {
-        tt.ifError(err, 'tried to lookup containers w/ filter');
-        tt.end();
-    });
+    );
 });
 
 /*
  * packageC we created with a random owner, so we shouldn't be able to provision
  * with it because that random owner is not us.
  */
-test('test creation w/ non-owned package', opts, function (tt) {
+test('test creation w/ non-owned package', opts, function(tt) {
     var cmdline;
 
     if (!packageC || !packageC.uuid) {
@@ -373,33 +461,49 @@ test('test creation w/ non-owned package', opts, function (tt) {
         return;
     }
 
-    cmdline = '--label com.joyent.package="' + packageC.uuid + '" '
-        + IMAGE_NAME + ' sleep 3600';
+    cmdline =
+        '--label com.joyent.package="' +
+        packageC.uuid +
+        '" ' +
+        IMAGE_NAME +
+        ' sleep 3600';
 
-    cli.create(tt, {
-        args: cmdline,
-        expectedErr: 'Error response from daemon: no packages match parameters'
-    }, function (err, id) {
-        tt.ok(err, 'expected error for create');
-        tt.end();
-    });
+    cli.create(
+        tt,
+        {
+            args: cmdline,
+            expectedErr: 'Error response from daemon: no packages match parameters'
+        },
+        function(err, id) {
+            tt.ok(err, 'expected error for create');
+            tt.end();
+        }
+    );
 });
 
 /*
  * When a VM is created with 2 labels, the second will take precendence and a VM
  * should be created with that package.
  */
-test('test creation w/ two package labels', opts, function (tt) {
+test('test creation w/ two package labels', opts, function(tt) {
     var cmdline;
 
-    cmdline = '--label com.joyent.package="' + packageA.uuid + '" '
-        + '--label com.joyent.package="' + packageB.uuid + '" '
-        + IMAGE_NAME + ' sleep 3600';
-
-    cli.create(tt, {args: cmdline}, function (err, id) {
-        var argstring = '--filter "label=com.joyent.package=' + packageB.name
-            + '" --all --format '
-            + '\"{{.ID}},{{.Label \\\"com.joyent.package\\\"}}\"';
+    cmdline =
+        '--label com.joyent.package="' +
+        packageA.uuid +
+        '" ' +
+        '--label com.joyent.package="' +
+        packageB.uuid +
+        '" ' +
+        IMAGE_NAME +
+        ' sleep 3600';
+
+    cli.create(tt, {args: cmdline}, function(err, id) {
+        var argstring =
+            '--filter "label=com.joyent.package=' +
+            packageB.name +
+            '" --all --format ' +
+            '"{{.ID}},{{.Label \\"com.joyent.package\\"}}"';
         var shortId;
 
         tt.ifErr(err, 'expect no error for create');
@@ -411,50 +515,67 @@ test('test creation w/ two package labels', opts, function (tt) {
             // Need to ensure that this got the right package (packageB)
             // This also ensures that the container list via `docker ps` is
             // including the package name correctly.
-            cli.ps(tt, {
-                args: argstring,
-                linesOnly: true
-            }, function (e, entries) {
-                var wrongPackages = [];
-
-                tt.ifError(e, 'list containers after creation');
-                tt.ok(entries.indexOf(shortId + ',' + packageB.name) !== -1,
-                    '`docker ps` shows ' + shortId + ' with packageB');
-                entries.forEach(function _checkEachPkg(entry) {
-                    if (entry.split(',')[1] !== packageB.name) {
-                        wrongPackages.push(entry);
-                    }
-                });
-                tt.deepEqual(wrongPackages, [], 'expected all packages to be '
-                    + packageB.name);
-                tt.end();
-            });
+            cli.ps(
+                tt,
+                {
+                    args: argstring,
+                    linesOnly: true
+                },
+                function(e, entries) {
+                    var wrongPackages = [];
+
+                    tt.ifError(e, 'list containers after creation');
+                    tt.ok(
+                        entries.indexOf(shortId + ',' + packageB.name) !== -1,
+                        '`docker ps` shows ' + shortId + ' with packageB'
+                    );
+                    entries.forEach(function _checkEachPkg(entry) {
+                        if (entry.split(',')[1] !== packageB.name) {
+                            wrongPackages.push(entry);
+                        }
+                    });
+                    tt.deepEqual(
+                        wrongPackages,
+                        [],
+                        'expected all packages to be ' + packageB.name
+                    );
+                    tt.end();
+                }
+            );
         } else {
             tt.end();
         }
     });
 });
 
-test('teardown', opts, function (tt) {
+test('teardown', opts, function(tt) {
     // cleanup the package we created
-    vasync.pipeline({funcs: [
-        function _rmCreatedPackages(_, cb) {
-            if (!packageC || !packageC.uuid) {
-                tt.ok(true, 'no packageC to delete');
-                cb();
-                return;
-            }
-            papi.del(packageC.uuid, {force: true}, function _papiDelCb(err) {
-                tt.ifError(err, 'papi delete packageC');
-                cb();
-            });
-        }, function _rmCreatedContainers(_, cb) {
-            // this must come last in the 'funcs' because it ends the test on us
-            cli.rmAllCreated(tt);
-            cb();
+    vasync.pipeline(
+        {
+            funcs: [
+                function _rmCreatedPackages(_, cb) {
+                    if (!packageC || !packageC.uuid) {
+                        tt.ok(true, 'no packageC to delete');
+                        cb();
+                        return;
+                    }
+                    papi.del(packageC.uuid, {force: true}, function _papiDelCb(
+                        err
+                    ) {
+                        tt.ifError(err, 'papi delete packageC');
+                        cb();
+                    });
+                },
+                function _rmCreatedContainers(_, cb) {
+                    // this must come last in the 'funcs' because it ends the test on us
+                    cli.rmAllCreated(tt);
+                    cb();
+                }
+            ]
+        },
+        function _teardownComplete() {
+            // cli.rmAllCreated() ends our test, so nothing more to do
+            return;
         }
-    ]}, function _teardownComplete() {
-        // cli.rmAllCreated() ends our test, so nothing more to do
-        return;
-    });
+    );
 });
diff --git a/test/integration/cli-pull.test.js b/test/integration/cli-pull.test.js
index 97b8171..dd740ca 100644
--- a/test/integration/cli-pull.test.js
+++ b/test/integration/cli-pull.test.js
@@ -18,14 +18,11 @@ var test = require('tape');
 var h = require('./helpers');
 var cli = require('../lib/cli');
 
-
 // --- Tests
 
-test('docker pull', function (tt) {
-
+test('docker pull', function(tt) {
     tt.test('  setup: alice init', cli.init);
 
-
     /**
      * Check for reasonable error messages for some 'docker pull' failures.
      * Some related issues: DOCKER-639, DOCKER-689
@@ -49,16 +46,28 @@ test('docker pull', function (tt) {
      *  time="2017-01-03T21:39:05Z" level=fatal msg="Error: image no-such-repo:latest not found (50e45d88-9b6e-4faa-9f92-56d81f8d27c1)"
      */
     /* END JSSTYLED */
-    tt.test('  docker pull no-such-repo', function (t) {
-        cli.docker('pull no-such-repo', function (err, stdout, stderr) {
+    tt.test('  docker pull no-such-repo', function(t) {
+        cli.docker('pull no-such-repo', function(err, stdout, stderr) {
             t.ok(err, 'expect failed pull: ' + err);
 
             // With Docker 1.6 the error
-            t.ok(/Error: image no-such-repo:latest not found/m.test(stderr),
-                format('stderr includes "Error: image $name not found", '
-                    + 'stdout=%j, stderr=%j', stdout, stderr));
-            t.ok(! /unauthorized/i.test(stderr), format('stderr does '
-                + '*not* contain "unauthorized", from stderr=%j', stderr));
+            t.ok(
+                /Error: image no-such-repo:latest not found/m.test(stderr),
+                format(
+                    'stderr includes "Error: image $name not found", ' +
+                        'stdout=%j, stderr=%j',
+                    stdout,
+                    stderr
+                )
+            );
+            t.ok(
+                !/unauthorized/i.test(stderr),
+                format(
+                    'stderr does ' +
+                        '*not* contain "unauthorized", from stderr=%j',
+                    stderr
+                )
+            );
 
             t.end();
         });
@@ -79,17 +88,29 @@ test('docker pull', function (tt) {
      * I think Triton's is an improvement.
      */
     /* END JSSTYLED */
-    tt.test('  docker pull quay.io/no-such-user', function (t) {
-        cli.docker('pull quay.io/no-such-user',
-                function (err, stdout, stderr) {
+    tt.test('  docker pull quay.io/no-such-user', function(t) {
+        cli.docker('pull quay.io/no-such-user', function(err, stdout, stderr) {
             t.ok(err, 'expect failed pull: ' + err);
 
-            t.ok(/Error: image quay.io\/no-such-user:latest not found/m
-                    .test(stderr),
-                format('stderr includes "Error: image $name not found", '
-                    + 'stdout=%j, stderr=%j', stdout, stderr));
-            t.ok(! /unauthorized/i.test(stderr), format('stderr does '
-                + '*not* contain "unauthorized", from stderr=%j', stderr));
+            t.ok(
+                /Error: image quay.io\/no-such-user:latest not found/m.test(
+                    stderr
+                ),
+                format(
+                    'stderr includes "Error: image $name not found", ' +
+                        'stdout=%j, stderr=%j',
+                    stdout,
+                    stderr
+                )
+            );
+            t.ok(
+                !/unauthorized/i.test(stderr),
+                format(
+                    'stderr does ' +
+                        '*not* contain "unauthorized", from stderr=%j',
+                    stderr
+                )
+            );
 
             t.end();
         });
@@ -108,18 +129,18 @@ test('docker pull', function (tt) {
      *  Error pulling image: (RemoteSourceError) nope.example.com host not found (...)
      */
     /* END JSSTYLED */
-    tt.test('  docker pull nope.example.com/nope', function (t) {
-        cli.docker('pull nope.example.com/nope',
-            function (err, stdout, stderr) {
+    tt.test('  docker pull nope.example.com/nope', function(t) {
+        cli.docker('pull nope.example.com/nope', function(err, stdout, stderr) {
             t.ok(err, 'expect failed pull: ' + err);
 
             /* JSSTYLED */
             var pat = /Error pulling image: \(RemoteSourceError\) nope.example.com host not found/m;
-            t.ok(pat.test(stderr), format('stderr matches %s, stderr=%j',
-                pat, stderr));
+            t.ok(
+                pat.test(stderr),
+                format('stderr matches %s, stderr=%j', pat, stderr)
+            );
 
             t.end();
         });
     });
-
 });
diff --git a/test/integration/cli-run-add-host.test.js b/test/integration/cli-run-add-host.test.js
index 6096d75..22f0217 100644
--- a/test/integration/cli-run-add-host.test.js
+++ b/test/integration/cli-run-add-host.test.js
@@ -20,38 +20,36 @@ var vasync = require('vasync');
 var cli = require('../lib/cli');
 var vm = require('../lib/vm');
 
-
 // --- Globals
 
 var CONTAINER_PREFIX = 'sdcdockertest_runaddhost_';
 
-
 // --- Tests
 
-test('setup', function (tt) {
+test('setup', function(tt) {
     tt.test('  test CLI init', cli.init);
     tt.test('  vmapi client init', vm.init);
 });
 
-
-test('docker run --add-host foo:1.2.3.4', function (tt) {
+test('docker run --add-host foo:1.2.3.4', function(tt) {
     var containerId;
 
     var containerName = CONTAINER_PREFIX + libuuid.create().split('-')[0];
     tt.ok(containerName, 'containerName: ' + containerName);
 
-    tt.test('  docker run --add-host foo:1.2.3.4 ...', function (t) {
+    tt.test('  docker run --add-host foo:1.2.3.4 ...', function(t) {
         var args = format(
             '--add-host foo:1.2.3.4 -d --name %s alpine sleep 3600',
-            containerName);
-        cli.run(t, {args: args}, function (err, id) {
+            containerName
+        );
+        cli.run(t, {args: args}, function(err, id) {
             t.ifErr(err, 'docker run --add-host foo:1.2.3.4 ...');
             containerId = id;
             t.end();
         });
     });
 
-    tt.test('  check VM.internal_metadata["docker:extraHosts"]', function (t) {
+    tt.test('  check VM.internal_metadata["docker:extraHosts"]', function(t) {
         vm.get(t, {
             id: containerId,
             partialExp: {
@@ -62,16 +60,16 @@ test('docker run --add-host foo:1.2.3.4', function (tt) {
         });
     });
 
-    tt.test('  check that /etc/hosts has the "foo" entry', function (t) {
+    tt.test('  check that /etc/hosts has the "foo" entry', function(t) {
         var cmd = 'exec ' + containerName + ' grep foo /etc/hosts';
-        cli.docker(cmd, function (err, stdout, stderr) {
+        cli.docker(cmd, function(err, stdout, stderr) {
             t.ifErr(err, 'docker CONTAINER grep foo /etc/hosts');
             t.equal(stdout, '1.2.3.4\tfoo\n');
             t.end();
         });
     });
 
-    tt.test('  check that ExtraHosts is set in inspect output', function (t) {
+    tt.test('  check that ExtraHosts is set in inspect output', function(t) {
         cli.inspect(t, {
             id: containerId,
             partialExp: {
@@ -83,5 +81,4 @@ test('docker run --add-host foo:1.2.3.4', function (tt) {
     });
 });
 
-
 test('teardown', cli.rmAllCreated);
diff --git a/test/integration/cli-run-ports.test.js b/test/integration/cli-run-ports.test.js
index 8b31691..abcf78a 100644
--- a/test/integration/cli-run-ports.test.js
+++ b/test/integration/cli-run-ports.test.js
@@ -22,8 +22,6 @@ var h = require('./helpers');
 var vm = require('../lib/vm');
 var test = require('tape');
 
-
-
 // --- Globals
 var MAX_PORTS_PER_RULE = 8;
 var FWRULE_VERSION = 1;
@@ -31,10 +29,8 @@ var FWRULE_VERSION = 1;
 var EXPOSED_PORTS = {};
 var CLIENTS = {};
 
-
 // --- Helpers
 
-
 /**
  * Return a rule for exposing ports
  */
@@ -44,11 +40,14 @@ function exposeRule(proto, vmID, ports) {
         ruleVM = h.dockerIdToUuid(vmID);
     }
 
-    return fmt('FROM any TO vm %s ALLOW %s %sPORT %s%s',
-        ruleVM, proto,
-        (ports.length === 1 ? '' : '('),
+    return fmt(
+        'FROM any TO vm %s ALLOW %s %sPORT %s%s',
+        ruleVM,
+        proto,
+        ports.length === 1 ? '' : '(',
         ports.join(' AND PORT '),
-        (ports.length === 1 ? '' : ')'));
+        ports.length === 1 ? '' : ')'
+    );
 }
 
 function exposeRange(proto, vmID, start, end) {
@@ -57,16 +56,20 @@ function exposeRange(proto, vmID, start, end) {
         ruleVM = h.dockerIdToUuid(vmID);
     }
 
-    return fmt('FROM any TO vm %s ALLOW %s PORTS %s - %s',
-        ruleVM, proto, start, end);
+    return fmt(
+        'FROM any TO vm %s ALLOW %s PORTS %s - %s',
+        ruleVM,
+        proto,
+        start,
+        end
+    );
 }
 
-
 /**
  * List firewall rules and compare to opts.expected
  */
 function listFwRules(t, opts) {
-    CLIENTS.fwapi.listRules(opts.filter, function (err, rules) {
+    CLIENTS.fwapi.listRules(opts.filter, function(err, rules) {
         t.ifErr(err, 'list firewall rules');
         if (err) {
             t.end();
@@ -75,37 +78,45 @@ function listFwRules(t, opts) {
 
         var expLength = opts.expected.length;
         t.equal(rules.length, expLength, expLength + ' rules returned');
-        t.deepEqual(rules.map(function (r) { return r.rule; }).sort(),
-            opts.expected, 'expected rules present');
+        t.deepEqual(
+            rules
+                .map(function(r) {
+                    return r.rule;
+                })
+                .sort(),
+            opts.expected,
+            'expected rules present'
+        );
 
         t.end();
         return;
     });
 }
 
-
 /**
  * Transform a port into the NetworkSettings.Ports format
  */
 function netSettingsPort(port) {
-    return [ {
-        HostIp: '0.0.0.0',
-        HostPort: port.toString()
-    } ];
+    return [
+        {
+            HostIp: '0.0.0.0',
+            HostPort: port.toString()
+        }
+    ];
 }
 
-
 /**
  * Transform a port into the HostConfig.PortBindings format
  */
 function portBindingsPort(port) {
-    return [ {
-        HostIp: '',
-        HostPort: port.toString()
-    } ];
+    return [
+        {
+            HostIp: '',
+            HostPort: port.toString()
+        }
+    ];
 }
 
-
 /**
  * Return an all-zeros IP + port
  */
@@ -113,20 +124,15 @@ function zeroAddr(port) {
     return '0.0.0.0:' + port.toString();
 }
 
-
 // --- Tests
 
-
-test('setup', function (tt) {
-
+test('setup', function(tt) {
     tt.test('DockerEnv: alice init', cli.init);
 
-
     tt.test('vmapi client', vm.init);
 
-
-    tt.test('fwapi client', function (t) {
-        h.createFwapiClient(function (err, client) {
+    tt.test('fwapi client', function(t) {
+        h.createFwapiClient(function(err, client) {
             t.error(err, 'fwapi client err');
             CLIENTS.fwapi = client;
             t.end();
@@ -134,8 +140,8 @@ test('setup', function (tt) {
         });
     });
 
-    tt.test('sapi client', function (t) {
-        h.createSapiClient(function (err, client) {
+    tt.test('sapi client', function(t) {
+        h.createSapiClient(function(err, client) {
             t.error(err, 'Error creating SAPI client');
             CLIENTS.sapi = client;
             t.end();
@@ -143,10 +149,11 @@ test('setup', function (tt) {
         });
     });
 
-    tt.test('FWRULE_VERSION', function (t) {
-        CLIENTS.sapi.getConfig(process.env.DOCKER_UUID, {},
-            function (err, config) {
-
+    tt.test('FWRULE_VERSION', function(t) {
+        CLIENTS.sapi.getConfig(process.env.DOCKER_UUID, {}, function(
+            err,
+            config
+        ) {
             t.error(err, 'Error getting Docker config');
             if (config.metadata.hasOwnProperty('FWRULE_VERSION')) {
                 FWRULE_VERSION = config.metadata.FWRULE_VERSION;
@@ -155,37 +162,36 @@ test('setup', function (tt) {
         });
     });
 
-    tt.test('pull nginx image', function (t) {
+    tt.test('pull nginx image', function(t) {
         cli.pull(t, {
             image: 'nginx:latest'
         });
     });
 
+    tt.test('inspect nginx image', function(t) {
+        cli.inspect(
+            t,
+            {
+                id: 'nginx:latest'
+            },
+            function(err, img) {
+                if (img) {
+                    EXPOSED_PORTS = img.Config.ExposedPorts;
+                }
 
-    tt.test('inspect nginx image', function (t) {
-        cli.inspect(t, {
-            id: 'nginx:latest'
-        }, function (err, img) {
-            if (img) {
-                EXPOSED_PORTS = img.Config.ExposedPorts;
+                t.end();
+                return;
             }
-
-            t.end();
-            return;
-        });
+        );
     });
-
 });
 
-
-test('no port args', function (tt) {
-
-    tt.test('docker run: no port args', function (t) {
-        cli.run(t, { args: '-d nginx:latest' });
+test('no port args', function(tt) {
+    tt.test('docker run: no port args', function(t) {
+        cli.run(t, {args: '-d nginx:latest'});
     });
 
-
-    tt.test('docker firewall rules created', function (t) {
+    tt.test('docker firewall rules created', function(t) {
         listFwRules(t, {
             filter: {
                 owner_uuid: cli.accountUuid,
@@ -198,8 +204,7 @@ test('no port args', function (tt) {
         });
     });
 
-
-    tt.test('expose firewall rules not created', function (t) {
+    tt.test('expose firewall rules not created', function(t) {
         listFwRules(t, {
             filter: {
                 owner_uuid: cli.accountUuid,
@@ -209,14 +214,13 @@ test('no port args', function (tt) {
         });
     });
 
-
-    tt.test('no port args: VMAPI tags', function (t) {
+    tt.test('no port args: VMAPI tags', function(t) {
         vm.get(t, {
             id: cli.lastCreated,
             partialExp: {
                 firewall_enabled: true,
                 internal_metadata: {
-                    'docker:tcp_unpublished_ports': JSON.stringify([ 443, 80 ])
+                    'docker:tcp_unpublished_ports': JSON.stringify([443, 80])
                 },
                 tags: {
                     sdc_docker: true
@@ -225,8 +229,7 @@ test('no port args', function (tt) {
         });
     });
 
-
-    tt.test('no port args: inspect', function (t) {
+    tt.test('no port args: inspect', function(t) {
         var partial = {
             Config: {
                 ExposedPorts: EXPOSED_PORTS
@@ -249,33 +252,28 @@ test('no port args', function (tt) {
         });
     });
 
-
-    tt.test('no port args: port', function (t) {
+    tt.test('no port args: port', function(t) {
         cli.port(t, {
             id: cli.lastCreated,
             expected: {}
         });
     });
-
 });
 
-
-test('-P', function (tt) {
-
-    tt.test('docker run -P', function (t) {
-        cli.run(t, { args: '-P -d nginx:latest' });
+test('-P', function(tt) {
+    tt.test('docker run -P', function(t) {
+        cli.run(t, {args: '-P -d nginx:latest'});
     });
 
-
-    tt.test('-P: inspect', function (t) {
+    tt.test('-P: inspect', function(t) {
         var partial = {
             Config: {
                 ExposedPorts: EXPOSED_PORTS
             },
             HostConfig: {
                 PortBindings: {
-                    '80/tcp' : portBindingsPort(80),
-                    '443/tcp' : portBindingsPort(443)
+                    '80/tcp': portBindingsPort(80),
+                    '443/tcp': portBindingsPort(443)
                 },
                 PublishAllPorts: true
             },
@@ -293,20 +291,17 @@ test('-P', function (tt) {
         });
     });
 
-
-    tt.test('-P: expose firewall rules created', function (t) {
+    tt.test('-P: expose firewall rules created', function(t) {
         listFwRules(t, {
             filter: {
                 owner_uuid: cli.accountUuid,
                 vm: h.dockerIdToUuid(cli.lastCreated)
             },
-            expected: [
-                exposeRule('tcp', cli.lastCreated, [80, 443])
-            ]
+            expected: [exposeRule('tcp', cli.lastCreated, [80, 443])]
         });
     });
 
-    tt.test('-P: VMAPI metadata', function (t) {
+    tt.test('-P: VMAPI metadata', function(t) {
         vm.get(t, {
             id: cli.lastCreated,
             partialExp: {
@@ -321,8 +316,7 @@ test('-P', function (tt) {
         });
     });
 
-
-    tt.test('-P: port', function (t) {
+    tt.test('-P: port', function(t) {
         cli.port(t, {
             id: cli.lastCreated,
             expected: {
@@ -331,18 +325,14 @@ test('-P', function (tt) {
             }
         });
     });
-
 });
 
-
-test('-p', function (tt) {
-
-    tt.test('docker run -p 80:80', function (t) {
-        cli.run(t, { args: '-p 80:80 -d nginx:latest' });
+test('-p', function(tt) {
+    tt.test('docker run -p 80:80', function(t) {
+        cli.run(t, {args: '-p 80:80 -d nginx:latest'});
     });
 
-
-    tt.test('-p 80:80: inspect', function (t) {
+    tt.test('-p 80:80: inspect', function(t) {
         var partial = {
             Config: {
                 ExposedPorts: EXPOSED_PORTS
@@ -367,27 +357,23 @@ test('-p', function (tt) {
         });
     });
 
-
-    tt.test('-p 80:80: expose firewall rules created', function (t) {
+    tt.test('-p 80:80: expose firewall rules created', function(t) {
         listFwRules(t, {
             filter: {
                 owner_uuid: cli.accountUuid,
                 vm: h.dockerIdToUuid(cli.lastCreated)
             },
-            expected: [
-                exposeRule('tcp', cli.lastCreated, [80])
-            ]
+            expected: [exposeRule('tcp', cli.lastCreated, [80])]
         });
     });
 
-
-    tt.test('-p 80:80: VMAPI metadata', function (t) {
+    tt.test('-p 80:80: VMAPI metadata', function(t) {
         vm.get(t, {
             id: cli.lastCreated,
             partialExp: {
                 firewall_enabled: true,
                 internal_metadata: {
-                    'docker:tcp_unpublished_ports': JSON.stringify([ 443 ])
+                    'docker:tcp_unpublished_ports': JSON.stringify([443])
                 },
                 tags: {
                     sdc_docker: true
@@ -396,8 +382,7 @@ test('-p', function (tt) {
         });
     });
 
-
-    tt.test('-P: port', function (t) {
+    tt.test('-P: port', function(t) {
         cli.port(t, {
             id: cli.lastCreated,
             expected: {
@@ -406,27 +391,22 @@ test('-p', function (tt) {
         });
     });
 
-
-    tt.test('docker run -p 8080:80', function (t) {
+    tt.test('docker run -p 8080:80', function(t) {
         // We don't allow remapping of ports (for now, at least):
         cli.run(t, {
             args: '-p 8080:80 -d nginx:latest',
-            expectedErr: 'Error response from daemon: publish port: '
-                + 'remapping of port numbers not allowed'
+            expectedErr: 'Error response from daemon: publish port: ' +
+                'remapping of port numbers not allowed'
         });
     });
-
 });
 
-
-test('-P and -p', function (tt) {
-
-    tt.test('docker run -P -p 54:54/udp -p 90:90', function (t) {
-        cli.run(t, { args: '-P -p 54:54/udp -p 90:90 -d nginx:latest' });
+test('-P and -p', function(tt) {
+    tt.test('docker run -P -p 54:54/udp -p 90:90', function(t) {
+        cli.run(t, {args: '-P -p 54:54/udp -p 90:90 -d nginx:latest'});
     });
 
-
-    tt.test('-P and -p: expose firewall rules created', function (t) {
+    tt.test('-P and -p: expose firewall rules created', function(t) {
         listFwRules(t, {
             filter: {
                 owner_uuid: cli.accountUuid,
@@ -439,8 +419,7 @@ test('-P and -p', function (tt) {
         });
     });
 
-
-    tt.test('-P and -p: VMAPI metadata', function (t) {
+    tt.test('-P and -p: VMAPI metadata', function(t) {
         vm.get(t, {
             id: cli.lastCreated,
             partialExp: {
@@ -455,8 +434,7 @@ test('-P and -p', function (tt) {
         });
     });
 
-
-    tt.test('-P and -p: inspect', function (t) {
+    tt.test('-P and -p: inspect', function(t) {
         var partial = {
             Config: {
                 ExposedPorts: extend(EXPOSED_PORTS, {
@@ -489,8 +467,7 @@ test('-P and -p', function (tt) {
         });
     });
 
-
-    tt.test('-P and -p: port', function (t) {
+    tt.test('-P and -p: port', function(t) {
         cli.port(t, {
             id: cli.lastCreated,
             expected: {
@@ -501,11 +478,9 @@ test('-P and -p', function (tt) {
             }
         });
     });
-
 });
 
-
-test('-p range', function (tt) {
+test('-p range', function(tt) {
     var large_range = '';
     var p;
     var ports = [];
@@ -513,14 +488,28 @@ test('-p range', function (tt) {
     var START_PORT = 50;
     var END_PORT = START_PORT + constants.MAX_EXPOSED_PORTS - 1;
 
-    tt.test(fmt('docker run -p %d-%d:%d-%d', START_PORT, END_PORT,
-        START_PORT, END_PORT), function (t) {
-        cli.run(t, { args: fmt('-p %d-%d:%d-%d/tcp -d nginx:latest', START_PORT,
-            END_PORT, START_PORT, END_PORT) });
-    });
-
+    tt.test(
+        fmt(
+            'docker run -p %d-%d:%d-%d',
+            START_PORT,
+            END_PORT,
+            START_PORT,
+            END_PORT
+        ),
+        function(t) {
+            cli.run(t, {
+                args: fmt(
+                    '-p %d-%d:%d-%d/tcp -d nginx:latest',
+                    START_PORT,
+                    END_PORT,
+                    START_PORT,
+                    END_PORT
+                )
+            });
+        }
+    );
 
-    tt.test('-p range: inspect', function (t) {
+    tt.test('-p range: inspect', function(t) {
         var partial = {
             Config: {
                 ExposedPorts: EXPOSED_PORTS
@@ -549,7 +538,7 @@ test('-p range', function (tt) {
         });
     });
 
-    tt.test('-p range:80: expose firewall rules created', function (t) {
+    tt.test('-p range:80: expose firewall rules created', function(t) {
         // odd implementation details here:
         // FWAPI supports 8 ports per rule, and rules are returned in
         // lexicographic order. Port groupings are also determined by
@@ -570,13 +559,22 @@ test('-p range', function (tt) {
         var expectedRules = [];
         if (FWRULE_VERSION > 1) {
             expectedRules.push(
-                exposeRange('tcp', cli.lastCreated, START_PORT, END_PORT));
+                exposeRange('tcp', cli.lastCreated, START_PORT, END_PORT)
+            );
         } else {
             ports.sort();
             for (var i = 0; i < ports.length; i += MAX_PORTS_PER_RULE) {
-                expectedRules.push(exposeRule('tcp', cli.lastCreated,
-                    ports.slice(i, i + MAX_PORTS_PER_RULE)
-                        .sort(function (a, b) { return a > b; })));
+                expectedRules.push(
+                    exposeRule(
+                        'tcp',
+                        cli.lastCreated,
+                        ports
+                            .slice(i, i + MAX_PORTS_PER_RULE)
+                            .sort(function(a, b) {
+                                return a > b;
+                            })
+                    )
+                );
             }
             expectedRules.sort();
         }
@@ -590,8 +588,7 @@ test('-p range', function (tt) {
         });
     });
 
-
-    tt.test('-p range: VMAPI metadata', function (t) {
+    tt.test('-p range: VMAPI metadata', function(t) {
         // expect lexicographic order.
         ports.sort();
         vm.get(t, {
@@ -606,8 +603,7 @@ test('-p range', function (tt) {
         });
     });
 
-
-    tt.test('-P: port', function (t) {
+    tt.test('-P: port', function(t) {
         var exp = {};
         for (p = START_PORT; p <= END_PORT; p++) {
             exp[p + '/tcp'] = zeroAddr(p);
@@ -624,16 +620,17 @@ test('-p range', function (tt) {
     }
 
     // Make sure the limit of 32 ports is enforced:
-    tt.test(fmt('docker run %s', large_range), function (t) {
+    tt.test(fmt('docker run %s', large_range), function(t) {
         cli.run(t, {
             args: fmt('%s -d nginx:latest', large_range),
-            expectedErr: 'Error response from daemon: publish port: '
-                + fmt('only support exposing %d TCP %s',
+            expectedErr: 'Error response from daemon: publish port: ' +
+                fmt(
+                    'only support exposing %d TCP %s',
                     constants.MAX_EXPOSED_PORTS,
-                    FWRULE_VERSION > 1 ? 'port ranges' : 'ports')
+                    FWRULE_VERSION > 1 ? 'port ranges' : 'ports'
+                )
         });
     });
-
 });
 
 test('teardown', cli.rmAllCreated);
diff --git a/test/integration/cli-search.test.js b/test/integration/cli-search.test.js
index 1970710..67cfff6 100644
--- a/test/integration/cli-search.test.js
+++ b/test/integration/cli-search.test.js
@@ -15,8 +15,6 @@
 var h = require('./helpers');
 var test = require('tape');
 
-
-
 // --- Globals
 
 var log = require('../lib/log');
@@ -25,15 +23,14 @@ var state = {
 };
 var alice;
 
-
-
 // --- Tests
 
-test('docker search', function (tt) {
-
-    tt.test(' setup', function (t) {
-        h.getDockerEnv(t, state, {account: 'sdcdockertest_alice'},
-                function (err, env) {
+test('docker search', function(tt) {
+    tt.test(' setup', function(t) {
+        h.getDockerEnv(t, state, {account: 'sdcdockertest_alice'}, function(
+            err,
+            env
+        ) {
             t.ifErr(err);
             t.ok(env, 'have a DockerEnv for alice');
             alice = env;
@@ -41,8 +38,8 @@ test('docker search', function (tt) {
         });
     });
 
-    tt.test(' docker search busybox', function (t) {
-        alice.docker('search busybox', function (err, stdout, stderr) {
+    tt.test(' docker search busybox', function(t) {
+        alice.docker('search busybox', function(err, stdout, stderr) {
             t.ifErr(err);
             t.ok(/^busybox /m.test(stdout), 'official busybox image');
             t.end();
@@ -50,12 +47,17 @@ test('docker search', function (tt) {
     });
 
     // DOCKER-604 skip this test for now, quay.io search is busted.
-    tt.skip(' docker search quay.io/quay/elasticsearch', function (t) {
-        alice.docker('search quay.io/quay/elasticsearch',
-                function (err, stdout, stderr) {
+    tt.skip(' docker search quay.io/quay/elasticsearch', function(t) {
+        alice.docker('search quay.io/quay/elasticsearch', function(
+            err,
+            stdout,
+            stderr
+        ) {
             t.ifErr(err);
-            t.ok(/^quay\/elasticsearch /m.test(stdout),
-                'quay user elasticsearch');
+            t.ok(
+                /^quay\/elasticsearch /m.test(stdout),
+                'quay user elasticsearch'
+            );
             t.end();
         });
     });
@@ -77,13 +79,14 @@ test('docker search', function (tt) {
      *
      * However, sdc-docker currently takes ~15s to fail here.
      */
-    tt.test(' docker search localhost:4321/foo', function (t) {
-        alice.docker('search localhost:4321/foo',
-                function (err, stdout, stderr) {
+    tt.test(' docker search localhost:4321/foo', function(t) {
+        alice.docker('search localhost:4321/foo', function(
+            err,
+            stdout,
+            stderr
+        ) {
             t.ok(err);
             t.end();
         });
     });
-
-
 });
diff --git a/test/integration/cli-triton-tags.test.js b/test/integration/cli-triton-tags.test.js
index ca0ccbb..0f73aa8 100644
--- a/test/integration/cli-triton-tags.test.js
+++ b/test/integration/cli-triton-tags.test.js
@@ -20,21 +20,18 @@ var vasync = require('vasync');
 var cli = require('../lib/cli');
 var vm = require('../lib/vm');
 
-
 // --- Globals
 
 var CONTAINER_PREFIX = 'sdcdockertest_triton_tags_';
 
-
 // --- Tests
 
-test('setup', function (tt) {
+test('setup', function(tt) {
     tt.test('  test CLI init', cli.init);
     tt.test('  vmapi client init', vm.init);
 });
 
-
-test('triton.* tags/labels', function (tt) {
+test('triton.* tags/labels', function(tt) {
     var containerId;
 
     var containerName = CONTAINER_PREFIX + libuuid.create().split('-')[0];
@@ -45,18 +42,19 @@ test('triton.* tags/labels', function (tt) {
      * results in a "triton." tag on the VM (without the usual "docker:label:"
      * prefix) and appears in `docker inspect ...`.
      */
-    tt.test('  docker run --label triton.cns.disable=true ...', function (t) {
+    tt.test('  docker run --label triton.cns.disable=true ...', function(t) {
         var args = format(
             '--label triton.cns.disable=true -d --name %s alpine sleep 3600',
-            containerName);
-        cli.run(t, {args: args}, function (err, id) {
+            containerName
+        );
+        cli.run(t, {args: args}, function(err, id) {
             t.ifErr(err, 'docker run --label triton.cns.disable=true ...');
             containerId = id;
             t.end();
         });
     });
 
-    tt.test('  check triton.cns.disable label on container', function (t) {
+    tt.test('  check triton.cns.disable label on container', function(t) {
         cli.inspect(t, {
             id: containerId,
             partialExp: {
@@ -71,12 +69,12 @@ test('triton.* tags/labels', function (tt) {
         });
     });
 
-    tt.test('  check triton.cns.disable tag on VM', function (t) {
+    tt.test('  check triton.cns.disable tag on VM', function(t) {
         vm.get(t, {
             id: containerId,
             partialExp: {
                 tags: {
-                    'sdc_docker': true,
+                    sdc_docker: true,
                     // VMAPI tags can be boolean, hence `true` here.
                     'triton.cns.disable': true
                 }
@@ -84,12 +82,11 @@ test('triton.* tags/labels', function (tt) {
         });
     });
 
-
     /*
      * Next, test that we can update "triton.*" tags on the VM (via VMAPI)
      * and have those updates show in `docker inspect ...`.
      */
-    tt.test('  add/update triton.* tags via VMAPI', function (t) {
+    tt.test('  add/update triton.* tags via VMAPI', function(t) {
         vm.addTags(t, {
             id: containerId,
             tags: {
@@ -100,7 +97,7 @@ test('triton.* tags/labels', function (tt) {
     });
 
     // Updating tags is async, so need to wait for them to propogate.
-    tt.test('  wait for VMAPI tag updates', function (t) {
+    tt.test('  wait for VMAPI tag updates', function(t) {
         vm.waitForTagUpdate(t, {
             id: containerId,
             tags: {
@@ -111,7 +108,7 @@ test('triton.* tags/labels', function (tt) {
         });
     });
 
-    tt.test('  check VMAPI tag updates on container labels', function (t) {
+    tt.test('  check VMAPI tag updates on container labels', function(t) {
         cli.inspect(t, {
             id: containerId,
             partialExp: {
@@ -127,16 +124,16 @@ test('triton.* tags/labels', function (tt) {
         });
     });
 
-
     /*
      * Next, sanity check that "triton.*" labels to "docker run" are
      * validated.
      */
-    tt.test('  invalid triton tag: triton.cns.disable=nonbool', function (t) {
+    tt.test('  invalid triton tag: triton.cns.disable=nonbool', function(t) {
         var name = CONTAINER_PREFIX + libuuid.create().split('-')[0];
         var args = format(
             '--label triton.cns.disable=nonbool -d --name %s alpine hostname',
-            name);
+            name
+        );
         cli.run(t, {
             args: args,
             /* JSSTYLED */
@@ -144,10 +141,12 @@ test('triton.* tags/labels', function (tt) {
         });
     });
 
-    tt.test('  invalid triton tag: triton.bogus=foo', function (t) {
+    tt.test('  invalid triton tag: triton.bogus=foo', function(t) {
         var name = CONTAINER_PREFIX + libuuid.create().split('-')[0];
         var args = format(
-            '--label triton.bogus=foo -d --name %s alpine hostname', name);
+            '--label triton.bogus=foo -d --name %s alpine hostname',
+            name
+        );
         cli.run(t, {
             args: args,
             /* JSSTYLED */
@@ -155,11 +154,12 @@ test('triton.* tags/labels', function (tt) {
         });
     });
 
-    tt.test('  invalid triton tag: triton._test.boolean=nonbool', function (t) {
+    tt.test('  invalid triton tag: triton._test.boolean=nonbool', function(t) {
         var name = CONTAINER_PREFIX + libuuid.create().split('-')[0];
         var args = format(
             '--label triton._test.boolean=nonbool -d --name %s alpine hostname',
-            name);
+            name
+        );
         cli.run(t, {
             args: args,
             /* JSSTYLED */
@@ -167,11 +167,12 @@ test('triton.* tags/labels', function (tt) {
         });
     });
 
-    tt.test('  invalid triton tag: triton._test.number=nonnum', function (t) {
+    tt.test('  invalid triton tag: triton._test.number=nonnum', function(t) {
         var name = CONTAINER_PREFIX + libuuid.create().split('-')[0];
         var args = format(
             '--label triton._test.number=nonnum -d --name %s alpine hostname',
-            name);
+            name
+        );
         cli.run(t, {
             args: args,
             /* JSSTYLED */
@@ -179,11 +180,12 @@ test('triton.* tags/labels', function (tt) {
         });
     });
 
-    tt.test('  invalid triton tag: triton._test.boolean=<empty>', function (t) {
+    tt.test('  invalid triton tag: triton._test.boolean=<empty>', function(t) {
         var name = CONTAINER_PREFIX + libuuid.create().split('-')[0];
         var args = format(
             '--label triton._test.boolean= -d --name %s alpine hostname',
-            name);
+            name
+        );
         cli.run(t, {
             args: args,
             /* JSSTYLED */
@@ -191,11 +193,12 @@ test('triton.* tags/labels', function (tt) {
         });
     });
 
-    tt.test('  invalid triton tag: triton._test.number=<empty>', function (t) {
+    tt.test('  invalid triton tag: triton._test.number=<empty>', function(t) {
         var name = CONTAINER_PREFIX + libuuid.create().split('-')[0];
         var args = format(
             '--label triton._test.number= -d --name %s alpine hostname',
-            name);
+            name
+        );
         cli.run(t, {
             args: args,
             /* JSSTYLED */
@@ -204,5 +207,4 @@ test('triton.* tags/labels', function (tt) {
     });
 });
 
-
 test('teardown', cli.rmAllCreated);
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index 5405801..897aae4 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -27,7 +27,6 @@ var common = require('../lib/common');
 var sdcCommon = require('../../lib/common');
 var constants = require('../../lib/constants');
 
-
 // --- globals
 
 var CONFIG = {
@@ -42,16 +41,16 @@ var p = console.error;
 var UA = 'sdcdockertest';
 
 var CLIENT_ZONE_PAYLOAD = {
-    'alias': 'sdcdockertest_client',
-    'owner_uuid': '$admin',
+    alias: 'sdcdockertest_client',
+    owner_uuid: '$admin',
 
     // (LX) ubuntu-14.04@20160201
-    'image_uuid': '5917ca96-c888-11e5-8da0-e785a1ad1185',
+    image_uuid: '5917ca96-c888-11e5-8da0-e785a1ad1185',
 
     // $(sdc-napi /networks | json -H -c "this.name=='external'" 0.uuid)
-    'networks': [],
-    'tags': {
-        'sdcdockertest': true
+    networks: [],
+    tags: {
+        sdcdockertest: true
     },
 
     package_name: 'sample-1G',
@@ -62,19 +61,13 @@ var CLIENT_ZONE_PAYLOAD = {
         'user-script': '/* from sdcdockertest_client.user-script.in */'
     },
 
-    'brand': 'lx',
-    'maintain_resolvers': true,
-    'resolvers': [
-        '8.8.8.8',
-        '8.8.4.4'
-    ]
+    brand: 'lx',
+    maintain_resolvers: true,
+    resolvers: ['8.8.8.8', '8.8.4.4']
 };
 
-
-
 // --- internal support routines
 
-
 /**
  * Return an options object suitable for passing to a restify client
  */
@@ -94,13 +87,16 @@ function createClientOpts(name, callback) {
         return;
     }
 
-    loadConfig(function (err, config) {
+    loadConfig(function(err, config) {
         if (err) {
             return callback(err);
         }
-        opts.url = fmt('https://%s.%s.%s:2376', name,
+        opts.url = fmt(
+            'https://%s.%s.%s:2376',
+            name,
             config.datacenter_name,
-            config.dns_domain);
+            config.dns_domain
+        );
 
         callback(null, opts);
         return;
@@ -119,17 +115,20 @@ function getAccountKeys(opts, cb) {
     }
 
     // Allow sometime for replication: poll for a while.
-    common.execPlus({
-        command: cmd,
-        log: opts.state.log
-    }, function (err, stdout, stderr) {
-        if (err) {
-            cb(err);
-        } else {
-            var keys = JSON.parse(stdout);
-            cb(null, keys);
+    common.execPlus(
+        {
+            command: cmd,
+            log: opts.state.log
+        },
+        function(err, stdout, stderr) {
+            if (err) {
+                cb(err);
+            } else {
+                var keys = JSON.parse(stdout);
+                cb(null, keys);
+            }
         }
-    });
+    );
 }
 
 function getAccount(opts, cb) {
@@ -139,7 +138,7 @@ function getAccount(opts, cb) {
     assert.optionalNumber(opts.retries, 'opts.retries');
     assert.func(cb, 'cb');
 
-    var retries = (opts.retries === undefined ? 0 : opts.retries);
+    var retries = opts.retries === undefined ? 0 : opts.retries;
 
     var cmd = '/opt/smartdc/bin/sdc sdc-useradm get ' + opts.login;
     if (opts.state.runningFrom === 'remote') {
@@ -152,25 +151,35 @@ function getAccount(opts, cb) {
     function attempt() {
         nAttempts++;
         if (nAttempts > MAX_ATTEMPTS) {
-            return cb(new Error(fmt(
-                'could not get "%s" account%s',
-                opts.login, (opts.retries === undefined
-                    ? '' : ' after ' + opts.retries + ' retries'))));
+            return cb(
+                new Error(
+                    fmt(
+                        'could not get "%s" account%s',
+                        opts.login,
+                        opts.retries === undefined
+                            ? ''
+                            : ' after ' + opts.retries + ' retries'
+                    )
+                )
+            );
         }
-        common.execPlus({
-            command: cmd,
-            log: opts.state.log
-        }, function (err, stdout, stderr) {
-            if (err) {
-                setTimeout(attempt, 1000);
-            } else {
-                var account = JSON.parse(stdout);
-                getAccountKeys(opts, function (kErr, keys) {
-                    account.keys = keys;
-                    cb(kErr, account);
-                });
+        common.execPlus(
+            {
+                command: cmd,
+                log: opts.state.log
+            },
+            function(err, stdout, stderr) {
+                if (err) {
+                    setTimeout(attempt, 1000);
+                } else {
+                    var account = JSON.parse(stdout);
+                    getAccountKeys(opts, function(kErr, keys) {
+                        account.keys = keys;
+                        cb(kErr, account);
+                    });
+                }
             }
-        });
+        );
     }
 
     setTimeout(attempt, 1000);
@@ -189,64 +198,87 @@ function getOrCreateAccount(opts, cb) {
 
     var account;
 
-    vasync.pipeline({arg: opts.state, funcs: [
-        function getAccount1(state, next) {
-            getAccount({
-                login: opts.login,
-                state: opts.state
-            }, function (err, account_) {
-                if (!err) {
-                    account = account_;
-                }
-                next();
-            });
-        },
+    vasync.pipeline(
+        {
+            arg: opts.state,
+            funcs: [
+                function getAccount1(state, next) {
+                    getAccount(
+                        {
+                            login: opts.login,
+                            state: opts.state
+                        },
+                        function(err, account_) {
+                            if (!err) {
+                                account = account_;
+                            }
+                            next();
+                        }
+                    );
+                },
 
-        function createAccount(state, next) {
-            if (account) {
-                return next();
-            }
+                function createAccount(state, next) {
+                    if (account) {
+                        return next();
+                    }
 
-            // Run sdc-useradm commands in the 'sdc' zone because, in general,
-            // the sdc zone is more likely to have access to the UFDS master,
-            // if this DC isn't the master.
-            p('# Creating "%s" account', opts.login);
-            var cmd = fmt('/opt/smartdc/bin/sdc sdc-useradm create -A '
-                + 'login=%s email=root+%s@localhost userpassword=secret123',
-                opts.login, opts.login);
-            if (state.runningFrom === 'remote') {
-                cmd = 'ssh ' + state.headnodeSsh + ' ' + cmd;
-            }
-            common.execPlus({
-                command: cmd,
-                log: log
-            }, function (err, stdout, stderr) {
-                log.debug({cmd: cmd, err: err, stdout: stdout,
-                    stderr: stderr}, 'createAccount cmd done');
-                next(err);
-            });
-        },
+                    // Run sdc-useradm commands in the 'sdc' zone because, in general,
+                    // the sdc zone is more likely to have access to the UFDS master,
+                    // if this DC isn't the master.
+                    p('# Creating "%s" account', opts.login);
+                    var cmd = fmt(
+                        '/opt/smartdc/bin/sdc sdc-useradm create -A ' +
+                            'login=%s email=root+%s@localhost userpassword=secret123',
+                        opts.login,
+                        opts.login
+                    );
+                    if (state.runningFrom === 'remote') {
+                        cmd = 'ssh ' + state.headnodeSsh + ' ' + cmd;
+                    }
+                    common.execPlus(
+                        {
+                            command: cmd,
+                            log: log
+                        },
+                        function(err, stdout, stderr) {
+                            log.debug(
+                                {
+                                    cmd: cmd,
+                                    err: err,
+                                    stdout: stdout,
+                                    stderr: stderr
+                                },
+                                'createAccount cmd done'
+                            );
+                            next(err);
+                        }
+                    );
+                },
 
-        function getAccount2(state, next) {
-            if (account) {
-                return next();
-            }
-            getAccount({
-                login: opts.login,
-                state: opts.state,
-                retries: 15
-            }, function (err, account_) {
-                account = account_;
-                next(err);
-            });
+                function getAccount2(state, next) {
+                    if (account) {
+                        return next();
+                    }
+                    getAccount(
+                        {
+                            login: opts.login,
+                            state: opts.state,
+                            retries: 15
+                        },
+                        function(err, account_) {
+                            account = account_;
+                            next(err);
+                        }
+                    );
+                }
+            ]
+        },
+        function(err) {
+            cb(err, account);
         }
-
-    ]}, function (err) {
-        cb(err, account);
-    });
+    );
 }
 
-
 /**
  * Load the SDC config.
  *
@@ -256,7 +288,7 @@ function loadConfig(callback) {
     assert.func(callback, 'callback');
 
     var cmd = '/usr/bin/bash /lib/sdc/config.sh -json';
-    exec(cmd, function (err, stdout, stderr) {
+    exec(cmd, function(err, stdout, stderr) {
         if (err) {
             return callback(err);
         }
@@ -268,7 +300,6 @@ function loadConfig(callback) {
     });
 }
 
-
 // --- vasync.pipeline "step" funcs (they expect and set vars on `state`)
 
 function stepSysinfo(state, cb) {
@@ -279,7 +310,7 @@ function stepSysinfo(state, cb) {
         return cb();
     }
     var cmd = '/usr/bin/sysinfo';
-    exec(cmd, function (err, stdout, stderr) {
+    exec(cmd, function(err, stdout, stderr) {
         if (err) {
             return cb(err);
         }
@@ -300,7 +331,7 @@ function stepSdcConfig(state, cb) {
         return cb();
     }
     var cmd = '/usr/bin/bash /lib/sdc/config.sh -json';
-    exec(cmd, function (err, stdout, stderr) {
+    exec(cmd, function(err, stdout, stderr) {
         if (err) {
             return cb(err);
         }
@@ -385,22 +416,25 @@ function stepCloudapiPublicIp(state, cb) {
     if (state.runningFrom === 'remote') {
         cmd = 'ssh ' + state.headnodeSsh + ' ' + cmd;
     }
-    common.execPlus({
-        command: cmd,
-        log: state.log
-    }, function (err, stdout, stderr) {
-        if (err) {
-            return cb(err);
-        }
-        var vm = JSON.parse(stdout)[0];
-        for (var i = 0; i < vm.nics.length; i++) {
-            var nic = vm.nics[i];
-            if (nic.nic_tag === 'external') {
-                state.cloudapiPublicIp = nic.ip;
-                cb();
+    common.execPlus(
+        {
+            command: cmd,
+            log: state.log
+        },
+        function(err, stdout, stderr) {
+            if (err) {
+                return cb(err);
+            }
+            var vm = JSON.parse(stdout)[0];
+            for (var i = 0; i < vm.nics.length; i++) {
+                var nic = vm.nics[i];
+                if (nic.nic_tag === 'external') {
+                    state.cloudapiPublicIp = nic.ip;
+                    cb();
+                }
             }
         }
-    });
+    );
 }
 
 /*
@@ -422,20 +456,21 @@ function stepClientZonePayload(state, cb) {
 
     // Load and render the user-script template.
     var tmpl = path.resolve(__dirname, 'sdcdockertest_client.user-script.in');
-    fs.readFile(tmpl, {encoding: 'utf8'}, function (err, userScript) {
+    fs.readFile(tmpl, {encoding: 'utf8'}, function(err, userScript) {
         if (err) {
             cb(err);
             return;
         }
 
         var vars = {
-            DOCKER_AVAILABLE_CLI_VERSIONS:
-                process.env.DOCKER_AVAILABLE_CLI_VERSIONS
+            DOCKER_AVAILABLE_CLI_VERSIONS: process.env
+                .DOCKER_AVAILABLE_CLI_VERSIONS
         };
-        Object.keys(vars).forEach(function (k) {
+        Object.keys(vars).forEach(function(k) {
             userScript = userScript.replace(
                 new RegExp('{{' + k + '}}', 'g'),
-                vars[k]);
+                vars[k]
+            );
         });
 
         state.clientZonePayload.customer_metadata['user-script'] = userScript;
@@ -457,29 +492,35 @@ function stepClientZone(state_, cb) {
         return cb();
     }
 
-    vasync.pipeline({arg: state_, funcs: [
-        stepVmapi,
-        function getClientZone(state, next) {
-            var filters = {
-                state: 'active',
-                owner_uuid: state.sdcConfig.ufds_admin_uuid,
-                alias: state.clientZonePayload.alias
-            };
-            state.vmapi.listVms(filters, function (err, vms) {
-                if (err) {
-                    return next(err);
-                }
-                if (vms.length) {
-                    state.clientZone = vms[0];
-                    //p('# Found existing client zone %s (%s)',
-                    //    state.clientZone.uuid, state.clientZone.alias);
-                }
-                next();
-            });
+    vasync.pipeline(
+        {
+            arg: state_,
+            funcs: [
+                stepVmapi,
+                function getClientZone(state, next) {
+                    var filters = {
+                        state: 'active',
+                        owner_uuid: state.sdcConfig.ufds_admin_uuid,
+                        alias: state.clientZonePayload.alias
+                    };
+                    state.vmapi.listVms(filters, function(err, vms) {
+                        if (err) {
+                            return next(err);
+                        }
+                        if (vms.length) {
+                            state.clientZone = vms[0];
+                            //p('# Found existing client zone %s (%s)',
+                            //    state.clientZone.uuid, state.clientZone.alias);
+                        }
+                        next();
+                    });
+                },
+                // Create the client zone if necessary.
+                _stepCreateClientZone
+            ]
         },
-        // Create the client zone if necessary.
-        _stepCreateClientZone
-    ]}, cb);
+        cb
+    );
 }
 
 function _stepCreateClientZone(state_, cb) {
@@ -492,125 +533,159 @@ function _stepCreateClientZone(state_, cb) {
 
     var payload = state_.clientZonePayload;
 
-    vasync.pipeline({arg: state_, funcs: [
-        stepNapi,
-        function payloadNetworks(state, next) {
-            state.napi.listNetworks({name: 'external'}, function (err, nets) {
-                if (err) {
-                    return next(err);
-                }
-                payload.networks.push({uuid: nets[0].uuid});
-                next();
-            });
-        },
+    vasync.pipeline(
+        {
+            arg: state_,
+            funcs: [
+                stepNapi,
+                function payloadNetworks(state, next) {
+                    state.napi.listNetworks({name: 'external'}, function(
+                        err,
+                        nets
+                    ) {
+                        if (err) {
+                            return next(err);
+                        }
+                        payload.networks.push({uuid: nets[0].uuid});
+                        next();
+                    });
+                },
+
+                stepImgapi,
+                function importImageIfNecessary(state, next) {
+                    state.imgapi.getImage(payload.image_uuid, function(
+                        err,
+                        img
+                    ) {
+                        if (err && err.statusCode !== 404) {
+                            return next(err);
+                        } else if (!err) {
+                            return next();
+                        }
+                        // Need to import this image into the DC.
+                        p(
+                            '# Importing image %s from images.joyent.com',
+                            payload.image_uuid
+                        );
+                        state.imgapi.adminImportRemoteImageAndWait(
+                            payload.image_uuid,
+                            'https://images.joyent.com',
+                            next
+                        );
+                    });
+                },
 
-        stepImgapi,
-        function importImageIfNecessary(state, next) {
-            state.imgapi.getImage(payload.image_uuid, function (err, img) {
-                if (err && err.statusCode !== 404) {
-                    return next(err);
-                } else if (!err) {
-                    return next();
-                }
-                // Need to import this image into the DC.
-                p('# Importing image %s from images.joyent.com',
-                    payload.image_uuid);
-                state.imgapi.adminImportRemoteImageAndWait(
-                    payload.image_uuid, 'https://images.joyent.com',
-                    next);
-            });
-        },
+                stepPapi,
+                function getPkg(state, next) {
+                    var filter = {active: true};
+                    state.papi.list(filter, {}, function(err, pkgs) {
+                        var pkg;
 
-        stepPapi,
-        function getPkg(state, next) {
-            var filter = {active: true};
-            state.papi.list(filter, {}, function (err, pkgs) {
-                var pkg;
+                        if (err) {
+                            return next(err);
+                        }
 
-                if (err) {
-                    return next(err);
-                }
+                        // Pick the first non-private package between 1-2G memory
+                        for (var i = 0; i < pkgs.length; i++) {
+                            pkg = pkgs[i];
+
+                            if (
+                                !pkg.owner_uuids || pkg.owner_uuids.length === 0
+                            ) {
+                                // package is not private to owner(s)
+                                if (
+                                    pkg.max_physical_memory >= 1024 &&
+                                    pkg.max_physical_memory <= 2048
+                                ) {
+                                    // found a package that meets our criteria!
+                                    p('# Using package %s', pkg.name);
+                                    payload.billing_id = pkg.uuid;
+                                    break;
+                                }
+                            }
+                        }
 
-                // Pick the first non-private package between 1-2G memory
-                for (var i = 0; i < pkgs.length; i++) {
-                    pkg = pkgs[i];
-
-                    if (!pkg.owner_uuids || pkg.owner_uuids.length === 0) {
-                        // package is not private to owner(s)
-                        if (pkg.max_physical_memory >= 1024
-                            && pkg.max_physical_memory <= 2048) {
-                            // found a package that meets our criteria!
-                            p('# Using package %s', pkg.name);
-                            payload.billing_id = pkg.uuid;
-                            break;
+                        assert.uuid(payload.billing_id, 'payload.billing_id');
+                        next();
+                    });
+                },
+
+                // Create the client zone on the local CN (typically the headnode)
+                // because we are getting failures, at least in nightly, when one
+                // of the CNs is used.
+                stepSysinfo,
+                function payloadServerUuid(state, next) {
+                    payload.server_uuid = state.sysinfo.UUID;
+                    next();
+                },
+
+                function createClientZone(state, next) {
+                    p('# Creating client zone (%s)', payload.alias);
+                    payload.owner_uuid = state.sdcConfig.ufds_admin_uuid;
+                    state.log.debug({payload: payload}, 'create clientZone');
+                    state.vmapi.createVmAndWait(payload, function(err, job) {
+                        if (err) {
+                            return next(err);
+                        }
+                        p(
+                            '# Created client zone %s (%s)',
+                            job.vm_uuid,
+                            payload.alias
+                        );
+                        state.vmapi.getVm({uuid: job.vm_uuid}, function(
+                            gErr,
+                            vm
+                        ) {
+                            state.clientZone = vm;
+                            next(gErr);
+                        });
+                    });
+                },
+
+                function waitForClientZoneUserScript(state, next) {
+                    p('# Wait until client zone user-script is done.');
+
+                    var marker = fmt(
+                        '/zones/%s/root/var/svc/user-script-done',
+                        state.clientZone.uuid
+                    );
+                    var nAttempts = 0;
+                    var MAX_ATTEMPTS = 600;
+
+                    function attempt() {
+                        nAttempts++;
+                        if (nAttempts > MAX_ATTEMPTS) {
+                            return next(
+                                new Error(
+                                    'timeout waiting for clientZone ' +
+                                        'user-script to finish'
+                                )
+                            );
                         }
+                        if (nAttempts % 10 === 0) {
+                            p(
+                                '# Still waiting (%d/%ds)',
+                                nAttempts,
+                                MAX_ATTEMPTS
+                            );
+                        }
+                        fs.exists(marker, function(exists) {
+                            if (!exists) {
+                                setTimeout(attempt, 1000);
+                            } else {
+                                next();
+                            }
+                        });
                     }
-                }
 
-                assert.uuid(payload.billing_id, 'payload.billing_id');
-                next();
-            });
-        },
-
-        // Create the client zone on the local CN (typically the headnode)
-        // because we are getting failures, at least in nightly, when one
-        // of the CNs is used.
-        stepSysinfo,
-        function payloadServerUuid(state, next) {
-            payload.server_uuid = state.sysinfo.UUID;
-            next();
-        },
-
-        function createClientZone(state, next) {
-            p('# Creating client zone (%s)', payload.alias);
-            payload.owner_uuid = state.sdcConfig.ufds_admin_uuid;
-            state.log.debug({payload: payload}, 'create clientZone');
-            state.vmapi.createVmAndWait(payload, function (err, job) {
-                if (err) {
-                    return next(err);
+                    setTimeout(attempt, 1000);
                 }
-                p('# Created client zone %s (%s)', job.vm_uuid, payload.alias);
-                state.vmapi.getVm({uuid: job.vm_uuid}, function (gErr, vm) {
-                    state.clientZone = vm;
-                    next(gErr);
-                });
-            });
+            ]
         },
-
-        function waitForClientZoneUserScript(state, next) {
-            p('# Wait until client zone user-script is done.');
-
-            var marker = fmt('/zones/%s/root/var/svc/user-script-done',
-                state.clientZone.uuid);
-            var nAttempts = 0;
-            var MAX_ATTEMPTS = 600;
-
-            function attempt() {
-                nAttempts++;
-                if (nAttempts > MAX_ATTEMPTS) {
-                    return next(new Error('timeout waiting for clientZone '
-                        + 'user-script to finish'));
-                }
-                if (nAttempts % 10 === 0) {
-                    p('# Still waiting (%d/%ds)', nAttempts, MAX_ATTEMPTS);
-                }
-                fs.exists(marker, function (exists) {
-                    if (!exists) {
-                        setTimeout(attempt, 1000);
-                    } else {
-                        next();
-                    }
-                });
-            }
-
-            setTimeout(attempt, 1000);
-        }
-
-    ]}, cb);
+        cb
+    );
 }
 
-
-
 /*
  * --- GzDockerEnv
  *
@@ -621,8 +696,11 @@ function GzDockerEnv(t, state, opts) {
     assert.object(state, 'state');
     assert.object(opts, 'opts');
     assert.string(opts.account, 'opts.account');
-    assert.equal(opts.account.split('_')[0], 'sdcdockertest',
-        'All test suite accounts should be prefixed with "sdcdockertest_"');
+    assert.equal(
+        opts.account.split('_')[0],
+        'sdcdockertest',
+        'All test suite accounts should be prefixed with "sdcdockertest_"'
+    );
 
     this.login = opts.account;
     this.log = state.log;
@@ -638,98 +716,147 @@ GzDockerEnv.prototype.init = function denvInit(t, state_, cb) {
 
     var newKey = false;
 
-    vasync.pipeline({arg: state_, funcs: [
-        stepSysinfo,
-        stepSdcConfig,
-        stepClientZonePayload,
-        stepClientZone,
-
-        function ensureAccount(state, next) {
-            getOrCreateAccount({login: self.login, state: state},
-                    function (err, account) {
-                self.account = account;
-                next(err);
-            });
-        },
-
-        function setPaths(state, next) {
-            self.clientZone = state.clientZone;
+    vasync.pipeline(
+        {
+            arg: state_,
+            funcs: [
+                stepSysinfo,
+                stepSdcConfig,
+                stepClientZonePayload,
+                stepClientZone,
+
+                function ensureAccount(state, next) {
+                    getOrCreateAccount(
+                        {login: self.login, state: state},
+                        function(err, account) {
+                            self.account = account;
+                            next(err);
+                        }
+                    );
+                },
+
+                function setPaths(state, next) {
+                    self.clientZone = state.clientZone;
+
+                    self.privKeyPath = fmt(
+                        '/zones/%s/root/root/.ssh/%s.id_rsa',
+                        state.clientZone.uuid,
+                        self.login
+                    );
+                    self.pubKeyPath = self.privKeyPath + '.pub';
+                    self.sdcDockerDir = fmt(
+                        '/zones/%s/root/root/.sdc/docker/%s',
+                        state.clientZone.uuid,
+                        self.login
+                    );
+                    next();
+                },
+
+                function ensureAccountKey(state, next) {
+                    var keyName = 'host-' + os.hostname();
+                    var accountHasKey =
+                        self.account.keys &&
+                        self.account.keys.filter(function(k) {
+                            return k.name === keyName;
+                        }).length;
+                    if (
+                        fs.existsSync(self.pubKeyPath) &&
+                        fs.existsSync(self.privKeyPath) &&
+                        fs.existsSync(self.sdcDockerDir) &&
+                        accountHasKey
+                    ) {
+                        return next();
+                    }
 
-            self.privKeyPath = fmt('/zones/%s/root/root/.ssh/%s.id_rsa',
-                state.clientZone.uuid, self.login);
-            self.pubKeyPath = self.privKeyPath + '.pub';
-            self.sdcDockerDir = fmt('/zones/%s/root/root/.sdc/docker/%s',
-                state.clientZone.uuid, self.login);
-            next();
-        },
+                    newKey = true;
+                    p(
+                        '# Creating "%s" SSH key for "%s" account',
+                        keyName,
+                        self.login
+                    );
+                    var cmds = [
+                        fmt('rm -rf %s %s', self.privKeyPath, self.pubKeyPath),
+                        fmt(
+                            'ssh-keygen -t rsa -f %s -b 2048 -N ""',
+                            self.privKeyPath
+                        ),
+                        fmt(
+                            'cp %s ' +
+                                '/zones/$(vmadm lookup -1 alias=sdc0)/root/var/tmp/',
+                            self.pubKeyPath
+                        )
+                    ];
+                    if (accountHasKey) {
+                        cmds.push(
+                            fmt(
+                                '/opt/smartdc/bin/sdc sdc-useradm delete-key %s %s',
+                                self.login,
+                                keyName
+                            )
+                        );
+                    }
+                    cmds.push(
+                        fmt(
+                            '/opt/smartdc/bin/sdc sdc-useradm add-key ' +
+                                '-n %s %s /var/tmp/%s.id_rsa.pub',
+                            keyName,
+                            self.login,
+                            self.login
+                        )
+                    );
+                    vasync.forEachPipeline(
+                        {
+                            inputs: cmds,
+                            func: function execOneCmd(cmd, nextCmd) {
+                                exec(cmd, function(err, stdout, stderr) {
+                                    state.log.debug(
+                                        {
+                                            cmd: cmd,
+                                            err: err,
+                                            stdout: stdout,
+                                            stderr: stderr
+                                        },
+                                        self.login + 'ensureKey cmd'
+                                    );
+                                    nextCmd(err);
+                                });
+                            }
+                        },
+                        next
+                    );
+                },
+
+                function getCloudapiPublicIp(state, next) {
+                    if (!newKey) {
+                        return next();
+                    }
+                    stepCloudapiPublicIp(state, next);
+                },
 
-        function ensureAccountKey(state, next) {
-            var keyName = 'host-' + os.hostname();
-            var accountHasKey = (
-                self.account.keys
-                && self.account.keys.filter(
-                    function (k) { return k.name === keyName; }).length);
-            if (fs.existsSync(self.pubKeyPath)
-                && fs.existsSync(self.privKeyPath)
-                && fs.existsSync(self.sdcDockerDir)
-                && accountHasKey)
-            {
-                return next();
-            }
+                function sdcDockerSetup(state, next) {
+                    if (!newKey) {
+                        return next();
+                    }
 
-            newKey = true;
-            p('# Creating "%s" SSH key for "%s" account', keyName, self.login);
-            var cmds = [
-                fmt('rm -rf %s %s', self.privKeyPath, self.pubKeyPath),
-                fmt('ssh-keygen -t rsa -f %s -b 2048 -N ""', self.privKeyPath),
-                fmt('cp %s '
-                    + '/zones/$(vmadm lookup -1 alias=sdc0)/root/var/tmp/',
-                    self.pubKeyPath)
-            ];
-            if (accountHasKey) {
-                cmds.push(fmt(
-                    '/opt/smartdc/bin/sdc sdc-useradm delete-key %s %s',
-                    self.login, keyName));
-            }
-            cmds.push(fmt('/opt/smartdc/bin/sdc sdc-useradm add-key '
-                + '-n %s %s /var/tmp/%s.id_rsa.pub',
-                keyName, self.login, self.login));
-            vasync.forEachPipeline({
-                inputs: cmds,
-                func: function execOneCmd(cmd, nextCmd) {
-                    exec(cmd, function (err, stdout, stderr) {
-                        state.log.debug({cmd: cmd, err: err, stdout: stdout,
-                            stderr: stderr}, self.login + 'ensureKey cmd');
-                        nextCmd(err);
-                    });
+                    p(
+                        '# Running "sdc-docker-setup.sh" for "%s" account',
+                        self.login
+                    );
+                    self.exec(
+                        fmt(
+                            '/root/bin/sdc-docker-setup.sh -k %s %s ' +
+                                '/root/.ssh/%s.id_rsa',
+                            state.cloudapiPublicIp,
+                            self.login,
+                            self.login
+                        ),
+                        next
+                    );
                 }
-            }, next);
-        },
-
-        function getCloudapiPublicIp(state, next) {
-            if (!newKey) {
-                return next();
-            }
-            stepCloudapiPublicIp(state, next);
+            ]
         },
-
-        function sdcDockerSetup(state, next) {
-            if (!newKey) {
-                return next();
-            }
-
-            p('# Running "sdc-docker-setup.sh" for "%s" account', self.login);
-            self.exec(
-                fmt(
-                    '/root/bin/sdc-docker-setup.sh -k %s %s '
-                        + '/root/.ssh/%s.id_rsa',
-                    state.cloudapiPublicIp,
-                    self.login,
-                    self.login
-                ), next);
-        }
-
-    ]}, cb);
+        cb
+    );
 };
 
 /*
@@ -741,14 +868,19 @@ GzDockerEnv.prototype.init = function denvInit(t, state_, cb) {
  */
 GzDockerEnv.prototype.docker = function denvDocker(cmd, opts, cb) {
     assert.string(cmd, 'cmd');
-    assert.ok(process.env.DOCKER_CLI_VERSION,
-        '$DOCKER_CLI_VERSION is not set, do not know which "docker-$ver" '
-        + 'to execute');
+    assert.ok(
+        process.env.DOCKER_CLI_VERSION,
+        '$DOCKER_CLI_VERSION is not set, do not know which "docker-$ver" ' +
+            'to execute'
+    );
     // other options asserted by this.exec()
 
     var dockerCmd = fmt(
         '(source /root/.sdc/docker/%s/env.sh; /root/bin/docker-%s --tls %s)',
-        this.login, process.env.DOCKER_CLI_VERSION, cmd);
+        this.login,
+        process.env.DOCKER_CLI_VERSION,
+        cmd
+    );
     this.exec(dockerCmd, opts, cb);
 };
 
@@ -769,15 +901,17 @@ GzDockerEnv.prototype.exec = function denvExec(cmd, opts, cb) {
     assert.func(cb, 'cb');
     assert.optionalObject(opts.execOpts, 'opts.execOpts');
 
-    common.execPlus({
-        // TODO: escaping single-quotes
-        command: fmt('zlogin %s \'%s\'', this.clientZone.uuid, cmd),
-        log: this.log,
-        execOpts: opts.execOpts
-    }, cb);
+    common.execPlus(
+        {
+            // TODO: escaping single-quotes
+            command: fmt("zlogin %s '%s'", this.clientZone.uuid, cmd),
+            log: this.log,
+            execOpts: opts.execOpts
+        },
+        cb
+    );
 };
 
-
 /*
  * --- LocalDockerEnv
  *
@@ -793,8 +927,11 @@ function LocalDockerEnv(t, state, opts) {
     assert.object(state, 'state');
     assert.object(opts, 'opts');
     assert.string(opts.account, 'opts.account');
-    assert.equal(opts.account.split('_')[0], 'sdcdockertest',
-        'All test suite accounts should be prefixed with "sdcdockertest_"');
+    assert.equal(
+        opts.account.split('_')[0],
+        'sdcdockertest',
+        'All test suite accounts should be prefixed with "sdcdockertest_"'
+    );
 
     this.login = opts.account;
     this.log = state.log;
@@ -810,106 +947,165 @@ LocalDockerEnv.prototype.init = function ldenvInit(t, state_, cb) {
 
     var newKey = false;
 
-    vasync.pipeline({arg: state_, funcs: [
-        function ensureAccount(state, next) {
-            getOrCreateAccount({login: self.login, state: state},
-                    function (err, account) {
-                self.account = account;
-                next(err);
-            });
-        },
-
-        function setVars(state, next) {
-            self.privKeyPath = fmt('%s/.ssh/%s.id_rsa',
-                process.env.HOME, self.login);
-            self.pubKeyPath = self.privKeyPath + '.pub';
-            self.sdcDockerDir = fmt('%s/.sdc/docker/%s',
-                process.env.HOME, self.login);
-            next();
-        },
+    vasync.pipeline(
+        {
+            arg: state_,
+            funcs: [
+                function ensureAccount(state, next) {
+                    getOrCreateAccount(
+                        {login: self.login, state: state},
+                        function(err, account) {
+                            self.account = account;
+                            next(err);
+                        }
+                    );
+                },
+
+                function setVars(state, next) {
+                    self.privKeyPath = fmt(
+                        '%s/.ssh/%s.id_rsa',
+                        process.env.HOME,
+                        self.login
+                    );
+                    self.pubKeyPath = self.privKeyPath + '.pub';
+                    self.sdcDockerDir = fmt(
+                        '%s/.sdc/docker/%s',
+                        process.env.HOME,
+                        self.login
+                    );
+                    next();
+                },
+
+                function getSdcZonename(state, next) {
+                    common.execPlus(
+                        {
+                            command: fmt(
+                                'ssh %s vmadm lookup -1 alias=sdc0',
+                                state.headnodeSsh
+                            ),
+                            log: state.log
+                        },
+                        function(err, stdout, stderr) {
+                            if (err) {
+                                return next(err);
+                            }
+                            state.sdcZonename = stdout.trim();
+                            next();
+                        }
+                    );
+                },
+
+                function ensureAccountKey(state, next) {
+                    var keyName = 'host-' + os.hostname();
+                    var accountHasKey =
+                        self.account.keys &&
+                        self.account.keys.filter(function(k) {
+                            return k.name === keyName;
+                        }).length;
+                    if (
+                        fs.existsSync(self.pubKeyPath) &&
+                        fs.existsSync(self.privKeyPath) &&
+                        fs.existsSync(self.sdcDockerDir) &&
+                        accountHasKey
+                    ) {
+                        return next();
+                    }
 
-        function getSdcZonename(state, next) {
-            common.execPlus({
-                command: fmt('ssh %s vmadm lookup -1 alias=sdc0',
-                    state.headnodeSsh),
-                log: state.log
-            }, function (err, stdout, stderr) {
-                if (err) {
-                    return next(err);
-                }
-                state.sdcZonename = stdout.trim();
-                next();
-            });
-        },
+                    newKey = true;
+                    p(
+                        '# Creating "%s" SSH key for "%s" account',
+                        keyName,
+                        self.login
+                    );
+                    var cmds = [
+                        fmt('rm -rf %s %s', self.privKeyPath, self.pubKeyPath),
+                        fmt(
+                            'ssh-keygen -t rsa -f %s -b 2048 -N ""',
+                            self.privKeyPath
+                        ),
+                        fmt(
+                            'scp %s %s:/zones/%s/root/var/tmp/',
+                            self.pubKeyPath,
+                            state.headnodeSsh,
+                            state.sdcZonename
+                        )
+                    ];
+                    if (accountHasKey) {
+                        cmds.push(
+                            fmt(
+                                'ssh %s /opt/smartdc/bin/sdc sdc-useradm ' +
+                                    'delete-key %s %s',
+                                state.headnodeSsh,
+                                self.login,
+                                keyName
+                            )
+                        );
+                    }
+                    cmds.push(
+                        fmt(
+                            'ssh %s /opt/smartdc/bin/sdc sdc-useradm add-key -n %s ' +
+                                '%s /var/tmp/%s.id_rsa.pub',
+                            state.headnodeSsh,
+                            keyName,
+                            self.login,
+                            self.login
+                        )
+                    );
+                    vasync.forEachPipeline(
+                        {
+                            inputs: cmds,
+                            func: function execOneCmd(cmd, nextCmd) {
+                                common.execPlus(
+                                    {
+                                        command: cmd,
+                                        log: state.log
+                                    },
+                                    nextCmd
+                                );
+                            }
+                        },
+                        next
+                    );
+                },
+
+                function getCloudapiPublicIp(state, next) {
+                    if (!newKey) {
+                        return next();
+                    }
+                    stepCloudapiPublicIp(state, next);
+                },
 
-        function ensureAccountKey(state, next) {
-            var keyName = 'host-' + os.hostname();
-            var accountHasKey = (
-                self.account.keys
-                && self.account.keys.filter(
-                    function (k) { return k.name === keyName; }).length);
-            if (fs.existsSync(self.pubKeyPath)
-                && fs.existsSync(self.privKeyPath)
-                && fs.existsSync(self.sdcDockerDir)
-                && accountHasKey)
-            {
-                return next();
-            }
+                function sdcDockerSetup(state, next) {
+                    if (!newKey) {
+                        return next();
+                    }
 
-            newKey = true;
-            p('# Creating "%s" SSH key for "%s" account', keyName, self.login);
-            var cmds = [
-                fmt('rm -rf %s %s', self.privKeyPath, self.pubKeyPath),
-                fmt('ssh-keygen -t rsa -f %s -b 2048 -N ""', self.privKeyPath),
-                fmt('scp %s %s:/zones/%s/root/var/tmp/',
-                    self.pubKeyPath, state.headnodeSsh, state.sdcZonename)
-            ];
-            if (accountHasKey) {
-                cmds.push(fmt('ssh %s /opt/smartdc/bin/sdc sdc-useradm '
-                    + 'delete-key %s %s', state.headnodeSsh, self.login,
-                    keyName));
-            }
-            cmds.push(fmt(
-                'ssh %s /opt/smartdc/bin/sdc sdc-useradm add-key -n %s '
-                + '%s /var/tmp/%s.id_rsa.pub', state.headnodeSsh, keyName,
-                self.login, self.login));
-            vasync.forEachPipeline({
-                inputs: cmds,
-                func: function execOneCmd(cmd, nextCmd) {
-                    common.execPlus({
-                        command: cmd,
-                        log: state.log
-                    }, nextCmd);
+                    p(
+                        '# Running "sdc-docker-setup.sh" for "%s" account',
+                        self.login
+                    );
+                    var cmd = fmt(
+                        '%s -sk %s %s %s',
+                        path.resolve(
+                            __dirname,
+                            '../../tools/sdc-docker-setup.sh'
+                        ),
+                        state.cloudapiPublicIp,
+                        self.login,
+                        self.privKeyPath
+                    );
+                    common.execPlus(
+                        {
+                            command: cmd,
+                            log: state.log
+                        },
+                        next
+                    );
                 }
-            }, next);
+            ]
         },
-
-        function getCloudapiPublicIp(state, next) {
-            if (!newKey) {
-                return next();
-            }
-            stepCloudapiPublicIp(state, next);
-        },
-
-        function sdcDockerSetup(state, next) {
-            if (!newKey) {
-                return next();
-            }
-
-            p('# Running "sdc-docker-setup.sh" for "%s" account', self.login);
-            var cmd = fmt(
-                '%s -sk %s %s %s',
-                path.resolve(__dirname, '../../tools/sdc-docker-setup.sh'),
-                state.cloudapiPublicIp,
-                self.login,
-                self.privKeyPath);
-            common.execPlus({
-                command: cmd,
-                log: state.log
-            }, next);
-        }
-
-    ]}, cb);
+        cb
+    );
 };
 
 /*
@@ -925,7 +1121,9 @@ LocalDockerEnv.prototype.docker = function ldenvDocker(cmd, opts, cb) {
 
     var dockerCmd = fmt(
         '(source ~/.sdc/docker/%s/env.sh; docker --tls %s)',
-        this.login, cmd);
+        this.login,
+        cmd
+    );
     this.exec(dockerCmd, opts, cb);
 };
 
@@ -945,14 +1143,15 @@ LocalDockerEnv.prototype.exec = function ldenvExec(cmd, opts, cb) {
     assert.object(opts, 'opts');
     assert.func(cb, 'cb');
 
-    common.execPlus({
-        command: cmd,
-        log: this.log
-    }, cb);
+    common.execPlus(
+        {
+            command: cmd,
+            log: this.log
+        },
+        cb
+    );
 };
 
-
-
 /*
  * --- Test helper functions
  *
@@ -996,7 +1195,8 @@ function initDockerEnv(t, state, opts, cb) {
             return;
         }
 
-        var s = '/opt/smartdc/bin/sdc sdc-useradm replace-attr %s \
+        var s =
+            '/opt/smartdc/bin/sdc sdc-useradm replace-attr %s \
             approved_for_provisioning %s';
         var cmd = fmt(s, env.login, val);
 
@@ -1007,8 +1207,10 @@ function initDockerEnv(t, state, opts, cb) {
         exec(cmd, next);
     }
 
-    getDockerEnv(t, state, {account: 'sdcdockertest_alice'},
-            function (err, alice) {
+    getDockerEnv(t, state, {account: 'sdcdockertest_alice'}, function(
+        err,
+        alice
+    ) {
         t.ifErr(err, 'docker env: alice');
         t.ok(alice, 'have a DockerEnv for alice');
 
@@ -1016,12 +1218,14 @@ function initDockerEnv(t, state, opts, cb) {
         // below. Docker's ufds client caches account values, so mutating
         // Alice isn't in the cards (nor is Bob -- which is why we don't
         // set Bob provisionable when this test file completes).
-        getDockerEnv(t, state, {account: 'sdcdockertest_bob'},
-                function (err2, bob) {
+        getDockerEnv(t, state, {account: 'sdcdockertest_bob'}, function(
+            err2,
+            bob
+        ) {
             t.ifErr(err2, 'docker env: bob');
             t.ok(bob, 'have a DockerEnv for bob');
 
-            setProvisioning(bob, false, function (err3) {
+            setProvisioning(bob, false, function(err3) {
                 t.ifErr(err3, 'set bob unprovisionable');
 
                 var accounts = {
@@ -1051,69 +1255,72 @@ function getDockerEnv(t, state_, opts, cb) {
 
     var env;
 
-    vasync.pipeline({arg: state_, funcs: [
-        /*
+    vasync.pipeline(
+        {
+            arg: state_,
+            funcs: [
+                /*
          * Set `state.runningFrom` to 'gz' (from the headnode global zone)
          * or 'remote'.
          */
-        function runningFromWhere(state, next) {
-            if (os.type() !== 'SunOS') {
-                state.runningFrom = 'remote';
-                return next();
-            }
+                function runningFromWhere(state, next) {
+                    if (os.type() !== 'SunOS') {
+                        state.runningFrom = 'remote';
+                        return next();
+                    }
 
-            common.execPlus({
-                command: '/usr/bin/zonename',
-                log: state.log
-            }, function (err, stdout, stderr) {
-                if (err) {
-                    return next(err);
-                }
-                var zonename = stdout.replace(/\s+$/g, '');
-                if (zonename !== 'global') {
-                    state.runningFrom = 'remote';
-                } else {
-                    state.runningFrom = 'gz';
-                }
-                next();
-            });
-        },
+                    common.execPlus(
+                        {
+                            command: '/usr/bin/zonename',
+                            log: state.log
+                        },
+                        function(err, stdout, stderr) {
+                            if (err) {
+                                return next(err);
+                            }
+                            var zonename = stdout.replace(/\s+$/g, '');
+                            if (zonename !== 'global') {
+                                state.runningFrom = 'remote';
+                            } else {
+                                state.runningFrom = 'gz';
+                            }
+                            next();
+                        }
+                    );
+                },
 
-        function getHeadnodeSsh(state, next) {
-            if (state.runningFrom !== 'remote') {
-                return next();
-            }
+                function getHeadnodeSsh(state, next) {
+                    if (state.runningFrom !== 'remote') {
+                        return next();
+                    }
 
-            // For now assume coal.
-            state.headnodeSsh = 'root@10.99.99.7';
-            next();
+                    // For now assume coal.
+                    state.headnodeSsh = 'root@10.99.99.7';
+                    next();
+                },
+
+                function getEnv(state, next) {
+                    var envClass = {
+                        remote: LocalDockerEnv,
+                        gz: GzDockerEnv
+                    }[state.runningFrom];
+                    env = new envClass(t, state, opts);
+                    env.init(t, state, next);
+                }
+            ]
         },
-
-
-        function getEnv(state, next) {
-            var envClass = {
-                remote: LocalDockerEnv,
-                gz: GzDockerEnv
-            }[state.runningFrom];
-            env = new envClass(t, state, opts);
-            env.init(t, state, next);
-        }
-
-    ]}, function (err) {
-        if (err) {
-            cb(err);
-        } else {
-            cb(null, env);
+        function(err) {
+            if (err) {
+                cb(err);
+            } else {
+                cb(null, env);
+            }
         }
-    });
-
+    );
 }
 
-
-
 // --- other exports
 
-
 /**
  * Get a simple restify JSON client to the SDC Docker Remote API.
  *
@@ -1138,18 +1345,18 @@ function createDockerRemoteClient(options, callback) {
     assert.func(callback, 'callback');
 
     var clientType = options.clientType;
-    assert.ok(clientType === undefined || typeof (clientType) === 'string');
+    assert.ok(clientType === undefined || typeof clientType === 'string');
 
     var user = options.user;
     assert.object(user, 'user');
 
     var clientFactories = {
-        'http': restify.createHttpClient,
-        'json': restify.createJsonClient,
-        'string': restify.createStringClient
+        http: restify.createHttpClient,
+        json: restify.createJsonClient,
+        string: restify.createStringClient
     };
 
-    createClientOpts('docker', function (err, opts) {
+    createClientOpts('docker', function(err, opts) {
         if (err) {
             return callback(err);
         }
@@ -1161,8 +1368,7 @@ function createDockerRemoteClient(options, callback) {
         opts.rejectUnauthorized = false;
 
         var clientFactory = restify.createJsonClient;
-        if (clientType)
-            clientFactory = clientFactories[clientType];
+        if (clientType) clientFactory = clientFactories[clientType];
 
         var client = clientFactory.call(clientFactory, opts);
         client.user = user;
@@ -1171,14 +1377,13 @@ function createDockerRemoteClient(options, callback) {
     });
 }
 
-
 /**
  * Get a simple restify JSON client to FWAPI.
  */
 function createFwapiClient(callback) {
     assert.func(callback, 'callback');
 
-    createClientOpts('fwapi', function (err, opts) {
+    createClientOpts('fwapi', function(err, opts) {
         if (err) {
             return callback(err);
         }
@@ -1194,7 +1399,7 @@ function createFwapiClient(callback) {
 function createSapiClient(callback) {
     assert.func(callback, 'callback');
 
-    createClientOpts('sapi', function (err, opts) {
+    createClientOpts('sapi', function(err, opts) {
         if (err) {
             return callback(err);
         }
@@ -1204,15 +1409,13 @@ function createSapiClient(callback) {
     });
 }
 
-
-
 /**
  * Get a simple restify JSON client to PAPI.
  */
 function createPapiClient(callback) {
     assert.func(callback, 'callback');
 
-    createClientOpts('papi', function (err, opts) {
+    createClientOpts('papi', function(err, opts) {
         if (err) {
             return callback(err);
         }
@@ -1222,14 +1425,13 @@ function createPapiClient(callback) {
     });
 }
 
-
 /**
  * Get a simple restify JSON client to VMAPI.
  */
 function createVmapiClient(callback) {
     assert.func(callback, 'callback');
 
-    createClientOpts('vmapi', function (err, opts) {
+    createClientOpts('vmapi', function(err, opts) {
         if (err) {
             return callback(err);
         }
@@ -1245,7 +1447,7 @@ function createVmapiClient(callback) {
 function createNapiClient(callback) {
     assert.func(callback, 'callback');
 
-    createClientOpts('napi', function (err, opts) {
+    createClientOpts('napi', function(err, opts) {
         if (err) {
             return callback(err);
         }
@@ -1261,12 +1463,11 @@ function createNapiClient(callback) {
 function assertInfo(t, info) {
     assert.object(t, 't');
 
-    t.equal(typeof (info), 'object', 'info is an object');
+    t.equal(typeof info, 'object', 'info is an object');
     t.equal(info.Driver, 'sdc', 'Driver is "sdc"');
-//     t.equal(info.NGoroutines, 42, 'Totally have 42 goroutines');
+    //     t.equal(info.NGoroutines, 42, 'Totally have 42 goroutines');
 }
 
-
 /*
  * Builds a docker container using the context passed in opts.tarball.
  *
@@ -1280,7 +1481,7 @@ function buildDockerContainer(opts, callback) {
     assert.optionalObject(opts.params, 'opts.params');
 
     var tarStream = opts.tarball;
-    if (typeof (opts.tarball) !== 'object') {
+    if (typeof opts.tarball !== 'object') {
         assert.string(opts.tarball, 'opts.tarball must be a string or stream');
         tarStream = fs.createReadStream(opts.tarball);
     }
@@ -1289,9 +1490,13 @@ function buildDockerContainer(opts, callback) {
     var log = dockerClient.log;
     var queryParams = '';
     if (opts.params) {
-        queryParams = '?' + Object.keys(opts.params).map(function (q) {
-            return fmt('%s=%s', escape(q), escape(opts.params[q]));
-        }).join('&');
+        queryParams =
+            '?' +
+            Object.keys(opts.params)
+                .map(function(q) {
+                    return fmt('%s=%s', escape(q), escape(opts.params[q]));
+                })
+                .join('&');
     }
 
     var headers = {
@@ -1303,8 +1508,9 @@ function buildDockerContainer(opts, callback) {
     if (opts.extraHeaders) {
         for (var header in opts.extraHeaders) {
             if (header in headers) {
-                var errorMsg = 'Extra header [%s] already set, you should '
-                + 'not override it';
+                var errorMsg =
+                    'Extra header [%s] already set, you should ' +
+                    'not override it';
                 errorMsg = fmt(errorMsg, header);
                 throw new Error(errorMsg);
             }
@@ -1313,10 +1519,13 @@ function buildDockerContainer(opts, callback) {
         }
     }
 
-    dockerClient.post({
-        path: '/build' + queryParams,
-        headers: headers
-    }, onpost);
+    dockerClient.post(
+        {
+            path: '/build' + queryParams,
+            headers: headers
+        },
+        onpost
+    );
 
     function onpost(connectErr, req) {
         var buildResult = {};
@@ -1377,116 +1586,135 @@ function ensureImage(opts, callback) {
     var log;
     var name = opts.name;
 
-    vasync.pipeline({ arg: {}, funcs: [
-        function getJsonClient(ctx, next) {
-            // Get the json client.
-            createDockerRemoteClient({user: opts.user},
-                    function _getJsonClient(err, client) {
-                log = client.log;
-                ctx.jsonClient = client;
-                next(err);
-            });
-        },
-
-        // Check if the image has already been pulled.
-        function checkImageExists(ctx, next) {
-            ctx.jsonClient.get('/images/' + name + '/json',
-                    function _getImage(err) {
-                if (!err) {
-                    // Image found, all is good in the world.
-                    log.debug({name: name}, 'image already exists');
-                    next(true); /* Early abort marker. */
-                    return;
-                }
-                // Allow a 404 error (image not found), other cases a failure.
-                if (err.statusCode !== 404) {
-                    log.warn({name: name}, 'image get error');
-                    next(err);
-                    return;
-                }
-                next();
-            });
-        },
-
-        function getHttpClient(ctx, next) {
-            createDockerRemoteClient({user: opts.user, clientType: 'http'},
-                    function (err, client) {
-                ctx.httpClient = client;
-                next(err);
-            });
-        },
-
-        // Image doesn't exist... pull it down.
-        function pullImage(ctx, next) {
-            log.debug({name: name}, 'ensureImage: pulling image');
-            var url = '/images/create?fromImage='
-                + encodeURIComponent(name);
-            ctx.httpClient.post(url, function _onPost(err, req) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-                req.on('result', function onResponse(err2, res) {
-                    // Don't cancel the request here, wait and read the error
-                    // string in readPullResponse.
-                    ctx.err = err2;
-                    ctx.res = res;
-                    next();
-                });
-                req.on('error', function onReqError(err2) {
-                    log.error({err: err2}, 'Image pull request error');
-                    next(err2);
-                    return;
-                });
-                // We don't need to write anything to create image.
-                req.end();
-            });
-        },
+    vasync.pipeline(
+        {
+            arg: {},
+            funcs: [
+                function getJsonClient(ctx, next) {
+                    // Get the json client.
+                    createDockerRemoteClient(
+                        {user: opts.user},
+                        function _getJsonClient(err, client) {
+                            log = client.log;
+                            ctx.jsonClient = client;
+                            next(err);
+                        }
+                    );
+                },
+
+                // Check if the image has already been pulled.
+                function checkImageExists(ctx, next) {
+                    ctx.jsonClient.get(
+                        '/images/' + name + '/json',
+                        function _getImage(err) {
+                            if (!err) {
+                                // Image found, all is good in the world.
+                                log.debug({name: name}, 'image already exists');
+                                next(true); /* Early abort marker. */
+                                return;
+                            }
+                            // Allow a 404 error (image not found), other cases a failure.
+                            if (err.statusCode !== 404) {
+                                log.warn({name: name}, 'image get error');
+                                next(err);
+                                return;
+                            }
+                            next();
+                        }
+                    );
+                },
+
+                function getHttpClient(ctx, next) {
+                    createDockerRemoteClient(
+                        {user: opts.user, clientType: 'http'},
+                        function(err, client) {
+                            ctx.httpClient = client;
+                            next(err);
+                        }
+                    );
+                },
+
+                // Image doesn't exist... pull it down.
+                function pullImage(ctx, next) {
+                    log.debug({name: name}, 'ensureImage: pulling image');
+                    var url =
+                        '/images/create?fromImage=' + encodeURIComponent(name);
+                    ctx.httpClient.post(url, function _onPost(err, req) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        req.on('result', function onResponse(err2, res) {
+                            // Don't cancel the request here, wait and read the error
+                            // string in readPullResponse.
+                            ctx.err = err2;
+                            ctx.res = res;
+                            next();
+                        });
+                        req.on('error', function onReqError(err2) {
+                            log.error({err: err2}, 'Image pull request error');
+                            next(err2);
+                            return;
+                        });
+                        // We don't need to write anything to create image.
+                        req.end();
+                    });
+                },
 
-        function readPullResponse(ctx, next) {
-            var body = '';
+                function readPullResponse(ctx, next) {
+                    var body = '';
 
-            ctx.res.on('data', function onResData(data) {
-                body += data.toString();
-            });
+                    ctx.res.on('data', function onResData(data) {
+                        body += data.toString();
+                    });
 
-            ctx.res.on('end', function onEnd() {
-                if (ctx.err) {
-                    if (!ctx.err.message) {
-                        ctx.err.message = body;
-                    }
-                    next(ctx.err);
-                    return;
+                    ctx.res.on('end', function onEnd() {
+                        if (ctx.err) {
+                            if (!ctx.err.message) {
+                                ctx.err.message = body;
+                            }
+                            next(ctx.err);
+                            return;
+                        }
+                        ctx.body = body;
+                        next();
+                    });
+                },
+
+                // Check again to ensure the image now exists.
+                function recheckImageExists(ctx, next) {
+                    ctx.jsonClient.get(
+                        '/images/' + name + '/json',
+                        function _getImage(err) {
+                            if (err) {
+                                log.error(
+                                    {name: name},
+                                    'Error pulling image, body: %s',
+                                    ctx.body
+                                );
+                                next(
+                                    new Error(
+                                        fmt('Failed to pull image %s', name)
+                                    )
+                                );
+                                return;
+                            }
+                            next();
+                        }
+                    );
                 }
-                ctx.body = body;
-                next();
-            });
+            ]
         },
-
-        // Check again to ensure the image now exists.
-        function recheckImageExists(ctx, next) {
-            ctx.jsonClient.get('/images/' + name + '/json',
-                    function _getImage(err) {
-                if (err) {
-                    log.error({name: name}, 'Error pulling image, body: %s',
-                        ctx.body);
-                    next(new Error(fmt('Failed to pull image %s', name)));
-                    return;
-                }
-                next();
-            });
-        }
-
-    ]}, function _onComplete(err) {
-        if (err === true) {
-            // Early abort - the image already exists.
-            err = null;
+        function _onComplete(err) {
+            if (err === true) {
+                // Early abort - the image already exists.
+                err = null;
+            }
+            callback(err);
         }
-        callback(err);
-    });
+    );
 }
 
-
 /**
  * Create a nginx VM fixture
  */
@@ -1495,49 +1723,49 @@ function createDockerContainer(opts, callback) {
     assert.func(callback, 'callback');
 
     var payload = {
-        'Hostname': '',
-        'Domainname': '',
-        'User': '',
-        'Memory': 0,
-        'MemorySwap': 0,
-        'CpuShares': 0,
-        'Cpuset': '',
-        'AttachStdin': false,
-        'AttachStdout': false,
-        'AttachStderr': false,
-        'PortSpecs': null,
-        'ExposedPorts': {},
-        'Tty': false,
-        'OpenStdin': false,
-        'StdinOnce': false,
-        'Env': [],
-        'Cmd': null,
-        'Image': 'nginx',
-        'Volumes': {},
-        'WorkingDir': '',
-        'Entrypoint': null,
-        'NetworkDisabled': false,
-        'OnBuild': null,
-        'SecurityOpt': null,
-        'HostConfig': {
-            'Binds': null,
-            'ContainerIDFile': '',
-            'LxcConf': [],
-            'Privileged': false,
-            'PortBindings': {},
-            'Links': null,
-            'PublishAllPorts': false,
-            'Dns': null,
-            'DnsSearch': null,
-            'ExtraHosts': null,
-            'VolumesFrom': null,
-            'Devices': [],
-            'NetworkMode': 'bridge',
-            'CapAdd': null,
-            'CapDrop': null,
-            'RestartPolicy': {
-                'Name': '',
-                'MaximumRetryCount': 0
+        Hostname: '',
+        Domainname: '',
+        User: '',
+        Memory: 0,
+        MemorySwap: 0,
+        CpuShares: 0,
+        Cpuset: '',
+        AttachStdin: false,
+        AttachStdout: false,
+        AttachStderr: false,
+        PortSpecs: null,
+        ExposedPorts: {},
+        Tty: false,
+        OpenStdin: false,
+        StdinOnce: false,
+        Env: [],
+        Cmd: null,
+        Image: 'nginx',
+        Volumes: {},
+        WorkingDir: '',
+        Entrypoint: null,
+        NetworkDisabled: false,
+        OnBuild: null,
+        SecurityOpt: null,
+        HostConfig: {
+            Binds: null,
+            ContainerIDFile: '',
+            LxcConf: [],
+            Privileged: false,
+            PortBindings: {},
+            Links: null,
+            PublishAllPorts: false,
+            Dns: null,
+            DnsSearch: null,
+            ExtraHosts: null,
+            VolumesFrom: null,
+            Devices: [],
+            NetworkMode: 'bridge',
+            CapAdd: null,
+            CapDrop: null,
+            RestartPolicy: {
+                Name: '',
+                MaximumRetryCount: 0
             }
         }
     };
@@ -1546,92 +1774,103 @@ function createDockerContainer(opts, callback) {
     var vmapiClient = opts.vmapiClient;
     var t = opts.test;
     var response = {};
-    var apiVersion = opts.apiVersion || ('v' + constants.API_VERSION);
+    var apiVersion = opts.apiVersion || 'v' + constants.API_VERSION;
 
     if (opts.extra) {
         for (var e in opts.extra) {
-
             // Allow overriding sub-properties with a dot notation,
             // eg: RestartPolicy.Name
             var split = e.split('.');
             if (split.length > 1) {
                 payload[split[0]][split[1]] = opts.extra[e];
-
             } else {
                 payload[e] = opts.extra[e];
             }
         }
     }
 
-    vasync.waterfall([
-        function (next) {
-            // There is a dependency here, in order to create a nginx container,
-            // the nginx image must first be downloaded.
-            ensureImage({
-                name: 'nginx:latest',
-                user: dockerClient.user
-            }, next);
-        },
+    vasync.waterfall(
+        [
+            function(next) {
+                // There is a dependency here, in order to create a nginx container,
+                // the nginx image must first be downloaded.
+                ensureImage(
+                    {
+                        name: 'nginx:latest',
+                        user: dockerClient.user
+                    },
+                    next
+                );
+            },
+
+            function(next) {
+                // Post create request
+                dockerClient.post(
+                    '/' + apiVersion + '/containers/create',
+                    payload,
+                    onpost
+                );
+                function onpost(err, res, req, body) {
+                    if (opts.expectedErr) {
+                        common.expApiErr(t, err, opts.expectedErr, callback);
+                        return;
+                    }
 
-        function (next) {
-            // Post create request
-            dockerClient.post(
-                '/' + apiVersion + '/containers/create', payload, onpost);
-            function onpost(err, res, req, body) {
-                if (opts.expectedErr) {
-                    common.expApiErr(t, err, opts.expectedErr, callback);
+                    t.deepEqual(
+                        body.Warnings,
+                        [],
+                        'Warnings should be present and empty'
+                    );
+                    t.ok(body.Id, 'Id should be present');
+                    response.id = body.Id;
+                    next(err);
+                }
+            },
+            function startContainer(next) {
+                // Attempt to start the container.
+                if (!opts.start) {
+                    next();
                     return;
                 }
-
-                t.deepEqual(
-                    body.Warnings, [], 'Warnings should be present and empty');
-                t.ok(body.Id, 'Id should be present');
-                response.id = body.Id;
-                next(err);
+                dockerClient.post(
+                    '/containers/' + response.id + '/start',
+                    onpost
+                );
+                function onpost(err, res, req, body) {
+                    t.error(err);
+                    next(err);
+                }
+            },
+            function(next) {
+                // Attempt to get container json (i.e. docker inspect).
+                dockerClient.get('/containers/' + response.id + '/json', onget);
+                function onget(err, res, req, body) {
+                    t.error(err);
+                    response.inspect = body;
+                    response.uuid = sdcCommon.dockerIdToUuid(response.id);
+                    next(err);
+                }
+            },
+            function(next) {
+                vmapiClient.getVm({uuid: response.uuid}, function(err, vm) {
+                    t.error(err);
+                    response.vm = vm;
+                    next(err);
+                });
             }
-        },
-        function startContainer(next) {
-            // Attempt to start the container.
-            if (!opts.start) {
-                next();
+        ],
+        function(err) {
+            if (opts.expectedError) {
+                common.expApiErr(t, err, opts.expectedErr, callback);
                 return;
             }
-            dockerClient.post('/containers/' + response.id + '/start', onpost);
-            function onpost(err, res, req, body) {
-                t.error(err);
-                next(err);
-            }
-        },
-        function (next) {
-            // Attempt to get container json (i.e. docker inspect).
-            dockerClient.get(
-                '/containers/' + response.id + '/json', onget);
-            function onget(err, res, req, body) {
-                t.error(err);
-                response.inspect = body;
-                response.uuid = sdcCommon.dockerIdToUuid(response.id);
-                next(err);
-            }
-        },
-        function (next) {
-            vmapiClient.getVm({ uuid: response.uuid }, function (err, vm) {
-                t.error(err);
-                response.vm = vm;
-                next(err);
-            });
-        }
-    ], function (err) {
-        if (opts.expectedError) {
-            common.expApiErr(t, err, opts.expectedErr, callback);
-            return;
-        }
-        t.error(err);
+            t.error(err);
 
-        callback(err, response);
-    });
+            callback(err, response);
+        }
+    );
 }
 
-
 function listContainers(opts, callback) {
     assert.object(opts, 'opts');
     assert.func(callback, 'callback');
@@ -1640,26 +1879,28 @@ function listContainers(opts, callback) {
     var t = opts.test;
     var containers;
 
-    vasync.waterfall([
-        function (next) {
-            // Post create request
-            dockerClient.get(
-                '/containers/json'
-                + (opts.all ? '?all=1' : ''), onget);
-            function onget(err, res, req, body) {
-                t.error(err);
-                containers = body;
-                next(err);
+    vasync.waterfall(
+        [
+            function(next) {
+                // Post create request
+                dockerClient.get(
+                    '/containers/json' + (opts.all ? '?all=1' : ''),
+                    onget
+                );
+                function onget(err, res, req, body) {
+                    t.error(err);
+                    containers = body;
+                    next(err);
+                }
             }
+        ],
+        function(err) {
+            t.error(err);
+            callback(err, containers);
         }
-    ],
-    function (err) {
-        t.error(err);
-        callback(err, containers);
-    });
+    );
 }
 
-
 /*
  * Takes a docker zone ID as first argument, and calls "callback"
  * with an error object as first argument, and the path to the SDC-docker
@@ -1691,8 +1932,11 @@ function getDockerZoneId(callback) {
             stdout = stdout.trim();
             var outputLines = stdout.split(os.EOL);
             if (outputLines.length !== 1)
-                err = new Error('vmadm output must be in 1 line, '
-                    + 'actual output: ' + stdout);
+                err = new Error(
+                    'vmadm output must be in 1 line, ' +
+                        'actual output: ' +
+                        stdout
+                );
         }
 
         return callback(err, stdout);
@@ -1713,25 +1957,28 @@ function findHandlerTimerInLogs(logFilePath, reqId, handlerName, callback) {
 
     var handlerTimerFound = false;
 
-    var cmdLine = 'cat ' + logFilePath
-    // filter non-JSON data
-    + ' | grep -v \'^[^{]\''
-    // filter records for the request ID passed as input
-    // and output with one line per record
-    + ' | json -ga -o jsony-0 -c this.req_id==' + reqId
-    // grab the latest request
-    + ' | tail -1'
-    // filter handlers timers info
-    + ' | json -o jsony-0 req.timers'
-    // Filter requests that made the body parser handler run
-    + ' | grep ' + handlerName;
+    var cmdLine =
+        'cat ' +
+        logFilePath +
+        // filter non-JSON data
+        " | grep -v '^[^{]'" +
+        // filter records for the request ID passed as input
+        // and output with one line per record
+        ' | json -ga -o jsony-0 -c this.req_id==' +
+        reqId +
+        // grab the latest request
+        ' | tail -1' +
+        // filter handlers timers info
+        ' | json -o jsony-0 req.timers' +
+        // Filter requests that made the body parser handler run
+        ' | grep ' +
+        handlerName;
 
     exec(cmdLine, onExecDone);
     function onExecDone(err, stdout, stderr) {
         // if grep exits with no error, it means it found
         // a match, and so the handler with name "handlerName" ran
-        if (err === null || err.code === 0)
-            handlerTimerFound = true;
+        if (err === null || err.code === 0) handlerTimerFound = true;
 
         // If there's an error when running grep, there are two different
         // cases:
@@ -1741,8 +1988,7 @@ function findHandlerTimerInLogs(logFilePath, reqId, handlerName, callback) {
         //
         // 2. if it exits with a status code of 1, it means no match was
         // found, but it's not an error per se.
-        if (err && err.code === 1)
-            err = null;
+        if (err && err.code === 1) err = null;
 
         return callback(err, handlerTimerFound);
     }
@@ -1762,15 +2008,18 @@ function didRestifyHandlerRun(reqId, handlerName, callback) {
     // log entry with the same request ID
     // doesn't have a req.timers entry for handlerName, which would
     // mean the handler was executed.
-    vasync.waterfall([
-        getDockerZoneId,
-        getServiceLogFilePath,
-        function (logFilePath, next) {
-            findHandlerTimerInLogs(logFilePath, reqId, handlerName, next);
+    vasync.waterfall(
+        [
+            getDockerZoneId,
+            getServiceLogFilePath,
+            function(logFilePath, next) {
+                findHandlerTimerInLogs(logFilePath, reqId, handlerName, next);
+            }
+        ],
+        function allDone(err, handlerTimerFound) {
+            return callback(err, handlerTimerFound);
         }
-    ], function allDone(err, handlerTimerFound) {
-        return callback(err, handlerTimerFound);
-    });
+    );
 }
 
 /*
@@ -1781,16 +2030,17 @@ function getOrCreateFabricVLAN(client, userUuid, fabricParams, callback) {
     assert.uuid(userUuid, 'user uuid');
     assert.object(fabricParams, 'fabricParams');
 
-    client.getFabricVLAN(userUuid, fabricParams.vlan_id, {},
-        function (err, vlan) {
-            if (err && err.restCode !== 'ResourceNotFound') {
-                return callback(err);
-            } else if (vlan) {
-                return callback(null, vlan);
-            }
-            client.createFabricVLAN(userUuid, fabricParams, callback);
+    client.getFabricVLAN(userUuid, fabricParams.vlan_id, {}, function(
+        err,
+        vlan
+    ) {
+        if (err && err.restCode !== 'ResourceNotFound') {
+            return callback(err);
+        } else if (vlan) {
+            return callback(null, vlan);
         }
-    );
+        client.createFabricVLAN(userUuid, fabricParams, callback);
+    });
 }
 
 /*
@@ -1806,17 +2056,18 @@ function getOrCreateFabricNetwork(client, userUuid, vlan_id, params, callback) {
     var listParams = {
         name: params.name
     };
-    client.listFabricNetworks(userUuid, vlan_id, listParams,
-        function (err, networks) {
-            if (err) {
-                return callback(err);
-            }
-            if (networks.length !== 0) {
-                return callback(null, networks[0]);
-            }
-            client.createFabricNetwork(userUuid, vlan_id, params, callback);
+    client.listFabricNetworks(userUuid, vlan_id, listParams, function(
+        err,
+        networks
+    ) {
+        if (err) {
+            return callback(err);
         }
-    );
+        if (networks.length !== 0) {
+            return callback(null, networks[0]);
+        }
+        client.createFabricNetwork(userUuid, vlan_id, params, callback);
+    });
 }
 
 /*
@@ -1834,36 +2085,49 @@ function getSortedPackages(callback) {
 
     assert.string(packagePrefix, 'configFile packagePrefix');
 
-    vasync.pipeline({funcs: [
-        function _createPapiClient(_, cb) {
-            createPapiClient(function (err, _papi) {
-                papi = _papi;
-                cb(err);
-            });
-        }, function _getPackages(_, cb) {
-            papi.list('name=' + packagePrefix + '*', {}, function (err, pkgs) {
-                if (err) {
-                    cb(err);
-                    return;
-                }
+    vasync.pipeline(
+        {
+            funcs: [
+                function _createPapiClient(_, cb) {
+                    createPapiClient(function(err, _papi) {
+                        papi = _papi;
+                        cb(err);
+                    });
+                },
+                function _getPackages(_, cb) {
+                    papi.list('name=' + packagePrefix + '*', {}, function(
+                        err,
+                        pkgs
+                    ) {
+                        if (err) {
+                            cb(err);
+                            return;
+                        }
 
-                assert.arrayOfObject(pkgs, 'pkgs');
+                        assert.arrayOfObject(pkgs, 'pkgs');
 
-                packages = pkgs.filter(function _filterPkgs(pkg) {
-                    return (Boolean(pkg.active));
-                }).sort(function _cmpPkgMemory(a, b) {
-                    return (a.max_physical_memory - b.max_physical_memory);
-                });
+                        packages = pkgs
+                            .filter(function _filterPkgs(pkg) {
+                                return Boolean(pkg.active);
+                            })
+                            .sort(function _cmpPkgMemory(a, b) {
+                                return (
+                                    a.max_physical_memory -
+                                    b.max_physical_memory
+                                );
+                            });
 
-                cb();
-            });
+                        cb();
+                    });
+                }
+            ]
+        },
+        function _afterPkgPipeline(err) {
+            callback(err, packages);
         }
-    ]}, function _afterPkgPipeline(err) {
-        callback(err, packages);
-    });
+    );
 }
 
-
 // --- exports
 
 module.exports = {
diff --git a/test/lib/cli.js b/test/lib/cli.js
index fe5a5f3..a142fd9 100644
--- a/test/lib/cli.js
+++ b/test/lib/cli.js
@@ -20,10 +20,8 @@ var cli = require('../lib/cli');
 var common = require('./common');
 var h = require('../integration/helpers');
 
-
 // --- Globals
 
-
 var ALICE;
 var ALICE_CLIENT;
 var CREATED = [];
@@ -33,10 +31,8 @@ var state = {
     log: LOG
 };
 
-
 // --- Exports
 
-
 /**
  * Initialize the alice DockerEnv
  *
@@ -47,26 +43,25 @@ var state = {
  *  }
  */
 function cliInit(t, cb) {
-    h.getDockerEnv(t, state, {account: 'sdcdockertest_alice'},
-            function (err, env) {
+    h.getDockerEnv(t, state, {account: 'sdcdockertest_alice'}, function(
+        err,
+        env
+    ) {
         t.ifErr(err, 'expect no error loading docker env');
         t.ok(env, 'have a DockerEnv for alice');
         ALICE = env;
 
-        h.createDockerRemoteClient({user: ALICE},
-            function (clientErr, client) {
-                t.ifErr(clientErr, 'docker remote client for alice');
-                ALICE_CLIENT = client;
-                if (cb) {
-                    cb(err || clientErr, {user: ALICE, client: ALICE_CLIENT});
-                }
-                t.end();
+        h.createDockerRemoteClient({user: ALICE}, function(clientErr, client) {
+            t.ifErr(clientErr, 'docker remote client for alice');
+            ALICE_CLIENT = client;
+            if (cb) {
+                cb(err || clientErr, {user: ALICE, client: ALICE_CLIENT});
             }
-        );
+            t.end();
+        });
     });
 }
 
-
 /**
  * `docker inspect <id>`
  */
@@ -75,7 +70,7 @@ function cliInspect(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.id, 'opts.id');
 
-    ALICE.docker('inspect ' + opts.id, function (err, stdout, stderr) {
+    ALICE.docker('inspect ' + opts.id, function(err, stdout, stderr) {
         var obj;
         var pe;
 
@@ -112,13 +107,13 @@ function cliInspect(t, opts, callback) {
             pe = opts.partialExp;
 
             if (pe && pe.Config && pe.Config.Labels) {
-                Object.keys(pe.Config.Labels).forEach(
-                    function _fixWildcardLabels(l) {
-                        if (pe.Config.Labels[l] === '*') {
-                            pe.Config.Labels[l] = obj.Config.Labels[l];
-                        }
+                Object.keys(
+                    pe.Config.Labels
+                ).forEach(function _fixWildcardLabels(l) {
+                    if (pe.Config.Labels[l] === '*') {
+                        pe.Config.Labels[l] = obj.Config.Labels[l];
                     }
-                );
+                });
             }
         }
 
@@ -130,7 +125,6 @@ function cliInspect(t, opts, callback) {
     });
 }
 
-
 /**
  * `docker images <opts.args>`
  *
@@ -159,7 +153,7 @@ function cliImages(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.optionalString(opts.args, 'opts.args');
 
-    ALICE.docker('images ' + (opts.args || ''), function (err, stdout, stderr) {
+    ALICE.docker('images ' + (opts.args || ''), function(err, stdout, stderr) {
         if (opts.expectedErr) {
             t.equal(stdout, '', 'stdout should be empty');
             common.expCliErr(t, stderr, opts.expectedErr, callback);
@@ -180,7 +174,6 @@ function cliImages(t, opts, callback) {
     });
 }
 
-
 /**
  * `docker port <id> [port spec]`
  */
@@ -189,7 +182,7 @@ function cliPort(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.id, 'opts.id');
 
-    ALICE.docker('port ' + opts.id, function (err, stdout, stderr) {
+    ALICE.docker('port ' + opts.id, function(err, stdout, stderr) {
         var obj = {};
 
         t.ifErr(err, 'docker port');
@@ -207,7 +200,7 @@ function cliPort(t, opts, callback) {
             stdout = '';
         }
 
-        stdout.split('\n').forEach(function (line) {
+        stdout.split('\n').forEach(function(line) {
             var split = line.split(' -> ');
             if (split[0] && split[1]) {
                 obj[split[0]] = split[1];
@@ -222,7 +215,6 @@ function cliPort(t, opts, callback) {
     });
 }
 
-
 /**
  * `docker pull <id>`
  */
@@ -231,7 +223,7 @@ function cliPull(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.image, 'opts.image');
 
-    ALICE.docker('pull ' + opts.image, function (err, stdout, stderr) {
+    ALICE.docker('pull ' + opts.image, function(err, stdout, stderr) {
         var obj;
 
         t.ifErr(err, 'docker pull');
@@ -258,7 +250,6 @@ function cliPull(t, opts, callback) {
     });
 }
 
-
 /**
  * Removes all docker VMs created during this test
  */
@@ -275,23 +266,25 @@ function cliRmAllCreated(t) {
         return;
     }
 
-    vasync.forEachParallel({
-        inputs: CREATED,
-        func: function _delOne(id, cb) {
-            ALICE.docker('rm -f ' + id, function (err, stdout, stderr) {
-                t.ifErr(err, 'rm container ' + id);
+    vasync.forEachParallel(
+        {
+            inputs: CREATED,
+            func: function _delOne(id, cb) {
+                ALICE.docker('rm -f ' + id, function(err, stdout, stderr) {
+                    t.ifErr(err, 'rm container ' + id);
 
-                cb();
-                return;
-            });
+                    cb();
+                    return;
+                });
+            }
+        },
+        function() {
+            t.end();
+            return;
         }
-    }, function () {
-        t.end();
-        return;
-    });
+    );
 }
 
-
 /**
  * `docker create <cmd>`
  */
@@ -300,7 +293,7 @@ function cliCreate(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.args, 'opts.args');
 
-    ALICE.docker('create ' + opts.args, function (err, stdout, stderr) {
+    ALICE.docker('create ' + opts.args, function(err, stdout, stderr) {
         var id;
 
         if (stdout) {
@@ -314,14 +307,14 @@ function cliCreate(t, opts, callback) {
 
             common.expCliErr(t, stderr, opts.expectedErr, callback);
             return;
-
         } else {
             t.ifErr(err, 'docker create');
             // Docker create may need to download the image, which produces
             // stderr - only allow for that case:
-            if (stderr
-                && stderr.indexOf('Status: Downloaded newer image') === -1)
-            {
+            if (
+                stderr &&
+                stderr.indexOf('Status: Downloaded newer image') === -1
+            ) {
                 t.equal(stderr, '', 'stderr');
             }
         }
@@ -337,7 +330,6 @@ function cliCreate(t, opts, callback) {
     });
 }
 
-
 /**
  * `docker run <cmd>`
  *
@@ -354,7 +346,7 @@ function cliRun(t, opts, callback) {
     var detachedRegex = /(^|\s)(-d|--detached)\s/;
     var isBackgroundMode = (opts.args || '').search(detachedRegex) >= 0;
 
-    ALICE.docker('run ' + opts.args, function (err, stdout, stderr) {
+    ALICE.docker('run ' + opts.args, function(err, stdout, stderr) {
         var id;
 
         if (isBackgroundMode && stdout) {
@@ -368,14 +360,14 @@ function cliRun(t, opts, callback) {
 
             common.expCliErr(t, stderr, opts.expectedErr, callback);
             return;
-
         } else {
             t.ifErr(err, 'docker run');
             // Docker run may need to download the image, which produces
             // stderr - only allow for that case:
-            if (stderr
-                && stderr.indexOf('Status: Downloaded newer image') === -1)
-            {
+            if (
+                stderr &&
+                stderr.indexOf('Status: Downloaded newer image') === -1
+            ) {
                 t.equal(stderr, '', 'stderr');
             }
         }
@@ -389,13 +381,12 @@ function cliRun(t, opts, callback) {
         if (isBackgroundMode) {
             common.done(t, callback, err, id);
         } else {
-            common.done(t, callback, err, { stdout: stdout, stderr: stderr });
+            common.done(t, callback, err, {stdout: stdout, stderr: stderr});
         }
         return;
     });
 }
 
-
 /**
  * `docker ps <opts.args>`
  *
@@ -416,7 +407,7 @@ function cliPs(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.optionalString(opts.args, 'opts.args');
 
-    ALICE.docker('ps ' + (opts.args || ''), function (err, stdout, stderr) {
+    ALICE.docker('ps ' + (opts.args || ''), function(err, stdout, stderr) {
         if (opts.expectedErr) {
             t.equal(stdout, '', 'stdout should be empty');
             common.expCliErr(t, stderr, opts.expectedErr, callback);
@@ -438,7 +429,6 @@ function cliPs(t, opts, callback) {
     });
 }
 
-
 /**
  * `docker delete <opts.args>`
  */
@@ -447,7 +437,7 @@ function cliRm(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.args, 'opts.args');
 
-    ALICE.docker('rm ' + opts.args, function (err, stdout, stderr) {
+    ALICE.docker('rm ' + opts.args, function(err, stdout, stderr) {
         t.ifErr(err, 'docker rm ' + opts.args);
         t.equal(stderr, '', 'stderr');
 
@@ -455,7 +445,6 @@ function cliRm(t, opts, callback) {
     });
 }
 
-
 /**
  * `docker rmi <opts.args>`
  */
@@ -464,14 +453,13 @@ function cliRmi(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.args, 'opts.args');
 
-    ALICE.docker('rmi ' + opts.args, function (err, stdout, stderr) {
+    ALICE.docker('rmi ' + opts.args, function(err, stdout, stderr) {
         t.ifErr(err, 'docker rmi ' + opts.args);
         t.equal(stderr, '', 'stderr');
         callback(err);
     });
 }
 
-
 /**
  * `docker stop <opts.args>`
  */
@@ -480,14 +468,13 @@ function cliStop(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.args, 'opts.args');
 
-    ALICE.docker('stop ' + opts.args, function (err, stdout, stderr) {
+    ALICE.docker('stop ' + opts.args, function(err, stdout, stderr) {
         t.ifErr(err, 'docker stop ' + opts.args);
         t.equal(stderr, '', 'stderr');
         callback(err);
     });
 }
 
-
 /**
  * `docker start <opts.args>`
  */
@@ -496,14 +483,13 @@ function cliStart(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.args, 'opts.args');
 
-    ALICE.docker('start ' + opts.args, function (err, stdout, stderr) {
+    ALICE.docker('start ' + opts.args, function(err, stdout, stderr) {
         t.ifErr(err, 'docker start ' + opts.args);
         t.equal(stderr, '', 'stderr');
         callback(err);
     });
 }
 
-
 /**
  * `docker commit <opts.args>`
  */
@@ -512,7 +498,7 @@ function cliCommit(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.args, 'opts.args');
 
-    ALICE.docker('commit ' + opts.args, function (err, stdout, stderr) {
+    ALICE.docker('commit ' + opts.args, function(err, stdout, stderr) {
         var id;
 
         if (stdout) {
@@ -526,7 +512,6 @@ function cliCommit(t, opts, callback) {
 
             common.expCliErr(t, stderr, opts.expectedErr, callback);
             return;
-
         } else {
             t.ifErr(err, 'docker commit');
         }
@@ -539,7 +524,6 @@ function cliCommit(t, opts, callback) {
     });
 }
 
-
 /**
  * `docker attach <id>`
  *
@@ -551,13 +535,12 @@ function cliAttach(t, opts, callback) {
     assert.object(opts, 'opts');
     assert.string(opts.args, 'opts.args');
 
-    ALICE.docker('attach ' + opts.args, function (err, stdout, stderr) {
+    ALICE.docker('attach ' + opts.args, function(err, stdout, stderr) {
         // pass errors back to caller
         common.done(t, callback, err);
     });
 }
 
-
 module.exports = {
     commit: cliCommit,
     create: cliCreate,
diff --git a/test/lib/common.js b/test/lib/common.js
index b139a06..513f39e 100644
--- a/test/lib/common.js
+++ b/test/lib/common.js
@@ -20,10 +20,8 @@ var fmt = require('util').format;
 var libuuid = require('libuuid');
 var VError = require('verror').VError;
 
-
 // --- Globals
 
-
 /* BEGIN JSSTYLED */
 /**
  * Parse docker error response.
@@ -42,7 +40,6 @@ var ERR_API_RE = /^()(.*) \(([^)]+)\)$/;
 var ERR_CLI_RE = /^(.*?\:\s?)?(Error response from daemon: .*) \(([^)]+)\)(\.\nSee '.* --help'\.)?$/m;
 /* END JSSTYLED */
 
-
 // --- Exports
 
 /**
@@ -59,7 +56,6 @@ function objCopy(from, to) {
     return to;
 }
 
-
 /**
  * Call when done an operation in a test.  If callback exists, call that.
  * If not, end the test.
@@ -73,7 +69,6 @@ function done(t, callback, err, res) {
     t.end();
 }
 
-
 /**
  * A convenience wrapper around `child_process.exec` to take away some
  * logging and error handling boilerplate.
@@ -99,20 +94,36 @@ function execPlus(args, cb) {
 
     // args.log.trace({exec: true, command: command, execOpts: execOpts},
     //      'exec start');
-    exec(command, execOpts, function (err, stdout, stderr) {
-        args.log.trace({exec: true, command: command, execOpts: execOpts,
-            err: err, stdout: stdout, stderr: stderr}, 'exec done');
+    exec(command, execOpts, function(err, stdout, stderr) {
+        args.log.trace(
+            {
+                exec: true,
+                command: command,
+                execOpts: execOpts,
+                err: err,
+                stdout: stdout,
+                stderr: stderr
+            },
+            'exec done'
+        );
         if (err) {
             cb(
-                new VError(err,
-                    '%s:\n'
-                    + '\tcommand: %s\n'
-                    + '\texit status: %s\n'
-                    + '\tstdout:\n%s\n'
-                    + '\tstderr:\n%s',
-                    args.errMsg || 'exec error', command, err.code,
-                    stdout.trim(), stderr.trim()),
-                stdout, stderr);
+                new VError(
+                    err,
+                    '%s:\n' +
+                        '\tcommand: %s\n' +
+                        '\texit status: %s\n' +
+                        '\tstdout:\n%s\n' +
+                        '\tstderr:\n%s',
+                    args.errMsg || 'exec error',
+                    command,
+                    err.code,
+                    stdout.trim(),
+                    stderr.trim()
+                ),
+                stdout,
+                stderr
+            );
         } else {
             cb(null, stdout, stderr);
         }
@@ -134,12 +145,12 @@ function expectedDeepEqual(t, opts, obj) {
 
     t.deepEqual(obj, opts.expected, 'expected');
     if (!deepEqual(obj, opts.expected)) {
-        t.comment(difflet({ indent: 4, comment: true })
-            .compare(obj, opts.expected));
+        t.comment(
+            difflet({indent: 4, comment: true}).compare(obj, opts.expected)
+        );
     }
 }
 
-
 /**
  * Tests for an expected error message, where `err` can either be an error
  * object or a string, and `expected` is the expected message (or regexp).
@@ -155,8 +166,7 @@ function expErr(t, err, expected, isCliErr, callback) {
         return;
     }
 
-    message = (typeof (err) === 'object' ? err.message : err)
-        .replace(/\n$/, '');
+    message = (typeof err === 'object' ? err.message : err).replace(/\n$/, '');
 
     /* BEGIN JSSTYLED */
     /*
@@ -182,11 +192,13 @@ function expErr(t, err, expected, isCliErr, callback) {
     }
     /* END JSSTYLED */
 
-    var expectedErrRe = (isCliErr ? ERR_CLI_RE : ERR_API_RE);
+    var expectedErrRe = isCliErr ? ERR_CLI_RE : ERR_API_RE;
     var matches = message.match(expectedErrRe);
     if (!matches) {
-        t.ok(matches, fmt('err message does not match %s: %j',
-            expectedErrRe, message));
+        t.ok(
+            matches,
+            fmt('err message does not match %s: %j', expectedErrRe, message)
+        );
         done(t, callback, new Error('unexpected error output'));
         return;
     }
@@ -194,17 +206,21 @@ function expErr(t, err, expected, isCliErr, callback) {
     errorString = matches[2];
 
     if (RegExp.prototype.isPrototypeOf(expected)) {
-        t.ok(expected.test(errorString),
-            fmt('error message matches %s: %j', expected, errorString));
+        t.ok(
+            expected.test(errorString),
+            fmt('error message matches %s: %j', expected, errorString)
+        );
     } else {
-        t.equal(errorString, expected,
-            'error message matches expected pattern');
+        t.equal(
+            errorString,
+            expected,
+            'error message matches expected pattern'
+        );
     }
 
     done(t, callback, err);
 }
 
-
 /**
  * Tests for an expected api error message, where `err` can either be an error
  * object or a string, and `expected` is the expected message.
@@ -213,7 +229,6 @@ function expApiErr(t, err, expected, callback) {
     return expErr(t, err, expected, false, callback);
 }
 
-
 /**
  * Tests for an expected cli error message, where `err` can either be an error
  * object or a string, and `expected` is the expected message.
@@ -222,7 +237,6 @@ function expCliErr(t, err, expected, callback) {
     return expErr(t, err, expected, true, callback);
 }
 
-
 /**
  * Calls t.ifError, outputs the error body for diagnostic purposes, and
  * returns true if there was an error
@@ -237,7 +251,6 @@ function ifErr(t, err, desc) {
     return false;
 }
 
-
 /**
  * Partial expected output - check equality of pieces of an object (specified
  * by `opts.partialExp`), not the whole thing.
@@ -257,13 +270,12 @@ function partialExp(t, opts, obj) {
     for (var p in opts.partialExp) {
         // Allow specifying some properties of sub-objects, but
         // not all:
-        if (typeof (opts.partialExp[p]) === 'object') {
+        if (typeof opts.partialExp[p] === 'object') {
             partial[p] = {};
 
             for (var e in opts.partialExp[p]) {
                 partial[p][e] = obj[p][e];
             }
-
         } else {
             partial[p] = obj[p];
         }
@@ -271,12 +283,15 @@ function partialExp(t, opts, obj) {
 
     t.deepEqual(partial, opts.partialExp, compareMessage);
     if (!deepEqual(partial, opts.partialExp)) {
-        t.comment(difflet({ indent: 4, comment: true })
-            .compare(partial, opts.partialExp));
+        t.comment(
+            difflet({indent: 4, comment: true}).compare(
+                partial,
+                opts.partialExp
+            )
+        );
     }
 }
 
-
 /*
  * Make a prefixed, randomized name for a test container.
  */
@@ -284,7 +299,6 @@ function makeContainerName(prefix) {
     return prefix + '-' + libuuid.create().split('-')[0];
 }
 
-
 /*
  * Make a prefixed, randomized name for a test image.
  */
@@ -292,7 +306,6 @@ function makeImageName(prefix) {
     return prefix + '-' + libuuid.create().split('-')[0];
 }
 
-
 /*
  * Parse docker columnar output by using the widths in the first header row.
  */
@@ -305,7 +318,7 @@ function parseOutputUsingHeader(stdout, opts) {
     // Some header names use spaces, like 'image id', so adjust those.
     if (opts.headerNamesWithSpaces) {
         var snames = opts.headerNamesWithSpaces;
-        snames.forEach(function (name) {
+        snames.forEach(function(name) {
             headerLine = headerLine.replace(name, name.replace(/\s/g, '_'));
         });
     }
@@ -315,13 +328,12 @@ function parseOutputUsingHeader(stdout, opts) {
         entries = lines;
     } else {
         // From header, determine where each section begins/ends:
-        var headerStartEnds = header.map(function (val, idx) {
+        var headerStartEnds = header.map(function(val, idx) {
             var nextval = header[idx + 1];
             if (idx + 1 == header.length) {
                 return [headerLine.indexOf(val), 100000];
             } else {
-                return [headerLine.indexOf(val),
-                    headerLine.indexOf(nextval)];
+                return [headerLine.indexOf(val), headerLine.indexOf(nextval)];
             }
         });
         //console.log('header:', header, 'startEnds', headerStartEnds);
@@ -345,7 +357,6 @@ function parseOutputUsingHeader(stdout, opts) {
     return entries;
 }
 
-
 module.exports = {
     constants: constants,
     done: done,
diff --git a/test/lib/vm.js b/test/lib/vm.js
index 7913612..38d7420 100644
--- a/test/lib/vm.js
+++ b/test/lib/vm.js
@@ -18,16 +18,12 @@ var format = require('util').format;
 var common = require('./common');
 var h = require('../integration/helpers');
 
-
 // --- Globals
 
-
 var VMAPI;
 
-
 // --- Exports
 
-
 /**
  * Get a VM from VMAPI
  */
@@ -37,7 +33,7 @@ function getVm(t, opts, callback) {
     assert.string(opts.id, 'opts.id');
 
     // XXX: pass in x-request-id here
-    VMAPI.getVm({ uuid: h.dockerIdToUuid(opts.id) }, function (err, obj) {
+    VMAPI.getVm({uuid: h.dockerIdToUuid(opts.id)}, function(err, obj) {
         t.ifErr(err, 'getVm error');
 
         // XXX: allow opts.expectedErr
@@ -52,7 +48,6 @@ function getVm(t, opts, callback) {
     });
 }
 
-
 /**
  * UpdateVm (https://mo.joyent.com/docs/vmapi/master/#UpdateVm)
  */
@@ -62,20 +57,22 @@ function updateVm(t, opts, callback) {
     assert.string(opts.id, 'opts.id');
     assert.object(opts.payload, 'opts.payload');
 
-    VMAPI.updateVm({uuid: h.dockerIdToUuid(opts.id), payload: opts.payload},
-            function (err, obj) {
-        t.ifErr(err, 'updateVm error');
+    VMAPI.updateVm(
+        {uuid: h.dockerIdToUuid(opts.id), payload: opts.payload},
+        function(err, obj) {
+            t.ifErr(err, 'updateVm error');
 
-        // XXX: allow opts.expectedErr
-        if (err) {
-            common.done(t, callback, err);
-            return;
-        }
+            // XXX: allow opts.expectedErr
+            if (err) {
+                common.done(t, callback, err);
+                return;
+            }
 
-        common.partialExp(t, opts, obj);
-        common.expected(t, opts, obj);
-        common.done(t, callback, err, obj);
-    });
+            common.partialExp(t, opts, obj);
+            common.expected(t, opts, obj);
+            common.done(t, callback, err, obj);
+        }
+    );
 }
 
 /**
@@ -88,22 +85,25 @@ function addTags(t, opts, callback) {
     assert.string(opts.id, 'opts.id');
     assert.object(opts.tags, 'opts.tags');
 
-    VMAPI.addMetadata('tags', {
-        uuid: h.dockerIdToUuid(opts.id),
-        metadata: opts.tags
-    }, function (err, obj) {
-        t.ifErr(err, 'addTags error');
-        if (err) {
-            common.done(t, callback, err);
-            return;
+    VMAPI.addMetadata(
+        'tags',
+        {
+            uuid: h.dockerIdToUuid(opts.id),
+            metadata: opts.tags
+        },
+        function(err, obj) {
+            t.ifErr(err, 'addTags error');
+            if (err) {
+                common.done(t, callback, err);
+                return;
+            }
+            common.partialExp(t, opts, obj);
+            common.expected(t, opts, obj);
+            common.done(t, callback, err, obj);
         }
-        common.partialExp(t, opts, obj);
-        common.expected(t, opts, obj);
-        common.done(t, callback, err, obj);
-    });
+    );
 }
 
-
 /*
  * Wait for given tag values to be applied to a VM (from an earlier
  * `addTags` call).
@@ -122,7 +122,7 @@ function addTags(t, opts, callback) {
 function waitForTagUpdate(t, opts, callback) {
     assert.object(t, 't');
     assert.object(opts, 'opts');
-    assert.string(opts.id, 'opts.id');  // the docker container id
+    assert.string(opts.id, 'opts.id'); // the docker container id
     assert.object(opts.tags, 'opts.tags');
     assert.optionalNumber(opts.timeout, 'opts.timeout');
     var timeout = opts.hasOwnProperty('timeout') ? opts.timeout : Infinity;
@@ -132,8 +132,8 @@ function waitForTagUpdate(t, opts, callback) {
     var uuid = h.dockerIdToUuid(opts.id);
     var startTime = Date.now();
 
-    var poll = function () {
-        VMAPI.getVm({uuid: uuid}, function (err, obj) {
+    var poll = function() {
+        VMAPI.getVm({uuid: uuid}, function(err, obj) {
             t.ifErr(err, 'waitForTagUpdate: poll getVm ' + uuid);
             if (err) {
                 common.done(t, callback, err);
@@ -156,9 +156,14 @@ function waitForTagUpdate(t, opts, callback) {
             } else {
                 var elapsedTime = Date.now() - startTime;
                 if (elapsedTime > timeout) {
-                    var timeoutErr = new Error(format('timeout waiting '
-                        + 'for tag changes on container %s (elapsed %ds)',
-                        opts.id, Math.round(elapsedTime / 1000)));
+                    var timeoutErr = new Error(
+                        format(
+                            'timeout waiting ' +
+                                'for tag changes on container %s (elapsed %ds)',
+                            opts.id,
+                            Math.round(elapsedTime / 1000)
+                        )
+                    );
                     t.ifErr(timeoutErr);
                     common.done(t, callback, timeoutErr);
                 } else {
@@ -171,12 +176,11 @@ function waitForTagUpdate(t, opts, callback) {
     setImmediate(poll);
 }
 
-
 /**
  * Initialize the VMAPI client
  */
 function vmapiInit(t) {
-    h.createVmapiClient(function (err, client) {
+    h.createVmapiClient(function(err, client) {
         t.error(err, 'vmapi client err');
         VMAPI = client;
         t.end();
@@ -184,7 +188,6 @@ function vmapiInit(t) {
     });
 }
 
-
 module.exports = {
     init: vmapiInit,
     get: getVm,
diff --git a/test/unit/affinity.test.js b/test/unit/affinity.test.js
index 28c1662..5252e83 100644
--- a/test/unit/affinity.test.js
+++ b/test/unit/affinity.test.js
@@ -21,7 +21,6 @@ var test = require('tape');
 var localityFromContainer = require('../../lib/backends/sdc/affinity')
     .localityFromContainer;
 
-
 // ---- globals
 
 var log = bunyan.createLogger({
@@ -33,7 +32,6 @@ var log = bunyan.createLogger({
 var ABE = 'abe00000-bad2-f64d-ae99-986b4fca0308';
 var BOB = 'b0b00000-bfe9-d94d-8874-7b56aea62a6c';
 
-
 /*
  * ---- Mock VMAPI client
  *
@@ -47,7 +45,7 @@ function _vmDottedLookup(obj, lookup) {
     for (var i = 0; i < parts.length; i++) {
         var part = parts[i];
         if (part === 'tag') {
-            part = 'tags';  // VMAPI "?tag.foo=bar" looks up "tags.foo".
+            part = 'tags'; // VMAPI "?tag.foo=bar" looks up "tags.foo".
         }
         s.push(part);
         if (!o.hasOwnProperty(part)) {
@@ -79,7 +77,7 @@ function _evalPred(pred, vm) {
             var re = new RegExp('^' + q.replace(/\*/g, '.*') + '$');
             return Boolean(re.test(val));
         } else {
-            return (val === q);
+            return val === q;
         }
     } else {
         throw new Error(format('unknown predicate op: %j', pred));
@@ -97,8 +95,9 @@ MockVMAPI.prototype.getVm = function getVm(query, options, cb) {
     var vms = this.vms;
 
     if (query.owner_uuid) {
-        vms = vms.filter(
-            function (vm) { return vm.owner_uuid === query.owner_uuid; });
+        vms = vms.filter(function(vm) {
+            return vm.owner_uuid === query.owner_uuid;
+        });
     }
 
     var hit;
@@ -112,7 +111,7 @@ MockVMAPI.prototype.getVm = function getVm(query, options, cb) {
     if (hit && query.fields) {
         var fields = query.fields.split(',');
         var newHit = {};
-        fields.forEach(function (field) {
+        fields.forEach(function(field) {
             newHit[field] = hit[field];
         });
         hit = newHit;
@@ -132,7 +131,6 @@ MockVMAPI.prototype.getVm = function getVm(query, options, cb) {
     }
 };
 
-
 MockVMAPI.prototype.listVms = function listVms(query, options, cb) {
     assert.equal(options.headers['x-request-id'], log.fields.req_id);
 
@@ -145,8 +143,9 @@ MockVMAPI.prototype.listVms = function listVms(query, options, cb) {
 
     assert.optionalUuid(query.owner_uuid, 'query.owner_uuid');
     if (query.owner_uuid) {
-        vms = vms.filter(
-            function (vm_) { return vm_.owner_uuid === query.owner_uuid; });
+        vms = vms.filter(function(vm_) {
+            return vm_.owner_uuid === query.owner_uuid;
+        });
     }
 
     assert.optionalString(query.state, 'query.state');
@@ -191,8 +190,10 @@ MockVMAPI.prototype.listVms = function listVms(query, options, cb) {
                     for (var j = 0; j < pred.or.length; j++) {
                         var subpred = pred.or[j];
                         isMatch = _evalPred(subpred, vm);
-                        log.trace({isMatch: isMatch, vm: vm, pred: subpred},
-                            '_evalPred');
+                        log.trace(
+                            {isMatch: isMatch, vm: vm, pred: subpred},
+                            '_evalPred'
+                        );
                         if (isMatch) {
                             hits.push(vm);
                             break;
@@ -203,15 +204,18 @@ MockVMAPI.prototype.listVms = function listVms(query, options, cb) {
                 for (i = 0; i < vms.length; i++) {
                     vm = vms[i];
                     isMatch = _evalPred(pred, vm);
-                    log.trace({isMatch: isMatch, vm: vm, pred: pred},
-                        '_evalPred');
+                    log.trace(
+                        {isMatch: isMatch, vm: vm, pred: pred},
+                        '_evalPred'
+                    );
                     if (isMatch) {
                         hits.push(vm);
                     }
                 }
             } else {
-                throw new Error(format('unexpected listVms predicate: %j',
-                    pred));
+                throw new Error(
+                    format('unexpected listVms predicate: %j', pred)
+                );
             }
         } catch (err) {
             cb(err);
@@ -223,9 +227,9 @@ MockVMAPI.prototype.listVms = function listVms(query, options, cb) {
 
     if (query.fields) {
         var fields = query.fields.split(',');
-        vms = vms.map(function (hit) {
+        vms = vms.map(function(hit) {
             var reducedVm = {};
-            fields.forEach(function (field) {
+            fields.forEach(function(field) {
                 reducedVm[field] = hit[field];
             });
             return reducedVm;
@@ -236,50 +240,46 @@ MockVMAPI.prototype.listVms = function listVms(query, options, cb) {
     cb(null, vms);
 };
 
-
-
 // ---- tests
 
-
-test('affinity', function (tt) {
-
+test('affinity', function(tt) {
     var vmapi = new MockVMAPI([
         // Owned by Abe:
         {
-            'uuid': 'cafe0000-3943-49d5-851f-afd5e2ed93e5',
-            'alias': 'cafe0',
-            'owner_uuid': ABE,
-            'tags': {}
+            uuid: 'cafe0000-3943-49d5-851f-afd5e2ed93e5',
+            alias: 'cafe0',
+            owner_uuid: ABE,
+            tags: {}
         },
         {
-            'uuid': 'db000000-b5eb-4e92-a542-93d4ca011294',
-            'alias': 'db0',
-            'owner_uuid': ABE,
-            'tags': {
-                'role': 'database',
-                'shard': 'shard-a',
-                'primary': true
+            uuid: 'db000000-b5eb-4e92-a542-93d4ca011294',
+            alias: 'db0',
+            owner_uuid: ABE,
+            tags: {
+                role: 'database',
+                shard: 'shard-a',
+                primary: true
             }
         },
         {
-            'uuid': 'db000001-1e4b-4fbd-9763-0492e32e7d07',
-            'alias': 'db1',
-            'owner_uuid': ABE,
-            'tags': {
-                'role': 'database',
-                'shard': 'shard-b'
+            uuid: 'db000001-1e4b-4fbd-9763-0492e32e7d07',
+            alias: 'db1',
+            owner_uuid: ABE,
+            tags: {
+                role: 'database',
+                shard: 'shard-b'
             }
         },
         {
-            'uuid': 'beef0000-f7d7-4721-9833-66700c5c280d',
-            'alias': 'beef0',
-            'owner_uuid': ABE,
-            'docker': true,
-            'tags': {
-                'sdc_docker': true,
+            uuid: 'beef0000-f7d7-4721-9833-66700c5c280d',
+            alias: 'beef0',
+            owner_uuid: ABE,
+            docker: true,
+            tags: {
+                sdc_docker: true,
                 'docker:label:role': 'cattle'
             },
-            'internal_metadata': {
+            internal_metadata: {
                 // JSSTYLED
                 'docker:id': 'beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6af74'
             }
@@ -287,13 +287,13 @@ test('affinity', function (tt) {
 
         // Owned by bob: b0b00000-bfe9-d94d-8874-7b56aea62a6c
         {
-            'uuid': 'db000000-b5eb-4e92-a542-93d4ca011294',
-            'alias': 'db0',
-            'owner_uuid': BOB,
-            'tags': {
-                'role': 'database',
-                'shard': 'shard-a',
-                'primary': true
+            uuid: 'db000000-b5eb-4e92-a542-93d4ca011294',
+            alias: 'db0',
+            owner_uuid: BOB,
+            tags: {
+                role: 'database',
+                shard: 'shard-a',
+                primary: true
             }
         }
     ]);
@@ -511,13 +511,12 @@ test('affinity', function (tt) {
             },
             locality: {
                 strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294'
-                ]
+                near: ['db000000-b5eb-4e92-a542-93d4ca011294']
             },
             modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(
-                ['container==db000000-b5eb-4e92-a542-93d4ca011294'])
+            modifiedAffinitiesLabel: JSON.stringify([
+                'container==db000000-b5eb-4e92-a542-93d4ca011294'
+            ])
         },
         {
             name: 'container==beef0000f7d7...c6af74 (64-char docker id)',
@@ -531,14 +530,15 @@ test('affinity', function (tt) {
             },
             locality: {
                 strict: true,
-                near: [
-                    'beef0000-f7d7-4721-9833-66700c5c280d'
-                ]
+                near: ['beef0000-f7d7-4721-9833-66700c5c280d']
             },
             modifiedEnv: [],
             modifiedAffinitiesLabel: JSON.stringify(
                 // JSSTYLED
-                ['container==beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6af74'])
+                [
+                    'container==beef0000f7d74721983366700c5c280d57f1c9bc623f454ba99d492ac2c6af74'
+                ]
+            )
         },
         {
             // JSSTYLED
@@ -562,34 +562,25 @@ test('affinity', function (tt) {
             ownerUuid: ABE,
             container: {
                 Labels: {},
-                Env: [
-                    'affinity:container==beef0000f7d7'
-                ]
+                Env: ['affinity:container==beef0000f7d7']
             },
             locality: {
                 strict: true,
-                near: [
-                    'beef0000-f7d7-4721-9833-66700c5c280d'
-                ]
+                near: ['beef0000-f7d7-4721-9833-66700c5c280d']
             },
             modifiedEnv: [],
-            modifiedAffinitiesLabel: JSON.stringify(
-                ['container==beef0000f7d7'])
+            modifiedAffinitiesLabel: JSON.stringify(['container==beef0000f7d7'])
         },
         {
             name: 'container==db0 (name)',
             ownerUuid: ABE,
             container: {
                 Labels: {},
-                Env: [
-                    'affinity:container==db0'
-                ]
+                Env: ['affinity:container==db0']
             },
             locality: {
                 strict: true,
-                near: [
-                    'db000000-b5eb-4e92-a542-93d4ca011294'
-                ]
+                near: ['db000000-b5eb-4e92-a542-93d4ca011294']
             },
             modifiedEnv: [],
             modifiedAffinitiesLabel: JSON.stringify(['container==db0'])
@@ -599,9 +590,7 @@ test('affinity', function (tt) {
             ownerUuid: ABE,
             container: {
                 Labels: {},
-                Env: [
-                    'affinity:container==DB0'
-                ]
+                Env: ['affinity:container==DB0']
             },
             err: {
                 // JSSTYLED
@@ -614,9 +603,7 @@ test('affinity', function (tt) {
             ownerUuid: ABE,
             container: {
                 Labels: {},
-                Env: [
-                    'affinity:container==db*'
-                ]
+                Env: ['affinity:container==db*']
             },
             locality: {
                 strict: true,
@@ -633,9 +620,7 @@ test('affinity', function (tt) {
             ownerUuid: ABE,
             container: {
                 Labels: {},
-                Env: [
-                    'affinity:container==DB*'
-                ]
+                Env: ['affinity:container==DB*']
             },
             err: {
                 // JSSTYLED
@@ -648,9 +633,7 @@ test('affinity', function (tt) {
             ownerUuid: ABE,
             container: {
                 Labels: {},
-                Env: [
-                    'affinity:container==/^db/'
-                ]
+                Env: ['affinity:container==/^db/']
             },
             locality: {
                 strict: true,
@@ -667,9 +650,7 @@ test('affinity', function (tt) {
             ownerUuid: ABE,
             container: {
                 Labels: {},
-                Env: [
-                    'affinity:container==/^DB/'
-                ]
+                Env: ['affinity:container==/^DB/']
             },
             err: {
                 // JSSTYLED
@@ -682,9 +663,7 @@ test('affinity', function (tt) {
             ownerUuid: ABE,
             container: {
                 Labels: {},
-                Env: [
-                    'affinity:container==/(?i)^DB/'
-                ]
+                Env: ['affinity:container==/(?i)^DB/']
             },
             locality: {
                 strict: true,
@@ -698,47 +677,64 @@ test('affinity', function (tt) {
         }
     ];
 
-    cases.forEach(function (c) {
+    cases.forEach(function(c) {
         if (process.env.FILTER && c.name.indexOf(process.env.FILTER) === -1) {
             tt.skip('  ' + c.name + ' (FILTER=' + process.env.FILTER + ')');
             return;
         }
 
-        tt.test('  ' + c.name, function (t) {
-            localityFromContainer({
-                log: log,
-                vmapi: vmapi,
-                ownerUuid: c.ownerUuid,
-                container: c.container
-            }, function (err, locality) {
-                if (c.err) {
-                    t.ok(err, 'err calling localityFromContainer');
-                    if (c.err.messageRe) {
-                        t.ok(c.err.messageRe.test(err.message), format(
-                            'err.message matches %s: %j', c.err.messageRe,
-                            err.message));
+        tt.test('  ' + c.name, function(t) {
+            localityFromContainer(
+                {
+                    log: log,
+                    vmapi: vmapi,
+                    ownerUuid: c.ownerUuid,
+                    container: c.container
+                },
+                function(err, locality) {
+                    if (c.err) {
+                        t.ok(err, 'err calling localityFromContainer');
+                        if (c.err.messageRe) {
+                            t.ok(
+                                c.err.messageRe.test(err.message),
+                                format(
+                                    'err.message matches %s: %j',
+                                    c.err.messageRe,
+                                    err.message
+                                )
+                            );
+                        }
+                        if (c.err.restCode) {
+                            t.equal(
+                                err.restCode,
+                                c.err.restCode,
+                                'err.restCode'
+                            );
+                        }
+                    } else {
+                        t.ifErr(err, 'no err calling localityFromContainer');
                     }
-                    if (c.err.restCode) {
-                        t.equal(err.restCode, c.err.restCode, 'err.restCode');
+                    if (c.hasOwnProperty('locality')) {
+                        t.deepEqual(locality, c.locality, 'locality');
                     }
-                } else {
-                    t.ifErr(err, 'no err calling localityFromContainer');
-                }
-                if (c.hasOwnProperty('locality')) {
-                    t.deepEqual(locality, c.locality, 'locality');
-                }
-                if (c.modifiedEnv) {
-                    t.deepEqual(c.container.Env, c.modifiedEnv,
-                        'modified container.Env');
-                }
-                if (c.modifiedAffinitiesLabel) {
-                    t.equal(c.container.Labels['com.docker.swarm.affinities'],
-                        c.modifiedAffinitiesLabel,
-                        // JSSTYLED
-                        'modified container.Labels["com.docker.swarm.affinities"]');
+                    if (c.modifiedEnv) {
+                        t.deepEqual(
+                            c.container.Env,
+                            c.modifiedEnv,
+                            'modified container.Env'
+                        );
+                    }
+                    if (c.modifiedAffinitiesLabel) {
+                        t.equal(
+                            c.container.Labels['com.docker.swarm.affinities'],
+                            c.modifiedAffinitiesLabel,
+                            // JSSTYLED
+                            'modified container.Labels["com.docker.swarm.affinities"]'
+                        );
+                    }
+                    t.end();
                 }
-                t.end();
-            });
+            );
         });
     });
 });
diff --git a/test/unit/common.test.js b/test/unit/common.test.js
index 2cee3da..04e4dbb 100644
--- a/test/unit/common.test.js
+++ b/test/unit/common.test.js
@@ -16,11 +16,9 @@ var common = require('../../lib/common');
 var sprintf = require('sprintf').sprintf;
 var test = require('tape');
 
-
-
 // --- Tests
 
-test('humanDuration', function (t) {
+test('humanDuration', function(t) {
     var humanDuration = common.humanDuration;
     var second = 1;
     var minute = 60;
@@ -30,42 +28,41 @@ test('humanDuration', function (t) {
     var month = day * 30;
     var year = day * 365;
 
-    t.equal(humanDuration(47*second), '47 seconds');
-    t.equal(humanDuration(1*minute), 'About a minute');
-    t.equal(humanDuration(3*minute), '3 minutes');
-    t.equal(humanDuration(35*minute), '35 minutes');
-    t.equal(humanDuration(35*minute + 40*second), '35 minutes');
-    t.equal(humanDuration(1*hour), 'About an hour');
-    t.equal(humanDuration(1*hour + 45*minute), 'About an hour');
-    t.equal(humanDuration(3*hour), '3 hours');
-    t.equal(humanDuration(3*hour + 59*minute), '3 hours');
-    t.equal(humanDuration(3*hour + 60*minute), '4 hours');
-    t.equal(humanDuration(24*hour), '24 hours');
-    t.equal(humanDuration(1*day + 12*hour), '36 hours');
-    t.equal(humanDuration(2*day), '2 days');
-    t.equal(humanDuration(7*day), '7 days');
-    t.equal(humanDuration(13*day + 5*hour), '13 days');
-    t.equal(humanDuration(2*week), '2 weeks');
-    t.equal(humanDuration(2*week + 4*day), '2 weeks');
-    t.equal(humanDuration(3*week), '3 weeks');
-    t.equal(humanDuration(4*week), '4 weeks');
-    t.equal(humanDuration(4*week + 3*day), '4 weeks');
-    t.equal(humanDuration(1*month), '4 weeks');
-    t.equal(humanDuration(1*month + 2*week), '6 weeks');
-    t.equal(humanDuration(2*month), '8 weeks');
-    t.equal(humanDuration(3*month + 1*week), '3 months');
-    t.equal(humanDuration(5*month + 2*week), '5 months');
-    t.equal(humanDuration(13*month), '13 months');
-    t.equal(humanDuration(23*month), '23 months');
-    t.equal(humanDuration(24*month), '24 months');
-    t.equal(humanDuration(24*month + 2*week), '2.010959 years');
-    t.equal(humanDuration(3*year + 2*month), '3.164384 years');
+    t.equal(humanDuration(47 * second), '47 seconds');
+    t.equal(humanDuration(1 * minute), 'About a minute');
+    t.equal(humanDuration(3 * minute), '3 minutes');
+    t.equal(humanDuration(35 * minute), '35 minutes');
+    t.equal(humanDuration(35 * minute + 40 * second), '35 minutes');
+    t.equal(humanDuration(1 * hour), 'About an hour');
+    t.equal(humanDuration(1 * hour + 45 * minute), 'About an hour');
+    t.equal(humanDuration(3 * hour), '3 hours');
+    t.equal(humanDuration(3 * hour + 59 * minute), '3 hours');
+    t.equal(humanDuration(3 * hour + 60 * minute), '4 hours');
+    t.equal(humanDuration(24 * hour), '24 hours');
+    t.equal(humanDuration(1 * day + 12 * hour), '36 hours');
+    t.equal(humanDuration(2 * day), '2 days');
+    t.equal(humanDuration(7 * day), '7 days');
+    t.equal(humanDuration(13 * day + 5 * hour), '13 days');
+    t.equal(humanDuration(2 * week), '2 weeks');
+    t.equal(humanDuration(2 * week + 4 * day), '2 weeks');
+    t.equal(humanDuration(3 * week), '3 weeks');
+    t.equal(humanDuration(4 * week), '4 weeks');
+    t.equal(humanDuration(4 * week + 3 * day), '4 weeks');
+    t.equal(humanDuration(1 * month), '4 weeks');
+    t.equal(humanDuration(1 * month + 2 * week), '6 weeks');
+    t.equal(humanDuration(2 * month), '8 weeks');
+    t.equal(humanDuration(3 * month + 1 * week), '3 months');
+    t.equal(humanDuration(5 * month + 2 * week), '5 months');
+    t.equal(humanDuration(13 * month), '13 months');
+    t.equal(humanDuration(23 * month), '23 months');
+    t.equal(humanDuration(24 * month), '24 months');
+    t.equal(humanDuration(24 * month + 2 * week), '2.010959 years');
+    t.equal(humanDuration(3 * year + 2 * month), '3.164384 years');
 
     t.end();
 });
 
-
-test('boolFromQueryParam', function (t) {
+test('boolFromQueryParam', function(t) {
     var boolFromQueryParam = common.boolFromQueryParam;
 
     t.equal(boolFromQueryParam(undefined), false);
@@ -93,8 +90,7 @@ test('boolFromQueryParam', function (t) {
     t.end();
 });
 
-
-test('apiVersionCmp', function (t) {
+test('apiVersionCmp', function(t) {
     var apiVersionCmp = common.apiVersionCmp;
 
     t.equal(apiVersionCmp('1.22', 1.22), 0, '"1.22" == 1.22');
@@ -106,24 +102,48 @@ test('apiVersionCmp', function (t) {
     t.equal(apiVersionCmp(1, 2), -1, '1 < 2');
     t.equal(apiVersionCmp(2, '2.0'), 0, '2 == "2.0"');
     t.equal(apiVersionCmp(2, '1.0'), 1, '2 > "1.0"');
-    t.throws(function () {
-        apiVersionCmp(-42, 42);
-    }, /a must match/, 'negative numbers throw');
-    t.throws(function () {
-        apiVersionCmp(undefined, 1.22);
-    }, /a \(string\) is required/, 'undefined throws');
-    t.throws(function () {
-        apiVersionCmp(null, 1.22);
-    }, /a \(string\) is required/, 'null throws');
-    t.throws(function () {
-        apiVersionCmp({hello: 'world'}, 1.22);
-    }, /a \(string\) is required/, 'object throws');
-    t.throws(function () {
-        apiVersionCmp({}, 1.22);
-    }, /a \(string\) is required/, 'empty object throws');
-    t.throws(function () {
-        apiVersionCmp([], 1.22);
-    }, /a \(string\) is required/, 'empty array throws');
+    t.throws(
+        function() {
+            apiVersionCmp(-42, 42);
+        },
+        /a must match/,
+        'negative numbers throw'
+    );
+    t.throws(
+        function() {
+            apiVersionCmp(undefined, 1.22);
+        },
+        /a \(string\) is required/,
+        'undefined throws'
+    );
+    t.throws(
+        function() {
+            apiVersionCmp(null, 1.22);
+        },
+        /a \(string\) is required/,
+        'null throws'
+    );
+    t.throws(
+        function() {
+            apiVersionCmp({hello: 'world'}, 1.22);
+        },
+        /a \(string\) is required/,
+        'object throws'
+    );
+    t.throws(
+        function() {
+            apiVersionCmp({}, 1.22);
+        },
+        /a \(string\) is required/,
+        'empty object throws'
+    );
+    t.throws(
+        function() {
+            apiVersionCmp([], 1.22);
+        },
+        /a \(string\) is required/,
+        'empty array throws'
+    );
 
     t.end();
 });
diff --git a/test/unit/helpers.js b/test/unit/helpers.js
index af73f46..f4ad532 100644
--- a/test/unit/helpers.js
+++ b/test/unit/helpers.js
@@ -14,8 +14,6 @@
 
 var common = require('../lib/common');
 
-
-
 // --- Exports
 
 module.exports = {
diff --git a/test/unit/ports.test.js b/test/unit/ports.test.js
index 630442e..988397c 100644
--- a/test/unit/ports.test.js
+++ b/test/unit/ports.test.js
@@ -40,13 +40,12 @@ function mkRangeArray(start, end) {
     var length = end - start + 1;
     var arr = new Array(length);
     var i, val;
-    for (i = 0, val = start; i < length; i++, val++) {
+    for ((i = 0), (val = start); i < length; i++, val++) {
         arr[i] = val;
     }
     return arr;
 }
 
-
 /*
  * A note about these tests: they were initially written for a more complex
  * implementation of compressPorts, so some of them exercise edge cases that
@@ -57,58 +56,64 @@ function mkRangeArray(start, end) {
 [
     {
         name: 'A single range in increasing order',
-        input: [ 1, 2, 3, 4, 5, 6, 7, 8 ],
-        result: [ { start: 1, end: 8 } ]
+        input: [1, 2, 3, 4, 5, 6, 7, 8],
+        result: [{start: 1, end: 8}]
     },
     {
         name: 'A range and two isolated numbers before and after the range',
-        input: [ 1, 3, 4, 5, 6, 8 ],
-        result: [ 1, { start: 3, end: 6 }, 8 ]
+        input: [1, 3, 4, 5, 6, 8],
+        result: [1, {start: 3, end: 6}, 8]
     },
     {
         name: 'A range of a numbers and an isolated number after the range ',
         input: [1, 3, 4, 2, 5, 6, 8, 2, 2, 5],
-        result: [ { start: 1, end: 6 }, 8 ]
+        result: [{start: 1, end: 6}, 8]
     },
     {
         name: 'A single element',
-        input: [ 1 ],
-        result: [ 1 ]
+        input: [1],
+        result: [1]
     },
     {
         name: 'Two ranges in a random order with repeated elements',
-        input: [ 1, 3, 4, 2, 5, 6, 8, 2, 2, 5, 3, 3, 9, 1 ],
-        result: [ { start: 1, end: 6 }, { start: 8, end: 9 } ]
+        input: [1, 3, 4, 2, 5, 6, 8, 2, 2, 5, 3, 3, 9, 1],
+        result: [{start: 1, end: 6}, {start: 8, end: 9}]
     },
     {
         name: 'Range with no input elements whose neighbours are one away',
-        input: [ 1, 3, 5, 7, 9, 11, 2, 10, 4, 8, 6, 20 ],
-        result: [ { start: 1, end: 11 }, 20 ]
+        input: [1, 3, 5, 7, 9, 11, 2, 10, 4, 8, 6, 20],
+        result: [{start: 1, end: 11}, 20]
     },
     {
         name: 'Shuffled range',
         input: shuffle(mkRangeArray(20, 400)),
-        result: [ { start: 20, end: 400 } ]
+        result: [{start: 20, end: 400}]
     },
     {
         name: '2 different ranges shuffled',
         input: shuffle(mkRangeArray(20, 400).concat(mkRangeArray(800, 1100))),
-        result: [ { start: 20, end: 400 }, { start: 800, end: 1100 } ]
+        result: [{start: 20, end: 400}, {start: 800, end: 1100}]
     },
     {
         name: '3 different ranges shuffled',
         input: shuffle(base),
-        result: [ { start: 20, end: 400 }, { start: 800, end: 1100 },
-            { start: 5000, end: 5200 } ]
+        result: [
+            {start: 20, end: 400},
+            {start: 800, end: 1100},
+            {start: 5000, end: 5200}
+        ]
     },
     {
         name: '3 ranges repeated 4 times and shuffled',
         input: shuffle(base.concat(base).concat(base).concat(base)),
-        result: [ { start: 20, end: 400 }, { start: 800, end: 1100 },
-            { start: 5000, end: 5200 } ]
+        result: [
+            {start: 20, end: 400},
+            {start: 800, end: 1100},
+            {start: 5000, end: 5200}
+        ]
     }
-].forEach(function (run) {
-    test(run.name, function (t) {
+].forEach(function(run) {
+    test(run.name, function(t) {
         t.deepEquals(compressPorts(run.input), run.result);
         t.end();
     });
-- 
2.21.0

