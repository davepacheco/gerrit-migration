From af7cca338004fc5709f8abc59795423255030127 Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <jwilsdon@joyent.com>
Date: Wed, 31 May 2017 23:02:10 -0700
Subject: [PATCH] VOLAPI-38 CreateVolume endpoint doesn't validate that
 networks passed as input parameter are owned by owner_uuid

---
 lib/endpoints/volumes.js                      |   8 +
 lib/validation/networks.js                    |  70 ++++-
 lib/volapi.js                                 |  19 +-
 test/integration/lib/clients-setup.js         |  35 ++-
 test/integration/lib/resources.js             |  16 +-
 ...-volumes-creation-invalid-networks.test.js | 227 +++++++++++++++
 ...d-volumes-creation-name-generation.test.js |  32 ++-
 test/integration/nfs-shared-volumes.test.js   | 267 ++++++++++++++----
 test/runtest                                  |   6 +-
 test/runtest.common                           |  18 +-
 test/runtests                                 |   6 +-
 11 files changed, 603 insertions(+), 101 deletions(-)
 create mode 100644 test/integration/nfs-shared-volumes-creation-invalid-networks.test.js

diff --git a/lib/endpoints/volumes.js b/lib/endpoints/volumes.js
index 3d480c3..cff4582 100644
--- a/lib/endpoints/volumes.js
+++ b/lib/endpoints/volumes.js
@@ -356,6 +356,14 @@ function createVolume(req, res, next) {
     var context = {};
 
     vasync.pipeline({funcs: [
+        function checkNetworks(ctx, done) {
+            // We've validated that networks is an array, now we need to
+            // validate that all of the elements are valid fabric network uuids
+            // that belong to this user.
+            networksValidation.validateFabricNetworkOwnership(req._napiClient,
+                volumeParams,
+                done);
+        },
         function acquireVolumeTicket(ctx, done) {
             var ticketId = ownerUuid + '-' + volumeName;
 
diff --git a/lib/validation/networks.js b/lib/validation/networks.js
index 259da2c..d80d78f 100644
--- a/lib/validation/networks.js
+++ b/lib/validation/networks.js
@@ -8,6 +8,9 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
 var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
 
 function validateNetwork(networkUuid) {
@@ -22,6 +25,71 @@ function validateNetwork(networkUuid) {
     return err;
 }
 
+function validateFabricNetworkOwnership(napiClient, volumeParams, callback) {
+    assert.object(napiClient, 'napiClient');
+    assert.object(volumeParams, 'volumeParams');
+    assert.arrayOfUuid(volumeParams.networks, 'volumeParams.networks');
+    assert.uuid(volumeParams.owner_uuid, 'volumeParams.owner_uuid');
+    assert.func(callback, 'callback');
+
+    var missing = [];
+    var nonFabric = [];
+    var nonOwned = [];
+
+    vasync.forEachParallel({
+        func: function validateOneNetwork(networkUuid, cb) {
+            napiClient.getNetwork(networkUuid, function onGetNetwork(err, net) {
+                if (!err && net) {
+                    assert.object(net, 'net');
+                    assert.optionalBool(net.fabric, 'net.fabric');
+                    assert.arrayOfUuid(net.owner_uuids, 'net.owner_uuids');
+
+                    if (net.fabric !== true) {
+                        nonFabric.push(networkUuid);
+                    }
+                    if (net.owner_uuids
+                        .indexOf(volumeParams.owner_uuid) === -1) {
+                        nonOwned.push(networkUuid);
+                    }
+                }
+                if (err && err.name === 'ResourceNotFoundError') {
+                    missing.push(networkUuid);
+                    // Swallow this error, since not found is just going to fail
+                    // validation anyway.
+                    err = undefined;
+                }
+                cb(err);
+            });
+        }, inputs: volumeParams.networks
+    }, function onValidated(err) {
+        var newErr = err;
+        var newErrMsgs = [];
+
+        if (!err) {
+            if (missing.length > 0) {
+                newErrMsgs.push('missing networks: ' + JSON.stringify(missing));
+            }
+            if (nonOwned.length > 0) {
+                newErrMsgs.push('non-owned networks: ' +
+                    JSON.stringify(nonOwned));
+            }
+            if (nonFabric.length > 0) {
+                newErrMsgs.push('non-fabric networks: ' +
+                    JSON.stringify(nonFabric));
+            }
+
+            if (newErrMsgs.length > 0) {
+                // use .trim() to remove trailing space
+                newErr = new Error('invalid network(s) specified: ' +
+                    newErrMsgs.join(' '));
+            }
+       }
+
+       callback(newErr);
+    });
+}
+
 module.exports = {
+    validateFabricNetworkOwnership: validateFabricNetworkOwnership,
     validateNetwork: validateNetwork
-};
\ No newline at end of file
+};
diff --git a/lib/volapi.js b/lib/volapi.js
index 71ee296..b0f5582 100644
--- a/lib/volapi.js
+++ b/lib/volapi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var crypto = require('crypto');
@@ -19,6 +19,7 @@ var vasync = require('vasync');
 
 var CnapiClient = require('sdc-clients').CNAPI;
 var ImgapiClient = require('sdc-clients').IMGAPI;
+var NapiClient = require('sdc-clients').NAPI;
 var PapiClient = require('sdc-clients').PAPI;
 var SapiClient = require('sdc-clients').SAPI;
 var VmapiClient = require('sdc-clients').VMAPI;
@@ -79,10 +80,11 @@ function setCommonMiddlewares(config, server, options, callback) {
             res.header('x-server-name', os.hostname());
         });
 
-        req._vmapiClient = options.vmapiClient;
-        req._papiClient = options.papiClient;
-        req._imgapiClient = options.imgapiClient;
         req._cnapiClient = options.cnapiClient;
+        req._imgapiClient = options.imgapiClient;
+        req._napiClient = options.napiClient;
+        req._papiClient = options.papiClient;
+        req._vmapiClient = options.vmapiClient;
 
         next();
     });
@@ -268,11 +270,12 @@ function init(config, log, callback) {
         setupRestifyServer,
         function setupMiddlewares(context, next) {
             return setCommonMiddlewares(config, context.server, {
-                vmapiClient: new VmapiClient(config.vmapi),
-                papiClient: new PapiClient(config.papi),
+                cnapiClient: new CnapiClient(config.cnapi),
                 imgapiClient: imgapiClient,
                 morayClient: morayClient,
-                cnapiClient: new CnapiClient(config.cnapi)
+                napiClient: new NapiClient(config.napi),
+                papiClient: new PapiClient(config.papi),
+                vmapiClient: new VmapiClient(config.vmapi)
             }, next);
         },
         function setupRoutes(context, next) {
@@ -287,4 +290,4 @@ function init(config, log, callback) {
 
 module.exports = {
     init: init
-};
\ No newline at end of file
+};
diff --git a/test/integration/lib/clients-setup.js b/test/integration/lib/clients-setup.js
index 9c5c26c..a168074 100644
--- a/test/integration/lib/clients-setup.js
+++ b/test/integration/lib/clients-setup.js
@@ -5,19 +5,20 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 var Logger = require('bunyan');
 var restify = require('restify');
-var VOLAPI = require('sdc-clients').VOLAPI;
+var IMGAPI = require('sdc-clients').IMGAPI;
 var NAPI = require('sdc-clients').NAPI;
+var PAPI = require('sdc-clients').PAPI;
 var VMAPI = require('sdc-clients').VMAPI;
+var VOLAPI = require('sdc-clients').VOLAPI;
 
 var configLoader = require('../../../lib/config-loader');
 var CONFIG = configLoader.loadConfigSync();
-
 var VOLAPI_URL = process.env.VOLAPI_URL || 'http://localhost';
 
 function getApiClients(callback) {
@@ -34,11 +35,8 @@ function getApiClients(callback) {
         }
     });
 
-    var volapiClient = new VOLAPI({
-        url: VOLAPI_URL,
-        version: '^1',
-        userAgent: 'sdc-volapi-integration-tests',
-        log: logger,
+    var imgapiClient = new IMGAPI({
+        url: CONFIG.imgapi.url,
         agent: false
     });
 
@@ -47,18 +45,33 @@ function getApiClients(callback) {
         agent: false
     });
 
+    var papiClient = new PAPI({
+        url: CONFIG.papi.url,
+        agent: false
+    });
+
     var vmapiClient = new VMAPI({
         url: CONFIG.vmapi.url,
         agent: false
     });
 
+    var volapiClient = new VOLAPI({
+        url: VOLAPI_URL,
+        version: '^1',
+        userAgent: 'sdc-volapi-integration-tests',
+        log: logger,
+        agent: false
+    });
+
     callback(null, {
-        volapi: volapiClient,
+        imgapi: imgapiClient,
         napi: napiClient,
-        vmapi: vmapiClient
+        papi: papiClient,
+        vmapi: vmapiClient,
+        volapi: volapiClient
     });
 }
 
 module.exports = {
     getApiClients: getApiClients
-};
\ No newline at end of file
+};
diff --git a/test/integration/lib/resources.js b/test/integration/lib/resources.js
index f03f82f..cf93685 100644
--- a/test/integration/lib/resources.js
+++ b/test/integration/lib/resources.js
@@ -5,18 +5,26 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 var libuuid = require('libuuid');
 
-function makeResourceName(prefix) {
+function makeResourceName(prefix, uuid) {
     assert.string(prefix, 'prefix');
 
-    return [prefix, libuuid.create().split('-')[0]].join('-');
+    var shortId;
+
+    if (uuid) {
+        shortId = uuid.split('-')[0];
+    } else {
+        shortId = libuuid.create().split('-')[0];
+    }
+
+    return [prefix, shortId].join('-');
 }
 
 module.exports = {
     makeResourceName: makeResourceName
-};
\ No newline at end of file
+};
diff --git a/test/integration/nfs-shared-volumes-creation-invalid-networks.test.js b/test/integration/nfs-shared-volumes-creation-invalid-networks.test.js
new file mode 100644
index 0000000..3dcfc79
--- /dev/null
+++ b/test/integration/nfs-shared-volumes-creation-invalid-networks.test.js
@@ -0,0 +1,227 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var libuuid = require('libuuid');
+var test = require('tape');
+var vasync = require('vasync');
+
+var clientsSetup = require('./lib/clients-setup');
+var configLoader = require('../../lib/config-loader');
+
+var CONFIG = configLoader.loadConfigSync();
+
+var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
+assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
+
+var CLIENTS;
+var NETWORKS = {
+    nonOwned: {
+        name: 'volapi-test-invalid-1',
+        fabric: true,
+        vlan_id: 100,
+        subnet: '10.100.0.0/24',
+        provision_start_ip: '10.100.0.5',
+        provision_end_ip: '10.100.0.250',
+        nic_tag: 'volapi_test_invalid',
+        owner_uuids: [libuuid.create()],
+        gateway: '10.100.0.1'
+    }, nonFabric: {
+        name: 'volapi-test-invalid-2',
+        vlan_id: 101,
+        subnet: '10.101.0.0/24',
+        provision_start_ip: '10.101.0.5',
+        provision_end_ip: '10.101.0.250',
+        nic_tag: 'volapi_test_invalid',
+        owner_uuids: [UFDS_ADMIN_UUID],
+        gateway: '10.101.0.1'
+    }
+};
+var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
+
+function cleanupPreviouslyCreatedTestNapiObjects(tt, okNoExist) {
+
+    if (okNoExist) {
+        // we assume when it's ok if the networks don't exist, that the NETWORKS
+        // object won't yet have the uuids. So we grab them here.
+        tt.test('find previous NAPI network objects', function (t) {
+            vasync.forEachParallel({
+                func: function getPreviousTestNetworks(netKey, cb) {
+                    var net = NETWORKS[netKey];
+
+                    CLIENTS.napi.listNetworks({
+                        name: net.name
+                    }, {}, function onListNetworks(err, foundNet) {
+                        if (foundNet && foundNet[0] && foundNet[0].uuid) {
+                            net.uuid = foundNet[0].uuid;
+                        }
+                        cb();
+                    });
+                }, inputs: Object.keys(NETWORKS)
+            }, function afterCleanup(err) {
+                t.ifError(err, 'should have succeeded to get networks');
+                t.end();
+            });
+        });
+    }
+
+    tt.test('remove networks', function removePreviousTestNetworks(t) {
+        vasync.forEachParallel({
+            func: function removeNetwork(netKey, cb) {
+                var net = NETWORKS[netKey];
+
+                if (okNoExist && !net.uuid) {
+                    cb();
+                    return;
+                }
+
+                CLIENTS.napi.deleteNetwork(net.uuid, {}, {},
+                    function onDeleteNetwork(err) {
+                        t.ifError(err, 'DeleteNetwork should succeed: ' +
+                            net.uuid);
+                        cb();
+                    });
+            }, inputs: Object.keys(NETWORKS)
+        }, function afterRemovingNetworks(err) {
+            if (!okNoExist) {
+                t.ifError(err, 'should have succeeded to delete networks');
+            }
+            t.end();
+        });
+    });
+
+    tt.test('remove nic tag', function removeInvalidTestNicTag(t) {
+        CLIENTS.napi.deleteNicTag('volapi_test_invalid', {}, {},
+            function deleteNicTag(err) {
+                if (!okNoExist) {
+                    t.ifError(err, 'expected to have deleted nic tag');
+                }
+                t.end();
+            });
+    });
+}
+
+function expectedError(t, actualErrMsg, expectedErrMsg, testMsg) {
+    var matches;
+
+    // Make a RegExp from the expectedErr but we need to escape the
+    // '(' and ')' characters to '\(' and '\)' so that the regex
+    // will not treat that as a grouping.
+    var re = new RegExp(expectedErrMsg.replace(/[()]/g, '\\$&'));
+
+    matches = actualErrMsg.match(re);
+
+    // with this, we get the actual error message if it fails
+    t.equal((matches ? matches[0] : actualErrMsg), expectedErrMsg, testMsg);
+}
+
+
+test('setup', function (tt) {
+    tt.test('setup clients', function (t) {
+        clientsSetup.getApiClients(function onClientsSetup(err, clients) {
+            CLIENTS = clients;
+            t.end();
+        });
+    });
+
+    tt.test('cleanup NAPI network objects', function (t) {
+        // cleanup from previous runs
+        cleanupPreviouslyCreatedTestNapiObjects(t, true);
+    });
+
+    tt.test('create nic tag', function (t) {
+        CLIENTS.napi.createNicTag('volapi_test_invalid', {}, {},
+            function createNicTag(err) {
+                t.ifError(err, 'expected to have created a nic tag');
+                t.end();
+            });
+    });
+
+    tt.test('create invalid networks', function (t) {
+        vasync.forEachParallel({
+            func: function createInvalidNetwork(netKey, cb) {
+                var net = NETWORKS[netKey];
+
+                CLIENTS.napi.createNetwork(net, {},
+                    function onCreateNetwork(err, network) {
+                        t.ifError(err, 'CreateNetwork should succeed');
+                        t.ok((network && network.uuid), 'expected network ' +
+                            'uuid got: ' + ((network && network.uuid) ?
+                                network.uuid : 'undefined'));
+                        if (network && network.uuid) {
+                            net.uuid = network.uuid;
+                        }
+                        cb();
+                    });
+            }, inputs: Object.keys(NETWORKS)
+        }, function (err) {
+            t.ifError(err, 'should have succeeded');
+            t.end();
+        });
+    });
+});
+
+test('should fail to create volume on invalid networks', function (tt) {
+    tt.test('test w/ non-owned network', function (t) {
+        CLIENTS.volapi.createVolume({
+            name: 'volapi-test-invalid-owner',
+            owner_uuid: UFDS_ADMIN_UUID,
+            type: NFS_SHARED_VOLUMES_TYPE_NAME,
+            networks: [NETWORKS['nonOwned'].uuid]
+        }, function onVolumeCreated(err, volume) {
+            var expectedErrMsg =
+                'invalid network(s) specified: non-owned networks';
+
+            t.ok(err, 'volume creation should result in an error');
+            expectedError(t, err.message, expectedErrMsg,
+                'expected invalid (non-owned) networks error');
+
+            t.end();
+        });
+    });
+    tt.test('test w/ non-fabric network', function (t) {
+        CLIENTS.volapi.createVolume({
+            name: 'volapi-test-invalid-not-fabric',
+            owner_uuid: UFDS_ADMIN_UUID,
+            type: NFS_SHARED_VOLUMES_TYPE_NAME,
+            networks: [NETWORKS['nonFabric'].uuid]
+        }, function onVolumeCreated(err, volume) {
+            var expectedErrMsg =
+                'invalid network(s) specified: non-fabric networks';
+
+            t.ok(err, 'volume creation should result in an error');
+            expectedError(t, err.message, expectedErrMsg,
+                'expected invalid (non-fabric) networks error');
+
+            t.end();
+        });
+    });
+    tt.test('test w/ non-existent network', function (t) {
+        CLIENTS.volapi.createVolume({
+            name: 'volapi-test-invalid-not-existing',
+            owner_uuid: UFDS_ADMIN_UUID,
+            type: NFS_SHARED_VOLUMES_TYPE_NAME,
+            networks: [libuuid.create()]
+        }, function onVolumeCreated(err, volume) {
+            var expectedErrMsg =
+                'invalid network(s) specified: missing networks';
+
+            t.ok(err, 'volume creation should result in an error');
+            expectedError(t, err.message, expectedErrMsg,
+                'expected missing networks error');
+
+            t.end();
+        });
+    });
+});
+
+test('teardown', function (tt) {
+    cleanupPreviouslyCreatedTestNapiObjects(tt);
+});
diff --git a/test/integration/nfs-shared-volumes-creation-name-generation.test.js b/test/integration/nfs-shared-volumes-creation-name-generation.test.js
index 8bed7fe..5b019f3 100644
--- a/test/integration/nfs-shared-volumes-creation-name-generation.test.js
+++ b/test/integration/nfs-shared-volumes-creation-name-generation.test.js
@@ -12,22 +12,19 @@ var assert = require('assert-plus');
 var test = require('tape');
 var vasync = require('vasync');
 
-var configLoader = require('../../lib/config-loader');
-
 var clientsSetup = require('./lib/clients-setup');
+var configLoader = require('../../lib/config-loader');
 var resources = require('./lib/resources');
 
-var CONFIG = configLoader.loadConfigSync();
-
-var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
-assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
-
+var ADMIN_OWNED_FABRIC_NETWORK_UUID;
 var CLIENTS;
+var CONFIG = configLoader.loadConfigSync();
 var CREATED_VOLUMES = []; // volumes we created and need to destroy
 var NFS_SHARED_VOLUMES_NAMES_PREFIX = 'nfs-shared-volumes';
 var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
+var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
 
-var NETWORKS;
+assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
 
 test('setup', function (tt) {
     tt.test('setup clients', function (t) {
@@ -38,14 +35,27 @@ test('setup', function (tt) {
     });
 
     tt.test('setup networks', function (t) {
-        CLIENTS.napi.get('/networks',
+        CLIENTS.napi.get('/networks?owner_uuid=' + UFDS_ADMIN_UUID,
             function onListNetworks(err, networks) {
+                var idx;
+
                 t.ifError(err, 'expected success listing networks');
                 t.ok(networks, 'got networks from NAPI');
                 t.ok(Array.isArray(networks),
                     'networks object from NAPI is an array');
                 t.ok(networks.length > 1, 'expected more than 1 NAPI network');
-                NETWORKS = networks;
+
+                for (idx = 0; idx < networks.length &&
+                    !ADMIN_OWNED_FABRIC_NETWORK_UUID; idx++) {
+                    if (networks[idx].fabric) {
+                        ADMIN_OWNED_FABRIC_NETWORK_UUID = networks[idx].uuid;
+                    }
+                }
+
+                t.ok(ADMIN_OWNED_FABRIC_NETWORK_UUID,
+                    'expected to find admin-owned fabric network, got: ' +
+                    ADMIN_OWNED_FABRIC_NETWORK_UUID);
+
                 t.end();
             });
     });
@@ -57,7 +67,7 @@ test('NFS shared volume creation with missing "name"', function (tt) {
             var COMMON_PAYLOAD = {
                 owner_uuid: UFDS_ADMIN_UUID,
                 type: NFS_SHARED_VOLUMES_TYPE_NAME,
-                networks: [NETWORKS[0].uuid]
+                networks: [ADMIN_OWNED_FABRIC_NETWORK_UUID]
             };
             var EMPTY_NAME_PAYLOAD = JSON.parse(JSON.stringify(COMMON_PAYLOAD));
             var MISSING_NAME_PAYLOADS;
diff --git a/test/integration/nfs-shared-volumes.test.js b/test/integration/nfs-shared-volumes.test.js
index 19fc3bb..80f7091 100644
--- a/test/integration/nfs-shared-volumes.test.js
+++ b/test/integration/nfs-shared-volumes.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var child_process = require('child_process');
@@ -20,26 +20,43 @@ var test = require('tape');
 var vasync = require('vasync');
 
 var configLoader = require('../../lib/config-loader');
-
 var clientsSetup = require('./lib/clients-setup');
 var resources = require('./lib/resources');
 var testVolumes = require('./lib/volumes');
 
 var ADMIN_NETWORK_UUID;
-var CONFIG = configLoader.loadConfigSync();
-
-var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
-assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
-
+var ADMIN_OWNED_FABRIC_NETWORK_UUID;
 var CLIENTS;
+var CONFIG = configLoader.loadConfigSync();
 /*
  * This regular expression is not meant to match the general ISO 8601 format,
  * only the specific format outputted by new Date().toISOString().
  */
+var IMAGE_UUID;
 var ISO_DATE_STRING_RE = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z/;
+var KEY_FILENAME = '/tmp/volapi-test-key';
 var NETWORKS;
 var NFS_SHARED_VOLUMES_NAMES_PREFIX = 'nfs-shared-volumes';
+var NFS_SHARED_VOLUMES_VM_NAME_PREFIX = 'test-nfs-shared-volumes-mounter';
 var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
+var SDC_128_UUID;
+var SSH_PUBLIC_KEY;
+var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
+var VM_ADMIN_IP;
+var VM_UUID = libuuid.create();
+
+assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
+
+function deleteKeypair(cb) {
+    child_process.exec([
+        'rm',
+        '-f',
+        KEY_FILENAME,
+        KEY_FILENAME + '.pub'
+    ].join(' '), function onKeyPairDeleted(err, stdout, stderr) {
+        cb(err);
+    });
+}
 
 test('setup', function (tt) {
     tt.test('setup clients', function (t) {
@@ -49,37 +66,120 @@ test('setup', function (tt) {
         });
     });
 
-    tt.test('setup networks', function (t) {
-        CLIENTS.napi.get('/networks',
+    // need admin network so we can ssh to it from volapi (where we're running)
+    tt.test('find admin network', function (t) {
+        CLIENTS.napi.get('/networks?name=admin',
             function onListNetworks(err, networks) {
-                t.ifError(err);
-                t.ok(networks);
-                t.ok(Array.isArray(networks));
-                t.ok(networks.length > 1);
+                t.ifError(err, 'should have succeeded to list networks');
+                t.ok(networks, 'should have found networks');
+                t.ok(Array.isArray(networks), 'networks should be an array');
+                t.equal(networks.length, 1, 'should have exactly 1 network');
+                ADMIN_NETWORK_UUID = networks[0].uuid;
+                t.ok(ADMIN_NETWORK_UUID, 'found admin network: ' +
+                    ADMIN_NETWORK_UUID);
+                t.end();
+            });
+    });
+
+    // need fabric network so we can mount the volume
+    tt.test('find fabric network', function (t) {
+        CLIENTS.napi.get('/networks?owner_uuid=' + UFDS_ADMIN_UUID,
+            function onListNetworks(err, networks) {
+                t.ifError(err, 'should have succeeded to list networks');
+                t.ok(networks, 'should have found networks');
+                t.ok(Array.isArray(networks), 'networks should be an array');
+                t.ok(networks.length >= 1, 'should have at least 1 network');
                 networks.forEach(function findAdminNetwork(network) {
-                    if (network && network.name === 'admin') {
-                        ADMIN_NETWORK_UUID = network.uuid;
+                    if (!ADMIN_OWNED_FABRIC_NETWORK_UUID &&
+                        network && network.fabric) {
+                        ADMIN_OWNED_FABRIC_NETWORK_UUID = network.uuid;
                     }
                 });
-                t.ok(ADMIN_NETWORK_UUID, 'found admin network');
+                t.ok(ADMIN_OWNED_FABRIC_NETWORK_UUID,
+                    'found admin-owned fabric network: ' +
+                    ADMIN_OWNED_FABRIC_NETWORK_UUID);
+                t.end();
+            });
+    });
+
+    // delete previous SSH keypair(s)
+    tt.test('delete previous SSH keypair', function (t) {
+        deleteKeypair(function onDeleted(err) {
+            t.ifErr(err, 'removing keypair should succeed');
+            t.end();
+        });
+    });
+
+    // create an SSH keypair so we can use that to SSH into the test zone we're
+    // going to create.
+    tt.test('create an SSH keypair', function (t) {
+        child_process.exec([
+            'ssh-keygen',
+            '-t rsa',
+            '-N ""',
+            '-f',
+            KEY_FILENAME
+        ].join(' '), function onKeyPairCreated(err, stdout, stderr) {
+            t.ifErr(err, 'ssh-keygen should succeed');
+
+            fs.readFile(KEY_FILENAME + '.pub',
+                function onReadKey(readErr, keyData) {
+                    t.ifErr(readErr, 'reading public key should succeed');
+                    SSH_PUBLIC_KEY = keyData.toString().trim();
+                    t.ok(SSH_PUBLIC_KEY, 'should have found pubic key, got: ' +
+                        SSH_PUBLIC_KEY.substr(0, 20) + '...' +
+                        SSH_PUBLIC_KEY.substr(SSH_PUBLIC_KEY.length - 20));
+                    t.end();
+                });
+
+        });
+    });
+
+    // We use the origin image from the volapi image here since we know that
+    // image will be installed (if volapi is installed) and we really don't
+    // care what the dataset actually is.
+    tt.test('finding image', function (t) {
+        child_process.exec([
+            'mdata-get',
+            'sdc:image_uuid'
+        ].join(' '), function onGotImageUuid(err, stdout, stderr) {
+            t.ifErr(err, 'mdata-get sdc:image_uuid should succeed');
+            IMAGE_UUID = stdout.trim();
+            t.ok(IMAGE_UUID, 'should have found image_uuid, got: ' +
+                JSON.stringify(IMAGE_UUID));
+            t.end();
+        });
+    });
+
+    tt.test('finding package', function (t) {
+        CLIENTS.papi.list({name: 'sdc_128'}, {},
+            function onPackageList(err, pkgs) {
+                t.ifErr(err, 'expected list packages to succeed');
+                t.ok(pkgs, 'expected to get packages');
+                t.ok(Array.isArray(pkgs), 'packages should be an array');
+                t.ok(pkgs.length >= 1, 'should have at least 1 package');
+                SDC_128_UUID = pkgs[0].uuid;
+                t.ok(SDC_128_UUID, 'should have found pkg uuid, got: ' +
+                    JSON.stringify(SDC_128_UUID));
                 t.end();
             });
     });
+
 });
 
 test('nfs shared volumes', function (tt) {
+    var mountPoint;
+    var nfsRemotePath;
+    var sharedNfsVolume;
     var volumeName =
         resources.makeResourceName(NFS_SHARED_VOLUMES_NAMES_PREFIX);
-    var sharedNfsVolume;
-    var nfsRemotePath;
-    var mountPoint;
 
     tt.test('creating a simple nfs shared volume should succeed', function (t) {
         var volumeParams = {
             name: volumeName,
             owner_uuid: UFDS_ADMIN_UUID,
             type: NFS_SHARED_VOLUMES_TYPE_NAME,
-            networks: [ADMIN_NETWORK_UUID]
+            networks: [ADMIN_OWNED_FABRIC_NETWORK_UUID]
         };
 
         CLIENTS.volapi.createVolumeAndWait(volumeParams,
@@ -106,37 +206,88 @@ test('nfs shared volumes', function (tt) {
             t.end();
         });
 
-    tt.test('mounting the shared volume via NFS suceeds', function (t) {
+    tt.test('create a VM on same network as volume', function (t) {
+        var payload = {
+            alias: resources.makeResourceName(NFS_SHARED_VOLUMES_VM_NAME_PREFIX,
+                VM_UUID),
+            billing_id: SDC_128_UUID,
+            brand: 'joyent',
+            customer_metadata: {},
+            image_uuid: IMAGE_UUID,
+            networks: [
+                {uuid: ADMIN_OWNED_FABRIC_NETWORK_UUID},
+                {uuid: ADMIN_NETWORK_UUID}
+            ],
+            owner_uuid: UFDS_ADMIN_UUID,
+            uuid: VM_UUID
+        };
+        var user_script = [
+            '#!/bin/bash',
+            '',
+            'cat > /root/.ssh/authorized_keys <<EOF',
+            SSH_PUBLIC_KEY,
+            'EOF',
+            'chmod 0700 /root/.ssh',
+            'chmod 0600 /root/.ssh/authorized_keys',
+            '',
+            'mkdir -p /mnt'
+        ].join('\n');
+
+        payload.customer_metadata['user-script'] = user_script;
+
+        t.comment('creating VM ' + VM_UUID);
+
+        CLIENTS.vmapi.createVmAndWait(payload, {},
+            function onVmCreate(err, job) {
+                t.ifErr(err, 'VM creation should succeed');
+
+                CLIENTS.vmapi.getVm({uuid: VM_UUID}, {},
+                    function onGetVm(getErr, vmobj) {
+                        t.ifErr(getErr, 'GET after create should succeed');
+
+                        t.ok(vmobj, 'should have vmobj from GetVm');
+                        if (vmobj) {
+                            t.equal(vmobj.state, 'running', 'VM should be running');
+
+                            VM_ADMIN_IP = vmobj.nics[1].ip;
+                            t.ok(VM_ADMIN_IP, 'expected to find admin IP, got: ' +
+                                JSON.stringify(VM_ADMIN_IP));
+                        }
+
+                        t.end();
+                    });
+            });
+    });
+
+    tt.test('mounting the shared volume via NFS succeeds', function (t) {
         nfsRemotePath = sharedNfsVolume.filesystem_path;
-        mountPoint = path.join('/mnt', libuuid.create());
+        mountPoint = '/mnt';
 
-        vasync.pipeline({funcs: [
-            function createMountPointDir(args, next) {
-                mkdirp(mountPoint, function onMkdirpDone(err) {
-                    t.ifErr(err,
-                        'mountpoint dir should be created successfully');
-                    next();
-                });
-            },
-            function mountNfsPath(args, next) {
-                child_process.exec([
-                    'mount -F nfs', nfsRemotePath, mountPoint
-                ].join(' '), function onNfsMountDone(err, stdout, stderr) {
-                    t.ifErr(err, 'mounting the NFS remote fs should not error');
-                    next();
-                });
-            }
-        ]}, function onMountVolumeDone(err) {
+        child_process.exec([
+            'ssh',
+            '-o StrictHostKeyChecking=no',
+            '-o UserKnownHostsFile=/dev/null',
+            '-i', KEY_FILENAME,
+            'root@' + VM_ADMIN_IP,
+            '"mount -F nfs ' + nfsRemotePath + ' ' + mountPoint + '"'
+        ].join(' '), function onNfsMountDone(err, stdout, stderr) {
+            t.ifErr(err, 'mounting the NFS remote fs should succeed');
             t.end();
         });
     });
 
-    tt.test('unmounting the shared volume via NFS suceeds', function (t) {
-        child_process.exec(['umount', mountPoint ].join(' '),
-            function onMountDone(err, stdout, stderr) {
-                t.ifErr(err, 'unmounting the NFS remote fs should not error');
-                t.end();
-            });
+    tt.test('unmounting the shared volume via NFS succeeds', function (t) {
+        child_process.exec([
+            'ssh',
+            '-o StrictHostKeyChecking=no',
+            '-o UserKnownHostsFile=/dev/null',
+            '-i', KEY_FILENAME,
+            'root@' + VM_ADMIN_IP,
+            '"umount ' + mountPoint + '"'
+        ].join(' '), function onMountDone(err, stdout, stderr) {
+            t.ifErr(err, 'unmounting the NFS remote fs should not error');
+            t.end();
+        });
     });
 
     tt.test('newly created volume should show up in list endpoint',
@@ -158,25 +309,31 @@ test('nfs shared volumes', function (tt) {
 
     tt.test('cleanup', function (t) {
         vasync.parallel({funcs: [
+            function deleteTestVM(done) {
+                CLIENTS.vmapi.deleteVm({uuid: VM_UUID, sync: true}, {},
+                    function onDeleteVm(err, job) {
+                        t.ifErr(err, 'should succeed to delete VM');
+                        done();
+                    });
+            },
+            function cleanupKeypair(done) {
+                deleteKeypair(function (err) {
+                    t.ifErr(err, 'removing keypair should succeed');
+                    done();
+                });
+            },
             function deleteSharedVolume(done) {
                 CLIENTS.volapi.deleteVolumeAndWait({
-                    uuid: sharedNfsVolume.uuid,
-                    owner_uuid: UFDS_ADMIN_UUID
+                    owner_uuid: UFDS_ADMIN_UUID,
+                    uuid: sharedNfsVolume.uuid
                 }, function onVolumeDeleted(err) {
                     t.ifErr(err,
                         'volume should have been deleted without error');
                     done();
                 });
-            },
-            function removeMountPointDirectory(done) {
-                fs.rmdir(mountPoint, function onMountPointDeleted(err) {
-                    t.ifErr(err,
-                        'mountpoint should have been deleted without erorr');
-                     done();
-                });
             }
         ]}, function cleanupDone(err) {
             t.end();
         });
     });
-});
\ No newline at end of file
+});
diff --git a/test/runtest b/test/runtest
index b56200b..4c2e046 100755
--- a/test/runtest
+++ b/test/runtest
@@ -6,7 +6,11 @@
 #
 
 #
-# Copyright (c) 2015, Joyent, Inc.
+# Copyright (c) 2017, Joyent, Inc.
+#
+# All tests must run in the volapi zone, since the volapi zone is on the admin
+# network so it already has access to all of the Triton services that it needs
+# and this way we don't need to support different mechanisms for GZ and non-GZ.
 #
 
 # Run a single test of any type.
diff --git a/test/runtest.common b/test/runtest.common
index 15fec1e..3cb0b44 100644
--- a/test/runtest.common
+++ b/test/runtest.common
@@ -22,6 +22,16 @@ function fatal
     exit 1
 }
 
+#
+# Ensure we're not in the global zone, and that it looks like the volapi zone.
+#
+# All tests must run in the volapi zone, since the volapi zone is on the admin
+# network so it already has access to all of the Triton services that it needs
+# and this way we don't need to support different mechanisms for GZ and non-GZ.
+#
+if [[ $(zonename) == "global" || ! -d /opt/smartdc/volapi ]]; then
+   fatal "These tests must run in the volapi zone"
+fi
 
 # Guard
 guard_file=/lib/sdc/.sdc-test-no-production-data
@@ -35,11 +45,3 @@ after ensuring you have no production data on this SDC.
 EOF
     exit 2
 fi
-
-# If we're in the global zone, we don't want to use the default 127.0.0.1:80,
-# and instead want to find the admin IP of VOLAPI.
-if [[ $(zonename) == "global" ]]; then
-    # Gather DC info
-    export VOLAPI_URL="http://$(vmadm lookup -j alias=volapi0 | json 0.nics \
-        | json -c 'this.nic_tag==="admin"' 0.ip)"
-fi
diff --git a/test/runtests b/test/runtests
index 0c15e53..cc5eb92 100755
--- a/test/runtests
+++ b/test/runtests
@@ -10,8 +10,10 @@
 #
 
 #
-# Run SDC Docker *integration* tests.
-# This is expected to be run from GZ.
+# All tests must run in the volapi zone, since the volapi zone is on the admin
+# network so it already has access to all of the Triton services that it needs
+# and this way we don't need to support different mechanisms for GZ and non-GZ.
+#
 #
 # This creates .tap files in OUTPUT_DIR that can be processed by a TAP reader.
 # Testing config and log files are also placed in this dir.
-- 
2.21.0

