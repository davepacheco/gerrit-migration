From 63c7b87296cf1279a7da8785ab7ea5580aaff8f6 Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <jwilsdon@joyent.com>
Date: Mon, 29 May 2017 20:38:36 -0700
Subject: [PATCH] VOLAPI-38 CreateVolume endpoint doesn't validate that
 networks passed as input parameter are owned by owner_uuid

---
 lib/endpoints/volumes.js                      |   8 +
 lib/validation/networks.js                    |  70 +++++-
 lib/volapi.js                                 |  19 +-
 ...-volumes-creation-invalid-networks.test.js | 227 ++++++++++++++++++
 4 files changed, 315 insertions(+), 9 deletions(-)
 create mode 100644 test/integration/nfs-shared-volumes-creation-invalid-networks.test.js

diff --git a/lib/endpoints/volumes.js b/lib/endpoints/volumes.js
index 0f56c3e..499aed8 100644
--- a/lib/endpoints/volumes.js
+++ b/lib/endpoints/volumes.js
@@ -356,6 +356,14 @@ function createVolume(req, res, next) {
     var context = {};
 
     vasync.pipeline({funcs: [
+        function checkNetworks(ctx, done) {
+            // We've validated that networks is an array, now we need to
+            // validate that all of the elements are valid fabric network uuids
+            // that belong to this user.
+            networksValidation.validateFabricNetworkOwnership(req._napiClient,
+                volumeParams,
+                done);
+        },
         function acquireVolumeTicket(ctx, done) {
             var ticketId = ownerUuid + '-' + volumeName;
 
diff --git a/lib/validation/networks.js b/lib/validation/networks.js
index 259da2c..d80d78f 100644
--- a/lib/validation/networks.js
+++ b/lib/validation/networks.js
@@ -8,6 +8,9 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
 var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
 
 function validateNetwork(networkUuid) {
@@ -22,6 +25,71 @@ function validateNetwork(networkUuid) {
     return err;
 }
 
+function validateFabricNetworkOwnership(napiClient, volumeParams, callback) {
+    assert.object(napiClient, 'napiClient');
+    assert.object(volumeParams, 'volumeParams');
+    assert.arrayOfUuid(volumeParams.networks, 'volumeParams.networks');
+    assert.uuid(volumeParams.owner_uuid, 'volumeParams.owner_uuid');
+    assert.func(callback, 'callback');
+
+    var missing = [];
+    var nonFabric = [];
+    var nonOwned = [];
+
+    vasync.forEachParallel({
+        func: function validateOneNetwork(networkUuid, cb) {
+            napiClient.getNetwork(networkUuid, function onGetNetwork(err, net) {
+                if (!err && net) {
+                    assert.object(net, 'net');
+                    assert.optionalBool(net.fabric, 'net.fabric');
+                    assert.arrayOfUuid(net.owner_uuids, 'net.owner_uuids');
+
+                    if (net.fabric !== true) {
+                        nonFabric.push(networkUuid);
+                    }
+                    if (net.owner_uuids
+                        .indexOf(volumeParams.owner_uuid) === -1) {
+                        nonOwned.push(networkUuid);
+                    }
+                }
+                if (err && err.name === 'ResourceNotFoundError') {
+                    missing.push(networkUuid);
+                    // Swallow this error, since not found is just going to fail
+                    // validation anyway.
+                    err = undefined;
+                }
+                cb(err);
+            });
+        }, inputs: volumeParams.networks
+    }, function onValidated(err) {
+        var newErr = err;
+        var newErrMsgs = [];
+
+        if (!err) {
+            if (missing.length > 0) {
+                newErrMsgs.push('missing networks: ' + JSON.stringify(missing));
+            }
+            if (nonOwned.length > 0) {
+                newErrMsgs.push('non-owned networks: ' +
+                    JSON.stringify(nonOwned));
+            }
+            if (nonFabric.length > 0) {
+                newErrMsgs.push('non-fabric networks: ' +
+                    JSON.stringify(nonFabric));
+            }
+
+            if (newErrMsgs.length > 0) {
+                // use .trim() to remove trailing space
+                newErr = new Error('invalid network(s) specified: ' +
+                    newErrMsgs.join(' '));
+            }
+       }
+
+       callback(newErr);
+    });
+}
+
 module.exports = {
+    validateFabricNetworkOwnership: validateFabricNetworkOwnership,
     validateNetwork: validateNetwork
-};
\ No newline at end of file
+};
diff --git a/lib/volapi.js b/lib/volapi.js
index 71ee296..b0f5582 100644
--- a/lib/volapi.js
+++ b/lib/volapi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var crypto = require('crypto');
@@ -19,6 +19,7 @@ var vasync = require('vasync');
 
 var CnapiClient = require('sdc-clients').CNAPI;
 var ImgapiClient = require('sdc-clients').IMGAPI;
+var NapiClient = require('sdc-clients').NAPI;
 var PapiClient = require('sdc-clients').PAPI;
 var SapiClient = require('sdc-clients').SAPI;
 var VmapiClient = require('sdc-clients').VMAPI;
@@ -79,10 +80,11 @@ function setCommonMiddlewares(config, server, options, callback) {
             res.header('x-server-name', os.hostname());
         });
 
-        req._vmapiClient = options.vmapiClient;
-        req._papiClient = options.papiClient;
-        req._imgapiClient = options.imgapiClient;
         req._cnapiClient = options.cnapiClient;
+        req._imgapiClient = options.imgapiClient;
+        req._napiClient = options.napiClient;
+        req._papiClient = options.papiClient;
+        req._vmapiClient = options.vmapiClient;
 
         next();
     });
@@ -268,11 +270,12 @@ function init(config, log, callback) {
         setupRestifyServer,
         function setupMiddlewares(context, next) {
             return setCommonMiddlewares(config, context.server, {
-                vmapiClient: new VmapiClient(config.vmapi),
-                papiClient: new PapiClient(config.papi),
+                cnapiClient: new CnapiClient(config.cnapi),
                 imgapiClient: imgapiClient,
                 morayClient: morayClient,
-                cnapiClient: new CnapiClient(config.cnapi)
+                napiClient: new NapiClient(config.napi),
+                papiClient: new PapiClient(config.papi),
+                vmapiClient: new VmapiClient(config.vmapi)
             }, next);
         },
         function setupRoutes(context, next) {
@@ -287,4 +290,4 @@ function init(config, log, callback) {
 
 module.exports = {
     init: init
-};
\ No newline at end of file
+};
diff --git a/test/integration/nfs-shared-volumes-creation-invalid-networks.test.js b/test/integration/nfs-shared-volumes-creation-invalid-networks.test.js
new file mode 100644
index 0000000..3dcfc79
--- /dev/null
+++ b/test/integration/nfs-shared-volumes-creation-invalid-networks.test.js
@@ -0,0 +1,227 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var libuuid = require('libuuid');
+var test = require('tape');
+var vasync = require('vasync');
+
+var clientsSetup = require('./lib/clients-setup');
+var configLoader = require('../../lib/config-loader');
+
+var CONFIG = configLoader.loadConfigSync();
+
+var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
+assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
+
+var CLIENTS;
+var NETWORKS = {
+    nonOwned: {
+        name: 'volapi-test-invalid-1',
+        fabric: true,
+        vlan_id: 100,
+        subnet: '10.100.0.0/24',
+        provision_start_ip: '10.100.0.5',
+        provision_end_ip: '10.100.0.250',
+        nic_tag: 'volapi_test_invalid',
+        owner_uuids: [libuuid.create()],
+        gateway: '10.100.0.1'
+    }, nonFabric: {
+        name: 'volapi-test-invalid-2',
+        vlan_id: 101,
+        subnet: '10.101.0.0/24',
+        provision_start_ip: '10.101.0.5',
+        provision_end_ip: '10.101.0.250',
+        nic_tag: 'volapi_test_invalid',
+        owner_uuids: [UFDS_ADMIN_UUID],
+        gateway: '10.101.0.1'
+    }
+};
+var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
+
+function cleanupPreviouslyCreatedTestNapiObjects(tt, okNoExist) {
+
+    if (okNoExist) {
+        // we assume when it's ok if the networks don't exist, that the NETWORKS
+        // object won't yet have the uuids. So we grab them here.
+        tt.test('find previous NAPI network objects', function (t) {
+            vasync.forEachParallel({
+                func: function getPreviousTestNetworks(netKey, cb) {
+                    var net = NETWORKS[netKey];
+
+                    CLIENTS.napi.listNetworks({
+                        name: net.name
+                    }, {}, function onListNetworks(err, foundNet) {
+                        if (foundNet && foundNet[0] && foundNet[0].uuid) {
+                            net.uuid = foundNet[0].uuid;
+                        }
+                        cb();
+                    });
+                }, inputs: Object.keys(NETWORKS)
+            }, function afterCleanup(err) {
+                t.ifError(err, 'should have succeeded to get networks');
+                t.end();
+            });
+        });
+    }
+
+    tt.test('remove networks', function removePreviousTestNetworks(t) {
+        vasync.forEachParallel({
+            func: function removeNetwork(netKey, cb) {
+                var net = NETWORKS[netKey];
+
+                if (okNoExist && !net.uuid) {
+                    cb();
+                    return;
+                }
+
+                CLIENTS.napi.deleteNetwork(net.uuid, {}, {},
+                    function onDeleteNetwork(err) {
+                        t.ifError(err, 'DeleteNetwork should succeed: ' +
+                            net.uuid);
+                        cb();
+                    });
+            }, inputs: Object.keys(NETWORKS)
+        }, function afterRemovingNetworks(err) {
+            if (!okNoExist) {
+                t.ifError(err, 'should have succeeded to delete networks');
+            }
+            t.end();
+        });
+    });
+
+    tt.test('remove nic tag', function removeInvalidTestNicTag(t) {
+        CLIENTS.napi.deleteNicTag('volapi_test_invalid', {}, {},
+            function deleteNicTag(err) {
+                if (!okNoExist) {
+                    t.ifError(err, 'expected to have deleted nic tag');
+                }
+                t.end();
+            });
+    });
+}
+
+function expectedError(t, actualErrMsg, expectedErrMsg, testMsg) {
+    var matches;
+
+    // Make a RegExp from the expectedErr but we need to escape the
+    // '(' and ')' characters to '\(' and '\)' so that the regex
+    // will not treat that as a grouping.
+    var re = new RegExp(expectedErrMsg.replace(/[()]/g, '\\$&'));
+
+    matches = actualErrMsg.match(re);
+
+    // with this, we get the actual error message if it fails
+    t.equal((matches ? matches[0] : actualErrMsg), expectedErrMsg, testMsg);
+}
+
+
+test('setup', function (tt) {
+    tt.test('setup clients', function (t) {
+        clientsSetup.getApiClients(function onClientsSetup(err, clients) {
+            CLIENTS = clients;
+            t.end();
+        });
+    });
+
+    tt.test('cleanup NAPI network objects', function (t) {
+        // cleanup from previous runs
+        cleanupPreviouslyCreatedTestNapiObjects(t, true);
+    });
+
+    tt.test('create nic tag', function (t) {
+        CLIENTS.napi.createNicTag('volapi_test_invalid', {}, {},
+            function createNicTag(err) {
+                t.ifError(err, 'expected to have created a nic tag');
+                t.end();
+            });
+    });
+
+    tt.test('create invalid networks', function (t) {
+        vasync.forEachParallel({
+            func: function createInvalidNetwork(netKey, cb) {
+                var net = NETWORKS[netKey];
+
+                CLIENTS.napi.createNetwork(net, {},
+                    function onCreateNetwork(err, network) {
+                        t.ifError(err, 'CreateNetwork should succeed');
+                        t.ok((network && network.uuid), 'expected network ' +
+                            'uuid got: ' + ((network && network.uuid) ?
+                                network.uuid : 'undefined'));
+                        if (network && network.uuid) {
+                            net.uuid = network.uuid;
+                        }
+                        cb();
+                    });
+            }, inputs: Object.keys(NETWORKS)
+        }, function (err) {
+            t.ifError(err, 'should have succeeded');
+            t.end();
+        });
+    });
+});
+
+test('should fail to create volume on invalid networks', function (tt) {
+    tt.test('test w/ non-owned network', function (t) {
+        CLIENTS.volapi.createVolume({
+            name: 'volapi-test-invalid-owner',
+            owner_uuid: UFDS_ADMIN_UUID,
+            type: NFS_SHARED_VOLUMES_TYPE_NAME,
+            networks: [NETWORKS['nonOwned'].uuid]
+        }, function onVolumeCreated(err, volume) {
+            var expectedErrMsg =
+                'invalid network(s) specified: non-owned networks';
+
+            t.ok(err, 'volume creation should result in an error');
+            expectedError(t, err.message, expectedErrMsg,
+                'expected invalid (non-owned) networks error');
+
+            t.end();
+        });
+    });
+    tt.test('test w/ non-fabric network', function (t) {
+        CLIENTS.volapi.createVolume({
+            name: 'volapi-test-invalid-not-fabric',
+            owner_uuid: UFDS_ADMIN_UUID,
+            type: NFS_SHARED_VOLUMES_TYPE_NAME,
+            networks: [NETWORKS['nonFabric'].uuid]
+        }, function onVolumeCreated(err, volume) {
+            var expectedErrMsg =
+                'invalid network(s) specified: non-fabric networks';
+
+            t.ok(err, 'volume creation should result in an error');
+            expectedError(t, err.message, expectedErrMsg,
+                'expected invalid (non-fabric) networks error');
+
+            t.end();
+        });
+    });
+    tt.test('test w/ non-existent network', function (t) {
+        CLIENTS.volapi.createVolume({
+            name: 'volapi-test-invalid-not-existing',
+            owner_uuid: UFDS_ADMIN_UUID,
+            type: NFS_SHARED_VOLUMES_TYPE_NAME,
+            networks: [libuuid.create()]
+        }, function onVolumeCreated(err, volume) {
+            var expectedErrMsg =
+                'invalid network(s) specified: missing networks';
+
+            t.ok(err, 'volume creation should result in an error');
+            expectedError(t, err.message, expectedErrMsg,
+                'expected missing networks error');
+
+            t.end();
+        });
+    });
+});
+
+test('teardown', function (tt) {
+    cleanupPreviouslyCreatedTestNapiObjects(tt);
+});
-- 
2.21.0

