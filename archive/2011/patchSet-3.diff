commit 06fb749ec9c4eb2bd8f82b4586e90fa3627b6135 (refs/changes/11/2011/3)
Author: Josh Wilsdon <jwilsdon@joyent.com>
Date:   2017-05-30T13:01:10-07:00 (2 years, 4 months ago)
    
    VOLAPI-38 CreateVolume endpoint doesn't validate that networks passed as input parameter are owned by owner_uuid

diff --git a/lib/endpoints/volumes.js b/lib/endpoints/volumes.js
index 0f56c3e..499aed8 100644
--- a/lib/endpoints/volumes.js
+++ b/lib/endpoints/volumes.js
@@ -356,6 +356,14 @@ function createVolume(req, res, next) {
     var context = {};
 
     vasync.pipeline({funcs: [
+        function checkNetworks(ctx, done) {
+            // We've validated that networks is an array, now we need to
+            // validate that all of the elements are valid fabric network uuids
+            // that belong to this user.
+            networksValidation.validateFabricNetworkOwnership(req._napiClient,
+                volumeParams,
+                done);
+        },
         function acquireVolumeTicket(ctx, done) {
             var ticketId = ownerUuid + '-' + volumeName;
 
diff --git a/lib/validation/networks.js b/lib/validation/networks.js
index 259da2c..d80d78f 100644
--- a/lib/validation/networks.js
+++ b/lib/validation/networks.js
@@ -8,6 +8,9 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
 var UUID_RE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
 
 function validateNetwork(networkUuid) {
@@ -22,6 +25,71 @@ function validateNetwork(networkUuid) {
     return err;
 }
 
+function validateFabricNetworkOwnership(napiClient, volumeParams, callback) {
+    assert.object(napiClient, 'napiClient');
+    assert.object(volumeParams, 'volumeParams');
+    assert.arrayOfUuid(volumeParams.networks, 'volumeParams.networks');
+    assert.uuid(volumeParams.owner_uuid, 'volumeParams.owner_uuid');
+    assert.func(callback, 'callback');
+
+    var missing = [];
+    var nonFabric = [];
+    var nonOwned = [];
+
+    vasync.forEachParallel({
+        func: function validateOneNetwork(networkUuid, cb) {
+            napiClient.getNetwork(networkUuid, function onGetNetwork(err, net) {
+                if (!err && net) {
+                    assert.object(net, 'net');
+                    assert.optionalBool(net.fabric, 'net.fabric');
+                    assert.arrayOfUuid(net.owner_uuids, 'net.owner_uuids');
+
+                    if (net.fabric !== true) {
+                        nonFabric.push(networkUuid);
+                    }
+                    if (net.owner_uuids
+                        .indexOf(volumeParams.owner_uuid) === -1) {
+                        nonOwned.push(networkUuid);
+                    }
+                }
+                if (err && err.name === 'ResourceNotFoundError') {
+                    missing.push(networkUuid);
+                    // Swallow this error, since not found is just going to fail
+                    // validation anyway.
+                    err = undefined;
+                }
+                cb(err);
+            });
+        }, inputs: volumeParams.networks
+    }, function onValidated(err) {
+        var newErr = err;
+        var newErrMsgs = [];
+
+        if (!err) {
+            if (missing.length > 0) {
+                newErrMsgs.push('missing networks: ' + JSON.stringify(missing));
+            }
+            if (nonOwned.length > 0) {
+                newErrMsgs.push('non-owned networks: ' +
+                    JSON.stringify(nonOwned));
+            }
+            if (nonFabric.length > 0) {
+                newErrMsgs.push('non-fabric networks: ' +
+                    JSON.stringify(nonFabric));
+            }
+
+            if (newErrMsgs.length > 0) {
+                // use .trim() to remove trailing space
+                newErr = new Error('invalid network(s) specified: ' +
+                    newErrMsgs.join(' '));
+            }
+       }
+
+       callback(newErr);
+    });
+}
+
 module.exports = {
+    validateFabricNetworkOwnership: validateFabricNetworkOwnership,
     validateNetwork: validateNetwork
-};
\ No newline at end of file
+};
diff --git a/lib/volapi.js b/lib/volapi.js
index 71ee296..b0f5582 100644
--- a/lib/volapi.js
+++ b/lib/volapi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var crypto = require('crypto');
@@ -19,6 +19,7 @@ var vasync = require('vasync');
 
 var CnapiClient = require('sdc-clients').CNAPI;
 var ImgapiClient = require('sdc-clients').IMGAPI;
+var NapiClient = require('sdc-clients').NAPI;
 var PapiClient = require('sdc-clients').PAPI;
 var SapiClient = require('sdc-clients').SAPI;
 var VmapiClient = require('sdc-clients').VMAPI;
@@ -79,10 +80,11 @@ function setCommonMiddlewares(config, server, options, callback) {
             res.header('x-server-name', os.hostname());
         });
 
-        req._vmapiClient = options.vmapiClient;
-        req._papiClient = options.papiClient;
-        req._imgapiClient = options.imgapiClient;
         req._cnapiClient = options.cnapiClient;
+        req._imgapiClient = options.imgapiClient;
+        req._napiClient = options.napiClient;
+        req._papiClient = options.papiClient;
+        req._vmapiClient = options.vmapiClient;
 
         next();
     });
@@ -268,11 +270,12 @@ function init(config, log, callback) {
         setupRestifyServer,
         function setupMiddlewares(context, next) {
             return setCommonMiddlewares(config, context.server, {
-                vmapiClient: new VmapiClient(config.vmapi),
-                papiClient: new PapiClient(config.papi),
+                cnapiClient: new CnapiClient(config.cnapi),
                 imgapiClient: imgapiClient,
                 morayClient: morayClient,
-                cnapiClient: new CnapiClient(config.cnapi)
+                napiClient: new NapiClient(config.napi),
+                papiClient: new PapiClient(config.papi),
+                vmapiClient: new VmapiClient(config.vmapi)
             }, next);
         },
         function setupRoutes(context, next) {
@@ -287,4 +290,4 @@ function init(config, log, callback) {
 
 module.exports = {
     init: init
-};
\ No newline at end of file
+};
diff --git a/test/integration/lib/clients-setup.js b/test/integration/lib/clients-setup.js
index 9c5c26c..a168074 100644
--- a/test/integration/lib/clients-setup.js
+++ b/test/integration/lib/clients-setup.js
@@ -5,19 +5,20 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 var Logger = require('bunyan');
 var restify = require('restify');
-var VOLAPI = require('sdc-clients').VOLAPI;
+var IMGAPI = require('sdc-clients').IMGAPI;
 var NAPI = require('sdc-clients').NAPI;
+var PAPI = require('sdc-clients').PAPI;
 var VMAPI = require('sdc-clients').VMAPI;
+var VOLAPI = require('sdc-clients').VOLAPI;
 
 var configLoader = require('../../../lib/config-loader');
 var CONFIG = configLoader.loadConfigSync();
-
 var VOLAPI_URL = process.env.VOLAPI_URL || 'http://localhost';
 
 function getApiClients(callback) {
@@ -34,11 +35,8 @@ function getApiClients(callback) {
         }
     });
 
-    var volapiClient = new VOLAPI({
-        url: VOLAPI_URL,
-        version: '^1',
-        userAgent: 'sdc-volapi-integration-tests',
-        log: logger,
+    var imgapiClient = new IMGAPI({
+        url: CONFIG.imgapi.url,
         agent: false
     });
 
@@ -47,18 +45,33 @@ function getApiClients(callback) {
         agent: false
     });
 
+    var papiClient = new PAPI({
+        url: CONFIG.papi.url,
+        agent: false
+    });
+
     var vmapiClient = new VMAPI({
         url: CONFIG.vmapi.url,
         agent: false
     });
 
+    var volapiClient = new VOLAPI({
+        url: VOLAPI_URL,
+        version: '^1',
+        userAgent: 'sdc-volapi-integration-tests',
+        log: logger,
+        agent: false
+    });
+
     callback(null, {
-        volapi: volapiClient,
+        imgapi: imgapiClient,
         napi: napiClient,
-        vmapi: vmapiClient
+        papi: papiClient,
+        vmapi: vmapiClient,
+        volapi: volapiClient
     });
 }
 
 module.exports = {
     getApiClients: getApiClients
-};
\ No newline at end of file
+};
diff --git a/test/integration/nfs-shared-volumes-creation-invalid-networks.test.js b/test/integration/nfs-shared-volumes-creation-invalid-networks.test.js
new file mode 100644
index 0000000..3dcfc79
--- /dev/null
+++ b/test/integration/nfs-shared-volumes-creation-invalid-networks.test.js
@@ -0,0 +1,227 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var libuuid = require('libuuid');
+var test = require('tape');
+var vasync = require('vasync');
+
+var clientsSetup = require('./lib/clients-setup');
+var configLoader = require('../../lib/config-loader');
+
+var CONFIG = configLoader.loadConfigSync();
+
+var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
+assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
+
+var CLIENTS;
+var NETWORKS = {
+    nonOwned: {
+        name: 'volapi-test-invalid-1',
+        fabric: true,
+        vlan_id: 100,
+        subnet: '10.100.0.0/24',
+        provision_start_ip: '10.100.0.5',
+        provision_end_ip: '10.100.0.250',
+        nic_tag: 'volapi_test_invalid',
+        owner_uuids: [libuuid.create()],
+        gateway: '10.100.0.1'
+    }, nonFabric: {
+        name: 'volapi-test-invalid-2',
+        vlan_id: 101,
+        subnet: '10.101.0.0/24',
+        provision_start_ip: '10.101.0.5',
+        provision_end_ip: '10.101.0.250',
+        nic_tag: 'volapi_test_invalid',
+        owner_uuids: [UFDS_ADMIN_UUID],
+        gateway: '10.101.0.1'
+    }
+};
+var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
+
+function cleanupPreviouslyCreatedTestNapiObjects(tt, okNoExist) {
+
+    if (okNoExist) {
+        // we assume when it's ok if the networks don't exist, that the NETWORKS
+        // object won't yet have the uuids. So we grab them here.
+        tt.test('find previous NAPI network objects', function (t) {
+            vasync.forEachParallel({
+                func: function getPreviousTestNetworks(netKey, cb) {
+                    var net = NETWORKS[netKey];
+
+                    CLIENTS.napi.listNetworks({
+                        name: net.name
+                    }, {}, function onListNetworks(err, foundNet) {
+                        if (foundNet && foundNet[0] && foundNet[0].uuid) {
+                            net.uuid = foundNet[0].uuid;
+                        }
+                        cb();
+                    });
+                }, inputs: Object.keys(NETWORKS)
+            }, function afterCleanup(err) {
+                t.ifError(err, 'should have succeeded to get networks');
+                t.end();
+            });
+        });
+    }
+
+    tt.test('remove networks', function removePreviousTestNetworks(t) {
+        vasync.forEachParallel({
+            func: function removeNetwork(netKey, cb) {
+                var net = NETWORKS[netKey];
+
+                if (okNoExist && !net.uuid) {
+                    cb();
+                    return;
+                }
+
+                CLIENTS.napi.deleteNetwork(net.uuid, {}, {},
+                    function onDeleteNetwork(err) {
+                        t.ifError(err, 'DeleteNetwork should succeed: ' +
+                            net.uuid);
+                        cb();
+                    });
+            }, inputs: Object.keys(NETWORKS)
+        }, function afterRemovingNetworks(err) {
+            if (!okNoExist) {
+                t.ifError(err, 'should have succeeded to delete networks');
+            }
+            t.end();
+        });
+    });
+
+    tt.test('remove nic tag', function removeInvalidTestNicTag(t) {
+        CLIENTS.napi.deleteNicTag('volapi_test_invalid', {}, {},
+            function deleteNicTag(err) {
+                if (!okNoExist) {
+                    t.ifError(err, 'expected to have deleted nic tag');
+                }
+                t.end();
+            });
+    });
+}
+
+function expectedError(t, actualErrMsg, expectedErrMsg, testMsg) {
+    var matches;
+
+    // Make a RegExp from the expectedErr but we need to escape the
+    // '(' and ')' characters to '\(' and '\)' so that the regex
+    // will not treat that as a grouping.
+    var re = new RegExp(expectedErrMsg.replace(/[()]/g, '\\$&'));
+
+    matches = actualErrMsg.match(re);
+
+    // with this, we get the actual error message if it fails
+    t.equal((matches ? matches[0] : actualErrMsg), expectedErrMsg, testMsg);
+}
+
+
+test('setup', function (tt) {
+    tt.test('setup clients', function (t) {
+        clientsSetup.getApiClients(function onClientsSetup(err, clients) {
+            CLIENTS = clients;
+            t.end();
+        });
+    });
+
+    tt.test('cleanup NAPI network objects', function (t) {
+        // cleanup from previous runs
+        cleanupPreviouslyCreatedTestNapiObjects(t, true);
+    });
+
+    tt.test('create nic tag', function (t) {
+        CLIENTS.napi.createNicTag('volapi_test_invalid', {}, {},
+            function createNicTag(err) {
+                t.ifError(err, 'expected to have created a nic tag');
+                t.end();
+            });
+    });
+
+    tt.test('create invalid networks', function (t) {
+        vasync.forEachParallel({
+            func: function createInvalidNetwork(netKey, cb) {
+                var net = NETWORKS[netKey];
+
+                CLIENTS.napi.createNetwork(net, {},
+                    function onCreateNetwork(err, network) {
+                        t.ifError(err, 'CreateNetwork should succeed');
+                        t.ok((network && network.uuid), 'expected network ' +
+                            'uuid got: ' + ((network && network.uuid) ?
+                                network.uuid : 'undefined'));
+                        if (network && network.uuid) {
+                            net.uuid = network.uuid;
+                        }
+                        cb();
+                    });
+            }, inputs: Object.keys(NETWORKS)
+        }, function (err) {
+            t.ifError(err, 'should have succeeded');
+            t.end();
+        });
+    });
+});
+
+test('should fail to create volume on invalid networks', function (tt) {
+    tt.test('test w/ non-owned network', function (t) {
+        CLIENTS.volapi.createVolume({
+            name: 'volapi-test-invalid-owner',
+            owner_uuid: UFDS_ADMIN_UUID,
+            type: NFS_SHARED_VOLUMES_TYPE_NAME,
+            networks: [NETWORKS['nonOwned'].uuid]
+        }, function onVolumeCreated(err, volume) {
+            var expectedErrMsg =
+                'invalid network(s) specified: non-owned networks';
+
+            t.ok(err, 'volume creation should result in an error');
+            expectedError(t, err.message, expectedErrMsg,
+                'expected invalid (non-owned) networks error');
+
+            t.end();
+        });
+    });
+    tt.test('test w/ non-fabric network', function (t) {
+        CLIENTS.volapi.createVolume({
+            name: 'volapi-test-invalid-not-fabric',
+            owner_uuid: UFDS_ADMIN_UUID,
+            type: NFS_SHARED_VOLUMES_TYPE_NAME,
+            networks: [NETWORKS['nonFabric'].uuid]
+        }, function onVolumeCreated(err, volume) {
+            var expectedErrMsg =
+                'invalid network(s) specified: non-fabric networks';
+
+            t.ok(err, 'volume creation should result in an error');
+            expectedError(t, err.message, expectedErrMsg,
+                'expected invalid (non-fabric) networks error');
+
+            t.end();
+        });
+    });
+    tt.test('test w/ non-existent network', function (t) {
+        CLIENTS.volapi.createVolume({
+            name: 'volapi-test-invalid-not-existing',
+            owner_uuid: UFDS_ADMIN_UUID,
+            type: NFS_SHARED_VOLUMES_TYPE_NAME,
+            networks: [libuuid.create()]
+        }, function onVolumeCreated(err, volume) {
+            var expectedErrMsg =
+                'invalid network(s) specified: missing networks';
+
+            t.ok(err, 'volume creation should result in an error');
+            expectedError(t, err.message, expectedErrMsg,
+                'expected missing networks error');
+
+            t.end();
+        });
+    });
+});
+
+test('teardown', function (tt) {
+    cleanupPreviouslyCreatedTestNapiObjects(tt);
+});
diff --git a/test/integration/nfs-shared-volumes-creation-name-generation.test.js b/test/integration/nfs-shared-volumes-creation-name-generation.test.js
index 8bed7fe..5b019f3 100644
--- a/test/integration/nfs-shared-volumes-creation-name-generation.test.js
+++ b/test/integration/nfs-shared-volumes-creation-name-generation.test.js
@@ -12,22 +12,19 @@ var assert = require('assert-plus');
 var test = require('tape');
 var vasync = require('vasync');
 
-var configLoader = require('../../lib/config-loader');
-
 var clientsSetup = require('./lib/clients-setup');
+var configLoader = require('../../lib/config-loader');
 var resources = require('./lib/resources');
 
-var CONFIG = configLoader.loadConfigSync();
-
-var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
-assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
-
+var ADMIN_OWNED_FABRIC_NETWORK_UUID;
 var CLIENTS;
+var CONFIG = configLoader.loadConfigSync();
 var CREATED_VOLUMES = []; // volumes we created and need to destroy
 var NFS_SHARED_VOLUMES_NAMES_PREFIX = 'nfs-shared-volumes';
 var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
+var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
 
-var NETWORKS;
+assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
 
 test('setup', function (tt) {
     tt.test('setup clients', function (t) {
@@ -38,14 +35,27 @@ test('setup', function (tt) {
     });
 
     tt.test('setup networks', function (t) {
-        CLIENTS.napi.get('/networks',
+        CLIENTS.napi.get('/networks?owner_uuid=' + UFDS_ADMIN_UUID,
             function onListNetworks(err, networks) {
+                var idx;
+
                 t.ifError(err, 'expected success listing networks');
                 t.ok(networks, 'got networks from NAPI');
                 t.ok(Array.isArray(networks),
                     'networks object from NAPI is an array');
                 t.ok(networks.length > 1, 'expected more than 1 NAPI network');
-                NETWORKS = networks;
+
+                for (idx = 0; idx < networks.length &&
+                    !ADMIN_OWNED_FABRIC_NETWORK_UUID; idx++) {
+                    if (networks[idx].fabric) {
+                        ADMIN_OWNED_FABRIC_NETWORK_UUID = networks[idx].uuid;
+                    }
+                }
+
+                t.ok(ADMIN_OWNED_FABRIC_NETWORK_UUID,
+                    'expected to find admin-owned fabric network, got: ' +
+                    ADMIN_OWNED_FABRIC_NETWORK_UUID);
+
                 t.end();
             });
     });
@@ -57,7 +67,7 @@ test('NFS shared volume creation with missing "name"', function (tt) {
             var COMMON_PAYLOAD = {
                 owner_uuid: UFDS_ADMIN_UUID,
                 type: NFS_SHARED_VOLUMES_TYPE_NAME,
-                networks: [NETWORKS[0].uuid]
+                networks: [ADMIN_OWNED_FABRIC_NETWORK_UUID]
             };
             var EMPTY_NAME_PAYLOAD = JSON.parse(JSON.stringify(COMMON_PAYLOAD));
             var MISSING_NAME_PAYLOADS;
diff --git a/test/integration/nfs-shared-volumes.test.js b/test/integration/nfs-shared-volumes.test.js
index 19fc3bb..f475739 100644
--- a/test/integration/nfs-shared-volumes.test.js
+++ b/test/integration/nfs-shared-volumes.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var child_process = require('child_process');
@@ -20,18 +20,14 @@ var test = require('tape');
 var vasync = require('vasync');
 
 var configLoader = require('../../lib/config-loader');
-
 var clientsSetup = require('./lib/clients-setup');
 var resources = require('./lib/resources');
 var testVolumes = require('./lib/volumes');
 
-var ADMIN_NETWORK_UUID;
-var CONFIG = configLoader.loadConfigSync();
-
-var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
-assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
-
+var ADMIN_OWNED_FABRIC_NETWORK_UUID;
+var BASE_IMAGE_UUID;
 var CLIENTS;
+var CONFIG = configLoader.loadConfigSync();
 /*
  * This regular expression is not meant to match the general ISO 8601 format,
  * only the specific format outputted by new Date().toISOString().
@@ -40,6 +36,12 @@ var ISO_DATE_STRING_RE = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z/;
 var NETWORKS;
 var NFS_SHARED_VOLUMES_NAMES_PREFIX = 'nfs-shared-volumes';
 var NFS_SHARED_VOLUMES_TYPE_NAME = 'tritonnfs';
+var SDC_128_UUID;
+var SYSINFO;
+var UFDS_ADMIN_UUID = CONFIG.ufdsAdminUuid;
+var VM_UUID = libuuid.create();
+
+assert.string(UFDS_ADMIN_UUID, 'UFDS_ADMIN_UUID');
 
 test('setup', function (tt) {
     tt.test('setup clients', function (t) {
@@ -50,36 +52,95 @@ test('setup', function (tt) {
     });
 
     tt.test('setup networks', function (t) {
-        CLIENTS.napi.get('/networks',
+        CLIENTS.napi.get('/networks?owner_uuid=' + UFDS_ADMIN_UUID,
             function onListNetworks(err, networks) {
-                t.ifError(err);
-                t.ok(networks);
-                t.ok(Array.isArray(networks));
-                t.ok(networks.length > 1);
+                t.ifError(err, 'should have succeeded to list networks');
+                t.ok(networks, 'should have found networks');
+                t.ok(Array.isArray(networks), 'networks should be an array');
+                t.ok(networks.length >= 1, 'should have at least 1 network');
                 networks.forEach(function findAdminNetwork(network) {
-                    if (network && network.name === 'admin') {
-                        ADMIN_NETWORK_UUID = network.uuid;
+                    if (!ADMIN_OWNED_FABRIC_NETWORK_UUID &&
+                        network && network.fabric) {
+                        ADMIN_OWNED_FABRIC_NETWORK_UUID = network.uuid;
                     }
                 });
-                t.ok(ADMIN_NETWORK_UUID, 'found admin network');
+                t.ok(ADMIN_OWNED_FABRIC_NETWORK_UUID,
+                    'found admin-owned fabric network: ' +
+                    ADMIN_OWNED_FABRIC_NETWORK_UUID);
+                t.end();
+            });
+    });
+
+    tt.test('finding UUID of this host', function (t) {
+        fs.readFile('/tmp/.sysinfo.json', function onReadSysinfo(err, data) {
+            t.ifErr(err, 'expected reading sysinfo to succeed');
+            t.ok(data, 'should get sysinfo data');
+            SYSINFO = JSON.parse(data);
+            t.ok(SYSINFO.UUID, 'sysinfo should have uuid, got: ' +
+                JSON.stringify(SYSINFO.UUID));
+            t.end();
+        });
+    });
+
+    tt.test('finding image', function (t) {
+        CLIENTS.imgapi.listImages({name: 'base-multiarch-lts'},
+            function onListImages(err, images) {
+                var img;
+                var idx = 0;
+
+                t.ifErr(err, 'expected ListImages to succeed');
+                t.ok(images, 'should have non-empty images result');
+                t.ok(Array.isArray(images), 'images should be an array');
+
+                for (idx = 0; idx < images.length; idx++) {
+                    // pick the most recent published image
+                    if (!img || img.published_at < images[idx].published_at) {
+                        img = images[idx];
+                    }
+                }
+
+                t.ok(img, 'found base image: ' + JSON.stringify({
+                    name: img.name,
+                    published_at: img.published_at,
+                    uuid: img.uuid,
+                    version: img.version
+                }));
+                BASE_IMAGE_UUID = img.uuid;
+
                 t.end();
             });
     });
+
+    tt.test('finding package', function (t) {
+        CLIENTS.papi.list({name: 'sdc_128'}, {},
+            function onPackageList(err, pkgs) {
+                t.ifErr(err, 'expected list packages to succeed');
+                t.ok(pkgs, 'expected to get packages');
+                t.ok(Array.isArray(pkgs), 'packages should be an array');
+                t.ok(pkgs.length >= 1, 'should have at least 1 package');
+                SDC_128_UUID = pkgs[0].uuid;
+                t.ok(SDC_128_UUID, 'should have found pkg uuid, got: ' +
+                    JSON.stringify(SDC_128_UUID));
+                t.end();
+            });
+    });
+
 });
 
 test('nfs shared volumes', function (tt) {
+    var gzMountPoint;
+    var mountPoint;
+    var nfsRemotePath;
+    var sharedNfsVolume;
     var volumeName =
         resources.makeResourceName(NFS_SHARED_VOLUMES_NAMES_PREFIX);
-    var sharedNfsVolume;
-    var nfsRemotePath;
-    var mountPoint;
 
     tt.test('creating a simple nfs shared volume should succeed', function (t) {
         var volumeParams = {
             name: volumeName,
             owner_uuid: UFDS_ADMIN_UUID,
             type: NFS_SHARED_VOLUMES_TYPE_NAME,
-            networks: [ADMIN_NETWORK_UUID]
+            networks: [ADMIN_OWNED_FABRIC_NETWORK_UUID]
         };
 
         CLIENTS.volapi.createVolumeAndWait(volumeParams,
@@ -106,13 +167,39 @@ test('nfs shared volumes', function (tt) {
             t.end();
         });
 
-    tt.test('mounting the shared volume via NFS suceeds', function (t) {
+    tt.test('create a VM on same network as volume', function (t) {
+        var payload = {
+            alias: 'test-nfs-shared-volumes-mounter-' + VM_UUID.split('-')[0],
+            billing_id: SDC_128_UUID,
+            brand: 'joyent-minimal',
+            image_uuid: BASE_IMAGE_UUID,
+            networks: [ {uuid: ADMIN_OWNED_FABRIC_NETWORK_UUID} ],
+            owner_uuid: UFDS_ADMIN_UUID,
+            server_uuid: SYSINFO.UUID, // provision here so we can zlogin
+            uuid: VM_UUID
+        };
+
+        CLIENTS.vmapi.createVmAndWait(payload, {},
+            function onVmCreate(err, job) {
+                t.ifErr(err, 'VM creation should succeed');
+
+                CLIENTS.vmapi.getVm({uuid: VM_UUID}, {},
+                    function onGetVm(getErr, vmobj) {
+                        t.ifErr(getErr, 'GET after create should succeed');
+                        t.equal(vmobj.state, 'running', 'VM should be running');
+                        t.end();
+                    });
+            });
+    });
+
+    tt.test('mounting the shared volume via NFS succeeds', function (t) {
         nfsRemotePath = sharedNfsVolume.filesystem_path;
         mountPoint = path.join('/mnt', libuuid.create());
+        gzMountPoint = path.join('/zones/', VM_UUID, '/root', mountPoint);
 
         vasync.pipeline({funcs: [
             function createMountPointDir(args, next) {
-                mkdirp(mountPoint, function onMkdirpDone(err) {
+                mkdirp(gzMountPoint, function onMkdirpDone(err) {
                     t.ifErr(err,
                         'mountpoint dir should be created successfully');
                     next();
@@ -120,7 +207,11 @@ test('nfs shared volumes', function (tt) {
             },
             function mountNfsPath(args, next) {
                 child_process.exec([
-                    'mount -F nfs', nfsRemotePath, mountPoint
+                    'zlogin',
+                    VM_UUID,
+                    'mount -F nfs',
+                    nfsRemotePath,
+                    mountPoint
                 ].join(' '), function onNfsMountDone(err, stdout, stderr) {
                     t.ifErr(err, 'mounting the NFS remote fs should not error');
                     next();
@@ -131,8 +222,8 @@ test('nfs shared volumes', function (tt) {
         });
     });
 
-    tt.test('unmounting the shared volume via NFS suceeds', function (t) {
-        child_process.exec(['umount', mountPoint ].join(' '),
+    tt.test('unmounting the shared volume via NFS succeeds', function (t) {
+        child_process.exec(['zlogin', VM_UUID, 'umount', mountPoint ].join(' '),
             function onMountDone(err, stdout, stderr) {
                 t.ifErr(err, 'unmounting the NFS remote fs should not error');
                 t.end();
@@ -158,25 +249,25 @@ test('nfs shared volumes', function (tt) {
 
     tt.test('cleanup', function (t) {
         vasync.parallel({funcs: [
+            function deleteTestVM(done) {
+                CLIENTS.vmapi.deleteVm({uuid: VM_UUID, sync: true}, {},
+                    function onDeleteVm(err, job) {
+                        t.ifErr(err, 'should succeed to delete VM');
+                        done();
+                    });
+            },
             function deleteSharedVolume(done) {
                 CLIENTS.volapi.deleteVolumeAndWait({
-                    uuid: sharedNfsVolume.uuid,
-                    owner_uuid: UFDS_ADMIN_UUID
+                    owner_uuid: UFDS_ADMIN_UUID,
+                    uuid: sharedNfsVolume.uuid
                 }, function onVolumeDeleted(err) {
                     t.ifErr(err,
                         'volume should have been deleted without error');
                     done();
                 });
-            },
-            function removeMountPointDirectory(done) {
-                fs.rmdir(mountPoint, function onMountPointDeleted(err) {
-                    t.ifErr(err,
-                        'mountpoint should have been deleted without erorr');
-                     done();
-                });
             }
         ]}, function cleanupDone(err) {
             t.end();
         });
     });
-});
\ No newline at end of file
+});
