commit 55616e6053b14c4e02267f2de5730bbeaf588089 (refs/changes/75/475/2)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2016-09-16T18:54:51+00:00 (3 years, 1 month ago)
    
    FWAPI-255 fwadm(1M) should exec ipf(1M) less when reloading firewalls

diff --git a/src/fw/lib/fw.js b/src/fw/lib/fw.js
index 9f4d3d57..a1af9b37 100644
--- a/src/fw/lib/fw.js
+++ b/src/fw/lib/fw.js
@@ -234,16 +234,11 @@ function getAffectedRules(new_vms, log) {
 /**
  * Starts ipf and reloads the rules for a VM
  */
-function startIPF(opts, log, callback) {
+function reloadIPF(opts, log, callback) {
     var ipfConf = util.format(IPF_CONF, opts.zonepath);
     var ipf6Conf = util.format(IPF6_CONF, opts.zonepath);
 
-    return mod_ipf.start(opts.vm, log, function (err, res) {
-        if (err) {
-            return callback(err, res);
-        }
-        return mod_ipf.reload(opts.vm, ipfConf, ipf6Conf, log, callback);
-    });
+    mod_ipf.reload(opts.vm, ipfConf, ipf6Conf, log, callback);
 }
 
 
@@ -1366,18 +1361,19 @@ function restartFirewalls(vms, uuids, log, callback) {
                 + '(enabled=%s, state=%s)', uuid, vms.all[uuid].enabled,
                 vms.all[uuid].state);
 
-            // Start the firewall just in case
-            return startIPF({ vm: uuid, zonepath: vms.all[uuid].zonepath },
+            // Reload the firewall, and start it if necessary.
+            reloadIPF({ vm: uuid, zonepath: vms.all[uuid].zonepath },
                 log, function (err, res) {
-                    restarted.push(uuid);
-                    if (err && zoneNotRunning(res)) {
-                        // An error starting the firewall due to the zone not
-                        // running isn't really an error
-                        return cb();
-                    }
+                restarted.push(uuid);
+                if (err && zoneNotRunning(res)) {
+                    // An error starting the firewall due to the zone not
+                    // running isn't really an error
+                    cb();
+                    return;
+                }
 
-                    return cb(err);
-                });
+                cb(err);
+            });
         }
     }, function (err, res) {
         // XXX: Does this stop on the first error?
diff --git a/src/fw/lib/ipf.js b/src/fw/lib/ipf.js
index e072bf47..b3114eaf 100644
--- a/src/fw/lib/ipf.js
+++ b/src/fw/lib/ipf.js
@@ -102,77 +102,56 @@ function setOld() {
  * Reloads the ipf rules for a zone
  *
  * @param uuid {String} : zone UUID
- * @param conf {String} : path of ipf conf file to load
+ * @param conf4 {String} : path of IPv4 IPF conf file to load
+ * @param conf6 {String} : path of IPv6 IPF conf file to load
  * @param log {Object} : bunyan logger
  * @param callback {Function} : `function (err, res)`
  */
-function zoneReload(uuid, conf, conf6, log, callback) {
+function zoneReload(uuid, conf4, conf6, log, callback) {
     assert.string(uuid, 'uuid');
-    assert.string(conf, 'conf');
+    assert.string(conf4, 'conf4');
     assert.string(conf6, 'conf6');
     assert.object(log, 'log');
     assert.func(callback, 'callback');
 
-    vasync.waterfall([
-        function _v4flush(cb) {
-            // Flush (-F) all (-a) IPv4 rules from the inactive list (-I) for
-            // the GZ-controlled ipf stack (-G) for zone uuid
-            var flushOpts = ['-GIFa', uuid];
-            if (OLD) {
-                flushOpts = ['-IFa', uuid];
-            }
+    /*
+     * ipf(1M) acts on each of its arguments in the order that they are
+     * supplied. Since executing 6 commands for reloading each zone's
+     * firewall gets expensive quickly, we perform multiple actions in
+     * a single ipf(1M) run:
+     */
+    var args = [
+        // Operate on the GZ-controlled firewall
+        '-G',
 
-            return ipf(flushOpts, log, cb);
-        },
-        function _v6flush(_, cb) {
-            // Flush (-F) all (-a) IPv6 (-6) rules from the inactive list (-I)
-            // for the GZ-controlled ipf stack (-G) for zone uuid
-            var flushOpts = ['-6GIFa', uuid];
-            if (OLD) {
-                flushOpts = ['-6IFa', uuid];
-            }
+        // Enable the firewall if it isn't already.
+        '-E',
 
-            return ipf(flushOpts, log, cb);
-        },
-        function _v4load(_, cb) {
-            // Load IPv4 rules from conf (-f) into the inactive list (-I) for
-            // the GZ-controlled (-G) ipf stack
-            var loadOpts = ['-G', '-I', '-f', conf, uuid];
-            if (OLD) {
-                loadOpts = ['-I', '-f', conf, uuid];
-            }
-            return ipf(loadOpts, log, cb);
-        },
-        function _v6load(_, cb) {
-            fs.stat(conf6, function (err, stati) {
-                if (err) {
-                    if (err.code === 'ENOENT') {
-                        // No IPv6 rules to load
-                        return cb();
-                    }
-                    return cb(err);
-                }
+        // Operate on the inactive list.
+        '-I',
 
-                // Load IPv6 (-6) rules from conf (-f) into the inactive
-                // list (-I) for the GZ-controlled (-G) ipf stack
-                var loadOpts = ['-6', '-G', '-I', '-f', conf6, uuid];
-                if (OLD) {
-                    loadOpts = ['-6', '-I', '-f', conf6, uuid];
-                }
-                return ipf(loadOpts, log, cb);
-            });
-        },
-        function _swap(_, cb) {
-            // Swap (-s) the active and inactive lists, and update the interface
-            // list (-y) for the GZ-controlled ipf stack (-G)
-            var swapOpts = ['-G', '-s', '-y', uuid];
-            if (OLD) {
-                swapOpts = ['-s', '-y', uuid];
-            }
+        // Flush all IPv4 rules from the inactive list, and
+        // then load rules from conf4 into it.
+        '-Fa', '-f', conf4,
 
-            return ipf(swapOpts, log, cb);
-        }
-    ], callback);
+        // Flush all IPv6 rules from the inactive list, and
+        // then load rules from conf6 into it.
+        '-6', '-Fa', '-f', conf6,
+
+        // Swap the active and inactive lists, and update the
+        // interface list.
+        '-sy',
+
+        // Operate on a specific zone.
+        uuid
+    ];
+
+    if (OLD) {
+        args.shift();
+    }
+
+    // Run ipf(1M) and reload the zone's firewall.
+    ipf(args, log, callback);
 }
 
 
diff --git a/src/fw/test/lib/mocks.js b/src/fw/test/lib/mocks.js
index c7a6a4b3..eebe4086 100644
--- a/src/fw/test/lib/mocks.js
+++ b/src/fw/test/lib/mocks.js
@@ -172,43 +172,37 @@ function resolveLevel() {
 function _recordIPFstate(args) {
     var zone = createSubObjects(VALUES.ipf, args[args.length - 1]);
 
-    if (args[0] == '-GD') {
-        zone.enabled = false;
-        zone.inactive = '';
-        zone.active = '';
-        return;
-    }
-
-    if (args[0] == '-GE') {
-        zone.enabled = true;
-        zone.inactive = '';
-        zone.active = '';
-        return;
-    }
-
-    if (args[0] == '-GIFa') {
-        zone.inactive = '';
-        return;
-    }
-
-    if (args[1] == '-s') {
-        var active = zone.active || '';
-        var inactive = zone.inactive || '';
-        zone.active = inactive;
-        zone.inactive = active;
-        return;
-    }
-
-    if (args[1] == '-I' && args[2] == '-f') {
-        var root = VALUES.fs;
-        var p = _splitFile(args[3]);
-        if (!root.hasOwnProperty(p.dir)
-                || !root[p.dir].hasOwnProperty(p.file)) {
-            throw _ENOENT(p.file);
+    for (var i = 0; i < args.length - 1; i++) {
+        switch (args[i]) {
+        case '-GD':
+            zone.enabled = false;
+            break;
+        case '-GE':
+            zone.enabled = true;
+            break;
+        case '-D':
+            zone.enabled = false;
+            break;
+        case '-E':
+            zone.enabled = true;
+            break;
+        // No state to record
+        case '-GV':
+        case '-G':
+            break;
+        // Not currently implemented
+        case '-sy':
+        case '-I':
+        case '-Fa':
+        case '-6':
+            break;
+        case '-f':
+            i += 1;
+            break;
+        default:
+            throw new Error('Unrecognized /usr/sbin/ipf argument (' + args[i]
+                + ') in arguments list: ' + args.join(' '));
         }
-
-        zone.inactive = root[p.dir][p.file];
-        return;
     }
 }
 
@@ -233,11 +227,7 @@ function execFile(path, args, opts, cb) {
     }
 
     if (path == IPF) {
-        try {
-            _recordIPFstate(args);
-        } catch (err) {
-            vals.err = err;
-        }
+        _recordIPFstate(args);
     }
 
     return cb(vals.err, vals.stdout, vals.stderr);
