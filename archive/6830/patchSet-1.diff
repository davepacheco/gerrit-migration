From 73b85d3841a72845d6aae20c90a4fc578310721b Mon Sep 17 00:00:00 2001
From: rhb2 <robert.bogart@joyent.com>
Date: Thu, 22 Aug 2019 17:54:45 +0000
Subject: [PATCH] MANTA-4497 Rebalancer Agent: Define and implement unit test
 cases

---
 Cargo.toml                               |   1 +
 src/agent.rs                             | 199 +++++++++++++++-
 src/jobs/mod.rs                          |   2 +-
 test/agent/files/area_codes_by_state.csv | 284 +++++++++++++++++++++++
 test/agent/test_init.sh                  | 164 +++++++++++++
 5 files changed, 647 insertions(+), 3 deletions(-)
 create mode 100644 test/agent/files/area_codes_by_state.csv
 create mode 100755 test/agent/test_init.sh

diff --git a/Cargo.toml b/Cargo.toml
index aff4b40..4bad1e6 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -21,6 +21,7 @@ gotham = "0.3.0"
 gotham_derive = "0.3.0"
 hyper = "0.12"
 mime = "0.3.13"
+more-asserts = "0.2.1"
 # TODO: remove in favor of rust-libmanta
 moray = { git = "https://github.com/joyent/rust-moray", tag = "v0.1.0" }
 futures = "0.1.27"
diff --git a/src/agent.rs b/src/agent.rs
index b32abf0..4415e82 100644
--- a/src/agent.rs
+++ b/src/agent.rs
@@ -27,6 +27,7 @@ use gotham_derive::{StateData, StaticResponseExtender};
 use base64;
 use hyper::{Body, Chunk, Method};
 use libmanta::moray::MantaObjectShark;
+use more_asserts;
 use md5::{Digest, Md5};
 
 use crate::jobs::Task;
@@ -99,7 +100,7 @@ pub struct Assignment {
     pub uuid: String,
     pub stats: AgentAssignmentStats,
 
-    #[serde(skip_serializing, skip_deserializing)]
+    #[serde(skip_serializing, skip_deserializing, default)]
     pub tasks: Vec<Task>,
 }
 
@@ -563,7 +564,7 @@ fn verify_file_md5(file_path: &str, csum: &str) -> bool {
         }
     };
 
-    let result_ascii = base64::encode(&hasher.result().to_ascii_lowercase());
+    let result_ascii = base64::encode(&hasher.result());
     result_ascii == csum
 }
 
@@ -777,3 +778,197 @@ fn create_dir(dirname: &str) {
         panic!("Error creating directory {}", e);
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use gotham::test::TestServer;
+    use std::{thread, time};
+    use more_asserts;
+
+    // Utility that actually forms the request, sends it off to the test
+    // server and verifies that it was received as intended.  Upon success,
+    // return the uuid of the assignment which we will use to monitor progress.
+    fn send_assignment(test_server: &TestServer,
+        assignment: Arc<RwLock<Assignment>>) -> String {
+        let tasks = &assignment.read().unwrap().tasks;
+        let body: Vec<u8> =
+            serde_json::to_vec(tasks).expect("Serialized assignment");
+
+        let response = test_server
+            .client()
+            .post(
+                "http://localhost/assignments",
+                hyper::Body::from(body),
+                mime::APPLICATION_JSON,
+            )
+            .perform()
+            .unwrap();
+
+        assert_eq!(response.status(), StatusCode::OK);
+
+        let body = response.read_body().unwrap();
+        let data = String::from_utf8(body.to_vec()).unwrap();
+        let uuid: String = match serde_json::from_str(&data) {
+            Ok(s) => s,
+            Err(e) => panic!(format!("Error: {}", e)),
+        };
+
+        println!("response: {:?}", uuid);
+        uuid.to_string()
+    }
+
+    // Given a test server and a directory containing assignments (and only
+    // assignments, load them in to memory and then them off to the test
+    // server for processing.  Return a vector containing any/all assignment
+    // uuids which are currently in flight.  The caller will want these in
+    // order to monitor their respective progress.
+    fn post_assignments(test_server: &TestServer, dir: &str) -> Vec<String> {
+        let mut ids = Vec::new();
+        for entry in WalkDir::new(dir)
+            .min_depth(1)
+            .follow_links(false)
+            .into_iter()
+            .filter_map(|e| e.ok())
+        {
+            let uuid = entry.file_name().to_string_lossy();
+            println!("{}/{}", dir, uuid);
+            let assignment = match assignment_recall(format!("{}/{}", dir,
+                uuid)) {
+                Ok(a) => a,
+                Err(e) => panic!(format!("Unable to load assignment: {}", e)),
+            };
+
+            ids.push(send_assignment(test_server, assignment)); 
+        }
+
+        more_asserts::assert_gt!(ids.len(), 0);
+        ids
+    }
+
+    // Send a request to get the latest information on an assignment.  This
+    // information is used by the test automation to determine how far along
+    // the agent is in processing the assignment.  During testing, this will
+    // likely be called repeatedly for a particular assignment until it is
+    // observed that the number of tasks completed is equal to the total number
+    // of tasks in the assignment.
+    fn get_progress(test_server: &TestServer, uuid: &str) -> Assignment {
+        let url = format!("http://localhost/assignment/{}", uuid);
+        let response = test_server
+            .client()
+            .get(url)
+            .perform()
+            .unwrap();
+
+        assert_eq!(response.status(), StatusCode::OK);
+        let body = response.read_body().unwrap();
+        let data = String::from_utf8(body.to_vec()).unwrap();
+        let assignment: Assignment = match serde_json::from_str(&data) {
+            Ok(a) => a,
+            Err(e) => panic!(format!("Failed to deserialize: {}", e)),
+        };
+
+        assignment
+    }
+
+    // Poll the server indefinitely on the status of a given assignment until
+    // it is complete.  Currently, it's not clear if there should be an
+    // expectation on how long an assignment should take to complete, especially
+    // in a test scenario.  If the agent is inoperable due to being wedged, a
+    // request will timeout causing a panic for a given test case anyway.  For
+    // that reason, it is probably reasonable to allow this function to loop
+    // indefinitely with the assumption that the agent is not hung.
+    fn monitor_progress(test_server: &TestServer, uuid: &str
+        ) -> Arc<RwLock<Assignment>> {
+        loop {
+            let assignment = get_progress(test_server, uuid);
+
+            // If we have finished processing all tasks, return the assignment
+            // to the caller.
+            if assignment.stats.complete == assignment.stats.total {
+                // Load the full assignment in to memory from disk.  The reason
+                // why this is necessary is because no public APIs currently
+                // exist that serialize the entire assignment in response to a
+                // request.  The reasonsing was that introducing a new publicly
+                // accessible API for the purposes of testing did not seem like
+                // a sufficient justification for creating one.  Since we have
+                // access to it on disk anyway, load it in to memory from there.
+                match assignment_recall(format!("{}/{}",
+                    REBALANCER_FINISHED_DIR, uuid)) {
+                    Ok(a) => return a,
+                    Err(e) => panic!(
+                        format!("Unable to load assignment: {}", e)),
+                }
+            }
+
+            thread::sleep(time::Duration::from_secs(10));
+        }
+    }
+
+    // Given a vector of assignments that have been posted, monitor their
+    // respective progress.  For the time being, the agent processes assignments
+    // sequeuntially, so it the assumption (for now) is that it is reasonable
+    // to monitor their progress sequentially.  If an assignment within the
+    // vector contains a task that does not have a status that matches the
+    // expected outcome, flag it for further analysis.
+    fn monitor_assignments(test_server: &TestServer, assignments: &Vec<String>,
+        expected: TaskStatus) -> Result<(), String>
+    {
+        for uuid in assignments.iter() {
+            // Wait for the assignment to complete.
+            let assignment = monitor_progress(test_server, &uuid);
+
+            let tasks = &assignment.read().unwrap().tasks;
+            let len = tasks.len();
+
+            for t in tasks.iter() {
+                assert_eq!(t.status, expected);
+            }
+        }
+        Ok(())
+    }
+
+    // Test name:    Download
+    // Description:  Download a healthy file from a storage node that the agent
+    //               does not already have.
+    // Expected:     The operation should be a success.  Specifically,
+    //               TaskStatus for any/all tasks as part of this assignment
+    //               should appear as "Complete".
+    #[test]
+    fn download() {
+        let test_server: TestServer = TestServer::new(router()).unwrap();
+        let v = post_assignments(&test_server, "test/agent/healthy");
+        monitor_assignments(&test_server, &v, TaskStatus::Complete);
+    }
+
+    // Test name:    Replace healthy
+    // Description:  First, download a known healthy file that the agent (may or
+    //               may not already have).  After successful completion of the
+    //               first download, repeat the process a second time with the
+    //               exact same assignment information.
+    // Expected:     TaskStatus for all tasks in all assignments should appear
+    //               as "Complete".
+    #[test]
+    fn replace_healthy() {
+        // Download a file once.
+        let test_server: TestServer = TestServer::new(router()).unwrap();
+        let v = post_assignments(&test_server, "test/agent/healthy");
+        monitor_assignments(&test_server, &v, TaskStatus::Complete);
+
+        // Download it again, but this time use the uuid to the database in
+        // /manta/rebalancer/uuid to make sure that the task status is complete
+        // after the second run.
+        let v = post_assignments(&test_server, "test/agent/healthy");
+        monitor_assignments(&test_server, &v, TaskStatus::Complete);
+    }
+
+    // Test name:   Replace damaged
+    // Description: Download a healthy file in order to replace a damaged file
+    //              on the agent.
+    // Expected:    TaskStatus for all tasks in all assignments should appear
+    //              as "Complete".
+    #[test]
+    fn replace_damaged() {
+
+    }
+}
diff --git a/src/jobs/mod.rs b/src/jobs/mod.rs
index a56de25..97f1f7a 100644
--- a/src/jobs/mod.rs
+++ b/src/jobs/mod.rs
@@ -110,7 +110,7 @@ impl Task {
     }
 }
 
-#[derive(Clone, Serialize, Deserialize, Debug)]
+#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
 pub enum TaskStatus {
     Pending,
     Running,
diff --git a/test/agent/files/area_codes_by_state.csv b/test/agent/files/area_codes_by_state.csv
new file mode 100644
index 0000000..1668c14
--- /dev/null
+++ b/test/agent/files/area_codes_by_state.csv
@@ -0,0 +1,284 @@
+Area code,State,State code
+201,New Jersey,NJ
+202,"Washington,DC",DC
+203,Connecticut,CT
+205,Alabama,AL
+206,Washington,WA
+207,Maine,ME
+208,Idaho,ID
+209,California,CA
+210,Texas,TX
+212,New York,NY
+213,California,CA
+214,Texas,TX
+215,Pennsylvania,PA
+216,Ohio,OH
+217,Illinois,IL
+218,Minnesota,MN
+219,Indiana,IN
+224,Illinois,IL
+225,Louisiana,LA
+227,Maryland,MD
+228,Mississippi,MS
+229,Georgia,GA
+231,Michigan,MI
+234,Ohio,OH
+239,Florida,FL
+240,Maryland,MD
+248,Michigan,MI
+251,Alabama,AL
+252,North Carolina,NC
+253,Washington,WA
+254,Texas,TX
+256,Alabama,AL
+260,Indiana,IN
+262,Wisconsin,WI
+267,Pennsylvania,PA
+269,Michigan,MI
+270,Kentucky,KY
+276,Virginia,VA
+281,Texas,TX
+283,Ohio,OH
+301,Maryland,MD
+302,Delaware,DE
+303,Colorado,CO
+304,West Virginia,WV
+305,Florida,FL
+307,Wyoming,WY
+308,Nebraska,NE
+309,Illinois,IL
+310,California,CA
+312,Illinois,IL
+313,Michigan,MI
+314,Missouri,MO
+315,New York,NY
+316,Kansas,KS
+317,Indiana,IN
+318,Louisiana,LA
+319,Iowa,IA
+320,Minnesota,MN
+321,Florida,FL
+323,California,CA
+330,Ohio,OH
+331,Illinois,IL
+334,Alabama,AL
+336,North Carolina,NC
+337,Louisiana,LA
+339,Massachusetts,MA
+347,New York,NY
+351,Massachusetts,MA
+352,Florida,FL
+360,Washington,WA
+361,Texas,TX
+386,Florida,FL
+401,Rhode Island,RI
+402,Nebraska,NE
+404,Georgia,GA
+405,Oklahoma,OK
+406,Montana,MT
+407,Florida,FL
+408,California,CA
+409,Texas,TX
+410,Maryland,MD
+412,Pennsylvania,PA
+413,Massachusetts,MA
+414,Wisconsin,WI
+415,California,CA
+417,Missouri,MO
+419,Ohio,OH
+423,Tennessee,TN
+424,California,CA
+425,Washington,WA
+434,Virginia,VA
+435,Utah,UT
+440,Ohio,OH
+443,Maryland,MD
+445,Pennsylvania,PA
+464,Illinois,IL
+469,Texas,TX
+470,Georgia,GA
+475,Connecticut,CT
+478,Georgia,GA
+479,Arkansas,AR
+480,Arizona,AZ
+484,Pennsylvania,PA
+501,Arkansas,AR
+502,Kentucky,KY
+503,Oregon,OR
+504,Louisiana,LA
+505,New Mexico,NM
+507,Minnesota,MN
+508,Massachusetts,MA
+509,Washington,WA
+510,California,CA
+512,Texas,TX
+513,Ohio,OH
+515,Iowa,IA
+516,New York,NY
+517,Michigan,MI
+518,New York,NY
+520,Arizona,AZ
+530,California,CA
+540,Virginia,VA
+541,Oregon,OR
+551,New Jersey,NJ
+557,Missouri,MO
+559,California,CA
+561,Florida,FL
+562,California,CA
+563,Iowa,IA
+564,Washington,WA
+567,Ohio,OH
+570,Pennsylvania,PA
+571,Virginia,VA
+573,Missouri,MO
+574,Indiana,IN
+580,Oklahoma,OK
+585,New York,NY
+586,Michigan,MI
+601,Mississippi,MS
+602,Arizona,AZ
+603,New Hampshire,NH
+605,South Dakota,SD
+606,Kentucky,KY
+607,New York,NY
+608,Wisconsin,WI
+609,New Jersey,NJ
+610,Pennsylvania,PA
+612,Minnesota,MN
+614,Ohio,OH
+615,Tennessee,TN
+616,Michigan,MI
+617,Massachusetts,MA
+618,Illinois,IL
+619,California,CA
+620,Kansas,KS
+623,Arizona,AZ
+626,California,CA
+630,Illinois,IL
+631,New York,NY
+636,Missouri,MO
+641,Iowa,IA
+646,New York,NY
+650,California,CA
+651,Minnesota,MN
+660,Missouri,MO
+661,California,CA
+662,Mississippi,MS
+667,Maryland,MD
+678,Georgia,GA
+682,Texas,TX
+701,North Dakota,ND
+702,Nevada,NV
+703,Virginia,VA
+704,North Carolina,NC
+706,Georgia,GA
+707,California,CA
+708,Illinois,IL
+712,Iowa,IA
+713,Texas,TX
+714,California,CA
+715,Wisconsin,WI
+716,New York,NY
+717,Pennsylvania,PA
+718,New York,NY
+719,Colorado,CO
+720,Colorado,CO
+724,Pennsylvania,PA
+727,Florida,FL
+731,Tennessee,TN
+732,New Jersey,NJ
+734,Michigan,MI
+737,Texas,TX
+740,Ohio,OH
+754,Florida,FL
+757,Virginia,VA
+760,California,CA
+763,Minnesota,MN
+765,Indiana,IN
+770,Georgia,GA
+772,Florida,FL
+773,Illinois,IL
+774,Massachusetts,MA
+775,Nevada,NV
+781,Massachusetts,MA
+785,Kansas,KS
+786,Florida,FL
+801,Utah,UT
+802,Vermont,VT
+803,South Carolina,SC
+804,Virginia,VA
+805,California,CA
+806,Texas,TX
+808,Hawaii,HI
+810,Michigan,MI
+812,Indiana,IN
+813,Florida,FL
+814,Pennsylvania,PA
+815,Illinois,IL
+816,Missouri,MO
+817,Texas,TX
+818,California,CA
+828,North Carolina,NC
+830,Texas,TX
+831,California,CA
+832,Texas,TX
+835,Pennsylvania,PA
+843,South Carolina,SC
+845,New York,NY
+847,Illinois,IL
+848,New Jersey,NJ
+850,Florida,FL
+856,New Jersey,NJ
+857,Massachusetts,MA
+858,California,CA
+859,Kentucky,KY
+860,Connecticut,CT
+862,New Jersey,NJ
+863,Florida,FL
+864,South Carolina,SC
+865,Tennessee,TN
+870,Arkansas,AR
+872,Illinois,IL
+878,Pennsylvania,PA
+901,Tennessee,TN
+903,Texas,TX
+904,Florida,FL
+906,Michigan,MI
+907,Alaska,AK
+908,New Jersey,NJ
+909,California,CA
+910,North Carolina,NC
+912,Georgia,GA
+913,Kansas,KS
+914,New York,NY
+915,Texas,TX
+916,California,CA
+917,New York,NY
+918,Oklahoma,OK
+919,North Carolina,NC
+920,Wisconsin,WI
+925,California,CA
+928,Arizona,AZ
+931,Tennessee,TN
+936,Texas,TX
+937,Ohio,OH
+940,Texas,TX
+941,Florida,FL
+947,Michigan,MI
+949,California,CA
+952,Minnesota,MN
+954,Florida,FL
+956,Texas,TX
+959,Connecticut,CT
+970,Colorado,CO
+971,Oregon,OR
+972,Texas,TX
+973,New Jersey,NJ
+975,Missouri,MO
+978,Massachusetts,MA
+979,Texas,TX
+980,North Carolina,NC
+984,North Carolina,NC
+985,Louisiana,LA
+989,Michigan,MI
diff --git a/test/agent/test_init.sh b/test/agent/test_init.sh
new file mode 100755
index 0000000..5025092
--- /dev/null
+++ b/test/agent/test_init.sh
@@ -0,0 +1,164 @@
+#!/bin/bash
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright 2019, Joyent, Inc.
+#
+
+#
+# This is a utility intended to automate an appreciable amount of the laborious
+# work required to set up a test enviornment to test the rebalancer agent.  It
+# requires two arguments to get started:
+#
+# 1. The destination storage node on which object will reside in the form of
+#    n.stor.<domain>.  An example would look like: 2.stor.us-west.joyent.us.
+#
+# 2. A path which contains one or more files that the rebalaner agent will
+#    attempt to download during a test.
+#
+# With the provided storage node information and a file path, this utility will
+# create an assignment based on this information and store it in a database
+# which the rebalancer agent will be able to load from disk and process like an
+# assignment that it would receive from a rebalancer zone.  In addition to
+# creating the assignment, it will also upload the objects to the destination
+# storage node (i.e. #1 above), where they will be stored in /manta/rebalancer.
+# The upload is performed via the http PUT interface supplied to us by mako.
+#
+
+uuid=$(uuid)
+files_dir="files"
+account="rebalancer"
+storage_id="${1}"
+
+if [[ -n "$TRACE" ]]; then
+    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
+    set -o xtrace
+fi
+set -o errexit
+set -o pipefail
+
+function fatal
+{
+	local LNOW=`date`
+	echo "$LNOW: $(basename $0): fatal error: $*" >&2
+	exit 1
+}
+
+function string_to_hex()
+{
+    if [[ -z "$1" ]]; then
+        fatal "No string was provided to string_to_hex()."
+    fi
+
+    echo -n "$1" | od -A n -t x1 |sed 's/ *//g' | tr -d '\n'
+}
+
+# Wrapper for the sqlite3 client.  Any failure of the sqlite3
+# client along the way should bring this process to an immedaite
+# halt, so rather than having the scaffolding of checking the
+# return status of the operation, we wrap it up with the call
+# to sqlite3 itself.
+function sqlite_exec()
+{
+    db="$1"
+    query="$2"
+
+    if [[ -z "$db" || -z "$query" ]]; then
+        fatal "insert_task() requires 2 arguments."
+    fi
+
+    sqlite3 "$db" "$query"
+
+    if [[ $? -ne 0 ]]; then
+        fatal "Failed to execute $query on $db"
+    fi
+}
+
+# Given the the name of a database and the location of a file, genereate the
+# associated task information for it and insert it in to the local database.
+# The tasks table will eventually be recalled by the rebalancer test automation
+# code and processed.
+function insert_task()
+{
+    db="$1"
+    path="$2"
+    object="$(basename $2)"
+    md5sum="$(cat $path | openssl dgst -md5 -binary | base64)"
+    status=$(string_to_hex '"Pending"')
+
+    if [[ -z "$db" || -z "$path" ]]; then
+        fatal "insert_task() requires 2 arguments."
+    fi
+
+    query=$(echo "INSERT INTO tasks " \
+        "(object_id, owner, md5sum, datacenter, manta_storage_id, status) " \
+        "VALUES " \
+        "('$object', '$account', '$md5sum', 'dc', '$storage_id', X'$status');")
+
+    sqlite_exec "$db" "$query"
+}
+
+# Create a database which will be used by the rebalancer test automation.  The
+# database will represent a single assignment.  The database representation of
+# an assignment in the rebalancer is comprised of two tables: A tasks table,
+# which contains some number of tasks (objects to download and their associated
+# location information within manta and a stats table.  The stats table contains
+# one single serialized entry which the agent loads in to memory and updates
+# as it processes tasks.
+function create_db()
+{
+    db="$1"
+
+    if [[ -z "$db" ]]; then
+        fatal "create_db() requires a name."
+    fi
+
+    # Create a table for the tasks
+    query="CREATE TABLE tasks (
+        object_id text primary key not null unique,
+        owner text not null,
+        md5sum text not null,
+        datacenter text not null,
+        manta_storage_id text not null,
+        status text not null);"
+    sqlite_exec "$db" "$query"
+
+    # Create a table for stats
+    query="CREATE TABLE stats (stats text not null);"
+    sqlite_exec "$db" "$query"
+
+    # Initialize the single stats structure that goes in to
+    # the stats table.
+    total=$(ls $files_dir | wc -l)
+    tsobj=$(echo "{}" | json -e "\
+        this.state = '"Scheduled"';
+        this.failed = 0;
+        this.complete = 0;
+        this.total = ${total};" | json -o json-0)
+
+    # Convert the json object to hex so that serde_json is able
+    # to make sense of it upon reading it in.
+    tsobjx=$(string_to_hex $tsobj)
+
+    # Finally, insert the stats structure in to the stats table.
+    query=$(echo "INSERT INTO stats VALUES(X'${tsobjx}');")
+    sqlite_exec "$db" "$query"
+}
+
+echo $uuid
+create_db "$uuid"
+
+for i in $files_dir/*
+do
+    insert_task "$uuid" "$i"
+
+    curl -X PUT -T $i "http://$storage_id/$account/$(basename $i)"
+
+    if [[ $? -ne 0 ]]; then
+        fatal "Failed to upload object $i to storage node $storage_id"
+    fi
+done
-- 
2.21.0

