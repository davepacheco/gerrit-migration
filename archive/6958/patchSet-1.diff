From b541858e4012bab3ddf176993d153f4b87f016cd Mon Sep 17 00:00:00 2001
From: Todd Whiteman <todd.whiteman@joyent.com>
Date: Mon, 7 Oct 2019 12:38:22 -0700
Subject: [PATCH] TRITON-1903 allow bhyve resize

---
 docs/index.md                 |  15 +-
 lib/apis/wfapi.js             |   3 +-
 lib/common/validation.js      | 183 +++++++++--
 lib/errors.js                 |  10 +-
 lib/vm-migration/migrate.js   |   8 +-
 package.json                  |   2 +-
 test/vms.full.test.js         | 257 ---------------
 test/vms.resize.bhyve.test.js | 470 ++++++++++++++++++++++++++++
 test/vms.resize.test.js       | 378 ++++++++++++++++++++++
 test/vms.validate.test.js     | 569 +++++++++++++++++++++++++++++++++-
 10 files changed, 1595 insertions(+), 300 deletions(-)
 create mode 100644 test/vms.resize.bhyve.test.js
 create mode 100644 test/vms.resize.test.js

diff --git a/docs/index.md b/docs/index.md
index 77f38a2..4cf5fd7 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -10,7 +10,7 @@ markdown2extras: tables, code-friendly
 -->
 
 <!--
-    Copyright (c) 2019, Joyent, Inc.
+    Copyright 2019 Joyent, Inc.
 -->
 
 # Introduction to VMs API
@@ -298,13 +298,16 @@ Since resizing a VM might cause unwanted effects depending on the current
 resources being utilized on the machine, this feature is only partially
 supported at the moment. For more information about how to resize a VM please
 refer to the [UpdateVm](#UpdateVm) section of this document. The following table
-describes the current resize support for KVM and OS VMs. Upsizing means when
-some VM attributes are increased and downsizing refers to the opposite.
+describes the current resize support. Upsizing means when some VM attributes
+are increased and downsizing refers to the opposite.
 
 | VM Type | Upsize        | Downsize      |
 | ------- | ------------- | ------------- |
-| KVM     | Not supported | Not supported |
 | OS      | Supported     | Supported     |
+| docker  | Supported     | Supported     |
+| lx      | Supported     | Supported     |
+| bhyve   | Supported     | Supported     |
+| KVM     | Not supported | Not supported |
 
 ## Delegate Dataset
 
@@ -1306,7 +1309,7 @@ Image UUID is a required input for reprovisioning a VM.
 
 ## UpdateVm (POST /vms/:uuid?action=update)
 
-Similar to CreateVm, this endpoint allows udpating a VM to a new SDC Package. Individual SDC Package related attributes can still be provided if one needs to override specific values. **UpdateVm is only supported for OS VMs**. See
+Similar to CreateVm, this endpoint allows updating a VM to a new SDC Package. Individual SDC Package related attributes can still be provided if one needs to override specific values. **UpdateVm is only supported for OS VMs**. See
 [VM Resize](#vm-resize) for more information.
 
 ### Updating VM to an SDC Package
@@ -1344,6 +1347,7 @@ In addition to 'billing_id', the following values can be specified to update add
 | cpu_cap                   | Number                        | CPU Cap                                                                                  |
 | max_lwps                  | Number                        | Max. Lightweight Processes                                                               |
 | quota (GiB)               | Number                        | VM quota (disk)                                                                          |
+| flexible_disk_size (MiB)  | Number                        | Total allowed VM disk space (Bhyve only)                                                 |
 | tags                      | Object                        | VM tags                                                                                  |
 | customer_metadata         | Object                        | VM metadata                                                                              |
 | internal_metadata         | Object                        | VM metadata                                                                              |
@@ -2411,6 +2415,7 @@ the source vm was originally running).
 
 This action is only actionable when migration sync is running. It is used to
 stop the migration sync operation and place the migration into a paused state.
+ze
 
 ### Migrate Abort
 
diff --git a/lib/apis/wfapi.js b/lib/apis/wfapi.js
index 7688bf9..51a8669 100644
--- a/lib/apis/wfapi.js
+++ b/lib/apis/wfapi.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -15,7 +15,6 @@
 var assert = require('assert-plus');
 var async = require('async');
 var sprintf = require('sprintf').sprintf;
-var uuid = require('libuuid');
 var WfClient = require('wf-client');
 var jsprim = require('jsprim');
 
diff --git a/lib/common/validation.js b/lib/common/validation.js
index be69401..a32d560 100644
--- a/lib/common/validation.js
+++ b/lib/common/validation.js
@@ -17,12 +17,12 @@ var assert = require('assert-plus');
 var async = require('async');
 var format = require('util').format;
 var jsprim = require('jsprim');
-var libuuid = require('libuuid');
 var net = require('net');
 var restify = require('restify');
 var strsplit = require('strsplit');
 var tritonTags = require('triton-tags');
 var util = require('util');
+var uuid = require('uuid');
 var verror = require('verror');
 
 var common = require('./vm-common');
@@ -686,8 +686,8 @@ function createValidateJSONPredicateFn(field, options) {
 /*
  * Validates if a string is a UUID
  */
-function validUUID(uuid) {
-    return UUID_RE.test(uuid);
+function validUUID(theUuid) {
+    return UUID_RE.test(theUuid);
 }
 exports.validUUID = validUUID;
 
@@ -1066,8 +1066,10 @@ exports._safeBrandName = safeBrandName;
  */
 function validatePackageValues(papi, params, errs, callback) {
     assert.uuid(params.billing_id, 'params.billing_id');
+    assert.string(params.brand, 'params.brand');
     assert.array(errs, 'errs');
 
+    var isBhyveOrKvm = (['bhyve', 'kvm'].indexOf(params.brand) !== -1);
     var packageFields = ['cpu_cap', 'max_lwps', 'max_physical_memory',
         'max_swap', 'quota', 'vcpus', 'zfs_io_priority'];
 
@@ -1099,14 +1101,19 @@ function validatePackageValues(papi, params, errs, callback) {
         packageFields.forEach(function (field) {
             if (params[field] === undefined && pkg[field] !== undefined) {
                 if (field === 'quota') {
-                    if (['bhyve', 'kvm'].indexOf(params.brand) !== -1) {
+                    if (isBhyveOrKvm) {
+                        params.quota = 10;
                         if (params.brand === 'bhyve' && pkg.flexible_disk) {
                             params.flexible_disk_size = Number(pkg.quota);
+                            // Do not set 'quota' for flexible disks.
+                            delete params.quota;
                         }
-                        params.quota = 10;
                     } else {
                         params.quota = Number(pkg.quota) / 1024;
                     }
+                // KVM and bhyve prefer 'ram' instead of 'max_physical_memory'.
+                } else if (isBhyveOrKvm && field === 'max_physical_memory') {
+                    params.ram = pkg[field];
                 } else {
                    params[field] = Number(pkg[field]);
                 }
@@ -1117,7 +1124,11 @@ function validatePackageValues(papi, params, errs, callback) {
         var pkgRam = pkg.max_physical_memory;
         if (pkgRam !== undefined) {
             if (params.max_physical_memory === undefined) {
-                params.max_physical_memory = Number(pkgRam);
+                if (isBhyveOrKvm) {
+                    params.ram = Number(pkgRam);
+                } else {
+                    params.max_physical_memory = Number(pkgRam);
+                }
             } else if (params.ram === undefined) {
                 params.ram = Number(pkgRam);
             }
@@ -1431,17 +1442,24 @@ exports.validateUpdateVmParams = function (vmapi, vm, obj, callback) {
     if (params.alias) {
         asyncFns.push(validateAlias);
     }
+    if (vm.brand === 'bhyve') {
+        asyncFns.push(convertMaxPhysicalMemoryToRam);
+    }
     if (params.billing_id) {
         asyncFns.push(validatePackage);
     }
     if (params.subtask === 'resize') {
-        if (['bhyve', 'kvm'].indexOf(vm.brand) === -1) {
-            asyncFns.push(validateResize);
-            asyncFns.push(validateCapacity);
-        } else {
-            // Not allowed for bhyve or kvm at the moment
+        if (vm.brand === 'kvm') {
+            // Not allowed for kvm at the moment
             errs.push(errors.invalidParamErrorsElem('brand',
                 'Cannot resize a ' + vm.brand + ' VM'));
+        } else {
+            asyncFns.push(validateImageConstraints);
+            asyncFns.push(validateCapacity);
+        }
+        if (vm.brand === 'bhyve') {
+            asyncFns.push(validateBhyveFlexibleDiskPackage);
+            asyncFns.push(validateBhyveStopped);
         }
     }
 
@@ -1457,20 +1475,46 @@ exports.validateUpdateVmParams = function (vmapi, vm, obj, callback) {
         });
     }
 
+    function convertMaxPhysicalMemoryToRam(next) {
+        assert.equal(vm.brand, 'bhyve', 'Should only be called for bhyve');
+        // Change max_physical_memory into ram.
+        if (params.max_physical_memory) {
+            params.ram = params.max_physical_memory;
+            delete params.max_physical_memory;
+        }
+        next();
+    }
+
     function validatePackage(next) {
+        // Add brand to params, as it is needed when the package has a brand
+        // value set.
+        params.brand = vm.brand;
+        // Note that validatePackageValues has a side affect of loading the
+        // package into params.package.
         validatePackageValues(vmapi.papi, params, errs, next);
     }
 
-    function validateResize(next) {
-        // First get image from IMGAPI and resort to CNAPI if the image omly
+    function validateImageConstraints(next) {
+        // First get image from IMGAPI and resort to CNAPI if the image only
         // exists in the server. This can be the case for customer created
-        // images that can be deleted from the IMGAPI repository
-        vmapi.imgapi.getImage(vm.image_uuid, function (err, image) {
+        // images that can be deleted from the IMGAPI repository.
+        var image_uuid = vm.image_uuid;
+        if (['bhyve', 'kvm'].indexOf(vm.brand) !== -1) {
+            image_uuid = vm.disks && vm.disks[0] && vm.disks[0].image_uuid;
+        }
+        if (!image_uuid) {
+            errs.push(errors.invalidParamErrorsElem(
+                'VM is missing an image_uuid'));
+            next();
+            return;
+        }
+
+        vmapi.imgapi.getImage(image_uuid, function (err, image) {
             if (err) {
                 if (verror.hasCauseWithName(err, 'ResourceNotFoundError')) {
                     return vmapi.cnapi.getImage(
                         vm.server_uuid,
-                        vm.image_uuid,
+                        image_uuid,
                         onImage);
                 } else {
                     return next(err);
@@ -1526,6 +1570,17 @@ exports.validateUpdateVmParams = function (vmapi, vm, obj, callback) {
         var currentDisk = vm.quota;
         var requiredDisk = params.quota;
 
+        // Flexible disks do not use quota, they use the 'flexible_disk_size'
+        // property instead, but we must also allow resizing from a vm that
+        // doesn't yet use flexible disk (i.e. it still uses quota). Note also
+        // that vm.quota uses GiB and vm.flexible_disk_size uses MiB!
+        if (vm.brand === 'bhyve' && params.flexible_disk_size) {
+            requiredDisk = params.flexible_disk_size / 1024;
+            if (vm.flexible_disk_size) {
+                currentDisk = vm.flexible_disk_size / 1024;
+            }
+        }
+
         vmapi.cnapi.capacity([ vm.server_uuid ], function (err, cap) {
             if (err) {
                 return next(err);
@@ -1545,7 +1600,7 @@ exports.validateUpdateVmParams = function (vmapi, vm, obj, callback) {
             }
 
             var sram = cap.capacities[vm.server_uuid].ram;
-            var sdisk = cap.capacities[vm.server_uuid].disk / 1024;
+            var sdisk = Math.floor(cap.capacities[vm.server_uuid].disk / 1024);
 
             if (currentRam < requiredRam && sram < neededRam) {
                 errs.push(errors.insufficientCapacityErrorsElem(
@@ -1583,6 +1638,93 @@ exports.validateUpdateVmParams = function (vmapi, vm, obj, callback) {
         });
     }
 
+    // Bhyve cannot change from a flex disk package to one without flex disk.
+    function validateBhyveFlexibleDiskPackage(next) {
+        assert.equal(vm.brand, 'bhyve', 'Should only be called for bhyve vms');
+
+        // Note: params.package gets side-loaded by the validatePackageValues
+        // call.
+        var flexible_disk_size = params.flexible_disk_size ||
+            (params.package && params.package.flexible_disk &&
+            params.package.quota);
+
+        if (!vm.flexible_disk_size) {
+            // Instances that do not already use flexible disk can only be
+            // resized if they are moving to use flexible disk (either via the
+            // package or via the flexible_disk_size param).
+            if (!flexible_disk_size) {
+                next(new errors.ValidationFailedError('Cannot resize bhyve ' +
+                    'instance to a package that does not use flexible disk',
+                    [ errors.invalidParamErrorsElem('flexible_disk_size') ]));
+                return;
+            }
+
+        } else if (params.package && !params.package.flexible_disk) {
+            next(new errors.ValidationFailedError('Cannot resize bhyve ' +
+                'instance to a package that does not use flexible disk',
+                [ errors.invalidParamErrorsElem('billing_id') ]));
+            return;
+        }
+
+        // Validate that the current disk size(s) do not exceed the total
+        // flexible_disk_size.
+        var totalDiskSizeMb = vm.disks.map(
+            function (disk) {
+                return disk.size || 0;
+            }).reduce(function (size, runningTotal) {
+                return size + runningTotal;
+            }, 0);
+        // Add snapshot sizes.
+        totalDiskSizeMb += (vm.snapshots || []).map(
+            function (snap) {
+                return snap.size || 0;
+            }).reduce(function (size, runningTotal) {
+                return size + runningTotal;
+            }, 0);
+        // Round up to the nearest whole number.
+        totalDiskSizeMb = Math.ceil(totalDiskSizeMb);
+
+        if (totalDiskSizeMb > flexible_disk_size) {
+            next(new errors.ValidationFailedError('Cannot resize bhyve ' +
+                'instance, existing disk usage (' + totalDiskSizeMb +
+                ') exceeds the flexible disk size (' +
+                flexible_disk_size + ')',
+                [ errors.invalidParamErrorsElem('flexible_disk_size') ]));
+            return;
+        }
+
+        next();
+    }
+
+    // If changing the amount of CPU, or changing the amount of memory in a
+    // bhyve instance, then ensure the instance is stopped.
+    function validateBhyveStopped(next) {
+        assert.equal(vm.brand, 'bhyve', 'Should only be called for bhyve vms');
+
+        if (vm.state === 'stopped') {
+            next();
+            return;
+        }
+
+        var cpuAndMemFields = ['cpu_cap', 'max_lwps', 'ram',
+            'max_swap', 'vcpus', 'zfs_io_priority'];
+
+        if (cpuAndMemFields.some(
+            function (field) {
+                if (params[field] === undefined) {
+                    return false;
+                }
+                return params[field] !== vm[field];
+            }))
+        {
+            next(new errors.VmNotStoppedError('changing bhyve CPU or memory ' +
+                'requires the instance to be stopped'));
+            return;
+        }
+
+        next();
+    }
+
     async.series(asyncFns, function (err) {
         if (err) {
             return callback(err);
@@ -1743,7 +1885,7 @@ function isPrimary(prm) {
 function validNetworks(object, isProvision) {
     var networks = [];
     var primaries = 0;
-    var array, obj, uuid;
+    var array, obj;
 
     if (Array.isArray(object)) {
         array = object;
@@ -1758,8 +1900,7 @@ function validNetworks(object, isProvision) {
 
         // See history of types up above
         if (typeof (obj) === 'string') {
-            uuid = obj;
-            obj = { ipv4_uuid: uuid, ipv4_count: 1 };
+            obj = { ipv4_uuid: obj, ipv4_count: 1 };
         } else {
             if (isPrimary(obj.primary)) {
                 primaries++;
@@ -2518,7 +2659,7 @@ exports.setDefaultValues = function (params, options) {
     }
 
     if (params.uuid === undefined) {
-        params.uuid = libuuid.create();
+        params.uuid = uuid.v4();
     }
 
     if (params.ram) {
diff --git a/lib/errors.js b/lib/errors.js
index c3a7575..4c8da26 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -70,14 +70,18 @@ VmNotRunningError.statusCode = 409;
  *  Return this error when we try to do something that only makes sense on a
  *  stopped container.
  */
-function VmNotStoppedError() {
+function VmNotStoppedError(desc) {
+    var message = 'VM not stopped';
+    if (desc) {
+        message += ': ' + desc;
+    }
     restify.RestError.call(this, {
         restCode: this.constructor.restCode,
         statusCode: this.constructor.statusCode,
-        message: 'VM not stopped',
+        message: message,
         body: {
             code: this.constructor.restCode,
-            message: 'VM not stopped'
+            message: message
         }
     });
 }
diff --git a/lib/vm-migration/migrate.js b/lib/vm-migration/migrate.js
index 06caae1..bee9feb 100644
--- a/lib/vm-migration/migrate.js
+++ b/lib/vm-migration/migrate.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -16,11 +16,11 @@ var fs = require('fs');
 var util = require('util');
 
 var assert = require('assert-plus');
-var libuuid = require('libuuid');
 var restify = require('restify');
+var uuid = require('uuid');
 var vasync = require('vasync');
-var common = require('../common');
 
+var common = require('../common');
 var errors = require('../errors');
 
 var format = util.format;
@@ -672,7 +672,7 @@ function migrateVm(req, res, next) {
                     action: action,
                     automatic: automatic,
                     created_timestamp: (new Date()).toISOString(),
-                    id: libuuid.create(),
+                    id: uuid.v4(),
                     num_sync_phases: 0,
                     owner_uuid: req.params.owner_uuid,
                     phase: 'begin',
diff --git a/package.json b/package.json
index d5d1ec1..f87dbd1 100644
--- a/package.json
+++ b/package.json
@@ -17,7 +17,6 @@
     "jsprim": "^1.2.2",
     "krill": "1.0.1",
     "ldap-filter": "0.3.3",
-    "libuuid": "0.2.1",
     "moray": "3.1.1",
     "once": "^1.3.3",
     "restify": "4.3.0",
@@ -28,6 +27,7 @@
     "trace-event": "1.3.0",
     "triton-metrics": "0.1.1",
     "triton-tags": "1.3.0",
+    "uuid": "3.3.3",
     "vasync": "2.2.0",
     "verror": "1.10.0",
     "wf-client": "0.3.1"
diff --git a/test/vms.full.test.js b/test/vms.full.test.js
index f0b44f2..f98a469 100644
--- a/test/vms.full.test.js
+++ b/test/vms.full.test.js
@@ -2328,263 +2328,6 @@ exports.wait_destroyed_vm_from_existing_nics = function (t) {
 };
 
 
-exports.create_vm_with_package = function (t) {
-    var vm = {
-        owner_uuid: CUSTOMER,
-        image_uuid: IMAGE,
-        networks: [ { uuid: ADMIN_NETWORK.uuid } ],
-        brand: 'joyent-minimal',
-        billing_id: pkgId
-    };
-
-    var opts = createOpts('/vms', vm);
-
-    client.post(opts, vm, function (err, req, res, body) {
-          common.ifError(t, err);
-          t.equal(res.statusCode, 202, '202 Accepted');
-          common.checkHeaders(t, res.headers);
-          t.ok(body, 'vm ok');
-          jobLocation = '/jobs/' + body.job_uuid;
-          t.ok(true, 'jobLocation: ' + jobLocation);
-          newUuid = body.vm_uuid;
-          vmLocation = '/vms/' + newUuid;
-          t.done();
-    });
-};
-
-
-exports.wait_provisioned_with_package_job = function (t) {
-    waitForValue(jobLocation, 'execution', 'succeeded', {
-        client: client
-    }, function (err) {
-        common.ifError(t, err);
-        t.done();
-    });
-};
-
-
-//
-// If there's not enough spare RAM on a server, and we're resizing upwards, we
-// want the provision to fail. Failure should be the normal case for this
-// feature, since ideally it will never work if we've done a good job of packing
-// VMs.
-//
-exports.resize_package_up_fail = function (t) {
-    //
-    // NOTE: VM should have been created by:
-    //
-    // create_vm_with_package
-    //
-    // above which uses 'pkgId' set by:
-    //
-    // filter_vms_ok
-    //
-    // To the package of the first VM it could find with 128M of "ram".
-    // So the VM should exist and be using 128M of DRAM.
-    //
-
-    var largeRamValue = // value is in MiB, so:
-            10 * 1024 * // 10 EiB should be enough for anyone
-            1024 *      // PiB
-            1024 *      // TiB
-            1024;       // GiB
-    var largeQuotaValue = largeRamValue * 1024; // EiB->ZiB
-    var pkgName = 'ginormous-vmapi-test-10EiB';
-
-    vasync.pipeline({
-        arg: {},
-        funcs: [
-            function _createGinormousPackage(ctx, cb) {
-                client.papi.post('/packages', {
-                    active: true,
-                    cpu_cap: 10000,
-                    description:
-                        'Very large test package for VMAPI\'s vms.full.test.js',
-                    max_lwps: 30000,
-                    max_physical_memory: largeRamValue,
-                    max_swap: largeRamValue,
-                    name: pkgName,
-                    quota: largeQuotaValue,
-                    version: '1.0.0',
-                    vcpus: 32, // the largest papi currently allows LOL
-                    zfs_io_priority: 16383 // also largest papi currently allows
-                }, function _onPost(err, req, res, body) {
-                    common.ifError(t, err, 'POST ginormous package to PAPI');
-
-                    if (!err) {
-                        t.ok(body.uuid, 'created package uuid: ' + body.uuid);
-                        t.equal(pkgName, body.name,
-                            'response should be our fresh package');
-                        ctx.pkgUuid = body.uuid;
-                    }
-
-                    cb(err);
-                });
-            }, function _resizeToGinormous(ctx, cb) {
-                var params = {
-                    action: 'update',
-                    billing_id: ctx.pkgUuid
-                };
-                var opts = createOpts(vmLocation, params);
-
-                client.post(opts, params,
-                    function _onPost(err, req, res, body) {
-
-                    var error;
-
-                    t.ok(err, 'expected error POSTing resize');
-                    t.equal(res.statusCode, 409, 'expected HTTP code 409');
-                    t.equal(body.code, 'ValidationFailed',
-                        'expected ValidationFailed error');
-                    t.equal(body.message, 'Invalid VM update parameters',
-                        'expected invalid update message');
-
-                    error = body.errors[0];
-                    t.equal(error.field, 'ram', 'error should be due to ram');
-                    t.equal(error.code, 'InsufficientCapacity',
-                        'error code should be InsufficientCapacity');
-                    t.ok(error.message.match(
-                        'Required additional RAM \\(\\d+\\) ' +
-                        'exceeds the server\'s available RAM \\(-?\\d+\\)'),
-                        'error message should explain additional RAM required');
-
-                    cb();
-                });
-            }, function _deleteGinormousPackage(ctx, cb) {
-                client.papi.del({
-                    path: '/packages/' + ctx.pkgUuid + '?force=true'
-                }, function _onDel(err, req, res, body) {
-                    common.ifError(t, err, 'DELETE created package');
-
-                    t.equal(204, res.statusCode, 'expected 204 from DELETE');
-                    t.ok(!err, 'expected no restCode' +
-                        (err ? 'got ' + err.restCode : ''));
-
-                    cb(err);
-                });
-            }
-        ]
-    }, function pipelineComplete(err) {
-        common.ifError(t, err, 'resize pipeline');
-        t.done();
-    });
-};
-
-
-exports.find_new_package_ok = function (t) {
-    var path = '/vms?ram=' + 256 + '&owner_uuid=' + CUSTOMER;
-
-    client.get(path, function (err, req, res, body) {
-        common.ifError(t, err);
-        t.equal(res.statusCode, 200, '200 OK');
-        common.checkHeaders(t, res.headers);
-        t.ok(res.headers['x-joyent-resource-count']);
-        t.ok(body, 'body is set');
-        t.ok(Array.isArray(body), 'body is Array');
-        t.ok(body.length > 0, 'body Array has more than 0 elements');
-        body.forEach(function (m) {
-            // Any non-null package works
-            if (m['billing_id'] &&
-                m['billing_id'] !== '00000000-0000-0000-0000-000000000000') {
-                pkgId = m['billing_id'];
-            }
-        });
-        t.done();
-    });
-};
-
-
-exports.resize_package = function (t) {
-    var params = { action: 'update', billing_id: pkgId };
-
-    var opts = createOpts(vmLocation + '?force=true', params);
-
-    client.post(opts, params, function (err, req, res, body) {
-        common.ifError(t, err);
-        t.equal(res.statusCode, 202, '202 Accepted');
-        jobLocation = '/jobs/' + body.job_uuid;
-        t.ok(true, 'jobLocation: ' + jobLocation);
-        t.done();
-    });
-};
-
-
-exports.wait_resize_package_job = function (t) {
-    waitForValue(jobLocation, 'execution', 'succeeded', {
-        client: client
-    }, function (err) {
-        common.ifError(t, err);
-        t.done();
-    });
-};
-
-
-// regardless of spare RAM on server, we always want resizing down to succeed
-exports.resize_package_down = function (t) {
-    var path = '/vms?ram=' + 128 + '&owner_uuid=' + CUSTOMER;
-    var smallerPkg;
-
-    client.get(path, function (err, req, res, body) {
-        common.ifError(t, err);
-        t.equal(res.statusCode, 200, '200 OK');
-        body.forEach(function (m) {
-            // Any non-null package works
-            if (m['billing_id'] &&
-                m['billing_id'] !== '00000000-0000-0000-0000-000000000000') {
-                smallerPkg = m['billing_id'];
-            }
-        });
-
-        var params = { action: 'update', billing_id: smallerPkg };
-
-        var opts = createOpts(vmLocation, params);
-
-        return client.post(opts, params, function (err2, req2, res2, body2) {
-            common.ifError(t, err2);
-            t.equal(res.statusCode, 200, '200 OK');
-            jobLocation = '/jobs/' + body2.job_uuid;
-            t.ok(true, 'jobLocation: ' + jobLocation);
-            t.done();
-        });
-    });
-};
-
-
-exports.wait_resize_package_job_2 = function (t) {
-    waitForValue(jobLocation, 'execution', 'succeeded', {
-        client: client
-    }, function (err) {
-        common.ifError(t, err);
-        t.done();
-    });
-};
-
-
-exports.destroy_vm_with_package = function (t) {
-    var opts = createOpts(vmLocation);
-
-    client.del(opts, function (err, req, res, body) {
-        common.ifError(t, err);
-        t.equal(res.statusCode, 202, '202 Accepted');
-        common.checkHeaders(t, res.headers);
-        t.ok(body, 'body is set');
-        jobLocation = '/jobs/' + body.job_uuid;
-        t.ok(true, 'jobLocation: ' + jobLocation);
-        t.done();
-    });
-};
-
-
-exports.wait_destroyed_with_package_job = function (t) {
-    waitForValue(jobLocation, 'execution', 'succeeded', {
-        client: client
-    }, function (err) {
-        common.ifError(t, err);
-        t.done();
-    });
-};
-
-
 exports.provision_network_names = function (t) {
     var vm = {
         owner_uuid: CUSTOMER,
diff --git a/test/vms.resize.bhyve.test.js b/test/vms.resize.bhyve.test.js
new file mode 100644
index 0000000..f2fa3c9
--- /dev/null
+++ b/test/vms.resize.bhyve.test.js
@@ -0,0 +1,470 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+// Test bhyve (regular and flexible disk) instance resizing.
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var uuid = require('uuid');
+
+var common = require('./common');
+
+
+// --- Globals
+
+var client;
+var pkgGinormous;
+var pkgSample1G;
+var pkgSampleSmallBhyveFlex;
+var pkgSampleBhyveFlex;
+var vmLocation;
+
+var ADMIN_NETWORK = null;
+var EXTERNAL_NETWORK = null;
+var CUSTOMER = common.config.ufdsAdminUuid;
+var IMAGE = '616c7421-4b9a-49fe-989e-81eb19232b87'; // ubuntu-certified-16.04
+var PACKAGE_NAME_SAMPLE_1G = 'sample-1G';
+var PACKAGE_NAME_SAMPLE_BHYVE_FLEX_1G_SMALL = 'sample-bhyve-flexible-1G';
+var PACKAGE_NAME_SAMPLE_BHYVE_FLEX_1G = 'sample-bhyve-reserved-snapshots-space';
+
+var CALLER = {
+    type: 'signature',
+    ip: '127.0.0.68',
+    keyId: '/foo@joyent.com/keys/id_rsa'
+};
+
+
+// --- Helpers
+
+function createOpts(path, params) {
+    return {
+        path: path,
+        headers: {
+            'x-request-id': uuid.v4(),
+            'x-context': JSON.stringify({
+                caller: CALLER,
+                params: params || {}
+            })
+        }
+    };
+}
+
+
+// --- Tests
+
+exports.setUp = function (callback) {
+    common.setUp(function (err, _client) {
+        assert.ifError(err);
+        assert.ok(_client, 'restify client');
+        client = _client;
+        callback();
+    });
+};
+
+
+// Other tests depend on there being both an 'admin' and 'external' network.
+// This test loads these and ensures we have both.
+exports.fetch_napi_networks = function (t) {
+    client.napi.get('/networks', function (err, req, res, networks) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 200, '200 OK');
+        t.ok(networks, 'networks is set');
+        t.ok(Array.isArray(networks), 'networks is Array');
+        t.ok(networks.length > 1, 'more than 1 network found');
+        var adminExtNetworks = common.extractAdminAndExternalNetwork(networks);
+        ADMIN_NETWORK = adminExtNetworks.admin;
+        EXTERNAL_NETWORK = adminExtNetworks.external;
+        t.ok(ADMIN_NETWORK, 'admin network is ' +
+            (ADMIN_NETWORK ? ADMIN_NETWORK.uuid : ADMIN_NETWORK));
+        t.ok(EXTERNAL_NETWORK, 'external network is ' +
+            (EXTERNAL_NETWORK ? EXTERNAL_NETWORK.uuid : EXTERNAL_NETWORK));
+        t.done();
+    });
+};
+
+exports.find_sample_1g_package = function (t) {
+    client.papi.get('/packages?name=' + PACKAGE_NAME_SAMPLE_1G + '&active=true',
+            function getPackages(err, req, res, packages) {
+        common.ifError(t, err, 'getting packages');
+        if (err) {
+            t.done();
+            return;
+        }
+
+        t.ok(packages.length > 0, 'found package named: ' +
+            PACKAGE_NAME_SAMPLE_1G);
+        if (packages.length > 0) {
+            pkgSample1G = packages[0];
+        }
+
+        t.done();
+    });
+};
+
+exports.find_small_flexible_disk_package = function (t) {
+    client.papi.get('/packages?name=' +
+            PACKAGE_NAME_SAMPLE_BHYVE_FLEX_1G_SMALL + '&active=true',
+            function getPackages(err, req, res, packages) {
+        common.ifError(t, err, 'getting packages');
+        if (err) {
+            t.done();
+            return;
+        }
+
+        t.ok(packages.length > 0, 'found package named: ' +
+            PACKAGE_NAME_SAMPLE_BHYVE_FLEX_1G_SMALL);
+        if (packages.length > 0) {
+            pkgSampleSmallBhyveFlex = packages[0];
+        }
+
+        t.done();
+    });
+};
+
+exports.find_flexible_disk_package = function (t) {
+    client.papi.get('/packages?name=' + PACKAGE_NAME_SAMPLE_BHYVE_FLEX_1G +
+            '&active=true',
+            function getPackages(err, req, res, packages) {
+        common.ifError(t, err, 'getting packages');
+        if (err) {
+            t.done();
+            return;
+        }
+
+        t.ok(packages.length > 0, 'found package named: ' +
+            PACKAGE_NAME_SAMPLE_BHYVE_FLEX_1G);
+        if (packages.length > 0) {
+            pkgSampleBhyveFlex = packages[0];
+        }
+
+        t.done();
+    });
+};
+
+exports.create_bhyve_vm = function (t) {
+    if (!pkgSample1G) {
+        t.ok(false, 'Skipping - no sample 1G package was found');
+        t.done();
+        return;
+    }
+
+    var vm = {
+        billing_id: pkgSample1G.uuid,
+        brand: 'bhyve',
+        cpu_cap: 100,
+        owner_uuid: CUSTOMER,
+        vcpus: 1,
+        networks: [ { uuid: EXTERNAL_NETWORK.uuid } ],
+        disks: [
+            { image_uuid: IMAGE }, // 10 GiB image
+            { size: 20 * 1024 } // 20 GiB disk
+        ]
+    };
+
+    var opts = createOpts('/vms', vm);
+
+    client.post(opts, vm, function (err, req, res, body) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 202, '202 Accepted');
+        common.checkHeaders(t, res.headers);
+        t.ok(body, 'vm ok');
+
+        var jobLocation = '/jobs/' + body.job_uuid;
+        t.ok(body.job_uuid, 'body.job_uuid', 'jobLocation: ' + jobLocation);
+
+        if (!body.job_uuid) {
+            t.done();
+            return;
+        }
+
+        common.waitForValue(jobLocation, 'execution', 'succeeded', {
+            client: client
+        }, function (err2) {
+            common.ifError(t, err2, 'no error when creating vm');
+            if (!err2) {
+                t.ok(body.vm_uuid, 'body.vm_uuid', 'vm_uuid: ' + body.vm_uuid);
+                vmLocation = '/vms/' + body.vm_uuid;
+            }
+            t.done();
+        });
+    });
+};
+
+
+exports.create_ginormous_package = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+    if (!pkgSampleBhyveFlex) {
+        t.ok(false, 'Skipping - no flexible disk package was found');
+        t.done();
+        return;
+    }
+
+    var largeQuotaValue = // value is in MiB, so:
+            10 * 1024 * // 10 ZiB should be enough for anyone
+            1024 *      // EiB
+            1024 *      // PiB
+            1024 *      // TiB
+            1024;       // GiB
+    var pkgName = 'ginormous-vmapi-test-flex-disk-10ZiB';
+
+    var params = jsprim.mergeObjects(pkgSampleBhyveFlex, {
+        name: pkgName,
+        description: 'Test package for VMAPI vms.resize.bhyve.test.js',
+        quota: largeQuotaValue
+    });
+    delete params.uuid;
+
+    client.papi.post('/packages', params,
+            function _onPost(err, req, res, body) {
+
+        common.ifError(t, err, 'POST ginormous package to PAPI');
+
+        if (!err) {
+            t.ok(body.uuid, 'created package uuid: ' + body.uuid);
+            t.equal(pkgName, body.name,
+                'response should be our fresh package');
+            pkgGinormous = body;
+        }
+
+        t.done();
+    });
+};
+
+// When there's not enough spare RAM on a server, and we're resizing upwards, we
+// want the provision to fail. Failure should be the normal case for this
+// feature, since ideally it will never work if we've done a good job of packing
+// VMs.
+exports.resize_vm_to_ginormous_package_gets_error = function (t) {
+    if (!pkgGinormous) {
+        t.ok(false, 'Skipping - no ginormous package created');
+        t.done();
+        return;
+    }
+
+    var params = {
+        action: 'update',
+        billing_id: pkgGinormous.uuid
+    };
+    var opts = createOpts(vmLocation, params);
+
+    client.post(opts, params, function _onPost(err, req, res, body) {
+        t.ok(err, 'expected error POSTing resize');
+        t.ok(res, 'expect a restify response object');
+        t.ok(body, 'expect a restify response body object');
+
+        if (res && body) {
+            t.equal(res.statusCode, 409, 'expected HTTP code 409');
+            t.equal(body.code, 'ValidationFailed',
+                'expected ValidationFailed error');
+            t.equal(body.message, 'Invalid VM update parameters',
+                'expected invalid update message');
+
+            if (Array.isArray(body.errors) && body.errors.length > 0) {
+                t.equal(body.errors[0].field, 'quota',
+                    'error should be due to quota');
+                t.equal(body.errors[0].code, 'InsufficientCapacity',
+                    'error code should be InsufficientCapacity');
+                t.ok(body.errors[0].message.match(
+                    'Required additional disk \\(\\d+\\) ' +
+                    'exceeds the server\'s available disk \\(-?\\d+\\)'),
+                    'error message should explain additional disk required');
+            } else {
+                t.ok(false,
+                    'body.errors should be an array with entries in it');
+            }
+        }
+
+        t.done();
+    });
+};
+
+exports.delete_ginormous_package = function (t) {
+    if (!pkgGinormous) {
+        t.ok(false, 'Skipping - no ginormous package created');
+        t.done();
+        return;
+    }
+
+    client.papi.del({
+        path: '/packages/' + pkgGinormous.uuid + '?force=true'
+    }, function _onDel(err, req, res, body) {
+        common.ifError(t, err, 'DELETE created package');
+
+        t.equal(204, res.statusCode, 'expected 204 from DELETE');
+        t.ok(!err, 'expected no restCode' + (err ? 'got ' + err.restCode : ''));
+
+        t.done();
+    });
+};
+
+// A non-flexible-disk vm does not include the disk image (first disk) size in
+// the calculation of the used quota (whilst flexible disk vm's do include this)
+// so when changing from non-flex to flex, we need to make sure it will not
+// exceed the total flexible disk size.
+exports.error_for_resize_when_disk_usage_exceeds_flex_size = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+    if (!pkgSampleSmallBhyveFlex) {
+        t.ok(false, 'Skipping - no small flexible disk package was found');
+        t.done();
+        return;
+    }
+
+    var params = { action: 'update', billing_id: pkgSampleSmallBhyveFlex.uuid };
+
+    var opts = createOpts(vmLocation + '?force=true', params);
+
+    client.post(opts, params, function (err, req, res, body) {
+        t.ok(err, 'expected error POSTing resize');
+        t.equal(res.statusCode, 409, 'expected HTTP code 409');
+        t.equal(body.code, 'ValidationFailed',
+            'expected ValidationFailed error');
+        t.equal(body.message, 'Cannot resize bhyve instance, existing disk ' +
+            'usage (30720) exceeds the flexible disk size (24576)');
+        t.done();
+    });
+};
+
+// Now there should be enough space to convert to a flexible disk instance.
+exports.resize_vm_to_flexible_disk = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+    if (!pkgSampleBhyveFlex) {
+        t.ok(false, 'Skipping - no flexible disk package was found');
+        t.done();
+        return;
+    }
+
+    var params = { action: 'update', billing_id: pkgSampleBhyveFlex.uuid };
+
+    var opts = createOpts(vmLocation + '?force=true', params);
+
+    client.post(opts, params, function (err, req, res, body) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 202, '202 Accepted');
+
+        var jobLocation = '/jobs/' + body.job_uuid;
+        t.ok(body.job_uuid, 'body.job_uuid', 'jobLocation: ' + jobLocation);
+
+        if (!body.job_uuid) {
+            t.done();
+            return;
+        }
+
+        common.waitForValue(jobLocation, 'execution', 'succeeded', {
+            client: client
+        }, function (err2) {
+            common.ifError(t, err2);
+            t.done();
+        });
+    });
+};
+
+// It should NOT be possible to change/resize back to a non-flexible disk
+// package.
+exports.resize_vm_non_flexible_disk_gets_error = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+    if (!pkgSample1G) {
+        t.ok(false, 'Skipping - no sample-1G package was found');
+        t.done();
+        return;
+    }
+
+    var params = { action: 'update', billing_id: pkgSample1G.uuid };
+    var opts = createOpts(vmLocation, params);
+
+    client.post(opts, params, function (err, req, res, body) {
+        t.ok(err, 'expected error POSTing resize');
+        t.equal(res.statusCode, 409, 'expected HTTP code 409');
+        t.equal(body.code, 'ValidationFailed',
+            'expected ValidationFailed error');
+        t.equal(body.message, 'Cannot resize bhyve instance to a package ' +
+            'that does not use flexible disk',
+            'expected invalid non-flex disk resize message');
+        t.done();
+    });
+};
+
+
+// It should NOT be possible to change/resize to a flexible disk size that is
+// too small to contain the current disks/snapshots.
+exports.resize_vm_down_too_small_gets_error = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+    if (!pkgSample1G) {
+        t.ok(false, 'Skipping - no sample-1G package was found');
+        t.done();
+        return;
+    }
+
+    var params = { action: 'update', billing_id: pkgSample1G.uuid };
+    var opts = createOpts(vmLocation, params);
+
+    client.post(opts, params, function (err, req, res, body) {
+        t.ok(err, 'expected error POSTing resize');
+        t.equal(res.statusCode, 409, 'expected HTTP code 409');
+        t.equal(body.code, 'ValidationFailed',
+            'expected ValidationFailed error');
+        t.equal(body.message, 'Cannot resize bhyve instance to a package ' +
+            'that does not use flexible disk',
+            'expected invalid non-flex disk resize message');
+        t.done();
+    });
+};
+
+
+exports.destroy_vm = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+
+    var opts = createOpts(vmLocation);
+
+    client.del(opts, function (err, req, res, body) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 202, '202 Accepted');
+        common.checkHeaders(t, res.headers);
+        t.ok(body, 'body is set');
+
+        var jobLocation = '/jobs/' + body.job_uuid;
+        t.ok(body.job_uuid, 'body.job_uuid', 'jobLocation: ' + jobLocation);
+
+        if (!body.job_uuid) {
+            t.done();
+            return;
+        }
+
+        common.waitForValue(jobLocation, 'execution', 'succeeded', {
+            client: client
+        }, function (err2) {
+            common.ifError(t, err2, 'no error when deleting instance');
+            t.done();
+        });
+    });
+};
diff --git a/test/vms.resize.test.js b/test/vms.resize.test.js
new file mode 100644
index 0000000..6cc031c
--- /dev/null
+++ b/test/vms.resize.test.js
@@ -0,0 +1,378 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+// Test instance resizing.
+
+var assert = require('assert-plus');
+var uuid = require('uuid');
+var vasync = require('vasync');
+
+var common = require('./common');
+
+
+// --- Globals
+
+var client;
+var pkg256;
+var pkg512;
+var pkgGinormous;
+var vmLocation;
+
+var ADMIN_NETWORK = null;
+var EXTERNAL_NETWORK = null;
+var CUSTOMER = common.config.ufdsAdminUuid;
+var IMAGE = 'fd2cc906-8938-11e3-beab-4359c665ac99'; // sdc-smartos
+var PACKAGE_NAME_128 = 'sample-128M';
+var PACKAGE_NAME_256 = 'sample-256M';
+var PACKAGE_NAME_512 = 'sample-512M';
+
+var CALLER = {
+    type: 'signature',
+    ip: '127.0.0.68',
+    keyId: '/foo@joyent.com/keys/id_rsa'
+};
+
+
+// --- Helpers
+
+function createOpts(path, params) {
+    return {
+        path: path,
+        headers: {
+            'x-request-id': uuid.v4(),
+            'x-context': JSON.stringify({
+                caller: CALLER,
+                params: params || {}
+            })
+        }
+    };
+}
+
+
+// --- Tests
+
+exports.setUp = function (callback) {
+    common.setUp(function (err, _client) {
+        assert.ifError(err);
+        assert.ok(_client, 'restify client');
+        client = _client;
+        callback();
+    });
+};
+
+
+// Other tests depend on there being both an 'admin' and 'external' network.
+// This test loads these and ensures we have both.
+exports.fetch_napi_networks = function (t) {
+    client.napi.get('/networks', function (err, req, res, networks) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 200, '200 OK');
+        t.ok(networks, 'networks is set');
+        t.ok(Array.isArray(networks), 'networks is Array');
+        t.ok(networks.length > 1, 'more than 1 network found');
+        var adminExtNetworks = common.extractAdminAndExternalNetwork(networks);
+        ADMIN_NETWORK = adminExtNetworks.admin;
+        EXTERNAL_NETWORK = adminExtNetworks.external;
+        t.ok(ADMIN_NETWORK, 'admin network is ' +
+            (ADMIN_NETWORK ? ADMIN_NETWORK.uuid : ADMIN_NETWORK));
+        t.ok(EXTERNAL_NETWORK, 'external network is ' +
+            (EXTERNAL_NETWORK ? EXTERNAL_NETWORK.uuid : EXTERNAL_NETWORK));
+        t.done();
+    });
+};
+
+exports.find_256M_package = function (t) {
+    client.papi.get('/packages?name=' + PACKAGE_NAME_256 + '&active=true',
+            function getPackages(err, req, res, packages) {
+        common.ifError(t, err, 'getting packages');
+        if (err) {
+            t.done();
+            return;
+        }
+
+        t.ok(packages.length > 0, 'found package named: ' + PACKAGE_NAME_256);
+        if (packages.length > 0) {
+            pkg256 = packages[0];
+        }
+
+        t.done();
+    });
+};
+
+exports.find_512M_package = function (t) {
+    client.papi.get('/packages?name=' + PACKAGE_NAME_512 + '&active=true',
+            function getPackages(err, req, res, packages) {
+        common.ifError(t, err, 'getting packages');
+        if (err) {
+            t.done();
+            return;
+        }
+
+        t.ok(packages.length > 0, 'found package named: ' + PACKAGE_NAME_512);
+        if (packages.length > 0) {
+            pkg512 = packages[0];
+        }
+
+        t.done();
+    });
+};
+
+exports.create_vm_256m = function (t) {
+    if (!pkg256) {
+        t.ok(false, 'Skipping - no package was found');
+        t.done();
+        return;
+    }
+
+    var vm = {
+        owner_uuid: CUSTOMER,
+        image_uuid: IMAGE,
+        networks: [ { uuid: ADMIN_NETWORK.uuid } ],
+        brand: 'joyent-minimal',
+        billing_id: pkg256.uuid
+    };
+
+    var opts = createOpts('/vms', vm);
+
+    client.post(opts, vm, function (err, req, res, body) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 202, '202 Accepted');
+        common.checkHeaders(t, res.headers);
+        t.ok(body, 'vm ok');
+
+        var jobLocation = '/jobs/' + body.job_uuid;
+        t.ok(body.job_uuid, 'body.job_uuid', 'jobLocation: ' + jobLocation);
+
+        if (!body.job_uuid) {
+            t.done();
+            return;
+        }
+
+        common.waitForValue(jobLocation, 'execution', 'succeeded', {
+            client: client
+        }, function (err2) {
+            common.ifError(t, err2, 'no error when creating vm');
+            if (!err2) {
+                vmLocation = '/vms/' + body.vm_uuid;
+            }
+            t.done();
+        });
+    });
+};
+
+
+exports.create_ginormous_package = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+
+    var largeRamValue = // value is in MiB, so:
+            10 * 1024 * // 10 EiB should be enough for anyone
+            1024 *      // PiB
+            1024 *      // TiB
+            1024;       // GiB
+    var largeQuotaValue = largeRamValue * 1024; // EiB->ZiB
+    var pkgName = 'ginormous-vmapi-test-10EiB';
+
+    client.papi.post('/packages', {
+        active: true,
+        cpu_cap: 10000,
+        description:
+            'Very large test package for VMAPI\'s vms.full.test.js',
+        max_lwps: 30000,
+        max_physical_memory: largeRamValue,
+        max_swap: largeRamValue,
+        name: pkgName,
+        quota: largeQuotaValue,
+        version: '1.0.0',
+        vcpus: 32, // the largest papi currently allows LOL
+        zfs_io_priority: 16383 // also largest papi currently allows
+    }, function _onPost(err, req, res, body) {
+        common.ifError(t, err, 'POST ginormous package to PAPI');
+
+        if (!err) {
+            t.ok(body.uuid, 'created package uuid: ' + body.uuid);
+            t.equal(pkgName, body.name,
+                'response should be our fresh package');
+            pkgGinormous = body;
+        }
+
+        t.done();
+    });
+};
+
+// If there's not enough spare RAM on a server, and we're resizing upwards, we
+// want the provision to fail. Failure should be the normal case for this
+// feature, since ideally it will never work if we've done a good job of packing
+// VMs.
+exports.resize_vm_to_ginormous_package = function (t) {
+    if (!pkgGinormous) {
+        t.ok(false, 'Skipping - no ginormous package created');
+        t.done();
+        return;
+    }
+
+    var params = {
+        action: 'update',
+        billing_id: pkgGinormous.uuid
+    };
+    var opts = createOpts(vmLocation, params);
+
+    client.post(opts, params, function _onPost(err, req, res, body) {
+
+        var error;
+
+        t.ok(err, 'expected error POSTing resize');
+        t.equal(res.statusCode, 409, 'expected HTTP code 409');
+        t.equal(body.code, 'ValidationFailed',
+            'expected ValidationFailed error');
+        t.equal(body.message, 'Invalid VM update parameters',
+            'expected invalid update message');
+
+        error = body.errors[0];
+        t.equal(error.field, 'ram', 'error should be due to ram');
+        t.equal(error.code, 'InsufficientCapacity',
+            'error code should be InsufficientCapacity');
+        t.ok(error.message.match(
+            'Required additional RAM \\(\\d+\\) ' +
+            'exceeds the server\'s available RAM \\(-?\\d+\\)'),
+            'error message should explain additional RAM required');
+
+        t.done();
+    });
+};
+
+exports.delete_ginormous_package = function (t) {
+    if (!pkgGinormous) {
+        t.ok(false, 'Skipping - no ginormous package created');
+        t.done();
+        return;
+    }
+
+    client.papi.del({
+        path: '/packages/' + pkgGinormous.uuid + '?force=true'
+    }, function _onDel(err, req, res, body) {
+        common.ifError(t, err, 'DELETE created package');
+
+        t.equal(204, res.statusCode, 'expected 204 from DELETE');
+        t.ok(!err, 'expected no restCode' + (err ? 'got ' + err.restCode : ''));
+
+        t.done();
+    });
+};
+
+exports.resize_vm_up_512m = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+    if (!pkg512) {
+        t.ok(false, 'Skipping - no 256M package was found');
+        t.done();
+        return;
+    }
+
+    var params = { action: 'update', billing_id: pkg512.uuid };
+
+    var opts = createOpts(vmLocation + '?force=true', params);
+
+    client.post(opts, params, function (err, req, res, body) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 202, '202 Accepted');
+
+        var jobLocation = '/jobs/' + body.job_uuid;
+        t.ok(body.job_uuid, 'body.job_uuid', 'jobLocation: ' + jobLocation);
+
+        if (!body.job_uuid) {
+            t.done();
+            return;
+        }
+
+        common.waitForValue(jobLocation, 'execution', 'succeeded', {
+            client: client
+        }, function (err2) {
+            common.ifError(t, err2);
+            t.done();
+        });
+    });
+};
+
+// Regardless of spare RAM on server, we always want resizing down to succeed.
+exports.resize_vm_down_256m = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+    if (!pkg256) {
+        t.ok(false, 'Skipping - no 128M package was found');
+        t.done();
+        return;
+    }
+
+    var params = { action: 'update', billing_id: pkg256.uuid };
+    var opts = createOpts(vmLocation, params);
+
+    client.post(opts, params, function (err, req, res, body) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 202, '202 Accepted');
+
+        var jobLocation = '/jobs/' + body.job_uuid;
+        t.ok(body.job_uuid, 'body.job_uuid', 'jobLocation: ' + jobLocation);
+
+        if (!body.job_uuid) {
+            t.done();
+            return;
+        }
+
+        common.waitForValue(jobLocation, 'execution', 'succeeded', {
+            client: client
+        }, function (err2) {
+            common.ifError(t, err2);
+            t.done();
+        });
+    });
+};
+
+
+exports.destroy_vm = function (t) {
+    if (!vmLocation) {
+        t.ok(false, 'Skipping - no vm was created');
+        t.done();
+        return;
+    }
+
+    var opts = createOpts(vmLocation);
+
+    client.del(opts, function (err, req, res, body) {
+        common.ifError(t, err);
+        t.equal(res.statusCode, 202, '202 Accepted');
+        common.checkHeaders(t, res.headers);
+        t.ok(body, 'body is set');
+
+        var jobLocation = '/jobs/' + body.job_uuid;
+        t.ok(body.job_uuid, 'body.job_uuid', 'jobLocation: ' + jobLocation);
+
+        if (!body.job_uuid) {
+            t.done();
+            return;
+        }
+
+        common.waitForValue(jobLocation, 'execution', 'succeeded', {
+            client: client
+        }, function (err2) {
+            common.ifError(t, err2, 'no error when deleting instance');
+            t.done();
+        });
+    });
+};
diff --git a/test/vms.validate.test.js b/test/vms.validate.test.js
index 40d2a31..4a694d7 100644
--- a/test/vms.validate.test.js
+++ b/test/vms.validate.test.js
@@ -5,14 +5,19 @@
  */
 
 /*
- * Copyright (c) 2019, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
+var assert = require('assert-plus');
+var uuid = require('uuid');
+
 var VError = require('verror').VError;
 
-var safeBrandName = require('../lib/common/validation')._safeBrandName;
-var validatePackageValues =
-    require('../lib/common/validation').validatePackageValues;
+var mod_validation = require('../lib/common/validation');
+
+var safeBrandName = mod_validation._safeBrandName;
+var validatePackageValues = mod_validation.validatePackageValues;
+var validateUpdateVmParams = mod_validation.validateUpdateVmParams;
 
 var PACKAGES = {
     'BHYVE_PACKAGE': {
@@ -23,7 +28,46 @@ var PACKAGES = {
         max_swap: 2048,
         name: 'BHYVE_PACKAGE',
         quota: 10240,
-        uuid: '62c59acd-456e-49e9-a3b2-bc707928624f',
+        uuid: uuid.v4(),
+        vcpus: 2,
+        zfs_io_priority: 100
+    },
+    'BHYVE_FLEX_PACKAGE': {
+        brand: 'bhyve',
+        cpu_cap: 100,
+        max_lwps: 4000,
+        max_physical_memory: 1024,
+        max_swap: 2048,
+        name: 'BHYVE_FLEX_PACKAGE',
+        flexible_disk: true,
+        quota: 10240,
+        uuid: uuid.v4(),
+        vcpus: 2,
+        zfs_io_priority: 100
+    },
+    'BHYVE_FLEX_LARGER_MEM_PACKAGE': {
+        brand: 'bhyve',
+        cpu_cap: 100,
+        max_lwps: 4000,
+        max_physical_memory: 1024 + 1024,
+        max_swap: 4096,
+        name: 'BHYVE_FLEX_LARGER_MEM_PACKAGE',
+        flexible_disk: true,
+        quota: 10240,
+        uuid: uuid.v4(),
+        vcpus: 2,
+        zfs_io_priority: 100
+    },
+    'BHYVE_FLEX_LARGER_QUOTA_PACKAGE': {
+        brand: 'bhyve',
+        cpu_cap: 100,
+        max_lwps: 4000,
+        max_physical_memory: 1024,
+        max_swap: 2048,
+        name: 'BHYVE_FLEX_LARGER_QUOTA_PACKAGE',
+        flexible_disk: true,
+        quota: 10240 + 10240,
+        uuid: uuid.v4(),
         vcpus: 2,
         zfs_io_priority: 100
     },
@@ -34,7 +78,7 @@ var PACKAGES = {
         max_swap: 2048,
         name: 'JOYENT_PACKAGE',
         quota: 10240,
-        uuid: 'f76066d9-8a26-46d8-b49b-7db693be5073',
+        uuid: uuid.v4(),
         zfs_io_priority: 100
     },
     'KVM_PACKAGE': {
@@ -45,12 +89,31 @@ var PACKAGES = {
         max_swap: 2048,
         name: 'KVM_PACKAGE',
         quota: 10240,
-        uuid: '592d392b-4792-4e83-8bc7-cee6506f9abb',
+        uuid: uuid.v4(),
         vcpus: 2,
         zfs_io_priority: 100
     }
 };
 
+// Ensure all packages use a unique name and uuid.
+Object.keys(PACKAGES).forEach(function checkUniqueUuid(pkgName) {
+    var sameUuid = Object.keys(PACKAGES).filter(function (name) {
+        return PACKAGES[name].uuid === PACKAGES[pkgName].uuid;
+    });
+    assert.equal(sameUuid.length, 1);
+
+    var sameName = Object.keys(PACKAGES).filter(function (name) {
+        return name === pkgName || PACKAGES[name].name === pkgName;
+    });
+    assert.equal(sameName.length, 1);
+});
+
+function ifError(t, err, prefix) {
+    t.ok(!err,
+        (prefix ? prefix + ': ' : '') +
+        (err ? ('error: ' + err.message) : 'no error'));
+}
+
 function DummyPapi() {
     var self = this;
 
@@ -79,6 +142,10 @@ DummyPapi.prototype.getPackage = function getPackage(pkgUuid, callback) {
     callback(null, self.packages[pkgUuid]);
 };
 
+DummyPapi.prototype.addPackage = function addPackage(pkg) {
+    this.packages[pkg.uuid] = pkg;
+};
+
 // This tests that our mock "getPackage" works in the case where a package
 // doesn't exist.
 exports.check_missing_package = function check_missing_package(t) {
@@ -183,3 +250,491 @@ exports.test_safe_brand_name = function test_safe_brand_name(t) {
 
     t.done();
 };
+
+
+function createDummyApp(opts) {
+    return {
+        cnapi: {
+            capacity: function (serverUuids, cb) {
+                var capacities = {};
+
+                serverUuids.forEach(function (server_uuid) {
+                    var capSettings = opts && opts.capacity || {};
+                    var entry = {
+                        ram: capSettings.ram || 100000,
+                        disk: capSettings.disk || 100000
+                    };
+                    capacities[server_uuid] = entry;
+                });
+
+                cb(null, {capacities: capacities});
+            }
+        },
+        imgapi: {
+            getImage: function fakeGetImage(image_uuid, cb) {
+                // Validation is checking against the image.requirements, so we
+                // just return an empty image with empty image.requirements.
+                cb(null, { requirements: {} });
+            }
+        },
+        log: {
+            trace: function () {},
+            debug: function () {},
+            info: function () {},
+            warn: function () {},
+            error: function () {}
+        },
+        papi: new DummyPapi()
+    };
+}
+
+function createDummyBhyveVm(props) {
+    var vm = {
+        brand: 'bhyve',
+        hvm: true,
+        state: 'running',
+        quota: 10,
+        disks: [
+            {
+                image_uuid: 'fake',
+                size: 10240
+            }
+        ],
+        uuid: uuid.v4(),
+        server_uuid: uuid.v4()
+    };
+
+    var pkgName = props.package;
+    delete props.package;
+
+    // Copy over package properties.
+    if (pkgName) {
+        var pkg = PACKAGES[pkgName];
+
+        // Start the vm with the properties from the base pkg.
+        Object.keys(pkg).forEach(function (field) {
+            if (['name', 'uuid'].indexOf(field) !== -1) {
+                return;
+            }
+            if (field === 'flexible_disk' && pkg[field]) {
+                vm.flexible_disk_size = pkg.quota;
+                return;
+            }
+            vm[field] = pkg[field];
+        });
+
+        // Fixup for quota for flexible disk.
+        if (pkg.flexible_disk) {
+            vm.quota = 10;
+        }
+
+        // Copy max_physical_memory to ram setting.
+        if (pkg.max_physical_memory) {
+            vm.ram = pkg.max_physical_memory;
+        }
+    }
+
+    // Copy over vm properties.
+    Object.keys(props).forEach(function (field) {
+        vm[field] = props[field];
+    });
+
+    return vm;
+}
+
+
+// Ensure that validation will convert package max_physical_memory to ram.
+exports.test_resize_convert_ram = function test_resize_convert_ram(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({
+        package: 'BHYVE_FLEX_PACKAGE',
+        state: 'stopped'
+    });
+    var params = {
+        billing_id: PACKAGES['BHYVE_FLEX_LARGER_MEM_PACKAGE'].uuid
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err, newparams) {
+        t.ok(!err, 'resize of running bhyve vm when no cpu/mem change');
+        t.equal(newparams.ram,
+            PACKAGES['BHYVE_FLEX_LARGER_MEM_PACKAGE'].max_physical_memory,
+            'max_physical_memory should be converted to ram');
+        t.equal(newparams.max_physical_memory, undefined,
+            'max_physical_memory should not be visible');
+        t.done();
+    });
+};
+
+// Check that we can resize running bhyve when cpu/mem does not change.
+exports.test_resize_running_mem_cpu_not_changed =
+function test_resize_running_mem_cpu_not_changed(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({package: 'BHYVE_FLEX_PACKAGE'});
+    var params = {
+        quota: vm.flexible_disk_size + 1024
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        t.ok(!err, 'resize of running bhyve vm when no cpu/mem change');
+        t.done();
+    });
+};
+
+// Check that we can't resize running bhyve when cpu/mem changes - as the vm
+// must be stopped.
+exports.test_resize_running_mem_cpu_changed =
+function test_resize_running_mem_cpu_changed(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({package: 'BHYVE_FLEX_PACKAGE'});
+    var params = {
+        max_physical_memory: vm.max_physical_memory + 1024
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        t.ok(err, 'expect error for bhyve resize with changed mem');
+        if (err) {
+            var msg = 'VM not stopped: changing bhyve CPU or memory ' +
+                'requires the instance to be stopped';
+            t.deepEqual(err, {
+                    jse_shortmsg: '',
+                    jse_info: {},
+                    message: msg,
+                    statusCode: 409,
+                    body: { code: 'VmNotStopped', message: msg },
+                    restCode: 'VmNotStopped' },
+                'should get an VM not stopped error');
+        }
+        t.done();
+    });
+};
+
+// Check that we can resize stopped bhyve even if the cpu/mem changes.
+exports.test_resize_stopped_mem_cpu_changed =
+function test_resize_stopped_mem_cpu_changed(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({
+        package: 'BHYVE_FLEX_PACKAGE',
+        state: 'stopped'
+    });
+    var params = {
+        max_physical_memory: vm.max_physical_memory + 1024
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        ifError(t, err);
+        t.done();
+    });
+};
+
+// Check that we can resize running bhyve when pkg cpu/mem does not change.
+exports.test_resize_running_pkg_mem_cpu_unchanged =
+function test_resize_running_pkg_mem_cpu_unchanged(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({package: 'BHYVE_FLEX_PACKAGE'});
+    var params = {
+        billing_id: PACKAGES['BHYVE_FLEX_LARGER_QUOTA_PACKAGE'].uuid
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        ifError(t, err);
+        t.done();
+    });
+};
+
+// Check that we can't resize running bhyve when package cpu/mem changes
+// as the vm must be stopped.
+exports.test_resize_running_pkg_mem_cpu_changed =
+function test_resize_running_pkg_mem_cpu_changed(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({package: 'BHYVE_FLEX_PACKAGE'});
+    var params = {
+        billing_id: PACKAGES['BHYVE_FLEX_LARGER_MEM_PACKAGE'].uuid
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        t.ok(err, 'expect error for bhyve resize with changed mem');
+        if (err) {
+            var msg = 'VM not stopped: changing bhyve CPU or memory ' +
+                'requires the instance to be stopped';
+            t.deepEqual(err, {
+                    jse_shortmsg: '',
+                    jse_info: {},
+                    message: msg,
+                    statusCode: 409,
+                    body: { code: 'VmNotStopped', message: msg },
+                    restCode: 'VmNotStopped' },
+                'should get an VM not stopped error');
+        }
+        t.done();
+    });
+};
+
+// Check that we can resize stopped bhyve even when the pkg cpu/mem changes.
+exports.test_resize_stopped_pkg_mem_cpu_changed =
+function test_resize_stopped_pkg_mem_cpu_changed(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({
+        package: 'BHYVE_FLEX_PACKAGE',
+        state: 'stopped'
+    });
+    var params = {
+        billing_id: PACKAGES['BHYVE_FLEX_LARGER_MEM_PACKAGE'].uuid
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        ifError(t, err);
+        t.done();
+    });
+};
+
+
+// Test that we can move from non-flexible disk package to a flexible disk one.
+exports.test_resize_bhyve_to_flex_disk =
+function test_resize_bhyve_to_flex_disk(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({
+        package: 'BHYVE_PACKAGE'
+    });
+
+    var params = {
+        billing_id: PACKAGES['BHYVE_FLEX_PACKAGE'].uuid
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err, newparams) {
+        ifError(t, err);
+        t.ok(newparams, 'validateUpdateVmParams returned new params');
+
+        if (newparams) {
+            t.equal(newparams.flexible_disk_size,
+                PACKAGES['BHYVE_FLEX_PACKAGE'].quota,
+                'validateUpdateVmParams should set flexible_disk_size');
+        }
+
+        t.done();
+    });
+};
+
+
+// Test that we cannot move from flexible disk to non-flexible disk package.
+exports.test_resize_bhyve_away_from_flex_disk =
+function test_resize_bhyve_away_from_flex_disk(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({
+        package: 'BHYVE_FLEX_PACKAGE'
+    });
+
+    var params = {
+        billing_id: PACKAGES['BHYVE_PACKAGE'].uuid
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        t.ok(err, 'expect error for bhyve resize away from flex disk package');
+        if (err) {
+            var msg = 'Cannot resize bhyve instance to a package that does ' +
+                'not use flexible disk';
+            t.deepEqual(err, {
+                    jse_shortmsg: '',
+                    jse_info: {},
+                    message: msg,
+                    statusCode: 409,
+                    body: {
+                        code: 'ValidationFailed',
+                        message: msg,
+                        errors: [ { field: 'billing_id',
+                            code: 'Invalid',
+                            message: 'Invalid parameter' } ]
+                    },
+                    restCode: 'ValidationFailed' },
+                'should get a validation failed error');
+        }
+        t.done();
+    });
+};
+
+// Test that we cannot resize to use more space than what is available for
+// flexible disk instances.
+exports.test_resize_bhyve_not_enough_disk_capacity =
+function test_resize_bhyve_not_enough_disk_capacity(t) {
+
+    var app = createDummyApp({capacity: {disk: 4 * 1024}});
+    var vm = createDummyBhyveVm({
+        package: 'BHYVE_FLEX_PACKAGE'
+    });
+    var params = {
+        billing_id: PACKAGES['BHYVE_FLEX_LARGER_QUOTA_PACKAGE'].uuid
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        t.ok(err, 'expect error for bhyve resize away from flex disk package');
+        if (err) {
+            t.deepEqual(err, {
+                    jse_shortmsg: '',
+                    jse_info: {},
+                    message: 'Invalid VM update parameters',
+                    statusCode: 409,
+                    body: {
+                        code: 'ValidationFailed',
+                        message: 'Invalid VM update parameters',
+                        errors: [ {
+                            field: 'quota',
+                            code: 'InsufficientCapacity',
+                            message: 'Required additional disk (10) exceeds ' +
+                                'the server\'s available disk (4)'
+                        } ]
+                    },
+                    restCode: 'ValidationFailed' },
+                'should get a validation failed error');
+        }
+        t.done();
+    });
+};
+
+// Test that we can resize when there is just space available.
+exports.test_resize_bhyve_just_enough_capacity =
+function test_resize_bhyve_just_enough_capacity(t) {
+
+    var app = createDummyApp({capacity: {
+        disk: (PACKAGES['BHYVE_FLEX_LARGER_QUOTA_PACKAGE'].quota -
+            PACKAGES['BHYVE_FLEX_PACKAGE'].quota) * 1024
+    }});
+    var vm = createDummyBhyveVm({
+        package: 'BHYVE_FLEX_PACKAGE'
+    });
+    var params = {
+        billing_id: PACKAGES['BHYVE_FLEX_LARGER_QUOTA_PACKAGE'].uuid
+    };
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        t.ok(!err, 'no error expected when there is just enough capacity');
+        t.done();
+    });
+};
+
+// Test that we cannot resize from non-flexible-disk if the resulting disk
+// size total exceeds the available flexible disk size.
+exports.test_resize_bhyve_disks_larger =
+function test_resize_bhyve_disks_larger(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({
+        package: 'BHYVE_PACKAGE',
+        disks: [
+            {
+                image_uuid: 'fake',
+                size: 10 * 1024
+            },
+            {
+                size: 15 * 1024
+            }
+        ]
+    });
+
+    var params = {
+        billing_id: PACKAGES['BHYVE_FLEX_PACKAGE'].uuid
+    };
+
+    // Double check that the disk usage has been exceeded.
+    var diskUsage = vm.disks.map(function (disk) { return disk.size || 0; }).
+        reduce(function (size, runningTotal) {
+            return size + runningTotal;
+        }, 0);
+    t.ok(diskUsage > PACKAGES['BHYVE_FLEX_PACKAGE'].quota,
+        'vm disk usage (' + diskUsage + ') should be higher than the ' +
+        'package quota (' + PACKAGES['BHYVE_FLEX_PACKAGE'].quota + ')');
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        t.ok(err, 'expect error for bhyve resize where usage exceeds quota');
+        if (err) {
+            var msg = 'Cannot resize bhyve instance, existing disk usage ' +
+                '(25600) exceeds the flexible disk size (10240)';
+            t.deepEqual(err, {
+                    jse_shortmsg: '',
+                    jse_info: {},
+                    message: msg,
+                    statusCode: 409,
+                    body: {
+                        code: 'ValidationFailed',
+                        message: msg,
+                        errors: [ { field: 'flexible_disk_size',
+                            code: 'Invalid',
+                            message: 'Invalid parameter' } ]
+                    },
+                    restCode: 'ValidationFailed' },
+                'should get a validation failed error');
+        }
+        t.done();
+    });
+};
+
+// Test that we cannot resize up/down when the current total disk usage
+// (including snapshots) exceeds the available flexible disk size.
+exports.test_resize_bhyve_not_enough_space_with_snapshots =
+function test_resize_bhyve_not_enough_space_with_snapshots(t) {
+
+    var app = createDummyApp();
+    var vm = createDummyBhyveVm({
+        package: 'BHYVE_FLEX_LARGER_QUOTA_PACKAGE',
+        snapshots: [
+            {name: 'snap1', size: 5 * 1024},
+            {name: 'snap2', size: 6 * 1024}
+        ]
+    });
+
+    var params = {
+        billing_id: PACKAGES['BHYVE_FLEX_PACKAGE'].uuid
+    };
+
+    var diskUsage = vm.disks.map(
+        function (disk) {
+            return disk.size || 0;
+        }). reduce(function (size, runningTotal) {
+            return size + runningTotal;
+        }, 0);
+    var newQuota = PACKAGES['BHYVE_FLEX_PACKAGE'].quota;
+    t.ok(diskUsage <= newQuota,
+        'vm disk usage (' + diskUsage + ') should be equal or lower than the ' +
+        'package quota (' + newQuota + ')');
+
+    var totalUsage = diskUsage + vm.snapshots.map(
+        function (snap) {
+            return snap.size || 0;
+        }).reduce(function (size, runningTotal) {
+            return size + runningTotal;
+        }, 0);
+    t.ok(totalUsage > newQuota,
+        'vm disk usage (' + diskUsage + ') should be greater than the ' +
+        'package quota (' + newQuota + ')');
+
+    validateUpdateVmParams(app, vm, params, function (err) {
+        t.ok(err, 'expect error for bhyve resize where usage exceeds quota');
+        if (err) {
+            var msg = 'Cannot resize bhyve instance, existing disk usage ' +
+                '(' + totalUsage + ') exceeds the flexible disk size (' +
+                newQuota + ')';
+            t.deepEqual(err, {
+                    jse_shortmsg: '',
+                    jse_info: {},
+                    message: msg,
+                    statusCode: 409,
+                    body: {
+                        code: 'ValidationFailed',
+                        message: msg,
+                        errors: [ { field: 'flexible_disk_size',
+                            code: 'Invalid',
+                            message: 'Invalid parameter' } ]
+                    },
+                    restCode: 'ValidationFailed' },
+                'should get a validation failed error');
+        }
+        t.done();
+    });
+};
-- 
2.17.2 (Apple Git-113)

