commit 6995a9a1f5cfa1f99098cf1e569a2d567f26244a (refs/changes/55/455/2)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2016-09-12T22:13:31+00:00 (3 years, 1 month ago)
    
    FWAPI-253 Adding an already existing rule shouldn't regenerate firewalls

diff --git a/src/fw/lib/fw.js b/src/fw/lib/fw.js
index 42e337d6..2194741b 100644
--- a/src/fw/lib/fw.js
+++ b/src/fw/lib/fw.js
@@ -170,7 +170,24 @@ function dedupRules(list1, list2) {
 }
 
 
-/*
+/**
+ * Given a list of new rules and a map of existing rules, build a list
+ * of the subset of new rules that are actually changing anything.
+ */
+function getChangingRules(rules, existingRules, cb) {
+    var changing = rules.filter(function (rule) {
+        if (!existingRules.hasOwnProperty(rule.uuid)) {
+            return true;
+        }
+        return !mod_obj.shallowObjEqual(rule.serialize(),
+            existingRules[rule.uuid].serialize());
+    });
+
+    cb(null, changing);
+}
+
+
+/**
  * This filter removes rules that aren't affected by adding a remote VM
  * or updating a local VM (for example, simple wildcard rules), and would
  * therefore require updating the rules of other VMs. This table shows which
@@ -652,6 +669,10 @@ function loadDataFromDisk(log, callback) {
                 loadAllRules(log, function (err, res) {
                     if (res) {
                         onDisk.rules = res;
+                        onDisk.rulesByUUID = {};
+                        onDisk.rules.forEach(function (rule) {
+                            onDisk.rulesByUUID[rule.uuid] = rule;
+                        });
                     }
 
                     return cb(err);
@@ -693,30 +714,24 @@ function findRules(opts, log, callback) {
 
     var errs = [];
     var found = {};
-    var uuids = {};
+    var missing = {};
+
     rules.forEach(function (r) {
         if (!r.hasOwnProperty('uuid')) {
             errs.push(new verror.VError('Missing UUID of rule: %j', r));
             return;
         }
-        uuids[r.uuid] = 1;
-    });
-    log.debug(uuids, 'findRules: rules');
-
-    allRules.forEach(function (r) {
-        if (!r.hasOwnProperty('uuid')) {
-            errs.push(new verror.VError('Missing UUID of rule: %j', r));
-        }
 
-        if (uuids.hasOwnProperty(r.uuid)) {
-            delete uuids[r.uuid];
-            found[r.uuid] = r;
+        if (allRules.hasOwnProperty(r.uuid)) {
+            found[r.uuid] = allRules[r.uuid];
+        } else {
+            missing[r.uuid] = 1;
         }
     });
 
     // If we're allowing adds, missing rules aren't an error
-    if (!allowAdds && !objEmpty(uuids)) {
-        Object.keys(uuids).forEach(function (uuid) {
+    if (!allowAdds && !objEmpty(missing)) {
+        Object.keys(missing).forEach(function (uuid) {
             errs.push(new verror.VError('Unknown rule: %s', uuid));
         });
     }
@@ -724,18 +739,19 @@ function findRules(opts, log, callback) {
     if (log.debug()) {
         var ret = { rules: found };
         if (allowAdds) {
-            ret.adds = Object.keys(uuids);
+            ret.adds = Object.keys(missing);
         } else {
-            ret.missing = Object.keys(uuids);
+            ret.missing = Object.keys(missing);
         }
         log.debug(ret, 'findRules: return');
     }
 
     if (errs.length !== 0) {
-        return callback(util_err.createMultiError(errs));
+        callback(util_err.createMultiError(errs));
+        return;
     }
 
-    return callback(null, found);
+    callback(null, found);
 }
 
 
@@ -1570,7 +1586,8 @@ function add(opts, callback) {
         function lock(_, cb) {
             mod_lock.acquireExclusiveLock(cb);
         },
-        function rules(_, cb) {
+
+        function originalRules(_, cb) {
             createRules(opts.rules, opts.createdBy, cb);
         },
 
@@ -1578,6 +1595,12 @@ function add(opts, callback) {
 
         function disk(_, cb) { loadDataFromDisk(log, cb); },
 
+        // If we're try to add a rule that already exists and looks
+        // the same, drop it.
+        function rules(res, cb) {
+            getChangingRules(res.originalRules, res.disk.rulesByUUID, cb);
+        },
+
         function newRemoteVMs(res, cb) {
             mod_rvm.create(res.vms, opts.remoteVMs, true, log, cb);
         },
@@ -2264,7 +2287,7 @@ function update(opts, callback) {
         // Make sure the rules exist
         function originalRules(res, cb) {
             findRules({
-                allRules: res.disk.rules,
+                allRules: res.disk.rulesByUUID,
                 allowAdds: opts.allowAdds,
                 rules: opts.rules
             }, log, cb);
diff --git a/src/fw/test/unit/add.test.js b/src/fw/test/unit/add.test.js
index 37618c81..76c8f0b5 100644
--- a/src/fw/test/unit/add.test.js
+++ b/src/fw/test/unit/add.test.js
@@ -63,8 +63,8 @@ exports['created_by'] = function (t) {
             {
                 rule: util.format('FROM vm %s TO any BLOCK tcp PORT 8080',
                     vm.uuid),
-                uuid: vm.owner_uuid,
-                owner_uuid: mod_uuid.v4(),
+                uuid: mod_uuid.v4(),
+                owner_uuid: vm.owner_uuid,
                 enabled: true,
                 version: '1383205115597.067782'
             },
@@ -100,11 +100,6 @@ exports['created_by'] = function (t) {
                 vms: [ vm.uuid ]
             }, 'rules returned');
 
-            t.deepEqual(res, {
-                rules: expRules,
-                vms: [ payload.vms[0].uuid ]
-            }, 'rules returned');
-
             expRulesOnDisk[expRules[0].uuid] = clone(expRules[0]);
             expRulesOnDisk[expRules[1].uuid] = clone(expRules[1]);
             t.deepEqual(helpers.rulesOnDisk(), expRulesOnDisk,
@@ -119,6 +114,53 @@ exports['created_by'] = function (t) {
     }, function (cb) {
         helpers.fwGetEquals(t, expRules[1], cb);
 
+    }, function (cb) {
+        fw.add(payload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb();
+                return;
+            }
+
+            // We're adding rules that we've already added, so nothing
+            // should be updated, and everything on disk should remain
+            // the same.
+            t.deepEqual(helpers.sortRes(res), { vms: [], rules: [] },
+                'rules returned');
+
+            t.deepEqual(helpers.rulesOnDisk(), expRulesOnDisk,
+                'rules on disk OK');
+
+            cb();
+        });
+
+    }, function (cb) {
+        var changing = payload.rules[0];
+        changing.version = '2383205215597.167882';
+        expRules = clone(payload.rules);
+        expRules[0].created_by = payload.createdBy;
+        expRulesOnDisk[changing.uuid].version = changing.version;
+
+        fw.add(payload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb();
+                return;
+            }
+
+            // We changed the version, so the rule on disk and the VM's
+            // firewall should get updated.
+            t.deepEqual(helpers.sortRes(res), {
+                rules: [ expRules[0] ],
+                vms: [ vm.uuid ]
+            }, 'rules returned');
+
+            t.deepEqual(helpers.rulesOnDisk(), expRulesOnDisk,
+                'rules on disk OK');
+
+            cb();
+        });
+
     }, function (cb) {
         payload.allowAdds = true;
         payload.rules[0].uuid = mod_uuid.v4();
