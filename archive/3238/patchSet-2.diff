From f25d921dd10d22f2e47079394574fe44e54ebdc8 Mon Sep 17 00:00:00 2001
From: Julien Gilli <julien.gilli@joyent.com>
Date: Thu, 18 Jan 2018 16:15:26 -0800
Subject: [PATCH] TRITON-59 check that instances mounting NFS volumes are
 provisioned on networks on which volumes are reachable VOLAPI-100 Attempting
 to mount a volume in an incorrect fabric network does not give an error
 correctly.

---
 lib/backends/sdc/containers.js                | 217 +++++++++++++-
 lib/backends/sdc/networks.js                  |   1 +
 lib/backends/sdc/volumes.js                   |   5 +-
 lib/errors.js                                 |  24 ++
 package.json                                  |   2 +-
 ...-mounts-nfs-shared-volume-networks.test.js | 280 ++++++++++++++++++
 test/integration/helpers.js                   |   6 +-
 test/lib/volumes-api.js                       |  35 ++-
 8 files changed, 552 insertions(+), 18 deletions(-)
 create mode 100644 test/integration/api-mounts-nfs-shared-volume-networks.test.js

diff --git a/lib/backends/sdc/containers.js b/lib/backends/sdc/containers.js
index 177631e..c8b2559 100644
--- a/lib/backends/sdc/containers.js
+++ b/lib/backends/sdc/containers.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var child_process = require('child_process');
@@ -27,6 +27,7 @@ var PAPI = require('sdc-clients').PAPI;
 var restify = require('restify');
 var triton_tags = require('triton-tags');
 var vasync = require('vasync');
+var VError = require('verror');
 var VMAPI = require('sdc-clients').VMAPI;
 
 var affinity = require('./affinity');
@@ -38,6 +39,8 @@ var mod_containers = require('../../containers');
 var mod_networks = require('./networks');
 var utils = require('./utils');
 var validate = require('../../validate');
+var VolumesUnreachableByContainerOnNetworksError =
+    errors.VolumesUnreachableByContainerOnNetworksError;
 
 //---- globals
 
@@ -1872,16 +1875,12 @@ function buildVmPayload(opts, container, callback) {
                 || container.HostConfig && container.HostConfig.Binds;
 
             if (binds && binds.length > 0) {
-                if (dockerNfsVolumes !== true) {
-                    cb(new Error('Support for NFS volumes is not enabled'));
-                    return;
-                } else if (dockerNfsVolumesAutomount !== true) {
-                    cb(new Error('Support for automounting NFS volumes is not '
-                        + 'enabled'));
-                    return;
-                } else {
-                    addNfsVolumesToPayload(opts, payload, binds);
-                }
+                /*
+                 * We already validated earlier that the proper NFS volumes
+                 * experimental flags are enabled, so we know NFS volumes are
+                 * supported if we're here.
+                 */
+                addNfsVolumesToPayload(opts, payload, binds);
             }
 
             cb();
@@ -2782,11 +2781,12 @@ function getContainers(opts, callback) {
 
 function createContainer(opts, callback) {
     assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
     assert.object(opts.app, 'opts.app');
+    assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
     assert.optionalObject(opts.log, 'opts.log');
+    assert.object(opts.payload, 'opts.payload');
     assert.string(opts.req_id, 'opts.req_id');
-    assert.object(opts.account, 'opts.account');
-    assert.number(opts.clientApiVersion, 'opts.clientApiVersion');
 
     var log = opts.log || this.log;
     var name = opts.name;
@@ -2797,12 +2797,67 @@ function createContainer(opts, callback) {
     var linkDetails;
 
     vasync.waterfall([
+        _checkNfsVolumesSupportEnabled,
+        _allNfsVolumesNetworkReachable,
         _buildPayload,
         _addLinks,
         _createVm,
         _saveLinks
     ], _done);
 
+    function _checkNfsVolumesSupportEnabled(cb) {
+        var binds;
+        var dockerNfsVolumes = config.experimental_docker_nfs_shared_volumes;
+        var dockerNfsVolumesAutomount =
+            config.experimental_docker_automount_nfs_shared_volumes;
+        var err;
+
+        if (container.Binds) {
+            binds = container.Binds;
+        } else if (container.HostConfig) {
+            binds = container.HostConfig.Binds;
+        }
+
+        if (binds && binds.length > 0) {
+            if (dockerNfsVolumes !== true) {
+                err = new Error('Support for NFS volumes is not enabled');
+            } else if (dockerNfsVolumesAutomount !== true) {
+                err = new Error('Support for automounting NFS volumes is not '
+                    + 'enabled');
+            }
+        }
+
+        cb(err);
+    }
+    function _allNfsVolumesNetworkReachable(cb) {
+        var app = opts.app;
+        var binds;
+        var containerNetwork;
+
+        if (container.Binds) {
+            binds = container.Binds;
+        } else if (container.HostConfig) {
+            binds = container.HostConfig.Binds;
+        }
+
+        if (container.HostConfig && container.HostConfig.NetworkMode) {
+            containerNetwork = container.HostConfig.NetworkMode;
+        }
+
+        if (binds) {
+            _checkNfsVolumesReachableOnNetworkByContainer(binds,
+                containerNetwork, name, {
+                account: opts.account,
+                app: opts.app,
+                log: log,
+                req_id: opts.req_id,
+                volapiClient: app.volapi
+            }, cb);
+        } else {
+            cb();
+        }
+    }
+
     function _buildPayload(cb) {
         // XXX check that "name" is not already used? VMAPI also does that.
         container.Name = name;
@@ -2877,6 +2932,142 @@ function createContainer(opts, callback) {
     }
 }
 
+function _checkNfsVolumesReachableOnNetworkByContainer(binds, networkName,
+    containerName, opts, cb) {
+    assert.arrayOfString(binds, 'binds');
+    assert.optionalString(networkName, 'networkName');
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.log, 'opts.log');
+    assert.uuid(opts.req_id, 'opts.req_id');
+    assert.object(opts.volapiClient, 'opts.volapiClient');
+    assert.func(cb, 'cb');
+
+    var account = opts.account;
+    var app = opts.app;
+    var context = {};
+    var log = opts.log;
+    var networkUuid;
+    var volapiClient = opts.volapiClient;
+
+    vasync.pipeline({arg: context, funcs: [
+        function getNetworkInfo(ctx, next) {
+            if (networkName === undefined || networkName === 'default'
+                || networkName === 'bridge') {
+                mod_networks.getDefaultFabricNetwork({
+                    account: account,
+                    app: app,
+                    log: log
+                }, function onGetDefaultFabricNet(getDefaultFabricNetErr,
+                        defaultFabricNet) {
+                    if (getDefaultFabricNetErr) {
+                        next(getDefaultFabricNetErr);
+                        return;
+                    }
+
+                    networkUuid = defaultFabricNet;
+                    next();
+                });
+            } else {
+                mod_networks.findNetworkOrPoolByNameOrId(networkName, {
+                    account: opts.account,
+                    app: app,
+                    config: app.config,
+                    log: log,
+                    req_id: opts.req_id
+                }, function onGetNet(getNetErr, network) {
+                    if (getNetErr) {
+                        next(getNetErr);
+                        return;
+                    }
+
+                    networkUuid = network.uuid;
+                    next();
+                });
+            }
+        },
+        function checkVolumes(ctx, next) {
+            vasync.forEachParallel({
+                func: function checkVolumeAtttachedToNetwork(bind, done) {
+                    var bindComponents;
+                    var volumeName;
+
+                    assert.string(bind, 'bind');
+                    /*
+                     * The format of each bind has been validated earlier, so we
+                     * assume they're all valid.
+                     */
+                    bindComponents = bind.split(':');
+                    assert.ok(bindComponents, 'bindComponents');
+                    assert.ok(bindComponents.length > 1,
+                            'bindComponents.length > 1');
+                    volumeName = bindComponents[0];
+
+                    log.debug({
+                        networkName: networkName,
+                        owner_uuid: account.uuid,
+                        volumeName: volumeName
+                    }, 'checking that volume is reachable on network');
+
+                    volapiClient.listVolumes({
+                        name: volumeName,
+                        owner_uuid: account.uuid
+                    }, function onListVolumes(listVolsErr, volumes) {
+                        var volUnreachableErr;
+
+                        if (listVolsErr) {
+                            done(listVolsErr);
+                            return;
+                        }
+
+                        if (!volumes || volumes.length === 0) {
+                            log.info({
+                                volumeName: volumeName, owner_uuid: account.uuid
+                            }, 'No existing volume found, volume to be '
+                                + 'created will be reachable');
+                            /*
+                             * No volume found, they will be created by the
+                             * workflow job that provisions the Docker
+                             * container, and they will be attached to the
+                             * container's network, so they'll be reachable.
+                             */
+                            done();
+                            return;
+                        }
+
+                        if (volumes.length > 1) {
+                            done(new Error('more than one volume with name '
+                                + volumeName + ', expected 1 or 0'));
+                            return;
+                        }
+
+                        if (volumes[0].networks.indexOf(networkUuid) === -1) {
+                            volUnreachableErr = new Error('volume ' + volumeName
+                                + ' unreachable on network ' + networkUuid);
+                            done(volUnreachableErr);
+                        } else {
+                            done();
+                        }
+                    });
+                },
+                inputs: binds
+            }, function onVolumesChecked(volumesReachableErr) {
+                var errs;
+
+                if (volumesReachableErr) {
+                    errs = volumesReachableErr.errors();
+                    next(new VolumesUnreachableByContainerOnNetworksError(
+                        containerName, errs));
+                } else {
+                    next();
+                }
+            });
+        }
+    ]}, function allVolumesChecked(err, results) {
+        cb(err);
+    });
+}
+
 function stopContainer(opts, callback) {
     assert.object(opts, 'opts');
     assert.optionalObject(opts.log, 'opts.log');
diff --git a/lib/backends/sdc/networks.js b/lib/backends/sdc/networks.js
index 3aba583..6437216 100644
--- a/lib/backends/sdc/networks.js
+++ b/lib/backends/sdc/networks.js
@@ -574,6 +574,7 @@ function findNetworkOrPoolByNameOrId(name, opts, callback) {
  */
 function getDefaultFabricNetwork(opts, callback) {
     assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
     assert.object(opts.app, 'opts.app');
     assert.object(opts.app.config, 'opts.app.config');
     assert.string(opts.app.config.datacenterName,
diff --git a/lib/backends/sdc/volumes.js b/lib/backends/sdc/volumes.js
index 2655e80..bc2f9cd 100644
--- a/lib/backends/sdc/volumes.js
+++ b/lib/backends/sdc/volumes.js
@@ -126,7 +126,10 @@ function createVolume(volumeParams, options, callback) {
                 mod_networks.findNetworkOrPoolByNameOrId(volumeParams.network,
                     networkOpts,
                     function onGetNamedNetwork(getNetworkErr, network) {
-                        payload.networks = [network.uuid];
+                        if (network) {
+                            payload.networks = [network.uuid];
+                        }
+
                         next(getNetworkErr);
                     });
             }
diff --git a/lib/errors.js b/lib/errors.js
index f74ff55..eaf77a1 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -587,6 +587,28 @@ PathNotDirectoryError.restCode = 'VolumeSizeNotAvailable';
 PathNotDirectoryError.statusCode = 409;
 PathNotDirectoryError.description = 'Volume size is not available';
 
+function VolumesUnreachableByContainerOnNetworksError(containerName, errors) {
+    assert.string(containerName, 'containerName');
+    assert.arrayOfObject(errors, 'errors');
+
+    var message = 'Some volumes are not reachable from container '
+        + containerName  + ': ' + errors.join(', ');
+
+    _DockerBaseError.call(this, {
+        restCode: this.constructor.restCode,
+        statusCode: this.constructor.statusCode,
+        message: message
+    });
+}
+util.inherits(VolumesUnreachableByContainerOnNetworksError, _DockerBaseError);
+VolumesUnreachableByContainerOnNetworksError.prototype.name =
+    'VolumesUnreachableByContainerOnNetworksError';
+VolumesUnreachableByContainerOnNetworksError.restCode =
+    'VolumesUnreachableByContainerOnNetworks';
+VolumesUnreachableByContainerOnNetworksError.statusCode = 409;
+VolumesUnreachableByContainerOnNetworksError.description =
+    'Some volumes are not reachable by container on network';
+
 // ---- wrappers for API responses
 
 function vmapiErrorWrap(cause, message) {
@@ -776,6 +798,8 @@ module.exports = {
     PathNotDirectoryError: PathNotDirectoryError,
 
     VolumeSizeNotAvailableError: VolumeSizeNotAvailableError,
+    VolumesUnreachableByContainerOnNetworksError:
+        VolumesUnreachableByContainerOnNetworksError,
 
     cnapiErrorWrap: cnapiErrorWrap,
     fwapiErrorWrap: fwapiErrorWrap,
diff --git a/package.json b/package.json
index a809285..2295078 100644
--- a/package.json
+++ b/package.json
@@ -30,7 +30,7 @@
     "triton-tags": "1.1.4",
     "ufds": "1.2.0",
     "vasync": "2.1.0",
-    "verror": "1.9.0",
+    "verror": "1.10.0",
     "wf-client": "0.2.1",
     "xregexp": "3.1.0"
   },
diff --git a/test/integration/api-mounts-nfs-shared-volume-networks.test.js b/test/integration/api-mounts-nfs-shared-volume-networks.test.js
new file mode 100644
index 0000000..e68023b
--- /dev/null
+++ b/test/integration/api-mounts-nfs-shared-volume-networks.test.js
@@ -0,0 +1,280 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018, Joyent, Inc.
+ */
+
+var libuuid = require('libuuid');
+var vasync = require('vasync');
+
+var mod_testVolumes = require('../lib/volumes');
+var testHelpers = require('./helpers');
+var volumesApi = require('../lib/volumes-api');
+
+var ALICE;
+var DOCKER_ALICE;
+var NAPI_CLIENT;
+var STATE = {
+    log: require('../lib/log')
+};
+var TEST_VOLUME_NAMES_PREFIX = 'sdc-docker-test-api-volume-networks';
+var VMAPI_CLIENT;
+
+var test = mod_testVolumes.createTestFunc({
+    checkTritonSupportsNfsVols: true
+});
+
+test('setup', function (tt) {
+
+    tt.test('docker env', function (t) {
+        testHelpers.initDockerEnv(t, STATE, {}, function (err, accounts) {
+            t.ifErr(err);
+
+            ALICE = accounts.alice;
+
+            t.end();
+        });
+    });
+
+    tt.test('docker client init', function (t) {
+        testHelpers.createDockerRemoteClient({
+            user: ALICE
+        }, function (err, client) {
+            t.ifErr(err, 'docker client init for alice');
+
+            DOCKER_ALICE = client;
+
+            t.end();
+        });
+    });
+
+    tt.test('vmapi client init', function (t) {
+        testHelpers.createVmapiClient(function (err, client) {
+            t.ifErr(err, 'vmapi client');
+            VMAPI_CLIENT = client;
+            t.end();
+        });
+    });
+
+
+    tt.test('napi client init', function (t) {
+        testHelpers.createNapiClient(function (err, napiClient) {
+            t.ifErr(err, 'napi client');
+            NAPI_CLIENT = napiClient;
+            t.end();
+        });
+    });
+});
+
+test('api: attach containers to volumes on different networks', function (tt) {
+    var fabricVlanId = 4;
+    var fabricNetworkName = 'sdcdockertest_nfsvolumenetworks_net1';
+
+    tt.test('create test VLAN', function (t) {
+        var vlanParams = {
+            name: 'sdcdockertest_nfsvolumenetworks_vlan4',
+            description: 'sdc-docker nfs volume networks test fixture',
+            vlan_id: fabricVlanId
+        };
+
+        testHelpers.getOrCreateFabricVLAN(NAPI_CLIENT,
+            ALICE.account.uuid, vlanParams,
+            function vlanCreated(vlanCreateErr, vlan) {
+                t.ifErr(vlanCreateErr, 'createing fabric vlan should succeed');
+                t.end();
+            }
+        );
+    });
+
+    tt.test('create non-default fabric network', function (t) {
+        var fabricParams = {
+            name: fabricNetworkName,
+            subnet: '10.0.42.0/24',
+            provision_start_ip: '10.0.42.2',
+            provision_end_ip: '10.0.42.254',
+            uuid: libuuid.create(),
+            gateway: '10.0.42.1',
+            resolvers: ['8.8.8.8']
+        };
+
+        testHelpers.getOrCreateFabricNetwork(NAPI_CLIENT,
+            ALICE.account.uuid, fabricVlanId, fabricParams,
+            function onFabricCreated(fabCreateErr) {
+                t.ifErr(fabCreateErr, 'creating fabric network should succeed');
+                t.end();
+            });
+    });
+
+    tt.test('docker container on default fabric, volume on non-default fabric',
+        function (t) {
+            var volumeName = TEST_VOLUME_NAMES_PREFIX + '-' + libuuid.create();
+
+            vasync.pipeline({funcs: [
+                function createVol(_, next) {
+                    volumesApi.createDockerVolume({
+                        dockerClient: DOCKER_ALICE,
+                        name: volumeName,
+                        network: fabricNetworkName
+                    }, function onVolCreated(volCreateErr) {
+                        t.ifErr(volCreateErr, 'volume creation should succeed');
+                        next(volCreateErr);
+                    });
+                },
+                function createContainer(_, next) {
+                    testHelpers.createDockerContainer({
+                        dockerClient: DOCKER_ALICE,
+                        expectedErr: /unreachable on network/,
+                        extra: {
+                            Binds: [volumeName + ':/data'],
+                            Cmd: ['/bin/sh', '-c', 'touch', '/data/foo']
+                        },
+                        imageName: 'busybox',
+                        start: true,
+                        test: t,
+                        vmapiClient: VMAPI_CLIENT,
+                        wait: true
+                    }, function onContainerCreated(containerCreateErr) {
+                        t.ok(containerCreateErr,
+                            'container creation should fail');
+                        next();
+                    });
+                },
+                function deleteVolume(ctx, next) {
+                    volumesApi.deleteDockerVolume({
+                        dockerClient: DOCKER_ALICE,
+                        name: volumeName
+                    }, function onDelVolume(delErr) {
+                        t.ifErr(delErr, 'deleting volume should succeed');
+                        next();
+                    });
+                }
+            ]}, function allDone(err) {
+                t.end();
+            });
+    });
+
+    tt.test('docker container on non-default fabric, volume on default fabric',
+        function (t) {
+            var volumeName = TEST_VOLUME_NAMES_PREFIX + '-' + libuuid.create();
+
+            vasync.pipeline({funcs: [
+                function createVol(_, next) {
+                    volumesApi.createDockerVolume({
+                        dockerClient: DOCKER_ALICE,
+                        name: volumeName
+                    }, function onVolCreated(volCreateErr) {
+                        t.ifErr(volCreateErr, 'volume creation should succeed');
+                        next(volCreateErr);
+                    });
+                },
+                function createContainer(_, next) {
+                    testHelpers.createDockerContainer({
+                        dockerClient: DOCKER_ALICE,
+                        expectedErr: /unreachable on network/,
+                        extra: {
+                            Binds: [volumeName + ':/data'],
+                            Cmd: ['/bin/sh', '-c', 'touch', '/data/foo'],
+                            'HostConfig.NetworkMode': fabricNetworkName
+                        },
+                        imageName: 'busybox',
+                        start: true,
+                        test: t,
+                        vmapiClient: VMAPI_CLIENT,
+                        wait: true
+                    }, function onContainerCreated(containerCreateErr) {
+                        t.ok(containerCreateErr,
+                            'container creation should fail');
+                        next();
+                    });
+                },
+                function deleteVolume(ctx, next) {
+                    volumesApi.deleteDockerVolume({
+                        dockerClient: DOCKER_ALICE,
+                        name: volumeName
+                    }, function onDelVolume(delErr) {
+                        t.ifErr(delErr, 'deleting volume should succeed');
+                        next();
+                    });
+                }
+            ]}, function allDone(err) {
+                t.end();
+            });
+    });
+
+    tt.test('docker container on non-default fabric, volume on same '
+        + 'non-default fabric',
+        function (t) {
+            var volumeName = TEST_VOLUME_NAMES_PREFIX + '-' + libuuid.create();
+
+            vasync.pipeline({arg: {}, funcs: [
+                function createVol(ctx, next) {
+                    volumesApi.createDockerVolume({
+                        dockerClient: DOCKER_ALICE,
+                        name: volumeName,
+                        network: fabricNetworkName
+                    }, function onVolCreated(volCreateErr) {
+                        t.ifErr(volCreateErr, 'volume creation should succeed');
+                        next(volCreateErr);
+                    });
+                },
+                function createContainer(ctx, next) {
+                    testHelpers.createDockerContainer({
+                        dockerClient: DOCKER_ALICE,
+                        extra: {
+                            Binds: [volumeName + ':/data'],
+                            Cmd: ['/bin/sh', '-c', 'touch', '/data/foo'],
+                            'HostConfig.NetworkMode': fabricNetworkName
+                        },
+                        imageName: 'busybox',
+                        start: true,
+                        test: t,
+                        vmapiClient: VMAPI_CLIENT,
+                        wait: true
+                    }, function onCreated(containerCreateErr, container) {
+                        t.ifErr(containerCreateErr,
+                            'container creation should succeed');
+                        ctx.container = container;
+                        next();
+                    });
+                },
+                function deleteContainer(ctx, next) {
+                    if (!ctx.container) {
+                        next();
+                        return;
+                    }
+
+                    DOCKER_ALICE.del('/containers/' + ctx.container.id,
+                        function onContainerDeleted(delErr) {
+                            t.ifErr(delErr,
+                                'container should be deleted succesfully');
+                            next();
+                        });
+                },
+                function deleteVolume(ctx, next) {
+                    volumesApi.deleteDockerVolume({
+                        dockerClient: DOCKER_ALICE,
+                        name: volumeName
+                    }, function onDelVolume(delErr) {
+                        t.ifErr(delErr, 'deleting volume should succeed');
+                        next();
+                    });
+                }
+            ]}, function allDone(err) {
+                t.end();
+            });
+    });
+});
\ No newline at end of file
diff --git a/test/integration/helpers.js b/test/integration/helpers.js
index 472b50e..55f1a0a 100644
--- a/test/integration/helpers.js
+++ b/test/integration/helpers.js
@@ -1672,11 +1672,13 @@ function ensureImage(opts, callback) {
  * Create a docker container.
  *
  * @param opts.dockerClient {Object} A docker client.
- * @param opts.vmapiClient {Object} A vmapi client.
- * @param opts.test {Object} The tape test object.
+ * @param opts.expectedErr {RegExp} or {String} a regular expression or a string
+ *        that matches the error sent back by the server.
  * @param opts.imageName {String} Optional image name to base the container on.
  *        Defaults to nginx container.
  * @param opts.start {Boolean} Optional. Use to start container after creation.
+ * @param opts.test {Object} The tape test object.
+ * @param opts.vmapiClient {Object} A vmapi client.
  *
  * @returns callback(err, result) Result contains these fields:
  *          - id: The id of the created container.
diff --git a/test/lib/volumes-api.js b/test/lib/volumes-api.js
index a74516c..4877b77 100644
--- a/test/lib/volumes-api.js
+++ b/test/lib/volumes-api.js
@@ -37,6 +37,7 @@ function createDockerVolume(opts, callback) {
     assert.object(opts, 'opts');
     assert.object(opts.dockerClient, 'opts.dockerClient');
     assert.optionalString(opts.name, 'opts.name');
+    assert.optionalString(opts.network, 'opts.network');
     assert.func(callback, 'callback');
 
     var dockerClient = opts.dockerClient;
@@ -60,6 +61,10 @@ function createDockerVolume(opts, callback) {
                 Labels: {}
             };
 
+            if (opts.network) {
+                payload.DriverOpts.network = opts.network;
+            }
+
             dockerClient.post('/' + dockerApiVersion + '/volumes/create',
                 payload,
                 function onVolumeCreated(err, res, req, body) {
@@ -81,6 +86,34 @@ function createDockerVolume(opts, callback) {
     ], callback);
 }
 
+/*
+ * Deletes a docker volume.
+ *
+ * @param {Object} opts: object with the following fields:
+ *   - apiVersion {String}: the desired Docker engine API version
+ *   - dockerClient {Object}: the docker client to use to perform the request
+ *   - name {String}: the name of the volume to delete
+ * @param {Function} callback: a function called when volume creation completes
+ *   either successfully or with an error. The function signature is:
+ *   function (err, body).
+ */
+function deleteDockerVolume(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.optionalString(opts.apiVersion, 'opts.apiVersion');
+    assert.object(opts.dockerClient, 'opts.dockerClient');
+    assert.string(opts.name, 'opts.name');
+    assert.func(callback, 'callback');
+
+    var dockerApiVersion = opts.apiVersion || ('v' + constants.API_VERSION);
+    var dockerClient = opts.dockerClient;
+
+    dockerClient.del('/' + dockerApiVersion + '/volumes/' + opts.name,
+        function onVolumeDelete(delErr, res, req, body) {
+            callback(delErr, body);
+        });
+}
+
 module.exports = {
-    createDockerVolume: createDockerVolume
+    createDockerVolume: createDockerVolume,
+    deleteDockerVolume: deleteDockerVolume
 };
\ No newline at end of file
-- 
2.21.0

