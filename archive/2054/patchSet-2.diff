commit 8a5bdc03adc4a357a28a7e2ef6b6b45315f316dd (refs/changes/54/2054/2)
Author: Brittany Wald <brittany.wald@joyent.com>
Date:   2017-06-08T17:54:16+00:00 (2 years, 4 months ago)
    
    MANTA-3279 node-fash loads the whole leveldb hash ring into memory

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..a9318c5
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,22 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+.PHONY: all test prepush
+
+all:
+	npm install
+
+test:
+	npm test
+
+prepush:
+	rm -rf node_modules
+	npm install
+	npm test
\ No newline at end of file
diff --git a/README.md b/README.md
index a649fb3..1deeb87 100644
--- a/README.md
+++ b/README.md
@@ -16,7 +16,7 @@ fash provides the ability to add, remove, or remap physical nodes on the ring
 Fash consists of a mapping of a set of fixed virtual nodes (vnodes) -- usually
 a large number, say 1000000 -- distributed across the hash ring. It is then
 possible to map these virtual nodes to a set of physical nodes (pnodes).  In
-practice, pnodes are usuall physical shards or servers in a distributed system.
+practice, pnodes are usually physical shards or servers in a distributed system.
 This gives the flexibility of mutating the hashspace of pnodes and the number
 of pnodes by re-mapping the vnode assignments.
 
@@ -52,6 +52,13 @@ To select a backend, simply pass in a backend object like so to fash.create();
     });
 ```
 
+Or from, the command line:
+
+```
+./bin/fash.js create -v 1000000 -b leveldb -l {filepath/to/hash_ring} -p '{pnodename}''
+
+```
+
 # Example
 
 Most examples can be found in the unit tests. Here are a few.
@@ -88,9 +95,9 @@ the remapNode() function, which returns an optional callback.
 
 You can also remove pnodes from the ring, but **you must first rebalance the
 ring by reassigning its vnodes to other pnodes** via remapVnode(). Then you can
-invoke removeNode(), which will eturn an optional callback.
+invoke removeNode(), which will return an optional callback.
 
-You can assign an arbitrary number of vnodes to the new vnode -- also -- the
+You can assign an arbitrary number of vnodes to the new pnode -- also -- the
 pnode can be a new node, or an existing one.  Again, as long as the order of
 removes and remaps is consistent across all clients, the ring toplogy will be
 consistent as well.
@@ -123,10 +130,11 @@ consistent as well.
 
 ## Adding More Pnodes to the Ring
 You can add additional pnodes to the ring after fash has been initialized by
-invoking remapVnode(). which optionally returns a callback. Note, adding the
-callback will cause fash to create a new copy of the ring topology across each
-invocation -- do not do this if you have millions of vnodes, as this is quite
-slow.
+invoking remapVnode(), which optionally returns a callback. Note that adding
+the callback will cause fash to create a new copy of the ring topology across
+each invocation -- do not do this if you have millions of vnodes, as this is
+quite slow and may consume all available memory, bringing the operation to a
+standstill and locking up other resources.
 
     var fash = require('fash');
     var Logger = require('bunyan');
@@ -256,22 +264,13 @@ mentioned in the earlier bootstrapping section.
 
 That's it, chash and chash2 now contain the same ring toplogy.
 
-Copyright (c) 2013 Yunong Xiao
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the "Software"), to deal in
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-of the Software, and to permit persons to whom the Software is furnished to do
-so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+## Running Tests
+
+Just run `make test`, first exporting the DB_LOCATION variable for the load
+test file to give it the location of your hash ring.
+
+Copyright (c) 2017, Joyent, Inc.
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at http://mozilla.org/MPL/2.0/.
\ No newline at end of file
diff --git a/bin/fash.js b/bin/fash.js
index 3acc976..48dfc8e 100755
--- a/bin/fash.js
+++ b/bin/fash.js
@@ -1,9 +1,13 @@
 #!/usr/bin/env node
 
-/**
- * Copyright (c) 2013, Yunong J Xiao. All rights reserved.
- *
- * fash.js: CLI tool for node-fash
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var bunyan = require('bunyan');
@@ -50,10 +54,10 @@ Fash.prototype.do_create = function (subcmd, opts, args, callback) {
         });
     }
 
-    var pnodes = opts.p.split(' ');
+    var pnodes = opts.p.split(/, | /);
     for (var i = 0; i < pnodes.length; i++) {
         var p = pnodes[i];
-        if (!p || p === '') {
+        if (!p || p === '' || p === ',') {
             pnodes.splice(i, 1);
         }
     }
@@ -193,8 +197,8 @@ Fash.prototype.do_deserialize_ring.help = (
     'load a hash ring into leveldb. Accepts input over stdin or via a file.\n'
     + '\n'
     + 'usage:\n'
-    + '     fash deserialize_ring [options] \n'
-    + '     cat /tmp/example_ring.json | fash deserialize_ring [options] \n'
+    + '     fash deserialize-ring [options] \n'
+    + '     cat /tmp/example_ring.json | fash deserialize-ring [options] \n'
     + '\n'
     + '{{options}}'
 );
@@ -262,10 +266,10 @@ Fash.prototype.do_add_data = function (subcmd, opts, args, callback) {
         },
         function addData(_, cb) {
             var count = 0;
-            var vnodes = opts.v.split(' ');
+            var vnodes = opts.v.split(/, | /);
             for (var i = 0; i < vnodes.length; i++) {
                 var v = vnodes[i];
-                if (!v || v === '') {
+                if (!v || v === '' || v === ',') {
                     vnodes.splice(i, 1);
                 }
             }
@@ -285,16 +289,20 @@ Fash.prototype.do_add_data = function (subcmd, opts, args, callback) {
             return (undefined);
         },
         function printRing(_, cb) {
-            hash.serialize(function (_err, sh) {
-                if (_err) {
-                    return cb(new verror.VError(_err,
-                                                'unable to print hash'));
-                }
-                if (opts.o) {
-                    console.log(sh);
-                }
+            if (opts.o) {
+                hash.serialize(function (_err, sh) {
+                    if (_err) {
+                        return cb(new verror.VError(_err,
+                                                    'unable to print hash'));
+                    }
+                    if (opts.o) {
+                        console.log(sh);
+                    }
+                    return cb();
+                });
+            } else {
                 return cb();
-            });
+            }
         }
     ], arg: {}}, function (err) {
         if (err) {
@@ -304,6 +312,7 @@ Fash.prototype.do_add_data = function (subcmd, opts, args, callback) {
     });
     return (undefined);
 };
+
 Fash.prototype.do_add_data.options = [ {
     names: [ 'v', 'vnode' ],
     type: 'string',
@@ -321,17 +330,18 @@ Fash.prototype.do_add_data.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'o', 'output' ],
     type: 'bool',
-    help: 'serialize and print out the resulting hash to stdout'
+    help: 'serialize and print out the resulting hash to stdout \n' +
+          'WARNING: may consume a large quantity of memory.'
 }];
 Fash.prototype.do_add_data.help = (
     'add data to a vnode.\n'
     + '\n'
     + 'usage:\n'
-    + '     fash add_data [options] \n'
+    + '     fash add-data [options] \n'
     + '\n'
     + '{{options}}'
 );
@@ -399,10 +409,10 @@ Fash.prototype.do_remap_vnode = function (subcmd, opts, args, callback) {
         },
         function remap(_, cb) {
             var count = 0;
-            var vnodes = opts.v.split(' ');
+            var vnodes = opts.v.split(/, | /);
             for (var i = 0; i < vnodes.length; i++) {
                 var v = vnodes[i];
-                if (!v || v === '') {
+                if (!v || v === '' || v === ',') {
                     vnodes.splice(i, 1);
                 }
             }
@@ -421,16 +431,20 @@ Fash.prototype.do_remap_vnode = function (subcmd, opts, args, callback) {
             }
         },
         function printRing(_, cb) {
-            hash.serialize(function (_err, sh) {
-                if (_err) {
-                    return cb(new verror.VError(_err,
-                                                'unable to print hash'));
-                }
-                if (opts.o) {
-                    console.log(sh);
-                }
+            if (opts.o) {
+                hash.serialize(function (_err, sh) {
+                    if (_err) {
+                        return cb(new verror.VError(_err,
+                                                    'unable to print hash'));
+                    }
+                    if (opts.o) {
+                        console.log(sh);
+                    }
+                    return cb();
+                });
+            } else {
                 return cb();
-            });
+            }
         }
     ], arg: {}}, function (err) {
         if (err) {
@@ -457,17 +471,18 @@ Fash.prototype.do_remap_vnode.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'o', 'output' ],
     type: 'bool',
-    help: 'serialize and print out the resulting hash to stdout'
+    help: 'serialize and print out the resulting hash to stdout \n' +
+          'WARNING: may consume a large quantity of memory.'
 }];
 Fash.prototype.do_remap_vnode.help = (
     'remap a vnode to a different pnode.\n'
     + '\n'
     + 'usage:\n'
-    + '     fash remap_vnode [options] \n'
+    + '     fash remap-vnode [options] \n'
     + '\n'
     + '{{options}}'
 );
@@ -537,15 +552,20 @@ Fash.prototype.do_remove_pnode = function (subcmd, opts, args, callback) {
             hash.removePnode(opts.p, cb);
         },
         function printRing(_, cb) {
-            hash.serialize(function (_err, sh) {
-                if (_err) {
-                    return cb(new verror.VError(_err, 'unable to print hash'));
-                }
-                if (opts.o) {
-                    console.log(sh);
-                }
+            if (opts.o) {
+                hash.serialize(function (_err, sh) {
+                    if (_err) {
+                        return cb(new verror.VError(_err,
+                            'unable to print hash'));
+                    }
+                    if (opts.o) {
+                        console.log(sh);
+                    }
+                    return cb();
+                });
+            } else {
                 return cb();
-            });
+            }
         }
     ], arg: {}}, function (err) {
         if (err) {
@@ -561,7 +581,7 @@ Fash.prototype.do_remove_pnode.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'p', 'pnode' ],
     type: 'string',
@@ -579,7 +599,7 @@ Fash.prototype.do_remove_pnode.help = (
     'remove a pnode'
     + '\n'
     + 'usage:\n'
-    + '     fash remove_pnode [options] \n'
+    + '     fash remove-pnode [options] \n'
     + '\n'
     + '{{options}}'
 );
@@ -668,7 +688,7 @@ Fash.prototype.do_get_pnodes.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'b', 'backend' ],
     type: 'string',
@@ -678,7 +698,7 @@ Fash.prototype.do_get_pnodes.help = (
     'get all the pnodes in the ring'
     + '\n'
     + 'usage:\n'
-    + '     fash get_pnodes [options]\n'
+    + '     fash get-pnodes [options]\n'
     + '\n'
     + '{{options}}'
 );
@@ -767,7 +787,7 @@ Fash.prototype.do_get_vnodes.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'b', 'backend' ],
     type: 'string',
@@ -777,13 +797,114 @@ Fash.prototype.do_get_vnodes.help = (
     'get the vnodes owned by a pnode'
     + '\n'
     + 'usage:\n'
-    + '     fash get_vnodes [options] pnode\n'
+    + '     fash get-vnodes [options] pnode\n'
+    + '\n'
+    + '{{options}}'
+);
+
+Fash.prototype.do_get_data_vnodes = function (subcmd, opts, args, callback) {
+    var self = this;
+
+    if (opts.help || !opts.v) {
+        this.do_help('help', {}, [subcmd], function (err) {
+            return callback(err ? err : true);
+        });
+    }
+
+    var hashOptions = {
+        log: self.log
+    };
+    var hash;
+    var constructor;
+
+    vasync.pipeline({funcs: [
+        function prepInput(_, cb) {
+            if (!opts.l) {
+                console.error('leveldb backend requires a location');
+                this.do_help('help', {}, [subcmd], function (err) {
+                    return callback(err ? err : true);
+                });
+            } else {
+                hashOptions.location = opts.l;
+                return cb();
+            }
+            return (undefined);
+        },
+        function loadRing(_, cb) {
+            // For this function, we choose not to support an IN_MEMORY backend.
+            hashOptions.backend = fash.BACKEND.LEVEL_DB;
+            constructor = fash.load;
+            hash = constructor(hashOptions, cb);
+        },
+        function getDataHash(_, cb) {
+            var vnodes = opts.v.split(/, | /);
+            for (var i = 0; i < vnodes.length; i++) {
+                var v = vnodes[i];
+                if (!v || v === '' || v === ',') {
+                    vnodes.splice(i, 1);
+                }
+                vnodes[i] = parseInt(vnodes[i], 10);
+            }
+
+            var dataHash = {};
+            function vnodeDataHash(input, _cb) {
+                hash.getDataVnode(input, function (err, value) {
+                    if (err) {
+                        return _cb(verror.VError(err,
+                            'unable to get data for for vnode ', input));
+                    }
+                    /**
+                     * We only care about the 2nd element in the "successes"
+                     * field of the value returned from vasync, to which it is
+                     * this function's destiny to be passed.
+                     */
+                    dataHash[input] = value.successes[1];
+                    return _cb();
+                });
+            }
+
+            vasync.forEachPipeline({
+                'inputs': vnodes,
+                'func': vnodeDataHash
+            }, function (err) {
+                if (err) {
+                    return console.error(new verror.VError(err,
+                        'unable to construct hash for vnode '));
+                }
+                // This is what it was all for.
+                console.log(dataHash);
+            });
+        }
+    ], arg: {}}, function (err) {
+        if (err)
+            console.error(new verror.VError(err));
+    });
+
+    return (undefined);
+
+};
+Fash.prototype.do_get_data_vnodes.options = [ {
+    names: [ 'v', 'vnodes' ],
+    type: 'string',
+    help: 'the vnode(s) to inspect'
+}, {
+    names: [ 'l', 'location' ],
+    type: 'string',
+    help: 'the location of the topology, assuming a leveldb backend, \n' +
+          'this is the path to the leveldb on disk.'
+}];
+Fash.prototype.do_get_data_vnodes.help = (
+    'get the data and pnode(s) associated with a set of vnodes'
+    + '\n'
+    + 'usage:\n'
+    + '     fash get-data-vnodes [options]\n'
     + '\n'
     + '{{options}}'
 );
 
 Fash.prototype.do_get_node = function (subcmd, opts, args, callback) {
     var self = this;
+
     if (opts.help || !opts.b || args.length !== 1) {
         this.do_help('help', {}, [subcmd], function (err) {
             return callback(err ? err : true);
@@ -865,7 +986,7 @@ Fash.prototype.do_get_node.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'b', 'backend' ],
     type: 'string',
@@ -875,7 +996,7 @@ Fash.prototype.do_get_node.help = (
     'hash a value to its spot on the ring'
     + '\n'
     + 'usage:\n'
-    + '     fash get_node [options] value\n'
+    + '     fash get-node [options] value\n'
     + '\n'
     + '{{options}}'
 );
@@ -964,17 +1085,17 @@ Fash.prototype.do_print_hash.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'b', 'backend' ],
     type: 'string',
     help: 'the backend to use'
 }];
 Fash.prototype.do_print_hash.help = (
-    'print out the hash ring'
+    'print out the hash ring, WARNING: may consume a large quantity of memory.'
     + '\n'
     + 'usage:\n'
-    + '     fash print_hash [options] value\n'
+    + '     fash print-hash [options] value\n'
     + '\n'
     + '{{options}}'
 );
@@ -1219,6 +1340,7 @@ Fash.prototype.do_diff.help = (
 var cli = new Fash();
 cli.main(process.argv, function (err, subcmd) {
     if (err) {
+        console.error(err);
         process.exit(1);
     } else {
         process.exit(0);
diff --git a/lib/backend/in_memory.js b/lib/backend/in_memory.js
index 3d72c51..7b29b07 100644
--- a/lib/backend/in_memory.js
+++ b/lib/backend/in_memory.js
@@ -1,5 +1,11 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
diff --git a/lib/backend/leveldb.js b/lib/backend/leveldb.js
index ccb4e80..29dd433 100644
--- a/lib/backend/leveldb.js
+++ b/lib/backend/leveldb.js
@@ -1,5 +1,11 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -37,7 +43,7 @@ var LKEY_COMPLETE = 'COMPLETE';
 var LVAL_NULL = 1;
 
 /**
- * leveldb default config
+ * leveldb config
  */
 var LEVEL_CONFIG = {
     createIfMissing: true,
@@ -193,9 +199,9 @@ function ConsistentHash(options, cb) {
                 _.pnodeToVnodeMap = {};
 
                 /*
-                 * #21 Batch up the vnode puts here. Becauase we are running in
-                 * a tight for loop, _every_ put get enqueued onto the node
-                 * work queue before they actually get procecessed. This means
+                 * #21 Batch up the vnode puts here. Because we are running in
+                 * a tight for loop, _every_ put gets enqueued onto the node
+                 * work queue before it is actually processed. This means
                  * that we are allocating a huge amount of memory and not
                  * deallocating it until every node has been enqueued. On
                  * sufficiently large counts of vnodes, say 10 000 000, we
@@ -203,7 +209,7 @@ function ConsistentHash(options, cb) {
                  * mmap(1) or v8 will fail to grow the heap because of
                  * fragmentation and cause the process to fail with OOME. Hence
                  * we want to batch up the puts in 1000 vnode increments and
-                 * let them finish before enqueueing more puts.
+                 * let them finish before enqueuing more puts.
                  */
                 var batch = _.db.batch();
                 // use this emitter to control the serial puts of vnodes.
@@ -218,7 +224,9 @@ function ConsistentHash(options, cb) {
                             }
                             return _cb();
                         });
-                    } else if (vnode % 1000 === 1) {
+                    } else if (vnode % 1000 === 0) {
+                        if (vnode % 10000 === 0 && vnode > 0)
+                            console.log('working: processed %s vnodes', vnode);
                         batch.write(function (err) {
                             if (err) {
                                 return _cb(new verror.VError('unable to ' +
@@ -471,7 +479,7 @@ function ConsistentHash(options, cb) {
                             );
                         }
 
-                        // write the VNDOE_DATA array.
+                        // write the VNODE_DATA array.
                         if (vcount === 0 && --pcount === 0) {
                             _.db.put(LKEY_VNODE_DATA, vnodeData, function(err) {
                                 if (err) {
@@ -709,6 +717,7 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
                 if (err) {
                     return _cb(new verror.VError(err, 'unable to add data'));
                 }
+
                 log.info({
                     vnodeData: vnodeData
                 }, 'ConsistentHash.addData: vnodeDataArray');
@@ -747,6 +756,7 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
 
                 return _cb(err);
             });
+            console.log('{"%s":"%s"}', vnode, data);
         }
     ], arg:{}}, function(err) {
         dtrace._fash_probes['adddata-done'].fire(function() {
@@ -756,8 +766,58 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
     });
 };
 
+/**
+ * Get a vnode with its data and pnode.
+ *
+ * @param {Number} vnode The vnode whose pnode and data we want to see.
+ * @param {function} cb The callback f(err, {})
+ */
+ConsistentHash.prototype.getDataVnode = function getDataVnode(vnode, cb) {
+    var self = this;
+
+    var log = self.log;
+    var db = self.db_;
+
+    log.info({
+        vnode: vnode
+    },'ConsistentHash.getDataVnode: entering');
+
+    assert.number(vnode, 'vnode');
+    assert.func(cb, 'callback');
+
+    vasync.pipeline({funcs: [
+        function getVnodePnode(_, _cb) {
+            db.get(sprintf(LKEY_VNODE_V, vnode), function(err, vnodePnode) {
+                if (err) {
+                    return _cb(new verror.VError('cannot get pnode for vnode ' +
+                        vnode + ', vnode ' + vnode + ' or pnode ' +
+                        vnodePnode + ' may not exist.'));
+                }
+                _.pnode = vnodePnode;
+                return _cb();
+            });
+        },
+        function getVnodeData(_, _cb) {
+            db.get(sprintf(LKEY_PNODE_P_V, _.pnode, vnode), function(err, data)
+            {
+                if (err) {
+                    return _cb(new verror.VError('cannot get data for vnode ' + vnode +
+                        ' and pnode ' + _.pnode));
+                } else {
+                    _.vnodeData = data;
+                    return _cb(null, _);
+                }
+            });
+        }
+    ], arg: {}}, function(err, results) {
+        log.info({err: err}, 'ConsistentHash.getDataVnode: exiting');
+        return cb(err, results);
+    });
+};
+
 /**
  * Get the list of vnodes with data in them.
+ * This is a helper that is used in tests.
  *
  * @param {function} cb The callback f(err, {})
  */
@@ -779,7 +839,7 @@ ConsistentHash.prototype.getDataVnodes = function getDataVnodes(cb) {
 };
 
 /**
- * Remaps a pnode on the hash ring. The node can be an existing pnode, or a new
+ * Remaps a vnode on the hash ring. The node can be on an existing pnode, or a new
  * one.
  *
  * @param {String} node The name of the node.
@@ -936,6 +996,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
                     return _cb();
                 }
             });
+            console.log('{"%s":"%s"}', newPnode, vnode);
         }
     ], arg: {}}, function(err) {
         log.info({err: err}, 'ConsistentHash.remapVnode: exiting');
diff --git a/lib/common.js b/lib/common.js
index d036abb..61b62ae 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -1,5 +1,11 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
diff --git a/lib/dtrace.js b/lib/dtrace.js
index 15ec107..e2b79ae 100644
--- a/lib/dtrace.js
+++ b/lib/dtrace.js
@@ -1,5 +1,11 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var PROBES = {
diff --git a/lib/index.js b/lib/index.js
index f4e19b1..84e64d9 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -1,5 +1,11 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
diff --git a/package.json b/package.json
index 76741da..ac2bc73 100644
--- a/package.json
+++ b/package.json
@@ -21,7 +21,7 @@
     "dynamo",
     "hash ring"
   ],
-  "version": "2.3.1",
+  "version": "2.3.2",
   "repository": {
     "type": "git",
     "url": "https://github.com/yunong/node-fash.git"
@@ -43,7 +43,7 @@
     "leveldown": "0.8.0",
     "once": "1.1.1",
     "redis": "0.8.4",
-    "vasync": "1.3.3",
+    "vasync": "1.6.4",
     "verror": "1.3.6"
   },
   "optionalDependencies": {
@@ -59,6 +59,9 @@
   "bin": {
     "fash": "bin/fash.js"
   },
+  "config": {
+    "leveldb_test_algorithm": "sha256"
+  },
   "scripts": {
     "pretest": "./lint.sh",
     "test": "./node_modules/.bin/nodeunit test/*.test.js"
diff --git a/test/in_memory.test.js b/test/in_memory.test.js
index 68871f7..706840c 100644
--- a/test/in_memory.test.js
+++ b/test/in_memory.test.js
@@ -1,3 +1,13 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
 var bignum = require('bignum');
 var crypto = require('crypto');
 var common = require('../lib/common');
diff --git a/test/leveldb.test.js b/test/leveldb.test.js
index 331b769..6fd5eca 100644
--- a/test/leveldb.test.js
+++ b/test/leveldb.test.js
@@ -1,3 +1,13 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
 var bignum = require('bignum');
 var crypto = require('crypto');
 var common = require('../lib/common');
@@ -25,7 +35,8 @@ var NUMBER_OF_VNODES = parseInt(process.env.NUMBER_OF_VNODES || 100);
 var NUMBER_OF_PNODES = parseInt(process.env.NUMBER_OF_PNODES || 10);
 var PNODES = new Array(NUMBER_OF_PNODES);
 var PNODE_STRING = '\'';
-var ALGORITHM = ['sha256', 'sha1', 'md5'];
+var ALGORITHM = [process.env.npm_package_config_leveldb_test_algorithm] ||
+    ['sha256', 'sha1', 'md5'];
 
 exports.beforeTest = function (t) {
     for (var i = 0; i < NUMBER_OF_PNODES; i++) {
@@ -515,6 +526,90 @@ _testAllConstructors(function addDataBackToNull(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function getDataVnode(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel) {
+                _.hLevel = hLevel;
+                return cb(err);
+            });
+        },
+        function pickVnode(_, cb) {
+            _.key = uuid.v4();
+            _.hLevel.getNode(_.key, function (err, node) {
+                _.node = node;
+                return cb(err);
+            });
+        },
+        function getDataVnode(_, cb) {
+            _.hLevel.getDataVnode(_.node.vnode, function (err, data) {
+                if (err) {
+                    return cb(err);
+                }
+                t.strictEqual(data.successes[1].pnode, _.node.pnode,
+                    'pnode output does not match');
+                t.strictEqual(data.successes[1].vnodeData, _.node.data,
+                    'data output does not match');
+                return cb();
+            });
+        },
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
+_testAllConstructors(function getDataVnodeReadOnly(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel) {
+                _.hLevel = hLevel;
+                return cb(err);
+            });
+        },
+        function pickVnode(_, cb) {
+            _.key = uuid.v4();
+            _.hLevel.getNode(_.key, function (err, node) {
+                _.node = node;
+                return cb(err);
+            });
+        },
+        function addData(_, cb) {
+            _.hLevel.addData(_.node.vnode, 'ro', cb);
+        },
+        function getNode(_, cb) {
+            _.hLevel.getNode(_.key, function (err, node) {
+                if (err) {
+                    return cb(err);
+                }
+                t.strictEqual(node.data, 'ro',
+                              'stored data should match put data');
+                _.node.data = node.data;
+                return cb();
+            });
+        },
+        function netyDataVnode(_, cb) {
+            _.hLevel.getDataVnode(_.node.vnode, function (err, data) {
+                if (err) {
+                    return cb(err);
+                }
+                t.strictEqual(data.successes[1].pnode, _.node.pnode,
+                    'pnode output does not match');
+                t.strictEqual(data.successes[1].vnodeData, _.node.data,
+                    'data output does not match');
+                return cb();
+            });
+        }
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
 _testAllConstructors(function addDataRemapVnodeToDifferentPnode(algo,
                                                                 constructor,
                                                                 t)
diff --git a/test/load.test.js b/test/load.test.js
index ba639dd..4ad1c7d 100644
--- a/test/load.test.js
+++ b/test/load.test.js
@@ -1,3 +1,13 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
 var fash = require('../lib');
 var fs = require('fs');
 var Logger = require('bunyan');
@@ -9,15 +19,18 @@ var LOG = new Logger({
     level: process.env.LOG_LEVEL || 'warn'
 });
 
-var DB_LOCATION = process.env.DB_LOCATION || '/tmp/fash-db';
-var FASH_BACKEND = process.env.FASH_BACKEND || fash.BACKEND.LEVEL_DB;
 var LVL_CFG = {
     createIfMissing: true,
-    errorIfExists: false,
+    errorIfExists: true,
     compression: false,
-    cacheSize: 800 * 1024 * 1024
+    cacheSize: 800 * 1024 * 1024,
+    keyEncoding: 'utf8',
+    valueEncoding: 'json'
 };
 
+var DB_LOCATION = process.env.DB_LOCATION || '/tmp/fash-db';
+var FASH_BACKEND = process.env.FASH_BACKEND || fash.BACKEND.LEVEL_DB;
+
 var RING = fash.load({
     log: LOG,
     backend: fash.BACKEND.LEVEL_DB,
@@ -29,19 +42,6 @@ var RING = fash.load({
     }
 });
 
-//console.log('loading ring into memory');
-//var RING = fash.deserialize({
-    //log: LOG,
-    //topology: fs.readFileSync(DB_LOCATION, 'utf-8'),
-    //backend: fash.BACKEND.IN_MEMORY,
-//}, function (err) {
-    //if (err) {
-        //throw new verror.VError(err, 'unable to load ring from disk');
-    //}
-
-    //console.log('ring loaded');
-//});
-
 var server = restify.createServer();
 server.use(restify.bodyParser());
 server.post('/hash', function (req, res, next) {
