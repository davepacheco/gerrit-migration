From 0ecf8f3294c948a7d85326bb75349849db29bb8d Mon Sep 17 00:00:00 2001
From: Brittany Wald <brittany.wald@joyent.com>
Date: Wed, 7 Jun 2017 23:45:36 +0000
Subject: [PATCH] MANTA-3279 node-fash loads the whole leveldb hash ring into
 memory

---
 Makefile                 |  22 ++++
 README.md                |  51 ++++----
 bin/fash.js              | 264 ++++++++++++++++++++++++++++-----------
 lib/backend/in_memory.js | 100 +++++++++------
 lib/backend/leveldb.js   | 151 ++++++++++++++++------
 lib/common.js            |  42 ++++++-
 lib/dtrace.js            |  10 +-
 lib/index.js             |  12 +-
 package.json             |   8 +-
 test/in_memory.test.js   |  10 ++
 test/leveldb.test.js     | 100 ++++++++++++++-
 test/load.test.js        |  34 ++---
 12 files changed, 596 insertions(+), 208 deletions(-)
 create mode 100644 Makefile

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..a9318c5
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,22 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+.PHONY: all test prepush
+
+all:
+	npm install
+
+test:
+	npm test
+
+prepush:
+	rm -rf node_modules
+	npm install
+	npm test
\ No newline at end of file
diff --git a/README.md b/README.md
index a649fb3..1deeb87 100644
--- a/README.md
+++ b/README.md
@@ -16,7 +16,7 @@ fash provides the ability to add, remove, or remap physical nodes on the ring
 Fash consists of a mapping of a set of fixed virtual nodes (vnodes) -- usually
 a large number, say 1000000 -- distributed across the hash ring. It is then
 possible to map these virtual nodes to a set of physical nodes (pnodes).  In
-practice, pnodes are usuall physical shards or servers in a distributed system.
+practice, pnodes are usually physical shards or servers in a distributed system.
 This gives the flexibility of mutating the hashspace of pnodes and the number
 of pnodes by re-mapping the vnode assignments.
 
@@ -52,6 +52,13 @@ To select a backend, simply pass in a backend object like so to fash.create();
     });
 ```
 
+Or from, the command line:
+
+```
+./bin/fash.js create -v 1000000 -b leveldb -l {filepath/to/hash_ring} -p '{pnodename}''
+
+```
+
 # Example
 
 Most examples can be found in the unit tests. Here are a few.
@@ -88,9 +95,9 @@ the remapNode() function, which returns an optional callback.
 
 You can also remove pnodes from the ring, but **you must first rebalance the
 ring by reassigning its vnodes to other pnodes** via remapVnode(). Then you can
-invoke removeNode(), which will eturn an optional callback.
+invoke removeNode(), which will return an optional callback.
 
-You can assign an arbitrary number of vnodes to the new vnode -- also -- the
+You can assign an arbitrary number of vnodes to the new pnode -- also -- the
 pnode can be a new node, or an existing one.  Again, as long as the order of
 removes and remaps is consistent across all clients, the ring toplogy will be
 consistent as well.
@@ -123,10 +130,11 @@ consistent as well.
 
 ## Adding More Pnodes to the Ring
 You can add additional pnodes to the ring after fash has been initialized by
-invoking remapVnode(). which optionally returns a callback. Note, adding the
-callback will cause fash to create a new copy of the ring topology across each
-invocation -- do not do this if you have millions of vnodes, as this is quite
-slow.
+invoking remapVnode(), which optionally returns a callback. Note that adding
+the callback will cause fash to create a new copy of the ring topology across
+each invocation -- do not do this if you have millions of vnodes, as this is
+quite slow and may consume all available memory, bringing the operation to a
+standstill and locking up other resources.
 
     var fash = require('fash');
     var Logger = require('bunyan');
@@ -256,22 +264,13 @@ mentioned in the earlier bootstrapping section.
 
 That's it, chash and chash2 now contain the same ring toplogy.
 
-Copyright (c) 2013 Yunong Xiao
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the "Software"), to deal in
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-of the Software, and to permit persons to whom the Software is furnished to do
-so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
+## Running Tests
+
+Just run `make test`, first exporting the DB_LOCATION variable for the load
+test file to give it the location of your hash ring.
+
+Copyright (c) 2017, Joyent, Inc.
+
+This Source Code Form is subject to the terms of the Mozilla Public
+License, v. 2.0. If a copy of the MPL was not distributed with this
+file, You can obtain one at http://mozilla.org/MPL/2.0/.
\ No newline at end of file
diff --git a/bin/fash.js b/bin/fash.js
index 3acc976..7d0b94d 100755
--- a/bin/fash.js
+++ b/bin/fash.js
@@ -1,13 +1,18 @@
 #!/usr/bin/env node
 
-/**
- * Copyright (c) 2013, Yunong J Xiao. All rights reserved.
- *
- * fash.js: CLI tool for node-fash
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var bunyan = require('bunyan');
 var cmdln = require('cmdln');
+var common = require('../lib/common');
 var fash = require('../lib/index');
 var fs = require('fs');
 var sprintf = require('util').format;
@@ -50,13 +55,16 @@ Fash.prototype.do_create = function (subcmd, opts, args, callback) {
         });
     }
 
-    var pnodes = opts.p.split(' ');
+    var pnodes = opts.p.split(/[, ]+/);
+    var pnodeArray = [];
+
     for (var i = 0; i < pnodes.length; i++) {
-        var p = pnodes[i];
-        if (!p || p === '') {
-            pnodes.splice(i, 1);
+        if (!pnodes[i] || pnodes[i] === '' || pnodes[i] === ',') {
+            continue;
         }
+        pnodeArray.push(pnodes[i]);
     }
+
     switch (opts.b) {
         case BACKENDS.IN_MEMORY:
             opts.b = fash.BACKEND.IN_MEMORY;
@@ -71,7 +79,7 @@ Fash.prototype.do_create = function (subcmd, opts, args, callback) {
     fash.create({
         log: self.log,
         algorithm: opts.a || 'sha256',
-        pnodes: pnodes,
+        pnodes: pnodeArray,
         vnodes: opts.v,
         backend: opts.b,
         location: opts.l
@@ -193,8 +201,8 @@ Fash.prototype.do_deserialize_ring.help = (
     'load a hash ring into leveldb. Accepts input over stdin or via a file.\n'
     + '\n'
     + 'usage:\n'
-    + '     fash deserialize_ring [options] \n'
-    + '     cat /tmp/example_ring.json | fash deserialize_ring [options] \n'
+    + '     fash deserialize-ring [options] \n'
+    + '     cat /tmp/example_ring.json | fash deserialize-ring [options] \n'
     + '\n'
     + '{{options}}'
 );
@@ -260,24 +268,22 @@ Fash.prototype.do_add_data = function (subcmd, opts, args, callback) {
         function loadRing(_, cb) {
             hash = constructor(hashOptions, cb);
         },
+        function getVnodeArray(_, cb) {
+            var vnodes = common.parseIntArray(opts.v);
+            _.vnodes = vnodes;
+            return cb();
+        },
         function addData(_, cb) {
             var count = 0;
-            var vnodes = opts.v.split(' ');
-            for (var i = 0; i < vnodes.length; i++) {
-                var v = vnodes[i];
-                if (!v || v === '') {
-                    vnodes.splice(i, 1);
-                }
-            }
-            hash.addData(parseInt(vnodes[count], 10), opts.d, addDataCb);
+            hash.addData(parseInt(_.vnodes[count], 10), opts.d, addDataCb);
             function addDataCb(err) {
                 if (err) {
                     return cb(err);
                 }
-                if (++count === vnodes.length) {
+                if (++count === _.vnodes.length) {
                     return cb();
                 } else {
-                    hash.addData(parseInt(vnodes[count], 10),
+                    hash.addData(parseInt(_.vnodes[count], 10),
                                  opts.d, addDataCb);
                 }
                 return (undefined);
@@ -285,16 +291,20 @@ Fash.prototype.do_add_data = function (subcmd, opts, args, callback) {
             return (undefined);
         },
         function printRing(_, cb) {
-            hash.serialize(function (_err, sh) {
-                if (_err) {
-                    return cb(new verror.VError(_err,
-                                                'unable to print hash'));
-                }
-                if (opts.o) {
-                    console.log(sh);
-                }
+            if (opts.o) {
+                hash.serialize(function (_err, sh) {
+                    if (_err) {
+                        return cb(new verror.VError(_err,
+                                                    'unable to print hash'));
+                    }
+                    if (opts.o) {
+                        console.log(sh);
+                    }
+                    return cb();
+                });
+            } else {
                 return cb();
-            });
+            }
         }
     ], arg: {}}, function (err) {
         if (err) {
@@ -304,6 +314,7 @@ Fash.prototype.do_add_data = function (subcmd, opts, args, callback) {
     });
     return (undefined);
 };
+
 Fash.prototype.do_add_data.options = [ {
     names: [ 'v', 'vnode' ],
     type: 'string',
@@ -321,17 +332,18 @@ Fash.prototype.do_add_data.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'o', 'output' ],
     type: 'bool',
-    help: 'serialize and print out the resulting hash to stdout'
+    help: 'serialize and print out the resulting hash to stdout \n' +
+          'WARNING: may consume a large quantity of memory.'
 }];
 Fash.prototype.do_add_data.help = (
     'add data to a vnode.\n'
     + '\n'
     + 'usage:\n'
-    + '     fash add_data [options] \n'
+    + '     fash add-data [options] \n'
     + '\n'
     + '{{options}}'
 );
@@ -397,40 +409,42 @@ Fash.prototype.do_remap_vnode = function (subcmd, opts, args, callback) {
         function loadRing(_, cb) {
             hash = constructor(hashOptions, cb);
         },
+        function getVnodeArray(_, cb) {
+            var vnodes = common.parseIntArray(opts.v);
+            _.vnodes = vnodes;
+            return cb();
+        },
         function remap(_, cb) {
             var count = 0;
-            var vnodes = opts.v.split(' ');
-            for (var i = 0; i < vnodes.length; i++) {
-                var v = vnodes[i];
-                if (!v || v === '') {
-                    vnodes.splice(i, 1);
-                }
-            }
-            hash.remapVnode(opts.p, parseInt(vnodes[count], 10), remapCb);
+            hash.remapVnode(opts.p, parseInt(_.vnodes[count], 10), remapCb);
             function remapCb(err) {
                 if (err) {
                     return cb(err);
                 }
-                if (++count === vnodes.length) {
+                if (++count === _.vnodes.length) {
                     return cb();
                 } else {
-                    hash.remapVnode(opts.p, parseInt(vnodes[count], 10),
+                    hash.remapVnode(opts.p, parseInt(_.vnodes[count], 10),
                                     remapCb);
                 }
                 return (undefined);
             }
         },
         function printRing(_, cb) {
-            hash.serialize(function (_err, sh) {
-                if (_err) {
-                    return cb(new verror.VError(_err,
-                                                'unable to print hash'));
-                }
-                if (opts.o) {
-                    console.log(sh);
-                }
+            if (opts.o) {
+                hash.serialize(function (_err, sh) {
+                    if (_err) {
+                        return cb(new verror.VError(_err,
+                                                    'unable to print hash'));
+                    }
+                    if (opts.o) {
+                        console.log(sh);
+                    }
+                    return cb();
+                });
+            } else {
                 return cb();
-            });
+            }
         }
     ], arg: {}}, function (err) {
         if (err) {
@@ -457,17 +471,18 @@ Fash.prototype.do_remap_vnode.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'o', 'output' ],
     type: 'bool',
-    help: 'serialize and print out the resulting hash to stdout'
+    help: 'serialize and print out the resulting hash to stdout \n' +
+          'WARNING: may consume a large quantity of memory.'
 }];
 Fash.prototype.do_remap_vnode.help = (
     'remap a vnode to a different pnode.\n'
     + '\n'
     + 'usage:\n'
-    + '     fash remap_vnode [options] \n'
+    + '     fash remap-vnode [options] \n'
     + '\n'
     + '{{options}}'
 );
@@ -537,15 +552,20 @@ Fash.prototype.do_remove_pnode = function (subcmd, opts, args, callback) {
             hash.removePnode(opts.p, cb);
         },
         function printRing(_, cb) {
-            hash.serialize(function (_err, sh) {
-                if (_err) {
-                    return cb(new verror.VError(_err, 'unable to print hash'));
-                }
-                if (opts.o) {
-                    console.log(sh);
-                }
+            if (opts.o) {
+                hash.serialize(function (_err, sh) {
+                    if (_err) {
+                        return cb(new verror.VError(_err,
+                            'unable to print hash'));
+                    }
+                    if (opts.o) {
+                        console.log(sh);
+                    }
+                    return cb();
+                });
+            } else {
                 return cb();
-            });
+            }
         }
     ], arg: {}}, function (err) {
         if (err) {
@@ -561,7 +581,7 @@ Fash.prototype.do_remove_pnode.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'p', 'pnode' ],
     type: 'string',
@@ -579,7 +599,7 @@ Fash.prototype.do_remove_pnode.help = (
     'remove a pnode'
     + '\n'
     + 'usage:\n'
-    + '     fash remove_pnode [options] \n'
+    + '     fash remove-pnode [options] \n'
     + '\n'
     + '{{options}}'
 );
@@ -668,7 +688,7 @@ Fash.prototype.do_get_pnodes.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'b', 'backend' ],
     type: 'string',
@@ -678,7 +698,7 @@ Fash.prototype.do_get_pnodes.help = (
     'get all the pnodes in the ring'
     + '\n'
     + 'usage:\n'
-    + '     fash get_pnodes [options]\n'
+    + '     fash get-pnodes [options]\n'
     + '\n'
     + '{{options}}'
 );
@@ -767,7 +787,7 @@ Fash.prototype.do_get_vnodes.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'b', 'backend' ],
     type: 'string',
@@ -777,13 +797,108 @@ Fash.prototype.do_get_vnodes.help = (
     'get the vnodes owned by a pnode'
     + '\n'
     + 'usage:\n'
-    + '     fash get_vnodes [options] pnode\n'
+    + '     fash get-vnodes [options] pnode\n'
+    + '\n'
+    + '{{options}}'
+);
+
+Fash.prototype.do_get_vnode_pnode_and_data =
+    function (subcmd, opts, args, callback) {
+        var self = this;
+
+        if (opts.help || !opts.v) {
+            this.do_help('help', {}, [subcmd], function (err) {
+                return callback(err ? err : true);
+            });
+        }
+
+        var hashOptions = {
+            log: self.log
+        };
+        var hash;
+        var constructor;
+
+        vasync.pipeline({funcs: [
+            function prepInput(_, cb) {
+                if (!opts.l) {
+                    console.error('leveldb backend requires a location');
+                    self.do_help('help', {}, [subcmd], function (err) {
+                        return callback(err ? err : true);
+                    });
+                } else {
+                    hashOptions.location = opts.l;
+                    return cb();
+                }
+                return (undefined);
+            },
+            function loadRing(_, cb) {
+                // We choose not to support an IN_MEMORY backend.
+                hashOptions.backend = fash.BACKEND.LEVEL_DB;
+                constructor = fash.load;
+                hash = constructor(hashOptions, cb);
+            },
+            function getVnodeArray(_, cb) {
+                var vnodes = common.parseIntArray(opts.v);
+                _.vnodes = vnodes;
+                return cb();
+            },
+            function getVnodePnodeAndData(_, cb) {
+                var dataHash = {};
+                function getResults(input, _cb) {
+                    hash.getVnodePnodeAndData(input,
+                        function (err, pnode, vnodeData) {
+                        if (err) {
+                            return _cb(verror.VError(err,
+                                'unable to get pnode and data for for vnode ',
+                                input));
+                        }
+                        dataHash[input] = {};
+                        dataHash[input]['pnode'] = pnode;
+                        dataHash[input]['vnodeData'] = vnodeData;
+                        return _cb(err, null);
+                    });
+                }
+
+                vasync.forEachPipeline({
+                    'inputs': _.vnodes,
+                    'func': getResults
+                }, function (err) {
+                    if (err) {
+                        return console.error(new verror.VError(err,
+                            'unable to construct hash for vnode '));
+                    }
+                    console.log('vnodes: ', dataHash);
+                });
+            }
+        ], arg: {}}, function (err) {
+            if (err)
+                console.error(new verror.VError(err));
+        });
+
+        return (undefined);
+};
+Fash.prototype.do_get_vnode_pnode_and_data.options = [ {
+    names: [ 'v', 'vnodes' ],
+    type: 'string',
+    help: 'the vnode(s) to inspect'
+}, {
+    names: [ 'l', 'location' ],
+    type: 'string',
+    help: 'the location of the topology, assuming a leveldb backend, \n' +
+          'this is the path to the leveldb on disk.'
+}];
+Fash.prototype.do_get_vnode_pnode_and_data.help = (
+    'get the data and pnode(s) associated with a set of vnodes'
+    + '\n'
+    + 'usage:\n'
+    + '     fash get-vnode-pnode-and-data [options]\n'
     + '\n'
     + '{{options}}'
 );
 
 Fash.prototype.do_get_node = function (subcmd, opts, args, callback) {
     var self = this;
+
     if (opts.help || !opts.b || args.length !== 1) {
         this.do_help('help', {}, [subcmd], function (err) {
             return callback(err ? err : true);
@@ -865,7 +980,7 @@ Fash.prototype.do_get_node.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'b', 'backend' ],
     type: 'string',
@@ -875,7 +990,7 @@ Fash.prototype.do_get_node.help = (
     'hash a value to its spot on the ring'
     + '\n'
     + 'usage:\n'
-    + '     fash get_node [options] value\n'
+    + '     fash get-node [options] value\n'
     + '\n'
     + '{{options}}'
 );
@@ -964,17 +1079,17 @@ Fash.prototype.do_print_hash.options = [ {
     type: 'string',
     help: 'the location of the topology, if using the in_memory backend, \n' +
           'this is the location of the serialized ring on disk, if using \n ' +
-          'the leveldb backend, this is the path to the levedb on disk.'
+          'the leveldb backend, this is the path to the leveldb on disk.'
 }, {
     names: [ 'b', 'backend' ],
     type: 'string',
     help: 'the backend to use'
 }];
 Fash.prototype.do_print_hash.help = (
-    'print out the hash ring'
+    'print out the hash ring, WARNING: may consume a large quantity of memory.'
     + '\n'
     + 'usage:\n'
-    + '     fash print_hash [options] value\n'
+    + '     fash print-hash [options] value\n'
     + '\n'
     + '{{options}}'
 );
@@ -1219,6 +1334,7 @@ Fash.prototype.do_diff.help = (
 var cli = new Fash();
 cli.main(process.argv, function (err, subcmd) {
     if (err) {
+        console.error(err);
         process.exit(1);
     } else {
         process.exit(0);
diff --git a/lib/backend/in_memory.js b/lib/backend/in_memory.js
index 3d72c51..1d6d4ec 100644
--- a/lib/backend/in_memory.js
+++ b/lib/backend/in_memory.js
@@ -1,5 +1,11 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -14,12 +20,12 @@ var sprintf = util.format;
 var verror = require('verror');
 
 
-/**
+/*
  * Global variables.
  */
 var DATA_NULL = 1;
 
-/**
+/*
  * Creates an instance of ConsistentHash.
  *
  * @constructor
@@ -60,12 +66,12 @@ function ConsistentHash(options, callback) {
     log.trace('new ConsistentHash with options', options);
     assert.optionalFunc(callback, 'callback');
 
-    /**
+    /*
      * The hash algorithm used determine the position of a key.
      */
     self.algorithm_ = options.algorithm;
 
-    /**
+    /*
      * The maximum output size of the hash algorithm. Used to determine the
      * hash interval between each vnode.
      */
@@ -80,27 +86,27 @@ function ConsistentHash(options, callback) {
     self.VNODE_HASH_INTERVAL = self.algorithmMax_.div(self.vnodesBignum_);
     self.algorithm_.VNODE_HASH_INTERVAL = self.VNODE_HASH_INTERVAL.toString(16);
 
-    /**
+    /*
      * The String array of physical nodes in the ring.
      */
     self.pnodes_ = options.pnodes ? options.pnodes.slice() : [];
     self.pnodes_.sort();
 
-    /**
+    /*
      * Map of {pnode -> {vnode1 ->{}, vnode2, ...}} Keeps track of the physical
      * node to virtual node mapping. Also keeps track of an optional data
      * object.
      */
     self.pnodeToVnodeMap_ = {};
 
-    /**
+    /*
      * Map of {vnode -> {pnode, data}. Contains the pnode and an optional data
      * object. If you want the actual pnode, you'll need to dereference as
      * self.vnodeToPnodeMap_[vnode].pnode -- otherwise you'll get the object.
      */
     self.vnodeToPnodeMap_ = {};
 
-    /**
+    /*
      * array of all the vnodes that have non-null data
      */
     self.vnodeData_ = [];
@@ -161,8 +167,10 @@ function ConsistentHash(options, callback) {
             return (undefined);
         });
 
-        // Allocate the vnodes to the pnodes by
-        // vnode % total_pnode = assigned pnode.
+        /*
+         * Allocate the vnodes to the pnodes by
+         * vnode % total_pnode = assigned pnode.
+         */
         function allocateVnode() {
             for (var vnode = 0; vnode < self.vnodeCount_; vnode++) {
                 var pnode = self.pnodes_[vnode % self.pnodes_.length];
@@ -181,8 +189,10 @@ function ConsistentHash(options, callback) {
                 if (!self.pnodeToVnodeMap_[pnode]) {
                     self.pnodeToVnodeMap_[pnode] = {};
                 }
-                // assign the pnode->vnode and vnode->pnode maps
-                // set the data here to 1 since this is a new ring
+                /*
+                 * assign the pnode->vnode and vnode->pnode maps
+                 * set the data here to 1 since this is a new ring
+                 */
                 self.pnodeToVnodeMap_[pnode][vnode] = 1;
                 self.vnodeToPnodeMap_[vnode] = {
                     pnode: pnode
@@ -212,12 +222,12 @@ function ConsistentHash(options, callback) {
     }
 }
 
-/**
+/*
  * @exports ConsistentHash as Consistenthash
  */
 module.exports = ConsistentHash;
 
-/**
+/*
  * Adds a data element to a vnode. If data already existed for the vnode, this
  * will over-write it. This is useful if you want to add stateful changes to a
  * set of particular vnodes -- for example, setting some vnodes to read only.
@@ -232,10 +242,12 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
     });
     var self = this;
     var log = self.log;
-    // node-fash#8: data has to be null and not undefined, otherwise
-    // serialize() aka JSON.stringify ignores keys where the value is
-    // undefined. This means that the vnode gets removed from the serialized
-    // topology!
+    /*
+     * node-fash#8: data has to be null and not undefined, otherwise
+     * serialize() aka JSON.stringify ignores keys where the value is
+     * undefined. This means that the vnode gets removed from the serialized
+     * topology!
+     */
     if (!data) {
         data = DATA_NULL;
     }
@@ -248,8 +260,10 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
     var pnode = self.vnodeToPnodeMap_[vnode];
     assert.object(pnode, 'vnode ' + vnode + ' doesn\'t map to pnode');
 
-    // data needs to be changed in both pvmap and vpmap
-    // change pvmap
+    /*
+     * data needs to be changed in both pvmap and vpmap
+     * change pvmap
+     */
     pnode.data = data;
     // change vpmap
     self.pnodeToVnodeMap_[pnode.pnode][vnode] = data;
@@ -282,7 +296,7 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
     return (undefined);
 };
 
-/**
+/*
  * Get the list of vnodes with data in them.
  *
  * @param {function} cb The callback f(err, {})
@@ -295,7 +309,7 @@ ConsistentHash.prototype.getDataVnodes = function getDataVnodes(cb) {
     return this.vnodeData_;
 };
 
-/**
+/*
  * Remaps a pnode on the hash ring. The node can be an existing pnode, or a new
  * one.
  *
@@ -322,10 +336,12 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnodes, cb)
     assert.optionalArrayOfNumber(vnodes, 'vnodes');
     assert.optionalFunc(cb, 'callback');
 
-    // assert the vnodes, ensuring that:
-    // 1) vnode actually exist.
-    // 2) vnode doesn't already belong to the newPnode.
-    // 3) vnodes are specified once and only once.
+    /*
+     * assert the vnodes, ensuring that:
+     * 1) vnode actually exist.
+     * 2) vnode doesn't already belong to the newPnode.
+     * 3) vnodes are specified once and only once.
+     */
     var vnodeMap = {};
     if (vnodes) {
         vnodes.forEach(function(v) {
@@ -378,9 +394,11 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnodes, cb)
             vnodeData: vnodeData
         }, 'ConsistentHash.remapVnode: remopping vnode');
 
-        // add vnode to new pnode
-        // 1) move the vnode object from the old pvmap to the new pvmap. Since
-        // we're just moving the vnode, there's no need to write any new values
+        /*
+         * add vnode to new pnode
+         * 1) move the vnode object from the old pvmap to the new pvmap. Since
+         * we're just moving the vnode, there's no need to write any new values
+         */
         self.pnodeToVnodeMap_[newPnode][vnode] =
             self.pnodeToVnodeMap_[oldPnode][vnode];
         // 2) add a new pnode,data object to the vpmap for the current vnode.
@@ -389,9 +407,11 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnodes, cb)
             data: vnodeData
         };
 
-        // remove vnode from current pnode mapping. but first set the value to
-        // 1 -- otherwise the vnode gets removed from the new pnode mappings
-        // as well.
+        /*        
+         * remove vnode from current pnode mapping. but first set the value to
+         * 1 -- otherwise the vnode gets removed from the new pnode mappings
+         * as well.
+         */
         self.pnodeToVnodeMap_[oldPnode][vnode] = 1;
         delete self.pnodeToVnodeMap_[oldPnode][vnode];
 
@@ -421,7 +441,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnodes, cb)
     return (undefined);
 };
 
-/**
+/*
  * Removes a pnode from the hash ring.  Note the pnode must not map to any
  * vnodes.  Remove the vnodes first by re-assigning them to other pnodes before
  * invoking this function.
@@ -506,7 +526,7 @@ ConsistentHash.prototype.getPnodes = function getPnodes(cb) {
     return self.pnodes_;
 };
 
-/**
+/*
  * Get the array of vnodes that belong to a particular pnode
  *
  * @param {String} pnode The pnode.
@@ -547,7 +567,7 @@ ConsistentHash.prototype.getVnodes = function getVnodes(pnode, cb) {
     return vnodeArray;
 };
 
-/**
+/*
  * Gets the pnode and vnode that a key belongs to on the ring.
  *
  * @param {String} key The key.
@@ -573,7 +593,7 @@ ConsistentHash.prototype.getNode = function getNode(key, cb) {
     return {pnode: pnode, vnode: vnode, data: data};
 };
 
-/**
+/*
  * Gets the vnode map.
  *
  * @returns {Object} vnodeToPnodeMap Map of {vnode -> {pnode, data}. Contains
@@ -585,7 +605,7 @@ ConsistentHash.prototype.getAllVnodes = function getAllVnodes() {
     return this.vnodeToPnodeMap_;
 };
 
-/**
+/*
  * Serialize the current state of the ring in serialized to a JSON string.
  *
  * @return {Object} ring The updated ring topology.
@@ -619,7 +639,7 @@ ConsistentHash.prototype.serialize = function serialize(callback) {
 
 // Private Functions
 
-/**
+/*
  * Simply divide the hash by the number of vnodes to find which vnode maps to
  * this hash.
  * @param {String} the value of the hash string in hex.
diff --git a/lib/backend/leveldb.js b/lib/backend/leveldb.js
index ccb4e80..92573a0 100644
--- a/lib/backend/leveldb.js
+++ b/lib/backend/leveldb.js
@@ -1,5 +1,11 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -18,7 +24,7 @@ var vasync = require('vasync');
 var verror = require('verror');
 
 
-/**
+/*
  * level db keys.
  */
 var LKEY_VNODE_COUNT = 'VNODE_COUNT';
@@ -31,12 +37,12 @@ var LKEY_ALGORITHM = 'ALGORITHM';
 var LKEY_VERSION = 'VERSION';
 var LKEY_COMPLETE = 'COMPLETE';
 
-/**
+/*
  * leveldb values.
  */
 var LVAL_NULL = 1;
 
-/**
+/*
  * leveldb default config
  */
 var LEVEL_CONFIG = {
@@ -48,7 +54,7 @@ var LEVEL_CONFIG = {
     valueEncoding: 'json'
 };
 
-/**
+/*
  * Creates an instance of ConsistentHash backed by leveldb.
  *
  * @constructor
@@ -94,26 +100,27 @@ function ConsistentHash(options, cb) {
 
     log.trace('new ConsistentHash with options', options);
 
-    /**
-     * the datapath leveldb
+    /*
+     * The datapath leveldb.
      */
     self.db_ = null;
-    /**
+    /*
      * The hash algorithm used determine the position of a key.
      */
     self.algorithm_ = null;
 
-    /**
+    /*
      * The leveldb configs.
      */
     self.leveldbCfg_ = options.leveldbCfg || LEVEL_CONFIG;
-    /* regardless of what is set, always set keyEncoding to utf8 and
+    /* 
+     * Regardless of what is set, always set keyEncoding to utf8 and
      * valueEncoding to json. Otherwise fash will not work.
      */
     self.leveldbCfg_.keyEncoding = LEVEL_CONFIG.keyEncoding;
     self.leveldbCfg_.valueEncoding = LEVEL_CONFIG.valueEncoding;
 
-    /**
+    /*
      * 1) create 'VNODE_COUNT' key which keeps track of the # of vnodes.
      * 2) create /VNODE/V keys which map vnodes to pnodes. The value is the
      * corresponding pnode.
@@ -182,7 +189,7 @@ function ConsistentHash(options, cb) {
                     return _cb(err);
                 });
             },
-            /**
+            /*
              * steps 2, 3
              * Allocate the vnodes to the pnodes by
              * vnode % total_pnode = assigned pnode.
@@ -193,9 +200,9 @@ function ConsistentHash(options, cb) {
                 _.pnodeToVnodeMap = {};
 
                 /*
-                 * #21 Batch up the vnode puts here. Becauase we are running in
-                 * a tight for loop, _every_ put get enqueued onto the node
-                 * work queue before they actually get procecessed. This means
+                 * #21 Batch up the vnode puts here. Because we are running in
+                 * a tight for loop, _every_ put gets enqueued onto the node
+                 * work queue before it is actually processed. This means
                  * that we are allocating a huge amount of memory and not
                  * deallocating it until every node has been enqueued. On
                  * sufficiently large counts of vnodes, say 10 000 000, we
@@ -203,7 +210,7 @@ function ConsistentHash(options, cb) {
                  * mmap(1) or v8 will fail to grow the heap because of
                  * fragmentation and cause the process to fail with OOME. Hence
                  * we want to batch up the puts in 1000 vnode increments and
-                 * let them finish before enqueueing more puts.
+                 * let them finish before enqueuing more puts.
                  */
                 var batch = _.db.batch();
                 // use this emitter to control the serial puts of vnodes.
@@ -218,7 +225,9 @@ function ConsistentHash(options, cb) {
                             }
                             return _cb();
                         });
-                    } else if (vnode % 1000 === 1) {
+                    } else if (vnode % 1000 === 0) {
+                        if (vnode % 10000 === 0 && vnode > 0)
+                            console.log('working: processed %s vnodes', vnode);
                         batch.write(function (err) {
                             if (err) {
                                 return _cb(new verror.VError('unable to ' +
@@ -360,7 +369,7 @@ function ConsistentHash(options, cb) {
         });
     }
 
-    /**
+    /*
      * 1) write vnodeCount.
      * 2) write /PNODE/PNODE, /PNODE/PNODE/VNODE, /VNODE/VNODE keys.
      * 3) write metadata.
@@ -424,8 +433,10 @@ function ConsistentHash(options, cb) {
                     // write /P/P and /V/V. and /P/P/V
                     vnodes.forEach(function(vnode, index) {
 
-                        // json serializes vnode into a string, we need to
-                        // parse it back into an integer before we store it
+                        /*
+                         * json serializes vnode into a string, we need to
+                         * parse it back into an integer before we store it
+                         */
                         vnodes[index] = parseInt(vnode, 10);
 
                         // write /V/V
@@ -449,14 +460,18 @@ function ConsistentHash(options, cb) {
                             }
                         );
 
-                        // put the vnode in the VNODE_DATA array if it contains
-                        // data
+                        /*
+                         * put the vnode in the VNODE_DATA array if it contains
+                         * data
+                         */
                         if (pvMap[pnode][vnode] !== LVAL_NULL) {
                             vnodeData.push(vnode);
                         }
 
-                        // write /P/P once all the vnodes have been parsed back
-                        // into ints.
+                        /* 
+                         * write /P/P once all the vnodes have been parsed back
+                         * into ints.
+                         */
                         vcount--;
                         if (vcount === 0) {
                             _.db.put(
@@ -471,7 +486,7 @@ function ConsistentHash(options, cb) {
                             );
                         }
 
-                        // write the VNDOE_DATA array.
+                        // write the VNODE_DATA array.
                         if (vcount === 0 && --pcount === 0) {
                             _.db.put(LKEY_VNODE_DATA, vnodeData, function(err) {
                                 if (err) {
@@ -612,12 +627,12 @@ function ConsistentHash(options, cb) {
     }
 }
 
-/**
+/*
  * @exports ConsistentHash as Consistenthash
  */
 module.exports = ConsistentHash;
 
-/**
+/*
  * Gets the pnode and vnode that a key belongs to on the ring.
  *
  * @param {String} key The key.
@@ -660,7 +675,7 @@ ConsistentHash.prototype.getNode = function getNode(key, callback) {
 };
 
 
-/**
+/*
  * Adds a data element to a vnode. If data already existed for the vnode, this
  * will over-write it. This is useful if you want to add stateful changes to a
  * set of particular vnodes -- for example, setting some vnodes to read only.
@@ -709,6 +724,7 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
                 if (err) {
                     return _cb(new verror.VError(err, 'unable to add data'));
                 }
+
                 log.info({
                     vnodeData: vnodeData
                 }, 'ConsistentHash.addData: vnodeDataArray');
@@ -747,6 +763,7 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
 
                 return _cb(err);
             });
+            console.log('{"%s":"%s"}', vnode, data);
         }
     ], arg:{}}, function(err) {
         dtrace._fash_probes['adddata-done'].fire(function() {
@@ -756,8 +773,67 @@ ConsistentHash.prototype.addData = function addData(vnode, data, cb) {
     });
 };
 
-/**
+/*
+ * Get a vnode with its data and pnode.
+ *
+ * @param {Number} vnode The vnode whose pnode and data we want to see.
+ * @param {function} cb The callback f(err, String, String)
+ */
+ConsistentHash.prototype.getVnodePnodeAndData = function getVnodePnodeAndData(vnode, cb) {
+    var self = this;
+
+    var log = self.log;
+    var db = self.db_;
+
+    log.info({
+        vnode: vnode
+    },'ConsistentHash.getDataVnode: entering');
+
+    assert.number(vnode, 'vnode');
+    assert.func(cb, 'callback');
+
+    vasync.pipeline({funcs: [
+        function getVnodePnode(_, _cb) {
+            db.get(sprintf(LKEY_VNODE_V, vnode), function(err, vnodePnode) {
+                if (err) {
+                    return _cb(new verror.VError('cannot get pnode for vnode ' +
+                        vnode + ', vnode ' + vnode + ' or pnode ' +
+                        vnodePnode + ' may not exist.'));
+                }
+                _.pnode = vnodePnode;
+                return _cb();
+            });
+        },
+        function getVnodeData(_, _cb) {
+            db.get(sprintf(LKEY_PNODE_P_V, _.pnode, vnode), function(err, data)
+            {
+                if (err) {
+                    return _cb(new verror.VError('cannot get data for vnode ' + vnode +
+                        ' and pnode ' + _.pnode));
+                } else {
+                    _.vnodeData = data;
+                    return _cb(null, _);
+                }
+            });
+        }
+    ], arg: {}}, function(err, results) {
+        log.info({err: err}, 'ConsistentHash.getDataVnode: exiting');
+        if (err) {
+            console.error(new verror.VError(err));
+            return cb(err);
+        }
+
+        if (results.successes[1]) {
+            return cb(null, results.successes[1].pnode, results.successes[1].vnodeData);
+        }
+        
+        return cb();
+    });
+};
+
+/*
  * Get the list of vnodes with data in them.
+ * This is a helper that is used in tests.
  *
  * @param {function} cb The callback f(err, {})
  */
@@ -778,8 +854,8 @@ ConsistentHash.prototype.getDataVnodes = function getDataVnodes(cb) {
     });
 };
 
-/**
- * Remaps a pnode on the hash ring. The node can be an existing pnode, or a new
+/*
+ * Remaps a vnode on the hash ring. The node can be on an existing pnode, or a new
  * one.
  *
  * @param {String} node The name of the node.
@@ -803,7 +879,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
     assert.func(cb, 'callback');
 
     var oldPnode;
-    /**
+    /*
      * assert the vnodes, ensuring that:
      * 1) vnode actually exists.
      * 2) vnode doesn't already belong to the newPnode.
@@ -936,6 +1012,7 @@ ConsistentHash.prototype.remapVnode = function remapVnode(newPnode, vnode, cb) {
                     return _cb();
                 }
             });
+            console.log('{"%s":"%s"}', newPnode, vnode);
         }
     ], arg: {}}, function(err) {
         log.info({err: err}, 'ConsistentHash.remapVnode: exiting');
@@ -974,7 +1051,7 @@ ConsistentHash.prototype.getVnodes = function getVnodes(pnode, cb) {
     });
 };
 
-/**
+/*
  * Get the array of pnodes that's in this hash.
  *
  * @param {function} cb The callback f(err, map).
@@ -996,7 +1073,7 @@ ConsistentHash.prototype.getPnodes = function getPnodes(cb) {
     });
 };
 
-/**
+/*
  * Removes a pnode from the hash ring.  Note the pnode must not map to any
  * vnodes.  Remove the vnodes first by re-assigning them to other pnodes before
  * invoking this function.
@@ -1073,7 +1150,7 @@ ConsistentHash.prototype.removePnode = function removePnode(pnode, cb) {
     });
 };
 
-/**
+/*
  * Serialize the current state of the ring in serialized to a JSON string.
  *
  * @param {Function} callback The callback of the form f(err, Object).
@@ -1173,7 +1250,7 @@ ConsistentHash.prototype.serialize = function serialize(callback) {
     });
 };
 
-/**
+/*
  * used for unit tests only.
  */
 module.exports.LKEY_ALGORITHM = LKEY_ALGORITHM;
diff --git a/lib/common.js b/lib/common.js
index d036abb..e63ceb6 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -1,16 +1,23 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
 var bignum = require('bignum');
 var bunyan = require('bunyan');
 var crypto = require('crypto');
+var jsprim = require('jsprim');
 var util = require('util');
 var sprintf = util.format;
 var verror = require('verror');
 
-/**
+/*
  * Find the hashspace a specific vnode maps to by multiplying the vnode by
  * hashspaceInterval.
  * @param {Object} options The options object.
@@ -46,7 +53,7 @@ function _findHashspace(options) {
     return hashspace.toString(16);
 }
 
-/**
+/*
  * Simply divide the hash by the number of vnodes to find which vnode maps to
  * this hash.
  * @param {Object} options The options object.
@@ -61,10 +68,33 @@ function _findVnode(options) {
     return parseInt(bignum(options.hash, 16).div(options.vnodeHashInterval), 10);
 }
 
-/**
+function _parseIntArray(nodes) {
+    assert.string(nodes, 'nodes');
+
+    var nodeArray = nodes.split(/[, ]+/);
+    var newNodeArray = [];
+
+    for (var i = 0; i < nodeArray.length; i++) {
+        var parsedElement = jsprim.parseInteger(nodeArray[i]);
+        var parsedElementIsError = parsedElement instanceof Error;
+        if (parsedElementIsError) {
+            continue;
+        }
+
+        nodeArray[i] = parsedElement;
+        if (!nodeArray[i] || nodeArray[i] === '' || nodeArray[i] === ',') {
+            continue;
+        }
+        newNodeArray.push(nodeArray[i]);
+    }
+    return newNodeArray;
+}
+
+/*
  * exports
  */
 module.exports = {
     findHashspace: _findHashspace,
-    findVnode: _findVnode
+    findVnode: _findVnode,
+    parseIntArray: _parseIntArray
 };
diff --git a/lib/dtrace.js b/lib/dtrace.js
index 15ec107..e2b79ae 100644
--- a/lib/dtrace.js
+++ b/lib/dtrace.js
@@ -1,5 +1,11 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var PROBES = {
diff --git a/lib/index.js b/lib/index.js
index f4e19b1..c2854b0 100644
--- a/lib/index.js
+++ b/lib/index.js
@@ -1,5 +1,11 @@
-/**
- * @author <a href="mailto:yjxiao@gmail.com">Yunong J Xiao</a>
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -71,7 +77,7 @@ module.exports = {
     assertVersion: assertVersion
 };
 
-/**
+/*
  * disallow newer versions
  */
 function assertVersion(version) {
diff --git a/package.json b/package.json
index 76741da..19fbc14 100644
--- a/package.json
+++ b/package.json
@@ -21,7 +21,7 @@
     "dynamo",
     "hash ring"
   ],
-  "version": "2.3.1",
+  "version": "2.4.1",
   "repository": {
     "type": "git",
     "url": "https://github.com/yunong/node-fash.git"
@@ -39,11 +39,12 @@
     "bunyan": "*",
     "cmdln": "1.3.1",
     "dashdash": "1.4.0",
+    "jsprim":"1.4.0",
     "levelup": "git://github.com/yunong/node-levelup.git#273cbda",
     "leveldown": "0.8.0",
     "once": "1.1.1",
     "redis": "0.8.4",
-    "vasync": "1.3.3",
+    "vasync": "1.6.4",
     "verror": "1.3.6"
   },
   "optionalDependencies": {
@@ -59,6 +60,9 @@
   "bin": {
     "fash": "bin/fash.js"
   },
+  "config": {
+    "leveldb_test_algorithm": "sha256"
+  },
   "scripts": {
     "pretest": "./lint.sh",
     "test": "./node_modules/.bin/nodeunit test/*.test.js"
diff --git a/test/in_memory.test.js b/test/in_memory.test.js
index 68871f7..706840c 100644
--- a/test/in_memory.test.js
+++ b/test/in_memory.test.js
@@ -1,3 +1,13 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
 var bignum = require('bignum');
 var crypto = require('crypto');
 var common = require('../lib/common');
diff --git a/test/leveldb.test.js b/test/leveldb.test.js
index 331b769..7cbc809 100644
--- a/test/leveldb.test.js
+++ b/test/leveldb.test.js
@@ -1,3 +1,13 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
 var bignum = require('bignum');
 var crypto = require('crypto');
 var common = require('../lib/common');
@@ -25,7 +35,8 @@ var NUMBER_OF_VNODES = parseInt(process.env.NUMBER_OF_VNODES || 100);
 var NUMBER_OF_PNODES = parseInt(process.env.NUMBER_OF_PNODES || 10);
 var PNODES = new Array(NUMBER_OF_PNODES);
 var PNODE_STRING = '\'';
-var ALGORITHM = ['sha256', 'sha1', 'md5'];
+var ALGORITHM = [process.env.npm_package_config_leveldb_test_algorithm] ||
+    ['sha256', 'sha1', 'md5'];
 
 exports.beforeTest = function (t) {
     for (var i = 0; i < NUMBER_OF_PNODES; i++) {
@@ -515,6 +526,93 @@ _testAllConstructors(function addDataBackToNull(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function getVnodePnodeAndData(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel) {
+                _.hLevel = hLevel;
+                return cb(err);
+            });
+        },
+        function pickVnode(_, cb) {
+            _.key = uuid.v4();
+            _.hLevel.getNode(_.key, function (err, node) {
+                _.node = node;
+                return cb(err);
+            });
+        },
+        function getVnodePnodeAndData(_, cb) {
+            _.hLevel.getVnodePnodeAndData(_.node.vnode,
+                function (err, pnode, vnodeData) {
+                    if (err) {
+                        return cb(err);
+                    }
+                    t.strictEqual(pnode, _.node.pnode,
+                        'pnode output does not match');
+                    t.strictEqual(vnodeData, _.node.data,
+                        'data output does not match');
+                    return cb();
+                });
+        },
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
+_testAllConstructors(function getVnodePnodeAndDataReadOnly(algo, constructor, t)
+{
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel) {
+                _.hLevel = hLevel;
+                return cb(err);
+            });
+        },
+        function pickVnode(_, cb) {
+            _.key = uuid.v4();
+            _.hLevel.getNode(_.key, function (err, node) {
+                _.node = node;
+                return cb(err);
+            });
+        },
+        function addData(_, cb) {
+            _.hLevel.addData(_.node.vnode, 'ro', cb);
+        },
+        function getNode(_, cb) {
+            _.hLevel.getNode(_.key, function (err, node) {
+                if (err) {
+                    return cb(err);
+                }
+                t.strictEqual(node.data, 'ro',
+                              'stored data should match put data');
+                _.node.data = node.data;
+                return cb();
+            });
+        },
+        function getVnodePnodeAndData(_, cb) {
+            _.hLevel.getVnodePnodeAndData(_.node.vnode,
+                function (err, pnode, vnodeData) {
+                    if (err) {
+                        return cb(err);
+                    }
+                    t.strictEqual(pnode, _.node.pnode,
+                        'pnode output does not match');
+                    t.strictEqual(vnodeData, _.node.data,
+                        'data output does not match');
+                    return cb();
+                });
+        }
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
 _testAllConstructors(function addDataRemapVnodeToDifferentPnode(algo,
                                                                 constructor,
                                                                 t)
diff --git a/test/load.test.js b/test/load.test.js
index ba639dd..4ad1c7d 100644
--- a/test/load.test.js
+++ b/test/load.test.js
@@ -1,3 +1,13 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
 var fash = require('../lib');
 var fs = require('fs');
 var Logger = require('bunyan');
@@ -9,15 +19,18 @@ var LOG = new Logger({
     level: process.env.LOG_LEVEL || 'warn'
 });
 
-var DB_LOCATION = process.env.DB_LOCATION || '/tmp/fash-db';
-var FASH_BACKEND = process.env.FASH_BACKEND || fash.BACKEND.LEVEL_DB;
 var LVL_CFG = {
     createIfMissing: true,
-    errorIfExists: false,
+    errorIfExists: true,
     compression: false,
-    cacheSize: 800 * 1024 * 1024
+    cacheSize: 800 * 1024 * 1024,
+    keyEncoding: 'utf8',
+    valueEncoding: 'json'
 };
 
+var DB_LOCATION = process.env.DB_LOCATION || '/tmp/fash-db';
+var FASH_BACKEND = process.env.FASH_BACKEND || fash.BACKEND.LEVEL_DB;
+
 var RING = fash.load({
     log: LOG,
     backend: fash.BACKEND.LEVEL_DB,
@@ -29,19 +42,6 @@ var RING = fash.load({
     }
 });
 
-//console.log('loading ring into memory');
-//var RING = fash.deserialize({
-    //log: LOG,
-    //topology: fs.readFileSync(DB_LOCATION, 'utf-8'),
-    //backend: fash.BACKEND.IN_MEMORY,
-//}, function (err) {
-    //if (err) {
-        //throw new verror.VError(err, 'unable to load ring from disk');
-    //}
-
-    //console.log('ring loaded');
-//});
-
 var server = restify.createServer();
 server.use(restify.bodyParser());
 server.post('/hash', function (req, res, next) {
-- 
2.21.0

