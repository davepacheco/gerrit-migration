commit f34b30b5edd11f3a6414ac0f577a77968f8970db (refs/changes/76/376/4)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-08-29T16:47:19-07:00 (3 years, 1 month ago)
    
    joyent/node-cueball#5 would like higher-level pool states exposed to consumers

diff --git a/README.md b/README.md
index 8c1a5e0..20efdaa 100644
--- a/README.md
+++ b/README.md
@@ -75,6 +75,8 @@ Parameters
   - `log` -- optional Object, a `bunyan`-style logger to use
   - `spares` -- optional Number, number of spares wanted in the pool per host
   - `maximum` -- optional Number, maximum number of connections per host
+  - `tcpKeepAliveInitialDelay` -- optional Number, if supplied, enable TCP
+    level keep-alives with the given initial delay (in milliseconds)
   - `ping` -- optional String, URL path to use for health checking. Connection
     is considered still viable if this URL returns a non-5xx response code.
   - `pingInterval` -- optional Number, interval between health check pings
@@ -125,6 +127,41 @@ Otherwise, if want to use the default DNS-based resolver, do not specify the
 `resolver` property.  A resolver instance will be created based on the other
 configuration properties.
 
+### Pool states
+
+ConnectionPool exposes the `mooremachine` FSM interface, with the following
+state graph:
+
+                                                .stop()
+             +--------+   connect ok   +-------+       +--------+
+    init --> |starting| +------------> |running| +---> |stopping|
+             +--------+                +-------+       +--------+
+                 +                      ^     +            +
+        resolver |                      |     |            |
+          failed |                      |     |            |
+              OR |       +------+       |     |            v
+         retries +---->  |failed| +-----+     |        +-------+
+       exhausted         +------+ connect ok  |        |stopped|
+                             ^                |        +-------+
+                             |                |
+                             +----------------+
+                              all retries exhausted
+
+Pools begin their life in the "starting" state. Once they have successfully made
+one connection to any backend, they proceed to the "running" state. Otherwise,
+if their underlying Resolver enters the "failed" state, or they exhaust their
+retry policy on all backends they are using for connections, they enter the
+"failed" state.
+
+A "running" pool can then either be stopped by calling the `.stop()` method, at
+which point it enters the "stopping" state and begins tearing down its
+connections; or all of its connections become disconnected and it exhausts its
+retry policy, in which case it enters the "failed" state.
+
+Failed pools can re-enter the "running" state at any time if they make a
+successful connection to a backend and their underlying Resolver is no longer
+"failed".
+
 ### `ConnectionPool#stop()`
 
 Stops the connection pool and its `Resolver`, then destroys all connections.
diff --git a/lib/agent.js b/lib/agent.js
index 22c476a..f2db3fe 100644
--- a/lib/agent.js
+++ b/lib/agent.js
@@ -30,6 +30,8 @@ function CueBallAgent(options) {
 	mod_assert.string(options.protocol, 'options.protocol');
 	mod_assert.optionalArrayOfString(options.resolvers,
 	    'options.resolvers');
+	mod_assert.optionalNumber(options.tcpKeepAliveInitialDelay,
+	    'options.tcpKeepAliveInitialDelay');
 	mod_assert.optionalObject(options.log, 'options.log');
 
 	EventEmitter.call(this);
@@ -43,6 +45,8 @@ function CueBallAgent(options) {
 	this.keepAlive = true;
 	this.maxSockets = Infinity;
 
+	this.tcpKAID = options.tcpKeepAliveInitialDelay;
+
 	this.pools = {};
 	this.resolvers = options.resolvers;
 	this.log = options.log;
@@ -96,11 +100,15 @@ CueBallAgent.prototype.addRequest = function (req, options) {
 					if (options.hasOwnProperty(k))
 						opts[k] = options[k];
 				});
+				var nsock;
 				if (self.protocol === 'https:') {
-					return (mod_tls.connect(opts));
+					nsock = mod_tls.connect(opts);
 				} else {
-					return (mod_net.createConnection(opts));
+					nsock = mod_net.createConnection(opts);
 				}
+				if (self.tcpKAID !== undefined)
+					nsock.setKeepAlive(true, self.tcpKAID);
+				return (nsock);
 			},
 			maximum: this.maximum,
 			spares: this.spares,
diff --git a/lib/pool-monitor.js b/lib/pool-monitor.js
index 0f0e93d..9baa19c 100644
--- a/lib/pool-monitor.js
+++ b/lib/pool-monitor.js
@@ -57,6 +57,7 @@ CueBallPoolMonitor.prototype.toKangOptions = function () {
 		obj.last_rebalance = Math.round(
 		    pool.p_lastRebalance.getTime() / 1000);
 		obj.resolvers = pool.p_resolver.r_resolvers;
+		obj.state = pool.getState();
 		obj.options = {};
 		obj.options.domain = pool.p_resolver.r_domain;
 		obj.options.service = pool.p_resolver.r_service;
diff --git a/lib/pool.js b/lib/pool.js
index 84ef370..bbdfb7e 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -525,7 +525,6 @@ ConnectionHandle.prototype.closeAfterRelease = function () {
  * to expand the pool will be queued when a claim() request comes in.
  */
 function CueBallConnectionPool(options) {
-	EventEmitter.call(this);
 	mod_assert.object(options);
 
 	mod_assert.func(options.constructor, 'options.constructor');
@@ -571,6 +570,7 @@ function CueBallConnectionPool(options) {
 
 	this.p_lastRebalance = undefined;
 	this.p_inRebalance = false;
+	this.p_startedResolver = false;
 
 	this.p_idleq = new Queue();
 	this.p_initq = new Queue();
@@ -593,69 +593,177 @@ function CueBallConnectionPool(options) {
 		this.p_resolver_custom = false;
 	}
 
-	this.p_resolver_onadded = function (k, backend) {
-		backend.key = k;
-		self.p_keys.push(k);
-		mod_utils.shuffle(self.p_keys);
-		self.p_backends[k] = backend;
-		self.rebalance();
-	};
-	this.p_resolver.on('added', this.p_resolver_onadded);
-
-	this.p_resolver_onremoved = function (k) {
-		var idx = self.p_keys.indexOf(k);
-		if (idx !== -1)
-			self.p_keys.splice(idx, 1);
-		delete (self.p_backends[k]);
-		(self.p_connections[k] || []).forEach(function (fsm) {
-			if (fsm.getState() !== 'busy')
-				fsm.close();
-		});
-		delete (self.p_connections[k]);
-		self.rebalance();
-	};
-	this.p_resolver.on('removed', this.p_resolver_onremoved);
-
 	/*
 	 * Periodically rebalance() so that we catch any connections that
 	 * come off "busy" (we're lazy about these and don't rebalance every
 	 * single time they return to the pool).
 	 */
-	this.p_rebalTimer = setInterval(function () {
-		self.rebalance();
+	this.p_rebalTimer = new EventEmitter();
+	this.p_rebalTimerInst = setInterval(function () {
+		self.p_rebalTimer.emit('timeout');
 	}, 10000);
-	this.p_rebalTimer.unref();
+	this.p_rebalTimerInst.unref();
+
+	FSM.call(this, 'starting');
+}
+mod_util.inherits(CueBallConnectionPool, FSM);
+
+CueBallConnectionPool.prototype.on_resolver_added = function (k, backend) {
+	backend.key = k;
+	this.p_keys.push(k);
+	mod_utils.shuffle(this.p_keys);
+	this.p_backends[k] = backend;
+	this.rebalance();
+};
+
+CueBallConnectionPool.prototype.on_resolver_removed = function (k) {
+	var idx = this.p_keys.indexOf(k);
+	if (idx !== -1)
+		this.p_keys.splice(idx, 1);
+	delete (this.p_backends[k]);
+	(this.p_connections[k] || []).forEach(function (fsm) {
+		if (fsm.getState() !== 'busy')
+			fsm.close();
+	});
+	delete (this.p_connections[k]);
+	this.rebalance();
+};
+
+CueBallConnectionPool.prototype.state_starting =
+    function (on, once, timeout, onState) {
+	mod_monitor.monitor.registerPool(this);
+
+	on(this.p_resolver, 'added', this.on_resolver_added.bind(this));
+	on(this.p_resolver, 'removed', this.on_resolver_removed.bind(this));
 
-	if (!this.p_resolver_custom) {
+	var self = this;
+	var rst = this.p_resolver.getState();
+
+	if (rst === 'failed') {
+		this.gotoState('failed');
+		return;
+	}
+
+	onState(this.p_resolver, 'failed', function () {
+		self.gotoState('failed');
+	});
+
+	if (rst === 'running') {
+		var backends = this.p_resolver.list();
+		Object.keys(backends).forEach(function (k) {
+			var backend = backends[k];
+			self.on_resolver_added(k, backend);
+		});
+	} else if (rst === 'stopped' && !this.p_resolver_custom) {
 		this.p_resolver.start();
+		this.p_startedResolver = true;
 	}
 
-	mod_monitor.monitor.registerPool(this);
-}
-mod_util.inherits(CueBallConnectionPool, EventEmitter);
+	on(this, 'connectedToBackend', function () {
+		self.gotoState('running');
+	});
 
-/* Stop and kill everything. */
-CueBallConnectionPool.prototype.stop = function () {
-	mod_monitor.monitor.unregisterPool(this);
+	var failures = 0;
+	on(this, 'closedBackend', function () {
+		if (++failures >= self.p_spares) {
+			self.gotoState('failed');
+		}
+	});
+
+	on(this, 'stopAsserted', function () {
+		self.gotoState('stopping');
+	});
+};
+
+CueBallConnectionPool.prototype.state_failed = function (on) {
+	on(this.p_resolver, 'added', this.on_resolver_added.bind(this));
+	on(this.p_resolver, 'removed', this.on_resolver_removed.bind(this));
+
+	var self = this;
+	on(this, 'connectedToBackend', function () {
+		if (self.p_resolver.getState() !== 'failed')
+			self.gotoState('running');
+	});
+
+	on(this, 'stopAsserted', function () {
+		self.gotoState('stopping');
+	});
+};
+
+CueBallConnectionPool.prototype.state_running = function (on) {
+	var self = this;
+	on(this.p_resolver, 'added', this.on_resolver_added.bind(this));
+	on(this.p_resolver, 'removed', this.on_resolver_removed.bind(this));
+	on(this.p_rebalTimer, 'timeout', this.rebalance.bind(this));
+
+	var closedSinceLastOpen = 0;
+	on(this, 'connectedToBackend', function () {
+		closedSinceLastOpen = 0;
+	});
+	on(this, 'closedBackend', function () {
+		++closedSinceLastOpen;
+		var fsms = 0;
+		self.p_keys.forEach(function (k) {
+			var conns = self.p_connections[k];
+			if (conns)
+				fsms += conns.length;
+		});
+		if (fsms < 1 || (fsms === self.p_initq.length &&
+		    closedSinceLastOpen >= self.p_spares)) {
+			self.gotoState('failed');
+		}
+	});
 
-	clearInterval(this.p_rebalTimer);
-	if (!this.p_resolver_custom) {
+	on(this, 'stopAsserted', function () {
+		self.gotoState('stopping');
+	});
+};
+
+CueBallConnectionPool.prototype.state_stopping =
+    function (on, once, timeout, onState) {
+	var self = this;
+	if (this.p_startedResolver) {
+		onState(this.p_resolver, 'stopped', function () {
+			self.gotoState('stopping.backends');
+		});
 		this.p_resolver.stop();
-		this.p_resolver.removeListener('added',
-		    this.p_resolver_onadded);
-		this.p_resolver.removeListener('removed',
-		    this.p_resolver_onremoved);
+	} else {
+		this.gotoState('stopping.backends');
 	}
+};
+
+CueBallConnectionPool.prototype.state_stopping.backends = function () {
 	var conns = this.p_connections;
+	var self = this;
+	var fsms = [];
 	Object.keys(conns).forEach(function (k) {
 		conns[k].forEach(function (fsm) {
-			mod_assert.ok(fsm.getState() !== 'busy');
-			fsm.close();
+			fsms.push(fsm);
 		});
 	});
+	mod_vasync.forEachParallel({
+		func: closeBackend,
+		inputs: fsms
+	}, function () {
+		self.gotoState('stopped');
+	});
+	function closeBackend(fsm, cb) {
+		mod_assert.ok(fsm.getState() !== 'busy');
+		fsm.close(cb);
+	}
+};
+
+CueBallConnectionPool.prototype.state_stopped = function () {
+	mod_monitor.monitor.unregisterPool(this);
 	this.p_keys = [];
 	this.p_connections = {};
 	this.p_backends = {};
+	clearInterval(this.p_rebalTimerInst);
+};
+
+/* Stop and kill everything. */
+CueBallConnectionPool.prototype.stop = function () {
+	this.emit('stopAsserted');
 };
 
 /*
@@ -752,6 +860,9 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 			 */
 			fsm.p_initq_node.remove();
 			delete (fsm.p_initq_node);
+
+			if (newState === 'idle')
+				self.emit('connectedToBackend', key);
 		}
 
 		if (newState === 'idle') {
@@ -797,6 +908,9 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 				var idx = self.p_connections[key].indexOf(fsm);
 				self.p_connections[key].splice(idx, 1);
 			}
+
+			self.emit('closedBackend', key);
+			self.rebalance();
 		}
 
 		if (fsm.p_idleq_node) {
@@ -808,7 +922,8 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 			delete (fsm.p_idleq_node);
 
 			/* Also rebalance, in case we were closed or died. */
-			self.rebalance();
+			if (newState !== 'closed')
+				self.rebalance();
 		}
 	});
 
