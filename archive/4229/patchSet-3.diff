commit c6332cd52afa7ccb7f7970b7cf058781720fd56b (refs/changes/29/4229/3)
Author: Robert Bogart <robert.bogart@joyent.com>
Date:   2018-06-15T06:58:54+00:00 (1 year, 4 months ago)
    
    MANTA-3751 Track failure events that occur in Cueball

diff --git a/README.adoc b/README.adoc
index 7fcbc42..65ca63b 100644
--- a/README.adoc
+++ b/README.adoc
@@ -113,7 +113,8 @@ var pool = new mod_cueball.ConnectionPool({
             delay: 250,
             maxDelay: 1000
         }
-    }
+    },
+    collector: collector
 });
 
 pool.claim(function (err, hdl, client) {
@@ -136,7 +137,9 @@ pool.claim(function (err, hdl, client) {
 
 This will create a pool of pre-authenticated LDAP connections ready for use in
 your application. Once you call `hdl.release()` to tell `cueball` you're done
-with the connection, it goes back to the pool ready to be re-used.
+with the connection, it goes back to the pool ready to be re-used. Optionally,
+the caller can supply an artedi collector for tracking failures within cueball,
+however it is not mandatory.
 
 Note that `cueball` also automatically uses DNS `SRV` records if available to
 locate your LDAP servers.
diff --git a/lib/agent.js b/lib/agent.js
index fbae298..e161131 100644
--- a/lib/agent.js
+++ b/lib/agent.js
@@ -39,6 +39,8 @@ function CueBallAgent(options) {
 	    'options.tcpKeepAliveInitialDelay');
 	mod_assert.optionalObject(options.log, 'options.log');
 
+	this.collector = mod_utils.createErrorMetrics(options);
+
 	EventEmitter.call(this);
 
 	/* These are used as defaults in the ClientRequest constructor. */
@@ -138,7 +140,8 @@ CueBallAgent.prototype._addPool = function (host, options) {
 		maximum: this.maximum,
 		spares: this.spares,
 		log: this.log,
-		recovery: this.cba_recovery
+		recovery: this.cba_recovery,
+		collector: this.collector
 	};
 	function constructSocket(backend) {
 		var opts = {
diff --git a/lib/pool.js b/lib/pool.js
index 7d4206f..fa39fb4 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -155,6 +155,8 @@ function CueBallConnectionPool(options) {
 		pool: this.p_uuid
 	});
 
+	this.p_collector = mod_utils.createErrorMetrics(options);
+
 	mod_assert.number(options.spares, 'options.spares');
 	mod_assert.number(options.maximum, 'options.maximum');
 	this.p_spares = options.spares;
@@ -246,6 +248,7 @@ function CueBallConnectionPool(options) {
 mod_util.inherits(CueBallConnectionPool, FSM);
 
 CueBallConnectionPool.prototype._incrCounter = function (counter) {
+	mod_utils.updateErrorMetrics(this.p_collector, this.p_uuid, counter);
 	if (this.p_counters[counter] === undefined)
 		this.p_counters[counter] = 0;
 	++this.p_counters[counter];
diff --git a/lib/set.js b/lib/set.js
index 473a427..eb33de7 100644
--- a/lib/set.js
+++ b/lib/set.js
@@ -61,6 +61,8 @@ function CueBallConnectionSet(options) {
 		cset: this.cs_uuid
 	});
 
+	this.cs_collector = mod_utils.createErrorMetrics(options);
+
 	mod_assert.number(options.target, 'options.target');
 	mod_assert.number(options.maximum, 'options.maximum');
 	this.cs_target = options.target;
@@ -607,6 +609,7 @@ CueBallConnectionSet.prototype.getConnections = function () {
 };
 
 CueBallConnectionSet.prototype._incrCounter = function (counter) {
+	mod_utils.updateErrorMetrics(this.cs_collector, this.cs_uuid, counter);
 	if (this.cs_counters[counter] === undefined)
 		this.cs_counters[counter] = 0;
 	++this.cs_counters[counter];
diff --git a/lib/utils.js b/lib/utils.js
index 49b30cc..aa6a5a1 100644
--- a/lib/utils.js
+++ b/lib/utils.js
@@ -14,13 +14,18 @@ module.exports = {
 	assertClaimDelay: assertClaimDelay,
 	currentMillis: currentMillis,
 	stackTracesEnabled: stackTracesEnabled,
-	maybeCaptureStackTrace: maybeCaptureStackTrace
+	maybeCaptureStackTrace: maybeCaptureStackTrace,
+	createErrorMetrics: createErrorMetrics,
+	updateErrorMetrics: updateErrorMetrics
 };
 
 const mod_assert = require('assert-plus');
+const mod_artedi = require('artedi');
+const mod_os = require('os');
 
 stackTracesEnabled.ENABLED = false;
 var mod_dtrace, dtProvider, dtProbe;
+var METRIC_CUEBALL_ERROR_COUNTER = 'cueball_error_events';
 
 /*
  * Returns true if cueball should collect stack traces at every claim() and
@@ -362,3 +367,43 @@ function planRebalance(inSpares, dead, target, max, singleton) {
 
 	return (plan);
 }
+
+function createErrorMetrics(options)
+{
+	var collector;
+	mod_assert.optionalObject(options.collector, 'options.collector');
+	if (options.collector === undefined || options.collector === null) {
+		collector = mod_artedi.createCollector();
+	} else {
+		collector = options.collector;
+	}
+
+	/*
+	 * This is idempotent, so if we're performing this on a collector that
+	 * already alraedy has this counter (like one created in the CueBall
+	 * agent and then passed to a set or pool), there's no harm done.
+	 */
+	collector.counter({
+		name: METRIC_CUEBALL_ERROR_COUNTER,
+		help: 'Total number of cueball error events'
+	});
+
+	return (collector);
+}
+
+function updateErrorMetrics(collector, uuid, err)
+{
+	var errors;
+
+	mod_assert(collector, 'collector');
+	mod_assert(uuid, 'uuid');
+	mod_assert(err, 'err');
+
+	errors = collector.getCollector(METRIC_CUEBALL_ERROR_COUNTER);
+
+	errors.increment({
+		hostname: mod_os.hostname(),
+		uuid: uuid,
+		type: err
+	});
+}
diff --git a/package.json b/package.json
index 39d78f9..852dd27 100644
--- a/package.json
+++ b/package.json
@@ -4,6 +4,7 @@
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
+    "artedi": "1.3.0",
     "assert-plus": ">=1.0.0 <2.0.0",
     "bunyan": ">=1.5.1 <2.0.0",
     "cmdutil": ">=1.0.0 <2.0.0",
