commit e4abceadb05991b242eb4f9e7f9fa05690dd1c44
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2019-07-08T23:59:47+00:00 (3 months ago)
    
    TRITON-1794 firewaller's configuration migration SMF service cannot be imported

diff --git a/Makefile b/Makefile
index d5d17f3..ce8e692 100644
--- a/Makefile
+++ b/Makefile
@@ -18,7 +18,7 @@
 
 
 BASH_FILES  := npm/postinstall.sh npm/postuninstall.sh
-JS_FILES        := $(shell find lib test -name '*.js') main.js
+JS_FILES        := $(shell find lib test -name '*.js') $(wildcard ./*.js)
 JSON_FILES       = package.json config.json
 JSL_CONF_NODE    = tools/jsl.node.conf
 JSL_FILES_NODE   = $(JS_FILES)
@@ -101,6 +101,7 @@ release: all docs $(SMF_MANIFESTS)
 	(git symbolic-ref HEAD | awk -F/ '{print $$3}' && git describe) > $(DSTDIR)/describe
 	cp -r \
     $(TOP)/config.json \
+    $(TOP)/config-migration.js \
     $(TOP)/main.js \
     $(TOP)/lib \
     $(TOP)/node_modules \
diff --git a/config-migration.js b/config-migration.js
index 3c6ee11..e190c86 100644
--- a/config-migration.js
+++ b/config-migration.js
@@ -36,14 +36,15 @@ vasync.pipeline({
     funcs: [
         // Get all the local VMs with firewall_enabled=true
         function loadFwEnabledVms(ctx, next) {
-            mod_vm.list(LOG, {
-                firewall_enabled: true
-            }, function listVmsCb(err, vms) {
+            mod_vm.list(LOG, {}, function listVmsCb(err, allVMs) {
                 if (err) {
                     next(err);
                     return;
                 }
-                ctx.vms = vms;
+                ctx.allVMs = allVMs;
+                ctx.vms = allVMs.filter(function (vm) {
+                    return vm.firewall_enabled;
+                });
                 ctx.vmsByVmUUID = {};
                 ctx.vms.forEach(function (vm) {
                     ctx.vmsByVmUUID[vm.uuid] = vm;
@@ -54,6 +55,7 @@ vasync.pipeline({
         // Load all the firewall rules for those vms
         function loadFwEnabledRules(ctx, next) {
             if (!ctx.vms.length) {
+                LOG.info('found 0 VMs with their firewall enabled');
                 next();
                 return;
             }
@@ -61,7 +63,7 @@ vasync.pipeline({
                 log: LOG,
                 payload: {
                     localVMs: ctx.vms,
-                    vms: ctx.vms
+                    vms: ctx.allVMs
                 }
             }, function listRulesCb(err, rules) {
                 if (err) {
@@ -72,17 +74,6 @@ vasync.pipeline({
                 next();
             });
         },
-        // We're interested only in firewall rules which have `rule.log` set
-        function filterRulesWithSetTags(ctx, next) {
-            if (!ctx.rules.length) {
-                next();
-                return;
-            }
-            ctx.rules = ctx.rules.filter(function ruleHasTags(rule) {
-                return rule.log;
-            });
-            next();
-        },
         // Since firewall rules don't keep a reference to the VM they belong
         // to, we need to figure out which VM UUIDs we're gonna need to check
         // based into the firewall rules
@@ -99,7 +90,7 @@ vasync.pipeline({
                         log: LOG,
                         payload: {
                             rule: rule,
-                            vms: ctx.vms
+                            vms: ctx.allVMs
                         }
                     }, function getRuleVmCb(getErr, vmUuids) {
                         if (getErr) {
@@ -168,13 +159,16 @@ vasync.pipeline({
         function updateIpfFiles(ctx, next) {
             if (!Array.isArray(ctx.vmsToRewriteIPF) ||
                 ctx.vmsToRewriteIPF.length === 0) {
+                LOG.info('found 0 VMs that need their ipfilter ' +
+                    'configuration rewritten');
                 next();
                 return;
             }
             fw.update({
                 log: LOG,
                 payload: {
-                    localVms: ctx.vmsToRewriteIPF
+                    localVMs: ctx.vmsToRewriteIPF,
+                    vms: ctx.allVMs
                 }
             }, next);
         }
@@ -185,6 +179,9 @@ vasync.pipeline({
 }, function pipeCb(pipeErr) {
     if (pipeErr) {
         console.error(pipeErr);
+        process.exit(1);
+    } else {
+        process.exit(0);
     }
 });
 
diff --git a/smf/manifests/firewaller-config-migration.xml.in b/smf/manifests/firewaller-config-migration.xml.in
index a7f5982..6688877 100644
--- a/smf/manifests/firewaller-config-migration.xml.in
+++ b/smf/manifests/firewaller-config-migration.xml.in
@@ -20,15 +20,24 @@
       <service_fmri value="svc:/network/physical"/>
       <service_fmri value="svc:/system/filesystem/local"/>
     </dependency>
+    <dependency name="vminfod_when_present" grouping="optional_all" restart_on="error" type="service">
+      <service_fmri value="svc:/system/smartdc/vminfod"/>
+    </dependency>
     <!--
-        Make vmadmd and zones services depend on this service so that firewall
-        rules are correct before those services cause them to be read.
+        We make the zones service depend on this service so that the firewall
+        rules are correct before the zones (and other services like vmadmd)
+        cause them to be read.
     -->
-    <dependent name="smartdc_vmadmd_and_system_zones" grouping="optional_all" restart_on="none">
-      <service_fmri value="svc:/system/smartdc/vmadmd:default"/>
+    <dependent name="system_zones" grouping="optional_all" restart_on="none">
       <service_fmri value="svc:/system/zones:default"/>
     </dependent>
-    <exec_method type="method" name="start" exec="/usr/bin/ctrun -l child -o noorphan @@ROOT@@/node/bin/node --abort_on_uncaught_exception @@ROOT@@/config-migration.js &amp;" timeout_seconds="60">
+    <!--
+        When the config-migration.js script runs, it will look up all of the
+        VMs that have their firewall enabled, and will take care of regenerating
+        their ipfilter configuration if neeed. We run it using ctrun since it
+        spawns child processes, to ensure they get cleaned up.
+    -->
+    <exec_method type="method" name="start" exec="/usr/bin/ctrun -l child -o noorphan @@ROOT@@/node/bin/node --abort_on_uncaught_exception @@ROOT@@/config-migration.js" timeout_seconds="0">
       <method_context>
         <method_credential user="root" group="staff"/>
         <method_environment>
@@ -36,16 +45,14 @@
         </method_environment>
       </method_context>
     </exec_method>
-    <exec_method type="method" name="restart" exec=":kill" timeout_seconds="60">
-      <method_context>
-        <method_credential user="root" group="staff"/>
-      </method_context>
-    </exec_method>
-    <exec_method type="method" name="stop" exec=":kill" timeout_seconds="60">
+    <exec_method type="method" name="stop" exec=":true" timeout_seconds="60">
       <method_context>
         <method_credential user="root" group="staff"/>
       </method_context>
     </exec_method>
+    <property_group name='startd' type='framework'>
+      <propval name='duration' type='astring' value='transient' />
+    </property_group>
     <instance name="default" enabled="true"/>
     <stability value="Unstable"/>
     <template>
