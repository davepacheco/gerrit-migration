From 6a9146c427a1cd5c82983a847b9e8d07a409ecf3 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 9 Jul 2019 17:52:40 +0000
Subject: [PATCH] TRITON-1794 firewaller's configuration migration SMF service
 cannot be imported TRITON-1803 firewaller's configuration migration script
 should apply to all rules

---
 Makefile                                      |   3 +-
 config-migration.js                           | 107 ++++--------------
 .../firewaller-config-migration.xml.in        |  29 +++--
 3 files changed, 42 insertions(+), 97 deletions(-)

diff --git a/Makefile b/Makefile
index d5d17f3..ce8e692 100644
--- a/Makefile
+++ b/Makefile
@@ -18,7 +18,7 @@
 
 
 BASH_FILES  := npm/postinstall.sh npm/postuninstall.sh
-JS_FILES        := $(shell find lib test -name '*.js') main.js
+JS_FILES        := $(shell find lib test -name '*.js') $(wildcard ./*.js)
 JSON_FILES       = package.json config.json
 JSL_CONF_NODE    = tools/jsl.node.conf
 JSL_FILES_NODE   = $(JS_FILES)
@@ -101,6 +101,7 @@ release: all docs $(SMF_MANIFESTS)
 	(git symbolic-ref HEAD | awk -F/ '{print $$3}' && git describe) > $(DSTDIR)/describe
 	cp -r \
     $(TOP)/config.json \
+    $(TOP)/config-migration.js \
     $(TOP)/main.js \
     $(TOP)/lib \
     $(TOP)/node_modules \
diff --git a/config-migration.js b/config-migration.js
index 3c6ee11..c1f5644 100644
--- a/config-migration.js
+++ b/config-migration.js
@@ -31,19 +31,21 @@ var LOG = bunyan.createLogger({
 
 var DEV_IPFEV = '/dev/ipfev';
 var IPF_CONF = '%s/config/ipf.conf';
+var IPF_VER_RE = /^# smartos_ipf_version (\d+)$/m;
 
 vasync.pipeline({
     funcs: [
         // Get all the local VMs with firewall_enabled=true
         function loadFwEnabledVms(ctx, next) {
-            mod_vm.list(LOG, {
-                firewall_enabled: true
-            }, function listVmsCb(err, vms) {
+            mod_vm.list(LOG, {}, function listVmsCb(err, allVMs) {
                 if (err) {
                     next(err);
                     return;
                 }
-                ctx.vms = vms;
+                ctx.allVMs = allVMs;
+                ctx.vms = allVMs.filter(function (vm) {
+                    return vm.firewall_enabled;
+                });
                 ctx.vmsByVmUUID = {};
                 ctx.vms.forEach(function (vm) {
                     ctx.vmsByVmUUID[vm.uuid] = vm;
@@ -51,72 +53,6 @@ vasync.pipeline({
                 next();
             });
         },
-        // Load all the firewall rules for those vms
-        function loadFwEnabledRules(ctx, next) {
-            if (!ctx.vms.length) {
-                next();
-                return;
-            }
-            fw.list({
-                log: LOG,
-                payload: {
-                    localVMs: ctx.vms,
-                    vms: ctx.vms
-                }
-            }, function listRulesCb(err, rules) {
-                if (err) {
-                    next(err);
-                    return;
-                }
-                ctx.rules = rules;
-                next();
-            });
-        },
-        // We're interested only in firewall rules which have `rule.log` set
-        function filterRulesWithSetTags(ctx, next) {
-            if (!ctx.rules.length) {
-                next();
-                return;
-            }
-            ctx.rules = ctx.rules.filter(function ruleHasTags(rule) {
-                return rule.log;
-            });
-            next();
-        },
-        // Since firewall rules don't keep a reference to the VM they belong
-        // to, we need to figure out which VM UUIDs we're gonna need to check
-        // based into the firewall rules
-        function getVmsForRulesWithSetTags(ctx, next) {
-            if (ctx.rules.length === 0) {
-                next();
-                return;
-            }
-            ctx.rulesByVmUUID = {};
-            vasync.forEachParallel({
-                inputs: ctx.rules,
-                func: function getRuleVm(rule, nextRule) {
-                    fw.vms({
-                        log: LOG,
-                        payload: {
-                            rule: rule,
-                            vms: ctx.vms
-                        }
-                    }, function getRuleVmCb(getErr, vmUuids) {
-                        if (getErr) {
-                            nextRule(getErr);
-                            return;
-                        }
-                        vmUuids.forEach(function addToCtx(vmUuid) {
-                            if (!ctx.rulesByVmUUID[vmUuid]) {
-                                ctx.rulesByVmUUID[vmUuid] = [];
-                            }
-                            ctx.rulesByVmUUID[vmUuid].push(rule);
-                        });
-                        nextRule();
-                    });
-                }
-            }, next);
-        },
         function getPlatformIPFVersion(ctx, next) {
             var vFile = '/etc/ipf/smartos_version';
             if (fs.existsSync(vFile)) {
@@ -129,37 +65,32 @@ vasync.pipeline({
         // Once we know which vms to check, we need to review the contents of
         // the IPF files
         function checkIPFVersions(ctx, next) {
-            if (!ctx.rulesByVmUUID) {
+            if (ctx.vms.length === 0) {
                 next();
                 return;
             }
+
             ctx.vmsToRewriteIPF = [];
-            var vmsToCheck = Object.keys(ctx.rulesByVmUUID);
-            LOG.debug({vmsToCheck: vmsToCheck}, 'VMs to check');
-            if (!vmsToCheck.length) {
-                next();
-                return;
-            }
+
             vasync.forEachParallel({
-                inputs: vmsToCheck,
-                func: function testIPFFiles(aVm, nextVm) {
+                inputs: ctx.vms,
+                func: function testIPFFiles(vm, nextVm) {
                     var ipfv4 = util.format(IPF_CONF,
-                        ctx.vmsByVmUUID[aVm].zonepath);
+                        ctx.vmsByVmUUID[vm.uuid].zonepath);
                     var ipfv4Data = fs.readFileSync(ipfv4, 'utf8');
-                    var re = /^# smartos_ipf_version (\d+)$/m;
-                    var ipfv4Res = re.exec(ipfv4Data);
+                    var ipfv4Res = IPF_VER_RE.exec(ipfv4Data);
                     // If we cannot find a version written on the rules file,
                     // let's assume it's version 1 (pre RFD 163):
                     var rulesVersion = (ipfv4Res !== null) ?
                             Number(ipfv4Res[1]) : 1;
                     if (rulesVersion !== ctx.ipfSmartosVersion) {
-                        ctx.vmsToRewriteIPF.push(ctx.vmsByVmUUID[aVm]);
+                        ctx.vmsToRewriteIPF.push(ctx.vmsByVmUUID[vm.uuid]);
                     }
 
                     LOG.debug({
                         smartos_ipf_version: ctx.ipfSmartosVersion,
                         rules_ipf_version: rulesVersion,
-                        vm_uuid: aVm
+                        vm_uuid: vm.uuid
                     }, 'SmartOS IPF version check');
                     nextVm();
                 }
@@ -168,13 +99,16 @@ vasync.pipeline({
         function updateIpfFiles(ctx, next) {
             if (!Array.isArray(ctx.vmsToRewriteIPF) ||
                 ctx.vmsToRewriteIPF.length === 0) {
+                LOG.info('found 0 VMs that need their ipfilter ' +
+                    'configuration rewritten');
                 next();
                 return;
             }
             fw.update({
                 log: LOG,
                 payload: {
-                    localVms: ctx.vmsToRewriteIPF
+                    localVMs: ctx.vmsToRewriteIPF,
+                    vms: ctx.allVMs
                 }
             }, next);
         }
@@ -185,6 +119,9 @@ vasync.pipeline({
 }, function pipeCb(pipeErr) {
     if (pipeErr) {
         console.error(pipeErr);
+        process.exit(1);
+    } else {
+        process.exit(0);
     }
 });
 
diff --git a/smf/manifests/firewaller-config-migration.xml.in b/smf/manifests/firewaller-config-migration.xml.in
index a7f5982..6688877 100644
--- a/smf/manifests/firewaller-config-migration.xml.in
+++ b/smf/manifests/firewaller-config-migration.xml.in
@@ -20,15 +20,24 @@
       <service_fmri value="svc:/network/physical"/>
       <service_fmri value="svc:/system/filesystem/local"/>
     </dependency>
+    <dependency name="vminfod_when_present" grouping="optional_all" restart_on="error" type="service">
+      <service_fmri value="svc:/system/smartdc/vminfod"/>
+    </dependency>
     <!--
-        Make vmadmd and zones services depend on this service so that firewall
-        rules are correct before those services cause them to be read.
+        We make the zones service depend on this service so that the firewall
+        rules are correct before the zones (and other services like vmadmd)
+        cause them to be read.
     -->
-    <dependent name="smartdc_vmadmd_and_system_zones" grouping="optional_all" restart_on="none">
-      <service_fmri value="svc:/system/smartdc/vmadmd:default"/>
+    <dependent name="system_zones" grouping="optional_all" restart_on="none">
       <service_fmri value="svc:/system/zones:default"/>
     </dependent>
-    <exec_method type="method" name="start" exec="/usr/bin/ctrun -l child -o noorphan @@ROOT@@/node/bin/node --abort_on_uncaught_exception @@ROOT@@/config-migration.js &amp;" timeout_seconds="60">
+    <!--
+        When the config-migration.js script runs, it will look up all of the
+        VMs that have their firewall enabled, and will take care of regenerating
+        their ipfilter configuration if neeed. We run it using ctrun since it
+        spawns child processes, to ensure they get cleaned up.
+    -->
+    <exec_method type="method" name="start" exec="/usr/bin/ctrun -l child -o noorphan @@ROOT@@/node/bin/node --abort_on_uncaught_exception @@ROOT@@/config-migration.js" timeout_seconds="0">
       <method_context>
         <method_credential user="root" group="staff"/>
         <method_environment>
@@ -36,16 +45,14 @@
         </method_environment>
       </method_context>
     </exec_method>
-    <exec_method type="method" name="restart" exec=":kill" timeout_seconds="60">
-      <method_context>
-        <method_credential user="root" group="staff"/>
-      </method_context>
-    </exec_method>
-    <exec_method type="method" name="stop" exec=":kill" timeout_seconds="60">
+    <exec_method type="method" name="stop" exec=":true" timeout_seconds="60">
       <method_context>
         <method_credential user="root" group="staff"/>
       </method_context>
     </exec_method>
+    <property_group name='startd' type='framework'>
+      <propval name='duration' type='astring' value='transient' />
+    </property_group>
     <instance name="default" enabled="true"/>
     <stability value="Unstable"/>
     <template>
-- 
2.21.0

