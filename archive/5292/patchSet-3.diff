commit c98dba4d74eb2161781852c7ba23bbb1a1c6ae90 (refs/changes/92/5292/3)
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2019-01-03T11:46:45-07:00 (9 months ago)
    
    joyent/node-manta#358 mchmod command stopped working after v5.1.1

diff --git a/lib/client.js b/lib/client.js
index ba0495a..021c227 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 var EventEmitter = require('events').EventEmitter;
@@ -321,6 +321,23 @@ function getPath(p, user, skipEncode) {
     return (p2);
 }
 
+function isPath(p, user, skipEncode) {
+    if (typeof (user) === 'boolean') {
+        skipEncode = user;
+        user = null;
+    }
+
+    /* JSSTYLED */
+    p = p.replace(/^~~\/*/, '/' + (user || process.env.MANTA_USER) + '/');
+
+    var p2 = path.posix.normalize(p).replace(/\/$/, '');
+    if (!skipEncode && !process.env.MANTA_SKIP_URLENCODE)
+        p2 = p2.split('/').map(encodeURIComponent).join('/');
+
+    /* JSSTYLED */
+    return (/^\/.*/.test(p2));
+}
+
 
 function getJobPath(p, user) {
     if (user && !/^\/.*\/jobs/.test(p))
@@ -3803,6 +3820,7 @@ MantaClient.prototype.commitUpload = function commitUpload(id, p, opts, cb) {
 
 module.exports = {
     path: getPath, // useful for the CLI
+    isPath: isPath, // useful for the CLI
     jobPath: getJobPath, // useful for mjob
     createOptions: createOptions, // useful for testing
     MantaClient: MantaClient
diff --git a/lib/options.js b/lib/options.js
index 3f7fdef..f8ae62a 100644
--- a/lib/options.js
+++ b/lib/options.js
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -76,16 +76,18 @@ function parseOptions(args) {
         opts.headers[tokens[0]] = tokens[1].trim();
     });
 
-    if (opts._args.length < 1) {
+    const getPath = function (acc, p) {
+        if (client.isPath(p, true)) {
+            acc.push(client.path(p, true));
+        }
+        return (acc);
+    };
+    opts.paths = opts._args.reduce(getPath, []);
+
+    if (opts.paths.length < 1) {
         cc.usage(parser, 'path required', extra);
     }
 
-    const getPath = function (p) {
-                        assert.ifError(utils.assertPath(p, true));
-                        return (client.path(p, true));
-                    };
-    opts.paths = opts._args.map(getPath);
-
     if (args.parseCmdOptions) {
         args.parseCmdOptions(opts, parser);
     }
diff --git a/test/mchmod.test.js b/test/mchmod.test.js
new file mode 100644
index 0000000..7c53a19
--- /dev/null
+++ b/test/mchmod.test.js
@@ -0,0 +1,268 @@
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+/*
+ * Test the "mchmod" command.
+ */
+
+var assert = require('assert-plus');
+var forkExecWait = require('forkexec').forkExecWait;
+var fs = require('fs');
+var libuuid = require('uuid');
+var path = require('path');
+var vasync = require('vasync');
+var sprintf = require('extsprintf').sprintf;
+
+var logging = require('./lib/logging');
+
+
+var log = logging.createLogger();
+
+var BINDIR = path.resolve(__dirname, '../bin');
+var MMKDIR = path.resolve(BINDIR, 'mmkdir');
+var MCHMOD = path.resolve(BINDIR, 'mchmod');
+var MPUT = path.resolve(BINDIR, 'mput');
+var MRM = path.resolve(BINDIR, 'mrm');
+var MINFO = path.resolve(BINDIR, 'minfo');
+
+var TMPDIR = process.env.TMPDIR || '/tmp';
+
+var TESTDIR = sprintf('/%s/stor/node-manta-test-mchmod-%s',
+    process.env.MANTA_USER || 'admin',
+    libuuid.v4().split('-')[0]);
+var TESTTREE = [
+    {
+        path: TESTDIR,
+        type: 'directory'
+    }
+];
+
+/*
+ * Create three regular UNIX text files (linefeed separated, with a terminating
+ * linefeed).
+ */
+var i;
+for (i = 1; i <= 3; i++) {
+    TESTTREE.push({
+        path: sprintf('%s/%02d.txt', TESTDIR, i),
+        type: 'object',
+        content: sprintf('%s\nfile (%02d)\n',
+            [ 'first', 'second', 'third' ][i - 1], i)
+    });
+}
+
+
+/*
+ * Create three data files that contain only a single character.  Of particular
+ * note is the lack of a trailing linefeed.
+ */
+for (i = 1; i <= 3; i++) {
+    TESTTREE.push({
+        path: sprintf('%s/%02d.data', TESTDIR, i),
+        type: 'object',
+        content: sprintf('%s', String.fromCharCode('a'.charCodeAt(0) + i - 1))
+    });
+}
+
+
+// ---- helper functions
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+
+function unlinkIfExists(targ) {
+    try {
+        fs.unlinkSync(targ);
+    } catch (ex) {
+        if (ex.code === 'ENOENT')
+            return;
+
+        throw (ex);
+    }
+}
+
+
+// ---- tests
+
+/*
+ * These tests require a role to be configured in triton to work properly so it
+ * is condtional upon the user setting MANTA_TEST_ROLE in the environment.
+ */
+if (process.env.MANTA_TEST_ROLE) {
+
+    test('setup: create test tree at ' + TESTDIR, function (t) {
+        var tmpFile = path.join(TMPDIR, 'node-manta-test-tmp-file-'
+            + process.pid);
+
+        vasync.forEachPipeline({
+            inputs: TESTTREE,
+            func: function createTreeItem(item, next) {
+                log.trace({ item: item }, 'create test tree item');
+
+                switch (item.type) {
+                case 'directory':
+                    forkExecWait({argv: [MMKDIR, '-p', item.path]}, next);
+                    return;
+
+                case 'object':
+                    /*
+                     * Would like a 'stdin' option to `forkExecWait`. For now
+                     * I'll quick hack with a local file. An alternative would
+                     * be to use the manta client.
+                     */
+                    vasync.pipeline({ funcs: [
+                        function mkTmpFile(_, next2) {
+                            fs.writeFile(tmpFile, item.content, next2);
+                        },
+                        function mputIt(_, next2) {
+                            forkExecWait({
+                                argv: [ MPUT, '-f', tmpFile, item.path ]
+                            }, next2);
+                        },
+                        function rmTmpFile(_, next2) {
+                            fs.unlink(tmpFile, next2);
+                        }
+                    ]}, next);
+                    return;
+
+                default:
+                    t.ifError(new Error('invalid test tree type: '
+                        + item.type));
+                    return;
+                }
+            }
+        }, function (err) {
+            t.ifError(err, err);
+            t.done();
+        });
+    });
+
+    test('minfo to verify lack of --role-tag header', function (t) {
+
+        // Expect the role-tag header
+        var role = process.env.MANTA_TEST_ROLE;
+        var expectedHeader = 'role-tag: ' + role;
+        var argv1 = [
+            MINFO,
+            sprintf('%s/%02d.data', TESTDIR, 1)
+        ];
+
+        forkExecWait({
+            argv: argv1
+        }, function (err, info) {
+               t.ifError(err, err);
+
+               t.equal(info.stderr, '', 'no stderr');
+
+               var headerIndex = info.stdout.indexOf(expectedHeader);
+               t.equal(headerIndex, -1,
+                   'minfo response doe not contain role-tag header');
+
+               t.done();
+           });
+    });
+
+    test('mchmod to add role-tag', function (t) {
+
+        // Expect the role-tag header
+        var role = process.env.MANTA_TEST_ROLE;
+        var expectedHeader = 'role-tag: ' + role;
+
+        var argv1 = [
+            MCHMOD,
+            '--',
+            sprintf('+%s', role),
+            sprintf('%s/%02d.data', TESTDIR, 1)
+        ];
+
+        var argv2 = [
+            MINFO,
+            sprintf('%s/%02d.data', TESTDIR, 1)
+        ];
+
+        forkExecWait({
+            argv: argv1
+        }, function (err, info) {
+               t.ifError(err, err);
+
+               t.equal(info.stderr, '', 'no stderr');
+
+               forkExecWait({
+                   argv: argv2
+               }, function (err2, info2) {
+                      t.ifError(err2, err2);
+                      t.equal(info2.stderr, '', 'no stderr');
+
+                      var headerIndex = info2.stdout.indexOf(expectedHeader);
+                      t.notEqual(headerIndex, -1,
+                          'minfo response contains role-tag header');
+
+                      t.done();
+                  });
+           });
+    });
+
+    test('mchmod to remove role-tag', function (t) {
+
+        // Expect the role-tag header
+        var role = process.env.MANTA_TEST_ROLE;
+        var expectedHeader = 'role-tag: ' + role;
+
+        var argv1 = [
+            MCHMOD,
+            '--',
+            sprintf('-%s', role),
+            sprintf('%s/%02d.data', TESTDIR, 1)
+        ];
+
+        var argv2 = [
+            MINFO,
+            sprintf('%s/%02d.data', TESTDIR, 1)
+        ];
+
+        forkExecWait({
+            argv: argv1
+        }, function (err, info) {
+               t.ifError(err, err);
+
+               t.equal(info.stderr, '', 'no stderr');
+
+               forkExecWait({
+                   argv: argv2
+               }, function (err2, info2) {
+                      t.ifError(err2, err2);
+                      t.equal(info2.stderr, '', 'no stderr');
+
+                      var headerIndex = info2.stdout.indexOf(expectedHeader);
+                      t.equal(headerIndex, -1,
+                          'minfo response does not contain role-tag header');
+
+                      t.done();
+                  });
+           });
+    });
+
+    test('cleanup: rm test tree ' + TESTDIR, function (t) {
+        // Sanity checks that we don't `mrm -r` a non-test dir.
+        assert.ok(TESTDIR);
+        assert.ok(TESTDIR.indexOf('node-manta-test') !== -1);
+
+        forkExecWait({ argv: [ MRM, '-r', TESTDIR ]}, function (err) {
+            t.ifError(err, err);
+            t.done();
+        });
+    });
+
+
+    test('cleanup: rm tmp directory ' + TMPDIR, function (t) {
+        var tmpFile = path.join(TMPDIR, 'node-manta-test-tmp-file-'
+            + process.pid);
+
+        unlinkIfExists(tmpFile);
+
+        t.done();
+    });
+}
