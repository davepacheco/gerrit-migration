commit 7dc6d3f2a45d0ccc8a120ff3fe2a93495c47934f (refs/changes/11/2511/1)
Author: Brittany Wald <brittany.wald@joyent.com>
Date:   2017-09-07T18:43:02+00:00 (2 years, 1 month ago)
    
    MANTA-3411 node-fash does not operate on vnode zero appropriately

diff --git a/lib/common.js b/lib/common.js
index 1ebcd3b..48e9101 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -88,7 +88,8 @@ function _parseIntArray(vnodes) {
         }
 
         vnodeArray[i] = parsedElement;
-        if (!vnodeArray[i] || vnodeArray[i] === '' || vnodeArray[i] === ',') {
+        if ((vnodeArray[i] !== 0 && !vnodeArray[i]) ||
+            vnodeArray[i] === '' || vnodeArray[i] === ',') {
             continue;
         }
         newVnodeArray.push(vnodeArray[i]);
diff --git a/test/leveldb.test.js b/test/leveldb.test.js
index fded58d..82ff6a0 100644
--- a/test/leveldb.test.js
+++ b/test/leveldb.test.js
@@ -174,6 +174,57 @@ _testAllConstructors(function remapSomeVnodeToAnother(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function remapVnodeZeroToAnother(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel, hInMem) {
+                _.hLevel = hLevel;
+                _.hInMem = hInMem;
+                return cb(err);
+            });
+        },
+        function getVnodes(_, cb) {
+            _.hLevel.getVnodes(PNODES[0], function (err, vnodes) {
+                _.vnodes = vnodes.splice(vnodes.length / 2);
+                return cb(err);
+            });
+        },
+        function remap(_, cb) {
+            _.hInMem.remapVnode(PNODES[1], 0);
+            var count = 0;
+            // remap to the second pnode
+            _.hLevel.remapVnode(PNODES[1], 0, remapCb);
+
+            // callback is necessary
+            function remapCb(err) {
+                if (err) {
+                    return cb(err);
+                }
+                return cb();
+            };
+        },
+        function assertVnodes(_, cb) {
+            _.hLevel.getVnodes(PNODES[1], function (err, vnodes) {
+                if (err) {
+                    return cb(err);
+                }
+                var inMemVnodes = _.hInMem.getVnodes(PNODES[1]);
+                t.ok(lodash.isEqual(vnodes.sort(), inMemVnodes.sort()),
+                              'level vnodes should equal in mem vnodes');
+                return cb();
+            });
+        },
+        function verify(_, cb) {
+            _verifyRing(_.hLevel, _.hInMem, t, algo, cb);
+        }
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
 _testAllConstructors(function removePnode(algo, constructor, t) {
     var rmPnodeIdx = ((PNODES.length - 1) * Math.random()).toFixed();
     var rmPnode = PNODES[rmPnodeIdx];
@@ -470,6 +521,41 @@ _testAllConstructors(function addData(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function addDataToVnodeZero(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel, hInMem) {
+                _.hLevel = hLevel;
+                _.hInMem = hInMem;
+                return cb(err);
+            });
+        },
+        function addData(_, cb) {
+            _.hLevel.addData(0, 'foo', cb);
+            _.hInMem.addData(0, 'foo');
+        },
+        function checkVnodeArray(_, cb) {
+            _.hLevel.getDataVnodes(function (err, vnodeArray) {
+                if (err) {
+                    return cb(err);
+                }
+                t.ok((vnodeArray.indexOf(0) !== -1), 'vnode ' +
+                     0 + ' is not in the vnode array');
+
+                return cb();
+            });
+        },
+        function verify(_, cb) {
+            _verifyRing(_.hLevel, _.hInMem, t, algo, cb);
+        },
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
 _testAllConstructors(function addDataBackToNull(algo, constructor, t) {
     vasync.pipeline({funcs: [
         function newRing(_, cb) {
@@ -562,6 +648,39 @@ _testAllConstructors(function getVnodePnodeAndData(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function getVnodeZeroPnodeAndData(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel) {
+                _.hLevel = hLevel;
+                return cb(err);
+            });
+        },
+        function getVnodePnodeAndData(_, cb) {
+            _.hLevel.getVnodePnodeAndData(0,
+                function (err, pnode, vnodeData) {
+                    if (err) {
+                        return cb(err);
+                    }
+                    if (PNODES.indexOf(pnode) === -1) {
+                        return cb(
+                            new Error('pnode does not exist in pnode array'));
+                    }
+                    if (vnodeData !== 0 && !vnodeData) {
+                        return cb(
+                            new Error('data for vnode 0 not found'));
+                    }
+                    return cb();
+                });
+        },
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
 _testAllConstructors(function getVnodePnodeAndDataReadOnly(algo, constructor, t)
 {
     vasync.pipeline({funcs: [
