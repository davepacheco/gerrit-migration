commit 73c51031814689fc4492d298f6a8a3c6f0e7825e (refs/changes/11/2511/6)
Author: Brittany Wald <brittany.wald@joyent.com>
Date:   2017-09-20T16:22:36+00:00 (2 years, 1 month ago)
    
    MANTA-3411 node-fash does not operate on vnode zero appropriately
    Reviewed by: Cody Peter Mello <cody.mello@joyent.com>
    Approved by: Kelly McLaughlin <kelly.mclaughlin@joyent.com>

diff --git a/lib/common.js b/lib/common.js
index 1ebcd3b..22dce75 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -86,12 +86,7 @@ function _parseIntArray(vnodes) {
         if (parsedElementIsError) {
             continue;
         }
-
-        vnodeArray[i] = parsedElement;
-        if (!vnodeArray[i] || vnodeArray[i] === '' || vnodeArray[i] === ',') {
-            continue;
-        }
-        newVnodeArray.push(vnodeArray[i]);
+        newVnodeArray.push(parsedElement);
     }
     return newVnodeArray;
 }
diff --git a/package.json b/package.json
index 8935c96..4f08587 100644
--- a/package.json
+++ b/package.json
@@ -21,7 +21,7 @@
     "dynamo",
     "hash ring"
   ],
-  "version": "2.4.0",
+  "version": "2.4.1",
   "repository": {
     "type": "git",
     "url": "https://github.com/yunong/node-fash.git"
diff --git a/test/leveldb.test.js b/test/leveldb.test.js
index fded58d..616db44 100644
--- a/test/leveldb.test.js
+++ b/test/leveldb.test.js
@@ -174,6 +174,48 @@ _testAllConstructors(function remapSomeVnodeToAnother(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function remapVnodeZeroToAnother(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel, hInMem) {
+                _.hLevel = hLevel;
+                _.hInMem = hInMem;
+                cb(err);
+            });
+        },
+        function getVnodes(_, cb) {
+            _.hLevel.getVnodes(PNODES[0], function (err, vnodes) {
+                _.vnodes = vnodes.splice(vnodes.length / 2);
+                cb(err);
+            });
+        },
+        function remapInMem(_, cb) {
+            _.hInMem.remapVnode(PNODES[1], 0, cb);
+        },
+        function remapLevelDB(_, cb) {
+            _.hLevel.remapVnode(PNODES[1], 0, cb);
+        },
+        function assertVnodes(_, cb) {
+            _.hLevel.getVnodes(PNODES[1], function (err, vnodes) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                var inMemVnodes = _.hInMem.getVnodes(PNODES[1]);
+                t.ok(lodash.isEqual(vnodes.sort(), inMemVnodes.sort()),
+                    'level vnodes should equal in mem vnodes');
+                cb();
+            });
+        },
+        function verify(_, cb) {
+            _verifyRing(_.hLevel, _.hInMem, t, algo, cb);
+        }
+    ], arg: {}}, function (err) {
+        t.ifError(err, 'all steps should succeed');
+        t.done();
+    });
+});
+
 _testAllConstructors(function removePnode(algo, constructor, t) {
     var rmPnodeIdx = ((PNODES.length - 1) * Math.random()).toFixed();
     var rmPnode = PNODES[rmPnodeIdx];
@@ -470,6 +512,41 @@ _testAllConstructors(function addData(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function addDataToVnodeZero(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel, hInMem) {
+                _.hLevel = hLevel;
+                _.hInMem = hInMem;
+                cb(err);
+            });
+        },
+        function addDataInMem(_, cb) {
+            _.hInMem.addData(0, 'foo', cb);
+        },
+        function addDataLevelDB(_, cb) {
+            _.hLevel.addData(0, 'foo', cb);
+        },
+        function checkVnodeArray(_, cb) {
+            _.hLevel.getDataVnodes(function (err, vnodeArray) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                t.ok((vnodeArray.indexOf(0) !== -1),
+                    'vnode 0 is not in the vnode array');
+                cb();
+            });
+        },
+        function verify(_, cb) {
+            _verifyRing(_.hLevel, _.hInMem, t, algo, cb);
+        },
+    ], arg: {}}, function (err) {
+        t.ifError(err, 'all steps should succeed');
+        t.done();
+    });
+});
+
 _testAllConstructors(function addDataBackToNull(algo, constructor, t) {
     vasync.pipeline({funcs: [
         function newRing(_, cb) {
@@ -562,6 +639,40 @@ _testAllConstructors(function getVnodePnodeAndData(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function getVnodeZeroPnodeAndData(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel) {
+                _.hLevel = hLevel;
+                cb(err);
+            });
+        },
+        function getVnodePnodeAndData(_, cb) {
+            _.hLevel.getVnodePnodeAndData(0,
+                function (err, pnode, vnodeData) {
+                    if (err) {
+                        cb(err);
+                        return;
+                    }
+                    if (PNODES.indexOf(pnode) === -1) {
+                        cb(new Error(
+                            'pnode does not exist in pnode array'));
+                        return;
+                    }
+                    if (vnodeData !== 0 && !vnodeData) {
+                        cb(new Error(
+                            'data for vnode 0 not found'));
+                        return;
+                    }
+                    cb();
+                });
+        },
+    ], arg: {}}, function (err) {
+        t.ifError(err, 'all steps should succeed');
+        t.done();
+    });
+});
+
 _testAllConstructors(function getVnodePnodeAndDataReadOnly(algo, constructor, t)
 {
     vasync.pipeline({funcs: [
