From 2e55d11354e5d2e31d793acaa2b2c280d233ca0d Mon Sep 17 00:00:00 2001
From: Brittany Wald <brittany.wald@joyent.com>
Date: Thu, 7 Sep 2017 18:43:02 +0000
Subject: [PATCH] MANTA-3411 node-fash does not operate on vnode zero
 appropriately

---
 lib/common.js        |   3 +-
 package.json         |   2 +-
 test/leveldb.test.js | 119 +++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 122 insertions(+), 2 deletions(-)

diff --git a/lib/common.js b/lib/common.js
index 1ebcd3b..48e9101 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -88,7 +88,8 @@ function _parseIntArray(vnodes) {
         }
 
         vnodeArray[i] = parsedElement;
-        if (!vnodeArray[i] || vnodeArray[i] === '' || vnodeArray[i] === ',') {
+        if ((vnodeArray[i] !== 0 && !vnodeArray[i]) ||
+            vnodeArray[i] === '' || vnodeArray[i] === ',') {
             continue;
         }
         newVnodeArray.push(vnodeArray[i]);
diff --git a/package.json b/package.json
index 8935c96..4f08587 100644
--- a/package.json
+++ b/package.json
@@ -21,7 +21,7 @@
     "dynamo",
     "hash ring"
   ],
-  "version": "2.4.0",
+  "version": "2.4.1",
   "repository": {
     "type": "git",
     "url": "https://github.com/yunong/node-fash.git"
diff --git a/test/leveldb.test.js b/test/leveldb.test.js
index fded58d..82ff6a0 100644
--- a/test/leveldb.test.js
+++ b/test/leveldb.test.js
@@ -174,6 +174,57 @@ _testAllConstructors(function remapSomeVnodeToAnother(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function remapVnodeZeroToAnother(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel, hInMem) {
+                _.hLevel = hLevel;
+                _.hInMem = hInMem;
+                return cb(err);
+            });
+        },
+        function getVnodes(_, cb) {
+            _.hLevel.getVnodes(PNODES[0], function (err, vnodes) {
+                _.vnodes = vnodes.splice(vnodes.length / 2);
+                return cb(err);
+            });
+        },
+        function remap(_, cb) {
+            _.hInMem.remapVnode(PNODES[1], 0);
+            var count = 0;
+            // remap to the second pnode
+            _.hLevel.remapVnode(PNODES[1], 0, remapCb);
+
+            // callback is necessary
+            function remapCb(err) {
+                if (err) {
+                    return cb(err);
+                }
+                return cb();
+            };
+        },
+        function assertVnodes(_, cb) {
+            _.hLevel.getVnodes(PNODES[1], function (err, vnodes) {
+                if (err) {
+                    return cb(err);
+                }
+                var inMemVnodes = _.hInMem.getVnodes(PNODES[1]);
+                t.ok(lodash.isEqual(vnodes.sort(), inMemVnodes.sort()),
+                              'level vnodes should equal in mem vnodes');
+                return cb();
+            });
+        },
+        function verify(_, cb) {
+            _verifyRing(_.hLevel, _.hInMem, t, algo, cb);
+        }
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
 _testAllConstructors(function removePnode(algo, constructor, t) {
     var rmPnodeIdx = ((PNODES.length - 1) * Math.random()).toFixed();
     var rmPnode = PNODES[rmPnodeIdx];
@@ -470,6 +521,41 @@ _testAllConstructors(function addData(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function addDataToVnodeZero(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel, hInMem) {
+                _.hLevel = hLevel;
+                _.hInMem = hInMem;
+                return cb(err);
+            });
+        },
+        function addData(_, cb) {
+            _.hLevel.addData(0, 'foo', cb);
+            _.hInMem.addData(0, 'foo');
+        },
+        function checkVnodeArray(_, cb) {
+            _.hLevel.getDataVnodes(function (err, vnodeArray) {
+                if (err) {
+                    return cb(err);
+                }
+                t.ok((vnodeArray.indexOf(0) !== -1), 'vnode ' +
+                     0 + ' is not in the vnode array');
+
+                return cb();
+            });
+        },
+        function verify(_, cb) {
+            _verifyRing(_.hLevel, _.hInMem, t, algo, cb);
+        },
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
 _testAllConstructors(function addDataBackToNull(algo, constructor, t) {
     vasync.pipeline({funcs: [
         function newRing(_, cb) {
@@ -562,6 +648,39 @@ _testAllConstructors(function getVnodePnodeAndData(algo, constructor, t) {
     });
 });
 
+_testAllConstructors(function getVnodeZeroPnodeAndData(algo, constructor, t) {
+    vasync.pipeline({funcs: [
+        function newRing(_, cb) {
+            constructor(algo, function (err, hLevel) {
+                _.hLevel = hLevel;
+                return cb(err);
+            });
+        },
+        function getVnodePnodeAndData(_, cb) {
+            _.hLevel.getVnodePnodeAndData(0,
+                function (err, pnode, vnodeData) {
+                    if (err) {
+                        return cb(err);
+                    }
+                    if (PNODES.indexOf(pnode) === -1) {
+                        return cb(
+                            new Error('pnode does not exist in pnode array'));
+                    }
+                    if (vnodeData !== 0 && !vnodeData) {
+                        return cb(
+                            new Error('data for vnode 0 not found'));
+                    }
+                    return cb();
+                });
+        },
+    ], arg: {}}, function (err) {
+        if (err) {
+            t.fail(err);
+        }
+        t.done();
+    });
+});
+
 _testAllConstructors(function getVnodePnodeAndDataReadOnly(algo, constructor, t)
 {
     vasync.pipeline({funcs: [
-- 
2.21.0

