From f7e7ead132b0d13bc287c5dc4eb9524e9b132e7a Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Thu, 3 Nov 2016 16:17:03 +0000
Subject: [PATCH] OS-5762 lxbrand SCM_RIGHTS fd manipulation could race when
 setting CLOEXEC

---
 .../uts/common/brand/lx/syscall/lx_socket.c   | 20 +++++++++++++++++--
 1 file changed, 18 insertions(+), 2 deletions(-)

diff --git a/usr/src/uts/common/brand/lx/syscall/lx_socket.c b/usr/src/uts/common/brand/lx/syscall/lx_socket.c
index 2db0204b51..4bb7440eca 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_socket.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_socket.c
@@ -1116,12 +1116,28 @@ lx_cmsg_set_cloexec(void *input, socklen_t inlen)
 		    inmsg->cmsg_type == SCM_RIGHTS) {
 			int *fds = (int *)CMSG_CONTENT(inmsg);
 			int i, num = (int)CMSG_CONTENTLEN(inmsg) / sizeof (int);
+
 			for (i = 0; i < num; i++) {
 				char flags;
 				file_t *fp;
-				/* set CLOEXEC on the fd */
+
 				fp = getf(fds[i]);
-				VERIFY(fp != NULL);
+				if (fp == NULL) {
+					/*
+					 * It is possible that a received fd
+					 * will already have been closed if a
+					 * thread in the local process is
+					 * indiscriminately issuing close(2)
+					 * calls while the message is being
+					 * received.  If that is the case, no
+					 * further processing of the fd is
+					 * needed.  It will still be passed
+					 * up in the cmsg even though the
+					 * caller chose to close it already.
+					 */
+					continue;
+				}
+
 				flags = f_getfd(fds[i]);
 				flags |= FD_CLOEXEC;
 				f_setfd(fds[i], flags);
-- 
2.21.0

