commit ea0ea452f10888cd22d14b184fd89c5d7ca779e9 (refs/changes/27/1427/1)
Author: David Pacheco <dap@joyent.com>
Date:   2017-02-03T12:13:51-08:00 (2 years, 8 months ago)
    
    MANTA-3137 minnow alarms fire spuriously after MANTA-3127

diff --git a/Makefile b/Makefile
index 71dd6b8..d1116d6 100644
--- a/Makefile
+++ b/Makefile
@@ -25,8 +25,9 @@
 #
 # Files
 #
+BASH_FILES	 = bin/check-minnow
 DOC_FILES	 = index.md
-JS_FILES	:= $(shell ls *.js)
+JS_FILES	:= $(wildcard *.js bin/*.js)
 JSL_CONF_NODE	 = tools/jsl.node.conf
 JSL_FILES_NODE   = $(JS_FILES)
 JSSTYLE_FILES	 = $(JS_FILES)
diff --git a/bin/check-minnow b/bin/check-minnow
new file mode 100755
index 0000000..db09ce6
--- /dev/null
+++ b/bin/check-minnow
@@ -0,0 +1,30 @@
+#!/bin/bash
+
+#
+# check-minnow: amon probe check script used to verify that this system's minnow
+# record is up-to-date.  This script just sets up paths to invoke a Node.js
+# script.
+#
+
+#
+# Given an absolute directory path or a path relative to the current directory,
+# emit an absolute path to the directory.  Returns 0 on success and non-zero
+# otherwise.
+#
+function abspath
+{
+	(cd "$1" && pwd)
+}
+
+function fail
+{
+	echo "$cm_arg0: $@" >&2
+	exit 1
+}
+
+cm_arg0="${BASH_SOURCE[0]}"
+cm_bindir="$(dirname "$cm_arg0")"
+cm_minnow_root="$(abspath "$cm_bindir/..")" || fail "failed to find minnow root"
+
+exec "$cm_minnow_root/build/node/bin/node" \
+    "$cm_minnow_root/bin/check-minnow.js" "$@"
diff --git a/bin/check-minnow.js b/bin/check-minnow.js
new file mode 100644
index 0000000..ccc80b3
--- /dev/null
+++ b/bin/check-minnow.js
@@ -0,0 +1,277 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * check-minnow.js: verifies that the specified host's minnow record is
+ * up-to-date.  Exits 0 on success and non-zero otherwise.  This is invoked by
+ * amon via the check-minnow bash script in the same directory.
+ */
+
+var assert = require('assert-plus');
+var bunyan = require('bunyan');
+var cmdutil = require('cmdutil');
+var dashdash = require('dashdash');
+var fs = require('fs');
+var moray = require('moray');
+var path = require('path');
+var VError = require('verror');
+
+var OPTIONS, USAGE_MESSAGE;
+
+OPTIONS = [ {
+    'names': [ 'help', 'h' ],
+    'type': 'bool',
+    'help': 'print this message and exit.'
+}, {
+    'names': [ 'file', 'f' ],
+    'type': 'string',
+    'help': 'path to minnow configuration file',
+    'default': path.join(__dirname, '..', 'etc', 'config.json')
+}, {
+    'names': [ 'max-age', 'a' ],
+    'type': 'positiveInteger',
+    'help': 'maximum age in seconds for a valid record',
+    'default': 900
+} ];
+
+USAGE_MESSAGE = [
+    'Checks the minnow heartbeat record for the current host to make sure ',
+    'that it\'s relatively recent.  Returns 0 if the record appears ',
+    'up-to-date and non-zero otherwise.'
+].join('\n');
+
+/*
+ * This data structure is used throughout this program to keep track of the
+ * state of the operation.
+ */
+var checkMinnow = {
+    /* bunyan log */
+    'cm_log': null,
+    /* dash-dash CLI argument parser */
+    'cm_parser': null,
+    /* raw dashdash-parsed command-line options */
+    'cm_args': null,
+    /* minnow configuration (file path) */
+    'cm_minnow_path': null,
+    /* minnow configuration (parsed JSON) */
+    'cm_minnow_config': null,
+    /* moray client */
+    'cm_moray': null
+};
+
+function main()
+{
+    parseArguments(checkMinnow);
+    parseMinnowConfig(checkMinnow);
+    morayInit(checkMinnow, function (err) {
+        if (err) {
+            cmdutil.fail(err);
+        }
+
+        minnowCheck(checkMinnow, function (err2) {
+            if (err2) {
+                cmdutil.fail(err2);
+            }
+
+            checkMinnow.cm_moray.close();
+        });
+    });
+}
+
+/*
+ * Process command-line arguments using dashdash and populate the "checkMinnow"
+ * structure (in "cm") with the results.
+ */
+function parseArguments(cm)
+{
+    assert.strictEqual(checkMinnow.cm_log, null);
+
+    cm.cm_log = bunyan.createLogger({
+        'level': process.env['LOG_LEVEL'] || 'warn',
+        'name': path.basename(__filename)
+    });
+
+    cm.cm_parser = new dashdash.Parser({ 'options': OPTIONS });
+
+    cmdutil.configure({
+        'synopses': [ '[-a | --max-age NSECONDS]' ],
+        'usageMessage': USAGE_MESSAGE + '\n\n' +
+            cm.cm_parser.help().trimRight()
+    });
+
+    try {
+        cm.cm_args = cm.cm_parser.parse(process.argv);
+        assert.object(cm.cm_args);
+    } catch (ex) {
+        cmdutil.usage(ex);
+    }
+
+    if (cm.cm_args.help) {
+        cmdutil.usage();
+    }
+
+    if (cm.cm_args._args.length > 0) {
+        cmdutil.usage('unexpected arguments');
+    }
+
+    cm.cm_minnow_path = cm.cm_args.file;
+    cm.cm_maxage = cm.cm_args.max_age;
+
+    cm.cm_log.debug({
+        'minnowConfigPath': cm.cm_minnow_path,
+        'maxAge': cm.cm_maxage
+    }, 'init');
+}
+
+/*
+ * Read and parse the minnow configuration file specified in "cm" and populate
+ * "cm" with the results.
+ */
+function parseMinnowConfig(cm)
+{
+    var contents, parsed;
+
+    assert.string(cm.cm_minnow_path);
+    try {
+        contents = fs.readFileSync(cm.cm_minnow_path, 'utf8');
+    } catch (ex) {
+        cmdutil.fail(new VError(ex, 'read minnow config "%s"',
+            cm.cm_minnow_path));
+    }
+
+    try {
+        parsed = JSON.parse(contents);
+    } catch (ex) {
+        cmdutil.fail(new VError(ex, 'parse minnow config "%s"',
+            cm.cm_minnow_path));
+    }
+
+    if (typeof (parsed) != 'object' || parsed === null ||
+        typeof (parsed.moray) != 'object' || parsed.moray === null ||
+        typeof (parsed.moray.morayConfig) != 'object' ||
+        parsed.moray.morayConfig === null ||
+        typeof (parsed.zone_uuid) != 'string' ||
+        typeof (parsed.domain) != 'string' ||
+        typeof (parsed.moray.bucket) != 'object' ||
+        parsed.moray.bucket === null ||
+        typeof (parsed.moray.bucket.name) != 'string') {
+        cmdutil.fail('validate minnow config "%s": unexpected contents',
+            cm.cm_minnow_path);
+    }
+
+    if (typeof (parsed.zone_uuid) != 'string') {
+        cmdutil.fail('"zone_uuid" missing from minnow configuration');
+        return;
+    }
+
+    if (typeof (parsed.domain) != 'string') {
+        cmdutil.fail('"domain" missing from minnow configuration');
+        return;
+    }
+
+    cm.cm_minnow_config = parsed;
+}
+
+/*
+ * Connect to Moray.
+ */
+function morayInit(cm, callback)
+{
+    var cfg, morayargs, k;
+    var done = false;
+
+    cfg = cm.cm_minnow_config.moray.morayConfig;
+    morayargs = {};
+    for (k in cfg) {
+        morayargs[k] = cfg[k];
+    }
+
+    morayargs.log = cm.cm_log.child({ 'component': 'MorayClient' });
+    morayargs.mustCloseBeforeNormalProcessExit = true;
+    morayargs.failFast = true;
+    cm.cm_moray = moray.createClient(morayargs);
+    cm.cm_moray.on('error', function (err) {
+        assert.ok(!done);
+        done = true;
+        callback(err);
+    });
+    cm.cm_moray.on('connect', function () {
+        assert.ok(!done);
+        done = true;
+        callback();
+    });
+}
+
+/*
+ * Given a connected Moray client, check the Minnow record.
+ */
+function minnowCheck(cm, callback)
+{
+    var bucket, zonename, domain, key;
+
+    /*
+     * The configuration has already been validated at this point.
+     */
+    bucket = cm.cm_minnow_config.moray.bucket.name;
+    assert.string(bucket);
+    domain = cm.cm_minnow_config.domain;
+    assert.string(domain);
+    zonename = cm.cm_minnow_config.zone_uuid;
+    assert.string(zonename);
+    key = zonename + '.' + domain;
+    cm.cm_moray.getObject(bucket, key, function (err, obj) {
+        var now, earliest, found;
+
+        if (err) {
+            callback(new VError(err, 'getObject "%s"', key));
+            return;
+        }
+
+        if (typeof (obj.value) != 'object' || obj.value === null ||
+            typeof (obj.value.timestamp) != 'number') {
+            callback(new VError('getObject "%s": unexpected response', key));
+            return;
+        }
+
+        now = new Date();
+        earliest = new Date(now.getTime() - (cm.cm_maxage * 1000));
+        found = new Date(obj.value.timestamp);
+        cm.cm_log.debug({
+            'now': now.toISOString(),
+            'earliest': earliest.toISOString(),
+            'found': found.toISOString()
+        }, 'timestamp check');
+
+        if (found.getTime() > now.getTime()) {
+            /*
+             * We're running on the same system that would have captured the
+             * timestamp that's in the record.  This really should be impossible
+             * unless the clock goes backwards.  If that happens, we may fire a
+             * spurious alarm, but it's likely worth notifying somebody about.
+             */
+            callback(new VError(
+                'record "%s" has timestamp from the future: "%s"', key,
+                found.toISOString()));
+            return;
+        }
+
+        if (found.getTime() < earliest.getTime()) {
+            callback(new VError(
+                'record "%s" is too old (found timestamp "%s", ' +
+                'expecting one from at least "%s"', key,
+                found.toISOString(), earliest.toISOString()));
+            return;
+        }
+
+        callback();
+    });
+}
+
+main();
diff --git a/package.json b/package.json
index 3791bb3..9ecd65a 100644
--- a/package.json
+++ b/package.json
@@ -12,12 +12,14 @@
     "dependencies": {
         "assert-plus": "0.1.4",
         "bunyan": "0.21.4",
+        "cmdutil": "1.1.0",
         "dashdash": "1.3.2",
         "libmanta": "git+ssh://git@github.com:joyent/node-libmanta.git#master",
         "moray": "3.0.0",
         "node-uuid": "1.4.0",
         "once": "1.2.0",
-        "statvfs": "2.0.0"
+        "statvfs": "2.0.0",
+        "verror": "1.9.0"
     },
     "sdcDependencies": {
         "config-agent": ">=1.2.0"
diff --git a/tools/bashstyle b/tools/bashstyle
old mode 100644
new mode 100755
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
index 0b8ae95..4ef2046 100644
--- a/tools/jsl.node.conf
+++ b/tools/jsl.node.conf
@@ -110,6 +110,8 @@
 #
 # Common uses for webpages might be:
 +define __dirname
++define __filename
++define clearImmediate
 +define clearInterval
 +define clearTimeout
 +define console
@@ -118,6 +120,7 @@
 +define module
 +define process
 +define require
++define setImmediate
 +define setInterval
 +define setTimeout
 +define Buffer
