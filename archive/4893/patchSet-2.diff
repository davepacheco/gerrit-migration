commit f3f2acd8402ea766d0b937d2f62a02077ca2e14f (refs/changes/93/4893/2)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2018-10-02T14:17:01-07:00 (1 year ago)
    
    joyent/node-cueball#148 cset with n=1 holds onto dead connections
    joyent/node-cueball#147 want setUnwanted() exposed to connections

diff --git a/CHANGES.adoc b/CHANGES.adoc
index 1e9d2c1..c4d8577 100644
--- a/CHANGES.adoc
+++ b/CHANGES.adoc
@@ -6,6 +6,20 @@ toc::[]
 
 ## v2.x
 
+### v2.9.0
+
+New minor release, due to addition of new API.
+
+API Changes:
+
+ - The connection interface now has a new optional function it can implement,
+   `setUnwanted()` which allows for optimising behaviour for connection types
+   that do extra work before emitting `connect` (e.g. authentication)
+
+Bugs fixed:
+
+ - #148 cset with n=1 holds onto dead connections
+
 ### v2.8.0
 
 New minor release, due to addition of new API.
diff --git a/docs/api.adoc b/docs/api.adoc
index aedc346..1be9f46 100644
--- a/docs/api.adoc
+++ b/docs/api.adoc
@@ -632,7 +632,17 @@ argument.
 May also be emitted as `connectTimeout` only in the state before `connect` has
 been emitted.
 
+### `->setUnwanted()`
 
+As an optional feature, connections that are still connecting to their assigned
+backend may implement this function to detect that they have become "unwanted"
+by cueball (e.g. because a primary backend as returned while they were starting
+to connect). A connection that is unwanted will be closed immediately after
+it has emitted its next event, regardless of whether the connection succeeds.
+
+If your connection type has multiple phases of set-up before emitting `connect`
+(e.g. an authentication step), this may be useful to avoid doing unnecessary
+extra work in the case where the connection would be discarded anyway.
 
 ## Errors
 
diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index dda98e9..3637e3b 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -205,6 +205,19 @@ SocketMgrFSM.prototype.resetBackoff = function () {
 	}
 };
 
+/*
+ * Unlike setUnwanted() on the ConnectionSlotFSM, this one cannot trigger a
+ * state transition, and isn't part of any state conditions for SocketMgrFSM.
+ * This is just a convenience to forward the call on to our sm_socket (if
+ * we currently have one).
+ */
+SocketMgrFSM.prototype.setUnwanted = function () {
+	if (this.sm_socket &&
+	    typeof (this.sm_socket.setUnwanted) === 'function') {
+		this.sm_socket.setUnwanted();
+	}
+};
+
 SocketMgrFSM.prototype.connect = function () {
 	mod_assert.ok(this.isInState('init') || this.isInState('closed'),
 	    'SocketMgrFSM#connect may only be called in state "init" or ' +
@@ -915,6 +928,7 @@ ConnectionSlotFSM.prototype.setUnwanted = function () {
 	if (this.csf_wanted === false)
 		return;
 	this.csf_wanted = false;
+	this.csf_smgr.setUnwanted();
 	this.emit('unwanted');
 };
 
diff --git a/lib/set.js b/lib/set.js
index 06a98d4..4cc8120 100644
--- a/lib/set.js
+++ b/lib/set.js
@@ -392,13 +392,15 @@ CueBallConnectionSet.prototype._rebalance = function () {
 
 	var conns = {};
 	var total = 0;
-	var busy = 0;
+	var working = 0;
 	this.cs_keys.forEach(function (k) {
 		conns[k] = [];
 		if (self.cs_fsm[k] !== undefined) {
 			conns[k].push(self.cs_fsm[k]);
-			if (self.cs_fsm[k].isInState('busy'))
-				++busy;
+			if (self.cs_fsm[k].isInState('busy') ||
+			    self.cs_fsm[k].isInState('idle')) {
+				++working;
+			}
 			++total;
 		}
 	});
@@ -414,18 +416,23 @@ CueBallConnectionSet.prototype._rebalance = function () {
 	}
 	plan.remove.forEach(function (fsm) {
 		/*
-		 * Never deliberately remove our last working connection. We
-		 * should wait for another connection to be up and running first
-		 * and then remove this one.
+		 * Never deliberately remove our last working connection (we
+		 * include both 'busy' and 'idle' connections in our definition
+		 * of 'working' to catch new ones that have connected but we
+		 * have not yet emitted handles for). We should wait for another
+		 * connection to be up and running first and then remove this
+		 * one (it connecting will trigger another rebalance).
 		 */
-		if (busy <= 1)
+		if ((fsm.isInState('busy') || fsm.isInState('idle')) &&
+		    working <= 1) {
 			return;
+		}
 
 		var k = fsm.csf_backend.key;
 
 		/* Subtract from "busy" so the "if" above does its job. */
-		if (fsm.isInState('busy'))
-			--busy;
+		if (fsm.isInState('busy') || fsm.isInState('idle'))
+			--working;
 		fsm.setUnwanted();
 
 		/* We might have stopped synchronously. */
diff --git a/package.json b/package.json
index 56de55b..35fab39 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.8.0",
+  "version": "2.9.0",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
