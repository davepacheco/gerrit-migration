commit 03d6e6e9a1216cced1dd401e3d84a71928b449cc (refs/changes/93/4893/4)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2018-10-16T22:58:43+00:00 (12 months ago)
    
    joyent/node-cueball#148 cset with n=1 holds onto dead connections
    joyent/node-cueball#147 want setUnwanted() exposed to connections
    Reviewed by: Jan Wyszynski <jan.wyszynski@joyent.com>
    Approved by: Jan Wyszynski <jan.wyszynski@joyent.com>

diff --git a/CHANGES.adoc b/CHANGES.adoc
index 1e9d2c1..c4d8577 100644
--- a/CHANGES.adoc
+++ b/CHANGES.adoc
@@ -6,6 +6,20 @@ toc::[]
 
 ## v2.x
 
+### v2.9.0
+
+New minor release, due to addition of new API.
+
+API Changes:
+
+ - The connection interface now has a new optional function it can implement,
+   `setUnwanted()` which allows for optimising behaviour for connection types
+   that do extra work before emitting `connect` (e.g. authentication)
+
+Bugs fixed:
+
+ - #148 cset with n=1 holds onto dead connections
+
 ### v2.8.0
 
 New minor release, due to addition of new API.
diff --git a/docs/api.adoc b/docs/api.adoc
index aedc346..1be9f46 100644
--- a/docs/api.adoc
+++ b/docs/api.adoc
@@ -632,7 +632,17 @@ argument.
 May also be emitted as `connectTimeout` only in the state before `connect` has
 been emitted.
 
+### `->setUnwanted()`
 
+As an optional feature, connections that are still connecting to their assigned
+backend may implement this function to detect that they have become "unwanted"
+by cueball (e.g. because a primary backend as returned while they were starting
+to connect). A connection that is unwanted will be closed immediately after
+it has emitted its next event, regardless of whether the connection succeeds.
+
+If your connection type has multiple phases of set-up before emitting `connect`
+(e.g. an authentication step), this may be useful to avoid doing unnecessary
+extra work in the case where the connection would be discarded anyway.
 
 ## Errors
 
diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index dda98e9..3637e3b 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -205,6 +205,19 @@ SocketMgrFSM.prototype.resetBackoff = function () {
 	}
 };
 
+/*
+ * Unlike setUnwanted() on the ConnectionSlotFSM, this one cannot trigger a
+ * state transition, and isn't part of any state conditions for SocketMgrFSM.
+ * This is just a convenience to forward the call on to our sm_socket (if
+ * we currently have one).
+ */
+SocketMgrFSM.prototype.setUnwanted = function () {
+	if (this.sm_socket &&
+	    typeof (this.sm_socket.setUnwanted) === 'function') {
+		this.sm_socket.setUnwanted();
+	}
+};
+
 SocketMgrFSM.prototype.connect = function () {
 	mod_assert.ok(this.isInState('init') || this.isInState('closed'),
 	    'SocketMgrFSM#connect may only be called in state "init" or ' +
@@ -915,6 +928,7 @@ ConnectionSlotFSM.prototype.setUnwanted = function () {
 	if (this.csf_wanted === false)
 		return;
 	this.csf_wanted = false;
+	this.csf_smgr.setUnwanted();
 	this.emit('unwanted');
 };
 
diff --git a/lib/set.js b/lib/set.js
index 06a98d4..4cc8120 100644
--- a/lib/set.js
+++ b/lib/set.js
@@ -392,13 +392,15 @@ CueBallConnectionSet.prototype._rebalance = function () {
 
 	var conns = {};
 	var total = 0;
-	var busy = 0;
+	var working = 0;
 	this.cs_keys.forEach(function (k) {
 		conns[k] = [];
 		if (self.cs_fsm[k] !== undefined) {
 			conns[k].push(self.cs_fsm[k]);
-			if (self.cs_fsm[k].isInState('busy'))
-				++busy;
+			if (self.cs_fsm[k].isInState('busy') ||
+			    self.cs_fsm[k].isInState('idle')) {
+				++working;
+			}
 			++total;
 		}
 	});
@@ -414,18 +416,23 @@ CueBallConnectionSet.prototype._rebalance = function () {
 	}
 	plan.remove.forEach(function (fsm) {
 		/*
-		 * Never deliberately remove our last working connection. We
-		 * should wait for another connection to be up and running first
-		 * and then remove this one.
+		 * Never deliberately remove our last working connection (we
+		 * include both 'busy' and 'idle' connections in our definition
+		 * of 'working' to catch new ones that have connected but we
+		 * have not yet emitted handles for). We should wait for another
+		 * connection to be up and running first and then remove this
+		 * one (it connecting will trigger another rebalance).
 		 */
-		if (busy <= 1)
+		if ((fsm.isInState('busy') || fsm.isInState('idle')) &&
+		    working <= 1) {
 			return;
+		}
 
 		var k = fsm.csf_backend.key;
 
 		/* Subtract from "busy" so the "if" above does its job. */
-		if (fsm.isInState('busy'))
-			--busy;
+		if (fsm.isInState('busy') || fsm.isInState('idle'))
+			--working;
 		fsm.setUnwanted();
 
 		/* We might have stopped synchronously. */
diff --git a/package.json b/package.json
index 56de55b..35fab39 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "cueball",
-  "version": "2.8.0",
+  "version": "2.9.0",
   "description": "manage a pool of connections to a multi-node service where nodes are listed in DNS",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/cset.test.js b/test/cset.test.js
index 7815b76..b42dbbc 100644
--- a/test/cset.test.js
+++ b/test/cset.test.js
@@ -62,6 +62,7 @@ function DummyConnection(backend) {
 	this.refd = true;
 	this.connected = false;
 	this.dead = false;
+	this.unwanted = false;
 	mod_events.EventEmitter.call(this);
 }
 mod_util.inherits(DummyConnection, mod_events.EventEmitter);
@@ -87,6 +88,10 @@ DummyConnection.prototype.destroy = function () {
 	this.dead = true;
 	this.emit('close');
 };
+DummyConnection.prototype.setUnwanted = function () {
+	this.unwanted = true;
+	this.emit('unwanted');
+};
 
 mod_tape.test('cset with one backend', function (t) {
 	connections = [];
@@ -114,6 +119,7 @@ mod_tape.test('cset with one backend', function (t) {
 		if (connections.length > 1) {
 			t.fail('more than 2 connections');
 		}
+		t.ok(!connections[0].unwanted);
 		if (connections.length === 1) {
 			setImmediate(function () {
 				cset.stop();
@@ -327,6 +333,13 @@ mod_tape.test('removing a backend', function (t) {
 			var conn = index.b2[0];
 			var conn2 = index.b3[0];
 
+			t.ok(!conn2.unwanted);
+			var unwantedDuringConnect = false;
+			conn2.on('unwanted', function () {
+				if (!conn2.connected && !conn2.dead)
+					unwantedDuringConnect = true;
+			});
+
 			resolver.emit('removed', 'b2');
 			resolver.emit('removed', 'b3');
 
@@ -335,6 +348,8 @@ mod_tape.test('removing a backend', function (t) {
 				t.ok(conn2.dead);
 				t.ok(conn.seen);
 				t.ok(!conn2.seen);
+				t.ok(conn2.unwanted);
+				t.ok(unwantedDuringConnect);
 				t.equal(connections.length, 1);
 				summarize();
 				t.deepEqual(counts, { 'b1': 1 });
