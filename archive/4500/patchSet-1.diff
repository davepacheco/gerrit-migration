From 5ee645afc2e71f60232d581c419f500898091bea Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Mon, 9 Jul 2018 19:23:17 -0500
Subject: [PATCH] Delete VL3 entry on target DROP response

---
 .../uts/common/io/overlay/overlay_target.c    | 44 ++++++++++++++++---
 1 file changed, 37 insertions(+), 7 deletions(-)

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index ef9a0b8f1a..d42a8ba274 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -1441,13 +1441,20 @@ overlay_target_for_varpd(overlay_dev_t *odd, mblk_t *mp)
 	return (B_FALSE);
 }
 
+typedef enum overlay_target_lookup_drop_act {
+	OTLDA_NONE,
+	OTLDA_QUEUE,
+	OTLDA_DELETE
+} overlay_target_lookup_drop_act_t;
+
 static int
 overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 {
 	const overlay_targ_resp_t *otr = arg;
+	overlay_target_t *ott;
 	overlay_target_entry_t *entry;
 	mblk_t *mp;
-	boolean_t queue = B_FALSE;
+	overlay_target_lookup_drop_act_t action = OTLDA_NONE;
 
 	mutex_enter(&thdl->oth_lock);
 	for (entry = list_head(&thdl->oth_outstanding); entry != NULL;
@@ -1464,6 +1471,7 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 	mutex_exit(&thdl->oth_lock);
 
 	mutex_enter(&entry->ote_lock);
+	ott = entry->ote_ott;
 
 	mp = entry->ote_chead;
 
@@ -1481,6 +1489,22 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 		goto done;
 	}
 
+	/*
+	 * If varpd is instructing us to drop the head mblk in a VL2 entry,
+	 * this could be because it's already provided a response (e.g. an
+	 * ARP reply), and the entry itself might still be used for other
+	 * purposes.  VL3 entries on the other had have no such uses.  If
+	 * we are told to drop the packet, there is no reason to retain
+	 * the VL3 entry and we can delete it.
+	 */
+	if (entry->ote_flags & OVERLAY_ENTRY_F_VL3) {
+		sarc_hold(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+		action = OTLDA_DELETE;
+		mutex_exit(&entry->ote_lock);
+		goto done;
+	}
+
+	/*  Drop the first packet in entry */
 	if (mp != NULL) {
 		entry->ote_chead = mp->b_next;
 		mp->b_next = NULL;
@@ -1488,23 +1512,29 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 			entry->ote_ctail = entry->ote_chead;
 		entry->ote_mbsize -= msgsize(mp);
 	}
+
 	if (entry->ote_chead != NULL) {
-		queue = B_TRUE;
+		action = OTLDA_QUEUE;
 		entry->ote_flags |= OVERLAY_ENTRY_F_PENDING;
 	} else {
 		entry->ote_flags &= ~OVERLAY_ENTRY_F_PENDING;
 	}
 	mutex_exit(&entry->ote_lock);
 
-	if (queue == B_TRUE)
+	if (action == OTLDA_QUEUE)
 		overlay_target_queue(entry);
 	freemsg(mp);
 
 done:
-	mutex_enter(&entry->ote_ott->ott_lock);
-	entry->ote_ott->ott_ocount--;
-	cv_signal(&entry->ote_ott->ott_cond);
-	mutex_exit(&entry->ote_ott->ott_lock);
+	mutex_enter(&ott->ott_lock);
+	ott->ott_ocount--;
+	if (action == OTLDA_DELETE) {
+		sarc_rele(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+		/* overlay_target_entry_dtor() will free the mblk chain */
+		sarc_remove(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+	}
+	cv_signal(&ott->ott_cond);
+	mutex_exit(&ott->ott_lock);
 
 	return (0);
 }
-- 
2.21.0

