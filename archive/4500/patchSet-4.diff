From ff6ac730d830393efb981876a31ada3fff924c4f Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Mon, 9 Jul 2018 19:23:17 -0500
Subject: [PATCH] Delete VL3 entry on target DROP response

---
 .../uts/common/io/overlay/overlay_target.c    | 113 +++++++++++++++---
 usr/src/uts/common/io/overlay/sarc.c          |   2 +-
 2 files changed, 96 insertions(+), 19 deletions(-)

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index ef9a0b8f1a..07cacf62e3 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -367,25 +367,42 @@ overlay_target_busy()
 	return (ret);
 }
 
-/* Queue the target entry on the list of varpd requests */
+/*
+ * Queue the target entry on the list of varpd requests.  entry should be
+ * refheld for the duration of this call (this call takes its own additional
+ * hold that is released when we receive a response).
+ */
 static void
 overlay_target_queue(overlay_target_entry_t *entry)
 {
+	overlay_target_t *ott = entry->ote_ott;
+	boolean_t is_vl3 = B_FALSE;
+
 	/*
 	 * ote_ott is read-only and set at entry creation, so it can be
 	 * read without ote_lock held
 	 */
 	ASSERT(!MUTEX_HELD(&entry->ote_lock));
 
+	mutex_enter(&entry->ote_lock);
+	if ((entry->ote_flags & OVERLAY_ENTRY_F_VL3) != 0)
+		is_vl3 = B_TRUE;
+	mutex_exit(&entry->ote_lock);
+
 	mutex_enter(&overlay_target_lock);
-	mutex_enter(&entry->ote_ott->ott_lock);
-	if (entry->ote_ott->ott_flags & OVERLAY_T_TEARDOWN) {
-		mutex_exit(&entry->ote_ott->ott_lock);
+	mutex_enter(&ott->ott_lock);
+	if (ott->ott_flags & OVERLAY_T_TEARDOWN) {
+		mutex_exit(&ott->ott_lock);
 		mutex_exit(&overlay_target_lock);
 		return;
 	}
-	entry->ote_ott->ott_ocount++;
-	mutex_exit(&entry->ote_ott->ott_lock);
+	ott->ott_ocount++;
+	if (is_vl3)
+		sarc_hold(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+	else
+		sarc_hold(ott->ott_u.ott_dyn.ott_dhash, entry);
+
+	mutex_exit(&ott->ott_lock);
 	list_insert_tail(&overlay_target_list, entry);
 	cv_signal(&overlay_target_condvar);
 	mutex_exit(&overlay_target_lock);
@@ -579,6 +596,7 @@ overlay_route(overlay_dev_t *odd, mblk_t *mp,
  * Entry should already be locked, however since it is intended that this
  * should be the final step in dealing with this entry (for handling the
  * packet in question), it always releases ote_lock before returning.
+ * entry should be refheld for the duration of this call.
  */
 static int
 overlay_target_try_queue(overlay_target_entry_t *entry, mblk_t *mp)
@@ -763,9 +781,15 @@ overlay_route_lookup(overlay_dev_t *odd, mblk_t *mp, uint16_t vlan,
 		entry->ote_odd = odd;
 
 		sarc_insert(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+		sarc_hold(ott->ott_u.ott_dyn.ott_l3dhash, entry);
 		avl_add(&ott->ott_u.ott_dyn.ott_l3tree, entry);
 		mutex_exit(&ott->ott_lock);
+
 		overlay_target_queue(entry);
+
+		mutex_enter(&ott->ott_lock);
+		sarc_rele(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+		mutex_exit(&ott->ott_lock);
 		return (OVERLAY_TARGET_ASYNC);
 	}
 	sarc_hold(ott->ott_u.ott_dyn.ott_l3dhash, entry);
@@ -901,9 +925,15 @@ overlay_target_lookup(overlay_dev_t *odd, mblk_t *mp, struct sockaddr *sock,
 		entry->ote_odd = odd;
 
 		sarc_insert(ott->ott_u.ott_dyn.ott_dhash, entry);
+		sarc_hold(ott->ott_u.ott_dyn.ott_dhash, entry);
 		avl_add(&ott->ott_u.ott_dyn.ott_tree, entry);
 		mutex_exit(&ott->ott_lock);
+
 		overlay_target_queue(entry);
+
+		mutex_enter(&ott->ott_lock);
+		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, entry);
+		mutex_exit(&ott->ott_lock);
 		return (OVERLAY_TARGET_ASYNC);
 	}
 	sarc_hold(ott->ott_u.ott_dyn.ott_dhash, entry);
@@ -1364,8 +1394,10 @@ static int
 overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 {
 	const overlay_targ_resp_t *otr = arg;
+	overlay_target_t *ott;
 	overlay_target_entry_t *entry;
 	mblk_t *mp;
+	boolean_t is_vl3 = B_FALSE;
 
 	mutex_enter(&thdl->oth_lock);
 	for (entry = list_head(&thdl->oth_outstanding); entry != NULL;
@@ -1382,6 +1414,10 @@ overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 	mutex_exit(&thdl->oth_lock);
 
 	mutex_enter(&entry->ote_lock);
+	ott = entry->ote_ott;
+
+	if ((entry->ote_flags & OVERLAY_ENTRY_F_VL3) != 0)
+		is_vl3 = B_TRUE;
 
 	/*
 	 * If we ever support a protocol that uses MAC addresses as the UL
@@ -1392,7 +1428,7 @@ overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 	    otr->otr_answer.otp_port == 0)
 		entry->ote_flags |= OVERLAY_ENTRY_F_ROUTER;
 
-	if ((entry->ote_flags & OVERLAY_ENTRY_F_VL3) == 0) {
+	if (!is_vl3) {
 		bcopy(&otr->otr_answer, &entry->ote_u.ote_vl2.otvl2_dest,
 		    sizeof (overlay_target_point_t));
 		entry->ote_vtime = gethrtime();
@@ -1419,10 +1455,14 @@ overlay_target_lookup_respond(overlay_target_hdl_t *thdl, void *arg)
 	mp = overlay_m_tx(entry->ote_odd, mp);
 	freemsgchain(mp);
 
-	mutex_enter(&entry->ote_ott->ott_lock);
-	entry->ote_ott->ott_ocount--;
-	cv_signal(&entry->ote_ott->ott_cond);
-	mutex_exit(&entry->ote_ott->ott_lock);
+	mutex_enter(&ott->ott_lock);
+	ott->ott_ocount--;
+	if (is_vl3)
+		sarc_rele(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+	else
+		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, entry);
+	cv_signal(&ott->ott_cond);
+	mutex_exit(&ott->ott_lock);
 
 	return (0);
 }
@@ -1441,13 +1481,21 @@ overlay_target_for_varpd(overlay_dev_t *odd, mblk_t *mp)
 	return (B_FALSE);
 }
 
+typedef enum overlay_target_lookup_drop_act {
+	OTLDA_NONE,
+	OTLDA_QUEUE,
+	OTLDA_DELETE
+} overlay_target_lookup_drop_act_t;
+
 static int
 overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 {
 	const overlay_targ_resp_t *otr = arg;
+	overlay_target_t *ott;
 	overlay_target_entry_t *entry;
 	mblk_t *mp;
-	boolean_t queue = B_FALSE;
+	overlay_target_lookup_drop_act_t action = OTLDA_NONE;
+	boolean_t is_vl3 = B_FALSE;
 
 	mutex_enter(&thdl->oth_lock);
 	for (entry = list_head(&thdl->oth_outstanding); entry != NULL;
@@ -1464,6 +1512,9 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 	mutex_exit(&thdl->oth_lock);
 
 	mutex_enter(&entry->ote_lock);
+	ott = entry->ote_ott;
+	if ((entry->ote_flags & OVERLAY_ENTRY_F_VL3) != 0)
+		is_vl3 = B_TRUE;
 
 	mp = entry->ote_chead;
 
@@ -1481,6 +1532,21 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 		goto done;
 	}
 
+	/*
+	 * If varpd is instructing us to drop the head mblk in a VL2 entry,
+	 * this could be because it's already provided a response (e.g. an
+	 * ARP reply), and the entry itself might still be used for other
+	 * purposes.  VL3 entries on the other had have no such uses.  If
+	 * we are told to drop the packet, there is no reason to retain
+	 * the VL3 entry and we can delete it.
+	 */
+	if (is_vl3) {
+		action = OTLDA_DELETE;
+		mutex_exit(&entry->ote_lock);
+		goto done;
+	}
+
+	/*  Drop the first packet in entry */
 	if (mp != NULL) {
 		entry->ote_chead = mp->b_next;
 		mp->b_next = NULL;
@@ -1488,23 +1554,34 @@ overlay_target_lookup_drop(overlay_target_hdl_t *thdl, void *arg)
 			entry->ote_ctail = entry->ote_chead;
 		entry->ote_mbsize -= msgsize(mp);
 	}
+
 	if (entry->ote_chead != NULL) {
-		queue = B_TRUE;
+		action = OTLDA_QUEUE;
 		entry->ote_flags |= OVERLAY_ENTRY_F_PENDING;
 	} else {
 		entry->ote_flags &= ~OVERLAY_ENTRY_F_PENDING;
 	}
 	mutex_exit(&entry->ote_lock);
 
-	if (queue == B_TRUE)
+	if (action == OTLDA_QUEUE)
 		overlay_target_queue(entry);
 	freemsg(mp);
 
 done:
-	mutex_enter(&entry->ote_ott->ott_lock);
-	entry->ote_ott->ott_ocount--;
-	cv_signal(&entry->ote_ott->ott_cond);
-	mutex_exit(&entry->ote_ott->ott_lock);
+	mutex_enter(&ott->ott_lock);
+	ott->ott_ocount--;
+	if (action == OTLDA_DELETE) {
+		/* overlay_target_entry_dtor() will free the mblk chain */
+		sarc_remove(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+	}
+
+	if (is_vl3)
+		sarc_rele(ott->ott_u.ott_dyn.ott_l3dhash, entry);
+	else
+		sarc_rele(ott->ott_u.ott_dyn.ott_dhash, entry);
+
+	cv_signal(&ott->ott_cond);
+	mutex_exit(&ott->ott_lock);
 
 	return (0);
 }
diff --git a/usr/src/uts/common/io/overlay/sarc.c b/usr/src/uts/common/io/overlay/sarc.c
index 9320cae5c5..6745b8b922 100644
--- a/usr/src/uts/common/io/overlay/sarc.c
+++ b/usr/src/uts/common/io/overlay/sarc.c
@@ -488,7 +488,7 @@ sarc_rele(sarc_t *s, void *op)
 	ASSERT3U(lp->sal_refcnt, >, 0);
 
 	if (--lp->sal_refcnt == 0 && (lp->sal_flags & SARC_F_DEAD))
-		sarc_remove(s, op);
+		sarc_delete(s, op);
 }
 
 int
-- 
2.21.0

