From 9c952134c8be059116c0d7133074569937b4f4e5 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Thu, 8 Aug 2019 16:53:09 +0000
Subject: [PATCH] OS-7931 ::refstr would be useful OS-7932 ::ps -s could show
 service FMRIs OS-7934 ptree could show service FMRIs OS-3513 ps(1) should see
 more arguments

---
 .../mdb/common/modules/genunix/Makefile.files |   1 +
 .../cmd/mdb/common/modules/genunix/genunix.c  |  60 ++++-
 .../cmd/mdb/common/modules/genunix/refstr.c   |  43 ++++
 usr/src/cmd/ps/Makefile.com                   |   8 +-
 usr/src/cmd/ps/ps.c                           | 184 ++++++++-------
 usr/src/cmd/ps/ucbps.c                        | 216 ++++--------------
 usr/src/cmd/ptools/ptree/ptree.c              | 171 +++++++++++---
 usr/src/man/man1/ptree.1                      |   8 +-
 usr/src/man/man1b/ps.1b                       |   2 +-
 usr/src/uts/common/contract/process.c         |   8 +-
 usr/src/uts/common/fs/proc/prvnops.c          |   2 +-
 usr/src/uts/common/sys/procfs.h               |   4 +-
 12 files changed, 407 insertions(+), 300 deletions(-)
 create mode 100644 usr/src/cmd/mdb/common/modules/genunix/refstr.c

diff --git a/usr/src/cmd/mdb/common/modules/genunix/Makefile.files b/usr/src/cmd/mdb/common/modules/genunix/Makefile.files
index 44ed819316..1169f5536f 100644
--- a/usr/src/cmd/mdb/common/modules/genunix/Makefile.files
+++ b/usr/src/cmd/mdb/common/modules/genunix/Makefile.files
@@ -73,6 +73,7 @@ GENUNIX_SRCS =		\
 	pg.c		\
 	rctl.c		\
 	refhash.c	\
+	refstr.c	\
 	sobj.c		\
 	streams.c	\
 	sysevent.c	\
diff --git a/usr/src/cmd/mdb/common/modules/genunix/genunix.c b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
index 4c7c5ef5c1..b9c860ac74 100644
--- a/usr/src/cmd/mdb/common/modules/genunix/genunix.c
+++ b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
@@ -61,6 +61,7 @@
 #include <sys/panic.h>
 #include <regex.h>
 #include <sys/port_impl.h>
+#include <sys/contract/process_impl.h>
 
 #include "avl.h"
 #include "bio.h"
@@ -141,6 +142,7 @@ pstat2ch(uchar_t state)
 #define	PS_TASKS	0x8
 #define	PS_PROJECTS	0x10
 #define	PS_ZONES	0x20
+#define	PS_SERVICES	0x40
 
 static int
 ps_threadprint(uintptr_t addr, const void *data, void *private)
@@ -270,6 +272,7 @@ typedef struct mdb_ps_proc {
 	struct sess	*p_sessp;
 	struct task	*p_task;
 	struct zone	*p_zone;
+	struct cont_process *p_ct_process;
 	pid_t		p_ppid;
 	uint_t		p_flag;
 	struct {
@@ -278,6 +281,12 @@ typedef struct mdb_ps_proc {
 	} p_user;
 } mdb_ps_proc_t;
 
+/*
+ * A reasonable enough limit. Note that we purposefully let this column over-run
+ * if needed.
+ */
+#define	FMRI_LEN (128)
+
 int
 ps(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 {
@@ -289,6 +298,8 @@ ps(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	task_t tk;
 	kproject_t pj;
 	zone_t zn;
+	struct cont_process cp;
+	char fmri[FMRI_LEN] = "";
 
 	if (!(flags & DCMD_ADDRSPEC)) {
 		if (mdb_walk_dcmd("proc", "ps", argc, argv) == -1) {
@@ -301,6 +312,7 @@ ps(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	if (mdb_getopts(argc, argv,
 	    'f', MDB_OPT_SETBITS, PS_PSARGS, &prt_flags,
 	    'l', MDB_OPT_SETBITS, PS_PRTLWPS, &prt_flags,
+	    's', MDB_OPT_SETBITS, PS_SERVICES, &prt_flags,
 	    'T', MDB_OPT_SETBITS, PS_TASKS, &prt_flags,
 	    'P', MDB_OPT_SETBITS, PS_PROJECTS, &prt_flags,
 	    'z', MDB_OPT_SETBITS, PS_ZONES, &prt_flags,
@@ -308,15 +320,17 @@ ps(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 		return (DCMD_USAGE);
 
 	if (DCMD_HDRSPEC(flags)) {
-		mdb_printf("%<u>%1s %6s %6s %6s %6s ",
+		mdb_printf("%<u>%-1s %-6s %-6s %-6s %-6s ",
 		    "S", "PID", "PPID", "PGID", "SID");
 		if (prt_flags & PS_TASKS)
-			mdb_printf("%5s ", "TASK");
+			mdb_printf("%-5s ", "TASK");
 		if (prt_flags & PS_PROJECTS)
-			mdb_printf("%5s ", "PROJ");
+			mdb_printf("%-5s ", "PROJ");
 		if (prt_flags & PS_ZONES)
-			mdb_printf("%5s ", "ZONE");
-		mdb_printf("%6s %10s %?s %s%</u>\n",
+			mdb_printf("%-5s ", "ZONE");
+		if (prt_flags & PS_SERVICES)
+			mdb_printf("%-40s ", "SERVICE");
+		mdb_printf("%-6s %-10s %-?s %-s%</u>\n",
 		    "UID", "FLAGS", "ADDR", "NAME");
 	}
 
@@ -334,17 +348,38 @@ ps(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 		mdb_vread(&pj, sizeof (pj), (uintptr_t)tk.tk_proj);
 	if (prt_flags & PS_ZONES)
 		mdb_vread(&zn, sizeof (zn), (uintptr_t)pr.p_zone);
+	if ((prt_flags & PS_SERVICES) && pr.p_ct_process != NULL) {
+		mdb_vread(&cp, sizeof (cp), (uintptr_t)pr.p_ct_process);
+
+		if (mdb_read_refstr((uintptr_t)cp.conp_svc_fmri, fmri,
+		    sizeof (fmri)) <= 0)
+			(void) strlcpy(fmri, "?", sizeof (fmri));
+
+		if (strncmp(fmri, "svc:/", strlen("svc:/")) == 0) {
+			char *i = fmri;
+			char *j = fmri + strlen("svc:/");
+			for (; *j != '\0'; i++, j++) {
+				if (strcmp(j, ":default") == 0)
+					break;
+				*i = *j;
+			}
 
-	mdb_printf("%c %6d %6d %6d %6d ",
+			*i = '\0';
+		}
+	}
+
+	mdb_printf("%-c %-6d %-6d %-6d %-6d ",
 	    pstat2ch(pr.p_stat), pid.pid_id, pr.p_ppid, pgid.pid_id,
 	    sid.pid_id);
 	if (prt_flags & PS_TASKS)
-		mdb_printf("%5d ", tk.tk_tkid);
+		mdb_printf("%-5d ", tk.tk_tkid);
 	if (prt_flags & PS_PROJECTS)
-		mdb_printf("%5d ", pj.kpj_id);
+		mdb_printf("%-5d ", pj.kpj_id);
 	if (prt_flags & PS_ZONES)
-		mdb_printf("%5d ", zn.zone_id);
-	mdb_printf("%6d 0x%08x %0?p %s\n",
+		mdb_printf("%-5d ", zn.zone_id);
+	if (prt_flags & PS_SERVICES)
+		mdb_printf("%-40s ", fmri);
+	mdb_printf("%-6d 0x%08x %0?p %-s\n",
 	    cred.cr_uid, pr.p_flag, addr,
 	    (prt_flags & PS_PSARGS) ? pr.p_user.u_psargs : pr.p_user.u_comm);
 
@@ -363,6 +398,7 @@ ps_help(void)
 	    "    -l\tDisplay LWPs\n"
 	    "    -T\tDisplay tasks\n"
 	    "    -P\tDisplay projects\n"
+	    "    -s\tDisplay SMF FMRI\n"
 	    "    -z\tDisplay zones\n"
 	    "    -t\tDisplay threads\n\n");
 
@@ -386,6 +422,7 @@ ps_help(void)
 	mdb_printf("TASK\tThe task id of the process.\n");
 	mdb_printf("PROJ\tThe project id of the process.\n");
 	mdb_printf("ZONE\tThe zone id of the process.\n");
+	mdb_printf("SERVICE The SMF service FMRI of the process.\n");
 	mdb_printf("UID\tThe user id of the process.\n");
 	mdb_printf("FLAGS\tThe process flags (see ::pflags).\n");
 	mdb_printf("ADDR\tThe kernel address of the proc_t structure of the "
@@ -4053,6 +4090,8 @@ time_help(void)
 	    "  -x   report times in hexadecimal\n");
 }
 
+extern int cmd_refstr(uintptr_t, uint_t, int, const mdb_arg_t *);
+
 static const mdb_dcmd_t dcmds[] = {
 
 	/* from genunix.c */
@@ -4083,6 +4122,7 @@ static const mdb_dcmd_t dcmds[] = {
 	{ "pgrep", "[-x] [-n | -o] pattern",
 		"pattern match against all processes", pgrep },
 	{ "ptree", NULL, "print process tree", ptree },
+	{ "refstr", NULL, "print string from a refstr_t", cmd_refstr, NULL },
 	{ "sysevent", "?[-sv]", "print sysevent pending or sent queue",
 		sysevent},
 	{ "sysevent_channel", "?", "print sysevent channel database",
diff --git a/usr/src/cmd/mdb/common/modules/genunix/refstr.c b/usr/src/cmd/mdb/common/modules/genunix/refstr.c
new file mode 100644
index 0000000000..5b5fcec14c
--- /dev/null
+++ b/usr/src/cmd/mdb/common/modules/genunix/refstr.c
@@ -0,0 +1,43 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2019 Joyent, Inc.
+ */
+
+#include <mdb/mdb_modapi.h>
+#include <mdb/mdb_ks.h>
+#include <sys/refstr.h>
+
+#define	REFSTR_LEN (1024)
+
+int
+cmd_refstr(uintptr_t addr, uint_t flags __unused,
+    int argc, const mdb_arg_t *argv)
+{
+	if (!(flags & DCMD_ADDRSPEC)) {
+		mdb_warn("address is required\n");
+		return (DCMD_ERR);
+	}
+
+	if (mdb_getopts(argc, argv, NULL) != argc)
+		return (DCMD_USAGE);
+
+	char *buf = mdb_alloc(REFSTR_LEN, UM_SLEEP | UM_GC);
+
+	if (mdb_read_refstr(addr, buf, REFSTR_LEN) < 0) {
+		mdb_warn("couldn't read refstr from %p", addr);
+		return (DCMD_ERR);
+	}
+
+	mdb_printf("%s\n", buf);
+	return (DCMD_OK);
+}
diff --git a/usr/src/cmd/ps/Makefile.com b/usr/src/cmd/ps/Makefile.com
index d9209ba95a..eaab1f7fca 100644
--- a/usr/src/cmd/ps/Makefile.com
+++ b/usr/src/cmd/ps/Makefile.com
@@ -22,7 +22,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
-# Copyright (c) 2018, Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
+#
 
 PROG=	ps
 
@@ -32,6 +33,8 @@ SRCS=	$(OBJS:%.o=../%.c)
 
 include ../../Makefile.cmd
 
+CSTD = $(CSTD_GNU99)
+
 CFLAGS	+= $(CCVERBOSE)
 LDLIBS += -lproject
 
@@ -49,6 +52,3 @@ $(PROG): $(OBJS)
 
 clean:
 	$(RM) $(OBJS)
-
-lint:
-	$(LINT.c) $(SRCS) $(LDLIBS)
diff --git a/usr/src/cmd/ps/ps.c b/usr/src/cmd/ps/ps.c
index 6a01543b00..b7853173d4 100644
--- a/usr/src/cmd/ps/ps.c
+++ b/usr/src/cmd/ps/ps.c
@@ -27,7 +27,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -64,6 +64,8 @@
 #include <sys/pset.h>
 #include <project.h>
 #include <zone.h>
+#include <assert.h>
+#include <stdbool.h>
 
 #define	min(a, b)	((a) > (b) ? (b) : (a))
 #define	max(a, b)	((a) < (b) ? (b) : (a))
@@ -337,6 +339,10 @@ static	int	pidcmp(const void *p1, const void *p2);
 extern	int	ucbmain(int, char **);
 static	int	stdmain(int, char **);
 
+/* also used by ucbps.c */
+void get_psargs(bool, psinfo_t *, char *, size_t);
+void print_psargs(char *, int);
+
 int
 main(int argc, char **argv)
 {
@@ -1370,14 +1376,12 @@ prfind(int found, psinfo_t *psinfo, char **tpp)
 static void
 prcom(psinfo_t *psinfo, char *ttyp)
 {
-	char	*cp;
-	long	tm;
-	int	bytesleft;
-	int	wcnt, length;
-	wchar_t	wchar;
+	long tm;
+	int wcnt;
 	struct passwd *pwd;
-	int	zombie_lwp;
-	char	zonename[ZONENAME_MAX];
+	int zombie_lwp;
+	char zonename[ZONENAME_MAX];
+	char psargs[PRMAXARGVLEN] = ""; // Or + 1 ?
 
 	/*
 	 * If process is zombie, call zombie print routine and return.
@@ -1566,44 +1570,22 @@ prcom(psinfo_t *psinfo, char *ttyp)
 		if (psinfo->pr_time.tv_nsec > 500000000)
 			tm++;
 	}
-	(void) printf(" %4ld:%.2ld", tm / 60, tm % 60);		/* [L]TIME */
+	(void) printf(" %4ld:%.2ld ", tm / 60, tm % 60);	/* [L]TIME */
 
 	if (zombie_lwp) {
-		(void) printf(" <defunct>\n");
+		(void) printf("<defunct>\n");
 		return;
 	}
 
 	if (!fflg) {						/* CMD */
 		wcnt = namencnt(psinfo->pr_fname, 16, 8);
-		(void) printf(" %.*s\n", wcnt, psinfo->pr_fname);
+		(void) printf("%.*s\n", wcnt, psinfo->pr_fname);
 		return;
 	}
 
-
-	/*
-	 * PRARGSZ == length of cmd arg string.
-	 */
-	psinfo->pr_psargs[PRARGSZ-1] = '\0';
-	bytesleft = PRARGSZ;
-	for (cp = psinfo->pr_psargs; *cp != '\0'; cp += length) {
-		length = mbtowc(&wchar, cp, MB_LEN_MAX);
-		if (length == 0)
-			break;
-		if (length < 0 || !iswprint(wchar)) {
-			if (length < 0)
-				length = 1;
-			if (bytesleft <= length) {
-				*cp = '\0';
-				break;
-			}
-			/* omit the unprintable character */
-			(void) memmove(cp, cp+length, bytesleft-length);
-			length = 0;
-		}
-		bytesleft -= length;
-	}
-	wcnt = namencnt(psinfo->pr_psargs, PRARGSZ, lflg ? 35 : PRARGSZ);
-	(void) printf(" %.*s\n", wcnt, psinfo->pr_psargs);
+	get_psargs(false, psinfo, psargs, sizeof (psargs));
+	print_psargs(psargs, 0);
+	printf("\n");
 }
 
 /*
@@ -1658,20 +1640,91 @@ print_time(time_t tim, int width)
 	(void) printf("%*s", width, buf);
 }
 
+void
+get_psargs(bool comm, psinfo_t *psinfo, char *buf, size_t bufsize)
+{
+	char *path = NULL;
+	ssize_t size = 0;
+	int fd;
+
+	assert(psinfo->pr_psargs[PRARGSZ - 1] == '\0');
+
+	if (asprintf(&path, "%s/%d/argv", procdir, (int)psinfo->pr_pid) != -1 &&
+	    (fd = open(path, O_RDONLY)) != -1) {
+		size = read(fd, buf, bufsize);
+		(void) close(fd);
+	}
+
+	free(path);
+
+	if (size <= 0) {
+		(void) strlcpy(buf, psinfo->pr_psargs, bufsize);
+	} else {
+		buf[bufsize - 1] = '\0';
+		for (char *cp = buf; cp - buf < size; cp++) {
+			if (*cp == '\0' && (cp - buf) + 1 < size)
+				*cp = ' ';
+		}
+	}
+
+	if (comm) {
+		char *c = strpbrk(buf, " \t\r\v\f\n");
+		*c = '\0';
+	}
+}
+
+void
+print_psargs(char *psargs, int width)
+{
+	int bytesleft;
+	int length;
+	int wcnt;
+	int slen;
+
+	slen = bytesleft = strlen(psargs);
+
+	// FIXME: check
+	for (char *cp = psargs; *cp != '\0'; cp += length) {
+		wchar_t	wchar;
+
+		length = mbtowc(&wchar, cp, MB_LEN_MAX);
+
+		if (length == 0)
+			break;
+
+		if (length < 0 || !iswprint(wchar)) {
+			if (length < 0)
+				length = 1;
+			if (bytesleft <= length) {
+				*cp = '\0';
+				break;
+			}
+			/* omit the unprintable character */
+			(void) memmove(cp, cp+length, bytesleft-length);
+			length = 0;
+		}
+		bytesleft -= length;
+	}
+
+	wcnt = namencnt(psargs, PRMAXARGVLEN, width);
+
+	if (width != 0) {
+		(void) printf("%-*.*s", width, wcnt, psargs);
+	} else {
+		(void) printf("%-.*s", wcnt, psargs);
+	}
+}
+
 static void
 print_field(psinfo_t *psinfo, struct field *f, const char *ttyp)
 {
+	char psargs[PRMAXARGVLEN] = ""; // Or + 1 ?
 	int width = f->width;
 	struct passwd *pwd;
 	struct group *grp;
 	time_t cputime;
-	int bytesleft;
 	int wcnt;
-	wchar_t	wchar;
-	char *cp;
-	int length;
 	ulong_t mask;
-	char c = '\0', *csave = NULL;
 	int zombie_lwp;
 
 	zombie_lwp = (Lflg && psinfo->pr_lwp.pr_sname == 'Z');
@@ -1924,12 +1977,11 @@ print_field(psinfo_t *psinfo, struct field *f, const char *ttyp)
 				(void) printf("%s", "<defunct>");
 			break;
 		}
-		csave = strpbrk(psinfo->pr_psargs, " \t\r\v\f\n");
-		if (csave) {
-			c = *csave;
-			*csave = '\0';
-		}
-		/* FALLTHROUGH */
+
+		get_psargs(true, psinfo, psargs, sizeof (psargs));
+		print_psargs(psargs, f->next != NULL ? width : 0);
+		break;
+
 	case F_ARGS:
 		/*
 		 * PRARGSZ == length of cmd arg string.
@@ -1938,38 +1990,11 @@ print_field(psinfo_t *psinfo, struct field *f, const char *ttyp)
 			(void) printf("%-*s", width, "<defunct>");
 			break;
 		}
-		psinfo->pr_psargs[PRARGSZ-1] = '\0';
-		bytesleft = PRARGSZ;
-		for (cp = psinfo->pr_psargs; *cp != '\0'; cp += length) {
-			length = mbtowc(&wchar, cp, MB_LEN_MAX);
-			if (length == 0)
-				break;
-			if (length < 0 || !iswprint(wchar)) {
-				if (length < 0)
-					length = 1;
-				if (bytesleft <= length) {
-					*cp = '\0';
-					break;
-				}
-				/* omit the unprintable character */
-				(void) memmove(cp, cp+length, bytesleft-length);
-				length = 0;
-			}
-			bytesleft -= length;
-		}
-		wcnt = namencnt(psinfo->pr_psargs, PRARGSZ, width);
-		/*
-		 * Print full width unless this is the last format.
-		 */
-		if (f->next != NULL)
-			(void) printf("%-*.*s", width, wcnt,
-			    psinfo->pr_psargs);
-		else
-			(void) printf("%-.*s", wcnt,
-			    psinfo->pr_psargs);
-		if (f->fname == F_COMM && csave)
-			*csave = c;
+
+		get_psargs(false, psinfo, psargs, sizeof (psargs));
+		print_psargs(psargs, f->next != NULL ? width : 0);
 		break;
+
 	case F_TASKID:
 		(void) printf("%*d", width, (int)psinfo->pr_taskid);
 		break;
@@ -2430,7 +2455,8 @@ namencnt(char *cmd, int csisize, int scrsize)
 			return (8); /* default to use for illegal chars */
 		if ((nscrsz = wcwidth(wchar)) <= 0)
 			return (8);
-		if (csiwcnt + ncsisz > csisize || scrwcnt + nscrsz > scrsize)
+		if (csiwcnt + ncsisz > csisize ||
+		    (scrsize && scrwcnt + nscrsz > scrsize))
 			break;
 		csiwcnt += ncsisz;
 		scrwcnt += nscrsz;
diff --git a/usr/src/cmd/ps/ucbps.c b/usr/src/cmd/ps/ucbps.c
index 3110e95313..ff96329bd3 100644
--- a/usr/src/cmd/ps/ucbps.c
+++ b/usr/src/cmd/ps/ucbps.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2012, Joyent, Inc.  All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -65,8 +65,10 @@
 #include <wctype.h>
 #include <stdarg.h>
 #include <sys/proc.h>
+#include <sys/procfs.h>
 #include <priv_utils.h>
 #include <zone.h>
+#include <stdbool.h>
 
 #define	NTTYS	2	/* max ttys that can be specified with the -t option */
 			/* only one tty can be specified with SunOS ps */
@@ -101,6 +103,7 @@ static	int	nflg;	/* Numerical output */
 static	int	pflg;	/* Specific process id passed as argument */
 static	int	Uflg;	/* Update private database, ups_data */
 static	int	errflg;
+static	int	wflag;
 
 static	char	*gettty();
 static	char	argbuf[ARGSIZ];
@@ -133,8 +136,7 @@ static	void	getarg(void);
 static	void	prtime(timestruc_t st);
 static	void	przom(psinfo_t *psinfo);
 static	int	num(char *);
-static	int	preadargs(int, psinfo_t *, char *);
-static	int	preadenvs(int, psinfo_t *, char *);
+static	int	preadenvs(int, psinfo_t *, char *, size_t);
 static	int	prcom(int, psinfo_t *, char *);
 static	int	namencnt(char *, int, int);
 static	int	pscompare(const void *, const void *);
@@ -142,12 +144,18 @@ static	char	*err_string(int);
 
 extern int	scrwidth(wchar_t);	/* header file? */
 
+/* from ps.c */
+void get_psargs(bool, psinfo_t *, char *, size_t);
+void print_psargs(char *, int);
+
 int
 ucbmain(int argc, char **argv)
 {
 	psinfo_t info;		/* process information structure from /proc */
-	char *psargs = NULL;	/* pointer to buffer for -w and -ww options */
-	char *svpsargs = NULL;
+	/*
+	 * This can also store env vars, so we bump up the size.
+	 */
+	char psargs[PRMAXARGVLEN * 2] = ""; // or +1 ?
 	struct psent *psent;
 	int entsize;
 	int nent;
@@ -236,11 +244,12 @@ ucbmain(int argc, char **argv)
 		case 'U':	/* update private database ups_data */
 			Uflg++;
 			break;
-		case 'w':	/* increase display width */
+		case 'w':
 			if (twidth < 132)
 				twidth = 132;
-			else	/* second w option */
+			if (wflag)
 				twidth = NCARGS;
+			wflag++;
 			break;
 		case 'v':	/* display virtual memory format */
 			vflg++;
@@ -375,12 +384,6 @@ ucbmain(int argc, char **argv)
 	twidth = twidth - strlen(hdr) + 6;
 	(void) printf("%s\n", hdr);
 
-	if (twidth > PRARGSZ && (psargs = malloc(twidth)) == NULL) {
-		(void) fprintf(stderr, "ps: no memory\n");
-		exit(1);
-	}
-	svpsargs = psargs;
-
 	/*
 	 * Determine which processes to print info about by searching
 	 * the /proc directory and looking at each process.
@@ -410,7 +413,7 @@ retry:
 		if ((psfd = open(psname, O_RDONLY)) == -1)
 			continue;
 		asfd = -1;
-		if (psargs != NULL || eflg) {
+		if (eflg) {
 
 			/* now we need the proc_owner privilege */
 			(void) __priv_bracket(PRIV_ON);
@@ -470,26 +473,20 @@ retry:
 		if (!found && !tflg && !aflg && info.pr_euid != my_uid)
 			goto closeit;
 
-		/*
-		 * Read the args for the -w and -ww cases
-		 */
-		if (asfd > 0) {
-			if ((psargs != NULL &&
-			    preadargs(asfd, &info, psargs) == -1) ||
-			    (eflg && preadenvs(asfd, &info, psargs) == -1)) {
-				int	saverr = errno;
+		get_psargs(false, &info, psargs, sizeof (psargs));
 
-				(void) close(asfd);
-				if (saverr == EAGAIN)
-					goto retry;
-				if (saverr != ENOENT)
-					(void) fprintf(stderr,
-					    "ps: read() on %s: %s\n",
-					    asname, err_string(saverr));
-				continue;
+		if (eflg && asfd > 0 &&
+		    preadenvs(asfd, &info, psargs, sizeof (psargs)) == -1) {
+			int saverr = errno;
+
+			(void) close(asfd);
+			if (saverr == EAGAIN)
+				goto retry;
+			if (saverr != ENOENT) {
+				(void) fprintf(stderr, "ps: read() on %s: %s\n",
+				    asname, err_string(saverr));
 			}
-		} else {
-			psargs = info.pr_psargs;
+			continue;
 		}
 
 		if (nent >= entsize) {
@@ -507,22 +504,17 @@ retry:
 			exit(1);
 		}
 		*psent[nent].psinfo = info;
-		if (psargs == NULL)
-			psent[nent].psargs = NULL;
-		else {
-			if ((psent[nent].psargs = malloc(strlen(psargs)+1))
-			    == NULL) {
-				(void) fprintf(stderr, "ps: no memory\n");
-				exit(1);
-			}
-			(void) strcpy(psent[nent].psargs, psargs);
+
+		if ((psent[nent].psargs = strndup(psargs, twidth)) == NULL) {
+			(void) fprintf(stderr, "ps: no memory\n");
+			exit(1);
 		}
+
 		psent[nent].found = found;
 		nent++;
 closeit:
 		if (asfd > 0)
 			(void) close(asfd);
-		psargs = svpsargs;
 	}
 
 	/* revert to non-privileged user */
@@ -552,101 +544,18 @@ usage()		/* print usage message and quit */
 	exit(1);
 }
 
-/*
- * Read the process arguments from the process.
- * This allows >PRARGSZ characters of arguments to be displayed but,
- * unlike pr_psargs[], the process may have changed them.
- */
-#define	NARG	100
-static int
-preadargs(int pfd, psinfo_t *psinfo, char *psargs)
-{
-	off_t argvoff = (off_t)psinfo->pr_argv;
-	size_t len;
-	char *psa = psargs;
-	int bsize = twidth;
-	int narg = NARG;
-	off_t argv[NARG];
-	off_t argoff;
-	off_t nextargoff;
-	int i;
-#ifdef _LP64
-	caddr32_t argv32[NARG];
-	int is32 = (psinfo->pr_dmodel != PR_MODEL_LP64);
-#endif
-
-	if (psinfo->pr_nlwp == 0 ||
-	    strcmp(psinfo->pr_lwp.pr_clname, "SYS") == 0)
-		goto out;
-
-	(void) memset(psa, 0, bsize--);
-	nextargoff = 0;
-	errno = EIO;
-	while (bsize > 0) {
-		if (narg == NARG) {
-			(void) memset(argv, 0, sizeof (argv));
-#ifdef _LP64
-			if (is32) {
-				if ((i = pread(pfd, argv32, sizeof (argv32),
-				    argvoff)) <= 0) {
-					if (i == 0 || errno == EIO)
-						break;
-					return (-1);
-				}
-				for (i = 0; i < NARG; i++)
-					argv[i] = argv32[i];
-			} else
-#endif
-				if ((i = pread(pfd, argv, sizeof (argv),
-				    argvoff)) <= 0) {
-					if (i == 0 || errno == EIO)
-						break;
-					return (-1);
-				}
-			narg = 0;
-		}
-		if ((argoff = argv[narg++]) == 0)
-			break;
-		if (argoff != nextargoff &&
-		    (i = pread(pfd, psa, bsize, argoff)) <= 0) {
-			if (i == 0 || errno == EIO)
-				break;
-			return (-1);
-		}
-		len = strlen(psa);
-		psa += len;
-		*psa++ = ' ';
-		bsize -= len + 1;
-		nextargoff = argoff + len + 1;
-#ifdef _LP64
-		argvoff += is32? sizeof (caddr32_t) : sizeof (caddr_t);
-#else
-		argvoff += sizeof (caddr_t);
-#endif
-	}
-	while (psa > psargs && isspace(*(psa-1)))
-		psa--;
-
-out:
-	*psa = '\0';
-	if (strlen(psinfo->pr_psargs) > strlen(psargs))
-		(void) strcpy(psargs, psinfo->pr_psargs);
-
-	return (0);
-}
-
 /*
  * Read environment variables from the process.
  * Append them to psargs if there is room.
  */
+#define	NARG	100
 static int
-preadenvs(int pfd, psinfo_t *psinfo, char *psargs)
+preadenvs(int pfd, psinfo_t *psinfo, char *psargs, size_t bufsize)
 {
 	off_t envpoff = (off_t)psinfo->pr_envp;
 	int len;
 	char *psa;
-	char *psainit;
-	int bsize;
+	int remaining;
 	int nenv = NARG;
 	off_t envp[NARG];
 	off_t envoff;
@@ -657,18 +566,18 @@ preadenvs(int pfd, psinfo_t *psinfo, char *psargs)
 	int is32 = (psinfo->pr_dmodel != PR_MODEL_LP64);
 #endif
 
-	psainit = psa = (psargs != NULL)? psargs : psinfo->pr_psargs;
+	psa = psargs;
 	len = strlen(psa);
 	psa += len;
-	bsize = twidth - len - 1;
+	remaining = bufsize - len - 1;
 
-	if (bsize <= 0 || psinfo->pr_nlwp == 0 ||
+	if (remaining <= 0 || psinfo->pr_nlwp == 0 ||
 	    strcmp(psinfo->pr_lwp.pr_clname, "SYS") == 0)
 		return (0);
 
 	nextenvoff = 0;
 	errno = EIO;
-	while (bsize > 0) {
+	while (remaining > 0) {
 		if (nenv == NARG) {
 			(void) memset(envp, 0, sizeof (envp));
 #ifdef _LP64
@@ -694,7 +603,7 @@ preadenvs(int pfd, psinfo_t *psinfo, char *psargs)
 		if ((envoff = envp[nenv++]) == 0)
 			break;
 		if (envoff != nextenvoff &&
-		    (i = pread(pfd, psa+1, bsize, envoff)) <= 0) {
+		    (i = pread(pfd, psa+1, remaining, envoff)) <= 0) {
 			if (i == 0 || errno == EIO)
 				break;
 			return (-1);
@@ -702,7 +611,7 @@ preadenvs(int pfd, psinfo_t *psinfo, char *psargs)
 		*psa++ = ' ';
 		len = strlen(psa);
 		psa += len;
-		bsize -= len + 1;
+		remaining -= len + 1;
 		nextenvoff = envoff + len + 1;
 #ifdef _LP64
 		envpoff += is32? sizeof (caddr32_t) : sizeof (caddr_t);
@@ -710,7 +619,7 @@ preadenvs(int pfd, psinfo_t *psinfo, char *psargs)
 		envpoff += sizeof (caddr_t);
 #endif
 	}
-	while (psa > psainit && isspace(*(psa-1)))
+	while (psa > psargs && isspace(*(psa-1)))
 		psa--;
 	*psa = '\0';
 
@@ -842,12 +751,9 @@ prtpct(ushort_t pct)
 static int
 prcom(int found, psinfo_t *psinfo, char *psargs)
 {
-	char	*cp;
 	char	*tp;
-	char	*psa;
 	long	tm;
-	int	i, wcnt, length;
-	wchar_t	wchar;
+	int	i, wcnt;
 	struct tty *ttyp;
 
 	/*
@@ -999,37 +905,9 @@ prcom(int found, psinfo_t *psinfo, char *psargs)
 		(void) printf(" %.*s", wcnt, psinfo->pr_fname);
 		return (1);
 	}
-	/*
-	 * PRARGSZ == length of cmd arg string.
-	 */
-	if (psargs == NULL) {
-		psa = &psinfo->pr_psargs[0];
-		i = PRARGSZ;
-		tp = &psinfo->pr_psargs[PRARGSZ];
-	} else {
-		psa = psargs;
-		i = strlen(psargs);
-		tp = psa + i;
-	}
 
-	for (cp = psa; cp < tp; /* empty */) {
-		if (*cp == 0)
-			break;
-		length = mbtowc(&wchar, cp, MB_LEN_MAX);
-		if (length < 0 || !iswprint(wchar)) {
-			(void) printf(" [ %.16s ]", psinfo->pr_fname);
-			return (1);
-		}
-		cp += length;
-	}
-	wcnt = namencnt(psa, i, maxlen);
-#if 0
-	/* dumps core on really long strings */
-	(void) printf(" %.*s", wcnt, psa);
-#else
-	(void) putchar(' ');
-	(void) fwrite(psa, 1, wcnt, stdout);
-#endif
+	printf(" ");
+	print_psargs(psargs, wflag < 2 ? maxlen : 0);
 	return (1);
 }
 
diff --git a/usr/src/cmd/ptools/ptree/ptree.c b/usr/src/cmd/ptools/ptree/ptree.c
index 92a65e2f44..fbddeb5dd1 100644
--- a/usr/src/cmd/ptools/ptree/ptree.c
+++ b/usr/src/cmd/ptools/ptree/ptree.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -47,6 +47,8 @@
 #include <sys/ctfs.h>
 #include <libcontract_priv.h>
 #include <sys/stat.h>
+#include <stdbool.h>
+
 #include "ptools_common.h"
 
 #define	FAKEDPID0(p)	(p->pid == 0 && p->psargs[0] == '\0')
@@ -61,6 +63,7 @@ typedef struct ps {
 	pid_t	sid;
 	zoneid_t zoneid;
 	ctid_t	ctid;
+	char *svc_fmri;
 	timestruc_t start;
 	char	psargs[PRARGSZ];
 	struct ps *pp;		/* parent */
@@ -81,16 +84,21 @@ static	char	*command;
 
 static	int	aflag = 0;
 static	int	cflag = 0;
+static	int	sflag = 0;
 static	int	zflag = 0;
 static	zoneid_t zoneid;
+static  const char *svc_fmri;
 static	int	columns = 80;
 
-static void markprocs(ps_t *p);
-static int printone(ps_t *p, int level);
+static bool match_proc(ps_t *);
+static void markprocs(ps_t *);
+static int printone(ps_t *, int);
 static void insertchild(ps_t *, ps_t *);
-static void prsort(ps_t *p);
-static void printsubtree(ps_t *p, int level);
-static zoneid_t getzone(char *arg);
+static void prsort(ps_t *);
+static void printsubtree(ps_t *, int);
+static void p_get_svc_fmri(ps_t *, ct_stathdl_t);
+static char *stripsvc(const char *);
+static zoneid_t getzone(const char *);
 static ps_t *fakepid0(void);
 
 int
@@ -118,7 +126,7 @@ main(int argc, char **argv)
 		command++;
 
 	/* options */
-	while ((opt = getopt(argc, argv, "acz:")) != EOF) {
+	while ((opt = getopt(argc, argv, "acs:z:")) != EOF) {
 		switch (opt) {
 		case 'a':		/* include children of process 0 */
 			aflag = 1;
@@ -126,6 +134,10 @@ main(int argc, char **argv)
 		case 'c':		/* display contract ownership */
 			aflag = cflag = 1;
 			break;
+		case 's':
+			sflag = 1;
+			svc_fmri = stripsvc(optarg);
+			break;
 		case 'z':		/* only processes in given zone */
 			zflag = 1;
 			zoneid = getzone(optarg);
@@ -141,7 +153,7 @@ main(int argc, char **argv)
 
 	if (errflg) {
 		(void) fprintf(stderr,
-		    "usage:\t%s [-ac] [-z zone] [ {pid|user} ... ]\n",
+		    "usage:\t%s [-ac] [-s svc] [-z zone] [ {pid|user} ... ]\n",
 		    command);
 		(void) fprintf(stderr,
 		    "  (show process trees)\n");
@@ -150,7 +162,9 @@ main(int argc, char **argv)
 		(void) fprintf(stderr,
 		    "  -a : include children of process 0\n");
 		(void) fprintf(stderr,
-		    "  -c : show contract ownership\n");
+		    "  -c : show contracts\n");
+		(void) fprintf(stderr,
+		    "  -s : print only processes with given service FMRI\n");
 		(void) fprintf(stderr,
 		    "  -z : print only processes in given zone\n");
 		return (2);
@@ -224,8 +238,8 @@ retry:
 				return (1);
 			}
 		}
-		if ((p = malloc(sizeof (ps_t))) == NULL) {
-			perror("malloc()");
+		if ((p = calloc(1, sizeof (ps_t))) == NULL) {
+			perror("calloc()");
 			return (1);
 		}
 		ps[nps++] = p;
@@ -252,6 +266,10 @@ retry:
 		p->pp = NULL;
 		p->sp = NULL;
 		p->cp = NULL;
+
+		if (sflag)
+			p_get_svc_fmri(p, NULL);
+
 		if (p->pid == p->ppid)
 			proc0 = p;
 		if (p->pid == 1)
@@ -338,8 +356,7 @@ retry:
 					    p->done != 1 && p->pid != 0;
 					    p = p->pp)
 						if ((p->ppid != 0 || aflag) &&
-						    (!zflag ||
-						    p->zoneid == zoneid))
+						    match_proc(p))
 							p->done = 1;
 				if (uid == (uid_t)-1)
 					break;
@@ -371,8 +388,9 @@ printone(ps_t *p, int level)
 			    PIDWIDTH, (int)p->pid, n, p->psargs);
 		} else {
 			assert(cflag != 0);
-			(void) printf("%*.*s[process contract %d]\n",
-			    indent, indent, " ", (int)p->ctid);
+			(void) printf("%*.*s[process contract %d: %s]\n",
+			    indent, indent, " ", (int)p->ctid,
+			    p->svc_fmri == NULL ? "?" : p->svc_fmri);
 		}
 		return (1);
 	}
@@ -401,11 +419,50 @@ insertchild(ps_t *pp, ps_t *cp)
 	*here = cp;
 }
 
+static ct_stathdl_t
+ct_status_open(ctid_t ctid, struct stat64 *stp)
+{
+	ct_stathdl_t hdl;
+	int fd;
+
+	if ((fd = contract_open(ctid, "process", "status", O_RDONLY)) == -1)
+		return (NULL);
+
+	if (fstat64(fd, stp) == -1 || ct_status_read(fd, CTD_FIXED, &hdl)) {
+		(void) close(fd);
+		return (NULL);
+	}
+
+	(void) close(fd);
+
+	return (hdl);
+}
+
+/*
+ * strdup() failure is OK - better to report something than fail totally.
+ */
+static void
+p_get_svc_fmri(ps_t *p, ct_stathdl_t inhdl)
+{
+	ct_stathdl_t hdl = inhdl;
+	struct stat64 st;
+	char *fmri;
+
+	if (hdl == NULL && (hdl = ct_status_open(p->ctid, &st)) == NULL)
+		return;
+
+	if (ct_pr_status_get_svc_fmri(hdl, &fmri) == 0)
+		p->svc_fmri = strdup(fmri);
+
+	if (inhdl == NULL)
+		ct_status_free(hdl);
+}
+
 static void
 ctsort(ctid_t ctid, ps_t *p)
 {
 	ps_t *pp;
-	int fd, n;
+	int n;
 	ct_stathdl_t hdl;
 	struct stat64 st;
 
@@ -415,13 +472,8 @@ ctsort(ctid_t ctid, ps_t *p)
 			return;
 		}
 
-	if ((fd = contract_open(ctid, "process", "status", O_RDONLY)) == -1)
-		return;
-	if (fstat64(fd, &st) == -1 || ct_status_read(fd, CTD_COMMON, &hdl)) {
-		(void) close(fd);
+	if ((hdl = ct_status_open(ctid, &st)) == NULL)
 		return;
-	}
-	(void) close(fd);
 
 	if (nctps >= ctsize) {
 		if ((ctsize *= 2) == 0)
@@ -440,10 +492,14 @@ ctsort(ctid_t ctid, ps_t *p)
 
 	pp->pid = -1;
 	pp->ctid = ctid;
+
+	p_get_svc_fmri(pp, hdl);
+
 	pp->start.tv_sec = st.st_ctime;
 	insertchild(pp, p);
 
 	pp->zoneid = ct_status_get_zoneid(hdl);
+
 	/*
 	 * In a zlogin <zonename>, the contract belongs to the
 	 * global zone and the shell opened belongs to <zonename>.
@@ -513,11 +569,51 @@ printsubtree(ps_t *p, int level)
 		printsubtree(p, level);
 }
 
+/*
+ * For the service matching, we don't go the whole hog like svcs(1), but we will
+ * strip svc:/ and a :default prefix, and allow a match of the final part of the
+ * service such as "name-service-cache".
+ */
+static bool
+match_proc(ps_t *p)
+{
+	const char *cp;
+	char *psvc;
+
+	if (zflag && p->zoneid != zoneid)
+		return (false);
+
+	if (!sflag)
+		return (true);
+
+	if (p->svc_fmri == NULL)
+		return (false);
+
+	if (strcmp(p->svc_fmri, svc_fmri) == 0)
+		return (true);
+
+	psvc = stripsvc(p->svc_fmri);
+
+	if (strcmp(psvc, svc_fmri) == 0) {
+		free(psvc);
+		return (true);
+	}
+
+	if ((cp = strrchr(psvc, '/')) != NULL &&
+	    strcmp(cp + 1, svc_fmri) == 0) {
+		free(psvc);
+		return (true);
+	}
+
+	return (false);
+}
+
 static void
 markprocs(ps_t *p)
 {
-	if (!zflag || p->zoneid == zoneid)
+	if (match_proc(p))
 		p->done = 1;
+
 	for (p = p->cp; p != NULL; p = p->sp)
 		markprocs(p);
 }
@@ -532,8 +628,8 @@ fakepid0(void)
 	ps_t *p0, *p;
 	int n;
 
-	if ((p0 = malloc(sizeof (ps_t))) == NULL) {
-		perror("malloc()");
+	if ((p0 = calloc(1, sizeof (ps_t))) == NULL) {
+		perror("calloc()");
 		exit(1);
 	}
 	(void) memset(p0, '\0', sizeof (ps_t));
@@ -559,7 +655,7 @@ fakepid0(void)
 
 /* convert string containing zone name or id to a numeric id */
 static zoneid_t
-getzone(char *arg)
+getzone(const char *arg)
 {
 	zoneid_t zoneid;
 
@@ -569,3 +665,26 @@ getzone(char *arg)
 	}
 	return (zoneid);
 }
+
+/* svc:/...:default -> ... */
+static char *
+stripsvc(const char *arg)
+{
+	const char *p = arg;
+	char *ret;
+	char *cp;
+
+	if (strncmp(p, "svc:/", strlen("svc:/")) == 0)
+		p += strlen("svc:/");
+
+	if ((ret = strdup(p)) == NULL) {
+		perror("strdup()");
+		exit(1);
+	}
+
+	if ((cp = strrchr(ret, ':')) != NULL &&
+	    strcmp(cp, ":default") == 0)
+		*cp = '\0';
+
+	return (ret);
+}
diff --git a/usr/src/man/man1/ptree.1 b/usr/src/man/man1/ptree.1
index a8de77c0bd..70ffe77673 100644
--- a/usr/src/man/man1/ptree.1
+++ b/usr/src/man/man1/ptree.1
@@ -1,9 +1,10 @@
 '\" te
 .\" Copyright (c) 2005, Sun Microsystems, Inc. All Rights Reserved.
+.\" Copyright 2019 Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PTREE 1 "Oct 11, 2005"
+.TH PTREE 1 "Aug 7 2019"
 .SH NAME
 ptree \- print process trees
 .SH SYNOPSIS
@@ -38,8 +39,9 @@ All. Print all processes, including children of process 0.
 \fB\fB-c\fR\fR
 .ad
 .RS 11n
-Contracts. Print process contract memberships in addition to parent-child
-relationships. See \fBprocess\fR(4). This option implies the \fB-a\fR option.
+Contracts. Print process contract memberships and their associated SMF FMRIs,
+in addition to parent-child relationships. See \fBprocess\fR(4).
+This option implies the \fB-a\fR option.
 .RE
 
 .sp
diff --git a/usr/src/man/man1b/ps.1b b/usr/src/man/man1b/ps.1b
index 5db8faf6f6..766539c752 100644
--- a/usr/src/man/man1b/ps.1b
+++ b/usr/src/man/man1b/ps.1b
@@ -206,7 +206,7 @@ fields \fBSIZE\fR, \fB%CPU\fR, \fB%MEM\fR, and \fBRSS\fR, described below.
 \fB\fB-w\fR\fR
 .ad
 .RS 11n
-Uses a wide output format, that is, 132 columns rather than 80. If the option
+Uses a wide output format, that is, FIXME 132 columns rather than 80. If the option
 letter is repeated, that is, \fB-ww\fR, this option uses arbitrarily wide
 output. This information is used to decide how much of long commands to print.
 \fBNote:\fR The wide output option can be viewed only by a superuser or the
diff --git a/usr/src/uts/common/contract/process.c b/usr/src/uts/common/contract/process.c
index e46cbd3abf..6e43bd7aef 100644
--- a/usr/src/uts/common/contract/process.c
+++ b/usr/src/uts/common/contract/process.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #include <sys/mutex.h>
@@ -737,13 +737,11 @@ contract_process_status(contract_t *ct, zone_t *zone, int detail, nvlist_t *nvl,
 	 * if we are in a local zone and svc_fmri was inherited from
 	 * the global zone, we provide fake svc_fmri and svc_ctid
 	 */
-	if (local_svc_zone_enter == 0||
+	if (local_svc_zone_enter == 0 ||
 	    zone->zone_uniqid == GLOBAL_ZONEUNIQID) {
 		if (detail > CTD_COMMON) {
 			VERIFY(nvlist_add_int32(nvl, CTPS_SVC_CTID,
 			    ctp->conp_svc_ctid) == 0);
-		}
-		if (detail == CTD_ALL) {
 			VERIFY(nvlist_add_string(nvl, CTPS_SVC_FMRI,
 			    refstr_value(ctp->conp_svc_fmri)) == 0);
 		}
@@ -751,8 +749,6 @@ contract_process_status(contract_t *ct, zone_t *zone, int detail, nvlist_t *nvl,
 		if (detail > CTD_COMMON) {
 			VERIFY(nvlist_add_int32(nvl, CTPS_SVC_CTID,
 			    local_svc_zone_enter) == 0);
-		}
-		if (detail == CTD_ALL) {
 			VERIFY(nvlist_add_string(nvl, CTPS_SVC_FMRI,
 			    CT_PR_SVC_FMRI_ZONE_ENTER) == 0);
 		}
diff --git a/usr/src/uts/common/fs/proc/prvnops.c b/usr/src/uts/common/fs/proc/prvnops.c
index 657cebf8c2..1c82cb83a5 100644
--- a/usr/src/uts/common/fs/proc/prvnops.c
+++ b/usr/src/uts/common/fs/proc/prvnops.c
@@ -100,7 +100,7 @@ struct prdirect {
 /*
  * Maximum length of the /proc/$$/argv file:
  */
-int prmaxargvlen = 4096;
+int prmaxargvlen = PRMAXARGVLEN;
 
 /*
  * Directory characteristics.
diff --git a/usr/src/uts/common/sys/procfs.h b/usr/src/uts/common/sys/procfs.h
index 99da92ab79..ad3bd54b15 100644
--- a/usr/src/uts/common/sys/procfs.h
+++ b/usr/src/uts/common/sys/procfs.h
@@ -271,10 +271,12 @@ typedef struct lwpsinfo {
 	int	pr_filler[4];	/* reserved for future use */
 } lwpsinfo_t;
 
+#define	PRARGSZ		80	/* number of chars of arguments */
+#define	PRMAXARGVLEN	4096	/* max len of /proc/%s/argv */
+
 /*
  * process ps(1) information file.  /proc/<pid>/psinfo
  */
-#define	PRARGSZ		80	/* number of chars of arguments */
 typedef struct psinfo {
 	int	pr_flag;	/* process flags (DEPRECATED; do not use) */
 	int	pr_nlwp;	/* number of active lwps in the process */
-- 
2.21.0

