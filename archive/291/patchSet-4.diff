commit 285b8c450e530196d8f4878e98b0a65a9d1716e4 (refs/changes/91/291/4)
Author: David Pacheco <dap@joyent.com>
Date:   2016-08-24T13:07:07-07:00 (3 years, 1 month ago)
    
    MORAY-352 fast client needs work

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..991e954
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+node_modules
+test/compat/node_modules
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..401f01a
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "deps/catest"]
+	path = deps/catest
+	url = https://github.com/joyent/catest
diff --git a/.npmignore b/.npmignore
new file mode 100644
index 0000000..9daeafb
--- /dev/null
+++ b/.npmignore
@@ -0,0 +1 @@
+test
diff --git a/CHANGES.md b/CHANGES.md
new file mode 100644
index 0000000..e22e7f8
--- /dev/null
+++ b/CHANGES.md
@@ -0,0 +1,51 @@
+# Fast Changelog
+
+## Not yet released
+
+This is a complete rewrite of the Fast client and server implementation.  Almost
+everything about the API has changed, including constructors, methods, and
+arguments.  The primary difference is that the new Fast client is generally only
+responsible for Fast-protocol-level concerns.  It does not do service discovery
+(via DNS), connection establishment, health monitoring, retries, or anything
+like that.  Callers are expected to use something like node-cueball for that.
+The server manages a little bit more of the TCP state than the client does
+(particularly as clients connect), but callers are still expected to manage the
+server socket itself.  To summarize: callers are expected to manage their own
+`net.Socket` (for clients) or `net.Server` (for servers), watching those objects
+for whatever events they're interested in and using those classes' methods for
+working with them.  You no longer treat the Fast client as a wrapper for a
+`net.Socket` or the Fast server as a wrapper for a `net.Server`.
+
+As a result of this change in design, the constructor arguments are pretty
+different.  Many methods are gone (e.g., client.connect(), client.close(),
+server.listen(), server.address(), and so on).  The interface is generally much
+simpler.
+
+To make methods more extensible and consistent with Joyent's Best Practices for
+Error Handling (see README), the major APIs (constructors, `client.rpc()`, and
+`server.rpc()`) have been changed to accept named arguments in a single `args`
+argument.
+
+Other concrete API differences include:
+
+* Clients that make RPC calls get back a proper Readable stream, rather than an
+  EventEmitter that emits `message`, `end`, and `error` events.  (The previous
+  implementation used the spirit of Node.js's object-mode streams, but predated
+  their maturity, and so implemented something similar but ad-hoc.) As a result
+  of this change, you cannot send `null` over the RPC channel, since object-mode
+  streams use `null` to denote end-of-stream.  Of course, you can wrap `null` in
+  an object.
+* `Client.rpc()` now takes named arguments as mentioned above.
+* `Server.rpc()` is now called `Server.registerRpcMethod()` and takes named
+  arguments as mentioned above.
+
+Other notable differences include:
+
+* This implementation fixes a large number of protocol bugs, including cases
+  where the protocol version was ignored in incoming messages and unsupported
+  kinds of messages were treated as new RPC requests.
+* This implementation does not support aborting RPC requests because the
+  previous mechanism for this was somewhat dangerous.  (See README.)
+* The client DTrace probes have been revised.  Server DTrace probes have been
+  added.  (See README.)
+* Kang entry points have been added for observability.  (See README.)
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000..623c8e9
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,96 @@
+# Contributing to node-fast2
+
+This repository uses [cr.joyent.us](https://cr.joyent.us) (Gerrit) for new
+changes.  Anyone can submit changes.  To get started, see the [cr.joyent.us user
+guide](https://github.com/joyent/joyent-gerrit/blob/master/docs/user/README.md).
+This repo does not use GitHub pull requests.
+
+See the [Joyent Engineering
+Guidelines](https://github.com/joyent/eng/blob/master/docs/index.md) for general
+best practices expected in this repository.
+
+Contributions should be "make prepush" clean.  The "prepush" target runs the
+"check" target, which requires these separate tools:
+
+* https://github.com/davepacheco/jsstyle
+* https://github.com/davepacheco/javascriptlint
+
+If you're changing something non-trivial or user-facing, you may want to submit
+an issue first.  Because this protocol is widely deployed, we generally view
+backwards compatibility (both on the wire and in the API) as a constraint on all
+changes.
+
+
+## Testing
+
+Automated tests can be run using `make test`.  This test suite should be pretty
+exhaustive for both basic functionality and edge cases.
+
+You can use the `fastserve` and `fastcall` programs for ad-hoc testing.
+
+
+## Backwards compatibility with older versions of Fast
+
+As mentioned in the README, there was a previous implementation of this
+protocol.  The client and server APIs are different in this module than the
+previous implementation.  However, the client here is compatible with a server
+built on the previous implementation, and the server here is compatible with a
+client built on the previous implementation.
+
+There are several reasons we might want to use the old implementation in this
+module:
+
+* done: basic functionality testing this client against the old server
+* not implemented: basic functionality testing this server against the old
+  client
+* not implemented: for performance testing either the old client or server
+
+This is made significantly more complicated by the fact that the old
+implementation only works with Node 0.10, while this implementation is expected
+to run on Node 0.12 and later.
+
+**The easiest way to test compatibility is to set `FAST\_COMPAT\_NODEDIR` in
+your environment and run `make test-compat`**:
+
+    export FAST_COMPAT_NODEDIR=/path/to/node-v0.10-directory
+    make test-compat
+
+This will do the following:
+
+* sanity-check the `node` in `$FAST_COMPAT_NODEDIR/bin/node`
+* use the `npm` in that directory to install the _old_ fast module into
+  `test/compat/node_modules/fast`
+* run the compatibility tests in `test/compat`.
+
+These could be incorporated into "make prepush", but developers would have to
+have `FAST_COMPAT_NODEDIR` set to a directory containing 0.10.
+
+
+## Performance testing
+
+The `fastbench` command can be used to make RPC requests to a remote server
+for a fixed number of requests, for a given period of time, or until the program
+itself is killed.  The tool reports very coarse metrics about client-side
+request performance:
+
+    $ fastbench -c 10 sync 127.0.0.1 8123
+    pid 17354: running workload "sync" until killed (type CTRL-C for results)
+    established connection to 127.0.0.1:8123
+    ^Cstopping due to SIGINT
+    -----------------------------------
+    total runtime:             4.233982s
+    total requests completed:  6063 (6073 issued)
+    total unexpected errors:   0
+    error rate:                0.00%
+    maximum concurrency:       10
+    request throughput:        1431 requests per second
+    estimated average latency: 6983 us
+
+The server must support the "fastbench" RPC method, which basically echoes its
+arguments and optionally sleeps.  The `fastserve` command implements this RPC,
+as does the legacy server in ./test/compat that's described above.
+
+This should be considered only a rough estimate of performance under very
+particular conditions.  Proper performance analysis requires not just careful
+collection of data, but also understanding exactly what the system is doing and
+where the bottleneck is to make sure you're looking at correct numbers.
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..5b02e67
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,20 @@
+Copyright (c) 2013 Mark Cavage, All rights reserved.
+Copyright (c) 2016, Joyent, Inc. All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..98e361a
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,50 @@
+#
+# Copyright (c) 2016, Joyent, Inc. All rights reserved.
+#
+# Makefile: top-level Makefile
+#
+# This Makefile contains only repo-specific logic and uses included makefiles
+# to supply common targets (javascriptlint, jsstyle, restdown, etc.), which are
+# used by other repos as well.
+#
+
+#
+# Tools
+#
+CATEST		 = deps/catest/catest
+NPM		 = npm
+NODE		 = node
+
+#
+# Files
+#
+JSON_FILES	 = package.json
+BASH_FILES	 = $(wildcard test/*.sh)
+JS_FILES	:= bin/fastbench \
+		   bin/fastcall \
+		   bin/fastserve \
+		   $(shell find lib test -name '*.js' | \
+			grep -v ^test/compat/node_modules)
+CATEST_FILES	 = $(shell find test -name 'tst.*.js' | \
+			grep -v ^test/compat/node_modules)
+JSL_FILES_NODE	 = $(JS_FILES)
+JSSTYLE_FILES	 = $(JS_FILES)
+JSL_CONF_NODE	 = tools/jsl.node.conf
+
+include ./test/compat/Makefile.compat.defs
+
+.PHONY: all
+all:
+	$(NPM) install
+CLEAN_FILES += node_modules
+
+.PHONY: test
+test: | $(CATEST)
+	$(CATEST) $(CATEST_FILES)
+	@echo Note: Compatibility tests need to be run manually with \
+	    \"make test-compat\".
+
+$(CATEST): deps/catest/.git
+
+include ./Makefile.targ
+include ./test/compat/Makefile.compat.targ
diff --git a/Makefile.targ b/Makefile.targ
new file mode 100644
index 0000000..ea19000
--- /dev/null
+++ b/Makefile.targ
@@ -0,0 +1,317 @@
+# -*- mode: makefile -*-
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2014, Joyent, Inc.
+#
+
+#
+# Makefile.targ: common targets.
+#
+# NOTE: This makefile comes from the "eng" repo. It's designed to be dropped
+# into other repos as-is without requiring any modifications. If you find
+# yourself changing this file, you should instead update the original copy in
+# eng.git and then update your repo to use the new version.
+#
+# This Makefile defines several useful targets and rules. You can use it by
+# including it from a Makefile that specifies some of the variables below.
+#
+# Targets defined in this Makefile:
+#
+#	check	Checks JavaScript files for lint and style
+#		Checks bash scripts for syntax
+#		Checks SMF manifests for validity against the SMF DTD
+#
+#	clean	Removes built files
+#
+#	docs	Builds restdown documentation in docs/
+#
+#	prepush	Depends on "check" and "test"
+#
+#	test	Does nothing (you should override this)
+#
+#	xref	Generates cscope (source cross-reference index)
+#
+# For details on what these targets are supposed to do, see the Joyent
+# Engineering Guide.
+#
+# To make use of these targets, you'll need to set some of these variables. Any
+# variables left unset will simply not be used.
+#
+#	BASH_FILES	Bash scripts to check for syntax
+#			(paths relative to top-level Makefile)
+#
+#	CLEAN_FILES	Files to remove as part of the "clean" target.  Note
+#			that files generated by targets in this Makefile are
+#			automatically included in CLEAN_FILES.  These include
+#			restdown-generated HTML and JSON files.
+#
+#	DOC_FILES	Restdown (documentation source) files. These are
+#			assumed to be contained in "docs/", and must NOT
+#			contain the "docs/" prefix.
+#
+#	JSL_CONF_NODE	Specify JavaScriptLint configuration files
+#	JSL_CONF_WEB	(paths relative to top-level Makefile)
+#
+#			Node.js and Web configuration files are separate
+#			because you'll usually want different global variable
+#			configurations.  If no file is specified, none is given
+#			to jsl, which causes it to use a default configuration,
+#			which probably isn't what you want.
+#
+#	JSL_FILES_NODE	JavaScript files to check with Node config file.
+#	JSL_FILES_WEB	JavaScript files to check with Web config file.
+#
+#	JSON_FILES	JSON files to be validated
+#
+#	JSSTYLE_FILES	JavaScript files to be style-checked
+#
+# You can also override these variables:
+#
+#	BASH		Path to bash (default: "bash")
+#
+#	CSCOPE_DIRS	Directories to search for source files for the cscope
+#			index. (default: ".")
+#
+#	JSL		Path to JavaScriptLint (default: "jsl")
+#
+#	JSL_FLAGS_NODE	Additional flags to pass through to JSL
+#	JSL_FLAGS_WEB
+#	JSL_FLAGS
+#
+#	JSON		Path to json tool (default: "json")
+#
+#	JSSTYLE		Path to jsstyle (default: "jsstyle")
+#
+#	JSSTYLE_FLAGS	Additional flags to pass through to jsstyle
+#
+#	RESTDOWN_EXT	By default '.restdown' is required for DOC_FILES
+#			(see above). If you want to use, say, '.md' instead, then
+#			set 'RESTDOWN_EXT=.md' in your Makefile.
+#
+
+#
+# Defaults for the various tools we use.
+#
+BASH		?= bash
+BASHSTYLE	?= tools/bashstyle
+CP		?= cp
+CSCOPE		?= cscope
+CSCOPE_DIRS	?= .
+JSL		?= jsl
+JSON		?= json
+JSSTYLE		?= jsstyle
+MKDIR		?= mkdir -p
+MV		?= mv
+RESTDOWN_FLAGS	?=
+RESTDOWN_EXT	?= .restdown
+RMTREE		?= rm -rf
+JSL_FLAGS  	?= --nologo --nosummary
+
+ifeq ($(shell uname -s),SunOS)
+	TAR	?= gtar
+else
+	TAR	?= tar
+endif
+
+
+#
+# Defaults for other fixed values.
+#
+BUILD		= build
+DISTCLEAN_FILES += $(BUILD)
+DOC_BUILD	= $(BUILD)/docs/public
+
+#
+# Configure JSL_FLAGS_{NODE,WEB} based on JSL_CONF_{NODE,WEB}.
+#
+ifneq ($(origin JSL_CONF_NODE), undefined)
+	JSL_FLAGS_NODE += --conf=$(JSL_CONF_NODE)
+endif
+
+ifneq ($(origin JSL_CONF_WEB), undefined)
+	JSL_FLAGS_WEB += --conf=$(JSL_CONF_WEB)
+endif
+
+#
+# Targets. For descriptions on what these are supposed to do, see the
+# Joyent Engineering Guide.
+#
+
+#
+# Instruct make to keep around temporary files. We have rules below that
+# automatically update git submodules as needed, but they employ a deps/*/.git
+# temporary file. Without this directive, make tries to remove these .git
+# directories after the build has completed.
+#
+.SECONDARY: $($(wildcard deps/*):%=%/.git)
+
+#
+# This rule enables other rules that use files from a git submodule to have
+# those files depend on deps/module/.git and have "make" automatically check
+# out the submodule as needed.
+#
+deps/%/.git:
+	git submodule update --init deps/$*
+
+#
+# These recipes make heavy use of dynamically-created phony targets. The parent
+# Makefile defines a list of input files like BASH_FILES. We then say that each
+# of these files depends on a fake target called filename.bashchk, and then we
+# define a pattern rule for those targets that runs bash in check-syntax-only
+# mode. This mechanism has the nice properties that if you specify zero files,
+# the rule becomes a noop (unlike a single rule to check all bash files, which
+# would invoke bash with zero files), and you can check individual files from
+# the command line with "make filename.bashchk".
+#
+.PHONY: check-bash
+check-bash: $(BASH_FILES:%=%.bashchk) $(BASH_FILES:%=%.bashstyle)
+
+%.bashchk: %
+	$(BASH) -n $^
+
+%.bashstyle: %
+	$(BASHSTYLE) $^
+
+.PHONY: check-json
+check-json: $(JSON_FILES:%=%.jsonchk)
+
+%.jsonchk: %
+	$(JSON) --validate -f $^
+
+#
+# The above approach can be slow when there are many files to check because it
+# requires that "make" invoke the check tool once for each file, rather than
+# passing in several files at once.  For the JavaScript check targets, we define
+# a variable for the target itself *only if* the list of input files is
+# non-empty.  This avoids invoking the tool if there are no files to check.
+#
+JSL_NODE_TARGET = $(if $(JSL_FILES_NODE), check-jsl-node)
+.PHONY: check-jsl-node
+check-jsl-node: $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $(JSL_FILES_NODE)
+
+JSL_WEB_TARGET = $(if $(JSL_FILES_WEB), check-jsl-web)
+.PHONY: check-jsl-web
+check-jsl-web: $(JSL_EXEC)
+	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_WEB) $(JSL_FILES_WEB)
+
+.PHONY: check-jsl
+check-jsl: $(JSL_NODE_TARGET) $(JSL_WEB_TARGET)
+
+JSSTYLE_TARGET = $(if $(JSSTYLE_FILES), check-jsstyle)
+.PHONY: check-jsstyle
+check-jsstyle:  $(JSSTYLE_EXEC)
+	$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)
+
+.PHONY: check
+check: check-jsl check-json $(JSSTYLE_TARGET) check-bash
+	@echo check ok
+
+.PHONY: clean
+clean::
+	-$(RMTREE) $(CLEAN_FILES)
+
+.PHONY: distclean
+distclean:: clean
+	-$(RMTREE) $(DISTCLEAN_FILES)
+
+CSCOPE_FILES = cscope.in.out cscope.out cscope.po.out
+CLEAN_FILES += $(CSCOPE_FILES)
+
+.PHONY: xref
+xref: cscope.files
+	$(CSCOPE) -bqR
+
+.PHONY: cscope.files
+cscope.files:
+	find $(CSCOPE_DIRS) -name '*.c' -o -name '*.h' -o -name '*.cc' \
+	    -o -name '*.js' -o -name '*.s' -o -name '*.cpp' > $@
+
+#
+# The "docs" target is complicated because we do several things here:
+#
+#    (1) Use restdown to build HTML and JSON files from each of DOC_FILES.
+#
+#    (2) Copy these files into $(DOC_BUILD) (build/docs/public), which
+#        functions as a complete copy of the documentation that could be
+#        mirrored or served over HTTP.
+#
+#    (3) Then copy any directories and media from docs/media into
+#        $(DOC_BUILD)/media. This allows projects to include their own media,
+#        including files that will override same-named files provided by
+#        restdown.
+#
+# Step (3) is the surprisingly complex part: in order to do this, we need to
+# identify the subdirectories in docs/media, recreate them in
+# $(DOC_BUILD)/media, then do the same with the files.
+#
+DOC_MEDIA_DIRS := $(shell find docs/media -type d 2>/dev/null | grep -v "^docs/media$$")
+DOC_MEDIA_DIRS := $(DOC_MEDIA_DIRS:docs/media/%=%)
+DOC_MEDIA_DIRS_BUILD := $(DOC_MEDIA_DIRS:%=$(DOC_BUILD)/media/%)
+
+DOC_MEDIA_FILES := $(shell find docs/media -type f 2>/dev/null)
+DOC_MEDIA_FILES := $(DOC_MEDIA_FILES:docs/media/%=%)
+DOC_MEDIA_FILES_BUILD := $(DOC_MEDIA_FILES:%=$(DOC_BUILD)/media/%)
+
+#
+# Like the other targets, "docs" just depends on the final files we want to
+# create in $(DOC_BUILD), leveraging other targets and recipes to define how
+# to get there.
+#
+.PHONY: docs
+docs:							\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.html)		\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.json)		\
+	$(DOC_MEDIA_FILES_BUILD)
+
+#
+# We keep the intermediate files so that the next build can see whether the
+# files in DOC_BUILD are up to date.
+#
+.PRECIOUS:					\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.html)		\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%json)
+
+#
+# We do clean those intermediate files, as well as all of DOC_BUILD.
+#
+CLEAN_FILES +=					\
+	$(DOC_BUILD)				\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.html)		\
+	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.json)
+
+#
+# Before installing the files, we must make sure the directories exist. The |
+# syntax tells make that the dependency need only exist, not be up to date.
+# Otherwise, it might try to rebuild spuriously because the directory itself
+# appears out of date.
+#
+$(DOC_MEDIA_FILES_BUILD): | $(DOC_MEDIA_DIRS_BUILD)
+
+$(DOC_BUILD)/%: docs/% | $(DOC_BUILD)
+	$(CP) $< $@
+
+docs/%.json docs/%.html: docs/%$(RESTDOWN_EXT) | $(DOC_BUILD) $(RESTDOWN_EXEC)
+	$(RESTDOWN) $(RESTDOWN_FLAGS) -m $(DOC_BUILD) $<
+
+$(DOC_BUILD):
+	$(MKDIR) $@
+
+$(DOC_MEDIA_DIRS_BUILD):
+	$(MKDIR) $@
+
+#
+# The default "test" target does nothing. This should usually be overridden by
+# the parent Makefile. It's included here so we can define "prepush" without
+# requiring the repo to define "test".
+#
+.PHONY: test
+test:
+
+.PHONY: prepush
+prepush: check test
diff --git a/README b/README
deleted file mode 100644
index 75ed9b6..0000000
--- a/README
+++ /dev/null
@@ -1 +0,0 @@
-Placeholder.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..e4429e0
--- /dev/null
+++ b/README.md
@@ -0,0 +1,424 @@
+# node-fast2: streaming JSON RPC over TCP
+
+This is version 2 of the [node-fast](https://github.com/mcavage/node-fast)
+client library.  Fast is a simple RPC protocol used in Joyent's
+[Triton](http://github.com/joyent/triton) and
+[Manta](https://github.com/joyent/manta) systems, particularly in the
+[Moray](https://github.com/joyent/moray) key-value store.  This README contains
+usage notes.  For developers, see CONTRIBUTING.md.
+
+Despite the name, this module contains an implementation of the protocol version
+**1** (it's just a new implementation).  The module includes:
+
+* client library interface
+* server library interface
+* `fastcall`, a command-line tool for making Fast RPC requests
+* `fastserve`, a command-line Fast server for demo and testing
+* `fastbench`, a command-line tool for very basic client load generation
+
+This rewrite was done to fix a number of issues with service discovery and
+connection management in the previous node-fast client.  Service discovery and
+connection management in this client are managed by the caller using something
+like [cueball](https://github.com/arekinath/node-cueball).
+
+The library interfaces here follow Joyent's [Best Practices for Error
+Handling](https://www.joyent.com/developers/node/design/errors).  In particular,
+all operational errors are emitted asynchronously.  It is a programmer error to
+call any of the public APIs with missing or incorrectly-typed arguments.  All
+arguments are required unless otherwise specified.
+
+
+## Synopsis
+
+Start the Fast server:
+
+    $ fastserve 2030 > server.log &
+
+Use `fastcall` to invoke the `date` RPC method inside the client:
+
+    $ fastcall 127.0.0.1 2030 date '[]'
+    {"timestamp":1457475515355,"iso8601":"2016-03-08T22:18:35.355Z"}
+
+Or try the `yes` method, an RPC version of yes(1):
+
+    $ fastcall 127.0.0.1 2030 yes '[ { "value": { "hello": "world" }, "count": 3 } ]'
+    {"hello":"world"}
+    {"hello":"world"}
+    {"hello":"world"}
+
+For an example client and server, see the [fastcall](bin/fastcall) and
+[fastserve](bin/fastserve) programs.
+
+
+## Caveats
+
+The Fast protocol is intended for internal systems.  It does not support
+authentication.  Neither the client nor server implementations are hardened
+against byzantine behavior (e.g., denial-of-service attacks), though they are
+expected to correctly handle all network-related failure modes and byzantine
+input.
+
+Previous implementations of the Fast protocol supported cancellation, but it was
+dangerous to use with servers that did not support it, and there was no way to
+tell if the server did support it.  As a result, this implementation does not
+support cancellation of in-flight requests.  (There's an `abandon()` function in
+the client API, but it only causes the request stream to fail.  The underlying
+RPC continues executing and incoming messages are ignored.)
+
+Early versions of the original node-fast module used a
+[buggy](https://github.com/alexgorbatchev/node-crc/issues/29) CRC
+implementation.  Since changing the CRC algorithm would require a flag day among
+deployed components, this module continues to use the buggy CRC implementation.
+
+
+## Observability
+
+### Kang server
+
+The Fast client and server provide functions suitable for use with
+[kang](https://github.com/davepacheco/kang), a small library for exposing
+debugging information over an HTTP API.
+
+The server-side kang functions report:
+
+* server-wide statistics about connections created, requests started,
+  requests completed, and requests failed;
+* per-connection state information (including time accepted and errors seen) and
+  statistics about requests started, completed, and failed; and
+* per-request state information (including time started)
+
+These enable basic monitoring of server activity and health.  The connection and
+request state information allows you to see which clients are connected, how
+long they've been connected, and how long individual requests have been running,
+which is often helpful in identifying leaked or hung requests.
+
+The client-side kang functions report per-client and per-request state and
+statistics.
+
+The client and server only provide functions; you have to hook this up to a kang
+server.  The built-in demo server ("fastserve") and benchmarking tool
+("fastbench") demonstrate how to do that.
+
+### DTrace probes
+
+The Fast client and server provide DTrace probes and scripts in the "bin"
+directory that use these probes to show client and server activity.  **These
+scripts, the probes, and their arguments may change over time.**
+
+**Fast client probes:**
+
+Probe name  | Event                                              | Arg0                    | Arg1                     | Arg2                     | Arg3
+----------- | -------------------------------------------------- | ----------------------- | ------------------------ | ------------------------ | ----
+`rpc-start` | Client begins issuing an RPC call                  | (int) Client identifier | (int) Message identifier | (string) RPC method name | (json) object with "rpcargs" and optional "timeout".
+`rpc-data`  | Client receives 'data' message for outstanding RPC | (int) Client identifier | (int) Message identifier | (json) Received data     | -
+`rpc-done`  | Client finishes processing RPC                     | (int) Client identifier | (int) Message identifier | (json) May contain "error" describing any error that occurred. | -
+
+**Fast client scripts in "bin" directory:**
+
+* fastclatency: trace latency of all client RPC requests.  Prints power-of-two
+  histogram of request latency when the script exits.
+* fastcsnoop: dump out client RPC activity (all "start", "data", and "done"
+  events).
+
+Note that the client identifier is only unique within a process, and the
+message identifier is only unique for a given client.  Both are only unique
+over a given period of time (i.e., client ids and message ids may be reused).
+See the sample scripts for how to use these correctly.
+
+**Fast server probes:**
+
+Probe name     | Event                                            | Arg0                    | Arg1                     | Arg2                     | Arg3
+-------------- | ------------------------------------------------ | ----------------------- | ------------------------ | ------------------------ | ----
+`conn-create`  | Client connection created                        | (int) server identifier | (int) client identifier  | (string) client label    | -
+`conn-destroy` | Client connection destroyed                      | (int) server identifier | (int) client identifier  | -                        | -
+`rpc-start`    | Server starts processing an RPC call             | (int) server identifier | (int) client identifier  | (int) request identifier | (string) RPC method name
+`rpc-done`     | Server finishes processing an RPC call           | (int) server identifier | (int) client identifier  | (int) request identifier | -
+
+**Fast server script in "bin" directory:**
+
+* fastssnoop: dump out server RPC activity (client connection create/destroy and
+  rpc start/done).
+
+Similar to the client, the server identifier is only unique within the process,
+and the request identifier is only unique within the client.  See the sample
+scripts for how to use these correctly.
+
+The client and server also use bunyan for logging.  On systems with DTrace
+support, you can use runtime log snooping (`bunyan -p`) to observe what the
+client and server would be logging at the finest-grained log levels, even if you
+haven't enabled those.
+
+
+## Client API
+
+Consumers of the client API are responsible for maintaining persistent
+connections to the server.  The
+[cueball](http://github.com/arekinath/node-cueball) module is recommended for
+this purpose.  Clients pass connected sockets to the FastClient constructor:
+
+
+### FastClient class
+
+A FastClient attaches to a Node `net.Socket` object.  The FastClient makes RPC
+calls by sending Fast messages over the socket and reading responses in the
+form of Fast messages from the socket.
+
+Constructor arguments:
+
+Name              | Type         | Meaning
+----------------- | ------------ | -------
+`log`             | object       | [bunyan](https://github.com/trentm/node-bunyan)-style logger
+`transport`       | `net.Socket` | underlying TCP connection to the server
+`nRecentRequests` | positive int | number of recent requests to track for debugging purposes
+
+While consumers are responsible for handling socket errors, the FastClient will
+watch the `transport` for `error` and `end` events in order to proactively fail
+any outstanding requests.
+
+Public methods:
+
+* `rpc(args)`: initiate an RPC request
+* `rpcBufferAndCallback(args)`: initiate an RPC request and buffer incoming data
+* `request.abandon()`: abandon an RPC request
+* `detach()`: detach client from underlying socket
+
+This class emits `error` when there's a problem with the underlying socket
+(other than an `error` emitted by the socket itself) that prevents any requests
+from completing.  This would usually be a protocol error of some sort.
+
+
+#### rpc(args): initiate an RPC request to the remote server
+
+Named arguments:
+
+Name            | Type         | Meaning
+--------------- | ------------ | -------
+`rpcmethod`     | string       | name of the RPC method to invoke on the server
+`rpcargs`       | array        | JSON-serializable array of RPC call arguments
+`timeout`       | integer      | (optional) milliseconds after which to abandon the request if it has not already completed.  The default is that there is no timeout.
+`log`           | object       | (optional) bunyan logger for this request.  If not specified, a child logger of the client-level logger will be used.
+
+The return value is an object-mode stream that consumers use to interact with
+the request.  Objects sent by the server to the client are made available via
+this stream.  The stream emits `end` when the server successfully completes the
+request.  The stream emits `error` when the server reports an error, or if
+there's a socket error or a protocol error.  Consumers need not proactively
+abandon requests that fail due to a socket error.
+
+Keep in mind that with any distributed system, failure of an RPC request due to
+a socket error, protocol error, network failure, or timeout does not mean that
+the RPC did not complete successfully or even that it is not still running.  The
+server may have successfully completed the request, or failed it for a different
+reason, or may still be running it when a network error occurs.  Consumers must
+keep this in mind in designing RPC protocols and responses to failure.
+
+As with other Node streams, the request stream will emit exactly one `end` or
+`error` event, after which no other events will be emitted.
+
+
+#### rpcBufferAndCallback(args, callback): initiate an RPC request and buffer response
+
+This is a convenience function for making RPC calls when the server is expected
+to return a bounded number of objects and the client doesn't intend to process
+the results in a streaming way.  This function buffers up to
+`maxObjectsToBuffer` objects and invokes `callback` when the request is
+complete, as:
+
+    callback(err, data, ndata)
+
+where:
+
+* `err` is the error emitted by the request
+* `data` is an array of buffered data objects, which will have at most
+  `maxObjectsToBuffer` elements
+* `ndata` is a non-negative integer describing the total number of data objects
+  received.  This may be larger than `data.length` only if some objects were
+  dropped because `maxObjectsToBuffer` objects had already been buffered.
+
+Note that `data` and `ndata` will always be present and valid, even if `err` is
+non-null, since some number of data objects may have been received before the
+request error.
+
+Named arguments:
+
+Name                 | Type                 | Meaning
+-------------------- | -------------------- | -------
+`rpcmethod`          | string               | see arguments to `rpc()`
+`rpcargs`            | array                | see arguments to `rpc()`
+`timeout`            | integer              | see arguments to `rpc()`
+`log`                | object               | see arguments to `rpc()`
+`maxObjectsToBuffer` | non-negative integer | maximum number of received data objects that may be buffered.  Subsequently received objects will be dropped.  Callers can tell whether this happened by looking at the `ndata` argument to the callback.
+
+
+#### request.abandon(): abandon an RPC request
+
+Callers may invoke `abandon()` on the return value from `rpc(args)` to abandon
+the request.  If the request is not yet complete, then it will emit an `error`
+indicating the abandonment, and no more data will be emitted.
+
+This does not actually notify the server.  The server will still process the
+request.
+
+Additionally, the client will continue to maintain state about this request
+until whenever the request would have otherwise terminated (i.e., until the
+request completes normally, the client is detached from the transport, or
+there's a transport error).  This can in principle result in holding onto a
+small amount of memory for some time.  Since consumers are expected to identify
+and respond to transport errors (e.g., using TCP KeepAlive or the like), this
+should only be possible if the server itself has hung responding to the request,
+and the resources will be freed when the server is restarted or disappears (as
+detected by the underlying transport) or if the consumer drops its references to
+this Fast client.
+
+
+#### detach(): detach client from underlying socket
+
+This method causes the client to stop sending data on the socket and stop
+reading from the socket.  Any outstanding RPC requests are failed as though the
+socket had emitted an `error`.
+
+This can be used during a graceful shutdown (e.g., of a command-line tool) to
+tear down a Fast client and its associated socket.  This could also be used if
+the caller wanted to stop using this particular client immediately (e.g.,
+because the remote server is no longer registered in the caller's service
+discovery mechanism and should not be used any more).
+
+
+## Server API
+
+### FastServer class
+
+Each `FastServer` instance wraps a `net.Socket` _server_ socket.  The server
+keeps track of clients connected to it.
+
+Named arguments for the constructor:
+
+Name            | Type         | Meaning
+--------------- | ------------ | -------
+`log`           | object       | [bunyan](https://github.com/trentm/node-bunyan)-style logger
+`server`        | `net.Socket` | underlying server socket
+
+Public methods:
+
+* `registerRpcMethod(args)`: register an RPC method handler
+* `close()`: shut down the server
+
+
+#### registerRpcMethod(args): register an RPC method handler
+
+Registers a JavaScript function to invoke for incoming RPC requests.  Named
+arguments include:
+
+Name            | Type         | Meaning
+--------------- | ------------ | -------
+rpcmethod       | string       | name of the method, as clients will specify it when making RPC calls
+rpchandler      | function     | JavaScript function to invoke for each incoming request
+
+The RPC handler function will be invoked as `rpchandler(rpc)`, where `rpc` is an
+RPC context object.  This is a function-oriented interface for accessing
+information about the RPC, including the request identifier, method name, and
+arguments.  It provides the following read-only methods:
+
+* `rpc.connectionId()`: returns a unique identifier for this connection
+* `rpc.requestId()`: returns a unique identifier for this request
+* `rpc.methodName()`: returns the client-specified name of this request
+* `rpc.argv()`: returns the array of arguments provided by the client for the
+  request
+* `rpc.fail(err)`: report failure of the RPC request with the specified error
+
+The `rpc` object is also an object-mode stream that the handler can use to emit
+values and report request completion.  Values are sent to the client by writing
+them to the stream.  Flow control is supported, provided the handler follows
+conventions for that (i.e., using `pipe()` or checking the return value of
+`write()`).  When the request has completed, the handler should end the stream
+with its `end()` method.
+
+The handler should report failure by invoking `rpc.fail(err)`, where `err` is an
+error describing the failure.  The handler should not emit data or end the
+request gracefully after reporting an error.
+
+#### close(): shut down the server
+
+This method shuts down the server by disconnecting outstanding requests from
+their underlying connections and then destroying those underlying client
+sockets.  **The consumer should close the underlying server socket first in
+order to ensure no new connections will be created.  Any newly-created
+connections will be dealt with, but without closing the server socket, there is
+no guarantee that this process will converge.**
+
+Since the interface for RPC handlers does not currently provide a way to inform
+those handlers that the request has been cancelled because of a case like this,
+handlers for outstanding requests continue as normal, and any data emitted is
+ignored.  As a result, though, these handlers may continue running even after
+this function has been called and client sockets are destroyed.
+
+
+## Protocol overview
+
+The Fast protocol is intended for use with TCP.  Typically, a Fast server
+listens for TCP connections on a well-known port, and Fast clients connect to
+the server to make RPC requests.  Clients can make multiple connections to the
+server, but each connection represents a logically separate client.
+Communication between client and server consist of discrete _messages_ sent over
+the TCP connection.  Each message contains:
+
+Field  | Type           | Purpose
+------ | -------------- | -------
+msgid  | 32-bit integer | identifies messages related to a given request
+status | 8-bit integer  | indicates what kind of message this is
+data   | raw JSON data  | depends on message status
+
+Messages have headers that include additional information, like payload length
+and checksum.  The physical format is described in detail in
+[lib/fast_protocol.js](lib/fast_protocol.js).
+
+There are three allowed values for `status`:
+
+Status value | Status name | Description
+-----------: | ----------- | -----------
+`0x1`        | `DATA`      | From clients, indicates an RPC request.  From servers, indicates one of many values emitted by an RPC call.
+`0x2`        | `END`       | Indicates the successful completion of an RPC call.  Only sent by servers.
+`0x3`        | `ERROR`     | Indicates the failed completion of an RPC call.  Only sent by servers.
+
+For all messages, the `data` field contains properties:
+
+Field    | Type              | Purpose
+-------- | ----------------- | -------
+`m`      | object            | describes the RPC method being invoked
+`m.name` | string            | name of the RPC method being invoked
+`m.uts`  | number (optional) | timestamp of message creation, in microseconds since the Unix epoch
+`d`      | object or array   | varies by message status
+
+In summary, there are four kinds of messages.
+
+**Client initiates an RPC request.** The client allocates a new message
+identifier and sends a `DATA` message with `data.m.name` set to the name of the
+RPC method it wants to invoke.  Arguments are specified by the array `data.d`.
+Clients may issue concurrent requests over a single TCP connection, provided
+they do not re-use a message identifier for separate requests.
+
+**Server sends data from an RPC call.**  RPC calls may emit an arbitrary number
+of values back to the client.  To emit these values, the server sends `DATA`
+messages with `data.d` set to an array of non-null values to be emitted.  All
+`DATA` messages for the same RPC request have the same message identifier that
+the client included in its original `DATA` message that initiated the RPC call.
+
+**Server completes an RPC call successfully.** When an RPC call completes
+successfully, the server sends an `END` event having the same message identifier
+as the one in the client's original `DATA` message that initiated the RPC call.
+This message can contain data as well, in which case it should be processed the
+same way as for a DATA message.
+
+**Server reports a failed RPC call.**  Any time before an `END` message is
+generated for an RPC call, the server may send an `ERROR` message having the
+same message identifier as the one in the client's original `DATA` message that
+initiated the RPC call.
+
+By convention, the `m` fields (`m.name` and `m.uts`) are populated for all
+server messages, even though `m.name` is redundant.
+
+The RPC request begins when the client sends the initial `DATA` message.  The
+RPC request is finished when the server sends either an `ERROR` or `END` message
+for that request.  In summary, the client only ever sends one message for each
+request.  The server may send any number of `DATA` messages and exactly one
+`END` or `ERROR` message.
diff --git a/bin/fastbench b/bin/fastbench
new file mode 100755
index 0000000..96e574e
--- /dev/null
+++ b/bin/fastbench
@@ -0,0 +1,494 @@
+#!/usr/bin/env node
+/* vim: set ft=javascript: */
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * fastbench: command-line tool for making a large number of RPC requests and
+ * measuring latency and throughput.
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_cmdutil = require('cmdutil');
+var mod_extsprintf = require('extsprintf');
+var mod_getopt = require('posix-getopt');
+var mod_jsprim = require('jsprim');
+var mod_kang = require('kang');
+var mod_net = require('net');
+var mod_os = require('os');
+var mod_strsplit = require('strsplit');
+var mod_vasync = require('vasync');
+
+var printf = mod_extsprintf.printf;
+var sprintf = mod_extsprintf.sprintf;
+var VError = require('verror');
+
+var mod_fast = require('../lib/fast');
+var mod_fastbench = require('../lib/bench');
+
+/* default concurrency of the client */
+var fbDflConcurrency = 1;
+/* default reporting interval, in seconds */
+var fbDflReportingInterval = 5;
+/* default port for kang server */
+var fbDflKangPort = 16520;
+
+/*
+ * The Big Theory Statement in lib/fast_server.js explains that completing N
+ * requests over a single client socket takes O(N^2) time.  To keep this
+ * manageable, fastbench attempts to maintain a fixed number of requests per
+ * connection.
+ */
+var fbDflRequestsPerConnection = 10;
+
+function fbUsageMessage()
+{
+	var msg, workloads;
+
+	msg = 'Runs Fast RPC requests to measure latency and throughput.\n\n';
+	msg += 'Available canned workloads:\n\n';
+	workloads = mod_fastbench.fastBenchWorkloads();
+	mod_jsprim.forEachKey(workloads, function (name, workload) {
+		msg += sprintf('    %-8s  %s\n', name, workload.description);
+	});
+
+	msg += [
+	    '',
+	    'Options:',
+	    '',
+	    '    -c | --concurrency N         Allow up to N outstanding ' +
+		'requests at once',
+	    '                                 (default: ' +
+		fbDflConcurrency + ')',
+	    '    -d | --duration NSECONDS     Stop after NSECONDS seconds.',
+	    '    -i | --interval NSECONDS     Report every NSECONDS seconds.',
+	    '    -n | --nrequests NREQUESTS   Stop after completing ' +
+		'NREQUESTS requests.',
+	    ''
+	].join('\n');
+
+	return (msg);
+}
+
+function main()
+{
+	var parser, option, args;
+	var workloads, wname;
+	var config = {
+	    'fbHost': null,
+	    'fbPort': null,
+	    'fbWorkload': null,
+	    'fbNRequests': null,
+	    'fbDuration': null,
+	    'fbReportingInterval': fbDflReportingInterval * 1000,
+	    'fbConcurrency': fbDflConcurrency,
+	    'fbKangPort': fbDflKangPort
+	};
+
+	mod_cmdutil.configure({
+	    'synopses': [
+		'[OPTIONS] WORKLOAD HOST PORT'
+	    ],
+	    'usageMessage': fbUsageMessage()
+	});
+
+	parser = new mod_getopt.BasicParser(
+	    'c:(count)d:(duration)i:(interval)n:(nrequests)', process.argv);
+	while ((option = parser.getopt()) !== undefined) {
+		switch (option.option) {
+		case 'c':
+			config.fbConcurrency = parseOptInt(option, 1);
+			break;
+
+		case 'd':
+			config.fbDuration = 1000 * parseOptInt(option, 1);
+			break;
+
+		case 'i':
+			config.fbReportingInterval =
+			    1000 * parseOptInt(option, 0);
+			break;
+
+		case 'n':
+			config.fbNRequests = parseOptInt(option, 1);
+			break;
+
+		default:
+			/* error message already emitted */
+			mod_assertplus.equal('?', option.option);
+			mod_cmdutil.usage();
+			break;
+		}
+	}
+
+	args = process.argv.slice(parser.optind());
+	if (args.length < 3) {
+		mod_cmdutil.usage('expected workload, host, and port');
+	}
+
+	workloads = mod_fastbench.fastBenchWorkloads();
+	wname = args[0];
+	if (!workloads.hasOwnProperty(wname)) {
+		mod_cmdutil.usage('unsupported workload: %s', wname);
+	}
+
+	config.fbWorkload = new (workloads[wname].cons)();
+	config.fbHost = args[1];
+	config.fbPort = parseInt(args[2], 10);
+	if (isNaN(config.fbPort) || config.fbPort < 1 ||
+	    config.fbPort > 65535) {
+		mod_cmdutil.usage('bad port number: %s', args[2]);
+	}
+
+	fastbench(config);
+}
+
+function parseOptInt(option, min)
+{
+	var v;
+
+	v = parseInt(option.optarg, 10);
+	if (isNaN(v)) {
+		mod_cmdutil.usage(new VError(
+		    'value for -%s is not an integer: "%s"',
+		    option.option, option.optarg));
+	}
+
+	mod_assertplus.optionalNumber(min, 'min');
+	mod_assertplus.ok(min !== undefined);
+	if (min !== null && v < min) {
+		mod_cmdutil.usage(new VError(
+		    'value for -%s is too small: "%s"',
+		    option.option, option.optarg));
+	}
+
+	return (v);
+}
+
+function fastbench(config)
+{
+	var log, queue, bencher, nconns, i;
+	var start = new Date();
+
+	printf('%s (%d) pid %d: running workload "%s" ',
+	    start.toISOString(), start.getTime(), process.pid,
+	    config.fbWorkload.name());
+
+	if (config.fbNRequests !== null) {
+		if (config.fbDuration !== null) {
+			printf('for %d requests or %d milliseconds',
+			    config.fbNRequests, config.fbDuration);
+		} else {
+			printf('for %d requests', config.fbNRequests);
+		}
+	} else if (config.fbDuration !== null) {
+		printf('for %d milliseconds', config.fbDuration);
+	} else {
+		printf('until killed (type CTRL-C for results)');
+	}
+
+	printf('\n');
+
+	log = new mod_bunyan({
+	    'name': 'fastbench',
+	    'level': process.env['LOG_LEVEL'] || 'fatal'
+	});
+
+	queue = mod_vasync.queuev({
+	    'concurrency': 10,
+	    'worker': function fastbenchInitConn(_, queuecallback) {
+		var csock;
+		csock = mod_net.createConnection(config.fbPort, config.fbHost);
+		bencher.fb_sockets.push(csock);
+
+		csock.on('error', function (err) {
+			mod_cmdutil.fail(new VError(err, 'socket error'));
+		});
+		csock.on('connect', function () {
+			var fastclient = new mod_fast.FastClient({
+			    'log': log,
+			    'transport': csock,
+			    'nRecentRequests': 5
+			});
+
+			bencher.fb_fastclients.push(fastclient);
+			fastclient.on('error', function (err) {
+				mod_cmdutil.fail(
+				    new VError(err, 'client error'));
+			});
+
+			queuecallback();
+		});
+	    }
+	});
+
+	bencher = new FastBench();
+	bencher.fb_config = config;
+	bencher.fb_sockets = [];
+	bencher.fb_fastclients = [];
+
+	nconns = Math.ceil(config.fbConcurrency / fbDflRequestsPerConnection);
+	mod_assertplus.ok(nconns > 0);
+	for (i = 0; i < nconns; i++) {
+		queue.push(0);
+	}
+	queue.close();
+	queue.on('end', function () {
+		printf('established %d connections to %s:%d\n',
+		    bencher.fb_sockets.length, config.fbHost, config.fbPort);
+		mod_assertplus.equal(bencher.fb_sockets.length,
+		    bencher.fb_fastclients.length);
+
+		mod_kang.knStartServer({
+		    'port': config.fbKangPort,
+		    'uri_base': '/kang',
+		    'service_name': 'fastbench',
+		    'version': '1.0.0',
+		    'ident': mod_os.hostname() + '/' + process.pid,
+		    'list_types': bencher.kangListTypes.bind(bencher),
+		    'list_objects': bencher.kangListObjects.bind(bencher),
+		    'get': bencher.kangGetObject.bind(bencher),
+		    'stats': bencher.kangStats.bind(bencher)
+		}, function (err, server) {
+			mod_assertplus.ok(!err);
+			bencher.fb_kangserver = server;
+			log.info({ 'kangPort': config.fbKangPort },
+			    'listening for kang requests');
+
+			if (config.fbDuration !== null) {
+				setTimeout(function onCommandTimeout() {
+					bencher.finish();
+				}, config.fbDuration);
+			}
+
+			process.once('SIGINT', function onSigInt() {
+				bencher.finish();
+			});
+
+			bencher.start();
+		});
+	});
+}
+
+function FastBench()
+{
+	this.fb_sockets = null;	/* list of client sockets */
+	this.fb_fastclients = null;	/* list of fast clients */
+	this.fb_config = null;		/* configuration */
+
+	this.fb_queue = null;	/* vasync queue for sending requests */
+	this.fb_start = null;	/* start hrtime */
+	this.fb_done = null;	/* finish hrtime */
+	this.fb_nissued = 0;	/* issued RPCs */
+	this.fb_ncompleted = 0;	/* completed RPCs */
+	this.fb_nerrors = 0;	/* unexpected errors */
+	this.fb_hiwat = 0;	/* maximum observed concurrency */
+	this.fb_timeout = null;	/* reporting timeout */
+	this.fb_kangserver = null;	/* kang server */
+
+	/* last reported stats */
+	this.fb_reported_ncompleted = 0;
+	this.fb_reported_nerrors = 0;
+}
+
+FastBench.prototype.start = function ()
+{
+	var ntoissue, i;
+	var self = this;
+
+	mod_assertplus.object(this.fb_sockets);
+	mod_assertplus.object(this.fb_fastclients);
+	mod_assertplus.object(this.fb_config);
+	mod_assertplus.ok(this.fb_queue === null);
+	mod_assertplus.ok(this.fb_sockets.length > 0);
+
+	this.fb_start = process.hrtime();
+	this.fb_queue = mod_vasync.queuev({
+	    'concurrency': this.fb_config.fbConcurrency,
+	    'worker': this.doWork.bind(this)
+	});
+
+	/*
+	 * This is kind of a cheesy way to do this.
+	 */
+	if (this.fb_config.fbNRequests !== null) {
+		ntoissue = Math.min(this.fb_config.fbConcurrency,
+		    this.fb_config.fbNRequests);
+	} else {
+		ntoissue = this.fb_config.fbConcurrency;
+	}
+
+	for (i = 0; i < ntoissue; i++) {
+		this.fb_queue.push(0);
+	}
+
+	if (this.fb_config.fbReportingInterval > 0) {
+		this.fb_timeout = setTimeout(function tickForReport() {
+			self.fb_timeout = setTimeout(tickForReport,
+			    self.fb_config.fbReportingInterval);
+			self.report();
+		}, self.fb_config.fbReportingInterval);
+	}
+};
+
+FastBench.prototype.doWork = function (_, queuecb)
+{
+	var self = this;
+	var concur, client;
+
+	if (this.fb_done !== null) {
+		setImmediate(queuecb);
+		return;
+	}
+
+	this.fb_nissued++;
+	concur = this.fb_nissued - this.fb_ncompleted;
+	if (concur > this.fb_hiwat) {
+		this.fb_hiwat = concur;
+	}
+
+	client = this.fb_fastclients[
+	    this.fb_nissued % this.fb_fastclients.length];
+	mod_assertplus.object(client);
+	this.fb_config.fbWorkload.nextRequest(client, function (err) {
+		if (self.fb_done !== null) {
+			queuecb();
+			return;
+		}
+
+		if (err) {
+			self.fb_nerrors++;
+		}
+
+		self.fb_ncompleted++;
+		if (self.fb_config.fbNRequests !== null) {
+			if (self.fb_nissued < self.fb_config.fbNRequests) {
+				self.fb_queue.push(0);
+			} else if (self.fb_ncompleted ==
+			    self.fb_config.fbNRequests) {
+				self.finish();
+			}
+		} else {
+			self.fb_queue.push(0);
+		}
+
+		queuecb();
+	});
+};
+
+FastBench.prototype.finish = function ()
+{
+	this.fb_done = process.hrtime();
+	this.fb_sockets.forEach(function (s) {
+		s.destroy();
+	});
+	this.fb_fastclients.forEach(function (fastclient) {
+		fastclient.detach();
+	});
+
+	if (this.fb_timeout !== null) {
+		clearTimeout(this.fb_timeout);
+	}
+
+	this.fb_kangserver.close();
+	this.printResults();
+};
+
+FastBench.prototype.report = function ()
+{
+	var elapsed, elapsedms;
+	var ndone, nerrors;
+
+	elapsed = process.hrtime(this.fb_start);
+	elapsedms = mod_jsprim.hrtimeMillisec(elapsed);
+	ndone = this.fb_ncompleted - this.fb_reported_ncompleted;
+	nerrors = this.fb_nerrors - this.fb_reported_nerrors;
+	this.fb_reported_ncompleted = this.fb_ncompleted;
+	this.fb_reported_nerrors = this.fb_nerrors;
+
+	printf('%d %4d.%03dms  %d completed, %d failed\n',
+	    Date.now(), Math.floor(elapsedms / 1000), elapsedms % 1000,
+	    ndone, nerrors);
+};
+
+FastBench.prototype.printResults = function ()
+{
+	var duration, durationus;
+
+	duration = mod_jsprim.hrtimeDiff(this.fb_done, this.fb_start);
+	durationus = mod_jsprim.hrtimeMicrosec(duration);
+
+	printf('-----------------------------------\n');
+	printf('total runtime:             %d.%06ds\n',
+	    Math.floor(durationus / 1e6), durationus % 1e6);
+	printf('total requests completed:  %d (%d issued)\n',
+	    this.fb_ncompleted, this.fb_nissued);
+	printf('total unexpected errors:   %d\n', this.fb_nerrors);
+	printf('error rate:                %s%%\n',
+	    (100 * this.fb_nerrors / this.fb_ncompleted).toFixed(2));
+	printf('maximum concurrency:       %d\n', this.fb_hiwat);
+	printf('request throughput:        %d requests per second\n',
+	    this.fb_ncompleted / durationus * 1e6);
+
+	/*
+	 * This really is a rougher estimate than it looks.  It's only true if
+	 * we really were at max concurrency the whole time.
+	 */
+	printf('estimated average latency: %d us\n',
+	    durationus / (this.fb_ncompleted / this.fb_hiwat));
+};
+
+FastBench.prototype.kangStats = function ()
+{
+	return ({
+	    'nRpcStarted': this.fb_nissued,
+	    'nRpcDone': this.fb_ncompleted,
+	    'nErrors': this.fb_nerrors,
+	    'maxObservedConcurrency': this.fb_hiwat
+	});
+};
+
+FastBench.prototype.kangListTypes = function ()
+{
+	if (this.fb_start === null) {
+		return ([]);
+	}
+
+	return (this.fb_fastclients[0].kangListTypes());
+};
+
+FastBench.prototype.kangListObjects = function (type)
+{
+	/*
+	 * It would be much better if Kang had a better way to aggregate up
+	 * hierarchies of objects.  This is pretty cheesy.
+	 */
+	var rv = [];
+
+	this.fb_fastclients.forEach(function (fastclient, i) {
+		var objs = fastclient.kangListObjects(type);
+		objs.forEach(function (key) { rv.push(i + '/' + key); });
+	});
+
+	return (rv);
+};
+
+FastBench.prototype.kangGetObject = function (type, id)
+{
+	var parts, client;
+
+	parts = mod_strsplit(id, '/', 2);
+	mod_assertplus.equal(parts.length, 2);
+	client = this.fb_fastclients[parts[0]];
+	return (client.kangGetObject(type, parts[1]));
+};
+
+main();
diff --git a/bin/fastcall b/bin/fastcall
new file mode 100755
index 0000000..122542e
--- /dev/null
+++ b/bin/fastcall
@@ -0,0 +1,150 @@
+#!/usr/bin/env node
+/* vim: set ft=javascript: */
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * fastcall: command-line tool for making a node-fast RPC method call.
+ */
+
+var VError = require('verror');
+
+var mod_assertplus = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_cmdutil = require('cmdutil');
+var mod_fast = require('../lib/fast_client');
+var mod_net = require('net');
+
+function main()
+{
+	var argv, doabandon, host, port, rpcmethod, rpcargs;
+	var timeout = null;
+
+	mod_cmdutil.configure({
+	    'synopses': [ '[--abandon-immediately] HOST PORT METHOD ARGS' ],
+	    'usageMessage': [
+	        '    HOST     DNS name or IP address for remote server',
+		'    PORT     TCP port for remote server',
+		'    METHOD   Name of remote RPC method call',
+		'    ARGS     JSON-encoded arguments for RPC method call'
+	    ].join('\n')
+	});
+	mod_cmdutil.exitOnEpipe();
+
+	argv = process.argv.slice(2);
+	if (argv.length > 4 && argv[0] == '--abandon-immediately') {
+		doabandon = true;
+		argv.shift();
+	} else {
+		doabandon = false;
+	}
+
+	if (argv.length != 4) {
+		mod_cmdutil.usage('expected four non-option arguments');
+	}
+
+	host = argv[0];
+	port = parseInt(argv[1], 10);
+	if (isNaN(port) || port < 1 || port > 65535) {
+		mod_cmdutil.usage('invalid TCP port: %s\n', argv[1]);
+	}
+
+	rpcmethod = argv[2];
+	try {
+		rpcargs = JSON.parse(argv[3]);
+	} catch (ex) {
+		mod_cmdutil.usage(new VError(ex, 'parsing RPC arguments'));
+	}
+
+	if (!Array.isArray(rpcargs)) {
+		mod_cmdutil.usage(new Error('RPC arguments: expected array'));
+	}
+
+	fastcall({
+	    'host': host,
+	    'port': port,
+	    'rpcmethod': rpcmethod,
+	    'rpcargs': rpcargs,
+	    'timeout': timeout,
+	    'abandonImmediately': doabandon
+	}, function (err, result) {
+		if (err) {
+			mod_cmdutil.warn(err);
+		}
+	});
+}
+
+function fastcall(args, callback)
+{
+	var log, conn;
+	var rpcmethod, rpcargs, timeout, doabandon;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.string(args.host, 'args.host');
+	mod_assertplus.number(args.port, 'args.port');
+	mod_assertplus.optionalNumber(args.timeout, 'args.timeout');
+	mod_assertplus.string(args.rpcmethod, 'args.rpcmethod');
+	mod_assertplus.array(args.rpcargs, 'args.rpcargs');
+	mod_assertplus.bool(args.abandonImmediately, 'args.abandonImmediately');
+
+	rpcmethod = args.rpcmethod;
+	rpcargs = args.rpcargs;
+	timeout = args.timeout;
+	doabandon = args.abandonImmediately;
+
+	log = new mod_bunyan({
+	    'name': 'fastcall',
+	    'level': process.env['LOG_LEVEL'] || 'fatal'
+	});
+
+	log.info(args, 'fastcall start');
+	conn = mod_net.createConnection(args.port, args.host);
+
+	conn.on('connect', function onConnect() {
+		var fastconn, req;
+
+		fastconn = new mod_fast.FastClient({
+		    'log': log,
+		    'transport': conn,
+		    'nRecentRequests': 10
+		});
+
+		fastconn.on('error', function (err) {
+			conn.destroy();
+			callback(new VError(err, 'fast connection'));
+		});
+
+		req = fastconn.rpc({
+		    'rpcmethod': rpcmethod,
+		    'rpcargs': rpcargs,
+		    'timeout': timeout
+		});
+
+		if (doabandon) {
+			req.abandon();
+		}
+
+		req.on('error', function (err) {
+			conn.destroy();
+			callback(new VError(err, 'fast request'));
+		});
+
+		req.on('data', function (message) {
+			console.log(JSON.stringify(message));
+		});
+
+		req.on('end', function () {
+			conn.destroy();
+			callback();
+		});
+	});
+}
+
+main();
diff --git a/bin/fastclatency b/bin/fastclatency
new file mode 100755
index 0000000..5499183
--- /dev/null
+++ b/bin/fastclatency
@@ -0,0 +1,40 @@
+#!/usr/sbin/dtrace -s
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * fastclatency: dump fast client request latency information
+ */
+
+#pragma D option aggsortkey
+#pragma D option aggzoom
+#pragma D option quiet
+#pragma D option zdefs
+
+BEGIN
+{
+	printf("Latencies are reported in microseconds.  ");
+	printf("CTRL-C to stop and print results.\n");
+}
+
+fastclient*:::rpc-start
+{
+	pending[pid, arg0, arg1] = copyinstr(arg2);
+	starts[pid, arg0, arg1] = timestamp;
+}
+
+fastclient*:::rpc-done
+/starts[pid, arg0, arg1] != 0/
+{
+	@[pending[pid, arg0, arg1]] =
+	    quantize((timestamp - starts[pid, arg0, arg1]) / 1000);
+	pending[pid, arg0, arg1] = 0;
+	starts[pid, arg0, arg1] = 0;
+}
diff --git a/bin/fastclatencytime b/bin/fastclatencytime
new file mode 100755
index 0000000..53a19b0
--- /dev/null
+++ b/bin/fastclatencytime
@@ -0,0 +1,40 @@
+#!/usr/sbin/dtrace -s
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * fastclatencytime: dump fast client request latency information over time
+ */
+
+#pragma D option aggpack
+#pragma D option aggsortkey
+#pragma D option aggzoom
+#pragma D option quiet
+#pragma D option zdefs
+
+BEGIN
+{
+	printf("Latencies are reported in milliseconds. CTRL-C to stop.\n");
+}
+
+fastclient*:::rpc-start
+{
+	pending[pid, arg0, arg1] = copyinstr(arg2);
+	starts[pid, arg0, arg1] = timestamp;
+}
+
+fastclient*:::rpc-done
+/pending[pid, arg0, arg1] != 0/
+{
+	@[pending[pid, arg0, arg1], walltimestamp / 1000000000] =
+	    quantize((timestamp - starts[pid, arg0, arg1]) / 1000000);
+	pending[pid, arg0, arg1] = 0;
+	starts[pid, arg0, arg1] = 0;
+}
diff --git a/bin/fastcsnoop b/bin/fastcsnoop
new file mode 100755
index 0000000..2a4f535
--- /dev/null
+++ b/bin/fastcsnoop
@@ -0,0 +1,54 @@
+#!/usr/sbin/dtrace -s
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * fastcsnoop: dump fast client activity
+ */
+
+#pragma D option quiet
+#pragma D option zdefs
+
+BEGIN
+{
+	start = timestamp;
+	printf("%-8s  %6s  %3s  %9s\n", "TIME", "PID", "CLI", "MSGID");
+}
+
+fastclient*:::rpc-start,
+fastclient*:::rpc-data,
+fastclient*:::rpc-done
+{
+	this->d = timestamp - start;
+	printf("%4d.%03d  %6d  %3d  %9d  ",
+	    this->d / 1000000000,
+	    (this->d % 1000000000) / 1000000,
+	    pid, arg0, arg1);
+}
+
+fastclient*:::rpc-start
+{
+	printf("-> %s\n", copyinstr(arg2));
+	printf("%37s %s\n", "", copyinstr(arg3));
+	pending[pid, arg0, arg1] = copyinstr(arg2);
+}
+
+fastclient*:::rpc-data
+{
+	printf("    data: %s\n", copyinstr(arg2));
+}
+
+fastclient*:::rpc-done
+/pending[pid, arg0, arg1] != 0/
+{
+	printf("<- %s (status: %s)\n", pending[pid, arg0, arg1],
+	    copyinstr(arg2));
+	pending[pid, arg0, arg1] = 0;
+}
diff --git a/bin/fastserve b/bin/fastserve
new file mode 100755
index 0000000..bd4e85c
--- /dev/null
+++ b/bin/fastserve
@@ -0,0 +1,124 @@
+#!/usr/bin/env node
+/* vim: set ft=javascript: */
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * fastserve: command-line fast server for demo and testing
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_cmdutil = require('cmdutil');
+var mod_fastdemo = require('../lib/demo_server');
+var mod_fastserver = require('../lib/fast_server');
+var mod_kang = require('kang');
+var mod_net = require('net');
+var mod_os = require('os');
+
+var KANG_PORT = 16519;
+
+var usageMessage = [
+    'Start a Fast protocol server supporting a few basic RPC calls.  PORT is ',
+    'the TCP port on which to listen.'
+].join('\n');
+
+function main()
+{
+	var argv, port;
+
+	mod_cmdutil.configure({
+	    'synopses': [ 'PORT' ],
+	    'usageMessage': usageMessage
+	});
+	mod_cmdutil.exitOnEpipe();
+
+	argv = process.argv.slice(2);
+	if (argv.length != 1) {
+		mod_cmdutil.usage('expected PORT');
+	}
+
+	port = parseInt(argv[0], 10);
+	if (isNaN(port) || port < 1 || port > 65535) {
+		mod_cmdutil.usage('invalid TCP port: %s\n', argv[1]);
+	}
+
+	fastDemoServer({
+	    'fastPort': port,
+	    'kangPort': KANG_PORT
+	});
+}
+
+function fastDemoServer(args)
+{
+	var fastPort, log, sock, fastserver;
+	var kangPort, kangserver;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.number(args.fastPort, 'args.fastPort');
+	mod_assertplus.number(args.kangPort, 'args.kangPort');
+
+	log = new mod_bunyan({
+	    'name': 'fastserve',
+	    'level': process.env['LOG_LEVEL'] || 'trace'
+	});
+
+	log.info('starting fast server');
+	sock = mod_net.createServer({ 'allowHalfOpen': true });
+	fastserver = new mod_fastserver.FastServer({
+	    'log': log,
+	    'server': sock
+	});
+
+	mod_fastdemo.demoRpcs().forEach(function (r) {
+		fastserver.registerRpcMethod(r);
+	});
+
+	fastPort = args.fastPort;
+	kangPort = args.kangPort;
+	sock.listen(fastPort, function () {
+		var nsigs = 0;
+
+		log.info({ 'fastPort': fastPort },
+		    'listening for fast requests');
+
+		mod_kang.knStartServer({
+		    'port': kangPort,
+		    'uri_base': '/kang',
+		    'service_name': 'fastserve',
+		    'version': '1.0.0',
+		    'ident': mod_os.hostname() + '/' +  process.pid,
+		    'list_types': fastserver.kangListTypes.bind(fastserver),
+		    'list_objects': fastserver.kangListObjects.bind(fastserver),
+		    'get': fastserver.kangGetObject.bind(fastserver),
+		    'stats': fastserver.kangStats.bind(fastserver)
+		}, function (err, server) {
+			mod_assertplus.ok(!err);
+			kangserver = server;
+			log.info({ 'kangPort': kangPort },
+			    'listening for kang requests');
+			if (nsigs > 0) {
+				kangserver.close();
+			}
+		});
+
+		process.on('SIGINT', function () {
+			if (++nsigs == 1) {
+				if (kangserver)
+					kangserver.close();
+				sock.close();
+				fastserver.close();
+			}
+		});
+	});
+
+}
+
+main();
diff --git a/bin/fastslatency b/bin/fastslatency
new file mode 100755
index 0000000..cde3e6e
--- /dev/null
+++ b/bin/fastslatency
@@ -0,0 +1,40 @@
+#!/usr/sbin/dtrace -s
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * fastslatency: dump fast server request latency information
+ */
+
+#pragma D option aggsortkey
+#pragma D option aggzoom
+#pragma D option quiet
+#pragma D option zdefs
+
+BEGIN
+{
+	printf("Latencies are reported in microseconds.  ");
+	printf("CTRL-C to stop and print results.\n");
+}
+
+fastserver*:::rpc-start
+{
+	pending[pid, arg0, arg1, arg2] = copyinstr(arg3);
+	starts[pid, arg0, arg1, arg2] = timestamp;
+}
+
+fastserver*:::rpc-done
+/starts[pid, arg0, arg1, arg2] != 0/
+{
+	@[pending[pid, arg0, arg1, arg2]] =
+	    quantize((timestamp - starts[pid, arg0, arg1, arg2]) / 1000);
+	pending[pid, arg0, arg1, arg2] = 0;
+	starts[pid, arg0, arg1, arg2] = 0;
+}
diff --git a/bin/fastssnoop b/bin/fastssnoop
new file mode 100755
index 0000000..030aa63
--- /dev/null
+++ b/bin/fastssnoop
@@ -0,0 +1,68 @@
+#!/usr/sbin/dtrace -s
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * fastssnoop: dump fast server activity
+ */
+
+#pragma D option quiet
+#pragma D option zdefs
+
+BEGIN
+{
+	start = timestamp;
+	printf("%-8s  %6s  %6s\n", "TIME", "PID", "SRV/CLI");
+}
+
+fastserver*:::conn-create,
+fastserver*:::conn-destroy,
+fastserver*:::rpc-start,
+fastserver*:::rpc-done
+{
+	this->d = timestamp - start;
+	printf("%4d.%03d  %6d  %d/%04d  ",
+	    this->d / 1000000000, (this->d % 1000000000) / 1000000,
+	    pid, arg0, arg1);
+}
+
+fastserver*:::conn-create
+{
+	printf("connection created for %s\n", copyinstr(arg2));
+}
+
+fastserver*:::conn-destroy
+{
+	printf("connection destroyed\n");
+}
+
+fastserver*:::rpc-start
+{
+	rpcstarts[pid, arg0, arg1, arg2] = timestamp;
+	rpcmethods[pid, arg0, arg1, arg2] = copyinstr(arg3);
+	printf("rpc start: %03d (\"%s\")\n", arg2,
+	    rpcmethods[pid, arg0, arg1, arg2]);
+}
+
+fastserver*:::rpc-done
+/rpcstarts[pid, arg0, arg1, arg2] == 0/
+{
+	printf("rpc  done: %03d\n", arg2);
+}
+
+fastserver*:::rpc-done
+/rpcstarts[pid, arg0, arg1, arg2] != 0/
+{
+	printf("rpc  done: %03d (\"%s\" call took %d us)\n",
+	    arg2, rpcmethods[pid, arg0, arg1, arg2],
+	    (timestamp - rpcstarts[pid, arg0, arg1, arg2]) / 1000);
+	rpcstarts[pid, arg0, arg1, arg2] = 0;
+	rpcmethods[pid, arg0, arg1, arg2] = 0;
+}
diff --git a/deps/catest b/deps/catest
new file mode 160000
index 0000000..ca13864
--- /dev/null
+++ b/deps/catest
@@ -0,0 +1 @@
+Subproject commit ca138645cc9647d6976063c61fa9f28dd16c5023
diff --git a/lib/bench.js b/lib/bench.js
new file mode 100644
index 0000000..e8bc8b4
--- /dev/null
+++ b/lib/bench.js
@@ -0,0 +1,100 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/bench.js: common facilities for basic benchmarking
+ */
+
+var mod_assertplus = require('assert-plus');
+var VError = require('verror');
+
+exports.fastBenchWorkloads = fastBenchWorkloads;
+
+var FastBenchWorkloads = {
+    'sync': {
+	'name': 'sync',
+	'description': 'uniform, moderate-sized, synchronous requests',
+	'cons': FastWorkloadSync
+    },
+
+    'sleep150': {
+	'name': 'sleep150',
+	'description': 'uniform, moderate-sized requests with 150ms sleep',
+	'cons': FastWorkloadSleep150
+    }
+};
+
+function fastBenchWorkloads()
+{
+	return (FastBenchWorkloads);
+}
+
+function FastWorkloadSync() {}
+FastWorkloadSync.prototype.name = function () { return ('sync'); };
+FastWorkloadSync.prototype.nextRequest = function (fastclient, callback)
+{
+	return (fastWorkloadRequest({
+	    'fastClient': fastclient,
+	    'delay': null
+	}, callback));
+};
+
+function FastWorkloadSleep150() {}
+FastWorkloadSleep150.prototype.name = function () { return ('sleep150'); };
+FastWorkloadSleep150.prototype.nextRequest = function (fastclient, callback)
+{
+	return (fastWorkloadRequest({
+	    'fastClient': fastclient,
+	    'delay': 150
+	}, callback));
+};
+
+function fastWorkloadRequest(args, callback)
+{
+	var fastclient, rpcargs, req, ndata;
+
+	fastclient = args.fastClient;
+	rpcargs = {
+	    'rpcmethod': 'fastbench',
+	    'rpcargs': [ {
+		'echo': [
+		    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
+		    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
+		    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
+		    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
+		]
+	    } ]
+	};
+
+	if (args.delay !== null) {
+		rpcargs.rpcargs[0]['delay'] = args.delay;
+	}
+
+	req = fastclient.rpc(rpcargs);
+
+	ndata = 0;
+	req.on('data', function (d) {
+		mod_assertplus.deepEqual(d,
+		    { 'value': [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] });
+		ndata++;
+	});
+
+	req.on('end', function (e) {
+		if (ndata != 4) {
+			callback(new Error('unexpected data in response'));
+		} else {
+			callback();
+		}
+	});
+
+	req.on('error', function (err) {
+		callback(new VError(err, 'unexpected server error'));
+	});
+}
diff --git a/lib/demo_server.js b/lib/demo_server.js
new file mode 100644
index 0000000..d72c243
--- /dev/null
+++ b/lib/demo_server.js
@@ -0,0 +1,200 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/demo_server.js: implementations of some RPC functions useful in both the
+ * demo server and test suite.
+ */
+
+var mod_fs = require('fs');
+var mod_lstream = require('lstream');
+var mod_stream = require('stream');
+
+var VError = require('verror');
+
+exports.demoRpcs = demoRpcs;
+
+var demoRpc = [
+    { 'rpcmethod': 'date',	'rpchandler': fastRpcDate      },
+    { 'rpcmethod': 'echo',	'rpchandler': fastRpcEcho      },
+    { 'rpcmethod': 'fail',	'rpchandler': fastRpcFail      },
+    { 'rpcmethod': 'fastbench',	'rpchandler': fastRpcFastbench },
+    { 'rpcmethod': 'sleep',	'rpchandler': fastRpcSleep     },
+    { 'rpcmethod': 'words',	'rpchandler': fastRpcWords     },
+    { 'rpcmethod': 'yes',	'rpchandler': fastRpcYes       }
+];
+
+function demoRpcs()
+{
+	return (demoRpc);
+}
+
+function fastRpcDate(rpc)
+{
+	var when;
+
+	if (rpc.argv().length !== 0) {
+		rpc.fail(new Error('expected no arguments'));
+	} else {
+		when = new Date();
+		rpc.end({
+		    'timestamp': when.getTime(),
+		    'iso8601': when.toISOString()
+		});
+	}
+}
+
+function fastRpcEcho(rpc)
+{
+	rpc.argv().forEach(function (a) { rpc.write({ 'value': a }); });
+	rpc.end();
+}
+
+function fastRpcFail(rpc)
+{
+	var errspec, rv;
+
+	if (rpc.argv().length != 1) {
+		rpc.fail(new Error('expected argument'));
+		return;
+	}
+
+	errspec = rpc.argv()[0];
+	if (typeof (errspec.name) != 'string' ||
+	    typeof (errspec.message) != 'string' ||
+	    (errspec.info !== undefined && typeof (errspec.info) != 'object')) {
+		rpc.fail(new Error('bad arguments'));
+		return;
+	}
+
+	if (errspec.data && Array.isArray(errspec.data)) {
+		errspec.data.forEach(function (d) {
+			rpc.write({ 'value': d });
+		});
+	}
+
+	rv = new VError({
+	    'name': errspec.name,
+	    'info': errspec.info || {}
+	}, '%s', errspec.message);
+	if (errspec.context)
+		rv.context = errspec.context;
+
+	setImmediate(function () { rpc.fail(rv); });
+}
+
+function fastRpcFastbench(rpc)
+{
+	var argv, args;
+
+	argv = rpc.argv();
+	if (argv.length != 1 || typeof (argv[0]) != 'object' ||
+	    argv[0] === null) {
+		rpc.fail(new Error('expected exactly one object argument'));
+		return;
+	}
+
+	args = argv[0];
+	if (!args.hasOwnProperty('echo') || !Array.isArray(args['echo'])) {
+		rpc.fail(new Error('expected arg.echo'));
+		return;
+	}
+
+	if (typeof (args['delay']) == 'number') {
+		setTimeout(fastRpcFastbenchFinish, args['delay'], rpc,
+		    args['echo']);
+	} else {
+		fastRpcFastbenchFinish(rpc, args['echo']);
+	}
+}
+
+function fastRpcFastbenchFinish(rpc, values)
+{
+	values.forEach(function (a) { rpc.write({ 'value': a }); });
+	rpc.end();
+}
+
+function fastRpcSleep(rpc)
+{
+	var argv, timems, maxtimems;
+
+	argv = rpc.argv();
+	if (argv.length != 1) {
+		rpc.fail(new Error('expected one argument'));
+		return;
+	}
+
+	timems = argv[0].ms;
+	maxtimems = 30 * 60 * 1000;	/* 30 minutes */
+	if (typeof (timems) != 'number' || timems < 0 || timems > maxtimems) {
+		rpc.fail(new Error('bad value for "ms"'));
+		return;
+	}
+
+	setTimeout(function () { rpc.end(); }, timems);
+}
+
+function fastRpcWords(rpc)
+{
+	var wordfile, wordstream, lstream, xform;
+
+	if (rpc.argv().length !== 0) {
+		rpc.fail(new Error('expected 0 arguments'));
+		return;
+	}
+
+	wordfile = '/usr/dict/words';
+	wordstream = mod_fs.createReadStream(wordfile);
+	lstream = new mod_lstream();
+	wordstream.pipe(lstream);
+	xform = new mod_stream.Transform({
+	    'objectMode': true,
+	    'highWaterMark': 1
+	});
+	xform._transform = function (c, _, callback) {
+		this.push({ 'word': c });
+		setImmediate(callback);
+	};
+	lstream.pipe(xform);
+	xform.pipe(rpc);
+	wordstream.on('error', function (err) {
+		rpc.fail(new VError(err, 'open/read "%s"', wordfile));
+	});
+}
+
+function fastRpcYes(rpc)
+{
+	var argv, value, count, i;
+
+	argv = rpc.argv();
+	if (argv.length != 1) {
+		rpc.fail(new Error('expected one argument'));
+		return;
+	}
+
+	value = argv[0].value;
+	count = argv[0].count;
+	if (typeof (count) != 'number' || count < 1 || count > 102400) {
+		rpc.fail(new VError({
+		    'info': {
+			'foundValue': count,
+			'minValue': 1,
+			'maxValue': 102400
+		    }
+		}, 'count must be an integer in range [1, 102400]'));
+		return;
+	}
+
+	for (i = 0; i < count; i++) {
+		rpc.write({ 'value': value });
+	}
+
+	rpc.end();
+}
diff --git a/lib/fast.js b/lib/fast.js
new file mode 100644
index 0000000..b28ef20
--- /dev/null
+++ b/lib/fast.js
@@ -0,0 +1,19 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/fast.js: public node-fast interface
+ */
+
+var mod_client = require('./fast_client');
+var mod_server = require('./fast_server');
+
+exports.FastClient = mod_client.FastClient;
+exports.FastServer = mod_server.FastServer;
diff --git a/lib/fast_client.js b/lib/fast_client.js
new file mode 100644
index 0000000..4a7c81f
--- /dev/null
+++ b/lib/fast_client.js
@@ -0,0 +1,842 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/fast_client.js: public node-fast client interface
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_dtrace = require('dtrace-provider');
+var mod_events = require('events');
+var mod_microtime = require('microtime');
+var mod_util = require('util');
+var VError = require('verror');
+
+var mod_protocol = require('./fast_protocol');
+var mod_client_request = require('./fast_client_request');
+var mod_subr = require('./subr');
+
+exports.FastClient = FastClient;
+
+/*
+ * There's one DTrace provider for all clients using this copy of this module.
+ */
+var fastClientProvider = null;
+
+/*
+ * We have one counter for the number of clients in the process.  Note that this
+ * is a true JavaScript global, so that different copies of this module
+ * (presumably at different versions) will still end up with unique client ids.
+ */
+/* jsl:declare fastNclients */
+fastNclients = 0;
+
+
+/*
+ * A FastClient is an object used to make RPC requests to a remote Fast server.
+ * This client does not manage the connection to the remote server.  That's the
+ * responsibility of the caller.
+ *
+ * Named arguments:
+ *
+ *     log		bunyan-style logger
+ *
+ *     nRecentRequests	count of recent requests to keep track of (for
+ *     			debugging)
+ *
+ *     transport	usually a socket connected to the remote server, but
+ *     			this could be any data-mode duplex stream.  This client
+ *     			will write messages to the transport and parse responses
+ *     			from the transport.  This client listens for 'error'
+ *     			events and end-of-stream only so that it can report
+ *     			request failures.  The caller is also expected to listen
+ *     			for these errors and handle reconnection appropriately.
+ *
+ * On 'error', the caller should assume that the current connection to the
+ * server is in an undefined state and should not be used any more.  Any
+ * in-flight RPC will be terminated gracefully (i.e., with an "error" or "end"
+ * event).
+ */
+function FastClient(args)
+{
+	var self = this;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.object(args.log, 'args.log');
+	mod_assertplus.number(args.nRecentRequests, 'args.nRecentRequests');
+	mod_assertplus.object(args.transport, 'args.transport');
+
+	this.fc_log = args.log;
+	this.fc_transport = args.transport;
+	this.fc_nrecent = args.nRecentRequests;
+
+	/* RPC and protocol state */
+	this.fc_pending = {}; 		/* pending requests */
+	this.fc_abandoned = {};		/* abandoned, outstanding requests */
+	this.fc_nrpc_started = 0;	/* requests issued */
+	this.fc_nrpc_done = 0;		/* requests completed */
+	this.fc_recentrpc = [];		/* recently completed requests */
+	this.fc_error = null;		/* first fatal error, if any */
+	this.fc_nerrors = 0;		/* count of fatal errors */
+	this.fc_rqidalloc = new mod_subr.IdAllocator({
+	    'min': 1,
+	    'max': mod_protocol.FP_MSGID_MAX,
+	    'isAllocated': function isReqIdAllocated(id) {
+		return (self.fc_pending.hasOwnProperty(id) ||
+		    self.fc_abandoned.hasOwnProperty(id));
+	    }
+	});
+
+	/* transport and message helper objects */
+	this.fc_transport_onerr = null;	/* error listener */
+	this.fc_msgencoder = new mod_protocol.FastMessageEncoder();
+	this.fc_msgdecoder = new mod_protocol.FastMessageDecoder();
+
+	/* transport state */
+	this.fc_detached = false;	 /* caller detached us */
+	this.fc_transport_ended = false; /* transport detached us */
+
+	if (fastClientProvider === null) {
+		fastClientProvider = fastClientProviderInit();
+	}
+
+	mod_assertplus.object(fastClientProvider);
+	this.fc_dtid = ++fastNclients;
+	this.fc_dtp = fastClientProvider;
+
+	mod_events.EventEmitter.call(this);
+	this.attach();
+}
+
+mod_util.inherits(FastClient, mod_events.EventEmitter);
+
+/*
+ * [public] Initiate an RPC request.  Named parameters include:
+ *
+ *     rpcmethod	(string)	name of the RPC method to invoke
+ *
+ *     rpcargs		(object)	values of arguments passed to the RPC
+ *
+ *     timeout (optional number)	milliseconds after which to abandon the
+ *     					request if no response has been received
+ *
+ *     log        (optional log)	bunyan-style logger
+ *
+ * The semantics of "rpcmethod" and "rpcargs" are defined by the server.
+ *
+ * If "log" is not provided, then this request uses a child of the client-level
+ * logger.
+ *
+ * The return value is an object-mode readable stream that emits zero or more
+ * messages from the server.  As with other readable streams, "end" denotes
+ * successful completion, and "error" denotes unsuccessful completion.  This
+ * stream does not support flow control, so the server must be trusted, and the
+ * caller must avoid making requests that return large amounts of data faster
+ * than the caller can process it.  Additionally, the stream is already reading
+ * when the caller gets it, so there's no need to call read(0) to kick off the
+ * RPC.
+ *
+ * See rpcBufferAndCallback() for an interface that buffers incoming data and
+ * invokes a callback upon completion.
+ */
+FastClient.prototype.rpc = function (args)
+{
+	var msgid, log, request, message;
+	var timeoutms = null;
+	var self = this;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.string(args.rpcmethod, 'method.rpcmethod');
+	mod_assertplus.array(args.rpcargs, 'args.rpcargs');
+	mod_assertplus.optionalNumber(args.timeout, 'args.timeout');
+	mod_assertplus.optionalObject(args.log, 'args.log');
+
+	if (typeof (args.timeout) == 'number') {
+		mod_assertplus.ok(args.timeout > 0, 'args.timeout > 0');
+		timeoutms = args.timeout;
+	}
+
+	msgid = this.allocMessageId();
+	mod_assertplus.ok(!this.fc_pending.hasOwnProperty(msgid));
+	log = args.log ? args.log : this.fc_log;
+	request = new mod_client_request.FastClientRequest({
+	    'client': this,
+	    'msgid': msgid,
+	    'rpcmethod': args.rpcmethod,
+	    'rpcargs': args.rpcargs,
+	    'log': log.child({
+		'component': 'FastClientRequest',
+		'msgid': msgid,
+		'rpcmethod': args.rpcmethod
+	    })
+	});
+
+	this.fc_pending[msgid] = request;
+	this.fc_nrpc_started++;
+
+	if (this.fc_error !== null || this.fc_detached ||
+	    this.fc_transport_ended) {
+		this.fc_log.debug('skipping new request (transport detached)');
+		request.frq_skip = true;
+		this.requestFail(request, new VError({
+		    'name': 'FastTransportError'
+		}, 'transport detached'));
+		return (request);
+	}
+
+	message = {
+	    'msgid': msgid,
+	    'status': mod_protocol.FP_STATUS_DATA,
+	    'data': {
+		'm': {
+		    'uts': mod_microtime.now(),
+		    'name': args.rpcmethod
+		},
+		'd': args.rpcargs
+	    }
+	};
+
+	request.frq_log.debug({
+	    'rpcargs': args.rpcargs,
+	    'timeoutms': timeoutms
+	}, 'rpc %s: entered', args.rpcmethod);
+
+	this.fc_dtp.fire('rpc-start', function () {
+	    return ([
+		self.fc_dtid,
+		request.frq_msgid,
+		args.rpcmethod,
+		{
+		    'rpcargs': args.rpcargs,
+		    'timeout': timeoutms
+		}
+	    ]);
+	});
+
+	this.fc_log.trace(message, 'outgoing message');
+	this.fc_msgencoder.write(message);
+
+	if (timeoutms !== null) {
+		request.frq_timeout = setTimeout(function onRpcTimeout() {
+			self.requestAbandon(request, new VError({
+			    'name': 'TimeoutError',
+			    'info': {
+				'timeout': timeoutms
+			    }
+			}, 'timed out after %d milliseconds', timeoutms));
+		}, timeoutms);
+	}
+
+	return (request);
+};
+
+/*
+ * Make an RPC request just like rpc(), but buffer incoming data messages until
+ * the request is complete and invoke "callback" as callback(err, data, ndata)
+ * when the request is complete.  In the callback:
+ *
+ *     "err" is the error, if any
+ *
+ *     "data" is an array of data objects returned with the RPC
+ *     (up to "maxObjectsToBuffer" objects)
+ *
+ *     "ndata" is a non-negative integer describing how many data objects were
+ *     received.  If "ndata" is larger than "data.length", then messages were
+ *     dropped because maxObjectsToBuffer was too small.
+ *
+ * Note that "data" will always be an array and may contain messages even if
+ * "err" is present.  Similarly, "ndata" will always be a non-negative integer.
+ *
+ * This function takes all of the named arguments that rpc() takes, plus the
+ * following required argument:
+ *
+ *     maxObjectsToBuffer	the maximum number of data messages to buffer.
+ *     				This allows callers to use this interface to
+ *     				make an RPC call that they expect may only
+ *     				produce a small number of data messages and know
+ *     				that a bounded amount of memory will be used,
+ *     				even if the server returns more than the
+ *     				expected number of messages.
+ */
+FastClient.prototype.rpcBufferAndCallback = function (args, callback)
+{
+	var maxbuffer, request, data, ndata, done;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.func(callback, 'callback');
+	mod_assertplus.number(args.maxObjectsToBuffer,
+	    'args.maxObjectsToBuffer');
+	maxbuffer = args.maxObjectsToBuffer;
+	mod_assertplus.ok(maxbuffer >= 0);
+
+	data = [];
+	ndata = 0;
+	done = false;
+	request = this.rpc(args);
+	request.on('data', function (c) {
+		mod_assertplus.ok(!done);
+		ndata++;
+		if (data.length < maxbuffer) {
+			data.push(c);
+		}
+	});
+
+	request.on('error', function (err) {
+		mod_assertplus.ok(!done);
+		done = true;
+		mod_assertplus.ok(data.length <= ndata);
+		mod_assertplus.ok(data.length <= maxbuffer);
+		callback(err, data, ndata);
+	});
+
+	request.on('end', function () {
+		mod_assertplus.ok(!done);
+		done = true;
+		mod_assertplus.ok(data.length <= ndata);
+		mod_assertplus.ok(data.length <= maxbuffer);
+		callback(null, data, ndata);
+	});
+
+	return (request);
+};
+
+/*
+ * Disconnect entirely from the underlying transport.  Do not read from it or
+ * write to it and remove any event handlers.
+ */
+FastClient.prototype.detach = function ()
+{
+	if (this.fc_detached) {
+		return;
+	}
+
+	this.fc_detached = true;
+	this.fc_transport.removeListener('error', this.fc_transport_onerr);
+	this.fc_transport.unpipe(this.fc_msgdecoder);
+	this.fc_msgencoder.unpipe(this.fc_transport);
+
+	this.requestAbandonAll(new VError({
+	    'name': 'FastTransportError'
+	}, 'client detached from transport'));
+};
+
+/*
+ * Public methods for exposing debugging data over kang.
+ *
+ * Over kang, we expose objects of types:
+ *
+ *     fastclient	  describes a single FastClient, including basic
+ *			  activity stats, any fatal error, and so on.
+ *
+ *     fastrequest	  describes a request that's currently outstanding,
+ *			  including which connection received it, how long it's
+ *			  been running, and what state it's in
+ *
+ * We do not provide a kang entry point for stats because we expect that there
+ * will be many FastClients in most kang components and they will aggregate up
+ * statistics from individual "fastclient" objects as desired.
+ */
+FastClient.prototype.kangListTypes = function ()
+{
+	return ([ 'fastclient', 'fastrequest' ]);
+};
+
+FastClient.prototype.kangListObjects = function (type)
+{
+	if (type == 'fastclient') {
+		return ([ this.fc_dtid ]);
+	}
+
+	mod_assertplus.equal(type, 'fastrequest');
+	return (Object.keys(this.fc_pending).concat(
+	    Object.keys(this.fc_abandoned)));
+};
+
+FastClient.prototype.kangGetObject = function (type, id)
+{
+	var rv, req;
+
+	if (type == 'fastclient') {
+		mod_assertplus.equal(id, this.fc_dtid);
+		rv = {
+		    'id': id,
+		    'nRpcStarted': this.fc_nrpc_started,
+		    'nRpcDone': this.fc_nrpc_done,
+		    'nErrors': this.fc_nerrors,
+		    'error': this.fc_error,
+		    'detached': this.fc_detached,
+		    'transportEnded': this.fc_transport_ended
+		};
+		return (rv);
+	}
+
+	mod_assertplus.equal(type, 'fastrequest');
+	rv = {};
+	rv['clientId'] = this.fc_dtid;
+	rv['msgid'] = id;
+
+	if (this.fc_pending.hasOwnProperty(id)) {
+		req = this.fc_pending[id];
+	} else {
+		req = this.fc_abandoned[id];
+	}
+
+	rv['skipped'] = req.frq_skip;
+	rv['rpcmethod'] = req.frq_rpcmethod;
+	rv['nDataEmitted'] = req.frq_ndata;
+	rv['nMessagesIgnored'] = req.frq_nignored;
+	rv['error'] = req.frq_error;
+	rv['abandoned'] = req.frq_abandoned;
+	rv['doneGraceful'] = req.frq_done_graceful;
+	rv['hasTimeout'] = req.frq_timeout !== null;
+	return (rv);
+};
+
+/*
+ * private methods
+ */
+
+FastClient.prototype.attach = function ()
+{
+	var self = this;
+
+	this.fc_transport.pipe(this.fc_msgdecoder);
+	this.fc_msgencoder.pipe(this.fc_transport, { 'end': false });
+
+	/*
+	 * It's non-idiomatic to use the "data" event because it defeats flow
+	 * control.  However, this abstraction cannot support flow control
+	 * anyway, but clients can already deal with this by limiting the size
+	 * of responses.  Since we know our message decoder is an object-mode
+	 * stream, we may as well just read objects with this handler.
+	 */
+	this.fc_msgdecoder.on('data',
+	    function onDecoderMessage(message) { self.onMessage(message); });
+	this.fc_msgdecoder.on('error',
+	    function onDecoderError(err) { self.fatalError(err); });
+
+	/*
+	 * By the nature of this abstraction, we don't own the transport.  But
+	 * we still want to know when it either emits "end" or "error" so that
+	 * we can know that any outstanding requests will not be completed.
+	 * Some modules use "close" for this, but transports are not required to
+	 * emit that event.  They should emit one of these two.  We listen for
+	 * "end" on the message decoder rather than the transport to deal with
+	 * the fact that there may be queueing of data in between them.
+	 */
+	this.fc_msgdecoder.on('end', function onTransportEnd() {
+		var err;
+
+		self.fc_transport_ended = true;
+
+		/*
+		 * There's no problem with seeing end-of-stream as long as we
+		 * have no requests pending and are not asked to make any more
+		 * requests.  Remember, the caller is separately responsible for
+		 * detecting this case for the purpose of reconnection, if
+		 * desired.
+		 */
+		if (self.fc_nrpc_started > self.fc_nrpc_done) {
+			err = new VError({
+			    'name': 'FastProtocolError'
+			}, 'unexpected end of transport stream');
+			self.fatalError(err);
+		}
+	});
+
+	this.fc_transport_onerr = function onTransportError(err) {
+		self.fatalError(new VError({
+		    'name': 'FastTransportError',
+		    'cause': err
+		}, 'unexpected error on transport'));
+	};
+
+	this.fc_transport.on('error', this.fc_transport_onerr);
+};
+
+/*
+ * Return the next message id.
+ */
+FastClient.prototype.allocMessageId = function ()
+{
+	return (this.fc_rqidalloc.alloc());
+};
+
+/*
+ * Record an error that's fatal to this client.  We emit the first one and
+ * abandon all outstanding requests.  If we see more than one, we simply log and
+ * count subsequent ones.
+ */
+FastClient.prototype.fatalError = function (err)
+{
+	this.fc_log.error(err);
+	this.fc_nerrors++;
+
+	if (this.fc_error !== null) {
+		return;
+	}
+
+	this.fc_error = err;
+	this.emit('error', err);
+	this.requestAbandonAll(err);
+};
+
+/*
+ * Abandon all pending requests, as with requestAbandon(request, error).
+ */
+FastClient.prototype.requestAbandonAll = function (error)
+{
+	var msgid;
+
+	for (msgid in this.fc_pending) {
+		mod_assertplus.ok(
+		    this.requestIsPending(this.fc_pending[msgid]));
+		this.requestAbandon(this.fc_pending[msgid], error);
+		mod_assertplus.ok(!this.fc_pending.hasOwnProperty(msgid));
+	}
+};
+
+/*
+ * Abandon the given request with an error indicating the request was abandoned.
+ * If "error" is provided, then the given error will be provided as the cause of
+ * the abandon error.  If the request has already completed in any way
+ * (including having been previously abandoned), this will do nothing.
+ */
+FastClient.prototype.requestAbandon = function (request, error)
+{
+	var msgid;
+
+	if (!this.requestIsPending(request)) {
+		return;
+	}
+
+	mod_assertplus.object(error, 'error');
+
+	msgid = request.frq_msgid;
+	mod_assertplus.ok(this.fc_pending[msgid] == request);
+	request.frq_abandoned = true;
+
+	/*
+	 * The history of cancellation in node-fast is somewhat complicated.
+	 * Early versions did not support cancellation of in-flight requests.
+	 * Cancellation was added, but old servers would interpret the
+	 * cancellation message as a new request for the same RPC, which is
+	 * extremely dangerous.  (Usually, the arguments would be invalid, but
+	 * that's only the best-case outcome.)  We could try to avoid this by
+	 * avoiding specifying the RPC method name in the cancellation request.
+	 * Since the protocol was never well-documented, the correctness of this
+	 * approach is mainly determined by what other servers do with it.
+	 * Unfortunately, old servers are likely to handle it as an RPC method
+	 * of some kind, which triggers an unrelated bug: if old servers
+	 * received a request for a method that's not registered, they just
+	 * hang on it, resulting in a resource leak.
+	 *
+	 * Things are a little better on more modern versions of the fast
+	 * server, where if you send a cancellation request and the RPC is not
+	 * yet complete when the server processes it, then the server may stop
+	 * processing the RPC and send back an acknowledgment of sorts.
+	 * However, that doesn't mean the request did not complete, since the
+	 * implementation may not have responded to the cancellation.  And more
+	 * seriously, if the RPC isn't running, the server won't send back
+	 * anything, so we don't know whether we need to expect something or
+	 * not.
+	 *
+	 * To summarize: if we were to send a cancellation request, we would not
+	 * know whether to expect a response, and it's possible that we would
+	 * inadvertently invoke the same RPC again (which could be very
+	 * destructive) or leak resources in the remote server.  For now, we
+	 * punt and declare that request abandonment is purely a client-side
+	 * convenience that directs the client to stop doing anything with
+	 * messages for this request.  We won't actually ask the server to stop
+	 * doing anything.
+	 */
+	this.fc_abandoned[request.frq_msgid] = request;
+	this.requestFail(request, error);
+};
+
+/*
+ * Mark the given request as completed with the specified error.
+ */
+FastClient.prototype.requestFail = function (request, error)
+{
+	mod_assertplus.ok(request.frq_error === null);
+	mod_assertplus.object(error);
+
+	request.frq_error = new VError({
+	    'name': 'FastRequestError',
+	    'cause': error,
+	    'info': {
+		'rpcMsgid': request.frq_msgid,
+		'rpcMethod': request.frq_rpcmethod
+	    }
+	}, 'request failed');
+
+	this.requestComplete(request);
+
+	/*
+	 * We may be called in the context of a user action (e.g., if they
+	 * issued a request while the transport was disconnected, or if they're
+	 * abandoning a request).  Defer the 'error' event so they don't have to
+	 * deal with it being emitted synchronously during the execution of that
+	 * action.
+	 */
+	setImmediate(function () {
+		request.emit('error', request.frq_error);
+	});
+};
+
+/*
+ * Mark the given request as completed.
+ */
+FastClient.prototype.requestComplete = function (request)
+{
+	var msgid;
+	var self = this;
+
+	if (request.frq_timeout !== null) {
+		clearTimeout(request.frq_timeout);
+		request.frq_timeout = null;
+	}
+
+	this.fc_dtp.fire('rpc-done', function () {
+		var result, err;
+
+		result = {};
+		if (request.frq_error !== null) {
+			err = VError.cause(request.frq_error);
+			result['error'] = {
+			    'name': err ? err.name : '?',
+			    'message': err ? err.message : '?'
+			};
+		}
+
+		return ([
+		    self.fc_dtid,
+		    request.frq_msgid,
+		    result
+		]);
+	});
+
+	if (request.frq_error !== null) {
+		request.frq_log.debug(request.frq_error, 'rpc %s: failed',
+		    request.frq_rpcmethod);
+	} else {
+		request.frq_log.debug('rpc %s: done', request.frq_rpcmethod);
+	}
+
+	msgid = request.frq_msgid;
+	mod_assertplus.ok(!this.requestIsPending(request));
+	mod_assertplus.ok(this.fc_pending[msgid] == request);
+	delete (this.fc_pending[msgid]);
+	this.fc_nrpc_done++;
+
+	this.fc_recentrpc.push(request);
+	if (this.fc_recentrpc.length > this.fc_nrecent) {
+		this.fc_recentrpc.shift();
+	}
+};
+
+FastClient.prototype.onMessage = function (message)
+{
+	var request, abandoned, cause;
+
+	this.fc_log.trace(message, 'incoming message');
+
+	mod_assertplus.number(message.msgid,
+	    'decoder provided message with no msgid');
+	if (this.fc_pending.hasOwnProperty(message.msgid)) {
+		request = this.fc_pending[message.msgid];
+		mod_assertplus.ok(!request.frq_abandoned);
+		abandoned = false;
+	} else if (this.fc_abandoned.hasOwnProperty(message.msgid)) {
+		request = this.fc_abandoned[message.msgid];
+		mod_assertplus.ok(request.frq_abandoned);
+		abandoned = true;
+	} else {
+		this.fatalError(new VError({
+		    'name': 'FastProtocolError',
+		    'info': {
+			'fastReason': 'unknown_msgid',
+			'fastMsgid': message.msgid
+		    }
+		}, 'fast protocol: received message with unknown msgid %d',
+		    message.msgid));
+		return;
+	}
+
+	mod_assertplus.ok(!request.frq_done_graceful);
+	request.frq_last = message;
+
+	/*
+	 * "end" messages are always meaningful because they allow us to clean
+	 * up both normal and abandoned requests.
+	 */
+	if (message.status == mod_protocol.FP_STATUS_END) {
+		if (abandoned) {
+			request.frq_log.debug('cleaning up abandoned request');
+			delete (this.fc_abandoned[request.frq_msgid]);
+		} else {
+			/*
+			 * Although seldom used, it's technically allowed for
+			 * END messages to contain data.
+			 */
+			if (this.requestEmitData(request, message)) {
+				request.frq_done_graceful = true;
+				this.requestComplete(request);
+				request.end();
+			}
+		}
+
+		return;
+	}
+
+	/*
+	 * If the request was abandoned, then ignore all other messages.
+	 */
+	if (abandoned) {
+		request.frq_log.trace(
+		    'ignoring incoming message (request abandoned)');
+		request.frq_nignored++;
+		return;
+	}
+
+	/*
+	 * The only reasons we can have an error are because we never sent the
+	 * request out at all (which can never result in us getting here), we
+	 * abandoned the request (which we handled above), or the server already
+	 * sent us an error (in which case we also shouldn't be able to get
+	 * here).
+	 */
+	mod_assertplus.ok(request.frq_error === null);
+
+	if (message.status == mod_protocol.FP_STATUS_DATA) {
+		request.frq_ndata++;
+		this.requestEmitData(request, message);
+		return;
+	}
+
+	mod_assertplus.equal(message.status, mod_protocol.FP_STATUS_ERROR,
+	    'decoder emitted message with invalid status');
+	cause = new VError({
+	    'name': message.data.d.name,
+	    'info': message.data.d.info
+	}, '%s', message.data.d.message);
+	if (message.data.d.stack) {
+		cause.stack = message.data.d.stack;
+	}
+	/*
+	 * Context is reconstituted for historical reasons.
+	 */
+	cause.context = message.data.d.context;
+	request.frq_done_graceful = true;
+	this.requestFail(request, new VError({
+	    'name': 'FastServerError',
+	    'cause': cause
+	}, 'server error'));
+};
+
+/*
+ * Emits data contained in "message".  Returns true if there was no problem
+ * processing this data.  If there was an issue, then the request will be
+ * abandoned.
+ */
+FastClient.prototype.requestEmitData = function (request, message)
+{
+	var i, d;
+	var self = this;
+
+	mod_assertplus.ok(this.requestIsPending(request));
+
+	for (i = 0; i < message.data.d.length; i++) {
+		d = message.data.d[i];
+		if (d === null) {
+			this.requestAbandon(request, new VError({
+			    'name': 'FastProtocolError',
+			    'info': {
+				'rpcMsgid': request.frq_msgid,
+				'rpcMethod': request.frq_rpcmethod,
+			        'rpcMessage': message
+			    }
+			}, 'server sent "null" value'));
+			return (false);
+		} else {
+			this.fc_dtp.fire('rpc-data', function () {
+			    return ([
+				self.fc_dtid,
+				request.frq_msgid,
+				d
+			    ]);
+			});
+
+			request.push(d);
+		}
+	}
+
+	return (true);
+};
+
+FastClient.prototype.requestIsPending = function (request)
+{
+	mod_assertplus.object(request, 'request');
+	mod_assertplus.ok(request instanceof
+	    mod_client_request.FastClientRequest,
+	    'request is not a FastClientRequest');
+	return (!request.frq_done_graceful && request.frq_error === null);
+};
+
+
+/*
+ * Initialize the DTrace provider for the Fast client.
+ */
+function fastClientProviderInit()
+{
+	var dtp;
+
+	dtp = mod_dtrace.createDTraceProvider('fastclient');
+
+	/*
+	 * The rpc-start probe provides arguments:
+	 *
+	 *     arg0   int	Unique identifier for this client in this
+	 *     			process.
+	 *     arg1   int       Message identifier (request identifier).
+	 *     			This is only unique among active requests for a
+	 *     			single client.  See arg2 for a unique
+	 *     			identifier.
+	 *     arg2   string    RPC method name
+	 *     arg3   string    JSON object with properties for "rpcargs" and
+	 *     			"timeout" (optionally).  Additional properties
+	 *     			may be added here in the future.
+	 */
+	dtp.addProbe('rpc-start', 'int', 'int', 'char *', 'json');
+
+	/*
+	 * The rpc-data probe provides arguments:
+	 *
+	 *     arg0   int       Same as for rpc-start.
+	 *     arg1   int       Same as for rpc-start.
+	 *     arg2   string    JSON object describing received data.
+	 */
+	dtp.addProbe('rpc-data', 'int', 'int', 'json');
+
+	/*
+	 * The rpc-done probe provides arguments:
+	 *
+	 *     arg0   int       Same as for rpc-start.
+	 *     arg1   int       Same as for rpc-start.
+	 *     arg2   string    JSON object with properties for "error".
+	 *     			Additional properties may be added here in the
+	 *     			future.
+	 */
+	dtp.addProbe('rpc-done', 'int', 'int', 'json');
+	dtp.enable();
+
+	return (dtp);
+}
diff --git a/lib/fast_client_request.js b/lib/fast_client_request.js
new file mode 100644
index 0000000..17c7041
--- /dev/null
+++ b/lib/fast_client_request.js
@@ -0,0 +1,138 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/fast_client_request.js: represents a single RPC request from a fast
+ * client.  This object is the caller's handle on an individual request.
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_stream = require('stream');
+var mod_util = require('util');
+var VError = require('verror');
+
+var mod_protocol = require('./fast_protocol');
+
+/* Exported interface */
+exports.FastClientRequest = FastClientRequest;
+
+/*
+ * This object is constructed internally by the client interface when beginning
+ * an RPC request.  Arguments include:
+ *
+ *     client		a reference back to the FastClient.  Much of the
+ *     			functionality of this request is implemented in the
+ *     			client.
+ *
+ *     msgid		unique identifier for this request, scoped to this
+ *     			transport connection
+ *
+ *     rpcmethod	string name of the remote RPC method to invoke
+ *
+ *     rpcargs		array of arguments to pass to the remote RPC method
+ *
+ *     log		bunyan-style logger
+ *
+ * A FastClientRequest object is a client-side caller's handle for an
+ * outstanding RPC request.  From the caller's perspective, fast requests
+ * normally emit zero or more "data" messages followed by an "end" message.  An
+ * "error" message at any point along the way indicates that the request will
+ * receive no further messages.
+ *
+ * We model this as an object-mode stream.  'data' events are emitted (along
+ * with the data payload) for each incoming Fast 'data' message.  When the
+ * request completes gracefully, the stream ends (and emits 'end').  If any
+ * error occurs along the way, 'error' is emitted, and no further 'data' or
+ * 'end' events will be emitted.  Possible sources of error include:
+ *
+ *     o server-side error: the server explicitly and cleanly sends us an error
+ *
+ *     o transport or protocol error: we fail the request locally because of an
+ *       error maintaining contact with the server
+ *
+ *     o local abandonment: the caller abandoned the request
+ */
+function FastClientRequest(args)
+{
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.object(args.client, 'args.client');
+	mod_assertplus.number(args.msgid, 'args.msgid');
+	mod_assertplus.string(args.rpcmethod, 'args.rpcmethod');
+	mod_assertplus.array(args.rpcargs, 'args.rpcargs');
+	mod_assertplus.object(args.log, 'args.log');
+
+	/* rpc parameters */
+	this.frq_client = args.client;
+	this.frq_msgid = args.msgid;
+	this.frq_rpcmethod = args.rpcmethod;
+	this.frq_rpcargs = args.rpcargs;
+
+	/*
+	 * RPC state: most RPC requests are immediately transmitted (at least to
+	 * the underlying transport, even if that component ends up queueing
+	 * them).  Once that happens, they complete in one of three ways:
+	 *
+	 *     o gracefully, when the server sends an "end" or "error" message
+	 *
+	 *     o when the local caller issues an abandonment
+	 *
+	 *     o when there's an error on the transport, after which we do not
+	 *       expect to receive a graceful response
+	 *
+	 * The first two conditions are indicated by frq_done_graceful and
+	 * frq_abandoned.  frq_error is set whenever an error is encountered for
+	 * this request, which may be in any of these conditions.
+	 *
+	 * If the transport is disconnected when the user makes the initial
+	 * request, then we never bother to transmit the request.  We will set
+	 * frq_skip for this case, though only for debugging purposes.
+	 */
+	this.frq_done_graceful = false;	/* recvd "end" or "error" from server */
+	this.frq_abandoned = false;	/* abandoned locally */
+	this.frq_error = null;		/* error, if any */
+	this.frq_timeout = null;	/* timeout handle, if any */
+
+	/* helpers */
+	this.frq_log = args.log;	/* logger */
+
+	/* debugging state */
+	this.frq_skip = false;		/* RPC was skipped (no transport) */
+	this.frq_ndata = 0;		/* data messages emitted */
+	this.frq_nignored = 0;		/* count of ignored messages */
+	this.frq_last = null;		/* last message received */
+
+	/*
+	 * The high watermark is not really used because we do not support flow
+	 * control.
+	 */
+	mod_stream.PassThrough.call(this, {
+	    'objectMode': true,
+	    'highWaterMark': 16
+	});
+}
+
+mod_util.inherits(FastClientRequest, mod_stream.PassThrough);
+
+FastClientRequest.prototype.abandon = function ()
+{
+	/*
+	 * This method is just a convenience alias for the guts that happen in
+	 * the client's requestAbandon() method, where all the real work
+	 * happens.
+	 */
+	return (this.frq_client.requestAbandon(this, new VError({
+	    'name': 'FastRequestAbandonedError'
+	}, 'request abandoned by user')));
+};
+
+FastClientRequest.prototype.requestId = function ()
+{
+	return (this.frq_msgid);
+};
diff --git a/lib/fast_protocol.js b/lib/fast_protocol.js
new file mode 100644
index 0000000..d385c47
--- /dev/null
+++ b/lib/fast_protocol.js
@@ -0,0 +1,473 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/fast_protocol.js: fast protocol definitions
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_crc = require('crc');
+var mod_stream = require('stream');
+var mod_util = require('util');
+var VError = require('verror');
+
+/* Exported interface */
+exports.fastMessageEncode = fastMessageEncode;
+exports.FastMessageEncoder = FastMessageEncoder;
+exports.FastMessageDecoder = FastMessageDecoder;
+/* Protocol constants are exported below. */
+
+/*
+ * Protocol definition
+ *
+ * All fast protocol messages look like the following:
+ *
+ *    0x00   +---------+--------+---------+---------+
+ *           | VERSION | TYPE   | STATUS  | MSGID1  |
+ *    0x04   +---------+--------+---------+---------+
+ *           | MSGID2  | MSGID3 | MSGID4  | CRC1    |
+ *    0x08   +---------+--------+---------+---------+
+ *           | CRC2    | CRC3   | CRC4    | DLEN1   |
+ *    0x0c   +---------+--------+---------+---------+
+ *           | DLEN2   | DLEN3  | DLEN4   | DATA0   |
+ *    0x10   +---------+--------+---------+---------+
+ *           | DATAN...                             |
+ *           +---------+--------+---------+---------+
+ *
+ * VERSION   1-byte integer.  The only supported value is "1".
+ *
+ * TYPE      1-byte integer.  The only supported value is TYPE_JSON (0x1),
+ *           indicating that the data payload is an encoded JSON object.
+ *
+ * STATUS    1-byte integer.  The only supported values are:
+ *
+ *     STATUS_DATA  0x1  indicates a "data" message
+ *
+ *     STATUS_END   0x2  indicates an "end" message
+ *
+ *     STATUS_ERROR 0x3  indicates an "error" message
+ *
+ * MSGID1...MSGID4    4-byte big-endian unsigned integer, a unique identifier
+ *                    for this message
+ *
+ * CRC1...CRC4        4-byte big-endian unsigned integer representing the CRC16
+ *                    value of the data payload
+ *
+ * DLEN0...DLEN4      4-byte big-endian unsigned integer representing the number
+ *                    of bytes of data payload that follow
+ *
+ * DATA0...DATAN      Data payload.  This is a JSON-encoded object (for TYPE =
+ *                    TYPE_JSON).  The encoding length in bytes is given by the
+ *                    DLEN0...DLEN4 bytes.
+ *
+ * Due to historical bugs in node-crc, the CRC implementation used in version 1
+ * of the protocol is essentially incompatible with any CRC implementation other
+ * than the one provided by node-crc version 0.x.
+ */
+
+/*
+ * Message IDs: each Fast message has a message id, which is scoped to the Fast
+ * connection.  We allocate these sequentially from a circular 31-bit space.
+ */
+var FP_MSGID_MAX        = Math.pow(2, 31) - 1;
+exports.FP_MSGID_MAX    = FP_MSGID_MAX;
+
+/*
+ * Field offsets
+ */
+var FP_OFF_VERSION      = 0x0;
+var FP_OFF_TYPE         = FP_OFF_VERSION + 0x1;	/* 0x1 */
+var FP_OFF_STATUS       = FP_OFF_TYPE + 0x1;	/* 0x2 */
+var FP_OFF_MSGID        = FP_OFF_STATUS + 0x1;   /* 0x3 */
+var FP_OFF_CRC          = FP_OFF_MSGID + 0x4;	/* 0x7 */
+var FP_OFF_DATALEN      = FP_OFF_CRC + 0x4;	/* 0xb */
+var FP_OFF_DATA         = FP_OFF_DATALEN + 0x4;	/* 0xf */
+exports.FP_OFF_VERSION  = FP_OFF_VERSION;
+exports.FP_OFF_TYPE     = FP_OFF_TYPE;
+exports.FP_OFF_STATUS   = FP_OFF_STATUS;
+exports.FP_OFF_MSGID    = FP_OFF_MSGID;
+exports.FP_OFF_CRC      = FP_OFF_CRC;
+exports.FP_OFF_DATALEN  = FP_OFF_DATALEN;
+exports.FP_OFF_DATA     = FP_OFF_DATA;
+
+
+/* size (in bytes) of each message header */
+var FP_HEADER_SZ        = FP_OFF_DATA;		/* 0xf */
+exports.FP_HEADER_SZ    = FP_HEADER_SZ;
+
+/* possible values for the "status" byte */
+var FP_STATUS_DATA      = 0x1;
+var FP_STATUS_END       = 0x2;
+var FP_STATUS_ERROR     = 0x3;
+exports.FP_STATUS_DATA  = FP_STATUS_DATA;
+exports.FP_STATUS_END   = FP_STATUS_END;
+exports.FP_STATUS_ERROR = FP_STATUS_ERROR;
+
+/* possible values for the "type" byte */
+var FP_TYPE_JSON        = 0x1;
+exports.FP_TYPE_JSON    = FP_TYPE_JSON;
+
+/* possible values for the "version" byte */
+var FP_VERSION_1           = 0x1;
+var FP_VERSION_CURRENT     = FP_VERSION_1;
+exports.FP_VERSION_1       = FP_VERSION_1;
+exports.FP_VERSION_CURRENT = FP_VERSION_CURRENT;
+
+
+/*
+ * Encode a logical message for sending over the wire.  This requires the
+ * following named properties:
+ *
+ *     msgid    (number) message identifier -- see lib/fast.js
+ *
+ *     data     (object) represents message contents.  At this level, this
+ *			 can be any plain-old JavaScript object.
+ *
+ *     status   (number) message "status" (one of FP_STATUS_DATA, FP_STATUS_END,
+ *			 or FP_STATUS_ERROR).
+ *
+ * Failure to match these requirements is a programmer error that may result in
+ * a synchronously thrown exception that should not be caught.
+ */
+function fastMessageEncode(msg)
+{
+	var buffer, data_encoded, datalen, crc16;
+
+	mod_assertplus.object(msg, 'msg');
+	mod_assertplus.ok(typeof (msg.msgid) == 'number' &&
+	    Math.floor(msg.msgid) == msg.msgid &&
+	    msg.msgid >= 0 && msg.msgid <= FP_MSGID_MAX,
+	    'msg.msgid is not an integer between 0 and FP_MSGID_MAX');
+	mod_assertplus.object(msg.data, 'msg.data');
+	mod_assertplus.number(msg.status, 'msg.status');
+
+	switch (msg.status) {
+	case FP_STATUS_DATA:
+	case FP_STATUS_END:
+	case FP_STATUS_ERROR:
+		break;
+	default:
+		throw (new VError('unsupported fast message status'));
+	}
+
+	data_encoded = JSON.stringify(msg.data);
+	crc16 = mod_crc.crc16(data_encoded);
+	datalen = Buffer.byteLength(data_encoded);
+	buffer = new Buffer(FP_HEADER_SZ + datalen);
+	buffer.writeUInt8(FP_VERSION_CURRENT, FP_OFF_VERSION);
+	buffer.writeUInt8(FP_TYPE_JSON, FP_OFF_TYPE);
+	buffer.writeUInt8(msg.status, FP_OFF_STATUS);
+	buffer.writeUInt32BE(msg.msgid, FP_OFF_MSGID);
+	buffer.writeUInt32BE(crc16, FP_OFF_CRC);
+	buffer.writeUInt32BE(datalen, FP_OFF_DATALEN);
+	buffer.write(data_encoded, FP_OFF_DATA, datalen, 'utf8');
+	return (buffer);
+}
+
+/*
+ * Decode a fast message from a buffer that's known to contain a single,
+ * well-formed message.  All of the protocol fields are known to be valid (e.g.,
+ * version, type, status, and msgid) at this point, but the data has not been
+ * read, so the CRC has not been validated.
+ */
+function fastMessageDecode(header, buffer)
+{
+	var datalen, datastr, json, calc;
+
+	mod_assertplus.number(header.datalen, 'header.datalen');
+	datalen = header.datalen;
+	mod_assertplus.equal(buffer.length, FP_OFF_DATA + datalen);
+	datastr = buffer.toString('utf8', FP_OFF_DATA);
+	calc = mod_crc.crc16(datastr);
+
+	if (calc != header.crc) {
+		return (new VError({
+		    'name': 'FastProtocolError',
+		    'info': {
+			'fastReason': 'bad_crc',
+			'crcCalculated': calc,
+			'crcExpected': header.crc
+		    }
+		}, 'fast protocol: expected CRC %s, found %s',
+		    header.crc, calc));
+	}
+
+	try {
+		json = JSON.parse(datastr);
+	} catch (ex) {
+		return (new VError({
+		    'name': 'FastProtocolError',
+		    'cause': ex,
+		    'info': {
+			'fastReason': 'invalid_json'
+		    }
+		}, 'fast protocol: invalid JSON in "data"'));
+	}
+
+	if (typeof (json) != 'object' || json === null) {
+		return (new VError({
+		    'name': 'FastProtocolError',
+		    'info': {
+			'fastReason': 'bad_data'
+		    }
+		}, 'fast protocol: message data must be a non-null object'));
+	}
+
+	if ((header.status == FP_STATUS_DATA ||
+	    header.status == FP_STATUS_END) && !Array.isArray(json.d)) {
+		return (new VError({
+		    'name': 'FastProtocolError',
+		    'info': {
+			'fastReason': 'bad_data_d'
+		    }
+		}, 'fast protocol: data.d for DATA and END messages must be ' +
+		    'an array'));
+	}
+
+	if (header.status == FP_STATUS_ERROR &&
+	    (typeof (json.d) != 'object' || json.d === null ||
+	    typeof (json.d.name) != 'string' ||
+	    typeof (json.d.message) != 'string')) {
+		return (new VError({
+		    'name': 'FastProtocolError',
+		    'info': {
+			'fastReason': 'bad_error'
+		    }
+		}, 'fast protocol: data.d for ERROR messages must have name ' +
+		    'and message'));
+	}
+
+	return ({
+	    'status': header.status,
+	    'msgid': header.msgid,
+	    'data': json
+	});
+}
+
+/*
+ * Transform stream that takes logical messages and emits a buffer representing
+ * that message (for sending over the wire).
+ */
+function FastMessageEncoder()
+{
+	mod_stream.Transform.call(this, {
+	    'highWaterMark': 16,
+	    'objectMode': true
+	});
+}
+
+mod_util.inherits(FastMessageEncoder, mod_stream.Transform);
+
+FastMessageEncoder.prototype._transform = function (chunk, _, callback)
+{
+	this.push(fastMessageEncode(chunk));
+	setImmediate(callback);
+};
+
+
+/*
+ * Transform stream that takes bytes (via Buffer objects) and emits an object
+ * representing the encoded Fast message.
+ */
+function FastMessageDecoder()
+{
+	mod_stream.Transform.call(this, {
+	    'objectMode': true
+	});
+
+	/* current state */
+	this.md_buffer = null;		/* unparsed data */
+	this.md_havebytes = 0;		/* bytes of unparsed data */
+	this.md_done = false;		/* we've read end-of-stream */
+	this.md_error = null;		/* fatal error */
+	this.md_pushing = false;	/* currently calling push() */
+
+	/* current header */
+	this.md_version = null;
+	this.md_type = null;
+	this.md_status = null;
+	this.md_msgid = null;
+	this.md_crc = null;
+	this.md_datalen = null;
+
+	/* debug information */
+	this.md_nmessages = 0;
+	this.md_nbytes = 0;
+}
+
+mod_util.inherits(FastMessageDecoder, mod_stream.Transform);
+
+FastMessageDecoder.prototype._transform = function (chunk, _, callback)
+{
+	this.md_havebytes += chunk.length;
+
+	if (this.md_buffer === null) {
+		mod_assertplus.equal(this.md_havebytes, chunk.length);
+		this.md_buffer = chunk;
+	} else {
+		this.md_buffer = Buffer.concat(
+		    [ this.md_buffer, chunk ], this.md_havebytes);
+	}
+
+	this.md_nbytes += chunk.length;
+	this.decode(callback);
+};
+
+FastMessageDecoder.prototype._flush = function (callback)
+{
+	this.md_done = true;
+	this.decode(callback);
+};
+
+FastMessageDecoder.prototype.decode = function (callback)
+{
+	var buf, msg;
+
+	if (this.md_pushing) {
+		return;
+	}
+
+	mod_assertplus.ok(this.md_error === null);
+
+	while (this.md_havebytes >= FP_HEADER_SZ) {
+		buf = this.md_buffer;
+		mod_assertplus.equal(buf.length, this.md_havebytes);
+		mod_assertplus.ok(buf !== null);
+		mod_assertplus.ok(this.md_error === null);
+		mod_assertplus.ok(this.md_version === null);
+
+		this.md_version = buf.readUInt8(FP_OFF_VERSION);
+		if (this.md_version != FP_VERSION_CURRENT) {
+			this.md_error = new VError({
+			    'name': 'FastProtocolError',
+			    'info': {
+				'fastReason': 'unsupported_version',
+				'foundVersion': this.md_version
+			    }
+			}, 'fast protocol: unsupported version %d',
+			    this.md_version);
+			break;
+		}
+
+		this.md_type = buf.readUInt8(FP_OFF_TYPE);
+		if (this.md_type != FP_TYPE_JSON) {
+			this.md_error = new VError({
+			    'name': 'FastProtocolError',
+			    'info': {
+			        'fastReason': 'unsupported_type',
+				'foundType': this.md_type
+			    }
+			}, 'fast protocol: unsupported type 0x%x',
+			    this.md_type);
+			break;
+		}
+
+		this.md_status = buf.readUInt8(FP_OFF_STATUS);
+		switch (this.md_status) {
+		case FP_STATUS_DATA:
+		case FP_STATUS_END:
+		case FP_STATUS_ERROR:
+			break;
+		default:
+			this.md_error = new VError({
+			    'name': 'FastProtocolError',
+			    'info': {
+			        'fastReason': 'unsupported_status',
+				'foundStatus': this.md_status
+			    }
+			}, 'fast protocol: unsupported status 0x%x',
+			    this.md_status);
+			break;
+		}
+
+		if (this.md_error !== null) {
+			break;
+		}
+
+		this.md_msgid = buf.readUInt32BE(FP_OFF_MSGID);
+		if (this.md_msgid < 0 || this.md_msgid > FP_MSGID_MAX) {
+			this.md_error = new VError({
+			    'name': 'FastProtocolError',
+			    'info': {
+				'fastReason': 'invalid_msgid',
+				'foundMsgid': this.md_msgid
+			    }
+			}, 'fast protocol: invalid msgid %s', this.md_msgid);
+			break;
+		}
+
+		this.md_crc = buf.readUInt32BE(FP_OFF_CRC);
+		this.md_datalen = buf.readUInt32BE(FP_OFF_DATALEN);
+
+		if (this.md_havebytes < FP_HEADER_SZ + this.md_datalen) {
+			/*
+			 * We don't have enough bytes to continue.  Stop now.
+			 * We'll end up re-parsing the header again when we have
+			 * more data.  If that turns out to be expensive, we can
+			 * rework this code to keep track of where we were.
+			 */
+			this.md_version = null;
+			this.md_type = null;
+			this.md_status = null;
+			this.md_msgid = null;
+			this.md_crc = null;
+			this.md_datalen = null;
+			break;
+		}
+
+		/*
+		 * We have a complete message.  Consume it and update our buffer
+		 * state.
+		 */
+		buf = this.md_buffer.slice(0, FP_HEADER_SZ + this.md_datalen);
+		this.md_buffer = this.md_buffer.slice(
+		    FP_HEADER_SZ + this.md_datalen);
+		this.md_havebytes -= buf.length;
+		msg = fastMessageDecode({
+		    'version': this.md_version,
+		    'type': this.md_type,
+		    'status': this.md_status,
+		    'msgid': this.md_msgid,
+		    'crc': this.md_crc,
+		    'datalen': this.md_datalen
+		}, buf);
+		if (msg instanceof Error) {
+			this.md_error = msg;
+			break;
+		}
+
+		this.md_version = null;
+		this.md_type = null;
+		this.md_status = null;
+		this.md_msgid = null;
+		this.md_crc = null;
+		this.md_datalen = null;
+
+		this.md_pushing = true;
+		this.push(msg);
+		this.md_pushing = false;
+		this.md_nmessages++;
+	}
+
+	if (this.md_error === null && this.md_havebytes > 0 && this.md_done) {
+		this.md_error = new VError({
+		    'name': 'FastProtocolError',
+		    'info': {
+			'fastReason': 'incomplete_message'
+		    }
+		}, 'fast protocol: incomplete message at end-of-stream');
+	}
+
+	if (this.md_error !== null) {
+		setImmediate(callback, this.md_error);
+	} else {
+		setImmediate(callback);
+	}
+};
diff --git a/lib/fast_server.js b/lib/fast_server.js
new file mode 100644
index 0000000..7013da3
--- /dev/null
+++ b/lib/fast_server.js
@@ -0,0 +1,1298 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/fast_server.js: public node-fast server interface
+ *
+ * The public interface for this module is the FastServer class, which takes a
+ * server socket and manages connections to clients that connect to the server.
+ * Callers register RPC method handlers with the server, and their handler
+ * functions are invoked when RPC requests are received for the registered
+ * method.  RPC handlers are functions that take a single argument, an RPC
+ * context, through which the handler can access the RPC arguments and send data
+ * back to the client.
+ *
+ *
+ * Flow control
+ *
+ * The implementation of the server is structured primarily into object-mode
+ * streams to support Node's built-in flow control.  This is only of limited
+ * utility at this time, since the client does not support per-request flow
+ * control.  However, if a client is itself reading slowly, then this mechanism
+ * allows the server manage backpressure appropriately.
+ *
+ * The RPC context argument provided to RPC method handlers is itself an
+ * object-mode stream.  Objects written to the stream are sent to the client.
+ * When the stream is ended, an "end" message is written to the client, which
+ * signifies the successfuly completion of the RPC call.  The stream pipeline
+ * from the RPC context to the client socket fully supports flow control, so the
+ * stream will used a bounded amount of memory as long as the RPC method
+ * respects Node's flow-control semantics (e.g., stops writing to the stream
+ * when write() returns false).  The pipeline looks like this:
+ *
+ *     RPC request context    (provided as argument to RPC method handlers)
+ *         |
+ *         | (pipe: objects)
+ *         v
+ *     FastRpcResponseEncoder (wraps objects in Fast "DATA" messages, and
+ *         |                  terminates the stream with an "END" message)
+ *         | (pipe: objects)
+ *         v
+ *     FastMessageEncoder     (serializes logical Fast messages into buffers)
+ *         |
+ *         | (pipe: bytes)
+ *         v
+ *     Client socket          (usually a net.Socket object for TCP)
+ *
+ * Of course, many of these pipelines may be piped to the same net.Socket
+ * object.  This has an unexpected, unfortunate scaling limitation: the
+ * completion of a pipe() operation causes Node to remove event listeners, and
+ * EventEmitter.removeListener() is O(N), where N is the number of listeners for
+ * the same event.  As a result, if a client maintains N concurrent requests,
+ * then completion of each request will run into this O(N) step.  This results
+ * in an O(N^2) factor in the overall time to complete N requests.  The Node API
+ * does not seem fixable.  We could implement a tree of EventEmitters that
+ * funnel into the socket, but it's not clear at this point that this
+ * considertaion is worthwhile.  In practice, Fast servers are more likely to
+ * see many clients making a small number of requests each rather than a small
+ * number of clients making a large number of requests each, and this deployment
+ * model is recommended to avoid this scaling limiter.
+ *
+ * Flow control is less well-supported on the receiving side because it's less
+ * clear what the source of backpressure should be.  The pipeline looks like
+ * this:
+ *
+ *    +---------------------------------------------------------------------+
+ *    | Per-connection pipeline                                             |
+ *    | -----------------------                                             |
+ *    |                                                                     |
+ *    |    Client socket             (usually a net.Socket object for TCP)  |
+ *    |        |                                                            |
+ *    |        | (pipe: bytes)                                              |
+ *    |        v                                                            |
+ *    |    FastMessageDecoder        (unmarshals Fast messages from bytes   |
+ *    |        |                     received on the socket)                |
+ *    |        | (pipe: objects)                                            |
+ *    |        v                                                            |
+ *    |    FastRpcConnectionDecoder  (tags incoming Fast messages with a    |
+ *    |        |                     connection identifier for session      |
+ *    |        | (pipe: objects)     tracking)                              |
+ *    |        |                                                            |
+ *    +------- | -----------------------------------------------------------+
+ *             |
+ *             v
+ *       FastMessageHandler          (one for the entire server that invokes
+ *                                   server.onMessage() for each message)
+ *
+ * Since there are many connections and one FastMessageHandler for the server,
+ * the whole picture looks like this:
+ *
+ *                    Connection  Connection  Connection
+ *                     pipeline    pipeline    pipeline
+ *                         |           |           |
+ *                   ...   |   ...     |   ...     | ...
+ *                         |           |           |
+ *                         v           v           v
+ *                       +---------------------------+
+ *                       |    FastMessageHandler     |
+ *                       +---------------------------+
+ *                                     |
+ *                                     v
+ *                             server.onMessage()
+ *
+ * The FastMessageHandler currently provides no backpressure.  If desired, a
+ * a simple throttle could flow-control the entire pipeline based on concurrent
+ * outstanding RPC requests.  A more complex governor could look at the the
+ * count of requests per connection and prioritize some notion of fairness among
+ * them.  As a result of the lack of flow control here, it's possible for any
+ * client to overwhelm the server by blasting messages to it; however, because
+ * the intended deployment is not a byzantine environment, this issue is not
+ * considered a priority for future work.
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_dtrace = require('dtrace-provider');
+var mod_events = require('events');
+var mod_jsprim = require('jsprim');
+var mod_microtime = require('microtime');
+var mod_stream = require('stream');
+var mod_util = require('util');
+var VError = require('verror');
+
+var mod_protocol = require('./fast_protocol');
+var mod_subr = require('./subr');
+
+exports.FastServer = FastServer;
+
+/*
+ * This maximum is chosen pretty arbitrarily.
+ */
+var FS_MAX_CONNID = (1 << 30);
+
+/*
+ * There's one DTrace provider for all servers using this copy of this module.
+ */
+var fastServerProvider = null;
+
+/*
+ * We have one counter for the number of servers in this process.  This is a
+ * true JavaScript global.  See the note in lib/fast_client.js.
+ */
+/* jsl:declare fastNservers */
+fastNservers = 0;
+
+/*
+ * Instantiate a new server for handling RPC requests made from remote Fast
+ * clients.  This server does not manage the underlying server socket.  That's
+ * the responsibility of the caller.
+ *
+ * Named arguments:
+ *
+ *     log		bunyan-style logger
+ *
+ *     server		server object that emits 'connection' events
+ *
+ * Use the server by invoking the registerRpcMethod() method to register
+ * handlers for named RPC methods.
+ */
+function FastServer(args)
+{
+	var self = this;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.object(args.log, 'args.log');
+	mod_assertplus.object(args.server, 'args.server');
+
+	this.fs_log = args.log;		/* logger */
+	this.fs_server = args.server;	/* server socket */
+	this.fs_handlers = {};		/* registered handlers, by name */
+	this.fs_conns = {};		/* active connections */
+	this.fs_msghandler = new FastMessageHandler({
+	    'server': this
+	});
+	/*
+	 * See the comments below on use of setMaxListeners().
+	 */
+	this.fs_msghandler.setMaxListeners(0);
+	this.fs_connallocator = new mod_subr.IdAllocator({
+	    'min': 1,
+	    'max': FS_MAX_CONNID,
+	    'isAllocated': function isConnIdAllocated(id) {
+		return (self.fs_conns.hasOwnProperty(id));
+	    }
+	});
+	this.fs_closed = false;		/* server is shutting down */
+
+	this.fs_server.on('connection',
+	    function onConnection(sock) { self.connCreate(sock); });
+
+	this.fs_nignored_noconn = 0;	/* count of msgs ignored: no conn */
+	this.fs_nignored_badconn = 0;	/* count of msgs ignored: bad conn */
+	this.fs_nignored_aborts = 0;	/* count of msgs ignored: aborts */
+	this.fs_nconnections_created = 0;	/* count of conns created */
+	this.fs_nrequests_started = 0;		/* count of reqs started */
+	this.fs_nrequests_completed = 0;	/* count of reqs completed */
+	this.fs_nrequests_failed = 0;		/* count of reqs failed */
+
+	if (fastServerProvider === null) {
+		fastServerProvider = fastServerProviderInit();
+	}
+
+	mod_assertplus.object(fastServerProvider);
+	this.fs_dtid = fastNservers++;
+	this.fs_dtp = fastServerProvider;
+}
+
+/* public methods */
+
+FastServer.prototype.registerRpcMethod = function (args)
+{
+	var rpcmethod, handler;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.string(args.rpcmethod, 'args.rpcmethod');
+	mod_assertplus.func(args.rpchandler, 'args.rpchandler');
+
+	rpcmethod = args.rpcmethod;
+	handler = args.rpchandler;
+	mod_assertplus.ok(!this.fs_handlers.hasOwnProperty(rpcmethod),
+	    'duplicate handler registered for method "' + rpcmethod + '"');
+
+	this.fs_log.info({ 'rpcmethod': rpcmethod }, 'registered RPC method');
+	this.fs_handlers[rpcmethod] = new FastRpcHandler({
+	    'rpcmethod': rpcmethod,
+	    'rpchandler': handler
+	});
+};
+
+FastServer.prototype.close = function ()
+{
+	var error, connid;
+
+	mod_assertplus.ok(arguments.length === 0,
+	    'close() accepts no arguments');
+
+	if (this.fs_closed) {
+		this.fs_log.warn('close() called while already shutting down');
+		return;
+	}
+
+	this.fs_log.info('shutting down');
+	this.fs_closed = true;
+	error = new VError('server is shutting down');
+	for (connid in this.fs_conns) {
+		this.connTerminate(this.fs_conns[connid], error);
+	}
+};
+
+/*
+ * Public methods for exposing debugging data over kang.
+ *
+ * Over kang, we expose basic statistics about the server (suitable for
+ * real-time monitoring of basic activity), as well as objects of types:
+ *
+ *     fastconnection     describes a client that's currently connected,
+ *			  including local and remote address information
+ *			  and basic activity stats
+ *
+ *     fastrequest	  describes a request that's currently outstanding,
+ *			  including which connection received it, how long it's
+ *			  been running, and what state it's in
+ */
+
+FastServer.prototype.kangStats = function ()
+{
+	var rv = {};
+	rv['nConnectionsActive'] = Object.keys(this.fs_conns).length;
+	rv['nIgnoredMessagesNoConn'] = this.fs_nignored_noconn;
+	rv['nIgnoredMessagesBadConn'] = this.fs_nignored_badconn;
+	rv['nIgnoredMessagesAborts'] = this.fs_nignored_aborts;
+	rv['nConnectionsCreated'] = this.fs_nconnections_created;
+	rv['nRequestsStarted'] = this.fs_nrequests_started;
+	rv['nRequestsCompleted'] = this.fs_nrequests_completed;
+	rv['nRequestsFailed'] = this.fs_nrequests_failed;
+	return (rv);
+};
+
+FastServer.prototype.kangListTypes = function ()
+{
+	return ([ 'fastconnection', 'fastrequest' ]);
+};
+
+FastServer.prototype.kangListObjects = function (type)
+{
+	if (type == 'fastconnection') {
+		return (Object.keys(this.fs_conns));
+	}
+
+	var rv = [];
+	mod_assertplus.equal(type, 'fastrequest');
+	mod_jsprim.forEachKey(this.fs_conns, function (cid, conn) {
+		Object.keys(conn.fc_pending).map(function (msgid) {
+			rv.push(cid + '/' + msgid);
+		});
+	});
+
+	return (rv);
+};
+
+FastServer.prototype.kangGetObject = function (type, id)
+{
+	var conn, rv;
+	var parts, req;
+
+	if (type == 'fastconnection') {
+		conn = this.fs_conns[id];
+		rv = {
+		    'connid': conn.fc_connid,
+		    'addrinfo': conn.fc_addrinfo,
+		    'nStarted': conn.fc_nstarted,
+		    'nCompleted': conn.fc_ncompleted,
+		    'nFailed': conn.fc_nfailed,
+		    'draining': conn.fc_draining,
+		    'errorSocket': conn.fc_socket_error,
+		    'errorServer': conn.fc_server_error,
+		    'timeAccepted': conn.fc_taccepted.toISOString()
+		};
+		return (rv);
+	}
+
+	mod_assertplus.equal(type, 'fastrequest');
+	parts = id.split('/');
+	mod_assertplus.equal(parts.length, 2);
+	conn = this.fs_conns[parts[0]];
+	req = conn.fc_pending[parts[1]];
+	rv = {
+	    'connid': parts[0],
+	    'msgid': parts[1],
+	    'rpcmethod': req.fsr_rpcmethod,
+	    'rpcargs': req.fsr_rpcargs,
+	    'state': req.fsr_state,
+	    'error': req.fsr_error,
+	    'blackholed': req.fsr_blackhole !== null,
+	    'timeStarted': req.fsr_tstarted.toISOString()
+	};
+	return (rv);
+};
+
+/* private methods */
+
+/*
+ * Connection lifecycle
+ *
+ * Connections are created when the underlying Server (usually either a TCP or
+ * UDS server) emits a 'connection' event.  In connCreate(), we set up data
+ * structures to manage a FastRpcConnection atop the new socket.
+ *
+ * Connections remain operational until they are abandoned for one of three
+ * reasons:
+ *
+ *     o We read end-of-stream from the socket.  This is a graceful termination
+ *       that we might expect when the remote side is shutting down after
+ *       completing all of its RPC requests.
+ *
+ *     o We see an 'error' event on the socket.  This is an ungraceful
+ *       termination of the connection that we might expect in the face of a
+ *       network error.
+ *
+ *     o We proactively terminate the connection because we've read an invalid
+ *       Fast protocol message or something else that's confused us as to the
+ *       state of the connection, or we're shutting down the server.
+ *
+ * This is managed through the following call chain:
+ *
+ *                        connection arrives
+ *                                |
+ *                                v
+ *            connCreate() sets up the FastRpcConnection
+ *                                |
+ *                                v
+ *                       normal operation
+ *                          |     |    |
+ *        +-----------------+     |    +---------------------+
+ *        |                       |                          |
+ *        | onConnectionEnd():    | onConnectionError():     | connTerminate():
+ *        | end-of-stream read    | socket error             | protocol error
+ *        |                       |                          | or server
+ *        |                       | connDisconnectRequests() | shutdown
+ *        |                       |                          |
+ *        +---------------------> + <------------------------+
+ *                                |
+ *                                v
+ *                         connDrain():
+ *                         wait for pending requests to complete
+ *                                |
+ *                                v
+ *                         connection removed
+ */
+
+FastServer.prototype.connCreate = function (sock)
+{
+	var self = this;
+	var cid, fastconn;
+
+	cid = this.allocConnectionId(sock);
+	mod_assertplus.ok(cid);
+	mod_assertplus.ok(!this.fs_conns.hasOwnProperty(cid));
+	fastconn = new FastRpcConnection({
+	    'connId': cid,
+	    'socket': sock,
+	    'log': this.fs_log
+	});
+
+	this.fs_nconnections_created++;
+	this.fs_conns[cid] = fastconn;
+	this.fs_dtp.fire('conn-create', function () {
+	    return ([ self.fs_dtid, cid, fastconn.fc_addrinfo.label ]);
+	});
+	fastconn.fc_taccepted = new Date();
+	fastconn.fc_ckddecoder.pipe(this.fs_msghandler, { 'end': false });
+	fastconn.fc_log.info('connection received');
+
+	sock.on('end', function onConnectionEnd() {
+		self.onConnectionEnd(cid, fastconn);
+	});
+
+	sock.on('error', function onConnectionError(err) {
+		self.onConnectionError(cid, fastconn, err);
+	});
+
+	/*
+	 * We shouldn't get here if the server is closing because the caller
+	 * should have shut down the server socket.  If we wind up seeing a
+	 * queued connection, terminate it immediately.
+	 */
+	if (this.fs_closed) {
+		this.fs_log.warn('unexpected connection after server shutdown');
+		this.connTerminate(new VError('server is shutting down'));
+	}
+};
+
+/*
+ * Remove this connection because we've read end-of-stream.  We will wait for
+ * pending requests to complete before actually removing the connection.
+ */
+FastServer.prototype.onConnectionEnd = function (cid, conn)
+{
+	mod_assertplus.ok(conn instanceof FastRpcConnection);
+	mod_assertplus.ok(this.fs_conns.hasOwnProperty(cid));
+	mod_assertplus.ok(this.fs_conns[cid] == conn);
+
+	/*
+	 * Due to Node issue 6083, it's possible to see an "end" event after
+	 * having previously seen an "error" event.  Ignore such events.
+	 */
+	if (conn.fc_socket_error !== null) {
+		conn.fc_log.debug('ignoring end-of-stream after error');
+	} else {
+		conn.fc_ended = true;
+		conn.fc_log.debug('end of input');
+		this.connDrain(conn);
+	}
+};
+
+/*
+ * Abandon this connection because we've seen a socket error.  This can happen
+ * after the connection has already read end-of-stream or experienced a
+ * protocol-level error.
+ */
+FastServer.prototype.onConnectionError = function (cid, conn, err)
+{
+	mod_assertplus.ok(conn instanceof FastRpcConnection);
+	mod_assertplus.ok(err instanceof Error);
+	mod_assertplus.ok(this.fs_conns.hasOwnProperty(cid));
+	mod_assertplus.ok(this.fs_conns[cid] == conn);
+	mod_assertplus.ok(conn.fc_socket_error === null);
+	conn.fc_socket_error = err;
+	conn.fc_log.warn(err, 'socket error');
+
+	/*
+	 * If we've already seen a server error, then we're already tearing down
+	 * the connection.
+	 */
+	if (conn.fc_server_error === null) {
+		this.connDisconnectRequests(conn);
+		this.connDrain(conn);
+	}
+};
+
+/*
+ * Allocate an internal connection id.  Callers will use this as a string (as an
+ * object property name), and callers assume that it cannot be falsey.
+ */
+FastServer.prototype.allocConnectionId = function ()
+{
+	return (this.fs_connallocator.alloc());
+};
+
+/*
+ * Terminate this connection because of a protocol error or a server shutdown.
+ * We do not allow existing requests to complete for this case.
+ */
+FastServer.prototype.connTerminate = function (conn, err)
+{
+	mod_assertplus.ok(conn instanceof FastRpcConnection);
+	mod_assertplus.ok(err instanceof Error);
+
+	if (conn.fc_server_error === null) {
+		conn.fc_log.warn(err, 'gracefully terminating connection');
+		conn.fc_server_error = err;
+		this.connDisconnectRequests(conn);
+		this.connDrain(conn);
+	} else {
+		conn.fc_log.warn(err, 'already terminating connection');
+	}
+};
+
+/*
+ * Disconnect all requests associated with this connection from the connection
+ * itself, generally as a result of a fatal error on the connection.
+ */
+FastServer.prototype.connDisconnectRequests = function (conn)
+{
+	var msgid;
+
+	for (msgid in conn.fc_pending) {
+		this.requestDisconnect(conn.fc_pending[msgid]);
+	}
+
+	conn.fc_socket.destroy();
+};
+
+/*
+ * Wait for outstanding requests to complete and then remove this connection
+ * from the server.
+ */
+FastServer.prototype.connDrain = function (conn)
+{
+	var self = this;
+
+	mod_assertplus.ok(this.fs_conns[conn.fc_connid] == conn);
+
+	if (!mod_jsprim.isEmpty(conn.fc_pending)) {
+		mod_assertplus.ok(conn.fc_nstarted > conn.fc_ncompleted);
+		conn.fc_log.debug({
+		    'remaining': conn.fc_nstarted - conn.fc_ncompleted
+		}, 'waiting for request drain');
+		conn.fc_draining = true;
+	} else {
+		mod_assertplus.equal(conn.fc_nstarted, conn.fc_ncompleted);
+		conn.fc_log.info('removing drained connection');
+		delete (this.fs_conns[conn.fc_connid]);
+		this.fs_dtp.fire('conn-destroy', function () {
+		    return ([ self.fs_dtid, conn.fc_connid ]);
+		});
+
+		/*
+		 * As long as we didn't see a socket error and didn't already
+		 * terminate the socket, destroy the socket.  We could try to
+		 * end it gracefully, but we don't actually want to wait for the
+		 * client to shut it down cleanly.  If we already saw an error,
+		 * then there's nothing else to do.
+		 */
+		if (conn.fc_socket_error === null &&
+		    conn.fc_server_error === null) {
+			conn.fc_socket.destroy();
+		}
+	}
+};
+
+
+/*
+ * Message handling
+ *
+ * The only message we actually expect from clients is a DATA message, which
+ * represents an RPC call.  This function handles those messages and either
+ * ignores or issues appropriate errors for other kinds of messages.
+ */
+
+FastServer.prototype.onMessage = function (message)
+{
+	var connid, conn;
+	var msgid, req;
+	var handler, handlerfunc;
+	var self = this;
+
+	connid = message.connId;
+	mod_assertplus.ok(connid);
+
+	if (!this.fs_conns.hasOwnProperty(connid)) {
+		/*
+		 * This should only be possible if there were messages queued up
+		 * from a connection that has since been destroyed.
+		 */
+		this.fs_log.warn({
+		    'fastMessage': message
+		}, 'dropping message from unknown connection');
+		this.fs_nignored_noconn++;
+		return;
+	}
+
+	conn = this.fs_conns[connid];
+	if (conn.fc_ended || conn.fc_socket_error !== null) {
+		this.fs_log.warn({
+		    'fastMessage': message
+		}, 'dropping message from abandoned connection');
+		this.fs_nignored_badconn++;
+		return;
+	}
+
+	if (message.status === mod_protocol.FP_STATUS_END) {
+		/*
+		 * There's no reason clients should ever send us an "end" event.
+		 */
+		this.connTerminate(conn, new VError({
+		    'name': 'FastProtocolError',
+		    'info': {
+			'fastReason': 'unexpected_status'
+		    }
+		}, 'unexpected END event from client'));
+		return;
+	}
+
+	msgid = message.msgid;
+	if (message.status === mod_protocol.FP_STATUS_ERROR) {
+		/*
+		 * Intermediate versions of node-fast would send ERROR messages
+		 * to request RPC cancellation.  We don't support this.  See the
+		 * notes inside lib/fast_client.js for details on why.  Such
+		 * clients may expect a response from us in the form of an ERROR
+		 * message, but we just let the RPC complete normally.  After
+		 * all, because of the inherent race between receiving the abort
+		 * and completing the RPC, the client has to handle this
+		 * possibility anyway.
+		 */
+		this.fs_log.warn({
+		    'msgid': msgid
+		}, 'ignoring request to abort RPC (not supported)');
+		this.fs_nignored_aborts++;
+		return;
+	}
+
+	mod_assertplus.equal(message.status, mod_protocol.FP_STATUS_DATA);
+	if (conn.fc_pending.hasOwnProperty(msgid)) {
+		this.connTerminate(conn, new VError({
+		    'name': 'FastProtocolError',
+		    'info': {
+			'fastReason': 'duplicate_msgid',
+			'rpcMsgid': msgid
+		    }
+		}, 'client attempted to re-use msgid'));
+		return;
+	}
+
+	/*
+	 * The message decoder only validates the Fast message and that the
+	 * payload in the message is a valid, non-null JSON object.  Here, we
+	 * validate the details of the payload.
+	 */
+	conn.fc_nstarted++;
+	this.fs_nrequests_started++;
+	req = new FastRpcServerRequest({
+	    'server': this,
+	    'fastMessage': message,
+	    'fastConn': conn,
+	    'log': conn.fc_log.child({ 'msgid': message.msgid }, true)
+	});
+	conn.fc_pending[req.fsr_msgid] = req;
+	req.fsr_tstarted = new Date();
+
+	mod_assertplus.equal(typeof (message.data), 'object');
+	mod_assertplus.ok(message.data !== null);
+	if (!message.data.m || !message.data.m.name ||
+	    typeof (message.data.m.name) != 'string' ||
+	    !message.data.d || !Array.isArray(message.data.d)) {
+		this.requestFail(req, new VError({
+		    'name': 'FastError',
+		    'info': {
+			'fastReason': 'bad_data',
+			'rpcMsgid': message.msgid,
+			'rpcMessage': message
+		    }
+		}, 'RPC request is not well-formed'));
+		return;
+	}
+
+	req.fsr_rpcmethod = message.data.m.name;
+	req.fsr_rpcargs = message.data.d;
+	if (!this.fs_handlers.hasOwnProperty(req.fsr_rpcmethod)) {
+		this.requestFail(req, new VError({
+		    'name': 'FastError',
+		    'info': {
+			'fastReason': 'bad_method',
+			'rpcMethod': req.fsr_rpcmethod,
+			'rpcMsgid': message.msgid
+		    }
+		}, 'unsupported RPC method: "%s"', req.fsr_rpcmethod));
+		return;
+	}
+
+
+	handler = this.fs_handlers[req.fsr_rpcmethod];
+	handler.fh_nstarted++;
+	handlerfunc = handler.fh_handler;
+	req.fsr_handler = handler;
+
+	/*
+	 * We skip the FR_S_QUEUED state because we do not currently limit
+	 * request concurrency.
+	 */
+	req.fsr_state = FR_S_RUNNING;
+	req.fsr_encoder.pipe(conn.fc_msgencoder, { 'end': false });
+	req.fsr_docomplete = function () { self.requestComplete(req); };
+	req.fsr_encoder.on('end', req.fsr_docomplete);
+	req.fsr_log.debug('request started');
+	this.fs_dtp.fire('rpc-start', function () {
+		return ([ self.fs_dtid, conn.fc_connid, req.fsr_msgid,
+		    req.fsr_rpcmethod ]);
+	});
+	handlerfunc(req.fsr_context);
+};
+
+/*
+ * Request lifecycle
+ *
+ * Requests are created via server.onMessage() and then advance through the
+ * following state machine:
+ *
+ *        +------------- FR_S_INIT -------------+
+ *        |                                     |
+ *        | validation okay                     |
+ *        v                                     | validation failed
+ *     FR_S_QUEUED                              | (invalid or missing method
+ *        |                                     | name, missing arguments, etc.)
+ *        | request handler invoked             |
+ *        v                                     |
+ *     FR_S_RUNNING                             |
+ *        |                                     |
+ *        | request handler ends stream or      |
+ *        | invokes stream.fail(error)          |
+ *        |                                     |
+ *        +----------> FR_S_COMPLETE <----------+
+ *
+ * There are two paths for reaching FR_S_COMPLETE:
+ *
+ *     - normal termination (handler ends the stream): server.requestComplete()
+ *
+ *     - graceful error (handler invokes fail(error)): server.requestFail()
+ *
+ * In both cases, server.requestCleanup() is invoked to finish processing the
+ * request.
+ */
+
+var FR_S_INIT     = 'INIT';
+var FR_S_QUEUED   = 'QUEUED';
+var FR_S_RUNNING  = 'RUNNING';
+var FR_S_COMPLETE = 'COMPLETE';
+
+/*
+ * Fail the given RPC request with the specified error.  This entry point is
+ * invoked by RPC implementors returning an error.
+ */
+FastServer.prototype.requestFail = function (request, error)
+{
+	mod_assertplus.ok(request instanceof FastRpcServerRequest);
+	mod_assertplus.ok(error instanceof Error,
+	    'failure must be represented as an Error instance');
+
+	request.fsr_error = error;
+	request.fsr_state = FR_S_COMPLETE;
+	request.fsr_log.debug(error, 'request failed');
+
+	request.fsr_conn.fc_msgencoder.write(requestMakeMessage(
+	    request, mod_protocol.FP_STATUS_ERROR, error));
+	this.requestCleanup(request);
+};
+
+/*
+ * Mark the given RPC request having completed successfully.  This is implicitly
+ * invoked by RPC implementors when they end their output stream.
+ */
+FastServer.prototype.requestComplete = function (request)
+{
+	mod_assertplus.equal(request.fsr_state, FR_S_RUNNING);
+	request.fsr_state = FR_S_COMPLETE;
+	request.fsr_log.debug('request completed normally');
+	this.requestCleanup(request);
+};
+
+/*
+ * Disconnect this request from the underlying connection, usually because the
+ * connection has failed.  We do not have a great way to signal cancellation to
+ * the RPC method handler, so we allow the request to complete and ignore any
+ * data sent.  This should not be a big deal, since Fast RPC requests are
+ * intended to be very bounded in size anyway.
+ */
+FastServer.prototype.requestDisconnect = function (request)
+{
+	mod_assertplus.ok(request instanceof FastRpcServerRequest);
+
+	if (request.fsr_state != FR_S_RUNNING) {
+		mod_assertplus.equal(request.fsr_state, FR_S_COMPLETE);
+		return;
+	}
+
+	mod_assertplus.ok(request.fsr_error === null);
+	mod_assertplus.ok(request.fsr_blackhole === null);
+	request.fsr_log.info('disconnecting request');
+	request.fsr_context.unpipe(request.fsr_encoder);
+	request.fsr_encoder.unpipe(request.fsr_conn.fc_msgencoder);
+	request.fsr_encoder.removeListener('end', request.fsr_docomplete);
+
+	request.fsr_blackhole = new NullSink();
+	request.fsr_context.pipe(request.fsr_blackhole);
+	request.fsr_blackhole.on('finish', request.fsr_docomplete);
+};
+
+/*
+ * Common function for completing execution of the given RPC request.
+ */
+FastServer.prototype.requestCleanup = function (request)
+{
+	var conn;
+	var self = this;
+
+	mod_assertplus.equal(request.fsr_state, FR_S_COMPLETE);
+	conn = request.fsr_conn;
+
+	mod_assertplus.ok(conn.fc_pending.hasOwnProperty(request.fsr_msgid));
+	mod_assertplus.ok(conn.fc_pending[request.fsr_msgid] == request);
+	delete (conn.fc_pending[request.fsr_msgid]);
+
+	conn.fc_ncompleted++;
+	this.fs_nrequests_completed++;
+
+	if (request.fsr_handler !== null) {
+		request.fsr_handler.fh_ncompleted++;
+
+		/*
+		 * If we never assigned a handler, then we didn't fire the
+		 * rpc-start probe.
+		 */
+		this.fs_dtp.fire('rpc-done', function () {
+			return ([ self.fs_dtid,
+			    conn.fc_connid, request.fsr_msgid ]);
+		});
+	}
+
+	if (request.fsr_error !== null) {
+		conn.fc_nfailed++;
+		this.fs_nrequests_failed++;
+		if (request.fsr_handler !== null) {
+			request.fsr_handler.fh_nerrors++;
+		}
+	}
+
+	if (conn.fc_draining) {
+		this.connDrain(conn);
+	}
+};
+
+
+/*
+ * Helper classes
+ *
+ * The classes below generally contain no methods of their own except as needed
+ * to implement various object-mode streams.
+ */
+
+/*
+ * Each FastRpcHandler instance represents a registered RPC method.  Besides the
+ * user's handler, we keep track of basic stats about this handler's usage.
+ * Named arguments include:
+ *
+ *     rpcmethod	string name of the RPC method
+ *
+ *     rpchandler	JavaScript function invoked for each outstanding
+ *     			request.
+ *
+ * When RPC requests are received for this method, the function is invoked as:
+ *
+ *     handler(context);
+ *
+ * where "context" is an object-mode writable stream to which the RPC method
+ * implementor should write plain JavaScript objects that will be received on
+ * the client.  The RPC is considered successfully completed when the stream is
+ * ended.  If the RPC fails, the caller should _not_ end the stream, but instead
+ * invoke context.fail(err) with an error that will be sent to the client.
+ * After the RPC completes (either by ending the stream or by invoking fail()),
+ * only read-only operations on "context" are allowed.
+ */
+function FastRpcHandler(args)
+{
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.string(args.rpcmethod, 'args.rpcmethod');
+	mod_assertplus.func(args.rpchandler, 'args.rpchandler');
+
+	this.fh_rpcmethod = args.rpcmethod;
+	this.fh_handler = args.rpchandler;
+	this.fh_nstarted = 0;		/* count of started RPC calls */
+	this.fh_ncompleted = 0;		/* count of completed RPC calls */
+	this.fh_nerrors = 0;		/* count of completed, failed calls */
+}
+
+
+/*
+ * Each FastRpcConnection instance represents a connection to an RPC client.
+ * See "Connection lifecycle" for details about how this object is used.
+ * Named arguments:
+ *
+ *     connId	unique identifier for this connection
+ *
+ *     socket	underlying socket for communicating with client
+ *
+ *     log      bunyan-style logger
+ */
+function FastRpcConnection(args)
+{
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.ok(args.connId, 'args.connId');
+	mod_assertplus.object(args.socket, 'args.socket');
+	mod_assertplus.object(args.log, 'args.log');
+
+	this.fc_connid = args.connId;	/* see above */
+	this.fc_socket = args.socket;	/* see above */
+	this.fc_addrinfo = mod_subr.summarizeSocketAddrs(this.fc_socket);
+	this.fc_log = args.log.child({
+	    'connId': this.fc_connid,
+	    'client': this.fc_addrinfo.label
+	});
+	this.fc_pending = {};		/* pending requests */
+	this.fc_nstarted = 0;		/* count of requests started */
+	this.fc_ncompleted = 0;		/* count of requests completed */
+	this.fc_nfailed = 0;		/* count of requests failed */
+	this.fc_taccepted = null;	/* time when the conn was accepted */
+	this.fc_ended = false;		/* end-of-stream has been read */
+	this.fc_socket_error = null;	/* conn experienced socket error */
+	this.fc_server_error = null;	/* proto error or shutdown */
+	this.fc_draining = false;	/* waiting for connection to drain */
+
+	/*
+	 * Messages written to fc_msgencoder are encoded and sent to the socket.
+	 */
+	this.fc_msgencoder = new mod_protocol.FastMessageEncoder();
+	this.fc_msgencoder.pipe(this.fc_socket);
+
+	/*
+	 * We'll end up piping each request's encoder to this connection-wide
+	 * encoder.  As a result, it may have listeners proportional to the
+	 * number of outstanding requests.  Disable Node's ill-considered
+	 * warning about the maximum number of listeners.
+	 */
+	this.fc_msgencoder.setMaxListeners(0);
+
+	/*
+	 * Messages read from the socket are annotated with this connection id
+	 * (using the FastRpcConnectionDecoder transform stream) and then
+	 * emitted from fc_ckddecoder.
+	 */
+	this.fc_rawdecoder = new mod_protocol.FastMessageDecoder();
+	this.fc_socket.pipe(this.fc_rawdecoder);
+	this.fc_ckddecoder = new FastRpcConnectionDecoder({ 'fastConn': this });
+	this.fc_rawdecoder.pipe(this.fc_ckddecoder);
+}
+
+
+/*
+ * This object-mode Transform stream annotates Fast protocol messages with the
+ * connection on which they were received.
+ */
+function FastRpcConnectionDecoder(args)
+{
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.object(args.fastConn, 'args.fastConn');
+
+	this.fcd_conn = args.fastConn;
+	mod_stream.Transform.call(this, {
+	    'objectMode': true,
+	    'highWaterMark': 1
+	});
+}
+
+mod_util.inherits(FastRpcConnectionDecoder, mod_stream.Transform);
+
+FastRpcConnectionDecoder.prototype._transform = function (msg, _, callback)
+{
+	mod_assertplus.object(msg);
+	mod_assertplus.number(msg.msgid);
+	mod_assertplus.ok(!msg.hasOwnProperty('connId'));
+	msg.connId = this.fcd_conn.fc_connid;
+	this.push(msg);
+	setImmediate(callback);
+};
+
+
+/*
+ * The FastMessageHandler is just a transform stream that takes incoming Fast
+ * protocol messages and dispatches them to the FastServer for which this
+ * handler was created.  Today, this class does not do any real flow control or
+ * concurrency management.  However, by phrasing this as an object-mode Writable
+ * stream, this is where we could implement flow control without having to
+ * modify much else.
+ */
+function FastMessageHandler(args)
+{
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.object(args.server, 'args.server');
+
+	this.fmh_server = args.server;
+
+	mod_stream.Writable.call(this, {
+	    'objectMode': true,
+	    'highWaterMark': 0
+	});
+}
+
+mod_util.inherits(FastMessageHandler, mod_stream.Writable);
+
+FastMessageHandler.prototype._write = function (obj, _, callback)
+{
+	this.fmh_server.onMessage(obj);
+	setImmediate(callback);
+};
+
+
+/*
+ * A FastRpcServerRequest represents an RPC request received on the server from
+ * a client.  See "Request lifecycle" above for details.  Named arguments:
+ *
+ *     fastMessage (object) incoming Fast protocol message that began this RPC
+ *
+ *     fastConn    (object) connection on which this request was received
+ *
+ *     server      (object) handle to the containing Fast server
+ *
+ *     log         (object) bunyan-style logger
+ */
+function FastRpcServerRequest(args)
+{
+	var request = this;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.object(args.fastMessage, 'args.fastMessage');
+	mod_assertplus.object(args.server, 'args.server');
+	mod_assertplus.object(args.log, 'args.log');
+	mod_assertplus.object(args.fastConn, 'args.fastConn');
+
+	/*
+	 * This should already have been validated by the Fast parser.  However,
+	 * the contents of the message's "data" field have not yet been
+	 * validated.
+	 */
+	mod_assertplus.number(args.fastMessage.msgid, 'args.fastMessage.msgid');
+
+	this.fsr_message = args.fastMessage;
+	this.fsr_msgid = args.fastMessage.msgid;
+	this.fsr_server = args.server;
+	this.fsr_conn = args.fastConn;
+	this.fsr_log = args.log;
+
+	this.fsr_rpcmethod = null;	/* filled in after validation */
+	this.fsr_rpcargs = null;	/* filled in after validation */
+	this.fsr_handler = null;	/* filled in after validation */
+	this.fsr_tstarted = null;	/* time the request started */
+	this.fsr_state = FR_S_INIT;	/* see state machine above */
+	this.fsr_encoder = new FastRpcResponseEncoder({ 'request': this });
+	this.fsr_docomplete = null;	/* callback for completion */
+	this.fsr_error = null;		/* error, if any */
+	this.fsr_blackhole = null;	/* see requestDisconnect() */
+
+	/*
+	 * The "context" is a handle by which implementors of RPC methods can
+	 * inspect the request and send response data.  Per well-established
+	 * design patterns, we provide a functional interface to this
+	 * information so that we can add additional information in the future
+	 * by just adding new methods to the context object.
+	 *
+	 * We could just use this object, rather than constructing a new object
+	 * specifically for this purpose.  Indeed, this author is not generally
+	 * a proponent of the following pattern for data hiding, as it disrupts
+	 * debuggability.  Sadly, past experience has shown that some
+	 * implementations cannot resist the temptation to peek and poke at
+	 * private fields.  Given how crisp this interface boundary is, we deem
+	 * it worthwhile to eliminate the possibility of malfeasance.
+	 */
+	this.fsr_context = new mod_stream.PassThrough({
+	    'objectMode': true,
+	    'highWaterMark': 1
+	});
+	this.fsr_context.connectionId = function ctxConnectionId() {
+		return (request.fsr_conn.fc_connid);
+	};
+	this.fsr_context.requestId = function ctxRequestId() {
+		return (request.fsr_msgid);
+	};
+	this.fsr_context.methodName = function ctxMethodName() {
+		return (request.fsr_rpcmethod);
+	};
+	this.fsr_context.argv = function ctxArgv() {
+		/*
+		 * For clarity and debuggability, callers ought to avoid mucking
+		 * with the arguments that they're given.  Normally, we'd copy
+		 * them here to eliminate this as a possibility.  But the cost
+		 * of a deep copy is a relatively high percentage of the on-CPU
+		 * time for many RPC calls.  Plus, it's unlikely that
+		 * modifications to these arguments would affect code other than
+		 * the caller.
+		 */
+		return (request.fsr_rpcargs.slice());
+	};
+	this.fsr_context.fail = function ctxFail(err) {
+		return (request.fsr_server.requestFail(request, err));
+	};
+
+	this.fsr_context.pipe(this.fsr_encoder);
+}
+
+
+function FastRpcResponseEncoder(args)
+{
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.object(args.request, 'args.request');
+
+	mod_stream.Transform.call(this, {
+	    'objectMode': true,
+	    'highWaterMark': 1
+	});
+	this.fse_request = args.request;
+	this.fse_ndropped = 0;
+}
+
+mod_util.inherits(FastRpcResponseEncoder, mod_stream.Transform);
+
+FastRpcResponseEncoder.prototype._transform = function (obj, _, callback)
+{
+	if (this.fse_request.fsr_state != FR_S_RUNNING) {
+		/*
+		 * The RPC handler should not be writing data after calling
+		 * fail() (and completing the request).  However, there's some
+		 * asynchrony between when they write data and when it reaches
+		 * our transform, so this isn't necessarily invalid.
+		 */
+		this.fse_ndropped++;
+		setImmediate(callback);
+		return;
+	}
+
+	mod_assertplus.ok(typeof (obj) == 'object' && obj !== null,
+	    'can only send non-null objects');
+	this.push(requestMakeMessage(this.fse_request,
+	    mod_protocol.FP_STATUS_DATA, [ obj ]));
+	setImmediate(callback);
+};
+
+FastRpcResponseEncoder.prototype._flush = function (callback)
+{
+	if (this.fse_request.fsr_state == FR_S_RUNNING) {
+		this.push(requestMakeMessage(this.fse_request,
+		    mod_protocol.FP_STATUS_END, null));
+	}
+
+	setImmediate(callback);
+};
+
+/*
+ * Construct a Fast RPC message that's part of a response for the given request.
+ */
+function requestMakeMessage(request, status, data)
+{
+	var datum;
+
+	mod_assertplus.ok(request instanceof FastRpcServerRequest);
+	if (status == mod_protocol.FP_STATUS_ERROR) {
+		mod_assertplus.ok(data instanceof Error);
+
+		/*
+		 * The marshaling of Errors is a little sketchy, owing partly to
+		 * the history of Fast and partly to the sketchy definition of
+		 * Errors in JavaScript.  The goal is to allow the client
+		 * program to reconstitute an Error object that looks like the
+		 * one we have here.
+		 *
+		 * We need to provide at least "name" and "message" to make it
+		 * look like a JavaScript Error.  As a departure from the
+		 * previous implementation, we do not provide the "stack" field.
+		 * It's way too confusing for the client to wind up with an
+		 * Error whose stacktrace is from a different program on a
+		 * different system.  (The filenames and line numbers in the
+		 * stack trace may not even exist on the client system, and
+		 * they certainly may not refer to the same files and line
+		 * numbers even if they do exist.)
+		 *
+		 * We provide "info" as VError.info() because this is the modern
+		 * way to provide information properties on Errors.
+		 *
+		 * We provide "context" and "ase_errors" because the old Fast
+		 * implementation did so.  "context" is how old Fast servers
+		 * would specify error metadata (before VError.info() existed).
+		 * "ase_errors" is a private implementation property of
+		 * MultiError, and we never should have exposed it, but things
+		 * potentially do depend on it.
+		 */
+		datum = {
+		    'name': data.name,
+		    'message': data.message,
+		    'context': data.context || {},
+		    'info': VError.info(data),
+		    'ase_errors': data.ase_errors
+		};
+	} else if (status == mod_protocol.FP_STATUS_END) {
+		mod_assertplus.ok(data === null);
+		datum = [];
+	} else {
+		mod_assertplus.equal(status, mod_protocol.FP_STATUS_DATA);
+		mod_assertplus.ok(Array.isArray(data));
+		datum = data;
+	}
+
+	return ({
+	    'msgid': request.fsr_msgid,
+	    'status': status,
+	    'data': {
+		'm': {
+		    'uts': mod_microtime.now(),
+		    'name': request.fsr_rpcmethod
+		},
+		'd': datum
+	    }
+	});
+}
+
+
+/*
+ * Object-mode data sink that drops all data.
+ */
+function NullSink()
+{
+	this.ns_nwritten = 0;
+	mod_stream.Writable.call(this, {
+	    'objectMode': true,
+	    'highWaterMark': 1
+	});
+}
+
+mod_util.inherits(NullSink, mod_stream.Writable);
+
+NullSink.prototype._write = function (_1, _2, callback)
+{
+	this.ns_nwritten++;
+	setImmediate(callback);
+};
+
+
+/*
+ * Initialize the DTrace provider for the Fast server.
+ */
+function fastServerProviderInit()
+{
+	var dtp;
+
+	dtp = mod_dtrace.createDTraceProvider('fastserver');
+
+	/*
+	 * conn-create: connection was created
+	 *
+	 *     arg0    int     unique identifier for this server in this process
+	 *     arg1    int     unique identifier for this client in this server
+	 *     arg2    string  human-readable label for this client (usually
+	 *                     a summary of the TCP connection)
+	 */
+	dtp.addProbe('conn-create', 'int', 'int', 'char *');
+
+	/*
+	 * conn-destroy: connection was destroyed
+	 *
+	 *     arg0    int     see conn-create arg0.
+	 *     arg1    int     see conn-create arg1.
+	 */
+	dtp.addProbe('conn-destroy', 'int', 'int');
+
+	/*
+	 * rpc-start: server starts handling RPC request
+	 *
+	 *     arg0    int     see conn-create arg0.
+	 *     arg1    int     see conn-create arg1.
+	 *     arg2    int     unique identifier for this request in this client
+	 *     arg3    string  RPC method name
+	 */
+	dtp.addProbe('rpc-start', 'int', 'int', 'int', 'char *');
+
+	/*
+	 * rpc-done: server finishes handling RPC request
+	 *
+	 *     arg0    int     see conn-create arg0.
+	 *     arg1    int     see conn-create arg1.
+	 *     arg2    int     unique identifier for this request in this
+	 *		       process
+	 */
+	dtp.addProbe('rpc-done', 'int', 'int', 'int');
+	dtp.enable();
+	return (dtp);
+}
diff --git a/lib/subr.js b/lib/subr.js
new file mode 100644
index 0000000..63f969c
--- /dev/null
+++ b/lib/subr.js
@@ -0,0 +1,134 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * lib/fast_subr.js: useful utility functions that have not yet been abstracted
+ * into separate Node modules.
+ */
+
+var mod_assertplus = require('assert-plus');
+
+exports.summarizeSocketAddrs = summarizeSocketAddrs;
+exports.IdAllocator = IdAllocator;
+
+/*
+ * Given a Node socket, return an object summarizing it for debugging purposes.
+ * It's sad how complicated this is.  This is only tested for Node v0.10 and
+ * v0.12.
+ */
+function summarizeSocketAddrs(sock)
+{
+	var laddr, rv;
+
+	laddr = sock.address();
+
+	if (sock.remoteAddress === undefined &&
+	    sock.remotePort === undefined &&
+	    sock.remoteFamily === undefined) {
+		return ({ 'socketType': 'UDS (inferred)', 'label': 'UDS' });
+	}
+
+	rv = {};
+	rv['remoteAddress'] = sock.remoteAddress;
+	rv['remotePort'] = sock.remotePort;
+
+	if (laddr === null) {
+		rv['socketType'] = 'unknown';
+		rv['label'] = 'unknown';
+	} else {
+		rv['socketType'] = laddr.family ? laddr.family : 'unknown';
+		rv['localAddress'] = laddr.address;
+		rv['localPort'] = laddr.port;
+
+		if (sock.remoteAddress) {
+			rv['label'] = sock.remoteAddress;
+			if (sock.remotePort) {
+				rv['label'] += ':' + sock.remotePort;
+			}
+		} else {
+			rv['label'] = 'unknown';
+		}
+	}
+
+	return (rv);
+}
+
+/*
+ * IdAllocator is a cheesy interface for allocating non-negative integer
+ * identifiers.  This is similar to the way an OS pid allocator might work,
+ * where ids are allocated in increasing order to avoid immediate reuse, but ids
+ * eventually will wrap around.  It's expected that callers will use these ids
+ * as strings (e.g., as object property names).
+ *
+ * This is a very simple implementation that we expect to be sufficient for our
+ * purposes.  However, it's not very efficient.  We may want to look at
+ * something like the Bonwick vmem allocator in the future.
+ *
+ * This interface considers it a programmer error to attempt to allocate more
+ * ids than are currently outstanding (i.e., to attempt to allocate when no
+ * resources are available).  That will result in a thrown exception that should
+ * not be caught.  If we want to make this survivable in the future, we could
+ * improve this, but it's extraordinarily unlikely in the use-cases for which
+ * this is intended so it's not worth special-casing at this point.
+ *
+ * Arguments:
+ *
+ *     min (number)    minimum allowed id (absolute minimum: 0)
+ *
+ *     max (number)    maximum allowed id (absolute maximum: 2^31)
+ *
+ *     isAllocated     function that takes an id and returns whether or not
+ *     (function)      the id is still allocated.  This is a obviously  cheesy,
+ *		       but given that callers are keeping track of it, we may as
+ *		       well just ask them rather than keep a shadow copy of the
+ *		       allocated ids.
+ *
+ */
+function IdAllocator(args)
+{
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.number(args.min, 'args.min');
+	mod_assertplus.number(args.max, 'args.max');
+	mod_assertplus.func(args.isAllocated, 'args.isAllocated');
+	mod_assertplus.ok(args.min < args.max, 'min must be less than max');
+	mod_assertplus.ok(args.min >= 0, 'min must be non-negative');
+	mod_assertplus.ok(args.max <= Math.pow(2, 31), 'max is too big');
+
+	this.ida_min = args.min;
+	this.ida_max = args.max;
+	this.ida_isalloc = args.isAllocated;
+	this.ida_nextid = this.ida_min;
+}
+
+IdAllocator.prototype.alloc = function ()
+{
+	var start, next;
+
+	start = this.ida_nextid;
+	next = start;
+	while (this.ida_isalloc(next)) {
+		next++;
+
+		if (next > this.ida_max) {
+			next = this.ida_min;
+		}
+
+		if (next == start) {
+			throw (new Error('all ids allocated'));
+		}
+	}
+
+	this.ida_nextid = next + 1;
+	if (this.ida_nextid > this.ida_max) {
+		this.ida_nextid = this.ida_min;
+	}
+
+	return (next);
+};
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..71b31c1
--- /dev/null
+++ b/package.json
@@ -0,0 +1,32 @@
+{
+	"name": "fast2",
+	"description": "streaming JSON RPC over TCP, version 2",
+	"version": "0.1.0",
+	"main": "./lib/fast.js",
+	"repository": {
+		"type": "git",
+		"url": "git://github.com/joyent/node-fast2.git"
+	},
+	"dependencies": {
+		"assert-plus": "1.0.0",
+		"bunyan": "^1.7.1",
+		"cmdutil": "^1.0.0",
+		"crc": "0.3.0",
+		"extsprintf": "^1.3.0",
+		"jsprim": "^1.2.2",
+		"kang": "^1.0.1",
+		"lstream": "0.0.4",
+		"microtime": "2.0.0",
+		"posix-getopt": "1.2.0",
+		"strsplit": "^1.0.0",
+		"vasync": "^1.6.3",
+		"verror": "^1.7.0"
+	},
+	"devDependencies": {
+		"forkexec": "^1.0.0"
+	},
+	"optionalDependencies": {
+	    "dtrace-provider": "^0.6.0"
+	},
+	"license": "MIT"
+}
diff --git a/test/common.js b/test/common.js
new file mode 100644
index 0000000..6b3dea8
--- /dev/null
+++ b/test/common.js
@@ -0,0 +1,315 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/common.js: common utilities for test suite
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_crc = require('crc');
+var mod_net = require('net');
+var mod_protocol = require('../lib/fast_protocol');
+var mod_stream = require('stream');
+var mod_util = require('util');
+var VError = require('verror');
+
+/* IP used for the server in this test suite */
+exports.serverIp = '127.0.0.1';
+/* TCP port used by the server in this test suite */
+exports.serverPort = 31016;
+
+/* dummy values used as test data */
+exports.dummyRpcMethodName = 'testmethod';
+exports.dummyValue = { 'movies': [ 'red dawn', 'wargames' ] };
+exports.dummyRpcArgs = [ exports.dummyValue ];
+exports.dummyResponseData = { 'd': [ exports.dummyValue ] };
+exports.dummyResponseEndEmpty = { 'd': [] };
+exports.dummyError = new VError({
+    'name': 'DummyError',
+    'info': {
+	'dummyProp': 'dummyVal'
+    }
+}, 'dummy error message');
+exports.dummyResponseError = { 'd': {
+    'name': exports.dummyError.name,
+    'message': exports.dummyError.message,
+    'info': VError.info(exports.dummyError)
+} };
+
+exports.makeBigObject = makeBigObject;
+exports.writeMessageForEncodedData = writeMessageForEncodedData;
+exports.mockServerSetup = mockServerSetup;
+exports.mockServerTeardown = mockServerTeardown;
+exports.assertRequestError = assertRequestError;
+exports.FlowControlSource = FlowControlSource;
+exports.isFlowControlled = isFlowControlled;
+exports.registerExitBlocker = registerExitBlocker;
+exports.unregisterExitBlocker = unregisterExitBlocker;
+exports.predatesUsefulPause = predatesUsefulPause;
+
+/*
+ * Construct a plain-old-JavaScript object whose size is linear in "width" and
+ * exponential in "depth".
+ */
+function makeBigObject(width, depth)
+{
+	var i, rv;
+
+	mod_assertplus.number(width);
+	mod_assertplus.number(depth);
+	mod_assertplus.ok(depth >= 1);
+
+	rv = {};
+	if (depth === 1) {
+		for (i = 0; i < width; i++) {
+			rv['prop_1_' + i] = 'prop_1_' + i + '_value';
+		}
+	} else {
+		for (i = 0; i < width; i++) {
+			rv['prop_' + depth + '_' + i] =
+			    makeBigObject(width, depth - 1);
+		}
+	}
+
+	return (rv);
+}
+
+/*
+ * Writes into "buf" (a Node buffer) at offset "msgoffset" a Fast packet with
+ * message id "msgid", status byte "status", encoded data "dataenc".  This
+ * low-level primitive is provided for the test suite to generate various types
+ * of invalid messages.  If you want to generate valid Fast messages, see the
+ * MessageEncoder class.
+ */
+function writeMessageForEncodedData(buf, msgid, status, dataenc, msgoffset)
+{
+	var crc, datalen;
+	crc = mod_crc.crc16(dataenc);
+	datalen = Buffer.byteLength(dataenc);
+
+	buf.writeUInt8(mod_protocol.FP_VERSION_1,
+	    msgoffset + mod_protocol.FP_OFF_VERSION);
+	buf.writeUInt8(mod_protocol.FP_TYPE_JSON,
+	    msgoffset + mod_protocol.FP_OFF_TYPE);
+	buf.writeUInt8(status, msgoffset + mod_protocol.FP_OFF_STATUS);
+	buf.writeUInt32BE(msgid, msgoffset + mod_protocol.FP_OFF_MSGID);
+	buf.writeUInt32BE(crc, msgoffset + mod_protocol.FP_OFF_CRC);
+	buf.writeUInt32BE(datalen, msgoffset + mod_protocol.FP_OFF_DATALEN);
+	buf.write(dataenc, msgoffset + mod_protocol.FP_OFF_DATA);
+}
+
+/*
+ * Sets up a server intended for testing.  This is little more than a plain TCP
+ * server, since the mock server needs low-level access to the socket.
+ *
+ * Invokes "callback" when the server is ready.
+ */
+function mockServerSetup(callback)
+{
+	var socket;
+
+	socket = mod_net.createServer({ 'allowHalfOpen': true });
+	socket.listen(exports.serverPort, exports.serverIp, function () {
+		callback(socket);
+	});
+}
+
+/*
+ * Tears down the mock server.
+ */
+function mockServerTeardown(socket)
+{
+	socket.close();
+}
+
+/*
+ * Asserts that the given found_error is a FastRequestError caused by
+ * expected_cause.
+ */
+function assertRequestError(found_error, expected_cause)
+{
+	mod_assertplus.equal(found_error.name, 'FastRequestError');
+	mod_assertplus.equal(found_error.message,
+	    'request failed: ' + expected_cause.message);
+	mod_assertplus.equal(found_error.cause().name, expected_cause.name);
+}
+
+
+/*
+ * A FlowControlSource is an object-mode Readable stream that emits data until
+ * the caller calls stop().  This class emits event 'resting' when it has been
+ * flow controlled for the specified time.
+ *
+ *     datum		chunk of data to emit when asked for data
+ *
+ *     log		bunyan-style logger
+ *
+ *     restMs		time to wait while flow-controlled before emitting
+ *     			'resting'
+ */
+function FlowControlSource(args)
+{
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.object(args.datum, 'args.datum');
+	mod_assertplus.object(args.log, 'args.log');
+	mod_assertplus.number(args.restMs, 'args.restMs');
+
+	this.fcs_datum = args.datum;
+	this.fcs_log = args.log;
+	this.fcs_rest_time = args.restMs;
+	this.fcs_reading = false;
+	this.fcs_stopped = false;
+	this.fcs_flowcontrolled = null;
+	this.fcs_timeout = null;
+	this.fcs_ntransients = 0;
+	this.fcs_nresting = 0;
+	this.fcs_nwritten = 0;
+
+	mod_stream.Readable.call(this, {
+	    'objectMode': true,
+	    'highWaterMark': 16
+	});
+}
+
+mod_util.inherits(FlowControlSource, mod_stream.Readable);
+
+FlowControlSource.prototype._read = function ()
+{
+	var i;
+
+	if (this.fcs_reading) {
+		this.fcs_log.debug('ignoring _read(): already reading');
+		return;
+	}
+
+	if (this.fcs_stopped) {
+		this.fcs_log.debug('_read() pushing end-of-stream');
+		this.push(null);
+		return;
+	}
+
+	this.fcs_reading = true;
+	if (this.fcs_timeout !== null) {
+		this.fcs_ntransients++;
+		clearTimeout(this.fcs_timeout);
+		this.fcs_timeout = null;
+	}
+
+	this.fcs_log.trace('reading');
+	for (i = 1; ; i++) {
+		this.fcs_nwritten++;
+		if (!this.push(this.fcs_datum)) {
+			break;
+		}
+	}
+
+	this.fcs_log.trace({
+	    'nwritten': this.fcs_nwritten,
+	    'ntransients': this.fcs_ntransients,
+	    'nresting': this.fcs_nresting
+	}, 'flow-controlled after %d objects', i);
+	this.fcs_flowcontrolled = new Date();
+	this.fcs_timeout = setTimeout(this.onTimeout.bind(this),
+	    this.fcs_rest_time);
+	this.fcs_reading = false;
+};
+
+FlowControlSource.prototype.stop = function ()
+{
+	this.fcs_stopped = true;
+	this._read();
+};
+
+FlowControlSource.prototype.onTimeout = function ()
+{
+	var state = {
+	    'nwritten': this.fcs_nwritten,
+	    'ntransients': this.fcs_ntransients,
+	    'nresting': this.fcs_nresting
+	};
+
+	this.fcs_nresting++;
+	this.fcs_timeout = null;
+	this.fcs_log.debug(state, 'coming to rest');
+	this.emit('resting', state);
+};
+
+
+/*
+ * Returns true only if the given stream appears to be flow-controlled.
+ *
+ * These checks are brittle because they depend on internal Node implementation
+ * details.  However, if those details change, the failure here is likely to be
+ * explicit, and we can decide how best to fix them.  We could skip these checks
+ * entirely, but we'd like to be sure that the flow-control mechanism was
+ * definitely engaged and that it was engaged because the client is backed up.
+ * If this check fails, and the Node internals on which it relies have not
+ * changed, that means that we inadvertently decided the server was
+ * flow-controlled above even though the client's buffer is not full.
+ */
+function isFlowControlled(stream)
+{
+	mod_assertplus.equal('number', typeof (stream._readableState.length));
+	mod_assertplus.equal('number',
+	    typeof (stream._readableState.highWaterMark));
+	return (stream._readableState.length >=
+	    stream._readableState.highWaterMark);
+}
+
+
+/*
+ * Register that the current program should not exit until this registration is
+ * removed.  It's sometimes easy to create Node programs that exit prematurely
+ * with status 0 because they had no more work to do.  This mechanism causes the
+ * program to crash when that happens.  You first register an "exit blocker"
+ * with a descriptive name (so that you know which part of the program thinks it
+ * should not be exiting).  On normal process exit (i.e. with status code 0), if
+ * the exit blocker has not been removed, then the program crashes.  Exits for
+ * non-zero status codes (including aborts due to --abort-on-uncaught-exception
+ * or other fatal errors) are not affected by this.
+ *
+ * This would be a useful first-class interface, maybe in node-vasync.
+ */
+var exitBlockers = {};
+function registerExitBlocker(name)
+{
+	var onExitHandler;
+
+	mod_assertplus.ok(!exitBlockers.hasOwnProperty(name),
+	    'exit blocker "' + name + '" is already registered');
+	onExitHandler = function (code) {
+		if (code === 0) {
+			throw (new VError('premature exit: blocker "%s" is ' +
+			    'still regisered', name));
+		}
+	};
+
+	exitBlockers[name] = onExitHandler;
+	process.on('exit', onExitHandler);
+}
+
+function unregisterExitBlocker(name)
+{
+	mod_assertplus.ok(exitBlockers.hasOwnProperty(name),
+	    'exit blocker "' + name + '" is not registered');
+	process.removeListener('exit', exitBlockers[name]);
+	delete (exitBlockers[name]);
+}
+
+/*
+ * Returns true if the current Node version predates a pause() function that
+ * works on all streams.  In Node v0.10, if you pause a stream that was
+ * constructed in the "new" mode, you get an error about "Cannot switch to old
+ * mode now", which makes it harder for us to exercise certain test cases.
+ */
+function predatesUsefulPause()
+{
+	return (/^v0\.10\./.test(process.version));
+}
diff --git a/test/common/client.js b/test/common/client.js
new file mode 100644
index 0000000..c882bd6
--- /dev/null
+++ b/test/common/client.js
@@ -0,0 +1,220 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/common/client.js: common facilities for testing the client
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_net = require('net');
+
+var mod_client = require('../../lib/fast_client');
+var mod_protocol = require('../../lib/fast_protocol');
+var mod_testcommon = require('../common');
+
+exports.ClientTestContext = ClientTestContext;
+
+/*
+ * The ClientTestContext class provides common functions for setting up a
+ * FastClient and connecting it to a mock server.  This class logs all activity
+ * and keeps track of events emitted.
+ *
+ * Note that this class is just a convenience.  It doesn't do any real
+ * implementation hiding.  Callers are free to mess with internal members as
+ * needed to exercise various functionality.
+ */
+function ClientTestContext(args)
+{
+	mod_assertplus.object(args.server);
+	mod_assertplus.object(args.log);
+
+	this.ctc_log = args.log;		/* bunyan logger */
+	this.ctc_closed = false;		/* already cleaned up */
+
+	/* server handles */
+	this.ctc_server = args.server;	/* server listening socket */
+	this.ctc_server_sock = null;	/* server-side connection to client */
+	this.ctc_server_message = null;	/* first message received by server */
+	this.ctc_server_decoder = null;	/* decoder piped from ctc_server_sock */
+	this.ctc_server_encoder = null;	/* encoder piped to ctc_server_sock */
+
+	/* client handles */
+	this.ctc_client_sock = null;	/* client TCP socket */
+	this.ctc_fastclient = null;	/* FastClient handle */
+
+	/* client events emitted */
+	this.ctc_error_client = null;	/* emitted on this.ctc_fastclient */
+	this.ctc_error_sock = null;	/* emitted on this.ctc_client_sock */
+}
+
+/*
+ * Creates a Fast client and connects it to the server.
+ */
+ClientTestContext.prototype.establishConnection = function ()
+{
+	var self = this;
+
+	mod_assertplus.ok(!this.ctc_closed);
+	this.ctc_client_sock = mod_net.createConnection(
+	    mod_testcommon.serverPort, mod_testcommon.serverIp);
+	this.ctc_fastclient = new mod_client.FastClient({
+	    'log': this.ctc_log.child({ 'component': 'FastClient' }),
+	    'nRecentRequests': 100,
+	    'transport': this.ctc_client_sock
+	});
+
+	this.ctc_fastclient.on('error', function (err) {
+		self.ctc_log.debug(err, 'client error');
+		mod_assertplus.ok(self.ctc_error_client === null,
+		    'client emitted more than one error');
+		self.ctc_error_client = err;
+	});
+
+	this.ctc_server.once('connection', function (sock) {
+		mod_assertplus.ok(self.ctc_server_sock === null);
+		self.ctc_log.debug('server accepted connection');
+		self.ctc_server_sock = sock;
+		self.ctc_server_encoder.pipe(sock);
+		sock.pipe(self.ctc_server_decoder);
+	});
+
+	this.ctc_server_encoder = new mod_protocol.FastMessageEncoder();
+	this.ctc_server_decoder = new mod_protocol.FastMessageDecoder();
+};
+
+/*
+ * Instructs that the server should handle the next RPC request that it sees.
+ */
+ClientTestContext.prototype.handleNextRequest = function (options)
+{
+	var self = this;
+	mod_assertplus.bool(options.data);
+	mod_assertplus.bool(options.error);
+
+	mod_assertplus.ok(!this.ctc_closed);
+	this.ctc_server_decoder.once('data', function (message) {
+		self.ctc_log.debug({
+		    'msgid': message.msgid
+		}, 'server got request');
+
+		self.ctc_server_message = message;
+		self.serverReply(message, options);
+	});
+};
+
+/*
+ * Reply to the given RPC request.
+ */
+ClientTestContext.prototype.serverReply = function (message, options)
+{
+	mod_assertplus.object(options);
+	mod_assertplus.bool(options.data);
+	mod_assertplus.bool(options.error);
+
+	if (options.data) {
+		this.ctc_server_encoder.write({
+		    'msgid': message.msgid,
+		    'status': mod_protocol.FP_STATUS_DATA,
+		    'data': mod_testcommon.dummyResponseData
+		});
+	}
+
+	if (options.error) {
+		this.ctc_server_encoder.write({
+		    'msgid': message.msgid,
+		    'status': mod_protocol.FP_STATUS_ERROR,
+		    'data': mod_testcommon.dummyResponseError
+		});
+	} else {
+		this.ctc_server_encoder.write({
+		    'msgid': message.msgid,
+		    'status': mod_protocol.FP_STATUS_END,
+		    'data': mod_testcommon.dummyResponseData
+		});
+	}
+};
+
+/*
+ * Direct the client to execute an RPC request.  Returns a ClientTestRequest,
+ * which keeps track of events emitted on the request.
+ */
+ClientTestContext.prototype.makeRequest = function (callback)
+{
+	var req, log;
+	var ctr = new ClientTestRequest(this);
+
+	mod_assertplus.ok(!this.ctc_closed);
+	ctr.ctr_data = [];
+
+	req = ctr.ctr_request = this.ctc_fastclient.rpc({
+	    'rpcmethod': mod_testcommon.dummyRpcMethodName,
+	    'rpcargs': mod_testcommon.dummyRpcArgs
+	});
+
+	ctr.ctr_log = this.ctc_log.child({ 'requestId': req.requestId() });
+	log = ctr.ctr_log;
+	log.debug('issued RPC');
+	req.on('data', function (d) {
+		log.debug(d, 'request data');
+		ctr.ctr_data.push(d);
+	});
+
+	req.on('end', function () {
+		log.debug('request end');
+		mod_assertplus.ok(!ctr.ctr_done);
+		ctr.ctr_done = true;
+		/*
+		 * This relies a bit on implicit semantics, but we invoke the
+		 * callback on the next tick so that if the client object emits
+		 * an error after this event, the caller will be able to see
+		 * that.
+		 */
+		setImmediate(callback);
+	});
+
+	req.on('error', function (err) {
+		log.debug(err, 'request error');
+		mod_assertplus.ok(!ctr.ctr_done);
+		ctr.ctr_done = true;
+		ctr.ctr_error = err;
+		setImmediate(callback);
+	});
+
+	return (ctr);
+};
+
+/*
+ * Clean up the client and server connections.  This does not close the
+ * listening socket.
+ */
+ClientTestContext.prototype.cleanup = function ()
+{
+	mod_assertplus.ok(!this.ctc_closed);
+	this.ctc_closed = true;
+	this.ctc_client_sock.destroy();
+
+	if (this.ctc_server_sock !== null) {
+		this.ctc_server_sock.destroy();
+	}
+};
+
+
+/*
+ * This helper class keeps track of the state of a single client request.
+ */
+function ClientTestRequest(ctc)
+{
+	this.ctr_context = ctc;		/* parent ClientTestContext */
+	this.ctr_request = null;	/* FastClientRequest object */
+	this.ctr_error = null;		/* "error" emitted */
+	this.ctr_data = [];		/* "data" events emitted */
+	this.ctr_done = false;		/* request has completed */
+	this.ctr_log = null;		/* bunyan logger */
+}
diff --git a/test/compat/Makefile.compat.defs b/test/compat/Makefile.compat.defs
new file mode 100644
index 0000000..4deee16
--- /dev/null
+++ b/test/compat/Makefile.compat.defs
@@ -0,0 +1,9 @@
+#
+# Copyright (c) 2016, Joyent, Inc. All rights reserved.
+#
+# Makefile.compat.defs: defines variables used for setting up and running the
+# Fast library compatibility tests.
+#
+
+FAST_COMPAT_TESTDIR	 = test/compat
+NODE			?= $(error expected NODE to be defined in Makefile)
diff --git a/test/compat/Makefile.compat.targ b/test/compat/Makefile.compat.targ
new file mode 100644
index 0000000..ee69b6f
--- /dev/null
+++ b/test/compat/Makefile.compat.targ
@@ -0,0 +1,19 @@
+#
+# Copyright (c) 2016, Joyent, Inc. All rights reserved.
+#
+# Makefile.compat.targ: defines targets used for setting up and running the Fast
+# library compatibility tests.
+#
+
+#
+# We normally despise monolithic targets that do a bunch of work like this.
+# It's typically much better to have them depend on intermediate targets that do
+# the real work so that the target is interruptible, incremental, and
+# parallelizable.  In this case, the main output is the local copy of the
+# node-fast module, but the presence of that module does not mean it was
+# successfully installed.
+#
+test-compat:
+	(cd $(FAST_COMPAT_TESTDIR) && $(NODE) setup.js && \
+	    $(NODE) manual-tst.client_compat.js)
+CLEAN_FILES 		+= $(FAST_COMPAT_TESTDIR)/node_modules
diff --git a/test/compat/common.js b/test/compat/common.js
new file mode 100644
index 0000000..5debaab
--- /dev/null
+++ b/test/compat/common.js
@@ -0,0 +1,167 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/compat/common.js: common functions for testing compatiblity of this Fast
+ * implementation with an older one.  This is a pain to test because because
+ * this module depends on Node v0.12 or later (because of cueball) while
+ * versions of the Fast server in use today cannot work on Node v0.12 (because
+ * of breaking changes to the V8 API across major versions).  As a result, in
+ * order to test this, we need to start a Fast server using a separate version
+ * of Node, with a separate node_modules hierarchy that includes the old Fast
+ * version.
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_child = require('child_process');
+var mod_forkexec = require('forkexec');
+var mod_fs = require('fs');
+var mod_net = require('net');
+var mod_path = require('path');
+var mod_vasync = require('vasync');
+var VError = require('verror');
+
+exports.nodeConfigLoad = nodeConfigLoad;
+exports.setupOldServer = setupOldServer;
+exports.teardownOldServer = teardownOldServer;
+
+/*
+ * Uses the FAST_COMPAT_NODEDIR environment variable to construct paths to the
+ * "node" and "npm" executables and then sanity-checks the results.  If that
+ * fails for any reason (including a missing environment variable or the node
+ * appears to point to the wrong version), emits an error.
+ */
+function nodeConfigLoad(callback)
+{
+	var nodedir, nodebin, npmbin;
+
+	if (!process.env['FAST_COMPAT_NODEDIR']) {
+		setImmediate(callback, new VError('The compatibility tests ' +
+		    'require that the FAST_COMPAT_NODEDIR environment ' +
+		    'variable refer to the directory of a Node 0.10 ' +
+		    'installation'));
+		return;
+	}
+
+	nodedir = process.env['FAST_COMPAT_NODEDIR'];
+	nodebin = mod_path.join(nodedir, 'bin', 'node');
+	npmbin = mod_path.join(nodedir, 'bin', 'npm');
+
+	process.stderr.write('checking node version ... ');
+	mod_forkexec.forkExecWait({
+	    'argv': [ nodebin, '-v' ]
+	}, function (err, info) {
+		if (err) {
+			process.stderr.write('FAIL\n');
+			callback(err);
+			return;
+		}
+
+		process.stderr.write(info.stdout);
+		if (!/^v0\.10\./.test(info.stdout)) {
+			callback(new VError('$FAST_COMPAT_NODEDIR/bin/' +
+			    'node does not appear to be v0.10'));
+		} else {
+			callback(null, {
+			    'nodebin': nodebin,
+			    'npmbin': npmbin
+			});
+		}
+	});
+}
+
+/*
+ * Instantiates an old-version Fast server and invokes "callback" once the
+ * server is listening.  The callback may be invoked with an error.
+ *
+ *     ip      IP address for the old server to listen on
+ *
+ *     port    TCP port for the old server to listen on
+ */
+function setupOldServer(args, callback)
+{
+	var nodebin, testdir, serverbin, child;
+
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.string(args.ip, 'args.ip');
+	mod_assertplus.ok(mod_net.isIP(args.ip), 'args.ip is an IP address');
+	mod_assertplus.number(args.port, 'args.port');
+	mod_assertplus.func(callback, 'callback');
+
+	testdir = __dirname;
+	serverbin = mod_path.join(testdir, 'legacy-server.js');
+
+	mod_vasync.pipeline({ 'funcs': [
+	    function loadConfig(_, next) {
+		nodeConfigLoad(function (err, nc) {
+			if (!err) {
+				mod_assertplus.object(nc);
+				mod_assertplus.string(nc.nodebin);
+				nodebin = nc.nodebin;
+			}
+
+			next(err);
+		});
+	    },
+
+	    function startOldServer(_, next) {
+		var onexit, onerror;
+
+		console.error('starting legacy server ... ');
+		child = mod_child.spawn(nodebin,
+		    [ serverbin, '--test-mode', args.ip, args.port ],
+		    {
+		        'stdio': [
+			    process.stdin,
+			    process.stdout,
+			    process.stderr,
+			    'pipe'
+			]
+		    });
+
+		onexit = function () {
+			next(new VError('child unexpectedly exited (have ' +
+			    'you set up this repo for compatibility tests?'));
+		};
+		child.on('exit', onexit);
+
+		onerror = function (err) {
+			next(new VError(err, 'child spawn failed'));
+		};
+		child.on('error', onerror);
+
+		child.stdio[3].once('data', function () {
+			/*
+			 * Having received any data at all on this file
+			 * descriptor indicates the server is now listening.
+			 */
+			child.removeListener('onerror', onerror);
+			child.removeListener('exit', onexit);
+			next();
+		});
+	    }
+	] }, function (err) {
+		if (err) {
+			callback(err);
+		} else {
+			callback(null, child);
+		}
+	});
+}
+
+function teardownOldServer(child, callback)
+{
+	process.stderr.write('tearing down server ... ');
+	child.on('exit', function () {
+		process.stderr.write('done.\n');
+		callback();
+	});
+	child.kill('SIGKILL');
+}
diff --git a/test/compat/legacy-server.js b/test/compat/legacy-server.js
new file mode 100644
index 0000000..284dec8
--- /dev/null
+++ b/test/compat/legacy-server.js
@@ -0,0 +1,175 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/compat/legacy-server.js: start an old-version Fast server listening on
+ * the specified port.
+ */
+
+/*
+ * NOTE: Unlike the rest of this project, this code is executed with Node 0.10!
+ * WE should not make use of any dependencies aside from the legacy node-fast
+ * implementation.  If we need to use more dependencies, we need to update
+ * setupOldServer() to make sure these are installed.
+ */
+var mod_fs = require('fs');
+var mod_legacyfast = require('fast');
+var mod_net = require('net');
+var mod_path = require('path');
+var server;
+
+function usage()
+{
+	console.error('usage: node %s IP PORT', mod_path.basename(__filename));
+	process.exit(2);
+}
+
+function main()
+{
+	var ip, port, args, testmode;
+
+	args = process.argv.slice(2);
+	if (args.length > 0 && args[0] == '--test-mode') {
+		testmode = true;
+		args.shift();
+	}
+
+	if (args.length != 2) {
+		usage();
+	}
+
+	ip = args[0];
+	port = args[1];
+	if (!mod_net.isIP(ip) || isNaN(port) || port <= 0 || port > 65535) {
+		console.error('bad IP or port number');
+		usage();
+	}
+
+	server = mod_legacyfast.createServer();
+	console.error('legacy server: startup (pid %d)', process.pid);
+	server.listen(port, ip, function () {
+		console.error('legacy server: listening on %s:%d', ip, port);
+		setupRpcHandlers();
+
+		if (testmode) {
+			exitWhenParentDies();
+			notifyParent();
+		}
+	});
+}
+
+/*
+ * The way this program is launched, our parent process is sitting on the other
+ * end of the pipe at fd 3, and we notify it that we're listening by writing
+ * data on this pipe.
+ */
+function notifyParent()
+{
+	var message, buf;
+
+	message = 'server ready';
+	buf = new Buffer(Buffer.byteLength(message, 'utf8'));
+	buf.write(message);
+	mod_fs.write(3, buf, 0, buf.length, null, function (err) {
+		if (err) {
+			console.error('legacy server: error writing to ' +
+			    'parent: %s', err.message);
+			process.exit(1);
+		}
+	});
+}
+
+/*
+ * This program should exit when the parent goes away.  This mechanism only
+ * works because the parent has set up a pipe on fd 3, which will be closed when
+ * that process exits.
+ */
+function exitWhenParentDies()
+{
+	var buf = new Buffer(1);
+	mod_fs.read(3, buf, 0, 1, null, function (err) {
+		console.error('legacy server: ' +
+		    'terminating after read from parent');
+		server.close();
+	});
+}
+
+function setupRpcHandlers()
+{
+	server.rpc('echo', function () {
+		var response, args;
+
+		/*
+		 * The varargs behavior of the original API makes this the
+		 * simplest way to get the arguments.
+		 */
+		response = arguments[arguments.length - 1];
+		args = Array.prototype.slice.call(
+		    arguments, 0, arguments.length - 1);
+		if (args.length != 1 || args[0] === null ||
+		    typeof (args[0]) != 'object' ||
+		    !Array.isArray(args[0].values) ||
+		    typeof (args[0].errorResult) != 'boolean') {
+			response.end(new Error('bad arguments'));
+			return;
+		}
+
+		args[0].values.forEach(function (v) {
+			response.write(v);
+		});
+
+		if (args[0].errorResult) {
+			var err = new Error('boom boom!');
+			err.context = { 'result': 'poof' };
+			response.end(err);
+		} else {
+			response.end();
+		}
+	});
+
+	server.rpc('fastbench', function () {
+		var response, args;
+
+		/*
+		 * The varargs behavior of the original API makes this the
+		 * simplest way to get the arguments.
+		 */
+		response = arguments[arguments.length - 1];
+		args = Array.prototype.slice.call(
+		    arguments, 0, arguments.length - 1);
+		if (args.length != 1 && typeof (args[0]) != 'object' ||
+		    args[0] === null) {
+			response.end(new Error('bad arguments'));
+			return;
+		}
+
+		args = args[0];
+		if (!args.hasOwnProperty('echo') ||
+		    !Array.isArray(args['echo'])) {
+			response.end(new Error('expected arg.echo'));
+			return;
+		}
+
+		if (typeof (args['delay']) == 'number') {
+			setTimeout(fastRpcFastbenchFinish, args['delay'],
+			    response, args['echo']);
+		} else {
+			fastRpcFastbenchFinish(response, args['echo']);
+		}
+	});
+
+	function fastRpcFastbenchFinish(response, values) {
+		values.forEach(
+		    function (a) { response.write({ 'value': a }); });
+		response.end();
+	}
+}
+
+main();
diff --git a/test/compat/manual-tst.client_compat.js b/test/compat/manual-tst.client_compat.js
new file mode 100644
index 0000000..abdc060
--- /dev/null
+++ b/test/compat/manual-tst.client_compat.js
@@ -0,0 +1,199 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/compat/tst.client_compat.js: tests compatibility of the new client
+ * against an old server.
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_cmdutil = require('cmdutil');
+var mod_fast = require('../../lib/fast');
+var mod_path = require('path');
+var mod_net = require('net');
+var mod_vasync = require('vasync');
+var VError = require('verror');
+
+var mod_testcommon = require('../common');
+var mod_testcompat = require('./common');
+var testLog, testcases;
+
+function main()
+{
+	testLog = new mod_bunyan({
+	    'name': mod_path.basename(__filename),
+	    'level': process.env['LOG_LEVEL'] || 'fatal'
+	});
+
+	mod_testcommon.registerExitBlocker('tests');
+
+	mod_testcompat.setupOldServer({
+	    'ip': mod_testcommon.serverIp,
+	    'port': mod_testcommon.serverPort
+	}, function (err, old) {
+		if (err) {
+			mod_cmdutil.fail(err);
+		}
+
+		mod_vasync.forEachPipeline({
+		    'inputs': testcases,
+		    'func': runTestCase
+		}, function (err2) {
+			mod_testcompat.teardownOldServer(old, function () {
+				if (err2) {
+					mod_cmdutil.fail(err2);
+				}
+
+				console.error('%s tests passed',
+				    mod_path.basename(__filename));
+				mod_testcommon.unregisterExitBlocker('tests');
+			});
+		});
+	});
+}
+
+function runTestCase(testcase, callback)
+{
+	var log, csock, cclient;
+
+	console.error('test case: %s', testcase['name']);
+	log = testLog.child({ 'testcase': testcase['name'] });
+	csock = mod_net.createConnection(mod_testcommon.serverPort,
+	    mod_testcommon.serverIp);
+	cclient = new mod_fast.FastClient({
+	    'log': log.child({ 'component': 'FastClient' }),
+	    'transport': csock,
+	    'nRecentRequests': 100
+	});
+
+	csock.on('connect', function () {
+		log.info('connected client');
+		testcase['run'](log, cclient, function (err) {
+			if (err) {
+				console.error('test case "%s" FAILED: %s',
+				    testcase['name'], err.message);
+				console.error(err.stack);
+			}
+
+			cclient.detach();
+			csock.destroy();
+			callback(err);
+		});
+	});
+}
+
+testcases = [ {
+    'name': 'basic RPC, no data',
+    'run': function (log, fastclient, callback) {
+	fastclient.rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 0,
+	    'rpcmethod': 'echo',
+	    'rpcargs': [ {
+		'values': [],
+		'errorResult': false
+	    } ]
+	}, function (err, data, ndata) {
+		if (!err && ndata !== 0) {
+			err = new VError('expected 0 data items');
+		}
+
+		callback(err);
+	});
+    }
+
+}, {
+    'name': 'basic RPC, some data',
+    'run': function (log, fastclient, callback) {
+	fastclient.rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 6,
+	    'rpcmethod': 'echo',
+	    'rpcargs': [ {
+		/*
+		 * null is not allowed by the protocol, but the old server does
+		 * not prevent you from trying to send it
+		 */
+		'values': [ 'one', 'two', false, true, 7, { 'foo': 'bar' } ],
+		'errorResult': false
+	    } ]
+	}, function (err, data, ndata) {
+		if (err) {
+			callback(err);
+			return;
+		}
+
+		mod_assertplus.equal(data.length, ndata);
+		mod_assertplus.deepEqual(data,
+		    [ 'one', 'two', false, true, 7, { 'foo': 'bar' }  ]);
+		callback();
+	});
+    }
+
+}, {
+    'name': 'failed RPC, no data',
+    'run': function (log, fastclient, callback) {
+	fastclient.rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 0,
+	    'rpcmethod': 'echo',
+	    'rpcargs': [ {
+		'values': [],
+		'errorResult': true
+	    } ]
+	}, function (err, data, ndata) {
+		if (!err) {
+			callback(new Error('expected error'));
+			return;
+		}
+
+		mod_assertplus.equal(data.length, 0);
+		mod_assertplus.equal(data.length, ndata);
+		mod_assertplus.equal(err.name, 'FastRequestError');
+		err = VError.cause(err);
+		mod_assertplus.equal(err.name, 'FastServerError');
+		err = VError.cause(err);
+		mod_assertplus.equal(err.name, 'Error');
+		mod_assertplus.equal(err.message, 'boom boom!');
+		mod_assertplus.deepEqual(err.context, { 'result': 'poof' });
+		callback();
+	});
+    }
+
+}, {
+    'name': 'failed RPC, some data',
+    'run': function (log, fastclient, callback) {
+	fastclient.rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 3,
+	    'rpcmethod': 'echo',
+	    'rpcargs': [ {
+		'values': [ 5, true, 'bob' ],
+		'errorResult': true
+	    } ]
+	}, function (err, data, ndata) {
+		if (!err) {
+			callback(new Error('expected error'));
+			return;
+		}
+
+		mod_assertplus.equal(data.length, ndata);
+		mod_assertplus.deepEqual(data, [ 5, true, 'bob' ]);
+		mod_assertplus.equal(err.name, 'FastRequestError');
+		err = VError.cause(err);
+		mod_assertplus.equal(err.name, 'FastServerError');
+		err = VError.cause(err);
+		mod_assertplus.equal(err.name, 'Error');
+		mod_assertplus.equal(err.message, 'boom boom!');
+		mod_assertplus.deepEqual(err.context, { 'result': 'poof' });
+		callback();
+	});
+    }
+
+} ];
+
+main();
diff --git a/test/compat/setup.js b/test/compat/setup.js
new file mode 100644
index 0000000..54d89bf
--- /dev/null
+++ b/test/compat/setup.js
@@ -0,0 +1,94 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/compat/setup.js: command-line tool for setting up a local repository for
+ * running compatibility tests.  This is responsible for installing the legacy
+ * node-fast package, which requires using a copy of Node 0.10 (while the rest
+ * of this repo uses 0.12 or later).
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_child = require('child_process');
+var mod_cmdutil = require('cmdutil');
+var mod_forkexec = require('forkexec');
+var mod_fs = require('fs');
+var mod_vasync = require('vasync');
+
+var mod_compat = require('./common');
+
+/*
+ * We test against the Fast server that's widely deployed in Moray, which is
+ * 0.3.1.
+ */
+var FAST_MODULE_NAME = 'fast';
+var FAST_MODULE_VERSION = '0.3.1';
+
+function main()
+{
+	var npmbin;
+	var pkgtoinstall = FAST_MODULE_NAME + '@' + FAST_MODULE_VERSION;
+
+	mod_vasync.waterfall([
+	    function loadConfig(next) {
+		mod_compat.nodeConfigLoad(next);
+	    },
+
+	    function workaroundNpmMisdesign(nodeconfig, next) {
+		mod_assertplus.object(nodeconfig);
+		mod_assertplus.string(nodeconfig.nodebin);
+		mod_assertplus.string(nodeconfig.npmbin);
+		npmbin = nodeconfig.npmbin;
+
+		/*
+		 * Contrary to popular belief, npm does not necessarily install
+		 * non-global packages into the current directory.  If there's
+		 * no node_modules or package.json there, it walks up to the
+		 * nearest parent directory that has one "even if you happen to
+		 * have cd'ed into some other folder".  That's decidedly not
+		 * what we want here, but we can trick it by creating our own
+		 * node_modules directory here.  Of course, if it already
+		 * exists, we should do nothing.
+		 */
+		mod_fs.mkdir('node_modules', function (err) {
+			if (err && err['code'] == 'EEXIST') {
+				err = null;
+			}
+
+			next(err);
+		});
+	     },
+
+	     function installOldModule(next) {
+		process.stderr.write('installing legacy fast version ' +
+		    pkgtoinstall + ' ... ');
+		mod_forkexec.forkExecWait({
+		    'argv': [ npmbin, 'install', pkgtoinstall ]
+		}, function (err, info) {
+			if (err) {
+				process.stderr.write('FAIL\n');
+				next(err);
+				return;
+			}
+
+			process.stderr.write('done.\n');
+			next();
+	             });
+	     }
+	], function (err) {
+		if (err) {
+			mod_cmdutil.fail(err);
+		}
+
+		console.log('setup for compatibility tests');
+	});
+}
+
+main();
diff --git a/test/tst.allocator.js b/test/tst.allocator.js
new file mode 100644
index 0000000..3675061
--- /dev/null
+++ b/test/tst.allocator.js
@@ -0,0 +1,117 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/tst.allocator.js: tests our cheesy IdAllocator
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_subr = require('../lib/subr');
+
+var allocator, isAllocated, nQueries;
+
+console.log('test cases: bad arguments');
+mod_assertplus.throws(function () {
+	allocator = mod_subr.IdAllocator({});
+}, /args\.min \(number\) is required/);
+
+mod_assertplus.throws(function () {
+	allocator = mod_subr.IdAllocator({ 'min': 7 });
+}, /args\.max \(number\) is required/);
+
+mod_assertplus.throws(function () {
+	allocator = mod_subr.IdAllocator({ 'min': 7, 'max': 15 });
+}, /args\.isAllocated \(func\) is required/);
+
+mod_assertplus.throws(function () {
+	allocator = mod_subr.IdAllocator({ 'min': 18, 'max': 15,
+	    'isAllocated': function () {} });
+}, /min must be less than max/);
+
+mod_assertplus.throws(function () {
+	allocator = mod_subr.IdAllocator({ 'min': -1, 'max': 15,
+	    'isAllocated': function () {} });
+}, /min must be non-negative/);
+
+mod_assertplus.throws(function () {
+	allocator = mod_subr.IdAllocator({ 'min': 0, 'max': Math.pow(2, 37),
+	    'isAllocated': function () {} });
+}, /max is too big/);
+
+
+console.log('test cases: basic allocator wraps around');
+isAllocated = {};
+nQueries = 0;
+allocator = new mod_subr.IdAllocator({
+    'min': 0,
+    'max': 7,
+    'isAllocated': function (id) {
+	nQueries++;
+    	return (isAllocated[id]);
+    }
+});
+
+/*
+ * For the first round, we're going to continue acting like nothing is allocated
+ * to make sure that we wrap around the id space.
+ */
+mod_assertplus.equal(allocator.alloc(), 0);
+mod_assertplus.equal(nQueries, 1);
+mod_assertplus.equal(allocator.alloc(), 1);
+mod_assertplus.equal(nQueries, 2);
+mod_assertplus.equal(allocator.alloc(), 2);
+mod_assertplus.equal(nQueries, 3);
+mod_assertplus.equal(allocator.alloc(), 3);
+mod_assertplus.equal(allocator.alloc(), 4);
+mod_assertplus.equal(allocator.alloc(), 5);
+mod_assertplus.equal(allocator.alloc(), 6);
+mod_assertplus.equal(allocator.alloc(), 7);
+mod_assertplus.equal(nQueries, 8);
+
+/*
+ * Again, since we're pretending like nothing is allocated, the next round
+ * should wrap around again as normal.
+ */
+mod_assertplus.equal(allocator.alloc(), 0);
+mod_assertplus.equal(nQueries, 9);
+mod_assertplus.equal(allocator.alloc(), 1);
+mod_assertplus.equal(allocator.alloc(), 2);
+mod_assertplus.equal(allocator.alloc(), 3);
+mod_assertplus.equal(allocator.alloc(), 4);
+mod_assertplus.equal(allocator.alloc(), 5);
+mod_assertplus.equal(allocator.alloc(), 6);
+mod_assertplus.equal(allocator.alloc(), 7);
+mod_assertplus.equal(allocator.alloc(), 0);
+mod_assertplus.equal(allocator.alloc(), 1);
+mod_assertplus.equal(nQueries, 18);
+
+/*
+ * Now let's pretend like the next several are allocated.  Those should be
+ * skipped, and we should get "5" after asking four questions.
+ */
+console.log('test cases: allocator skips allocated ids');
+isAllocated[2] = true;
+isAllocated[3] = true;
+isAllocated[4] = true;
+mod_assertplus.equal(allocator.alloc(), 5);
+mod_assertplus.equal(nQueries, 22);
+
+
+console.log('test cases: allocator fails if everything is allocated');
+isAllocated[0] = true;
+isAllocated[1] = true;
+isAllocated[5] = true;
+isAllocated[6] = true;
+isAllocated[7] = true;
+mod_assertplus.throws(function () { allocator.alloc(); },
+    /all ids allocated/);
+mod_assertplus.equal(nQueries, 30);
+
+console.log('tst.allocator.js tests passed');
diff --git a/test/tst.client_generic.js b/test/tst.client_generic.js
new file mode 100644
index 0000000..708ac65
--- /dev/null
+++ b/test/tst.client_generic.js
@@ -0,0 +1,856 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/tst.client_generic.js: client API generic test suite
+ *
+ * This file contains a test runner (runTestCase) that executes fairly free-form
+ * test cases against the client API.  Most client API test cases can be fit
+ * into the much simpler model in tst.client_request.js, and we should generally
+ * put test cases in there when possible.  The test cases that need to go here
+ * include those where the end of the test is harder to identify.
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_jsprim = require('jsprim');
+var mod_net = require('net');
+var mod_path = require('path');
+var mod_vasync = require('vasync');
+var VError = require('verror');
+
+var mod_client = require('../lib/fast_client');
+var mod_protocol = require('../lib/fast_protocol');
+var mod_testcommon = require('./common');
+var mod_testclient = require('./common/client');
+
+var serverSocket;
+var testLog;
+
+function main()
+{
+	testLog = new mod_bunyan({
+	    'name': mod_path.basename(__filename),
+	    'level': process.env['LOG_LEVEL'] || 'fatal'
+	});
+
+	mod_testcommon.registerExitBlocker('test run');
+	mod_testcommon.mockServerSetup(function (s) {
+		testLog.info('server listening');
+		serverSocket = s;
+
+		mod_vasync.forEachPipeline({
+		    'inputs': test_cases,
+		    'func': runTestCase
+		}, function (err) {
+			if (err) {
+				throw (err);
+			}
+
+			mod_testcommon.mockServerTeardown(serverSocket);
+			mod_testcommon.unregisterExitBlocker('test run');
+			console.log('%s tests passed',
+			    mod_path.basename(__filename));
+		});
+	});
+}
+
+function runTestCase(testcase, callback)
+{
+	var ctc;
+
+	console.log('test case: %s', testcase.name);
+	ctc = new mod_testclient.ClientTestContext({
+	    'server': serverSocket,
+	    'log': testLog.child({ 'testcase': testcase.name })
+	});
+
+	ctc.establishConnection();
+	testcase.run(ctc, function () {
+		mod_assertplus.ok(ctc.ctc_closed,
+		    'test case did not call ClientTestContext.cleanup()');
+		callback();
+	});
+}
+
+
+/*
+ * This function executes the body of test cases that do this:
+ *
+ *     o send a request
+ *     o have the server respond to the request normally
+ *     o have the server send an extra response message
+ *     o expect the client to produce an error
+ *
+ * "firstIsError" indicates whether the first request should produce an error or
+ * a normal response.  "secondStatus" is the STATUS value to use for the
+ * server's extra message.
+ */
+function runDuplicateResponseTest(ctc, firstIsError, secondStatus, callback)
+{
+	var ctr;
+
+	mod_vasync.waterfall([
+	    function makeRequest(next) {
+		ctc.handleNextRequest({
+		    'data': !firstIsError,
+		    'error': firstIsError
+		});
+
+		ctr = ctc.makeRequest(next);
+	    },
+
+	    function afterFirstRequest(next) {
+		mod_assertplus.ok(ctc.ctc_error_client === null);
+
+		if (firstIsError) {
+			mod_assertplus.ok(ctr.ctr_error !== null);
+			mod_assertplus.ok(ctr.ctr_data.length === 0);
+		} else {
+			mod_assertplus.ok(ctr.ctr_error === null);
+			mod_assertplus.ok(ctr.ctr_data.length > 0);
+		}
+
+		ctc.ctc_log.debug('server sending extra response');
+		ctc.ctc_server_encoder.end({
+		    'msgid': ctc.ctc_server_message.msgid,
+		    'status': secondStatus,
+		    'data': secondStatus === mod_protocol.FP_STATUS_ERROR ?
+			mod_testcommon.dummyResponseError :
+			mod_testcommon.dummyResponseData
+		});
+
+		/*
+		 * This handler is used only to advance us to the next stage of
+		 * the waterfall.  The ClientTestContext will record the error
+		 * itself.
+		 */
+		ctc.ctc_fastclient.on('error', function () { next(); });
+	    },
+
+	    function checkClientError(next) {
+		var error = ctc.ctc_error_client;
+
+		mod_assertplus.ok(error !== null);
+		mod_assertplus.equal(error.name, 'FastProtocolError');
+		mod_assertplus.equal(VError.info(error).fastReason,
+		    'unknown_msgid');
+		mod_assertplus.equal(VError.info(error).fastMsgid,
+		    ctc.ctc_server_message.msgid);
+		mod_assertplus.equal(error.message,
+		    'fast protocol: received message with unknown msgid ' +
+		    ctc.ctc_server_message.msgid);
+		next();
+	    }
+	], callback);
+}
+
+/*
+ * This function executes tests that work by issuing several requests
+ * concurrently, inducing some client-wide failure, and issues another request.
+ * This verifies that we correctly fail outstanding requests in the face of
+ * failure and also fail subsequent requests issued on the same client.
+ */
+function runClientFailureTest(ctc, doFail, callback)
+{
+	var npending, nextra;
+	var earlyrqs, laterqs;
+
+	npending = 100;
+	nextra = 5;
+
+	mod_vasync.waterfall([
+	    function issueEarlyRequests(next) {
+		ctc.ctc_log.debug({
+		    'npending': npending
+		}, 'issuing requests to be pending during failure');
+		earlyrqs = issueRequests(ctc, npending, next);
+		setTimeout(doFail, 50);
+
+		/*
+		 * Configure the server to send a DATA message for the first
+		 * request so that we have one example where the request was
+		 * partially completed.
+		 */
+		ctc.ctc_server_decoder.once('data', function (message) {
+			ctc.ctc_server_encoder.write({
+			    'msgid': message.msgid,
+			    'status': mod_protocol.FP_STATUS_DATA,
+			    'data': mod_testcommon.dummyResponseData
+			});
+		});
+	    },
+
+	    function issueLateRequests(next) {
+		ctc.ctc_log.debug({
+		    'npending': nextra
+		}, 'issuing requests after failure');
+		laterqs = issueRequests(ctc, nextra, next);
+	    }
+	], function (err) {
+		if (err) {
+			/* None of the waterfall functions emits an error. */
+			throw (err);
+		}
+
+		earlyrqs.forEach(function (erq, i) {
+			var cause;
+			if (i === 0) {
+				mod_assertplus.equal(erq.ctr_data.length, 1);
+				mod_assertplus.deepEqual(erq.ctr_data[0],
+				    mod_testcommon.dummyValue);
+			} else {
+				mod_assertplus.equal(erq.ctr_data.length, 0);
+			}
+
+			mod_assertplus.ok(erq.ctr_error !== null);
+			mod_assertplus.ok(erq.ctr_done);
+			mod_assertplus.ok(erq.ctr_error.name,
+			    'FastRequestError');
+			cause = erq.ctr_error.cause();
+			mod_assertplus.equal(erq.ctr_error.message,
+			    'request failed: ' + cause.message);
+			mod_assertplus.equal(erq.ctr_request.requestId(),
+			    VError.info(erq.ctr_error).rpcMsgid);
+			/* The caller will check the cause details later. */
+		});
+
+		laterqs.forEach(function (lrq) {
+			var cause;
+
+			mod_assertplus.equal(lrq.ctr_data.length, 0);
+			mod_assertplus.ok(lrq.ctr_error !== null);
+			mod_assertplus.ok(lrq.ctr_done);
+			mod_assertplus.ok(lrq.ctr_error.name,
+			    'FastRequestError');
+			cause = lrq.ctr_error.cause();
+			mod_assertplus.equal(lrq.ctr_error.message,
+			    'request failed: ' + cause.message);
+			mod_assertplus.equal(lrq.ctr_request.requestId(),
+			    VError.info(lrq.ctr_error).rpcMsgid);
+			mod_assertplus.equal(cause.name, 'FastTransportError');
+			mod_assertplus.equal(cause.message,
+			    'transport detached');
+		});
+
+		callback(earlyrqs);
+	});
+}
+
+/*
+ * Issue "nrequests" and invoke "callback" once all are completed.
+ */
+function issueRequests(ctc, nrequests, callback)
+{
+	var labels, rqs, i;
+	var barrier;
+
+	barrier = mod_vasync.barrier();
+	barrier.start('init');
+
+	labels = [];
+	for (i = 0; i < nrequests; i++) {
+		labels.push('req ' + i);
+	}
+
+	rqs = labels.map(function (label, j) {
+		barrier.start(label);
+		return (ctc.makeRequest(function () { barrier.done(label); }));
+	});
+
+	barrier.on('drain', function () { callback(); });
+	setImmediate(function () { barrier.done('init'); });
+	return (rqs);
+}
+
+var test_cases = [ {
+    'name': 'server reports extra END   event (after END   event)',
+    'run': function (ctc, callback) {
+	runDuplicateResponseTest(ctc, false, mod_protocol.FP_STATUS_END,
+	    function () {
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+}, {
+    'name': 'server reports extra DATA  event (after END   event)',
+    'run': function (ctc, callback) {
+	runDuplicateResponseTest(ctc, false, mod_protocol.FP_STATUS_DATA,
+	    function () {
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+}, {
+    'name': 'server reports extra ERROR event (after END   event)',
+    'run': function (ctc, callback) {
+	runDuplicateResponseTest(ctc, false, mod_protocol.FP_STATUS_ERROR,
+	    function () {
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+}, {
+    'name': 'server reports extra END   event (after ERROR event)',
+    'run': function (ctc, callback) {
+	runDuplicateResponseTest(ctc, true, mod_protocol.FP_STATUS_END,
+	    function () {
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+}, {
+    'name': 'server reports extra DATA  event (after ERROR event)',
+    'run': function (ctc, callback) {
+	runDuplicateResponseTest(ctc, true, mod_protocol.FP_STATUS_DATA,
+	    function () {
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+}, {
+    'name': 'server reports extra ERROR event (after ERROR event)',
+    'run': function (ctc, callback) {
+	runDuplicateResponseTest(ctc, true, mod_protocol.FP_STATUS_ERROR,
+	    function () {
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+}, {
+    'name': 'server sends unsolicited message',
+    'run': function (ctc, callback) {
+	ctc.ctc_server_encoder.end({
+	    'msgid': 0x7,
+	    'status': mod_protocol.FP_STATUS_ERROR,
+	    'data': mod_testcommon.dummyResponseError
+	});
+
+	ctc.ctc_fastclient.on('error', function (err) {
+		var error = ctc.ctc_error_client;
+		mod_assertplus.ok(error !== null);
+		mod_assertplus.ok(err == error);
+		mod_assertplus.equal(error.name, 'FastProtocolError');
+		mod_assertplus.equal(VError.info(error).fastReason,
+		    'unknown_msgid');
+		mod_assertplus.equal(VError.info(error).fastMsgid, 0x7);
+		mod_assertplus.equal(error.message,
+		    'fast protocol: received message with unknown msgid 7');
+		ctc.cleanup();
+		callback();
+	});
+    }
+
+}, {
+    'name': 'server sends message with null value',
+    'run': function (ctc, callback) {
+	var ctr;
+
+	ctc.ctc_server_decoder.once('data', function (message) {
+		ctc.ctc_server_encoder.end({
+		    'msgid': message.msgid,
+		    'status': mod_protocol.FP_STATUS_END,
+		    'data': { 'd': [ true, null, 7 ] }
+		});
+	});
+
+	ctr = ctc.makeRequest(function () {
+		mod_assertplus.ok(ctr.ctr_error !== null);
+		mod_assertplus.deepEqual(ctr.ctr_data, [ true ]);
+		mod_assertplus.equal(ctr.ctr_error.cause().name,
+		    'FastProtocolError');
+		mod_assertplus.equal(ctr.ctr_error.cause().message,
+		    'server sent "null" value');
+		ctc.cleanup();
+		callback();
+	});
+    }
+
+ }, {
+    'name': 'pending and new requests: transport detach',
+    'run': function (ctc, callback) {
+	runClientFailureTest(ctc,
+	    function () {
+		ctc.ctc_log.debug('injecting failure: detach');
+		ctc.ctc_fastclient.detach();
+	    },
+	    function (requests) {
+		requests.forEach(function (rq) {
+			/*
+			 * runClientFailureTest has already checked the
+			 * top-level error.  We need to check its cause.
+			 */
+			var cause = rq.ctr_error.cause();
+			mod_assertplus.equal(cause.name, 'FastTransportError');
+			mod_assertplus.equal(cause.message,
+			    'client detached from transport');
+		});
+
+		mod_assertplus.equal(requests.length, 100);
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+ }, {
+    'name': 'pending and new requests: protocol error',
+    'run': function (ctc, callback) {
+	runClientFailureTest(ctc,
+	    function () {
+		ctc.ctc_log.debug('injecting failure: bad message');
+		/*
+		 * This message is invalid because the response data is empty.
+		 */
+		ctc.ctc_server_encoder.write({
+		    'msgid': 1,
+		    'status': mod_protocol.FP_STATUS_DATA,
+		    'data': { 'd': null }
+		});
+	    },
+	    function (requests) {
+		requests.forEach(function (rq) {
+			/*
+			 * runClientFailureTest has already checked the
+			 * top-level error.  We need to check its cause.
+			 */
+			var cause = rq.ctr_error.cause();
+			mod_assertplus.equal(cause.name, 'FastProtocolError');
+			mod_assertplus.ok(/data.d for .* must be an array/.test(
+			    cause.message));
+		});
+
+		mod_assertplus.equal(requests.length, 100);
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+}, {
+    'name': 'pending and new requests: unexpected end-of-stream',
+    'run': function (ctc, callback) {
+	runClientFailureTest(ctc,
+	    function () {
+		ctc.ctc_log.debug('injecting failure: end-of-stream');
+		ctc.ctc_server_encoder.end();
+	    },
+	    function (requests) {
+		requests.forEach(function (rq) {
+			/*
+			 * runClientFailureTest has already checked the
+			 * top-level error.  We need to check its cause.
+			 */
+			var cause = rq.ctr_error.cause();
+			mod_assertplus.equal(cause.name, 'FastProtocolError');
+			mod_assertplus.equal(cause.message,
+			    'unexpected end of transport stream');
+		});
+
+		mod_assertplus.equal(requests.length, 100);
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+}, {
+    'name': 'pending and new requests: socket error',
+    'run': function (ctc, callback) {
+	runClientFailureTest(ctc,
+	    function () {
+		ctc.ctc_log.debug('injecting failure: socket error');
+		ctc.ctc_server_sock.destroy();
+		ctc.ctc_client_sock.write('boom!');
+	    },
+	    function (requests) {
+		requests.forEach(function (rq) {
+			/*
+			 * runClientFailureTest has already checked the
+			 * top-level error.  We need to check its cause.
+			 */
+			var cause = rq.ctr_error.cause();
+			mod_assertplus.equal(cause.name, 'FastTransportError');
+			mod_assertplus.ok(
+			    /^unexpected error on transport:/.test(
+			    cause.message));
+
+			cause = cause.cause();
+			mod_assertplus.ok(/ECONNRESET/.test(cause.message));
+		});
+
+		mod_assertplus.equal(requests.length, 100);
+		ctc.cleanup();
+		callback();
+	    });
+    }
+
+}, {
+    'name': 'pending requests: serviced out of order',
+    'run': function (ctc, callback) {
+	var client_requests, server_requests;
+	var nrequests = 100;
+
+	/*
+	 * To test requests serviced out of order, we'll issue a bunch of
+	 * requests, then add a server handler that accumulates all of the
+	 * requests, shuffle the requests, and service them in shuffled order.
+	 * To make sure we actually got the correct data back for each request,
+	 * we'll tie the response data to the message id.
+	 */
+	client_requests = issueRequests(ctc, nrequests, function () {
+		client_requests.forEach(function (crq, i) {
+			mod_assertplus.ok(crq.ctr_error === null);
+			mod_assertplus.equal(crq.ctr_data.length, 1);
+			mod_assertplus.equal(crq.ctr_data[0],
+			    crq.ctr_request.requestId());
+		});
+
+		mod_assertplus.equal(client_requests.length, nrequests);
+		ctc.cleanup();
+		callback();
+	});
+
+	server_requests = [];
+	ctc.ctc_server_decoder.on('data', function (message) {
+		var i, j, tmp;
+
+		ctc.ctc_log.debug(message, 'server: buffering request');
+		server_requests.push(message);
+
+		if (server_requests.length < nrequests) {
+			return;
+		}
+
+		ctc.ctc_log.debug('server: shuffling and processing requests');
+
+		/*
+		 * Shuffle the array using a Fisher-Yates shuffle.
+		 */
+		mod_assertplus.equal(server_requests.length, nrequests);
+		for (i = server_requests.length - 1; i > 0; i--) {
+			j = Math.floor(server_requests.length * Math.random());
+			tmp = server_requests[i];
+			server_requests[i] = server_requests[j];
+			server_requests[j] = tmp;
+		}
+
+		server_requests.forEach(function (srq) {
+			ctc.ctc_server_encoder.write({
+			    'msgid': srq.msgid,
+			    'status': mod_protocol.FP_STATUS_END,
+			    'data': { 'd': [ srq.msgid ] }
+			});
+		});
+	});
+    }
+
+}, {
+    'name': 'request abandon, same tick',
+    'run': function (ctc, callback) {
+	var ctr;
+
+	ctc.handleNextRequest({ 'error': false, 'data': false });
+	ctr = ctc.makeRequest(function () {
+		mod_assertplus.ok(ctr.ctr_error !== null);
+		mod_assertplus.equal(ctr.ctr_data.length, 0);
+		ctc.cleanup();
+		callback();
+	});
+	ctr.ctr_request.abandon();
+	/* Make sure it's okay to do it again. */
+	ctr.ctr_request.abandon();
+    }
+
+}, {
+    'name': 'request abandon after complete',
+    'run': function (ctc, callback) {
+	var ctr;
+
+	ctc.handleNextRequest({ 'error': false, 'data': true });
+	ctr = ctc.makeRequest(function () {
+		ctr.ctr_request.abandon();
+		mod_assertplus.ok(ctr.ctr_error === null);
+		mod_assertplus.equal(ctr.ctr_data.length, 2);
+		ctc.cleanup();
+		callback();
+	});
+    }
+
+}, {
+    'name': 'request abandoned after some data',
+    'run': function (ctc, callback) {
+	var ctr;
+
+	ctc.ctc_server_decoder.once('data', function (message) {
+		ctc.ctc_server_encoder.write({
+		    'msgid': message.msgid,
+		    'status': mod_protocol.FP_STATUS_DATA,
+		    'data': mod_testcommon.dummyResponseData
+		});
+	});
+
+	ctr = ctc.makeRequest(function () {
+		mod_assertplus.ok(ctr.ctr_error !== null);
+		mod_assertplus.equal(ctr.ctr_data.length, 1);
+		mod_assertplus.equal(ctr.ctr_error.cause().name,
+		    'FastRequestAbandonedError');
+		ctc.cleanup();
+		callback();
+	});
+
+	ctr.ctr_request.once('data', function () {
+		ctr.ctr_request.abandon();
+	});
+    }
+}, {
+    'name': 'request with timeout',
+    'run': function (ctc, callback) {
+	var start, req;
+
+	start = process.hrtime();
+	req = ctc.ctc_fastclient.rpc({
+	    'rpcmethod': mod_testcommon.dummyRpcMethodName,
+	    'rpcargs': mod_testcommon.dummyRpcArgs,
+	    'timeout': 400
+	});
+
+	req.on('end', function () {
+		throw (new Error('unexpected request completion'));
+	});
+
+	req.on('data', function () {
+		throw (new Error('unexpected request data'));
+	});
+
+	req.on('error', function (err) {
+		var cause, delta;
+
+		cause = VError.cause(err);
+		mod_assertplus.equal(err.name, 'FastRequestError');
+		mod_assertplus.equal(err.message, 'request failed: ' +
+		    cause.message);
+
+		mod_assertplus.equal(cause.name, 'TimeoutError');
+		mod_assertplus.equal(VError.info(cause).timeout, 400);
+		delta = mod_jsprim.hrtimeMillisec(process.hrtime(start));
+		mod_assertplus.ok(delta >= 400, 'timeout was too short');
+		mod_assertplus.ok(delta < 4000, 'timeout was too long');
+		ctc.cleanup();
+		callback();
+	});
+    }
+
+}, {
+    'name': 'flow control from server to client',
+    'run': function (ctc, callback) {
+	var req, source;
+
+	/*
+	 * This test case has an analog in the server test suite.  Changes here
+	 * may need to be reflected there.  As with the server analog, this test
+	 * case relies on pause() working even in new mode, which isn't
+	 * supported on Node 0.10.
+	 */
+	if (mod_testcommon.predatesUsefulPause()) {
+		ctc.ctc_log.warn('skipping test (not supported on v0.10)');
+		ctc.cleanup();
+		setImmediate(callback);
+		return;
+	}
+
+	mod_vasync.waterfall([
+	    function makeRequest(next) {
+		/*
+		 * We cannot use ctc.makeRequest() because that will immediately
+		 * start reading 'data' events.  We want to avoid doing that to
+		 * make sure that we get flow-controlled.  In order to do that,
+		 * we need to make the request ourselves and pause the request
+		 * stream.
+		 *
+		 * We deliberately add no "error" handler yet since we do not
+		 * expect an error and the test should crash if we see one.
+		 */
+		ctc.ctc_log.debug('issuing flow-controlled RPC');
+		req = ctc.ctc_fastclient.rpc({
+		    'rpcmethod': mod_testcommon.dummyRpcMethodName,
+		    'rpcargs': mod_testcommon.dummyRpcArgs
+		});
+
+		ctc.ctc_client_sock.pause();
+
+		/*
+		 * Set up a server handler that writes data until it's blocked.
+		 */
+		ctc.ctc_server_decoder.once('data', function (message) {
+			var outmessage = {
+			    'msgid': message.msgid,
+			    'status': mod_protocol.FP_STATUS_DATA,
+			    'data': mod_testcommon.dummyResponseData
+			};
+
+			source = new mod_testcommon.FlowControlSource({
+			    'datum': outmessage,
+			    'restMs': 1000,
+			    'log': ctc.ctc_log.child({
+				'component': 'FlowControlSource'
+			    })
+			});
+
+			source.pipe(ctc.ctc_server_encoder);
+			source.once('resting', function () { next(); });
+		});
+	    },
+
+	    function checkFlowControlled(next) {
+		/*
+		 * These checks are brittle because they depend on internal Node
+		 * implementation details.  However, if those details change,
+		 * the failure here is likely to be explicit, and we can decide
+		 * how best to fix them.  We could skip these checks entirely,
+		 * but we'd like to be sure that the flow-control mechanism was
+		 * definitely engaged and that it was engaged because the client
+		 * is backed up.  If this check fails, and the Node internals on
+		 * which it relies have not changed, that means that we
+		 * inadvertently decided the server was flow-controlled above
+		 * even though the client's buffer is not full.
+		 */
+		ctc.ctc_log.debug('came to rest; verifying and moving on');
+		mod_assertplus.ok(mod_testcommon.isFlowControlled(
+		    ctc.ctc_client_sock));
+
+		/*
+		 * Stop the source and release the flow control.  Add an "error"
+		 * handler to the request, because the FlowControlSource above
+		 * will not actually generate a proper END message, so we expect
+		 * an error to be generated when the end-of-stream is reached.
+		 */
+		req.on('error', function (err) {
+			var cause = err.cause();
+			mod_assertplus.equal(cause.name, 'FastProtocolError');
+			mod_assertplus.equal(cause.message,
+			    'unexpected end of transport stream');
+			next();
+		});
+		req.on('end', function () {
+			/* See above. */
+			throw (new VError('unexpected request completion'));
+		});
+
+		source.stop();
+		ctc.ctc_client_sock.resume();
+	    }
+	], function (err) {
+		ctc.cleanup();
+		callback();
+	});
+    }
+
+}, {
+    'name': '10,000 requests, with max concurrency 100',
+    'run': function (ctc, callback) {
+	var queue, nrequests, i, first;
+	var nhaddata = 0;
+	var nhaderrors = 0;
+	var nhadboth = 0;
+	var nmaxoutstanding = 0;
+	var noutstanding = 0;
+	var expected = [];
+
+	nrequests = 10000;
+	queue = mod_vasync.queuev({
+	    'concurrency': 100,
+	    'worker': function makeRequest(which, qcallback) {
+		var dodata = expected[which].data;
+		var doerror = expected[which].error;
+		var ndata = 0;
+		var ctr;
+
+		if (dodata) {
+			ndata++;
+			nhaddata++;
+		}
+		if (!doerror) {
+			ndata++;
+		}
+
+		ctr = ctc.makeRequest(function () {
+			noutstanding--;
+
+			ctc.ctc_log.debug('verifying request', which,
+			    expected[which]);
+
+			mod_assertplus.equal(ctr.ctr_data.length, ndata);
+
+			if (doerror) {
+				mod_assertplus.ok(ctr.ctr_error !== null);
+				nhaderrors++;
+				if (dodata) {
+					nhadboth++;
+				}
+			} else {
+				mod_assertplus.ok(ctr.ctr_error === null);
+			}
+
+			qcallback();
+		});
+
+		if (++noutstanding > nmaxoutstanding) {
+			nmaxoutstanding = noutstanding;
+		}
+	    }
+	});
+
+	expected = [];
+	for (i = 0; i < nrequests; i++) {
+		queue.push(i);
+		expected[i] = {
+		    'data': i % 3 === 0,
+		    'error': i % 4 === 0
+		};
+	}
+
+	queue.on('end', function () {
+		mod_assertplus.equal(nhaderrors, 2500);
+		mod_assertplus.equal(nhaddata, 3334);
+		mod_assertplus.equal(nhadboth, 834);
+		mod_assertplus.equal(nmaxoutstanding, 100);
+		ctc.cleanup();
+		callback();
+	});
+
+	queue.close();
+
+	/*
+	 * Set up the server handler.
+	 */
+	first = null;
+	ctc.ctc_server_decoder.on('data', function (message) {
+		var which;
+
+		if (first === null) {
+			first = message.msgid;
+		}
+
+		which = message.msgid - first;
+		ctc.ctc_log.debug({
+		    'which': which,
+		    'message': message,
+		    'expected': expected[which]
+		}, 'server responding');
+		ctc.serverReply(message, expected[which]);
+	});
+    }
+} ];
+
+main();
diff --git a/test/tst.client_request.js b/test/tst.client_request.js
new file mode 100644
index 0000000..daa0501
--- /dev/null
+++ b/test/tst.client_request.js
@@ -0,0 +1,487 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/tst.client_request.js: client API per-request test suite
+ *
+ * This file contains a test runner (runTestCase) that executes test cases
+ * following a very prescribed form, where a client connects to the server, the
+ * server handles the request (often in surprising ways), and the client reports
+ * some number of errors.  This allows us to exercise a lot of different cases,
+ * including normal, valid RPC calls, RPC calls that return lots of data, and
+ * various edge cases like invalid messages and unexpected end-of-stream events.
+ * There are some test cases that require more control over client-server
+ * interaction.  These are defined in tst.client_generic.js.
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_microtime = require('microtime');
+var mod_net = require('net');
+var mod_path = require('path');
+var mod_vasync = require('vasync');
+var VError = require('verror');
+
+var mod_client = require('../lib/fast_client');
+var mod_protocol = require('../lib/fast_protocol');
+var mod_testclient = require('./common/client');
+var mod_testcommon = require('./common');
+
+var testLog;
+var startUts;
+var serverSocket;
+var serverPort = mod_testcommon.serverPort;
+var serverIp = mod_testcommon.serverIp;
+
+function main()
+{
+	testLog = new mod_bunyan({
+	    'name': mod_path.basename(__filename),
+	    'level': process.env['LOG_LEVEL'] || 'fatal'
+	});
+
+	startUts = mod_microtime.now();
+
+	mod_testcommon.registerExitBlocker('test run');
+	mod_testcommon.mockServerSetup(function (s) {
+		testLog.info('server listening');
+		serverSocket = s;
+
+		mod_vasync.forEachPipeline({
+		    'inputs': mockResponders,
+		    'func': runTestCase
+		}, function (err) {
+			if (err) {
+				throw (err);
+			}
+
+			mod_testcommon.unregisterExitBlocker('test run');
+			mod_testcommon.mockServerTeardown(serverSocket);
+			console.log('%s tests passed',
+			    mod_path.basename(__filename));
+		});
+	});
+}
+
+function runTestCase(testcase, callback)
+{
+	var ctc, ctr;
+
+	console.log('test case: %s', testcase.name);
+	ctc = new mod_testclient.ClientTestContext({
+	    'server': serverSocket,
+	    'log': testLog.child({ 'testcase': testcase['name'] })
+	});
+
+	ctc.establishConnection();
+	ctc.ctc_server_decoder.once('data', function (message) {
+		ctc.ctc_server_message = message;
+		testcase['serverReply'](ctc.ctc_server_sock, message,
+		    ctc.ctc_server_encoder, ctc.ctc_server_decoder);
+	});
+
+	ctr = ctc.makeRequest(function () {
+		testcase['clientCheck'](ctr.ctr_data, {
+		    'socket': ctc.ctc_error_sock,
+		    'client': ctc.ctc_error_client,
+		    'request': ctr.ctr_error
+		});
+
+		ctc.cleanup();
+		callback();
+	});
+}
+
+/*
+ * "mockResponders" describes a bunch of client test cases by describing what
+ * the server should do and what users of the client API should see when that
+ * happens.
+ *
+ *     name          a human-readable label for this test case
+ *
+ *     serverReply   a function invoked when the client makes this request.
+ *                   This function implements the server's response.  The
+ *                   function is invoked as:
+ *
+ *                       serverReply(socket, message, encoder)
+ *
+ *                   where
+ *
+ *               socket     the net.Socket connected to the client, which is
+ *                          useful for injecting malformed responses or
+ *                          generating socket errors
+ *
+ *               message    the first well-formed message read from the socket,
+ *                          which is useful for common test cases of responding
+ *                          to a basic RPC request
+ *
+ *               encoder    a FastMessageEncoder connected to the socket, which
+ *                          is convenient for sending well-formed responses.
+ *
+ *               decoder    a FastMessageDecoder connected to the socket, which
+ *                          is convenient for receiving well-formed messages
+ *
+ *     clientCheck   a function invoked after the test case has completed in
+ *                   to verify client behavior.  It's invoked as:
+ *
+ *                       clientCheck(data, error)
+ *
+ *                   where
+ *
+ *               data    an array of "data" events emitted by the client
+ *
+ *               errors  an object with properties for each possible error
+ *                       emitted during the test, including "socket", "client",
+ *                       and "request".
+ */
+
+var mockResponders = [ {
+    'name': 'ok, no data',
+    'serverReply': function (socket, message, encoder) {
+	assertNormalRequest(message);
+	encoder.end({
+	    'msgid': message.msgid,
+	    'status': mod_protocol.FP_STATUS_END,
+	    'data': mod_testcommon.dummyResponseEndEmpty
+	});
+    },
+    'clientCheck': function (data, errors) {
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client === null);
+	mod_assertplus.ok(errors.request === null);
+	mod_assertplus.equal(data.length, 0);
+    }
+
+}, {
+    'name': 'ok, with 4 data messages, with 0-4 data objects per message',
+    'serverReply': function (socket, message, encoder) {
+	var nmessages, i, j, d;
+
+	assertNormalRequest(message);
+	nmessages = 5;
+	for (i = 0; i < nmessages; i++) {
+		d = [];
+		for (j = 0; j < i; j++) {
+			d.push('string ' + i + '_' + j);
+		}
+		encoder.write({
+		    'msgid': message.msgid,
+		    'status': i == nmessages - 1 ?
+		        mod_protocol.FP_STATUS_END :
+			mod_protocol.FP_STATUS_DATA,
+		    'data': { 'd': d }
+		});
+	}
+
+	encoder.end();
+    },
+    'clientCheck': function (data, errors) {
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client === null);
+	mod_assertplus.ok(errors.request === null);
+	mod_assertplus.deepEqual(data, [
+	    'string 1_0', 'string 2_0', 'string 2_1', 'string 3_0',
+	    'string 3_1', 'string 3_2', 'string 4_0', 'string 4_1',
+	    'string 4_2', 'string 4_3'
+	]);
+    }
+
+}, {
+    'name': 'error, no data',
+    'serverReply': function (socket, message, encoder) {
+	assertNormalRequest(message);
+	encoder.end({
+	    'msgid': message.msgid,
+	    'status': mod_protocol.FP_STATUS_ERROR,
+	    'data': mod_testcommon.dummyResponseError
+	});
+    },
+    'clientCheck': function (data, errors) {
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client === null);
+	mod_assertplus.ok(errors.request !== null);
+	mod_assertplus.equal(data.length, 0);
+	assertServerError(errors.request, mod_testcommon.dummyError);
+    }
+
+}, {
+    'name': 'error, after data',
+    'serverReply': function (socket, message, encoder) {
+	var nmessages, i;
+	assertNormalRequest(message);
+
+	nmessages = 5;
+	for (i = 0; i < nmessages; i++) {
+		encoder.write({
+		    'msgid': message.msgid,
+		    'status': mod_protocol.FP_STATUS_DATA,
+		    'data': mod_testcommon.dummyResponseData
+		});
+	}
+
+	encoder.end({
+	    'msgid': message.msgid,
+	    'status': mod_protocol.FP_STATUS_ERROR,
+	    'data': mod_testcommon.dummyResponseError
+	});
+    },
+    'clientCheck': function (data, errors) {
+	var i;
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client === null);
+	mod_assertplus.ok(errors.request !== null);
+	mod_assertplus.equal(data.length, 5);
+
+	for (i = 0; i < data.length; i++) {
+		mod_assertplus.deepEqual(data[i], mod_testcommon.dummyValue);
+	}
+
+	assertServerError(errors.request, mod_testcommon.dummyError);
+    }
+
+}, {
+    'name': 'unexpected end of stream: no response at all',
+    'serverReply': function (socket, message, encoder) {
+	socket.end();
+    },
+    'clientCheck': function (data, errors) {
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client !== null);
+	mod_assertplus.ok(errors.request !== null);
+	mod_assertplus.equal(data.length, 0);
+
+	mod_assertplus.equal(errors.client.name, 'FastProtocolError');
+	mod_assertplus.equal(errors.client.message,
+	    'unexpected end of transport stream');
+	mod_testcommon.assertRequestError(errors.request, errors.client);
+    }
+
+}, {
+    'name': 'unexpected end of stream: partial message response',
+    'serverReply': function (socket, message, encoder) {
+	var buf = new Buffer(1);
+	buf.writeUInt8(mod_protocol.FP_VERSION_1, mod_protocol.FP_OFF_VERSION);
+	socket.end(buf);
+    },
+    'clientCheck': function (data, errors) {
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client !== null);
+	mod_assertplus.ok(errors.request !== null);
+	mod_assertplus.equal(data.length, 0);
+
+	mod_assertplus.equal(errors.client.name, 'FastProtocolError');
+	mod_assertplus.equal(errors.client.message,
+	    'fast protocol: incomplete message at end-of-stream');
+	mod_testcommon.assertRequestError(errors.request, errors.client);
+    }
+
+}, {
+    'name': 'unexpected end of stream: complete DATA message, no END',
+    'serverReply': function (socket, message, encoder) {
+	encoder.end({
+	    'msgid': message.msgid,
+	    'status': mod_protocol.FP_STATUS_DATA,
+	    'data': mod_testcommon.dummyResponseData
+	});
+    },
+    'clientCheck': function (data, errors) {
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client !== null);
+	mod_assertplus.ok(errors.request !== null);
+	mod_assertplus.equal(data.length, 1);
+	mod_assertplus.deepEqual(data[0], mod_testcommon.dummyValue);
+
+	mod_assertplus.equal(errors.client.name, 'FastProtocolError');
+	mod_assertplus.equal(errors.client.message,
+	    'unexpected end of transport stream');
+	mod_testcommon.assertRequestError(errors.request, errors.client);
+    }
+
+}, {
+    'name': 'server responds with wrong msgid',
+    'serverReply': function (socket, message, encoder) {
+	mod_assertplus.ok(message.msgid != 47);
+	encoder.end({
+	    'msgid': 47,
+	    'status': mod_protocol.FP_STATUS_END,
+	    'data': mod_testcommon.dummyResponseData
+	});
+    },
+    'clientCheck': function (data, errors) {
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client !== null);
+	mod_assertplus.ok(errors.request !== null);
+	mod_assertplus.equal(data.length, 0);
+
+	mod_assertplus.equal(errors.client.name, 'FastProtocolError');
+	mod_assertplus.equal(errors.client.message,
+	    'fast protocol: received message with unknown msgid 47');
+	mod_testcommon.assertRequestError(errors.request, errors.client);
+    }
+
+}, {
+    'name': 'server responds with invalid message',
+    'serverReply': function (socket, message, encoder) {
+	/*
+	 * This test case exercises client handling of all decoder errors.  The
+	 * various decoder failure modes are tested separately in
+	 * ./test/tst.protocol_decoder.js.
+	 */
+	var buf = new Buffer(mod_protocol.FP_HEADER_SZ + 1);
+	mod_testcommon.writeMessageForEncodedData(
+	    buf, 3, mod_protocol.FP_STATUS_END, '{', 0);
+	socket.end(buf);
+    },
+    'clientCheck': function (data, errors) {
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client !== null);
+	mod_assertplus.ok(errors.request !== null);
+	mod_assertplus.equal(data.length, 0);
+
+	mod_assertplus.equal(errors.client.name, 'FastProtocolError');
+	mod_assertplus.ok(/fast protocol: invalid JSON/.test(
+	    errors.client.message));
+	mod_testcommon.assertRequestError(errors.request, errors.client);
+    }
+
+}, {
+    'name': 'server responds with invalid error',
+    'serverReply': function (socket, message, encoder) {
+	encoder.end({
+	    'msgid': message.msgid,
+	    'status': mod_protocol.FP_STATUS_ERROR,
+	    'data': { 'd': {} }
+	});
+    },
+    'clientCheck': function (data, errors) {
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client !== null);
+	mod_assertplus.ok(errors.request !== null);
+	mod_assertplus.equal(data.length, 0);
+
+	mod_assertplus.equal(errors.client.name, 'FastProtocolError');
+	mod_assertplus.ok(/data.d for ERROR messages must have name/.test(
+	    errors.client.message));
+	mod_testcommon.assertRequestError(errors.request, errors.client);
+    }
+
+}, {
+    'name': 'ok, with 10,000 data messages',
+    'serverReply': function (socket, message, encoder) {
+	var nmessages, i;
+
+	assertNormalRequest(message);
+	nmessages = 10000;
+	for (i = 0; i < nmessages; i++) {
+		encoder.write({
+		    'msgid': message.msgid,
+		    'status': mod_protocol.FP_STATUS_DATA,
+		    'data': { 'd': [ 'string_' + i ] }
+		});
+	}
+
+	encoder.end({
+	    'msgid': message.msgid,
+	    'status': mod_protocol.FP_STATUS_END,
+	    'data': { 'd': [ 'lastmessage' ] }
+	});
+    },
+    'clientCheck': function (data, errors) {
+	var i;
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client === null);
+	mod_assertplus.ok(errors.request === null);
+	mod_assertplus.equal(data.length, 10001);
+
+	for (i = 0; i < data.length - 1; i++) {
+		mod_assertplus.equal(data[i], 'string_' + i);
+	}
+
+	mod_assertplus.equal(data[data.length - 1], 'lastmessage');
+    }
+
+}, {
+    'name': 'ok, with 10,000 items in an END message',
+    'serverReply': function (socket, message, encoder) {
+	var nitems, d, i;
+
+	assertNormalRequest(message);
+	nitems = 10000;
+	d = [];
+	for (i = 0; i < nitems; i++) {
+		d.push('string_' + i);
+	}
+
+	encoder.end({
+	    'msgid': message.msgid,
+	    'status': mod_protocol.FP_STATUS_END,
+	    'data': { 'd': d }
+	});
+    },
+    'clientCheck': function (data, errors) {
+	var i;
+	mod_assertplus.ok(errors.socket === null);
+	mod_assertplus.ok(errors.client === null);
+	mod_assertplus.ok(errors.request === null);
+	mod_assertplus.equal(data.length, 10000);
+
+	for (i = 0; i < data.length; i++) {
+		mod_assertplus.equal(data[i], 'string_' + i);
+	}
+    }
+} ];
+
+/*
+ * Asserts that the given Fast message represents a well-formed RPC request.
+ */
+function assertNormalRequest(message)
+{
+	mod_assertplus.equal(message.status, mod_protocol.FP_STATUS_DATA);
+	mod_assertplus.object(message.data);
+	mod_assertplus.object(message.data.m);
+	mod_assertplus.string(message.data.m.name);
+	mod_assertplus.ok(message.data.m.uts >= startUts);
+	mod_assertplus.ok(message.data.m.uts <= mod_microtime.now());
+	mod_assertplus.array(message.data.d);
+}
+
+/*
+ * Asserts that the given found_error matches what we would expect if the server
+ * responded with the given server_error.
+ */
+function assertServerError(found_error, server_error)
+{
+	/*
+	 * Our current behavior is extremely pedantic, but at least it's clear
+	 * what really happened in all cases.
+	 */
+	var cause, info;
+
+	mod_assertplus.equal(found_error.name, 'FastRequestError');
+	mod_assertplus.equal(found_error.message,
+	    'request failed: server error: ' + server_error.message);
+
+	cause = found_error.cause();
+	mod_assertplus.equal(cause.name, 'FastServerError');
+	mod_assertplus.equal(cause.message,
+	    'server error: ' + server_error.message);
+
+	cause = cause.cause();
+	mod_assertplus.equal(cause.name, server_error.name);
+	mod_assertplus.equal(cause.message, server_error.message);
+
+	info = VError.info(found_error);
+	mod_assertplus.number(info['rpcMsgid'], 1);
+	mod_assertplus.equal(info['rpcMethod'],
+	    mod_testcommon.dummyRpcMethodName);
+	mod_assertplus.equal(info['dummyProp'], 'dummyVal');
+}
+
+main();
diff --git a/test/tst.protocol_decoder.js b/test/tst.protocol_decoder.js
new file mode 100644
index 0000000..2436c78
--- /dev/null
+++ b/test/tst.protocol_decoder.js
@@ -0,0 +1,561 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/tst.protocol_decoder.js: fast protocol decoder tests
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_cmdutil = require('cmdutil');
+var mod_crc = require('crc');
+var mod_extsprintf = require('extsprintf');
+var mod_path = require('path');
+var mod_vasync = require('vasync');
+var VError = require('verror');
+
+var mod_protocol = require('../lib/fast_protocol');
+var printf = mod_extsprintf.printf;
+
+var mod_testcommon = require('./common');
+
+var test_cases;
+
+function main()
+{
+	mod_testcommon.registerExitBlocker('test run');
+	mod_vasync.forEachPipeline({
+	    'inputs': test_cases,
+	    'func': runTestCase
+	}, function (err) {
+		if (err) {
+			throw (err);
+		}
+
+		mod_testcommon.unregisterExitBlocker('test run');
+		printf('%s tests passed\n', mod_path.basename(__filename));
+	});
+}
+
+function runTestCase(testcase, callback)
+{
+	var decoder = new mod_protocol.FastMessageDecoder();
+	var data = [];
+	var error = null;
+
+	printf('test case: %s: ', testcase['name']);
+
+	decoder.on('data', function (c) { data.push(c); });
+	decoder.on('error', function (err) {
+		mod_assertplus.ok(error === null);
+		error = err;
+		testcase['check'](error, data);
+		printf('ok\n');
+		callback();
+	});
+	decoder.on('end', function () {
+		mod_assertplus.ok(error === null);
+		testcase['check'](error, data);
+		printf('ok\n');
+		callback();
+	});
+
+	decoder.end(testcase['input']());
+}
+
+var sample_object = { 'd': [ { 'hello': 'world' } ] };
+var sample_data = JSON.stringify(sample_object);
+var sample_crc = mod_crc.crc16(sample_data);
+
+var sample_error = { 'd': { 'name': 'AnError', 'message': 'boom!' } };
+
+/* This object winds up being about 28MB encoded as JSON. */
+var big_object = { 'd': [ mod_testcommon.makeBigObject(10, 6) ] };
+var big_data = JSON.stringify(big_object);
+var big_crc = mod_crc.crc16(big_data);
+
+test_cases = [ {
+    'name': 'basic DATA message',
+    'input': function () {
+	/*
+	 * The first few of these test cases hardcode protocol values to make
+	 * sure these constants don't break silently on us (e.g., checking null
+	 * against undefined because FP_OFF_TYPE has been deleted).  Later,
+	 * we'll just use the constants for clarity.
+	 */
+	var buf = new Buffer(mod_protocol.FP_HEADER_SZ + sample_data.length);
+	buf.writeUInt8(0x1, mod_protocol.FP_OFF_VERSION);
+	buf.writeUInt8(0x1, mod_protocol.FP_OFF_TYPE);
+	buf.writeUInt8(0x1, mod_protocol.FP_OFF_STATUS);
+	buf.writeUInt32BE(0xbadcafe, mod_protocol.FP_OFF_MSGID);
+	buf.writeUInt32BE(sample_crc, mod_protocol.FP_OFF_CRC);
+	buf.writeUInt32BE(sample_data.length, mod_protocol.FP_OFF_DATALEN);
+	buf.write(sample_data, mod_protocol.FP_OFF_DATA);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error === null);
+	mod_assertplus.equal(data.length, 1);
+	mod_assertplus.equal(data[0].msgid, 0xbadcafe);
+	mod_assertplus.equal(data[0].status, mod_protocol.FP_STATUS_DATA);
+	mod_assertplus.deepEqual(data[0].data, sample_object);
+    }
+}, {
+    'name': 'large END message',
+    'input': function () {
+	return (makeMessageForData(
+	    14, mod_protocol.FP_STATUS_END, big_object));
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error === null);
+	mod_assertplus.equal(data.length, 1);
+	mod_assertplus.equal(data[0].msgid, 14);
+	mod_assertplus.equal(data[0].status, mod_protocol.FP_STATUS_END);
+	mod_assertplus.deepEqual(data[0].data, big_object);
+    }
+}, {
+    'name': 'basic ERROR message',
+    'input': function () {
+	return (makeMessageForData(47, 0x3, sample_error));
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error === null);
+	mod_assertplus.equal(data.length, 1);
+	mod_assertplus.equal(data[0].msgid, 47);
+	mod_assertplus.equal(data[0].status, mod_protocol.FP_STATUS_ERROR);
+	mod_assertplus.deepEqual(data[0].data, sample_error);
+    }
+}, {
+    'name': 'DATA message with maximum msgid',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf.writeUInt32BE(mod_protocol.FP_MSGID_MAX, mod_protocol.FP_OFF_MSGID);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error === null);
+	mod_assertplus.equal(data.length, 1);
+	mod_assertplus.equal(data[0].msgid, 2147483647);
+	mod_assertplus.equal(data[0].status, mod_protocol.FP_STATUS_DATA);
+	mod_assertplus.deepEqual(data[0].data, sample_object);
+    }
+}, {
+    'name': 'empty stream',
+    'input': function () {
+	return (undefined);
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error === null);
+	mod_assertplus.equal(data.length, 0);
+    }
+}, {
+    'name': '10,000 DATA messages',
+    'input': function () {
+	var nmessages, buf, msgsize, msgoffset, i;
+
+	nmessages = 10000;
+	msgsize = mod_protocol.FP_HEADER_SZ + sample_data.length;
+	buf = new Buffer(nmessages * msgsize);
+	for (i = 0; i < nmessages; i++) {
+		msgoffset = i * msgsize;
+		mod_testcommon.writeMessageForEncodedData(buf, i + 1,
+		    mod_protocol.FP_STATUS_DATA, sample_data, msgoffset);
+	}
+
+	return (buf);
+    },
+    'check': function (error, data) {
+	var i;
+	mod_assertplus.ok(error === null);
+	mod_assertplus.equal(data.length, 10000);
+	for (i = 0; i < data.length; i++) {
+		mod_assertplus.equal(data[i].msgid, i + 1);
+		mod_assertplus.equal(data[i].status,
+		    mod_protocol.FP_STATUS_DATA);
+		mod_assertplus.deepEqual(data[i].data, sample_object);
+	}
+    }
+}, {
+    'name': '10,000 messages with an error contained',
+    'input': function () {
+	var nmessages, buf, msgsize, msgoffset, i;
+
+	nmessages = 10000;
+	msgsize = mod_protocol.FP_HEADER_SZ + sample_data.length;
+	buf = new Buffer(nmessages * msgsize);
+	for (i = 0; i < nmessages; i++) {
+		msgoffset = i * msgsize;
+		mod_testcommon.writeMessageForEncodedData(buf, i + 1,
+		    mod_protocol.FP_STATUS_DATA, sample_data, msgoffset);
+		if (i == 1000) {
+			buf.writeUInt8(0x0,
+			    msgoffset + mod_protocol.FP_OFF_VERSION);
+		}
+	}
+
+	return (buf);
+    },
+    'check': function (error, data) {
+	var i;
+	mod_assertplus.ok(error !== null);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/unsupported version 0/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason,
+	    'unsupported_version');
+	mod_assertplus.equal(VError.info(error).foundVersion, 0);
+
+	mod_assertplus.equal(data.length, 1000);
+	for (i = 0; i < data.length; i++) {
+		mod_assertplus.equal(data[i].msgid, i + 1);
+		mod_assertplus.equal(data[i].status,
+		    mod_protocol.FP_STATUS_DATA);
+		mod_assertplus.deepEqual(data[i].data, sample_object);
+	}
+    }
+}, {
+    'name': 'bad version (0)',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf.writeUInt8(0, mod_protocol.FP_OFF_VERSION);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/unsupported version 0/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason,
+	    'unsupported_version');
+	mod_assertplus.equal(VError.info(error).foundVersion, 0);
+    }
+}, {
+    'name': 'bad version (37)',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf.writeUInt8(37, mod_protocol.FP_OFF_VERSION);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/unsupported version 37/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason,
+	    'unsupported_version');
+	mod_assertplus.equal(VError.info(error).foundVersion, 37);
+    }
+}, {
+    'name': 'bad type (0)',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf.writeUInt8(0, mod_protocol.FP_OFF_TYPE);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/unsupported type 0x0/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'unsupported_type');
+	mod_assertplus.equal(VError.info(error).foundType, 0);
+    }
+}, {
+    'name': 'bad type (2)',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf.writeUInt8(2, mod_protocol.FP_OFF_TYPE);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/unsupported type 0x2/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'unsupported_type');
+	mod_assertplus.equal(VError.info(error).foundType, 2);
+    }
+}, {
+    'name': 'bad status (0)',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf.writeUInt8(0, mod_protocol.FP_OFF_STATUS);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/unsupported status 0x0/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason,
+	    'unsupported_status');
+	mod_assertplus.equal(VError.info(error).foundStatus, 0);
+    }
+}, {
+    'name': 'bad status (4)',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf.writeUInt8(0x4, mod_protocol.FP_OFF_STATUS);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/unsupported status 0x4/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason,
+	    'unsupported_status');
+	mod_assertplus.equal(VError.info(error).foundStatus, 4);
+    }
+}, {
+    'name': 'bad msgid (too large)',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf.writeUInt32BE(mod_protocol.FP_MSGID_MAX + 1,
+	    mod_protocol.FP_OFF_MSGID);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/invalid msgid 2147483648/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'invalid_msgid');
+	mod_assertplus.equal(VError.info(error).foundMsgid, 2147483648);
+    }
+}, {
+    'name': 'bad CRC',
+    'input': function () {
+	var buf = makeSampleMessage();
+	mod_assertplus.ok(
+	    buf.readUInt32BE(mod_protocol.FP_OFF_CRC) != 0xdeadbeef);
+	buf.writeUInt32BE(0xdeadbeef, mod_protocol.FP_OFF_CRC);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/expected CRC 3735928559, found/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'bad_crc');
+	mod_assertplus.equal(VError.info(error).crcCalculated, sample_crc);
+	mod_assertplus.equal(VError.info(error).crcExpected, 0xdeadbeef);
+    }
+}, {
+    'name': 'bad: DATA message with non-array data.d',
+    'input': function () {
+	var data, buf;
+	data = { 'd': { 'foo': 'bar' } };
+	buf = makeMessageForData(3, mod_protocol.FP_STATUS_DATA, data);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/data.d for DATA.*must be an array/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'bad_data_d');
+    }
+}, {
+    'name': 'bad: END message with non-array data.d',
+    'input': function () {
+	var data, buf;
+	data = { 'd': { 'foo': 'bar' } };
+	buf = makeMessageForData(3, mod_protocol.FP_STATUS_END, data);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/data.d for .*END messages must be an array/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'bad_data_d');
+    }
+}, {
+    'name': 'bad: DATA message with null data',
+    'input': function () {
+	var data, buf;
+	data = null;
+	buf = makeMessageForData(3, mod_protocol.FP_STATUS_DATA, data);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/message data must be a non-null object/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'bad_data');
+    }
+}, {
+    'name': 'bad: DATA message with string data',
+    'input': function () {
+	var data, buf;
+	data = 'foobar';
+	buf = makeMessageForData(3, mod_protocol.FP_STATUS_DATA, data);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/message data must be a non-null object/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'bad_data');
+    }
+}, {
+    'name': 'bad: ERROR message with missing data',
+    'input': function () {
+	return (makeMessageForData(47, mod_protocol.FP_STATUS_ERROR, {}));
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/data\.d for ERROR messages must have name/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'bad_error');
+    }
+}, {
+    'name': 'bad: ERROR message with null d',
+    'input': function () {
+	return (makeMessageForData(47, mod_protocol.FP_STATUS_ERROR,
+	    { 'd': null }));
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/data\.d for ERROR messages must have name/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'bad_error');
+    }
+}, {
+    'name': 'bad: ERROR message with bad name',
+    'input': function () {
+	return (makeMessageForData(47, mod_protocol.FP_STATUS_ERROR,
+	    { 'd': { 'name': 47, 'message': 'threeve' } }));
+    },
+    'check': function (error, data) {
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/data\.d for ERROR messages must have name/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'bad_error');
+    }
+}, {
+    'name': 'bad: end of stream with 1-byte header',
+    'input': function () {
+	var buf = new Buffer(1);
+	buf.writeUInt8(mod_protocol.FP_VERSION_1, mod_protocol.FP_OFF_VERSION);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/incomplete message at end-of-stream/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason,
+	    'incomplete_message');
+    }
+}, {
+    'name': 'bad: end of stream with full header and no data',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf = buf.slice(0, mod_protocol.FP_HEADER_SZ);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/incomplete message at end-of-stream/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason,
+	    'incomplete_message');
+    }
+}, {
+    'name': 'bad: end of stream with full header and partial data',
+    'input': function () {
+	var buf = makeSampleMessage();
+	buf = buf.slice(0, mod_protocol.FP_HEADER_SZ + 1);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	mod_assertplus.ok(/incomplete message at end-of-stream/.test(
+	    error.message));
+	mod_assertplus.equal(VError.info(error).fastReason,
+	    'incomplete_message');
+    }
+}, {
+    'name': 'bad: invalid JSON data payload',
+    'input': function () {
+	var datalen, dataenc, buf;
+	dataenc = '{ "hello"';
+	datalen = Buffer.byteLength(dataenc);
+	buf = new Buffer(mod_protocol.FP_HEADER_SZ + datalen);
+	mod_testcommon.writeMessageForEncodedData(buf, 3,
+	    mod_protocol.FP_STATUS_DATA, dataenc, 0);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	/* JSSTYLED */
+	mod_assertplus.ok(/invalid JSON in "data"/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'invalid_json');
+    }
+}, {
+    'name': 'bad: 0-byte payload',
+    'input': function () {
+	var buf;
+	buf = new Buffer(mod_protocol.FP_HEADER_SZ);
+	mod_testcommon.writeMessageForEncodedData(buf, 3,
+	    mod_protocol.FP_STATUS_DATA, '', 0);
+	return (buf);
+    },
+    'check': function (error, data) {
+	mod_assertplus.ok(error instanceof Error);
+	mod_assertplus.equal(data.length, 0);
+	mod_assertplus.equal(error.name, 'FastProtocolError');
+	/* JSSTYLED */
+	mod_assertplus.ok(/invalid JSON in "data"/.test(error.message));
+	mod_assertplus.equal(VError.info(error).fastReason, 'invalid_json');
+    }
+} ];
+
+function makeSampleMessage()
+{
+	return (makeMessageForData(mod_protocol.FP_MSGID_MAX,
+	    mod_protocol.FP_STATUS_DATA, sample_object));
+}
+
+function makeMessageForData(msgid, status, data)
+{
+	var datalen, dataenc, buf;
+
+	mod_assertplus.number(msgid);
+	mod_assertplus.number(status);
+	dataenc = JSON.stringify(data);
+	datalen = Buffer.byteLength(dataenc);
+	buf = new Buffer(mod_protocol.FP_HEADER_SZ + datalen);
+	mod_testcommon.writeMessageForEncodedData(
+	    buf, msgid, status, dataenc, 0);
+	return (buf);
+}
+
+main();
diff --git a/test/tst.protocol_encoder.js b/test/tst.protocol_encoder.js
new file mode 100644
index 0000000..7646e09
--- /dev/null
+++ b/test/tst.protocol_encoder.js
@@ -0,0 +1,265 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/tst.protocol_encoder.js: fast protocol encoder tests
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_cmdutil = require('cmdutil');
+var mod_extsprintf = require('extsprintf');
+var mod_path = require('path');
+
+var mod_protocol = require('../lib/fast_protocol');
+var printf = mod_extsprintf.printf;
+
+var mod_testcommon = require('./common');
+
+var bigdata, bigdataval, test_cases;
+var circular = {};
+circular['a'] = 47;
+circular['b'] = circular;
+
+function main()
+{
+	/* This object winds up being about 28MB encoded as JSON. */
+	printf('generating large object ... ');
+	bigdata = [ mod_testcommon.makeBigObject(10, 6) ];
+	bigdataval = JSON.stringify(bigdata);
+	printf('%d bytes (stringified)\n', bigdataval.length);
+
+	test_cases.forEach(runTestCase);
+	printf('%s tests passed\n', mod_path.basename(__filename));
+}
+
+test_cases = [ {
+    'name': 'basic data message',
+    'input': {
+	'msgid': 1,
+	'status': mod_protocol.FP_STATUS_DATA,
+	'data': [ 'hello', 'world' ]
+    },
+    'check': function (output, parsed) {
+	var expected = '["hello","world"]';
+	var expectedlen = Buffer.byteLength(expected);
+	mod_assertplus.equal(parsed.pm_datalen, expectedlen);
+	mod_assertplus.equal(parsed.pm_data.toString('utf8'), expected);
+	mod_assertplus.equal(parsed.pm_msgid, 1);
+	mod_assertplus.equal(parsed.pm_status, mod_protocol.FP_STATUS_DATA);
+	mod_assertplus.equal(parsed.pm_crc, 10980);
+    }
+}, {
+    'name': 'large data message',
+    'input': {
+	'msgid': 7,
+	'status': mod_protocol.FP_STATUS_DATA,
+	'data': function () { return (bigdata); }
+    },
+    'check': function (output, parsed) {
+	var expected = bigdataval;
+	var expectedlen = Buffer.byteLength(expected);
+	mod_assertplus.equal(parsed.pm_datalen, expectedlen);
+	mod_assertplus.equal(parsed.pm_data.toString('utf8'), expected);
+	mod_assertplus.equal(parsed.pm_msgid, 7);
+	mod_assertplus.equal(parsed.pm_status, mod_protocol.FP_STATUS_DATA);
+    }
+}, {
+    'name': 'minimum msgid',
+    'input': {
+	'msgid': 0,
+	'status': mod_protocol.FP_STATUS_ERROR,
+	'data': []
+    },
+    'check': function (output, parsed) {
+	mod_assertplus.equal(parsed.pm_msgid, 0);
+	mod_assertplus.equal(parsed.pm_status, mod_protocol.FP_STATUS_ERROR);
+    }
+}, {
+    'name': 'maximum msgid',
+    'input': {
+	'msgid': 2147483647,
+	'status': mod_protocol.FP_STATUS_END,
+	'data': [ 'hello' ]
+    },
+    'check': function (output, parsed) {
+	mod_assertplus.equal(parsed.pm_msgid, 2147483647);
+	mod_assertplus.equal(parsed.pm_status, mod_protocol.FP_STATUS_END);
+    }
+}, {
+    'name': 'bad msgid: missing',
+    'error': /msg.msgid is not an integer between 0 and FP_MSGID_MAX/,
+    'input': {
+	'status': mod_protocol.FP_STATUS_DATA,
+	'data': []
+    }
+}, {
+    'name': 'bad msgid: negative',
+    'error': /msg.msgid is not an integer between 0 and FP_MSGID_MAX/,
+    'input': {
+	'msgid': -3,
+	'status': mod_protocol.FP_STATUS_DATA,
+	'data': []
+    }
+}, {
+    'name': 'bad msgid: too large',
+    'error': /msg.msgid is not an integer between 0 and FP_MSGID_MAX/,
+    'input': {
+	'msgid': 2147483648,
+	'status': mod_protocol.FP_STATUS_DATA,
+	'data': []
+    }
+}, {
+    'name': 'bad msgid: non-integer',
+    'error': /msg.msgid is not an integer between 0 and FP_MSGID_MAX/,
+    'input': {
+	'msgid': 3.7,
+	'status': mod_protocol.FP_STATUS_DATA,
+	'data': []
+    }
+}, {
+    'name': 'bad msgid: non-numeric',
+    'error': /msg.msgid is not an integer between 0 and FP_MSGID_MAX/,
+    'input': {
+	'msgid': {},
+	'status': mod_protocol.FP_STATUS_DATA,
+	'data': []
+    }
+}, {
+    'name': 'bad status: missing',
+    'error': /msg.status \(number\) is required/,
+    'input': {
+	'msgid': 17,
+	'data': []
+    }
+}, {
+    'name': 'bad status: non-numeric',
+    'error': /msg.status \(number\) is required/,
+    'input': {
+	'msgid': 17,
+	'status': {},
+	'data': []
+    }
+}, {
+    'name': 'bad status: unsupported value (4)',
+    'error': /unsupported fast message status/,
+    'input': {
+	'msgid': 17,
+	'status': 4,
+	'data': []
+    }
+}, {
+    'name': 'bad status: unsupported value (0)',
+    'error': /unsupported fast message status/,
+    'input': {
+	'msgid': 17,
+	'status': 0,
+	'data': []
+    }
+}, {
+    'name': 'bad data: missing',
+    'error': /msg.data \(object\) is required/,
+    'input': {
+	'msgid': 17,
+	'status': mod_protocol.FP_STATUS_ERROR
+    }
+}, {
+    'name': 'bad data: null',
+    'error': /msg.data \(object\) is required/,
+    'input': {
+	'msgid': 17,
+	'status': mod_protocol.FP_STATUS_ERROR,
+	'data': null
+    }
+}, {
+    'name': 'bad data: numeric',
+    'error': /msg.data \(object\) is required/,
+    'input': {
+	'msgid': 17,
+	'status': mod_protocol.FP_STATUS_ERROR,
+	'data': 47
+    }
+}, {
+    'name': 'bad data: not stringifiable',
+    'error': /Converting circular structure to JSON/,
+    'input': {
+	'msgid': 17,
+	'status': mod_protocol.FP_STATUS_ERROR,
+	'data': [ circular ]
+    }
+} ];
+
+function runTestCase(testcase)
+{
+	var error, outbuf, parsed;
+
+	printf('test case: %s: ', testcase.name);
+
+	if (typeof (testcase['input']['data']) == 'function') {
+		testcase['input']['data'] = testcase['input']['data']();
+	}
+
+	try {
+		outbuf = mod_protocol.fastMessageEncode(testcase.input);
+	} catch (ex) {
+		error = ex;
+	}
+
+	if (error !== undefined) {
+		if (!testcase['error']) {
+			printf('FAIL\n');
+			printf('expected success, found error: %s\n',
+			    error.stack);
+			throw (error);
+		}
+
+		if (!testcase['error'].test(error.message)) {
+			printf('FAIL\n');
+			printf('expected error to match: %s\n',
+			    testcase['error'].source);
+			printf('found error: %s\n', error.stack);
+			throw (error);
+		}
+	} else {
+		if (testcase['error']) {
+			printf('FAIL\n');
+			printf('expected error to match: %s\n',
+			    testcase['error'].source);
+			printf('found success\n');
+			throw (new Error('test case failed'));
+		}
+
+		/*
+		 * Check conditions that should be true for all success cases.
+		 */
+		mod_assertplus.ok(Buffer.isBuffer(outbuf));
+		mod_assertplus.ok(outbuf.length > mod_protocol.FP_HEADER_SZ);
+		mod_assertplus.equal(1,
+		    outbuf.readUInt8(mod_protocol.FP_OFF_VERSION));
+		mod_assertplus.equal(0x1,
+		    outbuf.readUInt8(mod_protocol.FP_OFF_TYPE));
+
+		parsed = {};
+		parsed.pm_datalen =
+		    outbuf.readUInt32BE(mod_protocol.FP_OFF_DATALEN);
+		parsed.pm_data = outbuf.slice(mod_protocol.FP_OFF_DATA);
+		parsed.pm_status = outbuf.readUInt8(mod_protocol.FP_OFF_STATUS);
+		parsed.pm_msgid =
+		    outbuf.readUInt32BE(mod_protocol.FP_OFF_MSGID);
+		parsed.pm_crc = outbuf.readUInt32BE(mod_protocol.FP_OFF_CRC);
+
+		mod_assertplus.ok(parsed.pm_status > 0 &&
+		    parsed.pm_status <= 0x3);
+		testcase['check'](outbuf, parsed);
+	}
+
+	printf('ok\n');
+}
+
+main();
diff --git a/test/tst.server.js b/test/tst.server.js
new file mode 100644
index 0000000..af24292
--- /dev/null
+++ b/test/tst.server.js
@@ -0,0 +1,799 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/tst.server.js: server API test suite
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_bunyan = require('bunyan');
+var mod_net = require('net');
+var mod_path = require('path');
+var mod_vasync = require('vasync');
+
+var mod_fast = require('../lib/fast');
+var mod_fastdemo = require('../lib/demo_server');
+var mod_protocol = require('../lib/fast_protocol');
+var mod_testcommon = require('./common');
+
+var VError = require('verror');
+
+var testLog;
+var serverTestCases;
+
+function main()
+{
+	testLog = new mod_bunyan({
+	    'name': mod_path.basename(__filename),
+	    'level': process.env['LOG_LEVEL'] || 'fatal'
+	});
+
+	mod_testcommon.registerExitBlocker('test run');
+
+	mod_vasync.forEachPipeline({
+	    'inputs': serverTestCases,
+	    'func': runTestCase
+	}, function (err) {
+		if (err) {
+			throw (err);
+		}
+
+		mod_testcommon.unregisterExitBlocker('test run');
+	});
+}
+
+function ServerTestContext()
+{
+	this.ts_log = null;	/* bunyan logger */
+	this.ts_socket = null;	/* server net socket */
+	this.ts_server = null;	/* fast server object */
+	this.ts_clients = [];	/* array of clients, each having properties */
+				/* "tsc_socket" and "tsc_client" */
+}
+
+ServerTestContext.prototype.connectClient = function (callback)
+{
+	var ip, port;
+	var csock, cclient;
+	var self = this;
+
+	ip = mod_testcommon.serverIp;
+	port = mod_testcommon.serverPort;
+	csock = mod_net.createConnection(port, ip);
+	cclient = new mod_fast.FastClient({
+	    'log': this.ts_log.child({ 'component': 'FastClient' }),
+	    'transport': csock,
+	    'nRecentRequests': 100
+	});
+
+	csock.on('connect', function () {
+		self.ts_log.info('connected client', self.ts_clients.length);
+
+		self.ts_clients.push({
+		    'tsc_socket': csock,
+		    'tsc_client': cclient
+		});
+
+		callback();
+	});
+};
+
+ServerTestContext.prototype.firstFastClient = function ()
+{
+	mod_assertplus.ok(this.ts_clients.length > 0);
+	return (this.ts_clients[0].tsc_client);
+};
+
+ServerTestContext.prototype.cleanup = function ()
+{
+	this.ts_clients.forEach(function (c) {
+		c.tsc_client.detach();
+		c.tsc_socket.destroy();
+	});
+
+	this.ts_socket.close();
+	this.ts_server.close();
+};
+
+function expectRpcResult(args)
+{
+	mod_assertplus.object(args, 'args');
+	mod_assertplus.optionalObject(args.errorActual, 'args.errorActual');
+	mod_assertplus.optionalBool(args.errorExpected, 'args.errorExpected');
+	mod_assertplus.arrayOfObject(args.dataActual, 'args.dataActual');
+	mod_assertplus.optionalArrayOfObject(
+	    args.dataExpected, 'args.dataExpected');
+
+	if (args.errorActual === null && args.errorExpected) {
+		return (new VError('expected error, but found none'));
+	}
+
+	if (args.errorActual !== null && !args.errorExpected) {
+		return (new VError(args.errorActual, 'unexpected error'));
+	}
+
+	if (args.dataExpected === null) {
+		return (null);
+	}
+
+	/* Pretty cheesy. */
+	try {
+		mod_assertplus.deepEqual(
+		    args.dataExpected, args.dataActual);
+	} catch (ex) {
+		mod_assertplus.equal(ex.name, 'AssertionError');
+		return (ex);
+	}
+
+	return (null);
+}
+
+function unwrapClientRpcError(err)
+{
+	mod_assertplus.equal(err.name, 'FastRequestError');
+	err = VError.cause(err);
+	mod_assertplus.equal(err.name, 'FastServerError');
+	err = VError.cause(err);
+	mod_assertplus.ok(err !== null);
+	return (err);
+}
+
+function runTestCase(testcase, callback)
+{
+	var tctx;
+
+	console.error('test case: %s', testcase['name']);
+
+	tctx = new ServerTestContext();
+	tctx.ts_log = testLog.child({ 'testcase': testcase['name'] });
+	tctx.ts_socket = mod_net.createServer({ 'allowHalfOpen': true });
+	tctx.ts_server = new mod_fast.FastServer({
+	    'log': tctx.ts_log.child({ 'component': 'FastServer' }),
+	    'server': tctx.ts_socket
+	});
+
+	mod_fastdemo.demoRpcs().forEach(function (rpc) {
+		tctx.ts_server.registerRpcMethod(rpc);
+	});
+
+	mod_vasync.pipeline({ 'funcs': [
+	    function initServer(_, next) {
+		var port = mod_testcommon.serverPort;
+		tctx.ts_socket.listen(port, function () {
+			tctx.ts_log.debug({ 'port': port }, 'server listening');
+			next();
+		});
+	    },
+
+	    function initClient(_, next) {
+		tctx.connectClient(next);
+	    },
+
+	    function runTest(_, next) {
+		testcase['run'](tctx, next);
+	    }
+	] }, function (err) {
+		tctx.cleanup();
+		callback(err);
+	});
+}
+
+function runConnFailureTest(tctx, injectFail, checkError, callback)
+{
+	var client1, client2, rqbarrier, rsbarrier;
+	var rpcs, client2cb;
+	var log = tctx.ts_log;
+
+	/*
+	 * The flow of control in this test case is pretty complicated.  We're
+	 * trying to test what happens when there are multiple clients, client1
+	 * and client2, that are connected with outstanding RPC requests and one
+	 * of the connections, client1, experiences an error.  The expected
+	 * behavior is that all of client1's requests fail immediately while
+	 * client2's request is unaffected.  We test this by doing the
+	 * following:
+	 *
+	 *     1) Set up a second client connection to the server.  (All tests
+	 *        come in with one client already set up.)
+	 *
+	 *     2) Issue three requests from client1 and one request from
+	 *        client2 and wait for all four requests to be received by the
+	 *        server.  To wait for this, we use a vasync barrier called
+	 *        "rqbarrier".
+	 *
+	 *     3) Inject an error into client1's connection.  This should
+	 *        trigger the server to fail all of the requests outstanding on
+	 *        that connection.  Wait for all three client1 requests to
+	 *        complete on the client.  This uses another vasync barrier
+	 *        called "rsbarrier".
+	 *
+	 *     4) On the server, complete the client2 request normally and wait
+	 *        for it to complete on the client with the expected result.
+	 *
+	 * The keys for each barrier include the connid and request id.  In
+	 * order to respond to RPC requests, we need to keep track of each
+	 * request in "rpcs".
+	 */
+	client1 = tctx.firstFastClient();
+	rpcs = {};
+	rqbarrier = mod_vasync.barrier();
+	rqbarrier.start('rpc 1/1');		/* wait for client1 requests */
+	rqbarrier.start('rpc 1/2');
+	rqbarrier.start('rpc 1/3');
+	rqbarrier.start('rpc 2/1');		/* wait for client2 requests */
+	rsbarrier = mod_vasync.barrier();
+	rsbarrier.start('response 1/0');	/* wait for client1 responses */
+	rsbarrier.start('response 1/1');
+	rsbarrier.start('response 1/2');
+
+	mod_vasync.pipeline({ 'funcs': [
+	    function initSecondClient(_, next) {
+		/*
+		 * Make a second client connection so that we can verify that
+		 * its requests are unaffected by connection-level failures.
+		 */
+		tctx.connectClient(next);
+	    },
+
+	    function makeRequests(_, next) {
+		client2 = tctx.ts_clients[1].tsc_client;
+
+		/*
+		 * Register an RPC handler that will cause this pipeline to
+		 * advance once all four RPC requests have been received by the
+		 * server.
+		 */
+		tctx.ts_server.registerRpcMethod({
+		    'rpcmethod': 'block',
+		    'rpchandler': function fastRpcBlock(rpc) {
+			var connid = rpc.connectionId();
+			var reqid = rpc.requestId();
+			rpcs[connid + '/' + reqid] = rpc;
+			rqbarrier.done('rpc ' + connid + '/' + reqid);
+		    }
+		});
+
+		rqbarrier.on('drain', next);
+
+		/*
+		 * Kick off the requests from the clients.
+		 */
+		[ 0, 1, 2 ].forEach(function (i) {
+			client1.rpcBufferAndCallback({
+			    'maxObjectsToBuffer': 0,
+			    'rpcmethod': 'block',
+			    'rpcargs': []
+			}, function (err, data, ndata) {
+				/*
+				 * Note that this callback will not be invoked
+				 * until several stages later in the pipeline.
+				 */
+				mod_assertplus.equal(err.name,
+				    'FastRequestError');
+				checkError(err.cause());
+				rsbarrier.done('response 1/' + i);
+			});
+		});
+
+		client2.rpcBufferAndCallback({
+		    'maxObjectsToBuffer': 1,
+		    'rpcmethod': 'block',
+		    'rpcargs': []
+		}, function (err, data, ndata) {
+			/*
+			 * Like above, this won't be invoked until a few stages
+			 * later in this pipeline, by which point a later stage
+			 * will have set client2cb.
+			 */
+			mod_assertplus.ok(!err);
+			mod_assertplus.equal(data.length, ndata);
+			mod_assertplus.deepEqual(data, [ { 'value': 52 } ]);
+			client2cb();
+		});
+	    },
+
+	    function injectError(_, next) {
+		var clientErrorExpected;
+
+		rsbarrier.start('client error');
+		client1.on('error', function (err) {
+			mod_assertplus.equal(err.name, 'FastProtocolError');
+			rsbarrier.done('client error');
+		});
+
+		/*
+		 * Wait for the server to fail outstanding requests on this
+		 * client.
+		 */
+		rsbarrier.on('drain', next);
+
+		log.info('injecting failure and waiting for completion');
+		clientErrorExpected = injectFail();
+		mod_assertplus.bool(clientErrorExpected,
+		    'injectFail must return boolean');
+		if (!clientErrorExpected) {
+			rsbarrier.done('client error');
+		}
+	    },
+
+	    function respondToClient2(_, next) {
+		/*
+		 * Set up a handler to be invoked when the client2 request
+		 * completes on the client.
+		 */
+		client2cb = next;
+
+		/*
+		 * End all of the client requests.  The client1 request data
+		 * will be black-holed, while the client2 request will work
+		 * normally.
+		 */
+		log.info('responding to client2 and waiting for client');
+		rpcs['1/1'].end({ 'value': 11 });
+		rpcs['1/2'].end({ 'value': 12 });
+		rpcs['1/3'].end({ 'value': 13 });
+		rpcs['2/1'].end({ 'value': 52 });
+	    }
+	] }, callback);
+}
+
+serverTestCases = [ {
+    'name': 'basic RPC: no data',
+    'run': function (tctx, callback) {
+	tctx.firstFastClient().rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 0,
+	    'rpcmethod': 'echo',
+	    'rpcargs': []
+	}, function (err, data, ndata) {
+		mod_assertplus.equal(data.length, ndata);
+		err = expectRpcResult({
+		    'errorActual': err,
+		    'errorExpected': null,
+		    'dataActual': data,
+		    'dataExpected': []
+		});
+
+		callback(err);
+	});
+    }
+
+}, {
+    'name': 'basic RPC: 1 data item',
+    'run': function (tctx, callback) {
+	tctx.firstFastClient().rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 1,
+	    'rpcmethod': 'echo',
+	    'rpcargs': [ 'lafayette' ]
+	}, function (err, data, ndata) {
+		mod_assertplus.equal(data.length, ndata);
+		err = expectRpcResult({
+		    'errorActual': err,
+		    'errorExpected': null,
+		    'dataActual': data,
+		    'dataExpected': [ { 'value': 'lafayette' } ]
+		});
+
+		callback(err);
+	});
+    }
+
+}, {
+    'name': 'basic RPC: several data items',
+    'run': function (tctx, callback) {
+	tctx.firstFastClient().rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 4,
+	    'rpcmethod': 'echo',
+	    'rpcargs': [
+	        { 'matches': [ 'tactical', 'brilliance' ] },
+		null,
+		false,
+		17.81
+	    ]
+	}, function (err, data, ndata) {
+		mod_assertplus.equal(data.length, ndata);
+		err = expectRpcResult({
+		    'errorActual': err,
+		    'errorExpected': null,
+		    'dataActual': data,
+		    'dataExpected': [
+	                { 'value':
+			    { 'matches': [ 'tactical', 'brilliance' ] } },
+		        { 'value': null  },
+		        { 'value': false },
+		        { 'value': 17.81 }
+		    ]
+		});
+
+		callback(err);
+	});
+    }
+
+}, {
+    'name': 'basic RPC: 0 data items, plus error',
+    'run': function (tctx, callback) {
+	tctx.firstFastClient().rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 0,
+	    'rpcmethod': 'fail',
+	    'rpcargs': [ {
+		'name': 'MyStupidError',
+		'message': 'the server ate my response',
+		'info': {
+		    'expectedResponse': 'not eaten',
+		    'actualResponse': 'eaten'
+		},
+		'context': {
+		    'legacyContextProperty': 'oops'
+		}
+	    } ]
+	}, function (err, data, ndata) {
+		var rpcerr, info;
+
+		mod_assertplus.equal(data.length, ndata);
+		rpcerr = expectRpcResult({
+		    'errorActual': err,
+		    'errorExpected': true,
+		    'dataActual': data,
+		    'dataExpected': []
+		});
+
+		if (rpcerr) {
+			callback(rpcerr);
+			return;
+		}
+
+		err = unwrapClientRpcError(err);
+		mod_assertplus.equal(err.name, 'MyStupidError');
+		mod_assertplus.equal(err.message, 'the server ate my response');
+		mod_assertplus.equal(err.context.legacyContextProperty, 'oops');
+
+		info = VError.info(err);
+		mod_assertplus.equal(info.expectedResponse, 'not eaten');
+		mod_assertplus.equal(info.actualResponse, 'eaten');
+		callback();
+	});
+    }
+
+}, {
+    'name': 'basic RPC: several data items, plus error',
+    'run': function (tctx, callback) {
+	tctx.firstFastClient().rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 3,
+	    'rpcmethod': 'fail',
+	    'rpcargs': [ {
+		'data': [ 'one', 'two', 'three' ],
+		'name': 'MyStupidError',
+		'message': 'the server ate my response',
+		'info': {
+		    'expectedResponse': 'not eaten',
+		    'actualResponse': 'eaten'
+		},
+		'context': {
+		    'legacyContextProperty': 'oops'
+		}
+	    } ]
+	}, function (err, data, ndata) {
+		var rpcerr, info;
+
+		mod_assertplus.equal(data.length, ndata);
+		rpcerr = expectRpcResult({
+		    'errorActual': err,
+		    'errorExpected': true,
+		    'dataActual': data,
+		    'dataExpected': null
+		});
+
+		if (rpcerr) {
+			callback(rpcerr);
+			return;
+		}
+
+		/*
+		 * Any number of data items between 0 and 3 is possible here,
+		 * depending on what the server sent out before the request
+		 * failed.
+		 */
+		mod_assertplus.ok(data.length >= 0 && data.length <= 3);
+		mod_assertplus.deepEqual(data, [
+		    { 'value': 'one' },
+		    { 'value': 'two' },
+		    { 'value': 'three' }
+		].slice(0, data.length));
+
+		err = unwrapClientRpcError(err);
+		mod_assertplus.equal(err.name, 'MyStupidError');
+		mod_assertplus.equal(err.message, 'the server ate my response');
+		mod_assertplus.equal(err.context.legacyContextProperty, 'oops');
+
+		info = VError.info(err);
+		mod_assertplus.equal(info.expectedResponse, 'not eaten');
+		mod_assertplus.equal(info.actualResponse, 'eaten');
+		callback();
+	});
+    }
+
+}, {
+    'name': 'RPC for non-existent method',
+    'run': function (tctx, callback) {
+	tctx.firstFastClient().rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 0,
+	    'rpcmethod': 'badmethod',
+	    'rpcargs': []
+	}, function (err, data, ndata) {
+		var rpcerr, info;
+
+		mod_assertplus.equal(data.length, ndata);
+		rpcerr = expectRpcResult({
+		    'errorActual': err,
+		    'errorExpected': true,
+		    'dataActual': data,
+		    'dataExpected': null
+		});
+
+		if (rpcerr) {
+			callback(rpcerr);
+			return;
+		}
+
+		err = unwrapClientRpcError(err);
+		mod_assertplus.equal(err.name, 'FastError');
+		mod_assertplus.equal(err.message,
+		    'unsupported RPC method: "badmethod"');
+
+		info = VError.info(err);
+		mod_assertplus.equal(info.fastReason, 'bad_method');
+		mod_assertplus.equal(info.rpcMethod, 'badmethod');
+		callback();
+	});
+    }
+
+}, {
+    'name': 'multiple RPCs for the same client run in parallel',
+    'run': function (tctx, callback) {
+	var which = 0;
+	var barrier;
+
+	/*
+	 * Set up a server where we wait for three RPC calls to show up and then
+	 * start completing each of them in order.
+	 */
+	barrier = mod_vasync.barrier();
+	barrier.start('rpc 0');
+	barrier.start('rpc 1');
+	barrier.start('rpc 2');
+
+	tctx.ts_server.registerRpcMethod({
+	    'rpcmethod': 'recordAndReturn',
+	    'rpchandler': function fastRpcRecordAndReturn(rpc) {
+		var whichrpc = which++;
+		barrier.on('drain', function () {
+			rpc.end({ 'value': whichrpc });
+		});
+		barrier.done('rpc ' + whichrpc);
+	    }
+	});
+
+	mod_vasync.forEachParallel({
+	    'inputs': [
+	        { 'rpcmethod': 'recordAndReturn', 'rpcargs': [] },
+	        { 'rpcmethod': 'recordAndReturn', 'rpcargs': [] },
+	        { 'rpcmethod': 'recordAndReturn', 'rpcargs': [] }
+	    ],
+	    'func': function makeRpc(rpcargs, next) {
+		rpcargs.maxObjectsToBuffer = 2;
+		tctx.firstFastClient().rpcBufferAndCallback(rpcargs, next);
+	    }
+	}, function (err, results) {
+		if (err) {
+			throw (err);
+		}
+
+		mod_assertplus.deepEqual(results.operations[0].result,
+		    [ { 'value': 0 } ]);
+		mod_assertplus.deepEqual(results.operations[1].result,
+		    [ { 'value': 1 } ]);
+		mod_assertplus.deepEqual(results.operations[2].result,
+		    [ { 'value': 2 } ]);
+
+		callback();
+	});
+    }
+
+}, {
+    'name': 'connection error with requests outstanding: protocol error',
+    'run': function (tctx, callback) {
+	var client1 = tctx.firstFastClient();
+
+	runConnFailureTest(tctx, function () {
+		/*
+		 * Inject a protocol error via the first client.
+		 */
+		mod_assertplus.ok(client1 instanceof mod_fast.FastClient);
+		mod_assertplus.object(client1.fc_msgencoder,
+		    'test error (needs to be updated for FastClient ' +
+		    'implementation change?');
+		client1.fc_msgencoder.write({
+		    'msgid': 7,
+		    'status': mod_protocol.FP_STATUS_END,
+		    'data': { 'd': [] }
+		});
+		return (true);
+	}, function (err) {
+		mod_assertplus.equal(err.name, 'FastProtocolError');
+	}, callback);
+    }
+
+}, {
+    'name': 'connection error with requests outstanding: socket error',
+    'run': function (tctx, callback) {
+	runConnFailureTest(tctx, function () {
+		/*
+		 * Inject a socket error via the first client.
+		 */
+		mod_assertplus.object(tctx.ts_server.fs_conns,
+		    'test error (needs to be updated for FastServer ' +
+		    'implementation change?');
+		mod_assertplus.ok(tctx.ts_server.fs_conns.hasOwnProperty(1));
+		mod_assertplus.object(tctx.ts_server.fs_conns[1].fc_socket);
+		tctx.ts_clients[0].tsc_socket.destroy();
+
+		/*
+		 * Note that since we're destroying the local socket, it won't
+		 * emit an error, so we have to detach the transport in order to
+		 * get the local client requests to complete.
+		 */
+		tctx.ts_clients[0].tsc_client.detach();
+		tctx.ts_server.fs_conns[1].fc_socket.write('boom');
+		return (false);
+	}, function (err) {
+		mod_assertplus.equal(err.name, 'FastTransportError');
+	}, callback);
+    }
+
+}, {
+    'name': 'basic RPC with immediate end-of-stream',
+    'run': function (tctx, callback) {
+	tctx.firstFastClient().rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 0,
+	    'rpcmethod': 'sleep',
+	    'rpcargs': [ { 'ms': 100 } ]
+	}, function (err, data, ndata) {
+		mod_assertplus.equal(data.length, ndata);
+		err = expectRpcResult({
+		    'errorActual': err,
+		    'errorExpected': null,
+		    'dataActual': data,
+		    'dataExpected': []
+		});
+
+		callback(err);
+	});
+
+	tctx.ts_clients[0].tsc_socket.end();
+    }
+
+}, {
+    'name': 'RPC with large amount of data',
+    'run': function (tctx, callback) {
+	tctx.firstFastClient().rpcBufferAndCallback({
+	    'maxObjectsToBuffer': 50000,
+	    'rpcmethod': 'yes',
+	    'rpcargs': [ {
+	        'count': 50000,
+		'value': 'undefined will not be used as a variable name'
+	    } ]
+	}, function (err, data, ndata) {
+		/*
+		 * It's only with great restraint that this variable was not
+		 * itself named "undefined".
+		 */
+		var expected = [];
+		var i;
+
+		for (i = 0; i < 50000; i++) {
+			expected.push({
+			    'value': 'undefined will not be used as a ' +
+			        'variable name'
+			});
+		}
+
+		mod_assertplus.equal(data.length, ndata);
+		err = expectRpcResult({
+		    'errorActual': err,
+		    'errorExpected': null,
+		    'dataActual': data,
+		    'dataExpected': expected
+		});
+
+		callback(err);
+	});
+
+	tctx.ts_clients[0].tsc_socket.end();
+    }
+
+}, {
+    'name': 'flow control from server to client',
+    'run': function (tctx, callback) {
+	var log, client, request, csock;
+	var ndata = 0;
+
+	/*
+	 * This test does not work on Node v0.10, but we don't claim full
+	 * support for that version.
+	 */
+	log = tctx.ts_log;
+	if (mod_testcommon.predatesUsefulPause()) {
+		log.warn('skipping test (not supported on v0.10)');
+		setImmediate(callback);
+		return;
+	}
+
+	/*
+	 * This test case has an analog in the server test suite.  Changes here
+	 * may need to be reflected there.  As described in more detail there,
+	 * the scope of flow control is limited because of the way multiple
+	 * requests are multiplexed over a single socket.
+	 */
+	client = tctx.firstFastClient();
+	tctx.ts_server.registerRpcMethod({
+	    'rpcmethod': 'faucet',
+	    'rpchandler': function (rpc) {
+		var source = new mod_testcommon.FlowControlSource({
+		    'datum': {
+		        'value': 'null cannot be used as a variable name'
+		    },
+		    'restMs': 1000,
+		    'log': tctx.ts_log.child({
+		        'component': 'FlowControlSource'
+		    })
+		});
+
+		source.pipe(rpc);
+		source.once('resting', function () {
+			log.debug('came to rest; verifying and moving on');
+			mod_assertplus.ok(mod_testcommon.isFlowControlled(
+			    csock));
+			mod_assertplus.equal('number',
+			    typeof (csock._readableState.length));
+			mod_assertplus.equal('number',
+			    typeof (csock._readableState.highWaterMark));
+			mod_assertplus.ok(csock._readableState.length >=
+			    csock._readableState.highWaterMark);
+
+			csock.resume();
+			source.stop();
+		});
+	    }
+	});
+
+	/*
+	 * We deliberately don't add a "data" listener until later.
+	 */
+	request = client.rpc({
+	    'rpcmethod': 'faucet',
+	    'rpcargs': [ {
+		'count': 10000,
+		'value': 'null cannot be used as a variable name'
+	    } ]
+	});
+
+	request.on('data', function (d) { ndata++; });
+
+	request.on('end', function () {
+		log.debug('finished after %d data items', ndata);
+		callback();
+	});
+
+	csock = tctx.ts_clients[0].tsc_socket;
+	csock.pause();
+    }
+
+} ];
+
+main();
diff --git a/test/tst.socket_summarize.js b/test/tst.socket_summarize.js
new file mode 100644
index 0000000..4b00862
--- /dev/null
+++ b/test/tst.socket_summarize.js
@@ -0,0 +1,169 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2016, Joyent, Inc.
+ */
+
+/*
+ * test/tst.socket_summarize.js: tests summarizeSocketAddrs function.
+ */
+
+var mod_assertplus = require('assert-plus');
+var mod_fs = require('fs');
+var mod_net = require('net');
+var mod_path = require('path');
+var mod_vasync = require('vasync');
+var VError = require('verror');
+
+var mod_subr = require('../lib/subr');
+var mod_testcommon = require('./common');
+
+var serverPort = mod_testcommon.serverPort;
+var serverUds = '/tmp/tst.socket_summarize.js';
+
+function main()
+{
+	mod_testcommon.registerExitBlocker('test run');
+	mod_vasync.forEachPipeline({
+	    'inputs': test_cases,
+	    'func': runTestCase
+	}, function (err) {
+		if (err) {
+			throw (err);
+		}
+
+		mod_testcommon.unregisterExitBlocker('test run');
+		console.log('%s tests passed', mod_path.basename(__filename));
+	});
+}
+
+function runTestCase(testcase, callback)
+{
+	var barrier, server, client;
+	var servers_socket;
+
+	console.log('test case: %s', testcase['name']);
+
+	barrier = mod_vasync.barrier();
+	server = mod_net.createServer();
+	testcase['listen'](server, function (err) {
+		mod_assertplus.ok(!err);
+		barrier.start('client connection');
+		client = testcase['connect']();
+		client.on('connect', function () {
+			if (testcase['cleanup']) {
+				testcase['cleanup'](function () {
+					barrier.done('client connection');
+				});
+			} else {
+				barrier.done('client connection');
+			}
+		});
+
+		barrier.start('server connection');
+		server.on('connection', function (s) {
+			servers_socket = s;
+			barrier.done('server connection');
+		});
+	});
+
+	barrier.on('drain', function () {
+		var serverSummary, clientSummary;
+
+		serverSummary = mod_subr.summarizeSocketAddrs(servers_socket);
+		clientSummary = mod_subr.summarizeSocketAddrs(client);
+		testcase['check'](serverSummary, clientSummary);
+		server.close();
+		servers_socket.destroy();
+		client.destroy();
+		callback();
+	});
+}
+
+var test_cases = [ {
+    'name': 'IPv4 sockets',
+    'listen': function (server, callback) {
+	server.listen(serverPort, '127.0.0.1', callback);
+    },
+    'connect': function () {
+	return (mod_net.createConnection(serverPort, '127.0.0.1'));
+    },
+    'check': function (serverSummary, clientSummary) {
+	mod_assertplus.equal(serverSummary.localAddress, '127.0.0.1');
+	mod_assertplus.equal(serverSummary.localPort, serverPort);
+	mod_assertplus.equal(serverSummary.remoteAddress, '127.0.0.1');
+	mod_assertplus.equal(serverSummary.remotePort,
+	    clientSummary.localPort);
+	mod_assertplus.equal(serverSummary.socketType, 'IPv4');
+	mod_assertplus.equal(serverSummary.label,
+	    '127.0.0.1:' + clientSummary.localPort);
+
+	mod_assertplus.equal(clientSummary.localAddress, '127.0.0.1');
+	mod_assertplus.equal(clientSummary.remoteAddress, '127.0.0.1');
+	mod_assertplus.equal(clientSummary.remotePort, serverPort);
+	mod_assertplus.equal(clientSummary.socketType, 'IPv4');
+	mod_assertplus.equal(clientSummary.label,
+	    '127.0.0.1:' + serverPort);
+    }
+
+}, {
+    'name': 'IPv6 sockets',
+    'listen': function (server, callback) {
+	server.listen(serverPort, '::1', callback);
+    },
+    'connect': function () {
+	return (mod_net.createConnection(serverPort, '::1'));
+    },
+    'check': function (serverSummary, clientSummary) {
+	mod_assertplus.equal(serverSummary.localAddress, '::1');
+	mod_assertplus.equal(serverSummary.localPort, serverPort);
+	mod_assertplus.equal(serverSummary.remoteAddress, '::1');
+	mod_assertplus.equal(serverSummary.remotePort,
+	    clientSummary.localPort);
+	mod_assertplus.equal(serverSummary.socketType, 'IPv6');
+	mod_assertplus.equal(serverSummary.label,
+	    '::1:' + clientSummary.localPort);
+
+	mod_assertplus.equal(clientSummary.localAddress, '::1');
+	mod_assertplus.equal(clientSummary.remoteAddress, '::1');
+	mod_assertplus.equal(clientSummary.remotePort, serverPort);
+	mod_assertplus.equal(clientSummary.socketType, 'IPv6');
+	mod_assertplus.equal(clientSummary.label, '::1:' + serverPort);
+    }
+
+}, {
+    'name': 'UDS sockets',
+    'listen': function (server, callback) {
+	cleanupUds(function () {
+		server.listen(serverUds, callback);
+	});
+    },
+    'connect': function () {
+	return (mod_net.createConnection(serverUds));
+    },
+    'check': function (serverSummary, clientSummary) {
+	mod_assertplus.equal(serverSummary.socketType, 'UDS (inferred)');
+	mod_assertplus.equal(serverSummary.label, 'UDS');
+	mod_assertplus.equal(clientSummary.socketType, 'UDS (inferred)');
+	mod_assertplus.equal(clientSummary.label, 'UDS');
+    },
+    'cleanup': cleanupUds
+} ];
+
+function cleanupUds(callback)
+{
+	mod_fs.unlink(serverUds, function (err) {
+		if (err && err['code'] != 'ENOENT') {
+			throw (new VError(err, 'failed to unlink "%s"',
+			    serverUds));
+		}
+
+		callback();
+	});
+}
+
+main();
diff --git a/tools/bashstyle b/tools/bashstyle
new file mode 100755
index 0000000..fa8dff7
--- /dev/null
+++ b/tools/bashstyle
@@ -0,0 +1,114 @@
+#!/usr/bin/env node
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2014, Joyent, Inc.
+ */
+
+/*
+ * bashstyle: check bash scripts for adherence to style guidelines, including:
+ *
+ *    o no lines longer than 80 characters
+ *    o file does not end with a blank line
+ *
+ * Future enhancements could include:
+ *    o indents consistent with respect to tabs, spaces
+ *    o indents consistently sized (all are some multiple of the smallest
+ *      indent, which must be a tab or 4 or 8 spaces)
+ */
+
+var mod_assert = require('assert');
+var mod_fs = require('fs');
+
+var nerrors = 0;
+
+main();
+process.exit(0);
+
+function main()
+{
+	var files = process.argv.slice(2);
+
+	if (files.length === 0) {
+		console.error('usage: %s file1 [...]',
+		    process.argv.slice(0, 2).join(' '));
+		process.exit(2);
+	}
+
+	files.forEach(checkFile);
+
+	if (nerrors != 0)
+		process.exit(1);
+}
+
+function checkFile(filename)
+{
+	var text = mod_fs.readFileSync(filename, 'utf-8');
+	var lines = text.split('\n');
+	var i;
+
+	mod_assert.ok(lines.length > 0);
+
+	/*
+	 * Expand tabs in each line and check for long lines.
+	 */
+	for (i = 1; i <= lines.length; i++) {
+		var line = expandTabs(lines[i - 1]);
+
+		if (line.length > 80) {
+			nerrors++;
+			console.log('%s: %d: line exceeds 80 columns',
+			    filename, i);
+		}
+	}
+
+	/*
+	 * No sane editor lets you save a file without a newline at the very
+	 * end.
+	 */
+	if (lines[lines.length - 1].length !== 0) {
+		nerrors++;
+		console.log('%s: %d: file does not end with newline',
+			filename, lines.length);
+	}
+
+	/*
+	 * Since the file will always end with a newline, the last entry of
+	 * "lines" will actually be blank.
+	 */
+	if (lines.length > 1 && lines[lines.length - 2].length === 0) {
+		nerrors++;
+		console.log('%s: %d: file ends with a blank line',
+		    filename, lines.length - 1);
+	}
+}
+
+function expandTabs(text)
+{
+	var out = '';
+	var col = 0;
+	var j, k;
+
+	for (j = 0; j < text.length; j++) {
+		if (text[j] != '\t') {
+			out += text[j];
+			col++;
+			continue;
+		}
+
+		k = 8 - (col % 8);
+		col += k;
+
+		do {
+			out += ' ';
+		} while (--k > 0);
+
+		col += k;
+	}
+
+	return (out);
+}
diff --git a/tools/jsl.node.conf b/tools/jsl.node.conf
new file mode 100644
index 0000000..5cf2ebb
--- /dev/null
+++ b/tools/jsl.node.conf
@@ -0,0 +1,142 @@
+#
+# Configuration File for JavaScript Lint 
+#
+# This configuration file can be used to lint a collection of scripts, or to enable
+# or disable warnings for scripts that are linted via the command line.
+#
+
+### Warnings
+# Enable or disable warnings based on requirements.
+# Use "+WarningName" to display or "-WarningName" to suppress.
+#
++ambiguous_else_stmt          # the else statement could be matched with one of multiple if statements (use curly braces to indicate intent
++ambiguous_nested_stmt        # block statements containing block statements should use curly braces to resolve ambiguity
++ambiguous_newline            # unexpected end of line; it is ambiguous whether these lines are part of the same statement
++anon_no_return_value         # anonymous function does not always return value
++assign_to_function_call      # assignment to a function call
+-block_without_braces         # block statement without curly braces
++comma_separated_stmts        # multiple statements separated by commas (use semicolons?)
++comparison_type_conv         # comparisons against null, 0, true, false, or an empty string allowing implicit type conversion (use === or !==)
++default_not_at_end           # the default case is not at the end of the switch statement
++dup_option_explicit          # duplicate "option explicit" control comment
++duplicate_case_in_switch     # duplicate case in switch statement
++duplicate_formal             # duplicate formal argument {name}
++empty_statement              # empty statement or extra semicolon
++identifier_hides_another     # identifer {name} hides an identifier in a parent scope
+-inc_dec_within_stmt          # increment (++) and decrement (--) operators used as part of greater statement
++incorrect_version            # Expected /*jsl:content-type*/ control comment. The script was parsed with the wrong version.
++invalid_fallthru             # unexpected "fallthru" control comment
++invalid_pass                 # unexpected "pass" control comment
++jsl_cc_not_understood        # couldn't understand control comment using /*jsl:keyword*/ syntax
++leading_decimal_point        # leading decimal point may indicate a number or an object member
++legacy_cc_not_understood     # couldn't understand control comment using /*@keyword@*/ syntax
++meaningless_block            # meaningless block; curly braces have no impact
++mismatch_ctrl_comments       # mismatched control comment; "ignore" and "end" control comments must have a one-to-one correspondence
++misplaced_regex              # regular expressions should be preceded by a left parenthesis, assignment, colon, or comma
++missing_break                # missing break statement
++missing_break_for_last_case  # missing break statement for last case in switch
++missing_default_case         # missing default case in switch statement
++missing_option_explicit      # the "option explicit" control comment is missing
++missing_semicolon            # missing semicolon
++missing_semicolon_for_lambda # missing semicolon for lambda assignment
++multiple_plus_minus          # unknown order of operations for successive plus (e.g. x+++y) or minus (e.g. x---y) signs
++nested_comment               # nested comment
++no_return_value              # function {name} does not always return a value
++octal_number                 # leading zeros make an octal number
++parseint_missing_radix       # parseInt missing radix parameter
++partial_option_explicit      # the "option explicit" control comment, if used, must be in the first script tag
++redeclared_var               # redeclaration of {name}
++trailing_comma_in_array      # extra comma is not recommended in array initializers
++trailing_decimal_point       # trailing decimal point may indicate a number or an object member
++undeclared_identifier        # undeclared identifier: {name}
++unreachable_code             # unreachable code
+-unreferenced_argument        # argument declared but never referenced: {name}
+-unreferenced_function        # function is declared but never referenced: {name}
++unreferenced_variable        # variable is declared but never referenced: {name}
++unsupported_version          # JavaScript {version} is not supported
++use_of_label                 # use of label
++useless_assign               # useless assignment
++useless_comparison           # useless comparison; comparing identical expressions
+-useless_quotes               # the quotation marks are unnecessary
++useless_void                 # use of the void type may be unnecessary (void is always undefined)
++var_hides_arg                # variable {name} hides argument
++want_assign_or_call          # expected an assignment or function call
++with_statement               # with statement hides undeclared variables; use temporary variable instead
+
+
+### Output format
+# Customize the format of the error message.
+#    __FILE__ indicates current file path
+#    __FILENAME__ indicates current file name
+#    __LINE__ indicates current line
+#    __COL__ indicates current column
+#    __ERROR__ indicates error message (__ERROR_PREFIX__: __ERROR_MSG__)
+#    __ERROR_NAME__ indicates error name (used in configuration file)
+#    __ERROR_PREFIX__ indicates error prefix
+#    __ERROR_MSG__ indicates error message
+#
+# For machine-friendly output, the output format can be prefixed with
+# "encode:". If specified, all items will be encoded with C-slashes.
+#
+# Visual Studio syntax (default):
++output-format __FILE__(__LINE__): __ERROR__
+# Alternative syntax:
+#+output-format __FILE__:__LINE__: __ERROR__
+
+
+### Context
+# Show the in-line position of the error.
+# Use "+context" to display or "-context" to suppress.
+#
++context
+
+
+### Control Comments
+# Both JavaScript Lint and the JScript interpreter confuse each other with the syntax for
+# the /*@keyword@*/ control comments and JScript conditional comments. (The latter is
+# enabled in JScript with @cc_on@). The /*jsl:keyword*/ syntax is preferred for this reason,
+# although legacy control comments are enabled by default for backward compatibility.
+#
+-legacy_control_comments
+
+
+### Defining identifiers
+# By default, "option explicit" is enabled on a per-file basis.
+# To enable this for all files, use "+always_use_option_explicit"
+-always_use_option_explicit
+
+# Define certain identifiers of which the lint is not aware.
+# (Use this in conjunction with the "undeclared identifier" warning.)
+#
+# Common uses for webpages might be:
++define __dirname
++define clearInterval
++define clearTimeout
++define console
++define exports
++define global
++define module
++define process
++define require
++define setImmediate
++define clearImmediate
++define setInterval
++define setTimeout
++define Buffer
++define JSON
++define Math
++define __dirname
++define __filename
+
+### JavaScript Version
+# To change the default JavaScript version:
+#+default-type text/javascript;version=1.5
+#+default-type text/javascript;e4x=1
+
+### Files
+# Specify which files to lint
+# Use "+recurse" to enable recursion (disabled by default).
+# To add a set of files, use "+process FileName", "+process Folder\Path\*.js",
+# or "+process Folder\Path\*.htm".
+#
+
diff --git a/tools/perfrun b/tools/perfrun
new file mode 100755
index 0000000..dd557b1
--- /dev/null
+++ b/tools/perfrun
@@ -0,0 +1,129 @@
+#!/bin/bash
+
+#
+# perfrun: quick-and-dirty tool to run a set of performance tests using fastbench
+#
+
+set -o pipefail
+
+arg0=perfrun
+
+function fail
+{
+	echo "$arg0: $@" >&2
+	exit 1
+}
+
+function usage
+{
+	echo "$arg0 SERVER_PID SERVER_PORT TEST_NAME" >&2
+	echo "    SERVER_PID is the pid of the server." >&2
+	echo "    SERVER_PORT is the TCP port of the server to test." >&2
+	echo "    TEST_NAME is the basename of the output directory." >&2
+	exit 2
+}
+
+pr_pid=
+pr_port=
+pr_testdir=
+pr_children=
+# seconds between memory samples
+pr_sample_mem=5
+# seconds between CPU usage samples
+pr_sample_cpu=5
+# seconds to wait between runs
+pr_wait=30
+pr_warmup=true
+pr_concurrencies="8 16 32 64 128 256 512 1024"
+pr_testduration=60
+pr_bindir=
+pr_fastbench=
+
+function main
+{
+	local first
+
+	if [[ $# != 3 ]]; then
+		usage
+	fi
+
+	pr_pid="$1"
+	pr_port="$2"
+	pr_testdir="$3"
+	if [[ -e "$pr_testdir" ]]; then
+		fail "refusing to clobber data in \"$pr_testdir\""
+	fi
+
+	pr_bindir="$(dirname ${BASH_SOURCE[0]})/../bin"
+	pr_fastbench="$pr_bindir/fastbench"
+
+	mkdir -p "$pr_testdir"
+
+	echo "Server: pid $pr_pid on port $pr_port."
+	echo "Will test concurrencies: $pr_concurrencies."
+	echo "Using fastbench: $pr_fastbench"
+	echo "Beginning data collection."
+	trap cleanup EXIT
+
+	# Start monitoring memory
+	(while :; do 
+		echo "$(date +%s) $(ps -opid= -orss= -ovsz= -p "$pr_pid")"
+		sleep $pr_sample_mem;
+	done) > $pr_testdir/memory.out &
+	pr_children="$pr_children $!"
+
+	# Start monitoring CPU usage
+	prstat -d u -Lmc -p "$pr_pid" $pr_sample_cpu > $pr_testdir/prstat.out &
+	pr_children="$pr_children $!"
+	echo "Child processes: $pr_children"
+
+	# Wait for a few data points
+	echo "Waiting for initial data points."
+	sleep $pr_sample_mem
+	sleep $pr_sample_cpu
+
+	if [[ "$pr_warmup" != "false" ]]; then
+		echo "Beginning warmup."
+		if ! $pr_fastbench -c 1 -i 5 -d 300 sync 127.0.0.1 "$pr_port" | \
+		    tee $pr_testdir/fastbench-warmup.out; then
+			fail "bailing out because warmup failed"
+		fi
+
+		sleep $pr_wait
+	fi
+
+	first=true
+	for concur in $pr_concurrencies; do
+		if [[ $first != "true" ]]; then
+			echo "Pausing for $pr_wait seconds."
+			sleep $pr_wait
+		else
+			first=false
+		fi
+
+		echo "Starting test: concurrency = $concur"
+		$pr_bindir/fastclatency > \
+		    $pr_testdir/latency-sleep150-$concur.out &
+		pr_dtrace="$!"
+
+		if ! $pr_fastbench -c $concur -i 5 \
+		    -d $pr_testduration sleep150 127.0.0.1 "$pr_port" | \
+		    tee $pr_testdir/fastbench-sleep150-$concur.out; then
+			kill $pr_dtrace
+			fail "bailing out after failed test"
+		fi
+
+		kill $pr_dtrace
+	done
+}
+
+function cleanup
+{
+	echo "Cleaning up processes: $pr_children"
+	for c in $pr_children; do
+		kill $c
+	done
+	wait
+}
+
+main "$@"
