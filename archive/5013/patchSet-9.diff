From 7c0101f620e6ddbf874bd93f56e356faa99f215b Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Fri, 9 Nov 2018 19:53:20 +0000
Subject: [PATCH] OS-7335 atomic ops in syscall_mstate() induce significant
 overhead Reviewed by: Robert Mustacchi <rm@joyent.com> Reviewed by: Patrick
 Mooney <patrick.mooney@joyent.com>

---
 manifest                               |  1 +
 usr/src/pkg/manifests/system-header.mf |  2 +
 usr/src/uts/common/Makefile.files      |  1 +
 usr/src/uts/common/os/cpu_uarray.c     | 79 ++++++++++++++++++++++++++
 usr/src/uts/common/os/msacct.c         | 54 +++++++++++-------
 usr/src/uts/common/os/zone.c           | 51 ++++++++++-------
 usr/src/uts/common/sys/Makefile        | 13 +++--
 usr/src/uts/common/sys/cpu_uarray.h    | 75 ++++++++++++++++++++++++
 usr/src/uts/common/sys/sysmacros.h     | 13 +++++
 usr/src/uts/common/sys/zone.h          | 46 +++++++--------
 10 files changed, 266 insertions(+), 69 deletions(-)
 create mode 100644 usr/src/uts/common/os/cpu_uarray.c
 create mode 100644 usr/src/uts/common/sys/cpu_uarray.h

diff --git a/manifest b/manifest
index 310b7878b3..5645ffbeb8 100644
--- a/manifest
+++ b/manifest
@@ -3783,6 +3783,7 @@ f usr/include/sys/corectl.h 0644 root bin
 f usr/include/sys/cpc_impl.h 0644 root bin
 f usr/include/sys/cpc_pcbe.h 0644 root bin
 f usr/include/sys/cpr.h 0644 root bin
+f usr/include/sys/cpu_uarray.h 0644 root bin
 f usr/include/sys/cpu.h 0644 root bin
 f usr/include/sys/cpucaps.h 0644 root bin
 f usr/include/sys/cpucaps_impl.h 0644 root bin
diff --git a/usr/src/pkg/manifests/system-header.mf b/usr/src/pkg/manifests/system-header.mf
index a65dbd02b9..5495835f8a 100644
--- a/usr/src/pkg/manifests/system-header.mf
+++ b/usr/src/pkg/manifests/system-header.mf
@@ -26,6 +26,7 @@
 # Copyright 2014 Garrett D'Amore <garrett@damore.org>
 # Copyright 2018 Nexenta Systems, Inc.
 # Copyright 2016 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 set name=pkg.fmri value=pkg:/system/header@$(PKGVERS)
@@ -854,6 +855,7 @@ file path=usr/include/sys/corectl.h
 file path=usr/include/sys/cpc_impl.h
 file path=usr/include/sys/cpc_pcbe.h
 file path=usr/include/sys/cpr.h
+file path=usr/include/sys/cpu_uarray.h
 file path=usr/include/sys/cpu.h
 file path=usr/include/sys/cpucaps.h
 file path=usr/include/sys/cpucaps_impl.h
diff --git a/usr/src/uts/common/Makefile.files b/usr/src/uts/common/Makefile.files
index 942a28069b..174141ea57 100644
--- a/usr/src/uts/common/Makefile.files
+++ b/usr/src/uts/common/Makefile.files
@@ -51,6 +51,7 @@ COMMON_CORE_OBJS +=		\
 		cmt.o		\
 		cmt_policy.o	\
 		cpu.o		\
+		cpu_uarray.o	\
 		cpu_event.o	\
 		cpu_intr.o	\
 		cpu_pm.o	\
diff --git a/usr/src/uts/common/os/cpu_uarray.c b/usr/src/uts/common/os/cpu_uarray.c
new file mode 100644
index 0000000000..b26b89e61a
--- /dev/null
+++ b/usr/src/uts/common/os/cpu_uarray.c
@@ -0,0 +1,79 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+#include <sys/cpu_uarray.h>
+#include <sys/sysmacros.h>
+#include <sys/cpuvar.h>
+#include <sys/debug.h>
+#include <sys/kmem.h>
+
+static size_t
+cpu_uarray_size(size_t nr_items)
+{
+	size_t size = P2ROUNDUP(nr_items * sizeof (uint64_t), CUA_ALIGN);
+	size *= NCPU;
+	return (sizeof (cpu_uarray_t) + size);
+}
+
+cpu_uarray_t *
+cpu_uarray_zalloc(size_t nr_items, int kmflags)
+{
+	cpu_uarray_t *cua;
+
+	cua = kmem_zalloc(cpu_uarray_size(nr_items), kmflags);
+
+	if (cua != NULL) {
+		VERIFY(IS_P2ALIGNED(cua->cu_vals, CUA_ALIGN));
+		cua->cu_nr_items = nr_items;
+	}
+
+	return (cua);
+}
+
+void
+cpu_uarray_free(cpu_uarray_t *cua)
+{
+	kmem_free(cua, cpu_uarray_size(cua->cu_nr_items));
+}
+
+uint64_t
+cpu_uarray_sum(cpu_uarray_t *cua, size_t index)
+{
+	uint64_t sum = 0;
+
+	VERIFY3U(index, <, cua->cu_nr_items);
+
+	for (size_t c = 0; c < ncpus; c++) {
+		uint64_t addend = CPU_UARRAY_VAL(cua, c, index);
+		sum = UINT64_OVERFLOW_ADD(sum, addend);
+	}
+
+	return (sum);
+}
+
+uint64_t
+cpu_uarray_sum_all(cpu_uarray_t *cua)
+{
+	uint64_t sum = 0;
+
+	for (size_t c = 0; c < ncpus; c++) {
+		for (size_t i = 0; i < cua->cu_nr_items; i++) {
+			uint64_t addend = CPU_UARRAY_VAL(cua, c, i);
+			sum = UINT64_OVERFLOW_ADD(sum, addend);
+		}
+	}
+
+	return (sum);
+}
diff --git a/usr/src/uts/common/os/msacct.c b/usr/src/uts/common/os/msacct.c
index 66994321f7..db3ddd7fc8 100644
--- a/usr/src/uts/common/os/msacct.c
+++ b/usr/src/uts/common/os/msacct.c
@@ -21,7 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2012 Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -416,16 +416,21 @@ syscall_mstate(int fromms, int toms)
 		newtime = curtime - ms->ms_state_start;
 	}
 	*mstimep += newtime;
-	if (fromms == LMS_USER)
-		atomic_add_64(&z->zone_utime, newtime);
-	else if (fromms == LMS_SYSTEM)
-		atomic_add_64(&z->zone_stime, newtime);
 	t->t_mstate = toms;
 	ms->ms_state_start = curtime;
 	ms->ms_prev = fromms;
 	kpreempt_disable(); /* don't change CPU while changing CPU's state */
 	cpu = CPU;
 	ASSERT(cpu == t->t_cpu);
+
+	if (fromms == LMS_USER) {
+		CPU_UARRAY_VAL(z->zone_ustate, cpu->cpu_id,
+		    ZONE_USTATE_UTIME) += newtime;
+	} else if (fromms == LMS_SYSTEM) {
+		CPU_UARRAY_VAL(z->zone_ustate, cpu->cpu_id,
+		    ZONE_USTATE_STIME) += newtime;
+	}
+
 	if ((toms != LMS_USER) && (cpu->cpu_mstate != CMS_SYSTEM)) {
 		NEW_CPU_MSTATE(CMS_SYSTEM);
 	} else if ((toms == LMS_USER) && (cpu->cpu_mstate != CMS_USER)) {
@@ -652,19 +657,6 @@ new_mstate(kthread_t *t, int new_state)
 	} while (atomic_cas_64((uint64_t *)mstimep, oldtime, newtime) !=
 	    oldtime);
 
-	/*
-	 * When the system boots the initial startup thread will have a
-	 * ms_state_start of 0 which would add a huge system time to the global
-	 * zone.  We want to skip aggregating that initial bit of work.
-	 */
-	if (origstart != 0) {
-		z = ttozone(t);
-		if (state == LMS_USER)
-			atomic_add_64(&z->zone_utime, ztime);
-		else if (state == LMS_SYSTEM)
-			atomic_add_64(&z->zone_stime, ztime);
-	}
-
 	/*
 	 * Remember the previous running microstate.
 	 */
@@ -676,7 +668,25 @@ new_mstate(kthread_t *t, int new_state)
 	 */
 
 	kpreempt_disable(); /* MUST disable kpreempt before touching t->cpu */
+
 	ASSERT(t->t_cpu == CPU);
+
+	/*
+	 * When the system boots the initial startup thread will have a
+	 * ms_state_start of 0 which would add a huge system time to the global
+	 * zone.  We want to skip aggregating that initial bit of work.
+	 */
+	if (origstart != 0) {
+		z = ttozone(t);
+		if (state == LMS_USER) {
+			CPU_UARRAY_VAL(z->zone_ustate, t->t_cpu->cpu_id,
+			    ZONE_USTATE_UTIME) += ztime;
+		} else if (state == LMS_SYSTEM) {
+			CPU_UARRAY_VAL(z->zone_ustate, t->t_cpu->cpu_id,
+			    ZONE_USTATE_STIME) += ztime;
+		}
+	}
+
 	if (!CPU_ON_INTR(t->t_cpu) && curthread->t_intr == NULL) {
 		if (new_state == LMS_USER && t->t_cpu->cpu_mstate != CMS_USER)
 			new_cpu_mstate(CMS_USER, curtime);
@@ -783,7 +793,13 @@ restore_mstate(kthread_t *t)
 	z = ttozone(t);
 	waittime = curtime - waitrq;
 	ms->ms_acct[LMS_WAIT_CPU] += waittime;
-	atomic_add_64(&z->zone_wtime, waittime);
+
+	/*
+	 * We are in a disp context where we're not going to migrate CPUs.
+	 */
+	CPU_UARRAY_VAL(z->zone_ustate, CPU->cpu_id,
+	    ZONE_USTATE_WTIME) += waittime;
+
 	CPU->cpu_waitrq += waittime;
 	ms->ms_state_start = curtime;
 }
diff --git a/usr/src/uts/common/os/zone.c b/usr/src/uts/common/os/zone.c
index 42eba20668..68832a2c75 100644
--- a/usr/src/uts/common/os/zone.c
+++ b/usr/src/uts/common/os/zone.c
@@ -2364,20 +2364,26 @@ zone_misc_kstat_update(kstat_t *ksp, int rw)
 {
 	zone_t *zone = ksp->ks_private;
 	zone_misc_kstat_t *zmp = ksp->ks_data;
-	hrtime_t tmp;
+	hrtime_t hrtime;
+	uint64_t tmp;
 
 	if (rw == KSTAT_WRITE)
 		return (EACCES);
 
-	tmp = zone->zone_utime;
-	scalehrtime(&tmp);
-	zmp->zm_utime.value.ui64 = tmp;
-	tmp = zone->zone_stime;
-	scalehrtime(&tmp);
-	zmp->zm_stime.value.ui64 = tmp;
-	tmp = zone->zone_wtime;
-	scalehrtime(&tmp);
-	zmp->zm_wtime.value.ui64 = tmp;
+	tmp = cpu_uarray_sum(zone->zone_ustate, ZONE_USTATE_STIME);
+	hrtime = UINT64_OVERFLOW_TO_INT64(tmp);
+	scalehrtime(&hrtime);
+	zmp->zm_stime.value.ui64 = hrtime;
+
+	tmp = cpu_uarray_sum(zone->zone_ustate, ZONE_USTATE_UTIME);
+	hrtime = UINT64_OVERFLOW_TO_INT64(tmp);
+	scalehrtime(&hrtime);
+	zmp->zm_utime.value.ui64 = hrtime;
+
+	tmp = cpu_uarray_sum(zone->zone_ustate, ZONE_USTATE_WTIME);
+	hrtime = UINT64_OVERFLOW_TO_INT64(tmp);
+	scalehrtime(&hrtime);
+	zmp->zm_wtime.value.ui64 = hrtime;
 
 	zmp->zm_avenrun1.value.ui32 = zone->zone_avenrun[0];
 	zmp->zm_avenrun5.value.ui32 = zone->zone_avenrun[1];
@@ -2572,9 +2578,6 @@ zone_zsd_init(void)
 	zone0.zone_swapresv_kstat = NULL;
 	zone0.zone_physmem_kstat = NULL;
 	zone0.zone_nprocs_kstat = NULL;
-	zone0.zone_stime = 0;
-	zone0.zone_utime = 0;
-	zone0.zone_wtime = 0;
 
 	zone_pdata[0].zpers_zfsp = &zone0_zp_zfs;
 	zone_pdata[0].zpers_zfsp->zpers_zfs_io_pri = 1;
@@ -2819,6 +2822,8 @@ zone_init(void)
 	 */
 	rw_init(&zone0.zone_mntfs_db_lock, NULL, RW_DEFAULT, NULL);
 
+	zone0.zone_ustate = cpu_uarray_zalloc(ZONE_USTATE_MAX, KM_SLEEP);
+
 	mutex_enter(&zonehash_lock);
 	zone_uniqid(&zone0);
 	ASSERT(zone0.zone_uniqid == GLOBAL_ZONEUNIQID);
@@ -2930,6 +2935,8 @@ zone_free(zone_t *zone)
 	zone_status_set(zone, ZONE_IS_FREE);
 	mutex_exit(&zone_status_lock);
 
+	cpu_uarray_free(zone->zone_ustate);
+
 	if (zone->zone_rootvp != NULL)
 		VN_RELE(zone->zone_rootvp);
 	if (zone->zone_rootpath)
@@ -3750,12 +3757,13 @@ zone_find_by_path(const char *path)
  * Based on loadavg_update(), genloadavg() and calcloadavg() from clock.c.
  */
 void
-zone_loadavg_update()
+zone_loadavg_update(void)
 {
 	zone_t *zp;
 	zone_status_t status;
 	struct loadavg_s *lavg;
 	hrtime_t zone_total;
+	uint64_t tmp;
 	int i;
 	hrtime_t hr_avg;
 	int nrun;
@@ -3780,7 +3788,9 @@ zone_loadavg_update()
 		 */
 		lavg = &zp->zone_loadavg;
 
-		zone_total = zp->zone_utime + zp->zone_stime + zp->zone_wtime;
+		tmp = cpu_uarray_sum_all(zp->zone_ustate);
+		zone_total = UINT64_OVERFLOW_TO_INT64(tmp);
+
 		scalehrtime(&zone_total);
 
 		/* The zone_total should always be increasing. */
@@ -4835,8 +4845,8 @@ zone_set_privset(zone_t *zone, const priv_set_t *zone_privs,
  * Where each element of the nvpair_list_array is of the form:
  *
  * [(name = "privilege", value = RCPRIV_PRIVILEGED),
- * 	(name = "limit", value = uint64_t),
- * 	(name = "action", value = (RCTL_LOCAL_NOACTION || RCTL_LOCAL_DENY))]
+ *	(name = "limit", value = uint64_t),
+ *	(name = "action", value = (RCTL_LOCAL_NOACTION || RCTL_LOCAL_DENY))]
  */
 static int
 parse_rctls(caddr_t ubuf, size_t buflen, nvlist_t **nvlp)
@@ -5131,10 +5141,7 @@ zone_create(const char *zone_name, const char *zone_root,
 	zone->zone_bootargs = NULL;
 	zone->zone_fs_allowed = NULL;
 
-	secflags_zero(&zone0.zone_secflags.psf_lower);
-	secflags_zero(&zone0.zone_secflags.psf_effective);
-	secflags_zero(&zone0.zone_secflags.psf_inherit);
-	secflags_fullset(&zone0.zone_secflags.psf_upper);
+	psecflags_default(&zone->zone_secflags);
 
 	zone->zone_initname =
 	    kmem_alloc(strlen(zone_default_initname) + 1, KM_SLEEP);
@@ -5157,6 +5164,8 @@ zone_create(const char *zone_name, const char *zone_root,
 	    kmem_zalloc(sizeof (zone_zfs_io_t), KM_SLEEP);
 	zone_pdata[zoneid].zpers_zfsp->zpers_zfs_io_pri = 1;
 
+	zone->zone_ustate = cpu_uarray_zalloc(ZONE_USTATE_MAX, KM_SLEEP);
+
 	/*
 	 * Zsched initializes the rctls.
 	 */
diff --git a/usr/src/uts/common/sys/Makefile b/usr/src/uts/common/sys/Makefile
index 787774e03a..498e2ebab3 100644
--- a/usr/src/uts/common/sys/Makefile
+++ b/usr/src/uts/common/sys/Makefile
@@ -21,7 +21,7 @@
 
 #
 # Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
-# Copyright 2014, Joyent, Inc. All rights reserved.
+# Copyright (c) 2018, Joyent, Inc.
 # Copyright 2013 Garrett D'Amore <garrett@damore.org>
 # Copyright 2015, Joyent, Inc. All rights reserved.
 # Copyright 2013 Saso Kiselkov. All rights reserved.
@@ -59,7 +59,7 @@ i386_HDRS=			\
 	nvme.h			\
 	ucode.h
 
-sparc_HDRS= 			\
+sparc_HDRS=			\
 	mouse.h			\
 	scsi/targets/ssddef.h	\
 	$(MDESCHDRS)
@@ -138,6 +138,7 @@ CHKHDRS=			\
 	cpc_impl.h		\
 	cpc_pcbe.h		\
 	cpr.h			\
+	cpu_uarray.h		\
 	cpupart.h		\
 	cpuvar.h		\
 	crc32.h			\
@@ -280,7 +281,7 @@ CHKHDRS=			\
 	iapriocntl.h		\
 	ibpart.h		\
 	id32.h			\
-	idmap.h 		\
+	idmap.h			\
 	ieeefp.h		\
 	id_space.h		\
 	inotify.h		\
@@ -714,7 +715,7 @@ BSCHDRS=			\
 
 MDESCHDRS=			\
 	mdesc.h			\
-	mdesc_impl.h		
+	mdesc_impl.h
 
 CPUDRVHDRS=			\
 	cpudrv.h
@@ -777,8 +778,8 @@ RDMAHDRS=		\
 	ib_user_mad.h	\
 	ib_user_sa.h	\
 	ib_user_verbs.h \
-	ib_verbs.h 	\
-	rdma_cm.h 	\
+	ib_verbs.h	\
+	rdma_cm.h	\
 	rdma_user_cm.h
 
 SOL_UVERBSHDRS=		\
diff --git a/usr/src/uts/common/sys/cpu_uarray.h b/usr/src/uts/common/sys/cpu_uarray.h
new file mode 100644
index 0000000000..478a6c2dde
--- /dev/null
+++ b/usr/src/uts/common/sys/cpu_uarray.h
@@ -0,0 +1,75 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Use a cpu_uarray_t for an array of uint64_t values that are written on a
+ * per-CPU basis.  We align each CPU on a 128-byte boundary (so two cachelines).
+ * It's not clear why, but this can have a significant effect in multi-socket
+ * systems running certain benchmarks.  So the layout is like this, for example:
+ *
+ * 0:	STAT1 for CPU 0
+ * 8:	STAT2 for CPU 0
+ * 16:	STAT3 for CPU 0
+ * 24:	padding
+ * 128: STAT1 for CPU 1
+ * 136: STAT2 for CPU 1
+ * ...
+ *
+ * At collection time, cpu_uarray_sum() can be used to sum the given value index
+ * across all CPUs, or cpu_uarray_sum_all() sums all stats across all CPUs.
+ * The summation is done such that it saturates at UINT64_MAX.
+ */
+
+#ifndef	_SYS_CPU_UARRAY_H
+#define	_SYS_CPU_UARRAY_H
+
+#include <sys/types.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#ifdef _KERNEL
+
+/*
+ * Trying to include sysmacros.h for P2ROUNDUP() here is just too painful.
+ */
+#define	CUA_ROUNDUP(x, align) (-(-(x) & -(align)))
+#define	CUA_ALIGN (128)
+#define	CUA_CPU_STRIDE(nr_items) \
+	CUA_ROUNDUP((nr_items), CUA_ALIGN / sizeof (uint64_t))
+#define	CUA_INDEX(nr_items, c, i) (((c) * CUA_CPU_STRIDE(nr_items)) + (i))
+
+#define	CPU_UARRAY_VAL(cua, cpu_index, stat_index) \
+	((cua)->cu_vals[CUA_INDEX((cua)->cu_nr_items, cpu_index, stat_index)])
+
+typedef struct {
+	uint64_t cu_nr_items;
+	char cu_pad[CUA_ALIGN - sizeof (uint64_t)];
+	volatile uint64_t cu_vals[];
+} cpu_uarray_t __aligned(CUA_ALIGN);
+
+extern cpu_uarray_t *cpu_uarray_zalloc(size_t, int);
+extern void cpu_uarray_free(cpu_uarray_t *);
+extern uint64_t cpu_uarray_sum(cpu_uarray_t *, size_t);
+extern uint64_t cpu_uarray_sum_all(cpu_uarray_t *);
+
+#endif /* _KERNEL */
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _SYS_CPU_UARRAY_H */
diff --git a/usr/src/uts/common/sys/sysmacros.h b/usr/src/uts/common/sys/sysmacros.h
index 6f5882b54b..5dc6eee0ec 100644
--- a/usr/src/uts/common/sys/sysmacros.h
+++ b/usr/src/uts/common/sys/sysmacros.h
@@ -373,6 +373,19 @@ extern unsigned char bcd_to_byte[256];
 #define	ARRAY_SIZE(x)	(sizeof (x) / sizeof (x[0]))
 #endif
 
+/*
+ * Add a value to a uint64_t that saturates at UINT64_MAX instead of wrapping
+ * around.
+ */
+#define	UINT64_OVERFLOW_ADD(val, add) \
+	((val) > ((val) + (add)) ? (UINT64_MAX) : ((val) + (add)))
+
+/*
+ * Convert to an int64, saturating at INT64_MAX.
+ */
+#define	UINT64_OVERFLOW_TO_INT64(uval) \
+	(((uval) > INT64_MAX) ? INT64_MAX : (int64_t)(uval))
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/usr/src/uts/common/sys/zone.h b/usr/src/uts/common/sys/zone.h
index 678dd4e029..845f20a46f 100644
--- a/usr/src/uts/common/sys/zone.h
+++ b/usr/src/uts/common/sys/zone.h
@@ -42,6 +42,7 @@
 #include <sys/socket_impl.h>
 #include <sys/secflags.h>
 #include <netinet/in.h>
+#include <sys/cpu_uarray.h>
 
 #ifdef	__cplusplus
 extern "C" {
@@ -353,6 +354,15 @@ typedef struct zone_net_data {
 
 #define	GLOBAL_ZONEUNIQID	0	/* uniqid of the global zone */
 
+/*
+ * Indexes into ->zone_ustate array, summing the micro state of all threads in a
+ * particular zone.
+ */
+#define	ZONE_USTATE_STIME (0)
+#define	ZONE_USTATE_UTIME (1)
+#define	ZONE_USTATE_WTIME (2)
+#define	ZONE_USTATE_MAX (3)
+
 struct pool;
 struct brand;
 
@@ -429,7 +439,7 @@ typedef struct {
 	kstat_named_t	zv_100ms_ops;
 	kstat_named_t	zv_1s_ops;
 	kstat_named_t	zv_10s_ops;
-	kstat_named_t 	zv_delay_cnt;
+	kstat_named_t	zv_delay_cnt;
 	kstat_named_t	zv_delay_time;
 } zone_vfs_kstat_t;
 
@@ -502,13 +512,13 @@ typedef struct zone {
 					/* if not emulated */
 	/*
 	 * zone_lock protects the following fields of a zone_t:
-	 * 	zone_ref
-	 * 	zone_cred_ref
-	 * 	zone_subsys_ref
-	 * 	zone_ref_list
-	 * 	zone_ntasks
-	 * 	zone_flags
-	 * 	zone_zsd
+	 *	zone_ref
+	 *	zone_cred_ref
+	 *	zone_subsys_ref
+	 *	zone_ref_list
+	 *	zone_ntasks
+	 *	zone_flags
+	 *	zone_zsd
 	 *	zone_pfexecd
 	 */
 	kmutex_t	zone_lock;
@@ -616,7 +626,7 @@ typedef struct zone {
 	boolean_t	zone_restart_init_0;	/* Restart only if it exits 0 */
 	boolean_t	zone_setup_app_contract; /* setup contract? */
 	struct brand	*zone_brand;		/* zone's brand */
-	void 		*zone_brand_data;	/* store brand specific data */
+	void		*zone_brand_data;	/* store brand specific data */
 	id_t		zone_defaultcid;	/* dflt scheduling class id */
 	boolean_t	zone_fixed_hipri;	/* fixed sched. hi prio */
 	kstat_t		*zone_swapresv_kstat;
@@ -678,22 +688,12 @@ typedef struct zone {
 
 	/*
 	 * Misc. kstats and counters for zone cpu-usage aggregation.
-	 * The zone_Xtime values are the sum of the micro-state accounting
-	 * values for all threads that are running or have run in the zone.
-	 * This is tracked in msacct.c as threads change state.
-	 * The zone_stime is the sum of the LMS_SYSTEM times.
-	 * The zone_utime is the sum of the LMS_USER times.
-	 * The zone_wtime is the sum of the LMS_WAIT_CPU times.
-	 * As with per-thread micro-state accounting values, these values are
-	 * not scaled to nanosecs.  The scaling is done by the
-	 * zone_misc_kstat_update function when kstats are requested.
 	 */
 	kmutex_t	zone_misc_lock;		/* protects misc statistics */
 	kstat_t		*zone_misc_ksp;
 	zone_misc_kstat_t *zone_misc_stats;
-	uint64_t	zone_stime;		/* total system time */
-	uint64_t	zone_utime;		/* total user time */
-	uint64_t	zone_wtime;		/* total time waiting in runq */
+	/* Accumulated microstate for all threads in this zone. */
+	cpu_uarray_t	*zone_ustate;
 	/* fork-fail kstat tracking */
 	uint32_t	zone_ffcap;		/* hit an rctl cap */
 	uint32_t	zone_ffnoproc;		/* get proc/lwp error */
@@ -825,7 +825,7 @@ typedef uint_t zone_key_t;
 
 extern void	zone_key_create(zone_key_t *, void *(*)(zoneid_t),
     void (*)(zoneid_t, void *), void (*)(zoneid_t, void *));
-extern int 	zone_key_delete(zone_key_t);
+extern int	zone_key_delete(zone_key_t);
 extern void	*zone_getspecific(zone_key_t, zone_t *);
 extern int	zone_setspecific(zone_key_t, zone_t *, const void *);
 
@@ -851,7 +851,7 @@ struct zsd_entry {
 	void			(*zsd_shutdown)(zoneid_t, void *);
 	void			(*zsd_destroy)(zoneid_t, void *);
 	list_node_t		zsd_linkage;
-	uint16_t 		zsd_flags;	/* See below */
+	uint16_t		zsd_flags;	/* See below */
 	kcondvar_t		zsd_cv;
 };
 
-- 
2.21.0

