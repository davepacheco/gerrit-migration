commit 9702197f4faad8a9d85454ddcc7b6651f140791f (refs/changes/19/3119/2)
Author: Jerry Jelinek <jerry.jelinek@joyent.com>
Date:   2017-12-18T20:01:16+00:00 (1 year, 10 months ago)
    
    OS-6467 LX go 1.9 aborts on unexpected signal interpositioning

diff --git a/usr/src/lib/brand/lx/lx_brand/common/clone.c b/usr/src/lib/brand/lx/lx_brand/common/clone.c
index b04ee953a3..f759506aff 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/clone.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/clone.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <assert.h>
@@ -391,8 +391,23 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 		/*
 		 * Suspend signal delivery, run the stack management prefork
 		 * handler and perform the actual fork(2) operation.
+		 *
+		 * During vfork, Linux will not deliver any signals to any
+		 * thread in the parent. Some applications (e.g. Go) depend on
+		 * this. For example, we must prevent the following sequence:
+		 * 1) Parent with many threads, one thread calls vfork
+		 * 2) vforked child resets all signal handlers
+		 * 3) a different child of the parent exits and SIGCHLD is sent
+		 *    to parent before the vforked child execs/exits
+		 * The parent cannot receive the SIGCHLD until afer we repair
+		 * the parent's signal handlers in lx_sighandlers_restore, once
+		 * the parent resumes after the vfork.
 		 */
-		_sigoff();
+		if (flags & LX_CLONE_VFORK) {
+			lx_block_all_signals();
+		} else {
+			_sigoff();
+		}
 		lx_stack_prefork();
 		if (flags & LX_CLONE_VFORK) {
 			lx_sighandlers_t saved;
@@ -444,16 +459,20 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 				(void) uucopy(&rval, ptidp, sizeof (int));
 			}
 
+			/*
+			 * Re-enable signal delivery in the parent process.
+			 */
+			if (flags & LX_CLONE_VFORK) {
+				lx_unblock_all_signals();
+			} else {
+				_sigon();
+			}
+
 			if (rval > 0) {
 				lx_ptrace_stop_if_option(ptrace_event, B_FALSE,
 				    (ulong_t)rval, NULL);
 			}
 
-			/*
-			 * Re-enable signal delivery in the parent process.
-			 */
-			_sigon();
-
 			return ((rval < 0) ? -errno : rval);
 		}
 
@@ -562,14 +581,18 @@ lx_clone(uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5)
 		}
 
 		/*
-		 * Stop for ptrace if required.
+		 * Re-enable signal delivery in the child process.
 		 */
-		lx_ptrace_stop_if_option(ptrace_event, B_TRUE, 0, NULL);
+		if (flags & LX_CLONE_VFORK) {
+			lx_unblock_all_signals();
+		} else {
+			_sigon();
+		}
 
 		/*
-		 * Re-enable signal delivery in the child process.
+		 * Stop for ptrace if required.
 		 */
-		_sigon();
+		lx_ptrace_stop_if_option(ptrace_event, B_TRUE, 0, NULL);
 
 		/*
 		 * The child process returns via the regular emulated system
diff --git a/usr/src/lib/brand/lx/lx_brand/common/fork.c b/usr/src/lib/brand/lx/lx_brand/common/fork.c
index aa14267185..beb76fcf59 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/fork.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/fork.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2016 Joyent, Inc.  All rights reserved.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #include <errno.h>
@@ -124,7 +124,7 @@ lx_vfork(void)
 	 * the comments in lx_clone for more detail.
 	 */
 
-	_sigoff();
+	lx_block_all_signals();
 	lx_stack_prefork();
 	lx_sighandlers_save(&saved);
 	lx_tsd->lxtsd_is_vforked++;
@@ -138,7 +138,7 @@ lx_vfork(void)
 	switch (ret) {
 	case -1:
 		lx_stack_postfork();
-		_sigon();
+		lx_unblock_all_signals();
 		return (-errno);
 
 	case 0:
@@ -158,6 +158,8 @@ lx_vfork(void)
 		lx_debug("\tvfork native stack sp %p",
 		    vforkuc.uc_brand_data[1]);
 
+		lx_unblock_all_signals();
+
 		/* Stop for ptrace if required. */
 		lx_ptrace_stop_if_option(LX_PTRACE_O_TRACEVFORK, B_TRUE, 0,
 		    NULL);
@@ -176,9 +178,9 @@ lx_vfork(void)
 	default:
 		/* parent - child should have exited or exec-ed by now */
 		lx_stack_postfork();
+		lx_unblock_all_signals();
 		lx_ptrace_stop_if_option(LX_PTRACE_O_TRACEVFORK, B_FALSE,
 		    (ulong_t)ret, NULL);
-		_sigon();
 		return (ret);
 	}
 }
diff --git a/usr/src/lib/brand/lx/lx_brand/common/signal.c b/usr/src/lib/brand/lx/lx_brand/common/signal.c
index 5c754733cb..61ddd6db20 100644
--- a/usr/src/lib/brand/lx/lx_brand/common/signal.c
+++ b/usr/src/lib/brand/lx/lx_brand/common/signal.c
@@ -2379,3 +2379,15 @@ lx_signalfd4(int fd, uintptr_t mask, size_t msize, int flags)
 
 	return (r == -1 ? -errno : r);
 }
+
+void
+lx_block_all_signals()
+{
+	(void) syscall(SYS_brand, B_BLOCK_ALL_SIGS);
+}
+
+void
+lx_unblock_all_signals()
+{
+	(void) syscall(SYS_brand, B_UNBLOCK_ALL_SIGS);
+}
diff --git a/usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h b/usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h
index 5879311cef..ce241db8bc 100644
--- a/usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h
+++ b/usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.  All rights reserved.
+ * Copyright 2017 Joyent, Inc.
  */
 
 #ifndef _SYS_LX_H
@@ -147,6 +147,9 @@ extern void lx_free_other_stacks(void);
 extern void lx_stack_prefork(void);
 extern void lx_stack_postfork(void);
 
+extern void lx_block_all_signals();
+extern void lx_unblock_all_signals();
+
 /*
  * NO_UUCOPY disables calls to the uucopy* system calls to help with
  * debugging brand library accesses to linux application memory.
diff --git a/usr/src/uts/common/brand/lx/os/lx_brand.c b/usr/src/uts/common/brand/lx/os/lx_brand.c
index 1b9bcc75c0..77d9f79086 100644
--- a/usr/src/uts/common/brand/lx/os/lx_brand.c
+++ b/usr/src/uts/common/brand/lx/os/lx_brand.c
@@ -1870,6 +1870,27 @@ lx_brandsys(int cmd, int64_t *rval, uintptr_t arg1, uintptr_t arg2,
 		(void) lx_start_nfs_lockd();
 		return (0);
 
+	case B_BLOCK_ALL_SIGS:
+		mutex_enter(&p->p_lock);
+		pd = ptolxproc(p);
+		pd->l_block_all_signals++;
+		mutex_exit(&p->p_lock);
+		return (0);
+
+	case B_UNBLOCK_ALL_SIGS: {
+		uint_t result;
+
+		mutex_enter(&p->p_lock);
+		pd = ptolxproc(p);
+		if (pd->l_block_all_signals == 0) {
+			result = set_errno(EINVAL);
+		} else {
+			pd->l_block_all_signals--;
+			result = 0;
+		}
+		mutex_exit(&p->p_lock);
+		return (result);
+	}
 	}
 
 	return (EINVAL);
diff --git a/usr/src/uts/common/brand/lx/os/lx_ptrace.c b/usr/src/uts/common/brand/lx/os/lx_ptrace.c
index cc24518f74..3131774f27 100644
--- a/usr/src/uts/common/brand/lx/os/lx_ptrace.c
+++ b/usr/src/uts/common/brand/lx/os/lx_ptrace.c
@@ -1644,6 +1644,14 @@ lx_ptrace_stop(ushort_t what)
 	return (lx_ptrace_stop_common(p, lwpd, what));
 }
 
+/*
+ * In addition to performing the ptrace sig_stop handling, this function is
+ * also used to block signal from being delivered.
+ *
+ * Return 0 if issig_forreal() should continue on, -1 if issig_forreal should
+ * recheck after we've made changes, or 1 if issig_forreal should stop checking
+ * signals.
+ */
 int
 lx_ptrace_issig_stop(proc_t *p, klwp_t *lwp)
 {
@@ -1652,6 +1660,9 @@ lx_ptrace_issig_stop(proc_t *p, klwp_t *lwp)
 
 	VERIFY(MUTEX_HELD(&p->p_lock));
 
+	if (ptolxproc(p)->l_block_all_signals != 0)
+		return (1);
+
 	/*
 	 * In very rare circumstances, a process which is almost completely
 	 * through proc_exit() may incur issig checks in the current thread via
diff --git a/usr/src/uts/common/brand/lx/sys/lx_brand.h b/usr/src/uts/common/brand/lx/sys/lx_brand.h
index 08d8d537d9..fb21f4961b 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_brand.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_brand.h
@@ -94,8 +94,8 @@ extern "C" {
 #define	B_GET_CURRENT_CONTEXT	129
 #define	B_EMULATION_DONE	130
 #define	B_START_NFS_LOCKD	131
-/* formerly B_SET_AFFINITY_MASK	132 */
-/* formerly B_GET_AFFINITY_MASK	133 */
+#define	B_BLOCK_ALL_SIGS	132
+#define	B_UNBLOCK_ALL_SIGS	133
 #define	B_PTRACE_CLONE_BEGIN	134
 #define	B_PTRACE_STOP_FOR_OPT	135
 #define	B_UNSUPPORTED		136
@@ -362,6 +362,9 @@ typedef struct lx_proc_data {
 	kmutex_t l_remap_anoncache_lock;
 	uint64_t l_remap_anoncache_generation;
 	lx_segmap_t l_remap_anoncache[LX_REMAP_ANONCACHE_NENTRIES];
+
+	/* Block all signals to all threads; used during vfork */
+	uint_t	 l_block_all_signals;
 } lx_proc_data_t;
 
 #endif	/* _KERNEL */
diff --git a/usr/src/uts/common/os/sig.c b/usr/src/uts/common/os/sig.c
index 5ef12f3ae4..67a93581dd 100644
--- a/usr/src/uts/common/os/sig.c
+++ b/usr/src/uts/common/os/sig.c
@@ -22,7 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -640,17 +640,24 @@ issig_forreal(void)
 		}
 
 		/*
+		 * The brand hook name 'b_issig_stop' is a misnomer.
 		 * Allow the brand the chance to alter (or suppress) delivery
 		 * of this signal.
 		 */
 		if (PROC_IS_BRANDED(p) && BROP(p)->b_issig_stop != NULL) {
+			int r;
+
 			/*
 			 * The brand hook will return 0 if it would like
-			 * us to drive on, or -1 if we should restart
-			 * the loop to check other conditions.
+			 * us to drive on, -1 if we should restart
+			 * the loop to check other conditions, or 1 if we
+			 * should terminate the loop.
 			 */
-			if (BROP(p)->b_issig_stop(p, lwp) != 0) {
+			r = BROP(p)->b_issig_stop(p, lwp);
+			if (r < 0) {
 				continue;
+			} else if (r > 0) {
+				break;
 			}
 		}
 
