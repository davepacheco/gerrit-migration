From 9e94f91c24b50626036fe01b308b0ecac7cf9203 Mon Sep 17 00:00:00 2001
From: Rob Johnston <rob.johnston@joyent.com>
Date: Mon, 20 Nov 2017 22:21:10 +0000
Subject: [PATCH] OS-6461 fac_prov_ipmi should support binding by entity id and
 instance OS-6464 ipmi topo plugin should automatically enumerate sensors on
 nodes it enumerates

---
 usr/src/lib/fm/topo/libtopo/common/topo_hc.h  |  7 ++
 .../common/fac_prov_ipmi/fac_prov_ipmi.c      | 64 +++++++++++++------
 .../fm/topo/modules/common/ipmi/ipmi_enum.c   | 38 +++++++++++
 3 files changed, 89 insertions(+), 20 deletions(-)

diff --git a/usr/src/lib/fm/topo/libtopo/common/topo_hc.h b/usr/src/lib/fm/topo/libtopo/common/topo_hc.h
index 9de7a86736..ec646b8dde 100644
--- a/usr/src/lib/fm/topo/libtopo/common/topo_hc.h
+++ b/usr/src/lib/fm/topo/libtopo/common/topo_hc.h
@@ -177,6 +177,13 @@ extern "C" {
 #define	TOPO_PORT_SFF_TRANSCEIVER_REV	"revision"
 #define	TOPO_PORT_SFF_TRANSCEIVER_SN	"serial-number"
 
+/*
+ * These properties will exist on nodes enumerated by the ipmi module. They
+ * are consumed by the fac_prov_ipmi module
+ */
+#define	TOPO_PROP_ENTITY_ID	"entity_id"
+#define	TOPO_PROP_ENTITY_INST	"entity_instance"
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/usr/src/lib/fm/topo/modules/common/fac_prov_ipmi/fac_prov_ipmi.c b/usr/src/lib/fm/topo/modules/common/fac_prov_ipmi/fac_prov_ipmi.c
index 559020efe5..720b207617 100644
--- a/usr/src/lib/fm/topo/modules/common/fac_prov_ipmi/fac_prov_ipmi.c
+++ b/usr/src/lib/fm/topo/modules/common/fac_prov_ipmi/fac_prov_ipmi.c
@@ -22,7 +22,9 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
-
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -1437,28 +1439,20 @@ sdr_callback(ipmi_handle_t *hdl, const char *id, ipmi_sdr_t *sdr, void *data)
 	return (0);
 }
 
-/* ARGSUSED */
 static int
-ipmi_sensor_enum(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
-    nvlist_t *in, nvlist_t **out)
+get_entity_info(topo_mod_t *mod, tnode_t *node, ipmi_handle_t *hdl,
+    struct entity_info *ei)
 {
 	char **entity_refs;
 	int err;
 	uint_t nelems;
-	struct entity_info ei;
 	ipmi_sdr_t *ref_sdr;
-	ipmi_handle_t *hdl;
 	ipmi_sdr_full_sensor_t *fsensor;
 	ipmi_sdr_compact_sensor_t *csensor;
 	ipmi_sdr_fru_locator_t *floc;
 	ipmi_sdr_generic_locator_t *gloc;
 	boolean_t found_sdr = B_FALSE;
 
-	if ((hdl = topo_mod_ipmi_hold(mod)) == NULL) {
-		topo_mod_dprintf(mod, "Failed to get IPMI handle\n");
-		return (-1);
-	}
-
 	/*
 	 * Use the entity ref to lookup the SDR, which will have the entity ID
 	 * and instance.
@@ -1490,24 +1484,24 @@ ipmi_sensor_enum(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
 	switch (ref_sdr->is_type) {
 		case IPMI_SDR_TYPE_FULL_SENSOR:
 			fsensor = (ipmi_sdr_full_sensor_t *)ref_sdr->is_record;
-			ei.ei_id = fsensor->is_fs_entity_id;
-			ei.ei_inst = fsensor->is_fs_entity_instance;
+			ei->ei_id = fsensor->is_fs_entity_id;
+			ei->ei_inst = fsensor->is_fs_entity_instance;
 			break;
 		case IPMI_SDR_TYPE_COMPACT_SENSOR:
 			csensor
 			    = (ipmi_sdr_compact_sensor_t *)ref_sdr->is_record;
-			ei.ei_id = csensor->is_cs_entity_id;
-			ei.ei_inst = csensor->is_cs_entity_instance;
+			ei->ei_id = csensor->is_cs_entity_id;
+			ei->ei_inst = csensor->is_cs_entity_instance;
 			break;
 		case IPMI_SDR_TYPE_FRU_LOCATOR:
 			floc = (ipmi_sdr_fru_locator_t *)ref_sdr->is_record;
-			ei.ei_id = floc->is_fl_entity;
-			ei.ei_inst = floc->is_fl_instance;
+			ei->ei_id = floc->is_fl_entity;
+			ei->ei_inst = floc->is_fl_instance;
 			break;
 		case IPMI_SDR_TYPE_GENERIC_LOCATOR:
 			gloc = (ipmi_sdr_generic_locator_t *)ref_sdr->is_record;
-			ei.ei_id = gloc->is_gl_entity;
-			ei.ei_inst = gloc->is_gl_instance;
+			ei->ei_id = gloc->is_gl_entity;
+			ei->ei_inst = gloc->is_gl_instance;
 			break;
 		default:
 			topo_mod_dprintf(mod, "Failed to determine entity id "
@@ -1515,6 +1509,36 @@ ipmi_sensor_enum(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
 			topo_mod_ipmi_rele(mod);
 			return (topo_mod_seterrno(mod, EMOD_NVL_INVAL));
 	}
+	return (0);
+}
+
+/* ARGSUSED */
+static int
+ipmi_sensor_enum(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
+    nvlist_t *in, nvlist_t **out)
+{
+	int err;
+	struct entity_info ei;
+	ipmi_handle_t *hdl;
+
+	if ((hdl = topo_mod_ipmi_hold(mod)) == NULL) {
+		topo_mod_dprintf(mod, "Failed to get IPMI handle\n");
+		return (-1);
+	}
+
+	/*
+	 * First check if properties for the associated IPMI entity id and
+	 * instance exist.  If not, we check for a property referencing
+	 * an IPMI entity name on which we can lookup the entity ID and
+	 * instance.  If neither exist then we bail out.
+	 */
+	if (topo_prop_get_uint32(node, TOPO_PGROUP_IPMI, TOPO_PROP_ENTITY_ID,
+	    &ei.ei_id, &err) != 0 ||
+	    topo_prop_get_uint32(node, TOPO_PGROUP_IPMI, TOPO_PROP_ENTITY_INST,
+	    &ei.ei_inst, &err) != 0) {
+		if (get_entity_info(mod, node, hdl, &ei) != 0)
+			goto out;
+	}
 	ei.ei_node = node;
 	ei.ei_mod = mod;
 
@@ -1528,7 +1552,7 @@ ipmi_sensor_enum(topo_mod_t *mod, tnode_t *node, topo_version_t vers,
 		topo_mod_ipmi_rele(mod);
 		return (-1);
 	}
-
+out:
 	topo_mod_ipmi_rele(mod);
 
 	return (0);
diff --git a/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c b/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c
index 4f0390dde1..9fbb5d01ee 100644
--- a/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c
+++ b/usr/src/lib/fm/topo/modules/common/ipmi/ipmi_enum.c
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 #include <assert.h>
@@ -32,6 +33,7 @@
 #define	TOPO_PGROUP_IPMI 		"ipmi"
 #define	TOPO_PROP_IPMI_ENTITY_REF	"entity_ref"
 #define	TOPO_PROP_IPMI_ENTITY_PRESENT	"entity_present"
+#define	FAC_PROV_IPMI			"fac_prov_ipmi"
 
 typedef struct ipmi_enum_data {
 	topo_mod_t	*ed_mod;
@@ -210,6 +212,7 @@ ipmi_check_entity(ipmi_handle_t *ihp, ipmi_entity_t *ep, void *data)
 	ipmi_enum_data_t cdata;
 	tnode_t *pnode = edp->ed_pnode;
 	topo_mod_t *mod = edp->ed_mod;
+	topo_mod_t *fmod = topo_mod_getspecific(mod);
 	nvlist_t *auth, *fmri;
 	tnode_t *tn;
 	topo_pgroup_info_t pgi;
@@ -313,12 +316,37 @@ ipmi_check_entity(ipmi_handle_t *ihp, ipmi_entity_t *ep, void *data)
 		}
 	}
 
+	/*
+	 * Add properties to contain the IPMI entity id and instance.  This
+	 * will be used by the fac_prov_ipmi module to discover and enumerate
+	 * facility nodes for any associated sensors.
+	 */
+	if (topo_prop_set_uint32(tn, TOPO_PGROUP_IPMI, TOPO_PROP_ENTITY_ID,
+	    TOPO_PROP_IMMUTABLE, ep->ie_type, &err) != 0 ||
+	    topo_prop_set_uint32(tn, TOPO_PGROUP_IPMI, TOPO_PROP_ENTITY_INST,
+	    TOPO_PROP_IMMUTABLE, ep->ie_instance, &err) != 0) {
+		topo_mod_dprintf(mod, "failed to add ipmi properties (%s)",
+		    topo_strerror(err));
+		return (1);
+	}
 	if (topo_method_register(mod, tn, ipmi_methods) != 0) {
 		topo_mod_dprintf(mod, "topo_method_register() failed: %s",
 		    topo_mod_errmsg(mod));
 		return (1);
 	}
 
+	/*
+	 * Invoke the tmo_enum callback from the fac_prov_ipmi module on this
+	 * node.  This will have the effect of registering a method on this node
+	 * for to enumerating sensors.
+	 */
+	if (topo_mod_enumerate(fmod, tn, FAC_PROV_IPMI, FAC_PROV_IPMI, 0, 0,
+	    NULL) != 0) {
+		topo_mod_dprintf(mod, "facility provider enum failed (%s)",
+		    topo_mod_errmsg(mod));
+		return (1);
+	}
+
 	/*
 	 * If we are a child of a non-chassis node, and there isn't an explicit
 	 * FRU locator record, then propagate the parent's FRU.  Otherwise, set
@@ -479,6 +507,8 @@ ipmi_post_process(topo_mod_t *mod, tnode_t *tn)
 int
 _topo_init(topo_mod_t *mod, topo_version_t version)
 {
+	topo_mod_t *fmod;
+
 	if (getenv("TOPOIPMIDEBUG") != NULL)
 		topo_mod_setdebug(mod);
 
@@ -488,6 +518,14 @@ _topo_init(topo_mod_t *mod, topo_version_t version)
 		return (-1); /* mod errno already set */
 	}
 
+	if ((fmod = topo_mod_load(mod, FAC_PROV_IPMI, TOPO_VERSION)) == NULL) {
+		topo_mod_dprintf(mod, "failed to load %s: %s",
+		    FAC_PROV_IPMI, topo_mod_errmsg(mod));
+		return (1);
+	}
+
+	topo_mod_setspecific(mod, fmod);
+
 	topo_mod_dprintf(mod, "IPMI enumerator initialized\n");
 	return (0);
 }
-- 
2.21.0

