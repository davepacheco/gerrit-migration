commit cf09259db615408f1c80ab05f1385b3de0f9f2b8 (refs/changes/14/3214/1)
Author: Marsell Kukuljevic <marsell@joyent.com>
Date:   2018-01-16T00:48:02+13:00 (1 year, 9 months ago)
    
    PUBAPI-1476: Create a compatibility layer so that all cloudapi plugins can be used in sdc-docker, and vice versa
    DOCKER-1054: Provide provisioning limits plugin for sdc-docker similar to cloudapi functionality

diff --git a/lib/app.js b/lib/app.js
index 11802d1..0b3600b 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -82,6 +82,8 @@ try {
 // PUBAPI-646: Backwards compatible authorization parser
 var authorizationParser = require('./authorization');
 
+var PluginManager = require('./plugin-manager');
+
 // --- Globals
 
 var HTML_FMT = '<html><head /><body><p>%s</p></body></html>\n';
@@ -98,33 +100,6 @@ var MORAY_POLL = 5000; // in ms
 
 // --- Internal functions
 
-
-function translatePlugin(pl) {
-    var plugin = {
-        name: pl.cn,
-        enabled: (pl.enabled === 'true'),
-        config: {
-            datacenter: pl.datacenter,
-            defaults: []
-        }
-    };
-
-    // a single 'defaults' entry will not be returned as an array, wrap it.
-    if (!Array.isArray(pl.defaults)) {
-        pl.defaults = [pl.defaults];
-    }
-
-    pl.defaults.forEach(function (d) {
-        try {
-            d = JSON.parse(d);
-            plugin.config.defaults.push(d);
-        } catch (e) {}
-    });
-
-    return (plugin);
-}
-
-
 /**
  * Returns the current semver version stored in CloudAPI's package.json.
  * This is used to set in the API versioning and in the Server header.
@@ -286,100 +261,6 @@ function createClients(options, callback) {
 }
 
 
-/**
- * Load enabled preprovision|postprovision|preaddnic|prelistnetworks plugins
- *
- * @param {Array} where each member is an {Object} representing a plugin config
- * @param {Array} ufdsPlugins is the same but coming from UFDS instead of
- *      the config file.
- * @returns {Object} with first member being preProvision methods to call,
- *          second member postProvision, third preAddNic, and fourth
- *          preListNetworks
- */
-
-function loadPlugins(plugins, ufdsPlugins, log) {
-    assert.ok(plugins);
-    // Load enabled pre|post provision plugins:
-    var preProvision = [];
-    var postProvision = [];
-    var preAddNic = [];
-    var preListNetworks = [];
-
-    // Plugins can be defined into Config file (plugins), UFDS (ufdsPlugins)
-    // or both. UFDS will take precedence over the config file. Therefore, we
-    // are gonna loop over ufdsPlugins and either append or override the
-    // required plugins we obtained from the config file:
-    ufdsPlugins.forEach(function (pl) {
-        // If the plugin is already loaded from config, override with value
-        // from UFDS
-        plugins = plugins.map(function (plugin) {
-            return ((plugin.name === pl.name) ? pl : plugin);
-        });
-    });
-
-    // If the plugin is not loaded from config file, just add it:
-    ufdsPlugins.forEach(function (pl) {
-        if (!plugins.some(function (plugin) {
-            return (plugin.name === pl.name);
-        })) {
-            plugins.push(pl);
-        }
-    });
-
-    plugins.forEach(function (pluginInfo) {
-        if (pluginInfo.enabled) {
-            log.info('Loading plugin: %s', pluginInfo.name);
-
-            var cfg = pluginInfo.config;
-            var pPath = path.resolve(__dirname, '../plugins', pluginInfo.name);
-            var plugin = require(pPath);
-
-            if (plugin.preProvision) {
-                preProvision.push(plugin.preProvision(cfg));
-            }
-
-            if (plugin.postProvision) {
-                postProvision.push(plugin.postProvision(cfg));
-            }
-
-            if (plugin.preAddNic) {
-                preAddNic.push(plugin.preAddNic(cfg));
-            }
-
-            if (plugin.preListNetworks) {
-                preListNetworks.push(plugin.preListNetworks(cfg));
-            }
-        }
-    });
-
-    return {
-        preProvision: preProvision,
-        postProvision: postProvision,
-        preAddNic: preAddNic,
-        preListNetworks: preListNetworks
-    };
-}
-
-
-function loadPluginsCfg(ufds, log, cb) {
-    function lookup() {
-        ufds.search('ou=config, o=smartdc', {
-            scope: 'one',
-            filter: '(objectclass=config)'
-        }, function (err, configs) {
-            if (err) {
-                log.error({err: err}, 'Cannot load plugins config. Retry...');
-                return setTimeout(lookup, MORAY_POLL);
-            }
-
-            return cb(null, configs);
-        });
-    }
-
-    lookup();
-}
-
-
 // --- API
 
 module.exports = {
@@ -452,322 +333,307 @@ module.exports = {
                 });
             }
 
-            loadPluginsCfg(clients.ufds, log, function (pErr, pluginsCfg) {
-                if (pErr) {
-                    throw pErr;
+            server = restify.createServer(config);
+
+            server.use(restify.acceptParser(server.acceptable));
+            server.use(authorizationParser());
+            server.use(restify.dateParser());
+            server.use(restify.requestLogger());
+            server.use(restify.queryParser({
+                allowDots: false,
+                plainObjects: false
+            }));
+            server.use(restify.bodyParser({
+                overrideParams: true,
+                mapParams: true,
+                maxBodySize: 100000
+            }));
+            server.use(restify.fullResponse());
+
+            server.use(function xForwardedFor(req, res, next) {
+                // Stolen from muskie!:
+                // This will only be null on the _first_ request, and in
+                // that instance, we're guaranteed that HAProxy sent us
+                // an X-Forwarded-For header
+
+                var conn = req.connection;
+                if (!conn._xff) {
+                    // Clean up clientip if IPv6
+                    var xff = req.headers['x-forwarded-for'];
+                    if (xff) {
+                        /* JSSTYLED */
+                        xff = xff.split(/\s*,\s*/).pop() || '';
+                        xff = xff.replace(/^(f|:)+/, '');
+                        conn._xff = xff;
+                    } else {
+                        conn._xff = conn.remoteAddress;
+                    }
                 }
+                return next();
+            });
+
+            // docs handler here has to run before auth stuff
+            docs.mount(server);
+
+            var plugins = new PluginManager({
+                log: log,
+                config: config,
+                clients: clients
+            });
 
-                pluginsCfg = pluginsCfg.map(translatePlugin);
+            server.use(function setupSDCProxies(req, res, next) {
+                req.config = config;
+                req.config.apertureConfig = apertureConfig;
+                req.sdc = clients;
+                req.plugins = plugins;
+                return next();
+            });
 
-                var plugins =  [];
-                if (typeof (config.plugins) !== 'undefined' &&
-                        Array.isArray(config.plugins)) {
-                    plugins = loadPlugins(config.plugins, pluginsCfg, log);
+            // Account management feature, added at version 7.2.0,
+            // requires both, the proper req.version and a configured
+            // mahi instance. Additionally, it'll require the feature
+            // added to bleeding_edge_features until it's out of beta:
+            server.use(function accountMgmt(req, res, next) {
+                var v = req.getVersion();
+                if (req.sdc.mahi &&
+                    (semver.satisfies('7.2.0', v) ||
+                    semver.ltr('7.2.0', v))) {
+                    req.accountMgmt = true;
                 }
+                return next();
+            });
 
-                server = restify.createServer(config);
-
-                server.use(restify.acceptParser(server.acceptable));
-                server.use(authorizationParser());
-                server.use(restify.dateParser());
-                server.use(restify.requestLogger());
-                server.use(restify.queryParser({
-                    allowDots: false,
-                    plainObjects: false
-                }));
-                server.use(restify.bodyParser({
-                    overrideParams: true,
-                    mapParams: true,
-                    maxBodySize: 100000
-                }));
-                server.use(restify.fullResponse());
-
-                server.use(function xForwardedFor(req, res, next) {
-                    // Stolen from muskie!:
-                    // This will only be null on the _first_ request, and in
-                    // that instance, we're guaranteed that HAProxy sent us
-                    // an X-Forwarded-For header
-                    if (!req.connection._xff) {
-                        // Clean up clientip if IPv6
-                        var xff = req.headers['x-forwarded-for'];
-                        if (xff) {
-                            /* JSSTYLED */
-                            xff = xff.split(/\s*,\s*/).pop() || '';
-                            xff = xff.replace(/^(f|:)+/, '');
-                            req.connection._xff = xff;
-                        } else {
-                            req.connection._xff =
-                                req.connection.remoteAddress;
-                        }
+            // Run authentication and authorization before everything else
+            server.use(auth.signatureAuth);
+            server.use(auth.tokenAuth);
+            server.use(auth.assertAuthenticated);
+            server.use(auth.loadAccount);
+            if (config.account_allowed_dcs) {
+                server.use(auth.authnAllowedDcs);
+            }
+
+            server.use(resources.resourceName);
+
+            server.use(datasets.loadDatasets);
+            server.use(packages.loadPackages);
+            server.use(networkMiddleware.loadNetworks);
+            server.use(machines.loadMachine);
+
+            server.use(resources.loadResource);
+
+            // req.routename will be used to GRANT/DENY access using
+            // policies rules. It must be called before auth.authorize.
+            server.use(function reqRoutename(req, res, next) {
+                var resourceTagRoutes = [
+                    'replaceaccountroletags',
+                    'replaceresourcesroletags',
+                    'replaceanalyticsresourcesroletags',
+                    'replaceuserkeysresourcesroletags',
+                    'replaceresourceroletags',
+                    'replacemachineroletags',
+                    'replaceanalyticsresourceroletags',
+                    'replaceuserkeysresourceroletags'
+                ];
+
+                if (req.route.name !== 'updatemachine') {
+                    if (resourceTagRoutes.indexOf(req.route.name) !== -1) {
+                        req.routename = 'setroletags';
+                    } else {
+                        req.routename = req.route.name;
                     }
-                    return next();
-                });
+                } else {
+                    switch (req.params.action) {
+                    case 'enable_firewall':
+                        req.routename = 'enablemachinefirewall';
+                        break;
+                    case 'disable_firewall':
+                        req.routename = 'disablemachinefirewall';
+                        break;
+                    default:
+                        req.routename = req.params.action + 'machine';
+                        break;
+                    }
+                }
+                return next();
+            });
 
-                // docs handler here has to run before auth stuff
-                docs.mount(server);
+            server.use(auth.authorize);
 
-                server.use(function setupSDCProxies(req, res, next) {
-                    req.config = config;
-                    req.config.apertureConfig = apertureConfig;
-                    req.sdc = clients;
-                    return next();
-                });
+            server.use(function readOnlyMode(req, res, next) {
+                var mthd = req.method;
+
+                if ((mthd === 'PUT' || mthd === 'POST' || mthd === 'DELETE') &&
+                    req.config.read_only === true) {
 
-                // Account management feature, added at version 7.2.0,
-                // requires both, the proper req.version and a configured
-                // mahi instance. Additionally, it'll require the feature
-                // added to bleeding_edge_features until it's out of beta:
-                server.use(function accountMgmt(req, res, next) {
-                    var v = req.getVersion();
-                    if (req.sdc.mahi &&
-                        (semver.satisfies('7.2.0', v) ||
-                        semver.ltr('7.2.0', v))) {
-                        req.accountMgmt = true;
+                    if (req.config.dcMaintUtcEta) {
+                        res.setHeader('Retry-After', req.config.dcMaintUtcEta);
                     }
-                    return next();
-                });
 
-                // Run authentication and authorization before everything else
-                server.use(auth.signatureAuth);
-                server.use(auth.tokenAuth);
-                server.use(auth.assertAuthenticated);
-                server.use(auth.loadAccount);
-                if (config.account_allowed_dcs) {
-                    server.use(auth.authnAllowedDcs);
+                    var msg = req.config.dc_maint_message ||
+                        'This Triton data center is being upgraded';
+
+                    return next(new restify.ServiceUnavailableError(msg));
                 }
 
-                server.use(resources.resourceName);
-
-                server.use(datasets.loadDatasets);
-                server.use(packages.loadPackages);
-                server.use(networkMiddleware.loadNetworks);
-                server.use(machines.loadMachine);
-
-                server.use(resources.loadResource);
-
-                // req.routename will be used to GRANT/DENY access using
-                // policies rules. It must be called before auth.authorize.
-                server.use(function reqRoutename(req, res, next) {
-                    var resourceTagRoutes = [
-                        'replaceaccountroletags',
-                        'replaceresourcesroletags',
-                        'replaceanalyticsresourcesroletags',
-                        'replaceuserkeysresourcesroletags',
-                        'replaceresourceroletags',
-                        'replacemachineroletags',
-                        'replaceanalyticsresourceroletags',
-                        'replaceuserkeysresourceroletags'
-                    ];
-
-                    if (req.route.name !== 'updatemachine') {
-                        if (resourceTagRoutes.indexOf(req.route.name) !== -1) {
-                            req.routename = 'setroletags';
-                        } else {
-                            req.routename = req.route.name;
-                        }
-                    } else {
-                        switch (req.params.action) {
-                        case 'enable_firewall':
-                            req.routename = 'enablemachinefirewall';
-                            break;
-                        case 'disable_firewall':
-                            req.routename = 'disablemachinefirewall';
-                            break;
-                        default:
-                            req.routename = req.params.action + 'machine';
-                            break;
-                        }
-                    }
-                    return next();
-                });
+                return next();
+            });
 
-                server.use(auth.authorize);
-
-                server.use(function readOnlyMode(req, res, next) {
-                    if ((req.method === 'PUT' ||
-                        req.method === 'POST' ||
-                        req.method === 'DELETE') &&
-                        typeof (req.config.read_only) !== 'undefined' &&
-                        req.config.read_only === true) {
-                        if (req.config.dcMaintUtcEta) {
-                            res.setHeader('Retry-After',
-                                    req.config.dcMaintUtcEta);
-                        }
-                        var msg = req.config.dc_maint_message ||
-                            'This Triton data center is being upgraded';
-
-                        return next(new restify.ServiceUnavailableError(msg));
-                    }
+            // Save Context for Machines Audit:
+            server.use(function saveContext(req, res, next) {
+                if (!/\/machines/.test(req.getUrl().pathname)) {
+                    return next();
+                }
 
+                if (req.method !== 'PUT' && req.method !== 'POST' &&
+                    req.method !== 'DELETE') {
                     return next();
-                });
+                }
 
-                // Save Context for Machines Audit:
-                server.use(function saveContext(req, res, next) {
-                    if (!/\/machines/.test(req.getUrl().pathname)) {
-                        return next();
-                    }
+                var authType = 'signature';
 
-                    if (req.method !== 'PUT' && req.method !== 'POST' &&
-                        req.method !== 'DELETE') {
-                        return next();
-                    }
+                if (req.authorization.scheme.toLowerCase() === 'basic') {
+                    authType = 'basic';
+                }
 
-                    var authType = 'signature';
+                if (typeof (req.headers['X-Auth-Token']) !== 'undefined') {
+                    authType = 'token';
+                }
 
-                    if (req.authorization.scheme.toLowerCase() === 'basic') {
-                        authType = 'basic';
-                    }
+                req._auditCtx = {
+                    type: authType,
+                    ip: req.connection.remoteAddress
+                };
 
-                    if (typeof (req.headers['X-Auth-Token']) !== 'undefined') {
-                        authType = 'token';
-                    }
+                if (authType === 'basic') {
+                    req._auditCtx.user = req.caller.login;
+                } else if (req.authorization.signature) {
+                    req._auditCtx.keyId =
+                        req.authorization.signature.keyId;
+                }
 
-                    req._auditCtx = {
-                        type: authType,
-                        ip: req.connection.remoteAddress
-                    };
+                return next();
+            });
 
-                    if (authType === 'basic') {
-                        req._auditCtx.user = req.caller.login;
-                    } else if (req.authorization.signature) {
-                        req._auditCtx.keyId =
-                            req.authorization.signature.keyId;
-                    }
+            // Now mount all the API handlers. Images, packages and networks are
+            // first:
+            datasets.mount(server, userThrottle(config, 'datasets'), config);
+            packages.mount(server, userThrottle(config, 'packages'));
+            networkEndpoints.mount(server, userThrottle(config, 'networks'));
+
+            // Wait for datasets and packages to mount everything else:
+            account.mount(server, userThrottle(config, 'account'));
+            datacenters.mount(server, userThrottle(config, 'datacenter'));
+            services.mount(server, userThrottle(config, 'services'));
+            keys.mount(server, userThrottle(config, 'keys'), config);
+
+            machineThrottle = userThrottle(config, 'machines');
+            machines.mount(server, machineThrottle);
+            metadata.mount(server, machineThrottle);
+            snapshots.mount(server, machineThrottle);
+            tags.mount(server, machineThrottle);
+            audit.mount(server, machineThrottle);
+            rules.mount(server, machineThrottle);
+
+            analytics.mount(server, userThrottle(config, 'analytics'));
+            users.mount(server, userThrottle(config, 'users'), config);
+            policies.mount(server, userThrottle(config, 'policies'), config);
+            roles.mount(server, userThrottle(config, 'roles'), config);
+            nics.mount(server, userThrottle(config, 'nics'));
+            configEndpoints.mount(server, userThrottle(config, 'config'));
+            resources.mount(server, userThrottle(config, 'resources'), config);
+
+            if (config.experimental_cloudapi_nfs_shared_volumes === true) {
+                volumeEndpoints.mount(server, userThrottle(config, 'volumes'));
+            }
 
-                    return next();
-                });
+            if (config.test) {
+                tests.mount(server, emptyThrottle(), config);
+            }
+
+            server.on('after', auditLogger({
+                log: log.child({component: 'audit'})
+            }));
 
-                // Now mount all the API handlers. Images, packages and
-                // networks are first:
-                datasets.mount(server,
-                        userThrottle(config, 'datasets'), config);
-                packages.mount(server, userThrottle(config, 'packages'));
-                networkEndpoints.mount(server, userThrottle(config, 'networks'),
-                        plugins.preListNetworks);
-
-                // Wait for datasets and packages to mount everything else:
-                account.mount(server, userThrottle(config, 'account'));
-                datacenters.mount(server, userThrottle(config, 'datacenter'));
-                services.mount(server, userThrottle(config, 'services'));
-                keys.mount(server, userThrottle(config, 'keys'), config);
-
-                machineThrottle = userThrottle(config, 'machines');
-                // Make sure we pass the pre|post provision hooks
-                // from the plugins
-                machines.mount(server, machineThrottle, plugins.preProvision,
-                        plugins.postProvision);
-                metadata.mount(server, machineThrottle);
-                snapshots.mount(server, machineThrottle);
-                tags.mount(server, machineThrottle);
-                audit.mount(server, machineThrottle);
-                rules.mount(server, machineThrottle);
-
-                analytics.mount(server, userThrottle(config, 'analytics'));
-                users.mount(server, userThrottle(config, 'users'), config);
-                policies.mount(server, userThrottle(config, 'policies'),
-                        config);
-                roles.mount(server, userThrottle(config, 'roles'), config);
-                nics.mount(server, userThrottle(config, 'nics'),
-                        plugins.preAddNic);
-                configEndpoints.mount(server, userThrottle(config, 'config'));
-                resources.mount(server, userThrottle(config, 'resources'),
-                        config);
-
-                if (config.experimental_cloudapi_nfs_shared_volumes === true) {
-                    volumeEndpoints.mount(server,
-                        userThrottle(config, 'volumes'));
+            // Closure to wrap up the port setting
+            server.start = function start(cb) {
+                if (config.read_only === true) {
+                    log.warn('Starting Cloud API on read only mode.');
+                }
+                return server.listen(config.port, cb);
+            };
+
+            // Setup a logger on HTTP Agent queueing
+            globalAgentInterval = setInterval(function () {
+                var httpReqs = http.globalAgent.requests;
+                if (httpReqs && httpReqs.length > 0) {
+                    log.warn('http.globalAgent queueing, depth=%d',
+                        httpReqs.length);
                 }
 
-                if (config.test) {
-                    tests.mount(server, emptyThrottle(), config);
+                var httpsReqs = https.globalAgent.requests;
+                if (httpsReqs && httpsReqs.length > 0) {
+                    log.warn('https.globalAgent queueing, depth=%d',
+                                httpsReqs.length);
                 }
+            }, 1000);
 
-                server.on('after', auditLogger({
-                    log: log.child({component: 'audit'})
-                }));
+            // If we make JSON main format, res.send(error) will send our
+            // Restify formatted error objects, and properly hide the v8
+            // backtrace.
+            server.acceptable.unshift('application/json');
 
-                // Closure to wrap up the port setting
-                server.start = function start(cb) {
-                    if (config.read_only === true) {
-                        log.warn('Starting Cloud API on read only mode.');
-                    }
-                    return server.listen(config.port, cb);
-                };
+            server.on('close', function () {
+                clearInterval(globalAgentInterval);
 
-                // Setup a logger on HTTP Agent queueing
-                globalAgentInterval = setInterval(function () {
-                    var agent = http.globalAgent;
-                    if (agent.requests && agent.requests.length > 0) {
-                        log.warn('http.globalAgent queueing, depth=%d',
-                                    agent.requests.length);
-                    }
-
-                    agent = https.globalAgent;
-                    if (agent.requests && agent.requests.length > 0) {
-                        log.warn('https.globalAgent queueing, depth=%d',
-                                    agent.requests.length);
-                    }
-                }, 1000);
+                kangServer.close();
 
-                // If we make JSON main format, res.send(error) will send our
-                // Restify formatted error objects, and properly hide the v8
-                // backtrace.
-                server.acceptable.unshift('application/json');
+                clients.vmapi.close();
+                clients.napi.close();
+                clients.fwapi.close();
+                clients.imgapi.close();
+                clients.ca.close();
+                clients.papi.close();
+                clients.cnapi.close();
 
-                server.on('close', function () {
-                    clearInterval(globalAgentInterval);
+                if (clients.mahi) {
+                    clients.mahi.close();
+                }
 
-                    kangServer.close();
+                if (clients.cns) {
+                    clients.cns.close();
+                }
 
-                    clients.vmapi.close();
-                    clients.napi.close();
-                    clients.fwapi.close();
-                    clients.imgapi.close();
-                    clients.ca.close();
-                    clients.papi.close();
-                    clients.cnapi.close();
+                if (clients.volapi) {
+                    clients.volapi.close();
+                }
 
-                    if (clients.mahi) {
-                        clients.mahi.close();
-                    }
+                process._getActiveHandles().forEach(function (h) {
+                    return h.unref && h.unref();
+                });
 
-                    if (clients.cns) {
-                        clients.cns.close();
+                clients.ufds.close(function (err) {
+                    if (err) {
+                        throw err;
                     }
 
-                    if (clients.volapi) {
-                        clients.volapi.close();
+                    if (!clients.ufds_master.closed) {
+                        clients.ufds_master.close(function (err2) {
+                            if (err2) {
+                                throw err2;
+                            }
+                        });
                     }
-
-                    process._getActiveHandles().forEach(function (h) {
-                        return h.unref && h.unref();
-                    });
-
-                    clients.ufds.close(function (err) {
-                        if (err) {
-                            throw err;
-                        }
-
-                        if (!clients.ufds_master.closed) {
-                            clients.ufds_master.close(function (err2) {
-                                if (err2) {
-                                    throw err2;
-                                }
-                            });
-                        }
-                    });
-                });
-
-                server.on('uncaughtException', function (req, res, route, err) {
-                    var e = new restify.InternalError('Internal Error');
-                    req.log.error(err, 'unexpected error');
-                    res.send(e);
                 });
+            });
 
-                server._clients = clients;
-                return callback(null, server);
+            server.on('uncaughtException', function (req, res, route, err) {
+                var e = new restify.InternalError('Internal Error');
+                req.log.error(err, 'unexpected error');
+                res.send(e);
             });
+
+            server._clients = clients;
+            return callback(null, server);
         });
     }
 };
diff --git a/lib/machines.js b/lib/machines.js
index 0c820c0..c217bbd 100644
--- a/lib/machines.js
+++ b/lib/machines.js
@@ -1339,6 +1339,18 @@ function create(req, res, next) {
 
     var pipeline = [];
 
+    // Since this is roughly the poimt where all the cheap checks are completed,
+    // this is where we invoke any allowProvision plugins
+    pipeline.push(function callAllowProvisionPlugins(_, cb) {
+        req.plugins.allowProvision({
+            account: req.account,
+            image: req.dataset,
+            pkg: req.pkg,
+            req_id: req.getId()
+        }, cb);
+    });
+
+
     /*
      * Translate any given `affinity` rules into "locality hints" that
      * sdc-designation (aka DAPI) currently understands. Eventually it is
@@ -1518,6 +1530,8 @@ function create(req, res, next) {
     }
 
 
+    var createdMachine;
+
     pipeline.push(function (_, cb) {
         return req.sdc.vmapi.createVm(opts, {
             log: req.log,
@@ -1580,9 +1594,7 @@ function create(req, res, next) {
                         req.datasets = [req.dataset];
                     }
                     machine = translate(machine, req);
-                    // Cache machine as a res member, so it can be used from
-                    // postProvision plugins.
-                    res.machine = machine;
+                    createdMachine = machine;
                     res.header('Location', sprintf(
                             '/%s/machines/%s', login, machine.id));
                     log.debug('GetMachine(/%s/%s) => %j',
@@ -1595,6 +1607,15 @@ function create(req, res, next) {
 
     });
 
+
+    pipeline.push(function callPostProvisionPlugins(_, cb) {
+        req.plugins.postProvision({
+            account: req.account,
+            instance: createdMachine,
+            req_id: req.getId()
+        }, cb);
+    });
+
     return vasync.pipeline({
         funcs: pipeline
     }, function (err, results) {
diff --git a/lib/middleware/networks.js b/lib/middleware/networks.js
index 10bee58..4268d38 100644
--- a/lib/middleware/networks.js
+++ b/lib/middleware/networks.js
@@ -62,6 +62,7 @@ function loadNetworks(req, res, next) {
             return next(err);
         }
 
+        var plugins = req.plugins;
         var networks = [];
         var externalNetworks = [];
         var internalNetworks = [];
@@ -72,6 +73,8 @@ function loadNetworks(req, res, next) {
             return (pool.nic_tag !== modNetworks.ADMIN_NIC_TAG);
         });
 
+        pools = plugins.filterListNetworks({ account: req.account }, pools);
+
         pools.forEach(function (pool) {
             var isFabric = false;
             networks.push(pool);
@@ -105,6 +108,8 @@ function loadNetworks(req, res, next) {
                     !networksInPools[net.uuid];
             });
 
+            nets = plugins.filterListNetworks({ account: req.account }, nets);
+
             networks = networks.concat(nets);
 
             networks.forEach(function (net) {
@@ -138,4 +143,4 @@ function loadNetworks(req, res, next) {
 
 module.exports = {
     loadNetworks: loadNetworks
-};
\ No newline at end of file
+};
diff --git a/lib/nics.js b/lib/nics.js
index e740a12..a9a2c72 100644
--- a/lib/nics.js
+++ b/lib/nics.js
@@ -197,7 +197,9 @@ function addNic(req, res, next) {
                 return cb(new InvalidArgumentError('network not found'));
             }
 
-            network = networkPool;
+            network = req.plugins.filterListNetworks({
+                account: req.account
+            }, [networkPool]).pop();
 
             return cb();
         });
@@ -222,7 +224,10 @@ function addNic(req, res, next) {
                 }
             }
 
-            network = _network;
+            network = req.plugins.filterListNetworks({
+                account: req.account
+            }, [_network]).pop();
+
             log.debug(network, 'Network retrieved from NAPI');
 
             return cb();
diff --git a/lib/plugin-manager.js b/lib/plugin-manager.js
new file mode 100644
index 0000000..e78324e
--- /dev/null
+++ b/lib/plugin-manager.js
@@ -0,0 +1,336 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * sdc-cloudapi plugin API and manager. It is compatible with sdc-docker's
+ * plugin API. Any changes made here must have their equivalents in sdc-docker's
+ * plugin manager.
+ *
+ * This file loads all enabled plugins listed in app.config.plugins, if any.
+ * For each plugin, this class attempts to load a fixed set of supported named
+ * functions (hooks); unrecognized hooks cause an exception.
+ *
+ * Plugin hooks are given a formal API by the plugin manager, through which
+ * the plugins can interact with sdc-cloudapi.
+ *
+ * Plugins are configured by adding the following to CLOUDAPI_PLUGINS in sapi:
+ *
+ * {
+ *    "name": "<name of plugin>",
+ *    "enabled": true,
+ *    "config":{
+ *        <this is specific to each plugin>
+ *    }
+ * }
+ *
+ * The above object is added to the plugin array, then serialized to JSON and
+ * used to replace DOCKER_PLUGINS and CLOUDAPI_PLUGINS. E.g.:
+ *
+ * sdc-sapi /services/$(sdc-sapi /services?name=cloudapi | json -Ha uuid) \
+ * -X PUT -d '
+ * {
+ *     "metadata": {
+ *         "CLOUDAPI_PLUGINS": "[{\"name\":\"...\", \
+ *         \"enabled\":true,\"config\":{ ... }}]"
+ *      }
+ * }
+ * '
+ */
+
+var assert = require('assert-plus');
+var fs = require('fs');
+var jsprim = require('jsprim');
+var path = require('path');
+var restify = require('restify');
+var vasync = require('vasync');
+
+
+var ADMIN_NIC_TAG = 'admin';
+
+
+var PluginManager = module.exports =
+function init(app) {
+    var self = this;
+
+    assert.object(app, 'app');
+    assert.object(app.log, 'app.log');
+    assert.object(app.clients, 'app.clients');
+    assert.object(app.config, 'app.config');
+
+    // if we don't have a wrapper function in this class, we don't support
+    // the import of functions with the same name from a plugin
+    var supportedPluginHooks = Object.keys(PluginManager.prototype);
+
+    self.hooks = {};
+    supportedPluginHooks.forEach(function addPluginArray(apiName) {
+        self.hooks[apiName] = [];
+    });
+
+    var cfg = app.config.plugins;
+    if (cfg === undefined) {
+        return;
+    }
+    assert.arrayOfObject(cfg, 'cfg');
+
+    var clients = app.clients;
+
+    // This is the API of functions that sdc-docker and cloudapi make available
+    // for use to the plugins they import.
+    self.api = {
+        log: app.log,
+        datacenterName: app.config.datacenter_name,
+        service: 'cloudapi',
+        NotAuthorizedError: restify.NotAuthorizedError,  // XXX make child
+        getNapiNetworksForAccount: function getNapiShim(obj, cb) {
+            assert.object(obj, 'obj');
+            assert.object(obj.account, 'obj.account');
+            assert.uuid(obj.req_id, 'obj.req_id');
+            assert.func(cb, 'cb');
+
+            var opts = { provisionable_by: obj.account.uuid };
+            var reqOpts = { headers: {'x-request-id': obj.req_id } };
+
+            clients.napi.listNetworkPools(opts, reqOpts,
+                function listNetworkPoolsCb(err, pools) {
+
+                if (err) {
+                    return cb(err);
+                }
+
+                var networks = [];
+                var networksInPools = {};
+
+                pools = pools.filter(function (pool) {
+                    return (pool.nic_tag !== ADMIN_NIC_TAG);
+                });
+
+                pools.forEach(function addNets(pool) {
+                    networks.push(pool);
+                    pool.networks.forEach(function (networkUuid) {
+                        networksInPools[networkUuid] = true;
+                    });
+                });
+
+                return clients.napi.listNetworks(opts, reqOpts,
+                    function listNetworksCb(err2, nets) {
+
+                    if (err2) {
+                        return cb(err2);
+                    }
+
+                    nets = nets.filter(function (net) {
+                        return net.nic_tag !== ADMIN_NIC_TAG &&
+                            !networksInPools[net.uuid];
+                    });
+
+                    return cb(null, networks.concat(nets));
+                });
+            });
+        },
+        getActiveVmsForAccount: function getActiveVmsShim(opts, cb) {
+            assert.object(opts, 'opts');
+            assert.object(opts.account, 'opts.account');
+            assert.optionalString(opts.brand, 'opts.brand');
+            assert.optionalString(opts.fields, 'opts.fields');
+            assert.uuid(opts.req_id, 'opts.req_id');
+            assert.func(cb, 'cb');
+
+            var args = {
+                owner_uuid: opts.account.uuid,
+                state: 'active'
+            };
+
+            if (opts.brand) {
+                args.brand = opts.brand;
+            }
+
+            if (opts.fields) {
+                args.fields = opts.fields;
+            }
+
+            var reqOpts = { headers: {'x-request-id': opts.req_id } };
+
+            clients.vmapi.listVms(args, reqOpts, cb);
+        },
+        getImage: function getImageShim(imgUuid, cb) {
+            assert.uuid(imgUuid, 'imgUuid');
+            assert.func(cb, 'cb');
+
+            clients.imgapi.getImage(imgUuid, cb);
+        },
+        listImages: function listImageShim(opts, cb) {
+            assert.object(opts, 'opts');
+            assert.uuid(opts.req_id, 'opts.req_id');
+            assert.func(cb, 'cb');
+
+            var reqOpts = { headers: {'x-request-id': opts.req_id } };
+            opts.req_id = undefined;
+
+            clients.imgapi.listImages(opts, reqOpts, cb);
+        }
+    };
+
+    cfg.forEach(function loadPlugin(description) {
+        assert.object(description, 'description');
+        assert.string(description.name, 'description.name');
+
+        if (!description.enabled) {
+            return;
+        }
+
+        app.log.info('Loading plugin: %s', description.name);
+
+        var pluginCfg = description.config;
+        var pPath = path.resolve(__dirname, '../plugins', description.name);
+        var plugin = require(pPath);
+
+        Object.keys(plugin).forEach(function (apiName) {
+            // Allow a plugin to export names that are not a known plugin
+            // function by prefixing with an underscore. This is used for
+            // testing.
+            if (apiName[0] === '_') {
+                return;
+            }
+
+            assert.notEqual(supportedPluginHooks.indexOf(apiName), -1,
+                'supportedPluginFunctions[apiName]');
+
+            var initedPlugin = plugin[apiName](self.api, pluginCfg);
+            self.hooks[apiName].push(initedPlugin);
+        });
+    });
+};
+
+
+/*
+ * This hooks into backends/sdc/networks.js, listNetworks(). It runs
+ * runs after sdc-docker has retrieved an array from napi, but before
+ * backends/sdc/networks.js returns the results any higher up the stack.
+ *
+ * For cloudapi, it hooks into middleware/networks.js, but otherwise behaves
+ * the same. Specifically, it affects req.networks/internal_networks/
+ * external_networks.
+ */
+PluginManager.prototype.filterListNetworks =
+function filterListNetworks(opts, networks) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.array(networks, 'networks');
+
+    this.hooks.filterListNetworks.forEach(function runPlugin(plugin) {
+        networks = plugin(opts, networks);
+    });
+
+    return networks;
+};
+
+
+/*
+ * This hooks into backends/sdc/networks.js, getNetworksOrPools(). That
+ * function is used several places in network.js, and is exported as well.
+ */
+PluginManager.prototype.filterGetNetworksOrPools =
+function filterGetNetworksOrPools(opts, networks) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.array(networks, 'networks');
+
+    this.hooks.filterGetNetworksOrPools.forEach(function runPlugin(plugin) {
+        networks = plugin(opts, networks);
+    });
+
+    return networks;
+};
+
+
+/*
+ * This hook is run when creating a container, before assigning
+ * a default external network to that container. The default network
+ * may not belong to the account creating the container, then this
+ * gets invoked.
+ */
+PluginManager.prototype.findOwnerExternalNetwork =
+function findOwnerExternalNetwork(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.uuid(opts.req_id, 'opts.req_id');
+    assert.func(cb, 'cb');
+
+    var hooks = this.hooks.findOwnerExternalNetwork;
+
+    // Runs every plugin (if any) until a plugin succeeds (doesn't return an
+    // error). If that plugin returned a network, use that network for the
+    // external instead of the default overlay.externalPool.
+    vasync.tryEach(hooks.map(function (p) {
+        return p.bind(null, opts);
+    }), cb);
+};
+
+
+/*
+ * This hook is run before the creation of a contain is initiated. It checks
+ * that various preconditions have been fulfilled before allowing the creation
+ * to proceed further.
+ */
+PluginManager.prototype.allowProvision =
+function allowProvision(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.image, 'opts.image');
+    assert.object(opts.pkg, 'opts.pkg');
+    assert.uuid(opts.req_id, 'opts.req_id');
+    assert.func(cb, 'cb');
+
+    var hooks = this.hooks.allowProvision;
+    var funcs = hooks.map(function wrapFunc(func) {
+        return function (_, next) {
+            func(opts, next);
+        };
+    });
+
+    // Runs every plugin (if any) until a plugin fails. Any failure indicates
+    // that the provision should not be allowed.
+    vasync.pipeline({ funcs: funcs }, function (err, results) {
+        cb(err);
+    });
+};
+
+
+/*
+ * This hook is run after the creation of a container. It performs no checks,
+ * and returns no error, since the provision is already made.
+ */
+PluginManager.prototype.postProvision =
+function postProvision(opts, cb) {
+    assert.object(opts, 'opts');
+    assert.object(opts.account, 'opts.account');
+    assert.object(opts.instance, 'opts.instance');
+    assert.uuid(opts.req_id, 'opts.req_id');
+    assert.func(cb, 'cb');
+
+    var hooks = this.hooks.postProvision;
+    var funcs = hooks.map(function wrapFunc(func) {
+        return function (_, next) {
+            func(opts, next);
+        };
+    });
+
+    // Runs every plugin (if any).
+    function callfuncs() {
+        if (funcs.length === 0) {
+            return cb();
+        }
+
+        var func = funcs.pop();
+        return func(opts, callfuncs);
+    }
+
+    callfuncs();
+};
diff --git a/package.json b/package.json
index 11ad5a3..56acd90 100644
--- a/package.json
+++ b/package.json
@@ -13,7 +13,7 @@
         "url": "git+ssh://git@github.com:joyent/sdc-cloudapi.git"
     },
     "dependencies": {
-        "vasync": "1.6.4",
+        "vasync": "2.2.0",
         "filed": "0.0.7",
         "http-signature": "1.1.0",
         "mime": "1.2.7",
@@ -27,7 +27,7 @@
         "sdc-clients": "10.4.0",
         "ufds": "1.3.0",
         "semver": "5.4.1",
-        "nodemailer": "0.3.29",
+        "nodemailer": "0.7.1",
         "clone": "0.1.5",
         "assert-plus": "1.0.0",
         "asn1": "0.1.11",
diff --git a/plugins/capi_limits.js b/plugins/capi_limits.js
deleted file mode 100644
index d82afd2..0000000
--- a/plugins/capi_limits.js
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-var assert = require('assert');
-var util = require('util');
-var restify = require('restify');
-
-
-// --- Globals
-
-var CODE = 'QuotaExceeded';
-var MESSAGE = 'To have your limits raised please contact Support.';
-
-
-module.exports = {
-    preProvision: function (cfg) {
-
-        if (!cfg || typeof (cfg) !== 'object') {
-            throw new TypeError('cfg (object) is required');
-        }
-
-        if (!cfg.datacenter) {
-            throw new TypeError('cfg.datacenter is required');
-        }
-
-        if (!cfg.defaults || typeof (cfg.defaults) !== 'object') {
-            throw new TypeError('cfg.defaults (object) is required');
-        }
-
-        return function capiLimits(req, res, next) {
-            // Do nothing if we are not provisioning:
-            if (!(/\/machines$/.test(req.url) &&
-                        req.method.toUpperCase() === 'POST')) {
-                return next();
-            }
-
-            assert.ok(req.account);
-
-            var log = req.log;
-
-            if (req.account.isAdmin()) {
-                log.debug('capi_limits: account %s is an admin, allowing.',
-                    req.account.login);
-                return next();
-            }
-
-            if (!req.dataset) {
-                log.debug('capi_limits: no dataset on req; skipping checks.');
-                return next();
-            }
-
-            return req.account.listLimits(function (err, limits) {
-                if (err) {
-                    log.error({err: err},
-                        'capi_limits: unable to list limits.');
-                    return next(new restify.InternalError(
-                            'capi_limits: unable to list limits.'));
-                }
-
-                if (!limits) {
-                    limits = [];
-                }
-
-                var dsname = req.dataset.name.toLowerCase();
-
-                req.limits = limits;
-                req.limit = cfg.defaults[dsname] || 2;
-                var i;
-                for (i = 0; i < limits.length; i++) {
-                    if (limits[i].datacenter !== cfg.datacenter) {
-                        continue;
-                    }
-
-                    if (limits[i][dsname]) {
-                        req.limit = parseInt(limits[i][dsname], 10);
-                        break;
-                    }
-                }
-
-                log.info({
-                    dataset: req.dataset.name,
-                    limit: req.limit,
-                    owner_uuid: req.account.uuid,
-                    params: req.params,
-                    limits: req.limits
-                }, 'capi_limits: dataset limits');
-
-                if (req.limit < 0) {
-                    return next(new restify.NotAuthorizedError(
-                                util.format('%s: %s', CODE, MESSAGE)));
-                }
-
-                if (req.limit === 0) {
-                    log.debug('capi_limits: unlimited quota.');
-                    return next();
-                }
-
-                // Note we have no way right now to filter customer machines
-                // by dataset name, since that's not added at all to our VMs
-                // representation on VMAPI, neither to vmadm itself.
-                // In order to get a reasonably good filter, we need to query
-                // IMGAPI for all the machines with a given name, then build a
-                // VMAPI query including all those images UUIDs into an LDAP
-                // search filter.
-                return req.sdc.imgapi.listImages({
-                    name: req.dataset.name,
-                    state: 'all'
-                }, function (err2, images, r) {
-                    if (err2) {
-                        log.error({err: err2},
-                            'capi_limits: unable to list Images');
-                    }
-
-                    if (!images) {
-                        log.info('No images found with name ' +
-                            req.dataset.name);
-                        return next();
-                    }
-
-                    var filter = '(&(owner_uuid=' + req.account.uuid +
-                            ')(&(!(state=destroyed))(!(state=failed)))(|(' +
-                    images.map(function (img) {
-                        return ('image_uuid=' + img.uuid);
-                    }).join(')(') + ')))';
-
-
-                    log.debug({filter: filter}, 'VMAPI search machines filter');
-
-                    return req.sdc.vmapi.client.head({
-                        path: '/vms',
-                        query: {query: filter}
-                    }, function (err3, req3, res3) {
-                        if (err3) {
-                            log.error({err: err3},
-                                'capi_limits: unable to count VMs.');
-                            return next(new restify.InternalError(
-                                    'capi_limits: unable to count VMs.'));
-                        }
-
-                        var count = Number(
-                            res3.headers['x-joyent-resource-count']) || 0;
-
-                        log.debug('capi_limits: limit=%d, count=%d',
-                            req.limit, count);
-
-                        if (count >= req.limit) {
-                            return next(new restify.NotAuthorizedError(
-                                    util.format('%s: %s', CODE, MESSAGE)));
-                        }
-                        return next();
-
-                    });
-                });
-            });
-        };
-    }
-};
diff --git a/plugins/filter_owner_networks.js b/plugins/filter_owner_networks.js
index 4a949d1..d27456f 100644
--- a/plugins/filter_owner_networks.js
+++ b/plugins/filter_owner_networks.js
@@ -5,273 +5,152 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
  * Forces specific accounts to only use networks or network pools which belong
- * to that account. Specifically, it prevents creating VMs with anything other
- * than networks or pools belonging to that account, or adding NICs which can
- * access same. It also applies the same rules to the listing of networks (i.e.
- * GET /:account/networks) to reduce surprises to cloudapi clients.
+ * to that account. Specifically, it filters out networks and network pools in
+ * lib/middleware/networks.js (cloudapi) and lib/backends/sdc/networks.js
+ * (sdc-docker), which later prevents the listing of non-owner networks or
+ * pools, and prevent the creation of containers with those networks or pools
+ * too. It also hooks into lib/backends/sdc/container.js (sdc-docker) to
+ * override the default external network.
  *
  * Each network or pool has an optional array of UUIDs associated with users.
- * When adding a NIC to a VM, we check that the UUID of the current account
+ * When filtering networks, we check that the UUID of the current account
  * matches any of the UUIDs in the requested network or pool's owner_uuids
  * array. If not, it is rejected.
  *
- * Provisioning of a VM is similar in principle, with the complication of
- * package networks and default_networks. If a params.networks is provided, we
- * check that every one of those network or poolss contains the current
- * account's UUID in their owner_uuids array. If params.networks isn't provided,
- * we check whether all networks or pools listed by the package are owned by the
- * account. If the package * doesn't have any network or pools listed, then we
- * lastly move on to params.default_networks and fill in params.networks
- * ourselves, to disable cloudapi doing its own default filtering (which has
- * looser filtering, by allowing DC-shared non-owned network and pools to also
- * be used). For default_networks, we again only allow the use of external and
- * internal networks/pools that belong to the owner.
+ * To configure this plugin, add the UUIDs of the account that should be
+ * filtered:
  *
- * Note that non-owner_uuid networks which are members of a pool which includes
- * the account UUID in the pool's owner_uuids will be included. This code
- * assumes that if an account is included in a pool's owner_uuids, that all
- * network members of that pool are eligible for use.
+ * {
+ *    "name": "filter_owner_networks",
+ *    "enabled": true,
+ *    "config": {
+ *        "accounts": [ ... list of UUIDs here ... ],
+ *    }
+ * }
+ * This is added to CLOUDAPI_PLUGINS and DOCKER_PLUGINS, serialized to JSON,
+ * and PUT to cloudapi's and sdc-docker's sapi service. E.g.:
  *
- * One significant pitfall to be aware of is that this plugin partially
- * replicated some of cloudapi's behaviours, plus it depends on certain others.
- * Any major changes to these behaviours by cloudapi might either break this
- * plugin, or cause the plugin to hide newer changes to cloudapi.
+ * sdc-sapi /services/$(sdc-sapi /services?name=cloudapi | json -Ha uuid) -X PUT
+ * -d '{
+ *    "metadata": {
+ *         "CLOUDAPI_PLUGINS": "[{\"name\":\"filter_owner_networks\", \
+ *         \"enabled\": true, \"config\": {\"accounts\": \
+ *         [\"fb7f31ad-52d6-4e92-83d2-9f9d94ceef3f\"]}}]"
+ *    }
+ * }'
  */
 
-
 var assert = require('assert-plus');
-var restify = require('restify');
 
-var InvalidArgumentError = restify.InvalidArgumentError;
 
-// same as in lib/networks.js and lib/machines.js
 var EXTERNAL_NIC_TAG = 'external';
-var INTERNAL_NIC_TAG = 'internal';
-var DEFAULT_NETWORKS = [EXTERNAL_NIC_TAG, INTERNAL_NIC_TAG];
-
-
-/*
- * Return all networks which include ownerUuid inside their owner_uuids
- * attribute.
- */
-function getOwnedNetworks(networks, ownerUuid) {
-    assert.arrayOfObject(networks, 'networks');
-    assert.uuid(ownerUuid, 'ownerUuid');
-
-    return networks.filter(function filterOwner(network) {
-        var owners = network.owner_uuids;
-        return owners && owners.indexOf(ownerUuid) !== -1;
-    });
-}
-
-
-/*
- * Returns either external (has public IPs) or internal (has private or DC-only
- * IPs) networks, depending on netType arg. NB: internal networks are defined
- * here to include fabrics.
- */
-function filterNetworkType(networks, netType) {
-    assert.arrayOfObject(networks, 'networks');
-    assert.string(netType, 'netType');
-
-    if (netType === EXTERNAL_NIC_TAG) {
-        return networks.filter(function externalFilter(network) {
-            return !network.fabric && network.nic_tag === EXTERNAL_NIC_TAG;
-        });
-    } else {
-        return networks.filter(function internalFilter(network) {
-            return network.fabric || network.nic_tag !== EXTERNAL_NIC_TAG;
-        });
-    }
-}
-
-
-/*
- * Take an array of network objects and return an array of their UUIDs.
- */
-function getNetworkUuids(networks) {
-    assert.arrayOfObject(networks, 'networks');
-
-    return networks.map(function mapUuids(network) {
-        return network.uuid;
-    });
-}
-
-
-/*
- * Return boolean of whether arr1 is a subset of arr2. Only works
- * with arrays of primitive types.
- */
-function isSubset(arr1, arr2) {
-    for (var i = 0; i < arr1.length; i++) {
-        var ele = arr1[i];
-
-        if (arr2.indexOf(ele) === -1) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-
-/*
- * The prelude is run at the beginning of all pre/post functions in this file.
- * It checks that required arguments are present, and whether the pre/post
- * function should be terminated early -- returned as a boolean.
- */
-function prelude(req, res, cfg, funcName, next) {
-    assert.object(req, 'req');
-    assert.object(res, 'res');
-    assert.object(cfg, 'cfg');
-    assert.string(funcName, 'funcName');
-    assert.func(next, 'next');
-
-    req.log.debug('Running ' + funcName);
-
-    if (cfg.accounts.indexOf(req.account.uuid) === -1) {
-        return false;
-    }
-
-    var path = req.path();
-    var method = req.method;
-
-    return ((method ===  'GET' && /^\/[^\/]+\/networks$/.test(path)) ||
-            (method === 'POST' && /\/(?:machines|nics)$/.test(path)));
-}
 
 
 /*
- * Hook for preprovisioning. Ensure that all networks given in params or
- * packages the request's account in their owner_uuids attribute. If
- * neither are provided, then filter the default external/internal networks
- * for networks which fulfill the owner_uuids requirement.
+ * This hook runs after sdc-docker and cloudapi have retrieved an array from
+ * napi, but before the array is returned any higher up the stack. It filters
+ * 'networks' so that it only contains networks or network pools which have the
+ * account UUID in their owner_uuids.
  */
-function preProvision(cfg) {
+function filterListNetworks(api, cfg) {
+    assert.object(api, 'api');
+    assert.object(api.log, 'api.log');
     assert.object(cfg, 'cfg');
     assert.arrayOfUuid(cfg.accounts, 'cfg.accounts');
 
-    return function filterOwnerProvision(req, res, next) {
-        if (!prelude(req, res, cfg, filterOwnerProvision.name, next)) {
-            return next();
-        }
-
-        var log = req.log;
-        var params = req.params;
-        var ownedNetworks = getOwnedNetworks(req.networks, req.account.uuid);
-        var ownedNetworkUuids = getNetworkUuids(ownedNetworks);
-        var reqNetworkUuids = params.networks;
-        var pkgNetworkUuids = req.pkg && req.pkg.networks;
+    var log = api.log;
 
-        if (reqNetworkUuids) {
-            log.debug('Comparing requested networks with owned networks');
+    return function filterOwnerListNetworks(opts, networks) {
+        assert.object(opts, 'opts');
+        assert.object(opts.account, 'opts.account');
+        assert.arrayOfObject(networks, 'networks');
 
-            if (!isSubset(reqNetworkUuids, ownedNetworkUuids)) {
-                return next(new InvalidArgumentError('Account does not have ' +
-                    'access to some or all of the requested networks.'));
-            }
-        } else if (pkgNetworkUuids) {
-            log.debug('Comparing package networks with owned networks');
+        log.debug('Running ' + filterOwnerListNetworks.name);
 
-            if (!isSubset(pkgNetworkUuids, ownedNetworkUuids)) {
-                return next(new InvalidArgumentError('Account does not have ' +
-                    'access to some or all of the package networks.'));
-            }
-        } else {
-            log.debug('Allowing only owned networks in internal/external.');
-
-            var defaultNetTypes = params.default_networks || DEFAULT_NETWORKS;
-            if (!Array.isArray(defaultNetTypes)) {
-                return next(new InvalidArgumentError('default_networks is ' +
-                    'not an array'));
-            }
-
-            var filteredNetworks = [];
-            defaultNetTypes.forEach(function (type) {
-                var nets = filterNetworkType(ownedNetworks, type);
-                if (nets.length > 0) {
-                    filteredNetworks.push(nets[0]);
-                }
-            });
-
-            if (filteredNetworks.length === 0) {
-                return next(new InvalidArgumentError('Account does not have ' +
-                    'ownership of any default networks'));
-            }
-
-            log.info('Plugin rewrite of req.params.networks using',
-                defaultNetTypes);
-            params.networks = getNetworkUuids(filteredNetworks);
+        var accountUuid = opts.account.uuid;
+        if (cfg.accounts.indexOf(accountUuid) === -1) {
+            return networks;
         }
 
-        return next();
+        log.debug('Filtering networks for account', accountUuid);
+
+        return networks.filter(function filterOwner(network) {
+            var owners = network.owner_uuids;
+            return owners && owners.indexOf(accountUuid) !== -1;
+        });
     };
 }
 
 
 /*
- * Hook run before adding a nic to a VM. Ensure that network given in network
- * param contains the request's account in its owner_uuids attribute.
+ * This hook is run when creating a container, before assigning
+ * a default external network to that container. The default network
+ * may not belong to the account creating the container, then this
+ * gets invoked. It finds a pool or network which is owned by an
+ * account, and has an 'external' nic tag.
  */
-function preAddNic(cfg) {
+function findOwnerExternalNetwork(api, cfg) {
+    assert.object(api, 'api');
+    assert.object(api.log, 'api.log');
+    assert.func(api.getNapiNetworksForAccount, 'api.getNapiNetworksForAccount');
     assert.object(cfg, 'cfg');
     assert.arrayOfUuid(cfg.accounts, 'cfg.accounts');
 
-    return function filterOwnerAddNic(req, res, next) {
-        if (!prelude(req, res, cfg, filterOwnerAddNic.name, next)) {
-            return next();
-        }
+    var log = api.log;
 
-        var networkUuid = req.params.network;
-        if (!networkUuid) {
-            return next();
-        }
+    return function findExternalNetworkWithOwnerUuid(opts, cb) {
+        assert.object(opts, 'opts');
+        assert.object(opts.account, 'opts.account');
+        assert.uuid(opts.req_id, 'opts.req_id');
 
-        req.log.debug('Comparing requested network with owned networks');
+        log.debug('Running ' + findExternalNetworkWithOwnerUuid.name);
 
-        var ownedNetworks = getOwnedNetworks(req.networks, req.account.uuid);
-        var ownedNetworkUuids = getNetworkUuids(ownedNetworks);
-
-        if (ownedNetworkUuids.indexOf(networkUuid) === -1) {
-            return next(new InvalidArgumentError(
-                'Account does not have access to the specified network.'));
+        var accountUuid = opts.account.uuid;
+        if (cfg.accounts.indexOf(accountUuid) === -1) {
+            return cb();
         }
 
-        return next();
-    };
-}
-
+        log.debug('Looking up external pools and networks for account',
+            accountUuid);
 
+        return api.getNapiNetworksForAccount({
+            account: opts.account,
+            req_id: opts.req_id,
+            log: log
+        }, function onAccountNetworks(err, networks) {
+            if (err) {
+                return cb(err);
+            }
 
-/*
- * This hook runs before the listing of non-fabric networks, and filters
- * req.networks (set earlier by cloudapi) so that it only contains networks
- * or network pools which have the account UUID in their owner_uuids.
- */
-function preListNetworks(cfg) {
-    assert.object(cfg, 'cfg');
-    assert.arrayOfUuid(cfg.accounts, 'cfg.accounts');
+            var owned = networks.filter(function filterOwner(network) {
+                var owners = network.owner_uuids;
+                return owners && owners.indexOf(accountUuid) !== -1;
+            });
 
-    return function filterOwnerListNetworks(req, res, next) {
-        if (!prelude(req, res, cfg, filterOwnerListNetworks.name, next)) {
-            return next();
-        }
+            var external = owned.filter(function filterExternal(network) {
+                var tags = network.nic_tags_present;
+                return network.nic_tag === EXTERNAL_NIC_TAG ||
+                    (tags && tags.indexOf(EXTERNAL_NIC_TAG) !== -1);
+            });
 
-        req.log.info('Plugin rewrite of req.networks');
-        req.networks = getOwnedNetworks(req.networks, req.account.uuid);
+            if (external.length === 0) {
+                var msg = 'Found no external network accessible to account';
+                return cb(new Error(msg));
+            }
 
-        return next();
+            return cb(null, external[0]);
+        });
     };
 }
 
 
 module.exports = {
-    preProvision: preProvision,
-    preAddNic: preAddNic,
-    preListNetworks: preListNetworks
+    filterGetNetworksOrPools: filterListNetworks,
+    filterListNetworks: filterListNetworks,
+    findOwnerExternalNetwork: findOwnerExternalNetwork
 };
diff --git a/plugins/free_tier.js b/plugins/free_tier.js
new file mode 100644
index 0000000..2c838c0
--- /dev/null
+++ b/plugins/free_tier.js
@@ -0,0 +1,125 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Free Tier offering plugin: each account can create a single free-tier
+ * instance per datacenter for the first year after the account has been
+ * created.
+ *
+ * To configure this plugin, add the UUIDs of the packages that are used for the
+ * free tier; exactly one free allocation will be allowed from this set of
+ * packages:
+ *
+ * {
+ *    "name": "free_tier",
+ *    "enabled": true,
+ *    "config": {
+ *        "packages": [ ... list of UUIDs here ... ],
+ *    }
+ * }
+ *
+ * This is added to CLOUDAPI_PLUGINS and DOCKER_PLUGINS, serialized to JSON, and
+ * PUT to cloudapi's and sdc-docker's sapi services. E.g.:
+ *
+ * sdc-sapi /services/$(sdc-sapi /services?name=cloudapi | json -Ha uuid) -X PUT
+ * -d '{
+ *    "metadata": {
+ *         "CLOUDAPI_PLUGINS": "[{\"name\":\"free_tier\", \
+ *         \"enabled\": true, \"config\": {\"packages\": \
+ *         [\"fb7f31ad-52d6-4e92-83d2-9f9d94ceef3f\"]}}]"
+ *    }
+ * }'
+ */
+
+
+var assert = require('assert-plus');
+
+
+// --- Globals
+
+
+var QUOTA_ERR = 'QuotaExceeded; free tier offering is limited to a single ' +
+    'instance for the first year after the account has been created';
+
+var YEAR_IN_MS = 365.25 * 24 * 60 * 60 * 1000;
+
+
+/*
+ * Calls cb(err), where no error means that the provision can proceed. An error
+ * should halt the provision.
+ */
+function allowOneYearFreeTier(api, cfg) {
+    assert.object(api, 'api');
+    assert.object(api.log, 'api.log');
+    assert.object(cfg, 'cfg');
+    assert.arrayOfUuid(cfg.packages, 'cfg.packages');
+
+    var log = api.log;
+    var packageUuids = cfg.packages;
+
+    return function checkOneYearFreeTier(opts, cb) {
+        assert.object(opts, 'opts');
+        assert.object(opts.account, 'opts.account');
+        assert.object(opts.pkg, 'opts.pkg');
+        assert.uuid(opts.req_id, 'opts.req_id');
+        assert.func(cb, 'cb');
+
+        log.debug('Running', checkOneYearFreeTier.name);
+
+        var account = opts.account;
+
+        // If requested package is not in the free tier config list, this plugin
+        // should have no impact on provisioning:
+        if (packageUuids.indexOf(opts.pkg.uuid) === -1) {
+            log.debug('Pkg %s is not free tier; allowing', opts.pkg.uuid);
+            return cb();
+        }
+
+        if (account.isAdmin()) {
+            log.debug('Account %s is an admin; allowing', account.login);
+            return cb();
+        }
+
+        // If the account is older than one year, disallow.
+        var created = new Date(account.created_at);
+        if (created < Date.now() - YEAR_IN_MS) {
+            log.info('Account %s created more than one year ago; disallowing',
+                account.login);
+            return cb(new api.NotAuthorizedError(QUOTA_ERR));
+        }
+
+        return api.getActiveVmsForAccount({
+            account: account,
+            fields: 'billing_id',
+            req_id: opts.req_id
+        }, function (err, vms) {
+            if (err) {
+                log.error({ err: err }, 'Unable to count VMs');
+                return cb(err);
+            }
+
+            var count = vms.filter(function (vm) {
+                return packageUuids.indexOf(vm.billing_id) !== -1;
+            }).length;
+
+            if (count > 0) {
+                log.info('%s free instances; disallowing', count);
+                return cb(new api.NotAuthorizedError(QUOTA_ERR));
+            }
+
+            return cb();
+        });
+    };
+}
+
+
+module.exports = {
+    allowProvision: allowOneYearFreeTier
+};
diff --git a/plugins/jpc_free_tier.js b/plugins/jpc_free_tier.js
deleted file mode 100644
index 448f8fd..0000000
--- a/plugins/jpc_free_tier.js
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2014, Joyent, Inc.
- */
-
-/*
- * JPC Free Tier offering plugin.
- *
- * Each JPC account can create a single free tier instance per
- * datacenter for the first year after the account has been created,
- * and only for accounts created after March 1, 2014.
- *
- * Free tier instance: req.package has one of the uuids listed into
- * plugin config file.
- *
- * First year after the account has been created: lookup at
- * req.account.created_at (epoch time), and compare with "one year ago".
- *
- * Single instance: count VMAPI vms into the current DC, (only those
- * whose state wasn't "failed").
- */
-
-
-var assert = require('assert');
-var util = require('util');
-var restify = require('restify');
-
-var CODE = 'QuotaExceeded';
-var MESSAGE = 'Free tier offering is limited to a single instance for the ' +
-                'first year after the account has been created, and only ' +
-                'for accounts created after March 1, 2014.';
-
-function leap(year) {
-    return ((year % 4) === 0 &&
-            ((year % 100) !== 0 || (year % 400) === 0));
-}
-
-// Epoch time for one year ago:
-function oneYearAgo() {
-    var d = new Date();
-    var y = d.getFullYear();
-    var days = leap(y) ? 366 : 365;
-    return (d - (days * 24 * 60 * 60 * 1000));
-}
-
-module.exports = {
-    preProvision: function (cfg) {
-
-        if (!cfg || typeof (cfg) !== 'object') {
-            throw new TypeError('cfg (object) is required');
-        }
-
-        if (!cfg.packages) {
-            throw new TypeError('cfg.packages is required');
-        }
-
-        return function jpcFreeTier(req, res, next) {
-            // Do nothing if we are not provisioning:
-            if (!(/\/machines$/.test(req.url) &&
-                        req.method.toUpperCase() === 'POST')) {
-                return next();
-            }
-
-            assert.ok(req.account);
-            assert.ok(req.sdc);
-            assert.ok(Array.isArray(cfg.packages));
-
-            var log = req.log;
-
-            if (!req.pkg) {
-                log.debug('jpc_free_tier: no package on req; skipping checks.');
-                return next();
-            }
-
-            if (!cfg.packages.length) {
-                log.debug('jpc_free_tier: no free tier packages, allowing.');
-                return next();
-            }
-            // If req.package is not included into the free tier config list,
-            // this plugin should have zero impact in provisioning:
-            if (cfg.packages.indexOf(req.pkg.uuid) === -1) {
-                log.debug('jpc_free_tier: pkg %s is not free tier, allowing.',
-                    req.pkg.uuid);
-                return next();
-            }
-
-            if (req.account.isAdmin()) {
-                log.debug('jpc_free_tier: account %s is an admin, allowing.',
-                    req.account.login);
-                return next();
-            }
-
-            // If the account is older than one year, we don't need to lookup
-            // anything else
-            var created = new Date(req.account.created_at);
-            var aYearAgo = new Date(oneYearAgo());
-            if (created <= aYearAgo) {
-                log.info('jpc_free_tier: account %s created %s before than ' +
-                        'one year ago, disallowing.',
-                        req.account.login, created.toUTCString());
-                return next(new restify.NotAuthorizedError(
-                                util.format('%s: %s', CODE, MESSAGE)));
-            }
-            // JPC Offering begins March the 1st, 2014:
-            var offer_begins_at = new Date(2014, 2, 1);
-            if (created < offer_begins_at) {
-                log.info('jpc_free_tier: account %s created %s before ' +
-                        'offering beginning %s, disallowing.',
-                        req.account.login, created.toUTCString(),
-                        offer_begins_at.toUTCString());
-                return next(new restify.NotAuthorizedError(
-                                util.format('%s: %s', CODE, MESSAGE)));
-
-            }
-
-
-            // Let's assume we will allow destroy/re-create a machine for
-            // the free tier time period
-            var filter = '(&(owner_uuid=' + req.account.uuid +
-                    ')(&(!(state=destroyed))(!(state=failed)))(|(' +
-            cfg.packages.map(function (i) {
-                return ('billing_id=' + i);
-            }).join(')(') + ')))';
-
-
-            log.debug({filter: filter}, 'VMAPI search machines filter');
-
-            return req.sdc.vmapi.client.head({
-                path: '/vms',
-                query: {query: filter}
-            }, function (err3, req3, res3) {
-                if (err3) {
-                    log.error({err: err3},
-                        'jpc_free_tier: unable to count VMs.');
-                    return next(new restify.InternalError(
-                            'jpc_free_tier: unable to count VMs.'));
-                }
-
-                var count = Number(
-                    res3.headers['x-joyent-resource-count']) || 0;
-
-                log.debug('jpc_free_tier: limit=1, count=%d', count);
-
-                if (count !== 0) {
-                    log.info('jpc_free_tier: %s instances, disallowing.',
-                        count);
-                    return next(new restify.NotAuthorizedError(
-                            util.format('%s: %s', CODE, MESSAGE)));
-                }
-
-                return next();
-
-            });
-
-        };
-    }
-};
diff --git a/plugins/machine_email.js b/plugins/machine_email.js
index 1351f5a..65d2d4b 100644
--- a/plugins/machine_email.js
+++ b/plugins/machine_email.js
@@ -5,101 +5,139 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
-var assert = require('assert');
-var util = require('util');
-var restify = require('restify');
+/*
+ * Sends an email after a VM/container has been successfully provisioned.
+ *
+ * To configure this plugin, provide the following configuration attributes:
+ *
+ * - from: email address that will be in the From field send to the client.
+ * - subject: what the subject line will be.
+ * - text: what the body of the email will be.
+ *
+ * In addition, the transport (sendmail or direct SMTP) requires configuration.
+ * To send through Sendmail, add the following attribute:
+ *
+ * - sendmail: {
+ *     path: full path to sendmail binary
+ * }
+ *
+ * To send through SMTP:
+ *
+ * - smtp: {
+ *     host: hostname of SMTP server
+ *     secureConnection: true to use SSL,
+ *     port: SMTP port,
+ *     auth: {
+ *         user: ...
+ *         pass: ...
+ *     }
+ * }
+ *
+ * A full example, using sendmail:
+ *
+ * {
+ *     "name": "machine_email",
+ *     "enabled": true,
+ *     "config": {
+ *         "from": "sender@example.com",
+ *         "subject": "A new container has been provisioned",
+ *         "text": "All toasty and ready for use!",
+ *         "sendmail": {
+ *             "path": "/usr/sbin/sendmail"
+ *         }
+ *     }
+ * }
+ *
+ * This is added to CLOUDAPI_PLUGINS and DOCKER_PLUGINS, serialized to JSON,
+ * and PUT to cloudapi's and sdc-docker's sapi services.
+ *
+ * E.g. for cloudapi:
+ *
+ * sdc-sapi /services/$(sdc-sapi /services?name=cloudapi | json -Ha uuid) -X PUT
+ * -d '{
+ *    "metadata": {
+ *         "CLOUDAPI_PLUGINS": "[{\"name\":\"machine_email\",\"enabled\":true, \
+ *         \"config\":{\"from\":\"sender@example.com\",\"subject\": \
+ *         \"A new container has been provisioned\",\"text\": \
+ *         \"All toasty and ready for use!\", \
+ *         \"sendmail\":{\"path\":\"/usr/sbin/sendmail\"}}}]"
+ *    }
+ * }'
+ */
+
+
+var assert = require('assert-plus');
 var nodemailer = require('nodemailer');
 
+
 // --- Globals
 
-var EMAIL = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i;
 
-// --- Exported API
+var EMAIL_RE = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i;
 
-module.exports = {
-  /**
-   * Creates a (post) provisioning hook.
-   *
-   * Config is the JS object that was converted from the
-   * free-form config object that is defined in config.json.
-   *
-   * This function must return a restify filter that is run as part
-   * of a restify "main" chain.
-   *
-   * @param {Object} configuration object for the selected nodemailer
-   *                 transport. Transport can be one of "smtp" or "sendmail",
-   *                 and such member should be present on the config object.
-   *
-   *                 SMTP example:
-   *
-   *                 smtp: {
-   *                     service: 'Gmail', // use well known service
-   *                     auth: {
-   *                        user: 'test.nodemailer@gmail.com',
-   *                        pass: 'Nodemailer123'
-   *                     }
-   *                 }
-   *
-   *                 Sendmail example:
-   *
-   *                 sendmail: '/usr/sbin/sendmail'
-   *
-   * @return {Function} restify filter
-   */
-    postProvision: function (cfg) {
-
-        if (!cfg || typeof (cfg) !== 'object') {
-            throw new TypeError('config (cfg) is required');
-        }
-        var transport;
-
-        if (cfg.smtp && typeof (cfg.smtp) === 'object') {
-            nodemailer.SMTP = cfg.smtp;
-            transport = nodemailer.createTransport('SMTP', cfg.smtp);
-        } else if (cfg.sendmail && typeof (cfg.sendmail) === 'string') {
-            transport = nodemailer.createTransport('Sendmail', cfg.sendmail);
-        } else {
-            throw new TypeError('cfg.smtp or cfg.sendmail is required');
-        }
-
-        if (!cfg.from || typeof (cfg.from) !== 'string' ||
-            !EMAIL.test(cfg.from)) {
-            throw new TypeError('cfg.from is required (email)');
-        }
-
-        if (!cfg.subject || typeof (cfg.subject) !== 'string') {
-            throw new TypeError('cfg.subject is required (string)');
-        }
-        if (!cfg.text || typeof (cfg.text) !== 'string') {
-            throw new TypeError('cfg.text is required (string)');
-        }
-
-        return function (req, res, next) {
-            assert.ok(req.account);
-            assert.ok(req.log);
-
-            var message = {
-                from: cfg.from,
-                to: req.account.email,
-                subject: cfg.subject,
-                text: cfg.text
-            };
-
-            transport.sendMail(message, function (error) {
-                if (error) {
-                    req.log.error({
-                        err: error
-                    }, 'Email failure');
-                } else {
-                    req.log.info('Email sent');
-                }
-
-                return next();
-
-            });
-        };
+
+/*
+ * Given a provision, send an email to the client who provisioned.
+ *
+ * Calls cb(). No error will ever be returned.
+ */
+function postProvisionEmail(api, cfg) {
+    assert.object(api, 'api');
+    assert.object(api.log, 'api.log');
+    assert.object(cfg, 'cfg');
+    assert.object(cfg.smtp || cfg.sendmail || cfg.test,
+        'cfg.smtp || cfg.sendmaili || cfg.test');
+    assert.string(cfg.from, 'cfg.from');
+    assert.ok(EMAIL_RE.test(cfg.from), 'cfg.from (email) is required');
+    assert.string(cfg.subject, 'cfg.subject');
+    assert.string(cfg.text, 'cfg.text');
+
+    var log = api.log;
+    var from = cfg.from;
+    var subject = cfg.subject;
+    var text = cfg.text;
+
+    var transport;
+    if (cfg.smtp) {
+        transport = nodemailer.createTransport('SMTP', cfg.smtp);
+    } else if (cfg.sendmail) {
+        assert.string(cfg.sendmail.path, 'cfg.sendmail.path');
+        transport = nodemailer.createTransport('SENDMAIL', cfg.sendmail.path);
+    } else {
+        transport = cfg.test; // for testing purposes
     }
+
+    return function sendPostProvisionEmail(opts, cb) {
+        assert.object(opts, 'opts');
+        assert.object(opts.account, 'opts.account');
+        assert.string(opts.account.email, 'opts.account.email');
+        assert.func(cb, 'cb');
+
+        log.debug('Running', sendPostProvisionEmail.name);
+
+        var to = opts.account.email;
+
+        transport.sendMail({
+            from: from,
+            to: to,
+            subject: subject,
+            text: text
+        }, function sendMailCb(err) {
+            if (err) {
+                log.error({ err: err }, 'Email failure');
+            } else {
+                log.info('Email sent');
+            }
+
+            cb();
+        });
+    };
+}
+
+
+module.exports = {
+    postProvision: postProvisionEmail
 };
diff --git a/plugins/provision_limits.js b/plugins/provision_limits.js
index 8881b75..c624998 100644
--- a/plugins/provision_limits.js
+++ b/plugins/provision_limits.js
@@ -5,393 +5,874 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
- * Provision Limits Plugin.
+ * This applies provision limits specified by operators across a datacenter,
+ * either for all accounts or for a specific account. It is possible to limit an
+ * account based on three sums: total number of account VMs, total sum of those
+ * VMs' RAM, and/or the total sum of those VM's disk quota. Each of these three
+ * sums can be optionally constrainted by: VM brand, VM OS (specifically, the
+ * "os" attribute in the VM's image), and/or VM image name.
  *
- * See Appendix A of CloudAPI Administrator Guide for the whole details
- * on how the plugin works:
+ * Examples are worth a lot, so here are some examples of limits before going
+ * into the specifics:
  *
- * https://mo.joyent.com/docs/cloudapi/master/admin.html
+ * { "value": 200,  "by": "quota" }
+ * { "value": 1024, "by": "ram", "check": "os",    "os": "windows" }
+ * { "value": 25 }
+ * { "value": 100,               "check": "brand", "brand": "lx" }
+ * { "value": 8192, "by": "ram", "check": "image", "image": "base64-lts" }
+ * { "value": 50,                "check": "os",    "os": "any" }
  *
+ * Now the specifics.
+ *
+ * Limit comes in the following JSON format:
+ * { "value": <number> }
+ *
+ * Where <number> is either a number, or a 10-base string encoding of a number.
+ * E.g. 10 or "10". 0 and -1 have special meanings: 0 means unlimited, and -1
+ * prevents all matching provisions.
+ *
+ * By default, a limit counts the number of VMs across a datacenter. So to set
+ * the maximum number of VMs for an account across a datacenter to 25, use:
+ * { "value": 25 }
+ *
+ * We can modify what the "value" counts by adding a "by" clause:
+ * { "value": <number>, "by": "<dimension>" }
+ *
+ * Where currently-supported dimensions are "ram" (in MiB) or "quota" (in GiB).
+ * It's possible to use something beyond "ram" and "quota" (e.g. "count"), but
+ * that will be ignored and treated as the default: counting the number of VMs
+ * across a datacenter; this is for compatibility with cloudapi's old plugin.
+ *
+ * As an example, to limit the total amount of RAM an account can use across a
+ * datacenter to 10240MiB, use the following limit:
+ * { "value": 10240, "by": "ram" }
+ *
+ * It's possible to constrain a limit to specific VM brands, image names or
+ * operating systems, instead of the entire datacenter. This is done with the
+ * "check" attribute. It comes in three forms:
+ * { ..., "check": "brand", "brand": "<VM brand>" }
+ * { ..., "check": "image", "image": "<name of image>" }
+ * { ..., "check": "os", "os": "<name of image operating system>" }
+ *
+ * So to limit the total amount of RAM used by VMs running Windows images to
+ * 8192MiB:
+ * { "value": 8192, "by": "ram", "check": "os", "os": "windows" }
+ *
+ * You can use "any" in place of the image OS or name, or the VM brand. Like so:
+ * { "value" 25, "check": "image", "image": "any" }
+ *
+ * "any" flags in "image" or "os" are commonly added by adminui, yet while "any"
+ * is supported, its effect is the same as not using "check" in the first place.
+ * E.g. these two are equivalent, both limiting the amount of disk used across
+ * an entire datacenter to 900GiB:
+ * { "value": 900, "by": "quota", "check": "os", "os": "any" }
+ * { "value": 900, "by": "quota" }
+ *
+ * Several limits can apply to the same account at once. All the examples above
+ * were meant as one-liners, but adding several limits to an account will work
+ * as desired. Each limit is applied to a new provision, and if any of the
+ * limits, the provision is rejected.
+ *
+ * As an example, to allow an account to have up to 25 VMs, a maximum of
+ * 25600MiB RAM and 2.5TiB disk across the datacenter, and specifically only
+ * allow them to use 2048MiB RAM for the heretical penguin-loving Linux,
+ * add the following four limits to the account:
+ * { "value": 25 }
+ * { "value": 25600, "by": "ram" }
+ * { "value": 2560, "by": "quota" }
+ * { "value": 2048, "by": "ram", "check": "os", "os": "other" }
+ *
+ * There are two places that limits can be stored, and this is also reflected in
+ * their use case:
+ *
+ * 1. sapi, both for sdc-docker and cloudapi. This is where default limits and
+ *    categories of limits for large numbers of users are kept. These limits
+ *    typically rarely change.
+ * 2. ufds, which is for individual accounts. These are used to add exceptions
+ *    to the defaults and categories stored in sapi.
+ *
+ * A typical use-case is to prevent all accounts from using more than a limited
+ * amount of RAM of VMs across a datacenter, until their account has been vetted
+ * by support (e.g. credit card number isn't fraudulent). After vetting, the
+ * limit is bumped substantially. In this use-case, small limits would be set in
+ * sdc-docker's and cloudapi's sapi configuration to serve as defaults. Once
+ * support has vetted the account, they can add a limit in ufds for that account
+ * to override the defaults, thus bumping the amount of RAM or VMs the account
+ * can provision.
+ *
+ * Limits are added to sdc-docker through sapi by adding a configuration for
+ * this sdc-docker plugin:
+ *
+ * DOCKER_UUID=$(sdc-sapi /services?name=docker | json -Ha uuid)
+ * sdc-sapi /services/$DOCKER_UUID -X PUT -d '{
+ *     "metadata": {
+ *         "DOCKER_PLUGINS": "[{\"name\":\"provision_limits\", \
+ *         \"enabled\": true,\"config\":{\"defaults\":[{\"value\":2 }]}}]"
+ *     }
+ * }'
+ *
+ * Likewise for cloudapi:
+ *
+ * CLOUDAPI_UUID=$(sdc-sapi /services?name=cloudapi | json -Ha uuid)
+ * sdc-sapi /services/$CLOUDAPI_UUID -X PUT -d '{
+ *     "metadata": {
+ *         "CLOUDAPI_PLUGINS": "[{\"name\":\"provision_limits\", \
+ *         \"enabled\": true,\"config\":{\"defaults\":[{\"value\":2 }]}}]"
+ *     }
+ * }'
+ *
+ * The above examples completely replace DOCKER_PLUGINS and CLOUDAPI_PLUGINS,
+ * so make sure to check that you're not overwriting the configurations for
+ * other plugins in the process.
+ *
+ * Looking at this plugin's configuration:
+ * { "defaults": [<limits>] }
+ *
+ * Limits in "defaults" are applied to all provisions unless specifically
+ * overridden with a ufds limit. Additional categories can be added in the
+ * plugin's configuration, and their names are up to you. E.g.:
+ * {
+ *     "defaults": [
+ *         { "value": 2 },
+ *         { "value": 1024, "by": "ram" }
+ *     ]
+ *     "small": [
+ *         { "value": 20 },
+ *         { "value": 10, "check": "brand", "brand": "kvm" },
+ *         { "value": 327680, "by": "ram" },
+ *         { "value": 2000, "by": "quota" }
+ *     ]
+ *     "whale": [
+ *         { "value": 10000 },
+ *         { "value": 327680000, "by": "ram" },
+ *         { "value": 1000000, "by" :"quota" }
+ *     ]
+ * }
+ *
+ * The above configuration has defaults which are applied to all accounts that
+ * do not have a category set in "tenant" (see below). There are two added
+ * category of users: "small" and "whale". The "small" category allows accounts
+ * to have up to 20 VMs, up to 10 KVM instances, and a total of 320GiB RAM and
+ * 2000GiB disk across the datacenter. The "whale" category is much, much
+ * higher.
+ *
+ * Which category an account falls in is determined by the "tenant" attribute on
+ * that account in ufds. If the attribute is blank or absent (or a category
+ * that doesn't exist in the configuration), the account uses "defaults" limits.
+ * If the attribute is present and matches a category in the plugin
+ * those are the limits used. For example, this account is a whale:
+ *
+ * $ sdc-ufds search '(login=megacorp)' | json tenant
+ * whale
+ *
+ * To override any of these defaults or categories in ufds, add a capilimit
+ * entry. It takes the general form of:
+ *
+ * sdc-ufds add '
+ * {
+ *   "dn": "dclimit=$DATACENTER, uuid=$ACCOUNT_UUID, ou=users, o=smartdc",
+ *   "datacenter": "$DATACENTER",
+ *   "objectclass": "capilimit",
+ *   "limit": ["<JSON limit>", "<JSON limit>", ...]
+ * }'
+ *
+ * Or you could use adminui, which lets operators do the same with a friendly
+ * discoverable GUI.
  */
 
-var assert = require('assert');
-var util = require('util');
-var restify = require('restify');
+var assert = require('assert-plus');
 var vasync = require('vasync');
 
+
 // --- Globals
 
-var CODE = 'QuotaExceeded';
-var MESSAGE = 'To have your limits raised please contact Support.';
+var QUOTA_ERR = 'Quota exceeded; to have your limits raised please contact '
+    + 'Support';
+var BRAND = 'brand';
+var IMAGE = 'image';
+var OS = 'os';
+var RAM = 'ram';
+var QUOTA = 'quota';
+var ANY = 'any';
 
 
 /*
- * Separated function in order to make testing easier.
+ * DC limits come in two formats, as a result of how ufds (LDAP) works:
+ * a single JSON string, or an array of JSON strings. Each string represents
+ * a single limit. We deserialize these strings here.
  *
- * Unique task for this function is to return which limits will be
- * applied for a given customer. Required information for the function includes
- * the specific limits, the global limits and the image which will be used for
- * provisioning. All this information can be obtained from the request object.
+ * Returns an array of limit objects.
+ */
+function convertFromCapi(log, dcUserLimits) {
+    assert.object(log, 'log');
+    assert.optionalObject(dcUserLimits, 'dcUserLimits');
+
+    if (!dcUserLimits) {
+        return [];
+    }
+
+    var rawLimits = dcUserLimits.limit;
+    if (!rawLimits) {
+        return [];
+    }
+
+    if (typeof (rawLimits) === 'string') {
+        rawLimits = [rawLimits];
+    }
+
+    var parsedLimits = [];
+    rawLimits.forEach(function (raw) {
+        try {
+            parsedLimits.push(JSON.parse(raw));
+        } catch (e) {
+            log.warn({
+                failed_json_string: raw
+            }, 'Failed to deserialize DC provision limit!');
+        }
+    });
+
+    return parsedLimits;
+}
+
+
+/*
+ * Take an array of limit objects and convert their value attributes to numbers.
  *
- * Please, note this function will just return an array with the limits to be
- * applied for the given request, even if that array is empty.
+ * Returns limits with all values as numbers.
  */
-function filterLimits(req_image, cfg_limits, limits) {
-
-    // First, filter relevant limits from configuration (defaults):
-    cfg_limits = cfg_limits.filter(function (l) {
-        return ((l.os && l.os === 'any') ||
-                (l.image && l.image === 'any') ||
-                (l.os && l.check && l.os === req_image.os &&
-                    l.check === 'os') ||
-                (l.image && (l.image === req_image.name ||
-                    l.image === req_image.name.toLowerCase())));
+function atoiValues(limits) {
+    assert.arrayOfObject(limits, 'limits');
+
+    limits.forEach(function (limit) {
+        if (limit.value !== undefined) {
+            limit.value = parseInt(limit.value, 10) || 0;
+        }
     });
 
+    return limits;
+}
 
-    // At this point we should have a single limits entry, let's
-    // convert from capi_limits before we go further
-    if (limits.length) {
-        var parsedLimits = [];
-        Object.keys(limits[0]).forEach(function (k) {
-            if (k === 'limit') {
-                if (typeof (limits[0][k]) === 'string') {
-                    limits[0][k] = [limits[0][k]];
-                }
-                if (!Array.isArray(limits[0][k]) &&
-                    typeof (limits[0][k]) === 'object') {
-                    parsedLimits.push(limits[0][k]);
-                } else {
-                    limits[0][k].forEach(function (j) {
-                        try {
-                            parsedLimits.push(JSON.parse(j));
-                        } catch (e) {}
-                    });
-                }
-            } else if (['dn',
-                'controls',
-                '_parent',
-                '_owner',
-                'objectclass',
-                'datacenter'].indexOf(k) === -1) {
-                // This is an old capi_limit: check image by
-                // number of machines:
-                parsedLimits.push({
-                    image: k,
-                    check: 'image',
-                    by: 'machines',
-                    value: limits[0][k]
-                });
+
+/*
+ * Given limits specified in sdc-docker's and cloudapi's config file, and limits
+ * placed on an account in this DC, merge the two sets of limits into one. DC
+ * limits take priority over config limits, and if any of the DC limits has a
+ * image/os value of 'any' we skip config limits altogether.
+ *
+ * We also do some cleaning/a few rudimentary optimizations here.
+ *
+ * Returns an array of limit objects.
+ */
+function filterLimits(log, service, cfgUserLimits, rawDcUserLimits) {
+    assert.object(log, 'log');
+    assert.string(service, 'service');
+    assert.arrayOfObject(cfgUserLimits, 'cfgUserLimits');
+    assert.optionalObject(rawDcUserLimits, 'dcUserLimits');
+
+    var dcUserLimits = convertFromCapi(log, rawDcUserLimits);
+
+    // Convert any value attributes to numbers
+    dcUserLimits  = atoiValues(dcUserLimits);
+    cfgUserLimits = atoiValues(cfgUserLimits);
+
+    // If the user has any DC-wide wildcard limits specified, we skip any limits
+    // specified in the sapi config.
+    var hasDcWildcards = dcUserLimits.some(function (limit) {
+        return !limit.check || limit.brand === ANY || limit.image === ANY ||
+            limit.os === ANY;
+    });
+
+    // Union of the set of DC and config limits
+    var unionUserLimits = dcUserLimits.slice();
+
+    if (!hasDcWildcards) {
+        // Add any config limit which hasn't been overridden by a DC limit
+        cfgUserLimits.forEach(function (cfgLimit) {
+            var collision = dcUserLimits.some(function (dcLimit) {
+                return dcLimit.check && dcLimit.check === cfgLimit.check &&
+                    dcLimit.by && dcLimit.by === cfgLimit.by;
+            });
+
+            if (!collision) {
+                unionUserLimits.push(cfgLimit);
             }
         });
-        limits = parsedLimits;
     }
 
-    limits = limits.filter(function (l) {
-        return ((l.os && l.os === 'any') ||
-                (l.image && l.image === 'any') ||
-                (l.os && l.check && l.os === req_image.os &&
-                    l.check === 'os') ||
-                (l.image && (l.image === req_image.name.toLowerCase() ||
-                            l.image === req_image.name)));
-    });
-    // Check if the customer has a 'catch all' limit specified and, if so
-    // skip adding anything from the cfg_limits:
-    var catchAll = limits.some(function (l) {
-        return ((l.os && l.os === 'any') || (l.image && l.image === 'any'));
+    // {image: 'any'} and {os: 'any'} are equivalent to {}: they're limits that
+    // apply to everything.
+    unionUserLimits.forEach(function simplifyAny(limit) {
+        if (limit.brand === ANY || limit.image === ANY || limit.os === ANY) {
+            limit.check = undefined;
+            limit.image = undefined;
+            limit.brand = undefined;
+            limit.os    = undefined;
+        }
     });
 
-    // Next, from cfg_limits, take any limit which is different
-    // than the ones from UFDS:
-    cfg_limits.filter(function (cfg_l) {
-        if (!cfg_l.by) {
+    // Remove and log invalid limits
+    unionUserLimits = unionUserLimits.filter(function validateLimit(limit) {
+        if ((limit.check === BRAND && !limit.brand) ||
+            (limit.check === IMAGE && !limit.image) ||
+            (limit.check === OS && !limit.os)) {
+
+            log.warn({ limit: limit }, 'Invalid limit; entry is incomplete');
             return false;
         }
-        var exists = limits.some(function (l) {
-            return (l.check && cfg_l.check &&
-                    l.check === cfg_l.check &&
-                    l.by === cfg_l.by);
+
+        return true;
+    });
+
+    // cloudapi currently supports filtering by image OS and name, but other
+    // services (i.e. Docker) don't need to. In the future image OS and name
+    // very likely be removed, albeit is not officially deprecated yet.
+    if (service !== 'cloudapi') {
+        unionUserLimits = unionUserLimits.filter(function stripImgAttr(limit) {
+            return limit.check !== IMAGE && limit.check !== OS;
         });
+    }
 
-        return (!exists);
+    // Any limit with a value of 0 means 'unlimited', so we remove such limits
+    // here since they're effectively a nop when filtering on them.
+    return unionUserLimits.filter(function filterZero(limit) {
+        return limit.value !== 0;
     });
+}
+
 
-    // Push any limits not the same to our limits list:
-    if (cfg_limits.length > 0 && !catchAll && limits.length === 0) {
-        limits = limits.concat(cfg_limits);
+/*
+ * Determine what the VM's brand will be from an image.
+ *
+ * Returns a brand as string, or undefined if unrecognized image.
+ */
+function getBrand(image) {
+    assert.object(image, 'image');
+
+    var brand = image.requirements && image.requirements.brand;
+
+    if (!brand) {
+        var imgType = image.type;
+
+        if (imgType === 'lx-dataset' || imgType === 'docker') {
+            brand = 'lx';
+        } else if (imgType === 'zone-dataset') {
+            brand = 'joyent';
+        } else if (imgType === 'zvol') {
+            brand = 'kvm';
+        }
     }
-    return (limits);
+
+    return brand;
 }
 
-module.exports = {
-    filterLimits: filterLimits,
-    preProvision: function (cfg) {
-        if (!cfg || typeof (cfg) !== 'object') {
-            throw new TypeError('cfg (object) is required');
+
+function sum(a, b) {
+    return a + b;
+}
+
+
+/*
+ * Takes a look at all of a user's VMs, and determines whether this provision
+ * will shoot over any limits set. The three possible limits are for the sum of
+ * all RAM across the DC (in MiB), the sum of all disk across the DC (in GiB),
+ * and the total number of an account's VMs. Each of these limits can be
+ * optionally be restricted to VMs made using an image with the given name, or
+ * VMs that contain a certain OS.
+ *
+ * Some examples:
+ *
+ * - account limited to total 2GiB RAM across whole DC:
+ *   { "by": "ram", "value": 2048 }
+ *
+ * - account limited to total 1TiB disk across whole DC for VMs with "other"
+ *   OS; "other" is usually used for Docker:
+ *   { "check": "os", "os": "other", "by": "quota", "value": 1024 }
+ *
+ * - account limited to 1GiB RAM across DC, 25GiB disk across DC, and can have
+ *   no more than four VMs:
+ *   { "by": "ram", "value": 1024 }
+ *   { "by": "quota", "value": 25 }
+ *   { "value": 4 }
+ *
+ * Unknown checks (i.e. not "ram" or "quota") are treated as the default case:
+ * counting VMs. Not great, but this is to keep consistent with the cloudapi
+ * plugin's behaviour.
+ *
+ * Returns a boolean: true means provision is a go, false means provision should
+ * be rejected.
+ */
+function canProvision(log, pkg, vms, image, limits) {
+    assert.object(log, 'log');
+    assert.object(pkg, 'pkg');
+    assert.arrayOfObject(vms, 'vms');
+    assert.object(image, 'image');
+    assert.arrayOfObject(limits, 'limits');
+
+    // For the next three filter()s, it's possible that image.name, image.os or
+    // getBrand()'s results are undefined. This will only be the case if none of
+    // the limits require filtering by the associated image name, OS or VM
+    // brand. If they don't require it, then the results of imgVms, osVms,
+    // brandVms don't matter since they won't be used.
+
+    // All VMs matching new provision's image name
+    var imgVms = vms.filter(function imgFilter(vm) {
+        return vm.image_name === image.name;
+    });
+
+    // All VMs matching new provision's OS
+    var osVms = vms.filter(function osFilter(vm) {
+        return vm.os === image.os;
+    });
+
+    // All VMs with a particular brand
+    var brand = getBrand(image);
+    var brandVms = vms.filter(function brandFilter(vm) {
+        return vm.brand === brand;
+    });
+
+    // Loop through each limit and ensure that it passes. If any limit fails,
+    // this provision fails.
+    for (var i = 0; i < limits.length; i++) {
+        var limit = limits[i];
+
+        log.debug({ limit: limit }, 'Applying provision limit');
+
+        var machines = vms;
+        if (limit.check === BRAND) {
+            machines = brandVms;
+        } else if (limit.check === IMAGE) {
+            machines = imgVms;
+        } else if (limit.check === OS) {
+            machines = osVms;
         }
 
-        // In the future we may replace this with terms like "any" or "all"
-        // and make possible apply the same configuration to every datacenter.
-        if (!cfg.datacenter) {
-            throw new TypeError('cfg.datacenter is required');
+        // Default is this
+        var count = machines.length + 1;
+
+        if (limit.by === RAM) {
+            // RAM; in MiB
+            count = machines.map(function (vm) {
+                return vm.ram;
+            }).reduce(sum, pkg.max_physical_memory);
+
+        } else if (limit.by === QUOTA) {
+            // Disk; VMs and limits are in GiB, but packages in MiB
+            count = machines.map(function (vm) {
+                return vm.quota;
+            }).reduce(sum, pkg.quota / 1024);
         }
 
-        if (!cfg.defaults || typeof (cfg.defaults) !== 'object') {
-            throw new TypeError('cfg.defaults (object) is required');
+        if (count > limit.value) {
+            log.info({ limit: limit }, 'Provision limit applied');
+            return false;
         }
+    }
+
+    return true;
+}
+
+
+/*
+ * Look at what the set of limits will be filtering on, and determine what
+ * are the minimal number of fields we need vmapi to populate each VM object
+ * with; this reduces serialization/deserialization time on both ends.
+ *
+ * One major limitation in vmapi is that it doesn't recognize "image_uuid" as
+ * a field, so if we need any information that can only be found in imgapi, we
+ * have no choice but to load complete vmapi objects.
+ *
+ * Returns a query string to use with vmapi's ListVms ?field=. Returns undefined
+ * if we'll use the default object layout instead.
+ */
+function findMinimalFields(limits) {
+    assert.arrayOfObject(limits, 'limits');
 
-        return function provisioningLimits(req, res, next) {
-            // Do nothing if we are not provisioning, (not strictly required,
-            // since CloudAPI will handle this, but illustrative):
-            if (!(/\/machines$/.test(req.url) &&
-                        req.method.toUpperCase() === 'POST')) {
-                return next();
+    var needImageUuid = limits.some(function (limit) {
+        return limit.check === IMAGE || limit.check === OS;
+    });
+
+    if (needImageUuid) {
+        // Cannot use fields because vmapi doesn't understand
+        // ?fields=image_uuid, so we have to load everything :(
+        return undefined;
+    }
+
+    var needRam = limits.some(function (limit) {
+        return limit.by === RAM;
+    });
+
+    var needQuota = limits.some(function (limit) {
+        return limit.by === QUOTA;
+    });
+
+    if (needRam && needQuota) {
+        return 'ram,quota';
+    } else if (needQuota) {
+        return 'quota';
+    } else {
+        // vmapi won't return empty objects, so we need at least one attribute
+        // regardless of whether any limit applies to ram or not
+        return 'ram';
+    }
+}
+
+
+/*
+ * Fetch all the VMs from vmapi that we'll need to apply the given limits. If
+ * any of the limits require that VM objects are populated with details of their
+ * image's OS or name, we need to ensure we have an imgapi version of the image
+ * manifest.
+ *
+ * If we'll be filtering by image name or OS, we can throw away all image or OS
+ * limits that don't apply to this provision once we know the provision's image
+ * OS or name. After all, at that point the only limits that apply either match
+ * the provision's name and OS, or aren't matching on name or OS.
+ *
+ * Calls cb(err, vms, vmImage, limits), where vms is the list of VMs
+ * (populated with "image_name" and "os" if required by the limits), vmImage
+ * (also populated with "name" and "os" if required by the limits), and limits
+ * (a new set of limits once we've throw away now-irrelevant limits).
+ */
+function getVms(log, api, account, image, limits, reqId, cb) {
+    assert.object(log, 'log');
+    assert.object(api, 'api');
+    assert.object(account, 'account');
+    assert.object(image, 'image');
+    assert.arrayOfObject(limits, 'limits');
+    assert.uuid(reqId, 'reqId');
+    assert.func(cb, 'cb');
+
+    var imageLookup = {};
+    var vms = [];
+    var brand;
+
+    // Depending on the service using this plugin, we may get a Moray image
+    // manifest (i.e. from sdc-docker), or we may get an imgapi image manifest
+    // (i.e. from sdc-cloudapi). The image object that sdc-docker stores in
+    // Moray doesn't have the information we need if any of the limits will be
+    // checking by either image name or OS, thus we load it here.
+    function getVmImage(_, next) {
+        log.trace('Running getVmImage');
+
+        var needVmImage = limits.some(function (limit) {
+            var check = limit.check;
+            return check === BRAND || check === IMAGE || check === OS;
+        });
+
+        var isMorayImage = (image.constructor &&
+            image.constructor.name === 'ImageV2');
+
+        if (!needVmImage || !isMorayImage) {
+            log.debug('Loading imgapi image unneeded for filtering; skipping');
+            return next();
+        }
+
+        var vmImgUuid = image.image_uuid;
+        log.debug('Loading imgapi image for limit filtering:', vmImgUuid);
+
+        return api.getImage(vmImgUuid, function getImageCb(err, _image) {
+            if (err) {
+                return next(err);
+            }
+
+            image = _image;
+
+            log.debug({ vm_image: image }, 'Loaded VM\'s image');
+
+            return next();
+        });
+    }
+
+    function refineLimits(_, next) {
+        var needBrand = limits.some(function (limit) {
+            return limit.check === BRAND;
+        });
+
+        if (needBrand) {
+            // If any limits filter by brand, we'll have loaded an imgapi image
+            // in getVmImage().
+            brand = getBrand(image);
+            if (!brand) {
+                var errMsg = 'Unable to determine brand of image ' + image.uuid;
+                return next(new Error(errMsg));
             }
+        }
 
-            // This is the customer account. See node_modules/sdc-clients UFDS
-            // library (lib/ufds.js) `_extendUser` method for a detailed list
-            // of available properties and methods for the `account` object.
-            assert.ok(req.account);
+        // limits after filtering can contain at most one image name and one os
+        // name to query, so we will have at most two imgapi queries later.
+        // Brand doesn't cause an imgapi query since that information is already
+        // on vmapi objects.
+        limits = limits.filter(function filterRelevant(limit) {
+            if (limit.check === BRAND) {
+                return limit.brand === brand;
+            }
 
-            var log = req.log;
+            if (limit.check === IMAGE) {
+                return limit.image === image.name;
+            }
 
-            if (req.account.isAdmin()) {
-                log.debug('Prov. limits: account %s is an admin, allowing.',
-                    req.account.login);
-                return next();
+            if (limit.check === OS) {
+                return limit.os === image.os;
             }
 
-            if (!req.dataset) {
-                log.debug('Prov. limits: no dataset on req; skipping checks.');
-                return next();
+            return true;
+        });
+
+        log.debug({ limits: limits }, 'Found applicable limits');
+
+        return next();
+    }
+
+    // Helper function used by getOsImages() and getNameImages()
+    function getImages(opts, next) {
+        assert.object(opts, 'opts');
+        assert.func(next, 'next');
+
+        opts.state = 'all';
+        opts.req_id = reqId;
+
+        api.listImages(opts, function listImagesCb(err, images) {
+            if (err) {
+                return next(err);
             }
 
-            // If the customer account has limits, we'll use those, otherwise,
-            // we'll go with the default limits specified on config
-            return req.account.listLimits(function (err, limits) {
-                if (err) {
-                    log.error({err: err},
-                        'Prov. limits: unable to list limits.');
-                    return next(new restify.InternalError(
-                            'Provisioning limits: unable to list limits.'));
-                }
+            log.debug({ opts: opts }, 'Loaded images');
 
-                if (!limits) {
-                    limits = [];
-                }
-                // First, we are only interested into limits defined for the
-                // current datacenter:
-                limits = limits.filter(function (l) {
-                    return (l.datacenter === cfg.datacenter);
-                });
-
-                var defaults = (req.account.tenant &&
-                                cfg[req.account.tenant]) ?
-                                cfg[req.account.tenant] : cfg.defaults;
-                limits = filterLimits(req.dataset, defaults, limits);
-                log.debug({provisioning_limits: limits},
-                        'Limits to be applied.');
-
-                // Before we attempt to fetch anything from VMAPI there are
-                // still several things we can do in order to fail/allow early:
-                // - If at this point we have any limit with a value of "-1",
-                // this means we will not be able to provision, since this one
-                // will be applied and we should return now with a failure.
-                if (limits.some(function (a) {
-                    return (a.value && parseInt(a.value, 10) <= -1);
-                })) {
-                    log.info('Prov. Limits: Limits with negative value ' +
-                            'applied, dissallowing');
-                    return next(new restify.NotAuthorizedError(
-                                util.format('%s: %s', CODE, MESSAGE)));
-                }
-                // - If we have any limit with a value of zero, we'll simply
-                // allow so we could safely remove those values from the list.
-                limits = limits.filter(function (a) {
-                    return (a.value && parseInt(a.value, 10) !== 0);
-                });
-                // - Make sure we have at least one limit or return now with
-                // an OK.
-                if (!limits.length) {
-                    log.debug('Prov. limits: no limits to be applied, ' +
-                            'allowing.');
-                    return next();
-                }
-                req.limits = limits;
-
-                // Now, we have to:
-                // - load all images with same os than req.dataset. (We will
-                // optimize and just return those with same name than current
-                // image if there isn't any "check": "os" limit)
-                // - get all the customer machines whose state is not destroyed
-                // or failed.
-                // - check pending limits
-                var toCheck = 'image';
-                var images = [];
-                var allVms = [];
-                // Vms with same OS:
-                var osVms = [];
-                // Vms with same image:
-                var imgVms = [];
-
-                function whatToCheck(_, cb) {
-                    if (req.limits.some(function (x) {
-                        return (x.check === 'os');
-                    })) {
-                        toCheck = 'os';
-                    }
-                    cb(null);
-                }
+            images.forEach(function (img) {
+                imageLookup[img.uuid] = img;
+            });
 
-                function fetchImages(_, cb) {
-                    var opts = {
-                        state: 'all'
-                    };
-
-                    if (toCheck === 'image') {
-                        opts.name = req.dataset.name;
-                    } else {
-                        opts.os = req.dataset.os;
-                    }
-
-                    req.sdc.imgapi.listImages(opts, function (er, imgs, r) {
-                        if (er) {
-                            log.error({err: er},
-                            'Prov. limits: unable to list Images');
-                            return cb(er);
-                        }
-
-                        if (!imgs) {
-                            log.error('Prov. limits: No Images found!');
-                            return cb(new Error('No images found'));
-                        }
-
-                        images = imgs;
-                        return cb(null);
-                    });
-                }
+            return next();
+        });
+    }
+
+    // Search for images that match the VM image's OS, but only if needed
+    function getOsImages(_, next) {
+        log.trace('Running getOsImages');
+
+        var needOsDetails = limits.some(function (limit) {
+            return limit.check === OS;
+        });
+
+        if (needOsDetails) {
+            return getImages({ os: image.os }, next);
+        }
+
+        log.debug('VMs\' OS not needed for limit filtering; skipping');
+
+        return next();
+    }
+
+    // Search for images that match the VM image's name, but only if needed
+    function getNameImages(_, next) {
+        log.trace('Running getNameImages');
+
+        var needNameDetails = limits.some(function (limit) {
+            return limit.check === IMAGE;
+        });
+
+        if (needNameDetails) {
+            return getImages({ name: image.name }, next);
+        }
+
+        log.debug('Img names not needed needed for limit filtering; skipping');
+
+        return next();
+    }
+
+    // Unfortunately, vmapi VMs don't have an 'os' attribute, nor do they store
+    // image names. Therefore we're stuck always loading all of an account's
+    // active VMs. This is really Not Great.
+    //
+    // There are various convoluted optimizations we could try and pull (e.g.
+    // we can make individual vmapi queries for each ?image_uuid=, iff all
+    // applicable limits involve the image name), but if the current approach
+    // becomes too expensive it'd be simplest to have vmapi store the 'os' and
+    // 'image_name' attributes. '?fields=' needs to be extended to support
+    // image_uuid as well. And if vmapi grew a fast path for HEAD with an object
+    // count, that would be pretty handy...
+    //
+    // Calls cb(err, vms, image, limits), where vms is an array of VMs loaded
+    // from vmapi, image comes from imgapi (if needed later on, otherwise it
+    // might be a Moray image manifest) and matches the current provision, and
+    // limits are a new set of limits filtered to match the current provision
+    // given new information about the provision's OS and image name (if
+    // relevant).
+    function getAccountVms(_, next) {
+        log.trace('Running getAccountVms');
+
+        var brandLimits = limits.filter(function isBrandLimit(limit) {
+            return limit.check === BRAND;
+        });
 
-                function loadActiveMachines(_, cb) {
-                    var filter = '(&(owner_uuid=' + req.account.uuid +
-                            ')(&(!(state=destroyed))(!(state=failed))))';
-                    req.sdc.vmapi.listVms({
-                        query: filter
-                    }, function (er, vms) {
-                        if (er) {
-                            log.error({err: er},
-                            'Prov. limits: unable to list VMs');
-                            return cb(er);
-                        }
-
-                        allVms = vms.map(function (vm) {
-                            images.filter(function (i) {
-                                if (i.uuid === vm.image_uuid ||
-                                    (vm.brand === 'kvm' &&
-                                    i.uuid === vm.disks[0].image_uuid)) {
-                                    vm.image_name = i.name;
-                                    vm.os = i.os;
-                                }
-                            });
-                            return (vm);
-                        });
-
-                        return cb(null);
-                    });
+        var opts = {
+            account: account,
+            fields: findMinimalFields(limits),
+            req_id: reqId
+        };
+
+        if (brandLimits.length > 0 && brandLimits.length === limits.length) {
+            // all limits are brand limits, so we only need to fetch VMs with
+            // our image's brand
+            opts.brand = brand;
+        }
+
+        api.getActiveVmsForAccount(opts, function getAccountVmsCb(err, _vms) {
+            if (err) {
+                return (err);
+            }
+
+            vms = _vms;
+
+            // Add 'os' and 'image_name' fields to vms when available. VMs which
+            // don't have a matching image are not under consideration for any
+            // "check":"image"/"os" (if applicable) in any case, which was why
+            // we didn't load those images earlier.
+            vms.forEach(function addVmAttr(vm) {
+                var img = imageLookup[vm.image_uuid];
+                if (img) {
+                    vm.image_name = img.name;
+                    vm.os = img.os;
                 }
+            });
+
+            log.debug('VMs loaded');
+
+            return next();
+        });
+    }
+
+    vasync.pipeline({
+        funcs: [
+            getVmImage,
+            refineLimits,
+            getOsImages,
+            getNameImages,
+            getAccountVms
+        ]
+    }, function vasyncCb(err) {
+        cb(err, vms, image, limits);
+    });
+}
+
+
+/*
+ * Given a new provision, load all limits that apply to the current account
+ * both in sdc-docker's config and in ufds, determine which limits are relevant
+ * to this provision, and check that the provision won't violate any of those
+ * limits.
+ *
+ * Calls cb(err), where no error means that the provision can proceed. An error
+ * should halt the provision.
+ */
+function allowProvision(api, cfg) {
+    assert.object(api, 'api');
+    assert.object(api.log, 'api.log');
+    assert.string(api.service, 'api.service');
+    assert.object(cfg, 'cfg');
+    assert.arrayOfObject(cfg.defaults, 'cfg.defaults');
+
+    var svcs = api.service;
+    var log = api.log;
+
+    return function checkProvisionLimits(opts, cb) {
+        assert.object(opts, 'opts');
+        assert.object(opts.account, 'opts.account');
+        assert.object(opts.image, 'opts.image');
+        assert.object(opts.pkg, 'opts.pkg');
+        assert.uuid(opts.req_id, 'opts.req_id');
+        assert.func(cb, 'cb');
+
+        var account = opts.account;
+        var image = opts.image;
+        var pkg = opts.pkg;
+
+        log.debug('Running', checkProvisionLimits.name);
+
+        if (account.isAdmin()) {
+            log.debug('Account %s is an admin; skipping provision limits',
+                account.uuid);
+                return cb();
+        }
 
-                function machinesByOs(_, cb) {
-                    osVms = allVms.filter(function (vm) {
-                        return (vm.os && vm.os === req.dataset.os);
-                    });
+        // fetch all of this account's DC limits from ufds
+        return account.listLimits(function listLimitsCb(err, globalUserLimits) {
+            if (err) {
+                return cb(err);
+            }
+
+            // Since ufds replicates between DCs, we're only interested in any
+            // limits that apply to this DC specifically.
+            var dcUserLimits = (globalUserLimits || []).find(function (limit) {
+                return limit.datacenter === api.datacenterName;
+            });
+
+            // We use a specific class of sapi-specified limits if the account
+            // has that class, otherwise fall back to defaults.
+            var cfgUserLimits = cfg[account.tenant] || cfg.defaults || [];
+
+            // Merge and optimize a bit the two sets of limits.
+            var limits = filterLimits(log, svcs, cfgUserLimits, dcUserLimits);
+
+            if (!limits.length) {
+                log.debug('No limits to be applied; skipping provision limits');
+                return cb();
+            }
 
-                    return cb(null);
+            log.debug({ provisioning_limits: limits }, 'Will apply limits');
+
+            var disallow = limits.some(function (limit) {
+                return limit.value <= -1;
+            });
+
+            if (disallow) {
+                log.info('Disallowing provision because -1 limit value found');
+                return cb(new api.NotAuthorizedError(QUOTA_ERR));
+            }
+
+            // Load and populate any required VMs from imgapi to check against
+            // the given limits. Narrow the limits based on new information
+            // available from those queries.
+            return getVms(log, api, account, image, limits, opts.req_id,
+                function (err2, vms, image2, fittedLimits) {
+
+                if (err2) {
+                    return cb(err2);
                 }
 
-                function machinesByImg(_, cb) {
-                    imgVms = allVms.filter(function (vm) {
-                        return (vm.image_name &&
-                            (vm.image_name === req.dataset.name ||
-                            vm.image_name.toLowerCase() === req.dataset.name));
-                    });
+                log.info({
+                    vm_count: vms.length,
+                    limits: fittedLimits,
+                    img_os: image2.os,
+                    img_name: image2.name
+                }, 'VMs loaded and provision limits adjusted');
 
-                    return cb(null);
+                var allow = canProvision(log, pkg, vms, image2, fittedLimits);
+                if (!allow) {
+                    return cb(new api.NotAuthorizedError(QUOTA_ERR));
                 }
 
-                return vasync.pipeline({
-                    funcs: [whatToCheck, fetchImages, loadActiveMachines,
-                            machinesByOs, machinesByImg]
-                }, function (er, results) {
-                    if (er) {
-                        log.error({err: er},
-                            'Prov. limits: unable to get machines/images');
-                        return next(new restify.InternalError(
-                                'Prov. limits: unable to get machines/images'));
-                    }
-
-                    return vasync.forEachPipeline({
-                        inputs: req.limits,
-                        func: function (limit, cb) {
-                            log.debug({limit: limit}, 'Applying limit');
-                            var value = parseInt(limit.value, 10);
-                            if (value === 0) {
-                                return cb(null);
-                            }
-                            var count;
-                            var machines = allVms;
-
-                            if (limit.check === 'os' && limit.os !== 'any') {
-                                machines = osVms;
-                            }
-
-                            if (limit.check === 'image' &&
-                                limit.image !== 'any') {
-                                machines = imgVms;
-                            }
-
-                            switch (limit.by) {
-                            case 'ram':
-                                count = machines.map(function (vm) {
-                                    return parseInt(vm.ram, 10);
-                                }).reduce(function (a, b) {
-                                    return (a + b);
-                                }, 0) + parseInt(
-                                    req.pkg.max_physical_memory, 10);
-                                break;
-                            case 'quota':
-                                count = machines.map(function (vm) {
-                                    return parseInt(vm.quota, 10);
-                                }).reduce(function (a, b) {
-                                    return (a + b);
-                                }, 0) + parseInt(req.pkg.quota, 10);
-                                break;
-                            default: // machines
-                                count = machines.length + 1;
-                                break;
-                            }
-
-                            if (count > value) {
-                                log.info({limit: limit},
-                                        'Provisioning limit applied');
-                                return cb(new restify.NotAuthorizedError(
-                                    util.format('%s: %s', CODE, MESSAGE)));
-                            }
-
-                            return cb(null);
-                        }
-                    }, function (er2, results2) {
-                        if (er2) {
-                            return next(er2);
-                        }
-
-                        return next();
-
-                    });
-                });
+                return cb();
             });
-        };
-    }
+        });
+    };
+}
+
+
+module.exports = {
+    // hook loaded by PluginManager
+    allowProvision: allowProvision,
+
+    // and these are additionally exported for tests
+    _convertFromCapi: convertFromCapi,
+    _atoiValues: atoiValues,
+    _filterLimits: filterLimits,
+    _getBrand: getBrand,
+    _canProvision: canProvision,
+    _findMinimalFields: findMinimalFields,
+    _getVms: getVms
 };
diff --git a/test/plugins/filter-owner-networks.test.js b/test/plugins/filter-owner-networks.test.js
new file mode 100644
index 0000000..6aa0e07
--- /dev/null
+++ b/test/plugins/filter-owner-networks.test.js
@@ -0,0 +1,292 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var test = require('tape').test;
+var clone = require('jsprim').deepCopy;
+var plugin = require('../../plugins/filter_owner_networks');
+
+
+// --- Globals
+
+
+var ACCOUNT = { uuid: '572c169e-a287-11e7-b95d-28cfe91f7d53' };
+var OTHER_ACCOUNT = { uuid: '5cc54706-a287-11e7-b33c-28cfe91f7d53' };
+
+var NETWORKS = [ {
+    uuid: '22a0b5fa-a292-11e7-8911-28cfe91f7d53',
+    owner_uuids: [ACCOUNT.uuid],
+    nic_tag: 'internal'
+}, {
+    uuid: '2790d1e4-a292-11e7-8d23-28cfe91f7d53',
+    owner_uuids: ['9ea6158e-a29a-11e7-a2c5-28cfe91f7d53'],
+    nic_tag: 'internal'
+}, {
+    uuid: '9336f8d0-a29a-11e7-a744-28cfe91f7d53',
+    nic_tag: 'interal'
+}, {
+    uuid: '4f854694-a35f-11e7-9574-28cfe91f7d53',
+    nic_tag: 'internal'
+}, {
+    uuid: '3acc8d3e-a35f-11e7-8f64-28cfe91f7d53',
+    owner_uuids: [ACCOUNT.uuid],
+    nic_tag: 'external'
+}  ];
+
+var API = {
+    getNapiNetworksForAccount: function () {},
+    log: {
+        info: function () {},
+        debug: function () {}
+    }
+};
+
+var FILTER_LIST_NETWORKS;
+var FILTER_GET_NETWORKS_OR_POOLS;
+var FIND_OWNER_EXTERNAL_NETWORK;
+
+
+// --- Tests
+
+
+test('Setup filterListNetworks without api',
+function (t) {
+    try {
+        plugin.filterListNetworks();
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'api (object) is required', 'err message');
+    }
+
+    t.end();
+});
+
+
+test('Setup filterListNetworks without cfg',
+function (t) {
+    try {
+        plugin.filterListNetworks(API);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cfg (object) is required', 'err message');
+    }
+
+    t.end();
+});
+
+
+test('Setup filterListNetworks with invalid cfg',
+function (t) {
+    try {
+        plugin.filterListNetworks(API, { accounts: 'foo' });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cfg.accounts ([uuid]) is required', 'err message');
+    }
+
+    t.end();
+});
+
+
+test('Setup filterListNetworks with valid cfg',
+function (t) {
+    FILTER_LIST_NETWORKS = plugin.filterListNetworks(API, {
+        accounts: [ACCOUNT.uuid]
+    });
+    t.equal(typeof (FILTER_LIST_NETWORKS), 'function', 'func type');
+    t.equal(FILTER_LIST_NETWORKS.name, 'filterOwnerListNetworks', 'func name');
+    t.end();
+});
+
+
+test('filterListNetworks with non-owner account',
+function (t) {
+    var networks = FILTER_LIST_NETWORKS({
+        account: OTHER_ACCOUNT
+    }, clone(NETWORKS));
+
+    t.deepEqual(networks, NETWORKS, 'networks');
+    t.end();
+});
+
+
+test('filterListNetworks with owner account',
+function (t) {
+    var networks = FILTER_LIST_NETWORKS({ account: ACCOUNT }, clone(NETWORKS));
+    t.deepEqual(networks, [
+        NETWORKS[0],
+        NETWORKS[4]
+    ], 'networks');
+    t.end();
+});
+
+
+test('Setup filterGetNetworksOrPools without api',
+function (t) {
+    try {
+        plugin.filterGetNetworksOrPools();
+    } catch (e) {
+        t.equal(e.message, 'api (object) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup filterGetNetworksOrPools without cfg',
+function (t) {
+    try {
+        plugin.filterGetNetworksOrPools(API);
+    } catch (e) {
+        t.equal(e.message, 'cfg (object) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup filterGetNetworksOrPools with invalid cfg',
+function (t) {
+    try {
+        plugin.filterGetNetworksOrPools(API, { accounts: 'foo' });
+    } catch (e) {
+        t.equal(e.message, 'cfg.accounts ([uuid]) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup filterGetNetworksOrPools with valid cfg',
+function (t) {
+    FILTER_GET_NETWORKS_OR_POOLS = plugin.filterGetNetworksOrPools(API, {
+        accounts: [ACCOUNT.uuid]
+    });
+    t.equal(typeof (FILTER_LIST_NETWORKS), 'function', 'func type');
+    t.equal(FILTER_LIST_NETWORKS.name, 'filterOwnerListNetworks', 'func name');
+    t.end();
+});
+
+
+test('filterGetNetworksOrPools with non-owner account',
+function (t) {
+    var networks = FILTER_GET_NETWORKS_OR_POOLS({
+        account: OTHER_ACCOUNT
+    }, clone(NETWORKS));
+
+    t.deepEqual(networks, NETWORKS, 'networks');
+    t.end();
+});
+
+
+test('filterGetNetworksOrPools with owner account',
+function (t) {
+    var networks = FILTER_GET_NETWORKS_OR_POOLS({
+        account: ACCOUNT
+    }, clone(NETWORKS));
+
+    t.deepEqual(networks, [
+        NETWORKS[0],
+        NETWORKS[4]
+    ], 'networks');
+
+    t.end();
+});
+
+
+test('Setup findOwnerExternalNetwork without api',
+function (t) {
+    try {
+        plugin.findOwnerExternalNetwork();
+    } catch (e) {
+        t.equal(e.message, 'api (object) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup findOwnerExternalNetwork without cfg',
+function (t) {
+    try {
+        plugin.findOwnerExternalNetwork(API);
+    } catch (e) {
+        t.equal(e.message, 'cfg (object) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup findOwnerExternalNetwork with invalid cfg',
+function (t) {
+    try {
+        plugin.findOwnerExternalNetwork(API, { accounts: 'foo' });
+    } catch (e) {
+        t.equal(e.message, 'cfg.accounts ([uuid]) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup findOwnerExternalNetwork with valid cfg',
+function (t) {
+    FIND_OWNER_EXTERNAL_NETWORK = plugin.findOwnerExternalNetwork(API, {
+        accounts: [ACCOUNT.uuid]
+    });
+    t.equal(typeof (FIND_OWNER_EXTERNAL_NETWORK), 'function', 'func type');
+    t.equal(FIND_OWNER_EXTERNAL_NETWORK.name,
+        'findExternalNetworkWithOwnerUuid', 'func name');
+    t.end();
+});
+
+
+test('findOwnerExternalNetwork with non-owner account',
+function (t) {
+    function failStub(opts, cb) {
+        t.fail('this should not be called');
+    }
+
+    // admittedly evil mutating a global like this...
+    API.getNapiNetworksForAccount = failStub;
+
+    FIND_OWNER_EXTERNAL_NETWORK({
+        account: OTHER_ACCOUNT,
+        req_id: '1180af02-a8ee-11e7-86c1-28cfe91f7d53'
+    }, function (err, network) {
+        t.equal(err, undefined, 'err');
+        t.equal(network, undefined, 'network');
+        t.end();
+    });
+});
+
+
+test('findOwnerExternalNetwork with owner account',
+function (t) {
+    function getNapiNetworksForAccountStub(opts, cb) {
+        t.deepEqual(opts, {
+            log: API.log,
+            reqId: '1180af02-a8ee-11e7-86c1-28cfe91f7d53',
+            accountUuid: ACCOUNT.uuid
+        }, 'stub opts');
+
+        var nets = NETWORKS.filter(function (network) {
+            return !network.owner_uuids ||
+                network.owner_uuids.indexOf(ACCOUNT.uuid) !== -1;
+        });
+
+        return cb(null, nets);
+    }
+
+    API.getNapiNetworksForAccount = getNapiNetworksForAccountStub;
+
+    FIND_OWNER_EXTERNAL_NETWORK({
+        account: ACCOUNT,
+        req_id: '1180af02-a8ee-11e7-86c1-28cfe91f7d53'
+    }, function (err, network) {
+        t.equal(err, null, 'err');
+        t.deepEqual(network, NETWORKS[4], 'network');
+        t.end();
+    });
+});
diff --git a/test/plugins/filter_owner_networks.test.js b/test/plugins/filter_owner_networks.test.js
deleted file mode 100644
index ecac9de..0000000
--- a/test/plugins/filter_owner_networks.test.js
+++ /dev/null
@@ -1,424 +0,0 @@
-/*
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/.
- */
-
-/*
- * Copyright (c) 2017, Joyent, Inc.
- */
-
-var test = require('tape').test;
-var format = require('util').format;
-var plugin = require('../../plugins/filter_owner_networks');
-
-
-// --- Globals
-
-var ACCOUNT = { uuid: '572c169e-a287-11e7-b95d-28cfe91f7d53' };
-var OTHER_ACCOUNT = { uuid: '5cc54706-a287-11e7-b33c-28cfe91f7d53' };
-
-var NETWORKS = [ {
-    uuid: '22a0b5fa-a292-11e7-8911-28cfe91f7d53',
-    owner_uuids: [ACCOUNT.uuid],
-    nic_tag: 'internal'
-}, {
-    uuid: '2790d1e4-a292-11e7-8d23-28cfe91f7d53',
-    owner_uuids: ['9ea6158e-a29a-11e7-a2c5-28cfe91f7d53'],
-    nic_tag: 'internal'
-}, {
-    uuid: '9336f8d0-a29a-11e7-a744-28cfe91f7d53',
-    nic_tag: 'interal'
-}, {
-    uuid: '4f854694-a35f-11e7-9574-28cfe91f7d53',
-    nic_tag: 'internal'
-}, {
-    uuid: '3acc8d3e-a35f-11e7-8f64-28cfe91f7d53',
-    owner_uuids: [ACCOUNT.uuid],
-    nic_tag: 'external'
-}  ];
-
-var ACCOUNT_NETWORK = NETWORKS[0];
-var OTHER_NETWORK = NETWORKS[1];
-var MACHINE_UUID = '8d91185e-a28e-11e7-8b47-28cfe91f7d53';
-
-var NICS_PATH = '/my/machines/%s/nics';
-var NETWORKS_PATH = '/my/networks';
-var MACHINES_PATH = '/my/machines';
-
-var PRE_PROVISION;
-var PRE_ADD_NIC;
-var PRE_LIST_NETWORKS;
-
-
-// --- Helpers
-
-function clone(o) {
-    return JSON.parse(JSON.stringify(o));
-}
-
-
-function createStubReq(method, path) {
-    return {
-        account: ACCOUNT,
-        params: {},
-        method: method,
-        networks: clone(NETWORKS),
-        path: function () { return path; },
-        log: {
-            info: function () {},
-            debug: function () {}
-        }
-    };
-}
-
-
-// --- Tests
-
-test('Setup preAddNic without cfg',
-function (t) {
-    try {
-        plugin.preAddNic();
-    } catch (e) {
-        t.equal(e.message, 'cfg (object) is required', 'err message');
-        t.end();
-    }
-});
-
-
-test('Setup preAddNic with invalid cfg',
-function (t) {
-    try {
-        plugin.preAddNic({ accounts: 'foo' });
-    } catch (e) {
-        t.equal(e.message, 'cfg.accounts ([uuid]) is required', 'err message');
-        t.end();
-    }
-});
-
-
-test('Setup preAddNic with valid cfg',
-function (t) {
-    PRE_ADD_NIC = plugin.preAddNic({ accounts: [ACCOUNT.uuid] });
-    t.equal(typeof (PRE_ADD_NIC), 'function', 'func type');
-    t.equal(PRE_ADD_NIC.name, 'filterOwnerAddNic', 'func name');
-    t.end();
-});
-
-
-test('preAddNic with non-owner account',
-function (t) {
-    var req = createStubReq('POST', format(NICS_PATH, MACHINE_UUID));
-    req.params.network = ACCOUNT_NETWORK.uuid;
-    req.account = OTHER_ACCOUNT;
-
-    PRE_ADD_NIC(req, {}, function onPreAddNic(err) {
-        t.ifError(err, 'err');
-        t.end();
-    });
-});
-
-
-test('preAddNic with owner account and non-owner network',
-function (t) {
-    var req = createStubReq('POST', format(NICS_PATH, MACHINE_UUID));
-    req.params.network = OTHER_NETWORK.uuid;
-
-    PRE_ADD_NIC(req, {}, function onPreAddNic(err) {
-        t.ok(err, 'err');
-        t.equal(err.restCode, 'InvalidArgument', 'err rest code');
-        t.equal(err.message,
-            'Account does not have access to the specified network.',
-            'err message');
-        t.end();
-    });
-});
-
-
-test('preAddNic with owner account and owner network',
-function (t) {
-    var req = createStubReq('POST', format(NICS_PATH, MACHINE_UUID));
-    req.params.network = ACCOUNT_NETWORK.uuid;
-
-    PRE_ADD_NIC(req, {}, function onPreAddNic(err) {
-        t.ifError(err, 'err');
-        t.end();
-    });
-});
-
-
-test('preAddNic with different path',
-function (t) {
-    var path = format(NICS_PATH, MACHINE_UUID) + '/1a2b3c4d5e6f';
-    var req = createStubReq('POST', path);
-    req.params.network = ACCOUNT_NETWORK.uuid;
-
-    PRE_ADD_NIC(req, {}, function onPreAddNic() {
-        t.end();
-    });
-});
-
-
-test('Setup preListNetworks without cfg',
-function (t) {
-    try {
-        plugin.preListNetworks();
-    } catch (e) {
-        t.equal(e.message, 'cfg (object) is required', 'err message');
-        t.end();
-    }
-});
-
-
-test('Setup preListNetworks with invalid cfg',
-function (t) {
-    try {
-        plugin.preListNetworks({ accounts: 'foo' });
-    } catch (e) {
-        t.equal(e.message, 'cfg.accounts ([uuid]) is required', 'err message');
-        t.end();
-    }
-});
-
-
-test('Setup preListNetworks with valid cfg',
-function (t) {
-    PRE_LIST_NETWORKS = plugin.preListNetworks({
-        accounts: [ACCOUNT.uuid]
-    });
-    t.equal(typeof (PRE_LIST_NETWORKS), 'function', 'func type');
-    t.equal(PRE_LIST_NETWORKS.name, 'filterOwnerListNetworks', 'func name');
-    t.end();
-});
-
-
-test('preListNetworks with non-owner account',
-function (t) {
-    var req = createStubReq('GET', NETWORKS_PATH);
-    req.account = OTHER_ACCOUNT;
-
-    PRE_LIST_NETWORKS(req, {}, function onPreListNetworks(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.networks, NETWORKS, 'req.networks');
-        t.end();
-    });
-});
-
-
-test('preListNetworks with owner account',
-function (t) {
-    var req = createStubReq('GET', NETWORKS_PATH);
-
-    PRE_LIST_NETWORKS(req, {}, function onPreListNetworks(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.networks, [
-            NETWORKS[0],
-            NETWORKS[4]
-        ], 'req.networks');
-        t.end();
-    });
-});
-
-
-test('preListNetworks with different path',
-function (t) {
-    var path = NETWORKS_PATH + '/' + ACCOUNT_NETWORK.uuid;
-    var req = createStubReq('GET', path);
-    req.params.network = ACCOUNT_NETWORK.uuid;
-
-    PRE_ADD_NIC(req, {}, function onPreListNetworks(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.networks, NETWORKS, 'req.networks');
-        t.end();
-    });
-});
-
-
-test('Setup preProvision without cfg',
-function (t) {
-    try {
-        plugin.preProvision();
-    } catch (e) {
-        t.equal(e.message, 'cfg (object) is required', 'err message');
-        t.end();
-    }
-});
-
-
-test('Setup preProvision with invalid cfg',
-function (t) {
-    try {
-        plugin.preProvision({ accounts: 'foo' });
-    } catch (e) {
-        t.equal(e.message, 'cfg.accounts ([uuid]) is required', 'err message');
-        t.end();
-    }
-});
-
-
-test('Setup preProvision with valid cfg',
-function (t) {
-    PRE_PROVISION = plugin.preProvision({ accounts: [ACCOUNT.uuid] });
-    t.equal(typeof (PRE_PROVISION), 'function');
-    t.equal(PRE_PROVISION.name, 'filterOwnerProvision');
-    t.end();
-});
-
-
-test('preProvision with non-owner account',
-function (t) {
-    var networks = [ACCOUNT_NETWORK.uuid];
-    var req = createStubReq('POST', MACHINES_PATH);
-    req.params.networks = networks;
-
-    PRE_PROVISION(req, {}, function onPreProvision(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.params.networks, networks, 'params.networks');
-        t.deepEqual(req.networks, NETWORKS, 'req.networks');
-        t.end();
-    });
-});
-
-
-test('preProvision with owner account and non-owner network',
-function (t) {
-    var req = createStubReq('POST', MACHINES_PATH);
-    req.params.networks = [OTHER_NETWORK.uuid];
-
-    PRE_PROVISION(req, {}, function onPreProvision(err) {
-        t.ok(err, 'err');
-        t.equal(err.restCode, 'InvalidArgument', 'err rest code');
-        t.equal(err.message, 'Account does not have access to some or all of ' +
-            'the requested networks.', 'err message');
-        t.end();
-    });
-});
-
-
-test('preProvision with owner account and owner networks',
-function (t) {
-    var networks = [ACCOUNT_NETWORK.uuid];
-    var req = createStubReq('POST', MACHINES_PATH);
-    req.params.networks = networks;
-
-    PRE_PROVISION(req, {}, function onPreProvision(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.params.networks, networks, 'params.networks');
-        t.deepEqual(req.networks, NETWORKS, 'req.networks');
-        t.end();
-    });
-});
-
-
-test('preProvision with owner account and non-owner package networks',
-function (t) {
-    var req = createStubReq('POST', MACHINES_PATH);
-    req.pkg = {
-        networks: [OTHER_NETWORK.uuid]
-    };
-
-    PRE_PROVISION(req, {}, function onPreProvision(err) {
-        t.ok(err, 'err');
-        t.equal(err.restCode, 'InvalidArgument', 'err rest code');
-        t.equal(err.message, 'Account does not have access to some or all of ' +
-            'the package networks.', 'err message');
-        t.end();
-    });
-});
-
-
-test('preProvision with owner account and owner package networks',
-function (t) {
-    var networks = [ACCOUNT_NETWORK.uuid];
-    var req = createStubReq('POST', MACHINES_PATH);
-    req.pkg = {
-        networks: networks
-    };
-
-    PRE_PROVISION(req, {}, function onPreProvision(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.networks, NETWORKS, 'req.networks');
-        t.end();
-    });
-});
-
-
-test('preProvision with owner account, package networks, non-owner networks',
-function (t) {
-    var req = createStubReq('POST', MACHINES_PATH);
-    req.params.networks = [OTHER_NETWORK.uuid];
-    req.pkg = {
-        networks: [ACCOUNT_NETWORK.uuid]
-    };
-
-    PRE_PROVISION(req, {}, function onPreProvision(err) {
-        t.ok(err, 'err');
-        t.equal(err.restCode, 'InvalidArgument', 'err rest code');
-        t.equal(err.message, 'Account does not have access to some or all of ' +
-            'the requested networks.', 'err message');
-        t.end();
-    });
-});
-
-
-test('preProvision with owner account, package networks, non-owner networks',
-function (t) {
-    var networks = [ACCOUNT_NETWORK.uuid];
-    var req = createStubReq('POST', MACHINES_PATH);
-    req.params.networks = networks;
-    req.pkg = {
-        networks: [OTHER_NETWORK.uuid]
-    };
-
-    PRE_PROVISION(req, {}, function onPreProvision(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.params.networks, networks, 'params.networks');
-        t.deepEqual(req.networks, NETWORKS, 'req.networks');
-        t.end();
-    });
-});
-
-
-test('preProvision with owner account and explicit default_networks',
-function (t) {
-    var req = createStubReq('POST', MACHINES_PATH);
-    req.params.default_networks = ['external'];
-
-    PRE_PROVISION(req, {}, function onPreProvision(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.params.networks, [NETWORKS[4].uuid], 'params.networks');
-        t.deepEqual(req.networks, NETWORKS, 'req.networks');
-        t.end();
-    });
-});
-
-
-test('preProvision with owner account and implicit default_networks',
-function (t) {
-    var req = createStubReq('POST', MACHINES_PATH);
-
-    PRE_PROVISION(req, {}, function onPreProvision(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.params.networks, [
-            NETWORKS[4].uuid,
-            NETWORKS[0].uuid
-        ], 'params.networks');
-        t.deepEqual(req.networks, NETWORKS, 'req.networks');
-        t.end();
-    });
-});
-
-
-test('preProvision with different path',
-function (t) {
-    var networks = [OTHER_NETWORK.uuid];
-    var req = createStubReq('POST', MACHINES_PATH + '/' + MACHINE_UUID);
-    req.params.networks = networks;
-
-    PRE_ADD_NIC(req, {}, function onPreListNetworks(err) {
-        t.ifError(err, 'err');
-        t.deepEqual(req.params.networks, networks, 'params.networks');
-        t.deepEqual(req.networks, NETWORKS, 'req.networks');
-        t.end();
-    });
-});
diff --git a/test/plugins/free-tier.test.js b/test/plugins/free-tier.test.js
new file mode 100644
index 0000000..7440583
--- /dev/null
+++ b/test/plugins/free-tier.test.js
@@ -0,0 +1,276 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var test = require('tape').test;
+var plugin = require('../../plugins/free_tier');
+var restify = require('restify');
+
+
+// --- Globals
+
+
+var API = {
+    getActiveVmsForAccount: function () {},
+    NotAuthorizedError: restify.NotAuthorizedError,
+    log: {
+        info: function () {},
+        debug: function () {},
+        error: function () {}
+    }
+};
+
+var PACKAGES = [ {
+    uuid: 'c09a10c8-f96b-11e7-a1d2-4396f3b1d925'
+}, {
+    uuid: 'c74857d6-f96b-11e7-be2e-93f2929bb742'
+} ];
+
+var PREPROVISION;
+
+
+// --- Tests
+
+
+test('setup allowProvision without api',
+function (t) {
+    try {
+        plugin.allowProvision();
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'api (object) is required', 'err message');
+    }
+
+    t.end();
+});
+
+
+test('setup allowProvision without cfg',
+function (t) {
+    try {
+        plugin.allowProvision(API);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cfg (object) is required', 'err message');
+    }
+
+    t.end();
+});
+
+
+test('setup allowProvision with invalid cfg',
+function (t) {
+    try {
+        plugin.allowProvision(API, {
+            packages: ''
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cfg.packages ([uuid]) is required', 'err message');
+    }
+
+    t.end();
+});
+
+
+test('setup',
+function (t) {
+    PREPROVISION = plugin.allowProvision(API, {
+        packages: PACKAGES.map(function (pkg) { return pkg.uuid; })
+    });
+
+    t.end();
+});
+
+
+test('allowProvision with non-free package',
+function (t) {
+    API.getActiveVmsForAccount = function () {
+        t.fail('should not be called');
+    };
+
+    PREPROVISION({
+        account: {},
+        pkg: { uuid: '6a204da2-f970-11e7-be40-cba47f48e574' },
+        req_id: '27ba32f8-f96f-11e7-a569-7f7ffc56b89b'
+    }, function allowProvisionCb(err) {
+        t.ifErr(err, 'err');
+        t.end();
+    });
+});
+
+
+test('allowProvision with admin user',
+function (t) {
+    API.getActiveVmsForAccount = function () {
+        t.fail('should not be called');
+    };
+
+    var called = false;
+
+    PREPROVISION({
+        account: {
+            isAdmin: function () {
+                called = true;
+                return true;
+            }
+        },
+        pkg: PACKAGES[0],
+        req_id: '27ba32f8-f96f-11e7-a569-7f7ffc56b89b'
+    }, function allowProvisionCb(err) {
+        t.ifErr(err, 'err');
+        t.equal(called, true, 'isAdmin() was called');
+        t.end();
+    });
+});
+
+
+test('allowProvision with user more than a year old',
+function (t) {
+    API.getActiveVmsForAccount = function () {
+        t.fail('should not be called');
+    };
+
+    var days366ago = new Date(Date.now() - 366 * 24 * 60 * 60 * 1000);
+
+    PREPROVISION({
+        account: {
+            isAdmin: function () { return false; },
+            created_at: days366ago.toISOString()
+        },
+        pkg: PACKAGES[0],
+        req_id: '27ba32f8-f96f-11e7-a569-7f7ffc56b89b'
+    }, function allowProvisionCb(err) {
+        t.ok(err, 'err');
+        t.equal(err.statusCode, 403, 'statusCode');
+        t.equal(err.restCode, 'NotAuthorized', 'message');
+        t.equal(err.message, 'QuotaExceeded; free tier offering is limited ' +
+            'to a single instance for the first year after the account has ' +
+            'been created', 'NotAuthorized');
+        t.end();
+    });
+});
+
+
+test('allowProvision with a matching free VMs',
+function (t) {
+    var called = false;
+
+    API.getActiveVmsForAccount = function (args, cb) {
+        t.equal(args.account.uuid, '4126713e-f974-11e7-b896-0724b8f2d98b',
+            'account uuid');
+        t.equal(args.fields, 'billing_id', 'billing_id');
+
+        called = true;
+
+        cb(null, [ {
+            billing_id: '5ec1780a-f975-11e7-a5d3-fb5712313c38'
+        }, {
+            billing_id: PACKAGES[1].uuid
+        } ]);
+    };
+
+    var days364ago = new Date(Date.now() - 364 * 24 * 60 * 60 * 1000);
+
+    PREPROVISION({
+        account: {
+            uuid: '4126713e-f974-11e7-b896-0724b8f2d98b',
+            isAdmin: function () { return false; },
+            created_at: days364ago.toISOString()
+        },
+        pkg: PACKAGES[0],
+        req_id: '27ba32f8-f96f-11e7-a569-7f7ffc56b89b'
+    }, function allowProvisionCb(err) {
+        t.ok(err, 'err');
+        t.equal(err.statusCode, 403, 'statusCode');
+        t.equal(err.restCode, 'NotAuthorized', 'message');
+        t.equal(err.message, 'QuotaExceeded; free tier offering is limited ' +
+            'to a single instance for the first year after the account has ' +
+            'been created', 'NotAuthorized');
+
+        t.equal(called, true, 'getActiveVmsForAccount called');
+
+        t.end();
+    });
+});
+
+
+test('allowProvision with no matching free VMs',
+function (t) {
+    API.getActiveVmsForAccount = function (args, cb) {
+        cb(null, [ {
+            billing_id: '5ec1780a-f975-11e7-a5d3-fb5712313c38'
+        }, {
+            billing_id: '39c51e5c-f976-11e7-8a57-d77f3551fb13'
+        } ]);
+    };
+
+    PREPROVISION({
+        account: {
+            uuid: '4126713e-f974-11e7-b896-0724b8f2d98b',
+            isAdmin: function () { return false; },
+            created_at: new Date().toISOString()
+        },
+        pkg: PACKAGES[0],
+        req_id: '27ba32f8-f96f-11e7-a569-7f7ffc56b89b'
+    }, function allowProvisionCb(err) {
+        t.ifErr(err, 'err');
+        t.end();
+    });
+});
+
+
+test('allowProvision - badargs',
+function (t) {
+    try {
+        PREPROVISION();
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'opts (object) is required', 'err message');
+    }
+
+    try {
+        PREPROVISION({});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'opts.account (object) is required', 'err message');
+    }
+
+    try {
+        PREPROVISION({
+            account: {}
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'opts.pkg (object) is required', 'err message');
+    }
+
+    try {
+        PREPROVISION({
+            account: {},
+            pkg: PACKAGES[0]
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'opts.req_id (uuid) is required', 'err message');
+    }
+
+    try {
+        PREPROVISION({
+            account: {},
+            pkg: PACKAGES[0],
+            req_id: '27ba32f8-f96f-11e7-a569-7f7ffc56b89b'
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cb (func) is required', 'err message');
+    }
+
+    t.end();
+});
diff --git a/test/plugins/machine-email.test.js b/test/plugins/machine-email.test.js
new file mode 100644
index 0000000..4c196e9
--- /dev/null
+++ b/test/plugins/machine-email.test.js
@@ -0,0 +1,198 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var test = require('tape').test;
+var plugin = require('../../plugins/machine_email');
+
+
+// --- Globals
+
+
+var API = {
+    log: {
+        info: function () {},
+        debug: function () {},
+        error: function () {}
+    }
+};
+
+var SENDER;
+
+
+// --- Tests
+
+
+test('setup postProvision without api',
+function (t) {
+    try {
+        plugin.postProvision();
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'api (object) is required', 'err message');
+    }
+
+    t.end();
+});
+
+
+test('Setup postProvision without cfg',
+function (t) {
+    try {
+        plugin.postProvision(API);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cfg (object) is required', 'err message');
+    }
+
+    t.end();
+});
+
+
+test('Setup postProvision with invalid cfg',
+function (t) {
+    try {
+        plugin.postProvision(API, {
+            smtp: 'foo'
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message,
+            'cfg.smtp || cfg.sendmaili || cfg.test (object) is required',
+            'err message');
+    }
+
+    try {
+        plugin.postProvision(API, {
+            smtp: {}
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cfg.from (string) is required');
+    }
+
+    try {
+        plugin.postProvision(API, {
+            smtp: {},
+            from: 'foobar'
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cfg.from (email) is required');
+    }
+
+    try {
+        plugin.postProvision(API, {
+            smtp: {},
+            from: 'sender@example.com'
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cfg.subject (string) is required');
+    }
+
+    try {
+        plugin.postProvision(API, {
+            smtp: {},
+            from: 'sender@example.com',
+            subject: 'test subject'
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'cfg.text (string) is required');
+    }
+
+    t.end();
+});
+
+
+test('Setup postProvision with smtp',
+function (t) {
+    plugin.postProvision(API, {
+        from: 'sender@example.com',
+        subject: 'test subject',
+        text: 'test body',
+        smtp: {
+            service: 'Gmail',
+            auth: {
+                user: 'example@example.com',
+                pass: 'userpass'
+            }
+        }
+    });
+
+    t.end();
+});
+
+
+test('Setup postProvision with sendmail',
+function (t) {
+    plugin.postProvision(API, {
+        from: 'sender@example.com',
+        subject: 'test subject',
+        text: 'test body',
+        sendmail: {
+            path: '/usr/sbin/sendmail'
+        }
+    });
+
+    t.end();
+});
+
+
+test('Setup postProvision with test stub',
+function (t) {
+    SENDER = plugin.postProvision(API, {
+        from: 'sender@example.com',
+        subject: 'test subject',
+        text: 'test body',
+        test: {
+            sendMail: function sendMailStub(obj, cb) {
+                cb(null, obj);
+            }
+        }
+    });
+
+    t.end();
+});
+
+
+test('postProvision',
+function (t) {
+    SENDER({
+        account: { email: 'receiver@example.com' }
+    }, function senderCb(err) {
+        t.ifErr(err, 'err');
+        t.end();
+    });
+});
+
+
+test('postProvision - badargs',
+function (t) {
+    try {
+        SENDER({}, function senderCb() {
+            t.fail('should not cb');
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'opts.account (object) is required');
+    }
+
+    try {
+        SENDER({ account: {} }, function sender2Cb() {
+            t.fail('should not cb');
+        });
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.equal(e.message, 'opts.account.email (string) is required');
+    }
+
+    t.end();
+});
diff --git a/test/plugins/plugin-manager.test.js b/test/plugins/plugin-manager.test.js
new file mode 100644
index 0000000..388ed31
--- /dev/null
+++ b/test/plugins/plugin-manager.test.js
@@ -0,0 +1,935 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var bunyan = require('bunyan');
+var clients = require('sdc-clients');
+var fs = require('fs');
+var restify = require('restify');
+var test = require('tape').test;
+
+var PluginManager = require('../../lib/plugin-manager');
+
+
+
+// --- Globals
+
+
+var CONFIG_PATH = __dirname + '/../../etc/cloudapi.cfg';
+
+var CLIENTS;
+var CONFIG;
+var LOG;
+var ACCOUNT;
+
+
+// --- Helpers
+
+
+function getManager() {
+    return new PluginManager({
+        clients: CLIENTS,
+        config: CONFIG,
+        log: LOG
+    });
+}
+
+
+// --- Tests
+
+
+test('setup',
+function (t) {
+    LOG = new bunyan.createLogger({
+        level: process.env.LOG_LEVEL || 'warn',
+        name: 'plugintest',
+        stream: process.stderr,
+        serializers: restify.bunyan.serializers
+    });
+
+    CONFIG = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf8'));
+
+    var imgapi = new clients.IMGAPI({
+        url: process.env.IMGAPI_URL || CONFIG.imgapi.url,
+        retry: { retries: 1, minTimeout: 1000 },
+        log: LOG,
+        agent: false
+    });
+
+    var napi = new clients.NAPI({
+        url: process.env.NAPI_URL || CONFIG.napi.url,
+        retry: { retries: 1, minTimeout: 1000 },
+        log: LOG,
+        agent: false
+    });
+
+    var vmapi = new clients.VMAPI({
+        url: process.env.VMAPI_URL || CONFIG.vmapi.url,
+        retry: { retries: 1, minTimeout: 1000 },
+        log: LOG,
+        agent: false
+    });
+
+    CLIENTS = {
+        imgapi: imgapi,
+        napi: napi,
+        vmapi: vmapi
+    };
+
+    vmapi.listVms({ state: 'active' }, function listVmsCb(err, vms) {
+        t.ifErr(err, 'err');
+
+        ACCOUNT = { uuid: vms[0].owner_uuid };
+        t.ok(ACCOUNT.uuid, 'ACCOUNT.uuid');
+
+        t.end();
+    });
+});
+
+
+test('API - constants',
+function (t) {
+    var manager = getManager();
+
+    t.ok(CONFIG.datacenter_name, 'CONFIG.datacenter_name');
+    t.deepEqual(manager.api.datacenterName, CONFIG.datacenter_name, 'DC name');
+    t.deepEqual(manager.api.log, LOG, 'log');
+    t.deepEqual(manager.api.service, 'cloudapi', 'service');
+    t.ok(manager.api.NotAuthorizedError, 'NotAuthorizedError');
+
+    t.end();
+});
+
+
+test('API - getNapiNetworksForAccount',
+function (t) {
+    var manager = getManager();
+
+    manager.api.getNapiNetworksForAccount({
+        account: ACCOUNT,
+        req_id: '541908ea-f804-11e7-a291-9f547787b0f5'
+    }, function (err, networks) {
+        t.ifErr(err, 'err');
+
+        var badNets = networks.filter(function checkOwnerUuid(net) {
+            return !net.owner_uuid;
+        }).filter(function checkOwnerUuids(net) {
+            return net.owner_uuids &&
+                net.owner_uuids.indexOf(ACCOUNT.uuid) == -1;
+        });
+
+        t.deepEqual(badNets, [], 'no unexpected networks');
+
+        t.end();
+    });
+});
+
+
+test('API - getNapiNetworksForAccount badargs',
+function (t) {
+    var manager = getManager();
+
+    try {
+        manager.api.getNapiNetworksForAccount({
+            req_id: '541908ea-f804-11e7-a291-9f547787b0f5'
+        }, function () {});
+
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.name, 'AssertionError', 'assertion');
+        t.deepEqual(e.operator, '===', 'assertion check');
+        t.deepEqual(e.expected, 'object', 'assertion expected');
+        t.deepEqual(e.actual, 'undefined', 'assertion actual');
+    }
+
+    try {
+        manager.api.getNapiNetworksForAccount({
+            account: ACCOUNT
+        }, function () {});
+
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.name, 'AssertionError', 'assertion');
+        t.deepEqual(e.operator, 'isUUID', 'assertion check');
+        t.deepEqual(e.expected, 'uuid', 'assertion expected');
+        t.deepEqual(e.actual, 'undefined', 'assertion actual');
+    }
+
+    t.end();
+});
+
+
+test('API - getActiveVmsForAccount',
+function (t) {
+    var manager = getManager();
+
+    manager.api.getActiveVmsForAccount({
+        account: ACCOUNT,
+        req_id: '541908ea-f804-11e7-a291-9f547787b0f5'
+    }, function getActiveCb(err, vms) {
+        t.ifErr(err, 'err');
+
+        CLIENTS.vmapi.listVms({
+            owner_uuid: ACCOUNT.uuid,
+            state: 'active'
+        }, function listVmsCb(err2, vmapiVms) {
+            t.ifErr(err2, 'err2');
+            t.deepEqual(vms, vmapiVms, 'vms');
+            t.end();
+        });
+    });
+});
+
+
+test('API - getActiveVmsForAccount with brand',
+function (t) {
+    var manager = getManager();
+
+    manager.api.getActiveVmsForAccount({
+        account: ACCOUNT,
+        req_id: '541908ea-f804-11e7-a291-9f547787b0f5',
+        brand: 'joyent'
+    }, function getActiveCb(err, vms) {
+        t.ifErr(err, 'err');
+
+        CLIENTS.vmapi.listVms({
+            owner_uuid: ACCOUNT.uuid,
+            state: 'active',
+            brand: 'joyent'
+        }, function listVmsCb(err2, vmapiVms) {
+            t.ifErr(err2, 'err2');
+            t.deepEqual(vms, vmapiVms, 'vms');
+            t.end();
+        });
+    });
+});
+
+
+test('API - getActiveVmsForAccount with fields',
+function (t) {
+    var manager = getManager();
+
+    manager.api.getActiveVmsForAccount({
+        account: ACCOUNT,
+        req_id: '541908ea-f804-11e7-a291-9f547787b0f5',
+        fields: 'uuid,alias'
+    }, function getActiveCb(err, vms) {
+        t.ifErr(err, 'err');
+
+        CLIENTS.vmapi.listVms({
+            owner_uuid: ACCOUNT.uuid,
+            state: 'active',
+            fields: 'uuid,alias'
+        }, function listVmsCb(err2, vmapiVms) {
+            t.ifErr(err2, 'err2');
+            t.deepEqual(vms, vmapiVms, 'vms');
+            t.end();
+        });
+    });
+});
+
+
+test('API - getActiveVmsForAccount badargs',
+function (t) {
+    var manager = getManager();
+
+    try {
+        manager.api.getActiveVmsForAccount({
+            req_id: '541908ea-f804-11e7-a291-9f547787b0f5'
+        }, function () {});
+
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.name, 'AssertionError', 'assertion');
+        t.deepEqual(e.operator, '===', 'assertion check');
+        t.deepEqual(e.expected, 'object', 'assertion expected');
+        t.deepEqual(e.actual, 'undefined', 'assertion actual');
+    }
+
+    try {
+        manager.api.getActiveVmsForAccount({
+            account: ACCOUNT
+        }, function () {});
+
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.name, 'AssertionError', 'assertion');
+        t.deepEqual(e.operator, 'isUUID', 'assertion check');
+        t.deepEqual(e.expected, 'uuid', 'assertion expected');
+        t.deepEqual(e.actual, 'undefined', 'assertion actual');
+    }
+
+    try {
+        manager.api.getActiveVmsForAccount({
+            account: ACCOUNT,
+            req_id: '541908ea-f804-11e7-a291-9f547787b0f5',
+            fields: 99
+        }, function () {});
+
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.name, 'AssertionError', 'assertion');
+        t.deepEqual(e.operator, '===', 'assertion check');
+        t.deepEqual(e.expected, 'string', 'assertion expected');
+        t.deepEqual(e.actual, 'number', 'assertion actual');
+    }
+
+    try {
+        manager.api.getActiveVmsForAccount({
+            account: ACCOUNT,
+            req_id: '541908ea-f804-11e7-a291-9f547787b0f5',
+            brand: 99
+        }, function () {});
+
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.name, 'AssertionError', 'assertion');
+        t.deepEqual(e.operator, '===', 'assertion check');
+        t.deepEqual(e.expected, 'string', 'assertion expected');
+        t.deepEqual(e.actual, 'number', 'assertion actual');
+    }
+
+    t.end();
+});
+
+
+test('API - getImage',
+function (t) {
+    var manager = getManager();
+
+    CLIENTS.imgapi.listImages({}, function listImagesCb(err, images) {
+        t.ifErr(err, 'err');
+
+        manager.api.getImage(images[0].uuid, function getCb(err2, img) {
+            t.ifErr(err2, 'err2');
+            t.deepEqual(img, images[0], 'images');
+            t.end();
+        });
+    });
+});
+
+
+test('API - getImage badargs',
+function (t) {
+    var manager = getManager();
+
+    try {
+        manager.api.getImage('', function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.name, 'AssertionError', 'assertion');
+        t.deepEqual(e.operator, 'isUUID', 'assertion check');
+        t.deepEqual(e.expected, 'uuid', 'assertion expected');
+        t.deepEqual(e.actual, 'string', 'assertion actual');
+    }
+
+    t.end();
+});
+
+
+test('API - listImage',
+function (t) {
+    var manager = getManager();
+
+    CLIENTS.imgapi.listImages({}, function listImagesCb(err, images) {
+        t.ifErr(err, 'err');
+
+        manager.api.listImages({
+            req_id: 'b8cca400-f9ca-11e7-8a6e-83fc53229350'
+        }, function listCb(err2, imgs) {
+            t.ifErr(err2, 'err2');
+            t.deepEqual(imgs, images, 'images');
+            t.end();
+        });
+    });
+});
+
+
+test('API - listImage badargs',
+function (t) {
+    var manager = getManager();
+
+    try {
+        manager.api.listImages(undefined, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts (object) is required', 'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.api.listImages({},  undefined);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.req_id (uuid) is required', 'e.message');
+        t.deepEqual(e.expected, 'uuid', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+
+    try {
+        manager.api.listImages({
+            req_id: 'b8cca400-f9ca-11e7-8a6e-83fc53229350'
+        },  undefined);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'cb (func) is required', 'e.message');
+        t.deepEqual(e.expected, 'func', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    t.end();
+});
+
+
+test('filterListNetworks',
+function (t) {
+    var manager = getManager();
+
+    var called = 0;
+    manager.hooks.filterListNetworks = [
+        function (opts, nets) {
+            called += 1;
+            t.deepEqual({ account: {} }, opts, 'opts');
+            t.deepEqual(nets, [1, 2, 3], 'nets');
+            return [1, 2];
+        },
+        function (opts, nets) {
+            called += 1;
+            t.deepEqual({ account: {} }, opts, 'opts');
+            t.deepEqual(nets, [1, 2], 'nets');
+            return [1, 2];
+        }
+    ];
+
+    var networks = manager.filterListNetworks({ account: {} }, [1, 2, 3]);
+    t.deepEqual(networks, [1, 2], 'networks');
+    t.equal(called, 2, 'both funcs called');
+
+    t.end();
+});
+
+
+test('filterListNetworks - no plugins',
+function (t) {
+    var manager = getManager();
+    var nets = manager.filterListNetworks({ account: {} }, [1, 2, 3]);
+    t.deepEqual(nets, [1, 2, 3], 'no filtering');
+    t.end();
+});
+
+
+test('filterListNetworks - badargs',
+function (t) {
+    var manager = getManager();
+
+    try {
+        manager.filterListNetworks(undefined, [1, 2, 3]);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts (object) is required', 'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.filterListNetworks({}, [1, 2, 3]);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.account (object) is required',
+            'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+
+    try {
+        manager.filterListNetworks({ account: {} }, undefined);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'networks (array) is required', 'e.message');
+        t.deepEqual(e.expected, 'array', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    t.end();
+});
+
+
+test('filterGetNetworksOrPools',
+function (t) {
+    var manager = getManager();
+
+    var called = 0;
+    manager.hooks.filterGetNetworksOrPools = [
+        function (opts, nets) {
+            called += 1;
+            t.deepEqual({ account: {} }, opts, 'opts');
+            t.deepEqual(nets, [1, 2, 3], 'nets');
+            return [1, 2];
+        },
+        function (opts, nets) {
+            called += 1;
+            t.deepEqual({ account: {} }, opts, 'opts');
+            t.deepEqual(nets, [1, 2], 'nets');
+            return [1, 2];
+        }
+    ];
+
+    var networks = manager.filterGetNetworksOrPools({ account: {} }, [1, 2, 3]);
+    t.deepEqual(networks, [1, 2], 'networks');
+    t.equal(called, 2, 'both funcs called');
+
+    t.end();
+});
+
+
+test('filterGetNetworksOrPools - no plugins',
+function (t) {
+    var manager = getManager();
+    var nets = manager.filterGetNetworksOrPools({ account: {} }, [1, 2, 3]);
+    t.deepEqual(nets, [1, 2, 3], 'no filtering');
+    t.end();
+});
+
+
+test('filterGetNetworksOrPools - badargs',
+function (t) {
+    var manager = getManager();
+
+    try {
+        manager.filterGetNetworksOrPools(undefined, [1, 2, 3]);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts (object) is required', 'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.filterGetNetworksOrPools({}, [1, 2, 3]);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.account (object) is required',
+            'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.filterGetNetworksOrPools({ account: {} }, undefined);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'networks (array) is required', 'e.message');
+        t.deepEqual(e.expected, 'array', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    t.end();
+});
+
+
+test('findOwnerExternalNetwork',
+function (t) {
+    var manager = getManager();
+
+    var called = 0;
+    manager.hooks.findOwnerExternalNetwork = [
+        function (opts, next) {
+            called += 1;
+            t.deepEqual(opts, {
+                account: {},
+                req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+            }, 'opts');
+            t.equal(typeof (next), 'function', 'next');
+            next(new Error());
+        },
+        function (opts, next) {
+            called += 1;
+            t.deepEqual(opts, {
+                account: {},
+                req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+            }, 'opts');
+            t.equal(typeof (next), 'function', 'next');
+            next(null, { test: true });
+        },
+        function (opts, next) {
+            called += 1;
+            t.fail('code should be unreachable');
+            next();
+        }
+    ];
+
+    manager.findOwnerExternalNetwork({
+        account: {},
+        req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+    }, function extCb(err, net) {
+        t.deepEqual(net, { test: true }, 'networks');
+        t.equal(called, 2, 'two funcs called');
+        t.end();
+    });
+});
+
+
+test('findOwnerExternalNetwork - no plugins',
+function (t) {
+    var manager = getManager();
+    manager.findOwnerExternalNetwork({
+        account: {},
+        req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+    }, function extCb(err, net) {
+        t.ifErr(err, 'err');
+        t.equal(net, undefined, 'net');
+        t.end();
+    });
+});
+
+
+test('findOwnerExternalNetwork - badargs',
+function (t) {
+    var manager = getManager();
+
+    try {
+        manager.findOwnerExternalNetwork(undefined, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts (object) is required', 'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.findOwnerExternalNetwork({}, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.account (object) is required',
+            'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.findOwnerExternalNetwork({
+            account: {}
+        }, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.req_id (uuid) is required',
+            'e.message');
+        t.deepEqual(e.expected, 'uuid', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+
+    try {
+        manager.findOwnerExternalNetwork({
+            account: {},
+            req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+        }, undefined);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'cb (func) is required', 'e.message');
+        t.deepEqual(e.expected, 'func', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    t.end();
+});
+
+
+test('allowProvision - pass',
+function (t) {
+    var manager = getManager();
+
+    var called = 0;
+    manager.hooks.allowProvision = [
+        function (opts, next) {
+            called += 1;
+            t.deepEqual(opts, {
+                account: {},
+                image: {},
+                pkg: {},
+                req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+            }, 'opts');
+            t.equal(typeof (next), 'function', 'next');
+            next();
+        },
+        function (opts, next) {
+            called += 1;
+            t.deepEqual(opts, {
+                account: {},
+                image: {},
+                pkg: {},
+                req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+            }, 'opts');
+            t.equal(typeof (next), 'function', 'next');
+            next();
+        }
+    ];
+
+    manager.allowProvision({
+        account: {},
+        image: {},
+        pkg: {},
+        req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+    }, function extCb(err) {
+        t.ifErr(err, 'err');
+        t.equal(called, 2, 'two funcs called');
+        t.end();
+    });
+});
+
+
+test('allowProvision - fail',
+function (t) {
+    var manager = getManager();
+
+    var called = 0;
+    manager.hooks.allowProvision = [
+        function (opts, next) {
+            called += 1;
+            t.deepEqual(opts, {
+                account: {},
+                image: {},
+                pkg: {},
+                req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+            }, 'opts');
+            t.equal(typeof (next), 'function', 'next');
+            next(new Error());
+        },
+        function (opts, next) {
+            called += 1;
+            t.fail('code should be unreachable');
+            next();
+        }
+    ];
+
+    manager.allowProvision({
+        account: {},
+        image: {},
+        pkg: {},
+        req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+    }, function extCb(err) {
+        t.ok(err, 'err');
+        t.equal(called, 1, 'one func called');
+        t.end();
+    });
+});
+
+
+test('allowProvision - no plugins',
+function (t) {
+    var manager = getManager();
+    manager.allowProvision({
+        account: {},
+        image: {},
+        pkg: {},
+        req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+    }, function extCb(err) {
+        t.ifErr(err, 'err');
+        t.end();
+    });
+});
+
+
+test('allowProvision - badargs',
+function (t) {
+    var manager = getManager();
+
+    try {
+        manager.allowProvision(undefined, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts (object) is required', 'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.allowProvision({}, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.account (object) is required',
+            'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.allowProvision({
+            account: {}
+        }, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.image (object) is required', 'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.allowProvision({
+            account: {},
+            image: {}
+        }, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.pkg (object) is required', 'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.allowProvision({
+            account: {},
+            image: {},
+            pkg: {}
+        }, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.req_id (uuid) is required', 'e.message');
+        t.deepEqual(e.expected, 'uuid', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.allowProvision({
+            account: {},
+            image: {},
+            pkg: {},
+            req_id: '03a19052-f9e0-11e7-bc63-1b41742f3bd0'
+        }, undefined);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'cb (func) is required', 'e.message');
+        t.deepEqual(e.expected, 'func', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    t.end();
+});
+
+
+test('postProvision',
+function (t) {
+    var manager = getManager();
+
+    var called = 0;
+    manager.hooks.postProvision = [
+        function (opts, next) {
+            called += 1;
+            next(new Error());
+        },
+        function (opts, next) {
+            called += 1;
+            next();
+        }
+    ];
+
+    manager.postProvision({
+        account: {},
+        instance: {},
+        req_id: '06ad0a72-f983-11e7-b781-63a5e1be85ea'
+    }, function extCb(err) {
+        t.ifErr(err, 'err');
+        t.equal(called, 2, 'two funcs called');
+        t.end();
+    });
+});
+
+
+test('postProvision - no plugins',
+function (t) {
+    var manager = getManager();
+    manager.postProvision({
+        account: {},
+        instance: {},
+        req_id: '06ad0a72-f983-11e7-b781-63a5e1be85ea'
+    }, function extCb(err) {
+        t.ifErr(err, 'err');
+        t.end();
+    });
+});
+
+
+test('postProvision - badargs',
+function (t) {
+    var manager = getManager();
+
+    try {
+        manager.postProvision(undefined, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts (object) is required', 'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.postProvision({
+        }, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.account (object) is required',
+            'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.postProvision({
+            account: {}
+        }, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.instance (object) is required',
+            'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.postProvision({
+            account: {}
+        }, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.instance (object) is required',
+            'e.message');
+        t.deepEqual(e.expected, 'object', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.postProvision({
+            account: {},
+            instance: {}
+        }, function () {});
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'opts.req_id (uuid) is required', 'e.message');
+        t.deepEqual(e.expected, 'uuid', 'e.expected');
+        t.deepEqual(e.actual, 'undefined', 'e.actual');
+    }
+
+    try {
+        manager.postProvision({
+            account: {},
+            instance: {},
+            req_id: '06ad0a72-f983-11e7-b781-63a5e1be85ea'
+        }, undefined);
+        t.fail('exception not thrown');
+    } catch (e) {
+        t.deepEqual(e.message, 'cb (func) is required', 'e.message');
+        t.deepEqual(e.expected, 'func', 'assertion expected');
+        t.deepEqual(e.actual, 'undefined', 'assertion actual');
+    }
+
+    t.end();
+});
diff --git a/test/plugins/provision-limits.test.js b/test/plugins/provision-limits.test.js
new file mode 100644
index 0000000..c3d85e9
--- /dev/null
+++ b/test/plugins/provision-limits.test.js
@@ -0,0 +1,1164 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+var test = require('tape').test;
+var clone = require('jsprim').deepCopy;
+var plugin = require('../../plugins/provision_limits');
+var restify = require('restify');
+
+
+// --- Globals
+
+
+var ACCOUNT = {
+    uuid: 'd987aa8e-bfa3-11e7-b71c-28cfe91f7d53',
+    isAdmin: function () { return false; }
+};
+
+var API = {
+    getImage: function () {},
+    listImages: function () {},
+    getActiveVmsForAccount: function () {},
+    datacenterName: 'testdc',
+    service: 'cloudapi',
+    NotAuthorizedError: restify.NotAuthorizedError,
+    log: {
+        debug: function () {},
+        info: function () {},
+        trace: function () {},
+        warn: function () {}
+    }
+};
+
+var IMAGE = {
+    uuid: '4cae467a-bfa5-11e7-ae02-28cfe91f7d53',
+    name: 'testimage',
+    type: 'lx-dataset',
+    os: 'other'
+};
+
+var REQ_ID = '8882779e-f9ab-11e7-a697-93c18b2a37ef';
+
+
+// --- Helpers
+
+
+function check1(t, cfgLimits, ufdsLimits, tenant, vms, fields, shouldSucceed) {
+    var api = clone(API);
+    api.getImage = function () {
+        t.fail('No image should be needed');
+    };
+    api.listImages = function () {
+        t.fail('No images should be loaded');
+    };
+    api.getActiveVmsForAccount = function (args, cb) {
+        t.equal(args.account.uuid, ACCOUNT.uuid, 'account uuid should match');
+        t.equal(args.fields, fields, 'fields should match');
+        return cb(null, vms);
+    };
+
+    var allowProvision = plugin.allowProvision(api, cfgLimits);
+
+    var account = clone(ACCOUNT);
+    account.tenant = tenant;
+    account.listLimits = function (cb) {
+        return cb(null, ufdsLimits);
+    };
+
+    var opts = {
+        account: account,
+        image: {
+            image_uuid: IMAGE.uuid
+        },
+        pkg: {
+            max_physical_memory: 256,
+            quota: 10
+        },
+        req_id: REQ_ID
+    };
+
+    allowProvision(opts, function (err) {
+        if (shouldSucceed) {
+            t.ifError(err, 'Provision should succeeed');
+        } else {
+            t.ok(err, 'Provision should fail');
+        }
+
+        t.end();
+    });
+}
+
+
+function check2(t, limits, vms, listImages, shouldSucceed) {
+    var api = clone(API);
+    api.getImage = function (imgUuid, cb) {
+        t.equal(imgUuid, IMAGE.uuid, 'imgUuid is present');
+        t.ok(cb, 'cb is present');
+        return cb(null, IMAGE);
+    };
+    api.listImages = listImages;
+    api.getActiveVmsForAccount = function (args, cb) {
+        t.equal(args.account.uuid, ACCOUNT.uuid, 'account uuid should match');
+        return cb(null, vms);
+    };
+
+    var allowProvision = plugin.allowProvision(api, { defaults: limits });
+
+    var account = clone(ACCOUNT);
+    account.listLimits = function (cb) {
+        return cb(null, []);
+    };
+
+    function ImageV2(imageUuid) {
+        this.image_uuid = imageUuid;
+        return this;
+    }
+
+    var opts = {
+        account: account,
+        image: new ImageV2(IMAGE.uuid),
+        pkg: {
+            max_physical_memory: 256,
+            quota: 10
+        },
+        req_id: REQ_ID
+    };
+
+    allowProvision(opts, function (err) {
+        if (shouldSucceed) {
+            t.ifError(err, 'Provision should succeeed');
+        } else {
+            t.ok(err, 'Provision should fail');
+        }
+
+        t.end();
+    });
+}
+
+
+// --- Tests
+
+
+test('Setup allowProvision without api',
+function (t) {
+    try {
+        plugin.allowProvision();
+    } catch (e) {
+        t.equal(e.message, 'api (object) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup allowProvision without cfg',
+function (t) {
+    try {
+        plugin.allowProvision(API);
+    } catch (e) {
+        t.equal(e.message, 'cfg (object) is required', 'err message');
+        t.end();
+    }
+});
+
+
+test('Setup allowProvision with invalid cfg',
+function (t) {
+    try {
+        plugin.allowProvision(API, { accounts: 'foo' });
+    } catch (e) {
+        t.equal(e.message, 'cfg.defaults ([object]) is required', 'err msg');
+        t.end();
+    }
+});
+
+
+test('Setup allowProvision with valid cfg',
+function (t) {
+    var allowProvision = plugin.allowProvision(API, { defaults: [] });
+    t.equal(typeof (allowProvision), 'function', 'func type');
+    t.equal(allowProvision.name, 'checkProvisionLimits', 'func name');
+    t.end();
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/one VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/two VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - unknown tenant/no ufdsLimits/one VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'supercalifragilisticexpialidocious';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - unknown tenant/no ufdsLimits/two VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'supercalifragilisticexpialidocious';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+
+test('allowProvision - tenant/no ufdsLimits/two VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - tenant/no ufdsLimits/three VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/no VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/one large VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - no tenant/no ufdsLimits/one large VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - tenant/no ufdsLimits/no VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - tenant/no ufdsLimits/two large VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 976 },
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields,  true);
+});
+
+
+test('allowProvision - tenant/no ufdsLimits/two large VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 976 },
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 }, { value: 1024, by: 'ram' } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/ufdsLimits/three VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [
+        { datacenter: API.datacenterName, limit: '{"value": 4}' }
+    ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/ufdsLimits/four VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [
+        { datacenter: API.datacenterName, limit: '{"value": 4}' }
+    ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - no tenant/different DC ufdsLimits/three VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [
+        { datacenter: 'lostinspaaace', limit: '{"value": 4}' }
+    ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - tenant/multiple ufdsLimits/three VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [ {
+        datacenter: API.datacenterName,
+        limit: ['{"value": 4}', '{"value": 2000, "by": "ram"}']
+    } ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: []
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - tenant/ufdsLimits/four VMs',
+function (t) {
+    var fields = 'ram';
+    var tenant = 'small';
+    var ufdsLimits = [
+        { datacenter: API.datacenterName, limit: '{"value": 4}' }
+    ];
+    var vms = [
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 },
+        { ram: 256 }
+    ];
+    var cfg = {
+        defaults: [ { value: 2 } ],
+        small: [ { value: 3 } ]
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - no tenant/multiple ufdsLimits/one large VM',
+function (t) {
+    var fields = 'ram';
+    var tenant = undefined;
+    var ufdsLimits = [ {
+        datacenter: API.datacenterName,
+        limit: ['{"value": 4}', '{"value": 2000, "by": "ram"}']
+    } ];
+    var vms = [
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: []
+    };
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - no tenant/multiple ufdsLimits/two large VMs',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [ {
+        datacenter: API.datacenterName,
+        limit: ['{"value": 4}', '{"value": 2000, "by": "ram"}']
+    } ];
+    var vms = [
+        { ram: 976 },
+        { ram: 976 }
+    ];
+    var cfg = {
+        defaults: []
+    };
+    var fields = 'ram';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - check by quota/small VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 50 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - check by quota/larger VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 60 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - check by quota/os wildcard/small VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 50 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'os', os: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - check by quota/os wildcard/larger VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 60 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'os', os: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - check by quota/image wildcard/small VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 50 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'os', os: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - check by quota/image wildcard/larger VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 60 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'os', os: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - check by quota/brand wildcard/small VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 50 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'brand', brand: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, true);
+});
+
+
+test('allowProvision - check by quota/brand wildcard/larger VM',
+function (t) {
+    var tenant = undefined;
+    var ufdsLimits = [];
+    var vms = [
+        { ram: 256, quota: 60 }
+    ];
+    var cfg = {
+        defaults: [ { value: 60, by: 'quota', check: 'brand', brand: 'any' } ]
+    };
+    var fields = 'quota';
+
+    check1(t, cfg, ufdsLimits, tenant, vms, fields, false);
+});
+
+
+test('allowProvision - count/os/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            os: 'other',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/os/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            os: 'other',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/different os/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'os', os: 'smartos' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', os: 'other' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/os/one VM same OS',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: 'd26e2a4c-bfb8-11e7-a0eb-28cfe91f7d53' }
+    ];
+    var limits = [
+        { value: 2, check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            os: 'other',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/os/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            os: 'other',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/os/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'os', os: 'other' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            os: 'other',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/image/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            name: 'testimage',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/image/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            name: 'testimage',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/different image/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 2, check: 'image', image: 'definitelynotwhatyouwant' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, { state: 'all', name: 'testimage' }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/image/one VM same image',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: 'd26e2a4c-bfb8-11e7-a0eb-28cfe91f7d53' }
+    ];
+    var limits = [
+        { value: 2, check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            name: 'testimage',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/image/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            name: 'testimage',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/image/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid },
+        { ram: 256, image_uuid: IMAGE.uuid }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'image', image: 'testimage' }
+    ];
+
+    function listImages(opts, cb) {
+        t.deepEqual(opts, {
+            state: 'all',
+            name: 'testimage',
+            req_id: '8882779e-f9ab-11e7-a697-93c18b2a37ef'
+        }, 'opts');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/brand/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 2, check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/brand/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' },
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 2, check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('allowProvision - count/different brand/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 2, check: 'brand', brand: 'joyent' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - count/brand/one VM same brand',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' },
+        { ram: 256, image_uuid: 'd26e2a4c-bfb8-11e7-a0eb-28cfe91f7d53',
+            brand: 'joyent' }
+    ];
+    var limits = [
+        { value: 2, check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/brand/one VM',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, true);
+});
+
+
+test('allowProvision - ram/brand/two VMs',
+function (t) {
+    var vms = [
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' },
+        { ram: 256, image_uuid: IMAGE.uuid, brand: 'lx' }
+    ];
+    var limits = [
+        { value: 512, by: 'ram', check: 'brand', brand: 'lx' }
+    ];
+
+    function listImages(opts, cb) {
+        t.fail('listImages() should not be called');
+        cb(null, [IMAGE]);
+    }
+
+    check2(t, limits, vms, listImages, false);
+});
+
+
+test('_convertFromCapi',
+function (t) {
+    var convertFromCapi = plugin._convertFromCapi;
+
+    var result = convertFromCapi(API.log, undefined);
+    t.deepEqual(result, []);
+
+    result = convertFromCapi(API.log, { limit: '{ "value": 2 }' });
+    t.deepEqual(result, [ { value: 2 } ]);
+
+    result = convertFromCapi(API.log, {
+        limit: [
+            '{ "value": 2 }',
+            'badjson',
+            '{ "value": 25, "by": "quota" }'
+        ]
+    });
+    t.deepEqual(result, [
+        { value: 2 },
+        { value: 25, by: 'quota' }
+    ]);
+
+    t.end();
+});
+
+
+test('_atoiValues',
+function (t) {
+    var atoiValues = plugin._atoiValues;
+
+    var result = atoiValues([
+        { value: 25,     by: 'ram'   },
+        { value: 1,      by: 'ram'   },
+        { value: -1,     by: 'quota' },
+        { value: '25',   by: 'quota' },
+        { value: 'xxxx', by: 'count' },
+        { value: '-1' }
+    ]);
+
+    t.deepEqual(result, [
+        { value: 25, by: 'ram'   },
+        { value: 1,  by: 'ram'   },
+        { value: -1, by: 'quota' },
+        { value: 25, by: 'quota' },
+        { value: 0,  by: 'count' },
+        { value: -1 }
+    ], 'atoiValues limits');
+
+    t.end();
+});
+
+
+test('_getBrand',
+function (t) {
+    var getBrand = plugin._getBrand;
+
+    var result = getBrand({
+        requirements: { brand: 'foo' },
+        type: 'docker'
+    });
+    t.equal(result, 'foo', 'getBrand results');
+
+    result = getBrand({ type: 'docker' });
+    t.equal(result, 'lx', 'getBrand results');
+
+    result = getBrand({ type: 'lx-dataset' });
+    t.equal(result, 'lx', 'getBrand results');
+
+    result = getBrand({ type: 'zone-dataset' });
+    t.equal(result, 'joyent', 'getBrand results');
+
+    result = getBrand({ type: 'zvol' });
+    t.equal(result, 'kvm', 'getBrand results');
+
+    result = getBrand({ type: 'foo' });
+    t.equal(result, undefined, 'getBrand results');
+
+    t.end();
+});
+
+
+test('_findMinimalFields',
+function (t) {
+    var findMinimalFields = plugin._findMinimalFields;
+
+    var result = findMinimalFields([
+        { value: 256, by: 'ram' },
+        { value: 256, by: 'ram' }
+    ]);
+    t.deepEqual(result, 'ram', 'findMinimalFields results');
+
+    result = findMinimalFields([
+        { value: 256, by: 'ram' },
+        { value: 256, by: 'ram' },
+        { value: 60,  by: 'quota' }
+    ]);
+    t.deepEqual(result, 'ram,quota', 'findMinimalFields results');
+
+    result = findMinimalFields([
+        { value: 60,  by: 'quota' },
+        { value: 60,  by: 'quota' }
+    ]);
+    t.deepEqual(result, 'quota', 'findMinimalFields results');
+
+    result = findMinimalFields([
+        { value: 60,  by: 'quota' },
+        { value: 5, check: 'os' }
+    ]);
+    t.deepEqual(result, undefined, 'findMinimalFields results');
+
+    result = findMinimalFields([
+        { value: 60,  by: 'quota' },
+        { value: 5, check: 'image' }
+    ]);
+    t.deepEqual(result, undefined, 'findMinimalFields results');
+
+    t.end();
+});
