From b8aadb6e19fe2448b7e44c6cc03429da54cf86c4 Mon Sep 17 00:00:00 2001
From: Dave Eddy <dave@daveeddy.com>
Date: Mon, 22 Apr 2019 16:24:46 -0400
Subject: [PATCH] joyent/boray#7 want sort, limit, and prefix support for
 listing buckets and objects

---
 src/bucket.rs | 40 ++++++++++++++++++++++++++++------------
 src/object.rs | 40 +++++++++++++++++++++++++++++-----------
 2 files changed, 57 insertions(+), 23 deletions(-)

diff --git a/src/bucket.rs b/src/bucket.rs
index 456d85c..88587cc 100644
--- a/src/bucket.rs
+++ b/src/bucket.rs
@@ -45,8 +45,12 @@ pub struct PutBucketPayload {
 
 #[derive(Serialize, Deserialize)]
 pub struct ListBucketsPayload {
-    owner : Uuid,
-    vnode : u64
+    owner   : Uuid,
+    vnode   : u64,
+    prefix  : String,
+    orderby : String,
+    limit   : u64,
+    offset  : u64
 }
 
 fn array_wrap(v: Value) -> Value {
@@ -124,13 +128,25 @@ pub fn list_handler(msg_id: u32,
         Err(_) => return Err(other_error("Failed to parse JSON data as payload for listbuckets function"))
     };
 
+    // TODO catch these as errors and return to the caller
+    assert!(payload.limit > 0);
+    assert!(payload.limit <= 1000);
+
+    match payload.orderby.as_ref() {
+        "created" | "name" => {},
+        _ => return Err(other_error("Unexpected value for payload.orderby"))
+    }
+
+    let prefix = format!("{}%", &payload.prefix);
+
     // Make db request and form response
     // TODO: make this call safe
     let conn = pool.get().unwrap();
     let txn = conn.transaction().unwrap();
-    let list_sql = list_sql(&payload.vnode);
+    let list_sql = list_sql(&payload.vnode, &payload.limit,
+        &payload.offset, &payload.orderby);
 
-    for row in txn.query(&list_sql, &[&payload.owner]).unwrap().iter() {
+    for row in txn.query(&list_sql, &[&payload.owner, &prefix]).unwrap().iter() {
         let resp = BucketResponse {
             id: row.get(0),
             owner: row.get(1),
@@ -274,14 +290,14 @@ fn put_sql(vnode: &u64) -> String {
        RETURNING id, owner, name, created"].concat()
 }
 
-/*
- * TODO: add a limit clause for eventual pagination.
- */
-fn list_sql(vnode: &u64) -> String {
-    ["SELECT id, owner, name, created \
-      FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket WHERE owner = $1"].concat()
+fn list_sql(vnode: &u64, limit: &u64, offset: &u64, orderby: &str) -> String {
+    format!("SELECT id, owner, name, created
+        FROM manta_bucket_{}.manta_bucket
+        WHERE owner = $1 AND name like $2
+        ORDER BY {} ASC
+        LIMIT {}
+        OFFSET {}",
+        vnode, orderby, limit, offset)
 }
 
 fn get(payload: GetBucketPayload, pool: &Pool<PostgresConnectionManager>)
diff --git a/src/object.rs b/src/object.rs
index a821c36..ce76d15 100644
--- a/src/object.rs
+++ b/src/object.rs
@@ -66,7 +66,11 @@ pub struct PutObjectPayload {
 pub struct ListObjectsPayload {
     owner     : Uuid,
     bucket_id : Uuid,
-    vnode     : u64
+    vnode     : u64,
+    prefix    : String,
+    orderby   : String,
+    limit     : u64,
+    offset    : u64
 }
 
 pub fn get_handler(msg_id: u32,
@@ -139,13 +143,25 @@ pub fn list_handler(msg_id: u32,
         Err(_) => return Err(other_error("Failed to parse JSON data as payload for listobjects function"))
     };
 
+    // TODO catch these as errors and return to the caller
+    assert!(payload.limit > 0);
+    assert!(payload.limit <= 1000);
+
+    match payload.orderby.as_ref() {
+        "created" | "name" => {},
+        _ => return Err(other_error("Unexpected value for payload.orderby"))
+    }
+
+    let prefix = format!("{}%", &payload.prefix);
+
     // Make db request and form response
     // TODO: make this call safe
     let conn = pool.get().unwrap();
     let txn = conn.transaction().unwrap();
-    let list_sql = list_sql(&payload.vnode);
+    let list_sql = list_sql(&payload.vnode, &payload.limit, &payload.offset,
+        &payload.orderby);
 
-    for row in txn.query(&list_sql, &[&payload.owner, &payload.bucket_id]).unwrap().iter() {
+    for row in txn.query(&list_sql, &[&payload.owner, &payload.bucket_id, &prefix]).unwrap().iter() {
         let content_md5_bytes: Vec<u8> = row.get(7);
         let content_md5 = base64::encode(&content_md5_bytes);
         let resp = ObjectResponse {
@@ -299,14 +315,16 @@ fn get_sql(vnode: &u64) -> String {
        AND name = $3"].concat()
 }
 
-// TODO add limits to this
-fn list_sql(vnode: &u64) -> String {
-    ["SELECT id, owner, bucket_id, name, created, modified, content_length, \
-      content_md5, content_type, headers, sharks, properties \
-      FROM manta_bucket_",
-     &vnode.to_string(),
-     &".manta_bucket_object WHERE owner = $1 \
-       AND bucket_id = $2"].concat()
+fn list_sql(vnode: &u64, limit: &u64, offset: &u64, orderby: &str) -> String {
+    format!("SELECT id, owner, bucket_id, name, created, modified, \
+        content_length, content_md5, content_type, headers, sharks, \
+        properties \
+        FROM manta_bucket_{}.manta_bucket_object
+        WHERE owner = $1 AND bucket_id = $2 AND name like $3
+        ORDER BY {} ASC
+        LIMIT {}
+        OFFSET {}",
+        vnode, orderby, limit, offset)
 }
 
 fn put(payload: PutObjectPayload, pool: &Pool<PostgresConnectionManager>)
-- 
2.21.0

