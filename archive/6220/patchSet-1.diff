commit 85e6c30a3005e43b8c89e58406e33b51e77e09e3
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2019-05-09T00:04:46+00:00 (5 months ago)
    
    TRITON-843 Add test suite to net-agent

diff --git a/Makefile b/Makefile
index 9f786e6..516cb8d 100644
--- a/Makefile
+++ b/Makefile
@@ -103,6 +103,7 @@ release: all deps docs $(SMF_MANIFESTS)
 	    $(TOP)/package.json \
 	    $(TOP)/sapi_manifests \
 	    $(TOP)/smf \
+	    $(TOP)/test \
 	    $(TOP)/npm \
 	    $(RELSTAGEDIR)/$(NAME)
 	cp -PR $(NODE_INSTALL) $(RELSTAGEDIR)/$(NAME)/node
diff --git a/lib/common.js b/lib/common.js
index 0184dd3..56292ab 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -11,10 +11,16 @@
 'use strict';
 
 var assert = require('assert-plus');
+var mod_forkexec = require('forkexec');
 var mod_jsprim = require('jsprim');
 var mod_mooremachine = require('mooremachine');
 var mod_util = require('util');
 
+// --- Globals
+
+var _versionCache = null;
+
+
 // --- Exports
 
 
@@ -40,6 +46,12 @@ function formatAggrId(cn_uuid, name) {
     return mod_util.format('%s-%s', cn_uuid, name);
 }
 
+function getNetAgentVersion() {
+    if (_versionCache === null) {
+        _versionCache = require('../package.json').version;
+    }
+    return _versionCache;
+}
 
 function hasChanged(fields, cur, old) {
     if (cur === old) {
@@ -55,6 +67,29 @@ function hasChanged(fields, cur, old) {
     });
 }
 
+function loadSysinfo(callback) {
+    mod_forkexec.forkExecWait({
+        argv: [ '/usr/bin/sysinfo' ],
+        includeStderr: true,
+        timeout: 0
+    }, function (err, info) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        var sysinfo;
+
+        try {
+            sysinfo = JSON.parse(info.stdout.trim());
+        } catch (e) {
+            callback(e);
+            return;
+        }
+
+        callback(null, sysinfo);
+    });
+}
 
 /**
  * This class encapsulates some of the common logic to net-agent's FSMs.
@@ -126,5 +161,7 @@ module.exports = {
     CommonFSM: CommonFSM,
     currentMillis: currentMillis,
     formatAggrId: formatAggrId,
-    hasChanged: hasChanged
+    getNetAgentVersion: getNetAgentVersion,
+    hasChanged: hasChanged,
+    loadSysinfo: loadSysinfo
 };
diff --git a/lib/net-agent.js b/lib/net-agent.js
index bcbb48e..d172305 100644
--- a/lib/net-agent.js
+++ b/lib/net-agent.js
@@ -94,14 +94,6 @@ var determineEventSource = require('./event-source');
 
 // --- Internal helpers
 
-var _versionCache = null;
-function getNetAgentVersion() {
-    if (_versionCache === null) {
-        _versionCache = require('../package.json').version;
-    }
-    return _versionCache;
-}
-
 function refreshFSM(_, fsm) {
     fsm.refresh();
 }
@@ -125,7 +117,7 @@ function NetAgent(options) {
     this.cn_uuid = options.cn_uuid;
     this.agent_uuid = options.agent_uuid;
     this.admin_uuid = options.admin_uuid;
-    this.version = getNetAgentVersion();
+    this.version = mod_common.getNetAgentVersion();
     this.vmadm = options.vmadm || vmadm;
 
     // Depending on the backend vmadm might be an object or a function.
diff --git a/lib/server-fsm.js b/lib/server-fsm.js
index 823b1b1..52db21a 100644
--- a/lib/server-fsm.js
+++ b/lib/server-fsm.js
@@ -12,7 +12,6 @@
 
 var assert = require('assert-plus');
 var mod_common = require('./common');
-var mod_forkexec = require('forkexec');
 var mod_jsprim = require('jsprim');
 var mod_util = require('util');
 
@@ -20,33 +19,6 @@ var mod_util = require('util');
 
 var VNIC_NAME_RE = /^([a-zA-Z0-9_]{0,31})[0-9]+$/;
 
-// --- Internal helpers
-
-function loadSysinfo(callback) {
-    mod_forkexec.forkExecWait({
-        argv: [ '/usr/bin/sysinfo' ],
-        includeStderr: true,
-        timeout: 0
-    }, function (err, info) {
-        if (err) {
-            callback(err);
-            return;
-        }
-
-        var sysinfo;
-
-        try {
-            sysinfo = JSON.parse(info.stdout.trim());
-        } catch (e) {
-            callback(e);
-            return;
-        }
-
-        callback(null, sysinfo);
-    });
-}
-
-
 // --- Exports
 
 function ServerFSM(opts) {
@@ -70,7 +42,7 @@ function ServerFSM(opts) {
      * Allow caller to pass in a function for loading sysinfo. Otherwise we'll
      * default to calling /usr/bin/sysinfo.
      */
-    this.loadSysinfo = opts.loadSysinfo || loadSysinfo;
+    this.loadSysinfo = opts.loadSysinfo || mod_common.loadSysinfo;
 
     mod_common.CommonFSM.call(this);
 }
diff --git a/test/integration/create-nics.test.js b/test/integration/create-nics.test.js
new file mode 100644
index 0000000..bd78b64
--- /dev/null
+++ b/test/integration/create-nics.test.js
@@ -0,0 +1,159 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019 Joyent, Inc.
+ */
+
+/*
+ * Tests that verify that locally created NICs (headnode NICs, core service
+ * zones created before NAPI existed, etc.) are created in NAPI.
+ */
+
+'use strict';
+
+var config = require('../lib/config');
+var log = require('../lib/log');
+var mod_common = require('../lib/common');
+var mod_jsprim = require('jsprim');
+var mod_net = require('../lib/net');
+var mod_nic = require('../lib/nic');
+var mod_vmadm = require('vmadm');
+var test = require('tape');
+
+// --- Globals
+
+var SYSINFO = null;
+var CN_UUID = config.cn_uuid;
+var ADMIN_OWNER = config.admin_uuid;
+var ADMIN_TAG = null;
+var NETWORK = null;
+
+// --- Setup
+
+test('Setup', function (t) {
+    t.plan(2);
+
+    t.test('Get sysinfo', function (t2) {
+        mod_common.loadSysinfo(function (err, sysinfo) {
+            if (mod_common.ifErr(t2, err, 'load sysinfo')) {
+                t2.end();
+                return;
+            }
+
+            SYSINFO = sysinfo;
+            ADMIN_TAG = sysinfo['Admin NIC Tag'] || 'admin';
+
+            t2.ok(sysinfo, 'loaded sysinfo');
+            t2.end();
+        });
+    });
+
+    t.test('Get admin network', function (t2) {
+        mod_net.get(t2, {
+            params: {
+                uuid: 'admin'
+            },
+            partialExp: {
+                name: 'admin'
+            }
+        }, function (err, net) {
+            if (mod_common.ifErr(t2, err, 'get network')) {
+                t2.end();
+                return;
+            }
+
+            NETWORK = net;
+
+            t2.end();
+        });
+    });
+});
+
+// --- Tests
+
+test('Headnode GZ NICs', function (t) {
+    t.plan(2);
+
+    var macs = [];
+
+    t.test('Get local NICs', function (t2) {
+        var pnics = SYSINFO['Network Interfaces'];
+        var vnics = SYSINFO['Virtual Network Interfaces'];
+
+        function pushMAC(_, nic) {
+            macs.push({ mac: nic['MAC Address'] });
+        }
+
+        mod_jsprim.forEachKey(pnics, pushMAC);
+        mod_jsprim.forEachKey(vnics, pushMAC);
+
+        t2.end();
+    });
+
+    t.test('Get NAPI NICs', function (t2) {
+        t2.notEqual(macs.length, 0, 'loaded nics');
+
+        mod_nic.list(t2, {
+            params: {
+                belongs_to_type: 'server',
+                belongs_to_uuid: CN_UUID,
+                owner_uuid: ADMIN_OWNER
+            },
+            present: macs
+        });
+    });
+});
+
+test('Triton zone NICs', function (t) {
+    t.plan(2);
+
+    var macs = [];
+
+    t.test('Get local NICs', function (t2) {
+        mod_vmadm.lookup({}, {
+            fields: [ 'nics' ],
+            log: log
+        }, function (err, vms) {
+            if (mod_common.ifErr(t2, err, 'list vms')) {
+                t2.end();
+                return;
+            }
+
+            function checkNIC(nic) {
+                if (nic.nic_tag === ADMIN_TAG) {
+                    t2.equal(nic.network_uuid, NETWORK.uuid,
+                        'NIC has backfilled "admin" network_uuid');
+                } else {
+                    t2.ok(nic.network_uuid,
+                        'NIC has backfilled network_uuid');
+                }
+
+                macs.push({ mac: nic.mac });
+            }
+
+            function checkVM(vm) {
+                vm.nics.forEach(checkNIC);
+            }
+
+            vms.forEach(checkVM);
+
+            t2.end();
+        });
+    });
+
+    t.test('Get NAPI NICs', function (t2) {
+        t2.notEqual(macs.length, 0, 'loaded nics');
+
+        mod_nic.list(t2, {
+            params: {
+                belongs_to_type: 'zone',
+                cn_uuid: CN_UUID
+            },
+            present: macs
+        });
+    });
+});
diff --git a/test/integration/napi-changes.test.js b/test/integration/napi-changes.test.js
new file mode 100644
index 0000000..b7f84ad
--- /dev/null
+++ b/test/integration/napi-changes.test.js
@@ -0,0 +1,750 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019 Joyent, Inc.
+ */
+
+/*
+ * Tests that verify that NIC changes made in NAPI are reflected locally.
+ */
+
+'use strict';
+
+var config = require('../lib/config');
+var log = require('../lib/log');
+var mod_common = require('../lib/common');
+var mod_forkexec = require('forkexec');
+var mod_jsprim = require('jsprim');
+var mod_net = require('../lib/net');
+var mod_nic = require('../lib/nic');
+var mod_uuid = require('uuid');
+var mod_vm = require('../lib/vm');
+var mod_vmadm = require('vmadm');
+var test = require('tape');
+
+// --- Globals
+
+var NAPI_TO_LOCAL_DELAY = 4000;
+var LOCAL_TO_NAPI_DELAY = 6000;
+
+var IMGADM = '/usr/sbin/imgadm';
+var IMAGE_SOURCE = 'https://images.joyent.com';
+var IMAGE_UUID = '915b500a-f147-11e7-a700-cfbbcabe6055';
+
+var FAKE_UUID = '00000000-dead-beef-badd-cafe00000000';
+
+var MTU = 1500;
+var NIC_TAG = 'external';
+var RESOLVERS1 = [ '8.8.8.8', '8.8.4.4' ];
+var RESOLVERS2 = [ '1.1.1.1' ];
+var SUBNET = '172.26.7.0/24';
+var NETMASK = '255.255.255.0';
+var GATEWAY1 = '172.26.7.1';
+var GATEWAY2 = '172.26.7.2';
+
+var IP1 = '172.26.7.7';
+var IP2 = '172.26.7.8';
+var IP3 = '172.26.7.9';
+var CIDR1 = '172.26.7.7/24';
+var CIDR2 = '172.26.7.8/24';
+var CIDR3 = '172.26.7.9/24';
+
+var INTERFACE1 = 'net0';
+var INTERFACE2 = 'net1';
+var INTERFACE3 = 'net2';
+var MAC1 = mod_common.randomMAC();
+var MAC2 = mod_common.randomMAC();
+var MAC3 = mod_common.randomMAC();
+
+var NET = null;
+var USER1 = mod_uuid.v4();
+var USER2 = mod_uuid.v4();
+var VM = null;
+
+
+// --- Helpers
+
+function createNIC(fields) {
+    return mod_jsprim.mergeObjects({
+        mac: MAC1,
+        interface: INTERFACE1,
+        nic_tag: NIC_TAG,
+        vlan_id: 0,
+        mtu: MTU,
+        ip: IP1,
+        ips: [ CIDR1 ],
+        netmask: NETMASK,
+        gateway: GATEWAY1,
+        gateways: [ GATEWAY1 ],
+        network_uuid: NET.uuid
+    }, fields);
+}
+
+
+// --- Setup
+
+test('Setup', function (t) {
+    t.plan(4);
+
+    t.test('Import test image', function (t2) {
+        mod_forkexec.forkExecWait({
+            argv: [ IMGADM, 'import', IMAGE_UUID, '-S', IMAGE_SOURCE ],
+            includeStderr: true,
+            timeout: 0
+        }, function (err) {
+            t2.ifErr(err, 'image imported');
+            t2.end();
+        });
+    });
+
+    t.test('Clean up previous test network', function (t2) {
+        mod_net.list(t2, {
+            params: {
+                name: 'net-agent-test'
+            }
+        }, function (err, nets) {
+            if (err || nets.length === 0) {
+                t2.end();
+                return;
+            }
+
+            mod_net.del(t2, { uuid: nets[0].uuid });
+        });
+    });
+
+    t.test('Clean up previous test VM', function (t2) {
+        mod_vmadm.lookup({ alias: 'net-agent-test' }, {
+            fields: [ 'uuid' ],
+            log: log
+        }, function (err, vms) {
+            if (err || vms.length === 0) {
+                t2.end();
+                return;
+            }
+
+            mod_vm.del(t2, { uuid: vms[0].uuid });
+        });
+    });
+
+    t.test('Create test network', function (t2) {
+        mod_net.create(t2, {
+            params: {
+                name: 'net-agent-test',
+                owner_uuids: [ USER1 ],
+                subnet: SUBNET,
+                gateway: GATEWAY1,
+                provision_start_ip: '172.26.7.3',
+                provision_end_ip: '172.26.7.100',
+                nic_tag: NIC_TAG,
+                vlan_id: 0,
+                mtu: MTU,
+                resolvers: RESOLVERS1
+            },
+            partialExp: {
+                name: 'net-agent-test',
+                owner_uuids: [ USER1 ],
+                subnet: SUBNET,
+                gateway: GATEWAY1,
+                resolvers: RESOLVERS1
+            }
+        }, function (err, net) {
+            if (mod_common.ifErr(t2, err, 'create network')) {
+                t2.end();
+                return;
+            }
+
+            NET = net;
+
+            t2.end();
+        });
+    });
+});
+
+
+// --- Tests
+
+test('Create VM', function (t) {
+    t.test('Create', function (t2) {
+        mod_vm.createAndGet(t2, {
+            params: {
+                owner_uuid: USER1,
+                brand: 'joyent-minimal',
+                image_uuid: IMAGE_UUID,
+                alias: 'net-agent-test',
+                hostname: 'net-agent-test',
+                max_physical_memory: 512,
+                quota: 10,
+                resolvers: RESOLVERS1,
+                nics: [
+                    {
+                        mac: MAC1,
+                        interface: INTERFACE1,
+                        nic_tag: NIC_TAG,
+                        vlan_id: 0,
+                        ips: [ CIDR1 ],
+                        gateways: [ GATEWAY1 ]
+                    }
+                ]
+            },
+            partialExp: {
+                owner_uuid: USER1,
+                nics: [
+                    createNIC({
+                        mac: MAC1,
+                        interface: INTERFACE1,
+                        primary: true,
+                        nic_tag: NIC_TAG,
+                        ip: IP1,
+                        ips: [ CIDR1 ],
+                        netmask: NETMASK,
+                        gateway: GATEWAY1,
+                        gateways: [ GATEWAY1 ]
+                    })
+                ]
+            },
+            delay: NAPI_TO_LOCAL_DELAY
+        }, function (err, vm) {
+            if (mod_common.ifErr(t2, err, 'create vm')) {
+                t2.end();
+                return;
+            }
+
+            VM = vm;
+
+            t2.end();
+        });
+    });
+
+    t.test('Verify remote', function (t2) {
+        mod_nic.get(t2, {
+            mac: VM.nics[0].mac,
+            partialExp: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: VM.uuid,
+                owner_uuid: USER1,
+                cn_uuid: config.cn_uuid,
+                state: 'running',
+                network_uuid: NET.uuid,
+                nic_tag: NET.nic_tag,
+                ip: IP1
+            }
+        });
+    });
+
+    t.test('Verify local', function (t2) {
+        /*
+         * net-agent should have noticed that the local NIC is missing
+         * information like "network_uuid", and should have updated the
+         * NIC to include it.
+         */
+        mod_vm.get(t2, {
+            uuid: VM.uuid,
+            partialExp: {
+                resolvers: RESOLVERS1,
+                nics: [
+                    createNIC({
+                        primary: true,
+                        ip: IP1,
+                        ips: [ CIDR1 ]
+                    })
+                ]
+            }
+        });
+    });
+});
+
+test('NIC: Update spoofing properties', function (t) {
+    t.plan(2);
+
+    t.test('Update NAPI', function (t2) {
+        mod_nic.update(t2, {
+            mac: MAC1,
+            params: {
+                allow_ip_spoofing: true,
+                allow_mac_spoofing: true
+            },
+            partialExp: {
+                allow_ip_spoofing: true,
+                allow_mac_spoofing: true
+            },
+            delay: NAPI_TO_LOCAL_DELAY
+        });
+    });
+
+    t.test('Verify', function (t2) {
+        mod_vm.get(t2, {
+            uuid: VM.uuid,
+            partialExp: {
+                resolvers: RESOLVERS1,
+                nics: [
+                    createNIC({
+                        primary: true,
+                        ip: IP1,
+                        ips: [ CIDR1 ],
+                        allow_ip_spoofing: true,
+                        allow_mac_spoofing: true
+                    })
+                ]
+            }
+        });
+    });
+});
+
+test('Network: Update gateway', function (t) {
+    t.plan(2);
+
+    t.test('Update', function (t2) {
+        mod_net.update(t2, {
+            params: {
+                uuid: NET.uuid,
+                gateway: GATEWAY2
+            },
+            partialExp: {
+                gateway: GATEWAY2
+            },
+            delay: NAPI_TO_LOCAL_DELAY
+        });
+    });
+
+    t.test('Verify', function (t2) {
+        mod_vm.get(t2, {
+            uuid: VM.uuid,
+            partialExp: {
+                resolvers: RESOLVERS1,
+                nics: [
+                    createNIC({
+                        primary: true,
+                        ip: IP1,
+                        ips: [ CIDR1 ],
+                        allow_ip_spoofing: true,
+                        allow_mac_spoofing: true,
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    })
+                ]
+            }
+        });
+    });
+});
+
+test('Network: Update resolvers', function (t) {
+    t.plan(2);
+
+    t.test('Update', function (t2) {
+        mod_net.update(t2, {
+            params: {
+                uuid: NET.uuid,
+                resolvers: RESOLVERS2
+            },
+            partialExp: {
+                resolvers: RESOLVERS2
+            },
+            delay: NAPI_TO_LOCAL_DELAY
+        });
+    });
+
+    t.test('Verify', function (t2) {
+        mod_vm.get(t2, {
+            uuid: VM.uuid,
+            partialExp: {
+                resolvers: RESOLVERS2,
+                nics: [
+                    createNIC({
+                        primary: true,
+                        ip: IP1,
+                        ips: [ CIDR1 ],
+                        allow_ip_spoofing: true,
+                        allow_mac_spoofing: true,
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    })
+                ]
+            }
+        });
+    });
+});
+
+test('Network: Update routes', function (t) {
+    t.plan(2);
+
+    t.test('Update', function (t2) {
+        mod_net.update(t2, {
+            params: {
+                uuid: NET.uuid,
+                routes: {
+                    '10.1.2.0/24': '172.26.7.170'
+                }
+            },
+            partialExp: {
+                routes: {
+                    '10.1.2.0/24': '172.26.7.170'
+                }
+            },
+            delay: NAPI_TO_LOCAL_DELAY
+        });
+    });
+
+    t.test('Verify', function (t2) {
+        mod_vm.get(t2, {
+            uuid: VM.uuid,
+            partialExp: {
+                routes: {
+                    '10.1.2.0/24': '172.26.7.170'
+                }
+            }
+        });
+    });
+});
+
+test('Stopping VM updates NIC state', function (t) {
+    t.plan(3);
+
+    t.test('Verify before', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC1,
+            partialExp: {
+                state: 'running'
+            }
+        });
+    });
+
+    t.test('Stop VM', function (t2) {
+        mod_vm.stop(t2, {
+            uuid: VM.uuid,
+            delay: LOCAL_TO_NAPI_DELAY
+        });
+    });
+
+    t.test('Verify after', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC1,
+            partialExp: {
+                state: 'stopped'
+            }
+        });
+    });
+});
+
+test('Incorrect cn_uuid is updated', function (t) {
+    t.plan(3);
+
+    t.test('Update NAPI', function (t2) {
+        mod_nic.update(t2, {
+            mac: MAC1,
+            params: {
+                cn_uuid: FAKE_UUID
+            },
+            partialExp: {
+                cn_uuid: FAKE_UUID
+            }
+        });
+    });
+
+    t.test('Start VM', function (t2) {
+        /*
+         * We start the VM again here so that net-agent will push our local
+         * state sooner than it would if we waited for the NicFSM to time out
+         * and check what's in NAPI.
+         */
+        mod_vm.start(t2, {
+            uuid: VM.uuid,
+            delay: LOCAL_TO_NAPI_DELAY
+        });
+    });
+
+    t.test('Verify', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC1,
+            partialExp: {
+                cn_uuid: config.cn_uuid,
+                state: 'running'
+            }
+        });
+    });
+});
+
+test('Change owner_uuid', function (t) {
+    t.plan(3);
+
+    t.test('Verify before', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC1,
+            partialExp: {
+                owner_uuid: USER1
+            }
+        });
+    });
+
+    t.test('Update VM', function (t2) {
+        mod_vm.updateAndGet(t2, {
+            uuid: VM.uuid,
+            params: {
+                owner_uuid: USER2
+            },
+            partialExp: {
+                owner_uuid: USER2
+            },
+            delay: LOCAL_TO_NAPI_DELAY
+        });
+    });
+
+    t.test('Verify after', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC1,
+            partialExp: {
+                owner_uuid: USER2
+            }
+        });
+    });
+});
+
+test('Adding a new NIC creates it in NAPI', function (t) {
+    t.plan(2);
+
+    t.test('Add NIC to VM', function (t2) {
+        mod_vm.updateAndGet(t2, {
+            uuid: VM.uuid,
+            params: {
+                add_nics: [ {
+                    mac: MAC2,
+                    interface: INTERFACE2,
+                    nic_tag: NIC_TAG,
+                    vlan_id: 0,
+                    ips: [ CIDR2 ],
+                    gateways: [ GATEWAY2 ]
+                } ]
+            },
+            partialExp: {
+                resolvers: RESOLVERS2,
+                nics: [
+                    createNIC({
+                        mac: MAC1,
+                        interface: INTERFACE1,
+                        primary: true,
+                        ip: IP1,
+                        ips: [ CIDR1 ],
+                        allow_ip_spoofing: true,
+                        allow_mac_spoofing: true,
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    }),
+                    createNIC({
+                        mac: MAC2,
+                        interface: INTERFACE2,
+                        ip: IP2,
+                        ips: [ CIDR2 ],
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    })
+                ],
+                routes: {
+                    '10.1.2.0/24': '172.26.7.170'
+                }
+            },
+            delay: LOCAL_TO_NAPI_DELAY
+        });
+    });
+
+    t.test('Verify after', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC2,
+            partialExp: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: VM.uuid,
+                owner_uuid: USER2,
+                cn_uuid: config.cn_uuid,
+                state: 'running',
+                network_uuid: NET.uuid,
+                nic_tag: NET.nic_tag,
+                ip: IP2
+            }
+        });
+    });
+});
+
+test('Change primary NIC', function (t) {
+    t.plan(3);
+
+    t.test('Verify before', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC1,
+            partialExp: {
+                primary: true
+            }
+        });
+    });
+
+    t.test('Update VM', function (t2) {
+        mod_vm.updateAndGet(t2, {
+            uuid: VM.uuid,
+            params: {
+                add_nics: [ {
+                    mac: MAC3,
+                    interface: INTERFACE3,
+                    nic_tag: NIC_TAG,
+                    vlan_id: 0,
+                    ips: [ CIDR3 ],
+                    gateways: [ GATEWAY2 ],
+                    primary: true
+                } ]
+            },
+            partialExp: {
+                resolvers: RESOLVERS2,
+                nics: [
+                    createNIC({
+                        mac: MAC1,
+                        interface: INTERFACE1,
+                        ip: IP1,
+                        ips: [ CIDR1 ],
+                        allow_ip_spoofing: true,
+                        allow_mac_spoofing: true,
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    }),
+                    createNIC({
+                        mac: MAC2,
+                        interface: INTERFACE2,
+                        ip: IP2,
+                        ips: [ CIDR2 ],
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    }),
+                    createNIC({
+                        mac: MAC3,
+                        interface: INTERFACE3,
+                        primary: true,
+                        ip: IP3,
+                        ips: [ CIDR3 ],
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    })
+                ],
+                routes: {
+                    '10.1.2.0/24': '172.26.7.170'
+                }
+            },
+            delay: LOCAL_TO_NAPI_DELAY
+        });
+    });
+
+    t.test('Verify after', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC3,
+            partialExp: {
+                belongs_to_type: 'zone',
+                belongs_to_uuid: VM.uuid,
+                owner_uuid: USER2,
+                cn_uuid: config.cn_uuid,
+                state: 'running',
+                network_uuid: NET.uuid,
+                nic_tag: NET.nic_tag,
+                primary: true,
+                ip: IP3
+            }
+        });
+    });
+});
+
+test('Removing NIC from VM removes it from NAPI', function (t) {
+    t.plan(2);
+
+    t.test('Remove NIC from VM', function (t2) {
+        mod_vm.updateAndGet(t2, {
+            uuid: VM.uuid,
+            params: {
+                remove_nics: [ MAC2 ]
+            },
+            partialExp: {
+                nics: [
+                    createNIC({
+                        mac: MAC1,
+                        interface: INTERFACE1,
+                        ip: IP1,
+                        ips: [ CIDR1 ],
+                        allow_ip_spoofing: true,
+                        allow_mac_spoofing: true,
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    }),
+                    createNIC({
+                        mac: MAC3,
+                        interface: INTERFACE3,
+                        primary: true,
+                        ip: IP3,
+                        ips: [ CIDR3 ],
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    })
+                ]
+            },
+            delay: LOCAL_TO_NAPI_DELAY
+        });
+    });
+
+    t.test('Verify NIC is gone', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC2,
+            expCode: 404,
+            expErr: {
+                code: 'ResourceNotFound',
+                message: 'nic not found'
+            }
+        });
+    });
+});
+
+test('Removing NIC from NAPI removes it from VM', function (t) {
+    t.plan(2);
+
+    t.test('Remove NIC from NAPI', function (t2) {
+        mod_nic.del(t2, {
+            mac: MAC3,
+            delay: NAPI_TO_LOCAL_DELAY
+        });
+    });
+
+    t.test('Verify VM', function (t2) {
+        mod_vm.get(t2, {
+            uuid: VM.uuid,
+            partialExp: {
+                nics: [
+                    createNIC({
+                        mac: MAC1,
+                        interface: INTERFACE1,
+                        primary: true,
+                        ip: IP1,
+                        ips: [ CIDR1 ],
+                        allow_ip_spoofing: true,
+                        allow_mac_spoofing: true,
+                        gateway: GATEWAY2,
+                        gateways: [ GATEWAY2 ]
+                    })
+                ]
+            }
+        });
+    });
+});
+
+test('Deleting VM deletes NIC from NAPI', function (t) {
+    t.test('Delete VM', function (t2) {
+        mod_vm.del(t2, {
+            uuid: VM.uuid,
+            delay: LOCAL_TO_NAPI_DELAY
+        });
+    });
+
+    t.test('Verify NIC is gone', function (t2) {
+        mod_nic.get(t2, {
+            mac: MAC1,
+            expCode: 404,
+            expErr: {
+                code: 'ResourceNotFound',
+                message: 'nic not found'
+            }
+        });
+    });
+});
diff --git a/test/lib/client.js b/test/lib/client.js
new file mode 100644
index 0000000..0ca406d
--- /dev/null
+++ b/test/lib/client.js
@@ -0,0 +1,49 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * Test helpers for dealing with the NAPI client
+ */
+
+'use strict';
+
+var config = require('./config');
+var log = require('./log');
+var mod_clients = require('sdc-clients');
+var mod_common = require('../../lib/common');
+var mod_util = require('util');
+
+
+// --- Globals
+
+var naVersion = mod_common.getNetAgentVersion();
+
+var userAgent = mod_util.format(
+    'net-agent-test/%s (node/%s) server/%s',
+    naVersion, process.versions.node, config.cn_uuid);
+
+var CLIENT = new mod_clients.NAPI({
+    url: config.napi.url,
+    log: log,
+    agent: false,
+    retry: false,
+    userAgent: userAgent
+});
+
+
+// --- Exports
+
+function getClient() {
+    return CLIENT;
+}
+
+module.exports = {
+    get: getClient
+};
diff --git a/test/lib/common.js b/test/lib/common.js
new file mode 100644
index 0000000..d389cc4
--- /dev/null
+++ b/test/lib/common.js
@@ -0,0 +1,685 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Common test helpers shared between integration and unit tests
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var fmt = require('util').format;
+var mod_common = require('../../lib/common');
+var mod_jsprim = require('jsprim');
+var mod_uuid = require('uuid');
+var NAPI = require('sdc-clients').NAPI;
+var util = require('util');
+
+var clone = mod_jsprim.deepCopy;
+
+
+var CREATED = {};
+
+// --- Private functions
+
+/*
+ * check if {created,modified}_timestamp are returned with sane values
+ * on creation or modification, as well as adjust opts as necessary
+ * so t.deepEquals() is kept happy
+ *
+ * Optionally, opts.ts can be used to track the timestamps
+ * across multiple invocations to make sure the values are
+ * being updated as expected.
+ */
+function checkTimestamps(t, type, desc, opts, obj) {
+    assert.optionalObject(opts.ts, 'opts.ts');
+
+    var supportedTypes = [ 'nic' ];
+
+    if (supportedTypes.indexOf(opts.type) < 0) {
+        return;
+    }
+
+    switch (opts.reqType) {
+        case 'create':
+            t.notEqual(obj.created_timestamp, 0,
+                type + 'created ts > 0' + desc);
+            t.notEqual(obj.modified_timestamp, 0,
+                type + 'modified ts > 0' + desc);
+            t.equal(obj.created_timestamp, obj.modified_timestamp,
+                type + 'created and modified ts equal at creation' + desc);
+
+            if (opts.ts) {
+                opts.ts.created_timestamp = obj.created_timestamp;
+                opts.ts.modified_timestamp = obj.modified_timestamp;
+            }
+            break;
+
+        case 'get':
+        case 'list':
+            // existing objects might not yet have timestamps, so can return 0
+            t.ok(obj.created_timestamp,
+                type + 'created ts exists' + desc);
+            t.ok(obj.modified_timestamp,
+                type + 'modified ts exsists' + desc);
+
+            if (opts.ts) {
+                t.equal(obj.modified_timestamp, opts.ts.modified_timestamp,
+                    type + 'modified ts unchanged on get' + desc);
+            }
+            break;
+
+        case 'update':
+            t.notEqual(obj.created_timestamp, 0,
+                type + 'created ts set' + desc);
+            t.notEqual(obj.modified_timestamp, 0,
+                type + 'modified ts set' + desc);
+            t.ok(obj.modified_timestamp > obj.created_timestamp,
+                type + 'modified ts > created ts on update' + desc);
+
+            if (opts.ts) {
+                t.ok(obj.modified_timestamp > opts.ts.modified_timestamp,
+                    type + 'modified ts increasing after update' + desc);
+                opts.ts.modified_timestamp = obj.modified_timestamp;
+            }
+            break;
+
+        default:
+            return;
+    }
+
+    if (opts.exp) {
+        var ignore = opts.ignore ? opts.ignore : [];
+
+        // skip implicit checks if caller explicity specifies a value
+        if (!opts.exp.created_timestamp) {
+            if (ignore.indexOf('created_timestamp') < 0) {
+                ignore.push('created_timestamp');
+            }
+        }
+
+        if (!opts.exp.modified_timestamp) {
+            if (ignore.indexOf('modified_timestamp') < 0) {
+                ignore.push('modified_timestamp');
+            }
+        }
+
+        opts.ignore = ignore;
+    }
+}
+
+// --- Exported functions
+
+
+
+/**
+ * Adds the given object to:
+ * - CREATED[type]
+ * - opts.state (if opts and opts.state are present)
+ */
+function addToState(opts, type, obj) {
+    if (!CREATED.hasOwnProperty(type)) {
+        CREATED[type] = [];
+    }
+
+    CREATED[type].push(obj);
+
+    if (!opts.state || !obj) {
+        return;
+    }
+
+    if (!opts.state.hasOwnProperty(type)) {
+        opts.state[type] = [];
+    }
+
+    var newObj = clone(obj);
+    if (opts.hasOwnProperty('stateProp')) {
+        if (!opts.state.hasOwnProperty(opts.stateProp)) {
+            opts.state[opts.stateProp] = [];
+        }
+
+        opts.state[opts.stateProp].push(newObj);
+    }
+
+    opts.state[type].push(newObj);
+}
+
+function requestHeaders(opts) {
+    var headers = opts.headers || {};
+
+    headers['x-request-id'] = mod_uuid.v4();
+
+    if (opts.etag) {
+        headers['If-Match'] = opts.etag;
+    }
+
+    return headers;
+}
+
+/**
+ * Shared test code for after API methods are called
+ */
+function afterAPIcall(t, opts, callback, err, obj, req, res) {
+    var desc = opts.desc ? (' ' + opts.desc) : '';
+    assert.string(opts.reqType, 'opts.reqType');
+    assert.string(opts.type, 'opts.type');
+    var type = opts.reqType + ' ' + opts.type + ': ';
+
+    if (opts.expErr) {
+        t.ok(err, type + 'expected error' + desc);
+        if (err) {
+            var code = opts.expCode || 422;
+            t.equal(err.statusCode, code, type + 'status code' + desc);
+            t.deepEqual(err.body, opts.expErr, type + 'error body' + desc);
+        }
+
+        if (obj) {
+            t.deepEqual(obj, {}, 'body (error expected)' + desc);
+        }
+
+        done(err, null, req, res, opts, t, callback);
+        return;
+    }
+
+    if (ifErr(t, err, type + desc)) {
+        done(err, null, req, res, opts, t, callback);
+        return;
+    }
+
+    if (res) {
+        t.equal(res.statusCode, 200, 'status code' + desc);
+    }
+
+    if (opts.hasOwnProperty('idKey')) {
+        t.pass(fmt('created %s "%s"', opts.type, obj[opts.idKey]));
+    }
+
+    checkTimestamps(t, type, desc, opts, obj);
+
+    if (opts.exp) {
+        /*
+         * For creates, the server will generate an ID (usually a UUID) if
+         * it's not set in the request.  Copy this over to the expected
+         * object so that we don't have to set it manually:
+         */
+        if (opts.hasOwnProperty('idKey') &&
+                !opts.exp.hasOwnProperty(opts.idKey)) {
+            opts.exp[opts.idKey] = obj[opts.idKey];
+        }
+
+        /*
+         * Allow filling in values that might be generated before doing the
+         * deepEqual below:
+         */
+        if (opts.hasOwnProperty('fillIn')) {
+            opts.fillIn.forEach(function (prop) {
+                if (!opts.exp.hasOwnProperty(prop) &&
+                    obj.hasOwnProperty(prop)) {
+                    opts.exp[prop] = obj[prop];
+                }
+            });
+        }
+
+        var actual = obj;
+        var expected = opts.exp;
+
+        if (opts.hasOwnProperty('ignore')) {
+            var objClone = clone(obj);
+            var expClone = clone(opts.exp);
+
+            opts.ignore.forEach(function (ign) {
+                delete objClone[ign];
+                delete expClone[ign];
+            });
+
+            actual = objClone;
+            expected = expClone;
+        }
+
+        t.deepEqual(actual, expected, type + 'full result' + desc);
+    }
+
+    if (opts.partialExp) {
+        var partialRes = {};
+        for (var p in opts.partialExp) {
+            partialRes[p] = obj[p];
+        }
+
+        t.deepEqual(partialRes, opts.partialExp,
+            type + 'partial result' + desc);
+    }
+
+    if (opts.reqType === 'create') {
+        // We take plural names elsewhere, but expect the singular here:
+        assert.notEqual('s', opts.type.slice(-1));
+        addToState(opts, opts.type + 's', obj);
+    }
+
+    done(null, obj, req, res, opts, t, callback);
+}
+
+
+/**
+ * Shared test code for after API delete methods are called
+ */
+function afterAPIdelete(t, opts, callback, err, obj, req, res) {
+    var desc = opts.desc ? (' ' + opts.desc) : '';
+    assert.string(opts.type, 'opts.type');
+    assert.string(opts.id, 'opts.id');
+    var type = util.format('delete %s %s: ', opts.type, opts.id);
+
+    if (opts.expErr) {
+        t.ok(err, 'expected error');
+        if (err) {
+            var code = opts.expCode || 422;
+            t.equal(err.statusCode, code, 'status code');
+            t.deepEqual(err.body, opts.expErr, 'error body');
+        }
+
+        done(err, null, req, res, opts, t, callback);
+        return;
+    }
+
+    /*
+     * mightNotExist allows for calling mod_whatever.dellAllCreated() when
+     * some of the created objects were actually deleted during the test:
+     */
+    if (opts.mightNotExist && err && err.restCode === 'ResourceNotFound') {
+        done(null, obj, req, res, opts, t, callback);
+        return;
+    }
+
+    if (ifErr(t, err, type + desc)) {
+        done(err, null, req, res, opts, t, callback);
+        return;
+    }
+
+    if (res) {
+        t.equal(res.statusCode, 204, type + 'status code' + desc);
+    }
+
+    done(null, obj, req, res, opts, t, callback);
+}
+
+
+/**
+ * Shared test code for after API list methods are called
+ */
+function afterAPIlist(t, opts, callback, err, obj, req, res) {
+    assert.string(opts.type, 'opts.type');
+    assert.string(opts.id, 'opts.id');
+    assert.optionalArray(opts.present, 'opts.present');
+
+    var desc = opts.desc ? (' ' + opts.desc) : '';
+    var id = opts.id;
+    var type = opts.type;
+
+    if (opts.expErr) {
+        t.ok(err, type + 'expected error' + desc);
+        if (err) {
+            var code = opts.expCode || 422;
+            t.equal(err.statusCode, code, type + 'status code' + desc);
+            t.deepEqual(err.body, opts.expErr, type + 'error body' + desc);
+        }
+
+        done(err, null, req, res, opts, t, callback);
+        return;
+    }
+
+    if (ifErr(t, err, type + desc)) {
+        done(err, null, req, res, opts, t, callback);
+        return;
+    }
+
+    t.equal(res.statusCode, 200, 'status code' + desc);
+    t.pass(obj.length + ' results returned' + desc);
+
+    if (opts.present) {
+        var left = clone(opts.present);
+        var ids = left.map(function (o) { return o[id]; });
+        var present = clone(ids);
+        var notInPresent = [];
+
+        mod_jsprim.forEachKey(obj, function (_key, resObj) {
+            var idx = ids.indexOf(resObj[id]);
+            if (idx !== -1) {
+                var expObj = left[idx];
+                var partialRes = {};
+                for (var p in expObj) {
+                    partialRes[p] = resObj[p];
+                }
+
+                var tsOpts = {
+                    id: opts.id,
+                    type: opts.type,
+                    reqType: opts.reqType,
+                    exp: expObj,
+                    ignore: clone(opts.ignore)
+                };
+
+                if (opts.ts && opts.ts[idx]) {
+                    tsOpts.ts = opts.ts[idx];
+                }
+
+                checkTimestamps(t, type, desc, tsOpts, resObj);
+
+                if (opts.deepEqual) {
+                    /*
+                     * ignore doesn't really make sense in the context of a
+                     * partial response.
+                     */
+                    if (tsOpts.ignore) {
+                        var resClone = clone(resObj);
+                        var expClone = clone(expObj);
+
+                        tsOpts.ignore.forEach(function (ign) {
+                            delete resClone[ign];
+                            delete expClone[ign];
+                        });
+
+                        resObj = resClone;
+                        expObj = expClone;
+                    }
+
+                    t.deepEqual(resObj, expObj,
+                        'full result for ' + resObj[id] + desc);
+                } else {
+                    t.deepEqual(partialRes, expObj,
+                        'partial result for ' + resObj[id] + desc);
+                }
+
+                ids.splice(idx, 1);
+                left.splice(idx, 1);
+            } else {
+                notInPresent.push(resObj);
+            }
+        });
+
+        t.deepEqual(ids, [],
+            'found ' + type + 's not specified in opts.present ' + desc);
+
+        if (ids.length !== 0) {
+            t.deepEqual(present, [], 'IDs in present list');
+        }
+
+        if (opts.deepEqual) {
+            t.deepEqual(notInPresent, [], 'IDs not in present list');
+        }
+    }
+
+    done(null, obj, req, res, opts, t, callback);
+}
+
+
+/**
+ * Gets all of the created objects of the given type
+ */
+function allCreated(type) {
+    return CREATED[type] || [];
+}
+
+
+function clearCreated(type) {
+    CREATED[type] = [];
+}
+
+
+function resetCreated() {
+    CREATED = {};
+}
+
+
+/**
+ * Assert the arguments to one of the helper functions are correct
+ */
+function assertArgs(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.exp, 'opts.exp');
+    assert.optionalObject(opts.expErr, 'opts.expErr');
+    assert.optionalObject(opts.partialExp, 'opts.partialExp');
+    assert.ok(opts.exp || opts.partialExp || opts.expErr,
+        'one of exp, expErr, partialExp required');
+    assert.optionalString(opts.etag, 'opts.etag');
+    assert.optionalObject(opts.params, 'opts.params');
+    assert.optionalObject(opts.state, 'opts.state');
+    assert.optionalNumber(opts.delay, 'opts.delay');
+    assert.optionalFunc(callback, 'callback');
+}
+
+
+/**
+ * Assert the arguments to one of the list helper functions are correct
+ */
+function assertArgsList(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.params, 'opts.params');
+    assert.optionalObject(opts.expErr, 'opts.expErr');
+    assert.optionalBool(opts.deepEqual, 'opts.deepEqual');
+    assert.optionalArrayOfObject(opts.present, 'opts.present');
+    assert.optionalFunc(callback, 'callback');
+}
+
+
+/**
+ * Creates a NAPI client for the configured NAPI instance, with a unique
+ * req_id.
+ */
+function createClient(url, t) {
+    var reqID = mod_uuid.v4();
+    var opts = {
+        agent: false,
+        headers: { 'x-request-id': reqID },
+        url: url
+    };
+
+    var client = new NAPI(opts);
+    client.req_id = reqID;
+
+    if (t) {
+        t.ok(client, 'created client with req_id=' + client.req_id);
+    }
+
+    return client;
+}
+
+
+/**
+ * Finish a test
+ */
+function done(err, obj, req, res, opts, t, callback) {
+    function _done() {
+        if (callback) {
+            callback(opts.continueOnErr ? null : err, obj, req, res);
+            return;
+        }
+
+        t.end();
+    }
+
+    if (typeof (opts.delay) === 'number') {
+        t.pass('waiting for ' + (opts.delay / 1000) +
+            ' seconds before continuing');
+        setTimeout(_done, opts.delay);
+    } else {
+        _done();
+    }
+}
+
+
+/**
+ * Finish a test with an error
+ */
+function doneErr(err, t, callback) {
+    if (callback) {
+        return callback(err);
+    }
+
+    return t.end();
+}
+
+
+/**
+ * Finish a test with a result
+ */
+function doneRes(res, t, callback) {
+    if (callback) {
+        return callback(null, res);
+    }
+
+    return t.end();
+}
+
+
+/**
+ * Calls t.ifError, outputs the error body for diagnostic purposes, and
+ * returns true if there was an error
+ */
+function ifErr(t, err, desc) {
+    t.ifError(err, desc);
+    if (err) {
+        t.deepEqual(err.body, {}, desc + ': error body');
+        return true;
+    }
+
+    return false;
+}
+
+
+/**
+ * Returns an invalid parameter error body, overriding with fields in
+ * extra
+ */
+function invalidParamErr(extra) {
+    assert.optionalObject(extra, 'extra');
+
+    var newErr = {
+        code: 'InvalidParameters',
+        message: 'Invalid parameters'
+    };
+
+    for (var e in extra) {
+        newErr[e] = extra[e];
+    }
+
+    return newErr;
+}
+
+
+/**
+ * Gets the last created object of the given type (eg: nics, networks)
+ */
+function lastCreated(type) {
+    if (!CREATED.hasOwnProperty(type) || CREATED[type].length === 0) {
+        return null;
+    }
+
+    return CREATED[type][CREATED[type].length - 1];
+}
+
+
+/**
+ * Returns an missing parameter error body, overriding with fields in
+ * extra
+ */
+function missingParamErr(extra) {
+    assert.optionalObject(extra, 'extra');
+
+    var newErr = {
+        code: 'InvalidParameters',
+        message: 'Missing parameter'
+    };
+
+    for (var e in extra) {
+        newErr[e] = extra[e];
+    }
+
+    return newErr;
+}
+
+
+/**
+ * Generate a valid random MAC address (multicast bit not set, locally
+ * administered bit set)
+ */
+function randomMAC() {
+    var data = [(Math.floor(Math.random() * 15) + 1).toString(16) + 2];
+    for (var i = 0; i < 5; i++) {
+        var oct = (Math.floor(Math.random() * 255)).toString(16);
+        if (oct.length === 1) {
+            oct = '0' + oct;
+        }
+        data.push(oct);
+    }
+
+    return data.join(':');
+}
+
+
+/**
+ * Generate request opts
+ */
+function requestOpts(t, opts) {
+    assert.object(t, 't');
+
+    var desc;
+    if (typeof (opts) === 'undefined') {
+        desc = '';
+        opts = {};
+    } else if (typeof (opts) === 'string') {
+        desc = ': ' + opts;
+        opts = {};
+    } else {
+        assert.object(opts, 'opts');
+        desc = opts.desc ? ': ' + opts.desc : '';
+    }
+
+    var headers = requestHeaders(opts);
+    var reqId = headers['x-request-id'];
+
+    t.ok(reqId, fmt('req ID: %s%s', reqId, desc));
+
+    return { headers: headers };
+}
+
+
+/**
+ * Sort by uuid property
+ */
+function uuidSort(a, b) {
+    return (a.uuid > b.uuid) ? 1 : -1;
+}
+
+
+
+module.exports = {
+    addToState: addToState,
+    afterAPIcall: afterAPIcall,
+    afterAPIdelete: afterAPIdelete,
+    afterAPIlist: afterAPIlist,
+    allCreated: allCreated,
+    assertArgs: assertArgs,
+    assertArgsList: assertArgsList,
+    clearCreated: clearCreated,
+    resetCreated: resetCreated,
+    createClient: createClient,
+    doneErr: doneErr,
+    doneRes: doneRes,
+    ifErr: ifErr,
+    invalidParamErr: invalidParamErr,
+    lastCreated: lastCreated,
+    loadSysinfo: mod_common.loadSysinfo,
+    missingParamErr: missingParamErr,
+    randomMAC: randomMAC,
+    reqHeaders: requestHeaders,
+    reqOpts: requestOpts,
+    uuidSort: uuidSort
+};
diff --git a/test/lib/config.js b/test/lib/config.js
new file mode 100644
index 0000000..6b2ac6d
--- /dev/null
+++ b/test/lib/config.js
@@ -0,0 +1,29 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Test configuration
+ */
+
+'use strict';
+
+var fs = require('fs');
+
+
+// --- Globals
+
+var CONFIG_PATH = '/opt/smartdc/agents/etc/net-agent.config.json';
+
+
+// --- Exports
+
+var CONFIG = JSON.parse(fs.readFileSync(CONFIG_PATH));
+
+module.exports = CONFIG;
diff --git a/test/lib/log.js b/test/lib/log.js
new file mode 100644
index 0000000..ecc15ea
--- /dev/null
+++ b/test/lib/log.js
@@ -0,0 +1,28 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * bunyan logger for tests
+ */
+
+'use strict';
+
+var bunyan = require('bunyan');
+
+module.exports = bunyan.createLogger({
+    name: 'net-agent-test',
+    serializers: bunyan.stdSerializers,
+    streams: [
+        {
+            level: process.env.LOG_LEVEL || 'fatal',
+            stream: process.stderr
+        }
+    ]
+});
diff --git a/test/lib/net.js b/test/lib/net.js
new file mode 100644
index 0000000..c0826b7
--- /dev/null
+++ b/test/lib/net.js
@@ -0,0 +1,323 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Test helpers for dealing with networks
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var common = require('./common');
+var fmt = require('util').format;
+var log = require('./log');
+var mod_client = require('./client');
+var mod_jsprim = require('jsprim');
+var mod_vasync = require('vasync');
+
+var clone = mod_jsprim.deepCopy;
+var doneErr = common.doneErr;
+
+
+// --- Globals
+
+
+var MAX_IPV4 = 4294967295;
+
+var NIC_NET_PARAMS = [
+    'gateway',
+    'gateway_provisioned',
+    'internet_nat',
+    'mtu',
+    'netmask',
+    'nic_tag',
+    'resolvers',
+    'routes',
+    'vlan_id'
+];
+var NUM = 0;
+var TYPE = 'network';
+
+
+// --- Internal helpers
+
+/*
+ * Converts an integer to a dotted IP address
+ */
+function numberToAddress(num) {
+    if (isNaN(num) || num > MAX_IPV4 || num < 0) {
+        return null;
+    }
+
+    var a = Math.floor(num / 16777216);
+    var aR = num - (a * 16777216);
+    var b = Math.floor(aR / 65536);
+    var bR = aR - (b * 65536);
+    var c = Math.floor(bR / 256);
+    var d = bR - (c * 256);
+
+    return a + '.' + b + '.' + c + '.' + d;
+}
+
+
+
+/*
+ * Converts CIDR (/xx) bits to netmask
+ */
+function bitsToNetmask(bits) {
+    var n = 0;
+
+    for (var i = 0; i < (32 - bits); i++) {
+        n |= 1 << i;
+    }
+    return numberToAddress(MAX_IPV4 - (n >>> 0));
+}
+
+
+// --- Exports
+
+
+
+/**
+ * Add network parameters to a nic
+ */
+function addNetParams(net, nic) {
+    NIC_NET_PARAMS.forEach(function (n) {
+        if (net.hasOwnProperty(n) && !nic.hasOwnProperty(n)) {
+            nic[n] = net[n];
+        }
+    });
+
+    nic.network_uuid = net.uuid;
+    return nic;
+}
+
+
+/**
+ * Create a network and compare the output
+ */
+function createNet(t, opts, callback) {
+    common.assertArgs(t, opts, callback);
+
+    var client = opts.client || mod_client.get();
+    var params = clone(opts.params);
+
+    if (params.name === '<generate>') {
+        params.name = netName();
+    }
+
+    opts.idKey = 'uuid';
+    opts.fillIn = [ 'family', 'mtu' ];
+    opts.reqType = 'create';
+    opts.type = TYPE;
+
+    if (opts.fillInMissing && opts.exp) {
+        opts.exp.netmask = bitsToNetmask(opts.exp.subnet.split('/')[1]);
+        if (!opts.params.resolvers && !opts.exp.resolvers) {
+            opts.exp.resolvers = [];
+        }
+    }
+
+    client.createNetwork(params, common.reqOpts(t, opts),
+        common.afterAPIcall.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Create a network, compare the output, then do the same for a get of
+ * that network.
+ */
+function createAndGet(t, opts, callback) {
+    opts.reqType = 'create';
+    createNet(t, opts, function (err, net, _, res) {
+        if (err) {
+            doneErr(err, t, callback);
+            return;
+        }
+
+        if (!opts.params.uuid) {
+            opts.params.uuid = net.uuid;
+        }
+
+        opts.params.uuid = net.uuid;
+        opts.etag = res.headers['etag'];
+
+        getNet(t, opts, callback);
+    });
+}
+
+
+/**
+ * Delete a network
+ */
+function delNet(t, opts, callback) {
+    assert.object(t, 't');
+    assert.string(opts.uuid, 'opts.uuid');
+    assert.optionalObject(opts.expErr, 'opts.expErr');
+
+    var client = opts.client || mod_client.get();
+    var params = opts.params || {};
+
+    opts.type = TYPE;
+    opts.id = opts.uuid;
+
+    client.deleteNetwork(opts.uuid, params, common.reqOpts(t, opts),
+        common.afterAPIdelete.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Delete all the networks created by this test
+ */
+function delAllCreatedNets(t) {
+    assert.object(t, 't');
+
+    var created = common.allCreated('networks');
+    if (created.length === 0) {
+        t.pass('No networks created');
+        t.end();
+        return;
+    }
+
+    common.clearCreated('networks');
+
+    mod_vasync.forEachParallel({
+        inputs: created,
+        func: function _delOne(net, cb) {
+            var delOpts = {
+                continueOnErr: true,
+                exp: {},
+                params: net,
+                uuid: net.uuid
+            };
+
+            delNet(t, delOpts, cb);
+        }
+    }, function () {
+        t.end();
+    });
+}
+
+
+/**
+ * Get a network and compare the output
+ */
+function getNet(t, opts, callback) {
+    common.assertArgs(t, opts, callback);
+    assert.object(opts.params, 'opts.params');
+
+    var client = opts.client || mod_client.get();
+    var params = {
+        params: opts.params.params || {},
+        headers: common.reqHeaders(opts)
+    };
+
+    opts.reqType = 'get';
+    opts.type = TYPE;
+
+    client.getNetwork(opts.params.uuid, params,
+        common.afterAPIcall.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Returns the most recently created network
+ */
+function lastCreated() {
+    return common.lastCreated('networks');
+}
+
+
+/**
+ * List networks
+ */
+function listNets(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.optionalObject(opts.expErr, 'opts.expErr');
+    assert.optionalBool(opts.deepEqual, 'opts.deepEqual');
+    assert.optionalArrayOfObject(opts.present, 'opts.present');
+
+    var client = opts.client || mod_client.get();
+    var params = opts.params || {};
+    var desc = ' ' + JSON.stringify(params)
+        + (opts.desc ? (' ' + opts.desc) : '');
+
+    if (!opts.desc) {
+        opts.desc = desc;
+    }
+    opts.id = 'uuid';
+    opts.type = TYPE;
+
+    log.debug({ params: params }, 'list networks');
+
+    client.listNetworks(params, common.reqOpts(t, opts),
+        common.afterAPIlist.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Generate a unique test network name
+ */
+function netName() {
+    return fmt('test-net%d-%d', NUM++, process.pid);
+}
+
+
+/**
+ * Update a network and compare the output
+ */
+function updateNet(t, opts, callback) {
+    common.assertArgs(t, opts, callback);
+    assert.object(opts.params, 'opts.params');
+
+    var client = opts.client || mod_client.get();
+
+    opts.type = TYPE;
+    opts.reqType = 'update';
+
+    client.updateNetwork(opts.params.uuid, opts.params, common.reqOpts(t, opts),
+        common.afterAPIcall.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Update a network, compare the output, then do the same for a get of
+ * that network.
+ */
+function updateAndGet(t, opts, callback) {
+    updateNet(t, opts, function (err, _, req, res) {
+        if (err) {
+            doneErr(err, t, callback);
+            return;
+        }
+
+        opts.etag = res.headers['etag'];
+
+        getNet(t, opts, callback);
+    });
+}
+
+
+
+module.exports = {
+    addNetParams: addNetParams,
+    create: createNet,
+    createAndGet: createAndGet,
+    del: delNet,
+    delAllCreated: delAllCreatedNets,
+    get: getNet,
+    lastCreated: lastCreated,
+    list: listNets,
+    name: netName,
+    netParams: NIC_NET_PARAMS,
+    update: updateNet,
+    updateAndGet: updateAndGet
+};
diff --git a/test/lib/nic.js b/test/lib/nic.js
new file mode 100644
index 0000000..52c6974
--- /dev/null
+++ b/test/lib/nic.js
@@ -0,0 +1,309 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * Test helpers for dealing with NICs
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var common = require('./common');
+var log = require('./log');
+var mod_client = require('./client');
+var mod_jsprim = require('jsprim');
+var mod_vasync = require('vasync');
+var verror = require('verror');
+
+var clone = mod_jsprim.deepCopy;
+var doneRes = common.doneRes;
+var doneErr = common.doneErr;
+
+
+
+// --- Globals
+
+var TYPE = 'nic';
+
+
+// --- Exports
+
+/**
+ * Create a nic and compare the output
+ */
+function createNic(t, opts, callback) {
+    var client = opts.client || mod_client.get();
+
+    assert.object(t, 't');
+    assert.string(opts.mac, 'opts.mac');
+    assert.optionalObject(opts.expErr, 'opts.expErr');
+    assert.optionalObject(opts.partialExp, 'opts.partialExp');
+    assert.ok(opts.exp || opts.partialExp || opts.expErr,
+            'one of exp, expErr, partialExp required');
+    assert.object(opts.params, 'opts.params');
+
+    var mac = opts.mac;
+    if (mac === 'generate') {
+        mac = common.randomMAC();
+    }
+    opts.idKey = 'mac';
+    opts.type = TYPE;
+    opts.reqType = 'create';
+
+
+    client.createNic(mac, clone(opts.params), common.reqOpts(t, opts),
+        common.afterAPIcall.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Create a nic, compare the output, then do the same for a get of
+ * that nic.
+ */
+function createAndGetNic(t, opts, callback) {
+    createNic(t, opts, function (err, _, req, res) {
+        if (err) {
+            doneErr(err, t, callback);
+            return;
+        }
+
+        opts.etag = res.headers['etag'];
+
+        getNic(t, opts, callback);
+    });
+}
+
+
+/**
+ * Create num nics, and end the test when done
+ */
+function createNumNics(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.number(opts.num, 'opts.num');
+    assert.object(opts.params, 'opts.params');
+
+    var done = 0;
+    var errs = [];
+    var nics = [];
+
+    opts.mac = 'generate';
+
+    // Don't require checking parameters
+    if (!opts.exp && !opts.params.partialExp) {
+        opts.partialExp = opts.params;
+    }
+
+    function _afterProvision(err, nic) {
+        if (err) {
+            errs.push(err);
+        }
+
+        if (nic) {
+            nics.push(nic);
+        }
+
+        if (++done === opts.num) {
+            if (errs.length !== 0) {
+                doneErr(new verror.MultiError(errs), t, callback);
+                return;
+            }
+
+            doneRes(nics, t, callback);
+            return;
+        }
+    }
+
+    for (var i = 0; i < opts.num; i++) {
+        createNic(t, opts, _afterProvision);
+    }
+}
+
+
+/**
+ * Delete all the nics created by this test
+ */
+function delAllCreatedNics(t) {
+    assert.object(t, 't');
+
+    var created = common.allCreated('nics');
+    if (created.length === 0) {
+        t.pass('No nics created');
+        t.end();
+        return;
+    }
+
+    common.clearCreated('nics');
+
+    var q = mod_vasync.queue(function _delOne(nic, cb) {
+        var delOpts = {
+            mightNotExist: true,
+            continueOnErr: true,
+            exp: {},
+            params: nic,
+            mac: nic.mac
+        };
+
+        delNic(t, delOpts, cb);
+    }, 100);
+
+    q.on('end', function () {
+        t.end();
+    });
+
+    q.push(created);
+    q.close();
+}
+
+
+/**
+ * Delete a nic
+ */
+function delNic(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.string(opts.mac, 'opts.mac');
+
+    var client = mod_client.get();
+    var params = opts.params || {};
+
+    log.debug({ mac: opts.mac }, 'delete nic');
+    opts.id = opts.mac;
+    opts.type = TYPE;
+
+    client.deleteNic(opts.mac, params, common.reqOpts(t, opts),
+        common.afterAPIdelete.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Get a nic and compare the output
+ */
+function getNic(t, opts, callback) {
+    common.assertArgs(t, opts, callback);
+
+    var client = opts.client || mod_client.get();
+
+    assert.object(t, 't');
+    assert.string(opts.mac, 'opts.mac');
+    assert.optionalObject(opts.exp, 'opts.exp');
+    assert.optionalObject(opts.expErr, 'opts.expErr');
+    assert.optionalObject(opts.partialExp, 'opts.partialExp');
+    assert.ok(opts.exp || opts.partialExp || opts.expErr,
+            'one of exp, expErr, partialExp required');
+
+    opts.type = TYPE;
+    opts.reqType = 'get';
+    client.getNic(opts.mac, common.reqOpts(t, opts),
+        common.afterAPIcall.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Returns the most recently created nic
+ */
+function lastCreatedNic() {
+    return common.lastCreated('nics');
+}
+
+
+/**
+ * List networks
+ */
+function listNics(t, opts, callback) {
+    common.assertArgsList(t, opts, callback);
+
+    var client = opts.client || mod_client.get();
+    var params = opts.params || {};
+    var desc = ' ' + JSON.stringify(params)
+        + (opts.desc ? (' ' + opts.desc) : '');
+
+    if (!opts.desc) {
+        opts.desc = desc;
+    }
+    opts.id = 'mac';
+    opts.type = TYPE;
+    opts.reqType = 'list';
+
+    log.debug({ params: params }, 'list networks');
+
+    client.listNics(params, common.reqOpts(t, opts),
+        common.afterAPIlist.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Provision a nic and compare the output
+ */
+function provisionNic(t, opts, callback) {
+    common.assertArgs(t, opts, callback);
+    assert.uuid(opts.net, 'opts.net');
+
+    var client = opts.client || mod_client.get();
+    log.debug({ params: opts.params }, 'provisioning nic');
+    opts.idKey = 'mac';
+    opts.type = TYPE;
+    opts.reqType = 'create';
+
+    if (opts.exp && opts.fillInMissing) {
+        opts.fillIn = [ 'ip', 'mac', 'primary', 'state' ];
+    }
+
+    client.provisionNic(opts.net, opts.params, common.reqOpts(t, opts),
+        common.afterAPIcall.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Update a nic and compare the output
+ */
+function updateNic(t, opts, callback) {
+    common.assertArgs(t, opts, callback);
+    assert.string(opts.mac, 'opts.mac');
+
+    var client = opts.client || mod_client.get();
+    opts.type = TYPE;
+    opts.reqType = 'update';
+
+    client.updateNic(opts.mac, opts.params, common.reqOpts(t, opts),
+        common.afterAPIcall.bind(null, t, opts, callback));
+}
+
+
+/**
+ * Update a nic, compare the output, then do the same for a get of
+ * that nic.
+ */
+function updateAndGet(t, opts, callback) {
+    updateNic(t, opts, function (err, res) {
+        if (err) {
+            doneErr(err, t, callback);
+            return;
+        }
+
+        getNic(t, opts, callback);
+    });
+}
+
+
+
+module.exports = {
+    create: createNic,
+    createAndGet: createAndGetNic,
+    createN: createNumNics,
+    delAllCreated: delAllCreatedNics,
+    del: delNic,
+    get: getNic,
+    lastCreated: lastCreatedNic,
+    list: listNics,
+    provision: provisionNic,
+    update: updateNic,
+    updateAndGet: updateAndGet
+};
diff --git a/test/lib/vm.js b/test/lib/vm.js
new file mode 100644
index 0000000..736190f
--- /dev/null
+++ b/test/lib/vm.js
@@ -0,0 +1,168 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * Test helpers for dealing with VMs
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var log = require('./log');
+var mod_common = require('./common');
+var mod_vmadm = require('vmadm');
+
+var doneErr = mod_common.doneErr;
+
+// --- Globals
+
+var TYPE = 'vm';
+
+// --- Exports
+
+function createVm(t, opts, callback) {
+    mod_common.assertArgs(t, opts, callback);
+
+    var params = opts.params;
+    params.log = log;
+
+    opts.idKey = 'uuid';
+    opts.type = TYPE;
+    opts.reqType = 'create';
+
+    mod_vmadm.create(params, function (err, info) {
+        mod_common.afterAPIcall(t, opts, callback, err, info);
+    });
+}
+
+function createAndGetVm(t, opts, callback) {
+    createVm(t, {
+        params: opts.params,
+        partialExp: {},
+        delay: opts.delay
+    }, function (err, info) {
+        if (err) {
+            doneErr(err, t, callback);
+            return;
+        }
+
+        opts.uuid = info.uuid;
+
+        getVm(t, opts, callback);
+    });
+}
+
+function updateVm(t, opts, callback) {
+    mod_common.assertArgs(t, opts, callback);
+    assert.uuid(opts.uuid, 'opts.uuid');
+
+    var params = opts.params;
+    params.uuid = opts.uuid;
+    params.log = log;
+
+    opts.type = TYPE;
+    opts.reqType = 'update';
+
+    mod_vmadm.update(params, function (err) {
+        mod_common.afterAPIcall(t, opts, callback, err, { uuid: opts.uuid });
+    });
+}
+
+function updateAndGetVm(t, opts, callback) {
+    mod_common.assertArgs(t, opts, callback);
+
+    updateVm(t, {
+        uuid: opts.uuid,
+        params: opts.params,
+        partialExp: {},
+        delay: opts.delay
+    }, function (err) {
+        if (err) {
+            doneErr(err, t, callback);
+            return;
+        }
+
+        getVm(t, opts, callback);
+    });
+}
+
+function delVm(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.uuid(opts.uuid, 'opts.uuid');
+
+    opts.id = opts.uuid;
+    opts.type = TYPE;
+    opts.reqType = 'delete';
+
+    mod_vmadm.delete({
+        uuid: opts.uuid,
+        log: log
+    }, function (err) {
+        mod_common.afterAPIdelete(t, opts, callback, err);
+    });
+}
+
+function getVm(t, opts, callback) {
+    mod_common.assertArgs(t, opts, callback);
+    assert.uuid(opts.uuid, 'opts.uuid');
+
+    opts.type = TYPE;
+    opts.reqType = 'get';
+
+    mod_vmadm.load({
+        uuid: opts.uuid,
+        log: log
+    }, function (err, vm) {
+        mod_common.afterAPIcall(t, opts, callback, err, vm);
+    });
+}
+
+function startVm(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.uuid(opts.uuid, 'opts.uuid');
+
+    opts.type = TYPE;
+    opts.reqType = 'stop';
+
+    mod_vmadm.start({
+        uuid: opts.uuid,
+        log: log
+    }, function (err) {
+        mod_common.afterAPIcall(t, opts, callback, err);
+    });
+}
+function stopVm(t, opts, callback) {
+    assert.object(t, 't');
+    assert.object(opts, 'opts');
+    assert.uuid(opts.uuid, 'opts.uuid');
+
+    opts.type = TYPE;
+    opts.reqType = 'stop';
+
+    mod_vmadm.stop({
+        uuid: opts.uuid,
+        log: log
+    }, function (err) {
+        mod_common.afterAPIcall(t, opts, callback, err);
+    });
+}
+
+module.exports = {
+    create: createVm,
+    createAndGet: createAndGetVm,
+    del: delVm,
+    get: getVm,
+    update: updateVm,
+    updateAndGet: updateAndGetVm,
+    start: startVm,
+    stop: stopVm
+};
diff --git a/test/unit/util.test.js b/test/unit/util.test.js
index 7b39263..e596d4d 100644
--- a/test/unit/util.test.js
+++ b/test/unit/util.test.js
@@ -19,6 +19,13 @@ var test = require('tape');
 
 // --- Tests
 
+test('Get net-agent version', function (t) {
+    var version = mod_common.getNetAgentVersion();
+
+    t.equal(typeof (version), 'string');
+    t.end();
+});
+
 test('hasChanged() tests', function (t) {
     var OBJ1 = { a: 5, b: [ 1, 2, 3, 4 ] };
     var OBJ2 = { a: 6, b: [ 1, 2, 3, 4 ] };
