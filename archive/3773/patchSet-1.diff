From 9bf4322c6575adb79692b41e14c85348553a2162 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Wed, 4 Apr 2018 12:42:10 +0000
Subject: [PATCH] OS-6727 bhyve should provide zone UUID to guest via SMBIOS

---
 manifest                                      |   1 -
 usr/src/cmd/mdb/intel/amd64/Makefile          |   4 +-
 usr/src/cmd/mdb/intel/amd64/vmm/Makefile      |  21 --
 .../cmd/mdb/intel/amd64/vmm/amd64/Makefile    |  35 ---
 usr/src/cmd/mdb/intel/amd64/vmm/vmm.c         | 237 ------------------
 usr/src/cmd/smbios/Makefile                   |   4 +
 usr/src/cmd/smbios/smbios.c                   |  26 +-
 usr/src/lib/brand/bhyve/zone/boot.c           |  39 ++-
 usr/src/man/man1m/smbios.1m                   |  16 +-
 usr/src/pkg/manifests/system-bhyve.mf         |   7 -
 usr/src/uts/i86pc/io/vmm/intel/vmx_support.s  |  21 ++
 usr/src/uts/i86pc/io/vmm/vmm.c                |   2 -
 usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c        | 175 -------------
 usr/src/uts/i86pc/os/pc_hvm.c                 |  12 +-
 usr/src/uts/i86pc/sys/vmm_dev.h               |   5 -
 usr/src/uts/i86pc/sys/vmm_impl.h              |  33 ---
 16 files changed, 97 insertions(+), 541 deletions(-)
 delete mode 100644 usr/src/cmd/mdb/intel/amd64/vmm/Makefile
 delete mode 100644 usr/src/cmd/mdb/intel/amd64/vmm/amd64/Makefile
 delete mode 100644 usr/src/cmd/mdb/intel/amd64/vmm/vmm.c

diff --git a/manifest b/manifest
index 212ec0b7dd..56470b7822 100644
--- a/manifest
+++ b/manifest
@@ -9610,7 +9610,6 @@ f usr/lib/mdb/kvm/amd64/sv.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/ufs.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/uhci.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/usba.so 0555 root sys
-f usr/lib/mdb/kvm/amd64/vmm.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/xhci.so 0555 root sys
 f usr/lib/mdb/kvm/amd64/zfs.so 0555 root sys
 d usr/lib/mdb/proc 0755 root sys
diff --git a/usr/src/cmd/mdb/intel/amd64/Makefile b/usr/src/cmd/mdb/intel/amd64/Makefile
index 7749b75f37..f7bc890fb5 100644
--- a/usr/src/cmd/mdb/intel/amd64/Makefile
+++ b/usr/src/cmd/mdb/intel/amd64/Makefile
@@ -21,12 +21,12 @@
 #
 # Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
-# Copyright 2017 Joyent, Inc.
+# Copyright 2018 Joyent, Inc.
 #
 
 include ../../Makefile.common
 
-MODULES = $(COMMON_MODULES_PROC) $(COMMON_MODULES_KVM) uhci vmm
+MODULES = $(COMMON_MODULES_PROC) $(COMMON_MODULES_KVM) uhci
 
 SUBDIRS = mdb mdb_ks kmdb libstandctf libstand .WAIT $(MODULES)
 
diff --git a/usr/src/cmd/mdb/intel/amd64/vmm/Makefile b/usr/src/cmd/mdb/intel/amd64/vmm/Makefile
deleted file mode 100644
index 0f2b977dfd..0000000000
--- a/usr/src/cmd/mdb/intel/amd64/vmm/Makefile
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright 2014 Pluribus Networks Inc.
-# Copyright 2017 Joyent, Inc.
-#
-
-#MAKEVARS = CW_NO_SHADOW=true __GNUC=
-
-include $(SRC)/Makefile.master
-$(BUILD64)SUBDIRS +=	$(MACH64)
-include ../../../Makefile.subdirs
diff --git a/usr/src/cmd/mdb/intel/amd64/vmm/amd64/Makefile b/usr/src/cmd/mdb/intel/amd64/vmm/amd64/Makefile
deleted file mode 100644
index e61be22d2a..0000000000
--- a/usr/src/cmd/mdb/intel/amd64/vmm/amd64/Makefile
+++ /dev/null
@@ -1,35 +0,0 @@
-#
-# This file and its contents are supplied under the terms of the
-# Common Development and Distribution License ("CDDL"), version 1.0.
-# You may only use this file in accordance with the terms of version
-# 1.0 of the CDDL.
-#
-# A full copy of the text of the CDDL should have accompanied this
-# source.  A copy of the CDDL is also available via the Internet at
-# http://www.illumos.org/license/CDDL.
-#
-
-#
-# Copyright 2013 Pluribus Networks Inc.
-#
-
-MODULE = vmm.so
-MDBTGT = kvm
-
-MODSRCS = vmm.c
-
-include ../../../../../Makefile.cmd
-include ../../../../../Makefile.cmd.64
-include ../../../Makefile.amd64
-include ../../../../Makefile.module
-
-CPPFLAGS = -D_KERNEL -D_MACHDEP
-CPPFLAGS += -I$(COMPAT)/freebsd -I$(COMPAT)/freebsd/amd64
-CPPFLAGS += -I$(CONTRIB)/freebsd -I$(CONTRIB)/freebsd/amd64
-CPPFLAGS += -I$(SRC)/uts/common -I$(SRC)/uts/i86pc
-CPPFLAGS += -I$(SRC)/cmd/mdb/common
-
-#CPPFLAGS += -_cc=-xdryrun
-
-LINTTAGS += -erroff=E_FUNC_ARG_UNUSED
-LINTTAGS += -erroff=E_STATIC_UNUSED
diff --git a/usr/src/cmd/mdb/intel/amd64/vmm/vmm.c b/usr/src/cmd/mdb/intel/amd64/vmm/vmm.c
deleted file mode 100644
index 74c4ebc6c0..0000000000
--- a/usr/src/cmd/mdb/intel/amd64/vmm/vmm.c
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * This file and its contents are supplied under the terms of the
- * Common Development and Distribution License ("CDDL"), version 1.0.
- * You may only use this file in accordance with the terms of version
- * 1.0 of the CDDL.
- *
- * A full copy of the text of the CDDL should have accompanied this
- * source.  A copy of the CDDL is also available via the Internet at
- * http://www.illumos.org/license/CDDL.
- */
-
-/*
- * Copyright 2014 Pluribus Networks Inc.
- */
-
-#include <sys/param.h>
-
-#include <mdb/mdb_modapi.h>
-#include <sys/cpuvar.h>
-#include <sys/varargs.h>
-#include <sys/vmm.h>
-#include <sys/vmm_impl.h>
-
-/*
- * VMM trace debug walker/dcmd code
- */
-
-/*
- * Initialize the vmm_trace_dmsg_t walker by either using the given starting
- * address, or reading the value of the kernel's vmm_debug_rbuf pointer.
- * We also allocate a vmm_trace_dmsg_t for storage, and save this using the
- * walk_data pointer.
- */
-static int
-vmm_dmsg_walk_i(mdb_walk_state_t *wsp)
-{
-	uintptr_t rbuf_addr;
-	vmm_trace_rbuf_t rbuf;
-
-	if (wsp->walk_addr == NULL) {
-		if (mdb_readvar(&rbuf_addr, "vmm_debug_rbuf") == -1) {
-			mdb_warn("failed to read 'vmm_debug_rbuf'");
-			return (WALK_ERR);
-		}
-
-		if (mdb_vread(&rbuf, sizeof (vmm_trace_rbuf_t), rbuf_addr)
-		    == -1) {
-			mdb_warn("failed to read vmm_trace_rbuf_t at %p",
-			    rbuf_addr);
-			return (WALK_ERR);
-		}
-
-		wsp->walk_addr = (uintptr_t)(vmm_trace_dmsg_t *)rbuf.dmsgh;
-	}
-
-	/*
-	 * Save ptr to head of ring buffer to prevent looping.
-	 */
-	wsp->walk_arg = (void *)wsp->walk_addr;
-	wsp->walk_data = mdb_alloc(sizeof (vmm_trace_dmsg_t), UM_SLEEP);
-	return (WALK_NEXT);
-}
-
-/*
- * At each step, read a vmm_trace_dmsg_t into our private storage, and then
- * invoke the callback function.  We terminate when we reach a NULL next
- * pointer.
- */
-static int
-vmm_dmsg_walk_s(mdb_walk_state_t *wsp)
-{
-	int status;
-
-	if (wsp->walk_addr == NULL)
-		return (WALK_DONE);
-
-	if (mdb_vread(wsp->walk_data, sizeof (vmm_trace_dmsg_t),
-	    wsp->walk_addr) == -1) {
-		mdb_warn("failed to read vmm_trace_dmsg_t at %p",
-		    wsp->walk_addr);
-		return (WALK_ERR);
-	}
-
-	status = wsp->walk_callback(wsp->walk_addr, wsp->walk_data,
-	    wsp->walk_cbdata);
-
-	wsp->walk_addr =
-	    (uintptr_t)(((vmm_trace_dmsg_t *)wsp->walk_data)->next);
-
-	/*
-	 * If we've looped then we're done.
-	 */
-	if (wsp->walk_addr == (uintptr_t)wsp->walk_arg)
-		wsp->walk_addr = NULL;
-
-	return (status);
-}
-
-/*
- * The walker's fini function is invoked at the end of each walk.  Since we
- * dynamically allocated a vmm_trace_dmsg_t in vmm_dmsg_walk_i, we must
- * free it now.
- */
-static void
-vmm_dmsg_walk_f(mdb_walk_state_t *wsp)
-{
-	mdb_free(wsp->walk_data, sizeof (vmm_trace_dmsg_t));
-}
-
-/*
- * This routine is used by the vmm_dmsg_dump dcmd to dump content of
- * VMM trace ring buffer.
- */
-int
-vmm_dmsg_dump(vmm_trace_dmsg_t *addr, int print_pathname, uint_t *printed)
-{
-	vmm_trace_dmsg_t	dmsg, *dmsgh = addr;
-	char			merge[1024];
-
-	while (addr != NULL) {
-		if (mdb_vread(&dmsg, sizeof (dmsg), (uintptr_t)addr) !=
-		    sizeof (dmsg)) {
-			mdb_warn("failed to read message pointer in kernel");
-			return (DCMD_ERR);
-		}
-
-		(void) mdb_snprintf(merge, sizeof (merge),
-		    "[%Y:%03d:%03d:%03d] : %s",
-		    dmsg.timestamp.tv_sec,
-		    (int)dmsg.timestamp.tv_nsec/1000000,
-		    (int)(dmsg.timestamp.tv_nsec/1000)%1000,
-		    (int)dmsg.timestamp.tv_nsec%1000,
-		    dmsg.buf);
-
-		mdb_printf("%s", merge);
-
-		if (printed != NULL) {
-			(*printed)++;
-		}
-
-		if (((addr = dmsg.next) == NULL) || (dmsg.next == dmsgh)) {
-			break;
-		}
-	}
-
-	return (DCMD_OK);
-}
-
-/*
- * 1. Process flag passed to vmm_dmsg_dump dcmd.
- * 2. Obtain VMM trace ring buffer pointer.
- * 3. Pass VMM trace ring buffer pointer to vmm_dmsg_dump()
- *    to dump content of VMM trace ring buffer.
- */
-int
-vmm_rbuf_dump(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
-{
-	vmm_trace_rbuf_t	rbuf;
-	uint_t		printed = 0; /* have we printed anything? */
-	int		print_pathname = FALSE;
-	int		rval = DCMD_OK;
-
-	if (argc > 1) {
-		return (DCMD_USAGE);
-	}
-
-	if (mdb_getopts(argc, argv,
-	    'a', MDB_OPT_SETBITS, TRUE, &print_pathname) != argc) {
-		return (DCMD_USAGE);
-	}
-
-	/*
-	 * If ring buffer address not provided try to obtain
-	 * it using vmm_debug_rbuf global.
-	 */
-	if ((addr == NULL) || !(flags & DCMD_ADDRSPEC)) {
-		if (mdb_readvar(&addr, "vmm_debug_rbuf") == -1) {
-			mdb_warn("Failed to read 'vmm_debug_rbuf'.");
-			return (DCMD_ERR);
-		}
-	}
-
-	if (mdb_vread(&rbuf, sizeof (rbuf), addr) != sizeof (rbuf)) {
-		mdb_warn("Failed to read ring buffer in kernel.");
-		return (DCMD_ERR);
-	}
-
-	if (rbuf.dmsgh == NULL) {
-		mdb_printf("The vmm trace ring buffer is empty.\n");
-		return (DCMD_OK);
-	}
-
-	rval = vmm_dmsg_dump((vmm_trace_dmsg_t *)rbuf.dmsgh,
-	    print_pathname, &printed);
-
-	if (rval != DCMD_OK) {
-		return (rval);
-	}
-
-	if (printed == 0) {
-		mdb_warn("Failed to read vmm trace ring buffer.");
-		return (DCMD_ERR);
-	}
-
-	return (rval);
-}
-
-/*
- * MDB module linkage information:
- *
- * We declare a list of structures describing our dcmds, a list of structures
- * describing our walkers, and a function named _mdb_init to return a pointer
- * to our module information.
- */
-
-static const mdb_dcmd_t dcmds[] = {
-	{ "vmm_dmsg_dump", "[-a]", "Dump vmm trace debug messages",
-	    vmm_rbuf_dump },
-	{ NULL }
-};
-
-static const mdb_walker_t walkers[] = {
-	{ "vmm_dmsg",
-	    "walk ring buffer containing vmm trace debug messages",
-	    vmm_dmsg_walk_i, vmm_dmsg_walk_s, vmm_dmsg_walk_f },
-	{ NULL }
-};
-
-static const mdb_modinfo_t modinfo = {
-	MDB_API_VERSION, dcmds, walkers
-};
-
-const mdb_modinfo_t *
-_mdb_init(void)
-{
-	return (&modinfo);
-}
diff --git a/usr/src/cmd/smbios/Makefile b/usr/src/cmd/smbios/Makefile
index f3d7803a78..eec224f524 100644
--- a/usr/src/cmd/smbios/Makefile
+++ b/usr/src/cmd/smbios/Makefile
@@ -22,6 +22,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2018 Joyent, Inc.
+#
 
 PROG = smbios
 OBJS = smbios.o
@@ -35,6 +37,8 @@ LDLIBS += -lsmbios
 FILEMODE = 0555
 STRIPFLAG =
 
+LINTFLAGS += -erroff=E_BAD_PTR_CAST_ALIGN
+
 .KEEP_STATE:
 
 all: $(PROG)
diff --git a/usr/src/cmd/smbios/smbios.c b/usr/src/cmd/smbios/smbios.c
index 2bac9156a5..f7c9ed1133 100644
--- a/usr/src/cmd/smbios/smbios.c
+++ b/usr/src/cmd/smbios/smbios.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright 2015 OmniTI Computer Consulting, Inc.  All rights reserved.
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
@@ -334,10 +334,30 @@ print_system(smbios_hdl_t *shp, FILE *fp)
 
 	(void) smbios_info_system(shp, &s);
 
+	/*
+	 * SMBIOS definition section 3.3.2.1 is clear that the first three
+	 * fields are little-endian, but this utility traditionally got this
+	 * wrong, and followed RFC 4122.  We keep this old behavior, but also
+	 * provide a corrected UUID.
+	 */
 	oprintf(fp, "  UUID: ");
-	for (i = 0; i < s.smbs_uuidlen; i++) {
+	oprintf(fp, "%02x%02x%02x%02x-%02x%02x-%02x%02x-",
+	    s.smbs_uuid[0], s.smbs_uuid[1], s.smbs_uuid[2], s.smbs_uuid[3],
+	    s.smbs_uuid[4], s.smbs_uuid[5], s.smbs_uuid[6], s.smbs_uuid[7]);
+	for (i = 8; i < s.smbs_uuidlen; i++) {
+		oprintf(fp, "%02x", s.smbs_uuid[i]);
+		if (i == 9)
+			oprintf(fp, "-");
+	}
+	oprintf(fp, "\n");
+
+	oprintf(fp, "  UUID (Endian-corrected): ");
+	oprintf(fp, "%08x-%04hx-%04hx-", *((uint_t *)&s.smbs_uuid[0]),
+	    *((ushort_t *)&s.smbs_uuid[4]),
+	    *((ushort_t *)&s.smbs_uuid[6]));
+	for (i = 8; i < s.smbs_uuidlen; i++) {
 		oprintf(fp, "%02x", s.smbs_uuid[i]);
-		if (i == 3 || i == 5 || i == 7 || i == 9)
+		if (i == 9)
 			oprintf(fp, "-");
 	}
 	oprintf(fp, "\n");
diff --git a/usr/src/lib/brand/bhyve/zone/boot.c b/usr/src/lib/brand/bhyve/zone/boot.c
index 1fd7208820..bbe828073d 100644
--- a/usr/src/lib/brand/bhyve/zone/boot.c
+++ b/usr/src/lib/brand/bhyve/zone/boot.c
@@ -28,6 +28,7 @@
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/utsname.h>
 #include <unistd.h>
 #include <zone.h>
 
@@ -493,16 +494,15 @@ int
 main(int argc, char **argv)
 {
 	int fd, err;
-	char *zhargv[ZH_MAXARGS] = {
-		"zhyve",	/* Squats on argv[0] */
-		"-H",		/* vmexit on halt isns */
-		"-B", "1,product=SmartDC HVM",
-		NULL };
-	int zhargc;
+	char *zhargv[ZH_MAXARGS] = { NULL, };
+	int zhargc = 0;
 	nvlist_t *nvl;
 	char *nvbuf = NULL;
 	size_t nvbuflen = 0;
 	char zoneroot[MAXPATHLEN];
+	char smbios[MAXPATHLEN];
+	struct utsname utsname;
+	const char *version;
 	int zrfd;
 	char *zonename;
 	char *zonepath;
@@ -520,9 +520,30 @@ main(int argc, char **argv)
 	if (setup_reboot(zonename) < 0)
 		return (1);
 
-	for (zhargc = 0; zhargv[zhargc] != NULL; zhargc++) {
-		dprintf(("def_arg: argv[%d]='%s'\n", zhargc, zhargv[zhargc]));
-	}
+	/*
+	 * Look for something like joyent_20180329T120303Z.  A little mucky, but
+	 * it's exactly what sysinfo does.
+	 */
+	(void) uname(&utsname);
+	if (strncmp(utsname.version, "joyent_", strlen("joyent_")) == 0)
+		version = utsname.version + strlen("joyent_");
+	else
+		version = "?";
+
+	/*
+	 * This is based upon the SMBIOS values we expose to KVM guests.
+	 */
+	(void) snprintf(smbios, sizeof (smbios),
+	    "1,manufacturer=Joyent,product=SmartDC HVM,version=7.%s,"
+	    "serial=%s,sku=001,family=Virtual Machine",
+	    version, zonename);
+
+	zhargv[zhargc++] = "zhyve";
+	zhargv[zhargc++] = "-H";
+	zhargv[zhargc++] = "-B";
+	zhargv[zhargc++] = smbios;
+	zhargv[zhargc++] = "-U";
+	zhargv[zhargc++] = zonename;
 
 	if (add_lpc(&zhargc, (char **)&zhargv) != 0 ||
 	    add_cpu(&zhargc, (char **)&zhargv) != 0 ||
diff --git a/usr/src/man/man1m/smbios.1m b/usr/src/man/man1m/smbios.1m
index 8c71627966..813c317a43 100644
--- a/usr/src/man/man1m/smbios.1m
+++ b/usr/src/man/man1m/smbios.1m
@@ -1,9 +1,10 @@
 '\" te
 .\" Copyright (c) 2005, Sun Microsystems, Inc. All Rights Reserved.
+.\" Copyright 2018 Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH SMBIOS 1M "Aug 31, 2005"
+.TH SMBIOS 1M "March 29, 2018"
 .SH NAME
 smbios \- display the contents of a System Management BIOS image
 .SH SYNOPSIS
@@ -13,7 +14,6 @@ smbios \- display the contents of a System Management BIOS image
 .fi
 
 .SH DESCRIPTION
-.sp
 .LP
 The \fBsmbios\fR utility displays the contents of the System Management BIOS
 (SMBIOS) image exported by the current system or stored in a file. SMBIOS is an
@@ -37,7 +37,6 @@ applied to the resulting file to display its content.
 readable fashion. If \fBsmbios\fR does not recognize a structure's type or
 content, the raw hexadecimal data for the structure is displayed.
 .SH OPTIONS
-.sp
 .LP
 The following options are supported:
 .sp
@@ -131,7 +130,6 @@ human-readable output for the selected structures.
 .RE
 
 .SH OPERANDS
-.sp
 .LP
 The following operands are supported:
 .sp
@@ -145,7 +143,6 @@ SMBIOS image.
 .RE
 
 .SH EXIT STATUS
-.sp
 .LP
 The following exit values are returned:
 .sp
@@ -178,7 +175,6 @@ Invalid command-line options were specified.
 .RE
 
 .SH FILES
-.sp
 .ne 2
 .na
 \fB\fB/dev/smbios\fR \fR
@@ -189,7 +185,6 @@ snapshot of the current system SMBIOS image.
 .RE
 
 .SH ATTRIBUTES
-.sp
 .LP
 See \fBattributes\fR(5) for descriptions of the following attributes:
 .sp
@@ -208,14 +203,12 @@ Interface Stability	See below.
 .LP
 The command-line options are Evolving. The human-readable output is Unstable.
 .SH SEE ALSO
-.sp
 .LP
 \fBprtdiag\fR(1M), \fBattributes\fR(5), \fBsmbios\fR(7D)
 .sp
 .LP
 \fISystem Management BIOS Reference Specification\fR (see http://www.dmtf.org)
 .SH NOTES
-.sp
 .LP
 The implementation of a System Management BIOS image is entirely at the
 discretion of the system and BIOS vendors. Not all systems export an SMBIOS.
@@ -223,3 +216,8 @@ The SMBIOS structure content varies widely between systems and BIOS vendors and
 frequently does not comply with the guidelines included in the specification.
 Some structure fields might not be filled in by the BIOS at all, and others
 might be filled inwith non-conforming values.
+.sp
+.LP
+This utility incorrectly interprets the first three fields of the system
+information UUID field as network-endian; the SMBIOS specification defines them
+as little-endian. The "UUID (Endian-corrected)" field has the correct value.
diff --git a/usr/src/pkg/manifests/system-bhyve.mf b/usr/src/pkg/manifests/system-bhyve.mf
index 9ddbd1cb5f..4b95d3986a 100644
--- a/usr/src/pkg/manifests/system-bhyve.mf
+++ b/usr/src/pkg/manifests/system-bhyve.mf
@@ -30,22 +30,16 @@ set name=info.classification \
     value=org.opensolaris.category.2008:System/Virtualization
 set name=variant.arch value=i386
 dir path=kernel group=sys
-dir path=kernel/kmdb group=sys
-dir path=kernel/kmdb/$(ARCH64) group=sys
 dir path=lib group=bin
 dir path=lib/$(ARCH64) group=bin
 dir path=usr group=sys
 dir path=usr/kernel/drv group=sys
 dir path=usr/kernel/drv/$(ARCH64) group=sys
 dir path=usr/lib group=bin
-dir path=usr/lib/mdb group=sys
-dir path=usr/lib/mdb/kvm group=sys
-dir path=usr/lib/mdb/kvm/$(ARCH64) group=sys
 dir path=usr/sbin
 driver name=ppt
 driver name=viona
 driver name=vmm
-file path=kernel/kmdb/$(ARCH64)/vmm mode=0555
 file path=lib/$(ARCH64)/libvmmapi.so.1
 file path=usr/kernel/drv/$(ARCH64)/ppt
 file path=usr/kernel/drv/$(ARCH64)/viona
@@ -53,7 +47,6 @@ file path=usr/kernel/drv/$(ARCH64)/vmm
 file path=usr/kernel/drv/ppt.conf
 file path=usr/kernel/drv/viona.conf
 file path=usr/kernel/drv/vmm.conf
-file path=usr/lib/mdb/kvm/$(ARCH64)/vmm.so mode=0555
 file path=usr/sbin/bhyve mode=0555
 file path=usr/sbin/bhyvectl mode=0555
 license lic_CDDL license=lic_CDDL
diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx_support.s b/usr/src/uts/i86pc/io/vmm/intel/vmx_support.s
index b97df10b68..c7fc1e7a77 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx_support.s
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx_support.s
@@ -102,6 +102,21 @@ vmx_enter_guest(struct vmxctx *ctx, struct vmx *vmx, int launched)
 	movq	VMXCTX_GUEST_R15(%rdi),%r15;				\
 	movq	VMXCTX_GUEST_RDI(%rdi),%rdi; /* restore rdi the last */
 
+/*
+ * Flush scratch registers to avoid lingering guest state being used for
+ * Spectre v1 attacks when returning from guest entry.
+ */
+#define	VMX_GUEST_FLUSH_SCRATCH						\
+	xorl	%edi, %edi;						\
+	xorl	%esi, %esi;						\
+	xorl	%edx, %edx;						\
+	xorl	%ecx, %ecx;						\
+	xorl	%r8d, %r8d;						\
+	xorl	%r9d, %r9d;						\
+	xorl	%r10d, %r10d;						\
+	xorl	%r11d, %r11d;
+
+
 /* Stack layout (offset from %rsp) for vmx_enter_guest */
 #define	VMXSTK_TMPRDI	0x00	/* temp store %rdi on vmexit		*/
 #define	VMXSTK_R15	0x08	/* callee saved %r15			*/
@@ -223,6 +238,9 @@ inst_error:
 	movq	VMXSTK_R13(%rsp), %r13
 	movq	VMXSTK_R14(%rsp), %r14
 	movq	VMXSTK_R15(%rsp), %r15
+
+	VMX_GUEST_FLUSH_SCRATCH
+
 	addq	$VMXSTKSIZE, %rsp
 	popq	%rbp
 	ret
@@ -277,6 +295,9 @@ ALTENTRY(vmx_exit_guest)
 	movq	VMXSTK_R13(%rsp), %r13
 	movq	VMXSTK_R14(%rsp), %r14
 	movq	VMXSTK_R15(%rsp), %r15
+
+	VMX_GUEST_FLUSH_SCRATCH
+
 	addq	$VMXSTKSIZE, %rsp
 	popq	%rbp
 	ret
diff --git a/usr/src/uts/i86pc/io/vmm/vmm.c b/usr/src/uts/i86pc/io/vmm/vmm.c
index 6332a094d4..2835857bf3 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm.c
@@ -459,7 +459,6 @@ vmm_mod_load()
 {
 	int	error;
 
-	vmmdev_init();
 	error = vmm_init();
 	if (error == 0)
 		vmm_initialized = 1;
@@ -472,7 +471,6 @@ vmm_mod_unload()
 {
 	int	error;
 
-	vmmdev_cleanup();
 	error = VMM_CLEANUP();
 	if (error)
 		return (error);
diff --git a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
index 7841735ef2..12c343e467 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm_sol_dev.c
@@ -77,18 +77,6 @@ static sdev_plugin_hdl_t vmm_sdev_hdl;
 /* From uts/i86pc/io/vmm/intel/vmx.c */
 extern int vmx_x86_supported(char **);
 
-/*
- * vmm trace ring
- */
-int	vmm_dmsg_ring_size = VMM_DMSG_RING_SIZE;
-static	vmm_trace_rbuf_t *vmm_debug_rbuf;
-static	vmm_trace_dmsg_t *vmm_trace_dmsg_alloc(void);
-static	void vmm_trace_dmsg_free(void);
-static	void vmm_trace_rbuf_alloc(void);
-#if notyet
-static	void vmm_trace_rbuf_free(void);
-#endif
-
 /* Holds and hooks from drivers external to vmm */
 struct vmm_hold {
 	list_node_t	vmh_node;
@@ -99,169 +87,6 @@ struct vmm_hold {
 
 static int vmm_drv_block_hook(vmm_softc_t *, boolean_t);
 
-/*
- * This routine is used to manage debug messages
- * on ring buffer.
- */
-static vmm_trace_dmsg_t *
-vmm_trace_dmsg_alloc(void)
-{
-	vmm_trace_dmsg_t *dmsg_alloc, *dmsg = vmm_debug_rbuf->dmsgp;
-
-	if (vmm_debug_rbuf->looped == TRUE) {
-		vmm_debug_rbuf->dmsgp = dmsg->next;
-		return (vmm_debug_rbuf->dmsgp);
-	}
-
-	/*
-	 * If we're looping for the first time,
-	 * connect the ring.
-	 */
-	if (((vmm_debug_rbuf->size + (sizeof (vmm_trace_dmsg_t))) >
-	    vmm_debug_rbuf->maxsize) && (vmm_debug_rbuf->dmsgh != NULL)) {
-		dmsg->next = vmm_debug_rbuf->dmsgh;
-		vmm_debug_rbuf->dmsgp = vmm_debug_rbuf->dmsgh;
-		vmm_debug_rbuf->looped = TRUE;
-		return (vmm_debug_rbuf->dmsgp);
-	}
-
-	/* If we've gotten this far then memory allocation is needed */
-	dmsg_alloc = kmem_zalloc(sizeof (vmm_trace_dmsg_t), KM_NOSLEEP);
-	if (dmsg_alloc == NULL) {
-		vmm_debug_rbuf->allocfailed++;
-		return (dmsg_alloc);
-	} else {
-		vmm_debug_rbuf->size += sizeof (vmm_trace_dmsg_t);
-	}
-
-	if (vmm_debug_rbuf->dmsgp != NULL) {
-		dmsg->next = dmsg_alloc;
-		vmm_debug_rbuf->dmsgp = dmsg->next;
-		return (vmm_debug_rbuf->dmsgp);
-	} else {
-		/*
-		 * We should only be here if we're initializing
-		 * the ring buffer.
-		 */
-		if (vmm_debug_rbuf->dmsgh == NULL) {
-			vmm_debug_rbuf->dmsgh = dmsg_alloc;
-		} else {
-			/* Something is wrong */
-			kmem_free(dmsg_alloc, sizeof (vmm_trace_dmsg_t));
-			return (NULL);
-		}
-
-		vmm_debug_rbuf->dmsgp = dmsg_alloc;
-		return (vmm_debug_rbuf->dmsgp);
-	}
-}
-
-/*
- * Free all messages on debug ring buffer.
- */
-static void
-vmm_trace_dmsg_free(void)
-{
-	vmm_trace_dmsg_t *dmsg_next, *dmsg = vmm_debug_rbuf->dmsgh;
-
-	while (dmsg != NULL) {
-		dmsg_next = dmsg->next;
-		kmem_free(dmsg, sizeof (vmm_trace_dmsg_t));
-
-		/*
-		 * If we've looped around the ring than we're done.
-		 */
-		if (dmsg_next == vmm_debug_rbuf->dmsgh) {
-			break;
-		} else {
-			dmsg = dmsg_next;
-		}
-	}
-}
-
-static void
-vmm_trace_rbuf_alloc(void)
-{
-	vmm_debug_rbuf = kmem_zalloc(sizeof (vmm_trace_rbuf_t), KM_SLEEP);
-
-	mutex_init(&vmm_debug_rbuf->lock, NULL, MUTEX_DRIVER, NULL);
-
-	if (vmm_dmsg_ring_size > 0) {
-		vmm_debug_rbuf->maxsize = vmm_dmsg_ring_size;
-	}
-}
-
-#if notyet
-static void
-vmm_trace_rbuf_free(void)
-{
-	vmm_trace_dmsg_free();
-	mutex_destroy(&vmm_debug_rbuf->lock);
-	kmem_free(vmm_debug_rbuf, sizeof (vmm_trace_rbuf_t));
-}
-#endif
-
-static void
-vmm_vtrace_log(const char *fmt, va_list ap)
-{
-	vmm_trace_dmsg_t *dmsg;
-
-	if (vmm_debug_rbuf == NULL) {
-		return;
-	}
-
-	/*
-	 * If max size of ring buffer is smaller than size
-	 * required for one debug message then just return
-	 * since we have no room for the debug message.
-	 */
-	if (vmm_debug_rbuf->maxsize < (sizeof (vmm_trace_dmsg_t))) {
-		return;
-	}
-
-	mutex_enter(&vmm_debug_rbuf->lock);
-
-	/* alloc or reuse on ring buffer */
-	dmsg = vmm_trace_dmsg_alloc();
-
-	if (dmsg == NULL) {
-		/* resource allocation failed */
-		mutex_exit(&vmm_debug_rbuf->lock);
-		return;
-	}
-
-	gethrestime(&dmsg->timestamp);
-
-	(void) vsnprintf(dmsg->buf, sizeof (dmsg->buf), fmt, ap);
-
-	mutex_exit(&vmm_debug_rbuf->lock);
-}
-
-void
-vmm_trace_log(const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	vmm_vtrace_log(fmt, ap);
-	va_end(ap);
-}
-
-void
-vmmdev_init(void)
-{
-	vmm_trace_rbuf_alloc();
-}
-
-int
-vmmdev_cleanup(void)
-{
-	VERIFY(list_is_empty(&vmmdev_list));
-
-	vmm_trace_dmsg_free();
-	return (0);
-}
-
 static int
 vmmdev_get_memseg(vmm_softc_t *sc, struct vm_memseg *mseg)
 {
diff --git a/usr/src/uts/i86pc/os/pc_hvm.c b/usr/src/uts/i86pc/os/pc_hvm.c
index b74ceb17bf..60f8e8d3ca 100644
--- a/usr/src/uts/i86pc/os/pc_hvm.c
+++ b/usr/src/uts/i86pc/os/pc_hvm.c
@@ -10,9 +10,12 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
+#include <sys/cmn_err.h>
+#include <sys/ddi.h>
+#include <sys/sunddi.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/mutex.h>
@@ -35,12 +38,17 @@ static const char *hvm_excl_holder = NULL;
 boolean_t
 hvm_excl_hold(const char *consumer)
 {
-	boolean_t res = B_FALSE;
+	boolean_t res;
 
 	mutex_enter(&hvm_excl_lock);
 	if (hvm_excl_holder == NULL) {
 		hvm_excl_holder = consumer;
 		res = B_TRUE;
+	} else {
+		cmn_err(CE_WARN, "zone '%s' cannot take HVM exclusion lock as "
+		    "'%s': held by '%s'", curproc->p_zone->zone_name, consumer,
+		    hvm_excl_holder);
+		res = B_FALSE;
 	}
 	mutex_exit(&hvm_excl_lock);
 
diff --git a/usr/src/uts/i86pc/sys/vmm_dev.h b/usr/src/uts/i86pc/sys/vmm_dev.h
index d9cb23ece9..e037089239 100644
--- a/usr/src/uts/i86pc/sys/vmm_dev.h
+++ b/usr/src/uts/i86pc/sys/vmm_dev.h
@@ -42,11 +42,6 @@
 #ifndef	_VMM_DEV_H_
 #define	_VMM_DEV_H_
 
-#ifdef _KERNEL
-void	vmmdev_init(void);
-int	vmmdev_cleanup(void);
-#endif
-
 struct vm_memmap {
 	vm_paddr_t	gpa;
 	int		segid;		/* memory segment */
diff --git a/usr/src/uts/i86pc/sys/vmm_impl.h b/usr/src/uts/i86pc/sys/vmm_impl.h
index 4d5708e48d..db2c4ab991 100644
--- a/usr/src/uts/i86pc/sys/vmm_impl.h
+++ b/usr/src/uts/i86pc/sys/vmm_impl.h
@@ -78,37 +78,4 @@ int vmm_do_vm_destroy(vmm_softc_t *, boolean_t);
 
 #endif /* _KERNEL */
 
-/*
- * VMM trace ring buffer constants
- */
-#define	VMM_DMSG_RING_SIZE		0x100000	/* 1MB */
-#define	VMM_DMSG_BUF_SIZE		256
-
-/*
- * VMM trace ring buffer content
- */
-typedef struct vmm_trace_dmsg {
-	timespec_t		timestamp;
-	char			buf[VMM_DMSG_BUF_SIZE];
-	struct vmm_trace_dmsg	*next;
-} vmm_trace_dmsg_t;
-
-/*
- * VMM trace ring buffer header
- */
-typedef struct vmm_trace_rbuf {
-	kmutex_t		lock;		/* lock to avoid clutter */
-	int			looped;		/* completed ring */
-	int			allocfailed;	/* dmsg mem alloc failed */
-	size_t			size;		/* current size */
-	size_t			maxsize;	/* max size */
-	vmm_trace_dmsg_t	*dmsgh;		/* messages head */
-	vmm_trace_dmsg_t	*dmsgp;		/* ptr to last message */
-} vmm_trace_rbuf_t;
-
-/*
- * VMM trace ring buffer interfaces
- */
-void vmm_trace_log(const char *fmt, ...);
-
 #endif	/* _VMM_IMPL_H_ */
-- 
2.21.0

