From 8c889f76564bc93f6493ac0465901da776cc2421 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Wed, 4 Apr 2018 16:22:48 +0000
Subject: [PATCH] OS-6727 bhyve should provide zone UUID to guest via SMBIOS

---
 usr/src/cmd/smbios/Makefile         |   4 ++
 usr/src/cmd/smbios/smbios.c         |  26 ++++++-
 usr/src/cmd/zoneadmd/zoneadmd.c     |   9 +++
 usr/src/lib/brand/bhyve/zone/boot.c | 107 +++++++++++++++++++---------
 usr/src/man/man1m/smbios.1m         |  16 ++---
 5 files changed, 115 insertions(+), 47 deletions(-)

diff --git a/usr/src/cmd/smbios/Makefile b/usr/src/cmd/smbios/Makefile
index f3d7803a78..eec224f524 100644
--- a/usr/src/cmd/smbios/Makefile
+++ b/usr/src/cmd/smbios/Makefile
@@ -22,6 +22,8 @@
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2018 Joyent, Inc.
+#
 
 PROG = smbios
 OBJS = smbios.o
@@ -35,6 +37,8 @@ LDLIBS += -lsmbios
 FILEMODE = 0555
 STRIPFLAG =
 
+LINTFLAGS += -erroff=E_BAD_PTR_CAST_ALIGN
+
 .KEEP_STATE:
 
 all: $(PROG)
diff --git a/usr/src/cmd/smbios/smbios.c b/usr/src/cmd/smbios/smbios.c
index 2bac9156a5..f7c9ed1133 100644
--- a/usr/src/cmd/smbios/smbios.c
+++ b/usr/src/cmd/smbios/smbios.c
@@ -21,7 +21,7 @@
 
 /*
  * Copyright 2015 OmniTI Computer Consulting, Inc.  All rights reserved.
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
@@ -334,10 +334,30 @@ print_system(smbios_hdl_t *shp, FILE *fp)
 
 	(void) smbios_info_system(shp, &s);
 
+	/*
+	 * SMBIOS definition section 3.3.2.1 is clear that the first three
+	 * fields are little-endian, but this utility traditionally got this
+	 * wrong, and followed RFC 4122.  We keep this old behavior, but also
+	 * provide a corrected UUID.
+	 */
 	oprintf(fp, "  UUID: ");
-	for (i = 0; i < s.smbs_uuidlen; i++) {
+	oprintf(fp, "%02x%02x%02x%02x-%02x%02x-%02x%02x-",
+	    s.smbs_uuid[0], s.smbs_uuid[1], s.smbs_uuid[2], s.smbs_uuid[3],
+	    s.smbs_uuid[4], s.smbs_uuid[5], s.smbs_uuid[6], s.smbs_uuid[7]);
+	for (i = 8; i < s.smbs_uuidlen; i++) {
+		oprintf(fp, "%02x", s.smbs_uuid[i]);
+		if (i == 9)
+			oprintf(fp, "-");
+	}
+	oprintf(fp, "\n");
+
+	oprintf(fp, "  UUID (Endian-corrected): ");
+	oprintf(fp, "%08x-%04hx-%04hx-", *((uint_t *)&s.smbs_uuid[0]),
+	    *((ushort_t *)&s.smbs_uuid[4]),
+	    *((ushort_t *)&s.smbs_uuid[6]));
+	for (i = 8; i < s.smbs_uuidlen; i++) {
 		oprintf(fp, "%02x", s.smbs_uuid[i]);
-		if (i == 3 || i == 5 || i == 7 || i == 9)
+		if (i == 9)
 			oprintf(fp, "-");
 	}
 	oprintf(fp, "\n");
diff --git a/usr/src/cmd/zoneadmd/zoneadmd.c b/usr/src/cmd/zoneadmd/zoneadmd.c
index 60af30d40b..59e43a37ec 100644
--- a/usr/src/cmd/zoneadmd/zoneadmd.c
+++ b/usr/src/cmd/zoneadmd/zoneadmd.c
@@ -104,6 +104,7 @@
 #include <libdladm.h>
 #include <sys/dls_mgmt.h>
 #include <libscf.h>
+#include <uuid/uuid.h>
 
 #include <libzonecfg.h>
 #include <zonestat_impl.h>
@@ -841,11 +842,19 @@ setup_subproc_env(boolean_t debug)
 	char net_resources[MAXNAMELEN * 2];
 	char dev_resources[MAXNAMELEN * 2];
 	char didstr[16];
+	char uuidstr[UUID_PRINTABLE_STRING_LENGTH];
+	uuid_t uuid;
 
 	/* snap_hndl is null when called through the set_brand_env code path */
 	if (snap_hndl == NULL)
 		return (Z_OK);
 
+	if ((res = zonecfg_get_uuid(zone_name, uuid)) != Z_OK)
+		return (res);
+
+	uuid_unparse(uuid, uuidstr);
+	(void) setenv("_ZONECFG_uuid", uuidstr, 1);
+
 	(void) snprintf(didstr, sizeof (didstr), "%d", zone_did);
 	(void) setenv("_ZONECFG_did", didstr, 1);
 
diff --git a/usr/src/lib/brand/bhyve/zone/boot.c b/usr/src/lib/brand/bhyve/zone/boot.c
index 1fd7208820..b8c4fa062b 100644
--- a/usr/src/lib/brand/bhyve/zone/boot.c
+++ b/usr/src/lib/brand/bhyve/zone/boot.c
@@ -28,6 +28,7 @@
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/utsname.h>
 #include <unistd.h>
 #include <zone.h>
 
@@ -48,11 +49,13 @@ typedef enum {
 	PCI_SLOT_NICS
 } pci_slot_t;
 
-boolean_t debug;
+static boolean_t debug;
+static const char *zonename;
+static const char *zonepath;
 
 #define	dprintf(x) if (debug) (void)printf x
 
-char *
+static char *
 get_zcfg_var(const char *rsrc, const char *inst, const char *prop)
 {
 	char envvar[MAXNAMELEN];
@@ -77,7 +80,7 @@ get_zcfg_var(const char *rsrc, const char *inst, const char *prop)
 	return (ret);
 }
 
-boolean_t
+static boolean_t
 is_env_true(const char *rsrc, const char *inst, const char *prop)
 {
 	char *val = get_zcfg_var(rsrc, inst, prop);
@@ -85,8 +88,8 @@ is_env_true(const char *rsrc, const char *inst, const char *prop)
 	return (val != NULL && strcmp(val, "true") == 0);
 }
 
-int
-add_arg(int *argc, char **argv, char *val)
+static int
+add_arg(int *argc, char **argv, const char *val)
 {
 	if (*argc >= ZH_MAXARGS) {
 		(void) printf("Error: too many arguments\n");
@@ -99,7 +102,46 @@ add_arg(int *argc, char **argv, char *val)
 	return (0);
 }
 
-int
+static int
+add_smbios(int *argc, char **argv)
+{
+	char smbios[MAXPATHLEN];
+	struct utsname utsname;
+	const char *version;
+	const char *uuid;
+
+	/*
+	 * Look for something like joyent_20180329T120303Z.  A little mucky, but
+	 * it's exactly what sysinfo does.
+	 */
+	(void) uname(&utsname);
+	if (strncmp(utsname.version, "joyent_", strlen("joyent_")) == 0)
+		version = utsname.version + strlen("joyent_");
+	else
+		version = "?";
+
+	/*
+	 * This is based upon the SMBIOS values we expose to KVM guests.
+	 */
+	(void) snprintf(smbios, sizeof (smbios),
+	    "1,manufacturer=Joyent,product=SmartDC HVM,version=7.%s,"
+	    "serial=%s,sku=001,family=Virtual Machine",
+	    version, zonename);
+
+	if (add_arg(argc, argv, "-B") != 0 ||
+	    add_arg(argc, argv, smbios) != 0)
+		return (1);
+
+	if ((uuid = getenv("_ZONECFG_uuid")) != NULL) {
+		if (add_arg(argc, argv, "-U") != 0 ||
+		    add_arg(argc, argv, uuid) != 0)
+			return (1);
+	}
+
+	return (0);
+}
+
+static int
 add_cpu(int *argc, char **argv)
 {
 	char *val;
@@ -113,7 +155,7 @@ add_cpu(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_ram(int *argc, char **argv)
 {
 	char *val;
@@ -127,7 +169,7 @@ add_ram(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 {
 	static char *boot = NULL;
@@ -165,7 +207,7 @@ add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 	return (0);
 }
 
-int
+static int
 add_ppt(int *argc, char **argv, char *ppt, char *path, char *slotconf,
     size_t slotconf_len)
 {
@@ -191,25 +233,26 @@ add_ppt(int *argc, char **argv, char *ppt, char *path, char *slotconf,
 		bus = 0;
 		break;
 	default:
-		(void) printf("Error: device %s has illegal PCI slot: %s\n",
+		(void) printf("Error: device %d has illegal PCI slot: %s\n",
 		    dev, pcislot);
 		return (-1);
 	}
 
 	if (bus > 255 || dev > 31 || func > 7) {
-		(void) printf("Error: device %s has illegal PCI slot: %s\n",
+		(void) printf("Error: device %d has illegal PCI slot: %s\n",
 		    dev, pcislot);
 		return (-1);
 	}
 
 	if (bus > 0) {
-		if (!acpi)
-			add_arg(argc, argv, "-A");
+		if (!acpi && add_arg(argc, argv, "-A") != 0)
+			return (-1);
 		acpi = B_TRUE;
 	}
 
-	if (!wired)
-		add_arg(argc, argv, "-S");
+	if (!wired && add_arg(argc, argv, "-S") != 0)
+		return (-1);
+
 	wired = B_TRUE;
 
 	if (snprintf(slotconf, slotconf_len, "%d:%d:%d,passthru,%s",
@@ -221,7 +264,7 @@ add_ppt(int *argc, char **argv, char *ppt, char *path, char *slotconf,
 	return (0);
 }
 
-int
+static int
 add_devices(int *argc, char **argv)
 {
 	char *devices;
@@ -277,7 +320,7 @@ add_devices(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_nets(int *argc, char **argv)
 {
 	char *nets;
@@ -331,7 +374,7 @@ add_nets(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_lpc(int *argc, char **argv)
 {
 	char *lpcdevs[] = { "bootrom", "com1", "com2", NULL };
@@ -378,7 +421,7 @@ add_lpc(int *argc, char **argv)
 	return (0);
 }
 
-int
+static int
 add_bhyve_extra_opts(int *argc, char **argv)
 {
 	char *val;
@@ -410,7 +453,7 @@ add_bhyve_extra_opts(int *argc, char **argv)
 }
 
 /* Must be called last */
-int
+static int
 add_vmname(int *argc, char **argv)
 {
 	char buf[32];				/* VM_MAX_NAMELEN */
@@ -433,7 +476,7 @@ add_vmname(int *argc, char **argv)
  * paranoid and call fdsync() at the end.  That's not really need for this use
  * case because it is being written to tmpfs.
  */
-int
+static int
 full_write(int fd, char *buf, size_t buflen)
 {
 	ssize_t nwritten;
@@ -455,7 +498,7 @@ full_write(int fd, char *buf, size_t buflen)
 	return (0);
 }
 
-void
+static void
 init_debug(void)
 {
 	char *val = getenv("_ZONEADMD_brand_debug");
@@ -464,7 +507,7 @@ init_debug(void)
 }
 
 static int
-setup_reboot(char *zonename)
+setup_reboot(void)
 {
 	zoneid_t	zoneid;
 
@@ -481,7 +524,7 @@ setup_reboot(char *zonename)
 
 	if (zone_setattr(zoneid, ZONE_ATTR_INITREBOOT, NULL, 0) < 0 ||
 	    zone_setattr(zoneid, ZONE_ATTR_INITRESTART0, NULL, 0) < 0) {
-		(void) printf("Error: bhyve zoneid %d setattr failed: %s\n",
+		(void) printf("Error: bhyve zoneid %ld setattr failed: %s\n",
 		    zoneid, strerror(errno));
 		return (-1);
 	}
@@ -496,16 +539,13 @@ main(int argc, char **argv)
 	char *zhargv[ZH_MAXARGS] = {
 		"zhyve",	/* Squats on argv[0] */
 		"-H",		/* vmexit on halt isns */
-		"-B", "1,product=SmartDC HVM",
 		NULL };
-	int zhargc;
+	int zhargc = 2;
 	nvlist_t *nvl;
 	char *nvbuf = NULL;
 	size_t nvbuflen = 0;
 	char zoneroot[MAXPATHLEN];
 	int zrfd;
-	char *zonename;
-	char *zonepath;
 
 	init_debug();
 
@@ -517,14 +557,11 @@ main(int argc, char **argv)
 	zonename = argv[1];
 	zonepath = argv[2];
 
-	if (setup_reboot(zonename) < 0)
+	if (setup_reboot() < 0)
 		return (1);
 
-	for (zhargc = 0; zhargv[zhargc] != NULL; zhargc++) {
-		dprintf(("def_arg: argv[%d]='%s'\n", zhargc, zhargv[zhargc]));
-	}
-
-	if (add_lpc(&zhargc, (char **)&zhargv) != 0 ||
+	if (add_smbios(&zhargc, (char **)&zhargv) != 0 ||
+	    add_lpc(&zhargc, (char **)&zhargv) != 0 ||
 	    add_cpu(&zhargc, (char **)&zhargv) != 0 ||
 	    add_ram(&zhargc, (char **)&zhargv) != 0 ||
 	    add_devices(&zhargc, (char **)&zhargv) != 0 ||
@@ -578,7 +615,7 @@ main(int argc, char **argv)
 	 */
 	if (mkdirat(zrfd, BHYVE_DIR, 0700) != 0 && errno != EEXIST) {
 		(void) printf("Error: failed to create directory %s "
-		    "in zone: %s\n" BHYVE_DIR, strerror(errno));
+		    "in zone: %s\n", BHYVE_DIR, strerror(errno));
 		return (1);
 	}
 
diff --git a/usr/src/man/man1m/smbios.1m b/usr/src/man/man1m/smbios.1m
index 8c71627966..813c317a43 100644
--- a/usr/src/man/man1m/smbios.1m
+++ b/usr/src/man/man1m/smbios.1m
@@ -1,9 +1,10 @@
 '\" te
 .\" Copyright (c) 2005, Sun Microsystems, Inc. All Rights Reserved.
+.\" Copyright 2018 Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH SMBIOS 1M "Aug 31, 2005"
+.TH SMBIOS 1M "March 29, 2018"
 .SH NAME
 smbios \- display the contents of a System Management BIOS image
 .SH SYNOPSIS
@@ -13,7 +14,6 @@ smbios \- display the contents of a System Management BIOS image
 .fi
 
 .SH DESCRIPTION
-.sp
 .LP
 The \fBsmbios\fR utility displays the contents of the System Management BIOS
 (SMBIOS) image exported by the current system or stored in a file. SMBIOS is an
@@ -37,7 +37,6 @@ applied to the resulting file to display its content.
 readable fashion. If \fBsmbios\fR does not recognize a structure's type or
 content, the raw hexadecimal data for the structure is displayed.
 .SH OPTIONS
-.sp
 .LP
 The following options are supported:
 .sp
@@ -131,7 +130,6 @@ human-readable output for the selected structures.
 .RE
 
 .SH OPERANDS
-.sp
 .LP
 The following operands are supported:
 .sp
@@ -145,7 +143,6 @@ SMBIOS image.
 .RE
 
 .SH EXIT STATUS
-.sp
 .LP
 The following exit values are returned:
 .sp
@@ -178,7 +175,6 @@ Invalid command-line options were specified.
 .RE
 
 .SH FILES
-.sp
 .ne 2
 .na
 \fB\fB/dev/smbios\fR \fR
@@ -189,7 +185,6 @@ snapshot of the current system SMBIOS image.
 .RE
 
 .SH ATTRIBUTES
-.sp
 .LP
 See \fBattributes\fR(5) for descriptions of the following attributes:
 .sp
@@ -208,14 +203,12 @@ Interface Stability	See below.
 .LP
 The command-line options are Evolving. The human-readable output is Unstable.
 .SH SEE ALSO
-.sp
 .LP
 \fBprtdiag\fR(1M), \fBattributes\fR(5), \fBsmbios\fR(7D)
 .sp
 .LP
 \fISystem Management BIOS Reference Specification\fR (see http://www.dmtf.org)
 .SH NOTES
-.sp
 .LP
 The implementation of a System Management BIOS image is entirely at the
 discretion of the system and BIOS vendors. Not all systems export an SMBIOS.
@@ -223,3 +216,8 @@ The SMBIOS structure content varies widely between systems and BIOS vendors and
 frequently does not comply with the guidelines included in the specification.
 Some structure fields might not be filled in by the BIOS at all, and others
 might be filled inwith non-conforming values.
+.sp
+.LP
+This utility incorrectly interprets the first three fields of the system
+information UUID field as network-endian; the SMBIOS specification defines them
+as little-endian. The "UUID (Endian-corrected)" field has the correct value.
-- 
2.21.0

