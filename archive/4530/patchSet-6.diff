From 49aec0b0b7ce840c197fd11fa8623ca749526839 Mon Sep 17 00:00:00 2001
From: Rui Loura <rui@joyent.com>
Date: Thu, 10 May 2018 14:31:10 +0000
Subject: [PATCH] MANTA-3822 manta deployment zone should be aware of alternate
 admin nictags

---
 cmd/manta-factoryreset.js |  85 ++++++---------
 cmd/manta-init.js         |  83 ++++++---------
 lib/adm.js                |  10 +-
 lib/common.js             | 212 +++++++++++++++++++++++++++++++++++++-
 lib/deploy.js             | 166 ++++++++++++++++++++++-------
 networking/manta-net.sh   |   4 +-
 6 files changed, 410 insertions(+), 150 deletions(-)

diff --git a/cmd/manta-factoryreset.js b/cmd/manta-factoryreset.js
index 44ca54d..5c5d511 100755
--- a/cmd/manta-factoryreset.js
+++ b/cmd/manta-factoryreset.js
@@ -6,7 +6,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -24,6 +24,9 @@ var sdc = require('sdc-clients');
 var sprintf = require('util').format;
 var stdin = process.openStdin();
 var vasync = require('vasync');
+var verror = require('verror');
+
+var VError = verror.VError;
 
 
 // -- Globals
@@ -49,59 +52,31 @@ function usage() {
 
 // -- Helpers
 
-function removeUserFromNetwork(name, owner_uuid, cb) {
-	var napi = self.NAPI;
-	var log = self.log;
-
-	assert.string(name, 'name');
-	assert.string(owner_uuid, 'owner_uuid');
-	assert.func(cb, 'cb');
-
-	log.info('remove user %s from network "%s"', owner_uuid, name);
-
-	napi.listNetworks({ name: name }, function (err, networks) {
-		if (err) {
-			log.error(err, 'failed to list networks');
-			return (cb(err));
-		}
-
-		if (networks.length === 0) {
-			log.info('network "%s" not found', name);
-			return (cb(null));
+/*
+ * Callback method for common.updateNetworkUsers.
+ */
+function removeUserFromNetwork(owner_uuid, network_uuids, callback) {
+	var uuids = [];
+	var foundUser = false;
+
+	network_uuids.forEach(function (uuid) {
+		if (uuid === owner_uuid) {
+			foundUser = true;
+		} else {
+			uuids.push(uuid);
 		}
+	});
 
-		var network = networks[0];
-
-		var uuids = network.owner_uuids || [];
-
-		var foundUser = false;
-		var newUuids = [];
-		uuids.forEach(function (uuid) {
-			if (uuid === owner_uuid) {
-				foundUser = true;
-			} else {
-				newUuids.push(uuid);
-			}
-		});
-
-		if (!foundUser) {
-			log.info('user %s not owner of network "%s"',
-				owner_uuid, name);
-			return (cb(null));
-		}
+	if (!foundUser) {
+		var e = new VError({
+		    name: 'UserNotFoundError',
+		    info: { errno: 'ENOENT' }
+		}, 'User %s is not an owner of this network', owner_uuid);
 
-		napi.updateNetwork(network.uuid, { owner_uuids : newUuids },
-			function (suberr) {
-			if (suberr) {
-				log.error(suberr, 'failed to update network');
-				return (cb(suberr));
-			}
+		return (callback(e));
+	}
 
-			log.info('removed user %s from network "%s"',
-				owner_uuid, name);
-			return (cb(null));
-		});
-	});
+	return (callback(null, uuids));
 }
 
 // -- Mainline
@@ -463,8 +438,14 @@ async.waterfall([
 
 		vasync.forEachParallel({
 			func: function (network, subcb) {
-				removeUserFromNetwork.call(self,
-					network, POSEIDON.uuid, subcb);
+				common.updateNetworkUsers({
+				    name: network,
+				    owner_uuid: POSEIDON.uuid,
+				    napi: self.NAPI,
+				    log: self.log,
+				    action: 'remove',
+				    update_func: removeUserFromNetwork
+				}, subcb);
 			},
 			inputs: networks
 		}, function (err, results) {
diff --git a/cmd/manta-init.js b/cmd/manta-init.js
index 6059a43..9d78304 100755
--- a/cmd/manta-init.js
+++ b/cmd/manta-init.js
@@ -7,7 +7,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -27,6 +27,7 @@ var ssh = require('../lib/ssh');
 var url = require('url');
 var node_uuid = require('node-uuid');
 var vasync = require('vasync');
+var verror = require('verror');
 
 var Logger = require('bunyan');
 
@@ -34,6 +35,8 @@ var exec = require('child_process').exec;
 var sprintf = require('util').format;
 
 
+var VError = verror.VError;
+
 // -- Globals
 
 var POSEIDON;
@@ -170,60 +173,28 @@ function updateEmail(user, email, cb) {
 // -- Network management
 
 /*
- * Update the specified network to include owner_uuid in the set of users
- * allowed to provision zones on this network.
+ * Update the specified network, network_pool, and any networks that are part
+ * of the named network_pool to include owner_uuid in the set of users allowed
+ * to provision zones on this network.
  */
-function addUserToNetwork(name, owner_uuid, cb) {
-	var napi = self.NAPI;
-	var log = self.log;
-
-	assert.string(name, 'name');
-	assert.string(owner_uuid, 'owner_uuid');
-	assert.func(cb, 'cb');
-
-	log.info('adding user %s to network "%s"', owner_uuid, name);
-
-	napi.listNetworks({ name: name }, function (err, networks) {
-		if (err) {
-			log.error(err, 'failed to list networks');
-			return (cb(err));
-		}
-
-		if (networks.length === 0) {
-			log.info('network "%s" not found', name);
-			return (cb(null));
-		}
-
-		var network = networks[0];
 
-		var uuids = network.owner_uuids || [];
-
-		var foundUser = false;
-		uuids.forEach(function (uuid) {
-			if (uuid === owner_uuid)
-				foundUser = true;
-		});
-
-		if (foundUser) {
-			log.info('user %s already allowed for network "%s"',
-			    owner_uuid, name);
-			return (cb(null));
-		}
-
-		uuids.push(owner_uuid);
+/*
+ * Callback method for common.updateNetworkUsers.
+ */
+function addUserToNetwork(owner_uuid, network_uuids, callback) {
+	var uuids = [];
+
+	if (network_uuids.indexOf(owner_uuid) !== -1) {
+		var e = new VError({
+		    name: 'UserExistsError',
+		    info: { errno: 'EEXISTS' }
+		}, 'user %s already allowed for this network', owner_uuid);
+		return (callback(e));
+	}
 
-		napi.updateNetwork(network.uuid, { owner_uuids : uuids },
-		    function (suberr) {
-			if (suberr) {
-				log.error(suberr, 'failed to update network');
-				return (cb(suberr));
-			}
+	uuids = network_uuids.concat(owner_uuid);
 
-			log.info('updated network "%s" with user %s',
-			    name, owner_uuid);
-			return (cb(null));
-		});
-	});
+	return (callback(null, uuids));
 }
 
 
@@ -530,8 +501,14 @@ async.waterfall([
 
 		vasync.forEachParallel({
 			func: function (network, subcb) {
-				addUserToNetwork.call(self,
-				    network, POSEIDON.uuid, subcb);
+				common.updateNetworkUsers({
+				    name: network,
+				    owner_uuid: POSEIDON.uuid,
+				    napi: self.NAPI,
+				    log: self.log,
+				    action: 'add',
+				    update_func: addUserToNetwork
+				}, subcb);
 			},
 			inputs: networks
 		}, function (err, results) {
diff --git a/lib/adm.js b/lib/adm.js
index 3c2a117..3165112 100644
--- a/lib/adm.js
+++ b/lib/adm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -2972,9 +2972,11 @@ maAdm.prototype.loadCns = function ()
 	var gzinfo, cnid, cn;
 	var ifaces, ifacename, iface;
 	var cids;
+	var admin_tag;
 
 	gzinfo = {};
 	for (cnid in this.ma_cns) {
+		admin_tag = 'admin';
 		cn = this.ma_cns[cnid];
 		if (cn === null)
 			continue;
@@ -2987,10 +2989,14 @@ maAdm.prototype.loadCns = function ()
 		    'compute_id': null,
 		    'storage_ids': []
 		};
+
 		ifaces = cn['sysinfo']['Network Interfaces'];
+		if (cn['sysinfo']['Admin NIC Tag']) {
+			admin_tag = cn['sysinfo']['Admin NIC Tag'];
+		}
 		for (ifacename in ifaces) {
 			iface = ifaces[ifacename];
-			if (iface['NIC Names'].indexOf('admin') == -1)
+			if (iface['NIC Names'].indexOf(admin_tag) == -1)
 				continue;
 
 			gzinfo[cnid]['admin_ip'] = iface['ip4addr'];
diff --git a/lib/common.js b/lib/common.js
index 349c19e..e36b401 100644
--- a/lib/common.js
+++ b/lib/common.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -697,6 +697,214 @@ function fmtDuration(ms)
 	return (rv);
 }
 
+/*
+ * Update the specified network, network_pool, and any networks that are part
+ * of the named network_pool to include or exclude owner_uuid in the set of
+ * users allowed to provision zones on this network.  Inclusion or exclusion
+ * action is dependent on the update_func method.
+ */
+function updateNetworkUsers(opts, callback) {
+	assert.string(opts.name, 'opts.name');
+	assert.string(opts.owner_uuid, 'opts.owner_uuid');
+	assert.string(opts.action, 'opts.action');
+	assert.object(opts.napi, 'opts.napi');
+	assert.object(opts.log, 'opts.log');
+	assert.func(opts.update_func, 'update_func');
+	assert.func(callback, 'callback');
+
+	var napi = opts.napi;
+	var log = opts.log;
+	var update_func = opts.update_func;
+	var name = opts.name;
+	var owner_uuid = opts.owner_uuid;
+	var action = opts.action;
+
+	log.info('Attempting to %s user %s permission\'s for network "%s"',
+		action, owner_uuid, name);
+
+	var _updateNetworkUserCommon = function (network, cb) {
+		var network_uuids = network.owner_uuids || [];
+
+		update_func(owner_uuid, network_uuids, function (err, uuids) {
+			if (err) {
+			        var e = err;
+				log.warn({err: err}, 'could not update user %s '
+				    + 'on network "%s"', owner_uuid, name);
+				if ((action === 'add' &&
+				    err.name === 'UserExistsError') ||
+				    (action === 'remove' &&
+				    err.name === 'UserNotFoundError')) {
+					e = null;
+				}
+
+				cb(e);
+				return;
+			}
+
+			napi.updateNetwork(network.uuid,
+			    { owner_uuids : uuids }, function (suberr) {
+
+				if (suberr) {
+					log.error(suberr, 'failed to update '
+					    + 'network');
+					cb(suberr);
+					return;
+				}
+
+				log.info('successfully updated network "%s"',
+				    name);
+				cb(null);
+				return;
+			});
+		});
+	};
+
+    var _updateNetworkUserByUUID = function (uuid, cb) {
+	napi.getNetwork(uuid, function (err, network) {
+	    if (err) {
+		log.error(err, 'failed to get network with uuid (%s)', uuid);
+		return (cb(err));
+	    }
+	    _updateNetworkUserCommon(network, cb);
+	});
+    };
+
+    vasync.pipeline({
+	arg: name,
+	funcs: [
+	    function updatePools(n, cb) {
+		/*
+		 * If the network pool is missing there's nothing to update.
+		 */
+		napi.listNetworkPools({ name: n }, function (err, pools) {
+		    if (err) {
+			log.error(err, 'failed to list network pools of name '
+			    + '"%s"', n);
+			cb(err);
+			return;
+		    }
+
+		    if (pools.length === 0) {
+			log.info('network pool "%s" not found', n);
+			cb(null);
+			return;
+		    }
+
+		    if (pools.length > 1) {
+			log.warn('more than one network pool with the name '
+			    + '"%s" found, skipping all', n);
+			cb(null);
+			return;
+		    }
+
+		    vasync.forEachParallel({
+			'func': _updateNetworkUserByUUID,
+			'inputs': pools[0].networks
+		    }, function (suberr, results) {
+			cb(suberr);
+		    });
+		});
+	    },
+	    function updateNetworks(n, cb) {
+		napi.listNetworks({ name: n }, function (err, networks) {
+		    if (err) {
+			log.error(err, 'failed to list networks');
+			cb(err);
+			return;
+		    }
+
+		    if (networks.length === 0) {
+			log.info('network "%s" not found', n);
+			cb(null);
+			return;
+		    }
+
+		    _updateNetworkUserCommon(networks[0], cb);
+	    });
+	}]
+    }, function (err, results) {
+	callback(err);
+    });
+}
+
+/*
+ * Get server nictags from sysinfo.
+ */
+function getServerNicTags(cb) {
+	var self = this;
+	var uuid = self.options.server_uuid;
+	var cnapi = self.CNAPI;
+
+	if (!uuid) {
+		self.log.error({options: self.options},
+		    'missing server uuid, cannot get nic tags');
+		return;
+	}
+
+	/*
+	 * Copied from DAPI with slight modifications. :(
+	 */
+	function getTags(interfaces, vnics) {
+		assert.object(interfaces, 'interfaces');
+		assert.object(vnics, 'vnics');
+
+		var onlineTags = [];
+		var offlineTags = [];
+
+		Object.keys(interfaces).forEach(function (nicName) {
+			var nic = interfaces[nicName];
+			var nicStatus = nic['Link Status'];
+			var nicTags   = nic['NIC Names'];
+			var tagIndex;
+
+			nic.interface = nicName;
+
+			tagIndex = (nicStatus === 'up' ?
+			    onlineTags : offlineTags);
+
+			for (var i = 0; i !== nicTags.length; i++) {
+				tagIndex.push(nicTags[i]);
+			}
+		});
+
+		Object.keys(vnics).forEach(function (nicName) {
+			var nic = vnics[nicName];
+			var nicStatus = nic['Link Status'];
+			var nicTags   = nic['Overlay Nic Tags'] || [];
+			var tagIndex;
+
+			nic.interface = nicName;
+
+			tagIndex = (nicStatus === 'up' ?
+			    onlineTags : offlineTags);
+
+			for (var i = 0; i !== nicTags.length; i++) {
+				tagIndex.push(nicTags[i]);
+			}
+		});
+
+		return {
+			online: onlineTags,
+			offline: offlineTags
+		};
+	}
+
+	cnapi.getServer(uuid, function (err, server) {
+		if (err) {
+			cb(err);
+			return;
+		}
+		var sysinfo = server.sysinfo;
+		var interfaces = sysinfo['Network Interfaces'];
+		var vnics = sysinfo['Virtual Network Interfaces'] || {};
+
+		var tags = getTags(interfaces, vnics);
+
+		cb(null, tags);
+		return;
+	});
+}
+
 exports.shuffle = shuffle;
 exports.domainToPath = domainToPath;
 exports.initSdcClients = initSdcClients;
@@ -711,3 +919,5 @@ exports.insert = insert;
 exports.stripe = stripe;
 exports.sortObjectsByProps = sortObjectsByProps;
 exports.fmtDuration = fmtDuration;
+exports.updateNetworkUsers = updateNetworkUsers;
+exports.getServerNicTags = getServerNicTags;
diff --git a/lib/deploy.js b/lib/deploy.js
index b0a5f27..4d525df 100644
--- a/lib/deploy.js
+++ b/lib/deploy.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -379,6 +379,27 @@ Deployer.prototype.deploy = function (options, svcname, callback)
 			], cb);
 		},
 
+		/*
+		 * Make sure self.options.server_uuid is set for the rest of
+		 * this waterfall.
+		 */
+		function getServerUuid(cb) {
+			if (self.options.server_uuid) {
+				cb(null);
+				return;
+			} else {
+				common.findServerUuid.call(self,
+				    function (err, id) {
+					if (err) {
+						return (cb(err));
+					}
+
+					self.options.server_uuid = id;
+					cb(null);
+				});
+			}
+		},
+
 		function reserveIP(cb) {
 			if (self.svcname !== 'nameservice')
 				return (cb(null, {}));
@@ -388,8 +409,7 @@ Deployer.prototype.deploy = function (options, svcname, callback)
 			var log = self.log;
 			log.info('reserving nic');
 			reserveAndGetNic(self, 'manta', self.zone_uuid,
-			    self.poseidon.uuid,
-			    function (err, nic) {
+			    self.poseidon.uuid, function (err, nic) {
 				self.nic = nic;
 				cb(err, nic);
 			    });
@@ -452,47 +472,34 @@ Deployer.prototype.deploy = function (options, svcname, callback)
 			}
 
 			var log = self.log;
-			var serverUuid;
+			var serverUuid = self.options.server_uuid;
 
 			log.debug('Ensuring that the server has a compute id');
 
-			function getComputeId() {
-				log.debug({
-					serverUuid: serverUuid
-				}, 'server uuid for looking up compute id');
-				var m = 'Error getting compute id';
-				common.getOrCreateComputeId.call(
-					self, serverUuid, function (err, cid) {
-						if (err) {
-							return (cb(err));
-						}
-
-						if (!cid) {
-							var e = new Error(m);
-							e.message = m;
-							return (cb(e));
-						}
-						log.debug({
-							computeId: cid
-						}, 'found compute id');
-						return (cb(null));
-					});
+			if (!serverUuid) {
+				cb(new Error('Error, missing server UUID'));
+				return;
 			}
 
-			if (self.options.server_uuid) {
-				serverUuid = self.options.server_uuid;
-				getComputeId();
-			} else {
-				common.findServerUuid.call(
-					self, function (err, id) {
-						if (err) {
-							return (cb(err));
-						}
-						serverUuid = id;
-						getComputeId();
-					});
-			}
+			log.debug({ serverUuid: serverUuid },
+			    'server uuid for looking up compute id');
+
+			var m = 'Error getting compute id';
+			common.getOrCreateComputeId.call(self, serverUuid,
+			    function (err, cid) {
+				if (err) {
+					return (cb(err));
+				}
 
+				if (!cid) {
+					var e = new Error(m);
+					e.message = m;
+					return (cb(e));
+				}
+				log.debug({ computeId: cid },
+				    'found compute id');
+				return (cb(null));
+			});
 		},
 
 		function deployMantaInstance(cb) {
@@ -689,7 +696,85 @@ function reserveAndGetNic(self, name, zone_uuid, owner_uuid, cb) {
 	log.info({ opts: opts }, 'provisioning NIC');
 
 	async.waterfall([
-		function (subcb) {
+		function getNicTags(subcb) {
+			common.getServerNicTags.call(self,
+			    function (err, tags) {
+				if (err) {
+					subcb(err);
+					return;
+				}
+				/*
+				 * XXX: This case should never happen.  If it
+				 * does, we should bomb out early.
+				 */
+				if (!tags.online || tags.online.length < 1) {
+					var msg = 'No nic tags available';
+					log.error({tags: tags}, msg);
+					subcb(new Error(msg));
+					return;
+				}
+				subcb(null, tags.online);
+			});
+		},
+		function checkNetworkPool(stags, subcb) {
+			napi.listNetworkPools({ name: name },
+			    function (err, pools) {
+				if (err) {
+					subcb(err);
+					return;
+				}
+
+				if (!pools || pools.length < 1) {
+					subcb(null, null);
+					return;
+				}
+
+				if (pools && pools.length > 1) {
+					log.warn({pools: pools},
+					    'Skipping network pool check for '
+					    + 'NIC reservation, multiple pools '
+					    + 'with the same name.');
+					subcb(null, null);
+					return;
+				}
+
+				/*
+				 * We only look for the first matching nictag.
+				 * If there were two matches that would be a
+				 * configuration error.  Log it and move on.
+				 */
+				var ptags = pools[0].nic_tags_present;
+				var final_tags = ptags.filter(function (t) {
+					return (stags.indexOf(t) !== -1);
+				});
+
+				if (final_tags.length < 1) {
+					log.debug('No matching pool nictags '
+					    + 'found for network name %s',
+					    name);
+					subcb(null, null);
+					return;
+				}
+
+				if (final_tags.length > 1) {
+					log.warn({tags: final_tags}, 'More '
+					    + 'than one matching nictag found. '
+					    + 'using %s', final_tags[0]);
+				}
+
+				log.debug('Found matching pool nictag %s',
+				    final_tags[0]);
+
+				opts.nic_tag = final_tags[0];
+				subcb(null, pools[0].uuid);
+				return;
+			});
+		},
+		function checkNetworks(network_uuid, subcb) {
+			if (network_uuid) {
+				return (subcb(null, network_uuid));
+			}
+
 			napi.listNetworks({ name: name },
 			    function (err, networks) {
 				if (err) {
@@ -704,7 +789,8 @@ function reserveAndGetNic(self, name, zone_uuid, owner_uuid, cb) {
 				return (subcb(null, networks[0].uuid));
 			});
 		},
-		function (network_uuid, subcb) {
+		function provisionNic(network_uuid, subcb) {
+
 			napi.provisionNic(network_uuid, opts,
 			    function (err, nic) {
 				if (err) {
diff --git a/networking/manta-net.sh b/networking/manta-net.sh
index e9cd70d..3e9cc97 100755
--- a/networking/manta-net.sh
+++ b/networking/manta-net.sh
@@ -6,7 +6,7 @@
 #
 
 #
-# Copyright (c) 2016, Joyent, Inc.
+# Copyright (c) 2018, Joyent, Inc.
 #
 
 #
@@ -812,7 +812,7 @@ EOF
 	    || fatal "failed to install manta-nic.sh"
 
 	sdc-oneachnode -n $server -d /tmp -g ./smf/manta-nic.xml \
-	    || fatal "failed to copy over manta-nic.sh"
+	    || fatal "failed to copy over manta-nic.xml"
 	sdc-oneachnode -n $server 'mv /tmp/manta-nic.xml /opt/custom/smf' \
 	    || fatal "failed to install manta-nic.xml manifest"
 	sdc-oneachnode -n $server 'svccfg import \
-- 
2.21.0

