From 5cb500ab6669df2486c317750c6f5dbf9737ff4c Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Mon, 3 Jun 2019 13:16:02 +0000
Subject: [PATCH] MANTA-3730 update muppet to haproxy v1.8.20 MANTA-4335
 pfiles(1) sends haproxy loopy MANTA-4358 haproxy could limit old workers
 Reviewed by: Robert Mustacchi <rm@joyent.com> Approved by: Robert Mustacchi
 <rm@joyent.com>

---
 .gitignore             |   1 +
 Makefile               |   8 +
 README.md              |  53 +++++
 doc/configuration.txt  |  22 +-
 doc/haproxy.1          |   5 +
 include/types/global.h |   4 +
 src/cfgparse.c         |  47 ++++-
 src/ev_evports.c       | 441 +++++++++++++++++++++++++++++++++++++++++
 src/haproxy.c          |  78 ++++++--
 src/hathreads.c        |  32 ++-
 10 files changed, 667 insertions(+), 24 deletions(-)
 create mode 100644 README.md
 create mode 100644 src/ev_evports.c

diff --git a/.gitignore b/.gitignore
index 73eaeae2..e57e298d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,6 +7,7 @@
 !/LICENSE
 !/Makefile
 !/README
+!/README.md
 !/CONTRIBUTING
 !/MAINTAINERS
 !/ROADMAP
diff --git a/Makefile b/Makefile
index 36df7b29..61fe605a 100644
--- a/Makefile
+++ b/Makefile
@@ -8,6 +8,7 @@
 #   USE_DLMALLOC         : enable use of dlmalloc (see DLMALLOC_SRC)
 #   USE_EPOLL            : enable epoll() on Linux 2.6. Automatic.
 #   USE_KQUEUE           : enable kqueue() on BSD. Automatic.
+#   USE_EVPORTS          : enable event ports on SunOS systems. Automatic.
 #   USE_MY_EPOLL         : redefine epoll_* syscalls. Automatic.
 #   USE_MY_SPLICE        : redefine the splice syscall if build fails without.
 #   USE_NETFILTER        : enable netfilter on Linux. Automatic.
@@ -323,6 +324,7 @@ ifeq ($(TARGET),solaris)
   USE_CRYPT_H     = implicit
   USE_GETADDRINFO = implicit
   USE_THREAD      = implicit
+  USE_EVPORTS     = implicit
 else
 ifeq ($(TARGET),freebsd)
   # This is for FreeBSD
@@ -534,6 +536,12 @@ OPTIONS_OBJS   += src/ev_kqueue.o
 BUILD_OPTIONS  += $(call ignore_implicit,USE_KQUEUE)
 endif
 
+ifneq ($(USE_EVPORTS),)
+OPTIONS_CFLAGS += -DENABLE_EVPORTS
+OPTIONS_OBJS   += src/ev_evports.o
+BUILD_OPTIONS  += $(call ignore_implicit,USE_EVPORTS)
+endif
+
 ifneq ($(USE_VSYSCALL),)
 OPTIONS_OBJS   += src/i386-linux-vsys.o
 OPTIONS_CFLAGS += -DCONFIG_HAP_LINUX_VSYSCALL
diff --git a/README.md b/README.md
new file mode 100644
index 00000000..3abd19b0
--- /dev/null
+++ b/README.md
@@ -0,0 +1,53 @@
+# HAProxy
+
+This repository represents the version of [haproxy](https://www.haproxy.org/)
+that is used as part of the [Manta project](https://github.com/joyent/manta).
+
+The changes specific to this repo are:
+
+- backport of event port poller implementation
+- work-around for spurious event port wakeups breaking thread sync
+- implementation of max-old-workers
+
+## Repository Management
+
+To better understand and maintain our differences from HAProxy, we try to
+manage branches and tags in a specific fashion. First and foremost, all
+branches and tags from the upstream HAProxy repository are mirrored here.
+Anything that is Joyent-specific begins with a `joyent/` prefix.
+
+Branches with Joyent modifications are named `joyent/<version>`, such as
+`joyent/v1.8.8`. This is a branch that starts from the HAProxy
+`v1.8.8` tag. These branches will have all of our patches
+rebased on top of them. Currently, this repository is consumed by
+`muppet`, which contains a git submodule for this repository.
+
+When it comes time to update to a newer version of HAProxy, we would take
+the following steps:
+
+* Ensure that we have pushed all changes from the upstream repository and
+  synced all of our branches and tags.
+* Identify the release tag that corresponds to the point release. For
+  this example, we'll say that's `v1.12.3`.
+* Create a new branch named `joyent/<version>` from the tag. In this
+  case we would name the branch `joyent/v1.12.3`.
+* Rebase all of our patches on to that new branch, removing any patches
+  that are no longer necessary.
+* Test the new HAProxy binary.
+* Review and Commit all relevant changes.
+* Update the [muppet](https://github.com/joyent/muppet)
+  submodule to point to the branch.
+
+## Building and testing
+
+As mentioned, this version of haproxy is built and used via
+[muppet](https://github.com/joyent/muppet). However, for testing purposes, a
+local build will suffice:
+
+```
+make -j TARGET=solaris
+```
+
+The resulting binary can be placed in the `loadbalancer` zone.
+
+For more general details on haproxy, see the README.
diff --git a/doc/configuration.txt b/doc/configuration.txt
index 863508f5..501c303a 100644
--- a/doc/configuration.txt
+++ b/doc/configuration.txt
@@ -4,7 +4,7 @@
                          ----------------------
                               version 1.8
                              willy tarreau
-                              2019/04/25
+                              2019/06/19
 
 
 This document covers the configuration language as implemented in the version
@@ -568,6 +568,8 @@ The following keywords are supported in the "global" section :
    - log-tag
    - log-send-hostname
    - lua-load
+   - master-worker
+   - max-old-workers
    - nbproc
    - nbthread
    - node
@@ -613,6 +615,7 @@ The following keywords are supported in the "global" section :
    - maxzlibmem
    - noepoll
    - nokqueue
+   - noevports
    - nopoll
    - nosplice
    - nogetaddrinfo
@@ -912,6 +915,14 @@ master-worker [no-exit-on-failure]
 
   See also "-W" in the management guide.
 
+max-old-workers <number>
+  In master-worker mode, the maximum number of old child processes permitted.
+  If this value is exceeded, the oldest child worker is sent SIGTERM to cause
+  it to quit immediately. This can be useful if hard-stop-after is not suitable
+  for cleaning up old workers with long-standing open connections, but a limit
+  on overall haproxy resource usage is still required. It must be at least as
+  high as "nbproc". Default is no limit.
+
 nbproc <number>
   Creates <number> processes when going daemon. This requires the "daemon"
   mode. By default, only one process is created, which is the recommended mode
@@ -1376,11 +1387,18 @@ nokqueue
   equivalent to the command-line argument "-dk". The next polling system
   used will generally be "poll". See also "nopoll".
 
+noevports
+  Disables the use of the event ports event polling system on SunOS systems
+  derived from Solaris 10 and later. It is equivalent to the command-line
+  argument "-dv". The next polling system used will generally be "poll". See
+  also "nopoll".
+
 nopoll
   Disables the use of the "poll" event polling system. It is equivalent to the
   command-line argument "-dp". The next polling system used will be "select".
   It should never be needed to disable "poll" since it's available on all
-  platforms supported by HAProxy. See also "nokqueue" and "noepoll".
+  platforms supported by HAProxy. See also "nokqueue", "noepoll" and
+  "noevports".
 
 nosplice
   Disables the use of kernel tcp splicing between sockets on Linux. It is
diff --git a/doc/haproxy.1 b/doc/haproxy.1
index 91f58a3b..86d17cfa 100644
--- a/doc/haproxy.1
+++ b/doc/haproxy.1
@@ -104,6 +104,11 @@ in daemon mode.
 \fB\-dk\fP
 Disable use of \fBkqueue\fP(2). \fBkqueue\fP(2) is available only on BSD systems.
 
+.TP
+\fB\-dv\fP
+Disable use of event ports. Event ports are available only on SunOS systems
+derived from Solaris 10 and later (including illumos systems).
+
 .TP
 \fB\-ds\fP
 Disable use of speculative \fBepoll\fP(7). \fBepoll\fP(7) is available only on
diff --git a/include/types/global.h b/include/types/global.h
index bd7761cd..3ae0df7a 100644
--- a/include/types/global.h
+++ b/include/types/global.h
@@ -3,6 +3,7 @@
  * Global variables.
  *
  * Copyright (C) 2000-2012 Willy Tarreau - w@1wt.eu
+ * Copyright 2019 Joyent, Inc.
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -68,6 +69,8 @@
 #define GTUNE_NOEXIT_ONFAILURE   (1<<9)
 #define GTUNE_USE_SYSTEMD        (1<<10)
 
+#define GTUNE_USE_EVPORTS        (1<<11)
+
 /* Access level for a stats socket */
 #define ACCESS_LVL_NONE     0
 #define ACCESS_LVL_USER     1
@@ -91,6 +94,7 @@ struct global {
 	int nbproc;
 	int nbthread;
 	unsigned int hard_stop_after;	/* maximum time allowed to perform a soft-stop */
+	int max_old_workers;	/* max length of 'oldpids' */
 	int maxconn, hardmaxconn;
 	int maxsslconn;
 	int ssl_session_max_cost;   /* how many bytes an SSL session may cost */
diff --git a/src/cfgparse.c b/src/cfgparse.c
index c178538b..2c516e78 100644
--- a/src/cfgparse.c
+++ b/src/cfgparse.c
@@ -2,6 +2,7 @@
  * Configuration parser
  *
  * Copyright 2000-2011 Willy Tarreau <w@1wt.eu>
+ * Copyright 2019 Joyent, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -733,6 +734,22 @@ int cfg_parse_global(const char *file, int linenum, char **args, int kwm)
 		}
 		global.mode |= MODE_MWORKER;
 	}
+	else if (!strcmp(args[0], "max-old-workers")) {
+		if (alertif_too_many_args(1, file, linenum, args, &err_code))
+			goto out;
+		if (*(args[1]) == 0) {
+			ha_alert("parsing [%s:%d] : '%s' expects an integer argument.\n", file, linenum, args[0]);
+			err_code |= ERR_ALERT | ERR_FATAL;
+			goto out;
+		}
+		global.max_old_workers = atol(args[1]);
+		if (global.max_old_workers < 1 || global.max_old_workers > LONGBITS) {
+			ha_alert("parsing [%s:%d] : '%s' must be between 1 and %d (was %d).\n",
+			         file, linenum, args[0], LONGBITS, global.max_old_workers);
+			err_code |= ERR_ALERT | ERR_FATAL;
+			goto out;
+		}
+	}
 	else if (!strcmp(args[0], "debug")) {
 		if (alertif_too_many_args(0, file, linenum, args, &err_code))
 			goto out;
@@ -748,6 +765,11 @@ int cfg_parse_global(const char *file, int linenum, char **args, int kwm)
 			goto out;
 		global.tune.options &= ~GTUNE_USE_KQUEUE;
 	}
+	else if (!strcmp(args[0], "noevports")) {
+		if (alertif_too_many_args(0, file, linenum, args, &err_code))
+			goto out;
+		global.tune.options &= ~GTUNE_USE_EVPORTS;
+	}
 	else if (!strcmp(args[0], "nopoll")) {
 		if (alertif_too_many_args(0, file, linenum, args, &err_code))
 			goto out;
@@ -1893,7 +1915,7 @@ int cfg_parse_global(const char *file, int linenum, char **args, int kwm)
 				}
 			}
 		}
-		
+
 		ha_alert("parsing [%s:%d] : unknown keyword '%s' in '%s' section\n", file, linenum, args[0], "global");
 		err_code |= ERR_ALERT | ERR_FATAL;
 	}
@@ -1903,6 +1925,26 @@ int cfg_parse_global(const char *file, int linenum, char **args, int kwm)
 	return err_code;
 }
 
+int cfg_post_parse_section_global(void)
+{
+	int err_code = 0;
+
+	if (global.max_old_workers > 0) {
+		if (!(global.mode & MODE_MWORKER)) {
+			ha_alert("max-old-workers can only be set in master-worker mode\n");
+			err_code |= ERR_FATAL | ERR_ALERT;
+		}
+
+		if (global.max_old_workers < global.nbproc) {
+			ha_alert("max-old-workers=%d is less than nbproc=%d\n",
+			         global.max_old_workers, global.nbproc);
+			err_code |= ERR_FATAL | ERR_ALERT;
+		}
+	}
+
+	return err_code;
+}
+
 void init_default_instance()
 {
 	init_new_proxy(&defproxy);
@@ -9369,7 +9411,8 @@ static void cfgparse_init(void)
 	cfg_register_section("frontend",       cfg_parse_listen,    NULL);
 	cfg_register_section("backend",        cfg_parse_listen,    NULL);
 	cfg_register_section("defaults",       cfg_parse_listen,    NULL);
-	cfg_register_section("global",         cfg_parse_global,    NULL);
+	cfg_register_section("global",         cfg_parse_global,
+			     cfg_post_parse_section_global);
 	cfg_register_section("userlist",       cfg_parse_users,     NULL);
 	cfg_register_section("peers",          cfg_parse_peers,     NULL);
 	cfg_register_section("mailers",        cfg_parse_mailers,   NULL);
diff --git a/src/ev_evports.c b/src/ev_evports.c
new file mode 100644
index 00000000..42457bba
--- /dev/null
+++ b/src/ev_evports.c
@@ -0,0 +1,441 @@
+/*
+ * FD polling functions for SunOS event ports.
+ *
+ * Copyright 2019 Joyent, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <unistd.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+#include <poll.h>
+#include <port.h>
+#include <errno.h>
+#include <syslog.h>
+#include <assert.h>
+
+#include <common/compat.h>
+#include <common/config.h>
+#include <common/hathreads.h>
+#include <common/ticks.h>
+#include <common/time.h>
+#include <common/tools.h>
+
+#include <types/global.h>
+
+#include <proto/fd.h>
+#include <proto/log.h>
+#include <proto/signal.h>
+
+/*
+ * Private data:
+ */
+static int evports_fd[MAX_THREADS]; // per-thread evports_fd
+static THREAD_LOCAL port_event_t *evports_evlist = NULL;
+static THREAD_LOCAL int evports_evlist_max = 0;
+
+/*
+ * Convert the "state" member of "fdtab" into an event ports event mask.
+ */
+static inline int evports_state_to_events(int state)
+{
+	int events = 0;
+
+	if (state & FD_EV_POLLED_W)
+		events |= POLLOUT;
+	if (state & FD_EV_POLLED_R)
+		events |= POLLIN;
+
+	return (events);
+}
+
+/*
+ * Associate or dissociate this file descriptor with the event port, using the
+ * specified event mask.
+ */
+static inline void evports_resync_fd(int fd, int events)
+{
+	int ret;
+
+	if (events == 0) {
+		ret = port_dissociate(evports_fd[tid], PORT_SOURCE_FD, fd);
+	} else {
+		ret = port_associate(evports_fd[tid], PORT_SOURCE_FD,
+		    fd, events, NULL);
+	}
+
+	if (ret) {
+		send_log(NULL, LOG_INFO, "%s(%d, %d) failed, errno %d (%s)\n",
+		    __func__, fd, events, errno, strerror(errno));
+		abort();
+	}
+}
+
+static void _update_fd(int fd)
+{
+	int en;
+	int events;
+
+	en = fdtab[fd].state;
+
+	if (!(fdtab[fd].thread_mask & tid_bit) || !(en & FD_EV_POLLED_RW)) {
+		if (!(fdtab[fd].polled_mask & tid_bit)) {
+			/* fd was not watched, it's still not */
+			return;
+		}
+		/* fd totally removed from poll list */
+		events = 0;
+		HA_ATOMIC_AND(&fdtab[fd].polled_mask, ~tid_bit);
+	}
+	else {
+		/* OK fd has to be monitored, it was either added or changed */
+		events = evports_state_to_events(en);
+		HA_ATOMIC_OR(&fdtab[fd].polled_mask, tid_bit);
+	}
+	evports_resync_fd(fd, events);
+}
+
+/*
+ * Event Ports poller.  This routine interacts with the file descriptor
+ * management data structures and routines; see the large block comment in
+ * "src/fd.c" for more information.
+ */
+
+REGPRM2 static void _do_poll(struct poller *p, int exp)
+{
+	int i;
+	int wait_time;
+	struct timespec timeout_ts;
+	unsigned int nevlist;
+	int fd;
+	int eo, en;
+	int status;
+
+	/* first, scan the update list to find changes */
+	for (i = 0; i < fd_nbupdt; i++) {
+		fd = fd_updt[i];
+
+		HA_SPIN_LOCK(FD_LOCK, &fdtab[fd].lock);
+		fdtab[fd].update_mask &= ~tid_bit;
+
+		if (fdtab[fd].owner == NULL) {
+			activity[tid].poll_drop++;
+			HA_SPIN_UNLOCK(FD_LOCK, &fdtab[fd].lock);
+			continue;
+		}
+
+		fdtab[fd].new = 0;
+
+		eo = fdtab[fd].state;
+		en = fd_compute_new_polled_status(eo);
+		fdtab[fd].state = en;
+		HA_SPIN_UNLOCK(FD_LOCK, &fdtab[fd].lock);
+
+		_update_fd(fd);
+	}
+
+	/* Scan the global update list */
+	HA_SPIN_LOCK(FD_UPDATE_LOCK, &fd_updt_lock);
+	for (fd = update_list.first; fd != -1; fd = fdtab[fd].update.next) {
+		HA_SPIN_LOCK(FD_LOCK, &fdtab[fd].lock);
+		if (fdtab[fd].update_mask & tid_bit)
+			done_update_polling(fd);
+		else {
+			HA_SPIN_UNLOCK(FD_LOCK, &fdtab[fd].lock);
+			continue;
+		}
+		fdtab[fd].new = 0;
+
+		eo = fdtab[fd].state;
+		en = fd_compute_new_polled_status(eo);
+		fdtab[fd].state = en;
+		HA_SPIN_UNLOCK(FD_LOCK, &fdtab[fd].lock);
+
+		if (fdtab[fd].owner == NULL)
+			continue;
+
+		_update_fd(fd);
+	}
+	HA_SPIN_UNLOCK(FD_UPDATE_LOCK, &fd_updt_lock);
+
+	fd_nbupdt = 0;
+
+	thread_harmless_now();
+
+	wait_time        = 0;
+
+	if (!exp) {
+		wait_time        = MAX_DELAY_MS;
+	}
+	else if (!tick_is_expired(exp, now_ms)) {
+		wait_time = TICKS_TO_MS(tick_remain(now_ms, exp)) + 1;
+		if (wait_time > MAX_DELAY_MS)
+			wait_time = MAX_DELAY_MS;
+	}
+	else
+		activity[tid].poll_exp++;
+
+	gettimeofday(&before_poll, NULL);
+
+	nevlist = 1; /* desired number of events to be retrieved */
+	timeout_ts.tv_sec  = (wait_time / 1000);
+	timeout_ts.tv_nsec = (wait_time % 1000) * 1000000;
+
+	status = port_getn(evports_fd[tid],
+			   evports_evlist,
+			   evports_evlist_max,
+			   &nevlist, /* updated to the number of events retrieved */
+			   &timeout_ts);
+
+	if (status != 0) {
+		int e = errno;
+		switch (e) {
+		case ETIME:
+			/*
+			 * Though the manual page has not historically made it
+			 * clear, port_getn() can return -1 with an errno of
+			 * ETIME and still have returned some number of events.
+			 */
+			/* nevlist >= 0 */
+			break;
+		default:
+			nevlist = 0;
+			break;
+		}
+	}
+
+	tv_update_date(wait_time, nevlist);
+	measure_idle();
+
+	thread_harmless_end();
+
+	for (i = 0; i < nevlist; i++) {
+		unsigned int n = 0;
+		int events, rebind_events;
+		fd = evports_evlist[i].portev_object;
+		events = evports_evlist[i].portev_events;
+
+		if (fdtab[fd].owner == NULL) {
+			activity[tid].poll_dead++;
+			continue;
+		}
+
+		if (!(fdtab[fd].thread_mask & tid_bit)) {
+			activity[tid].poll_skip++;
+			continue;
+		}
+
+		/*
+		 * By virtue of receiving an event for this file descriptor, it
+		 * is no longer associated with the port in question.  Store
+		 * the previous event mask so that we may reassociate after
+		 * processing is complete.
+		 */
+		rebind_events = evports_state_to_events(fdtab[fd].state);
+		assert(rebind_events != 0);
+
+		/*
+		 * Set bits based on the events we received from the port:
+		 */
+		if (events & POLLIN)
+			n |= FD_POLL_IN;
+		if (events & POLLOUT)
+			n |= FD_POLL_OUT;
+		if (events & POLLERR)
+			n |= FD_POLL_ERR;
+		if (events & POLLHUP)
+			n |= FD_POLL_HUP;
+
+		/*
+		 * Call connection processing callbacks.  Note that it's
+		 * possible for this processing to alter the required event
+		 * port assocation; i.e., the "state" member of the "fdtab"
+		 * entry.  If it changes, the fd will be placed on the updated
+		 * list for processing the next time we are called.
+		 */
+		fd_update_events(fd, n);
+
+		/*
+		 * This file descriptor was closed during the processing of
+		 * polled events.  No need to reassociate.
+		 */
+		if (fdtab[fd].owner == NULL)
+			continue;
+
+		/*
+		 * Reassociate with the port, using the same event mask as
+		 * before.  This call will not result in a dissociation as we
+		 * asserted that _some_ events needed to be rebound above.
+		 *
+		 * Reassociating with the same mask allows us to mimic the
+		 * level-triggered behaviour of poll(2).  In the event that we
+		 * are interested in the same events on the next turn of the
+		 * loop, this represents no extra work.
+		 *
+		 * If this additional port_associate(3C) call becomes a
+		 * performance problem, we would need to verify that we can
+		 * correctly interact with the file descriptor cache and update
+		 * list (see "src/fd.c") to avoid reassociating here, or to use
+		 * a different events mask.
+		 */
+		evports_resync_fd(fd, rebind_events);
+	}
+}
+
+static int init_evports_per_thread()
+{
+	int fd;
+
+	evports_evlist_max = global.tune.maxpollevents;
+	evports_evlist = calloc(evports_evlist_max, sizeof (port_event_t));
+	if (evports_evlist == NULL) {
+		goto fail_alloc;
+	}
+
+	if (MAX_THREADS > 1 && tid) {
+		if ((evports_fd[tid] = port_create()) == -1) {
+			goto fail_fd;
+		}
+	}
+
+	/* we may have to unregister some events initially registered on the
+	 * original fd when it was alone, and/or to register events on the new
+	 * fd for this thread. Let's just mark them as updated, the poller will
+	 * do the rest.
+	 */
+	for (fd = 0; fd < global.maxsock; fd++) {
+		HA_SPIN_LOCK(FD_LOCK, &fdtab[fd].lock);
+		updt_fd_polling(fd);
+	}
+
+	return 1;
+
+ fail_fd:
+	free(evports_evlist);
+	evports_evlist = NULL;
+	evports_evlist_max = 0;
+ fail_alloc:
+	return 0;
+}
+
+static void deinit_evports_per_thread()
+{
+	if (MAX_THREADS > 1 && tid)
+		close(evports_fd[tid]);
+
+	free(evports_evlist);
+	evports_evlist = NULL;
+	evports_evlist_max = 0;
+}
+
+/*
+ * Initialisation of the event ports poller.
+ * Returns 0 in case of failure, non-zero in case of success.
+ */
+REGPRM1 static int _do_init(struct poller *p)
+{
+	p->private = NULL;
+
+	if ((evports_fd[tid] = port_create()) == -1) {
+		goto fail;
+	}
+
+	hap_register_per_thread_init(init_evports_per_thread);
+	hap_register_per_thread_deinit(deinit_evports_per_thread);
+
+	return 1;
+
+fail:
+	p->pref = 0;
+	return 0;
+}
+
+/*
+ * Termination of the event ports poller.
+ * All resources are released and the poller is marked as inoperative.
+ */
+REGPRM1 static void _do_term(struct poller *p)
+{
+	if (evports_fd[tid] != -1) {
+		close(evports_fd[tid]);
+		evports_fd[tid] = -1;
+	}
+
+	p->private = NULL;
+	p->pref = 0;
+
+	free(evports_evlist);
+	evports_evlist = NULL;
+	evports_evlist_max = 0;
+}
+
+/*
+ * Run-time check to make sure we can allocate the resources needed for
+ * the poller to function correctly.
+ * Returns 1 on success, otherwise 0.
+ */
+REGPRM1 static int _do_test(struct poller *p)
+{
+	int fd;
+
+	if ((fd = port_create()) == -1) {
+		return 0;
+	}
+
+	close(fd);
+	return 1;
+}
+
+/*
+ * Close and recreate the event port after fork().  Returns 1 on success,
+ * otherwise 0.  If this function fails, "_do_term()" must be called to
+ * clean up the poller.
+ */
+REGPRM1 static int _do_fork(struct poller *p)
+{
+	if (evports_fd[tid] != -1) {
+		close(evports_fd[tid]);
+	}
+
+	if ((evports_fd[tid] = port_create()) == -1) {
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * This constructor must be called before main() to register the event ports
+ * poller.
+ */
+__attribute__((constructor))
+static void _do_register(void)
+{
+	struct poller *p;
+	int i;
+
+	if (nbpollers >= MAX_POLLERS)
+		return;
+
+	for (i = 0; i < MAX_THREADS; i++)
+		evports_fd[i] = -1;
+
+	p = &pollers[nbpollers++];
+
+	p->name = "evports";
+	p->pref = 300;
+	p->flags = 0;
+	p->private = NULL;
+
+	p->clo  = NULL;
+	p->test = _do_test;
+	p->init = _do_init;
+	p->term = _do_term;
+	p->poll = _do_poll;
+	p->fork = _do_fork;
+}
diff --git a/src/haproxy.c b/src/haproxy.c
index 105cde6f..17f26287 100644
--- a/src/haproxy.c
+++ b/src/haproxy.c
@@ -1,6 +1,7 @@
 /*
  * HA-Proxy : High Availability-enabled HTTP/TCP proxy
  * Copyright 2000-2019 Willy Tarreau <willy@haproxy.org>.
+ * Copyright 2019 Joyent, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -180,6 +181,7 @@ int jobs = 0;   /* number of active jobs (conns, listeners, active tasks, ...) *
 #define MAX_START_RETRIES	200
 static int *oldpids = NULL;
 static int oldpids_sig; /* use USR1 or TERM */
+static void delete_oldpid(int);
 
 /* Path to the unix socket we use to retrieve listener sockets from the old process */
 static const char *old_unixsocket;
@@ -426,6 +428,9 @@ static void usage(char *name)
 #if defined(ENABLE_KQUEUE)
 		"        -dk disables kqueue() usage even when available\n"
 #endif
+#if defined(ENABLE_EVPORTS)
+		"        -dv disables event ports usage even when available\n"
+#endif
 #if defined(ENABLE_POLL)
 		"        -dp disables poll() usage even when available\n"
 #endif
@@ -453,17 +458,31 @@ static void usage(char *name)
 /*   more specific functions   ***************************************/
 /*********************************************************************/
 
-/* sends the signal <sig> to all pids found in <oldpids>. Returns the number of
- * pids the signal was correctly delivered to.
+/*
+ * Sends the signal <sig> to all pids found in <oldpids>, returning 1 if we
+ * signaled at least one child.
  */
 static int tell_old_pids(int sig)
 {
+	int signaled = 0;
 	int p;
-	int ret = 0;
-	for (p = 0; p < nb_oldpids; p++)
-		if (kill(oldpids[p], sig) == 0)
-			ret++;
-	return ret;
+
+	for (p = 0; p < nb_oldpids;) {
+		if (kill(oldpids[p], sig) == 0) {
+			signaled++;
+		} else if (errno == ESRCH) {
+			/* pid went away: remove it from our list. */
+			delete_oldpid(oldpids[p]);
+			continue;
+		} else {
+			ha_warning("Failed to signal worker %d: %s.\n",
+			           (int)oldpids[p], strerror(errno));
+		}
+
+		p++;
+	}
+
+	return (signaled > 0);
 }
 
 /* return 1 if a pid is a current child otherwise 0 */
@@ -593,23 +612,22 @@ static void mworker_cleanlisteners()
 
 
 /*
- * remove a pid forom the olpid array and decrease nb_oldpids
- * return 1 pid was found otherwise return 0
+ * Remove a pid from the olpid array and decrease nb_oldpids. List is kept in
+ * newest-first order for the benefit of max-old-workers.
  */
-
-int delete_oldpid(int pid)
+static void delete_oldpid(int pid)
 {
 	int i;
 
 	for (i = 0; i < nb_oldpids; i++) {
 		if (oldpids[i] == pid) {
-			oldpids[i] = oldpids[nb_oldpids - 1];
-			oldpids[nb_oldpids - 1] = 0;
+			oldpids[i++] = 0;
+			for (; i < nb_oldpids; i++)
+				oldpids[i - 1] = oldpids[i];
 			nb_oldpids--;
-			return 1;
+			return;
 		}
 	}
-	return 0;
 }
 
 
@@ -1340,6 +1358,9 @@ static void init(int argc, char **argv)
 #if defined(ENABLE_KQUEUE)
 	global.tune.options |= GTUNE_USE_KQUEUE;
 #endif
+#if defined(ENABLE_EVPORTS)
+	global.tune.options |= GTUNE_USE_EVPORTS;
+#endif
 #if defined(CONFIG_HAP_LINUX_SPLICE)
 	global.tune.options |= GTUNE_USE_SPLICE;
 #endif
@@ -1384,6 +1405,10 @@ static void init(int argc, char **argv)
 			else if (*flag == 'd' && flag[1] == 'k')
 				global.tune.options &= ~GTUNE_USE_KQUEUE;
 #endif
+#if defined(ENABLE_EVPORTS)
+			else if (*flag == 'd' && flag[1] == 'v')
+				global.tune.options &= ~GTUNE_USE_EVPORTS;
+#endif
 #if defined(CONFIG_HAP_LINUX_SPLICE)
 			else if (*flag == 'd' && flag[1] == 'S')
 				global.tune.options &= ~GTUNE_USE_SPLICE;
@@ -1911,6 +1936,9 @@ static void init(int argc, char **argv)
 	if (!(global.tune.options & GTUNE_USE_KQUEUE))
 		disable_poller("kqueue");
 
+	if (!(global.tune.options & GTUNE_USE_EVPORTS))
+		disable_poller("evports");
+
 	if (!(global.tune.options & GTUNE_USE_EPOLL))
 		disable_poller("epoll");
 
@@ -2611,7 +2639,7 @@ int main(int argc, char **argv)
 		 * simply send SIGUSR1, which will not be undoable.
 		 */
 		if (tell_old_pids(SIGTTOU) == 0) {
-			/* no need to wait if we can't contact old pids */
+			/* no need to wait if we can't contact any old pids */
 			retry = 0;
 			continue;
 		}
@@ -2725,8 +2753,22 @@ int main(int argc, char **argv)
 		}
 	}
 
-	if (nb_oldpids)
-		nb_oldpids = tell_old_pids(oldpids_sig);
+	if (nb_oldpids) {
+		tell_old_pids(oldpids_sig);
+
+		if (oldpids_sig != SIGTERM && global.max_old_workers > 0) {
+			while (nb_oldpids > global.max_old_workers) {
+				pid_t pid = oldpids[nb_oldpids - 1];
+
+				if (kill(pid, SIGTERM) != 0 && errno != ESRCH) {
+					ha_warning("[%s.main()] Failed to kill old worker %d: %s.\n",
+					           argv[0], (int)pid, strerror(errno));
+				}
+
+				delete_oldpid(pid);
+			}
+		}
+	}
 
 	if ((getenv("HAPROXY_MWORKER_REEXEC") == NULL)) {
 		nb_oldpids = 0;
diff --git a/src/hathreads.c b/src/hathreads.c
index 730ebee4..b0e59560 100644
--- a/src/hathreads.c
+++ b/src/hathreads.c
@@ -10,6 +10,7 @@
  *
  */
 
+#include <assert.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <fcntl.h>
@@ -20,12 +21,13 @@
 #include <proto/fd.h>
 
 
-/* Dummy I/O handler used by the sync pipe.*/
+#ifndef USE_THREAD
+
 void thread_sync_io_handler(int fd)
 {
 }
 
-#ifdef USE_THREAD
+#else
 
 static HA_SPINLOCK_T sync_lock;
 static int           threads_sync_pipe[2] = {-1, -1};
@@ -41,6 +43,32 @@ THREAD_LOCAL unsigned long tid_bit       = (1UL << 0);
 struct lock_stat lock_stats[LOCK_LABELS];
 #endif
 
+/*
+ * Dummy I/O handler used by the sync pipe.
+ *
+ * This does nothing upstream, as indeed it should: the acknowledgement end of
+ * writing to the sync pipe is via thread_exit_sync().
+ *
+ * However, we have a pfiles(1) workaround: if somebody happens to run it on the
+ * haproxy process, as a side-effect threads_sync_pipe[0] will appear in
+ * the poller with POLLIN. However, this code is not expecting such spurious
+ * wake-ups, and we will end up in a busy loop as the fd is never cleared from
+ * fd_cache (and run_poll_loop() will force immediate timeouts as a result).
+ *
+ * As our deployment in the loadbalancer zone is single-threaded, we'll actively
+ * presume this is the case, in which case we know we can ignore it as spurious.
+ */
+void thread_sync_io_handler(int fd)
+{
+	assert(!(all_threads_mask & (all_threads_mask - 1)));
+	assert(fd == threads_sync_pipe[0]);
+
+	send_log(NULL, LOG_INFO, "%s: ignoring spurious wake-up on "
+	    "threads_sync_pipe[0]: were we a victim of pfiles(1) ?\n",
+	    __func__);
+	fd_done_recv(fd);
+}
+
 /* Initializes the sync point. It creates a pipe used by threads to wake up all
  * others when a sync is requested. It also initializes the mask of all created
  * threads. It returns 0 on success and -1 if an error occurred.
-- 
2.21.0

