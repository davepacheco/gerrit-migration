commit 07f95fbdca3eaef470326c0cc41adad17ec86c94 (refs/changes/44/4244/1)
Author: Mike Gerdts <mike.gerdts@joyent.com>
Date:   2018-06-17T20:21:46+00:00 (1 year, 4 months ago)
    
    OS-7030 lx audit may consume all kernel memory

diff --git a/usr/src/uts/common/brand/lx/io/lx_netlink.c b/usr/src/uts/common/brand/lx/io/lx_netlink.c
index 2635d1cae5..05b85ad023 100644
--- a/usr/src/uts/common/brand/lx/io/lx_netlink.c
+++ b/usr/src/uts/common/brand/lx/io/lx_netlink.c
@@ -1778,7 +1778,8 @@ lx_netlink_au_um(lx_netlink_sock_t *lxsock, lx_netlink_hdr_t *hdr, mblk_t *mp)
 }
 
 static int
-lx_netlink_au_emit_cb(void *s, uint_t type, const char *msg, uint_t size)
+lx_netlink_au_emit_cb(void *s, uint_t type, const char *msg, uint_t size,
+    boolean_t check_space)
 {
 	lx_netlink_sock_t *lxsock = (lx_netlink_sock_t *)s;
 	lx_netlink_hdr_t *hdr;
@@ -1816,12 +1817,33 @@ lx_netlink_au_emit_cb(void *s, uint_t type, const char *msg, uint_t size)
 		freeb(mp);
 		return (ENOMEM);
 	}
+
+	/*
+	 * so_queue_msg() enqueues the message then checks for the queue being
+	 * full.  We send a NULL mblk to perform the space check prior to
+	 * sending anything that could make it even fuller.
+	 */
+	if (check_space) {
+		lxsock->lxns_upcalls->su_recv(lxsock->lxns_uphandle, NULL,
+		    0, 0, &error, NULL);
+		if (error != 0) {
+			freeb(mp1);
+			freeb(mp);
+			lx_netlink_flowctrld++;
+			return (error);
+		}
+	}
+
 	/* As in lx_netlink_reply_sendup, send as T_UNITDATA_IND message. */
 	mp1->b_cont = mp;
 	lxsock->lxns_upcalls->su_recv(lxsock->lxns_uphandle, mp1,
 	    msgdsize(mp1), 0, &error, NULL);
 
-	return (error);
+	/*
+	 * Do not return ENOSPC after its been queued because our caller will
+	 * requeue on ENOSPC.
+	 */
+	return (error == ENOSPC ? 0 : error);
 }
 
 static int
diff --git a/usr/src/uts/common/brand/lx/os/lx_audit.c b/usr/src/uts/common/brand/lx/os/lx_audit.c
index b940a0527d..4456d9f25f 100644
--- a/usr/src/uts/common/brand/lx/os/lx_audit.c
+++ b/usr/src/uts/common/brand/lx/os/lx_audit.c
@@ -354,7 +354,8 @@ typedef struct lx_audit_state {
  * Function pointer to netlink function used by audit worker threads to send
  * audit messages up to the user-level auditd.
  */
-static int (*lx_audit_emit_msg)(void *, uint_t, const char *, uint_t);
+static int (*lx_audit_emit_msg)(void *, uint_t, const char *, uint_t,
+    boolean_t);
 static kmutex_t	lx_audit_em_lock;		/* protects emit_msg above */
 
 /* From uts/common/brand/lx/syscall/lx_socket.c */
@@ -367,10 +368,17 @@ lx_audit_emit_syscall_event(uint_t mtype, void *lxsock, const char *msg)
 {
 	int err;
 
-	err = lx_audit_emit_msg(lxsock, mtype, msg, LX_AUDIT_MESSAGE_TEXT_MAX);
+	/*
+	 * Set the check_space argument to B_TRUE only on the first call.  It's
+	 * not a big deal of we buffer a little more than planned, but we really
+	 * should send the LX_NETLINK_NLMSG_DONE message if an earlier message
+	 * was sent.
+	 */
+	err = lx_audit_emit_msg(lxsock, mtype, msg, LX_AUDIT_MESSAGE_TEXT_MAX,
+	    B_TRUE);
 	if (err != 0)
 		return (err);
-	err = lx_audit_emit_msg(lxsock, 0, NULL, 0);
+	err = lx_audit_emit_msg(lxsock, 0, NULL, 0, B_FALSE);
 	return (err);
 }
 
@@ -1489,7 +1497,7 @@ lx_audit_stop_worker(void *s, void (*cb)(void *, boolean_t))
  * up to the auditd.
  */
 void
-lx_audit_init(int (*cb)(void *, uint_t, const char *, uint_t))
+lx_audit_init(int (*cb)(void *, uint_t, const char *, uint_t, boolean_t))
 {
 	lx_zone_data_t *lxzd = ztolxzd(curzone);
 	lx_audit_state_t *asp;
diff --git a/usr/src/uts/common/brand/lx/sys/lx_audit.h b/usr/src/uts/common/brand/lx/sys/lx_audit.h
index 76686dd9ec..99a83b2e77 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_audit.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_audit.h
@@ -19,7 +19,8 @@
 extern "C" {
 #endif
 
-extern void lx_audit_init(int (*)(void *, uint_t, const char *, uint_t));
+extern void lx_audit_init(int (*)(void *, uint_t, const char *, uint_t,
+    boolean_t));
 extern void lx_audit_cleanup(void);
 extern void lx_audit_stop_worker(void *, void (*)(void *, boolean_t));
 extern int lx_audit_append_rule(void *, uint_t);
