commit 9656166048c4c80f3665cb5953e088c8bce855c8 (refs/changes/06/1906/2)
Author: Trent Mick <trentm@gmail.com>
Date:   2017-05-09T13:04:19-07:00 (2 years, 5 months ago)
    
    TOOLS-1767 sdcadm's DownloadImages procedure could fail faster and use a refactor
    Reviewed by: Pedro Palaz√≥n Candel <pedro@joyent.com>

diff --git a/CHANGES.md b/CHANGES.md
index bcedeed..28a7a57 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -11,6 +11,11 @@
 # sdcadm Changelog
 
 
+## 1.15.9
+
+- TOOLS-1767 Fix 'sdcadm up' to fail faster if there is a download error
+  with on in a number of images.
+
 ## 1.15.8
 
 - TOOLS-1634 'sdcadm up' parallel import of images can break when multiple
diff --git a/lib/procedures/download-images.js b/lib/procedures/download-images.js
index 99cf226..c7e18af 100644
--- a/lib/procedures/download-images.js
+++ b/lib/procedures/download-images.js
@@ -8,18 +8,24 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
-var p = console.log;
+/*
+ * A `Procedure` to download/import a set of given images (typically from
+ * updates.joyent.com) into the DC's IMGAPI. It attempts to parallelize some
+ * of the downloads.
+ */
+
 var assert = require('assert-plus');
 var sprintf = require('extsprintf').sprintf;
 var util = require('util'),
     format = util.format;
 var vasync = require('vasync');
+var VError = require('verror');
 
 var common = require('../common');
 var errors = require('../errors');
-
 var Procedure = require('./procedure').Procedure;
 
+
 function DownloadImages(options) {
     assert.arrayOfObject(options.images, 'options.images');
     this.images = options.images;
@@ -57,6 +63,8 @@ DownloadImages.prototype.execute = function diExecute(options, cb) {
     assert.optionalString(options.source, 'options.source');
     assert.func(options.progress, 'options.progress');
     assert.func(cb, 'cb');
+
+    var log = options.log;
     var self = this;
     var sdcadm = options.sdcadm;
     var progress = options.progress;
@@ -70,11 +78,11 @@ DownloadImages.prototype.execute = function diExecute(options, cb) {
     }
 
     /*
-     * Limitation: Origin/ancestry handling (`getAncestorsForImages`) doesn't
+     * Limitation: Origin/ancestry handling (`gatherImageGenerations`) doesn't
      * properly handle a custom `options.source`. Instead it assumes it can
      * look up an origin image on updates.joyent.com. For example,
      * `sdcadm post-setup dev-sample-data` uses `options.source` to import
-     * some images from images.joyent.com. However, it gets lucky because the
+     * some images from *images.joyent.com*. However, it gets lucky because the
      * images it is pulling do not have origins (they aren't incremental).
      *
      * A *workaround* for this is to (a) avoid looking up origin images (b/c
@@ -97,293 +105,365 @@ DownloadImages.prototype.execute = function diExecute(options, cb) {
     }
 
     /*
-     * Keep track of errors during parallel image imports
+     * Gotchas to watch out for when downloading/importing images:
+     * - There might be stale "state=unactivated" images sitting in IMGAPI. We
+     *   want to re-import those if we hit them.
+     * - If there are common origins in the parentage of the `self.images` to
+     *   import, then importing them in parallel can cause a race that breaks
+     *   import. Say we are importing images C and D that both have
+     *   `origin = B`. If we ask IMGAPI to import C and D in parallel, then
+     *   IMGAPI will race attempting to import B and the loser of the race will
+     *   break.
+     *
+     * To deal with common origins we'll gather the ancestry of the images
+     * to import and import in blocks of one generation at a time, starting
+     * from the oldest generation.
+     *
+     *              A           <--- oldest generation (import these first)
+     *             / \
+     *            B   \         <--- previous generation (... then these)
+     *           / \   \
+     *          C  D    E       <--- given set of images (... and finally these)
+     *
+     * within each generation we can import in parallel.
      */
-    var errs = [];
+    var generations = [
+        self.images.slice()
+    ];
+
+    gatherImageGenerations({
+        generations: generations,
+        sdcadm: sdcadm,
+        useCustomSourceCountermeasures: useCustomSourceCountermeasures
+    }, function (gatherErr) {
+        if (gatherErr) {
+            cb(gatherErr);
+            return;
+        }
 
+        // Log a summary (elide irrelevant img fields) of the generations
+        // to import.
+        if (log.debug()) {
+            var summary = generations.map(function (gen) {
+                return gen.map(function (img) {
+                    return {
+                        uuid: img.uuid,
+                        name: img.name,
+                        version: img.version,
+                        origin: img.origin
+                    };
+                });
+            });
+            log.debug({generations: summary}, 'DownloadImages: generations');
+        }
 
-    /*
-     * Given an array containing an array of images, this function will
-     * recursively call itself until we get the origins for all the images,
-     * storing these in arrays of the form:
-     * [..., [Arr of origins of level 2], [Arr of origins of level 1], [imgs]]
-     *
-     * The callback will be called with `f(err, collectionsOfImages)`
-     */
-    function getAncestorsForImages(colsToRetrieve, callback) {
-        var currCol = colsToRetrieve[0];
-        var newCol = [];
-        vasync.forEachParallel({
-            inputs: currCol,
-            func: function checkImgOrigin(img, nextImg) {
-                if (!img.origin || useCustomSourceCountermeasures) {
-                    nextImg();
-                    return;
-                }
+        var concurrency = 4;
+        if (useCustomSourceCountermeasures) {
+            concurrency = 1;
+        }
 
+        vasync.forEachPipeline({
+            inputs: generations,
+            func: function importOneGen(gen, nextGen) {
+                importSetOfImages({
+                    concurrency: concurrency,
+                    imgs: gen,
+                    progress: progress,
+                    sdcadm: sdcadm,
+                    source: source
+                }, nextGen);
+            }
+        }, function doneGens(genErr) {
+            if (genErr) {
                 /*
-                 * If we find that the image origin has already been queued for
-                 * download, we need to move it up on the download queue, since
-                 * we want it downloaded before the image we're evaluating now.
+                 * A common source of errors is that someone tries to
+                 * 'sdcadm up' on a DC with an IMGAPI that has no external
+                 * access. Let's try to give a nicer error message for that
+                 * case.
                  */
-                var found = false;
-                colsToRetrieve.forEach(function (aCol) {
-                    var pos;
-                    for (pos = 0; pos < aCol.length; pos += 1) {
-                        if (aCol[pos].uuid === img.origin) {
-                            newCol.push(aCol[pos]);
-                            delete (aCol[pos]);
-                            found = true;
+                if (VError.findCauseByName(genErr, 'RemoteSourceError')) {
+                    sdcadm.checkMissingExternalNics({
+                        progress: progress
+                    }, function (checkErr, checkRes) {
+                        if (checkErr) {
+                            cb(VError.errorFromList([genErr, checkErr]));
+                            return;
                         }
-                    }
-                });
-                if (found) {
-                    nextImg();
-                    return;
-                }
 
-                var orig = img.origin;
-                sdcadm.imgapi.getImage(orig, function (err, local) {
-                    if (!err) {
-                        /*
-                         * Origin already imported but unactivated.
-                         */
-                        if (local.state === 'unactivated') {
-                            newCol.push(local);
-                        }
-                        nextImg();
-                        return;
-                    } else if (err) {
-                        if (err.body.code !== 'ResourceNotFound') {
-                            nextImg(new errors.SDCClientError(err, 'imgapi'));
-                            return;
-                        } else {
-                            /*
-                             * We need to fetch origin details from remote
-                             * (origin not imported).
-                             */
-                            sdcadm.updates.getImage(orig, function (er, rem) {
-                                if (er) {
-                                    nextImg(new errors.SDCClientError(er,
-                                        'updates'));
-                                    return;
-                                }
-                                newCol.push(rem);
-                                nextImg();
-                            });
+                        if (checkRes.doimgapi) {
+                            progress(
+                                '* * *\n' +
+                                'There was an error trying to download ' +
+                                    'images because the imgapi zone has no\n' +
+                                'external NIC. Please run the following and ' +
+                                    'try again:\n' +
+                                '    sdcadm post-setup common-external-nics\n' +
+                                '* * *'
+                            );
                         }
-                    }
-                });
-            }
-        }, function paraCb(paraErr) {
-            if (paraErr) {
-                callback(paraErr);
-                return;
-            }
-            if (newCol.length) {
-                var uuids = [];
-                newCol = newCol.filter(function (elm) {
-                    var isNew = (uuids.indexOf(elm.uuid) === -1);
-                    if (isNew) {
-                        uuids.push(elm.uuid);
-                    }
-                    return isNew;
-                });
-                colsToRetrieve.unshift(newCol);
-                getAncestorsForImages(colsToRetrieve, callback);
+                        cb(genErr);
+                    });
+                } else {
+                    cb(genErr);
+                }
             } else {
-                callback(null, colsToRetrieve);
+                cb();
             }
         });
-    }
+    });
+};
 
 
-    function importCollectionOfImages(collection, nextCollection) {
-        var concurrency = 4;
-        if (useCustomSourceCountermeasures) {
-            concurrency = 1;
-        }
+/*
+ * Each element in `args.generations` an array of image objects (one
+ * generation). This function prepends generations to the array (modifying
+ * *in place*), until there are no more origins, or they are already
+ * in the local IMGAPI.
+ *
+ * @param {Object} args
+ *      - {Array} args.generations - The current stack of generations.
+ *      - {Boolean} args.useCustomSourceCountermeasures
+ * @param {Function} cb - `function (err)`
+ */
+function gatherImageGenerations(args, cb) {
+    assert.arrayOfArray(args.generations, 'args.generations');
+    assert.bool(args.useCustomSourceCountermeasures,
+        'args.useCustomSourceCountermeasures');
+    assert.object(args.sdcadm, 'args.sdcadm');
+    assert.func(cb, 'cb');
 
-        var q = vasync.queuev({
-            concurrency: concurrency,
-            worker: function importUpdateImage(image, next) {
-                /*
-                 * Need to be verified here b/c there are callers other than
-                 * procedures/index.js calling DownloadImages.
-                 */
-                function checkIfImageIsUnactivated(_, nextStep) {
-                    if (image.state === 'unactivated') {
-                        nextStep();
-                        return;
+    /*
+     * In this pass of the function we will fill out the `parentGen`eration,
+     * and then call ourself recursively for the next.
+     */
+    var currGen = args.generations[0];
+    var parentGen = [];
+    var sdcadm = args.sdcadm;
+
+    vasync.forEachParallel({
+        inputs: currGen,
+        func: function checkImgOrigin(img, nextImg) {
+            if (!img.origin || args.useCustomSourceCountermeasures) {
+                nextImg();
+                return;
+            }
+
+            /*
+             * If we find this image's origin in a younger generation (see
+             * image "A" in the diagram above), we need to move it up to
+             * this older generation so that it is downloaded before `currGen`.
+             */
+            var found = false;
+            args.generations.forEach(function (youngerGen) {
+                for (var i = 0; i < youngerGen.length; i += 1) {
+                    if (youngerGen[i].uuid === img.origin) {
+                        parentGen.push(youngerGen[i]);
+                        delete youngerGen[i];
+                        found = true;
+                        break;
                     }
-                    sdcadm.imgapi.getImage(image.uuid, function (err, local) {
-                        if (err && err.body.code === 'ResourceNotFound') {
-                            nextStep();
-                        } else if (err) {
-                            nextStep(new errors.SDCClientError(err, 'imgapi'));
-                        } else {
-                            if (local.state === 'unactivated') {
-                                // Let DownloadImages know that it has to
-                                // remove the image first:
-                                image.state = 'unactivated';
-                            }
-                            nextStep();
+                }
+            });
+            if (found) {
+                nextImg();
+                return;
+            }
+
+            // If the origin is already in the local IMGAPI, we can skip it.
+            sdcadm.imgapi.getImage(img.origin, function (localErr, localImg) {
+                if (!localErr) {
+                    /*
+                     * An 'unactivated' image is possibly stale, we will
+                     * re-import it.
+                     */
+                    if (localImg.state === 'unactivated') {
+                        parentGen.push(localImg);
+                    }
+                    nextImg();
+                } else if (
+                    localErr.body &&
+                    localErr.body.code === 'ResourceNotFound'
+                ) {
+                    /*
+                     * 404. We don't have the image locally. Get the image obj
+                     * from the remote source to be imported.
+                     */
+                    sdcadm.updates.getImage(img.origin, function (
+                        remoteErr,
+                        remoteImg
+                    ) {
+                        if (remoteErr) {
+                            nextImg(new errors.SDCClientError(remoteErr,
+                                'updates'));
+                            return;
                         }
+                        parentGen.push(remoteImg);
+                        nextImg();
                     });
+                } else {
+                    nextImg(new errors.SDCClientError(localErr, 'imgapi'));
+                }
+            });
+        }
+    }, function finishedParentGen(parentGenErr) {
+        if (parentGenErr) {
+            cb(parentGenErr);
+            return;
+        }
+        if (parentGen.length) {
+            var uuids = [];
+            parentGen = parentGen.filter(function (elm) {
+                var isNew = (uuids.indexOf(elm.uuid) === -1);
+                if (isNew) {
+                    uuids.push(elm.uuid);
                 }
+                return isNew;
+            });
+            args.generations.unshift(parentGen);
+            gatherImageGenerations(args, cb);
+        } else {
+            cb(null);
+        }
+    });
+}
+
+
+/*
+ * Import the given set of image objects (`args.imgs`) with the given
+ * concurrency.
+ *
+ * @param ...
+ * @param {Function} `cb` - called as `cb(err)` where `err` is null or
+ *      a single error, or a `verror.MultiError` if multiple concurrent imports
+ *      failed.
+ *
+ * Dev Note: If there are multiple errors, then `err` will be a
+ * `verror.MultiError` -- which is different from a `errors.MultiError`.
+ * This is an unfortunate middle ground, until sdcadm transitions from
+ * its "errors.js" wrappers to raw VError instances using facilities
+ * in verror v1.7.0 (see RFD 41).
+ */
+function importSetOfImages(args, cb) {
+    assert.arrayOfObject(args.imgs, 'args.imgs');
+    assert.string(args.source, 'args.source');
+    assert.object(args.sdcadm, 'args.sdcadm');
+    assert.func(args.progress, 'args.progress');
+    assert.finite(args.concurrency, 'args.concurrency');
+    assert.func(cb, 'cb');
 
-                function deleteImage(_, nextStep) {
-                    if (image.state !== 'unactivated') {
-                        return nextStep();
+    var errs = [];
+    var progress = args.progress;
+    var sdcadm = args.sdcadm;
+
+    var q = vasync.queuev({
+        concurrency: args.concurrency,
+        worker: function importAnImage(image, nextImg) {
+            /*
+             * Need to be verified here b/c there are callers other than
+             * procedures/index.js calling DownloadImages.
+             */
+            function checkIfImageIsUnactivated(_, nextStep) {
+                if (image.state === 'unactivated') {
+                    nextStep();
+                    return;
+                }
+                sdcadm.imgapi.getImage(image.uuid, function (err, local) {
+                    if (err && err.body.code === 'ResourceNotFound') {
+                        nextStep();
+                    } else if (err) {
+                        nextStep(new errors.SDCClientError(err, 'imgapi'));
+                    } else {
+                        if (local.state === 'unactivated') {
+                            // Let DownloadImages know that it has to
+                            // remove the image first:
+                            image.state = 'unactivated';
+                        }
+                        nextStep();
                     }
+                });
+            }
+
+            function deleteImage(_, nextStep) {
+                if (image.state !== 'unactivated') {
+                    nextStep();
+                    return;
+                }
+
+                progress('Removing unactivated image %s\n(%s@%s)',
+                    image.uuid, image.name, image.version);
 
-                    progress('Removing unactivated image %s\n(%s@%s)',
-                        image.uuid, image.name, image.version);
+                sdcadm.imgapi.deleteImage(image.uuid, function (err) {
+                    if (err) {
+                        progress('Error removing unactivated image %s\n(%s@%s)',
+                            image.uuid, image.name, image.version);
 
-                    sdcadm.imgapi.deleteImage(image.uuid, function (err) {
+                        var e = new errors.SDCClientError(err, 'imgapi');
+                        e.image = image.uuid;
+                        sdcadm.log.error({err: e}, 'Error removing image');
+                        nextStep(e);
+                    } else {
+                        nextStep();
+                    }
+                });
+            }
+
+            function getImage(_, nextStep) {
+                progress('Downloading image %s\n    (%s@%s)',
+                    image.uuid, image.name, image.version);
+                sdcadm.imgapi.adminImportRemoteImageAndWait(
+                    image.uuid,
+                    args.source,
+                    {
+                        // TODO: Once IMGAPI-408 is sufficient deployed,
+                        // then drop this `skipOwnerCheck`.
+                        skipOwnerCheck: true,
+                        // Retry image import 5 times by default:
+                        retries: 5
+                    },
+                    function (err, img, res) {
                         if (err) {
-                            progress(
-                                'Error removing unactivated image %s\n(%s@%s)',
+                            progress('Error importing image %s\n    (%s@%s)',
                                 image.uuid, image.name, image.version);
-
-                            var e = new errors.SDCClientError(err, 'imgapi');
+                            var e = new errors.SDCClientError(err,
+                                'imgapi');
                             e.image = image.uuid;
-                            sdcadm.log.error({err: e}, 'Error removing image');
                             nextStep(e);
                         } else {
+                            progress('Imported image %s\n    (%s@%s)',
+                                image.uuid, image.name, image.version);
                             nextStep();
                         }
                     });
-                }
-
-                function getImage(_, nextStep) {
-                    progress('Downloading image %s\n    (%s@%s)',
-                        image.uuid, image.name, image.version);
-                    sdcadm.imgapi.adminImportRemoteImageAndWait(
-                        image.uuid,
-                        source,
-                        {
-                            // TODO: Once IMGAPI-408 is sufficient deployed,
-                            // then drop this `skipOwnerCheck`.
-                            skipOwnerCheck: true,
-                            // Retry image import 5 times by default:
-                            retries: 5
-                        },
-                        function (err, img, res) {
-                            if (err) {
-                                progress('Error importing image %s\n(%s@%s)',
-                                    image.uuid, image.name, image.version);
-                                var e = new errors.SDCClientError(err,
-                                    'imgapi');
-                                e.image = image.uuid;
-                                nextStep(e);
-                            } else {
-                                progress('Imported image %s\n    (%s@%s)',
-                                    image.uuid, image.name, image.version);
-                                nextStep();
-                            }
-                        });
-                }
-
-                vasync.pipeline({funcs: [
-                    checkIfImageIsUnactivated,
-                    deleteImage,
-                    getImage
-                ]}, next);
             }
-        });
 
-        function onTaskComplete(err) {
-            if (err) {
-                errs.push(err);
-            }
+            vasync.pipeline({funcs: [
+                checkIfImageIsUnactivated,
+                deleteImage,
+                getImage
+            ]}, nextImg);
         }
+    });
 
-        q.on('end', function done() {
-            nextCollection();
-        });
-
-        q.push(collection, onTaskComplete);
-        q.close();
-    }
-
-
-
-    /*
-     * TOOLS-1634: We need to make sure that all the origins for
-     * all our images are imported and active in local IMGAPI.
-     * Additionally, we cannot try to import origins and the images
-     * created from those origins in parallel, so we need to import
-     * the different level of images ancestors sequentially.
-     *
-     * We'll use an array of arrays, prepending collections to this array as
-     * we go deeper in image's origins. Every origin not already on the local
-     * IMGAPI or with a state of 'unactivated' will be imported. Once we have
-     * a collection of 'sibiling' origins, we'll normalize that collection
-     * (remove duplicates) and prepend to `collectionsToRetrieve`:
-     */
-    var collectionsToRetrieve = [];
-    /*
-     * We'll begin with the service images we want to retrieve first,
-     * then we'll continue with successive origins.
-     */
-    collectionsToRetrieve.unshift(self.images);
-
-    getAncestorsForImages(collectionsToRetrieve, function (err, collections) {
+    function onTaskComplete(err) {
         if (err) {
-            cb(err);
-            return;
+            errs.push(err);
+            /*
+             * Don't start more tasks. After a single image import failure
+             * we want to fail reasonably fast, i.e. *not* wait for another
+             * N image imports to be started from the queue.
+             */
+            q.kill();
         }
+    }
 
-        vasync.forEachPipeline({
-            inputs: collections,
-            func: importCollectionOfImages
-        }, function pipeCb(pipeErr) {
-            if (pipeErr) {
-                cb(pipeErr);
-                return;
-            }
-            var er = (errs.length === 1) ? errs[0] :
-                new errors.MultiError(errs);
-
-            // Check if the problem is that external nics are missing.
-            if (errs.length) {
-                var remoteSourceErr = errs.some(function (e) {
-                    return (e && e.we_cause &&
-                        e.we_cause.name === 'RemoteSourceError');
-                });
+    q.on('end', function done() {
+        cb(VError.errorFromList(errs));
+    });
 
-                if (remoteSourceErr) {
-                    sdcadm.checkMissingExternalNics({
-                        progress: progress
-                    }, function (nicsErr, res) {
-                        if (nicsErr) {
-                            return cb(errs);
-                        }
+    q.push(args.imgs, onTaskComplete);
+    q.close();
+}
 
-                        var doimgapi = res.doimgapi;
-                        if (doimgapi) {
-                            p('');
-                            var msg = 'There is an error trying to download ' +
-                                'images because the imgapi zone has no ' +
-                                'external NIC.\nPlease run:\n\n' +
-                                '   sdcadm post-setup common-external-nics\n' +
-                                '\nand try again.\n';
-                            p(msg);
-                        }
-                        // we need to return the error anyway:
-                        cb(er);
-                        return;
-                    });
-                } else {
-                    cb(er);
-                }
-            } else {
-                cb();
-            }
-        });
-    });
-};
 
 //---- exports
 
diff --git a/package.json b/package.json
index b355758..5756a00 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "sdcadm",
   "description": "Administer a SmartDataCenter (SDC) standup",
-  "version": "1.15.8",
+  "version": "1.15.9",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
@@ -28,7 +28,7 @@
     "tape": "3.5.0",
     "urclient": "^1.1.0",
     "vasync": "^1.6.4",
-    "verror": "^1.6.1",
+    "verror": "^1.10.0",
     "wf-client": "git+https://github.com/joyent/sdc-wf-client.git#9bcb3a0ebec7cd5b4052acaacde8fd6e3e2dfcf9"
   },
   "devDependencies": {
