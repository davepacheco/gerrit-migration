From 291d670dd2770047aa2b9c51e22145c914b0bad6 Mon Sep 17 00:00:00 2001
From: John Levon <john.levon@joyent.com>
Date: Thu, 4 Apr 2019 17:00:09 +0000
Subject: [PATCH] TRITON-1016 Need to build and deliver the ipxe EFI binary
 TRITON-1021 Re-enable bzimage support in ipxe TRITON-1071 iPXE needs
 multiboot2 EFI support Reviewed by: Robert Mustacchi <rm@joyent.com> Approved
 by: Joshua M. Clulow <jmc@joyent.com>

---
 .gitignore                            |   9 +
 .gitmodules                           |   3 +
 Makefile                              | 136 ++++
 README                                |   5 +-
 boot/default.ipxe                     |  49 ++
 deps/eng                              |   1 +
 src/Makefile.efi                      |   2 +
 src/arch/x86/image/multiboot.c        |   2 +-
 src/arch/x86/image/multiboot2.c       | 988 ++++++++++++++++++++++++++
 src/arch/x86/image/multiboot2_entry.S | 137 ++++
 src/arch/x86/include/bits/errfile.h   |   1 +
 src/arch/x86/include/multiboot2.h     | 417 +++++++++++
 src/arch/x86_64/Makefile              |   2 +-
 src/bin/.gitignore                    |   1 -
 src/config/config.c                   |   3 +
 src/config/defaults/efi.h             |   4 +
 src/config/local/general.h            |   4 +-
 src/config/local/settings.h           |   4 +-
 src/include/ipxe/features.h           |   1 +
 src/include/ipxe/image.h              |  15 +-
 src/util/elf2efi.c                    |  29 +
 21 files changed, 1802 insertions(+), 11 deletions(-)
 create mode 100644 .gitignore
 create mode 100644 .gitmodules
 create mode 100644 Makefile
 create mode 100644 boot/default.ipxe
 create mode 160000 deps/eng
 create mode 100644 src/arch/x86/image/multiboot2.c
 create mode 100644 src/arch/x86/image/multiboot2_entry.S
 create mode 100644 src/arch/x86/include/multiboot2.h
 delete mode 100644 src/bin/.gitignore

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 00000000..54706de2
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,9 @@
+bits
+ipxe-*.tar.gz
+proto
+# These headers are generated by the build
+src/config/local/crypto.h
+src/config/local/fault.h
+src/config/local/reboot.h
+src/config/local/usb.h
+
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 00000000..6cbac639
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "deps/eng"]
+	path = deps/eng
+	url = https://github.com/joyent/eng.git
diff --git a/Makefile b/Makefile
new file mode 100644
index 00000000..2ac760de
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,136 @@
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+# Copyright (c) 2019, Joyent, Inc.
+#
+
+NAME = ipxe
+
+TOP :=	$(shell pwd)
+ROOT =	$(TOP)/proto
+
+RELEASE_TARBALL =	$(NAME)-$(STAMP).tar.gz
+
+# ipxe doesn't quite clean up after itself
+CLEAN_FILES += \
+	src/config/local/crypto.h \
+	src/config/local/fault.h \
+	src/config/local/reboot.h \
+	src/config/local/usb.h \
+	$(ROOT) \
+	$(NAME)-*.tar.gz
+
+#
+# ipxe assumes GNU without using prefixed commands.
+#
+IPXE_ENV = \
+	CC=/opt/local/bin/gcc \
+	AS=/opt/local/bin/as \
+	LD=/opt/local/bin/gld \
+	AWK=/usr/bin/nawk \
+	GREP=/usr/xpg4/bin/grep \
+	GITVERSION= \
+	V=1
+
+TAR =		/usr/bin/gtar
+MKDIR =		/usr/bin/mkdir
+MKFILE =	/usr/sbin/mkfile
+CP =		/usr/bin/cp
+OBJCOPY =	/opt/local/bin/objcopy
+CHMOD =		/usr/bin/chmod
+RM =		/usr/bin/rm -f
+INS =		/usr/sbin/install
+
+FILEMODE =	644
+DIRMODE =	755
+
+INS.file =	$(RM) $@; $(INS) -s -m $(FILEMODE) -f $(@D) $<
+INS.dir =	$(INS) -s -d -m $(DIRMODE) $@
+
+EFI_BINS = ipxe.efi snponly.efi
+EFI_SRC_BIN = src/bin-x86_64-efi
+EFI_TARGETS = $(EFI_BINS:%=$(EFI_SRC_BIN)/%)
+
+BOOT_BINS = \
+	undionly.kpxe \
+	default.ipxe \
+	ipxe.lkrn \
+	$(EFI_BINS)
+
+BOOT_ROOT =	$(ROOT)/boot
+ROOT_BOOT_BINS =	$(BOOT_BINS:%=$(BOOT_ROOT)/%)
+ROOT_BOOT =	$(ROOT_BOOT_BINS)
+
+$(BOOT_ROOT)/ipxe.lkrn :	FILEMODE = 755
+$(BOOT_ROOT)/default.ipxe :	FILEMODE = 644
+$(BOOT_ROOT)/undionly.kpxe :	FILEMODE = 644
+
+# our base image is triton-origin-multiarch-15.4.1
+BASE_IMAGE_UUID = 04a48d7d-6bb5-4e83-8c3b-e60a99e0f48f
+
+ENGBLD_USE_BUILDIMAGE = false
+ENGBLD_REQUIRE := $(shell git submodule update --init deps/eng)
+include ./deps/eng/tools/mk/Makefile.defs
+TOP ?= $(error Unable to access eng.git submodule Makefiles.)
+
+.PHONY: all
+all: src/bin/ipxe.lkrn $(EFI_TARGETS)
+
+.PHONY: install
+install: all $(ROOT_BOOT)
+	mkdir -p $(ROOT)/etc/version
+	echo $(TIMESTAMP) >$(ROOT)/etc/version/ipxe
+
+$(ROOT):
+	$(INS.dir)
+
+$(BOOT_ROOT): | $(ROOT)
+	$(INS.dir)
+
+$(BOOT_ROOT)/%: src/bin/% | $(BOOT_ROOT)
+	$(INS.file)
+
+$(BOOT_ROOT)/ipxe.efi: src/bin-x86_64-efi/ipxe.efi | $(BOOT_ROOT)
+	$(INS.file)
+
+$(BOOT_ROOT)/snponly.efi: src/bin-x86_64-efi/snponly.efi | $(BOOT_ROOT)
+	$(INS.file)
+
+$(BOOT_ROOT)/%: boot/% | $(BOOT_ROOT)
+	$(INS.file)
+
+src/bin/%:
+	(cd src && $(MAKE) bin/$(@F) $(IPXE_ENV))
+
+src/bin-x86_64-efi/%:
+	 (cd src && $(MAKE) bin-x86_64-efi/$(@F) $(IPXE_ENV))
+
+.PHONY: test
+test:
+
+.PHONY: pkg
+pkg: install
+
+clean:: ipxe.clean
+	rm -rf $(CLEAN_FILES)
+
+ipxe.clean:
+	(cd src && $(MAKE) clean $(IPXE_ENV))
+
+release: $(RELEASE_TARBALL)
+
+$(RELEASE_TARBALL): pkg
+	(cd $(ROOT); $(TAR) -I pigz -cf $(TOP)/$(RELEASE_TARBALL) .)
+
+publish: release
+	@if [[ -z "$(ENGBLD_BITS_DIR)" ]]; then \
+		echo "error: 'ENGBLD_BITS_DIR' must be set for 'publish' target"; \
+		exit 1; \
+	fi
+	mkdir -p $(ENGBLD_BITS_DIR)/ipxe
+	cp $(RELEASE_TARBALL) $(ENGBLD_BITS_DIR)/ipxe/$(RELEASE_TARBALL)
+
+include ./deps/eng/tools/mk/Makefile.deps
+include ./deps/eng/tools/mk/Makefile.targ
diff --git a/README b/README
index cb6a03bb..9ae0fb78 100644
--- a/README
+++ b/README
@@ -1,9 +1,8 @@
 iPXE README File (as adapted to illumos systems)
 
-Quick start guide:
+To build:
 
-   cd src
-   gmake AS=/path/to/gnu/as LD=/path/to/gnu/ld AWK=nawk GREP=/usr/xpg4/bin/grep
+    gmake install
 
 ipxe, unlike virtually all other software, actually assumes and requires
 GNU ld to build.  This is because of the presence of GNU linker scripts.
diff --git a/boot/default.ipxe b/boot/default.ipxe
new file mode 100644
index 00000000..1b6f83af
--- /dev/null
+++ b/boot/default.ipxe
@@ -0,0 +1,49 @@
+#!ipxe
+#
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+
+#
+# Copyright (c) 2014, Joyent, Inc.
+#
+
+#
+# We attempt to boot from 10Gb interfaces first, if there are any that match
+# our expected PCI ID.  Failing that, try anything.
+#
+iseq ${net0/busid} 01:80:86:10:fb && autoboot net0 ||
+iseq ${net1/busid} 01:80:86:10:fb && autoboot net1 ||
+iseq ${net2/busid} 01:80:86:10:fb && autoboot net2 ||
+iseq ${net3/busid} 01:80:86:10:fb && autoboot net3 ||
+iseq ${net4/busid} 01:80:86:10:fb && autoboot net4 ||
+iseq ${net5/busid} 01:80:86:10:fb && autoboot net5 ||
+iseq ${net6/busid} 01:80:86:10:fb && autoboot net6 ||
+iseq ${net7/busid} 01:80:86:10:fb && autoboot net7 ||
+iseq ${net8/busid} 01:80:86:10:fb && autoboot net8 ||
+iseq ${net9/busid} 01:80:86:10:fb && autoboot net9 ||
+
+iseq ${net0/busid} 01:80:86:15:28 && autoboot net0 ||
+iseq ${net1/busid} 01:80:86:15:28 && autoboot net1 ||
+iseq ${net2/busid} 01:80:86:15:28 && autoboot net2 ||
+iseq ${net3/busid} 01:80:86:15:28 && autoboot net3 ||
+iseq ${net4/busid} 01:80:86:15:28 && autoboot net4 ||
+iseq ${net5/busid} 01:80:86:15:28 && autoboot net5 ||
+iseq ${net6/busid} 01:80:86:15:28 && autoboot net6 ||
+iseq ${net7/busid} 01:80:86:15:28 && autoboot net7 ||
+iseq ${net8/busid} 01:80:86:15:28 && autoboot net8 ||
+iseq ${net9/busid} 01:80:86:15:28 && autoboot net9 ||
+
+iseq ${net0/busid} 01:80:86:15:4d && autoboot net0 ||
+iseq ${net1/busid} 01:80:86:15:4d && autoboot net1 ||
+iseq ${net2/busid} 01:80:86:15:4d && autoboot net2 ||
+iseq ${net3/busid} 01:80:86:15:4d && autoboot net3 ||
+iseq ${net4/busid} 01:80:86:15:4d && autoboot net4 ||
+iseq ${net5/busid} 01:80:86:15:4d && autoboot net5 ||
+iseq ${net6/busid} 01:80:86:15:4d && autoboot net6 ||
+iseq ${net7/busid} 01:80:86:15:4d && autoboot net7 ||
+iseq ${net8/busid} 01:80:86:15:4d && autoboot net8 ||
+iseq ${net9/busid} 01:80:86:15:4d && autoboot net9 ||
+
+autoboot
diff --git a/deps/eng b/deps/eng
new file mode 160000
index 00000000..4443fcd3
--- /dev/null
+++ b/deps/eng
@@ -0,0 +1 @@
+Subproject commit 4443fcd38fe1682556e1851df97c7d652d078f3d
diff --git a/src/Makefile.efi b/src/Makefile.efi
index 151b3318..11df561c 100644
--- a/src/Makefile.efi
+++ b/src/Makefile.efi
@@ -8,6 +8,8 @@ LDSCRIPT	= scripts/efi.lds
 #
 LDFLAGS		+= -q -S
 
+CFLAGS		+= -DPXE_EFI
+
 # Media types.
 #
 NON_AUTO_MEDIA	+= efi
diff --git a/src/arch/x86/image/multiboot.c b/src/arch/x86/image/multiboot.c
index 715574fb..de627fe1 100644
--- a/src/arch/x86/image/multiboot.c
+++ b/src/arch/x86/image/multiboot.c
@@ -192,7 +192,7 @@ static physaddr_t multiboot_add_cmdline ( struct image *image ) {
 	/* Copy image URI to base memory buffer as start of command line */
 	len = ( format_uri ( image->uri, buf, remaining ) + 1 /* NUL */ );
 	if ( len > remaining ) {
-		printf ( "MULTIBOOT %p limit of %d cmdline characters "
+		printf ( "MULTIBOOT %p limit of %zd cmdline characters "
 		       "reached\n", image, sizeof (mb_cmdlines));
 		multiboot_panic();
 	}
diff --git a/src/arch/x86/image/multiboot2.c b/src/arch/x86/image/multiboot2.c
new file mode 100644
index 00000000..5a82dc77
--- /dev/null
+++ b/src/arch/x86/image/multiboot2.c
@@ -0,0 +1,988 @@
+/*
+ * Copyright (C) 2016 Star Lab Corp.
+ * Copyright (c) 2019, Joyent, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ * You can also choose to distribute this program under the terms of
+ * the Unmodified Binary Distribution Licence (as given in the file
+ * COPYING.UBDL), provided that you have satisfied its requirements.
+ */
+
+FILE_LICENCE ( GPL2_OR_LATER_OR_UBDL );
+
+/**
+ * Multiboot2 image format
+ *
+ * An illumos kernel is not an EFI image, and multiboot1 cannot load under
+ * UEFI.  Thus, multiboot2 is the only hope we have when in UEFI. The format is
+ * similar to that of multiboot1.
+ *
+ * This implementation is certainly incomplete - aside from the lack of legacy
+ * BIOS support - but it's sufficient.
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <assert.h>
+#include <strings.h>
+#include <stdbool.h>
+
+#include <ipxe/uaccess.h>
+#include <ipxe/image.h>
+#include <ipxe/segment.h>
+#include <ipxe/io.h>
+#include <ipxe/init.h>
+#include <ipxe/features.h>
+#include <ipxe/umalloc.h>
+#include <ipxe/uri.h>
+#include <ipxe/version.h>
+
+#include <multiboot2.h>
+
+FEATURE ( FEATURE_IMAGE, "MBOOT2", DHCP_EB_FEATURE_MULTIBOOT2, 1 );
+
+#ifdef EFIAPI
+
+#include <ipxe/efi/efi.h>
+
+#define P2ROUNDUP(x, align) (-(-(x) & -(align)))
+
+#define BIB_MAX_SIZE 4096
+#define	BIB_ADDR(mb2) ((void *)&((mb2)->bib[(mb2)->bib_offset]))
+#define BIB_REMAINING(mb2) (BIB_MAX_SIZE - (mb2)->bib_offset)
+
+#define	MB2_STACK_OFF (EFI_PAGE_SIZE * 2)
+
+struct mb2_image_header {
+	struct multiboot_header mb;
+	size_t file_offset;
+};
+
+struct mb2_entry {
+	enum entry_type {
+		ENTRY_I386,
+		ENTRY_EFI32,
+		ENTRY_EFI64
+	} type;
+	uint32_t addr;
+};
+
+struct mb2 {
+	struct image *image;
+	struct mb2_image_header image_hdr;
+
+	/* Kernel information. */
+	struct mb2_entry kernel_entry;
+	uint32_t kernel_load_addr;
+	size_t kernel_file_offset;
+	userptr_t kernel_image;
+	size_t kernel_filesz;
+	size_t kernel_memsz;
+
+	union {
+		uint64_t bib_align;
+		char bib[BIB_MAX_SIZE];
+	};
+
+	size_t bib_offset;
+
+	void *multiboot2_stack;
+};
+
+extern void multiboot2_bounce ( struct mb2 *, void *,
+				void (*fp)( struct mb2 * ) );
+extern void multiboot2_entry ( uint32_t, uint64_t, uint64_t );
+static void multiboot2_enter_kernel ( struct mb2 * );
+
+static int multiboot2_find_header ( struct image *image,
+				    struct mb2_image_header *hdr ) {
+	uint32_t buf[64];
+	size_t offset;
+	unsigned int buf_idx;
+	uint32_t checksum;
+
+	/*
+	 * Scan through first MULTIBOOT_SEARCH of image file 256 bytes at
+	 * a time.  (Use the buffering to avoid the overhead of a
+	 * copy_from_user() for every dword.)
+	 */
+
+	for ( offset = 0 ; offset < MULTIBOOT_SEARCH ;
+	      offset += sizeof ( buf[0] ) ) {
+		if ( offset > image->len )
+			break;
+
+		size_t remaining = image->len - offset;
+
+		/* Refill buffer if applicable */
+		buf_idx = ( ( offset % sizeof ( buf ) ) / sizeof ( buf[0] ) );
+		if ( buf_idx == 0 ) {
+			bzero ( buf, sizeof ( buf ) );
+			copy_from_user ( buf, image->data, offset,
+				remaining > sizeof ( buf ) ?
+				sizeof ( buf ) : remaining );
+		}
+
+		if ( buf[buf_idx] != MULTIBOOT2_HEADER_MAGIC )
+			continue;
+
+		if ( remaining < sizeof ( hdr->mb ) )
+			return -ENOSPC;
+
+		copy_from_user ( &hdr->mb, image->data, offset,
+				 sizeof ( hdr->mb ) );
+
+		checksum = ( hdr->mb.magic + hdr->mb.architecture +
+			     hdr->mb.header_length + hdr->mb.checksum );
+		if ( checksum != 0 )
+			continue;
+
+		if ( hdr->mb.architecture != MULTIBOOT_ARCHITECTURE_I386 )
+			return -ENOEXEC;
+
+		hdr->file_offset = offset;
+		return 0;
+	}
+
+	/* No multiboot header found */
+	return -ENOEXEC;
+}
+
+static int multiboot2_inforeq ( struct mb2 *mb2, size_t offset,
+				size_t nr_reqs ) {
+	size_t i;
+
+	for ( i = 0; i < nr_reqs; i++ ) {
+		uint32_t inforeq;
+
+		copy_from_user ( &inforeq, mb2->image->data,
+				 offset + ( i * sizeof ( inforeq ) ),
+				 sizeof ( inforeq ) );
+
+		DBGC ( mb2->image, "MULTIBOOT2 %p inforeq tag %d\n",
+		       mb2->image, inforeq );
+
+		/*
+		 * Note that we don't actually supply framebuffer or bootdev
+		 * information, but we acknowledge the request.
+		 */
+
+		switch ( inforeq ) {
+		case MULTIBOOT_TAG_TYPE_BASIC_MEMINFO:
+		case MULTIBOOT_TAG_TYPE_MMAP:
+		case MULTIBOOT_TAG_TYPE_CMDLINE:
+		case MULTIBOOT_TAG_TYPE_MODULE:
+		case MULTIBOOT_TAG_TYPE_BOOTDEV:
+		case MULTIBOOT_TAG_TYPE_FRAMEBUFFER:
+			continue;
+
+		default:
+			printf ( "unsupported inforeq tag %d\n", inforeq );
+			return -ENOTSUP;
+		}
+	}
+
+	return 0;
+}
+
+static int multiboot2_process_tag ( struct mb2 *mb2,
+				    struct multiboot_header_tag *tag,
+				    size_t offset ) {
+	struct multiboot_header_tag_entry_address entry_tag = { 0 };
+	int rc = 0;
+
+	switch ( tag->type ) {
+	case MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST: {
+		size_t nr_inforeqs = ( tag->size - sizeof ( *tag ) ) /
+				       sizeof ( uint32_t );
+
+		rc = multiboot2_inforeq ( mb2, offset + sizeof ( *tag ),
+					  nr_inforeqs );
+		if ( rc )
+			return rc;
+		break;
+	}
+
+	case MULTIBOOT_HEADER_TAG_ADDRESS: {
+		struct multiboot_header_tag_address load;
+
+		if ( tag->size != sizeof ( load ) ) {
+			printf ( "invalid address tag size %x\n", tag->size );
+			return -EINVAL;
+		}
+
+		copy_from_user ( &load, mb2->image->data, offset, tag->size );
+
+		DBGC ( mb2->image, "address tag: header_addr 0x%x, "
+		       "load_addr 0x%x, load_end_addr 0x%x "
+		       "bss_end_addr 0x%x\n", load.header_addr,
+		       load.load_addr, load.load_end_addr, load.bss_end_addr );
+
+		mb2->kernel_load_addr = load.load_addr;
+
+		mb2->kernel_file_offset = ( mb2->image_hdr.file_offset -
+			load.header_addr + mb2->kernel_load_addr );
+
+		mb2->kernel_filesz = ( load.load_end_addr ?
+		   ( load.load_end_addr - mb2->kernel_load_addr ) :
+		   mb2->image->len - mb2->kernel_file_offset );
+
+		mb2->kernel_memsz = ( load.bss_end_addr ?
+		  ( load.bss_end_addr - mb2->kernel_load_addr ) :
+		  mb2->kernel_filesz );
+
+		mb2->kernel_image = mb2->image->data;
+		break;
+	}
+
+	case MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS:
+		copy_from_user ( &entry_tag, mb2->image->data,
+				 offset, tag->size );
+
+		mb2->kernel_entry.type = ENTRY_I386;
+		mb2->kernel_entry.addr = entry_tag.entry_addr;
+		break;
+
+	case MULTIBOOT_HEADER_TAG_CONSOLE_FLAGS:
+		/* We should be OK to safely ignore this tag. */
+		break;
+
+	case MULTIBOOT_HEADER_TAG_FRAMEBUFFER:
+		/* Should be able to ignore this. */
+		break;
+
+	case MULTIBOOT_HEADER_TAG_MODULE_ALIGN:
+		/* Modules are umalloc()ed and hence always page-aligned. */
+		break;
+
+	case MULTIBOOT_HEADER_TAG_EFI_BS:
+		printf ( "Keeping boot services unsupported" );
+		rc = -ENOTSUP;
+		break;
+
+	case MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS_EFI32:
+		printf ( "unsupported tag ENTRY_ADDRESS_EFI32" );
+		rc = -ENOTSUP;
+		break;
+
+	case MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS_EFI64:
+		copy_from_user ( &entry_tag, mb2->image->data,
+				 offset, tag->size );
+
+		mb2->kernel_entry.type = ENTRY_EFI64;
+		mb2->kernel_entry.addr = entry_tag.entry_addr;
+		break;
+
+	case MULTIBOOT_HEADER_TAG_RELOCATABLE:
+		/* We will always map at the requested address. */
+		break;
+
+	default:
+		printf ( "unknown header tag %x\n", tag->type );
+		rc = -ENOTSUP;
+		break;
+	}
+
+	return rc;
+}
+
+/*
+ * Process the image's tags.
+ */
+static int multiboot2_process_tags ( struct mb2 *mb2 ) {
+	size_t offset = mb2->image_hdr.file_offset +
+			sizeof ( struct multiboot_header );
+	size_t end_offset = offset + mb2->image_hdr.mb.header_length;
+	int saw_entry = 0;
+	int saw_load = 0;
+	int rc;
+
+	while ( offset < end_offset ) {
+		struct multiboot_header_tag tag;
+
+		copy_from_user ( &tag, mb2->image->data,
+				 offset, sizeof ( tag ) );
+
+		DBGC ( mb2->image, "MULTIBOOT2 %p (offset: 0x%zx) tag type: %x "
+		       "flags: %x size: %d\n", mb2->image,
+		       offset - mb2->image_hdr.file_offset,
+		       tag.type, tag.flags, tag.size );
+
+		switch ( tag.type ) {
+		case MULTIBOOT_HEADER_TAG_END:
+			if (!saw_load) {
+				printf ( "%p missing address\n", mb2->image );
+				return -ENOEXEC;
+			}
+			if (!saw_entry) {
+				printf ( "%p missing entry\n", mb2->image );
+				return -ENOEXEC;
+			}
+			return 0;
+		case MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS_EFI64:
+		case MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS:
+			saw_entry = 1;
+			break;
+		case MULTIBOOT_HEADER_TAG_ADDRESS:
+			saw_load = 1;
+			break;
+		}
+
+		rc = multiboot2_process_tag ( mb2, &tag, offset );
+
+		if ( rc )
+			return rc;
+
+		offset += tag.size + (MULTIBOOT_TAG_ALIGN - 1);
+		offset = offset & ~(MULTIBOOT_TAG_ALIGN - 1);
+	}
+
+	printf ( "%p missing end tag\n", mb2->image );
+	return -ENOTSUP;
+}
+
+static int bib_get_space ( struct mb2 *mb2, size_t size ) {
+	if ( BIB_REMAINING( mb2 ) < size ) {
+		printf ( "%p exceeded BIB_MAX_SIZE ", mb2->image );
+		return -ENOSPC;
+	}
+
+	mb2->bib_offset += size;
+	return 0;
+}
+
+static void *bib_open_tag ( struct mb2 *mb2, multiboot_uint32_t type,
+			    size_t size ) {
+	struct multiboot_tag *tag;
+
+	if ( ( mb2->bib_offset & 7 ) != 0 ) {
+		size_t aligned_off = ( ( mb2->bib_offset + 8 ) & ~7 );
+		if ( aligned_off > BIB_MAX_SIZE )
+			return NULL;
+		mb2->bib_offset = aligned_off;
+	}
+
+	DBGC ( mb2->image, "MULTIBOOT2 tag %d at 0x%zx\n", type,
+	       mb2->bib_offset );
+
+	tag = BIB_ADDR ( mb2 );
+
+	if ( bib_get_space ( mb2, size ) )
+		return NULL;
+
+	tag->type = type;
+	return tag;
+}
+
+static void bib_close_tag ( struct mb2 *mb2, void *tagp ) {
+	struct multiboot_tag *tag = tagp;
+	tag->size = (char *)BIB_ADDR ( mb2 ) - (char *)tagp;
+}
+
+/*
+ * An image cmdline buffer is the URI of the image appended with its cmdline.
+ */
+static int multiboot2_fmt_cmdline ( struct mb2 *mb2, struct image *image,
+				    char *buf ) {
+	size_t remaining = BIB_REMAINING ( mb2 );
+	size_t len;
+
+	len = format_uri ( image->uri, buf, remaining ) + 1;
+	if ( len > remaining )
+		return -ENOSPC;
+
+	if ( image->cmdline == NULL ) {
+		mb2->bib_offset += len;
+		return 0;
+	}
+
+	/* Overwrite the NIL. */
+	len--;
+
+	mb2->bib_offset += len;
+	buf += len;
+	remaining -= len;
+
+	len = snprintf ( buf, remaining, " %s", image->cmdline ) + 1;
+	if ( len > remaining )
+		return -ENOSPC;
+
+	mb2->bib_offset += len;
+	return 0;
+}
+
+static int multiboot2_add_cmdline ( struct mb2 *mb2 ) {
+	struct multiboot_tag_string *tag;
+	int rc;
+
+	if ( ( tag = bib_open_tag ( mb2, MULTIBOOT_TAG_TYPE_CMDLINE,
+	       sizeof ( *tag ) ) ) == NULL )
+		return -ENOSPC;
+
+	rc = multiboot2_fmt_cmdline ( mb2, mb2->image, tag->string );
+
+	if ( rc )
+		return rc;
+
+	bib_close_tag ( mb2, tag );
+	return 0;
+}
+
+static int multiboot2_add_bootloader ( struct mb2 *mb2 ) {
+	struct multiboot_tag_string *tag;
+	size_t len;
+
+	if ( ( tag = bib_open_tag ( mb2, MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME,
+	       sizeof ( *tag ) ) ) == NULL )
+		return -ENOSPC;
+
+	len = snprintf ( tag->string, BIB_REMAINING ( mb2 ), "iPXE %s",
+			 product_version ) + 1;
+
+	if (len > BIB_REMAINING ( mb2 ))
+		return -ENOSPC;
+
+	mb2->bib_offset += len;
+	bib_close_tag ( mb2, tag );
+	return 0;
+}
+
+static int multiboot2_add_modules ( struct mb2 * mb2 ) {
+	struct image *module_image;
+
+	/* Add each image as a multiboot module */
+	for_each_image ( module_image ) {
+		struct multiboot_tag_module *tag;
+		int rc;
+
+		/* Do not include kernel image itself as a module */
+		if ( module_image == mb2->image )
+			continue;
+
+		if ( ( tag = bib_open_tag ( mb2, MULTIBOOT_TAG_TYPE_MODULE,
+		       sizeof ( *tag ) ) ) == NULL )
+			return -ENOSPC;
+
+		tag->mod_start = user_to_phys ( module_image->data, 0 );
+		tag->mod_end = user_to_phys ( module_image->data,
+					      module_image->len );
+
+		rc = multiboot2_fmt_cmdline ( mb2, module_image, tag->cmdline );
+
+		if ( rc )
+			return rc;
+
+		bib_close_tag ( mb2, tag );
+
+		DBGC ( mb2->image, "MULTIBOOT2 %p module %s is [%x,%x): %s\n",
+		       mb2->image, module_image->name, tag->mod_start,
+		       tag->mod_end, tag->cmdline );
+	}
+
+	return 0;
+}
+
+#define EM_ENTRY(em, i) ((EFI_MEMORY_DESCRIPTOR *)	\
+	((em)->mmap_buf + (i) * ((em)->descr_size)))
+
+static char *efi_mmap_buf;
+static size_t efi_mmap_bufsize;
+
+struct efi_mmap {
+	char *mmap_buf;
+	size_t nr_descrs;
+	size_t descr_size;
+	size_t descr_version;
+	UINTN key;
+};
+
+static EFI_STATUS get_efi_mmap ( struct efi_mmap *mp ) {
+	EFI_BOOT_SERVICES *bs = efi_systab->BootServices;
+	UINTN size = efi_mmap_bufsize;
+	UINT32 descr_version;
+	EFI_STATUS efirc;
+	UINTN descr_size;
+	UINTN key;
+
+again:
+	efirc = bs->GetMemoryMap ( &size, (EFI_MEMORY_DESCRIPTOR *)efi_mmap_buf,
+				   &key, &descr_size, &descr_version );
+
+	if ( efirc ) {
+		if ( efirc == EFI_BUFFER_TOO_SMALL ) {
+			free ( efi_mmap_buf );
+
+			if ( ( efi_mmap_buf = malloc ( size ) ) == NULL ) {
+				printf ( "Failed to alloc %llx bytes for "
+					"EFI memory map buffer\n", size );
+				return EFI_BUFFER_TOO_SMALL;
+			}
+
+			goto again;
+		}
+
+		printf ( "GetMemoryMap failed with %d\n", (int)efirc );
+		return efirc;
+	}
+
+	mp->mmap_buf = efi_mmap_buf;
+	mp->nr_descrs = size / descr_size;
+	mp->descr_size = descr_size;
+	mp->descr_version = descr_version;
+	mp->key = key;
+
+	return EFI_SUCCESS;
+}
+
+static multiboot_uint32_t
+convert_efi_type ( EFI_MEMORY_TYPE type )
+{
+	switch ( type ) {
+	case EfiReservedMemoryType:
+		return MULTIBOOT_MEMORY_RESERVED;
+
+	case EfiLoaderCode:
+	case EfiLoaderData:
+	case EfiBootServicesCode:
+	case EfiBootServicesData:
+		return MULTIBOOT_MEMORY_AVAILABLE;
+
+	case EfiRuntimeServicesCode:
+	case EfiRuntimeServicesData:
+		return MULTIBOOT_MEMORY_RESERVED;
+
+	case EfiConventionalMemory:
+		return MULTIBOOT_MEMORY_AVAILABLE;
+
+	case EfiUnusableMemory:
+		return MULTIBOOT_MEMORY_BADRAM;
+
+	case EfiACPIReclaimMemory:
+		return MULTIBOOT_MEMORY_ACPI_RECLAIMABLE;
+
+	case EfiACPIMemoryNVS:
+		return MULTIBOOT_MEMORY_NVS;
+
+	case EfiMemoryMappedIO:
+	case EfiMemoryMappedIOPortSpace:
+	case EfiPalCode:
+		return MULTIBOOT_MEMORY_RESERVED;
+
+	default:
+		printf ( "unknown memory type %d\n", type );
+		return MULTIBOOT_MEMORY_RESERVED;
+	}
+}
+
+/**
+ *
+ * Convert an EFI mmap into a traditional multiboot structure.  As the types
+ * are less specific, we will merge adjacent ranges that have the same multiboot
+ * type. We explicitly mark things such as EfiBootServicesCode as available,
+ * because they will be, post-ExitBootServices().
+ */
+static ssize_t multiboot2_build_mmap ( struct image *image,
+				       struct efi_mmap *em,
+				       struct multiboot_mmap_entry *mmap,
+				       size_t bufsize) {
+	struct multiboot_mmap_entry *lastme = NULL;
+	size_t nr = 0;
+	size_t i;
+
+	for ( i = 0; i < em->nr_descrs; i++ ) {
+		EFI_MEMORY_DESCRIPTOR *d = EM_ENTRY ( em, i );
+		multiboot_uint32_t mt = convert_efi_type ( d->Type );
+		struct multiboot_mmap_entry *me = &mmap[nr];
+
+		DBGC ( image, "EM[%zd]: PhysicalStart 0x%llx "
+		       "NumberOfPages %lld Type 0x%d\n", i, d->PhysicalStart,
+		       d->NumberOfPages, d->Type );
+
+		if ( lastme != NULL && mt == lastme->type &&
+			d->PhysicalStart == lastme->addr + lastme->len ) {
+			lastme->len += d->NumberOfPages << EFI_PAGE_SHIFT;
+			continue;
+		}
+
+		if ( bufsize < ( ++nr ) * sizeof ( *me ) ) {
+			printf ( "not enough space for mmap (%lx < %lx)\n",
+			    bufsize, nr * sizeof ( *me ) );
+			return -ENOSPC;
+		}
+
+		me->addr = d->PhysicalStart;
+		me->len =  d->NumberOfPages << EFI_PAGE_SHIFT;
+		me->type = mt;
+		me->zero = 0;
+		lastme = me;
+	}
+
+	return nr * sizeof ( *mmap );
+}
+
+/**
+ *
+ * Supply the MMAP tag. This is built from the EFI mmap, but we don't supply
+ * MULTIBOOT_TAG_TYPE_EFI_MMAP as well - illumos doesn't use it, and it can be
+ * significantly larger than the space we have available (e.g. 250 entries on
+ * one machine).
+ */
+static int multiboot2_add_mmap ( struct mb2 *mb2 ) {
+	struct multiboot_tag_mmap *tag;
+	struct efi_mmap em;
+	EFI_STATUS efirc;
+	ssize_t size;
+
+	if ( ( efirc = get_efi_mmap ( &em ) ) != 0 )
+		return -EEFI ( efirc );
+
+	if ( ( tag = bib_open_tag ( mb2, MULTIBOOT_TAG_TYPE_MMAP,
+	       sizeof ( *tag ) ) ) == NULL )
+		return -ENOSPC;
+
+	tag->entry_size = sizeof ( struct multiboot_mmap_entry );
+	tag->entry_version = 0;
+
+	size = multiboot2_build_mmap ( mb2->image, &em, BIB_ADDR ( mb2 ),
+				       BIB_REMAINING ( mb2 ) );
+
+        if ( size < 0 )
+		return (int)size;
+
+	(void) bib_get_space ( mb2, size );
+
+	bib_close_tag ( mb2, tag );
+	return 0;
+}
+
+static bool overlaps ( size_t s1, size_t e1, size_t s2, size_t e2 ) {
+	return s1 < e2 && e1 >= s2;
+}
+
+/*
+ * We've been requested to map the kernel at a certain fixed address.  If we
+ * find that something will still be in use after exiting boot services, then
+ * there's nothing we can do.
+ */
+static int multiboot2_check_mmap ( struct mb2 *mb2 ) {
+	size_t kern_start = mb2->kernel_load_addr;
+	size_t kern_end = mb2->kernel_load_addr + mb2->kernel_memsz;
+	struct efi_mmap em;
+	EFI_STATUS efirc;
+	size_t i;
+
+	if ( ( efirc = get_efi_mmap ( &em ) ) != 0 )
+		return -EEFI ( efirc );
+
+	for ( i = 0; i < em.nr_descrs; i++ ) {
+		EFI_MEMORY_DESCRIPTOR *d = EM_ENTRY ( &em, i );
+		multiboot_uint32_t mt = convert_efi_type ( d->Type );
+		size_t mm_start = d->PhysicalStart;
+		size_t mm_end = d->PhysicalStart +
+				  ( d->NumberOfPages * EFI_PAGE_SIZE );
+
+		if ( mt == MULTIBOOT_MEMORY_AVAILABLE )
+			continue;
+
+		if ( ! ( overlaps ( kern_start, kern_end, mm_start, mm_end ) ) )
+			continue;
+
+		printf ( "EFI map entry 0x%zx-0x%zx (type %d) overlaps "
+			 "kernel map 0x%zx-0x%zx\n", mm_start, mm_end, d->Type,
+			 kern_start, kern_end );
+		return -ENOSPC;
+	}
+
+
+	/*
+	 * These are (hopefully) less likely, but paranoia here is a good idea.
+	 * If we do hit any of these, we'll have to implement more relocation
+	 * code (and somehow make sure that our code copies only have
+	 * %rip-relative relocations).
+	 */
+
+	if ( overlaps ( kern_start, kern_end, mb2->kernel_image,
+			mb2->kernel_image + mb2->kernel_memsz ) ) {
+		printf ( "Kernel image 0x%zx-0x%zx overlaps "
+			 "kernel map 0x%zx-0x%zx\n", mb2->kernel_image,
+			 mb2->kernel_image + mb2->kernel_memsz,
+			 kern_start, kern_end );
+		return -ENOSPC;
+	}
+
+	if ( overlaps ( kern_start, kern_end, (intptr_t)multiboot2_entry,
+			(intptr_t)multiboot2_entry + EFI_PAGE_SIZE ) ) {
+		printf ( "multiboot2_entry 0x%p overlaps "
+			 "kernel map 0x%zx-0x%zx\n", multiboot2_entry,
+			 kern_start, kern_end );
+		return -ENOSPC;
+	}
+
+	if ( overlaps ( kern_start, kern_end, (intptr_t)multiboot2_enter_kernel,
+			(intptr_t)multiboot2_enter_kernel + EFI_PAGE_SIZE ) ) {
+		printf ( "multiboot2_enter_kernel 0x%p overlaps "
+			 "kernel map 0x%zx-0x%zx\n", multiboot2_enter_kernel,
+			 kern_start, kern_end );
+		return -ENOSPC;
+	}
+
+	return 0;
+}
+
+/*
+ * We just need a small unused region that we're definitely not going to copy
+ * the kernel over during the bounce to kernel.
+ */
+static struct mb2 *multiboot2_alloc_bounce_buffer ( struct mb2 *mb2 ) {
+	EFI_BOOT_SERVICES *bs = efi_systab->BootServices;
+	EFI_PHYSICAL_ADDRESS phys_addr = P2ROUNDUP ( mb2->kernel_load_addr,
+						     EFI_PAGE_SIZE );
+	size_t size = EFI_PAGE_SIZE * 3;
+	int efirc;
+	char *p;
+
+	if ( ( efirc = bs->AllocatePages ( AllocateMaxAddress,
+		EfiBootServicesData, EFI_SIZE_TO_PAGES ( size ),
+		&phys_addr ) ) != 0 ) {
+		printf ( "MULTIBOOT2 could not allocate 0x%zx bytes: %s\n",
+		      size, strerror ( -EEFI ( efirc ) ) );
+		return NULL;
+	}
+
+	memcpy_user ( phys_to_user ( phys_addr), 0,
+		      (userptr_t)mb2, 0, sizeof ( *mb2 ) );
+
+	p = (char *)phys_to_user ( phys_addr );
+	mb2 = (struct mb2 *)p;
+	assert ( sizeof ( *mb2 ) < MB2_STACK_OFF );
+	mb2->multiboot2_stack = p + MB2_STACK_OFF;
+	return mb2;
+}
+
+/*
+ * To successfully exit boot services, we must pass a non-stale mmap key.
+ * However, the first time we call ->ExitBootServices(), this can trigger
+ * EVT_SIGNAL_EXIT_BOOT_SERVICES handlers, which themselves can do allocations
+ * and hence make the key stale.
+ *
+ * A second call will not trigger such handlers again, so trying twice should be
+ * sufficient.
+ *
+ * The key is also why we need to re-get the mmap immediately before
+ * ->ExitBootServices().
+ */
+static int exit_boot_services ( struct mb2 *mb2 ) {
+	EFI_BOOT_SERVICES *bs = efi_systab->BootServices;
+	struct efi_mmap em;
+	EFI_STATUS efirc;
+	int tries = 0;
+
+	DBGC ( mb2->image, "MULTIBOOT2 exit_boot_services ( )\n");
+
+again:
+	if ( ( efirc = get_efi_mmap ( &em ) ) != 0 )
+		return -EEFI ( efirc );
+
+	efirc = bs->ExitBootServices ( efi_image_handle, (UINTN)em.key );
+
+	if ( efirc == EFI_INVALID_PARAMETER && tries++ == 0 )
+		goto again;
+
+	if ( efirc ) {
+		DBGC ( mb2->image, "ExitBootServices() failed with %d\n",
+		       (int)efirc );
+		return -EEFI ( efirc );
+	}
+
+	return 0;
+}
+
+/*
+ * We need to copy the kernel image into the requested load address.  We've
+ * already exited boot services, so we know we're OK to use that region if
+ * it was previously EfiBootServicesCode/Data. We've also checked that the
+ * region doesn't overlap with:
+ *
+ * - any runtime services code or data, unusable memory and the like
+ * - multiboot2_enter_kernel
+ * - multiboot2_entry
+ * - mb2->kernel_image
+ *
+ * Our stack, and "mb2" itself, come from our bounce buffer. Thus, we shouldn't
+ * be using anything that the relocation code below could over-write.
+ */
+static void multiboot2_enter_kernel ( struct mb2 *mb2 ) {
+	char *load_addr = (char *)(intptr_t) mb2->kernel_load_addr;
+	size_t i;
+
+	/*
+	 * A lame byte-by-byte implementation, but iPXE's memcpy() does this
+	 * anyway...
+	 */
+	for ( i = 0; i < mb2->kernel_filesz; i++ ) {
+		load_addr[i] = ( (char *)mb2->kernel_image )
+			[mb2->kernel_file_offset + i];
+	}
+
+	for ( i = 0; i < mb2->kernel_memsz - mb2->kernel_filesz; i++ ) {
+		load_addr[mb2->kernel_filesz + i] = '\0';
+	}
+
+	if ( mb2->kernel_entry.type == ENTRY_EFI64 ) {
+		__asm__ __volatile__ ( "push %%rbp\n\t"
+				       "call *%%rdi\n\t"
+				       "pop %%rbp\n\t" : :
+				       "a" ( MULTIBOOT2_BOOTLOADER_MAGIC ),
+	                               "b" ( (uint32_t *)mb2->bib ),
+				       "D" ( (uint32_t)mb2->kernel_entry.addr )
+				       : "rcx", "rdx", "rsi", "memory" );
+	} else {
+		multiboot2_entry ( MULTIBOOT2_BOOTLOADER_MAGIC,
+				   (uint64_t)mb2->bib, mb2->kernel_entry.addr );
+	}
+
+	printf ( "MULTIBOOT2 entry returned !\n" );
+
+	for ( ;; ) {
+	}
+}
+
+struct mb2 init_mb2 = { 0 };
+
+static int multiboot2_exec ( struct image *image ) {
+	struct mb2 *mb2 = &init_mb2;
+	struct multiboot_tag_load_base_addr *load_tag;
+	struct multiboot_tag_efi64_ih *efi64_ih_tag;
+	struct multiboot_tag_efi64 *efi64_tag;
+	struct multiboot_tag *tag;
+	uint32_t *total_sizep;
+	int rc;
+
+	mb2->image = image;
+
+	if ( ( rc = multiboot2_find_header ( mb2->image,
+					     &mb2->image_hdr ) ) != 0 ) {
+		DBGC ( image, "MULTIBOOT2 %p has no multiboot header\n",
+		       image );
+		return rc;
+	}
+
+	if ( ( rc = multiboot2_process_tags ( mb2 ) ) != 0 )
+		return rc;
+
+	if ( ( rc = multiboot2_check_mmap ( mb2 ) ) != 0 )
+		return rc;
+
+	if ( ( mb2 = multiboot2_alloc_bounce_buffer ( mb2 ) ) == NULL )
+		return -ENOMEM;
+
+	total_sizep = BIB_ADDR ( mb2 );
+	mb2->bib_offset += sizeof ( *total_sizep );
+
+	/* reserved field */
+	mb2->bib_offset += sizeof ( uint32_t );
+
+	if ( ( load_tag = bib_open_tag ( mb2,
+	       MULTIBOOT_TAG_TYPE_LOAD_BASE_ADDR,
+	       sizeof ( *load_tag ) ) ) == NULL )
+		return -ENOSPC;
+	load_tag->load_base_addr = mb2->kernel_load_addr;
+	bib_close_tag ( mb2, load_tag );
+
+	if ( ( efi64_ih_tag = bib_open_tag ( mb2, MULTIBOOT_TAG_TYPE_EFI64_IH,
+	       sizeof ( *efi64_ih_tag ) ) ) == NULL )
+		return -ENOSPC;
+	efi64_ih_tag->pointer = (multiboot_uint64_t)efi_image_handle;
+	bib_close_tag ( mb2, efi64_ih_tag );
+
+	if ( ( efi64_tag = bib_open_tag ( mb2, MULTIBOOT_TAG_TYPE_EFI64,
+	       sizeof ( *efi64_tag ) ) ) == NULL )
+		return -ENOSPC;
+	efi64_tag->pointer = (multiboot_uint64_t)efi_systab;
+	bib_close_tag ( mb2, efi64_tag );
+
+	if ( ( rc = multiboot2_add_mmap ( mb2 ) ) != 0 )
+		return rc;
+
+	if ( ( rc = multiboot2_add_cmdline ( mb2 ) ) != 0 )
+		return rc;
+
+	if ( ( rc = multiboot2_add_bootloader ( mb2 ) ) != 0 )
+		return rc;
+
+	if ( ( rc = multiboot2_add_modules ( mb2 ) ) != 0 )
+		return rc;
+
+	if ( ( tag = bib_open_tag ( mb2, MULTIBOOT_TAG_TYPE_END,
+	       sizeof ( *tag ) ) ) == NULL )
+		return -ENOSPC;
+	bib_close_tag ( mb2, tag );
+
+	*total_sizep = mb2->bib_offset;
+
+	DBGC ( image, "MULTIBOOT2 %p BIB is %d bytes\n", image, *total_sizep );
+	DBGC ( image, "MULTIBOOT2 %p starting execution at %x\n",
+	       image, mb2->kernel_entry.addr );
+
+	if ( ( rc = exit_boot_services ( mb2 ) ) != 0 )
+		return rc;
+
+	/*
+	 * We have to bounce out and back again: GCC inline asm can't clobber
+	 * the stack pointer.
+	 */
+	multiboot2_bounce ( mb2, mb2->multiboot2_stack,
+			    multiboot2_enter_kernel );
+
+	return -ECANCELED;  /* -EIMPOSSIBLE, anyone? */
+}
+
+static int multiboot2_probe ( struct image *image ) {
+	struct mb2_image_header hdr;
+	int rc;
+
+	if ( ( rc = multiboot2_find_header ( image, &hdr ) ) != 0 ) {
+		DBGC ( image, "MULTIBOOT2 %p has no multiboot2 header\n",
+			   image );
+		return rc;
+	}
+
+	DBGC ( image, "MULTIBOOT2 %p found header at offset %zx "
+	       "with architecture %08x and header_length %d\n", image,
+	       hdr.file_offset, hdr.mb.architecture, hdr.mb.header_length );
+
+	return 0;
+}
+
+#else /* EFIAPI */
+
+static int multiboot2_exec ( struct image *image __unused ) {
+	return -ENOTSUP;
+}
+
+static int multiboot2_probe ( struct image *image __unused ) {
+	return -ENOEXEC;
+}
+
+#endif
+
+/** Multiboot image type */
+struct image_type multiboot2_image_type __image_type ( PROBE_MULTIBOOT2 ) = {
+	.name = "Multiboot 2",
+	.probe = multiboot2_probe,
+	.exec = multiboot2_exec,
+};
diff --git a/src/arch/x86/image/multiboot2_entry.S b/src/arch/x86/image/multiboot2_entry.S
new file mode 100644
index 00000000..ddc75f82
--- /dev/null
+++ b/src/arch/x86/image/multiboot2_entry.S
@@ -0,0 +1,137 @@
+/*
+ * Parts copyright Michael Brown <mbrown@fensystems.co.uk>
+ *
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+FILE_LICENCE ( GPL2_OR_LATER_OR_UBDL )
+
+/* CR0: protection enabled */
+#define CR0_PE ( 1 << 0 )
+
+/* CR0: paging */
+#define CR0_PG ( 1 << 31 )
+
+/* CR4: physical address extensions */
+#define CR4_PSE ( 1 << 4 )
+#define CR4_PAE ( 1 << 5 )
+#define CR4_PGE ( 1 << 7 )
+
+/* Extended feature enable MSR (EFER) */
+#define MSR_EFER 0xc0000080
+
+/* EFER: long mode enable */
+#define EFER_LME ( 1 << 8 )
+
+#define GDTSEL_CODE 0x8
+#define GDTSEL_DATA 0x10
+
+#if defined(PXE_EFI) && defined(__x86_64__)
+
+	.section ".text", "ax", @progbits
+
+	/*
+	 * %rdi -> multiboot2 magic
+	 * %rsi -> multiboot info pointer
+	 * %rdx -> entry address (32 bits)
+	 *
+	 *
+	 * We need to transition from our 64-bit environment into the one
+	 * defined by the multiboot2 spec, section 3.3. Namely, drop down to
+	 * 32-bit protected mode with a basic GDT, paging disabled, interrupts
+	 * off, and
+	 *
+	 * %eax -> multiboot2 magic
+	 * %ebx -> multiboot info pointer (physical)
+	 */
+	.align 16
+	.globl multiboot2_entry
+
+multiboot2_entry:
+	cli
+
+	movq	%rsi, %rbx /* mb2 infop */
+	movq	%rdx, %rsi /* entry address */
+
+	/* Load the mb2-mandated code and data segments.  */
+	leaq	entry_gdt_base(%rip), %rcx
+	leaq	entry_gdt(%rip), %rax
+	movq	%rax, (%rcx)
+
+	leaq	entry_gdtr(%rip), %rax
+	lgdt	(%rax)
+
+	/* Load our new %cs. */
+	ljmp	*newcs_vector
+
+	.code32
+newcs:
+
+	movw	$GDTSEL_DATA, %ax
+	movw	%ax, %ds
+	movw	%ax, %es
+	movw	%ax, %fs
+	movw	%ax, %gs
+	movw	%ax, %ss
+
+	/* Disable paging */
+	movl	%cr0, %eax
+	andl	$~CR0_PG, %eax
+	movl	%eax, %cr0
+
+	movl	%cr4, %eax
+	andb	$~(CR4_PAE | CR4_PGE | CR4_PSE), %al
+	movl	%eax, %cr4
+
+	/* Disable long mode (clobbers %eax, %edx) */
+	movl	$MSR_EFER, %ecx
+	rdmsr
+	andw	$~EFER_LME, %ax
+	wrmsr
+
+	/* %ebx still has our infop */
+	movl	%edi, %eax
+	jmp	*%esi
+
+	/*
+	 * %rdi -> struct mb2 *
+	 * %rsi -> stack pointer to switch to
+	 * %rdx -> &multiboot2_enter_kernel
+	 */
+	.align 16
+	.code64
+	.globl multiboot2_bounce
+
+multiboot2_bounce:
+	movq	%rsi, %rsp
+	jmp	*%rdx
+
+	.data
+
+newcs_vector:
+	.long	newcs, GDTSEL_CODE
+
+	.align 16
+entry_gdt:
+	/* null entry */
+	.word	0x0, 0x0
+	.byte	0x0, 0x0, 0x0, 0x0
+
+	/* 32 bit protected mode code segment */
+	.word	0xffff, 0x0
+	.byte	0x0, 0x9f, 0xcf, 0x0
+
+	/* 32 bit protected mode data segment */
+	.word	0xffff, 0x0
+	.byte	0x0, 0x93, 0xcf, 0x0
+
+entry_gdt_end:
+	.equ	entry_gdt_length, entry_gdt_end - entry_gdt
+
+	.align 16
+entry_gdtr:
+	.word entry_gdt_length - 1
+entry_gdt_base:
+	.quad 0
+
+#endif /* PXE_EFI && __x86_64__ */
diff --git a/src/arch/x86/include/bits/errfile.h b/src/arch/x86/include/bits/errfile.h
index b0ae1abc..8895dc81 100644
--- a/src/arch/x86/include/bits/errfile.h
+++ b/src/arch/x86/include/bits/errfile.h
@@ -43,6 +43,7 @@ FILE_LICENCE ( GPL2_OR_LATER_OR_UBDL );
 #define ERRFILE_sdi	       ( ERRFILE_ARCH | ERRFILE_IMAGE | 0x000b0000 )
 #define ERRFILE_initrd	       ( ERRFILE_ARCH | ERRFILE_IMAGE | 0x000c0000 )
 #define ERRFILE_pxe_call       ( ERRFILE_ARCH | ERRFILE_IMAGE | 0x000d0000 )
+#define ERRFILE_multiboot2     ( ERRFILE_ARCH | ERRFILE_IMAGE | 0x000e0000 )
 
 #define ERRFILE_undi		 ( ERRFILE_ARCH | ERRFILE_NET | 0x00000000 )
 #define ERRFILE_undiload	 ( ERRFILE_ARCH | ERRFILE_NET | 0x00010000 )
diff --git a/src/arch/x86/include/multiboot2.h b/src/arch/x86/include/multiboot2.h
new file mode 100644
index 00000000..2c93a2a6
--- /dev/null
+++ b/src/arch/x86/include/multiboot2.h
@@ -0,0 +1,417 @@
+/*  multiboot2.h - Multiboot 2 header file.  */
+/*  Copyright (C) 1999,2003,2007,2008,2009,2010  Free Software Foundation, Inc.
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy
+ *  of this software and associated documentation files (the "Software"), to
+ *  deal in the Software without restriction, including without limitation the
+ *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ *  sell copies of the Software, and to permit persons to whom the Software is
+ *  furnished to do so, subject to the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be included in
+ *  all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL ANY
+ *  DEVELOPER OR DISTRIBUTOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+ *  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef MULTIBOOT_HEADER
+#define MULTIBOOT_HEADER 1
+
+/* How many bytes from the start of the file we search for the header.  */
+#define MULTIBOOT_SEARCH			32768
+#define MULTIBOOT_HEADER_ALIGN			8
+
+/* The magic field should contain this.  */
+#define MULTIBOOT2_HEADER_MAGIC			0xe85250d6
+
+/* This should be in %eax.  */
+#define MULTIBOOT2_BOOTLOADER_MAGIC		0x36d76289
+
+/* Alignment of multiboot modules.  */
+#define MULTIBOOT_MOD_ALIGN			0x00001000
+
+/* Alignment of the multiboot info structure.  */
+#define MULTIBOOT_INFO_ALIGN			0x00000008
+
+/* Flags set in the 'flags' member of the multiboot header.  */
+
+#define MULTIBOOT_TAG_ALIGN                  8
+#define MULTIBOOT_TAG_TYPE_END               0
+#define MULTIBOOT_TAG_TYPE_CMDLINE           1
+#define MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME  2
+#define MULTIBOOT_TAG_TYPE_MODULE            3
+#define MULTIBOOT_TAG_TYPE_BASIC_MEMINFO     4
+#define MULTIBOOT_TAG_TYPE_BOOTDEV           5
+#define MULTIBOOT_TAG_TYPE_MMAP              6
+#define MULTIBOOT_TAG_TYPE_VBE               7
+#define MULTIBOOT_TAG_TYPE_FRAMEBUFFER       8
+#define MULTIBOOT_TAG_TYPE_ELF_SECTIONS      9
+#define MULTIBOOT_TAG_TYPE_APM               10
+#define MULTIBOOT_TAG_TYPE_EFI32             11
+#define MULTIBOOT_TAG_TYPE_EFI64             12
+#define MULTIBOOT_TAG_TYPE_SMBIOS            13
+#define MULTIBOOT_TAG_TYPE_ACPI_OLD          14
+#define MULTIBOOT_TAG_TYPE_ACPI_NEW          15
+#define MULTIBOOT_TAG_TYPE_NETWORK           16
+#define MULTIBOOT_TAG_TYPE_EFI_MMAP          17
+#define MULTIBOOT_TAG_TYPE_EFI_BS            18
+#define MULTIBOOT_TAG_TYPE_EFI32_IH          19
+#define MULTIBOOT_TAG_TYPE_EFI64_IH          20
+#define MULTIBOOT_TAG_TYPE_LOAD_BASE_ADDR    21
+
+#define MULTIBOOT_HEADER_TAG_END  0
+#define MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST  1
+#define MULTIBOOT_HEADER_TAG_ADDRESS  2
+#define MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS  3
+#define MULTIBOOT_HEADER_TAG_CONSOLE_FLAGS  4
+#define MULTIBOOT_HEADER_TAG_FRAMEBUFFER  5
+#define MULTIBOOT_HEADER_TAG_MODULE_ALIGN  6
+#define MULTIBOOT_HEADER_TAG_EFI_BS        7
+#define MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS_EFI32  8
+#define MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS_EFI64  9
+#define MULTIBOOT_HEADER_TAG_RELOCATABLE  10
+
+#define MULTIBOOT_ARCHITECTURE_I386  0
+#define MULTIBOOT_ARCHITECTURE_MIPS32  4
+#define MULTIBOOT_HEADER_TAG_OPTIONAL 1
+
+#define MULTIBOOT_LOAD_PREFERENCE_NONE 0
+#define MULTIBOOT_LOAD_PREFERENCE_LOW 1
+#define MULTIBOOT_LOAD_PREFERENCE_HIGH 2
+
+#define MULTIBOOT_CONSOLE_FLAGS_CONSOLE_REQUIRED 1
+#define MULTIBOOT_CONSOLE_FLAGS_EGA_TEXT_SUPPORTED 2
+
+#ifndef ASM_FILE
+
+typedef unsigned char		multiboot_uint8_t;
+typedef unsigned short		multiboot_uint16_t;
+typedef unsigned int		multiboot_uint32_t;
+typedef unsigned long long	multiboot_uint64_t;
+
+struct multiboot_header
+{
+  /* Must be MULTIBOOT_MAGIC - see above.  */
+  multiboot_uint32_t magic;
+
+  /* ISA */
+  multiboot_uint32_t architecture;
+
+  /* Total header length.  */
+  multiboot_uint32_t header_length;
+
+  /* The above fields plus this one must equal 0 mod 2^32. */
+  multiboot_uint32_t checksum;
+};
+
+struct multiboot_header_tag
+{
+  multiboot_uint16_t type;
+  multiboot_uint16_t flags;
+  multiboot_uint32_t size;
+};
+
+struct multiboot_header_tag_information_request
+{
+  multiboot_uint16_t type;
+  multiboot_uint16_t flags;
+  multiboot_uint32_t size;
+  multiboot_uint32_t requests[0];
+};
+
+struct multiboot_header_tag_address
+{
+  multiboot_uint16_t type;
+  multiboot_uint16_t flags;
+  multiboot_uint32_t size;
+  multiboot_uint32_t header_addr;
+  multiboot_uint32_t load_addr;
+  multiboot_uint32_t load_end_addr;
+  multiboot_uint32_t bss_end_addr;
+};
+
+struct multiboot_header_tag_entry_address
+{
+  multiboot_uint16_t type;
+  multiboot_uint16_t flags;
+  multiboot_uint32_t size;
+  multiboot_uint32_t entry_addr;
+};
+
+struct multiboot_header_tag_console_flags
+{
+  multiboot_uint16_t type;
+  multiboot_uint16_t flags;
+  multiboot_uint32_t size;
+  multiboot_uint32_t console_flags;
+};
+
+struct multiboot_header_tag_framebuffer
+{
+  multiboot_uint16_t type;
+  multiboot_uint16_t flags;
+  multiboot_uint32_t size;
+  multiboot_uint32_t width;
+  multiboot_uint32_t height;
+  multiboot_uint32_t depth;
+};
+
+struct multiboot_header_tag_module_align
+{
+  multiboot_uint16_t type;
+  multiboot_uint16_t flags;
+  multiboot_uint32_t size;
+};
+
+struct multiboot_header_tag_relocatable
+{
+  multiboot_uint16_t type;
+  multiboot_uint16_t flags;
+  multiboot_uint32_t size;
+  multiboot_uint32_t min_addr;
+  multiboot_uint32_t max_addr;
+  multiboot_uint32_t align;
+  multiboot_uint32_t preference;
+};
+
+struct multiboot_color
+{
+  multiboot_uint8_t red;
+  multiboot_uint8_t green;
+  multiboot_uint8_t blue;
+};
+
+struct multiboot_mmap_entry
+{
+  multiboot_uint64_t addr;
+  multiboot_uint64_t len;
+#define MULTIBOOT_MEMORY_AVAILABLE		1
+#define MULTIBOOT_MEMORY_RESERVED		2
+#define MULTIBOOT_MEMORY_ACPI_RECLAIMABLE       3
+#define MULTIBOOT_MEMORY_NVS                    4
+#define MULTIBOOT_MEMORY_BADRAM                 5
+  multiboot_uint32_t type;
+  multiboot_uint32_t zero;
+};
+typedef struct multiboot_mmap_entry multiboot_memory_map_t;
+
+struct multiboot_tag
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+};
+
+struct multiboot_tag_string
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  char string[0];
+};
+
+struct multiboot_tag_module
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint32_t mod_start;
+  multiboot_uint32_t mod_end;
+  char cmdline[0];
+};
+
+struct multiboot_tag_basic_meminfo
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint32_t mem_lower;
+  multiboot_uint32_t mem_upper;
+};
+
+struct multiboot_tag_bootdev
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint32_t biosdev;
+  multiboot_uint32_t slice;
+  multiboot_uint32_t part;
+};
+
+struct multiboot_tag_mmap
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint32_t entry_size;
+  multiboot_uint32_t entry_version;
+  struct multiboot_mmap_entry entries[0];
+};
+
+struct multiboot_vbe_info_block
+{
+  multiboot_uint8_t external_specification[512];
+};
+
+struct multiboot_vbe_mode_info_block
+{
+  multiboot_uint8_t external_specification[256];
+};
+
+struct multiboot_tag_vbe
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+
+  multiboot_uint16_t vbe_mode;
+  multiboot_uint16_t vbe_interface_seg;
+  multiboot_uint16_t vbe_interface_off;
+  multiboot_uint16_t vbe_interface_len;
+
+  struct multiboot_vbe_info_block vbe_control_info;
+  struct multiboot_vbe_mode_info_block vbe_mode_info;
+};
+
+struct multiboot_tag_framebuffer_common
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+
+  multiboot_uint64_t framebuffer_addr;
+  multiboot_uint32_t framebuffer_pitch;
+  multiboot_uint32_t framebuffer_width;
+  multiboot_uint32_t framebuffer_height;
+  multiboot_uint8_t framebuffer_bpp;
+#define MULTIBOOT_FRAMEBUFFER_TYPE_INDEXED 0
+#define MULTIBOOT_FRAMEBUFFER_TYPE_RGB     1
+#define MULTIBOOT_FRAMEBUFFER_TYPE_EGA_TEXT	2
+  multiboot_uint8_t framebuffer_type;
+  multiboot_uint16_t reserved;
+};
+
+struct multiboot_tag_framebuffer
+{
+  struct multiboot_tag_framebuffer_common common;
+
+  union
+  {
+    struct
+    {
+      multiboot_uint16_t framebuffer_palette_num_colors;
+      struct multiboot_color framebuffer_palette[0];
+    };
+    struct
+    {
+      multiboot_uint8_t framebuffer_red_field_position;
+      multiboot_uint8_t framebuffer_red_mask_size;
+      multiboot_uint8_t framebuffer_green_field_position;
+      multiboot_uint8_t framebuffer_green_mask_size;
+      multiboot_uint8_t framebuffer_blue_field_position;
+      multiboot_uint8_t framebuffer_blue_mask_size;
+    };
+  };
+};
+
+struct multiboot_tag_elf_sections
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint32_t num;
+  multiboot_uint32_t entsize;
+  multiboot_uint32_t shndx;
+  char sections[0];
+};
+
+struct multiboot_tag_apm
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint16_t version;
+  multiboot_uint16_t cseg;
+  multiboot_uint32_t offset;
+  multiboot_uint16_t cseg_16;
+  multiboot_uint16_t dseg;
+  multiboot_uint16_t flags;
+  multiboot_uint16_t cseg_len;
+  multiboot_uint16_t cseg_16_len;
+  multiboot_uint16_t dseg_len;
+};
+
+struct multiboot_tag_efi32
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint32_t pointer;
+};
+
+struct multiboot_tag_efi64
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint64_t pointer;
+};
+
+struct multiboot_tag_smbios
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint8_t major;
+  multiboot_uint8_t minor;
+  multiboot_uint8_t reserved[6];
+  multiboot_uint8_t tables[0];
+};
+
+struct multiboot_tag_old_acpi
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint8_t rsdp[0];
+};
+
+struct multiboot_tag_new_acpi
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint8_t rsdp[0];
+};
+
+struct multiboot_tag_network
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint8_t dhcpack[0];
+};
+
+struct multiboot_tag_efi_mmap
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint32_t descr_size;
+  multiboot_uint32_t descr_vers;
+  multiboot_uint8_t efi_mmap[0];
+};
+
+struct multiboot_tag_efi32_ih
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint32_t pointer;
+};
+
+struct multiboot_tag_efi64_ih
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint64_t pointer;
+};
+
+struct multiboot_tag_load_base_addr
+{
+  multiboot_uint32_t type;
+  multiboot_uint32_t size;
+  multiboot_uint32_t load_base_addr;
+};
+
+#endif /* ! ASM_FILE */
+
+#endif /* ! MULTIBOOT_HEADER */
diff --git a/src/arch/x86_64/Makefile b/src/arch/x86_64/Makefile
index b3064b75..6ada01ee 100644
--- a/src/arch/x86_64/Makefile
+++ b/src/arch/x86_64/Makefile
@@ -11,7 +11,7 @@ CFLAGS		+= -falign-jumps=1 -falign-loops=1 -falign-functions=1
 #
 CFLAGS		+= -m64
 ASFLAGS		+= --64
-LDFLAGS		+= -m elf_x86_64
+LDFLAGS		+= -m elf_x86_64_sol2
 
 # Prevent use of MMX and SSE registers
 #
diff --git a/src/bin/.gitignore b/src/bin/.gitignore
deleted file mode 100644
index 72e8ffc0..00000000
--- a/src/bin/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-*
diff --git a/src/config/config.c b/src/config/config.c
index 2ca05dff..3c80363f 100644
--- a/src/config/config.c
+++ b/src/config/config.c
@@ -156,6 +156,9 @@ REQUIRE_OBJECT ( elfboot );
 #ifdef IMAGE_MULTIBOOT
 REQUIRE_OBJECT ( multiboot );
 #endif
+#ifdef IMAGE_MULTIBOOT2
+REQUIRE_OBJECT ( multiboot2 );
+#endif
 #ifdef IMAGE_PXE
 REQUIRE_OBJECT ( pxe_image );
 #endif
diff --git a/src/config/defaults/efi.h b/src/config/defaults/efi.h
index 74effa42..aa674c53 100644
--- a/src/config/defaults/efi.h
+++ b/src/config/defaults/efi.h
@@ -28,6 +28,10 @@ FILE_LICENCE ( GPL2_OR_LATER_OR_UBDL );
 #define	IMAGE_EFI		/* EFI image support */
 #define	IMAGE_SCRIPT		/* iPXE script image support */
 
+#if defined ( __x86_64__ )
+#define	IMAGE_MULTIBOOT2		/* Multiboot2 image support */
+#endif
+
 #define	SANBOOT_PROTO_ISCSI	/* iSCSI protocol */
 #define	SANBOOT_PROTO_AOE	/* AoE protocol */
 #define	SANBOOT_PROTO_IB_SRP	/* Infiniband SCSI RDMA protocol */
diff --git a/src/config/local/general.h b/src/config/local/general.h
index e7a5f76c..4d7c5d50 100644
--- a/src/config/local/general.h
+++ b/src/config/local/general.h
@@ -5,10 +5,12 @@
 #undef	SANBOOT_PROTO_IB_SRP
 #undef	SANBOOT_PROTO_FCP
 
-#undef	IMAGE_BZIMAGE
+#define PING_CMD
 
 #define	VLAN_CMD
+#ifndef PXE_EFI
 #define	PXE_CMD
+#endif
 
 #undef	BANNER_TIMEOUT
 #define	BANNER_TIMEOUT	50
diff --git a/src/config/local/settings.h b/src/config/local/settings.h
index 66779aca..d3f308fd 100644
--- a/src/config/local/settings.h
+++ b/src/config/local/settings.h
@@ -1,3 +1,5 @@
 #define	PCI_SETTINGS
 #define	CPUID_SETTINGS
-#define	MEMMAP_SETTINGS
+#ifndef PXE_EFI
+	#define MEMMAP_SETTINGS
+#endif
diff --git a/src/include/ipxe/features.h b/src/include/ipxe/features.h
index e86a2d22..985c4146 100644
--- a/src/include/ipxe/features.h
+++ b/src/include/ipxe/features.h
@@ -55,6 +55,7 @@ FILE_LICENCE ( GPL2_OR_LATER_OR_UBDL );
 #define DHCP_EB_FEATURE_MENU		0x27 /**< Menu support */
 #define DHCP_EB_FEATURE_SDI		0x28 /**< SDI image support */
 #define DHCP_EB_FEATURE_NFS		0x29 /**< NFS protocol */
+#define DHCP_EB_FEATURE_MULTIBOOT2	0x2a /**< Multiboot2 format */
 
 /** @} */
 
diff --git a/src/include/ipxe/image.h b/src/include/ipxe/image.h
index 2e7eb4ce..f0bc8c50 100644
--- a/src/include/ipxe/image.h
+++ b/src/include/ipxe/image.h
@@ -115,18 +115,27 @@ struct image_type {
 			 struct asn1_cursor **cursor );
 };
 
+/**
+ * Multiboot2 image probe priority
+ *
+ * Multiboot2 images are also valid executables in another format
+ * (e.g. ELF) AND might also have multiboot headers on them, so we
+ * must perform the multiboot2 probe first.
+ */
+#define PROBE_MULTIBOOT2 01
+
 /**
  * Multiboot image probe priority
  *
  * Multiboot images are also valid executables in another format
  * (e.g. ELF), so we must perform the multiboot probe first.
  */
-#define PROBE_MULTIBOOT	01
+#define PROBE_MULTIBOOT	02
 
 /**
  * Normal image probe priority
  */
-#define PROBE_NORMAL 02
+#define PROBE_NORMAL 03
 
 /**
  * PXE image probe priority
@@ -134,7 +143,7 @@ struct image_type {
  * PXE images have no signature checks, so will claim all image files.
  * They must therefore be tried last in the probe order list.
  */
-#define PROBE_PXE 03
+#define PROBE_PXE 04
 
 /** Executable image type table */
 #define IMAGE_TYPES __table ( struct image_type, "image_types" )
diff --git a/src/util/elf2efi.c b/src/util/elf2efi.c
index 2c5b9df8..ff947a39 100644
--- a/src/util/elf2efi.c
+++ b/src/util/elf2efi.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 Michael Brown <mbrown@fensystems.co.uk>.
+ * Copyright (c) 2019, Joyent, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -18,6 +19,7 @@
  */
 
 #define FILE_LICENCE(...) extern void __file_licence ( void )
+#define	ELF_TARGET_ALL
 #include <stdint.h>
 #include <stddef.h>
 #include <stdlib.h>
@@ -97,6 +99,31 @@
 #define R_ARM_V4BX 40
 #endif
 
+/*
+ * illumos currently defines EM_AARCH64 in sys/elf.h, but does not define any
+ * of the other ARM64 relocations.  Ideally illumos should deliver
+ * sys/aarch64.h and that may happen in the future if ARM64 porting efforts
+ * move forward.
+ */
+#if defined(sun) && !defined(_SYS_ELF_AARCH64_H)
+#define	R_ARM_NONE                      0
+#define	R_ARM_ABS32                     2
+#define	R_ARM_REL32                     3
+#define	R_ARM_THM_PC22                  10
+
+#define	R_AARCH64_NONE                  0
+#define	R_AARCH64_ABS64                 257
+#define	R_AARCH64_CALL26                283
+#define	R_AARCH64_JUMP26                282
+#define	R_AARCH64_ADR_PREL_LO21         274
+#define	R_AARCH64_ADR_PREL_PG_HI21      275
+#define	R_AARCH64_ADD_ABS_LO12_NC       277
+#define	R_AARCH64_LDST8_ABS_LO12_NC     278
+#define	R_AARCH64_LDST16_ABS_LO12_NC    284
+#define	R_AARCH64_LDST32_ABS_LO12_NC    285
+#define	R_AARCH64_LDST64_ABS_LO12_NC    286
+#endif
+
 /* Seems to be missing from elf.h */
 #ifndef R_AARCH64_NULL
 #define R_AARCH64_NULL 256
@@ -621,6 +648,8 @@ static void process_reloc ( struct elf_file *elf, const Elf_Shdr *shdr,
 			break;
 		case ELF_MREL ( EM_386, R_386_32 ) :
 		case ELF_MREL ( EM_ARM, R_ARM_ABS32 ) :
+		case ELF_MREL ( EM_X86_64, R_X86_64_32 ) :
+		case ELF_MREL ( EM_X86_64, R_X86_64_32S ) :
 			/* Generate a 4-byte PE relocation */
 			generate_pe_reloc ( pe_reltab, offset, 4 );
 			break;
-- 
2.21.0

