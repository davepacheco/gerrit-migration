From e2588b1eb9687a03f0c7deef8525b5e59c985a50 Mon Sep 17 00:00:00 2001
From: Marsell Kukuljevic <marsell@joyent.com>
Date: Sat, 1 Dec 2018 07:03:57 +1030
Subject: [PATCH] TRITON-962 Add `CreateDisk`, `ResizeDisk` and `DeleteDisk`
 end-points to VMAPI

---
 docs/index.md            |  90 ++++++++-
 lib/common/validation.js |  36 ++++
 lib/endpoints/vms.js     | 235 ++++++++++++++++++++++-
 lib/errors.js            |  79 +++++++-
 test/vms.disks.test.js   | 405 +++++++++++++++++++++++++++++++++++++++
 5 files changed, 840 insertions(+), 5 deletions(-)
 create mode 100644 test/vms.disks.test.js

diff --git a/docs/index.md b/docs/index.md
index 8166d4c..52c60d3 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -36,7 +36,7 @@ call, while some of them can only be set at VM creation time. In the next table,
 the column "VM Response Default" refers to attributes that are always going to
 be part of the VM response object. Those with a column value of 'No' are only
 going to be returned when set via CreateVm or UpdateVm. Finally, the last two
-columns specify wether or not some VM attributes can be set at creation or
+columns specify whether or not some VM attributes can be set at creation or
 update time.
 
 | Param                    | Type                          | Description                                                                                                                                                                                                               | Vm Response Default | Create | Update |
@@ -52,7 +52,13 @@ update time.
 | destroyed                | Date                          | The time at which the VM was destroyed in ISO 8601 format                                                                                                                                                                 | Yes                 | No     | No     |
 | datasets                 | Array                         | VM datasets                                                                                                                                                                                                               | Yes                 | No     | No     |
 | delegate_dataset         | Boolean                       | Delegate a data dataset to the VM                                                                                                                                                                                         | No                  | Yes    | No     |
-| dns_domain               | String                        | Search domain value for /etc/resolv.conf (max length 255 chars)                                                                                                                                                   | No                  | Yes    | No     |
+| disks                    | Array                         | Array of virtual disks (zvols) that are used by a bhyve VM.                                                                                                                                                               | No                  | No     | No     |
+| disks.*.path             | String                        | File path in GZ.                                                                                                                                                                                                          | No                  | No     | No     |
+| disks.*.size             | Number (MiB)                  | Size of disk.                                                                                                                                                                                                             | No                  | No     | No     |
+| disks.*.pci_slot         | String                        | Specifies the virtual PCI slot a disk occupies.                                                                                                                                                                           | No                  | No     | No     |
+| disks.*.boot             | Boolean                       | If this is a VM's boot disk.                                                                                                                                                                                              | No                  | No     | No     |
+| flexible_disk_size       | Number (MiB)                  | Maximum amount of space that can be used by the sum of all disks.                                                                                                                                                         | No                  | Yes    | No     |
+| dns_domain               | String                        | Search domain value for /etc/resolv.conf (max length 255 chars)                                                                                                                                                           | No                  | Yes    | No     |
 | do_not_inventory         | Boolean                       | The primary use-case of this attribute is for test VMs that are created but you don't want their existence propagated up to VMAPI since they'll be short-lived and its lifecycle will be physically managed in the server | No                  | Yes    | Yes    |
 | firewall_enabled         | Boolean                       | Enable firewall for the VM                                                                                                                                                                                                | Yes                 | Yes    | Yes    |
 | flexible_disk_size       | Number (MiB)                  | The amount of space a bhyve instance may use for its disks and snapshots of those disks | No                 | Yes    | Yes    |
@@ -317,6 +323,29 @@ a VM with a delegate dataset:
       "delegate_dataset": true
     }'
 
+## Disk PCI Slot
+
+Disk can only be added and removed from bhyve instances, and only if
+`flexible_disk_size` is set on those instances.
+
+Bhyve places each disk into a PCI slot that is identified by the PCI bus,
+device, and function. The slot is specified as <bus>:<device>:<function>
+(e.g. "0:4:0"). If a PCI slot is not given to a disk being created, one will be
+assigned.
+
+Per the PCI specification legal values for bus, device and function are:
+
+    bus: 0 - 255, inclusive
+    device: 0 - 31, inclusive
+    function: 0 - 7, inclusive
+
+All functions on devices 0, 6, 30, and 31 on bus 0 are reserved.  If any
+function other than zero (e.g. 0:4:1) is used, function zero on the same device
+(e.g. 0:4:0) must also be used for the guest OS to recognize the disk in the
+non-zero slot.
+
+See the SmartOS `vmadm(1M)` man page for more details about pci_slot.
+
 ## Firewall
 
 If the `firewall_enabled` property is set when creating or updating a VM,
@@ -1429,6 +1458,63 @@ For removing NICs from a VM, a macs list parameter must be specified. This param
       -d macs=90:b8:d0:d9:f0:83 \
 
 
+## CreateDisk (POST /vms/:uuid?action=create_disk)
+
+Create a virtual disk and attach it to a bhyve VM. VM must be currently stopped,
+and have flexible_disk_size set.
+
+| Param    | Type         | Description                                                                                                         |
+| -------- | ------------ | ------------------------------------------------------------------------------------------------------------------- |
+| pci_slot | String       | Optional. Free PCI slot of disk to create. This is typically in the 0:4:[0-7] and 0:5:[0-7] range.                  |
+| size     | Number (MiB) | Size of new virtual disk. Can also use string "remaining" to use up all remaining free space in flexible_disk_size. |
+
+If `pci_slot` is not provided when creating the disk, a slot will be
+automatically assigned. See [Disk PCI Slot](#disk-pci-slot) for more
+information about proper assignment of PCI slots.
+
+### Example of creating a new 5GiB virtual disk using a JSON payload
+
+    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=create_disk -d '{
+        "pci_slot": "0:4:3",
+        "size": 5120
+    }'
+
+
+## ResizeDisk (POST /vms/:uuid?action=resize_disk)
+
+Resizes one of the virtual disks on a bhyve VM. VM must be currently stopped,
+and have flexible_disk_size set.
+
+| Param                  | Type         | Description                             |
+| ---------------------- | ------------ | --------------------------------------- |
+| pci_slot               | String       | PCI slot of disk to resize              |
+| size                   | Number (MiB) | Size to change the virtual disk to      |
+| dangerous_allow_shrink | Boolean      | Since resizing down potentially causes data loss due to internal filesystem truncation, this must be set when shrinking a disk. |
+
+### Example: resizing virtual disk "disk1" up to 10GiB using a JSON payload
+
+    POST /vms/0cb0f7b1-b092-4252-b205-c9c268bfa148?action=resize_disk -d '{
+      "slot": "0:4:1",
+      "size": 10240
+    }'
+
+
+## DeleteDisk (POST /vms/:uuid?action=delete_disk)
+
+Removes and deletes a virtual disk from a bhyve VM. VM must currently be
+stopped, and have flexible_disk_size set.
+
+| Param    | Type   | Description                                   |
+| -------- | ------ | --------------------------------------------- |
+| pci_slot | String | PCI slot of disk to delete                    |
+
+### Example with a JSON payload
+
+    POST /vms/e9bd0ed1-7de3-4c66-a649-d675dbce6e83?action=delete_disk -d '{
+      "pci_slot": "0:4:6"
+    }'
+
+
 ## CreateSnapshot (POST /vms/:uuid?action=create_snapshot)
 
 If a name for the snapshot is not specified, VMAPI will generate a timestamp for its name with the UTC ISO date/time format (without colons or dashes):
diff --git a/lib/common/validation.js b/lib/common/validation.js
index b18d187..608edc5 100644
--- a/lib/common/validation.js
+++ b/lib/common/validation.js
@@ -44,6 +44,8 @@ var DNS_NAME_RE = /^[a-z0-9][a-z0-9\-]{0,62}(?:\.[a-z0-9][a-z0-9\-]{0,62})*$/i;
 /*JSSTYLED*/
 var IP_RE = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
 var MAX_LIST_VMS_LIMIT = 1000;
+var PCI_SLOT_RE = /^[0-9]{1,3}\:[0-9]{1,2}\:[0-7]$/;
+var PCI_SLOT_DEV_RESERVED = [0, 6, 30, 31];
 var PW_SUFFIX = /^(.*)_pw$/;
 var RAM_RE = /^0$|^([1-9][0-9]*$)/;
 var TRITON_TAG_ROOT_RE = /^triton\./;
@@ -2419,6 +2421,40 @@ exports.validateMacs = function (params) {
 
 
 
+/*
+ * Simple validation; ensures that pci_slot has the right format and isn't
+ * using any reserved device IDs.
+ */
+exports.validatePciSlot = function validatePciSlot(params) {
+    var slot = params.pci_slot;
+
+    function throwErr(err) {
+        throw new errors.ValidationFailedError('Invalid VM update parameters',
+            [err]);
+    }
+
+    if (!slot) {
+        throwErr(errors.missingParamErr('pci_slot'));
+    } else if (!PCI_SLOT_RE.test(slot)) {
+        throwErr(errors.invalidParamErr('pci_slot', 'Not a valid value'));
+    }
+
+    var parts = slot.split(':');
+    var bus  = +parts[0];
+    var dev  = +parts[1];
+    var func = +parts[2];
+
+    if (bus < 0 || bus > 255 || dev < 0 || dev > 31 || func < 0 || func > 7) {
+        throwErr(errors.invalidParamErr('pci_slot', 'Not a valid value'));
+    } else if (PCI_SLOT_DEV_RESERVED.indexOf(dev) !== -1) {
+        throwErr(errors.invalidParamErr('pci_slot', 'Reserved device ID'));
+    }
+
+    return true;
+};
+
+
+
 /*
  * Sets default attributes for a vm on things that depend on
  * RAM or disk for example
diff --git a/lib/endpoints/vms.js b/lib/endpoints/vms.js
index 1fdc466..fa08e60 100644
--- a/lib/endpoints/vms.js
+++ b/lib/endpoints/vms.js
@@ -39,7 +39,10 @@ var VALID_VM_ACTIONS = [
     'remove_nics',
     'create_snapshot',
     'rollback_snapshot',
-    'delete_snapshot'
+    'delete_snapshot',
+    'create_disk',
+    'resize_disk',
+    'delete_disk'
 ];
 
 
@@ -493,6 +496,15 @@ function updateVm(req, res, next) {
         case 'delete_snapshot':
             method = deleteSnapshot;
             break;
+        case 'create_disk':
+            method = createDisk;
+            break;
+        case 'resize_disk':
+            method = resizeDisk;
+            break;
+        case 'delete_disk':
+            method = deleteDisk;
+            break;
         default:
             error = [ errors.invalidParamErr('action') ];
             return next(new errors.ValidationFailedError('Invalid Parameters',
@@ -829,6 +841,227 @@ function removeNics(req, res, next) {
 }
 
 
+
+/*
+ * Add disk to a VM
+ */
+function createDisk(req, res, next) {
+    var params = req.params;
+    var slot = params.pci_slot;
+    var size = params.size;
+    var vm = req.vm;
+    var paramErr;
+
+    req.log.trace({ vm_uuid: vm.uuid }, 'CreateDisk start');
+
+    if (params.pci_slot !== undefined) {
+        try {
+            common.validatePciSlot(params);
+        } catch (e) {
+            next(e);
+            return;
+        }
+
+        var found = vm.disks.filter(function matchSlot(disk) {
+            return disk.pci_slot === slot;
+        })[0];
+
+        if (found) {
+            paramErr = [ errors.invalidParamErr('pci_slot', 'Already in use') ];
+            next(new errors.ValidationFailedError('Invalid Parameters',
+                 paramErr));
+            return;
+        }
+    }
+
+    if (isNaN(size) && size !== 'remaining') {
+        paramErr = [ errors.invalidParamErr('size', 'Not a valid value') ];
+        next(new errors.ValidationFailedError('Invalid Parameters', paramErr));
+        return;
+    } else if (vm.brand !== 'bhyve') {
+        next(new errors.BrandNotSupportedError('Can only create disks on ' +
+            'bhyve VMs'));
+        return;
+    } else if (!vm.flexible_disk_size) {
+        next(new errors.VmWithoutFlexibleDiskSizeError());
+        return;
+    } else if (vm.state !== 'stopped') {
+        next(new errors.VmNotStoppedError());
+        return;
+    }
+
+    var currentAggrSize = vm.disks.reduce(function addSize(acc, disk) {
+        return acc + disk.size;
+    }, 0);
+
+    if (size !== 'remaining' &&
+               currentAggrSize + size > vm.flexible_disk_size) {
+        next(new errors.InsufficientDiskSpaceError());
+        return;
+    }
+
+    var args = {
+        subtask: 'create_disk',
+        add_disks: [ {
+            pci_slot: slot,
+            size: size,
+            model: 'virtio'
+        } ]
+    };
+
+    req.app.wfapi.createUpdateJob(req, args, function onDiskJob(err, juuid) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        handleUpdateVMResponse(req, res, next, juuid);
+    });
+}
+
+
+
+/*
+ * Resize a VM's disk
+ */
+function resizeDisk(req, res, next) {
+    var params = req.params;
+    var size = +params.size;
+    var slot = params.pci_slot;
+    var shrink = params.dangerous_allow_shrink;
+    var vm = req.vm;
+    var paramErr;
+
+    req.log.trace({ vm_uuid: vm.uuid }, 'ResizeDisk start');
+
+    try {
+        common.validatePciSlot(params);
+    } catch (e) {
+        next(e);
+        return;
+    }
+
+    var found = vm.disks.filter(function matchSlot(disk) {
+        return disk.pci_slot === slot;
+    })[0];
+
+    if (!found) {
+        next(new restify.ResourceNotFoundError('Disk not found'));
+        return;
+    } else if (isNaN(size)) {
+        paramErr = [ errors.invalidParamErr('size', 'Not a valid number') ];
+        next(new errors.ValidationFailedError('Invalid Parameters', paramErr));
+        return;
+    } else if (shrink !== undefined && typeof (shrink) !== 'boolean') {
+        paramErr = [ errors.invalidParamErr('dangerous_allow_shrink', 'Not a ' +
+                     'boolean') ];
+        next(new errors.ValidationFailedError('Invalid Parameters', paramErr));
+        return;
+    } else if (vm.brand !== 'bhyve') {
+        next(new errors.BrandNotSupportedError('Can only resize disks on ' +
+             'bhyve VMs'));
+        return;
+    } else if (!vm.flexible_disk_size) {
+        next(new errors.VmWithoutFlexibleDiskSizeError());
+        return;
+    } else if (vm.state !== 'stopped') {
+        next(new errors.VmNotStoppedError());
+        return;
+    } else if (found.size > size && !shrink) {
+        paramErr = [ errors.invalidParamErr('size', 'Reducing disk size is a ' +
+                     'dangerous operation') ];
+        next(new errors.ValidationFailedError('Invalid Parameters', paramErr));
+        return;
+    }
+
+    var aggrSize = vm.disks.reduce(function addSize(acc, disk) {
+        return acc + disk.size;
+    }, 0);
+
+    if (aggrSize - found.size + size > vm.flexible_disk_size) {
+        next(new errors.InsufficientDiskSpaceError());
+        return;
+    }
+
+    var args = {
+        subtask: 'resize_disk',
+        update_disks: [ {
+            path: found.path,
+            size: size,
+            dangerous_allow_shrink: shrink || false
+        } ]
+    };
+
+    req.app.wfapi.createUpdateJob(req, args, function onDiskJob(err, juuid) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        handleUpdateVMResponse(req, res, next, juuid);
+    });
+}
+
+
+
+/*
+ * Removes a disk from a VM
+ */
+function deleteDisk(req, res, next) {
+    var params = req.params;
+    var slot = params.pci_slot;
+    var vm = req.vm;
+
+    req.log.trace({ vm_uuid: vm.uuid }, 'DeleteDisk start');
+
+    try {
+        common.validatePciSlot(params);
+    } catch (e) {
+        next(e);
+        return;
+    }
+
+    var found = vm.disks.filter(function matchSlot(disk) {
+        return disk.pci_slot === slot;
+    })[0];
+
+    if (!found) {
+        next(new restify.ResourceNotFoundError('Disk not found'));
+        return;
+    } else if (found.boot) {
+        var  paramErr = [ errors.invalidParamErr('slot', 'Cannot remove boot ' +
+                          'disk') ];
+        next(new errors.ValidationFailedError('Invalid Parameters', paramErr));
+        return;
+    } else if (vm.brand !== 'bhyve') {
+        next(new errors.BrandNotSupportedError('Can only delete disks on ' +
+            'bhyve VMs'));
+        return;
+    } else if (!vm.flexible_disk_size) {
+        next(new errors.VmWithoutFlexibleDiskSizeError());
+        return;
+    } else if (vm.state !== 'stopped') {
+        next(new errors.VmNotStoppedError());
+        return;
+    }
+
+    var args = {
+        subtask: 'delete_disk',
+        remove_disks: [found.path]
+    };
+
+    req.app.wfapi.createUpdateJob(req, args, function onDiskJob(err, juuid) {
+        if (err) {
+            next(err);
+            return;
+        }
+
+        handleUpdateVMResponse(req, res, next, juuid);
+    });
+}
+
+
+
 /*
  * Deletes a vm
  */
diff --git a/lib/errors.js b/lib/errors.js
index e038af7..2d9f107 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -53,7 +53,8 @@ function VmNotRunningError() {
         statusCode: this.constructor.statusCode,
         message: 'VM not running',
         body: {
-            code: this.constructor.restCode
+            code: this.constructor.restCode,
+            message: 'VM not running'
         }
     });
 }
@@ -65,6 +66,76 @@ VmNotRunningError.statusCode = 409;
 
 
 
+/*
+ *  Return this error when we try to do something that only makes sense on a
+ *  stopped container.
+ */
+function VmNotStoppedError() {
+    restify.RestError.call(this, {
+        restCode: this.constructor.restCode,
+        statusCode: this.constructor.statusCode,
+        message: 'VM not stopped',
+        body: {
+            code: this.constructor.restCode,
+            message: 'VM not stopped'
+        }
+    });
+}
+
+util.inherits(VmNotStoppedError, restify.ResourceNotFoundError);
+VmNotStoppedError.prototype.name = 'VmNotStoppedError';
+VmNotStoppedError.restCode = 'VmNotStopped';
+VmNotStoppedError.statusCode = 409;
+
+
+
+/*
+ *  Return this error when we try to do something that only makes sense on a
+ *  container with flexible disk sizing enabled.
+ */
+function VmWithoutFlexibleDiskSizeError() {
+    restify.RestError.call(this, {
+        restCode: this.constructor.restCode,
+        statusCode: this.constructor.statusCode,
+        message: 'VM does not have flexible disk sizing enabled',
+        body: {
+            code: this.constructor.restCode,
+            message: 'VM does not have flexible disk sizing enabled'
+        }
+    });
+}
+
+util.inherits(VmWithoutFlexibleDiskSizeError, restify.ResourceNotFoundError);
+VmWithoutFlexibleDiskSizeError.prototype.name =
+    'VmWithoutFlexibleDiskSizeError';
+VmWithoutFlexibleDiskSizeError.restCode = 'VmWithoutFlexibleDiskSize';
+VmWithoutFlexibleDiskSizeError.statusCode = 409;
+
+
+
+/*
+ *  Return this error when we try to do something that only makes sense on a
+ *  container with flexible disk sizing enabled.
+ */
+function InsufficientDiskSpaceError() {
+    restify.RestError.call(this, {
+        restCode: this.constructor.restCode,
+        statusCode: this.constructor.statusCode,
+        message: 'VM does not have sufficient free disk',
+        body: {
+            code: this.constructor.restCode,
+            message: 'VM does not have sufficient free disk'
+        }
+    });
+}
+
+util.inherits(InsufficientDiskSpaceError, restify.ResourceNotFoundError);
+InsufficientDiskSpaceError.prototype.name = 'InsufficientDiskSpaceError';
+InsufficientDiskSpaceError.restCode = 'InsufficientDiskSpace';
+InsufficientDiskSpaceError.statusCode = 409;
+
+
+
 /*
  * This error is produced when trying to call an action on a brand that doesn't
  * support it
@@ -230,6 +301,10 @@ exports.UnallocatedVMError = UnallocatedVMError;
 exports.ValidationFailedError = ValidationFailedError;
 exports.BrandNotSupportedError = BrandNotSupportedError;
 exports.VmNotRunningError = VmNotRunningError;
+exports.VmNotStoppedError = VmNotStoppedError;
+exports.VmWithoutFlexibleDiskSizeError = VmWithoutFlexibleDiskSizeError;
+exports.InsufficientDiskSpaceError = InsufficientDiskSpaceError;
+
 
 function MorayBucketsNotSetupError(lastInitError) {
     assert.optionalObject(lastInitError, 'lastInitError');
@@ -339,4 +414,4 @@ util.inherits(VolumesNotReachableError, restify.RestError);
 exports.VolumesNotReachableError = VolumesNotReachableError;
 VolumesNotReachableError.prototype.name = 'VolumesNotReachableError';
 VolumesNotReachableError.restCode = 'VolumesNotReachable';
-VolumesNotReachableError.statusCode = 409;
\ No newline at end of file
+VolumesNotReachableError.statusCode = 409;
diff --git a/test/vms.disks.test.js b/test/vms.disks.test.js
new file mode 100644
index 0000000..aa732f3
--- /dev/null
+++ b/test/vms.disks.test.js
@@ -0,0 +1,405 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var uuid = require('libuuid');
+
+var common = require('./common');
+var waitForValue = common.waitForValue;
+
+
+// --- Globals
+
+
+var CLIENT;
+var VM_UUID;
+var PCI_SLOTS = [];
+
+var CUSTOMER_UUID = common.config.ufdsAdminUuid;
+var VM_ALIAS_BASE = 'vmapitest-disk';
+var VM_OPTS = {
+    autoboot: false,
+    owner_uuid: CUSTOMER_UUID,
+    brand: 'bhyve',
+    billing_id: '00000000-0000-0000-0000-000000000000',
+    vcpus: 1,
+    cpu_cap: 100,
+    ram: 1024,
+    disks: [ { image_uuid: '81c0ef69-e9d7-4e93-a15b-efd7ea9c9ee8' } ],
+    networks: [],
+    creator_uuid: CUSTOMER_UUID
+};
+var CALLER = {
+    type: 'signature',
+    ip: '127.0.0.68',
+    keyId: '/foo@joyent.com/keys/id_rsa'
+};
+
+
+// --- Helpers
+
+
+function createOpts(path, params) {
+    return {
+        path: path,
+        headers: {
+            'x-request-id': uuid.create(),
+            'x-context': JSON.stringify({
+                caller: CALLER,
+                params: params || {}
+            })
+        }
+    };
+}
+
+
+function createVm(t, vmOpts) {
+    var opts = createOpts('/vms', vmOpts);
+
+    CLIENT.post(opts, vmOpts, function postCb(err, req, res, job) {
+        common.ifError(t, err, 'err');
+
+        assert.object(job, 'job');
+        assert.uuid(job.job_uuid, 'job.job_uuid');
+
+        VM_UUID = job.vm_uuid;
+        var path = '/jobs/' + job.job_uuid;
+
+        waitForValue(path, 'execution', 'succeeded', {
+            client: CLIENT
+        }, function waitForValueCb(err2) {
+            common.ifError(t, err2, 'err2');
+            t.done();
+        });
+    });
+}
+
+
+function deleteVm(t) {
+    CLIENT.del('/vms/' + VM_UUID, function delCb(err, req, res, job) {
+        common.ifError(t, err, 'err');
+        assert.object(job, 'job');
+        assert.uuid(job.job_uuid, 'job.job_uuid');
+
+        var path = '/jobs/' + job.job_uuid;
+        waitForValue(path, 'execution', 'succeeded', {
+            client: CLIENT
+        }, function waitForValueCb(err2) {
+            common.ifError(t, err2, 'err2');
+            t.done();
+        });
+    });
+}
+
+
+// --- Tests
+
+
+exports.setup = function setup(t) {
+    common.setUp(function setUpCb(err, _client) {
+        assert.ifError(err);
+        assert.ok(_client, 'restify client');
+        CLIENT = _client;
+
+        CLIENT.napi.get('/networks', function getCb(err2, req, res, networks) {
+            common.ifError(t, err2, 'err2');
+            var admin = common.extractAdminAndExternalNetwork(networks).admin;
+
+            VM_OPTS.networks.push({ uuid: admin.uuid });
+
+            t.done();
+        });
+    });
+};
+
+
+exports.initialize_non_flexible_disk_vm =
+function initialize_non_flexible_disk_vms(t) {
+    var opts = jsprim.deepCopy(VM_OPTS);
+    opts.alias = VM_ALIAS_BASE + '-' + process.pid;
+    createVm(t, opts);
+};
+
+
+exports.attempt_to_add_disk = function attempt_to_add_disk(t) {
+    var path = '/vms/' + VM_UUID + '?action=create_disk';
+    var opts = { size: 1536 };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, job) {
+        t.ok(err, 'err');
+        t.equal(err.name, 'VmWithoutFlexibleDiskSizeError');
+        t.done();
+    });
+};
+
+
+exports.destroy_non_flexible_disk_vm = deleteVm;
+
+
+exports.initialize_flexible_disk_vm = function initialize_flexible_disk_vm(t) {
+    var opts = jsprim.deepCopy(VM_OPTS);
+    opts.alias = VM_ALIAS_BASE + '-' + process.pid;
+    opts.flexible_disk_size = 11264;
+    createVm(t, opts);
+};
+
+
+exports.add_too_large_disk = function add_too_large_disk(t) {
+    var path = '/vms/' + VM_UUID + '?action=create_disk';
+    var opts = { size: 1536 };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, job) {
+        t.ok(err, 'err');
+        t.equal(err.name, 'InsufficientDiskSpaceError');
+        t.done();
+    });
+};
+
+
+exports.add_disk = function add_disk(t) {
+    var path = '/vms/' + VM_UUID + '?action=create_disk';
+    var opts = { size: 1024 };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, job) {
+        t.ok(!err, 'err');
+
+        assert.object(job, 'job');
+        assert.uuid(job.job_uuid, 'job.job_uuid');
+
+        var jobPath = '/jobs/' + job.job_uuid;
+        waitForValue(jobPath, 'execution', 'succeeded', {
+            client: CLIENT
+        }, function waitForValueCb(err2) {
+            common.ifError(t, err2, 'err2');
+            t.done();
+        });
+    });
+};
+
+
+exports.check_added_disk = function check_added_disk(t) {
+    var path = '/vms/' + VM_UUID;
+    CLIENT.get(path, function getCb(err, req, res, vm) {
+        common.ifError(t, err, 'err');
+
+        var disks = vm.disks;
+        t.equal(disks.length, 2);
+        t.equal(disks[0].pci_slot, '0:4:0', '[0].pci_slot');
+        t.equal(disks[0].size, 10240, '[0].size');
+        t.equal(disks[1].pci_slot, '0:4:1', '[1].pci_slot');
+        t.equal(disks[1].size, 1024, '[1].size');
+
+        PCI_SLOTS = disks.map(function (d) { return d.pci_slot; });
+
+        t.done();
+    });
+};
+
+
+exports.add_additional_too_much_disk = function add_too_much_disk(t) {
+    var path = '/vms/' + VM_UUID + '?action=create_disk';
+    var opts = { size: 128 };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, job) {
+        t.ok(err, 'err');
+        t.equal(err.name, 'InsufficientDiskSpaceError');
+        t.done();
+    });
+};
+
+
+exports.resize_disk_down_without_flag =
+function resize_disk_down_without_flag(t) {
+    var path = '/vms/' + VM_UUID + '?action=resize_disk';
+    var opts = {
+        pci_slot: PCI_SLOTS[1],
+        size: 512
+    };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, body) {
+        t.ok(err, 'err');
+        t.equal(err.name, 'ValidationFailedError');
+        t.equal(body.errors[0].message,
+            'Reducing disk size is a dangerous operation');
+        t.done();
+    });
+};
+
+
+exports.resize_disk_down_with_flag = function resize_disk_down_with_flag(t) {
+    var path = '/vms/' + VM_UUID + '?action=resize_disk';
+    var opts = {
+        pci_slot: PCI_SLOTS[1],
+        size: 512,
+        dangerous_allow_shrink: true
+    };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, job) {
+        t.ok(!err, 'err');
+
+        assert.object(job, 'job');
+        assert.uuid(job.job_uuid, 'job.job_uuid');
+
+        var jobPath = '/jobs/' + job.job_uuid;
+        waitForValue(jobPath, 'execution', 'succeeded', {
+            client: CLIENT
+        }, function waitForValueCb(err2) {
+            common.ifError(t, err2, 'err2');
+            t.done();
+        });
+    });
+};
+
+
+exports.check_resized_down_disk = function check_resized_down_disk(t) {
+    var path = '/vms/' + VM_UUID;
+    CLIENT.get(path, function getCb(err, req, res, vm) {
+        common.ifError(t, err, 'err');
+
+        var disks = vm.disks;
+        t.equal(disks[0].size, 10240, '[0].size');
+        t.equal(disks[1].size, 512, '[1].size');
+
+        t.done();
+    });
+};
+
+
+exports.resize_disk_up = function resize_disk_up(t) {
+    var path = '/vms/' + VM_UUID + '?action=resize_disk';
+    var opts = {
+        pci_slot: PCI_SLOTS[1],
+        size: 1024
+    };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, job) {
+        t.ok(!err, 'err');
+
+        assert.object(job, 'job');
+        assert.uuid(job.job_uuid, 'job.job_uuid');
+
+        var jobPath = '/jobs/' + job.job_uuid;
+        waitForValue(jobPath, 'execution', 'succeeded', {
+            client: CLIENT
+        }, function waitForValueCb(err2) {
+            common.ifError(t, err2, 'err2');
+            t.done();
+        });
+    });
+};
+
+
+exports.check_resized_up_disk = function check_resized_up_disk(t) {
+    var path = '/vms/' + VM_UUID;
+    CLIENT.get(path, function getCb(err, req, res, vm) {
+        common.ifError(t, err, 'err');
+
+        var disks = vm.disks;
+        t.equal(disks[0].size, 10240, '[0].size');
+        t.equal(disks[1].size, 1024, '[1].size');
+
+        t.done();
+    });
+};
+
+
+exports.resize_disk_up_too_far = function resize_disk_up_too_far(t) {
+    var path = '/vms/' + VM_UUID + '?action=resize_disk';
+    var opts = {
+        pci_slot: PCI_SLOTS[1],
+        size: 1536
+    };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, body) {
+        t.ok(err, 'err');
+        t.equal(err.name, 'InsufficientDiskSpaceError');
+        t.done();
+    });
+};
+
+
+exports.delete_disk = function delete_disk(t) {
+    var path = '/vms/' + VM_UUID + '?action=delete_disk';
+    var opts = { pci_slot: PCI_SLOTS[1] };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, job) {
+        t.ok(!err, 'err');
+
+        assert.object(job, 'job');
+        assert.uuid(job.job_uuid, 'job.job_uuid');
+
+        var jobPath = '/jobs/' + job.job_uuid;
+        waitForValue(jobPath, 'execution', 'succeeded', {
+            client: CLIENT
+        }, function waitForValueCb(err2) {
+            common.ifError(t, err2, 'err2');
+            t.done();
+        });
+    });
+};
+
+exports.check_deleted_disk = function check_deleted_disk(t) {
+    var path = '/vms/' + VM_UUID;
+    CLIENT.get(path, function getCb(err, req, res, vm) {
+        common.ifError(t, err, 'err');
+
+        var disks = vm.disks;
+        t.equal(disks.length, 1);
+        t.equal(disks[0].size, 10240, '[0].size');
+
+        t.done();
+    });
+};
+
+
+exports.add_disk_with_pci_slot = function add_disk_with_pci_slot(t) {
+    var path = '/vms/' + VM_UUID + '?action=create_disk';
+    var opts = {
+        pci_slot: '0:4:5',
+        size: 1024
+    };
+
+    CLIENT.post(path, opts, function postCb(err, req, res, job) {
+        t.ok(!err, 'err');
+
+        assert.object(job, 'job');
+        assert.uuid(job.job_uuid, 'job.job_uuid');
+
+        var jobPath = '/jobs/' + job.job_uuid;
+        waitForValue(jobPath, 'execution', 'succeeded', {
+            client: CLIENT
+        }, function waitForValueCb(err2) {
+            common.ifError(t, err2, 'err2');
+            t.done();
+        });
+    });
+};
+
+
+exports.check_added_disk_with_pci_slot =
+function check_added_disk_with_pci_slot(t) {
+    var path = '/vms/' + VM_UUID;
+    CLIENT.get(path, function getCb(err, req, res, vm) {
+        common.ifError(t, err, 'err');
+
+        var disks = vm.disks;
+        t.equal(disks.length, 2);
+        t.equal(disks[0].pci_slot, '0:4:0', '[0].pci_slot');
+        t.equal(disks[0].size, 10240, '[0].size');
+        t.equal(disks[1].pci_slot, '0:4:5', '[1].pci_slot');
+        t.equal(disks[1].size, 1024, '[1].size');
+
+        t.done();
+    });
+};
+
+
+exports.destroy_flexible_disk_vm = deleteVm;
-- 
2.21.0

