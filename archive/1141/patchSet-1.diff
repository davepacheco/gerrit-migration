From 3806781ca7d07d202c9aa3d76578ef18719c5f30 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Fri, 16 Dec 2016 16:41:30 -0800
Subject: [PATCH] joyent/node-cueball#62 returning to idle from error fails to
 emit connectedToBackend

---
 lib/pool.js       |  12 ++--
 test/pool.test.js | 136 ++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 142 insertions(+), 6 deletions(-)

diff --git a/lib/pool.js b/lib/pool.js
index 655e75d..1ec3503 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -598,14 +598,14 @@ CueBallConnectionPool.prototype.addConnection = function (key) {
 			 */
 			fsm.p_initq_node.remove();
 			delete (fsm.p_initq_node);
+		}
 
-			if (newState === 'idle') {
-				self.emit('connectedToBackend', key, fsm);
+		if (newState === 'idle') {
+			self.emit('connectedToBackend', key, fsm);
 
-				if (self.p_dead[key] !== undefined) {
-					delete (self.p_dead[key]);
-					self.rebalance();
-				}
+			if (self.p_dead[key] !== undefined) {
+				delete (self.p_dead[key]);
+				self.rebalance();
 			}
 		}
 
diff --git a/test/pool.test.js b/test/pool.test.js
index ce8f2c1..a461011 100644
--- a/test/pool.test.js
+++ b/test/pool.test.js
@@ -381,6 +381,142 @@ mod_tape.test('removing a backend', function (t) {
 	});
 });
 
+mod_tape.test('pool failure', function (t) {
+	connections = [];
+	resolver = undefined;
+
+	recovery.default.retries = 2;
+	var pool = new mod_pool.ConnectionPool({
+		log: log,
+		domain: 'foobar',
+		spares: 2,
+		maximum: 2,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery
+	});
+	t.ok(resolver);
+
+	pool.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			t.end();
+		}
+	});
+
+	resolver.emit('added', 'b1', {});
+	setImmediate(function () {
+		t.equal(connections.length, 2);
+		summarize();
+		t.deepEqual(counts, { 'b1': 2 });
+
+		index.b1[0].connect();
+		index.b1[0].emit('error', new Error());
+		index.b1[1].connect();
+		index.b1[1].emit('error', new Error());
+
+		setTimeout(function () {
+			t.ok(pool.isInState('running'));
+
+			t.equal(connections.length, 2);
+			summarize();
+			index.b1[1].connect();
+			index.b1[1].emit('error', new Error());
+			index.b1[0].connect();
+
+			setTimeout(function () {
+				t.ok(pool.isInState('running'));
+
+				t.equal(connections.length, 2);
+				summarize();
+				index.b1[0].emit('error', new Error());
+				index.b1[1].emit('error', new Error());
+
+				setTimeout(function () {
+					t.ok(pool.isInState('failed'));
+
+					t.equal(connections.length, 1);
+					summarize();
+					t.deepEqual(counts, { 'b1': 1 });
+
+					index.b1[0].connect();
+
+					setImmediate(function () {
+						t.ok(pool.isInState('running'));
+						pool.stop();
+					});
+				}, 100);
+			}, 100);
+		}, 100);
+	});
+});
+
+mod_tape.test('pool failure / retry race', function (t) {
+	connections = [];
+	resolver = undefined;
+
+	recovery.default.retries = 2;
+	var pool = new mod_pool.ConnectionPool({
+		log: log,
+		domain: 'foobar',
+		spares: 2,
+		maximum: 2,
+		constructor: function (backend) {
+			return (new DummyConnection(backend));
+		},
+		recovery: recovery
+	});
+	t.ok(resolver);
+
+	pool.on('stateChanged', function (st) {
+		if (st === 'stopped') {
+			t.end();
+		}
+	});
+
+	resolver.emit('added', 'b1', {});
+	setImmediate(function () {
+		t.equal(connections.length, 2);
+		summarize();
+		t.deepEqual(counts, { 'b1': 2 });
+
+		index.b1[0].connect();
+		index.b1[0].emit('error', new Error());
+		index.b1[1].connect();
+		index.b1[1].emit('error', new Error());
+
+		setTimeout(function () {
+			t.ok(pool.isInState('running'));
+
+			t.equal(connections.length, 2);
+			summarize();
+			index.b1[1].connect();
+			index.b1[1].emit('error', new Error());
+			index.b1[0].connect();
+			index.b1[0].emit('error', new Error());
+
+			setTimeout(function () {
+				t.ok(pool.isInState('running'));
+
+				t.equal(connections.length, 2);
+				summarize();
+				index.b1[1].emit('error', new Error());
+				index.b1[0].connect();
+
+				setTimeout(function () {
+					t.ok(pool.isInState('running'));
+
+					t.equal(connections.length, 2);
+					summarize();
+					t.deepEqual(counts, { 'b1': 2 });
+
+					pool.stop();
+				}, 100);
+			}, 100);
+		}, 100);
+	});
+});
+
 mod_tape.test('cleanup sandbox', function (t) {
 	sandbox.restore();
 	t.end();
-- 
2.21.0

