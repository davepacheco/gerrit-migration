From d6afa5f0952c18c4ba688ca22659d836f8db7cb3 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 2 Jan 2018 17:40:15 +0000
Subject: [PATCH] OS-6532 Add rsync patches that don't ship in the 3.1.2
 tarball

---
 rsync/Makefile                                |   2 +-
 ...g-0-when-receiving-xattr-name-values.patch |  31 +
 ...002-Check-fname-in-recv_files-sooner.patch |  44 +
 ...Sanitize-xname-in-read_ndx_and_attrs.patch |  38 +
 ...ilter-against-fnamecmp-in-recv_files.patch |  27 +
 .../0005-Add-copy-devices-option.patch        | 117 +++
 .../0006-Fix-rsync-manual-page.patch}         |   5 +
 rsync/Patches/0007-Speedup-xattrs.patch       | 833 ++++++++++++++++++
 .../0008-Pass-along-ssh-4-6-options.patch     | 120 +++
 rsync/Patches/0009-Fix-progress-quirks.patch  | 130 +++
 .../Patches/0010-Add-time-limit-option.patch  | 352 ++++++++
 11 files changed, 1698 insertions(+), 1 deletion(-)
 create mode 100644 rsync/Patches/0001-Enforce-trailing-0-when-receiving-xattr-name-values.patch
 create mode 100644 rsync/Patches/0002-Check-fname-in-recv_files-sooner.patch
 create mode 100644 rsync/Patches/0003-Sanitize-xname-in-read_ndx_and_attrs.patch
 create mode 100644 rsync/Patches/0004-Check-daemon-filter-against-fnamecmp-in-recv_files.patch
 create mode 100644 rsync/Patches/0005-Add-copy-devices-option.patch
 rename rsync/{rsync.1.diff => Patches/0006-Fix-rsync-manual-page.patch} (83%)
 create mode 100644 rsync/Patches/0007-Speedup-xattrs.patch
 create mode 100644 rsync/Patches/0008-Pass-along-ssh-4-6-options.patch
 create mode 100644 rsync/Patches/0009-Fix-progress-quirks.patch
 create mode 100644 rsync/Patches/0010-Add-time-limit-option.patch

diff --git a/rsync/Makefile b/rsync/Makefile
index 6080ad0..8451b88 100644
--- a/rsync/Makefile
+++ b/rsync/Makefile
@@ -30,7 +30,7 @@ AUTOCONF_ENV += \
 AUTOCONF_OPTS += \
 	--with-included-popt
 
-PATCHES =	rsync.1.diff
+PATCHES =	Patches/*
 
 include ../Makefile.targ
 
diff --git a/rsync/Patches/0001-Enforce-trailing-0-when-receiving-xattr-name-values.patch b/rsync/Patches/0001-Enforce-trailing-0-when-receiving-xattr-name-values.patch
new file mode 100644
index 0000000..6b0fdb1
--- /dev/null
+++ b/rsync/Patches/0001-Enforce-trailing-0-when-receiving-xattr-name-values.patch
@@ -0,0 +1,31 @@
+From: Wayne Davison <wayned@samba.org>
+Date: Sun, 5 Nov 2017 11:33:15 -0800
+Subject: Enforce trailing \0 when receiving xattr name values. Fixes bug
+ 13112.
+Origin: https://git.samba.org/rsync.git/?p=rsync.git;a=commit;h=47a63d90e71d3e19e0e96052bb8c6b9cb140ecc1
+Bug: https://bugzilla.samba.org/show_bug.cgi?id=13112
+Bug-Debian: https://bugs.debian.org/880954
+Bug-Debian-Security: https://security-tracker.debian.org/tracker/CVE-2017-16548
+
+---
+ xattrs.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/xattrs.c b/xattrs.c
+index 68305d75..4867e6f5 100644
+--- a/xattrs.c
++++ b/xattrs.c
+@@ -824,6 +824,10 @@ void receive_xattr(int f, struct file_struct *file)
+ 			out_of_memory("receive_xattr");
+ 		name = ptr + dget_len + extra_len;
+ 		read_buf(f, name, name_len);
++		if (name_len < 1 || name[name_len-1] != '\0') {
++			rprintf(FERROR, "Invalid xattr name received (missing trailing \\0).\n");
++			exit_cleanup(RERR_FILEIO);
++		}
+ 		if (dget_len == datum_len)
+ 			read_buf(f, ptr, dget_len);
+ 		else {
+-- 
+2.15.1
+
diff --git a/rsync/Patches/0002-Check-fname-in-recv_files-sooner.patch b/rsync/Patches/0002-Check-fname-in-recv_files-sooner.patch
new file mode 100644
index 0000000..1b69cf6
--- /dev/null
+++ b/rsync/Patches/0002-Check-fname-in-recv_files-sooner.patch
@@ -0,0 +1,44 @@
+From: Jeriko One <jeriko.one@gmx.us>
+Date: Thu, 2 Nov 2017 23:44:19 -0700
+Subject: Check fname in recv_files sooner.
+Origin: https://git.samba.org/?p=rsync.git;a=commit;h=3e06d40029cfdce9d0f73d87cfd4edaf54be9c51
+Bug-Debian: https://bugs.debian.org/883667
+Bug-Debian-Security: https://security-tracker.debian.org/tracker/CVE-2017-17433
+
+---
+ receiver.c | 12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+diff --git a/receiver.c b/receiver.c
+index baae3a91..9fdafa15 100644
+--- a/receiver.c
++++ b/receiver.c
+@@ -574,6 +574,12 @@ int recv_files(int f_in, int f_out, char *local_name)
+ 			file = dir_flist->files[cur_flist->parent_ndx];
+ 		fname = local_name ? local_name : f_name(file, fbuf);
+ 
++		if (daemon_filter_list.head
++		    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {
++			rprintf(FERROR, "attempt to hack rsync failed.\n");
++			exit_cleanup(RERR_PROTOCOL);
++		}
++
+ 		if (DEBUG_GTE(RECV, 1))
+ 			rprintf(FINFO, "recv_files(%s)\n", fname);
+ 
+@@ -645,12 +651,6 @@ int recv_files(int f_in, int f_out, char *local_name)
+ 
+ 		cleanup_got_literal = 0;
+ 
+-		if (daemon_filter_list.head
+-		    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {
+-			rprintf(FERROR, "attempt to hack rsync failed.\n");
+-			exit_cleanup(RERR_PROTOCOL);
+-		}
+-
+ 		if (read_batch) {
+ 			int wanted = redoing
+ 				   ? we_want_redo(ndx)
+-- 
+2.15.1
+
diff --git a/rsync/Patches/0003-Sanitize-xname-in-read_ndx_and_attrs.patch b/rsync/Patches/0003-Sanitize-xname-in-read_ndx_and_attrs.patch
new file mode 100644
index 0000000..d42f595
--- /dev/null
+++ b/rsync/Patches/0003-Sanitize-xname-in-read_ndx_and_attrs.patch
@@ -0,0 +1,38 @@
+From: Jeriko One <jeriko.one@gmx.us>
+Date: Thu, 16 Nov 2017 17:05:42 -0800
+Subject: [1/2] Sanitize xname in read_ndx_and_attrs.
+Origin: https://git.samba.org/?p=rsync.git;a=commit;h=70aeb5fddd1b2f8e143276f8d5a085db16c593b9
+Bug-Debian: https://bugs.debian.org/883665
+Bug-Debian-Security: https://security-tracker.debian.org/tracker/CVE-2017-17434
+
+---
+ rsync.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/rsync.c b/rsync.c
+index b82e5988..a0945ba4 100644
+--- a/rsync.c
++++ b/rsync.c
+@@ -49,6 +49,7 @@ extern int flist_eof;
+ extern int file_old_total;
+ extern int keep_dirlinks;
+ extern int make_backups;
++extern int sanitize_paths;
+ extern struct file_list *cur_flist, *first_flist, *dir_flist;
+ extern struct chmod_mode_struct *daemon_chmod_modes;
+ #ifdef ICONV_OPTION
+@@ -396,6 +397,11 @@ int read_ndx_and_attrs(int f_in, int f_out, int *iflag_ptr, uchar *type_ptr,
+ 	if (iflags & ITEM_XNAME_FOLLOWS) {
+ 		if ((len = read_vstring(f_in, buf, MAXPATHLEN)) < 0)
+ 			exit_cleanup(RERR_PROTOCOL);
++
++		if (sanitize_paths) {
++			sanitize_path(buf, buf, "", 0, SP_DEFAULT);
++			len = strlen(buf);
++		}
+ 	} else {
+ 		*buf = '\0';
+ 		len = -1;
+-- 
+2.15.1
+
diff --git a/rsync/Patches/0004-Check-daemon-filter-against-fnamecmp-in-recv_files.patch b/rsync/Patches/0004-Check-daemon-filter-against-fnamecmp-in-recv_files.patch
new file mode 100644
index 0000000..e754918
--- /dev/null
+++ b/rsync/Patches/0004-Check-daemon-filter-against-fnamecmp-in-recv_files.patch
@@ -0,0 +1,27 @@
+From: Jeriko One <jeriko.one@gmx.us>
+Date: Thu, 16 Nov 2017 17:26:03 -0800
+Subject: [2/2] Check daemon filter against fnamecmp in recv_files().
+Origin: https://git.samba.org/?p=rsync.git;a=commit;h=5509597decdbd7b91994210f700329d8a35e70a1
+Bug-Debian: https://bugs.debian.org/883665
+Bug-Debian-Security: https://security-tracker.debian.org/tracker/CVE-2017-17434
+
+---
+ receiver.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/receiver.c b/receiver.c
+index 9fdafa15..9c46242e 100644
+--- a/receiver.c
++++ b/receiver.c
+@@ -722,7 +722,7 @@ int recv_files(int f_in, int f_out, char *local_name)
+ 				break;
+ 			}
+ 			if (!fnamecmp || (daemon_filter_list.head
+-			  && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {
++			  && check_filter(&daemon_filter_list, FLOG, fnamecmp, 0) < 0)) {
+ 				fnamecmp = fname;
+ 				fnamecmp_type = FNAMECMP_FNAME;
+ 			}
+-- 
+2.15.1
+
diff --git a/rsync/Patches/0005-Add-copy-devices-option.patch b/rsync/Patches/0005-Add-copy-devices-option.patch
new file mode 100644
index 0000000..292aa9a
--- /dev/null
+++ b/rsync/Patches/0005-Add-copy-devices-option.patch
@@ -0,0 +1,117 @@
+From rsync-patches-3.1.2.tar.gz; originally copy-devices.diff
+
+This patch adds the --copy-devices option, which will try to copy
+the data inside a device instead of duplicating the device node.
+
+To use this patch, run these commands for a successful build:
+
+    patch -p1 <patches/copy-devices.diff
+    ./prepare-source
+    ./configure                      (optional if already run)
+    make
+
+based-on: 16b49716d55a50f2e985b879b720b2c53c892a3a
+---
+
+diff --git a/generator.c b/generator.c
+--- a/generator.c
++++ b/generator.c
+@@ -39,6 +39,7 @@ extern int preserve_acls;
+ extern int preserve_xattrs;
+ extern int preserve_links;
+ extern int preserve_devices;
++extern int copy_devices;
+ extern int preserve_specials;
+ extern int preserve_hard_links;
+ extern int preserve_executability;
+@@ -1650,7 +1651,7 @@ static void recv_generator(char *fname, struct file_struct *file, int ndx,
+ 		goto cleanup;
+ 	}
+ 
+-	if (!S_ISREG(file->mode)) {
++	if (!(S_ISREG(file->mode) || (copy_devices && IS_DEVICE(file->mode)))) {
+ 		if (solo_file)
+ 			fname = f_name(file, NULL);
+ 		rprintf(FINFO, "skipping non-regular file \"%s\"\n", fname);
+diff --git a/options.c b/options.c
+--- a/options.c
++++ b/options.c
+@@ -50,6 +50,7 @@ int append_mode = 0;
+ int keep_dirlinks = 0;
+ int copy_dirlinks = 0;
+ int copy_links = 0;
++int copy_devices = 0;
+ int preserve_links = 0;
+ int preserve_hard_links = 0;
+ int preserve_acls = 0;
+@@ -704,6 +705,7 @@ void usage(enum logcode F)
+   rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
+   rprintf(F," -g, --group                 preserve group\n");
+   rprintf(F,"     --devices               preserve device files (super-user only)\n");
++  rprintf(F,"     --copy-devices          copy device contents as regular file\n");
+   rprintf(F,"     --specials              preserve special files\n");
+   rprintf(F," -D                          same as --devices --specials\n");
+   rprintf(F," -t, --times                 preserve modification times\n");
+@@ -885,6 +887,7 @@ static struct poptOption long_options[] = {
+   {"no-D",             0,  POPT_ARG_NONE,   0, OPT_NO_D, 0, 0 },
+   {"devices",          0,  POPT_ARG_VAL,    &preserve_devices, 1, 0, 0 },
+   {"no-devices",       0,  POPT_ARG_VAL,    &preserve_devices, 0, 0, 0 },
++  {"copy-devices",     0,  POPT_ARG_NONE,   &copy_devices, 0, 0, 0 },
+   {"specials",         0,  POPT_ARG_VAL,    &preserve_specials, 1, 0, 0 },
+   {"no-specials",      0,  POPT_ARG_VAL,    &preserve_specials, 0, 0, 0 },
+   {"links",           'l', POPT_ARG_VAL,    &preserve_links, 1, 0, 0 },
+@@ -2762,6 +2765,9 @@ void server_options(char **args, int *argc_p)
+ 	else if (remove_source_files)
+ 		args[ac++] = "--remove-sent-files";
+ 
++	if (copy_devices)
++		args[ac++] = "--copy-devices";
++
+ 	if (preallocate_files && am_sender)
+ 		args[ac++] = "--preallocate";
+ 
+diff --git a/rsync.c b/rsync.c
+--- a/rsync.c
++++ b/rsync.c
+@@ -33,6 +33,7 @@ extern int preserve_xattrs;
+ extern int preserve_perms;
+ extern int preserve_executability;
+ extern int preserve_times;
++extern int copy_devices;
+ extern int am_root;
+ extern int am_server;
+ extern int am_daemon;
+@@ -404,7 +405,8 @@ int read_ndx_and_attrs(int f_in, int f_out, int *iflag_ptr, uchar *type_ptr,
+ 
+ 	if (iflags & ITEM_TRANSFER) {
+ 		int i = ndx - cur_flist->ndx_start;
+-		if (i < 0 || !S_ISREG(cur_flist->files[i]->mode)) {
++		struct file_struct *file = cur_flist->files[i];
++		if (i < 0 || !(S_ISREG(file->mode) || (copy_devices && IS_DEVICE(file->mode)))) {
+ 			rprintf(FERROR,
+ 				"received request to transfer non-regular file: %d [%s]\n",
+ 				ndx, who_am_i());
+diff --git a/sender.c b/sender.c
+--- a/sender.c
++++ b/sender.c
+@@ -365,6 +365,20 @@ void send_files(int f_in, int f_out)
+ 			exit_cleanup(RERR_FILEIO);
+ 		}
+ 
++		/* On Matt's computer, st_size is falsely 0 for most devices.
++		 * If this happens, try harder to determine the actual device size. */
++		if (IS_DEVICE(st.st_mode) && st.st_size == 0) {
++			OFF_T off = lseek(fd, 0, SEEK_END);
++			if (off == (OFF_T) -1)
++				rsyserr(FERROR, errno, "failed to seek to end of %s to determine size", fname);
++			else {
++				st.st_size = off;
++				off = lseek(fd, 0, SEEK_SET);
++				if (off != 0)
++					rsyserr(FERROR, errno, "failed to seek back to beginning of %s to read it", fname);
++			}
++		}
++
+ 		if (st.st_size) {
+ 			int32 read_size = MAX(s->blength * 3, MAX_MAP_SIZE);
+ 			mbuf = map_file(fd, st.st_size, read_size, s->blength);
diff --git a/rsync/rsync.1.diff b/rsync/Patches/0006-Fix-rsync-manual-page.patch
similarity index 83%
rename from rsync/rsync.1.diff
rename to rsync/Patches/0006-Fix-rsync-manual-page.patch
index f6203c8..6f39015 100644
--- a/rsync/rsync.1.diff
+++ b/rsync/Patches/0006-Fix-rsync-manual-page.patch
@@ -1,3 +1,8 @@
+From: Joyent
+Date: Wed Dec 8 23:26:28 2010 -0800
+Subject: Fixup rsync(1) manual page
+---
+
 --- rsync-3.1.2/rsync.1	Thu Sep 17 01:30:37 2009
 +++ rsync-3.1.2/rsync.1.new	Thu Sep 17 01:32:44 2009
 @@ -1426,5 +1426,8 @@
diff --git a/rsync/Patches/0007-Speedup-xattrs.patch b/rsync/Patches/0007-Speedup-xattrs.patch
new file mode 100644
index 0000000..734306f
--- /dev/null
+++ b/rsync/Patches/0007-Speedup-xattrs.patch
@@ -0,0 +1,833 @@
+From: Stefan Metzmacher <metze@samba.org>
+Date: Fri, 22 Jul 2016 12:43:27 +0000 (+0200)
+Subject: xattrs: add const to empty_xattr
+X-Git-Url: https://git.samba.org/?p=rsync.git;a=commitdiff_plain;h=ac97bc14f623fe5027423aa0a6acd3a8c1124e99
+
+xattrs: add const to empty_xattr
+
+Part of a patchset for bug 5324.
+---
+
+diff --git a/xattrs.c b/xattrs.c
+index 0658afb..ed8c81b 100644
+--- a/xattrs.c
++++ b/xattrs.c
+@@ -82,7 +82,7 @@ typedef struct {
+ static size_t namebuf_len = 0;
+ static char *namebuf = NULL;
+ 
+-static item_list empty_xattr = EMPTY_ITEM_LIST;
++static const item_list empty_xattr = EMPTY_ITEM_LIST;
+ static item_list rsync_xal_l = EMPTY_ITEM_LIST;
+ 
+ static size_t prior_xattr_count = (size_t)-1;
+@@ -466,7 +466,7 @@ int send_xattr(int f, stat_x *sxp)
+  * need so that send_xattr_request() can tell the sender about them. */
+ int xattr_diff(struct file_struct *file, stat_x *sxp, int find_all)
+ {
+-	item_list *lst = rsync_xal_l.items;
++	const item_list *lst = rsync_xal_l.items;
+ 	rsync_xa *snd_rxa, *rec_rxa;
+ 	int snd_cnt, rec_cnt;
+ 	int cmp, same, xattrs_equal = 1;
+From: Stefan Metzmacher <metze@samba.org>
+Date: Fri, 22 Jul 2016 16:14:40 +0000 (+0200)
+Subject: xattrs: let rsync_xal_store() return ndx.
+X-Git-Url: https://git.samba.org/?p=rsync.git;a=commitdiff_plain;h=39d7e3ec255a15ed6da035a009abc2a1c0a3d856
+
+xattrs: let rsync_xal_store() return ndx.
+
+Part of a patchset for bug 5324.
+---
+
+diff --git a/xattrs.c b/xattrs.c
+index ed8c81b..88da5ee 100644
+--- a/xattrs.c
++++ b/xattrs.c
+@@ -398,8 +398,9 @@ static int find_matching_xattr(item_list *xalp)
+ }
+ 
+ /* Store *xalp on the end of rsync_xal_l */
+-static void rsync_xal_store(item_list *xalp)
++static int rsync_xal_store(item_list *xalp)
+ {
++	int ndx = rsync_xal_l.count; /* pre-incremented count */
+ 	item_list *new_lst = EXPAND_ITEM_LIST(&rsync_xal_l, item_list, RSYNC_XAL_LIST_INITIAL);
+ 	/* Since the following call starts a new list, we know it will hold the
+ 	 * entire initial-count, not just enough space for one new item. */
+@@ -408,6 +409,7 @@ static void rsync_xal_store(item_list *xalp)
+ 	memcpy(new_lst->items, xalp->items, xalp->count * sizeof (rsync_xa));
+ 	new_lst->count = xalp->count;
+ 	xalp->count = 0;
++	return ndx;
+ }
+ 
+ /* Send the make_xattr()-generated xattr list for this flist entry. */
+@@ -454,8 +456,7 @@ int send_xattr(int f, stat_x *sxp)
+ 			else
+ 				write_bigbuf(f, rxa->datum, rxa->datum_len);
+ 		}
+-		ndx = rsync_xal_l.count; /* pre-incremented count */
+-		rsync_xal_store(sxp->xattr); /* adds item to rsync_xal_l */
++		ndx = rsync_xal_store(sxp->xattr); /* adds item to rsync_xal_l */
+ 	}
+ 
+ 	return ndx;
+@@ -769,8 +770,7 @@ void receive_xattr(int f, struct file_struct *file)
+ 	if (need_sort && count > 1)
+ 		qsort(temp_xattr.items, count, sizeof (rsync_xa), rsync_xal_compare_names);
+ 
+-	ndx = rsync_xal_l.count; /* pre-incremented count */
+-	rsync_xal_store(&temp_xattr); /* adds item to rsync_xal_l */
++	ndx = rsync_xal_store(&temp_xattr); /* adds item to rsync_xal_l */
+ 
+ 	F_XATTR(file) = ndx;
+ }
+From: Stefan Metzmacher <metze@samba.org>
+Date: Fri, 22 Jul 2016 16:32:04 +0000 (+0200)
+Subject: xattrs: introduce a rsync_xa_list struct as layer between two nested item_lists
+X-Git-Url: https://git.samba.org/?p=rsync.git;a=commitdiff_plain;h=6eb71beaffb365c8f3b3d0db3ab7123026ee423e
+
+xattrs: introduce a rsync_xa_list struct as layer between two nested item_lists
+
+We have the global 'item_list rsync_xal_l', this maintains an array
+of rsync_xa_list structure, one per file.
+
+Each rsync_xa_list structure maintains an array of rsync_xa structure,
+while each represent a single xattr with name and value.
+
+Part of a patchset for bug 5324.
+---
+
+diff --git a/xattrs.c b/xattrs.c
+index 88da5ee..7c52e7b 100644
+--- a/xattrs.c
++++ b/xattrs.c
+@@ -79,9 +79,16 @@ typedef struct {
+ 	int num;
+ } rsync_xa;
+ 
++typedef struct {
++	item_list xa_items;
++} rsync_xa_list;
++
+ static size_t namebuf_len = 0;
+ static char *namebuf = NULL;
+ 
++static const rsync_xa_list empty_xa_list = {
++	.xa_items = EMPTY_ITEM_LIST,
++};
+ static const item_list empty_xattr = EMPTY_ITEM_LIST;
+ static item_list rsync_xal_l = EMPTY_ITEM_LIST;
+ 
+@@ -360,17 +367,19 @@ int copy_xattrs(const char *source, const char *dest)
+ 	return 0;
+ }
+ 
+-static int find_matching_xattr(item_list *xalp)
++static int find_matching_xattr(const item_list *xalp)
+ {
+-	size_t i, j;
+-	item_list *lst = rsync_xal_l.items;
++	const rsync_xa_list *glst = rsync_xal_l.items;
++	size_t i;
+ 
+ 	for (i = 0; i < rsync_xal_l.count; i++) {
+-		rsync_xa *rxas1 = lst[i].items;
+-		rsync_xa *rxas2 = xalp->items;
++		const item_list *lst = &glst[i].xa_items;
++		const rsync_xa *rxas1 = lst->items;
++		const rsync_xa *rxas2 = xalp->items;
++		size_t j;
+ 
+ 		/* Wrong number of elements? */
+-		if (lst[i].count != xalp->count)
++		if (lst->count != xalp->count)
+ 			continue;
+ 		/* any elements different? */
+ 		for (j = 0; j < xalp->count; j++) {
+@@ -401,13 +410,13 @@ static int find_matching_xattr(item_list *xalp)
+ static int rsync_xal_store(item_list *xalp)
+ {
+ 	int ndx = rsync_xal_l.count; /* pre-incremented count */
+-	item_list *new_lst = EXPAND_ITEM_LIST(&rsync_xal_l, item_list, RSYNC_XAL_LIST_INITIAL);
++	rsync_xa_list *new_list = EXPAND_ITEM_LIST(&rsync_xal_l, rsync_xa_list, RSYNC_XAL_LIST_INITIAL);
+ 	/* Since the following call starts a new list, we know it will hold the
+ 	 * entire initial-count, not just enough space for one new item. */
+-	*new_lst = empty_xattr;
+-	(void)EXPAND_ITEM_LIST(new_lst, rsync_xa, xalp->count);
+-	memcpy(new_lst->items, xalp->items, xalp->count * sizeof (rsync_xa));
+-	new_lst->count = xalp->count;
++	*new_list = empty_xa_list;
++	(void)EXPAND_ITEM_LIST(&new_list->xa_items, rsync_xa, xalp->count);
++	memcpy(new_list->xa_items.items, xalp->items, xalp->count * sizeof (rsync_xa));
++	new_list->xa_items.count = xalp->count;
+ 	xalp->count = 0;
+ 	return ndx;
+ }
+@@ -467,7 +476,8 @@ int send_xattr(int f, stat_x *sxp)
+  * need so that send_xattr_request() can tell the sender about them. */
+ int xattr_diff(struct file_struct *file, stat_x *sxp, int find_all)
+ {
+-	const item_list *lst = rsync_xal_l.items;
++	const rsync_xa_list *glst = rsync_xal_l.items;
++	const item_list *lst;
+ 	rsync_xa *snd_rxa, *rec_rxa;
+ 	int snd_cnt, rec_cnt;
+ 	int cmp, same, xattrs_equal = 1;
+@@ -480,9 +490,10 @@ int xattr_diff(struct file_struct *file, stat_x *sxp, int find_all)
+ 		rec_cnt = 0;
+ 	}
+ 
+-	if (F_XATTR(file) >= 0)
+-		lst += F_XATTR(file);
+-	else
++	if (F_XATTR(file) >= 0) {
++		glst += F_XATTR(file);
++		lst = &glst->xa_items;
++	} else
+ 		lst = &empty_xattr;
+ 
+ 	snd_rxa = lst->items;
+@@ -541,11 +552,14 @@ int xattr_diff(struct file_struct *file, stat_x *sxp, int find_all)
+  * XSTATE_ABBREV states into XSTATE_DONE. */
+ void send_xattr_request(const char *fname, struct file_struct *file, int f_out)
+ {
+-	item_list *lst = rsync_xal_l.items;
++	const rsync_xa_list *glst = rsync_xal_l.items;
++	const item_list *lst;
+ 	int cnt, prior_req = 0;
+ 	rsync_xa *rxa;
+ 
+-	lst += F_XATTR(file);
++	glst += F_XATTR(file);
++	lst = &glst->xa_items;
++
+ 	for (rxa = lst->items, cnt = lst->count; cnt--; rxa++) {
+ 		if (rxa->datum_len <= MAX_FULL_DATUM)
+ 			continue;
+@@ -596,7 +610,8 @@ void send_xattr_request(const char *fname, struct file_struct *file, int f_out)
+  * stores it in place of its checksum. */
+ int recv_xattr_request(struct file_struct *file, int f_in)
+ {
+-	item_list *lst = rsync_xal_l.items;
++	const rsync_xa_list *glst = rsync_xal_l.items;
++	const item_list *lst;
+ 	char *old_datum, *name;
+ 	rsync_xa *rxa;
+ 	int rel_pos, cnt, num, got_xattr_data = 0;
+@@ -605,7 +620,8 @@ int recv_xattr_request(struct file_struct *file, int f_in)
+ 		rprintf(FERROR, "recv_xattr_request: internal data error!\n");
+ 		exit_cleanup(RERR_PROTOCOL);
+ 	}
+-	lst += F_XATTR(file);
++	glst += F_XATTR(file);
++	lst = &glst->xa_items;
+ 
+ 	cnt = lst->count;
+ 	rxa = lst->items;
+@@ -796,12 +812,13 @@ void cache_tmp_xattr(struct file_struct *file, stat_x *sxp)
+ void uncache_tmp_xattrs(void)
+ {
+ 	if (prior_xattr_count != (size_t)-1) {
+-		item_list *xattr_item = rsync_xal_l.items;
+-		item_list *xattr_start = xattr_item + prior_xattr_count;
+-		xattr_item += rsync_xal_l.count;
++		rsync_xa_list *xa_list_item = rsync_xal_l.items;
++		rsync_xa_list *xa_list_start = xa_list_item + prior_xattr_count;
++		xa_list_item += rsync_xal_l.count;
+ 		rsync_xal_l.count = prior_xattr_count;
+-		while (xattr_item-- > xattr_start)
+-			rsync_xal_free(xattr_item);
++		while (xa_list_item-- > xa_list_start) {
++			rsync_xal_free(&xa_list_item->xa_items);
++		}
+ 		prior_xattr_count = (size_t)-1;
+ 	}
+ }
+@@ -921,8 +938,9 @@ static int rsync_xal_set(const char *fname, item_list *xalp,
+ int set_xattr(const char *fname, const struct file_struct *file,
+ 	      const char *fnamecmp, stat_x *sxp)
+ {
++	rsync_xa_list *glst = rsync_xal_l.items;
++	item_list *lst;
+ 	int ndx;
+-	item_list *lst = rsync_xal_l.items;
+ 
+ 	if (dry_run)
+ 		return 1; /* FIXME: --dry-run needs to compute this value */
+@@ -952,7 +970,9 @@ int set_xattr(const char *fname, const struct file_struct *file,
+ #endif
+ 
+ 	ndx = F_XATTR(file);
+-	return rsync_xal_set(fname, lst + ndx, fnamecmp, sxp);
++	glst += ndx;
++	lst = &glst->xa_items;
++	return rsync_xal_set(fname, lst, fnamecmp, sxp);
+ }
+ 
+ #ifdef SUPPORT_ACLS
+From: Stefan Metzmacher <metze@samba.org>
+Date: Fri, 22 Jul 2016 16:35:18 +0000 (+0200)
+Subject: hashtable: add hashlittle() from lookup3.c, by Bob Jenkins
+X-Git-Url: https://git.samba.org/?p=rsync.git;a=commitdiff_plain;h=cc29b94d0f3ae5d8f96dd0daaf282ed9a73bfe73
+
+hashtable: add hashlittle() from lookup3.c, by Bob Jenkins
+
+Part of a patchset for bug 5324.
+---
+
+diff --git a/hashtable.c b/hashtable.c
+index f0fbe51..238db08 100644
+--- a/hashtable.c
++++ b/hashtable.c
+@@ -170,3 +170,305 @@ void *hashtable_find(struct hashtable *tbl, int64 key, int allocate_if_missing)
+ 	tbl->entries++;
+ 	return node;
+ }
++
++#ifndef WORDS_BIGENDIAN
++# define HASH_LITTLE_ENDIAN 1
++# define HASH_BIG_ENDIAN 0
++#else
++# define HASH_LITTLE_ENDIAN 0
++# define HASH_BIG_ENDIAN 1
++#endif
++
++/*
++ -------------------------------------------------------------------------------
++ lookup3.c, by Bob Jenkins, May 2006, Public Domain.
++
++ These are functions for producing 32-bit hashes for hash table lookup.
++ hash_word(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()
++ are externally useful functions.  Routines to test the hash are included
++ if SELF_TEST is defined.  You can use this free for any purpose.  It's in
++ the public domain.  It has no warranty.
++
++ You probably want to use hashlittle().  hashlittle() and hashbig()
++ hash byte arrays.  hashlittle() is is faster than hashbig() on
++ little-endian machines.  Intel and AMD are little-endian machines.
++ On second thought, you probably want hashlittle2(), which is identical to
++ hashlittle() except it returns two 32-bit hashes for the price of one.
++ You could implement hashbig2() if you wanted but I haven't bothered here.
++
++ If you want to find a hash of, say, exactly 7 integers, do
++   a = i1;  b = i2;  c = i3;
++   mix(a,b,c);
++   a += i4; b += i5; c += i6;
++   mix(a,b,c);
++   a += i7;
++   final(a,b,c);
++ then use c as the hash value.  If you have a variable length array of
++ 4-byte integers to hash, use hash_word().  If you have a byte array (like
++ a character string), use hashlittle().  If you have several byte arrays, or
++ a mix of things, see the comments above hashlittle().
++
++ Why is this so big?  I read 12 bytes at a time into 3 4-byte integers,
++ then mix those integers.  This is fast (you can do a lot more thorough
++ mixing with 12*3 instructions on 3 integers than you can with 3 instructions
++ on 1 byte), but shoehorning those bytes into integers efficiently is messy.
++*/
++
++#define hashsize(n) ((uint32_t)1<<(n))
++#define hashmask(n) (hashsize(n)-1)
++#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))
++
++/*
++ -------------------------------------------------------------------------------
++ mix -- mix 3 32-bit values reversibly.
++
++ This is reversible, so any information in (a,b,c) before mix() is
++ still in (a,b,c) after mix().
++
++ If four pairs of (a,b,c) inputs are run through mix(), or through
++ mix() in reverse, there are at least 32 bits of the output that
++ are sometimes the same for one pair and different for another pair.
++ This was tested for:
++ * pairs that differed by one bit, by two bits, in any combination
++   of top bits of (a,b,c), or in any combination of bottom bits of
++   (a,b,c).
++ * "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
++   the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
++   is commonly produced by subtraction) look like a single 1-bit
++   difference.
++ * the base values were pseudorandom, all zero but one bit set, or
++   all zero plus a counter that starts at zero.
++
++ Some k values for my "a-=c; a^=rot(c,k); c+=b;" arrangement that
++ satisfy this are
++     4  6  8 16 19  4
++     9 15  3 18 27 15
++    14  9  3  7 17  3
++ Well, "9 15 3 18 27 15" didn't quite get 32 bits diffing
++ for "differ" defined as + with a one-bit base and a two-bit delta.  I
++ used http://burtleburtle.net/bob/hash/avalanche.html to choose
++ the operations, constants, and arrangements of the variables.
++
++ This does not achieve avalanche.  There are input bits of (a,b,c)
++ that fail to affect some output bits of (a,b,c), especially of a.  The
++ most thoroughly mixed value is c, but it doesn't really even achieve
++ avalanche in c.
++
++ This allows some parallelism.  Read-after-writes are good at doubling
++ the number of bits affected, so the goal of mixing pulls in the opposite
++ direction as the goal of parallelism.  I did what I could.  Rotates
++ seem to cost as much as shifts on every machine I could lay my hands
++ on, and rotates are much kinder to the top and bottom bits, so I used
++ rotates.
++ -------------------------------------------------------------------------------
++*/
++#define mix(a,b,c) \
++{ \
++  a -= c;  a ^= rot(c, 4);  c += b; \
++  b -= a;  b ^= rot(a, 6);  a += c; \
++  c -= b;  c ^= rot(b, 8);  b += a; \
++  a -= c;  a ^= rot(c,16);  c += b; \
++  b -= a;  b ^= rot(a,19);  a += c; \
++  c -= b;  c ^= rot(b, 4);  b += a; \
++}
++
++/*
++ -------------------------------------------------------------------------------
++ final -- final mixing of 3 32-bit values (a,b,c) into c
++
++ Pairs of (a,b,c) values differing in only a few bits will usually
++ produce values of c that look totally different.  This was tested for
++ * pairs that differed by one bit, by two bits, in any combination
++   of top bits of (a,b,c), or in any combination of bottom bits of
++   (a,b,c).
++ * "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
++   the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
++   is commonly produced by subtraction) look like a single 1-bit
++   difference.
++ * the base values were pseudorandom, all zero but one bit set, or
++   all zero plus a counter that starts at zero.
++
++ These constants passed:
++  14 11 25 16 4 14 24
++  12 14 25 16 4 14 24
++ and these came close:
++   4  8 15 26 3 22 24
++  10  8 15 26 3 22 24
++  11  8 15 26 3 22 24
++ -------------------------------------------------------------------------------
++*/
++#define final(a,b,c) \
++{ \
++  c ^= b; c -= rot(b,14); \
++  a ^= c; a -= rot(c,11); \
++  b ^= a; b -= rot(a,25); \
++  c ^= b; c -= rot(b,16); \
++  a ^= c; a -= rot(c,4);  \
++  b ^= a; b -= rot(a,14); \
++  c ^= b; c -= rot(b,24); \
++}
++
++
++/*
++ -------------------------------------------------------------------------------
++ hashlittle() -- hash a variable-length key into a 32-bit value
++   k       : the key (the unaligned variable-length array of bytes)
++   length  : the length of the key, counting by bytes
++   val2    : IN: can be any 4-byte value OUT: second 32 bit hash.
++ Returns a 32-bit value.  Every bit of the key affects every bit of
++ the return value.  Two keys differing by one or two bits will have
++ totally different hash values.  Note that the return value is better
++ mixed than val2, so use that first.
++
++ The best hash table sizes are powers of 2.  There is no need to do
++ mod a prime (mod is sooo slow!).  If you need less than 32 bits,
++ use a bitmask.  For example, if you need only 10 bits, do
++   h = (h & hashmask(10));
++ In which case, the hash table should have hashsize(10) elements.
++
++ If you are hashing n strings (uint8_t **)k, do it like this:
++   for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);
++
++ By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this
++ code any way you wish, private, educational, or commercial.  It's free.
++
++ Use for hash table lookup, or anything where one collision in 2^^32 is
++ acceptable.  Do NOT use for cryptographic purposes.
++ -------------------------------------------------------------------------------
++*/
++
++uint32_t hashlittle(const void *key, size_t length)
++{
++  uint32_t a,b,c;                                          /* internal state */
++  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */
++
++  /* Set up the internal state */
++  a = b = c = 0xdeadbeef + ((uint32_t)length);
++
++  u.ptr = key;
++  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {
++    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */
++    const uint8_t  *k8;
++
++    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
++    while (length > 12)
++    {
++      a += k[0];
++      b += k[1];
++      c += k[2];
++      mix(a,b,c);
++      length -= 12;
++      k += 3;
++    }
++
++    /*----------------------------- handle the last (probably partial) block */
++    k8 = (const uint8_t *)k;
++    switch(length)
++    {
++    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;
++    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */
++    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */
++    case 9 : c+=k8[8];                   /* fall through */
++    case 8 : b+=k[1]; a+=k[0]; break;
++    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */
++    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */
++    case 5 : b+=k8[4];                   /* fall through */
++    case 4 : a+=k[0]; break;
++    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */
++    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */
++    case 1 : a+=k8[0]; break;
++    case 0 : return c;
++    }
++  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {
++    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */
++    const uint8_t  *k8;
++
++    /*--------------- all but last block: aligned reads and different mixing */
++    while (length > 12)
++    {
++      a += k[0] + (((uint32_t)k[1])<<16);
++      b += k[2] + (((uint32_t)k[3])<<16);
++      c += k[4] + (((uint32_t)k[5])<<16);
++      mix(a,b,c);
++      length -= 12;
++      k += 6;
++    }
++
++    /*----------------------------- handle the last (probably partial) block */
++    k8 = (const uint8_t *)k;
++    switch(length)
++    {
++    case 12: c+=k[4]+(((uint32_t)k[5])<<16);
++             b+=k[2]+(((uint32_t)k[3])<<16);
++             a+=k[0]+(((uint32_t)k[1])<<16);
++             break;
++    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */
++    case 10: c+=k[4];
++             b+=k[2]+(((uint32_t)k[3])<<16);
++             a+=k[0]+(((uint32_t)k[1])<<16);
++             break;
++    case 9 : c+=k8[8];                      /* fall through */
++    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);
++             a+=k[0]+(((uint32_t)k[1])<<16);
++             break;
++    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */
++    case 6 : b+=k[2];
++             a+=k[0]+(((uint32_t)k[1])<<16);
++             break;
++    case 5 : b+=k8[4];                      /* fall through */
++    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);
++             break;
++    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */
++    case 2 : a+=k[0];
++             break;
++    case 1 : a+=k8[0];
++             break;
++    case 0 : return c;                     /* zero length requires no mixing */
++    }
++
++  } else {                        /* need to read the key one byte at a time */
++    const uint8_t *k = (const uint8_t *)key;
++
++    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
++    while (length > 12)
++    {
++      a += k[0];
++      a += ((uint32_t)k[1])<<8;
++      a += ((uint32_t)k[2])<<16;
++      a += ((uint32_t)k[3])<<24;
++      b += k[4];
++      b += ((uint32_t)k[5])<<8;
++      b += ((uint32_t)k[6])<<16;
++      b += ((uint32_t)k[7])<<24;
++      c += k[8];
++      c += ((uint32_t)k[9])<<8;
++      c += ((uint32_t)k[10])<<16;
++      c += ((uint32_t)k[11])<<24;
++      mix(a,b,c);
++      length -= 12;
++      k += 12;
++    }
++
++    /*-------------------------------- last block: affect all 32 bits of (c) */
++    switch(length)                   /* all the case statements fall through */
++    {
++    case 12: c+=((uint32_t)k[11])<<24;
++    case 11: c+=((uint32_t)k[10])<<16;
++    case 10: c+=((uint32_t)k[9])<<8;
++    case 9 : c+=k[8];
++    case 8 : b+=((uint32_t)k[7])<<24;
++    case 7 : b+=((uint32_t)k[6])<<16;
++    case 6 : b+=((uint32_t)k[5])<<8;
++    case 5 : b+=k[4];
++    case 4 : a+=((uint32_t)k[3])<<24;
++    case 3 : a+=((uint32_t)k[2])<<16;
++    case 2 : a+=((uint32_t)k[1])<<8;
++    case 1 : a+=k[0];
++             break;
++    case 0 : return c;
++    }
++  }
++
++  final(a,b,c);
++  return c;
++}
+From: Stefan Metzmacher <metze@samba.org>
+Date: Fri, 22 Jul 2016 17:46:46 +0000 (+0200)
+Subject: xattrs: maintain a hashtable in order to speed up find_matching_xattr()
+X-Git-Url: https://git.samba.org/?p=rsync.git;a=commitdiff_plain;h=6e3b2102bc2c7df42aa4961a6460eae954c95af2
+
+xattrs: maintain a hashtable in order to speed up find_matching_xattr()
+
+As a testcase I've used one directory on gpfs with 1000000 files,
+each with an xattr called 'name$i' having a value of 'value$i'.
+So we also have 1000000 unique xattrs. The source and dest directories
+are already in sync before. So the rsync command is basically a noop,
+just verifying that everything is already in sync.
+
+The results before this patchset are:
+
+  [gpfs]# time rsync -a -P -X -q source-xattr/ dest-with-xattr/
+
+  real    8m46.191s
+  user    6m29.016s
+  sys     0m24.883s
+
+  [gpfs]# time rsync -a -P -q source-xattr/ dest-without-xattr/
+
+  real    1m58.462s
+  user    0m0.957s
+  sys     0m11.801s
+
+With the patchset I got:
+
+  [gpfs]# time /gpfs/rsync.install/bin/rsync -a -P -X -q source-xattr/ dest-with-xattr/
+
+  real    2m4.150s
+  user    0m1.917s
+  sys     0m17.077s
+
+  [gpfs]# time /gpfs/rsync.install/bin/rsync -a -P -q source-xattr/ dest-without-xattr/
+  real    1m59.534s
+  user    0m0.924s
+  sys     0m11.599s
+
+It means the time in userspace dropped from 6m29.016s down to 0m1.917s!
+Without -X we get ~ 0m0.9s with or without the patch.
+
+Part of a patchset for bug 5324.
+---
+
+diff --git a/xattrs.c b/xattrs.c
+index 7c52e7b..b105392 100644
+--- a/xattrs.c
++++ b/xattrs.c
+@@ -79,7 +79,16 @@ typedef struct {
+ 	int num;
+ } rsync_xa;
+ 
+-typedef struct {
++struct _rsync_xa_list;
++
++typedef struct _rsync_xa_list_ref {
++	struct _rsync_xa_list_ref *next;
++	int ndx;
++} rsync_xa_list_ref;
++
++typedef struct _rsync_xa_list {
++	int ndx;
++	int64 key;
+ 	item_list xa_items;
+ } rsync_xa_list;
+ 
+@@ -91,6 +100,7 @@ static const rsync_xa_list empty_xa_list = {
+ };
+ static const item_list empty_xattr = EMPTY_ITEM_LIST;
+ static item_list rsync_xal_l = EMPTY_ITEM_LIST;
++static struct hashtable *rsync_xal_h = NULL;
+ 
+ static size_t prior_xattr_count = (size_t)-1;
+ 
+@@ -367,19 +377,58 @@ int copy_xattrs(const char *source, const char *dest)
+ 	return 0;
+ }
+ 
+-static int find_matching_xattr(const item_list *xalp)
++static int64 xattr_lookup_hash(const item_list *xalp)
+ {
+-	const rsync_xa_list *glst = rsync_xal_l.items;
++	const rsync_xa *rxas = xalp->items;
+ 	size_t i;
++	int64 key = hashlittle(&xalp->count, sizeof xalp->count);
++
++	for (i = 0; i < xalp->count; i++) {
++		key += hashlittle(rxas[i].name, rxas[i].name_len);
++		if (rxas[i].datum_len > MAX_FULL_DATUM)
++			key += hashlittle(rxas[i].datum, MAX_DIGEST_LEN);
++		else
++			key += hashlittle(rxas[i].datum, rxas[i].datum_len);
++	}
++
++	if (key == 0) {
++		/* This is very unlikely, but we should never
++		 * return 0 as hashtable_find() doesn't like it. */
++		return 1;
++	}
++
++	return key;
++}
+ 
+-	for (i = 0; i < rsync_xal_l.count; i++) {
+-		const item_list *lst = &glst[i].xa_items;
+-		const rsync_xa *rxas1 = lst->items;
++static int find_matching_xattr(const item_list *xalp)
++{
++	const struct ht_int64_node *node;
++	const rsync_xa_list_ref *ref;
++	int64 key;
++
++	if (rsync_xal_h == NULL)
++		return -1;
++
++	key = xattr_lookup_hash(xalp);
++
++	node = hashtable_find(rsync_xal_h, key, 0);
++	if (node == NULL)
++		return -1;
++
++	if (node->data == NULL)
++		return -1;
++
++	for (ref = node->data; ref != NULL; ref = ref->next) {
++		const rsync_xa_list *ptr = rsync_xal_l.items;
++		const rsync_xa *rxas1;
+ 		const rsync_xa *rxas2 = xalp->items;
+ 		size_t j;
+ 
++		ptr += ref->ndx;
++		rxas1 = ptr->xa_items.items;
++
+ 		/* Wrong number of elements? */
+-		if (lst->count != xalp->count)
++		if (ptr->xa_items.count != xalp->count)
+ 			continue;
+ 		/* any elements different? */
+ 		for (j = 0; j < xalp->count; j++) {
+@@ -400,7 +449,7 @@ static int find_matching_xattr(const item_list *xalp)
+ 		}
+ 		/* no differences found.  This is The One! */
+ 		if (j == xalp->count)
+-			return i;
++			return ref->ndx;
+ 	}
+ 
+ 	return -1;
+@@ -409,8 +458,10 @@ static int find_matching_xattr(const item_list *xalp)
+ /* Store *xalp on the end of rsync_xal_l */
+ static int rsync_xal_store(item_list *xalp)
+ {
++	struct ht_int64_node *node;
+ 	int ndx = rsync_xal_l.count; /* pre-incremented count */
+ 	rsync_xa_list *new_list = EXPAND_ITEM_LIST(&rsync_xal_l, rsync_xa_list, RSYNC_XAL_LIST_INITIAL);
++	rsync_xa_list_ref *new_ref;
+ 	/* Since the following call starts a new list, we know it will hold the
+ 	 * entire initial-count, not just enough space for one new item. */
+ 	*new_list = empty_xa_list;
+@@ -418,6 +469,40 @@ static int rsync_xal_store(item_list *xalp)
+ 	memcpy(new_list->xa_items.items, xalp->items, xalp->count * sizeof (rsync_xa));
+ 	new_list->xa_items.count = xalp->count;
+ 	xalp->count = 0;
++
++	new_list->ndx = ndx;
++	new_list->key = xattr_lookup_hash(&new_list->xa_items);
++
++	if (rsync_xal_h == NULL)
++		rsync_xal_h = hashtable_create(512, 1);
++	if (rsync_xal_h == NULL)
++		out_of_memory("rsync_xal_h hashtable_create()");
++
++	node = hashtable_find(rsync_xal_h, new_list->key, 1);
++	if (node == NULL)
++		out_of_memory("rsync_xal_h hashtable_find()");
++
++	new_ref = new0(rsync_xa_list_ref);
++	if (new_ref == NULL)
++		out_of_memory("new0(rsync_xa_list_ref)");
++
++	new_ref->ndx = ndx;
++
++	if (node->data != NULL) {
++		rsync_xa_list_ref *ref = node->data;
++
++		while (ref != NULL) {
++			if (ref->next != NULL) {
++				ref = ref->next;
++				continue;
++			}
++
++			ref->next = new_ref;
++			break;
++		}
++	} else
++		node->data = new_ref;
++
+ 	return ndx;
+ }
+ 
+@@ -817,7 +902,41 @@ void uncache_tmp_xattrs(void)
+ 		xa_list_item += rsync_xal_l.count;
+ 		rsync_xal_l.count = prior_xattr_count;
+ 		while (xa_list_item-- > xa_list_start) {
++			struct ht_int64_node *node;
++			rsync_xa_list_ref *ref;
++
+ 			rsync_xal_free(&xa_list_item->xa_items);
++
++			if (rsync_xal_h == NULL)
++				continue;
++
++			node = hashtable_find(rsync_xal_h, xa_list_item->key, 0);
++			if (node == NULL)
++				continue;
++
++			if (node->data == NULL)
++				continue;
++
++			ref = node->data;
++			if (xa_list_item->ndx == ref->ndx) {
++				/* xa_list_item is the first in the list. */
++				node->data = ref->next;
++				free(ref);
++				continue;
++			}
++
++			while (ref != NULL) {
++				if (ref->next == NULL) {
++					ref = NULL;
++					break;
++				}
++				if (xa_list_item->ndx == ref->next->ndx) {
++					ref->next = ref->next->next;
++					free(ref);
++					break;
++				}
++				ref = ref->next;
++			}
+ 		}
+ 		prior_xattr_count = (size_t)-1;
+ 	}
diff --git a/rsync/Patches/0008-Pass-along-ssh-4-6-options.patch b/rsync/Patches/0008-Pass-along-ssh-4-6-options.patch
new file mode 100644
index 0000000..423b98b
--- /dev/null
+++ b/rsync/Patches/0008-Pass-along-ssh-4-6-options.patch
@@ -0,0 +1,120 @@
+From rsync-patches-3.1.2.tar.gz; originally ssh-4-6-options.diff
+
+This patch adds the sending of the -4 or -6 option to ssh when the
+-4 or -6 option was given to rsync.
+
+To use this patch, run these commands for a successful build:
+
+    patch -p1 <patches/ssh-4-6-options.diff
+    ./configure                         (optional if already run)
+    make
+
+based-on: 16b49716d55a50f2e985b879b720b2c53c892a3a
+---
+
+diff --git a/main.c b/main.c
+--- a/main.c
++++ b/main.c
+@@ -78,6 +78,7 @@ extern BOOL flist_receiving_enabled;
+ extern BOOL shutting_down;
+ extern int backup_dir_len;
+ extern int basis_dir_cnt;
++extern int default_af_hint;
+ extern struct stats stats;
+ extern char *stdout_format;
+ extern char *logfile_format;
+@@ -447,6 +448,11 @@ static pid_t do_cmd(char *cmd, char *machine, char *user, char **remote_argv, in
+ 			*t++ = '\0';
+ 		}
+ 
++		if ((t = strrchr(cmd, '/')) != NULL)
++		    t++;
++		else
++		    t = cmd;
++
+ 		/* check to see if we've already been given '-l user' in
+ 		 * the remote-shell command */
+ 		for (i = 0; i < argc-1; i++) {
+@@ -466,20 +472,25 @@ static pid_t do_cmd(char *cmd, char *machine, char *user, char **remote_argv, in
+ 			args[argc++] = "-l";
+ 			args[argc++] = user;
+ 		}
++#ifdef AF_INET
++		if (default_af_hint == AF_INET && strcmp(cmd, "ssh") == 0) {
++			/* we're using ssh so we can add a -4 option */
++			args[argc++] = "-4";
++		}
++#endif
++#ifdef AF_INET6
++		if (default_af_hint == AF_INET6 && strcmp(cmd, "ssh") == 0) {
++			/* we're using ssh so we can add a -6 option */
++			args[argc++] = "-6";
++		}
++#endif
+ 		args[argc++] = machine;
+ #endif
+ 
+ 		args[argc++] = rsync_path;
+ 
+-		if (blocking_io < 0) {
+-			char *cp;
+-			if ((cp = strrchr(cmd, '/')) != NULL)
+-				cp++;
+-			else
+-				cp = cmd;
+-			if (strcmp(cp, "rsh") == 0 || strcmp(cp, "remsh") == 0)
+-				blocking_io = 1;
+-		}
++		if (blocking_io < 0 && (strcmp(t, "rsh") == 0 || strcmp(t, "remsh") == 0))
++			blocking_io = 1;
+ 
+ 		server_options(args,&argc);
+ 
+diff --git a/rsync.yo b/rsync.yo
+--- a/rsync.yo
++++ b/rsync.yo
+@@ -2589,14 +2589,18 @@ regardless of the remote charset you actually pass.  Thus, you may feel free to
+ specify just the local charset for a daemon transfer (e.g. bf(--iconv=utf8)).
+ 
+ dit(bf(-4, --ipv4) or bf(-6, --ipv6)) Tells rsync to prefer IPv4/IPv6
+-when creating sockets.  This only affects sockets that rsync has direct
++when creating sockets.  This affects sockets that rsync has direct
+ control over, such as the outgoing socket when directly contacting an
+-rsync daemon.  See also these options in the bf(--daemon) mode section.
++rsync daemon, as well as forwaring the -4 or -6 option to ssh, if rsync
++deduces that ssh is being used as the remote shell.  For other remote
++shells, see the bf(--rsh) option.
+ 
+ If rsync was complied without support for IPv6, the bf(--ipv6) option
+ will have no effect.  The bf(--version) output will tell you if this
+ is the case.
+ 
++See also these options in the bf(--daemon) mode section.
++
+ dit(bf(--checksum-seed=NUM)) Set the checksum seed to the integer NUM.  This 4
+ byte checksum seed is included in each block and MD4 file checksum calculation
+ (the more modern MD5 file checksums don't use a seed).  By default the checksum
+diff -Nurp a/rsync.1 b/rsync.1
+--- a/rsync.1
++++ b/rsync.1
+@@ -2943,14 +2943,18 @@ specify just the local charset for a dae
+ .IP 
+ .IP "\fB\-4, \-\-ipv4\fP or \fB\-6, \-\-ipv6\fP"
+ Tells rsync to prefer IPv4/IPv6
+-when creating sockets.  This only affects sockets that rsync has direct
++when creating sockets.  This affects sockets that rsync has direct
+ control over, such as the outgoing socket when directly contacting an
+-rsync daemon.  See also these options in the \fB\-\-daemon\fP mode section.
++rsync daemon, as well as forwaring the \-4 or \-6 option to ssh, if rsync
++deduces that ssh is being used as the remote shell.  For other remote
++shells, see the \fB\-\-rsh\fP option.
+ .IP 
+ If rsync was complied without support for IPv6, the \fB\-\-ipv6\fP option
+ will have no effect.  The \fB\-\-version\fP output will tell you if this
+ is the case.
+ .IP 
++See also these options in the \fB\-\-daemon\fP mode section.
++.IP 
+ .IP "\fB\-\-checksum\-seed=NUM\fP"
+ Set the checksum seed to the integer NUM.  This 4
+ byte checksum seed is included in each block and MD4 file checksum calculation
diff --git a/rsync/Patches/0009-Fix-progress-quirks.patch b/rsync/Patches/0009-Fix-progress-quirks.patch
new file mode 100644
index 0000000..3d86fa3
--- /dev/null
+++ b/rsync/Patches/0009-Fix-progress-quirks.patch
@@ -0,0 +1,130 @@
+From: Wayne Davison <wayned@samba.org>
+Subject: Fixes for --progress quirks; originally templines.diff from Debian patches
+Origin: https://git.samba.org/rsync.git/?p=rsync.git;a=commit;h=e02b89d0d35ab8acbd522983c08d2519d8bd12d4
+Origin: https://git.samba.org/rsync.git/?p=rsync.git;a=commit;h=ff66fd4bb6cc76488c6ea1e4b651a869847f6375
+Bug: https://bugzilla.samba.org/show_bug.cgi?id=12367
+
+---
+
+diff a/flist.c b/flist.c
+--- a/flist.c	2016-10-07 13:31:58.347895363 +0200
++++ b/flist.c	2016-11-09 14:57:58.697060497 +0100
+@@ -36,6 +36,7 @@
+ extern int module_id;
+ extern int ignore_errors;
+ extern int numeric_ids;
++extern int quiet;
+ extern int recurse;
+ extern int use_qsort;
+ extern int xfer_dirs;
+@@ -127,6 +128,7 @@
+ 
+ static char empty_sum[MAX_DIGEST_LEN];
+ static int flist_count_offset; /* for --delete --progress */
++static int show_filelist_progress;
+ 
+ static void flist_sort_and_clean(struct file_list *flist, int strip_root);
+ static void output_flist(struct file_list *flist);
+@@ -142,13 +144,10 @@
+ 		     : MD5_DIGEST_LEN;
+ }
+ 
+-static int show_filelist_p(void)
+-{
+-	return INFO_GTE(FLIST, 1) && xfer_dirs && !am_server && !inc_recurse;
+-}
+-
+ static void start_filelist_progress(char *kind)
+ {
++	if (quiet)
++		return;
+ 	rprintf(FCLIENT, "%s ... ", kind);
+ 	output_needs_newline = 1;
+ 	rflush(FINFO);
+@@ -156,23 +155,28 @@
+ 
+ static void emit_filelist_progress(int count)
+ {
++	if (quiet)
++		return;
++	if (output_needs_newline == 2) /* avoid a newline in the middle of this filelist-progress output */
++		output_needs_newline = 0;
+ 	rprintf(FCLIENT, " %d files...\r", count);
++	output_needs_newline = 2;
+ }
+ 
+ static void maybe_emit_filelist_progress(int count)
+ {
+-	if (INFO_GTE(FLIST, 2) && show_filelist_p() && (count % 100) == 0)
++	if (INFO_GTE(FLIST, 2) && show_filelist_progress && (count % 100) == 0)
+ 		emit_filelist_progress(count);
+ }
+ 
+ static void finish_filelist_progress(const struct file_list *flist)
+ {
++	output_needs_newline = 0;
+ 	if (INFO_GTE(FLIST, 2)) {
+ 		/* This overwrites the progress line */
+ 		rprintf(FINFO, "%d file%sto consider\n",
+ 			flist->used, flist->used == 1 ? " " : "s ");
+ 	} else {
+-		output_needs_newline = 0;
+ 		rprintf(FINFO, "done\n");
+ 	}
+ }
+@@ -2087,7 +2091,7 @@
+ 	int implied_dot_dir = 0;
+ 
+ 	rprintf(FLOG, "building file list\n");
+-	if (show_filelist_p())
++	if (show_filelist_progress)
+ 		start_filelist_progress("building file list");
+ 	else if (inc_recurse && INFO_GTE(FLIST, 1) && !am_server)
+ 		rprintf(FCLIENT, "sending incremental file list\n");
+@@ -2361,7 +2365,7 @@
+ 		idev_destroy();
+ #endif
+ 
+-	if (show_filelist_p())
++	if (show_filelist_progress)
+ 		finish_filelist_progress(flist);
+ 
+ 	gettimeofday(&end_tv, NULL);
+@@ -2443,7 +2447,7 @@
+ 	int64 start_read;
+ 
+ 	if (!first_flist) {
+-		if (show_filelist_p())
++		if (show_filelist_progress)
+ 			start_filelist_progress("receiving file list");
+ 		else if (inc_recurse && INFO_GTE(FLIST, 1) && !am_server)
+ 			rprintf(FCLIENT, "receiving incremental file list\n");
+@@ -2539,7 +2543,7 @@
+ 	if (DEBUG_GTE(FLIST, 2))
+ 		rprintf(FINFO, "received %d names\n", flist->used);
+ 
+-	if (show_filelist_p())
++	if (show_filelist_progress)
+ 		finish_filelist_progress(flist);
+ 
+ 	if (need_unsorted_flist) {
+diff a/progress.c b/progress.c
+--- a/progress.c	2015-12-30 08:33:38.268872577 +0100
++++ b/progress.c	2016-11-09 14:58:39.373429408 +0100
+@@ -25,6 +25,7 @@
+ 
+ extern int am_server;
+ extern int flist_eof;
++extern int quiet;
+ extern int need_unsorted_flist;
+ extern int output_needs_newline;
+ extern struct stats stats;
+@@ -127,7 +128,7 @@
+ 	pct = ofs == size ? 100 : (int) (100.0 * ofs / size);
+ 	rprintf(FCLIENT, "\r%15s %3d%% %7.2f%s %s%s",
+ 		human_num(ofs), pct, rate, units, rembuf, eol);
+-	if (!is_last) {
++	if (!is_last && !quiet) {
+ 		output_needs_newline = 1;
+ 		rflush(FCLIENT);
+ 	}
diff --git a/rsync/Patches/0010-Add-time-limit-option.patch b/rsync/Patches/0010-Add-time-limit-option.patch
new file mode 100644
index 0000000..f82dbdd
--- /dev/null
+++ b/rsync/Patches/0010-Add-time-limit-option.patch
@@ -0,0 +1,352 @@
+From rsync-patches-3.1.2.tar.gz; originally time-limit.diff
+
+John Taylor's patch for implementing --time-limit and --stop-at, reworked
+to be simpler and more efficient by Wayne Davison.
+
+Do we need configure support for mktime()?
+
+To use this patch, run these commands for a successful build:
+
+    patch -p1 <patches/time-limit.diff
+    ./configure                              (optional if already run)
+    make
+
+based-on: 16b49716d55a50f2e985b879b720b2c53c892a3a
+---
+
+diff --git a/io.c b/io.c
+--- a/io.c
++++ b/io.c
+@@ -59,6 +59,7 @@ extern int preserve_hard_links;
+ extern BOOL extra_flist_sending_enabled;
+ extern BOOL flush_ok_after_signal;
+ extern struct stats stats;
++extern time_t stop_at_utime;
+ extern struct file_list *cur_flist;
+ #ifdef ICONV_OPTION
+ extern int filesfrom_convert;
+@@ -170,11 +171,19 @@ static void check_timeout(BOOL allow_keepalive, int keepalive_flags)
+ 	 * generator might be blocked trying to send checksums, it needs to
+ 	 * know that the receiver is active).  Thus, as long as one or the
+ 	 * other is successfully doing work, the generator will not timeout. */
+-	if (!io_timeout)
++	if (!io_timeout && !stop_at_utime)
+ 		return;
+ 
+ 	t = time(NULL);
+ 
++	if (stop_at_utime && t >= stop_at_utime) {
++		rprintf(FERROR, "run-time limit exceeded\n");
++		exit_cleanup(RERR_TIMEOUT);
++	}
++
++	if (!io_timeout)
++		return;
++
+ 	if (allow_keepalive) {
+ 		/* This may put data into iobuf.msg w/o flushing. */
+ 		maybe_send_keepalive(t, keepalive_flags);
+diff --git a/options.c b/options.c
+--- a/options.c
++++ b/options.c
+@@ -115,6 +115,7 @@ size_t bwlimit_writemax = 0;
+ int ignore_existing = 0;
+ int ignore_non_existing = 0;
+ int need_messages_from_generator = 0;
++time_t stop_at_utime = 0;
+ int max_delete = INT_MIN;
+ OFF_T max_size = -1;
+ OFF_T min_size = -1;
+@@ -791,6 +792,8 @@ void usage(enum logcode F)
+   rprintf(F,"     --password-file=FILE    read daemon-access password from FILE\n");
+   rprintf(F,"     --list-only             list the files instead of copying them\n");
+   rprintf(F,"     --bwlimit=RATE          limit socket I/O bandwidth\n");
++  rprintf(F,"     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute\n");
++  rprintf(F,"     --time-limit=MINS       Stop rsync after MINS minutes have elapsed\n");
+ #ifdef HAVE_SETVBUF
+   rprintf(F,"     --outbuf=N|L|B          set output buffering to None, Line, or Block\n");
+ #endif
+@@ -819,6 +822,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
+       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
+       OPT_NO_D, OPT_APPEND, OPT_NO_ICONV, OPT_INFO, OPT_DEBUG,
+       OPT_USERMAP, OPT_GROUPMAP, OPT_CHOWN, OPT_BWLIMIT,
++      OPT_STOP_AT, OPT_TIME_LIMIT,
+       OPT_SERVER, OPT_REFUSED_BASE = 9000};
+ 
+ static struct poptOption long_options[] = {
+@@ -1014,6 +1018,8 @@ static struct poptOption long_options[] = {
+   {"no-timeout",       0,  POPT_ARG_VAL,    &io_timeout, 0, 0, 0 },
+   {"contimeout",       0,  POPT_ARG_INT,    &connect_timeout, 0, 0, 0 },
+   {"no-contimeout",    0,  POPT_ARG_VAL,    &connect_timeout, 0, 0, 0 },
++  {"stop-at",          0,  POPT_ARG_STRING, 0, OPT_STOP_AT, 0, 0 },
++  {"time-limit",       0,  POPT_ARG_STRING, 0, OPT_TIME_LIMIT, 0, 0 },
+   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
+   {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
+   {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
+@@ -1785,6 +1791,36 @@ int parse_arguments(int *argc_p, const char ***argv_p)
+ 			return 0;
+ #endif
+ 
++		case OPT_STOP_AT:
++			arg = poptGetOptArg(pc);
++			if ((stop_at_utime = parse_time(arg)) == (time_t)-1) {
++				snprintf(err_buf, sizeof err_buf,
++				    "invalid --stop-at format: %s\n",
++				    arg);
++				rprintf(FERROR, "ERROR: %s", err_buf);
++				return 0;
++			}
++			if (stop_at_utime < time(NULL)) {
++				snprintf(err_buf, sizeof err_buf,
++				    "--stop-at time is in the past: %s\n",
++				    arg);
++				rprintf(FERROR, "ERROR: %s", err_buf);
++				return 0;
++			}
++			break;
++
++		case OPT_TIME_LIMIT:
++			arg = poptGetOptArg(pc);
++			if ((stop_at_utime = atol(arg) * 60) <= 0) {
++				snprintf(err_buf, sizeof err_buf,
++				    "invalid --time-limit value: %s\n",
++				    arg);
++				rprintf(FERROR, "ERROR: %s", err_buf);
++				return 0;
++			}
++			stop_at_utime += time(NULL);
++			break;
++
+ 		default:
+ 			/* A large opt value means that set_refuse_options()
+ 			 * turned this option off. */
+@@ -2584,6 +2620,15 @@ void server_options(char **args, int *argc_p)
+ 		args[ac++] = arg;
+ 	}
+ 
++	if (stop_at_utime) {
++		long mins = (stop_at_utime - time(NULL)) / 60;
++		if (mins <= 0)
++			mins = 1;
++		if (asprintf(&arg, "--time-limit=%ld", mins) < 0)
++			goto oom;
++		args[ac++] = arg;
++	}
++
+ 	if (backup_dir) {
+ 		args[ac++] = "--backup-dir";
+ 		args[ac++] = backup_dir;
+diff --git a/rsync.yo b/rsync.yo
+--- a/rsync.yo
++++ b/rsync.yo
+@@ -451,6 +451,8 @@ to the detailed description below for a complete description.  verb(
+      --password-file=FILE    read daemon-access password from FILE
+      --list-only             list the files instead of copying them
+      --bwlimit=RATE          limit socket I/O bandwidth
++     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute
++     --time-limit=MINS       Stop rsync after MINS minutes have elapsed
+      --write-batch=FILE      write a batched update to FILE
+      --only-write-batch=FILE like --write-batch but w/o updating dest
+      --read-batch=FILE       read a batched update from FILE
+@@ -2524,6 +2526,19 @@ files can show up as being rapidly sent when the data is quickly buffered,
+ while other can show up as very slow when the flushing of the output buffer
+ occurs.  This may be fixed in a future version.
+ 
++dit(bf(--stop-at=y-m-dTh:m)) This option allows you to specify at what
++time to stop rsync, in year-month-dayThour:minute numeric format (e.g.
++2004-12-31T23:59).  You can specify a 2 or 4-digit year.  You can also
++leave off various items and the result will be the next possible time
++that matches the specified data.  For example, "1-30" specifies the next
++January 30th (at midnight), "04:00" specifies the next 4am, "1"
++specifies the next 1st of the month at midnight, and ":59" specifies the
++next 59th minute after the hour.  If you prefer, you may separate the
++date numbers using slashes instead of dashes.
++
++dit(bf(--time-limit=MINS)) This option allows you to specify the maximum
++number of minutes rsync will run for.
++
+ dit(bf(--write-batch=FILE)) Record a file that can later be applied to
+ another identical destination with bf(--read-batch). See the "BATCH MODE"
+ section for details, and also the bf(--only-write-batch) option.
+diff --git a/util.c b/util.c
+--- a/util.c
++++ b/util.c
+@@ -115,6 +115,133 @@ void print_child_argv(const char *prefix, char **cmd)
+ 	rprintf(FCLIENT, " (%d args)\n", cnt);
+ }
+ 
++/* Allow the user to specify a time in the format yyyy-mm-ddThh:mm while
++ * also allowing abbreviated data.  For instance, if the time is omitted,
++ * it defaults to midnight.  If the date is omitted, it defaults to the
++ * next possible date in the future with the specified time.  Even the
++ * year or year-month can be omitted, again defaulting to the next date
++ * in the future that matches the specified information.  A 2-digit year
++ * is also OK, as is using '/' instead of '-'. */
++time_t parse_time(const char *arg)
++{
++	const char *cp;
++	time_t val, now = time(NULL);
++	struct tm t, *today = localtime(&now);
++	int in_date, n;
++
++	memset(&t, 0, sizeof t);
++	t.tm_year = t.tm_mon = t.tm_mday = -1;
++	t.tm_hour = t.tm_min = t.tm_isdst = -1;
++	cp = arg;
++	if (*cp == 'T' || *cp == 't' || *cp == ':') {
++		cp++;
++		in_date = 0;
++	} else
++		in_date = 1;
++	for ( ; ; cp++) {
++		if (!isDigit(cp))
++			return -1;
++
++		n = 0;
++		do {
++			n = n * 10 + *cp++ - '0';
++		} while (isDigit(cp));
++
++		if (*cp == ':')
++			in_date = 0;
++		if (in_date) {
++			if (t.tm_year != -1)
++				return -1;
++			t.tm_year = t.tm_mon;
++			t.tm_mon = t.tm_mday;
++			t.tm_mday = n;
++			if (!*cp)
++				break;
++			if (*cp == 'T' || *cp == 't') {
++				if (!cp[1])
++					break;
++				in_date = 0;
++			} else if (*cp != '-' && *cp != '/')
++				return -1;
++			continue;
++		}
++		if (t.tm_hour != -1)
++			return -1;
++		t.tm_hour = t.tm_min;
++		t.tm_min = n;
++		if (!*cp)
++			break;
++		if (*cp != ':')
++			return -1;
++	}
++
++	in_date = 0;
++	if (t.tm_year < 0) {
++		t.tm_year = today->tm_year;
++		in_date = 1;
++	} else if (t.tm_year < 100) {
++		while (t.tm_year < today->tm_year)
++			t.tm_year += 100;
++	} else
++		t.tm_year -= 1900;
++	if (t.tm_mon < 0) {
++		t.tm_mon = today->tm_mon;
++		in_date = 2;
++	} else
++		t.tm_mon--;
++	if (t.tm_mday < 0) {
++		t.tm_mday = today->tm_mday;
++		in_date = 3;
++	}
++
++	n = 0;
++	if (t.tm_min < 0) {
++		t.tm_hour = t.tm_min = 0;
++	} else if (t.tm_hour < 0) {
++		if (in_date != 3)
++			return -1;
++		in_date = 0;
++		t.tm_hour = today->tm_hour;
++		n = 60*60;
++	}
++
++	if (t.tm_hour > 23 || t.tm_min > 59
++	    || t.tm_mon < 0 || t.tm_mon >= 12
++	    || t.tm_mday < 1 || t.tm_mday > 31
++	    || (val = mktime(&t)) == (time_t)-1)
++		return -1;
++
++	if (val <= now && in_date) {
++	    tweak_date:
++		switch (in_date) {
++		case 3:
++			t.tm_mday++;
++			break;
++		case 2:
++			if (++t.tm_mon == 12)
++				t.tm_mon = 0;
++			else
++				break;
++		case 1:
++			t.tm_year++;
++			break;
++		}
++		if ((val = mktime(&t)) == (time_t)-1) {
++			if (in_date == 3 && t.tm_mday > 28) {
++				t.tm_mday = 1;
++				in_date = 2;
++				goto tweak_date;
++			}
++			return -1;
++		}
++	}
++	if (n) {
++		while (val <= now)
++			val += n;
++	}
++	return val;
++}
++
+ /* This returns 0 for success, 1 for a symlink if symlink time-setting
+  * is not possible, or -1 for any other error. */
+ int set_modtime(const char *fname, time_t modtime, uint32 mod_nsec, mode_t mode)
+diff -Nurp a/proto.h b/proto.h
+--- a/proto.h
++++ b/proto.h
+@@ -354,6 +354,7 @@ void set_nonblocking(int fd);
+ void set_blocking(int fd);
+ int fd_pair(int fd[2]);
+ void print_child_argv(const char *prefix, char **cmd);
++time_t parse_time(const char *arg);
+ int set_modtime(const char *fname, time_t modtime, uint32 mod_nsec, mode_t mode);
+ int make_path(char *fname, int flags);
+ int full_write(int desc, const char *ptr, size_t len);
+diff -Nurp a/rsync.1 b/rsync.1
+--- a/rsync.1
++++ b/rsync.1
+@@ -527,6 +527,8 @@ to the detailed description below for a
+      \-\-password\-file=FILE    read daemon\-access password from FILE
+      \-\-list\-only             list the files instead of copying them
+      \-\-bwlimit=RATE          limit socket I/O bandwidth
++     \-\-stop\-at=y\-m\-dTh:m     Stop rsync at year\-month\-dayThour:minute
++     \-\-time\-limit=MINS       Stop rsync after MINS minutes have elapsed
+      \-\-write\-batch=FILE      write a batched update to FILE
+      \-\-only\-write\-batch=FILE like \-\-write\-batch but w/o updating dest
+      \-\-read\-batch=FILE       read a batched update from FILE
+@@ -2872,6 +2874,21 @@ files can show up as being rapidly sent
+ while other can show up as very slow when the flushing of the output buffer
+ occurs.  This may be fixed in a future version.
+ .IP 
++.IP "\fB\-\-stop\-at=y\-m\-dTh:m\fP"
++This option allows you to specify at what
++time to stop rsync, in year\-month\-dayThour:minute numeric format (e.g.
++2004\-12\-31T23:59).  You can specify a 2 or 4\-digit year.  You can also
++leave off various items and the result will be the next possible time
++that matches the specified data.  For example, \(dq\&1\-30\(dq\& specifies the next
++January 30th (at midnight), \(dq\&04:00\(dq\& specifies the next 4am, \(dq\&1\(dq\&
++specifies the next 1st of the month at midnight, and \(dq\&:59\(dq\& specifies the
++next 59th minute after the hour.  If you prefer, you may separate the
++date numbers using slashes instead of dashes.
++.IP 
++.IP "\fB\-\-time\-limit=MINS\fP"
++This option allows you to specify the maximum
++number of minutes rsync will run for.
++.IP 
+ .IP "\fB\-\-write\-batch=FILE\fP"
+ Record a file that can later be applied to
+ another identical destination with \fB\-\-read\-batch\fP. See the \(dq\&BATCH MODE\(dq\&
-- 
2.21.0

