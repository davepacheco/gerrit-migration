From 00a9ac0f48ec8a1f293da1769c90e557a3c1a598 Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Fri, 9 Nov 2018 22:44:37 +0000
Subject: [PATCH] OS-7353 bhyve support for persistent pci slots for disks

---
 usr/src/lib/brand/bhyve/zone/boot.c | 109 +++++++++++++++++++++++++++-
 1 file changed, 106 insertions(+), 3 deletions(-)

diff --git a/usr/src/lib/brand/bhyve/zone/boot.c b/usr/src/lib/brand/bhyve/zone/boot.c
index 58160a88cc..639e2feb94 100644
--- a/usr/src/lib/brand/bhyve/zone/boot.c
+++ b/usr/src/lib/brand/bhyve/zone/boot.c
@@ -180,6 +180,97 @@ add_ram(int *argc, char **argv)
 	return (0);
 }
 
+/*
+ * Be sure the pci_slot string matches one of "bus:slot:func", "slot:func"
+ * or "slot" with each numeric value expressed in decimal.
+ */
+static int
+check_pci_slot_str(const char *str)
+{
+	int bus, slot, func;
+	char *end;
+	int ret = 0;
+
+	errno = 0;
+	bus = strtol(str, &end, 10);
+	if (errno != 0) {
+		(void) printf(
+		    "Invalid pci_slot while parsing first token of '%s': %s\n",
+		    str, strerror(errno));
+		return (-1);
+	}
+	if (*end == '\0') {		/* "slot" */
+		slot = bus;
+		bus = 0;
+		func = 0;
+		goto done;
+	}
+	if (*end != ':') {
+		(void) printf("Invalid pci_slot '%s': invalid character '%c'\n",
+		    str, *end);
+		return (-1);
+	}
+
+	slot = strtol(end + 1, &end, 10);
+	if (errno != 0) {
+		(void) printf(
+		    "Invalid pci_slot while parsing second token of '%s': %s\n",
+		    str, strerror(errno));
+		return (-1);
+	}
+	if (*end == '\0') {		/* "slot:func" */
+		func = slot;
+		slot = bus;
+		func = 0;
+		goto done;
+	}
+	if (*end != ':') {
+		(void) printf("Invalid pci_slot '%s': invalid character '%c'\n",
+		    str, *end);
+		return (-1);
+	}
+
+	func = strtol(end + 1, &end, 10);
+	if (errno != 0) {
+		(void) printf(
+		    "Invalid pci_slot while parsing third token of '%s': %s\n",
+		    str, strerror(errno));
+		return (-1);
+	}
+	if (*end != '\0') {		/* "bus:slot:func" */
+		(void) printf("Invalid pci_slot '%s': invalid character '%c'\n",
+		    str, *end);
+		return (-1);
+	}
+
+done:
+	if (bus < 0 || bus > 255) {
+		(void) printf( "Invalid pci_slot '%s': "
+		    "bus must be in range [0 - 255]\n", str);
+		ret = -1;
+	}
+	if (slot < 0 || slot > 31) {
+		(void) printf( "Invalid pci_slot '%s': "
+		    "slot must be in range [0 - 31]\n", str);
+		ret = -1;
+	}
+	if (func < 0 || func > 7) {
+		(void) printf( "Invalid pci_slot '%s': "
+		    "function must be in range [0 - 7]\n", str);
+		ret = -1;
+	}
+
+	return (ret);
+}
+
+/*
+ * In the initial implementation, slot assignment was dynamic on every boot.
+ * Now, each device resource can have a pci_slot property that will override
+ * dyanmic assignment.  The original behavior is preserved, but no effort is
+ * made to detect or avoid conflicts between legacy behavior and new behavior.
+ * When used with vmadm this is not an issue, as it will update the zone config
+ * at boot time to contain static assignments.
+ */
 static int
 add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 {
@@ -189,6 +280,13 @@ add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 	const char *model = "virtio-blk";
 	int pcislot;
 	int pcifn;
+	const char *slotstr;
+	char slotbuf[16];
+
+	if ((slotstr = get_zcfg_var("device", disk, "pci_slot")) != NULL &&
+	    check_pci_slot_str(slotstr) != 0) {
+		return (-1);
+	}
 
 	/* Allow at most one "primary" disk */
 	if (is_env_true("device", disk, "boot")) {
@@ -210,7 +308,6 @@ add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 		next_other++;
 	}
 
-
 	if (is_env_string("device", disk, "model", "virtio")) {
 		model = "virtio-blk";
 	} else if (is_env_string("device", disk, "model", "ahci")) {
@@ -224,8 +321,14 @@ add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 		return (-1);
 	}
 
-	if (snprintf(slotconf, slotconf_len, "%d:%d,%s,%s",
-	    pcislot, pcifn, model, path) >= slotconf_len) {
+	if (slotstr == NULL) {
+		(void) snprintf(slotbuf, sizeof (slotbuf), "%d:%d",
+		    pcislot, pcifn);
+		slotstr = slotbuf;
+	}
+
+	if (snprintf(slotconf, slotconf_len, "%s,%s,%s",
+	    slotstr, model, path) >= slotconf_len) {
 		(void) printf("Error: disk path '%s' too long\n", path);
 		return (-1);
 	}
-- 
2.21.0

