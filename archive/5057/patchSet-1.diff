From f8dc2cfc8174b9f3dc85b9b0003806018ccf8ebc Mon Sep 17 00:00:00 2001
From: Mike Gerdts <mike.gerdts@joyent.com>
Date: Fri, 9 Nov 2018 22:44:37 +0000
Subject: [PATCH] OS-7353 bhyve support for persistent pci slots for disks

---
 usr/src/lib/brand/bhyve/zone/boot.c | 23 ++++++++++++++++++++---
 1 file changed, 20 insertions(+), 3 deletions(-)

diff --git a/usr/src/lib/brand/bhyve/zone/boot.c b/usr/src/lib/brand/bhyve/zone/boot.c
index 58160a88cc..5d0b0a8eac 100644
--- a/usr/src/lib/brand/bhyve/zone/boot.c
+++ b/usr/src/lib/brand/bhyve/zone/boot.c
@@ -180,6 +180,14 @@ add_ram(int *argc, char **argv)
 	return (0);
 }
 
+/*
+ * In the initial implementation, slot assignment was dynamic on every boot.
+ * Now, each device resource can have a pci_slot property that will override
+ * dyanmic assignment.  The original behavior is preserved, but no effort is
+ * made to detect or avoid conflicts between legacy behavior and new behavior.
+ * When used with vmadm this is not an issue, as it will update the zone config
+ * at boot time to contain static assignments.
+ */
 static int
 add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 {
@@ -189,6 +197,10 @@ add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 	const char *model = "virtio-blk";
 	int pcislot;
 	int pcifn;
+	const char *slotstr;
+	char slotbuf[16];
+
+	slotstr = get_zcfg_var("device", disk, "pci_slot");
 
 	/* Allow at most one "primary" disk */
 	if (is_env_true("device", disk, "boot")) {
@@ -210,7 +222,6 @@ add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 		next_other++;
 	}
 
-
 	if (is_env_string("device", disk, "model", "virtio")) {
 		model = "virtio-blk";
 	} else if (is_env_string("device", disk, "model", "ahci")) {
@@ -224,8 +235,14 @@ add_disk(char *disk, char *path, char *slotconf, size_t slotconf_len)
 		return (-1);
 	}
 
-	if (snprintf(slotconf, slotconf_len, "%d:%d,%s,%s",
-	    pcislot, pcifn, model, path) >= slotconf_len) {
+	if (slotstr == NULL) {
+		(void) snprintf(slotbuf, sizeof (slotbuf), "%d:%d",
+		    pcislot, pcifn);
+		slotstr = slotbuf;
+	}
+
+	if (snprintf(slotconf, slotconf_len, "%s,%s,%s",
+	    slotstr, model, path) >= slotconf_len) {
 		(void) printf("Error: disk path '%s' too long\n", path);
 		return (-1);
 	}
-- 
2.21.0

