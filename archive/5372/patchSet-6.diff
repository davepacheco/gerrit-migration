commit a3d8d55408e6e093f6d621601a82a1a9841d8952 (refs/changes/72/5372/6)
Author: Hans Rosenfeld <hans.rosenfeld@joyent.com>
Date:   2019-02-13T15:08:50+00:00 (8 months ago)
    
    OS-7508 mdb: assertion tripped in libvmm when bhyve VM halts while mdb is attached
    OS-7519 mdb: bhyve target can attach before the first vCPU is configured

diff --git a/usr/src/cmd/mdb/intel/mdb/mdb_bhyve.c b/usr/src/cmd/mdb/intel/mdb/mdb_bhyve.c
index 1bfd8416c4..2bcf7f233f 100644
--- a/usr/src/cmd/mdb/intel/mdb/mdb_bhyve.c
+++ b/usr/src/cmd/mdb/intel/mdb/mdb_bhyve.c
@@ -911,8 +911,8 @@ bhyve_setflags(mdb_tgt_t *tgt, int flags)
 static void
 bhyve_activate(mdb_tgt_t *tgt)
 {
+	mdb_tgt_status_t *tsp = &tgt->t_status;
 	bhyve_data_t *bd = tgt->t_data;
-	mdb_tgt_status_t tsp;
 	const char *format;
 	char buf[BUFSIZ];
 
@@ -921,19 +921,19 @@ bhyve_activate(mdb_tgt_t *tgt)
 	(void) mdb_tgt_register_dcmds(tgt, bhyve_dcmds, MDB_MOD_FORCE);
 	mdb_tgt_register_regvars(tgt, bhyve_kregs, &bhyve_reg_disc, 0);
 
-	vmm_stop(bd->bd_vmm);
+	(void) vmm_stop(bd->bd_vmm);
 
-	if (mdb_tgt_status(tgt, &tsp) != 0)
+	if (mdb_tgt_status(tgt, tsp) != 0)
 		return;
 
-	if (tsp.st_pc != 0) {
+	if (tsp->st_pc != 0) {
 		if (mdb_dis_ins2str(mdb.m_disasm, mdb.m_target,
-		    MDB_TGT_AS_VIRT_I, buf, sizeof (buf), tsp.st_pc) !=
-		    tsp.st_pc)
+		    MDB_TGT_AS_VIRT_I, buf, sizeof (buf), tsp->st_pc) !=
+		    tsp->st_pc)
 			format = "target stopped at:\n%-#16a%8T%s\n";
 		else
 			format = "target stopped at %a:\n";
-		mdb_warn(format, tsp.st_pc, buf);
+		mdb_warn(format, tsp->st_pc, buf);
 	}
 }
 
@@ -963,7 +963,7 @@ bhyve_deactivate(mdb_tgt_t *tgt)
 		if (mdb_module_remove_dcmd(tgt->t_module, dc->dc_name) == -1)
 			mdb_warn("failed to remove dcmd %s", dc->dc_name);
 
-	vmm_cont(bd->bd_vmm);
+	(void) vmm_cont(bd->bd_vmm);
 }
 
 /*
@@ -985,7 +985,7 @@ bhyve_destroy(mdb_tgt_t *tgt)
 {
 	bhyve_data_t *bd = tgt->t_data;
 
-	vmm_cont(bd->bd_vmm);
+	(void) vmm_cont(bd->bd_vmm);
 	vmm_unmap(bd->bd_vmm);
 	vmm_close_vm(bd->bd_vmm);
 	mdb_free(bd, sizeof (bhyve_data_t));
@@ -1249,11 +1249,17 @@ bhyve_status(mdb_tgt_t *tgt, mdb_tgt_status_t *tsp)
 static void
 bhyve_sighdl(int sig, siginfo_t *sip, ucontext_t *ucp, mdb_tgt_t *tgt)
 {
+	mdb_tgt_status_t *tsp = &tgt->t_status;
 	bhyve_data_t *bd = tgt->t_data;
 
 	switch (sig) {
 	case SIGINT:
-		vmm_stop(bd->bd_vmm);
+		/*
+		 * vmm_stop() may fail if the VM was destroyed while we were
+		 * waiting. This will be handled by mdb_tgt_status().
+		 */
+		(void) vmm_stop(bd->bd_vmm);
+		(void) mdb_tgt_status(tgt, tsp);
 		break;
 	}
 }
@@ -1289,7 +1295,10 @@ bhyve_cont(mdb_tgt_t *tgt, mdb_tgt_status_t *tsp)
 	intf = mdb_signal_gethandler(SIGINT, &intd);
 	(void) mdb_signal_sethandler(SIGINT, (mdb_signal_f *)bhyve_sighdl, tgt);
 
-	vmm_cont(bd->bd_vmm);
+	if (ret = vmm_cont(bd->bd_vmm) != 0) {
+		mdb_warn("failed to continue target execution: %d", ret);
+		return (set_errno(EMDB_TGT));
+	}
 
 	tsp->st_state = MDB_TGT_RUNNING;
 	pause();
diff --git a/usr/src/lib/libvmm/libvmm.c b/usr/src/lib/libvmm/libvmm.c
index 373dfe2844..8c8e32c9f3 100644
--- a/usr/src/lib/libvmm/libvmm.c
+++ b/usr/src/lib/libvmm/libvmm.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -30,6 +30,7 @@
 #include <errno.h>
 #include <stdlib.h>
 #include <strings.h>
+#include <unistd.h>
 #include <assert.h>
 
 #include <machine/vmm.h>
@@ -104,6 +105,18 @@ vmm_open_vm(const char *name)
 
 	vmm_update_ncpu(vmm);
 
+	/*
+	 * If we open a VM that has just been created we may see a state
+	 * where it has no CPUs configured yet. We'll just wait for 10ms
+	 * and retry until we get a non-zero CPU count.
+	 */
+	if (vmm->vmm_ncpu == 0) {
+		do {
+			(void) usleep(10000);
+			vmm_update_ncpu(vmm);
+		} while (vmm->vmm_ncpu == 0);
+	}
+
 	return (vmm);
 }
 
@@ -304,10 +317,10 @@ vmm_memsize(vmm_t *vmm)
 	return (vmm->vmm_memsize);
 }
 
-void
+int
 vmm_cont(vmm_t *vmm)
 {
-	assert(vm_resume_cpu(vmm->vmm_ctx, -1) == 0);
+	return (vm_resume_cpu(vmm->vmm_ctx, -1));
 }
 
 int
@@ -336,12 +349,15 @@ vmm_step(vmm_t *vmm, int vcpu)
 	return (ret);
 }
 
-void
+int
 vmm_stop(vmm_t *vmm)
 {
-	assert(vm_suspend_cpu(vmm->vmm_ctx, -1) == 0);
+	int ret = vm_suspend_cpu(vmm->vmm_ctx, -1);
 
-	vmm_update_ncpu(vmm);
+	if (ret == 0)
+		vmm_update_ncpu(vmm);
+
+	return (ret);
 }
 
 /*
diff --git a/usr/src/lib/libvmm/libvmm.h b/usr/src/lib/libvmm/libvmm.h
index 49a721b486..352b09e970 100644
--- a/usr/src/lib/libvmm/libvmm.h
+++ b/usr/src/lib/libvmm/libvmm.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #ifndef _LIBVMM_H
@@ -98,9 +98,9 @@ ssize_t vmm_vwrite(vmm_t *, int, int, const void *, size_t, uintptr_t);
 size_t vmm_ncpu(vmm_t *);
 size_t vmm_memsize(vmm_t *);
 
-void vmm_cont(vmm_t *);
+int vmm_cont(vmm_t *);
 int vmm_step(vmm_t *, int);
-void vmm_stop(vmm_t *);
+int vmm_stop(vmm_t *);
 
 int vmm_getreg(vmm_t *, int, int, uint64_t *);
 int vmm_setreg(vmm_t *, int, int, uint64_t);
