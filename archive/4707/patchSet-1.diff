commit 0366b7a103052f1670ea471c8c3e530401790840 (refs/changes/07/4707/1)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2018-08-16T18:27:54-04:00 (1 year, 2 months ago)
    
    joyent/node-manta#61 msign should allow for friendlier expiry date formats

diff --git a/bin/msign b/bin/msign
index 6cd1ca0..64d67da 100755
--- a/bin/msign
+++ b/bin/msign
@@ -26,7 +26,12 @@ function optionsParser(name) {
                 names: ['expires', 'e'],
                 type: 'positiveInteger',
                 help: 'expiration time (epoch). Default is 1hr from now.',
-                'default': Math.floor((new Date().getTime() / 1000) + 3600),
+                helpArg: 'EXPIRATION'
+            },
+            {
+                names: ['expires-relative', 'E'],
+                type: 'string',
+                help: 'expiration time (relative). Default is 1h from now.',
                 helpArg: 'EXPIRATION'
             },
             {
@@ -126,13 +131,58 @@ function parseCmdOptions(opts, parser) {
     } catch (e) {
         ifError(e);
     }
+
+    if (opts.hasOwnProperty('expires') &&
+        opts.hasOwnProperty('expires_relative')) {
+
+        ifError(new Error('-e and -E cannot be specified together'));
+    }
+
+    // normalize expires (-e and -E) options
+    var expires = Math.floor((new Date().getTime() / 1000) + 3600)
+
+    if (opts.hasOwnProperty('expires_relative')) {
+        var match = opts.expires_relative.match(/^([0-9]+)([smhdwy])$/);
+        if (!match) {
+            // error
+            ifError(new Error('invalid expires: ' + opts.expires_relative));
+        }
+        var now = Math.floor(Date.now() / 1000);
+        var num = parseInt(match[1], 10);
+        switch (match[2]) {
+        case 's':
+            expires = now + (num);
+            break;
+        case 'm':
+            expires = now + (num * 60);
+            break;
+        case 'h':
+            expires = now + (num * 60 * 60);
+            break;
+        case 'd':
+            expires = now + (num * 60 * 60 * 24);
+            break;
+        case 'w':
+            expires = now + (num * 60 * 60 * 24 * 7);
+            break;
+        case 'y':
+            expires = now + (num * 60 * 60 * 24 * 365);
+            break;
+        default:
+            ifError(new Error('invalid expires: ' + opts.expires));
+            break;
+        }
+    } else if (opts.hasOwnProperty('expires')) {
+        expires = opts.expires;
+    }
+
     opts.paths.forEach(function (p) {
 
         ifError(manta.assertPath(p, true));
 
         var _opts = {
             algorithm: opts.algorithm,
-            expires: opts.expires,
+            expires: expires,
             host: url.parse(opts.url).host,
             keyId: opts.keyId,
             log: opts.log,
diff --git a/man/man1/msign.1 b/man/man1/msign.1
index a8d9b72..33b8825 100644
--- a/man/man1/msign.1
+++ b/man/man1/msign.1
@@ -43,6 +43,24 @@ Authenticate as account (login name).
 Signed URL should last until EXPIRATION (seconds since epoch).  Default is 1
 hour from \fB\fCnow\fR\&.
 .TP
+\fB\fC\-E, \-\-expires-relative expiration\fR
+Signed URL should until EXPIRATION from now.  Default is 1 hour from
+\fB\fCnow\fR\&.  Valid arguments are:
+.RS
+.IP \fB[n]s\fP
+n seconds from now
+.IP \fB[n]m\fP
+n minutes from now
+.IP \fB[n]h\fP
+n hours from now
+.IP \fB[n]d\fP
+n days from now
+.IP \fB[n]w\fP
+n weeks from now
+.IP \fB[n]y\fP
+n years from now
+.RE
+.TP
 \fB\fC\-h, \-\-help\fR
 Print a help message and exit.
 .TP
diff --git a/test/msign.test.js b/test/msign.test.js
new file mode 100644
index 0000000..84d3109
--- /dev/null
+++ b/test/msign.test.js
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * Test `msign`.
+ */
+
+var f = require('util').format;
+var forkExecWait = require('forkexec').forkExecWait;
+var path = require('path');
+var url = require('url');
+
+// ---- globals
+
+var BINDIR = path.resolve(__dirname, '../bin');
+var MSIGN = path.resolve(BINDIR, 'msign');
+
+// This doesn't really matter - msign doesn't check to see if the object exists
+var PATH = '~~/stor/foo';
+
+// ---- helper functions
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+
+// ---- tests
+
+test('msign (no arguments)', function (t) {
+    forkExecWait({
+        argv: [MSIGN]
+    }, function (err, info) {
+        t.ok(err, 'msign should fail');
+        t.ok(/^path required/m.test(info.stderr), 'path required in stderr');
+        t.done();
+    });
+});
+
+test(f('msign %s', PATH), function (t) {
+    var mantaUrl = process.env.MANTA_URL;
+
+    forkExecWait({
+        argv: [MSIGN, PATH]
+    }, function (err, info) {
+        t.ifError(err, err);
+
+        // should be a signed URL
+        var uri = info.stdout.trim();
+
+        t.ok(uri.length > mantaUrl.length, 'uri.length > mantaUrl.length');
+        t.equal(uri.slice(0, mantaUrl.length), mantaUrl, 'base URL correct');
+
+        // ensure query paramaters are present that we expect
+        var signed = url.parse(uri, true);
+        var q = signed.query;
+        t.ok(q, 'query');
+        t.ok(q.signature, 'signature');
+        t.ok(q.algorithm, 'algorithm');
+        t.ok(q.expires, 'expires');
+        t.ok(q.keyId, 'keyId');
+
+        t.done();
+    });
+});
+
+test(f('msign -e <expires> %s', PATH), function (t) {
+    // 1 minute from now
+    var expires = Math.floor(Date.now() / 1000) + 60;
+
+    forkExecWait({
+        argv: [MSIGN, '-e', expires.toString(), PATH]
+    }, function (err, info) {
+        t.ifError(err, err);
+
+        var uri = info.stdout.trim();
+        var signed = url.parse(uri, true);
+        var q = signed.query;
+
+        t.ok(q, 'query');
+        t.equal(q.expires, expires, 'expires');
+
+        t.done();
+    });
+});
+
+test(f('msign -E 1h %s', PATH), function (t) {
+    // 1 hour from now
+    var expires = Math.floor(Date.now() / 1000) + (1 * 60 * 60);
+
+    forkExecWait({
+        argv: [MSIGN, '-E', '1h', PATH]
+    }, function (err, info) {
+        t.ifError(err, err);
+
+        var uri = info.stdout.trim();
+        var signed = url.parse(uri, true);
+        var q = signed.query;
+
+        /*
+         * Because there is some time from when we get the current time in this
+         * test, to when `msign` gets the current time, it is possible that the
+         * expires date set by `msign` will be a couple seconds ahead of us, so
+         * allow for a slight variance.
+         */
+        t.ok(q.expires >= expires, 'q.expires >= expires');
+        t.ok(q.expires < expires + 5, 'q.expires < expires + 5');
+
+        t.done();
+    });
+});
+
+[
+    '1s',
+    '1m',
+    '1h',
+    '1d',
+    '1w',
+    '1y'
+].forEach(function (expires) {
+    test(f('msign -E %s %s (good argument)', expires, PATH), function (t) {
+        forkExecWait({
+            argv: [MSIGN, '-E', expires, PATH]
+        }, function (err, info) {
+            t.ifError(err, err);
+            t.done();
+        });
+    });
+});
+
+test(f('msign -E foo %s (bad argument)', PATH), function (t) {
+    forkExecWait({
+        argv: [MSIGN, '-E', 'foo', PATH]
+    }, function (err, info) {
+        t.ok(err, 'msign should fail');
+        t.ok(/invalid expires: foo/m.test(info.stderr),
+            'invalid expires in stderr');
+        t.done();
+    });
+});
+
+test('msign -E and -e together', function (t) {
+    forkExecWait({
+        argv: [MSIGN, '-E', '1h', '-e', '1234567', PATH]
+    }, function (err, info) {
+        t.ok(err, 'msign should fail');
+        t.ok(/-e and -E cannot be specified together/m.test(info.stderr),
+            '-e and -E cannot be specified together in stderr');
+        t.done();
+    });
+});
