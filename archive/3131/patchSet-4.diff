commit fc58d2ece5c1a6e93fc933159da0550ba9d8db23 (refs/changes/31/3131/4)
Author: Mike Zeller <mike.zeller@joyent.com>
Date:   2017-12-29T16:30:12-08:00 (1 year, 9 months ago)
    
    PUBAPI-1081 Enable requesting IP addresses on networks when provisioning or adding nics

diff --git a/lib/errors.js b/lib/errors.js
index 5f3f6a1..d08f891 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -303,6 +303,34 @@ function vmapiErrorWrap(cause, message) {
     }
 }
 
+/**
+ * Selectively expose some NAPI error details via a whitelist on restCode.
+ * Other NAPI error codes are wrapped such that the error is *logged*, but
+ * only the `statusCode` is exposed.
+ *
+ * Usage:
+ *      next(new errors.napiErrorWrap(err, 'error creating NIC'));
+ */
+function napiErrorWrap(cause, message) {
+    assert.object(cause, 'cause');
+    assert.string(message, 'message');
+
+    if (!cause) {
+        return cause;
+    } else if (!cause.restCode) {
+        return new CloudApiError(cause, message);
+    }
+
+    switch (cause.restCode) {
+        case 'ResourceNotFound':
+            return new ExposedSDCError(cause, message);
+
+        /* By default don't expose internal error message details. */
+        default:
+            return new CloudApiError(cause, message);
+    }
+}
+
 /**
  * Selectively expose some VOLAPI error details via a whitelist on restCode.
  * Other VOLAPI error codes are wrapped such that the error is *logged*, but
@@ -369,6 +397,7 @@ module.exports = {
 
     // Internal SDC API wrappers
     vmapiErrorWrap: vmapiErrorWrap,
+    napiErrorWrap: napiErrorWrap,
     volapiErrorWrap: volapiErrorWrap,
 
     // Utility functions
diff --git a/lib/machines.js b/lib/machines.js
index 9708248..d60a293 100644
--- a/lib/machines.js
+++ b/lib/machines.js
@@ -29,6 +29,7 @@ var membership = require('./membership'),
     preloadGroups = membership.preloadGroups;
 var triton_affinity = require('./triton-affinity');
 var volumeValidation = require('./validation/volumes');
+var networkValidation = require('./validation/networks');
 
 
 // --- Globals
@@ -443,26 +444,28 @@ function getCreateOptions(req) {
 
             if (objectsAllowed) {
                 switch (netType) {
-                    case 'string':
-                        ifaceObjects++;
-                        break;
-                    case 'object':
-                        ifaceObjects++;
-                        netUuid = netObj.ipv4_uuid;
-
-                        if (typeof (netUuid) !== 'string') {
-                            throw new InvalidArgumentError(sprintf(
-                                'property "networks[%d].ipv4_uuid": ' +
-                                'string expected', idx));
-                        }
+                case 'string':
+                    ifaceObjects++;
+                    break;
+                case 'object':
+                    ifaceObjects++;
+
+                    var networkObjErr = networkValidation.validateNetworkObject(
+                        netObj, req.networks);
+
+                    if (networkObjErr) {
+                        throw networkObjErr;
+                    }
 
-                        break;
-                    default:
-                        // the 'property "foo" ...' format intended to match
-                        // the json-schema error format:
-                        throw new InvalidArgumentError(sprintf(
-                            'property "networks[%d]": array of strings or ' +
-                            'objects expected', idx));
+                    netUuid = netObj.ipv4_uuid;
+
+                    break;
+                default:
+                    // the 'property "foo" ...' format intended to match
+                    // the json-schema error format:
+                    throw new InvalidArgumentError(sprintf(
+                        'property "networks[%d]": array of strings or ' +
+                        'objects expected', idx));
                 }
 
             } else {
@@ -472,6 +475,8 @@ function getCreateOptions(req) {
                 }
             }
 
+            assert.uuid(netUuid, 'netUuid');
+
             if (alreadyAdded[netUuid]) {
                 return false;
             }
@@ -526,13 +531,21 @@ function getCreateOptions(req) {
 
     opts.networks = networkUuids;
     if (typeof (networkUuids[0]) === 'object') {
-        // We only support ipv4_uuid and ipv4_count for now, so only allow
-        // them, just to be safe:
+        // We only support ipv4_uuid, and ipv4_ips for now, so only allow them,
+        // just to be safe:
         opts.networks = opts.networks.map(function (n) {
-            return {
-                ipv4_count: n.ipv4_count || 1,
-                ipv4_uuid: n.ipv4_uuid
-            };
+            var netObj = {};
+
+            // If a user doesn't specify ipv4_ips we tell vmapi to only give us
+            // a single ip. Multiple IPs per network will also be supported one
+            // day
+            if (!n.ipv4_ips) {
+                netObj.ipv4_count = n.ipv4_count || 1;
+            }
+
+            netObj.ipv4_uuid = n.ipv4_uuid;
+            netObj.ipv4_ips = n.ipv4_ips;
+            return netObj;
         });
 
     } else {
@@ -1463,6 +1476,46 @@ function create(req, res, next) {
         });
     }
 
+    /*
+     * We need to verify that if a user passed in networks with IPs that none
+     * of the IPs are considered "managed".  NAPI will handle other validations
+     * for us.
+     */
+    var networksWithIps = [];
+    opts.networks.forEach(function (net) {
+        // Today we only support passing in ipv4 addrs,
+        // but this should be extended to support ipv6 addrs
+        if (net.ipv4_ips && net.ipv4_ips.length > 0) {
+            networksWithIps.push(net);
+        }
+    });
+
+    if (networksWithIps.length > 0) {
+        pipeline.push(function validateIps(_, cb) {
+            function validateIp(network, done) {
+                req.sdc.napi.getIP(network.ipv4_uuid, network.ipv4_ips[0],
+                    function napiGetIp(err, ip) {
+                    if (err) {
+                        done(err);
+                        return;
+                    }
+                    if (ip.belongs_to_type === 'other' ||
+                        ip.owner_uuid === req.config.ufds_admin_uuid) {
+                        done(new InvalidArgumentError('cannot use %s because' +
+                            ' its a managed ip', ip.ip));
+                        return;
+                    }
+                    done(null, ip);
+                });
+            }
+
+            vasync.forEachPipeline({
+                func: validateIp,
+                inputs: networksWithIps
+            }, cb);
+        });
+    }
+
 
     pipeline.push(function (_, cb) {
         return req.sdc.vmapi.createVm(opts, {
@@ -1478,7 +1531,7 @@ function create(req, res, next) {
                 var body = err.body;
                 var msgs = [];
                 if (body.code && body.code === 'ValidationFailed' &&
-                    body.errors.length) {
+                    body.errors.length > 0) {
                     body.errors.forEach(function (e) {
                         if (e.field === 'alias') {
                             msgs.push('Invalid machine name');
@@ -1491,6 +1544,15 @@ function create(req, res, next) {
                             msgs.push('Invalid ' + e.field);
                         }
                     });
+                } else if (body.code && body.code === 'InvalidParameters' &&
+                    body.errors.length > 0) {
+                    body.errors.forEach(function forEachError(e) {
+                        if (e.field === 'ip' && e.code === 'UsedBy') {
+                            // when NAPI-438 is finished we should report back
+                            // the IP
+                            err = new InvalidArgumentError(err, 'ip in use');
+                        }
+                    });
                 }
 
                 if (msgs.length) {
diff --git a/lib/nics.js b/lib/nics.js
index 2f8c8a2..6468f42 100644
--- a/lib/nics.js
+++ b/lib/nics.js
@@ -45,6 +45,8 @@ var assert  = require('assert-plus');
 var restify = require('restify');
 var vasync  = require('vasync');
 
+var errors = require('./errors');
+var networkValidation = require('./validation/networks');
 
 
 // --- Globals
@@ -68,12 +70,12 @@ var MAC_RE  = /^[0-9a-f]{12}/i;
 /*
  * Add a NIC to a VM.
  *
- * A network UUID is passed in as an argument, which we need to look up in NAPI
- * in order to find out the nic tag associated with that network or network
- * pool. We then check that there isn't already another NIC on that VM with that
- * network -- if there is, we 302 redirect to that NIC. We also need to check
- * that the server has an appropriate nic tag, otherwise adding that network to
- * the VM will not work.
+ * AddNic accepts a single network UUID or a single network object as an
+ * argument, which we need to look up in NAPI in order to find out the nic tag
+ * associated with that network or network pool. We then check that there isn't
+ * already another NIC on that VM with that network -- if there is, we 302
+ * redirect to that NIC. We also need to check that the server has an
+ * appropriate nic tag, otherwise adding that network to the VM will not work.
  *
  * Fabric networks are treated differently; instead of looking up the network
  * nic_tag in NAPI, we check the server's sysinfo for virtual network interfaces
@@ -104,20 +106,69 @@ function addNic(req, res, next) {
     var serverUuid  = req.vm.server_uuid;
     var ownerUuid   = req.account.uuid;
     var login       = req.account.login;
-    var networkUuid = req.params.network;
+    var networkArg  = req.params.network;
     var origin      = req.params.origin || 'cloudapi';
     var context = {
         caller: req._auditCtx,
         params: req.params
     };
 
-    if (!networkUuid) {
+    if (!networkArg) {
         return next(new MissingParameterError('network must be specified'));
     }
 
-    if (typeof (networkUuid) !== 'string' || !networkUuid.match(UUID_RE)) {
-        var errMsg = 'network argument has invalid format';
-        return next(new InvalidArgumentError(errMsg));
+    /*
+     * With the push to use interface-centric provisioning across the stack
+     * we want AddNic to be able to accept the new style payload which looks
+     * like:
+     *
+     * [
+     *   {
+     *     ipv4_uuid: uuid_0, ipv4_count: <number>,
+     *     ipv4_ips: [ ip0, ip1, ... ],
+     *     ipv6_uuid: uuid_1, ipv6_count: <number>,
+     *     ipv6_ips: [ ip0, ip1, ... ],
+     *     primary: true
+     *   }, ...
+     * ]
+     *
+     * At this point in time AddNic will only accept a single interface
+     * object that contains a single ipv4_uuid. In addition to the network
+     * uuid we also allow the user to pass in an optional ipv4_ips array
+     * consisting of a single IP. In the future when napi fully supports having
+     * NICs with multiple IPs this will likely be extended to allow the array to
+     * contain multiple IPs.
+     *
+     * Once ZAPI-816 is rolled out everywhere, we would also like to support
+     * specifying that the new NIC should be the primary via the primaryIp flag.
+     * In addtion we will also be able to make a vmapi call directly without
+     * having to first create the NIC up front.
+     */
+    var networkUuid, networkIp;
+
+    // Make sure we have a single network uuid, or a single network object
+    switch (typeof (networkArg)) {
+    case 'string':
+        if (!networkArg.match(UUID_RE)) {
+            return next(new InvalidArgumentError(
+                'network argument has invalid format'));
+        }
+        networkUuid = networkArg;
+        break;
+    case 'object':
+        var networkObjErr = networkValidation.validateNetworkObject(networkArg,
+            req.networks);
+
+        if (networkObjErr) {
+            return next(networkObjErr);
+        }
+
+        networkUuid = networkArg.ipv4_uuid;
+        networkIp = networkArg.ipv4_ips[0];
+        break;
+    default:
+        return next(new InvalidArgumentError(
+            'network argument must be a network object or string'));
     }
 
     var network, nic;  // filled in by the vasync-called functions
@@ -298,7 +349,9 @@ function addNic(req, res, next) {
     }
 
     function addToNapi(_, cb) {
-        req.sdc.napi.provisionNic(network.uuid, {
+        var pipeline = [];
+
+        var params = {
             belongs_to_uuid: vmUuid,
             belongs_to_type: 'zone',
             cn_uuid: serverUuid,
@@ -306,19 +359,68 @@ function addNic(req, res, next) {
             state: 'provisioning',
             origin: origin,
             context: context
-        }, {
-            log: log,
-            headers: headers
-        }, function (err, _nic) {
-            if (err) {
-                return cb(err);
-            }
+        };
 
-            nic = _nic;
-            log.debug(nic, 'Added NIC to NAPI');
+        function validateIp(__, done) {
+            assert.string(networkIp, 'networkIp');
 
-            return cb();
-        });
+            req.sdc.napi.getIP(network.uuid, networkIp,
+                function napiGetIp(err, ip) {
+                if (err) {
+                    done(errors.napiErrorWrap(err, 'cannot provision ip'));
+                    return;
+                }
+                if (ip.belongs_to_type === 'other' ||
+                    ip.owner_uuid === req.config.ufds_admin_uuid) {
+                    done(new InvalidArgumentError('cannot use %s because' +
+                        ' it is a managed ip', ip.ip));
+                    return;
+                }
+                done(null, ip);
+            });
+        }
+
+        if (networkIp) {
+            params.ip = networkIp;
+            pipeline.push(validateIp);
+        }
+
+        function provisionNic(__, done) {
+            req.sdc.napi.provisionNic(network.uuid, params, {
+                log: log,
+                headers: headers
+            }, function napiProvisionNic(err, _nic) {
+                if (err) {
+                    var body = err.body;
+                    if (body.code && body.code === 'InvalidParameters' &&
+                        body.errors.length > 0) {
+                        body.errors.forEach(function forEachError(e) {
+                            if (e.field === 'ip' && e.code === 'UsedBy') {
+                                // when NAPI-438 is finished we should report
+                                // back the IP
+                                err = new InvalidArgumentError(err,
+                                    'ip in use');
+                            }
+                        });
+
+                    }
+
+                    done(err);
+                    return;
+                }
+
+                nic = _nic;
+                log.info(nic, 'Added NIC to NAPI');
+
+                done();
+            });
+        }
+
+        pipeline.push(provisionNic);
+
+        vasync.pipeline({
+            funcs: pipeline
+        }, cb);
     }
 
     // if the addToVm() call below failed, we need to clean up the NIC in NAPI
diff --git a/lib/validation/networks.js b/lib/validation/networks.js
new file mode 100644
index 0000000..5808406
--- /dev/null
+++ b/lib/validation/networks.js
@@ -0,0 +1,91 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var restify = require('restify');
+var util = require('util');
+
+var InvalidArgumentError  = restify.InvalidArgumentError;
+var MissingParameterError = restify.MissingParameterError;
+var ResourceNotFoundError = restify.ResourceNotFoundError;
+
+var UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
+
+function validateNetworkObject(netObj, networks) {
+    assert.object(netObj, 'netObj');
+    assert.arrayOfObject(networks, 'networks');
+
+    var ipv4_uuid = netObj.ipv4_uuid;
+    var ipv4_ips = netObj.ipv4_ips;
+
+    if (!ipv4_uuid) {
+        return new MissingParameterError('network objects must contain' +
+            ' ipv4_uuid');
+    }
+
+    if (typeof (ipv4_uuid) !== 'string') {
+        return new InvalidArgumentError('ipv4_uuid must be a string');
+    }
+
+    if (!ipv4_uuid.match(UUID_RE)) {
+        return new InvalidArgumentError(util.format('ipv4_uuid: %s is not a' +
+            ' uuid', ipv4_uuid));
+    }
+
+    if (ipv4_ips) {
+        if (!Array.isArray(ipv4_ips)) {
+            return new InvalidArgumentError('ipv4_ips must be an array with a' +
+                ' single IP');
+        }
+
+        if (ipv4_ips.length > 1) {
+            return  new InvalidArgumentError(util.format('ipv4_ips: network' +
+                ' with ipv4_uuid %s should contain a single IP' +
+                ' array', ipv4_uuid));
+        }
+
+        if (typeof (ipv4_ips[0]) !== 'string') {
+            return new InvalidArgumentError('ipv4_ips[0]: string expected');
+        }
+
+        /*
+         * We need to verify the following up front:
+         * - The network is within the users networks
+         * - The network is not a pool
+         * - The network is not public
+         */
+        var net = networks.find(
+            function checkForNetwork(n) {
+            return n.uuid === ipv4_uuid;
+        });
+
+        if (!net) {
+            return new ResourceNotFoundError(util.format(
+                'ipv4_uuid: network %s not found', ipv4_uuid));
+        }
+
+        if (Array.isArray(net.networks)) {
+            return new InvalidArgumentError(util.format('ipv4_uuid: %s cannot' +
+                ' specify IP on a network pool', ipv4_uuid));
+        }
+
+        if (!net.hasOwnProperty('owner_uuids')) {
+            return new InvalidArgumentError(util.format('ipv4_uuid: %s cannot' +
+                ' specify IP on a public network', ipv4_uuid));
+        }
+    }
+
+    return null;
+}
+
+
+module.exports = {
+    validateNetworkObject: validateNetworkObject
+};
diff --git a/test/machines.70.test.js b/test/machines.70.test.js
index 5e9e8f6..fc36495 100644
--- a/test/machines.70.test.js
+++ b/test/machines.70.test.js
@@ -136,7 +136,6 @@ test('CreateMachine', function (t) {
     });
 });
 
-
 test('Wait For Running', function (t) {
     machinesCommon.waitForRunningMachine(CLIENT, MACHINE_UUID, function (err) {
         t.ifError(err);
diff --git a/test/machines.test.js b/test/machines.test.js
index 6c60b29..ecda906 100644
--- a/test/machines.test.js
+++ b/test/machines.test.js
@@ -9,8 +9,10 @@
  */
 
 var util = require('util');
+
 var test = require('tape').test;
 var restify = require('restify');
+var vasync = require('vasync');
 var common = require('./common');
 var uuid = common.uuid;
 var addPackage = common.addPackage;
@@ -89,6 +91,8 @@ var SDC_512 = {
 var SERVER_UUID;
 var IMAGE_UUID;
 var MACHINE_UUID;
+var NETWORK_UUID;
+var NETWORK_IP = '10.99.66.50';
 
 var CLIENTS;
 var CLIENT;
@@ -332,9 +336,10 @@ test('CreateMachine using network without permissions', function (t) {
 
         vmDetails.networks = [net.uuid];
 
-        CLIENT.post('/my/machines', vmDetails, function (err2, req, res, body) {
-            t.ok(err2);
-            t.equal(err2.statusCode, 409);
+        CLIENT.post('/my/machines', vmDetails, function (machineCreateErr, req,
+            res, body) {
+            t.ok(machineCreateErr);
+            t.equal(machineCreateErr.statusCode, 409);
             t.deepEqual(body, {
                 code: 'InvalidArgument',
                 message: 'Invalid Networks'
@@ -349,6 +354,230 @@ test('CreateMachine using network without permissions', function (t) {
 });
 
 
+test('CreateMachine using public network and ip', function (t) {
+    var netDetails = {
+        name: 'machines-test-network-fake-public',
+        vlan_id: 99,
+        subnet: '10.99.66.0/24',
+        provision_start_ip: '10.99.66.5',
+        provision_end_ip: '10.99.66.250',
+        nic_tag: 'external',
+        owner_uuids: []
+    };
+
+    var vmDetails = {
+        image: IMAGE_UUID,
+        package: SDC_256.name,
+        server_uuid: SERVER_UUID
+    };
+
+    CLIENT.napi.createNetwork(netDetails, function (err, net) {
+        t.ifError(err);
+
+        vmDetails.networks = [
+            {
+                ipv4_uuid: net.uuid,
+                ipv4_ips: ['10.99.66.10']
+            }
+        ];
+
+        CLIENT.post('/my/machines', vmDetails, function (machineCreateErr, req,
+            res, body) {
+            t.ok(machineCreateErr);
+            t.equal(machineCreateErr.statusCode, 409);
+            t.deepEqual(body, {
+                code: 'InvalidArgument',
+                message: 'property networks[0].ipv4_uuid: cannot specify an' +
+                    ' IP on a public network'
+            });
+
+            CLIENT.napi.deleteNetwork(net.uuid, {},
+                function napiDeleteNetwork(networkDelErr) {
+                t.ifError(networkDelErr);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('CreateMachine using unknown network and an ip', function (t) {
+    var networkUuid = 'd674f27a-e695-11e7-8490-001fc69cf4fd';
+    var vmDetails = {
+        image: IMAGE_UUID,
+        package: SDC_256.name,
+        server_uuid: SERVER_UUID,
+        networks: [
+            {
+                ipv4_uuid: networkUuid,
+                // IP set to any value just for this test
+                ipv4_ips: ['10.99.66.10']
+            }
+        ]
+    };
+
+    CLIENT.post('/my/machines', vmDetails, function (machineCreateErr, req, res,
+        body) {
+        t.ok(machineCreateErr);
+        t.equal(machineCreateErr.statusCode, 404);
+        t.deepEqual(body, {
+            code: 'ResourceNotFound',
+            message: 'property networks[0].ipv4_uuid: ' +
+                'network ' + networkUuid + ' not found'
+        });
+
+        t.end();
+    });
+});
+
+
+test('CreateMachine using network and invalid number of ips', function (t) {
+    var networkUuid = 'd674f27a-e695-11e7-8490-001fc69cf4fd';
+    var vmDetails = {
+        image: IMAGE_UUID,
+        package: SDC_256.name,
+        server_uuid: SERVER_UUID,
+        networks: [
+            {
+                ipv4_uuid: networkUuid,
+                // IP set to any value just for this test
+                ipv4_ips: ['10.99.66.10', '10.99.66.10']
+            }
+        ]
+    };
+
+    CLIENT.post('/my/machines', vmDetails, function (machineCreateErr, req, res,
+        body) {
+        t.ok(machineCreateErr);
+        t.equal(machineCreateErr.statusCode, 409);
+        t.deepEqual(body, {
+            code: 'InvalidArgument',
+            message: 'property networks[0].ipv4_ips: ' +
+                'array should contain single ip'
+        });
+
+        t.end();
+    });
+});
+
+
+test('CreateMachine using network pool and an ip', function (t) {
+    var networkPoolUuid;
+    var networkUuids = [];
+    var networks = [
+        {
+            name: 'machines-test-network-pool-fake-1',
+            vlan_id: 97,
+            subnet: '10.99.55.0/24',
+            provision_start_ip: '10.99.55.5',
+            provision_end_ip: '10.99.55.250',
+            nic_tag: 'external',
+            owner_uuids: []
+        },
+        {
+            name: 'machines-test-network-pool-fake-2',
+            vlan_id: 98,
+            subnet: '10.99.67.0/24',
+            provision_start_ip: '10.99.67.5',
+            provision_end_ip: '10.99.67.250',
+            nic_tag: 'external',
+            owner_uuids: []
+        }
+    ];
+
+
+    function createNetwork(params, done) {
+        CLIENT.napi.createNetwork(params, function (err, net) {
+            if (err) {
+                done(err);
+                return;
+            }
+            networkUuids.push(net.uuid);
+            done();
+        });
+    }
+
+    function createNetworksForPool(_, done) {
+        vasync.forEachPipeline({
+            func: createNetwork,
+            inputs: networks
+        }, function (err, results) {
+            if (err) {
+                done(err);
+                return;
+            }
+            done();
+        });
+    }
+
+    function createPool(_, done) {
+        CLIENT.napi.createNetworkPool('network-pool-fake',
+            {networks: networkUuids}, function (err, net) {
+            if (err) {
+                done(err);
+                return;
+            }
+            networkPoolUuid = net.uuid;
+            done();
+        });
+    }
+
+    function runTest(_, done) {
+        var vmDetails = {
+            image: IMAGE_UUID,
+            package: SDC_256.name,
+            server_uuid: SERVER_UUID,
+            networks: [
+                {
+                    ipv4_uuid: networkPoolUuid,
+                    // IP set to any value just for this test
+                    ipv4_ips: ['10.99.66.10']
+                }
+            ]
+        };
+        CLIENT.post('/my/machines', vmDetails, function (machineCreateErr, req,
+            res, body) {
+            t.ok(machineCreateErr);
+            t.equal(machineCreateErr.statusCode, 409);
+            t.deepEqual(body, {
+                code: 'InvalidArgument',
+                message: 'property networks[0].ipv4_uuid: ' +
+                    'cannot specify an IP on a network pool'
+            });
+
+            // Call done without error since we expect to get one
+            done();
+        });
+    }
+
+    vasync.pipeline({
+        funcs: [createNetworksForPool, createPool, runTest]
+    }, function (err, results) {
+        // Regardless of errors we should cleanup and end the test
+        CLIENT.napi.deleteNetworkPool(networkPoolUuid,
+            function (delNetworkPoolErr, net) {
+            t.ifError(delNetworkPoolErr);
+
+            function deleteNetwork(netUuid, done) {
+                CLIENT.napi.deleteNetwork(netUuid,
+                    function (delNetworkErr, _) {
+                    t.ifError(delNetworkErr);
+                    done();
+                });
+            }
+
+            vasync.forEachParallel({
+                func: deleteNetwork,
+                inputs: networkUuids
+            }, function (delPipelineErr, _) {
+                t.ifError(delPipelineErr);
+                t.end();
+            });
+        });
+    });
+});
+
+
 test('Create machine with invalid parameters', function (t) {
     var obj = {
         image: IMAGE_UUID,
@@ -828,20 +1057,21 @@ test('Delete tests', function (t) {
 test('machine audit', function (t) {
     var p = '/my/machines/' + MACHINE_UUID + '/audit';
 
+    t.ok(true, p);
     CLIENT.get(p, function (err, req, res, body) {
-        t.ifError(err);
-        t.ok(Array.isArray(body));
-        t.ok(body.length);
+        t.ifError(err, 'CLIENT.get error');
+        t.ok(Array.isArray(body), 'body is array');
+        t.ok(body.length > 0, 'body non-zero length');
 
         var f = body[body.length - 1];
-        t.ok(f.success);
-        t.ok(f.time);
-        t.ok(f.action);
-        t.ok(f.caller);
-        t.ok(f.caller.type);
-        t.equal(f.caller.type, 'signature');
-        t.ok(f.caller.ip);
-        t.ok(f.caller.keyId);
+        t.ok(f.success, 'f.success: ' + f.success);
+        t.ok(f.time, 'f.time: ' + f.time);
+        t.ok(f.action, 'f.action: ' + f.action);
+        t.ok(f.caller, 'f.caller: ' + f.caller);
+        t.ok(f.caller.type, 'f.caller.type: ' + f.caller.type);
+        t.equal(f.caller.type, 'signature', 'f.caller.type == signature');
+        t.ok(f.caller.ip, 'f.caller.ip: ' + f.caller.ip);
+        t.ok(f.caller.keyId, 'f.caller.keyId: ' + f.caller.keyId);
 
         var expectedJobs = [
             'destroy', 'delete_snapshot', 'rollback_snapshot',
@@ -854,6 +1084,8 @@ test('machine audit', function (t) {
         for (var i = 0; i !== expectedJobs.length; i++) {
             var expected = expectedJobs[i];
             var job      = body[i];
+            t.ok(job, 'expected job: ' + expected);
+
             var caller   = job.caller;
 
             if (expected === 'replace_tags') {
@@ -861,13 +1093,14 @@ test('machine audit', function (t) {
                 // vmapi doesn't promise immediate consistency, we have to
                 // accept that sometimes the replace_tags job only adds a tag
                 t.ok(job.action === 'replace_tags' || job.action === 'set_tags',
-                    'action');
+                    'action match');
             } else {
-                t.equal(job.action, expected, 'action');
+                t.equal(job.action, expected, 'action match');
             }
-            t.equal(caller.type, 'signature');
-            t.ok(caller.ip, 'ip');
-            t.ok(caller.keyId.indexOf('test@joyent.com/keys/id_rsa') !== -1);
+            t.equal(caller.type, 'signature', 'caller.type == signature');
+            t.ok(caller.ip, 'caller.ip: ' + caller.ip);
+            t.ok(caller.keyId.indexOf('test@joyent.com/keys/id_rsa') !== -1,
+                'test key found');
         }
 
         t.end();
@@ -1333,6 +1566,116 @@ test('Affinity tests', function (t) {
 });
 
 
+test('Create Machine using network and IP', function (t) {
+    var netDetails = {
+        name: 'machines-test-network-and-ip',
+        vlan_id: 99,
+        subnet: '10.99.66.0/24',
+        provision_start_ip: '10.99.66.5',
+        provision_end_ip: '10.99.66.250',
+        nic_tag: 'external',
+        owner_uuids: [CLIENT.account.uuid]
+    };
+
+    var obj = {
+        image: IMAGE_UUID,
+        package: SDC_128.name,
+        server_uuid: SERVER_UUID
+    };
+
+    CLIENT.napi.createNetwork(netDetails, function (err, net) {
+        t.ifError(err);
+
+        NETWORK_UUID = net.uuid;
+
+        obj.networks = [
+            {
+                ipv4_uuid: net.uuid,
+                ipv4_ips: [ NETWORK_IP ]
+            }
+        ];
+
+
+        machinesCommon.createMachine(t, CLIENT, obj, function (_, machineUuid) {
+            MACHINE_UUID = machineUuid;
+            t.end();
+        });
+
+    });
+});
+
+
+test('Wait For Running Machine provisioned with IP', waitForRunning);
+
+
+test('Verify the machines IP', function (t) {
+    var params = {
+        belongs_to_uuid: MACHINE_UUID,
+        belongs_to_type: 'zone'
+    };
+
+    CLIENT.napi.listNics(params, function napiListNics(err, nics) {
+        t.ifError(err);
+
+        var found = nics.some(function nicHasIp(n) {
+            return n.ip === NETWORK_IP;
+        });
+
+        t.ok(found, 'nic with correct ip found');
+        t.end();
+    });
+});
+
+
+test('Create Machine using network and in use IP', function (t) {
+    var obj = {
+        image: IMAGE_UUID,
+        package: SDC_128.name,
+        server_uuid: SERVER_UUID,
+        networks: [
+            {
+                ipv4_uuid: NETWORK_UUID,
+                ipv4_ips: [ NETWORK_IP ]
+            }
+        ]
+    };
+
+    CLIENT.post('/my/machines', obj, function createMachine(err, req, res,
+        body) {
+        t.ok(err);
+        t.equal(err.statusCode, 409);
+        t.deepEqual(body, {
+            code: 'InvalidArgument',
+            message: 'ip in use'
+        });
+        t.end();
+    });
+});
+
+
+test('Destroy machine created with IP', function (t) {
+    CLIENT.vmapi.deleteVm({
+        uuid: MACHINE_UUID,
+        owner_uuid: CLIENT.account.uuid
+    }, function (err, job) {
+        t.ifError(err, 'Deleting machine ' + MACHINE_UUID);
+
+        waitForJob(CLIENT, job.job_uuid, function (deleteJobErr) {
+            t.ifError(deleteJobErr, 'waiting for job ' + job.job_uuid);
+            t.end();
+        });
+    });
+});
+
+
+test('Destroy machines-test-network-and-ip network', function (t) {
+    CLIENT.napi.deleteNetwork(NETWORK_UUID,
+        function napiDeleteNetwork(err, res) {
+        t.ifError(err);
+        t.end();
+    });
+});
+
 test('teardown', function (t) {
     common.deletePackage(CLIENT, SDC_256, function (err) {
         common.deletePackage(CLIENT, SDC_256_INACTIVE, function (err2) {
diff --git a/test/nics.test.js b/test/nics.test.js
index 1d67992..cbf8331 100644
--- a/test/nics.test.js
+++ b/test/nics.test.js
@@ -784,6 +784,9 @@ test('nics', function (tt) {
     var fixtures;
     var instNic;
 
+    // filled in later when adding a fabric nic
+    var fabricNetworkIp;
+
     tt.test('  setup', function (t) {
         vasync.pipeline({funcs: [
             function commonSetup(_, next) {
@@ -1151,6 +1154,86 @@ test('nics', function (tt) {
         getErr(t, path, expectedErr);
     });
 
+    tt.test('  Create NIC using public network and ip', function (t) {
+        var path = '/my/machines/' + fixtures.instId + '/nics';
+        var networkParams = {
+            ipv4_uuid: fixtures.externalNetwork.uuid,
+            // Doesn't matter what IP we pass here, just that we pass one
+            ipv4_ips: [ '192.168.1.1' ]
+        };
+        var args = { network: networkParams };
+
+        var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
+            message: 'property network.ipv4_uuid:' +
+                    ' cannot specify an IP on a public network',
+            statusCode: 409,
+            restCode: 'InvalidArgument',
+            name: 'InvalidArgumentError',
+            body: {
+                code: 'InvalidArgument',
+                message: 'property network.ipv4_uuid:' +
+                        ' cannot specify an IP on a public network'
+            }
+        };
+
+        postErr(t, path, args, expectedErr);
+    });
+
+    tt.test('  Create NIC using network and multiple ips', function (t) {
+        var path = '/my/machines/' + fixtures.instId + '/nics';
+        var networkParams = {
+            ipv4_uuid: fixtures.networks[0].network.uuid,
+            // Doesn't matter what IPs we use here, we should short curcuit
+            // early when multiple are detected
+            ipv4_ips: [ '192.168.1.1', '192.168.1.1' ]
+        };
+        var args = { network: networkParams };
+
+        var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
+            message: 'property network.ipv4_ips:' +
+                    ' array should contain single ip',
+            statusCode: 409,
+            restCode: 'InvalidArgument',
+            name: 'InvalidArgumentError',
+            body: {
+                code: 'InvalidArgument',
+                message: 'property network.ipv4_ips:' +
+                        ' array should contain single ip'
+            }
+        };
+
+        postErr(t, path, args, expectedErr);
+    });
+
+    tt.test('  Create NIC using unknown network and ip', function (t) {
+        var path = '/my/machines/' + fixtures.instId + '/nics';
+        var networkParams = {
+            ipv4_uuid: 'dd39e200-e68b-11e7-8490-001fc69cf4fd',
+            ipv4_ips: [ '192.168.1.1' ]
+        };
+        var args = { network: networkParams };
+
+        var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
+            message: 'property network.ipv4_uuid:' +
+                    ' network ' + networkParams.ipv4_uuid + ' not found',
+            statusCode: 404,
+            restCode: 'ResourceNotFound',
+            name: 'ResourceNotFoundError',
+            body: {
+                code: 'ResourceNotFound',
+                message: 'property network.ipv4_uuid:' +
+                        ' network ' + networkParams.ipv4_uuid + ' not found'
+            }
+        };
+
+        postErr(t, path, args, expectedErr);
+    });
 
     tt.test('  Create NIC using network', function (t) {
         var path = '/my/machines/' + fixtures.instId + '/nics';
@@ -1567,6 +1650,9 @@ test('nics', function (tt) {
             t.ifError(nic.belongs_to_type);
             t.ifError(nic.belongs_to_uuid);
 
+            // Save the IP to use in the add nic provision from pool with IP
+            fixtures.networks[0].ip = nic.ip;
+
             var location = res.headers.location;
             t.ok(location);
 
@@ -1587,6 +1673,70 @@ test('nics', function (tt) {
         removeNic(t, fixtures.instId, instNic);
     });
 
+    tt.test('  Create NIC using network pool and ip', function (t) {
+        var path = '/my/machines/' + fixtures.instId + '/nics';
+        var networkParams = {
+            ipv4_uuid: fixtures.networks[0].pool.uuid,
+            ipv4_ips: [ fixtures.networks[0].ip ]
+        };
+        var args = { network: networkParams };
+
+        var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
+            message: 'property network.ipv4_uuid:' +
+                    ' cannot specify an IP on a network pool',
+            statusCode: 409,
+            restCode: 'InvalidArgument',
+            name: 'InvalidArgumentError',
+            body: {
+                code: 'InvalidArgument',
+                message: 'property network.ipv4_uuid:' +
+                        ' cannot specify an IP on a network pool'
+            }
+        };
+
+        postErr(t, path, args, expectedErr);
+    });
+
+
+    tt.test('  Add fabric network NIC with managed ip', FABRIC_TEST_OPTS,
+        function (t) {
+        CLIENT.get('/my/networks', function (err, req, res, networks) {
+            t.ifError(err);
+
+            var fabricNetwork = networks.filter(function (net) {
+                return net.fabric;
+            })[0];
+            t.ok(fabricNetwork, format('fabricNetwork %s (%s)',
+                fabricNetwork.id, fabricNetwork.name));
+
+            var path = '/my/machines/' + fixtures.instId + '/nics';
+            var networkParams = {
+                ipv4_uuid: fabricNetwork.id,
+                ipv4_ips: [ fabricNetwork.gateway ]
+            };
+            var args = { network: networkParams };
+
+            var expectedErr = {
+                jse_info: {},
+                jse_shortmsg: '',
+                message: 'cannot use ' + fabricNetwork.gateway +
+                        ' because it is a managed ip',
+                statusCode: 409,
+                restCode: 'InvalidArgument',
+                name: 'InvalidArgumentError',
+                body: {
+                    code: 'InvalidArgument',
+                    message: 'cannot use ' + fabricNetwork.gateway +
+                            ' because it is a managed ip'
+                }
+            };
+
+            postErr(t, path, args, expectedErr);
+        });
+    });
+
 
     tt.test('  Add fabric network NIC', FABRIC_TEST_OPTS, function (t) {
         CLIENT.get('/my/networks', function (err, req, res, networks) {
@@ -1609,6 +1759,10 @@ test('nics', function (tt) {
                 instNic = nic;
                 t.ok(instNic, 'AddNic nic: ' + JSON.stringify(nic));
 
+                // Save the ip so we can pass it back in manually in another
+                // create test
+                fabricNetworkIp = nic.ip;
+
                 waitTilNicAdded(t, location);
             });
         });
@@ -1621,6 +1775,43 @@ test('nics', function (tt) {
     });
 
 
+    tt.test('  Add fabric network NIC with ip', FABRIC_TEST_OPTS, function (t) {
+        CLIENT.get('/my/networks', function (err, req, res, networks) {
+            t.ifError(err);
+
+            var fabricNetwork = networks.filter(function (net) {
+                return net.fabric;
+            })[0];
+            t.ok(fabricNetwork, format('fabricNetwork %s (%s)',
+                fabricNetwork.id, fabricNetwork.name));
+
+            var path = '/my/machines/' + fixtures.instId + '/nics';
+            var networkParams = {
+                ipv4_uuid: fabricNetwork.id,
+                ipv4_ips: [ fabricNetworkIp ]
+            };
+            var args = { network: networkParams };
+            CLIENT.post(path, args, function (nicCreateErr, nicCreateReq,
+                nicCreateRes, nic) {
+                t.ifError(nicCreateErr, 'AddNic to vm '+ fixtures.instId);
+                t.equal(nicCreateRes.statusCode, 201, 'AddNic 201 statusCode');
+
+                var location = nicCreateRes.headers.location;
+                t.ok(location, 'AddNic Location header: ' + location);
+                instNic = nic;
+                t.ok(instNic, 'AddNic nic: ' + JSON.stringify(nic));
+
+                waitTilNicAdded(t, location);
+            });
+        });
+    });
+
+    tt.test('  Remove NIC using fabric network and ip', FABRIC_TEST_OPTS,
+            function (t) {
+        removeNic(t, fixtures.instId, instNic);
+    });
+
+
     tt.test('  teardown', function (t) {
         deleteFixtures(t, fixtures, function (err) {
             t.ifError(err, 'deleteFixtures');
