commit d0d24e46edb4436dbb61e0003e653b3ff5d35799 (refs/changes/31/3131/1)
Author: Mike Zeller <mike.zeller@joyent.com>
Date:   2017-12-21T15:57:31-08:00 (1 year, 10 months ago)
    
    PUBAPI-1081 Enable requesting IP addresses on networks when provisioning or adding nics

diff --git a/lib/machines.js b/lib/machines.js
index 9708248..aac0ac1 100644
--- a/lib/machines.js
+++ b/lib/machines.js
@@ -443,26 +443,83 @@ function getCreateOptions(req) {
 
             if (objectsAllowed) {
                 switch (netType) {
-                    case 'string':
-                        ifaceObjects++;
-                        break;
-                    case 'object':
-                        ifaceObjects++;
-                        netUuid = netObj.ipv4_uuid;
-
-                        if (typeof (netUuid) !== 'string') {
+                case 'string':
+                    ifaceObjects++;
+                    break;
+                case 'object':
+                    ifaceObjects++;
+                    netUuid = netObj.ipv4_uuid;
+                    var ips = netObj.ipv4_ips;
+
+                    if (!netUuid) {
+                        throw new MissingParameterError(sprintf(
+                            'property "networks[%d].ipv4_uuid": ' +
+                            'must be specified', idx));
+                    }
+
+                    if (typeof (netUuid) !== 'string') {
+                        throw new InvalidArgumentError(sprintf(
+                            'property "networks[%d].ipv4_uuid": ' +
+                            'string expected', idx));
+                    }
+
+                    if (ips) {
+                        if (!Array.isArray(ips)) {
                             throw new InvalidArgumentError(sprintf(
-                                'property "networks[%d].ipv4_uuid": ' +
+                                'property "networks[%d].ipv4_ips": ' +
+                                'array expected', idx));
+                        }
+
+                        if (ips.length > 1) {
+                            throw new InvalidArgumentError(sprintf(
+                                'property "networks[%d].ipv4_ips": ' +
+                                'array should contain single ip', idx));
+                        }
+
+                        if (typeof (ips[0]) !== 'string') {
+                            throw new InvalidArgumentError(sprintf(
+                                'property "networks[%d].ipv4_ips[0]": ' +
                                 'string expected', idx));
                         }
 
-                        break;
-                    default:
-                        // the 'property "foo" ...' format intended to match
-                        // the json-schema error format:
-                        throw new InvalidArgumentError(sprintf(
-                            'property "networks[%d]": array of strings or ' +
-                            'objects expected', idx));
+                        /*
+                         * We need to verify the following up front:
+                         * - The network is within the users req.networks
+                         * - The network is not a pool
+                         * - The network is not public
+                         */
+                        var _net = req.networks.find(
+                            function checkForNetwork(n) {
+                            return n.uuid === netUuid;
+                        });
+
+                        if (!_net) {
+                            throw new ResourceNotFoundError(sprintf(
+                                'property "networks[%d].ipv4_uuid": ' +
+                                'network %s not found', idx, netUuid));
+                        }
+
+                        if (Array.isArray(_net.networks)) {
+                            throw new InvalidArgumentError(sprintf(
+                                'property "networks[%d].ipv4_uuid": ' +
+                                'cannot specify an IP on a network pool', idx));
+                        }
+
+                        if (!_net.hasOwnProperty('owner_uuids')) {
+                            throw new InvalidArgumentError(sprintf(
+                                'property "networks[%d].ipv4_uuid": ' +
+                                'cannot specify an IP on a public network',
+                                idx));
+                        }
+                    }
+
+                    break;
+                default:
+                    // the 'property "foo" ...' format intended to match
+                    // the json-schema error format:
+                    throw new InvalidArgumentError(sprintf(
+                        'property "networks[%d]": array of strings or ' +
+                        'objects expected', idx));
                 }
 
             } else {
@@ -529,10 +586,15 @@ function getCreateOptions(req) {
         // We only support ipv4_uuid and ipv4_count for now, so only allow
         // them, just to be safe:
         opts.networks = opts.networks.map(function (n) {
-            return {
-                ipv4_count: n.ipv4_count || 1,
-                ipv4_uuid: n.ipv4_uuid
-            };
+            var netObj = {};
+
+            if (!n.ipv4_ips) {
+                netObj.ipv4_count = n.ipv4_count || 1;
+            }
+
+            netObj.ipv4_uuid = n.ipv4_uuid;
+            netObj.ipv4_ips = n.ipv4_ips;
+            return netObj;
         });
 
     } else {
@@ -1463,6 +1525,52 @@ function create(req, res, next) {
         });
     }
 
+    /*
+     * We need to verify that if a user passed in networks with IPs that none
+     * of the IPs are considered "managed".  NAPI will handle other validations
+     * for us.
+     */
+    var networksWithIps = [];
+    opts.networks.forEach(function (net) {
+        // Today we only support passing in ipv4 addrs,
+        // but this should be extended to support ipv6 addrs
+        if (net.ipv4_ips && net.ipv4_ips.length > 0) {
+            networksWithIps.push(net);
+        }
+    });
+
+    if (networksWithIps.length > 0) {
+        pipeline.push(function (_, cb) {
+            function validateIp(network, done) {
+                req.sdc.napi.getIP(network.ipv4_uuid, network.ipv4_ips[0],
+                    function (err, ip) {
+                    if (err) {
+                        done(err);
+                        return;
+                    }
+                    if (ip.belongs_to_type === 'other' ||
+                        ip.owner_uuid === req.config.ufds_admin_uuid) {
+                        done(new InvalidArgumentError('cannot use %s because' +
+                            ' its a managed ip', ip.ip));
+                        return;
+                    }
+                    done(null, ip);
+                });
+            }
+
+            vasync.forEachPipeline({
+                func: validateIp,
+                inputs: networksWithIps
+            }, function (err, results) {
+                if (err) {
+                    cb(err);
+                    return;
+                }
+                cb();
+            });
+        });
+    }
+
 
     pipeline.push(function (_, cb) {
         return req.sdc.vmapi.createVm(opts, {
@@ -1491,6 +1599,13 @@ function create(req, res, next) {
                             msgs.push('Invalid ' + e.field);
                         }
                     });
+                } else if (body.code && body.code === 'InvalidParameters' &&
+                    body.errors.length) {
+                    body.errors.forEach(function (e) {
+                        if (e.field === 'ip') {
+                            err = new InvalidArgumentError(err, e.message);
+                        }
+                    });
                 }
 
                 if (msgs.length) {
diff --git a/lib/nics.js b/lib/nics.js
index 2f8c8a2..f732818 100644
--- a/lib/nics.js
+++ b/lib/nics.js
@@ -45,6 +45,9 @@ var assert  = require('assert-plus');
 var restify = require('restify');
 var vasync  = require('vasync');
 
+var util = require('util');
+var sprintf = util.format;
+
 
 
 // --- Globals
@@ -68,12 +71,12 @@ var MAC_RE  = /^[0-9a-f]{12}/i;
 /*
  * Add a NIC to a VM.
  *
- * A network UUID is passed in as an argument, which we need to look up in NAPI
- * in order to find out the nic tag associated with that network or network
- * pool. We then check that there isn't already another NIC on that VM with that
- * network -- if there is, we 302 redirect to that NIC. We also need to check
- * that the server has an appropriate nic tag, otherwise adding that network to
- * the VM will not work.
+ * AddNic accepts a single network UUID or a single network object as an
+ * argument, which we need to look up in NAPI in order to find out the nic tag
+ * associated with that network or network pool. We then check that there isn't
+ * already another NIC on that VM with that network -- if there is, we 302
+ * redirect to that NIC. We also need to check that the server has an
+ * appropriate nic tag, otherwise adding that network to the VM will not work.
  *
  * Fabric networks are treated differently; instead of looking up the network
  * nic_tag in NAPI, we check the server's sysinfo for virtual network interfaces
@@ -104,20 +107,126 @@ function addNic(req, res, next) {
     var serverUuid  = req.vm.server_uuid;
     var ownerUuid   = req.account.uuid;
     var login       = req.account.login;
-    var networkUuid = req.params.network;
+    var networkArg  = req.params.network;
     var origin      = req.params.origin || 'cloudapi';
     var context = {
         caller: req._auditCtx,
         params: req.params
     };
 
-    if (!networkUuid) {
+    if (!networkArg) {
         return next(new MissingParameterError('network must be specified'));
     }
 
-    if (typeof (networkUuid) !== 'string' || !networkUuid.match(UUID_RE)) {
-        var errMsg = 'network argument has invalid format';
-        return next(new InvalidArgumentError(errMsg));
+    /*
+     * With the push to use interface-centric provisioning across the stack
+     * we want AddNic to be able to accept the new style payload which looks
+     * like:
+     *
+     * [
+     *   {
+     *     ipv4_uuid: uuid_0, ipv4_count: <number>,
+     *     ipv4_ips: [ ip0, ip1, ... ],
+     *     ipv6_uuid: uuid_1, ipv6_count: <number>,
+     *     ipv6_ips: [ ip0, ip1, ... ],
+     *     primary: true
+     *   }, ...
+     * ]
+     *
+     * At this point in time AddNic will only accept a single interface
+     * object that contains a single ipv4_uuid. In addition to the network
+     * uuid we also allow the user to pass in an optional ipv4_ips array
+     * consisting of a single IP. In the future when napi fully supports having
+     * NICs with multiple IPs this will likely be extended to allow the array to
+     * contain multiple IPs.
+     *
+     * Once ZAPI-816 is rolled out everywhere, we would also like to support
+     * specifying that the new NIC should be the primary via the primaryIp flag.
+     * In addtion we will also be able to make a vmapi call directly without
+     * having to first create the NIC up front.
+     */
+    function validateNetworkObject(netObj) {
+        var ipv4_uuid = netObj.ipv4_uuid;
+        var ipv4_ips = netObj.ipv4_ips;
+
+        if (!ipv4_uuid) {
+            throw new MissingParameterError('property "network.ipv4_uuid": ' +
+                'must be specified');
+        }
+
+        if (typeof (ipv4_uuid) !== 'string' || !ipv4_uuid.match(UUID_RE)) {
+            throw new InvalidArgumentError('property "network.ipv4_uuid": ' +
+                'uuid string expected');
+        }
+
+        if (ipv4_ips) {
+            if (!Array.isArray(ipv4_ips)) {
+                throw new InvalidArgumentError('property "network.ipv4_ips": ' +
+                    'array expected');
+            }
+
+            if (ipv4_ips.length > 1) {
+                throw new InvalidArgumentError('property "network.ipv4_ips": ' +
+                    'array should contain single ip');
+            }
+
+            if (typeof (ipv4_ips[0]) !== 'string') {
+                throw new InvalidArgumentError('property ' +
+                    '"network.ipv4_ips[0]": string expected');
+            }
+
+            /*
+             * We need to verify the following up front:
+             * - The network is within the users req.networks
+             * - The network is not a pool
+             * - The network is not public
+             */
+            var _net = req.networks.find(
+                function checkForNetwork(n) {
+                return n.uuid === ipv4_uuid;
+            });
+
+            if (!_net) {
+                throw new ResourceNotFoundError(sprintf(
+                    'property "network.ipv4_uuid": ' +
+                    'network %s not found', ipv4_uuid));
+            }
+
+            if (Array.isArray(_net.networks)) {
+                throw new InvalidArgumentError('property "network.ipv4_uuid":' +
+                    ' cannot specify an IP on a network pool');
+            }
+
+            if (!_net.hasOwnProperty('owner_uuids')) {
+                throw new InvalidArgumentError('property "network.ipv4_uuid":' +
+                    ' cannot specify an IP on a public network');
+            }
+        }
+    }
+
+    var networkUuid, networkIp;
+
+    // Make sure we have a single network uuid, or a single network object
+    switch (typeof (networkArg)) {
+    case 'string':
+        if (!networkArg.match(UUID_RE)) {
+            return next(new InvalidArgumentError(
+                'network argument has invalid format'));
+        }
+        networkUuid = networkArg;
+        break;
+    case 'object':
+        try {
+            validateNetworkObject(networkArg);
+        } catch (networkObjErr) {
+            return next(networkObjErr);
+        }
+        networkUuid = networkArg.ipv4_uuid;
+        networkIp = networkArg.ipv4_ips[0];
+        break;
+    default:
+        return next(new InvalidArgumentError(
+            'network argument must be a network object or string'));
     }
 
     var network, nic;  // filled in by the vasync-called functions
@@ -298,7 +407,9 @@ function addNic(req, res, next) {
     }
 
     function addToNapi(_, cb) {
-        req.sdc.napi.provisionNic(network.uuid, {
+        var pipeline = [];
+
+        var params = {
             belongs_to_uuid: vmUuid,
             belongs_to_type: 'zone',
             cn_uuid: serverUuid,
@@ -306,18 +417,68 @@ function addNic(req, res, next) {
             state: 'provisioning',
             origin: origin,
             context: context
-        }, {
-            log: log,
-            headers: headers
-        }, function (err, _nic) {
-            if (err) {
-                return cb(err);
-            }
+        };
+
+        // linter currently complains about "_" being used in the parent scope
+        function provisionNic(notUsed, done) {
+            req.sdc.napi.provisionNic(network.uuid, params, {
+                log: log,
+                headers: headers
+            }, function (err, _nic) {
+                if (err) {
+                    var body = err.body;
+                    if (body.code && body.code === 'InvalidParameters' &&
+                        body.errors.length) {
+                        if (err.field === 'ip') {
+                            err = new InvalidArgumentError(err, err.message);
+                        }
+                    }
+
+                    done(err);
+                    return;
+                }
 
-            nic = _nic;
-            log.debug(nic, 'Added NIC to NAPI');
+                nic = _nic;
+                log.debug(nic, 'Added NIC to NAPI');
 
-            return cb();
+                done();
+            });
+        }
+
+        // linter currently complains about "_" being used in the parent scope
+        function validateIp(notUsed, done) {
+            assert.ok(networkIp, 'networkIp');
+
+            req.sdc.napi.getIP(network.uuid, networkIp, function (err, ip) {
+                if (err) {
+                    done(err);
+                    return;
+                }
+                if (ip.belongs_to_type === 'other' ||
+                    ip.owner_uuid === req.config.ufds_admin_uuid) {
+                    done(new InvalidArgumentError('cannot use %s because' +
+                        ' it is a managed ip', ip.ip));
+                    return;
+                }
+                done(null, ip);
+            });
+        }
+
+        if (networkIp) {
+            params.ip = networkIp;
+            pipeline.push(validateIp);
+        }
+
+        pipeline.push(provisionNic);
+
+        vasync.pipeline({
+            funcs: pipeline
+        }, function (err, results) {
+            if (err) {
+                cb(err);
+                return;
+            }
+            cb();
         });
     }
 
diff --git a/test/machines.70.test.js b/test/machines.70.test.js
index 5e9e8f6..9e4ded7 100644
--- a/test/machines.70.test.js
+++ b/test/machines.70.test.js
@@ -33,6 +33,8 @@ var CLIENT;
 var OTHER;
 var SERVER;
 
+var NETWORK_UUID;
+
 
 // --- Tests
 
@@ -136,7 +138,6 @@ test('CreateMachine', function (t) {
     });
 });
 
-
 test('Wait For Running', function (t) {
     machinesCommon.waitForRunningMachine(CLIENT, MACHINE_UUID, function (err) {
         t.ifError(err);
@@ -151,6 +152,7 @@ test('Wait For Running', function (t) {
 });
 
 
+
 test('Get Machine,  with Firewall Enabled', function (t) {
     if (!MACHINE_UUID) {
         return t.end();
diff --git a/test/machines.80.test.js b/test/machines.80.test.js
index 2c9b626..f6f5e40 100644
--- a/test/machines.80.test.js
+++ b/test/machines.80.test.js
@@ -25,6 +25,7 @@ var IMAGE_UUID;
 var SERVER_UUID;
 var PROVISIONABLE_NET_UUID;
 var MACHINE_UUID;
+var NETWORK_UUID;
 
 var CLIENTS;
 var CLIENT;
@@ -66,6 +67,64 @@ test('Get test image', function (t) {
 });
 
 
+test('Create Machine using network and ip', function (t) {
+    var netDetails = {
+        name: 'network-test-owned',
+        vlan_id: 99,
+        subnet: '10.99.66.0/24',
+        provision_start_ip: '10.99.66.5',
+        provision_end_ip: '10.99.66.250',
+        nic_tag: 'external',
+        owner_uuids: [CLIENT.account.uuid]
+    };
+
+    var obj = {
+        image: IMAGE_UUID,
+        package: SDC_128.name,
+        server_uuid: SERVER_UUID
+    };
+
+    CLIENT.napi.createNetwork(netDetails, function (err, net) {
+        t.ifError(err);
+
+        NETWORK_UUID = net.uuid;
+
+        obj.networks = [
+            {
+                ipv4_uuid: net.uuid,
+                ipv4_ips: [ '10.99.66.50' ]
+            }
+        ];
+
+
+        machinesCommon.createMachine(t, CLIENT, obj, function (_, machineUuid) {
+            MACHINE_UUID = machineUuid;
+            t.end();
+        });
+
+    });
+});
+
+
+test('Wait For Running', function (t) {
+    machinesCommon.waitForRunningMachine(CLIENT, MACHINE_UUID, function (err) {
+        t.ifError(err);
+
+        if (err) {
+            // Skip machine tests when machine creation fails
+            MACHINE_UUID = false;
+        }
+
+        CLIENT.napi.deleteNetwork(NETWORK_UUID, {}, function (err2) {
+            t.ifError(err2);
+            t.end();
+        });
+    });
+});
+
+
+
+
 test('CreateMachine', function (t) {
     var obj = {
         image: IMAGE_UUID,
diff --git a/test/machines.test.js b/test/machines.test.js
index 6c60b29..e5f7a47 100644
--- a/test/machines.test.js
+++ b/test/machines.test.js
@@ -11,6 +11,7 @@
 var util = require('util');
 var test = require('tape').test;
 var restify = require('restify');
+var vasync = require('vasync');
 var common = require('./common');
 var uuid = common.uuid;
 var addPackage = common.addPackage;
@@ -349,6 +350,263 @@ test('CreateMachine using network without permissions', function (t) {
 });
 
 
+test('CreateMachine using public network and ip', function (t) {
+    var netDetails = {
+        name: 'network-test-fake-public',
+        vlan_id: 99,
+        subnet: '10.99.66.0/24',
+        provision_start_ip: '10.99.66.5',
+        provision_end_ip: '10.99.66.250',
+        nic_tag: 'external',
+        owner_uuids: []
+    };
+
+    var vmDetails = {
+        image: IMAGE_UUID,
+        package: SDC_256.name,
+        server_uuid: SERVER_UUID
+    };
+
+    CLIENT.napi.createNetwork(netDetails, function (err, net) {
+        t.ifError(err);
+
+        vmDetails.networks = [
+            {
+                ipv4_uuid: net.uuid,
+                ipv4_ips: ['10.99.66.10']
+            }
+        ];
+
+        CLIENT.post('/my/machines', vmDetails, function (err2, req, res, body) {
+            t.ok(err2);
+            t.equal(err2.statusCode, 409);
+            t.deepEqual(body, {
+                code: 'InvalidArgument',
+                message: 'property "networks[0].ipv4_uuid": cannot specify an' +
+                    ' IP on a public network'
+            });
+
+            CLIENT.napi.deleteNetwork(net.uuid, {}, function (err3) {
+                t.ifError(err3);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('CreateMachine using network and ip', function (t) {
+    var netDetails = {
+        name: 'network-test-fake',
+        vlan_id: 99,
+        subnet: '10.99.66.0/24',
+        provision_start_ip: '10.99.66.5',
+        provision_end_ip: '10.99.66.250',
+        nic_tag: 'external',
+        owner_uuids: ['fbae7be9-922f-48cf-b935-e3027881fca0']
+    };
+
+    var vmDetails = {
+        image: IMAGE_UUID,
+        package: SDC_256.name,
+        server_uuid: SERVER_UUID
+    };
+
+    CLIENT.napi.createNetwork(netDetails, function (err, net) {
+        t.ifError(err);
+
+        vmDetails.networks = [net.uuid];
+
+        CLIENT.post('/my/machines', vmDetails, function (err2, req, res, body) {
+            t.ok(err2);
+            t.equal(err2.statusCode, 409);
+            t.deepEqual(body, {
+                code: 'InvalidArgument',
+                message: 'Invalid Networks'
+            });
+
+            CLIENT.napi.deleteNetwork(net.uuid, {}, function (err3) {
+                t.ifError(err3);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('CreateMachine using unknown network and an ip', function (t) {
+    var networkUuid = 'd674f27a-e695-11e7-8490-001fc69cf4fd';
+    var vmDetails = {
+        image: IMAGE_UUID,
+        package: SDC_256.name,
+        server_uuid: SERVER_UUID,
+        networks: [
+            {
+                ipv4_uuid: networkUuid,
+                // IP set to any value just for this test
+                ipv4_ips: ['10.99.66.10']
+            }
+        ]
+    };
+
+    CLIENT.post('/my/machines', vmDetails, function (err2, req, res, body) {
+        t.ok(err2);
+        t.equal(err2.statusCode, 404);
+        t.deepEqual(body, {
+            code: 'ResourceNotFound',
+            message: 'property "networks[0].ipv4_uuid": ' +
+                'network ' + networkUuid + ' not found'
+        });
+
+        t.end();
+    });
+});
+
+
+test('CreateMachine using network and invalid number of ips', function (t) {
+    var networkUuid = 'd674f27a-e695-11e7-8490-001fc69cf4fd';
+    var vmDetails = {
+        image: IMAGE_UUID,
+        package: SDC_256.name,
+        server_uuid: SERVER_UUID,
+        networks: [
+            {
+                ipv4_uuid: networkUuid,
+                // IP set to any value just for this test
+                ipv4_ips: ['10.99.66.10', '10.99.66.10']
+            }
+        ]
+    };
+
+    CLIENT.post('/my/machines', vmDetails, function (err2, req, res, body) {
+        t.ok(err2);
+        t.equal(err2.statusCode, 409);
+        t.deepEqual(body, {
+            code: 'InvalidArgument',
+            message: 'property "networks[0].ipv4_ips": ' +
+                'array should contain single ip'
+        });
+
+        t.end();
+    });
+});
+
+
+test('CreateMachine using network pool and an ip', function (t) {
+    var networkPoolUuid;
+    var networkUuids = [];
+    var networks = [
+        {
+            name: 'network-pool-fake-1',
+            vlan_id: 97,
+            subnet: '10.99.55.0/24',
+            provision_start_ip: '10.99.55.5',
+            provision_end_ip: '10.99.55.250',
+            nic_tag: 'external',
+            owner_uuids: []
+        },
+        {
+            name: 'network-pool-fake-2',
+            vlan_id: 98,
+            subnet: '10.99.67.0/24',
+            provision_start_ip: '10.99.67.5',
+            provision_end_ip: '10.99.67.250',
+            nic_tag: 'external',
+            owner_uuids: []
+        }
+    ];
+
+
+    function createNetwork(params, done) {
+        CLIENT.napi.createNetwork(params, function (err, net) {
+            if (err) {
+                done(err);
+                return;
+            }
+            networkUuids.push(net.uuid);
+            done();
+        });
+    }
+
+    function createNetworksForPool(_, done) {
+        vasync.forEachPipeline({
+            func: createNetwork,
+            inputs: networks
+        }, function (err, results) {
+            if (err) {
+                done(err);
+                return;
+            }
+            done();
+        });
+    }
+
+    function createPool(_, done) {
+        CLIENT.napi.createNetworkPool('network-pool-fake',
+            {networks: networkUuids}, function (err, net) {
+            if (err) {
+                done(err);
+                return;
+            }
+            networkPoolUuid = net.uuid;
+            done();
+        });
+    }
+
+    function runTest(_, done) {
+        var vmDetails = {
+            image: IMAGE_UUID,
+            package: SDC_256.name,
+            server_uuid: SERVER_UUID,
+            networks: [
+                {
+                    ipv4_uuid: networkPoolUuid,
+                    // IP set to any value just for this test
+                    ipv4_ips: ['10.99.66.10']
+                }
+            ]
+        };
+        CLIENT.post('/my/machines', vmDetails, function (err2, req, res, body) {
+            t.ok(err2);
+            t.equal(err2.statusCode, 409);
+            t.deepEqual(body, {
+                code: 'InvalidArgument',
+                message: 'property "networks[0].ipv4_uuid": ' +
+                    'cannot specify an IP on a network pool'
+            });
+
+            // Call done without error since we expect to get one
+            done();
+        });
+    }
+
+    vasync.pipeline({
+        funcs: [createNetworksForPool, createPool, runTest]
+    }, function (err, results) {
+        // Regardless of errors we should cleanup and end the test
+        CLIENT.napi.deleteNetworkPool(networkPoolUuid, function (err2, net) {
+            t.ifError(err2);
+
+            function deleteNetwork(netUuid, done) {
+                CLIENT.napi.deleteNetwork(netUuid,
+                    function (err3, _) {
+                    t.ifError(err3);
+                    done();
+                });
+            }
+
+            vasync.forEachParallel({
+                func: deleteNetwork,
+                inputs: networkUuids
+            }, function (err4, _) {
+                t.ifError(err4);
+                t.end();
+            });
+        });
+    });
+});
+
+
 test('Create machine with invalid parameters', function (t) {
     var obj = {
         image: IMAGE_UUID,
diff --git a/test/nics.test.js b/test/nics.test.js
index 1d67992..e25d507 100644
--- a/test/nics.test.js
+++ b/test/nics.test.js
@@ -784,6 +784,9 @@ test('nics', function (tt) {
     var fixtures;
     var instNic;
 
+    // filled in later when adding a fabric nic
+    var fabricNetworkIp;
+
     tt.test('  setup', function (t) {
         vasync.pipeline({funcs: [
             function commonSetup(_, next) {
@@ -1151,6 +1154,86 @@ test('nics', function (tt) {
         getErr(t, path, expectedErr);
     });
 
+    tt.test('  Create NIC using public network and ip', function (t) {
+        var path = '/my/machines/' + fixtures.instId + '/nics';
+        var networkParams = {
+            ipv4_uuid: fixtures.externalNetwork.uuid,
+            // Doesn't matter what IP we pass here, just that we pass one
+            ipv4_ips: [ '192.168.1.1' ]
+        };
+        var args = { network: networkParams };
+
+        var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
+            message: 'property "network.ipv4_uuid":' +
+                    ' cannot specify an IP on a public network',
+            statusCode: 409,
+            restCode: 'InvalidArgument',
+            name: 'InvalidArgumentError',
+            body: {
+                code: 'InvalidArgument',
+                message: 'property "network.ipv4_uuid":' +
+                        ' cannot specify an IP on a public network'
+            }
+        };
+
+        postErr(t, path, args, expectedErr);
+    });
+
+    tt.test('  Create NIC using network and multiple ips', function (t) {
+        var path = '/my/machines/' + fixtures.instId + '/nics';
+        var networkParams = {
+            ipv4_uuid: fixtures.networks[0].network.uuid,
+            // Doesn't matter what IPs we use here, we should short curcuit
+            // early when multiple are detected
+            ipv4_ips: [ '192.168.1.1', '192.168.1.1' ]
+        };
+        var args = { network: networkParams };
+
+        var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
+            message: 'property "network.ipv4_ips":' +
+                    ' array should contain single ip',
+            statusCode: 409,
+            restCode: 'InvalidArgument',
+            name: 'InvalidArgumentError',
+            body: {
+                code: 'InvalidArgument',
+                message: 'property "network.ipv4_ips":' +
+                        ' array should contain single ip'
+            }
+        };
+
+        postErr(t, path, args, expectedErr);
+    });
+
+    tt.test('  Create NIC using unknown network and ip', function (t) {
+        var path = '/my/machines/' + fixtures.instId + '/nics';
+        var networkParams = {
+            ipv4_uuid: 'dd39e200-e68b-11e7-8490-001fc69cf4fd',
+            ipv4_ips: [ '192.168.1.1' ]
+        };
+        var args = { network: networkParams };
+
+        var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
+            message: 'property "network.ipv4_uuid":' +
+                    ' network ' + networkParams.ipv4_uuid + ' not found',
+            statusCode: 404,
+            restCode: 'ResourceNotFound',
+            name: 'ResourceNotFoundError',
+            body: {
+                code: 'ResourceNotFound',
+                message: 'property "network.ipv4_uuid":' +
+                        ' network ' + networkParams.ipv4_uuid + ' not found'
+            }
+        };
+
+        postErr(t, path, args, expectedErr);
+    });
 
     tt.test('  Create NIC using network', function (t) {
         var path = '/my/machines/' + fixtures.instId + '/nics';
@@ -1567,6 +1650,9 @@ test('nics', function (tt) {
             t.ifError(nic.belongs_to_type);
             t.ifError(nic.belongs_to_uuid);
 
+            // Save the IP to use in the add nic provision from pool with IP
+            fixtures.networks[0].ip = nic.ip;
+
             var location = res.headers.location;
             t.ok(location);
 
@@ -1587,6 +1673,70 @@ test('nics', function (tt) {
         removeNic(t, fixtures.instId, instNic);
     });
 
+    tt.test('  Create NIC using network pool and ip', function (t) {
+        var path = '/my/machines/' + fixtures.instId + '/nics';
+        var networkParams = {
+            ipv4_uuid: fixtures.networks[0].pool.uuid,
+            ipv4_ips: [ fixtures.networks[0].ip ]
+        };
+        var args = { network: networkParams };
+
+        var expectedErr = {
+            jse_info: {},
+            jse_shortmsg: '',
+            message: 'property "network.ipv4_uuid":' +
+                    ' cannot specify an IP on a network pool',
+            statusCode: 409,
+            restCode: 'InvalidArgument',
+            name: 'InvalidArgumentError',
+            body: {
+                code: 'InvalidArgument',
+                message: 'property "network.ipv4_uuid":' +
+                        ' cannot specify an IP on a network pool'
+            }
+        };
+
+        postErr(t, path, args, expectedErr);
+    });
+
+
+    tt.test('  Add fabric network NIC with managed ip', FABRIC_TEST_OPTS,
+        function (t) {
+        CLIENT.get('/my/networks', function (err, req, res, networks) {
+            t.ifError(err);
+
+            var fabricNetwork = networks.filter(function (net) {
+                return net.fabric;
+            })[0];
+            t.ok(fabricNetwork, format('fabricNetwork %s (%s)',
+                fabricNetwork.id, fabricNetwork.name));
+
+            var path = '/my/machines/' + fixtures.instId + '/nics';
+            var networkParams = {
+                ipv4_uuid: fabricNetwork.id,
+                ipv4_ips: [ fabricNetwork.gateway ]
+            };
+            var args = { network: networkParams };
+
+            var expectedErr = {
+                jse_info: {},
+                jse_shortmsg: '',
+                message: 'cannot use ' + fabricNetwork.gateway +
+                        ' because it is a managed ip',
+                statusCode: 409,
+                restCode: 'InvalidArgument',
+                name: 'InvalidArgumentError',
+                body: {
+                    code: 'InvalidArgument',
+                    message: 'cannot use ' + fabricNetwork.gateway +
+                            ' because it is a managed ip'
+                }
+            };
+
+            postErr(t, path, args, expectedErr);
+        });
+    });
+
 
     tt.test('  Add fabric network NIC', FABRIC_TEST_OPTS, function (t) {
         CLIENT.get('/my/networks', function (err, req, res, networks) {
@@ -1609,6 +1759,10 @@ test('nics', function (tt) {
                 instNic = nic;
                 t.ok(instNic, 'AddNic nic: ' + JSON.stringify(nic));
 
+                // Save the ip so we can pass it back in manually in another
+                // create test
+                fabricNetworkIp = nic.ip;
+
                 waitTilNicAdded(t, location);
             });
         });
@@ -1621,6 +1775,42 @@ test('nics', function (tt) {
     });
 
 
+    tt.test('  Add fabric network NIC with ip', FABRIC_TEST_OPTS, function (t) {
+        CLIENT.get('/my/networks', function (err, req, res, networks) {
+            t.ifError(err);
+
+            var fabricNetwork = networks.filter(function (net) {
+                return net.fabric;
+            })[0];
+            t.ok(fabricNetwork, format('fabricNetwork %s (%s)',
+                fabricNetwork.id, fabricNetwork.name));
+
+            var path = '/my/machines/' + fixtures.instId + '/nics';
+            var networkParams = {
+                ipv4_uuid: fabricNetwork.id,
+                ipv4_ips: [ fabricNetworkIp ]
+            };
+            var args = { network: networkParams };
+            CLIENT.post(path, args, function (err2, req2, res2, nic) {
+                t.ifError(err2, 'AddNic to vm '+ fixtures.instId);
+                t.equal(res2.statusCode, 201, 'AddNic 201 statusCode');
+
+                var location = res2.headers.location;
+                t.ok(location, 'AddNic Location header: ' + location);
+                instNic = nic;
+                t.ok(instNic, 'AddNic nic: ' + JSON.stringify(nic));
+
+                waitTilNicAdded(t, location);
+            });
+        });
+    });
+
+    tt.test('  Remove NIC using fabric network and ip', FABRIC_TEST_OPTS,
+            function (t) {
+        removeNic(t, fixtures.instId, instNic);
+    });
+
+
     tt.test('  teardown', function (t) {
         deleteFixtures(t, fixtures, function (err) {
             t.ifError(err, 'deleteFixtures');
