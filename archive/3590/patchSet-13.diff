commit 5626578a0469d156f540a7c26ead9af15276b254 (refs/changes/90/3590/13)
Author: Todd Whiteman <todd.whiteman@joyent.com>
Date:   2018-06-27T14:04:50-07:00 (1 year, 3 months ago)
    
    TRITON-53 x-account image clone
    Reviewed by: Trent Mick <trentm@gmail.com>
    Approved by: Trent Mick <trentm@gmail.com>

diff --git a/CHANGES.md b/CHANGES.md
index b2c6e2a..6fb636b 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,6 +1,12 @@
 # IMGAPI changelog
 
+## 4.4.0
+
+- TRITON-53 x-account image clone, adds a new CloneImage
+  /images/:uuid/clone endpoint.
+
 ## 4.3.1
+
 - TRITON-489 Add metricPort metadata to IMGAPI for cmon-agent
 
 ## 4.3.0
diff --git a/docs/index.md b/docs/index.md
index d2f2bd9..3cf0a5c 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -621,6 +621,7 @@ and relevant for images in an IMGAPI server that uses [channels](#channels).
 | [EnableImage](#EnableImage)                       | POST /images/:uuid?action=enable                           | Enable the image.                                                             |
 | [AddImageAcl](#AddImageAcl)                       | POST /images/:uuid/acl?action=add                          | Add account UUIDs to the image ACL.                                           |
 | [RemoveImageAcl](#RemoveImageAcl)                 | POST /images/:uuid/acl?action=remove                       | Remove account UUIDs from the image ACL.                                      |
+| [CloneImage](#CloneImage)                         | POST /images/:uuid/clone                                   | Clone this image.
 | [AddImageIcon](#AddImageIcon)                     | POST /images/:uuid/icon                                    | Add the image icon.                                                           |
 | [GetImageIcon](#GetImageIcon)                     | GET /images/:uuid/icon                                     | Get the image icon file.                                                      |
 | [DeleteImageIcon](#DeleteImageIcon)               | DELETE /images/:uuid/icon                                  | Remove the image icon.                                                        |
@@ -1900,6 +1901,67 @@ CLI tool:
 
 
 
+## CloneImage (POST /images/:uuid/clone?account=:account)
+
+Clone this image. This endpoint is only available when IMGAPI is in 'dc' mode.
+
+This makes a copy of the given image (including origin images). The provided
+`account` param must be on the image ACL in order to clone the image, see
+[AddImageAcl](#AddImageAcl). The newly-cloned image(s) will have a different
+uuid to the original, the `owner` field will be set to the `account` param, and
+the cloned image will have an empty ACL.
+
+### Inputs
+
+| Field                 | Type | Required? | Default | Notes                                                |
+| --------------------- | ---- | --------- | ------- | ---------------------------------------------------- |
+| account (query param) | UUID | Yes       | -       | The owner the cloned image will be assigned to.      |
+
+### Returns
+
+The cloned image object.
+
+### Errors
+
+See [Errors](#errors) section above.
+
+### Example
+
+Raw API tool:
+
+    $ sdc-imgapi /images/e70502b0-705e-498e-a810-53a03980eabf/clone?account=ab0896af-bf8c-48d4-885c-6573a94b1895 -X POST
+    HTTP/1.1 200 OK
+    Content-Type: application/json
+    Content-Length: 356
+    Date: Tue, 08 Jan 2013 20:21:17 GMT
+    Server: IMGAPI/1.0.0
+    x-request-id: f5645880-59d0-11e2-b638-4b6ffa4ca56f
+    x-response-time: 110
+    x-server-name: 70f0978d-7efa-4c45-8ebf-8cb9e3a887f7
+    Connection: keep-alive
+
+    {
+      "uuid": "e70502b0-705e-498e-a810-53a03980eabf",
+      "owner": "ab0896af-bf8c-48d4-885c-6573a94b1895",
+      "name": "foo",
+      "version": "1.0.0",
+      "state": "active",
+      "disabled": false,
+      "public": false,
+      "published_at": "2013-01-08T20:21:17.932Z",
+      "type": "zone-dataset",
+      "os": "smartos",
+      "files": [
+        {
+          "sha1": "cd0e0510c4a0799551687901077d7c4c06a4ebd8",
+          "size": 42,
+          "compression": "bzip2"
+        }
+      ],
+      "acl": []
+    }
+
+
 ## AdminImportImage (POST /images/:uuid?action=import)
 
 Import an image (preserving its `uuid` and `published_at` fields).
diff --git a/lib/app.js b/lib/app.js
index ab724eb..795e8b4 100644
--- a/lib/app.js
+++ b/lib/app.js
@@ -490,7 +490,7 @@ function App(config, log) {
     );
 
     channels.mountApi(server, self, reqAuth, reqPassiveAuth);
-    images.mountApi(server, reqAuth, reqPassiveAuth);
+    images.mountApi(server, self, reqAuth, reqPassiveAuth);
     datasets.mountApi(server);
     authkeys.mountApi(server, reqAuth);
 }
diff --git a/lib/constants.js b/lib/constants.js
index ba8913d..2a2e654 100644
--- a/lib/constants.js
+++ b/lib/constants.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -50,6 +50,12 @@ module.exports = {
     MAX_IMAGE_SIZE: 20*1024*1024*1024, // 20GiB
     MAX_IMAGE_SIZE_STR: '20 GiB',
 
+    /*
+     * Maximum number of IMGAPI origin images that can exist in the origin
+     * chain.
+     */
+    MAX_ORIGIN_DEPTH: 100,
+
     /*
      * Dir used by the 'local' storage backend to store images and archive
      * files.
diff --git a/lib/errors.js b/lib/errors.js
index f5b45f9..048c061 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -378,6 +378,22 @@ NotImageOwnerError.statusCode = 422;
 NotImageOwnerError.description = 'The caller is not the owner of this image.';
 
 
+function ImageNotSharedError(cause, account, imageUuid) {
+    RestError.call(this, {
+        restCode: this.constructor.restCode,
+        statusCode: this.constructor.statusCode,
+        message: format('Image %s is not shared with account %s',
+            account, imageUuid),
+        cause: cause
+    });
+}
+util.inherits(ImageNotSharedError, RestError);
+ImageNotSharedError.prototype.name = 'ImageNotSharedError';
+ImageNotSharedError.restCode = 'ImageNotShared';
+ImageNotSharedError.statusCode = 422;
+ImageNotSharedError.description = 'The image is not shared with this account.';
+
+
 function NotMantaPathOwnerError(cause, account, mpath) {
     if (mpath === undefined) {
         mpath = account;
@@ -608,6 +624,7 @@ module.exports = {
     StorageUnsupportedError: StorageUnsupportedError,
     RemoteSourceError: RemoteSourceError,
     OwnerDoesNotExistError: OwnerDoesNotExistError,
+    ImageNotSharedError: ImageNotSharedError,
     AccountDoesNotExistError: AccountDoesNotExistError,
     NotImageOwnerError: NotImageOwnerError,
     NotMantaPathOwnerError: NotMantaPathOwnerError,
diff --git a/lib/images.js b/lib/images.js
index 4ded88d..b4d87e0 100644
--- a/lib/images.js
+++ b/lib/images.js
@@ -274,12 +274,7 @@ Image.prototype.addFile = function addFile(app, file, log, callback) {
  * Move the image file from this, into the given Image instance.
  *
  * @param app {App} The IMGAPI app.
- * @param file {Object} Describes the uploaded file, with keys:
- *      - `sha1` {String}
- *      - `size` {Integer}
- *      - `stor` {String}
- *      - `contentMD5` {String}
- *      - `mtime` {String} ISO date string
+ * @param toImage {Object} The description Image instance.
  * @param log {Bunyan Logger}
  * @param callback {Function} `function (err)` where `err` is some internal
  *      detail (i.e. it should be wrapped for the user).
@@ -316,6 +311,41 @@ function moveFileToImage(app, toImage, log, callback) {
 };
 
 
+/**
+ * Copy the image files from this, into the given Image instance.
+ *
+ * @param app {App} The IMGAPI app.
+ * @param toImage {Object} The destination Image instance.
+ * @param log {Bunyan Logger}
+ * @param callback {Function} `function (err)` where `err` is some internal
+ *      detail (i.e. it should be wrapped for the user).
+ */
+Image.prototype.copyFilesToImage =
+function copyFilesToImage(app, toImage, log, callback) {
+    assert.object(app, 'app');
+    assert.object(toImage, 'toImage');
+    assert.object(log, 'log');
+    assert.func(callback, 'callback');
+
+    var files = this.files;
+    assert.equal(files.length, 1, 'Expect exactly one image file');
+    var file = files[0];
+    var self = this;
+
+    var stor = app.getStor(file.stor);
+    assert.object(stor, 'stor');
+    stor.copyFileBetweenImages(self, toImage, 'file0',
+            function _copyFileCb(err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        // Add the file image metadata.
+        toImage.addFile(app, file, log, callback);
+    });
+};
+
+
 /**
  * Add an uploaded icon to this Image instance. The file will have already
  * be written out (to disk or to manta, depending).
@@ -543,6 +573,84 @@ Image.prototype.channelRemove = function channelRemove(
 };
 
 
+/**
+ * Delete this image.
+ *
+ * @param app {App} The IMGAPI app.
+ * @param log {Bunyan Logger}
+ * @param callback {Function} `function (err)` where `err` is okay to
+ *      use for an API reponse (i.e. doesn't expose internal details).
+ */
+Image.prototype.delete = function imageDelete(app, log, callback) {
+    assert.object(app, 'app');
+    assert.object(log, 'log');
+    assert.func(callback, 'callback');
+
+    var self = this;
+
+    vasync.pipeline({funcs: [
+        deleteModel,
+        deleteFiles,
+        deleteIconFile
+    ]}, callback);
+
+    // Delete the model.
+    // Note: We delete the manifest entry first to make sure the entry
+    // goes away, if subsequent deletion of files from storage fails,
+    // then that is just internally logged for operators to cleanup.
+    function deleteModel(_, next) {
+        app.db.del(self.uuid, function (delErr) {
+            if (delErr) {
+                next(delErr);
+                return;
+            }
+            app.cacheInvalidateDelete('Image', self);
+            next();
+        });
+    }
+
+    function deleteFiles(_, next) {
+        // Delete all files.
+        async.forEach(
+            self.files,
+            function deleteOneFile(file, nextFile) {
+                var stor = app.getStor(file.stor);
+                stor.deleteImageFile(self, nextFile);
+            },
+            function doneDeletes(fileErr) {
+                if (fileErr) {
+                    log.error({err: fileErr, image: self},
+                        'error deleting image file(s), this image may ' +
+                        'have zombie files which must be remove ' +
+                        'manually by an operator');
+                    next(errors.parseErrorFromStorage(fileErr,
+                        'error deleting image file'));
+                    return;
+                }
+                next();
+            }
+        );
+    }
+
+    function deleteIconFile(_, next) {
+        if (!self.icon) {
+            next();
+            return;
+        }
+        var stor = app.getStor(self.icon.stor);
+        stor.deleteImageFile(self, 'icon', function (fileErr) {
+            if (fileErr) {
+                log.error({err: fileErr, image: self},
+                    'error deleting model icon, this image may ' +
+                    'have a zombie icon file which must be ' +
+                    'removed manually by an operator');
+            }
+            next();
+        });
+    }
+};
+
+
 /**
  * Get an image from the database.
  *
@@ -3662,65 +3770,11 @@ function apiDeleteImage(req, res, callback) {
             }
             image.channelRemove(req._app, req.channel.name, req.log, next);
         },
-        function deleteModel(next) {
+        function deleteImage(next) {
             if (!actuallyDelete) {
                 return next();
             }
-            // Delete the model.
-            // Note: We delete the manifest entry first to make sure the entry
-            // goes away, if subsequent deletion of files from storage fails,
-            // then that is just internally logged for operators to cleanup.
-            app.db.del(image.uuid, function (delErr) {
-                if (delErr) {
-                    return next(delErr);
-                }
-                app.cacheInvalidateDelete('Image', image);
-                next();
-            });
-        },
-        function deleteFiles(next) {
-            if (!actuallyDelete) {
-                return next();
-            }
-            // Delete any files.
-            async.forEach(
-                image.files,
-                function deleteOneFile(file, nextFile) {
-                    var stor = req._app.getStor(file.stor);
-                    stor.deleteImageFile(image, nextFile);
-                },
-                function doneDeletes(fileErr) {
-                    if (fileErr) {
-                        log.error({err: fileErr, image: image},
-                            'error deleting image file(s), this image may ' +
-                            'have zombie files which must be remove ' +
-                            'manually by an operator');
-                        return next(errors.parseErrorFromStorage(fileErr,
-                            'error deleting image file'));
-                    }
-                    next();
-                }
-            );
-        },
-        function deleteIconFile(next) {
-            if (!actuallyDelete) {
-                return next();
-            }
-            var icon = image.icon;
-            if (icon) {
-                var stor = req._app.getStor(icon.stor);
-                stor.deleteImageFile(image, 'icon', function (fileErr) {
-                    if (fileErr) {
-                        log.error({err: fileErr, image: image},
-                            'error deleting model icon, this image may ' +
-                            'have a zombie icon file which must be ' +
-                            'removed manually by an operator');
-                    }
-                    next();
-                });
-            } else {
-                next();
-            }
+            image.delete(req._app, req.log, next);
         },
         function respond(next) {
             res.send(204);
@@ -3818,6 +3872,203 @@ function apiListImageJobs(req, res, next) {
 }
 
 
+function apiCloneImage(req, res, next) {
+    assert.object(req, 'req');
+    assert.object(req._app, 'req._app');
+    assert.equal(req._app.mode, 'dc', 'app is in dc mode');
+    assert.object(req._image, 'req._image');
+    assert.ok(req._image.activated, 'req._image.activated');
+    assert.object(res, 'res');
+    assert.func(next, 'next');
+
+    var account;
+    var app = req._app;
+    var clonedImages = [];
+    var image = req._image;
+    var log = req.log;
+
+    if (req.query && req.query.account) {
+        account = req.query.account;
+    }
+
+    // Validation.
+    if (!UUID_RE.test(account)) {
+        next(new errors.InvalidParameterError(
+            format('invalid "account": not a UUID: "%s"', account),
+            [ { field: 'account', code: 'Invalid' } ]));
+        return;
+    }
+
+    if (!req._image.acl || req._image.acl.indexOf(account) === -1) {
+        next(new errors.ImageNotSharedError(null, account, image.uuid));
+        return;
+    }
+
+    if (image.type === 'docker') {
+        next(new errors.ValidationFailedError(
+            'docker images cannot be cloned',
+            [ { field: 'type', code: 'Invalid' } ]));
+        return;
+    }
+
+    log.debug({image: image}, 'cloneImage: start');
+
+    vasync.pipeline({arg: {}, funcs: [
+        // Find and validate each of the origin images:
+        // 1. must be activated or disabled (disabled means cannot provision)
+        // 2. must be owned by the given user (or admin)
+        function lookupOriginImages(ctx, pipeNext) {
+            // The images to clone, starting from the base.
+            ctx.imagesToClone = [image];
+
+            if (!image.origin) {
+                pipeNext();
+                return;
+            }
+
+            function validateOneOriginImage(currentOrigin, subnext) {
+                Image.get(app, currentOrigin, log,
+                        function _cloneImageGetCb(err, img) {
+                    if (err) {
+                        subnext(err);
+                        return;
+                    }
+                    // Stop cloning when an admin image is found.
+                    if (img.owner === constants.UNSET_OWNER_UUID ||
+                            img.owner === app.config.adminUuid) {
+                        ctx.originImage = img;
+                        subnext();
+                        return;
+                    }
+                    ctx.imagesToClone.unshift(img);
+                    // Follow the origin chain.
+                    if (img.origin) {
+                        if (ctx.imagesToClone.length >=
+                                constants.MAX_ORIGIN_DEPTH) {
+                            subnext(new errors.InternalError(format(
+                                'Origin chain too long, exceeds %d images',
+                                constants.MAX_ORIGIN_DEPTH)));
+                            return;
+                        }
+                        validateOneOriginImage(img.origin, subnext);
+                        return;
+                    }
+                    subnext();
+                });
+            }
+
+            validateOneOriginImage(image.origin, pipeNext);
+        },
+
+        // Clone all of the images in the imagesToClone array.
+        function cloneImages(ctx, pipeNext) {
+            assert.arrayOfObject(ctx.imagesToClone, 'ctx.imagesToClone');
+
+            log.info({uuid: image.uuid},
+                'cloneImage: %d images to clone',
+                ctx.imagesToClone.length);
+
+            function cloneOneImage(img, nextImageCb) {
+                vasync.pipeline({ arg: {}, funcs: [
+                    cloneImgMetadata,
+                    cloneImgFiles,
+                    activateClonedImg
+                ]}, nextImageCb);
+
+                function cloneImgMetadata(subctx, subnext) {
+                    var imgData = img.serialize(app.mode, '*');
+                    var lastIdx = ctx.imagesToClone.length - 1;
+                    var isFinalImg = (img === ctx.imagesToClone[lastIdx]);
+                    // Remove these image fields.
+                    delete imgData.acl;  // No access given to others.
+                    delete imgData.uuid; // So we get a new uuid.
+                    delete imgData.published_at; // Will be updated.
+                    // Change the owner and update the origin.
+                    imgData.owner = account;
+                    if (ctx.originImage) {
+                        imgData.origin = ctx.originImage.uuid;
+                    }
+                    // Disable intermediate images (so they are not shown as
+                    // provisionable), otherwise it would be strange when you
+                    // clone image X, but then you see image X, Y and Z (where
+                    // Y and Z are parent images of X).
+                    if (!isFinalImg) {
+                        imgData.disabled = true;
+                    }
+                    // Create the clone.
+                    Image.create(app, imgData, false, false,
+                            function _cloneImageCreateCb(cErr, newimg) {
+                        if (cErr) {
+                            subnext(cErr);
+                            return;
+                        }
+                        subctx.newimg = newimg;
+                        ctx.originImage = newimg;
+                        clonedImages.push(newimg);
+                        subnext();
+                    });
+                }
+
+                function cloneImgFiles(subctx, subnext) {
+                    img.copyFilesToImage(app, subctx.newimg, log, subnext);
+                }
+
+                function activateClonedImg(subctx, subnext) {
+                    subctx.newimg.activate(app, log, function _imgActCb(err) {
+                        if (!err) {
+                            log.info({uuid: image.uuid,
+                                    clone_uuid: subctx.newimg.uuid},
+                                'image cloned');
+                        }
+                        subnext(err);
+                    });
+                }
+            }
+
+            function cleanupDeleteOneImage(img, deleteNextImg) {
+                img.delete(app, log, function _delOneImgCb(delErr) {
+                    if (delErr) {
+                        log.error({uuid: img.uuid},
+                            'clone cleanup failure: unable to delete cloned ' +
+                            'image: %s', delErr);
+                    }
+                    deleteNextImg();
+                });
+            }
+
+            vasync.forEachPipeline({
+                func: cloneOneImage,
+                inputs: ctx.imagesToClone
+            }, function _cloneImgPipeCb(err) {
+                if (err) {
+                    // Failure - cleanup newly created/cloned images.
+                    vasync.forEachPipeline({
+                        func: cleanupDeleteOneImage,
+                        inputs: clonedImages
+                    }, function _deleteImgPipeCb() {
+                        pipeNext(err);
+                    });
+                    return;
+                }
+                pipeNext();
+            });
+        }
+
+    ]}, function _clonePipelineCb(err) {
+        if (err) {
+            log.error({account: account, image: image.uuid},
+                'Unable to clone image: %s', err);
+            next(err);
+            return;
+        }
+
+        var finalImage = clonedImages[clonedImages.length - 1];
+        res.send(finalImage.serialize(app.mode, req.getVersion()));
+        next();
+    });
+}
+
+
 /**
  * Ensure the 'uuid' request param is valid, else this is a 404.
  */
@@ -4021,7 +4272,7 @@ function resume(req, res, next) {
  * endpoints.
  *
  */
-function mountApi(server, reqAuth, reqPassiveAuth) {
+function mountApi(server, app, reqAuth, reqPassiveAuth) {
     server.get(
         {path: '/images', name: 'ListImages'},
         reqPassiveAuth,
@@ -4164,6 +4415,19 @@ function mountApi(server, reqAuth, reqPassiveAuth) {
         channels.reqChannel,
         reqGetImage,    // add `req._image`, ensure access
         apiListImageJobs);
+
+
+    // IMGAPI functionality that is only available in 'dc' mode.
+    if (app.mode === 'dc') {
+
+        server.post(
+            {path: '/images/:uuid/clone', name: 'CloneImage'},
+            reqAuth,
+            reqValidUuid,
+            channels.reqChannel,
+            reqGetImage,
+            apiCloneImage);
+    }
 }
 
 
diff --git a/lib/storage.js b/lib/storage.js
index db83ddf..3e5f764 100644
--- a/lib/storage.js
+++ b/lib/storage.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2017 Joyent, Inc.
+ * Copyright 2018 Joyent, Inc.
  */
 
 /*
@@ -147,6 +147,18 @@ Storage.prototype.moveFileBetweenImages =
     function (fromImage, toImage, filename, callback) {
 };
 
+/**
+ * Copies an image file from one image to another image.
+ *
+ * @param fromImage {Image}
+ * @param toImage {Image}
+ * @param filename {String} Image filename (i.e. 'file0')
+ * @param callback {Function} `function (err)`
+ */
+Storage.prototype.copyFileBetweenImages =
+    function (fromImage, toImage, filename, callback) {
+};
+
 
 /**
  * Returns the archive path for image manifests. Image manifests are archived
@@ -479,6 +491,63 @@ function (fromImage, toImage, filename, callback) {
 };
 
 
+LocalStorage.prototype.copyFileBetweenImages =
+function localCopyFileBetweenImages(fromImage, toImage, filename, callback) {
+    assert.object(fromImage, 'fromImage');
+    assert.uuid(fromImage.uuid, 'fromImage.uuid');
+    assert.object(toImage, 'toImage');
+    assert.uuid(toImage.uuid, 'toImage.uuid');
+    assert.string(filename, 'filename');
+    assert.func(callback, 'callback');
+
+    var fromPath = this.storPathFromImageUuid(fromImage.uuid, filename);
+    var toPath = this.storPathFromImageUuid(toImage.uuid, filename);
+
+    var toDir = path.dirname(toPath);
+    mkdirp(toDir, function _localCopyFileMkdirpCb(mkdirErr) {
+        var cbCalled = false;
+        var readStream;
+        var writeStream;
+
+        if (mkdirErr) {
+            callback(mkdirErr);
+            return;
+        }
+
+        // Create read stream.
+        try {
+            readStream = fs.createReadStream(fromPath);
+        } catch (ex) {
+            callback(new errors.ValidationFailedError(ex,
+                'source file not found'));
+            return;
+        }
+
+        // Create write stream.
+        try {
+            writeStream = fs.createWriteStream(toPath);
+        } catch (ex) {
+            callback(new errors.ValidationFailedError(ex,
+                'destination file not writable'));
+            return;
+        }
+
+        function done(err) {
+            if (!cbCalled) {
+                callback(err);
+                cbCalled = true;
+            }
+        }
+
+        readStream.on('error', done);
+        writeStream.on('error', done);
+        writeStream.on('close', done);
+
+        readStream.pipe(writeStream);
+    });
+};
+
+
 LocalStorage.prototype.archiveImageManifest = function (manifest, callback) {
     assert.object(manifest, 'manifest');
     assert.string(manifest.uuid, 'manifest.uuid');
@@ -759,7 +828,7 @@ MantaStorage.prototype.moveImageFile = function (image, from, to, callback) {
 };
 
 MantaStorage.prototype.moveFileBetweenImages =
-function (fromImage, toImage, filename, callback) {
+function moveFileBetweenImages(fromImage, toImage, filename, callback) {
     assert.object(fromImage, 'fromImage');
     assert.uuid(fromImage.uuid, 'fromImage.uuid');
     assert.object(toImage, 'toImage');
@@ -792,6 +861,29 @@ function (fromImage, toImage, filename, callback) {
     });
 };
 
+MantaStorage.prototype.copyFileBetweenImages =
+function mantaCopyFileBetweenImages(fromImage, toImage, filename, callback) {
+    assert.object(fromImage, 'fromImage');
+    assert.uuid(fromImage.uuid, 'fromImage.uuid');
+    assert.object(toImage, 'toImage');
+    assert.uuid(toImage.uuid, 'toImage.uuid');
+    assert.string(filename, 'filename');
+    assert.func(callback, 'callback');
+
+    var fromPath = this._storPathFromImageUuid(fromImage.uuid, filename);
+    var toPath = this._storPathFromImageUuid(toImage.uuid, filename);
+    var toDir = path.dirname(toPath);
+
+    var self = this;
+
+    self.client.mkdirp(toDir, function _mantaCopyFileMkdirpCb(mkdirErr) {
+        if (mkdirErr) {
+            return callback(mkdirErr);
+        }
+        self.client.ln(fromPath, toPath, callback);
+    });
+};
+
 MantaStorage.prototype.archiveImageManifest =
 function (manifest, callback) {
     assert.object(manifest, 'manifest');
diff --git a/package.json b/package.json
index 470d91b..6ef4567 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "imgapi",
   "description": "Image API to manage images for SDC 7",
-  "version": "4.3.1",
+  "version": "4.4.0",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
diff --git a/test/dc-test-images.json b/test/dc-test-images.json
index d26e5a1..852f7eb 100644
--- a/test/dc-test-images.json
+++ b/test/dc-test-images.json
@@ -14,6 +14,7 @@
     "published_at": "2012-11-02T22:46:45.992Z",
     "files": [
         {
+            "stor": "local",
             "sha1": "25592745c0b06822e0a4c9e9945e67322bdfe619",
             "size": 42,
             "compression": "gzip"
@@ -37,6 +38,7 @@
     "published_at": "2012-10-02T22:46:45.992Z",
     "files": [
         {
+            "stor": "local",
             "sha1": "25592745c0b06822e0a4c9e9945e67322bdfe619",
             "size": 42,
             "compression": "gzip"
@@ -74,6 +76,7 @@
     "published_at": "2012-11-02T22:46:45.992Z",
     "files": [
         {
+            "stor": "local",
             "sha1": "25592745c0b06822e0a4c9e9945e67322bdfe619",
             "size": 42,
             "compression": "gzip"
@@ -97,6 +100,7 @@
     "published_at": "2012-10-02T22:46:45.992Z",
     "files": [
         {
+            "stor": "local",
             "sha1": "25592745c0b06822e0a4c9e9945e67322bdfe619",
             "size": 42,
             "compression": "gzip"
diff --git a/test/image-clone.dc-test.js b/test/image-clone.dc-test.js
new file mode 100644
index 0000000..9e302b3
--- /dev/null
+++ b/test/image-clone.dc-test.js
@@ -0,0 +1,174 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2018 Joyent, Inc.
+ */
+
+/*
+ * TRITON-53: Test the image clone endpoint.
+ */
+
+var util = require('util');
+
+var IMGAPI = require('sdc-clients/lib/imgapi');
+var restify = require('restify');
+var uuid = require('uuid');
+
+
+// ---- globals
+
+var client;
+var jsonClient;
+var CLONED_IMAGE;
+var CLONED_IMAGE_2;
+var PUBLIC_OPERATOR_IMAGE = 'c58161c0-2547-11e2-a75e-9fdca1940570';
+// Private image owned by vader, shared with luke.
+var PRIVATE_SHARED_IMAGE = '7a1b1967-6ecf-1e4c-8f09-f49094cc36ad';
+var IMGAPI_URL = process.env.IMGAPI_URL || 'http://localhost';
+var LUKE = '91ba0e64-2547-11e2-a972-df579e5fddb3';
+var VADER = '86055c40-2547-11e2-8a6b-4bb37edc84ba';
+
+// ---- tests
+
+var tests = {};
+
+tests['setup'] = function (t) {
+    client = new IMGAPI({url: IMGAPI_URL, agent: false});
+    t.ok(client, 'got an imgapi client');
+    jsonClient = restify.createJSONClient({
+        connectTimeout: 250,
+        rejectUnauthorized: false,
+        retry: false,
+        url: IMGAPI_URL
+    });
+    t.ok(jsonClient, 'got a json client');
+    t.done();
+};
+
+
+tests['error when no account provided'] = function (t) {
+    var url = util.format('/images/%s/clone', PRIVATE_SHARED_IMAGE);
+    jsonClient.post(url, function (err) {
+        t.ok(err, 'expect an error when no account provided');
+        t.equal(err.statusCode, 422, 'error statusCode should be 422');
+        t.ok(err.body, 'error should have a body object');
+        if (err.body) {
+            t.equal(err.body.code, 'InvalidParameter',
+                'error code should be InvalidParameter');
+        }
+        t.done();
+    });
+};
+
+tests['error when cloning a private image'] = function (t) {
+    var account = uuid.v4();
+    client.cloneImage(PRIVATE_SHARED_IMAGE, account, function (err) {
+        t.ok(err, 'got an error');
+        t.equal(err.statusCode, 404, 'error statusCode should be 404');
+        t.ok(err.body, 'error should have a body object');
+        if (err.body) {
+            t.equal(err.body.code, 'ResourceNotFound',
+                'error code should be ResourceNotFound');
+        }
+        t.done();
+    });
+};
+
+tests['error when cloning public operator image'] = function (t) {
+    var account = uuid.v4();
+    client.cloneImage(PUBLIC_OPERATOR_IMAGE, account, function (err) {
+        t.ok(err, 'got an error');
+        t.equal(err.statusCode, 422, 'error statusCode should be 422');
+        t.ok(err.body, 'error should have a body object');
+        if (err.body) {
+            t.equal(err.body.code, 'ImageNotShared',
+                'error code should be ImageNotShared');
+        }
+        t.done();
+    });
+};
+
+tests['error when cloning own image'] = function (t) {
+    client.cloneImage(PRIVATE_SHARED_IMAGE, VADER, function (err) {
+        t.ok(err, 'got an error');
+        t.equal(err.statusCode, 422, 'error statusCode should be 422');
+        t.ok(err.body, 'error should have a body object');
+        if (err.body) {
+            t.equal(err.body.code, 'ImageNotShared',
+                'error code should be ImageNotShared');
+        }
+        t.done();
+    });
+};
+
+tests['clone shared image'] = function (t) {
+    client.cloneImage(PRIVATE_SHARED_IMAGE, LUKE, function (err, img) {
+        t.ok(!err, 'should not have an error on cloneImage');
+        t.ok(img, 'should return an image object');
+        if (img) {
+            CLONED_IMAGE = img.uuid;
+            t.notEqual(CLONED_IMAGE, PRIVATE_SHARED_IMAGE,
+                'cloned image should have a different uuid');
+        }
+        t.done();
+    });
+};
+
+tests['clone the same image again'] = function (t) {
+    client.cloneImage(PRIVATE_SHARED_IMAGE, LUKE, function (err, img) {
+        t.ok(!err, 'should not have an error on cloneImage');
+        t.ok(img, 'should return an image object');
+        if (img) {
+            CLONED_IMAGE_2 = img.uuid;
+            t.notEqual(CLONED_IMAGE_2, PRIVATE_SHARED_IMAGE,
+                'cloned image should have a different uuid');
+            t.notEqual(CLONED_IMAGE_2, CLONED_IMAGE,
+                'cloned image should have a different uuid');
+        }
+        t.done();
+    });
+};
+
+tests['error when cloning the cloned image'] = function (t) {
+    t.ok(CLONED_IMAGE, 'should have a cloned image');
+    if (!CLONED_IMAGE) {
+        t.done();
+        return;
+    }
+    client.cloneImage(CLONED_IMAGE, LUKE, function (err) {
+        t.ok(err, 'got an error');
+        t.equal(err.statusCode, 422, 'error statusCode should be 422');
+        t.ok(err.body, 'error should have a body object');
+        if (err.body) {
+            t.equal(err.body.code, 'ImageNotShared',
+                'error code should be ImageNotShared');
+        }
+        t.done();
+    });
+};
+
+tests['cleanup'] = function (t) {
+    t.ok(CLONED_IMAGE, 'should have a cloned image');
+    t.ok(CLONED_IMAGE_2, 'should have a second cloned image');
+    if (!CLONED_IMAGE) {
+        t.done();
+        return;
+    }
+    client.deleteImage(CLONED_IMAGE, LUKE, function (err) {
+        t.ok(!err, 'should not have an error deleting clone');
+        if (!CLONED_IMAGE_2) {
+            t.done();
+            return;
+        }
+        client.deleteImage(CLONED_IMAGE_2, LUKE, function (err2) {
+            t.ok(!err2, 'should not have an error deleting second clone');
+            t.done();
+        });
+    });
+};
+
+exports.clone = tests;
diff --git a/test/reload-test-data.sh b/test/reload-test-data.sh
index 1b05051..7097a54 100755
--- a/test/reload-test-data.sh
+++ b/test/reload-test-data.sh
@@ -109,12 +109,20 @@ elif [[ "$opt_mode" == "dc" ]]; then
     CFG_FILE=/data/imgapi/etc/imgapi.config.json
     test_images=$TOP/test/dc-test-images.json
     num_test_images=$(json length <$test_images)
+    stor_dir=$(node $TOP/lib/constants.js LOCAL_BASE_DIR)
     i=0
     while [[ $i < $num_test_images ]]; do
         image=$(json $i <$test_images)
         uuid=$(echo "$image" | json uuid)
         echo "Adding $uuid"
         MORAY_URL=moray://$(json moray.host <$CFG_FILE) $TOP/test/putobject -d "$image" imgapi_images $uuid
+        # Add local file object.
+        file_path=$stor_dir/images/${uuid:0:3}/$uuid/file0
+        mkdir -p $(dirname $file_path)
+        echo "file" >$file_path
+        icon_path=$stor_dir/images/${uuid:0:3}/$uuid/icon
+        mkdir -p $(dirname $icon_path)
+        echo "icon" >$icon_path
         i=$(($i + 1))
     done
 fi
