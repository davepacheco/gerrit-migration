commit f692485f7956b27e111a2d87801e6227490f617d
Author: rhb2 <robert.bogart@joyent.com>
Date:   2019-08-02T19:50:06+00:00 (9 weeks ago)
    
    MANTA-4442 Rebalancer Agent: Worker threads should load their assignments in to memory themselves

diff --git a/src/agent.rs b/src/agent.rs
index a202552..4e5f132 100644
--- a/src/agent.rs
+++ b/src/agent.rs
@@ -115,19 +115,44 @@ impl Assignment {
     }
 }
 
-fn load_saved_assignments(agent: &Agent) {
+fn assignment_signal(agent: &Agent, uuid: &str) {
+    let tx = agent.tx.lock().unwrap();
+    tx.send(uuid.to_string()).unwrap();
+}
+
+// Given a uuid of an assignment (presumably on disk) and access to the
+// HashMap, locate the assignment, load it in to memory and store it in the
+// HashMap.  Currently, this should really only be called by a worker thread
+// with the intention of immediately processing whatever it gets.
+fn load_saved_assignment(
+    assignments: &Arc<Mutex<Assignments>>,
+    uuid: &str
+) {
+    match assignment_recall(format!("{}/{}", REBALANCER_SCHEDULED_DIR, &uuid)) {
+        Ok(a) => {
+            let mut work = assignments.lock().unwrap();
+            work.insert(uuid.to_string(), a);
+        },
+        Err(e) => panic!(format!("Error loading database: {}", e)),
+    }
+}
+
+// Locate all saved assignments on disk and signal their presence to our pool
+// of workers.  To be clear, this does not explicitly load assignment in to
+// memory -- it merely signals the thread pool of their presence.  Ultimately,
+// worker(s) will load assignemnts in to memory right before processing them.
+// This ensures that our memory footprint remains relateively low even if we
+// experience a major backlog of assignments.
+fn discover_saved_assignments(agent: &Agent) {
     for entry in WalkDir::new(REBALANCER_SCHEDULED_DIR)
         .min_depth(1)
         .follow_links(false)
         .into_iter()
-        .filter_map(|e| e.ok()) {
+        .filter_map(|e| e.ok())
+    {
         let uuid = entry.file_name().to_string_lossy();
         println!("{}/{}", REBALANCER_SCHEDULED_DIR, uuid);
-        match assignment_recall(format!("{}/{}", REBALANCER_SCHEDULED_DIR,
-            &uuid)) {
-            Ok(v) => assignment_add(&agent, v, &uuid),
-            Err(e) => panic!(format!("Error loading database: {}", e)),
-        }
+        assignment_signal(&agent, &uuid);
     }
 }
 
@@ -314,28 +339,6 @@ fn assignment_complete(assignments: Arc<Mutex<Assignments>>, uuid: String) {
     hm.remove(&uuid);
 }
 
-// Take a given assignment (i.e. a vector of Task objects) and add it to
-// the our HashMap which contains all outstanding work to be processed.  Then
-// signal the uuid of that assignment to our workers.  The first available
-// worker will begin procesing it.  There are basically two ways that this
-// function can get called:
-//
-// 1. At the start of the rebalancer agent when we are loading incomplete
-//    assignments from disk.
-// 2. When we receive an assignment over the network from the rebalancer zone.
-fn assignment_add(
-    agent: &Agent,
-    assignment: Arc<RwLock<Assignment>>,
-    uuidstr: &str,
-) {
-    let mut work = agent.assignments.lock().unwrap();
-
-    work.insert(uuidstr.to_string(), assignment);
-
-    let tx = agent.tx.lock().unwrap();
-    tx.send(uuidstr.to_string()).unwrap();
-}
-
 fn post(agent: Agent, mut state: State) -> Box<HandlerFuture> {
     let f = Body::take_from(&mut state)
         .concat2()
@@ -367,8 +370,9 @@ fn post(agent: Agent, mut state: State) -> Box<HandlerFuture> {
                         .expect("serialized assignment id"),
                 );
 
-                // Add the assignment to the queue for processing.
-                assignment_add(&agent, assignment.clone(), &uuid);
+                // Signal the workers that there is a new assignent ready for
+                // processing.
+                assignment_signal(&agent, &uuid);
                 future::ok((state, res))
             }
             Err(e) => future::err((state, e.into_handler_error())),
@@ -583,7 +587,7 @@ fn name_to_address(name: &str) -> Result<String, String> {
     let resolver = Resolver::from_system_conf().unwrap();
     let response = match resolver.lookup_ip(name) {
         Ok(resp) => resp,
-        Err(e) => return Err(format!("DNS lookup {}", e)),
+        Err(e) => return Err(format!("name_to_address: {}", e)),
     };
     let shark_ip: Vec<IpAddr> = response.iter().collect();
     Ok(shark_ip[0].to_string())
@@ -609,8 +613,8 @@ fn process_task(task: &mut Task) {
     let shark_ip = match name_to_address(&task.source.manta_storage_id) {
         Ok(addr) => addr,
         Err(e) => {
+            println!("{}", &e);
             task.set_status(TaskStatus::Failed(e));
-            println!("DNS lookup error");
             return;
         }
     };
@@ -668,6 +672,7 @@ fn assignment_get(
 // is the only one that will clean up the assignment when we have finished
 // processing it, by calling `assignment_complete()'.
 fn process_assignment(assignments: Arc<Mutex<Assignments>>, uuid: String) {
+    load_saved_assignment(&assignments, &uuid);
     let assignment = assignment_get(&assignments, &uuid).unwrap();
     let len = assignment.read().unwrap().tasks.len();
     let mut failures = Vec::new();
@@ -747,7 +752,7 @@ fn router() -> Router {
             });
         }
 
-        load_saved_assignments(&agent);
+        discover_saved_assignments(&agent);
 
         route
             .get("/*")
