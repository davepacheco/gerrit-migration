From 7905055ecc203f62b529d8388d9d7a8e2b5517d5 Mon Sep 17 00:00:00 2001
From: rhb2 <robert.bogart@joyent.com>
Date: Fri, 2 Aug 2019 19:50:06 +0000
Subject: [PATCH] MANTA-4442 Rebalancer Agent: Worker threads should load their
 assignments in to memory themselves

---
 src/agent.rs | 149 ++++++++++++++++++++++++++++++---------------------
 1 file changed, 89 insertions(+), 60 deletions(-)

diff --git a/src/agent.rs b/src/agent.rs
index a202552..0a70d97 100644
--- a/src/agent.rs
+++ b/src/agent.rs
@@ -8,10 +8,10 @@
  * Copyright (c) 2019, Joyent, Inc.
  */
 use std::collections::HashMap;
+use std::ffi::OsString;
 use std::fs;
 use std::fs::File;
 use std::net::*;
-use std::ffi::OsString;
 use std::path::Path;
 use std::sync::{mpsc, Arc, Mutex, RwLock};
 
@@ -115,19 +115,57 @@ impl Assignment {
     }
 }
 
-fn load_saved_assignments(agent: &Agent) {
+// Inform the work threads that of an assignment that needs to be processed.
+// Whenever a worker is available, they will receive the UUID of the assignment
+// from the receiving end of the channel and will then attempt to load it from
+// disk in to memory for processing.
+fn assignment_signal(agent: &Agent, uuid: &str) {
+    let tx = agent.tx.lock().unwrap();
+    tx.send(uuid.to_string()).unwrap();
+}
+
+// Given a uuid of an assignment (presumably on disk) and access to the
+// HashMap, locate the assignment, load it in to memory and store it in the
+// HashMap.  Currently, this should really only be called by a worker thread
+// with the intention of immediately processing whatever it gets.
+fn load_saved_assignment(
+    assignments: &Arc<Mutex<Assignments>>,
+    uuid: &str,
+) -> Result<(), String> {
+    match assignment_recall(format!("{}/{}", REBALANCER_SCHEDULED_DIR, &uuid)) {
+        Ok(a) => {
+            let mut work = assignments.lock().unwrap();
+            work.insert(uuid.to_string(), a);
+            Ok(())
+        }
+        Err(e) => {
+            // We need to take some kind of remedial action here.  We have a
+            // database file that (for one reason or another) we are unable to
+            // load.  Rather than bring down the house by calling panic, it
+            // is better to log the error and move on.  It may also be desirable
+            // to quarantine problematic database files so that they can be
+            // examined later, but not rediscovered by the agent.
+            Err(format!("Error loading database: {}", e))
+        }
+    }
+}
+
+// Locate all saved assignments on disk and signal their presence to our pool
+// of workers.  To be clear, this does not explicitly load assignments in to
+// memory -- it merely notifies the thread pool of their existence.  Ultimately,
+// worker(s) will load assignemnts in to memory right before processing them.
+// This ensures that our memory footprint remains relateively low even if we
+// experience a major backlog of assignments.
+fn discover_saved_assignments(agent: &Agent) {
     for entry in WalkDir::new(REBALANCER_SCHEDULED_DIR)
         .min_depth(1)
         .follow_links(false)
         .into_iter()
-        .filter_map(|e| e.ok()) {
+        .filter_map(|e| e.ok())
+    {
         let uuid = entry.file_name().to_string_lossy();
         println!("{}/{}", REBALANCER_SCHEDULED_DIR, uuid);
-        match assignment_recall(format!("{}/{}", REBALANCER_SCHEDULED_DIR,
-            &uuid)) {
-            Ok(v) => assignment_add(&agent, v, &uuid),
-            Err(e) => panic!(format!("Error loading database: {}", e)),
-        }
+        assignment_signal(&agent, &uuid);
     }
 }
 
@@ -216,8 +254,9 @@ fn assignment_recall(path: String) -> Result<Arc<RwLock<Assignment>>, String> {
     // always be named after the assignment uuid.  This will never change,
     // however if it does, then the uuid of the assignment must be stored
     // somewhere within the database.
-    let uuid = OsString::from(file_path.file_stem().unwrap()).
-        into_string().unwrap();
+    let uuid = OsString::from(file_path.file_stem().unwrap())
+        .into_string()
+        .unwrap();
 
     let conn = match rusqlite::Connection::open(path) {
         Ok(conn) => conn,
@@ -314,28 +353,6 @@ fn assignment_complete(assignments: Arc<Mutex<Assignments>>, uuid: String) {
     hm.remove(&uuid);
 }
 
-// Take a given assignment (i.e. a vector of Task objects) and add it to
-// the our HashMap which contains all outstanding work to be processed.  Then
-// signal the uuid of that assignment to our workers.  The first available
-// worker will begin procesing it.  There are basically two ways that this
-// function can get called:
-//
-// 1. At the start of the rebalancer agent when we are loading incomplete
-//    assignments from disk.
-// 2. When we receive an assignment over the network from the rebalancer zone.
-fn assignment_add(
-    agent: &Agent,
-    assignment: Arc<RwLock<Assignment>>,
-    uuidstr: &str,
-) {
-    let mut work = agent.assignments.lock().unwrap();
-
-    work.insert(uuidstr.to_string(), assignment);
-
-    let tx = agent.tx.lock().unwrap();
-    tx.send(uuidstr.to_string()).unwrap();
-}
-
 fn post(agent: Agent, mut state: State) -> Box<HandlerFuture> {
     let f = Body::take_from(&mut state)
         .concat2()
@@ -367,8 +384,9 @@ fn post(agent: Agent, mut state: State) -> Box<HandlerFuture> {
                         .expect("serialized assignment id"),
                 );
 
-                // Add the assignment to the queue for processing.
-                assignment_add(&agent, assignment.clone(), &uuid);
+                // Signal the workers that there is a new assignent ready for
+                // processing.
+                assignment_signal(&agent, &uuid);
                 future::ok((state, res))
             }
             Err(e) => future::err((state, e.into_handler_error())),
@@ -383,29 +401,32 @@ fn empty_response(state: State, code: StatusCode) -> Box<HandlerFuture> {
 
 // First check to see if the assignment in question is located in memory.  If
 // it is, then just return it to the caller, otherwise, go to disk and look
-// through assignments that have already been full processed.
+// through both scheduled and completed assignments for a match.
 fn get_assignment_impl(
     agent: &Agent,
     uuid: &str,
 ) -> Option<Arc<RwLock<Assignment>>> {
-    match assignment_get(&agent.assignments, &uuid) {
-        Some(assignment) => Some(assignment),
-        None => {
-            // If it was not found in memory, then we should check
-            // our records of assignments that have already been
-            // completed.
-            match assignment_recall(format!(
-                "{}/{}",
-                REBALANCER_FINISHED_DIR, &uuid
-            )) {
-                Ok(assignment) => Some(assignment),
-                Err(e) => {
-                    println!("Assignment recall: {}", e);
-                    None
-                }
-            }
-        }
+    // Check in memory.
+    if let Some(assignment) = assignment_get(&agent.assignments, &uuid) {
+        return Some(assignment);
+    }
+
+    // Check completed assignments on disk.
+    if let Ok(assignment) =
+        assignment_recall(format!("{}/{}", REBALANCER_FINISHED_DIR, &uuid))
+    {
+        return Some(assignment);
     }
+
+    // Check scheduled assignments on disk.
+    if let Ok(assignment) =
+        assignment_recall(format!("{}/{}", REBALANCER_SCHEDULED_DIR, &uuid))
+    {
+        return Some(assignment);
+    }
+
+    // No assignment of the supplied uuid was found.
+    None
 }
 
 fn get_assignment(
@@ -426,7 +447,7 @@ fn get_assignment(
                 serde_json::to_vec(&msg).expect("serialized message"),
             );
             return Box::new(future::ok((state, res)));
-        },
+        }
     };
 
     let res = match get_assignment_impl(&agent, uuid) {
@@ -479,10 +500,8 @@ impl Handler for Agent {
                     "assignment" => get_assignment(self, state, path),
                     _ => empty_response(state, StatusCode::NOT_FOUND),
                 }
-            },
-            _ => {
-                empty_response(state, StatusCode::METHOD_NOT_ALLOWED)
-            },
+            }
+            _ => empty_response(state, StatusCode::METHOD_NOT_ALLOWED),
         }
     }
 }
@@ -583,7 +602,7 @@ fn name_to_address(name: &str) -> Result<String, String> {
     let resolver = Resolver::from_system_conf().unwrap();
     let response = match resolver.lookup_ip(name) {
         Ok(resp) => resp,
-        Err(e) => return Err(format!("DNS lookup {}", e)),
+        Err(e) => return Err(format!("name_to_address: {}", e)),
     };
     let shark_ip: Vec<IpAddr> = response.iter().collect();
     Ok(shark_ip[0].to_string())
@@ -609,8 +628,11 @@ fn process_task(task: &mut Task) {
     let shark_ip = match name_to_address(&task.source.manta_storage_id) {
         Ok(addr) => addr,
         Err(e) => {
+            error!(
+                "Unable to resolve {}: {}",
+                &task.source.manta_storage_id, e
+            );
             task.set_status(TaskStatus::Failed(e));
-            println!("DNS lookup error");
             return;
         }
     };
@@ -668,6 +690,13 @@ fn assignment_get(
 // is the only one that will clean up the assignment when we have finished
 // processing it, by calling `assignment_complete()'.
 fn process_assignment(assignments: Arc<Mutex<Assignments>>, uuid: String) {
+    // If we are unsuccessful in loading the assignment from disk, there is
+    // nothing left to do here, other than return.
+    if let Err(e) = load_saved_assignment(&assignments, &uuid) {
+        error!("Unable to load assignment {} from disk: {}", &uuid, e);
+        return;
+    }
+
     let assignment = assignment_get(&assignments, &uuid).unwrap();
     let len = assignment.read().unwrap().tasks.len();
     let mut failures = Vec::new();
@@ -747,7 +776,7 @@ fn router() -> Router {
             });
         }
 
-        load_saved_assignments(&agent);
+        discover_saved_assignments(&agent);
 
         route
             .get("/*")
-- 
2.21.0

