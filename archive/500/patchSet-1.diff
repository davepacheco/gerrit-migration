From 08607d8f0fb718f1ab129b9e1e7dea87d901c017 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Fri, 16 Sep 2016 16:05:48 +0000
Subject: [PATCH] OS-5669 want cached cpuset of active CPUs OS-5668 want
 _MACHDEP-free cpuset_t access

---
 usr/src/uts/common/os/cpu.c     | 23 +++++++---
 usr/src/uts/common/sys/cpuvar.h | 77 ++++++++++++++++++---------------
 2 files changed, 59 insertions(+), 41 deletions(-)

diff --git a/usr/src/uts/common/os/cpu.c b/usr/src/uts/common/os/cpu.c
index 48439a90a5..175c771aff 100644
--- a/usr/src/uts/common/os/cpu.c
+++ b/usr/src/uts/common/os/cpu.c
@@ -21,6 +21,7 @@
 /*
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012 by Delphix. All rights reserved.
+ * Copyright 2016 Joyent, Inc.
  */
 
 /*
@@ -108,6 +109,7 @@ kmutex_t	cpu_lock;
 cpu_t		*cpu_list;		/* list of all CPUs */
 cpu_t		*clock_cpu_list;	/* used by clock to walk CPUs */
 cpu_t		*cpu_active;		/* list of active CPUs */
+cpuset_t	cpu_active_set;		/* cached set of active CPUs */
 static cpuset_t	cpu_available;		/* set of available CPUs */
 cpuset_t	cpu_seqid_inuse;	/* which cpu_seqids are in use */
 
@@ -1724,6 +1726,7 @@ cpu_list_init(cpu_t *cp)
 	cp->cpu_part = &cp_default;
 
 	CPUSET_ADD(cpu_available, cp->cpu_id);
+	CPUSET_ADD(cpu_active_set, cp->cpu_id);
 }
 
 /*
@@ -1895,6 +1898,7 @@ cpu_add_active_internal(cpu_t *cp)
 	cp->cpu_prev_onln = cpu_active->cpu_prev_onln;
 	cpu_active->cpu_prev_onln->cpu_next_onln = cp;
 	cpu_active->cpu_prev_onln = cp;
+	CPUSET_ADD(cpu_active_set, cp->cpu_id);
 
 	if (pp->cp_cpulist) {
 		cp->cpu_next_part = pp->cp_cpulist;
@@ -1965,6 +1969,7 @@ cpu_remove_active(cpu_t *cp)
 	}
 	cp->cpu_next_onln = cp;
 	cp->cpu_prev_onln = cp;
+	CPUSET_DEL(cpu_active_set, cp->cpu_id);
 
 	cp->cpu_prev_part->cpu_next_part = cp->cpu_next_part;
 	cp->cpu_next_part->cpu_prev_part = cp->cpu_prev_part;
@@ -2704,13 +2709,18 @@ cpu_bind_thread(kthread_id_t tp, processorid_t bind, processorid_t *obind,
 	return (0);
 }
 
-#if CPUSET_WORDS > 1
 
-/*
- * Functions for implementing cpuset operations when a cpuset is more
- * than one word.  On platforms where a cpuset is a single word these
- * are implemented as macros in cpuvar.h.
- */
+cpuset_t *
+cpuset_alloc(int kmflags)
+{
+	return (kmem_alloc(sizeof (cpuset_t), kmflags));
+}
+
+void
+cpuset_free(cpuset_t *s)
+{
+	kmem_free(s, sizeof (cpuset_t));
+}
 
 void
 cpuset_all(cpuset_t *s)
@@ -2822,7 +2832,6 @@ cpuset_bounds(cpuset_t *s, uint_t *smallestid, uint_t *largestid)
 	*smallestid = *largestid = CPUSET_NOTINSET;
 }
 
-#endif	/* CPUSET_WORDS */
 
 /*
  * Unbind threads bound to specified CPU.
diff --git a/usr/src/uts/common/sys/cpuvar.h b/usr/src/uts/common/sys/cpuvar.h
index 7b333680c6..2abe03be6b 100644
--- a/usr/src/uts/common/sys/cpuvar.h
+++ b/usr/src/uts/common/sys/cpuvar.h
@@ -23,6 +23,7 @@
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012 by Delphix. All rights reserved.
  * Copyright 2014 Igor Kozhukhov <ikozhukhov@gmail.com>.
+ * Copyright 2016 Joyent, Inc.
  */
 
 #ifndef _SYS_CPUVAR_H
@@ -388,7 +389,7 @@ extern cpu_core_t cpu_core[];
 
 #endif /* _KERNEL || _KMEMUSER */
 
-#if (defined(_KERNEL) || defined(_KMEMUSER)) && defined(_MACHDEP)
+#if (defined(_KERNEL) || defined(_KMEMUSER))
 
 /*
  * Macros for manipulating sets of CPUs as a bitmap.  Note that this
@@ -404,12 +405,20 @@ extern cpu_core_t cpu_core[];
 #define	CPUSET_WORDS	BT_BITOUL(NCPU)
 #define	CPUSET_NOTINSET	((uint_t)-1)
 
-#if	CPUSET_WORDS > 1
-
 typedef struct cpuset {
+#if defined(_MACHDEP)
 	ulong_t	cpub[CPUSET_WORDS];
+#else
+	ulong_t	cpub[1];
+#endif
 } cpuset_t;
 
+
+extern cpuset_t	*cpuset_alloc(int);
+extern void	cpuset_free(cpuset_t *);
+
+#if	!defined(_MACHDEP) || CPUSET_WORDS > 1
+
 /*
  * Private functions for manipulating cpusets that do not fit in a
  * single word.  These should not be used directly; instead the
@@ -424,6 +433,7 @@ extern	void	cpuset_only(cpuset_t *, uint_t);
 extern	uint_t	cpuset_find(cpuset_t *);
 extern	void	cpuset_bounds(cpuset_t *, uint_t *, uint_t *);
 
+
 #define	CPUSET_ALL(set)			cpuset_all(&(set))
 #define	CPUSET_ALL_BUT(set, cpu)	cpuset_all_but(&(set), cpu)
 #define	CPUSET_ONLY(set, cpu)		cpuset_only(&(set), cpu)
@@ -493,42 +503,42 @@ extern	void	cpuset_bounds(cpuset_t *, uint_t *, uint_t *);
 		(set).cpub[_i] = 0;			\
 }
 
-#elif	CPUSET_WORDS == 1
-
-typedef	ulong_t	cpuset_t;	/* a set of CPUs */
+#elif	defined(_MACHDEP) && CPUSET_WORDS == 1
 
 #define	CPUSET(cpu)			(1UL << (cpu))
 
-#define	CPUSET_ALL(set)			((void)((set) = ~0UL))
-#define	CPUSET_ALL_BUT(set, cpu)	((void)((set) = ~CPUSET(cpu)))
-#define	CPUSET_ONLY(set, cpu)		((void)((set) = CPUSET(cpu)))
-#define	CPU_IN_SET(set, cpu)		((set) & CPUSET(cpu))
-#define	CPUSET_ADD(set, cpu)		((void)((set) |= CPUSET(cpu)))
-#define	CPUSET_DEL(set, cpu)		((void)((set) &= ~CPUSET(cpu)))
-#define	CPUSET_ISNULL(set)		((set) == 0)
-#define	CPUSET_ISEQUAL(set1, set2)	((set1) == (set2))
-#define	CPUSET_OR(set1, set2)		((void)((set1) |= (set2)))
-#define	CPUSET_XOR(set1, set2)		((void)((set1) ^= (set2)))
-#define	CPUSET_AND(set1, set2)		((void)((set1) &= (set2)))
-#define	CPUSET_ZERO(set)		((void)((set) = 0))
+#define	CPUSET_ALL(set)			((void)((set).cpub[0] = ~0UL))
+#define	CPUSET_ALL_BUT(set, cpu)	((void)((set).cpub[0] = ~CPUSET(cpu)))
+#define	CPUSET_ONLY(set, cpu)		((void)((set).cpub[0] = CPUSET(cpu)))
+#define	CPU_IN_SET(set, cpu)		((set).cpub[0] & CPUSET(cpu))
+#define	CPUSET_ADD(set, cpu)		((void)((set).cpub[0] |= CPUSET(cpu)))
+#define	CPUSET_DEL(set, cpu)		((void)((set).cpub[0] &= ~CPUSET(cpu)))
+#define	CPUSET_ISNULL(set)		((set).cpub[0] == 0)
+#define	CPUSET_ISEQUAL(set1, set2)	((set1).cpub[0] == (set2).cpub[0])
+#define	CPUSET_OR(set1, set2)	((void)((set1).cpub[0] |= (set2).cpub[0]))
+#define	CPUSET_XOR(set1, set2)	((void)((set1).cpub[0] ^= (set2).cpub[0]))
+#define	CPUSET_AND(set1, set2)	((void)((set1).cpub[0] &= (set2).cpub[0]))
+#define	CPUSET_ZERO(set)	((void)((set).cpub[0] = 0))
 
 #define	CPUSET_FIND(set, cpu)		{		\
-	cpu = (uint_t)(lowbit(set) - 1);				\
+	cpu = (uint_t)(lowbit((set).cpub[0]) - 1);			\
 }
 
 #define	CPUSET_BOUNDS(set, smallest, largest)	{	\
-	smallest = (uint_t)(lowbit(set) - 1);		\
-	largest = (uint_t)(highbit(set) - 1);		\
+	smallest = (uint_t)(lowbit((set).cpub[0]) - 1);		\
+	largest = (uint_t)(highbit((set).cpub[0]) - 1);		\
 }
 
-#define	CPUSET_ATOMIC_DEL(set, cpu)	atomic_and_ulong(&(set), ~CPUSET(cpu))
-#define	CPUSET_ATOMIC_ADD(set, cpu)	atomic_or_ulong(&(set), CPUSET(cpu))
+#define	CPUSET_ATOMIC_DEL(set, cpu)	\
+	atomic_and_ulong((set).cpub, ~CPUSET(cpu))
+#define	CPUSET_ATOMIC_ADD(set, cpu)	\
+	atomic_or_ulong((set).cpub, CPUSET(cpu))
 
 #define	CPUSET_ATOMIC_XADD(set, cpu, result) \
-	{ result = atomic_set_long_excl(&(set), (cpu)); }
+	{ result = atomic_set_long_excl((set).cpub, (cpu)); }
 
 #define	CPUSET_ATOMIC_XDEL(set, cpu, result) \
-	{ result = atomic_clear_long_excl(&(set), (cpu)); }
+	{ result = atomic_clear_long_excl((set).cpub, (cpu)); }
 
 #else	/* CPUSET_WORDS <= 0 */
 
@@ -538,20 +548,13 @@ typedef	ulong_t	cpuset_t;	/* a set of CPUs */
 
 extern cpuset_t cpu_seqid_inuse;
 
-#endif	/* (_KERNEL || _KMEMUSER) && _MACHDEP */
 
-#define	CPU_CPR_OFFLINE		0x0
-#define	CPU_CPR_ONLINE		0x1
-#define	CPU_CPR_IS_OFFLINE(cpu)	(((cpu)->cpu_cpr_flags & CPU_CPR_ONLINE) == 0)
-#define	CPU_CPR_IS_ONLINE(cpu)	((cpu)->cpu_cpr_flags & CPU_CPR_ONLINE)
-#define	CPU_SET_CPR_FLAGS(cpu, flag)	((cpu)->cpu_cpr_flags |= flag)
-
-#if defined(_KERNEL) || defined(_KMEMUSER)
 
 extern struct cpu	*cpu[];		/* indexed by CPU number */
 extern struct cpu	**cpu_seq;	/* indexed by sequential CPU id */
 extern cpu_t		*cpu_list;	/* list of CPUs */
 extern cpu_t		*cpu_active;	/* list of active CPUs */
+extern cpuset_t		cpu_active_set;	/* cached set of active CPUs */
 extern int		ncpus;		/* number of CPUs present */
 extern int		ncpus_online;	/* number of CPUs not quiesced */
 extern int		max_ncpus;	/* max present before ncpus is known */
@@ -611,7 +614,13 @@ extern struct cpu *curcpup(void);
  */
 #define	CPU_NEW_GENERATION(cp)	((cp)->cpu_generation++)
 
-#endif /* _KERNEL || _KMEMUSER */
+#endif /* defined(_KERNEL) || defined(_KMEMUSER) */
+
+#define	CPU_CPR_OFFLINE		0x0
+#define	CPU_CPR_ONLINE		0x1
+#define	CPU_CPR_IS_OFFLINE(cpu)	(((cpu)->cpu_cpr_flags & CPU_CPR_ONLINE) == 0)
+#define	CPU_CPR_IS_ONLINE(cpu)	((cpu)->cpu_cpr_flags & CPU_CPR_ONLINE)
+#define	CPU_SET_CPR_FLAGS(cpu, flag)	((cpu)->cpu_cpr_flags |= flag)
 
 /*
  * CPU support routines.
-- 
2.21.0

