From b4c83229c928c9511c589ef49f910c3e4ee15ae5 Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Wed, 27 Jun 2018 13:26:28 -0500
Subject: [PATCH] fix net delete search

---
 .../uts/common/io/overlay/overlay_target.c    | 156 ++++++++++++------
 1 file changed, 104 insertions(+), 52 deletions(-)

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index 98fe2b4e54..6b49add79b 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -2139,6 +2139,40 @@ overlay_target_cache_iter_copyout(void *ubuf, void *buf, size_t bufsize,
 	return (0);
 }
 
+/*
+ * Take an IPv6 address + prefix length, and turn it into the network address.
+ * E.g. ::ffff:192.168.51.50/120 -> ::fff:192.168.51.0
+ */
+static void
+overlay_in6_to_subnet(const struct in6_addr *src, struct in6_addr *dst,
+    uint8_t prefixlen)
+{
+	uint32_t val;
+
+	for (size_t i = 0; i < 4; i++) {
+		val = ntohl(src->_S6_un._S6_u32[i]);
+		val &= IN6_MASK_FROM_PREFIX(i, prefixlen);
+		dst->_S6_un._S6_u32[i] = htonl(val);
+	}
+}
+
+/*
+ * Take an IPv6 address + prefix length, and turn it into the last address
+ * within that subnet.  E.g. ::fff:10.0.21.12/120 -> 10.0.21.255
+ */
+static void
+overlay_in6_to_lastaddr(const struct in6_addr *src, struct in6_addr *dst,
+    uint8_t prefixlen)
+{
+	uint32_t val;
+
+	for (size_t i = 0; i < 4; i++) {
+		val = ntohl(src->_S6_un._S6_u32[i]);
+		val |= ~IN6_MASK_FROM_PREFIX(i, prefixlen);
+		dst->_S6_un._S6_u32[i] = htonl(val);
+	}
+}
+
 /* ARGSUSED */
 static int
 overlay_target_cache_remove_net(overlay_target_hdl_t *thdl, void *arg)
@@ -2156,30 +2190,6 @@ overlay_target_cache_remove_net(overlay_target_hdl_t *thdl, void *arg)
 	if (odd == NULL)
 		return (ENOENT);
 
-	cmp.otvl3_src_vlan = otcne->otcne_vlan;
-
-	/*
-	 * A bit ugly, but as explained below, these need to be the network
-	 * addresses for the src/dst subnets.
-	 */
-	cmp.otvl3_src._S6_un._S6_u32[0] = otcne->otcne_src._S6_un._S6_u32[0] &
-	    IN6_MASK_FROM_PREFIX(0, otcne->otcne_src_prefixlen);
-	cmp.otvl3_src._S6_un._S6_u32[1] = otcne->otcne_src._S6_un._S6_u32[1] &
-	    IN6_MASK_FROM_PREFIX(1, otcne->otcne_src_prefixlen);
-	cmp.otvl3_src._S6_un._S6_u32[2] = otcne->otcne_src._S6_un._S6_u32[2] &
-	    IN6_MASK_FROM_PREFIX(2, otcne->otcne_src_prefixlen);
-	cmp.otvl3_src._S6_un._S6_u32[3] = otcne->otcne_src._S6_un._S6_u32[3] &
-	    IN6_MASK_FROM_PREFIX(3, otcne->otcne_src_prefixlen);
-
-	cmp.otvl3_dst._S6_un._S6_u32[0] = otcne->otcne_dst._S6_un._S6_u32[0] &
-	    IN6_MASK_FROM_PREFIX(0, otcne->otcne_dst_prefixlen);
-	cmp.otvl3_dst._S6_un._S6_u32[1] = otcne->otcne_dst._S6_un._S6_u32[1] &
-	    IN6_MASK_FROM_PREFIX(1, otcne->otcne_dst_prefixlen);
-	cmp.otvl3_dst._S6_un._S6_u32[2] = otcne->otcne_dst._S6_un._S6_u32[2] &
-	    IN6_MASK_FROM_PREFIX(2, otcne->otcne_dst_prefixlen);
-	cmp.otvl3_dst._S6_un._S6_u32[3] = otcne->otcne_dst._S6_un._S6_u32[3] &
-	    IN6_MASK_FROM_PREFIX(3, otcne->otcne_dst_prefixlen);
-
 	mutex_enter(&odd->odd_lock);
 	if (!(odd->odd_flags & OVERLAY_F_VARPD)) {
 		mutex_exit(&odd->odd_lock);
@@ -2194,29 +2204,33 @@ overlay_target_cache_remove_net(overlay_target_hdl_t *thdl, void *arg)
 	}
 	mutex_enter(&ott->ott_lock);
 	mutex_exit(&odd->odd_lock);
-	avl = &ott->ott_u.ott_dyn.ott_l3tree;
-
-	/*
-	 * For deleting all the entries between two networks, we first locate
-	 * the entry just before the given net addresses.  VL3 target entries
-	 * are sorted by <src ip, dst ip, src vlan>, so the subnet address
-	 * (i.e. 192.168.1.0) will always sort before any addresses within
-	 * the subnet.  Therefore, the entry just before where the subnet
-	 * addresses would go the entry that immediately preceeds any
-	 * potential matching entries (note that we should never actually
-	 * have the subnet addresses stored as target entries as that would
-	 * not make any sense).  We find the entry immediately before where
-	 * any potential entries are (or if NULL, that means any potential
-	 * matches would be the first entries when sorted), then start
-	 * iterating through the subsequent entries until we either exhaust
-	 * all our entries, or find an entry no longer in range.  The latter
-	 * indicating we've iterated all potential matches.
-	 */
 
 	/*
-	 * Find where the network address would be in the tree, but should
-	 * never actually see them in the tree.
+	 * Entries are sorted in the AVL tree by src ip, dst ip, src vlan.
+	 * To find the entries to delete, we search for the source subnet (w
+	 * use the prefix length to guarantee we have a network address) with
+	 * the dst ip and src vlan fields set to 0 (cmp is initialized to 0).
+	 * Since we do not store network addresses as entries, this should fail,
+	 * By noting the location where such an entry would reside, the nearest
+	 * neighbor prior to that location will be the entry that immediately
+	 * preceeds any possible entries in the source subnet.  We use that
+	 * entry to skip into the tree as close to any entries that need to
+	 * be removed as we can.  However there might be entries with a
+	 * destination subnet that is less than (as a bytewise comparison)
+	 * the subnet we are interested in.  Similarly, as we could have
+	 * duplicate src subnet values but with different vlan values.  We
+	 * skip past any entries whose destination ip is less than (as a
+	 * per-byte comparison) the destination subnet we're interested as
+	 * well as any entries whose source subnet is less than the one we're
+	 * interested in.  Once we reach any entries whose src ip doesn't match,
+	 * or whose dst ip is greater than the last IP in the subnet, or whose
+	 * src vlan is not the one we're interested in, we are past where any
+	 * possible matching entries can reside, and can stop iterating through
+	 * the tree.
 	 */
+	avl = &ott->ott_u.ott_dyn.ott_l3tree;
+	overlay_in6_to_subnet(&otcne->otcne_src, &cmp.otvl3_src,
+	    otcne->otcne_src_prefixlen);
 	VERIFY3P(avl_find(avl, &cmp, &where), ==, NULL);
 
 	ote = avl_nearest(avl, where, AVL_BEFORE);
@@ -2225,19 +2239,57 @@ overlay_target_cache_remove_net(overlay_target_hdl_t *thdl, void *arg)
 	else
 		ote = AVL_NEXT(avl, ote);
 
-#define	IN_RANGE(_ote, _otcne)						\
-    (IN6_ARE_PREFIXEDADDR_EQUAL(&(_ote)->ote_u.ote_vl3.otvl3_src,	\
-    &(_otcne)->otcne_src, (_otcne)->otcne_src_prefixlen) &&		\
-    IN6_ARE_PREFIXEDADDR_EQUAL(&(_ote)->ote_u.ote_vl3.otvl3_dst,	\
-    &(_otcne)->otcne_dst, (_otcne)->otcne_dst_prefixlen) &&		\
-    (_ote)->ote_u.ote_vl3.otvl3_src_vlan == (_otcne)->otcne_vlan)
+	overlay_in6_to_lastaddr(&otcne->otcne_dst, &cmp.otvl3_dst,
+	    otcne->otcne_dst_prefixlen);
+	cmp.otvl3_src_vlan = otcne->otcne_vlan;
 
-	while (ote != NULL && IN_RANGE(ote, otcne)) {
+#define	IN_RANGE(_cmp, _ote)						\
+    ((memcmp(&(_cmp)->otvl3_src, &(_ote)->ote_u.ote_vl3.otvl3_src,	\
+    sizeof (struct in6_addr)) < 0) &&					\
+    (memcmp(&(_cmp)->otvl3_dst, &(_ote)->ote_u.ote_vl3.otvl3_dst,	\
+    sizeof (struct in6_addr)) >= 0) &&					\
+    (_ote)->ote_u.ote_vl3.otvl3_src_vlan <= (_cmp)->otvl3_src_vlan)
+
+	for (; ote != NULL && IN_RANGE(&cmp, ote); ote = ote_next) {
 		ote_next = AVL_NEXT(avl, ote);
+
+		/*
+		 * Since entries are ordered first by src address, once we
+		 * see entries not in the subnet, there are no further entries
+		 * to remove.
+		 */
+		if (!IN6_ARE_PREFIXEDADDR_EQUAL(&cmp.otvl3_src,
+		    &ote->ote_u.ote_vl3.otvl3_src, otcne->otcne_src_prefixlen))
+			break;
+
+		/*
+		 * IN_RANGE() guarantees that the dst ip is <= the last IP
+		 * in the subnet we are interested in.  If it's not within
+		 * the subnet, it means we haven't reached any potential
+		 * entries yet.
+		 */
+		if (!IN6_ARE_PREFIXEDADDR_EQUAL(&cmp.otvl3_dst,
+		    &ote->ote_u.ote_vl3.otvl3_dst,
+		    otcne->otcne_dst_prefixlen)) {
+			ASSERT3S(memcmp(&cmp.otvl3_dst,
+			    &ote->ote_u.ote_vl3.otvl3_dst,
+			    sizeof (struct in6_addr)), <, 0);
+			continue;
+		}
+
+		if (ote->ote_u.ote_vl3.otvl3_src_vlan < otcne->otcne_vlan)
+			continue;
+
+		ASSERT(IN6_ARE_PREFIXEDADDR_EQUAL(&otcne->otcne_src,
+		    &ote->ote_u.ote_vl3.otvl3_src, otcne->otcne_src_prefixlen));
+		ASSERT(IN6_ARE_PREFIXEDADDR_EQUAL(&otcne->otcne_dst,
+		    &ote->ote_u.ote_vl3.otvl3_dst, otcne->otcne_dst_prefixlen));
+		ASSERT3U(ote->ote_u.ote_vl3.otvl3_src_vlan, ==,
+		    otcne->otcne_vlan);
+
 		sarc_remove(ott->ott_u.ott_dyn.ott_l3dhash, ote);
 		ote = ote_next;
 	}
-
 #undef	IN_RANGE
 
 	mutex_exit(&ott->ott_lock);
-- 
2.21.0

