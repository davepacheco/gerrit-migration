commit 9775e18ae2f65dca31b0dda3761f276bcb252375 (refs/changes/12/612/8)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2016-10-06T23:28:31-07:00 (3 years ago)
    
    joyent/node-mooremachine#9 substates are broken
    Reviewed by: Cody Mello <cody.mello@joyent.com>

diff --git a/lib/fsm.js b/lib/fsm.js
index 65d519c..fb77838 100644
--- a/lib/fsm.js
+++ b/lib/fsm.js
@@ -50,6 +50,12 @@ FSMStateHandle.prototype.gotoState = function (state) {
 	return (this.fsh_fsm._gotoState(state));
 };
 
+FSMStateHandle.prototype.reset = function () {
+	this.fsh_valid = true;
+	this.fsh_nextState = undefined;
+};
+
+/* Disconnect just this handle, returning our parent handle (if any). */
 FSMStateHandle.prototype.disconnect = function () {
 	var ls = this.fsh_listeners;
 	for (var i = 0; i < ls.length; ++i) {
@@ -71,8 +77,17 @@ FSMStateHandle.prototype.disconnect = function () {
 	this.fsh_timeouts = [];
 	this.fsh_intervals = [];
 	this.fsh_immediates = [];
-	if (this.fsh_link !== undefined)
-		this.fsh_link.disconnect();
+	this.fsh_valid = false;
+	var link = this.fsh_link;
+	this.fsh_link = undefined;
+	return (link);
+};
+
+/* Disconnect this handle and all parents. */
+FSMStateHandle.prototype.disconnectAll = function () {
+	var l = this.disconnect();
+	if (l !== undefined)
+		l.disconnectAll();
 };
 
 FSMStateHandle.prototype.on = function (obj, evt, cb) {
@@ -171,14 +186,44 @@ FSM.prototype._gotoState = function (state) {
 	}
 
 	/*
-	 * If we're changing to a state that is not a sub-state of this one,
-	 * then kill of all timers and listeners we created in this state.
+	 * First, kill event handlers and timers from our previous state, as
+	 * needed.
 	 */
 	var parts = (this.fsm_state ? this.fsm_state.split('.') : ['']);
 	var newParts = state.split('.');
-	if (parts[0] !== newParts[0] && this.fsm_handle !== undefined) {
-		this.fsm_handle.disconnect();
-		this.fsm_handle = undefined;
+	if (newParts.length > 2)
+		throw (new Error('Invalid FSM destination state: ' + state));
+	if (this.fsm_handle !== undefined) {
+		if (parts[0] === newParts[0] && parts[1] === undefined &&
+		    newParts[1] !== undefined) {
+			/*
+			 * e.g. 'connected' => 'connected.idle'. Don't
+			 * disconnect anything.
+			 */
+			this.fsm_handle.reset();
+		} else if (parts[0] === newParts[0] && parts[1] !== undefined &&
+		    newParts[1] !== undefined) {
+			/*
+			 * e.g. 'connected.idle' => 'connected.busy'. Just
+			 * disconnect the things we set up in 'connected.idle'
+			 * while leaving things from 'connected' alone. Also
+			 * reset the parent handle in case it was the cause of
+			 * the transition.
+			 *
+			 * Note we end up here if we're re-entering the same
+			 * exact state, too.
+			 */
+			this.fsm_handle = this.fsm_handle.disconnect();
+			if (this.fsm_handle !== undefined)
+				this.fsm_handle.reset();
+		} else {
+			/*
+			 * e.g. 'connected' => 'closing'. Disconnect all
+			 * handlers (including from any parent states).
+			 */
+			this.fsm_handle.disconnectAll();
+			this.fsm_handle = undefined;
+		}
 	}
 
 	var f = this['state_' + newParts[0]];
diff --git a/test/basic.test.js b/test/basic.test.js
index 2eb5cb9..ebd9dc5 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -110,3 +110,150 @@ test('double transition', function (t) {
 		});
 	});
 });
+
+test('substates', function (t) {
+	var Class = function () {
+		FSM.call(this, 'initial');
+	};
+	util.inherits(Class, FSM);
+	Class.prototype.state_initial = function (S) {
+		S.on(this, 'foo', function () {
+			S.gotoState('next');
+		});
+		S.on(this, 'bar', function () {
+			S.gotoState('initial.sub1');
+		});
+	};
+	Class.prototype.state_initial.sub1 = function (S) {
+		S.on(this, 'foobar', function () {
+			S.gotoState('initial.sub2');
+		});
+	};
+	Class.prototype.state_initial.sub2 = function (S) {
+		S.on(this, 'baz', function () {
+			S.gotoState('initial.sub1');
+		});
+	};
+	Class.prototype.state_next = function (S) {
+		S.validTransitions([]);
+	};
+
+	var c = new Class();
+	var history = [];
+	c.on('stateChanged', function (st) {
+		history.push(st);
+	});
+	t.ok(c.isInState('initial'));
+	t.ok(!c.isInState('initial.sub1'));
+	t.ok(!c.isInState('initial.sub2'));
+	c.emit('bar');
+	t.ok(c.isInState('initial.sub1'));
+	t.strictEqual(c.listeners('foobar').length, 1);
+	t.strictEqual(c.listeners('foo').length, 1);
+	c.emit('foobar');
+	t.ok(c.isInState('initial.sub2'));
+	t.strictEqual(c.listeners('foobar').length, 0);
+	c.emit('foobar');
+	t.ok(c.isInState('initial.sub2'));
+	c.emit('baz');
+	t.ok(c.isInState('initial.sub1'));
+	c.emit('foobar');
+	c.emit('bar');
+	t.ok(c.isInState('initial.sub1'));
+	c.emit('foo');
+	t.ok(c.isInState('next'));
+
+	setImmediate(function () {
+		t.deepEqual(history, ['initial', 'initial.sub1',
+		    'initial.sub2', 'initial.sub1', 'initial.sub2',
+		    'initial.sub1', 'next']);
+		t.end();
+	});
+});
+
+/*
+ * Note that re-entry into the same state is legal, but discouraged. We keep
+ * the test here to verify that it works in the basic case, but making
+ * heavy use of it is usually a sign of a poorly considered state model.
+ */
+test('re-entry into same state', function (t) {
+	var Class = function () {
+		FSM.call(this, 'initial');
+	};
+	util.inherits(Class, FSM);
+	Class.prototype.state_initial = function (S) {
+		S.on(this, 'foo', function () {
+			S.gotoState('initial');
+		});
+	};
+
+	var c = new Class();
+	var history = [];
+	c.on('stateChanged', function (st) {
+		history.push(st);
+	});
+	t.ok(c.isInState('initial'));
+	c.emit('foo');
+	t.ok(c.isInState('initial'));
+	setImmediate(function () {
+		t.deepEqual(history, ['initial', 'initial']);
+		t.end();
+	});
+});
+
+test('re-entry to parent state', function (t) {
+	var Class = function () {
+		FSM.call(this, 'initial');
+	};
+	util.inherits(Class, FSM);
+	Class.prototype.state_initial = function (S) {
+		S.on(this, 'foo', function () {
+			S.gotoState('initial.sub1');
+		});
+	};
+	Class.prototype.state_initial.sub1 = function (S) {
+		S.on(this, 'bar', function () {
+			S.gotoState('initial');
+		});
+	};
+
+	var c = new Class();
+	var history = [];
+	c.on('stateChanged', function (st) {
+		history.push(st);
+	});
+	t.ok(c.isInState('initial'));
+	c.emit('foo');
+	c.emit('bar');
+	c.emit('foo');
+	c.emit('foo');
+	c.emit('bar');
+	t.ok(c.isInState('initial'));
+	t.strictEqual(c.listeners('foo').length, 1);
+	t.strictEqual(c.listeners('bar').length, 0);
+
+	setImmediate(function () {
+		t.deepEqual(history, ['initial', 'initial.sub1', 'initial',
+		    'initial.sub1', 'initial.sub1', 'initial']);
+		t.end();
+	});
+});
+
+test('too many dots in state name', function (t) {
+	var Class = function () {
+		FSM.call(this, 'initial');
+	};
+	util.inherits(Class, FSM);
+	Class.prototype.state_initial = function (S) {
+		S.on(this, 'foo', function () {
+			S.gotoState('initial.foo.bar');
+		});
+	};
+
+	var c = new Class();
+	t.ok(c.isInState('initial'));
+	t.throws(function () {
+		c.emit('foo');
+	});
+	t.end();
+});
