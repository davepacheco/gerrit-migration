From 2261184dffcb25b7fdb20eb85b94fdfc407d96f5 Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Mon, 26 Feb 2018 21:46:24 +0000
Subject: [PATCH] MORAY-458 Make "_moray_had_err" the responsible Error instead
 of a boolean Reviewed by: Tim Kordas <tim.kordas@joyent.com> Approved by: Tim
 Kordas <tim.kordas@joyent.com>

---
 lib/pg.js | 26 +++++++++++++++-----------
 1 file changed, 15 insertions(+), 11 deletions(-)

diff --git a/lib/pg.js b/lib/pg.js
index e74fbd0..695f8c6 100644
--- a/lib/pg.js
+++ b/lib/pg.js
@@ -19,6 +19,7 @@ var once = require('once');
 var pg = require('pg');
 require('pg-parse-float')(pg);
 var pooling = require('pooling');
+var VError = require('verror');
 
 var dtrace = require('./dtrace');
 
@@ -75,6 +76,7 @@ function PGClient(options) {
     this._moray_id = CLIENT_ID;
     this._defaultTimeout = options.queryTimeout;
     this._queryTimeout = options.queryTimeout;
+    this._moray_had_err = null;
     this._moray_txn = false;
     this._reqid = null;
 
@@ -98,7 +100,7 @@ PGClient.prototype._handleClientError = function (err) {
         client: this
     }, 'pg: client emitted an error');
 
-    this._moray_had_err = true;
+    this._moray_had_err = new VError(err, 'Postgres client failed');
 };
 
 
@@ -226,6 +228,8 @@ PGClient.prototype.query = function clientQuery(sql, args) {
 
     if (this._queryTimeout > 0) {
         timer = setTimeout(function onRowTimeout() {
+            var err = new QueryTimeoutError(sql);
+
             /*
              * Don't ROLLBACK, since it may or may not make
              * it to the server, and the query we just timed
@@ -233,7 +237,7 @@ PGClient.prototype.query = function clientQuery(sql, args) {
              * just force a connection close to happen once
              * the connection is out of the pool.
              */
-            self._moray_had_err = true;
+            self._moray_had_err = err;
 
             dtrace['query-timeout'].fire(function () {
                 return ([reqid, sql]);
@@ -251,7 +255,7 @@ PGClient.prototype.query = function clientQuery(sql, args) {
              */
             aborted = true;
 
-            res.emit('error', new QueryTimeoutError(sql));
+            res.emit('error', err);
         }, this._queryTimeout);
     }
 
@@ -283,8 +287,8 @@ PGClient.prototype.begin = function transactionBegin(level, cb) {
 
     var q = self.query('BEGIN TRANSACTION ISOLATION LEVEL ' + level);
 
-    q.once('error', function (err) {
-        self._moray_had_err = true;
+    q.once('error', function onBeginTransactionError(err) {
+        self._moray_had_err = new VError(err, 'Failed to begin transaction');
         cb(err);
     });
 
@@ -325,8 +329,8 @@ PGClient.prototype.commit = function transactionCommit(cb) {
 
     var q = self.query('COMMIT');
 
-    q.once('error', function (err) {
-        self._moray_had_err = true;
+    q.once('error', function onCommitError(err) {
+        self._moray_had_err = new VError(err, 'Failed to commit transaction');
         _cb(err);
     });
 
@@ -365,15 +369,15 @@ PGClient.prototype.rollback = function transactionRollback(cb) {
      * as the ROLLBACK returns, so failing fast here and letting Postgres abort
      * the transaction itself seems to be a better approach.
      */
-    if (!self._moray_txn || self._moray_had_err) {
+    if (!self._moray_txn || self._moray_had_err !== null) {
         _cb();
         return;
     }
 
     var q = self.query('ROLLBACK');
 
-    q.once('error', function (err) {
-        self._moray_had_err = true;
+    q.once('error', function onRollbackError(err) {
+        self._moray_had_err = new VError(err, 'Failed to rollback transaction');
         _cb(err);
     });
 
@@ -410,7 +414,7 @@ function pgAssert(_pg) {
     assert.ok(!_pg.client.connection.stream.destroyed, 'pg not destroyed');
     assert.ok(_pg.client.connection.stream.writable, 'pg writable');
 
-    return (!_pg._moray_had_err);
+    return (_pg._moray_had_err === null);
 }
 
 
-- 
2.21.0

