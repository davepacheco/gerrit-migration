commit fffaa6c866acdef116a501cd1eb600eea59c02a9 (refs/changes/78/5278/1)
Author: Robert Mustacchi <rm@joyent.com>
Date:   2018-12-20T21:45:38+00:00 (10 months ago)
    
    OS-7467 libproc ia32 Pstack_iter() should leverage ctf

diff --git a/usr/src/lib/libproc/amd64/Pisadep.c b/usr/src/lib/libproc/amd64/Pisadep.c
index 8ef8340b02..9671ab9d63 100644
--- a/usr/src/lib/libproc/amd64/Pisadep.c
+++ b/usr/src/lib/libproc/amd64/Pisadep.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2018, Joyent, Inc.
  */
 
 #include <sys/stack.h>
@@ -158,6 +159,28 @@ Pissyscall_text(struct ps_prochandle *P, const void *buf, size_t buflen)
 
 #define	TR_ARG_MAX 6	/* Max args to print, same as SPARC */
 
+static boolean_t
+argcount_ctf(struct ps_prochandle *P, uint32_t pc, ulong_t *countp)
+{
+	GElf_Sym sym;
+	ctf_file_t *ctfp;
+	ctf_funcinfo_t finfo;
+	prsyminfo_t si = { 0 };
+
+	if (Pxlookup_by_addr(P, pc, NULL, 0, &sym, &si) != 0)
+		return (B_FALSE);
+
+	if ((ctfp = Paddr_to_ctf(P, pc)) == NULL)
+		return (B_FALSE);
+
+	if (ctf_func_info(ctfp, si.prs_id, &finfo) == CTF_ERR)
+		return (B_FALSE);
+
+	*countp = finfo.ctc_argc;
+
+	return (B_TRUE);
+}
+
 /*
  * Given a return address, determine the likely number of arguments
  * that were pushed on the stack prior to its execution.  We do this by
@@ -180,6 +203,15 @@ argcount(struct ps_prochandle *P, uint32_t pc, ssize_t sz)
 	uchar_t instr[6];
 	ulong_t count, max;
 
+	/*
+	 * Attempt to use CTF to lookup the number of arguments this function
+	 * should have. If we can't find anything, default to the traditional
+	 * discovery method described above.
+	 */
+	if (argcount_ctf(P, pc, &count)) {
+		return (count);
+	}
+
 	max = MIN(sz / sizeof (uint32_t), TR_ARG_MAX);
 
 	/*
@@ -465,7 +497,7 @@ read_args(struct ps_prochandle *P, uintptr_t fp, uintptr_t pc, prgreg_t *args,
 
 int
 Pstack_iter(struct ps_prochandle *P, const prgregset_t regs,
-	proc_stack_f *func, void *arg)
+    proc_stack_f *func, void *arg)
 {
 	struct {
 		uintptr_t fp;
diff --git a/usr/src/lib/libproc/i386/Pisadep.c b/usr/src/lib/libproc/i386/Pisadep.c
index e09b40bb73..f0527f4906 100644
--- a/usr/src/lib/libproc/i386/Pisadep.c
+++ b/usr/src/lib/libproc/i386/Pisadep.c
@@ -21,6 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2018, Joyent, Inc.
  */
 
 #include <sys/stack.h>
@@ -118,6 +119,28 @@ Pissyscall_text(struct ps_prochandle *P, const void *buf, size_t buflen)
 
 #define	TR_ARG_MAX 6	/* Max args to print, same as SPARC */
 
+static boolean_t
+argcount_ctf(struct ps_prochandle *P, long pc, ulong_t *countp)
+{
+	GElf_Sym sym;
+	ctf_file_t *ctfp;
+	ctf_funcinfo_t finfo;
+	prsyminfo_t si = { 0 };
+
+	if (Pxlookup_by_addr(P, pc, NULL, 0, &sym, &si) != 0)
+		return (B_FALSE);
+
+	if ((ctfp = Paddr_to_ctf(P, pc)) == NULL)
+		return (B_FALSE);
+
+	if (ctf_func_info(ctfp, si.prs_id, &finfo) == CTF_ERR)
+		return (B_FALSE);
+
+	*countp = finfo.ctc_argc;
+
+	return (B_TRUE);
+}
+
 /*
  * Given a return address, determine the likely number of arguments
  * that were pushed on the stack prior to its execution.  We do this by
@@ -140,6 +163,15 @@ argcount(struct ps_prochandle *P, long pc, ssize_t sz)
 	uchar_t instr[6];
 	ulong_t count, max;
 
+	/*
+	 * Attempt to use CTF to lookup the number of arguments this function
+	 * should have. If we can't find anything, default to the traditional
+	 * discovery method described above.
+	 */
+	if (argcount_ctf(P, pc, &count)) {
+		return (count);
+	}
+
 	max = MIN(sz / sizeof (long), TR_ARG_MAX);
 
 	/*
@@ -172,7 +204,7 @@ ucontext_n_to_prgregs(const ucontext_t *src, prgregset_t dst)
 
 int
 Pstack_iter(struct ps_prochandle *P, const prgregset_t regs,
-	proc_stack_f *func, void *arg)
+    proc_stack_f *func, void *arg)
 {
 	prgreg_t *prevfp = NULL;
 	uint_t pfpsize = 0;
