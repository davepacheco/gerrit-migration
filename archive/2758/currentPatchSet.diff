commit d75322689f0e889d6cf3f26063c9149a154a2641 (refs/changes/58/2758/4)
Author: Robert Mustacchi <rm@joyent.com>
Date:   2017-10-13T01:08:29+00:00 (2 years ago)
    
    OS-5531 smbios(1M) could decode voltage and curent probes
    OS-6379 smbios(1M) could decode cooling devices
    OS-5532 smbios(1M) could decode temperature probes
    OS-6378 smb_impl.h structs should comment corresponding type
    OS-6380 overshifted smbios major version leads to undershifted data
    OS-6381 smbios(1M) shouldn't print non-existant bios versions
    Reviewed by: Tim Kordas <tim.kordas@joyent.com>
    Reviewed by: Dan McDonald <danmcd@joyent.com>
    Approved by: Jason King <jason.king@joyent.com>

diff --git a/usr/src/cmd/smbios/smbios.c b/usr/src/cmd/smbios/smbios.c
index c7bd5d75c6..8c1d7a4d7e 100644
--- a/usr/src/cmd/smbios/smbios.c
+++ b/usr/src/cmd/smbios/smbios.c
@@ -314,7 +314,13 @@ print_bios(smbios_hdl_t *shp, FILE *fp)
 		    b.smbb_biosv.smbv_major, b.smbb_biosv.smbv_minor);
 	}
 
-	if (b.smbb_nxcflags > SMB_BIOSXB_ECFW_MIN) {
+	/*
+	 * If the major and minor versions are 0xff then that indicates that the
+	 * embedded controller does not exist.
+	 */
+	if (b.smbb_nxcflags > SMB_BIOSXB_ECFW_MIN &&
+	    b.smbb_ecfwv.smbv_major != 0xff &&
+	    b.smbb_ecfwv.smbv_minor != 0xff) {
 		oprintf(fp, "  Embedded Ctlr Firmware Version Number: %u.%u\n",
 		    b.smbb_ecfwv.smbv_major, b.smbb_ecfwv.smbv_minor);
 	}
@@ -976,6 +982,227 @@ print_hwsec(smbios_hdl_t *shp, FILE *fp)
 	    fp, "  Front Panel Reset Status: %u", h.smbh_pan_ps);
 }
 
+static void
+print_vprobe(smbios_hdl_t *shp, id_t id, FILE *fp)
+{
+	smbios_vprobe_t vp;
+
+	if (smbios_info_vprobe(shp, id, &vp) != 0) {
+		smbios_warn(shp, "failed to read voltage probe information");
+		return;
+	}
+
+	oprintf(fp, "  Description: %s\n", vp.smbvp_description != NULL ?
+	    vp.smbvp_description : "unknown");
+	desc_printf(smbios_vprobe_loc_desc(vp.smbvp_location),
+	    fp, "  Location: %u", vp.smbvp_location);
+	desc_printf(smbios_vprobe_status_desc(vp.smbvp_status),
+	    fp, "  Status: %u", vp.smbvp_status);
+
+	if (vp.smbvp_maxval != 0x8000) {
+		oprintf(fp, "  Maximum Possible Voltage: %u mV\n",
+		    vp.smbvp_maxval);
+	} else {
+		oprintf(fp, "  Maximum Possible Voltage: unknown\n");
+	}
+
+	if (vp.smbvp_minval != 0x8000) {
+		oprintf(fp, "  Minimum Possible Voltage: %u mV\n",
+		    vp.smbvp_minval);
+	} else {
+		oprintf(fp, "  Minimum Possible Voltage: unknown\n");
+	}
+
+	if (vp.smbvp_resolution != 0x8000) {
+		oprintf(fp, "  Probe Resolution: %u.%u mV\n",
+		    vp.smbvp_resolution / 10,
+		    vp.smbvp_resolution % 10);
+	} else {
+		oprintf(fp, "  Probe Resolution: unknown\n");
+	}
+
+	if (vp.smbvp_tolerance != 0x8000) {
+		oprintf(fp, "  Probe Tolerance: +/-%u mV\n",
+		    vp.smbvp_tolerance);
+	} else {
+		oprintf(fp, "  Probe Tolerance: unknown\n");
+	}
+
+	if (vp.smbvp_accuracy != 0x8000) {
+		oprintf(fp, "  Probe Accuracy: +/-%u.%02u%%\n",
+		    vp.smbvp_accuracy / 100,
+		    vp.smbvp_accuracy % 100);
+	} else {
+		oprintf(fp, "  Probe Accuracy: unknown\n");
+	}
+
+	oprintf(fp, "  OEM- or BIOS- defined value: 0x%x\n", vp.smbvp_oem);
+
+	if (vp.smbvp_nominal != 0x8000) {
+		oprintf(fp, "  Probe Nominal Value: %u mV\n", vp.smbvp_nominal);
+	} else {
+		oprintf(fp, "  Probe Nominal Value: unknown\n");
+	}
+}
+
+static void
+print_cooldev(smbios_hdl_t *shp, id_t id, FILE *fp)
+{
+	smbios_cooldev_t cd;
+
+	if (smbios_info_cooldev(shp, id, &cd) != 0) {
+		smbios_warn(shp, "failed to read cooling device "
+		    "information");
+		return;
+	}
+
+	oprintf(fp, "  Temperature Probe Handle: %u\n", cd.smbcd_tprobe);
+	desc_printf(smbios_cooldev_type_desc(cd.smbcd_type),
+	    fp, "  Device Type: %u", cd.smbcd_type);
+	desc_printf(smbios_cooldev_status_desc(cd.smbcd_status),
+	    fp, "  Status: %u", cd.smbcd_status);
+	oprintf(fp, "  Cooling Unit Group: %u\n", cd.smbcd_group);
+	oprintf(fp, "  OEM- or BIOS- defined data: 0x%x\n", cd.smbcd_oem);
+	if (cd.smbcd_nominal != 0x8000) {
+		oprintf(fp, "  Nominal Speed: %u RPM\n", cd.smbcd_nominal);
+	} else {
+		oprintf(fp, "  Nominal Speed: unknown\n");
+	}
+
+	if (cd.smbcd_descr != NULL && cd.smbcd_descr[0] != '\0') {
+		oprintf(fp, "  Description: %s\n", cd.smbcd_descr);
+	}
+}
+
+static void
+print_tprobe(smbios_hdl_t *shp, id_t id, FILE *fp)
+{
+	smbios_tprobe_t tp;
+
+	if (smbios_info_tprobe(shp, id, &tp) != 0) {
+		smbios_warn(shp, "failed to read temperature probe "
+		    "information");
+		return;
+	}
+
+	oprintf(fp, "  Description: %s\n", tp.smbtp_description != NULL ?
+	    tp.smbtp_description : "unknown");
+	desc_printf(smbios_tprobe_loc_desc(tp.smbtp_location),
+	    fp, "  Location: %u", tp.smbtp_location);
+	desc_printf(smbios_tprobe_status_desc(tp.smbtp_status),
+	    fp, "  Status: %u", tp.smbtp_status);
+
+	if (tp.smbtp_maxval != 0x8000) {
+		oprintf(fp, "  Maximum Possible Temperature: %u.%u C\n",
+		    tp.smbtp_maxval / 10, tp.smbtp_maxval % 10);
+	} else {
+		oprintf(fp, "  Maximum Possible Temperature: unknown\n");
+	}
+
+	if (tp.smbtp_minval != 0x8000) {
+		oprintf(fp, "  Minimum Possible Temperature: %u.%u C\n",
+		    tp.smbtp_minval / 10, tp.smbtp_minval % 10);
+	} else {
+		oprintf(fp, "  Minimum Possible Temperature: unknown\n");
+	}
+
+	if (tp.smbtp_resolution != 0x8000) {
+		oprintf(fp, "  Probe Resolution: %u.%03u C\n",
+		    tp.smbtp_resolution / 1000,
+		    tp.smbtp_resolution % 1000);
+	} else {
+		oprintf(fp, "  Probe Resolution: unknown\n");
+	}
+
+	if (tp.smbtp_tolerance != 0x8000) {
+		oprintf(fp, "  Probe Tolerance: +/-%u.%u C\n",
+		    tp.smbtp_tolerance / 10, tp.smbtp_tolerance % 10);
+	} else {
+		oprintf(fp, "  Probe Tolerance: unknown\n");
+	}
+
+	if (tp.smbtp_accuracy != 0x8000) {
+		oprintf(fp, "  Probe Accuracy: +/-%u.%02u%%\n",
+		    tp.smbtp_accuracy / 100,
+		    tp.smbtp_accuracy % 100);
+	} else {
+		oprintf(fp, "  Probe Accuracy: unknown\n");
+	}
+
+	oprintf(fp, "  OEM- or BIOS- defined value: 0x%x\n", tp.smbtp_oem);
+
+	if (tp.smbtp_nominal != 0x8000) {
+		oprintf(fp, "  Probe Nominal Value: %u C\n",
+		    tp.smbtp_nominal / 10, tp.smbtp_nominal % 10);
+	} else {
+		oprintf(fp, "  Probe Nominal Value: unknown\n");
+	}
+}
+
+static void
+print_iprobe(smbios_hdl_t *shp, id_t id, FILE *fp)
+{
+	smbios_iprobe_t ip;
+
+	if (smbios_info_iprobe(shp, id, &ip) != 0) {
+		smbios_warn(shp, "failed to read current probe information");
+		return;
+	}
+
+	oprintf(fp, "  Description: %s\n", ip.smbip_description != NULL ?
+	    ip.smbip_description : "unknown");
+	desc_printf(smbios_iprobe_loc_desc(ip.smbip_location),
+	    fp, "  Location: %u", ip.smbip_location);
+	desc_printf(smbios_iprobe_status_desc(ip.smbip_status),
+	    fp, "  Status: %u", ip.smbip_status);
+
+	if (ip.smbip_maxval != 0x8000) {
+		oprintf(fp, "  Maximum Possible Current: %u mA\n",
+		    ip.smbip_maxval);
+	} else {
+		oprintf(fp, "  Maximum Possible Current: unknown\n");
+	}
+
+	if (ip.smbip_minval != 0x8000) {
+		oprintf(fp, "  Minimum Possible Current: %u mA\n",
+		    ip.smbip_minval);
+	} else {
+		oprintf(fp, "  Minimum Possible Current: unknown\n");
+	}
+
+	if (ip.smbip_resolution != 0x8000) {
+		oprintf(fp, "  Probe Resolution: %u.%u mA\n",
+		    ip.smbip_resolution / 10,
+		    ip.smbip_resolution % 10);
+	} else {
+		oprintf(fp, "  Probe Resolution: unknown\n");
+	}
+
+	if (ip.smbip_tolerance != 0x8000) {
+		oprintf(fp, "  Probe Tolerance: +/-%u mA\n",
+		    ip.smbip_tolerance);
+	} else {
+		oprintf(fp, "  Probe Tolerance: unknown\n");
+	}
+
+	if (ip.smbip_accuracy != 0x8000) {
+		oprintf(fp, "  Probe Accuracy: +/-%u.%02u%%\n",
+		    ip.smbip_accuracy / 100,
+		    ip.smbip_accuracy % 100);
+	} else {
+		oprintf(fp, "  Probe Accuracy: unknown\n");
+	}
+
+	oprintf(fp, "  OEM- or BIOS- defined value: 0x%x\n", ip.smbip_oem);
+
+	if (ip.smbip_nominal != 0x8000) {
+		oprintf(fp, "  Probe Nominal Value: %u mA\n", ip.smbip_nominal);
+	} else {
+		oprintf(fp, "  Probe Nominal Value: unknown\n");
+	}
+}
+
+
 static void
 print_boot(smbios_hdl_t *shp, FILE *fp)
 {
@@ -1255,6 +1482,22 @@ print_struct(smbios_hdl_t *shp, const smbios_struct_t *sp, void *fp)
 		oprintf(fp, "\n");
 		print_hwsec(shp, fp);
 		break;
+	case SMB_TYPE_VPROBE:
+		oprintf(fp, "\n");
+		print_vprobe(shp, sp->smbstr_id, fp);
+		break;
+	case SMB_TYPE_COOLDEV:
+		oprintf(fp, "\n");
+		print_cooldev(shp, sp->smbstr_id, fp);
+		break;
+	case SMB_TYPE_TPROBE:
+		oprintf(fp, "\n");
+		print_tprobe(shp, sp->smbstr_id, fp);
+		break;
+	case SMB_TYPE_IPROBE:
+		oprintf(fp, "\n");
+		print_iprobe(shp, sp->smbstr_id, fp);
+		break;
 	case SMB_TYPE_BOOT:
 		oprintf(fp, "\n");
 		print_boot(shp, fp);
diff --git a/usr/src/common/smbios/mktables.sh b/usr/src/common/smbios/mktables.sh
index 7a001c0eb3..969c329b25 100644
--- a/usr/src/common/smbios/mktables.sh
+++ b/usr/src/common/smbios/mktables.sh
@@ -72,12 +72,16 @@ SMB_CAG_	smbios_cache_logical_desc	uint_t
 SMB_CAM_	smbios_cache_mode_desc		uint_t
 SMB_CHST_	smbios_chassis_state_desc	uint_t
 SMB_CHT_	smbios_chassis_type_desc	uint_t
+SMB_COOLDEV_S_	smbios_cooldev_status_desc	uint_t
+SMB_COOLDEV_T_	smbios_cooldev_type_desc	uint_t
 SMB_EVFL_	smbios_evlog_flag_desc		uint_t
 SMB_EVHF_	smbios_evlog_format_desc	uint_t
 SMB_EVM_	smbios_evlog_method_desc	uint_t
 SMB_HWSEC_PS_	smbios_hwsec_desc		uint_t
 SMB_IPMI_F_	smbios_ipmi_flag_desc		uint_t
 SMB_IPMI_T_	smbios_ipmi_type_desc		uint_t
+SMB_IPROBE_L_	smbios_iprobe_loc_desc		uint_t
+SMB_IPROBE_S_	smbios_iprobe_status_desc	uint_t
 SMB_POWERSUP_F_	smbios_powersup_flag_desc	uint_t
 SMB_POWERSUP_I_	smbios_powersup_input_desc	uint_t
 SMB_POWERSUP_S_	smbios_powersup_status_desc	uint_t
@@ -103,7 +107,11 @@ SMB_SLL_	smbios_slot_length_desc		uint_t
 SMB_SLT_	smbios_slot_type_desc		uint_t
 SMB_SLU_	smbios_slot_usage_desc		uint_t
 SMB_SLW_	smbios_slot_width_desc		uint_t
+SMB_TPROBE_L_	smbios_tprobe_loc_desc		uint_t
+SMB_TPROBE_S_	smbios_tprobe_status_desc	uint_t
 SMB_TYPE_ 	smbios_type_desc		uint_t
+SMB_VPROBE_L_	smbios_vprobe_loc_desc		uint_t
+SMB_VPROBE_S_	smbios_vprobe_status_desc	uint_t
 SMB_WAKEUP_	smbios_system_wakeup_desc	uint_t
 '
 
diff --git a/usr/src/common/smbios/smb_info.c b/usr/src/common/smbios/smb_info.c
index 476ce0b059..b834f09863 100644
--- a/usr/src/common/smbios/smb_info.c
+++ b/usr/src/common/smbios/smb_info.c
@@ -1318,3 +1318,155 @@ smbios_info_powersup(smbios_hdl_t *shp, id_t id, smbios_powersup_t *psup)
 
 	return (0);
 }
+
+int
+smbios_info_vprobe(smbios_hdl_t *shp, id_t id, smbios_vprobe_t *vprobe)
+{
+	const smb_struct_t *stp = smb_lookup_id(shp, id);
+	smb_vprobe_t vp;
+
+	if (stp == NULL)
+		return (-1); /* errno is set for us */
+
+	if (stp->smbst_hdr->smbh_type != SMB_TYPE_VPROBE)
+		return (smb_set_errno(shp, ESMB_TYPE));
+
+	if (stp->smbst_hdr->smbh_len < SMB_VPROBE_MINLEN)
+		return (smb_set_errno(shp, ESMB_SHORT));
+
+	bzero(vprobe, sizeof (*vprobe));
+	smb_info_bcopy(stp->smbst_hdr, &vp, sizeof (vp));
+	vprobe->smbvp_description = smb_strptr(stp, vp.smbvpr_descr);
+	vprobe->smbvp_location = SMB_VPROBE_LOCATION(vp.smbvpr_locstat);
+	vprobe->smbvp_status = SMB_VPROBE_STATUS(vp.smbvpr_locstat);
+	vprobe->smbvp_maxval = vp.smbvpr_maxval;
+	vprobe->smbvp_minval = vp.smbvpr_minval;
+	vprobe->smbvp_resolution = vp.smbvpr_resolution;
+	vprobe->smbvp_tolerance	= vp.smbvpr_tolerance;
+	vprobe->smbvp_accuracy = vp.smbvpr_accuracy;
+
+	if (stp->smbst_hdr->smbh_len >= SMB_VPROBE_NOMINAL_MINLEN) {
+		vprobe->smbvp_nominal = vp.smbvpr_nominal;
+	} else {
+		vprobe->smbvp_nominal = 0x8000;
+	}
+
+	return (0);
+}
+
+int
+smbios_info_cooldev(smbios_hdl_t *shp, id_t id, smbios_cooldev_t *cooldev)
+{
+	const smb_struct_t *stp = smb_lookup_id(shp, id);
+	smb_cooldev_t cd;
+
+	if (stp == NULL)
+		return (-1); /* errno is set for us */
+
+	if (stp->smbst_hdr->smbh_type != SMB_TYPE_COOLDEV)
+		return (smb_set_errno(shp, ESMB_TYPE));
+
+	if (stp->smbst_hdr->smbh_len < SMB_COOLDEV_MINLEN)
+		return (smb_set_errno(shp, ESMB_SHORT));
+
+	bzero(cooldev, sizeof (*cooldev));
+	smb_info_bcopy(stp->smbst_hdr, &cd, sizeof (cd));
+	cooldev->smbcd_tprobe = cd.smbcdev_tprobe;
+	cooldev->smbcd_type = SMB_COOLDEV_TYPE(cd.smbcdev_typstat);
+	cooldev->smbcd_status = SMB_COOLDEV_STATUS(cd.smbcdev_typstat);
+	cooldev->smbcd_group = cd.smbcdev_group;
+	cooldev->smbcd_oem = cd.smbcdev_oem;
+
+	if (stp->smbst_hdr->smbh_len >= SMB_COOLDEV_NOMINAL_MINLEN) {
+		cooldev->smbcd_nominal = cd.smbcdev_nominal;
+	} else {
+		cooldev->smbcd_nominal = 0x8000;
+	}
+
+	/*
+	 * The description field was added in SMBIOS version 2.7. The
+	 * SMB_TYPE_COOLDEV support was only added after all of the 2.7+ fields
+	 * were added in the spec. So while a user may request an older version,
+	 * we don't have to worry about old structures and just simply skip it
+	 * if they're not asking for it.
+	 */
+	if (smb_libgteq(shp, SMB_VERSION_27) &&
+	    smb_gteq(shp, SMB_VERSION_27) &&
+	    stp->smbst_hdr->smbh_len >= SMB_COOLDEV_DESCR_MINLEN) {
+		cooldev->smbcd_descr = smb_strptr(stp, cd.smbcdev_descr);
+	} else {
+		cooldev->smbcd_descr = NULL;
+	}
+
+	return (0);
+}
+
+int
+smbios_info_tprobe(smbios_hdl_t *shp, id_t id, smbios_tprobe_t *tprobe)
+{
+	const smb_struct_t *stp = smb_lookup_id(shp, id);
+	smb_tprobe_t tp;
+
+	if (stp == NULL)
+		return (-1); /* errno is set for us */
+
+	if (stp->smbst_hdr->smbh_type != SMB_TYPE_TPROBE)
+		return (smb_set_errno(shp, ESMB_TYPE));
+
+	if (stp->smbst_hdr->smbh_len < SMB_TPROBE_MINLEN)
+		return (smb_set_errno(shp, ESMB_SHORT));
+
+	bzero(tprobe, sizeof (*tprobe));
+	smb_info_bcopy(stp->smbst_hdr, &tp, sizeof (tp));
+	tprobe->smbtp_description = smb_strptr(stp, tp.smbtpr_descr);
+	tprobe->smbtp_location = SMB_TPROBE_LOCATION(tp.smbtpr_locstat);
+	tprobe->smbtp_status = SMB_TPROBE_STATUS(tp.smbtpr_locstat);
+	tprobe->smbtp_maxval = tp.smbtpr_maxval;
+	tprobe->smbtp_minval = tp.smbtpr_minval;
+	tprobe->smbtp_resolution = tp.smbtpr_resolution;
+	tprobe->smbtp_tolerance	= tp.smbtpr_tolerance;
+	tprobe->smbtp_accuracy = tp.smbtpr_accuracy;
+
+	if (stp->smbst_hdr->smbh_len >= SMB_TPROBE_NOMINAL_MINLEN) {
+		tprobe->smbtp_nominal = tp.smbtpr_nominal;
+	} else {
+		tprobe->smbtp_nominal = 0x8000;
+	}
+
+	return (0);
+}
+
+int
+smbios_info_iprobe(smbios_hdl_t *shp, id_t id, smbios_iprobe_t *iprobe)
+{
+	const smb_struct_t *sip = smb_lookup_id(shp, id);
+	smb_iprobe_t ip;
+
+	if (sip == NULL)
+		return (-1); /* errno is set for us */
+
+	if (sip->smbst_hdr->smbh_type != SMB_TYPE_IPROBE)
+		return (smb_set_errno(shp, ESMB_TYPE));
+
+	if (sip->smbst_hdr->smbh_len < SMB_IPROBE_MINLEN)
+		return (smb_set_errno(shp, ESMB_SHORT));
+
+	bzero(iprobe, sizeof (*iprobe));
+	smb_info_bcopy(sip->smbst_hdr, &ip, sizeof (ip));
+	iprobe->smbip_description = smb_strptr(sip, ip.smbipr_descr);
+	iprobe->smbip_location = SMB_IPROBE_LOCATION(ip.smbipr_locstat);
+	iprobe->smbip_status = SMB_IPROBE_STATUS(ip.smbipr_locstat);
+	iprobe->smbip_maxval = ip.smbipr_maxval;
+	iprobe->smbip_minval = ip.smbipr_minval;
+	iprobe->smbip_resolution = ip.smbipr_resolution;
+	iprobe->smbip_tolerance	= ip.smbipr_tolerance;
+	iprobe->smbip_accuracy = ip.smbipr_accuracy;
+
+	if (sip->smbst_hdr->smbh_len >= SMB_IPROBE_NOMINAL_MINLEN) {
+		iprobe->smbip_nominal = ip.smbipr_nominal;
+	} else {
+		iprobe->smbip_nominal = 0x8000;
+	}
+
+	return (0);
+}
diff --git a/usr/src/lib/libsmbios/common/mapfile-vers b/usr/src/lib/libsmbios/common/mapfile-vers
index f2e6544050..6df8e6d4a6 100644
--- a/usr/src/lib/libsmbios/common/mapfile-vers
+++ b/usr/src/lib/libsmbios/common/mapfile-vers
@@ -68,6 +68,8 @@ SYMBOL_VERSION SUNWprivate_1.1 {
 	smbios_chassis_state_desc;
 	smbios_chassis_type_desc;
 	smbios_checksum;
+	smbios_cooldev_status_desc;
+	smbios_cooldev_type_desc;
 	smbios_close;
 	smbios_csn;
 	smbios_errmsg;
@@ -83,11 +85,13 @@ SYMBOL_VERSION SUNWprivate_1.1 {
 	smbios_info_boot;
 	smbios_info_cache;
 	smbios_info_chassis;
+	smbios_info_cooldev;
 	smbios_info_common;
 	smbios_info_contains;
 	smbios_info_eventlog;
 	smbios_info_hwsec;
 	smbios_info_ipmi;
+	smbios_info_iprobe;
 	smbios_info_lang;
 	smbios_info_memarray;
 	smbios_info_extmemarray;
@@ -108,9 +112,13 @@ SYMBOL_VERSION SUNWprivate_1.1 {
 	smbios_info_strtab;
 	smbios_info_system;
 	smbios_info_pciexrc;
+	smbios_info_tprobe;
+	smbios_info_vprobe;
 	smbios_ipmi_flag_desc;
 	smbios_ipmi_flag_name;
 	smbios_ipmi_type_desc;
+	smbios_iprobe_loc_desc;
+	smbios_iprobe_status_desc;
 	smbios_iter;
 	smbios_lookup_id;
 	smbios_lookup_type;
@@ -147,9 +155,13 @@ SYMBOL_VERSION SUNWprivate_1.1 {
 	smbios_slot_usage_desc;
 	smbios_slot_width_desc;
 	smbios_system_wakeup_desc;
+	smbios_tprobe_loc_desc;
+	smbios_tprobe_status_desc;
 	smbios_truncated;
 	smbios_type_desc;
 	smbios_type_name;
+	smbios_vprobe_loc_desc;
+	smbios_vprobe_status_desc;
 	smbios_write;
     local:
 	*;
diff --git a/usr/src/uts/common/sys/smbios.h b/usr/src/uts/common/sys/smbios.h
index bf601e3cb0..7a8637e222 100644
--- a/usr/src/uts/common/sys/smbios.h
+++ b/usr/src/uts/common/sys/smbios.h
@@ -1296,6 +1296,151 @@ typedef struct smbios_hwsec {
 #define	SMB_HWSEC_PS_NOTIMPL	0x02	/* password not implemented */
 #define	SMB_HWSEC_PS_UNKNOWN	0x03	/* password status unknown */
 
+/*
+ * SMBIOS Voltage Probe.  See DSP0134 Section 7.27 for more information.
+ * Please see the specification for the units of each value.
+ */
+typedef struct smbios_vprobe {
+	const char *smbvp_description;	/* description information */
+	uint8_t smbvp_location;		/* probe location */
+	uint8_t smbvp_status;		/* probe status */
+	uint16_t smbvp_maxval;		/* maximum voltage */
+	uint16_t smbvp_minval;		/* minimum voltage */
+	uint16_t smbvp_resolution;	/* probe resolution */
+	uint16_t smbvp_tolerance;	/* probe tolerance */
+	uint16_t smbvp_accuracy;	/* probe accuracy */
+	uint32_t smbvp_oem;		/* vendor-specific data */
+	uint16_t smbvp_nominal;		/* nominal value */
+} smbios_vprobe_t;
+
+#define	SMB_VPROBE_S_OTHER	0x01	/* other */
+#define	SMB_VPROBE_S_UNKNOWN	0x02	/* unknown */
+#define	SMB_VPROBE_S_OK		0x03	/* OK */
+#define	SMB_VPROBE_S_NONCRIT	0x04	/* non-critical */
+#define	SMB_VPROBE_S_CRIT	0x05	/* critical */
+#define	SMB_VPROBE_S_NONRECOV	0x06	/* non-recoverable */
+
+#define	SMB_VPROBE_L_OTHER	0x01	/* other */
+#define	SMB_VPROBE_L_UNKNOWN	0x02	/* unknown */
+#define	SMB_VPROBE_L_PROC	0x03	/* processor */
+#define	SMB_VPROBE_L_DISK	0x04	/* disk */
+#define	SMB_VPROBE_L_PBAY	0x05	/* peripheral bay */
+#define	SMB_VPROBE_L_MGMT	0x06	/* system management module */
+#define	SMB_VPROBE_L_MOBO	0x07	/* motherboard */
+#define	SMB_VPROBE_L_MEMMOD	0x08	/* memory module */
+#define	SMB_VPROBE_L_PROCMOD	0x09	/* processor module */
+#define	SMB_VPROBE_L_POWER	0x0a	/* power unit */
+#define	SMB_VPROBE_L_AIC	0x0b	/* add-in card */
+
+/*
+ * SMBIOS Cooling Device.  See DSP0134 Section 7.28 for more information.
+ * Please see the specification for the units of each value.
+ */
+typedef struct smbios_cooldev {
+	id_t smbcd_tprobe;		/* temperature probe handle */
+	uint8_t smbcd_type;		/* cooling device type */
+	uint8_t smbcd_status;		/* status */
+	uint8_t smbcd_group;		/* group ID */
+	uint32_t smbcd_oem;		/* vendor-specific data */
+	uint16_t smbcd_nominal;		/* nominal speed */
+	const char *smbcd_descr;	/* device description */
+} smbios_cooldev_t;
+
+#define	SMB_COOLDEV_S_OTHER	0x01	/* other */
+#define	SMB_COOLDEV_S_UNKNOWN	0x02	/* unknown */
+#define	SMB_COOLDEV_S_OK	0x03	/* OK */
+#define	SMB_COOLDEV_S_NONCRIT	0x04	/* non-critical */
+#define	SMB_COOLDEV_S_CRIT	0x05	/* critical */
+#define	SMB_COOLDEV_S_NONRECOV	0x06	/* non-recoverable */
+
+#define	SMB_COOLDEV_T_OTHER	0x01	/* other */
+#define	SMB_COOLDEV_T_UNKNOWN	0x02	/* unknown */
+#define	SMB_COOLDEV_T_FAN	0x03	/* fan */
+#define	SMB_COOLDEV_T_BLOWER	0x04	/* centrifugal blower */
+#define	SMB_COOLDEV_T_CHIPFAN	0x05	/* chip fan */
+#define	SMB_COOLDEV_T_CABFAN	0x06	/* cabinet fan */
+#define	SMB_COOLDEV_T_PSFAN	0x07	/* power supply fan */
+#define	SMB_COOLDEV_T_HEATPIPE	0x08	/* head pipe */
+#define	SMB_COOLDEV_T_IREFRIG	0x09	/* integrated refrigeration */
+#define	SMB_COOLDEV_T_ACTCOOL	0x10	/* active cooling */
+#define	SMB_COOLDEV_T_PASSCOOL	0x11	/* passive cooling */
+
+/*
+ * SMBIOS Temperature Probe.  See DSP0134 Section 7.29 for more information.
+ * Please see the specification for the units of each value.
+ */
+typedef struct smbios_tprobe {
+	const char *smbtp_description;	/* description information */
+	uint8_t smbtp_location;		/* probe location */
+	uint8_t smbtp_status;		/* probe status */
+	uint16_t smbtp_maxval;		/* maximum temperature */
+	uint16_t smbtp_minval;		/* minimum temperature */
+	uint16_t smbtp_resolution;	/* probe resolution */
+	uint16_t smbtp_tolerance;	/* probe tolerance */
+	uint16_t smbtp_accuracy;	/* probe accuracy */
+	uint32_t smbtp_oem;		/* vendor-specific data */
+	uint16_t smbtp_nominal;		/* nominal value */
+} smbios_tprobe_t;
+
+#define	SMB_TPROBE_S_OTHER	0x01	/* other */
+#define	SMB_TPROBE_S_UNKNOWN	0x02	/* unknown */
+#define	SMB_TPROBE_S_OK		0x03	/* OK */
+#define	SMB_TPROBE_S_NONCRIT	0x04	/* non-critical */
+#define	SMB_TPROBE_S_CRIT	0x05	/* critical */
+#define	SMB_TPROBE_S_NONRECOV	0x06	/* non-recoverable */
+
+#define	SMB_TPROBE_L_OTHER	0x01	/* other */
+#define	SMB_TPROBE_L_UNKNOWN	0x02	/* unknown */
+#define	SMB_TPROBE_L_PROC	0x03	/* processor */
+#define	SMB_TPROBE_L_DISK	0x04	/* disk */
+#define	SMB_TPROBE_L_PBAY	0x05	/* peripheral bay */
+#define	SMB_TPROBE_L_MGMT	0x06	/* system management module */
+#define	SMB_TPROBE_L_MOBO	0x07	/* motherboard */
+#define	SMB_TPROBE_L_MEMMOD	0x08	/* memory module */
+#define	SMB_TPROBE_L_PROCMOD	0x09	/* processor module */
+#define	SMB_TPROBE_L_POWER	0x0a	/* power unit */
+#define	SMB_TPROBE_L_AIC	0x0b	/* add-in card */
+#define	SMB_TPROBE_L_FPBOARD	0x0c	/* front panel board */
+#define	SMB_TPROBE_L_BPBOARD	0x0d	/* rear panel board */
+#define	SMB_TPROBE_L_PSBOARD	0x0e	/* power system board */
+#define	SMB_TPROBE_L_DBPANE	0x0f	/* drive back plane */
+
+/*
+ * SMBIOS Current Probe.  See DSP0134 Section 7.30 for more information.
+ * Please see the specification for the units of each value.
+ */
+typedef struct smbios_iprobe {
+	const char *smbip_description;	/* description information */
+	uint8_t smbip_location;		/* probe location */
+	uint8_t smbip_status;		/* probe status */
+	uint16_t smbip_maxval;		/* maximum current */
+	uint16_t smbip_minval;		/* minimum current */
+	uint16_t smbip_resolution;	/* probe resolution */
+	uint16_t smbip_tolerance;	/* probe tolerance */
+	uint16_t smbip_accuracy;	/* probe accuracy */
+	uint32_t smbip_oem;		/* vendor-specific data */
+	uint16_t smbip_nominal;		/* nominal value */
+} smbios_iprobe_t;
+
+#define	SMB_IPROBE_S_OTHER	0x01	/* other */
+#define	SMB_IPROBE_S_UNKNOWN	0x02	/* unknown */
+#define	SMB_IPROBE_S_OK		0x03	/* OK */
+#define	SMB_IPROBE_S_NONCRIT	0x04	/* non-critical */
+#define	SMB_IPROBE_S_CRIT	0x05	/* critical */
+#define	SMB_IPROBE_S_NONRECOV	0x06	/* non-recoverable */
+
+#define	SMB_IPROBE_L_OTHER	0x01	/* other */
+#define	SMB_IPROBE_L_UNKNOWN	0x02	/* unknown */
+#define	SMB_IPROBE_L_PROC	0x03	/* processor */
+#define	SMB_IPROBE_L_DISK	0x04	/* disk */
+#define	SMB_IPROBE_L_PBAY	0x05	/* peripheral bay */
+#define	SMB_IPROBE_L_MGMT	0x06	/* system management module */
+#define	SMB_IPROBE_L_MOBO	0x07	/* motherboard */
+#define	SMB_IPROBE_L_MEMMOD	0x08	/* memory module */
+#define	SMB_IPROBE_L_PROCMOD	0x09	/* processor module */
+#define	SMB_IPROBE_L_POWER	0x0a	/* power unit */
+#define	SMB_IPROBE_L_AIC	0x0b	/* add-in card */
+
 /*
  * SMBIOS System Boot Information.  See DSP0134 Section 7.33 for more
  * information.  The contents of the data varies by type and is undocumented
@@ -1549,11 +1694,16 @@ extern int smbios_info_extmemdevice(smbios_hdl_t *, id_t,
     smbios_memdevice_ext_t *);
 extern int smbios_info_memdevmap(smbios_hdl_t *, id_t, smbios_memdevmap_t *);
 extern id_t smbios_info_hwsec(smbios_hdl_t *, smbios_hwsec_t *);
+extern int smbios_info_vprobe(smbios_hdl_t *, id_t, smbios_vprobe_t *);
+extern int smbios_info_cooldev(smbios_hdl_t *, id_t, smbios_cooldev_t *);
+extern int smbios_info_tprobe(smbios_hdl_t *, id_t, smbios_tprobe_t *);
+extern int smbios_info_iprobe(smbios_hdl_t *, id_t, smbios_iprobe_t *);
 extern id_t smbios_info_boot(smbios_hdl_t *, smbios_boot_t *);
 extern id_t smbios_info_ipmi(smbios_hdl_t *, smbios_ipmi_t *);
 extern int smbios_info_powersup(smbios_hdl_t *, id_t, smbios_powersup_t *);
 extern int smbios_info_pciexrc(smbios_hdl_t *, id_t, smbios_pciexrc_t *);
 
+
 extern const char *smbios_psn(smbios_hdl_t *);
 extern const char *smbios_csn(smbios_hdl_t *);
 
@@ -1596,6 +1746,18 @@ extern const char *smbios_evlog_flag_name(uint_t);
 extern const char *smbios_evlog_format_desc(uint_t);
 extern const char *smbios_evlog_method_desc(uint_t);
 
+extern const char *smbios_vprobe_loc_desc(uint_t);
+extern const char *smbios_vprobe_status_desc(uint_t);
+
+extern const char *smbios_cooldev_status_desc(uint_t);
+extern const char *smbios_cooldev_type_desc(uint_t);
+
+extern const char *smbios_tprobe_loc_desc(uint_t);
+extern const char *smbios_tprobe_status_desc(uint_t);
+
+extern const char *smbios_iprobe_loc_desc(uint_t);
+extern const char *smbios_iprobe_status_desc(uint_t);
+
 extern const char *smbios_ipmi_flag_name(uint_t);
 extern const char *smbios_ipmi_flag_desc(uint_t);
 extern const char *smbios_ipmi_type_desc(uint_t);
diff --git a/usr/src/uts/common/sys/smbios_impl.h b/usr/src/uts/common/sys/smbios_impl.h
index ea11aea2c1..66edfb027a 100644
--- a/usr/src/uts/common/sys/smbios_impl.h
+++ b/usr/src/uts/common/sys/smbios_impl.h
@@ -67,6 +67,9 @@ typedef struct smb_header {
 	uint16_t smbh_hdl;		/* structure handle */
 } smb_header_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_BIOS.
+ */
 typedef struct smb_bios {
 	smb_header_t smbbi_hdr;		/* structure header */
 	uint8_t smbbi_vendor;		/* bios vendor string */
@@ -78,6 +81,9 @@ typedef struct smb_bios {
 	uint8_t smbbi_xcflags[1];	/* bios characteristics extensions */
 } smb_bios_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_SYSTEM.
+ */
 typedef struct smb_system {
 	smb_header_t smbsi_hdr;		/* structure header */
 	uint8_t smbsi_manufacturer;	/* manufacturer */
@@ -90,6 +96,9 @@ typedef struct smb_system {
 	uint8_t smbsi_family;		/* family */
 } smb_system_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_BASEBOARD.
+ */
 typedef struct smb_bboard {
 	smb_header_t smbbb_hdr;		/* structure header */
 	uint8_t smbbb_manufacturer;	/* manufacturer */
@@ -105,6 +114,9 @@ typedef struct smb_bboard {
 	uint16_t smbbb_cv[1];		/* array of contained handles */
 } smb_bboard_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_CHASSIS.
+ */
 typedef struct smb_chassis {
 	smb_header_t smbch_hdr;		/* structure header */
 	uint8_t smbch_manufacturer;	/* manufacturer */
@@ -129,6 +141,9 @@ typedef struct smb_chassis {
 	(smbcp)->smbch_cv + ((smbcp)->smbch_cn * (smbcp)->smbch_cm))
 #define	SMB_CHT_LOCK	0x80		/* lock bit within smbch_type */
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_PROCESSOR.
+ */
 typedef struct smb_processor {
 	smb_header_t smbpr_hdr;		/* structure header */
 	uint8_t smbpr_socket;		/* socket designation */
@@ -159,6 +174,9 @@ typedef struct smb_processor {
 	uint16_t smbpr_threadcount2;	/* second number of enabled threads */
 } smb_processor_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_CACHE.
+ */
 typedef struct smb_cache {
 	smb_header_t smbca_hdr;		/* structure header */
 	uint8_t smbca_socket;		/* socket designation */
@@ -193,6 +211,9 @@ typedef struct smb_cache {
 #define	SMB_CACHE_CFG_SOCKETED(c)	(((c) >> 3) & 1)
 #define	SMB_CACHE_CFG_LEVEL(c)		(((c) & 7) + 1)
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_PORT.
+ */
 typedef struct smb_port {
 	smb_header_t smbpo_hdr;		/* structure header */
 	uint8_t smbpo_iref;		/* internal reference designator */
@@ -202,6 +223,9 @@ typedef struct smb_port {
 	uint8_t smbpo_ptype;		/* port type */
 } smb_port_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_SLOT.
+ */
 typedef struct smb_slot {
 	smb_header_t smbsl_hdr;		/* structure header */
 	uint8_t smbsl_name;		/* reference designation */
@@ -217,6 +241,9 @@ typedef struct smb_slot {
 	uint8_t smbsl_df;		/* device/function number */
 } smb_slot_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_OBDEVS.
+ */
 typedef struct smb_obdev {
 	uint8_t smbob_type;		/* encoded type and enable bit */
 	uint8_t smbob_name;		/* description string */
@@ -224,11 +251,18 @@ typedef struct smb_obdev {
 
 #define	SMB_OBT_ENABLED		0x80	/* enable bit within smbob_type */
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_OEMSTR, SMB_TYPE_SYSCONFSTR,
+ * and SMB_TYPE_LANG.
+ */
 typedef struct smb_strtab {
 	smb_header_t smbtb_hdr;		/* structure header */
 	uint8_t smbtb_count;		/* number of strings */
 } smb_strtab_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_LANG.
+ */
 typedef struct smb_lang {
 	smb_header_t smblang_hdr;	/* structure header */
 	uint8_t smblang_num;		/* number of installed languages */
@@ -237,6 +271,9 @@ typedef struct smb_lang {
 	uint8_t smblang_cur;		/* current language string */
 } smb_lang_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_EVENTLOG.
+ */
 typedef struct smb_sel {
 	smb_header_t smbsel_hdr;	/* structure header */
 	uint16_t smbsel_len;		/* log area length */
@@ -252,6 +289,9 @@ typedef struct smb_sel {
 	uint8_t smbsel_typev[1];	/* array of type descriptors */
 } smb_sel_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_MEMARRAY.
+ */
 typedef struct smb_memarray {
 	smb_header_t smbmarr_hdr;	/* structure header */
 	uint8_t smbmarr_loc;		/* location */
@@ -263,6 +303,9 @@ typedef struct smb_memarray {
 	uint64_t smbmarr_extcap;	/* extended maximum capacity */
 } smb_memarray_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_MEMARRAYMAP.
+ */
 typedef struct smb_memarrmap {
 	smb_header_t smbamap_hdr;	/* structure header */
 	uint32_t smbamap_start;		/* starting address in kilobytes */
@@ -273,6 +316,9 @@ typedef struct smb_memarrmap {
 	uint64_t smbamap_extend;	/* extended ending address in bytes */
 } smb_memarrmap_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_MEMDEVICE.
+ */
 typedef struct smb_memdevice {
 	smb_header_t smbmdev_hdr;	/* structure header */
 	uint16_t smbmdev_array;		/* array handle */
@@ -301,6 +347,9 @@ typedef struct smb_memdevice {
 
 #define	SMB_MDS_KBYTES		0x8000	/* size in specified in kilobytes */
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_MEMDEVICEMAP.
+ */
 typedef struct smb_memdevmap {
 	smb_header_t smbdmap_hdr;	/* structure header */
 	uint32_t smbdmap_start;		/* starting address in kilobytes */
@@ -314,6 +363,9 @@ typedef struct smb_memdevmap {
 	uint64_t smbdmap_extend;	/* extended ending address */
 } smb_memdevmap_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_BATTERY.
+ */
 typedef struct smb_battery {
 	smb_header_t smbbat_hdr;	/* structure header */
 	uint8_t smbbat_loc;		/* location */
@@ -333,6 +385,9 @@ typedef struct smb_battery {
 	uint32_t smbbat_oemdata;	/* OEM-specific data */
 } smb_battery_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_SECURITY.
+ */
 typedef struct smb_hwsec {
 	smb_header_t smbhs_hdr;		/* structure header */
 	uint8_t smbhs_settings;		/* settings byte */
@@ -343,12 +398,104 @@ typedef struct smb_hwsec {
 #define	SMB_HWS_ADM_PS(x)	(((x) & 0x0C) >> 2)
 #define	SMB_HWS_PAN_PS(x)	(((x) & 0x03) >> 0)
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_VPROBE.
+ */
+typedef struct smb_vprobe {
+	smb_header_t smbvpr_hdr;	/* structure header */
+	uint8_t smbvpr_descr;		/* description string */
+	uint8_t smbvpr_locstat;		/* location and status */
+	uint16_t smbvpr_maxval;		/* maximum voltage */
+	uint16_t smbvpr_minval;		/* minimum voltage */
+	uint16_t smbvpr_resolution;	/* probe resolution */
+	uint16_t smbvpr_tolerance;	/* probe tolerance */
+	uint16_t smbvpr_accuracy;	/* probe accuracy */
+	uint32_t smbvpr_oem;		/* vendor-specific data */
+	uint16_t smbvpr_nominal;	/* nominal value */
+} smb_vprobe_t;
+
+#define	SMB_VPROBE_MINLEN		0x14
+#define	SMB_VPROBE_NOMINAL_MINLEN	0x16
+
+#define	SMB_VPROBE_LOCATION(x)	((x) & 0x1f)
+#define	SMB_VPROBE_STATUS(x)	(((x) >> 5) & 0x7)
+
+/*
+ * SMBIOS implementation structure for SMB_TYPE_COOLDEV.
+ */
+typedef struct smb_cooldev {
+	smb_header_t smbcdev_hdr;	/* structure header */
+	uint16_t smbcdev_tprobe;	/* temperature probe */
+	uint8_t smbcdev_typstat;	/* type and status */
+	uint8_t smbcdev_group;		/* group identifier */
+	uint32_t smbcdev_oem;		/* vendor-specific data */
+	uint16_t smbcdev_nominal;	/* nominal value */
+	uint8_t smbcdev_descr;		/* description string */
+} smb_cooldev_t;
+
+#define	SMB_COOLDEV_MINLEN		0x0c
+#define	SMB_COOLDEV_NOMINAL_MINLEN	0x0e
+#define	SMB_COOLDEV_DESCR_MINLEN	0x0f
+
+#define	SMB_COOLDEV_TYPE(x)	((x) & 0x1f)
+#define	SMB_COOLDEV_STATUS(x)	(((x) >> 5) & 0x7)
+
+/*
+ * SMBIOS implementation structure for SMB_TYPE_TPROBE.
+ */
+typedef struct smb_tprobe {
+	smb_header_t smbtpr_hdr;	/* structure header */
+	uint8_t smbtpr_descr;		/* description string */
+	uint8_t smbtpr_locstat;		/* location and status */
+	uint16_t smbtpr_maxval;		/* maximum temperature */
+	uint16_t smbtpr_minval;		/* minimum temperature */
+	uint16_t smbtpr_resolution;	/* probe resolution */
+	uint16_t smbtpr_tolerance;	/* probe tolerance */
+	uint16_t smbtpr_accuracy;	/* probe accuracy */
+	uint32_t smbtpr_oem;		/* vendor-specific data */
+	uint16_t smbtpr_nominal;	/* nominal value */
+} smb_tprobe_t;
+
+#define	SMB_TPROBE_MINLEN		0x14
+#define	SMB_TPROBE_NOMINAL_MINLEN	0x16
+
+#define	SMB_TPROBE_LOCATION(x)	((x) & 0x1f)
+#define	SMB_TPROBE_STATUS(x)	(((x) >> 5) & 0x7)
+
+/*
+ * SMBIOS implementation structure for SMB_TYPE_IPROBE.
+ */
+typedef struct smb_iprobe {
+	smb_header_t smbipr_hdr;	/* structure header */
+	uint8_t smbipr_descr;		/* description string */
+	uint8_t smbipr_locstat;		/* location and status */
+	uint16_t smbipr_maxval;		/* maximum current */
+	uint16_t smbipr_minval;		/* minimum current */
+	uint16_t smbipr_resolution;	/* probe resolution */
+	uint16_t smbipr_tolerance;	/* probe tolerance */
+	uint16_t smbipr_accuracy;	/* probe accuracy */
+	uint32_t smbipr_oem;		/* vendor-specific data */
+	uint16_t smbipr_nominal;	/* nominal value */
+} smb_iprobe_t;
+
+#define	SMB_IPROBE_MINLEN		0x14
+#define	SMB_IPROBE_NOMINAL_MINLEN	0x16
+
+#define	SMB_IPROBE_LOCATION(x)	((x) & 0x1f)
+#define	SMB_IPROBE_STATUS(x)	(((x) >> 5) & 0x7)
+
+/*
+ * SMBIOS implementation structure for SMB_TYPE_BOOT.
+ */
 typedef struct smb_boot {
 	smb_header_t smbbo_hdr;		/* structure header */
 	uint8_t smbbo_pad[6];		/* reserved for future use */
 	uint8_t smbbo_status[1];	/* variable-length status buffer */
 } smb_boot_t;
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_IPMIDEV.
+ */
 typedef struct smb_ipmi {
 	smb_header_t smbipm_hdr;	/* structure header */
 	uint8_t smbipm_type;		/* interface type */
@@ -381,6 +528,9 @@ typedef struct smb_ipmi {
 #define	SMB_IPM_IMODE_EDGE	0
 #define	SMB_IPM_IMODE_LEVEL	1
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_POWERSUP.
+ */
 typedef struct smb_powersup {
 	smb_header_t smbpsup_hdr;	/* structure header */
 	uint8_t smbpsup_group;		/* group id */
@@ -405,6 +555,9 @@ typedef struct smb_powersup {
 #define	SMB_PSU_CHARS_STATUS(x)		(((x) >> 7) & 0x7)
 #define	SMB_PSU_CHARS_TYPE(x)		(((x) >> 10) & 0xf)
 
+/*
+ * SMBIOS implementation structure for SMB_TYPE_OBDEVEXT.
+ */
 typedef struct smb_obdev_ext {
 	smb_header_t smbobe_hdr;	/* structure header */
 	uint8_t smbobe_name;		/* reference designation */
@@ -415,6 +568,9 @@ typedef struct smb_obdev_ext {
 	uint8_t smbobe_df;		/* device/function number */
 } smb_obdev_ext_t;
 
+/*
+ * SMBIOS implementation structure for SUN_OEM_EXT_PROCESSOR.
+ */
 typedef struct smb_processor_ext {
 	smb_header_t smbpre_hdr;	/* structure header */
 	uint16_t smbpre_processor;	/* processor handle */
@@ -423,6 +579,9 @@ typedef struct smb_processor_ext {
 	uint16_t smbpre_apicid[1];	/* strand initial apic id */
 } smb_processor_ext_t;
 
+/*
+ * SMBIOS implementation structure for SUN_OEM_EXT_PORT.
+ */
 typedef struct smb_port_ext {
 	smb_header_t smbpoe_hdr;	/* structure header */
 	uint16_t smbpoe_chassis;	/* chassis handle */
@@ -432,12 +591,18 @@ typedef struct smb_port_ext {
 	uint8_t smbpoe_phy;		/* PHY number */
 } smb_port_ext_t;
 
+/*
+ * SMBIOS implementation structure for SUN_OEM_PCIEXRC.
+ */
 typedef struct smb_pciexrc {
 	smb_header_t smbpciexrc_hdr;	/* structure header */
 	uint16_t smbpciexrc_bboard;	/* base board handle */
 	uint16_t smbpciexrc_bdf;	/* PCI Bus/Dev/Func */
 } smb_pciexrc_t;
 
+/*
+ * SMBIOS implementation structure for SUN_OEM_EXT_MEMARRAY.
+ */
 typedef struct smb_memarray_ext {
 	smb_header_t smbmarre_hdr;	/* structure header */
 	uint16_t smbmarre_ma;		/* memory array handle */
@@ -445,6 +610,9 @@ typedef struct smb_memarray_ext {
 	uint16_t smbmarre_bdf;		/* PCI bus/dev/funct */
 } smb_memarray_ext_t;
 
+/*
+ * SMBIOS implementation structure for SUN_OEM_EXT_MEMDEVICE.
+ */
 typedef struct smb_memdevice_ext {
 	smb_header_t smbmdeve_hdr;	/* structure header */
 	uint16_t smbmdeve_mdev;		/* memory device handle */
@@ -491,7 +659,7 @@ struct smbios_hdl {
 #define	SMB_RANGE_LIMIT	0xFFFFF		/* limit of physical address range */
 #define	SMB_SCAN_STEP	16		/* stepping by paragraph */
 
-#define	SMB_MAJMIN(M, m)	((((M) & 0xFF) << 16) | ((m) & 0xFF))
+#define	SMB_MAJMIN(M, m)	((((M) & 0xFF) << 8) | ((m) & 0xFF))
 #define	SMB_MAJOR(v)		(((v) & 0xFF00) >> 8)
 #define	SMB_MINOR(v)		(((v) & 0x00FF))
 
