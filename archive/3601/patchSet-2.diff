commit eb38cbcb78ddec98c209cc95c027b7711a05e154 (refs/changes/01/3601/2)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-03-13T01:28:10+00:00 (1 year, 7 months ago)
    
    TRITON-95 Failure to write ipf(6).conf for a zone shouldn't block reloading other zones' firewalls

diff --git a/src/fw/lib/fw.js b/src/fw/lib/fw.js
index 77dfd2bb..669fc836 100644
--- a/src/fw/lib/fw.js
+++ b/src/fw/lib/fw.js
@@ -1244,11 +1244,9 @@ function prepareIPFdata(opts, log, callback) {
         });
     });
 
-    var toReturn = { files: {}, vms: [] };
+    var toReturn = [];
     for (var vm in conf) {
         var rulesIncluded = {};
-        var v4filename = util.format(IPF_CONF, allVMs.all[vm].zonepath);
-        var v6filename = util.format(IPF6_CONF, allVMs.all[vm].zonepath);
         var ipf4Conf = [
             '# DO NOT EDIT THIS FILE. THIS FILE IS AUTO-GENERATED BY fwadm(1M)',
             '# AND MAY BE OVERWRITTEN AT ANY TIME.',
@@ -1259,8 +1257,6 @@ function prepareIPFdata(opts, log, callback) {
         var ipf6Conf = ipf4Conf.slice();
         var iks = hasKey(keepInboundState, vm) ? keepInboundState[vm] : {};
 
-        toReturn.vms.push(vm);
-
         conf[vm].sort(compareRules).forEach(function (sortObj) {
             var ktxt = KEEP_FRAGS;
             if (sortObj.direction === 'to' && iks[sortObj.protocol]) {
@@ -1288,8 +1284,12 @@ function prepareIPFdata(opts, log, callback) {
         var v4rules = ipf4Conf.concat(v4fallbacks);
         var v6rules = ipf6Conf.concat(v6fallbacks);
 
-        toReturn.files[v4filename] = v4rules.join('\n') + '\n';
-        toReturn.files[v6filename] = v6rules.join('\n') + '\n';
+        toReturn.push({
+            uuid: vm,
+            zonepath: allVMs.all[vm].zonepath,
+            v4text: v4rules.join('\n') + '\n',
+            v6text: v6rules.join('\n') + '\n'
+        });
     }
 
     return callback(null, toReturn);
@@ -1504,93 +1504,150 @@ function addOtherSideRemoteTargets(vms, rule, targets, dir, log) {
 
 
 /**
- * Saves all of the files in ipfData to disk
+ * Carefully move the new ipfilter configuration file into place. It's
+ * important to make sure that if we fail or crash at any point that we
+ * leave a file in place, since its presence is what determines whether
+ * to enable the firewall at zone boot.
  */
-function saveIPFfiles(ipfData, log, callback) {
+function replaceIPFconf(file, data, ver, callback) {
+    var tempFile = util.format('%s.%s', file, ver);
+    var oldFile = util.format('%s.old', file);
+
+    vasync.pipeline({
+    funcs: [
+        function _write(_, cb) {
+            fs.writeFile(tempFile, data, cb);
+        },
+        function _unlinkOld(_, cb) {
+            fs.unlink(oldFile, function (err) {
+                if (err && err.code === 'ENOENT') {
+                    cb(null);
+                    return;
+                }
+
+                cb(err);
+            });
+        },
+        function _linkOld(_, cb) {
+            fs.link(file, oldFile, function (err) {
+                if (err && err.code === 'ENOENT') {
+                    cb(null);
+                    return;
+                }
+
+                cb(err);
+            });
+        },
+        function _renameTemp(_, cb) {
+            fs.rename(tempFile, file, cb);
+        }
+    ]}, callback);
+}
+
+
+/**
+ * Saves all of the generated ipfilter rules in ipfData to disk. We handle
+ * each VM separately in parallel, so that failures for one don't impact
+ * reloading others. For example, a VM may have filled up its disk, and we
+ * now can't write out its configuration, or a VM may have stopped on us
+ * before we had a chance to run ipf(1M) on it.
+ */
+function saveConfsAndReload(opts, ipfData, log, callback) {
     var ver = Date.now(0) + '.' + sprintf('%06d', process.pid);
+    var files = {};
+    var uuids = [];
 
-    return vasync.forEachParallel({
-        inputs: Object.keys(ipfData),
-        func: function _apply(file, cb) {
-            var tempFile = util.format('%s.%s', file, ver);
-            var oldFile = util.format('%s.old', file);
+    vasync.forEachParallel({
+        inputs: ipfData,
+        func: function (vm, cb) {
+            uuids.push(vm.uuid);
 
             vasync.pipeline({
             funcs: [
-                function _write(_, cb2) {
-                    log.trace('saveIPFfiles: writing temp file "%s"', tempFile);
-                    return fs.writeFile(tempFile, ipfData[file], cb2);
-                },
-                function _unlinkOld(_, cb2) {
-                    return fs.unlink(oldFile, function (err) {
-                        if (err && err.code === 'ENOENT') {
-                            return cb2(null);
-                        }
-                        return cb2(err);
-                    });
+                // Write the new ipf.conf for IPv4 rules:
+                function writeV4(_, cb2) {
+                    var filename = util.format(IPF_CONF, vm.zonepath);
+                    files[filename] = vm.v4text;
+
+                    if (opts.dryrun) {
+                        cb2(null);
+                        return;
+                    }
+
+                    replaceIPFconf(filename, vm.v4text, ver, cb2);
                 },
-                function _linkOld(_, cb2) {
-                    return fs.link(file, oldFile, function (err) {
-                        if (err && err.code === 'ENOENT') {
-                            return cb2(null);
-                        }
-                        return cb2(err);
-                    });
+
+                // Write the new ipf6.conf for IPv6 rules:
+                function writeV6(_, cb2) {
+                    var filename = util.format(IPF6_CONF, vm.zonepath);
+                    files[filename] = vm.v6text;
+
+                    if (opts.dryrun) {
+                        cb2(null);
+                        return;
+                    }
+
+                    replaceIPFconf(filename, vm.v6text, ver, cb2);
                 },
-                function _renameTemp(_, cb2) {
-                    return fs.rename(tempFile, file, cb2);
+
+                // Restart the VM's firewall:
+                function reload(_, cb2) {
+                    if (opts.dryrun) {
+                        cb2(null);
+                        return;
+                    }
+
+                    restartFirewall(opts.allVMs, vm.uuid, log, cb2);
                 }
             ]}, cb);
         }
-    }, function (err, res) {
-        return callback(err, res);
+    }, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        callback(null, {
+            files: files,
+            vms: uuids
+        });
     });
 }
 
 
 /**
- * Restart the firewalls for VMs listed in uuids
+ * Restart the given VMs firewall.
  *
  * @param vms {Object}: VM lookup table, as returned by createVMlookup()
- * @param rules {Array}: array of VM UUIDs to restart
- * @param callback {Function} `function (err, restarted)`
- * - Where restarted is a list of UUIDs for VMs that were actually restarted
+ * @param uuid {UUID}: The UUID of the target VM
+ * @param callback {Function} `function (err)`
  */
-function restartFirewalls(vms, uuids, log, callback) {
-    log.trace(uuids, 'restartFirewalls: entry');
-    var restarted = [];
-
-    return vasync.forEachParallel({
-        inputs: uuids,
-        func: function _restart(uuid, cb) {
-            if (!vms.all[uuid].enabled || vms.all[uuid].state !== 'running') {
-                log.debug('restartFirewalls: VM "%s": not restarting '
-                    + '(enabled=%s, state=%s)', uuid, vms.all[uuid].enabled,
-                    vms.all[uuid].state);
-                return cb(null);
-            }
-
-            log.debug('restartFirewalls: reloading firewall for VM "%s" '
-                + '(enabled=%s, state=%s)', uuid, vms.all[uuid].enabled,
-                vms.all[uuid].state);
-
-            // Reload the firewall, and start it if necessary.
-            reloadIPF({ vm: uuid, zonepath: vms.all[uuid].zonepath },
-                log, function (err, res) {
-                restarted.push(uuid);
-                if (err && zoneNotRunning(res)) {
-                    // An error starting the firewall due to the zone not
-                    // running isn't really an error
-                    cb();
-                    return;
-                }
+function restartFirewall(vms, uuid, log, cb) {
+    if (!vms.all[uuid].enabled || vms.all[uuid].state !== 'running') {
+        log.debug('restartFirewalls: VM "%s": not restarting '
+            + '(enabled=%s, state=%s)', uuid, vms.all[uuid].enabled,
+            vms.all[uuid].state);
+        cb(null);
+        return;
+    }
 
-                cb(err);
-            });
+    log.debug('restartFirewalls: reloading firewall for VM "%s" '
+        + '(enabled=%s, state=%s)', uuid, vms.all[uuid].enabled,
+        vms.all[uuid].state);
+
+    // Reload the firewall, and start it if necessary.
+    reloadIPF({ vm: uuid, zonepath: vms.all[uuid].zonepath }, log,
+        function (err, res) {
+        if (err && zoneNotRunning(res)) {
+            /*
+             * An error starting the firewall due to the zone not
+             * running isn't really an error.
+             */
+            cb();
+            return;
         }
-    }, function (err, res) {
-        // XXX: Does this stop on the first error?
-        return callback(err, restarted);
+
+        cb(err);
     });
 }
 
@@ -1631,7 +1688,7 @@ function applyChanges(opts, log, callback) {
     pipeline({
     funcs: [
         // Generate the ipf files for each VM
-        function ipfData(res, cb) {
+        function reloadPlan(res, cb) {
             prepareIPFdata({
                 allVMs: opts.allVMs,
                 remoteVMs: opts.allRemoteVMs,
@@ -1676,25 +1733,14 @@ function applyChanges(opts, log, callback) {
             mod_rvm.del(opts.del.rvms, log, cb);
         },
 
-        // Write the new ipf files to disk
-        function writeIPF(res, cb) {
-            if (opts.dryrun) {
-                return cb(null);
-            }
-            saveIPFfiles(res.ipfData.files, log, cb);
-        },
-
-        // Restart the firewalls for all of the affected VMs
-        function restart(res, cb) {
-            if (opts.dryrun) {
-                return cb(null);
-            }
-            restartFirewalls(opts.allVMs, res.ipfData.vms, log, cb);
+        // Write the new ipf files to disk and restart affected VMs
+        function ipfData(res, cb) {
+            saveConfsAndReload(opts, res.reloadPlan, log, cb);
         }
-
     ] }, function (err, res) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var toReturn = {
@@ -1729,7 +1775,7 @@ function applyChanges(opts, log, callback) {
             toReturn.files = res.state.ipfData.files;
         }
 
-        return callback(null, toReturn);
+        callback(null, toReturn);
     });
 }
 
