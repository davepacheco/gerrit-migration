commit 980439154fe2dd14aac4b8a03bca5e6ef9b6a0c4 (refs/changes/02/1502/4)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2017-02-14T02:28:28+00:00 (2 years, 8 months ago)
    
    NAPI-121 Allow searching network pools by name and networks
    NAPI-386 Want description for network pools
    NAPI-395 Network pools should only contain networks of the same address family

diff --git a/docs/index.md b/docs/index.md
index 2f2d10f..96ea991 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -10,7 +10,7 @@ markdown2extras: tables, code-friendly, fenced-code-blocks
 -->
 
 <!--
-    Copyright (c) 2015, Joyent, Inc.
+    Copyright 2017, Joyent, Inc.
 -->
 
 # Networking API (NAPI)
@@ -453,7 +453,8 @@ No response payload, only a "204 No Content" response status.
 
 ## ProvisionNic (POST /networks/:network_uuid/nics)
 
-Creates a new nic, provisioning an IP and MAC address in the process.
+Creates a new NIC, provisioning an IP and MAC address in the process. The
+`:network_uuid` can refer to a Network or a [Network Pool](#network-pools).
 
 ### Inputs
 
@@ -1246,11 +1247,14 @@ Returns a list of all logical network pools.
 All parameters are optional filters on the list. A network pool will be listed
 if it matches *all* of the input parameters.
 
-| Field            | Type    | Description                                                    |
-| ---------------- | ------- | -------------------------------------------------------------- |
-| provisionable_by | UUID    | Return network pools that are provisionable by this owner_uuid |
-| offset           | Integer | Starting offset, see [Pagination](#pagination)                 |
-| limit            | Integer | Maximum number of responses, see [Pagination](#pagination)     |
+| Field            | Type           | Description                                                                              |
+| ---------------- | -------------- | ---------------------------------------------------------------------------------------- |
+| name             | String         | Return network pools that match the pool name                                            |
+| family           | String         | Return network pools containing networks of the given family (one of 'ipv4' or 'ipv6')   |
+| networks         | Array of UUIDs | Return network pools that contain the given network UUID (only one can be given for now) |
+| provisionable_by | UUID           | Return network pools that are provisionable by this owner_uuid                           |
+| offset           | Integer        | Starting offset, see [Pagination](#pagination)                                           |
+| limit            | Integer        | Maximum number of responses, see [Pagination](#pagination)                               |
 
 ### Example
 
@@ -1258,7 +1262,9 @@ if it matches *all* of the input parameters.
     [
       {
         "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
-        "name": "internal",
+        "name": "internal networks",
+        "nic_tag": "internal",
+        "family": "ipv4",
         "networks": [
           "0e70de36-a40b-4ac0-9429-819f5ff822bd",
           "9f2eada0-529b-4673-a377-c249f9240a12"
@@ -1266,7 +1272,10 @@ if it matches *all* of the input parameters.
       },
       {
         "uuid": "e967a42b-312d-490c-b753-c4768d9f2091",
-        "name": "external",
+        "name": "external v6 networks",
+        "description": "Logical pool of public IPv6 addresses",
+        "nic_tag": "external",
+        "family": "ipv6",
         "networks": [
           "57a83e2b-527c-41c1-983c-be9b792011dc",
           "8ba8a35f-3eb3-496b-8103-8238eb40f9d0"
@@ -1283,7 +1292,8 @@ Creates a new logical network provisioning pool.
 
 | Field       | Type           | Description                                                          |
 | ----------- | -------------- | -------------------------------------------------------------------- |
-| name        | String         | network provisioning pool name                                       |
+| name        | String         | Network provisioning pool name                                       |
+| description | String         | Description of the new network pool                                  |
 | networks    | Array of UUIDs | Logical Network UUIDs                                                |
 | owner_uuids | Array of UUIDs | UFDS user UUIDs allowed to provision on this network pool (Optional) |
 
@@ -1297,11 +1307,13 @@ Creates a new logical network provisioning pool.
 ### Example
 
     POST /network_pools
-        name=internal
+        name=internal%20networks
         networks=0e70de36-a40b-4ac0-9429-819f5ff822bd,9f2eada0-529b-4673-a377-c249f9240a12
     {
       "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
-      "name": "internal",
+      "name": "internal networks",
+      "nic_tag": "internal",
+      "family": "ipv4",
       "networks": [
         "0e70de36-a40b-4ac0-9429-819f5ff822bd",
         "9f2eada0-529b-4673-a377-c249f9240a12"
@@ -1318,7 +1330,9 @@ Gets a logical network provisioning pool by UUID.
     GET /network_pools/3b5913ec-42e6-4803-9c0b-c9b1c5603520
     {
       "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
-      "name": "internal",
+      "name": "internal networks",
+      "nic_tag": "internal",
+      "family": "ipv4",
       "networks": [
         "0e70de36-a40b-4ac0-9429-819f5ff822bd",
         "9f2eada0-529b-4673-a377-c249f9240a12"
@@ -1334,18 +1348,22 @@ Changes a logical network provisioning pool.
 
 Must specify at least one of:
 
-| Field    | Type           | Description                    |
-| -------- | -------------- | ------------------------------ |
-| name     | String         | network provisioning pool name |
-| networks | Array of UUIDs | Logical Network UUIDs          |
+| Field       | Type           | Description                                                          |
+| ----------- | -------------- | -------------------------------------------------------------------- |
+| name        | String         | Network provisioning pool name                                       |
+| description | String         | Description of the new network pool                                  |
+| networks    | Array of UUIDs | Logical Network UUIDs                                                |
+| owner_uuids | Array of UUIDs | UFDS user UUIDs allowed to provision on this network pool            |
 
 ### Example
 
     PUT /network_pools/3b5913ec-42e6-4803-9c0b-c9b1c5603520
-        name=internal2
+        name=internal-pool
     {
       "uuid": "3b5913ec-42e6-4803-9c0b-c9b1c5603520",
-      "name": "internal2",
+      "name": "internal-pool",
+      "nic_tag": "internal",
+      "family": "ipv4",
       "networks": [
         "0e70de36-a40b-4ac0-9429-819f5ff822bd",
         "9f2eada0-529b-4673-a377-c249f9240a12"
diff --git a/lib/endpoints/networks/index.js b/lib/endpoints/networks/index.js
index 3f1452e..c22cf1a 100644
--- a/lib/endpoints/networks/index.js
+++ b/lib/endpoints/networks/index.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -30,26 +30,23 @@ var restify = require('restify');
  * Ensures the network isn't in use in a network pool
  */
 function ensureNetworkUnused(req, res, next) {
-    return mod_pool.list(req.app, req.log, { }, function (err, pools) {
+    mod_pool.list(req.app, req.log, { networks: [ req.params.uuid ] },
+        function (err, usedBy) {
         if (err) {
-            return next(err);
+            next(err);
+            return;
         }
 
-        var usedBy = [];
-        for (var p in pools) {
-            if (pools[p].networks.indexOf(req.params.uuid) !== -1) {
-                usedBy.push(pools[p].uuid);
-            }
+        if (usedBy.length === 0) {
+            next();
+            return;
         }
 
-        if (usedBy.length !== 0) {
-            return next(new errors.InUseError('Network is in use',
-                usedBy.map(function (uuid) {
-                    return errors.usedBy('network pool', uuid);
-                })));
-        }
+        var usedByErrs = usedBy.map(function (pool) {
+            return errors.usedBy('network pool', pool.uuid);
+        });
 
-        return next();
+        next(new errors.InUseError('Network is in use', usedByErrs));
     });
 }
 
diff --git a/lib/models/network-pool.js b/lib/models/network-pool.js
index 01d2ec1..749b4b7 100644
--- a/lib/models/network-pool.js
+++ b/lib/models/network-pool.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -17,6 +17,7 @@
 var assert = require('assert-plus');
 var constants = require('../util/constants');
 var errors = require('../util/errors');
+var jsprim = require('jsprim');
 var mod_moray = require('../apis/moray');
 var mod_net = require('./network');
 var restify = require('restify');
@@ -37,10 +38,20 @@ var BUCKET = {
     name: 'napi_network_pools',
     schema: {
         index: {
-            owner_uuids: { type: 'string' },
-            uuid: { type: 'string', unique: true }
+            name: { type: 'string' },
+            networks: { type: '[string]' },
+            owner_uuids_arr: { type: '[string]' },
+            family: { type: 'string' },
+            uuid: { type: 'string', unique: true },
+            description: { type: 'string' },
+            v: { type: 'number' },
+
+            // Deprecated indexes, left here in case we need to rollback:
+            owner_uuids: { type: 'string' }
         }
-    }
+    },
+    morayVersion: 2,        // moray version must be > than this
+    version: 1
 };
 var MAX_NETS = 64;
 
@@ -53,6 +64,7 @@ var CREATE_SCHEMA = {
         networks: validateNetworks
     },
     optional: {
+        description: validate.string,
         owner_uuids: validate.UUIDarray,
         uuid: validate.UUID
     },
@@ -73,7 +85,25 @@ var LIST_SCHEMA = {
     optional: {
         limit: validate.limit,
         offset: validate.offset,
+        name: validate.string,
+        family: validate.enum([ 'ipv4', 'ipv6' ]),
+        networks: validate.stringOrArray,
         provisionable_by: validate.UUID
+    },
+    after: function (_opts, _, parsed, cb) {
+        /*
+         * For now we only allow a single network UUID; in the future, once we
+         * decide how we want searching on multiple UUIDs to work by default
+         * (AND or OR), this restriction can be lifted.
+         */
+        var networks = parsed.networks;
+        if (networks && Array.isArray(networks) && networks.length > 1) {
+            cb(new errors.invalidParam('networks',
+                'Only one network UUID allowed'));
+            return;
+        }
+
+        cb();
     }
 };
 
@@ -83,14 +113,16 @@ var UPDATE_SCHEMA = {
     },
     optional: {
         name: validate.string,
+        description: validate.string,
         networks: validateNetworks,
         owner_uuids: function (_, name, uuids, cb) {
-            if (!uuids) {
-                // Allow removing owner_uuids
-                return cb(null, false);
+            if (uuids === null) {
+                // Allow removing owner_uuids with null
+                cb(null, []);
+                return;
             }
 
-            return validate.UUIDarray(null, name, uuids, cb);
+            validate.UUIDarray(null, name, uuids, cb);
         }
     },
     after: function (opts, original, parsed, cb) {
@@ -128,29 +160,84 @@ function provisionableBy(params, uuid) {
 }
 
 
+/**
+ * Fetch the Network objects for each of the given UUIDs.
+ */
+function getAllNetworks(app, log, uuids, callback) {
+    var networks = [];
+
+    vasync.forEachParallel({
+        inputs: uuids,
+        func: function (uuid, cb) {
+            mod_net.get({
+                app: app,
+                log: log,
+                params: { uuid: uuid }
+            }, function (err3, obj) {
+                if (obj) {
+                    networks.push(obj);
+                }
+
+                cb(err3);
+            });
+        }
+    }, function (err4) {
+        if (err4) {
+            callback(err4);
+            return;
+        }
+
+        callback(null, networks);
+    });
+}
+
+
 /**
  * Validate that the networks in a pool are not over the maximum limit, and
  * that they all exist.
  */
-function validateNetworks(opts, name, list, callback) {
+function validateNetworks(opts, name, value, callback) {
+    validate.UUIDarray(opts, name, value, function (err, uuids) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        _validateNetworks(opts, name, uuids, callback);
+    });
+}
+
+
+function _validateNetworks(opts, name, uuids, callback) {
     var nets = [];
     var notFound = [];
     var tag;
     var tagsNotMatching = [];
-    var uuids = util_common.arrayify(list);
+    var pool_type;
+    var poolTypeNotMatching = [];
     var validated = [];
 
     assert.ok(opts.app, 'opts.app');
     assert.ok(opts.log, 'opts.log');
 
+    /*
+     * Initialize the pool type to the current family to
+     * prevent changing the family of a pool.
+     */
+    if (opts.hasOwnProperty('oldPool')) {
+        pool_type = opts.oldPool.family;
+    }
+
     if (uuids.length === 0) {
-        return callback(errors.invalidParam(name,
+        callback(errors.invalidParam(name,
             constants.POOL_MIN_NETS_MSG));
+        return;
     }
 
     if (uuids.length > MAX_NETS) {
-        return callback(errors.invalidParam(name,
+        callback(errors.invalidParam(name,
             util.format('maximum %d networks per network pool', MAX_NETS)));
+        return;
     }
 
     vasync.forEachParallel({
@@ -160,33 +247,46 @@ function validateNetworks(opts, name, list, callback) {
                 app: opts.app,
                 log: opts.log,
                 params: { uuid: uuid }
-            }, function (err, res) {
+            }, function (err, net) {
                 if (err) {
                     if (err.name === 'ResourceNotFoundError') {
                         notFound.push(uuid);
-                        return cb();
+                        cb();
                     } else {
-                        return cb(err);
+                        cb(err);
                     }
+                    return;
                 }
 
                 if (tag === undefined) {
-                    tag = res.params.nic_tag;
+                    tag = net.nic_tag;
                 }
 
-                if (res.params.nic_tag !== tag) {
+                if (net.nic_tag !== tag) {
                     tagsNotMatching.push(uuid);
-                    return cb();
+                    cb();
+                    return;
+                }
+
+                if (pool_type === undefined) {
+                    pool_type = net.family;
+                }
+
+                if (net.family !== pool_type) {
+                    poolTypeNotMatching.push(uuid);
+                    cb();
+                    return;
                 }
 
                 validated.push(uuid);
-                nets.push(res);
-                return cb();
+                nets.push(net);
+                cb();
             });
         }
     }, function (err) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         if (notFound.length !== 0) {
@@ -194,18 +294,26 @@ function validateNetworks(opts, name, list, callback) {
                 util.format('unknown network%s',
                     notFound.length === 1 ? '' : 's'));
             err.invalid = notFound;
-            return callback(err);
+            callback(err);
+            return;
         }
 
         if (tagsNotMatching.length !== 0) {
-            return callback(errors.invalidParam(name,
+            callback(errors.invalidParam(name,
                 constants.POOL_TAGS_MATCH_MSG));
+            return;
+        }
+
+        if (poolTypeNotMatching.length !== 0) {
+            callback(errors.invalidParam(name,
+                constants.POOL_AF_MATCH_MSG));
+            return;
         }
 
         var toReturn = { _networks: nets };
         toReturn[name] = validated;
 
-        return callback(null, null, toReturn);
+        callback(null, null, toReturn);
     });
 }
 
@@ -218,7 +326,8 @@ function validateNetworkOwners(_opts, _, parsed, callback) {
     if (!parsed.owner_uuids || !parsed._networks ||
         parsed.owner_uuids.length === 0 ||
         parsed._networks.length === 0) {
-        return callback();
+        callback();
+        return;
     }
 
     var owners = {};
@@ -243,10 +352,11 @@ function validateNetworkOwners(_opts, _, parsed, callback) {
         var err = errors.invalidParam('networks',
             constants.POOL_OWNER_MATCH_MSG);
         err.invalid = notMatching;
-        return callback(err);
+        callback(err);
+        return;
     }
 
-    return callback();
+    callback();
 }
 
 
@@ -262,8 +372,8 @@ function NetworkPool(params) {
     delete params.nic_tag;
     if (params._networks && util.isArray(params._networks) &&
         params._networks.length !== 0) {
+        params.family = params._networks[0].family;
         params.nic_tag = params._networks[0].params.nic_tag;
-        delete params._networks;
     }
 
     mod_moray.valToArray(params, 'owner_uuids');
@@ -276,12 +386,26 @@ function NetworkPool(params) {
     if (this.params.hasOwnProperty('networks')) {
         this.params.networks = util_common.arrayify(this.params.networks);
     }
+
+    this.etag = params.etag || null;
+
+    Object.seal(this);
 }
 
 Object.defineProperty(NetworkPool.prototype, 'networks', {
     get: function () { return this.params.networks.sort(); }
 });
 
+Object.defineProperty(NetworkPool.prototype, 'family', {
+    get: function () {
+        if (this.params.family !== undefined) {
+            return this.params.family;
+        }
+
+        return 'ipv4';
+    }
+});
+
 Object.defineProperty(NetworkPool.prototype, 'uuid', {
     get: function () { return this.params.uuid; }
 });
@@ -292,12 +416,16 @@ Object.defineProperty(NetworkPool.prototype, 'uuid', {
  */
 NetworkPool.prototype.raw = function poolRaw() {
     var raw = {
+        v: BUCKET.version,
+        family: this.family,
         uuid: this.params.uuid,
         name: this.params.name,
+        description: this.params.description,
         networks: this.params.networks.sort()
     };
 
     if (this.params.owner_uuids) {
+        raw.owner_uuids_arr = this.params.owner_uuids;
         raw.owner_uuids = mod_moray.arrayToVal(this.params.owner_uuids);
     }
 
@@ -305,11 +433,33 @@ NetworkPool.prototype.raw = function poolRaw() {
 };
 
 
+/**
+ * Returns the raw Moray form of this pool for adding to a batch.
+ */
+NetworkPool.prototype.batch = function poolBatch() {
+    return {
+        bucket: BUCKET.name,
+        key: this.uuid,
+        operation: 'put',
+        value: this.raw(),
+        options: {
+            etag: this.etag
+        }
+    };
+};
+
+
 /**
  * Returns the serialized (API-facing) form of the network pool
  */
 NetworkPool.prototype.serialize = function poolSerialize() {
-    var ser = this.raw();
+    var ser = {
+        family: this.family,
+        uuid: this.params.uuid,
+        name: this.params.name,
+        description: this.params.description,
+        networks: this.params.networks.sort()
+    };
 
     if (this.params.hasOwnProperty('nic_tag')) {
         ser.nic_tag = this.params.nic_tag;
@@ -337,17 +487,19 @@ function createNetworkPool(app, log, params, callback) {
     validate.params(CREATE_SCHEMA, { app: app, log: log }, params,
         function (err, validatedParams) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var pool = new NetworkPool(validatedParams);
-        app.moray.putObject(BUCKET.name, pool.uuid, pool.raw(),
+        app.moray.putObject(BUCKET.name, pool.uuid, pool.raw(), { etag: null },
             function (err2) {
             if (err2) {
-                return callback(err2);
+                callback(err2);
+                return;
             }
 
-            return callback(null, pool);
+            callback(null, pool);
         });
     });
 }
@@ -367,35 +519,37 @@ function getNetworkPool(app, log, params, callback) {
         mod_moray.getObj(app.moray, BUCKET, validated.uuid,
             function (err2, rec) {
             if (err2) {
-                return callback(err2);
+                callback(err2);
+                return;
             }
 
+            rec.value.etag = rec._etag;
+
             if (validated.provisionable_by &&
                 !provisionableBy(rec.value, validated.provisionable_by)) {
-                return callback(new restify.NotAuthorizedError(
+                callback(new restify.NotAuthorizedError(
                     constants.msg.POOL_OWNER));
+                return;
             }
 
             var netUUIDs = rec.value.networks;
 
-            // No networks - don't bother fetching one of them, then
-            if (!netUUIDs) {
-                return callback(null, new NetworkPool(rec.value));
-            }
+            assert.array(netUUIDs, 'network pool UUIDs');
 
-            netUUIDs = util_common.arrayify(netUUIDs);
+            // No networks - don't bother trying to fetch anything.
             if (netUUIDs.length === 0) {
-                return callback(null, new NetworkPool(rec.value));
+                callback(null, new NetworkPool(rec.value));
+                return;
             }
 
-            mod_net.get({ app: app, log: log, params: { uuid: netUUIDs[0] } },
-                function (err3, res) {
+            getAllNetworks(app, log, netUUIDs, function (err3, res) {
                 if (err3) {
-                    return callback(err3);
+                    callback(err3);
+                    return;
                 }
 
-                rec.value._networks = [ res ];
-                return callback(null, new NetworkPool(rec.value));
+                rec.value._networks = res;
+                callback(null, new NetworkPool(rec.value));
             });
         });
     });
@@ -407,20 +561,35 @@ function getNetworkPool(app, log, params, callback) {
  */
 function listNetworkPools(app, log, oparams, callback) {
     log.debug({ params: oparams }, 'listNetworkPools: entry');
-    var filter = '(uuid=*)';
 
     validate.params(LIST_SCHEMA, null, oparams, function (valErr, params) {
         if (valErr) {
-            return callback(valErr);
+            callback(valErr);
+            return;
         }
 
+        var filterObj = {};
+
         if (params.provisionable_by) {
             // Match both pools with that owner_uuid as well as no owner_uuid
-            filter = mod_moray.filter({
-                owner_uuids: [ '*,' + params.provisionable_by + ',*', '!*' ]
-            });
+            filterObj.owner_uuids_arr = [ params.provisionable_by, '!*' ];
         }
 
+        if (params.family) {
+            filterObj.family = params.family;
+        }
+
+        if (params.name) {
+            filterObj.name = params.name;
+        }
+
+        if (params.networks) {
+            filterObj.networks = params.networks;
+        }
+
+        var filter = jsprim.isEmpty(filterObj) ?
+            '(uuid=*)' : mod_moray.filter(filterObj);
+
         var req = app.moray.findObjects(BUCKET.name, filter, {
             limit: params.limit,
             offset: params.offset,
@@ -446,41 +615,37 @@ function listNetworkPools(app, log, oparams, callback) {
                 inputs: values,
                 func: function _getNet(val, cb) {
                     if (!val.networks) {
-                        return cb();
+                        cb();
+                        return;
                     }
 
                     var nets = util_common.arrayify(val.networks);
                     if (nets.length === 0) {
-                        return cb();
+                        cb();
+                        return;
                     }
 
-                    mod_net.get({
-                        app: app,
-                        log: log,
-                        params: { uuid: nets[0] }
-                    }, function (err, res) {
-                        if (err) {
-                            return cb(err);
+                    getAllNetworks(app, log, nets, function (err, res) {
+                        if (res) {
+                            val._networks = res;
                         }
 
-                        val._networks = [ res ];
-
-                        return cb();
+                        cb(err);
                     });
                 }
             }, function (err) {
                 if (err) {
-                    return callback(err);
+                    callback(err);
+                    return;
                 }
 
                 var pools = values.map(function (n) {
                     return new NetworkPool(n);
                 });
 
-                return callback(null, pools);
+                callback(null, pools);
             });
         });
-
     });
 }
 
@@ -493,7 +658,8 @@ function updateNetworkPool(app, log, params, callback) {
 
     getNetworkPool(app, log, params, function (getErr, oldPool) {
         if (getErr) {
-            return callback(getErr);
+            callback(getErr);
+            return;
         }
 
         if (!params.hasOwnProperty('networks') &&
@@ -513,46 +679,33 @@ function updateNetworkPool(app, log, params, callback) {
         validate.params(UPDATE_SCHEMA, uopts, params,
             function (err, validatedParams) {
             if (err) {
-                return callback(err);
+                callback(err);
+                return;
             }
 
             if (validatedParams.hasOwnProperty('owner_uuids') &&
-                validatedParams.owner_uuids) {
-                validatedParams.owner_uuids =
-                    mod_moray.arrayToVal(validatedParams.owner_uuids);
-
-                // An empty owner_uuids array is effectively a delete
-                if (validatedParams.owner_uuids === ',,') {
-                    validatedParams.owner_uuids = null;
-                }
+                validatedParams.owner_uuids.length === 0) {
+                validatedParams.owner_uuids = null;
             }
 
-            var toUpdate = oldPool.raw();
-            for (var p in validatedParams) {
-                if (p === '_networks' || p === 'nic_tag') {
-                    continue;
-                }
+            var updatedParams = oldPool.raw();
+            updatedParams._networks = oldPool.params._networks;
 
-                if (!validatedParams[p]) {
-                    delete toUpdate[p];
-                } else {
-                    toUpdate[p] = validatedParams[p];
-                }
+            for (var p in validatedParams) {
+                updatedParams[p] = validatedParams[p];
             }
 
-            mod_moray.updateObj({
-                moray: app.moray,
-                bucket: BUCKET,
-                key: params.uuid,
-                replace: true,
-                val: toUpdate
-            }, function (err2, rec) {
+            var newPool = new NetworkPool(updatedParams);
+
+            app.moray.putObject(BUCKET.name, params.uuid, newPool.raw(), {
+                etag: oldPool.etag
+            }, function (err2) {
                 if (err2) {
-                    return callback(err2);
+                    callback(err2);
+                    return;
                 }
 
-                rec.value._networks = validatedParams._networks;
-                return callback(null, new NetworkPool(rec.value));
+                callback(null, newPool);
             });
         });
     });
diff --git a/lib/models/network.js b/lib/models/network.js
index 2fe3ff2..44c832c 100644
--- a/lib/models/network.js
+++ b/lib/models/network.js
@@ -1139,6 +1139,10 @@ Object.defineProperty(Network.prototype, 'ip_use_strings', {
     get: function () { return this.params.ip_use_strings; }
 });
 
+Object.defineProperty(Network.prototype, 'family', {
+    get: function () { return this.params.subnet_type; }
+});
+
 Object.defineProperty(Network.prototype, 'uuid', {
     get: function () { return this.params.uuid; }
 });
@@ -1645,9 +1649,7 @@ function updateNetwork(opts, callback) {
 
 
 function validateListNetworks(params, callback) {
-    validate.params(LIST_SCHEMA, null, params, function (err, res) {
-        return callback(err, res);
-    });
+    validate.params(LIST_SCHEMA, null, params, callback);
 }
 
 
diff --git a/lib/util/constants.js b/lib/util/constants.js
index 5b69e9b..4b11955 100644
--- a/lib/util/constants.js
+++ b/lib/util/constants.js
@@ -153,6 +153,8 @@ module.exports = {
         'network owner_uuids do not match the owner_uuids of the pool',
     POOL_TAGS_MATCH_MSG:
         'nic tags of all networks in a network pool must match',
+    POOL_AF_MATCH_MSG:
+        'address family of all networks in a network pool must match',
     PRIV_RANGE_ONLY: 'subnet must be within private ranges',
     PROV_RANGE_ORDER_MSG:
         'provision_start_ip must be before provision_end_ip',
diff --git a/package.json b/package.json
index b5a296b..da72861 100644
--- a/package.json
+++ b/package.json
@@ -18,7 +18,7 @@
     "node-uuid": "1.4.7",
     "portolan-moray": "git+https://github.com/joyent/sdc-portolan-moray.git#c756be9",
     "restify": "4.1.1",
-    "restify-warden": "0.1.0",
+    "restify-warden": "0.1.1",
     "sdc-clients": "9.2.0",
     "tape": "4.5.1",
     "trace-event": "1.3.0",
diff --git a/test/integration/network-overlap.test.js b/test/integration/network-overlap.test.js
index 2891c8f..18225f7 100644
--- a/test/integration/network-overlap.test.js
+++ b/test/integration/network-overlap.test.js
@@ -42,6 +42,10 @@ var VLAN = {
 };
 
 
+function overlapSort(a, b) {
+    return (a.id > b.id) ? 1 : -1;
+}
+
 
 // --- Setup
 
@@ -228,7 +232,7 @@ function testOverlap(t, testParams) {
             params: params,
             expErr: h.invalidParamErr({
                 errors: mod_err.networkOverlapParams(
-                    [ net, nonOverlappingNets[0] ])
+                    [ net, nonOverlappingNets[0] ]).sort(overlapSort)
             })
         });
     });
diff --git a/test/integration/network-owner.test.js b/test/integration/network-owner.test.js
index c197532..15dbb84 100644
--- a/test/integration/network-owner.test.js
+++ b/test/integration/network-owner.test.js
@@ -88,7 +88,7 @@ function checkProvisionSuccess(newOwner, t) {
 }
 
 
-function createNetworkPool(t, name, params) {
+function createNetworkPool(t, name, type, params) {
     var pidName = name + '-' + process.pid;
     napi.createNetworkPool(pidName, params, function (err, res) {
         if (h.ifErr(t, err, 'create network pool ' + name)) {
@@ -101,8 +101,9 @@ function createNetworkPool(t, name, params) {
         params.networks.sort();
         params.uuid = res.uuid;
         params.nic_tag = state.nicTag.name;
+        params.family = type;
 
-        t.deepEqual(params, res, 'network pool ' + name);
+        t.deepEqual(res, params, 'network pool ' + name);
         state[name] = res;
         return t.end();
     });
@@ -168,14 +169,20 @@ test('setup', function (t) {
 // without an owner that already exist, since these will show up in the
 // list
 test('populate no owner pool list', function (t) {
-    mod_pool.list(t, { }, function (_, res) {
+    mod_pool.list(t, {
+        params: {
+            provisionable_by: mod_uuid.v4()
+        },
+        present: []
+    }, function (err, res) {
         if (res) {
             state.noOwnerPools = res.map(function (p) {
                 return p.uuid;
             });
         }
 
-        return t.end();
+        t.ifError(err);
+        t.end();
     });
 });
 
@@ -223,14 +230,14 @@ test('Create second no owner network', function (t) {
 
 
 test('Create no owner network pool', function (t) {
-    createNetworkPool(t, 'noOwnerPool', {
+    createNetworkPool(t, 'noOwnerPool', 'ipv4', {
         networks: [ state.noOwner.uuid, state.noOwner2.uuid ]
     });
 });
 
 
 test('Create owner network pool', function (t) {
-    createNetworkPool(t, 'ownerPool', {
+    createNetworkPool(t, 'ownerPool', 'ipv4', {
         networks: [ state.network.uuid, state.ownerNet2.uuid ],
         owner_uuids: [ owner ]
     });
@@ -238,8 +245,8 @@ test('Create owner network pool', function (t) {
 
 
 test('Create owner2 network pool', function (t) {
-    createNetworkPool(t, 'ownerPool2', {
-        networks: [ state.ownerNet3.uuid, state.ownerNet3.uuid ],
+    createNetworkPool(t, 'ownerPool2', 'ipv4', {
+        networks: [ state.ownerNet3.uuid, state.ownerNet4.uuid ],
         owner_uuids: [ owner2 ]
     });
 });
@@ -318,22 +325,16 @@ test('provisionable_by network: owner', function (t) {
 test('provisionable_by network: other owner', function (t) {
     var netUuid = state.ownerNet3.uuid;
 
-    napi.getNetwork(netUuid, { params: { provisionable_by: owner } },
-        function (err, res) {
-        t.deepEqual(err, {
-            message: constants.msg.NET_OWNER,
-            statusCode: 403,
-            body: {
-                code: 'NotAuthorized',
-                message: constants.msg.NET_OWNER
-            },
-            restCode: 'NotAuthorized',
-            name: 'NotAuthorizedError'
-        });
-
-        t.ifError(res);
-
-        return t.end();
+    mod_net.get(t, {
+        params: {
+            uuid: netUuid,
+            params: { provisionable_by: owner }
+        },
+        expCode: 403,
+        expErr: {
+            code: 'NotAuthorized',
+            message: constants.msg.NET_OWNER
+        }
     });
 });
 
diff --git a/test/integration/network-pools.test.js b/test/integration/network-pools.test.js
index e771eee..8d0f371 100644
--- a/test/integration/network-pools.test.js
+++ b/test/integration/network-pools.test.js
@@ -94,6 +94,7 @@ test('POST /network_pools', function (t) {
                 networks: [ state.network.uuid ].sort()
             },
             exp: {
+                family: 'ipv4',
                 networks: [ state.network.uuid ].sort(),
                 nic_tag: state.network.nic_tag
             },
@@ -108,6 +109,7 @@ test('POST /network_pools', function (t) {
                 networks: [ state.network.uuid, state.network2.uuid ].sort()
             },
             exp: {
+                family: 'ipv4',
                 networks: [ state.network.uuid, state.network2.uuid ].sort(),
                 nic_tag: state.network.nic_tag
             },
@@ -150,6 +152,7 @@ test('PUT /network_pools/:uuid', function (t) {
 
         params.uuid = state.pools[0].uuid;
         params.nic_tag = state.network.nic_tag;
+        params.family = 'ipv4';
         t.deepEqual(res, params, 'update params');
 
         return napi.getNetworkPool(res.uuid, function (err2, res2) {
diff --git a/test/lib/mock-moray.js b/test/lib/mock-moray.js
index de431c5..2c2e28a 100644
--- a/test/lib/mock-moray.js
+++ b/test/lib/mock-moray.js
@@ -142,7 +142,9 @@ function matchObj(filter, origObj) {
     var obj = {};
     for (var k in origObj.value) {
         var val = origObj.value[k];
-        if (util.isArray(val)) {
+        if (val === undefined) {
+            continue;
+        } else if (util.isArray(val)) {
             obj[k] = clone(origObj.value[k]);
         } else {
             obj[k] = origObj.value[k].toString();
diff --git a/test/lib/pool.js b/test/lib/pool.js
index 8721199..a4d51b7 100644
--- a/test/lib/pool.js
+++ b/test/lib/pool.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -187,19 +187,25 @@ function lastCreated() {
  */
 function list(t, opts, callback) {
     var client = opts.client || mod_client.get();
-    var desc = opts.desc ? (' ' + opts.desc) : '';
-    var params = opts.params || {};
+    var params = opts.params;
 
     assert.object(t, 't');
-    log.debug({ params: params }, 'list network pools');
+    assert.object(opts.params, 'opts.params');
+    assert.optionalObject(opts.expErr, 'opts.expErr');
+    assert.optionalObject(opts.params, 'opts.params');
+    assert.optionalObject(opts.partialExp, 'opts.partialExp');
+    assert.optionalArrayOfObject(opts.present, 'opts.present');
+    assert.ok(opts.present || opts.partialExp || opts.expErr,
+        'one of present, expErr, partialExp required');
 
-    client.listNetworkPools(params, function (err, obj, _, res) {
-        common.ifErr(t, err, 'list pools: ' + JSON.stringify(params) + desc);
-        t.equal(res.statusCode, 200,
-            'status code: ' + JSON.stringify(params) + desc);
+    opts.type = 'pool';
+    opts.id = 'uuid';
+    opts.reqType = 'list';
 
-        return callback(err, obj);
-    });
+    log.debug({ params: params }, 'list network pools');
+
+    client.listNetworkPools(params,
+        common.afterAPIlist.bind(null, t, opts, callback));
 }
 
 /**
diff --git a/test/unit/network-owner.test.js b/test/unit/network-owner.test.js
index 0f8cc40..b51de4a 100644
--- a/test/unit/network-owner.test.js
+++ b/test/unit/network-owner.test.js
@@ -256,7 +256,7 @@ function successfulReserve(params, t) {
 }
 
 
-function createPool(name, params, t) {
+function createPool(name, params, type, t) {
     NAPI.createNetworkPool(name, params, function (err, res) {
         t.ifError(err, 'error returned');
         if (err) {
@@ -267,6 +267,7 @@ function createPool(name, params, t) {
         params.uuid = res.uuid;
         params.name = name;
         params.nic_tag = netParams.nic_tag;
+        params.family = type;
         t.deepEqual(res, params, 'result');
         pools.push(res);
 
@@ -403,7 +404,7 @@ test('create', function (t) {
         createPool('pool1-' + process.pid, {
             networks: [ nets[0].uuid, nets[1].uuid ].sort(),
             owner_uuids: [ owner ]
-        }, t2);
+        }, 'ipv4', t2);
     });
 
 
@@ -412,7 +413,7 @@ test('create', function (t) {
         createPool('pool2-' + process.pid, {
             networks: [ nets[0].uuid, nets[3].uuid ].sort(),
             owner_uuids: [ owner ]
-        }, t2);
+        }, 'ipv4', t2);
     });
 
 
@@ -420,7 +421,7 @@ test('create', function (t) {
         // pools[2]
         createPool('pool3-' + process.pid, {
             networks: [ nets[0].uuid, nets[3].uuid ].sort()
-        }, t2);
+        }, 'ipv4', t2);
     });
 });
 
diff --git a/test/unit/network-pools.test.js b/test/unit/network-pools.test.js
index 724ad5c..67b524b 100644
--- a/test/unit/network-pools.test.js
+++ b/test/unit/network-pools.test.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016, Joyent, Inc.
+ * Copyright 2017, Joyent, Inc.
  */
 
 /*
@@ -53,6 +53,8 @@ function netParams(extra) {
     }
 
     var l = NETS.length;
+    assert.ok(l < 10, 'too many networks');
+
     var params = {
         name: 'net' + l,
         subnet: util.format('10.0.%d.0/28', l),
@@ -70,6 +72,28 @@ function netParams(extra) {
     return h.validNetworkParams(params);
 }
 
+function v6netParams(extra) {
+    if (!extra) {
+        extra = {};
+    }
+
+    var l = NETS.length;
+    assert.ok(l < 10, 'too many networks');
+
+    var params = {
+        name: 'net' + l,
+        // Ensure the networks sort in order of creation:
+        uuid: util.format('%d%d%d%d7862-54fa-4667-89ae-c981cd5ada9a',
+            l, l, l, l)
+    };
+
+    for (var e in extra) {
+        params[e] = extra[e];
+    }
+
+    return h.validIPv6NetworkParams(params);
+}
+
 
 function createNet(t, extra) {
     if (!extra) {
@@ -123,12 +147,12 @@ test('Initial setup', function (t) {
 
         t.test('create net0', function (t2) {
             NAPI.createNetwork(net1Params, function (err2, res2) {
-                t2.ifErr(err2);
                 if (res2) {
                     NETS.push(res2);
                 }
 
-                return t.end();
+                t2.ifErr(err2);
+                t2.end();
             });
         });
 
@@ -152,23 +176,47 @@ test('Initial setup', function (t) {
             createNet(t2);
         });
 
+        t.test('create net6', function (t2) {
+            NAPI.createNetwork(v6netParams(), function (err2, res2) {
+                if (res2) {
+                    NETS.push(res2);
+                }
+
+                t2.ifErr(err2);
+                t2.end();
+            });
+        });
+
+        t.test('create net7', function (t2) {
+            NAPI.createNetwork(v6netParams(), function (err2, res2) {
+                if (res2) {
+                    NETS.push(res2);
+                }
+
+                t2.ifErr(err2);
+                t2.end();
+            });
+        });
+
         t.test('create pool1', function (t2) {
             var name = 'pool1-' + process.pid;
             var params = {
+                description: 'This is pool 1',
                 networks: [ NETS[0].uuid, NETS[1].uuid, NETS[2].uuid ]
             };
 
             NAPI.createNetworkPool(name, params, function (err2, res2) {
-                t.ifErr(err2);
-                if (!err2) {
+                if (res2) {
                     POOLS.push(res2);
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[0].nic_tag;
+                    params.family = 'ipv4';
                     t2.deepEqual(res2, params, 'result');
                 }
 
-                return t2.end();
+                t2.ifErr(err2);
+                t2.end();
             });
         });
 
@@ -180,17 +228,64 @@ test('Initial setup', function (t) {
             };
 
             NAPI.createNetworkPool(name, params, function (err2, res2) {
-                if (!err2) {
+                if (res2) {
                     POOLS.push(res2);
                     params.name = name;
                     params.uuid = res2.uuid;
                     params.nic_tag = NETS[4].nic_tag;
+                    params.family = 'ipv4';
                     t2.deepEqual(res2, params, 'result');
                 }
 
-                return t2.end();
+                t2.ifErr(err2);
+                t2.end();
             });
         });
+
+        t.test('create pool3', function (t2) {
+            var name = 'pool3-' + process.pid;
+            var params = {
+                networks: [ NETS[6].uuid, NETS[7].uuid ],
+                owner_uuids: [ mod_uuid.v4() ]
+            };
+
+            NAPI.createNetworkPool(name, params, function (err2, res2) {
+                if (res2) {
+                    POOLS.push(res2);
+                    params.name = name;
+                    params.uuid = res2.uuid;
+                    params.nic_tag = NETS[6].nic_tag;
+                    params.family = 'ipv6';
+                    t2.deepEqual(res2, params, 'result');
+                }
+
+                t2.ifErr(err2);
+                t2.end();
+            });
+        });
+
+        t.test('create pool4', function (t2) {
+            var name = 'pool4-' + process.pid;
+            var params = {
+                networks: [ NETS[0].uuid, NETS[1].uuid ]
+            };
+
+            NAPI.createNetworkPool(name, params, function (err2, res2) {
+                if (res2) {
+                    POOLS.push(res2);
+                    params.name = name;
+                    params.uuid = res2.uuid;
+                    params.nic_tag = NETS[0].nic_tag;
+                    params.family = 'ipv4';
+                    t2.deepEqual(res2, params, 'result');
+                }
+
+                t2.ifErr(err2);
+                t2.end();
+            });
+        });
+
+        t.end();
     });
 });
 
@@ -304,6 +399,97 @@ test('Create pool - invalid params (non-objects)', function (t) {
 });
 
 
+test('Create pool - mismatched address families', function (t) {
+    mod_pool.create(t, {
+        name: 'pool-fail-3-' + process.pid,
+        params: {
+            networks: [ NETS[0].uuid, NETS[6].uuid ]
+        },
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('networks',
+                constants.POOL_AF_MATCH_MSG) ]
+        })
+    });
+});
+
+
+test('All invalid parameters', function (t) {
+    NAPI.post({ path: '/network_pools' }, {
+        uuid: 'foobar',
+        name: true,
+        networks: { '0': '258f413b-3a37-4c5b-af61-af69ef8a542e' },
+        description: 2017,
+        owner_uuids: { 'owner': '5edc49d0-c3df-c7c2-d475-b92facca7895' }
+    }, function (err, res) {
+        t.ok(err, 'error returned');
+        if (!err) {
+            t.end();
+            return;
+        }
+
+        t.equal(err.statusCode, 422, 'status code');
+        t.deepEqual(err.body, h.invalidParamErr({
+            errors: [
+                mod_err.invalidParam('description',
+                    constants.msg.STR),
+                mod_err.invalidParam('name',
+                    constants.msg.STR),
+                mod_err.invalidParam('networks',
+                    constants.msg.ARRAY_OF_STR),
+                mod_err.invalidParam('owner_uuids',
+                    constants.msg.ARRAY_OF_STR),
+                mod_err.invalidParam('uuid',
+                    constants.msg.INVALID_UUID)
+            ]
+        }), 'error body');
+
+        t.end();
+    });
+});
+
+
+test('Missing "name" parameter', function (t) {
+    NAPI.post({ path: '/network_pools' }, {
+        networks: [ NETS[0].uuid ]
+    }, function (err, res) {
+        t.ok(err, 'error returned');
+        if (!err) {
+            t.end();
+            return;
+        }
+
+        t.equal(err.statusCode, 422, 'status code');
+        t.deepEqual(err.body, h.missingParamErr({
+            errors: [ mod_err.missingParam('name') ]
+        }), 'error body');
+
+        t.end();
+    });
+});
+
+
+test('Missing "networks" parameter', function (t) {
+    NAPI.post({ path: '/network_pools' }, {
+        name: 'my-network-pool'
+    }, function (err, res) {
+        t.ok(err, 'error returned');
+        if (!err) {
+            t.end();
+            return;
+        }
+
+        t.equal(err.statusCode, 422, 'status code');
+        t.deepEqual(err.body, h.missingParamErr({
+            errors: [ mod_err.missingParam('networks') ]
+        }), 'error body');
+
+        t.end();
+    });
+});
+
+
+
 
 // --- Update tests
 
@@ -349,6 +535,45 @@ test('Update pool', function (t) {
 });
 
 
+test('Update pool 1 to a new description', function (t) {
+    var descr = 'This is the new pool 1 description';
+    POOLS[0].description = descr;
+    mod_pool.update(t, {
+        uuid: POOLS[0].uuid,
+        params: {
+            description: descr
+        },
+        exp: POOLS[0]
+    });
+});
+
+
+test('Update pool 2 to have a description', function (t) {
+    var descr = 'This is pool 2';
+    POOLS[1].description = descr;
+    mod_pool.update(t, {
+        uuid: POOLS[1].uuid,
+        params: {
+            description: descr
+        },
+        exp: POOLS[1]
+    });
+});
+
+
+test('Update pool 3 to a new name', function (t) {
+    var name = POOLS[2].name + '-altered';
+    POOLS[2].name = name;
+    mod_pool.update(t, {
+        uuid: POOLS[2].uuid,
+        params: {
+            name: name
+        },
+        exp: POOLS[2]
+    });
+});
+
+
 test('Update pool: no networks', function (t) {
     var params = {
         networks: [ ]
@@ -371,6 +596,66 @@ test('Update pool: no networks', function (t) {
 });
 
 
+test('Update IPv4 pool - mixed address families', function (t) {
+    mod_pool.update(t, {
+        uuid: POOLS[0].uuid,
+        params: {
+            networks: [ NETS[0].uuid, NETS[1].uuid, NETS[2].uuid, NETS[6].uuid ]
+        },
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('networks',
+                constants.POOL_AF_MATCH_MSG) ]
+        })
+    });
+});
+
+
+test('Update IPv4 pool - all IPv6 networks', function (t) {
+    mod_pool.update(t, {
+        uuid: POOLS[0].uuid,
+        params: {
+            networks: [ NETS[6].uuid, NETS[7].uuid ]
+        },
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('networks',
+                constants.POOL_AF_MATCH_MSG) ]
+        })
+    });
+});
+
+
+test('Update IPv6 pool - mixed address families', function (t) {
+    mod_pool.update(t, {
+        uuid: POOLS[2].uuid,
+        params: {
+            networks: [ NETS[0].uuid, NETS[6].uuid, NETS[7].uuid ]
+        },
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('networks',
+                constants.POOL_AF_MATCH_MSG) ]
+        })
+    });
+});
+
+
+test('Update IPv6 pool - all IPv4 networks', function (t) {
+    mod_pool.update(t, {
+        uuid: POOLS[2].uuid,
+        params: {
+            networks: [ NETS[0].uuid, NETS[1].uuid ]
+        },
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('networks',
+                constants.POOL_AF_MATCH_MSG) ]
+        })
+    });
+});
+
+
 test('Update pool: remove owner_uuids', function (t) {
     t.plan(4);
 
@@ -503,17 +788,8 @@ test('provisionable_by network pools: owner', function (t) {
         mod_pool.list(t2, {
             params: {
                 provisionable_by: owners[0]
-            }
-        }, function (err, res) {
-            if (err) {
-                return t2.end();
-            }
-
-            t2.ok(res.map(function (n) {
-                    return n.uuid;
-                }).indexOf(pool.uuid) !== -1,
-                'pool in list');
-            return t2.end();
+            },
+            present: [ pool ]
         });
     });
 
@@ -546,14 +822,6 @@ test('provisionable_by network pools: owner', function (t) {
 
 // --- List tests
 
-function testPoolList(t, opts, callback) {
-    assert.object(t, 't');
-    opts.type = 'nic_tag';
-    opts.reqType = 'list';
-    NAPI.listNetworkPools(opts.params,
-        common.afterAPIcall.bind(null, t, opts, callback));
-}
-
 test('List pools', function (t) {
     NAPI.listNetworkPools(function (err, res) {
         t.ifError(err, 'error returned');
@@ -568,13 +836,101 @@ test('List pools', function (t) {
     });
 });
 
+test('List pools - filter for "ipv4" pools', function (t) {
+    mod_pool.list(t, {
+        params: {
+            family: 'ipv4'
+        },
+        deepEqual: true,
+        present: [ POOLS[0], POOLS[1], POOLS[3], POOLS[4] ]
+    });
+});
+
+test('List pools - filter for "ipv6" pools', function (t) {
+    mod_pool.list(t, {
+        params: {
+            family: 'ipv6'
+        },
+        deepEqual: true,
+        present: [ POOLS[2] ]
+    });
+});
+
+test('List pools - bad "family" filter', function (t) {
+    mod_pool.list(t, {
+        params: {
+            family: 'unix'
+        },
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('family',
+                'must be one of: "ipv4", "ipv6"') ]
+        })
+    });
+});
+
+test('List pools - name filter', function (t) {
+    mod_pool.list(t, {
+        params: {
+            name: POOLS[0].name
+        },
+        deepEqual: true,
+        present: [ POOLS[0] ]
+    });
+});
+
+test('List pools - empty name filter', function (t) {
+    mod_pool.list(t, {
+        params: {
+            name: ''
+        },
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('name', 'must not be empty') ]
+        })
+    });
+});
+
+test('List pools - single network filter', function (t) {
+    mod_pool.list(t, {
+        params: {
+            networks: NETS[4].uuid
+        },
+        deepEqual: true,
+        present: [ POOLS[1] ]
+    });
+});
+
+test('List pools - filter with two networks', function (t) {
+    mod_pool.list(t, {
+        params: {
+            networks: [ POOLS[3].networks[0] ]
+        },
+        deepEqual: true,
+        present: [ POOLS[0], POOLS[3] ]
+    });
+});
+
+test('List pools - filter with three networks', function (t) {
+    mod_pool.list(t, {
+        params: {
+            networks: POOLS[0].networks
+        },
+        expCode: 422,
+        expErr: h.invalidParamErr({
+            errors: [ mod_err.invalidParam('networks',
+                'Only one network UUID allowed') ]
+        })
+    });
+});
+
 test('List Network Pool failures', function (t) {
     t.plan(common.badLimitOffTests.length);
 
      for (var i = 0; i < common.badLimitOffTests.length; i++) {
         var blot = common.badLimitOffTests[i];
         t.test(blot.bc_name, function (t2) {
-            testPoolList(t2, {
+            mod_pool.list(t2, {
                 params: blot.bc_params,
                 expCode: blot.bc_expcode,
                 expErr: blot.bc_experr
@@ -590,7 +946,7 @@ test('List Network Pool failures', function (t) {
 
 
 
-test('Provision nic - on network pool with IP', function (t) {
+test('Provision nic - on IPv4 network pool with IPv4 address', function (t) {
     var params = {
         belongs_to_type: 'zone',
         belongs_to_uuid: mod_uuid.v4(),
@@ -687,20 +1043,28 @@ test('Provision nic - on network pool', function (t) {
 
 
 
-test('Delete network in pool', function (t) {
-    NAPI.deleteNetwork(NETS[0].uuid, function (err, res) {
-        t.ok(err, 'error returned');
-        if (!err) {
-            return t.end();
+test('Delete network in IPv4 pool', function (t) {
+    mod_net.del(t, {
+        uuid: NETS[4].uuid,
+        expCode: 422,
+        expErr: {
+            code: 'InUse',
+            message: 'Network is in use',
+            errors: [ mod_err.usedBy('network pool', POOLS[1].uuid) ]
         }
+    });
+});
 
-        t.equal(err.statusCode, 422, 'status code');
-        t.deepEqual(err.body, {
+
+test('Delete network in IPv6 pool', function (t) {
+    mod_net.del(t, {
+        uuid: NETS[6].uuid,
+        expCode: 422,
+        expErr: {
             code: 'InUse',
             message: 'Network is in use',
-            errors: [ mod_err.usedBy('network pool', POOLS[0].uuid) ]
-        }, 'error body');
-        return t.end();
+            errors: [ mod_err.usedBy('network pool', POOLS[2].uuid) ]
+        }
     });
 });
 
