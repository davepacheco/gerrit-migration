commit 0165240a5abe99333cb543c08e66c31c7af84a90 (refs/changes/87/2987/1)
Author: Julien Gilli <julien.gilli@joyent.com>
Date:   2017-11-22T18:56:17-08:00 (1 year, 11 months ago)
    
    PUBAPI-1460 nightly1-080-test-cloudapi fails in volumes-automount.test.js

diff --git a/test/common.js b/test/common.js
index 93e19fe..51192f7 100644
--- a/test/common.js
+++ b/test/common.js
@@ -168,6 +168,18 @@ function _imgapi() {
     });
 }
 
+function _joyentImgapi() {
+    return new IMGAPI({
+        url: 'https://images.joyent.com/',
+        retry: {
+            retries: 1,
+            minTimeout: 1000
+        },
+        log: LOG,
+        agent: false
+    });
+}
+
 
 function _papi() {
     return PAPI({
@@ -444,6 +456,7 @@ function setupClient(version, serverUrl, user, keyId, keyPath, parentAcc, cb) {
     client.cnapi  = _cnapi();
     client.napi   = _napi();
     client.imgapi = _imgapi();
+    client.joyentImgapi = _joyentImgapi();
     client.papi   = _papi();
     client.mahi   = _mahi();
     client.ufds   = _ufds();
diff --git a/test/volumes-automount.test.js b/test/volumes-automount.test.js
index d1f004c..e80f1f7 100644
--- a/test/volumes-automount.test.js
+++ b/test/volumes-automount.test.js
@@ -12,6 +12,7 @@ var assert = require('assert-plus');
 var child_process = require('child_process');
 var fs = require('fs');
 var test = require('tape').test;
+var util = require('util');
 var vasync = require('vasync');
 var verror = require('verror');
 
@@ -25,13 +26,12 @@ var mod_testVolumes = require('./lib/volumes');
 var machinesCommon = require('./machines/common');
 
 var CONFIG = mod_config.configure();
-var IMGAPI_SOURCE = 'https://images.joyent.com';
+var JOYENT_IMGAPI_SOURCE = 'https://images.joyent.com';
 var KEY_FILENAME = '/tmp/cloudapi-test-key';
-var TEST_IMAGE_KVM =
-    'd472f84c-69cf-431c-b848-c5dce6bee153'; // ubuntu-certified-16.04
-var TEST_IMAGE_LX = '7b5981c4-1889-11e7-b4c5-3f3bdfc9b88b'; // ubuntu-16.04
-var TEST_IMAGE_SMARTOS =
-    'ede31770-e19c-11e5-bb6e-3b7de3cca9ce'; // minimal-multiarch-lts (15.4.1)
+var TEST_IMAGE_KVM = 'ubuntu-certified-16.04';
+var TEST_IMAGE_LX = 'ubuntu-16.04';
+var TEST_IMAGE_NAMES_TO_UUID = {};
+var TEST_IMAGE_SMARTOS = 'minimal-multiarch-lts';
 var UFDS_ADMIN_UUID = CONFIG.ufds_admin_uuid;
 
 function deleteKeypair(cb) {
@@ -45,6 +45,122 @@ function deleteKeypair(cb) {
     });
 }
 
+/*
+ * Make the image with name "imageName" provisionable. If it's not imported, it
+ * imports it in the DC's IMGAPI service from images.joyent.com. If it's
+ * imported and not public, it makes the image public.
+ *
+ * @params {String} imageName (required): the name of the image to make
+ *   provisionable
+ * @params {Function} callback (required): called at the end of the process as
+ *   callback(err, provisionableImgObject)
+ *
+ * where "provisionableImgObject" represents an image with an "id" property that
+ * stores its UUID.
+ */
+function makeImageProvisionable(imageName, callback) {
+    assert.string(imageName, 'imageName');
+    assert.func(callback, 'callback');
+
+    var context = {};
+
+    vasync.pipeline({arg: context, funcs: [
+        function listImportedImages(ctx, next) {
+            CLIENT.get('/my/images?name=' + imageName,
+                function onListImportedImages(listImagesErr, req, res, images) {
+                    ctx.images = images;
+                    next(listImagesErr);
+                });
+
+        },
+        /*
+         * When images are imported into a DC's IMGAPI because they're an origin
+         * image for another image imported from updates.joyent.com, their
+         * "public" attribute is set to false, which makes them
+         * non-provisionable. In this case, we just update that public property
+         * to "true".
+         */
+        function ensureOneImportedImgIsPublic(ctx, next) {
+            var firstImage;
+            var publicImages;
+
+            assert.optionalArrayOfObject(ctx.images, 'ctx.images');
+
+            if (ctx.images && ctx.images.length > 0) {
+                publicImages = ctx.images.filter(function isPublic(image) {
+                    return image.public;
+                });
+
+                if (publicImages.length > 0) {
+                    ctx.provisionableImage = publicImages[0];
+                    next();
+                } else {
+                    firstImage = ctx.images[0];
+                    firstImage.public = true;
+                    CLIENT.imgapi.updateImage(firstImage.uuid, firstImage,
+                        CLIENT.account.uuid,
+                        function onImageUpdated(updateImgErr) {
+                            if (updateImgErr) {
+                                next(updateImgErr);
+                                return;
+                            }
+
+                            ctx.provisionableImage = firstImage;
+                            next();
+                        });
+                }
+            } else {
+                next();
+            }
+        },
+        /*
+         * If an image with name "imageName" is not imported, we import it now
+         * from images.joyent.com.
+         */
+        function importImg(ctx, next) {
+            assert.optionalArrayOfObject(ctx.images, 'ctx.images');
+            assert.optionalBool(ctx.atLeastOneImgPublic,
+                'ctx.atLeastOneImgPublic');
+
+            if (!ctx.images || ctx.images.length === 0) {
+                CLIENT.joyentImgapi.listImages({
+                    name: imageName
+                }, function onListImages(listImagesErr, images) {
+                    if (listImagesErr) {
+                        next(listImagesErr);
+                        return;
+                    }
+
+                    if (!images || images.length === 0) {
+                        next(new Error('Could not find image ' +
+                            'with name ' + imageName));
+                        return;
+                    }
+
+                    CLIENT.imgapi.adminImportRemoteImageAndWait(images[0].uuid,
+                        JOYENT_IMGAPI_SOURCE, {},
+                        function onImgImported(importImgErr, image) {
+                            if (importImgErr) {
+                                next(importImgErr);
+                                return;
+                            }
+
+                            image.id = image.uuid;
+                            delete image.uuid;
+
+                            ctx.provisionableImage = image;
+                            next();
+                        });
+                });
+            } else {
+                next();
+            }
+        }
+    ]}, function onAllDone(err) {
+        callback(err, context.provisionableImage);
+    });
+}
+
 if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
     console.log('experimental_cloudapi_nfs_shared_volumes setting not ' +
         'enabled, skipping tests');
@@ -69,22 +185,6 @@ if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
     var testVolume;
     var testVolumeStorageVmUuid;
 
-    function getMissingImages(t, missing, callback) {
-        if (missing.length === 0) {
-            callback();
-            return;
-        }
-
-        vasync.forEachParallel({
-            func: function importOneImage(imgUuid, cb) {
-                CLIENT.imgapi.adminImportRemoteImageAndWait(imgUuid,
-                    IMGAPI_SOURCE, {}, cb);
-            }, inputs: missing
-        }, function (err, results) {
-            callback(err);
-        });
-    }
-
     test('setup', function (t) {
         common.setup({clientApiVersion: '~8.0'}, function (_, clients, server) {
             CLIENTS = clients;
@@ -188,53 +288,30 @@ if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
 
     // Ensure we have required images
     test('ensure images', function (t) {
-        var foundKvm = false;
-        var foundLx = false;
-        var foundSmartOS = false;
-        var idx = 0;
-        var missing = [];
-
-        CLIENT.get('/my/images',
-            function onGetImages(getImagesErr, req, res, images) {
-                t.ifErr(getImagesErr, 'getting images should succeed');
-
-                if (!getImagesErr) {
-                    t.ok(Array.isArray(images),
-                        'images should be an array');
-                    t.ok(images.length >= 3,
-                        'should have at least three images');
-                }
+        var IMG_NAMES = [TEST_IMAGE_LX, TEST_IMAGE_KVM, TEST_IMAGE_SMARTOS];
 
-                for (idx = 0; idx < images.length; idx++) {
-                    if (images[idx].id === TEST_IMAGE_LX) {
-                        foundLx = true;
-                    }
-                    if (images[idx].id === TEST_IMAGE_SMARTOS) {
-                        foundSmartOS = true;
-                    }
-                    if (images[idx].id === TEST_IMAGE_KVM) {
-                        foundKvm = true;
+        vasync.forEachParallel({
+            func: makeImageProvisionable,
+            inputs: IMG_NAMES
+        }, function onAllImgsSetupDone(imgsSetupErr, results) {
+            var idx;
+
+            t.ifErr(imgsSetupErr, 'setting up images should not error');
+
+            if (!imgsSetupErr) {
+                t.ok(results.successes, 'result of making images provisionable should be present');
+                if (results.successes) {
+                    t.equal(results.successes.length, IMG_NAMES.length,
+                        'made ' + IMG_NAMES.length + ' images provisionable');
+                    for (idx = 0; idx < results.successes.length; ++idx) {
+                        TEST_IMAGE_NAMES_TO_UUID[results.successes[idx].name] =
+                            results.successes[idx].id;
                     }
                 }
+            }
 
-                if (!foundLx) {
-                    missing.push(TEST_IMAGE_LX);
-                }
-
-                if (!foundSmartOS) {
-                    missing.push(TEST_IMAGE_SMARTOS);
-                }
-
-                if (!foundKvm) {
-                    missing.push(TEST_IMAGE_KVM);
-                }
-
-                getMissingImages(t, missing, function (getMissingErr) {
-                    t.ifErr(getMissingErr,
-                        'should have succeeded to get missing images');
-                    t.end();
-                });
-            });
+            t.end();
+        });
     });
 
     // delete previous SSH keypair(s)
@@ -275,6 +352,7 @@ if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
      * only after the entry for the newly added user (including its default
      * fabric network used to provision volumes) is present in UFDS.
      */
+
     test('getting config from ufds', function (t) {
         mod_testConfig.waitForAccountConfigReady(CLIENT,
             function onConfigReady(configReadyErr) {
@@ -331,7 +409,7 @@ if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
 
         payload = {
             metadata: {},
-            image: TEST_IMAGE_LX,
+            image: TEST_IMAGE_NAMES_TO_UUID[TEST_IMAGE_LX],
             package: testPackage.id,
             name: 'cloudapi-volume-lx-' + libuuid.create().split('-')[0],
             firewall_enabled: false,
@@ -481,7 +559,7 @@ if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
 
         payload = {
             metadata: {},
-            image: TEST_IMAGE_SMARTOS,
+            image: TEST_IMAGE_NAMES_TO_UUID[TEST_IMAGE_SMARTOS],
             package: testPackage.id,
             name: 'cloudapi-volume-smartos-' + libuuid.create().split('-')[0],
             firewall_enabled: false,
@@ -631,7 +709,7 @@ if (CONFIG.experimental_cloudapi_nfs_shared_volumes !== true) {
 
         payload = {
             metadata: {},
-            image: TEST_IMAGE_KVM,
+            image: TEST_IMAGE_NAMES_TO_UUID[TEST_IMAGE_KVM],
             package: testPackage.id,
             name: 'cloudapi-volume-kvm-' + libuuid.create().split('-')[0],
             firewall_enabled: false,
