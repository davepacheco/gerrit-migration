commit 2dd5ad885a8333a83b4c2ab2f3af637572811bdb (refs/changes/47/3947/2)
Author: John Levon <john.levon@joyent.com>
Date:   2018-05-14T14:22:19+00:00 (1 year, 5 months ago)
    
    joyent/node-vasync#39 want race

diff --git a/CHANGES.md b/CHANGES.md
index cd72b86..c950b8d 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -2,7 +2,9 @@
 
 ## Not yet released
 
-None yet.
+## v2.3.0
+
+* #39 want race
 
 ## v2.2.0
 
diff --git a/README.md b/README.md
index b327fb8..b17a823 100644
--- a/README.md
+++ b/README.md
@@ -54,6 +54,8 @@ have several ways of getting at this state:
 * [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate
   multiple concurrent operations
 * [queue/queuev](#queuequeuev-fixed-size-worker-queue): fixed-size worker queue
+* [race](#race-invoke-n-functions-in-parallel-with-one-callback): invoke N
+   functions in parallel, invoke callback at first function to complete
 
 ### parallel: invoke N functions in parallel
 
@@ -771,3 +773,70 @@ This example outputs:
     first task ends
     second task begins
     second task ends
+
+### race: invoke N functions in parallel, with one callback
+
+Synopsis: `race(funcs, callback)`
+
+This function takes an array of input functions and runs them all.  These input
+functions are expected to be asynchronous: they get a "callback" argument and
+should invoke it as `callback(err, result)`.
+
+The callback is invoked at most once, by the first child function to call it.
+Any subsequent invocations are discarded. However, the functions themselves will
+still execute, so it's a good idea to clean them up in your callback with
+`clearTimeout()` or similar.
+
+This function returns a status object as follows:
+
+* `operations`: array corresponding to the input functions, with
+    * `func`: input function,
+    * `status`: "pending", "ok", or "fail",
+    * `err`: returned "err" value, if any, and
+    * `result`: returned "result" value, if any
+* `successes`: "result" field for each of "operations" where
+  "status" == "ok" (in no particular order)
+* `ndone`: number of input operations that have completed
+* `nerrors`: number of input operations that have failed
+
+Note that these values are updated even after the first invocation of the
+callback.
+
+For example:
+
+```js
+$ cat examples/race.js
+var mod_vasync = require('../lib/vasync');
+
+var w = mod_vasync.race([
+    function first(cb) {
+        console.log('initiating first()');
+        setTimeout(function () { cb(null, 'result1'); }, 10);
+    }, function second(cb) {
+        console.log('initiating second()');
+        setTimeout(function () { cb(null, 'result2'); }, 10);
+    }],
+
+    /*
+     * The timeout for first() will expire first, which means we'll get
+     * 'result1' here; mycb will not be called again.
+     */
+    function mycb(err, result) {
+        console.log('result: %s state: %j', result, w);
+    }
+);
+
+console.log('w (start): %j', w);
+$ node examples/race.js
+initiating first()
+initiating second()
+w (start):
+{"operations":[{"funcname":"first","status":"pending"},{"funcname":"second","status":"pending"}],"successes":[],"ndone":0,"nerrors":0}
+result: result1 state:
+{"operations":[{"funcname":"first","status":"ok","err":null,"result":"result1"},{"funcname":"second","status":"pending"}],"successes":["result1"],"ndone":1,"nerrors":0}
+```
+
+Note that "successes" is provided as a convenience and the order of items in
+that array may not correspond to the order of the inputs.  To consume output in
+an ordered manner, you should iterate over "operations" and pick out the result
+from each item.
diff --git a/examples/race.js b/examples/race.js
new file mode 100644
index 0000000..cb5786b
--- /dev/null
+++ b/examples/race.js
@@ -0,0 +1,21 @@
+var mod_vasync = require('../lib/vasync');
+
+var w = mod_vasync.race([
+    function first(cb) {
+        console.log('initiating first()');
+        setTimeout(function () { cb(null, 'result1'); }, 10);
+    }, function second(cb) {
+        console.log('initiating second()');
+        setTimeout(function () { cb(null, 'result2'); }, 10);
+    }],
+
+    /*
+     * The timeout for first() will expire first, which means we'll get
+     * 'result1' here; mycb will not be called again.
+     */
+    function mycb(err, result) {
+        console.log('result: %s state: %j', result, w);
+    }
+);
+
+console.log('w (start): %j', w);
diff --git a/lib/vasync.js b/lib/vasync.js
index 1b7b564..85b5d3a 100644
--- a/lib/vasync.js
+++ b/lib/vasync.js
@@ -23,6 +23,7 @@ exports.queue = queue;
 exports.queuev = queuev;
 exports.barrier = barrier;
 exports.waterfall = waterfall;
+exports.race = race;
 
 if (!global.setImmediate) {
 	global.setImmediate = function (func) {
@@ -762,7 +763,7 @@ function waterfall_impl(opts)
 
 	rv = {
 	    'operations': funcs.map(function (func) {
-	        return ({
+		return ({
 		    'func': func,
 		    'funcname': func.name || '(anon)',
 		    'status': 'waiting'
@@ -889,3 +890,76 @@ function waterfall_impl(opts)
 	}
 	return (rv);
 }
+
+/*
+ * Given a set of functions that complete asynchronously using the standard
+ * callback(err, result) pattern, invoke them all, but only invoke the callback
+ * for the first function to complete. The other callback invocations, if any,
+ * are ignored.  See README.md for details.
+ */
+function race(funcs, callback)
+{
+	var rv, doneOne, i;
+
+	mod_assert.ok(Array.isArray(funcs),
+	    '"funcs" must be specified and must be an array');
+	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function',
+	    '"callback" must be a function');
+
+	rv = {
+	    'operations': new Array(funcs.length),
+	    'successes': [],
+	    'ndone': 0,
+	    'nerrors': 0
+	};
+
+	if (funcs.length === 0) {
+		if (callback)
+			setImmediate(function () { callback(null, rv); });
+		return (rv);
+	}
+
+	function once(fn) {
+		var f = function () {
+			if (f.called)
+				return;
+			f.called = true;
+			fn.apply(this, arguments);
+		};
+		f.called = false;
+		return (f);
+	}
+
+	callback = once(callback);
+
+	doneOne = function (entry) {
+		return (function (err, result) {
+			mod_assert.equal(entry['status'], 'pending');
+
+			entry['err'] = err;
+			entry['result'] = result;
+			entry['status'] = err ? 'fail' : 'ok';
+
+			if (err)
+				rv['nerrors']++;
+			else
+				rv['successes'].push(result);
+
+			rv['ndone']++;
+
+			callback.apply(null, arguments);
+		});
+	};
+
+	for (i = 0; i < funcs.length; i++) {
+		rv['operations'][i] = {
+			'func': funcs[i],
+			'funcname': funcs[i].name || '(anon)',
+			'status': 'pending'
+		};
+
+		funcs[i](doneOne(rv['operations'][i]));
+	}
+
+	return (rv);
+}
diff --git a/package.json b/package.json
index 60f6eee..6dd977c 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
 	"name": "vasync",
-	"version": "2.2.0",
+	"version": "2.3.0",
 	"description": "utilities for observable asynchronous control flow",
 	"main": "./lib/vasync.js",
 	"repository": {
diff --git a/tests/compat.js b/tests/compat.js
index 8461a82..ad7ace9 100644
--- a/tests/compat.js
+++ b/tests/compat.js
@@ -102,3 +102,5 @@ exports['waterfall error'] = function(test){
     });
     setTimeout(test.done, 50);
 };
+
+// FIXME
diff --git a/tests/race.js b/tests/race.js
new file mode 100644
index 0000000..eb1f9f9
--- /dev/null
+++ b/tests/race.js
@@ -0,0 +1,175 @@
+/*
+ * Tests the "waterfall" primitive.
+ */
+
+var mod_tap = require('tap');
+var mod_vasync = require('..');
+
+var count = 0;
+var st;
+
+mod_tap.test('badargs', function (test) {
+	test.throws(function () { mod_vasync.race(); });
+	test.throws(function () { mod_vasync.race({}); });
+	test.throws(function () { mod_vasync.race([], 'foo'); });
+	test.throws(function () { mod_vasync.race('foo', 'bar'); });
+	test.end();
+});
+
+mod_tap.test('empty race, no callback', function (test) {
+	st = mod_vasync.race([]);
+	setTimeout(function () { test.end(); }, 100);
+});
+
+mod_tap.test('empty race', function (test) {
+	st = mod_vasync.race([], function (err) {
+		test.ok(err === null);
+		test.ok(st.ndone === 0);
+		test.ok(st.nerrors === 0);
+		test.ok(st.operations.length === 0);
+		test.ok(st.successes.length === 0);
+		test.equal(count, 1);
+		test.end();
+	});
+	count++;
+	test.ok(st.ndone === 0);
+	test.ok(st.nerrors === 0);
+	test.ok(st.operations.length === 0);
+	test.ok(st.successes.length === 0);
+});
+
+mod_tap.test('single func race', function (test) {
+	count = 0;
+
+	st = mod_vasync.race([
+		function func1(cb) {
+			count++;
+			setTimeout(cb, 10, null, 1, 2);
+		}
+	], function callback(err, one, two) {
+		test.ok(count == 1, 'callback: count == 1');
+		test.ok(err === null, 'no error');
+		test.ok(one === 1);
+		test.ok(two === 2);
+		test.ok(st.ndone === 1);
+		test.ok(st.nerrors === 0);
+		test.ok(st.operations.length === 1);
+		test.ok(st.successes.length === 1);
+		test.ok(st.operations[0].status == 'ok');
+		setTimeout(function () { test.end(); }, 10);
+	});
+});
+
+mod_tap.test('single func error', function (test) {
+	count = 0;
+
+	st = mod_vasync.race([
+		function func1(cb) {
+			count++;
+			setTimeout(cb, 10, 'failed');
+		}
+	], function callback(err, res) {
+		test.ok(count == 1, 'callback: count == 1');
+		test.ok(err !== null, 'error seen');
+		test.ok(res === undefined, 'undefined result');
+		test.ok(st.ndone === 1);
+		test.ok(st.nerrors === 1);
+		test.ok(st.operations.length === 1);
+		test.ok(st.successes.length === 0);
+		test.ok(st.operations[0].status == 'fail');
+		setTimeout(function () { test.end(); }, 10);
+	});
+});
+
+mod_tap.test('race with error', function (test) {
+	var called = 0;
+	count = 0;
+
+	st = mod_vasync.race([
+		function func1(cb) {
+			count++;
+			setTimeout(cb, 10, 'failed');
+		},
+		function func2(cb) {
+			count++;
+			setTimeout(cb, 100, null, 1, 2);
+		}
+	], function callback(err, res) {
+		test.ok(count == 2, 'callback: count == 2');
+		test.ok(called === 0, 'callback: called == 0');
+		test.ok(err !== null, 'error seen');
+		test.ok(res === undefined, 'undefined result');
+		test.ok(st.ndone === 1);
+		test.ok(st.nerrors === 1);
+		test.ok(st.operations.length === 2);
+		test.ok(st.successes.length === 0);
+		test.ok(st.operations[0].status == 'fail');
+		test.ok(st.operations[1].status == 'pending');
+		called++;
+		setTimeout(function () { test.end(); }, 110);
+	});
+});
+
+mod_tap.test('normal race', function (test) {
+	var called = 0;
+	count = 0;
+
+	st = mod_vasync.race([
+		function func1(cb) {
+			count++;
+			setTimeout(cb, 100, null, 1, 2);
+		},
+		function func2(cb) {
+			count++;
+			setTimeout(cb, 10, null, 3, 4);
+		}
+	], function callback(err, three, four) {
+		test.ok(count == 2, 'callback: count == 2');
+		test.ok(called === 0, 'callback: called == 0');
+		test.ok(err === null, 'no error');
+		test.ok(three === 3);
+		test.ok(four === 4);
+		test.ok(st.ndone === 1);
+		test.ok(st.nerrors === 0);
+		test.ok(st.operations.length === 2);
+		test.ok(st.successes.length === 1);
+		test.ok(st.operations[0].status == 'pending');
+		test.ok(st.operations[1].status == 'ok');
+		called++;
+		setTimeout(function () { test.end(); }, 110);
+	});
+});
+
+mod_tap.test('normal race, 3 funcs', function (test) {
+	var called = 0;
+	count = 0;
+
+	st = mod_vasync.race([
+		function func1(cb) {
+			count++;
+			setTimeout(cb, 10, null, 1, 2);
+		},
+		function func2(cb) {
+			count++;
+			setTimeout(cb, 100, null, 3, 4);
+		},
+		function func3(cb) {
+			count++;
+			setTimeout(cb, 101, null, 5);
+		}
+	], function callback(err, one, two) {
+		test.ok(count == 3, 'callback: count == 3');
+		test.ok(called === 0, 'callback: called == 0');
+		test.ok(err === null, 'no error');
+		test.ok(one === 1);
+		test.ok(two === 2);
+		test.ok(st.ndone === 1);
+		test.ok(st.nerrors === 0);
+		test.ok(st.operations.length === 3);
+		test.ok(st.successes.length === 1);
+		test.ok(st.operations[0].status == 'ok');
+		test.ok(st.operations[1].status == 'pending');
+		called++;
+		setTimeout(function () { test.end(); }, 110);
+	});
+});
