commit ec1009372063bc769580b7ce76185f04ab6a90d0 (refs/changes/26/3026/1)
Author: Jerry Jelinek <jerry.jelinek@joyent.com>
Date:   2017-12-01T18:08:51+00:00 (1 year, 10 months ago)
    
    OS-6475 lx - not reporting mount options in /proc/mounts

diff --git a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
index ec0b003b3e..f770ab2447 100644
--- a/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
+++ b/usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
@@ -2017,6 +2017,8 @@ typedef struct lxpr_mount_entry {
 	uint_t		lme_parent_id;
 	refstr_t	*lme_mntpt;
 	refstr_t	*lme_resource;
+	uint_t		lme_mntopts_len;
+	char		*lme_mntopts;
 	uint_t		lme_flag;
 	int		lme_fstype;
 	dev_t		lme_dev;
@@ -2027,6 +2029,95 @@ static int lxpr_zfs_fstype = -1;
 
 #define	LXPR_ROOT_MOUNT_ID	15
 
+/*
+ * Ensure the mount option string is large enough, expanding if necessary.
+ */
+static void
+lxpr_mntbuf_len_chk(lxpr_mount_entry_t *lme, uint_t len, uint_t addlen)
+{
+	if (len + addlen >= lme->lme_mntopts_len) {
+		/* expand option string */
+		uint_t tlen = lme->lme_mntopts_len + addlen + 128;
+		char *t = kmem_alloc(tlen, KM_SLEEP);
+
+		(void) strlcpy(t, lme->lme_mntopts, tlen);
+		kmem_free(lme->lme_mntopts, lme->lme_mntopts_len);
+		lme->lme_mntopts_len = tlen;
+		lme->lme_mntopts = t;
+	}
+}
+
+/*
+ * Perform the somewhat complicated work of getting the mount options string
+ * for the mount.
+ */
+static void
+lxpr_get_mntopts(vfs_t *vfsp, lxpr_mount_entry_t *lme)
+{
+	uint_t i, len, olen;
+	mntopt_t *mop;
+	boolean_t have_nosuid = B_FALSE, have_nodev = B_FALSE;
+
+	lme->lme_mntopts_len = 128;
+	lme->lme_mntopts = kmem_alloc(lme->lme_mntopts_len, KM_SLEEP);
+	lme->lme_mntopts[0] = '\0';
+
+	/* Always show rw/ro option */
+	(void) strlcpy(lme->lme_mntopts,
+	    (lme->lme_flag & VFS_RDONLY) == 0 ? "rw" : "ro",
+	    lme->lme_mntopts_len);
+	len = 3;	/* account for null terminator */
+
+	for (i = 0; i < vfsp->vfs_mntopts.mo_count; i++) {
+		mop = &vfsp->vfs_mntopts.mo_list[i];
+		if ((mop->mo_flags & MO_NODISPLAY) || !(mop->mo_flags & MO_SET))
+			continue;
+
+		if (strcmp(mop->mo_name, "ro") == 0 ||
+		    strcmp(mop->mo_name, "rw") == 0)
+			continue;
+
+		if (strcmp(mop->mo_name, "nosuid") == 0)
+			have_nosuid = B_TRUE;
+		/* sigh, either option string is used */
+		if (strcmp(mop->mo_name, "nodev") == 0 ||
+		    strcmp(mop->mo_name, "nodevices") == 0)
+			have_nodev = B_TRUE;
+
+		olen = strlen(mop->mo_name) + 1;	/* +1 for comma */
+		if (mop->mo_arg != NULL)
+			olen += strlen(mop->mo_arg) + 1; /* +1 for = */
+
+		lxpr_mntbuf_len_chk(lme, len, olen);
+
+		(void) strlcat(lme->lme_mntopts, ",", lme->lme_mntopts_len);
+		(void) strlcat(lme->lme_mntopts, mop->mo_name,
+		    lme->lme_mntopts_len);
+		if (mop->mo_arg != NULL) {
+			(void) strlcat(lme->lme_mntopts, "=",
+			    lme->lme_mntopts_len);
+			(void) strlcat(lme->lme_mntopts, mop->mo_arg,
+			    lme->lme_mntopts_len);
+		}
+		len += olen;
+	}
+
+	/*
+	 * Sometimes nosuid is an explicit string, other times it's a flag.
+	 * The same is true for nodevices.
+	 */
+	if (!have_nosuid && (lme->lme_flag & VFS_NOSETUID)) {
+		lxpr_mntbuf_len_chk(lme, len, 7);
+		(void) strlcat(lme->lme_mntopts, ",nosuid",
+		    lme->lme_mntopts_len);
+	}
+	if (!have_nodev && (lme->lme_flag & VFS_NODEVICES)) {
+		lxpr_mntbuf_len_chk(lme, len, 10);
+		(void) strlcat(lme->lme_mntopts, ",nodevices",
+		    lme->lme_mntopts_len);
+	}
+}
+
 static list_t *
 lxpr_enumerate_mounts(zone_t *zone)
 {
@@ -2071,6 +2162,7 @@ lxpr_enumerate_mounts(zone_t *zone)
 	lme->lme_flag = rvfsp->vfs_flag;
 	lme->lme_fstype = rvfsp->vfs_fstype;
 	lme->lme_force = B_TRUE;
+	lxpr_get_mntopts(rvfsp, lme);
 
 	lme->lme_resource = NULL;
 	vd = list_head(lxzd->lxzd_vdisks);
@@ -2109,6 +2201,7 @@ lxpr_enumerate_mounts(zone_t *zone)
 		lme->lme_flag = vfsp->vfs_flag;
 		lme->lme_fstype = vfsp->vfs_fstype;
 		lme->lme_force = B_FALSE;
+		lxpr_get_mntopts(vfsp, lme);
 
 		lme->lme_resource = NULL;
 		vd = list_head(lxzd->lxzd_vdisks);
@@ -2147,6 +2240,10 @@ lxpr_enumerate_mounts(zone_t *zone)
 	    "%snative/usr", zone->zone_rootpath);
 	lme->lme_mntpt = refstr_alloc(tmppath);
 	lme->lme_resource = lme->lme_mntpt;
+	lme->lme_mntopts = NULL;
+	lme->lme_mntopts_len = 3;
+	lme->lme_mntopts = kmem_alloc(lme->lme_mntopts_len, KM_SLEEP);
+	(void) strlcpy(lme->lme_mntopts, "ro", lme->lme_mntopts_len);
 	refstr_hold(lme->lme_mntpt);
 	if (lxpr_zfs_fstype == -1) {
 		vfssw_t *zfssw = vfs_getvfssw("zfs");
@@ -2228,11 +2325,12 @@ lxpr_read_pid_mountinfo(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
 		    "%d %d %d:%d / %s %s - %s %s %s\n",
 		    lme->lme_id, lme->lme_parent_id,
 		    getmajor(lme->lme_dev), getminor(lme->lme_dev),
-		    mntpt, rwflag, fstype, resource, rwflag);
+		    mntpt, rwflag, fstype, resource, lme->lme_mntopts);
 
 nextp:
 		refstr_rele(lme->lme_mntpt);
 		refstr_rele(lme->lme_resource);
+		kmem_free(lme->lme_mntopts, lme->lme_mntopts_len);
 		kmem_free(lme, sizeof (lxpr_mount_entry_t));
 		lme = (lxpr_mount_entry_t *)list_remove_head(mounts);
 	}
@@ -3960,7 +4058,7 @@ lxpr_read_mounts(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
 	 */
 	lme = list_remove_head(mounts);
 	while (lme != NULL) {
-		char *resource, *mntpt, *fstype, *rwflag;
+		char *resource, *mntpt, *fstype;
 		vnode_t *vp;
 		int error;
 
@@ -3995,14 +4093,14 @@ lxpr_read_mounts(lxpr_node_t *lxpnp, lxpr_uiobuf_t *uiobuf)
 		    !lme->lme_force) {
 			goto nextp;
 		}
-		rwflag = ((lme->lme_flag & VFS_RDONLY) == 0) ? "rw" : "ro";
 
 		lxpr_uiobuf_printf(uiobuf, "%s %s %s %s 0 0\n",
-		    resource, mntpt, fstype, rwflag);
+		    resource, mntpt, fstype, lme->lme_mntopts);
 
 nextp:
 		refstr_rele(lme->lme_mntpt);
 		refstr_rele(lme->lme_resource);
+		kmem_free(lme->lme_mntopts, lme->lme_mntopts_len);
 		kmem_free(lme, sizeof (lxpr_mount_entry_t));
 		lme = list_remove_head(mounts);
 	}
