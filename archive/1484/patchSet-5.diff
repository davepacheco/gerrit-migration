commit 3d08349489520d96f4a65da4209e3abab0b4e411 (refs/changes/84/1484/5)
Author: Dave Eddy <dave@daveeddy.com>
Date:   2017-02-24T12:40:53-05:00 (2 years, 7 months ago)
    
    OS-5951 sysevent(1M) should emit "ready" event when it has started

diff --git a/man/src/sysevent.1m.md b/man/src/sysevent.1m.md
index 0e60fdc3..52e53d87 100644
--- a/man/src/sysevent.1m.md
+++ b/man/src/sysevent.1m.md
@@ -30,6 +30,9 @@ JSON to stdout instead for easy machine parsing.
 **-j**
     JSON output.
 
+**-r**
+    Print 'ready' event at start.
+
 ## EXAMPLES
 
 `sysevent`
diff --git a/src/sysevent.c b/src/sysevent.c
index efffed27..95c458e1 100644
--- a/src/sysevent.c
+++ b/src/sysevent.c
@@ -1,17 +1,114 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright 2017 Joyent, Inc.
+ *
+ */
+
 #include <err.h>
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <synch.h>
+#include <thread.h>
 #include <time.h>
 #include <unistd.h>
 
 #include <libsysevent.h>
 #include <libnvpair.h>
 
+/* CLI arguments */
 struct {
 	boolean_t opt_j; /* -j, json output */
+	boolean_t opt_r; /* -r, print ready event */
 } opts;
 
+static mutex_t stdout_mutex;
+
+/*
+ * Like VERIFY0, but instead of calling abort(), will print an error message
+ * to stderr and exit the program.
+ */
+#define ENSURE0(arg) {	\
+    if (arg != 0)	\
+        err(1, #arg);	\
+}
+
+/*
+ * Create an nvlist with "type" set to the type argument given,
+ * and "date" set to the current time.  Must be free()d by
+ * the caller
+ */
+nvlist_t *
+make_nvlist(char *type)
+{
+	nvlist_t *nvl;
+	struct timeval tv;
+	struct tm *gmt;
+	char date[128];
+	size_t i;
+
+	ENSURE0(nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0));
+
+	// get the current time
+	if (gettimeofday(&tv, NULL) != 0)
+		err(1, "gettimeofday");
+
+	if ((gmt = gmtime(&tv.tv_sec)) == NULL)
+		err(1, "gmtime");
+
+	i = strftime(date, sizeof (date), "%Y-%m-%dT%H:%M:%S", gmt);
+	if (i == 0)
+		err(1, "strftime");
+
+	// append milliseconds
+	i = snprintf(date + i, sizeof (date) - i, ".%03ldZ", tv.tv_usec / 1000);
+	if (i == 0)
+		err(1, "snprintf date");
+
+	ENSURE0(nvlist_add_string(nvl, "date", date));
+	ENSURE0(nvlist_add_string(nvl, "type", type));
+
+	return (nvl);
+}
+
+/*
+ * Print an nvlist to stdout (with respect to the -j argument)
+ * as well as a trailing newline followed by a call to fflush.
+ *
+ * Must be called while holding the stdout mutex
+ */
+void
+print_nvlist(nvlist_t *nvl)
+{
+	if (opts.opt_j)
+		nvlist_print_json(stdout, nvl);
+	else
+		nvlist_print(stdout, nvl);
+
+	printf("\n");
+	fflush(stdout);
+}
+
 /*
  * Called by sysevent handlers for each event. This will handle emitting the
  * event to stdout, either in human-readable form or JSON based on the
@@ -24,50 +121,20 @@ struct {
 static void
 process_event(sysevent_t *ev, const char *channel)
 {
-	struct timeval tv;
-	struct tm *gmt;
+	nvlist_t *nvl;
 	nvlist_t *evnvl = NULL;
-	nvlist_t *nvl = NULL;
 	char *vendor = NULL;
 	char *publisher = NULL;
 	char *class = NULL;
 	char *subclass = NULL;
-	char date[128];
 	pid_t pid;
-	size_t i;
 
 	/* create an nvlist to hold everything */
-	if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0) {
-		warn("nvlist_alloc");
-		goto done;
-	}
+	nvl = make_nvlist("event");
 
 	/* get the nvlist from the sysevent */
-	if (sysevent_get_attr_list(ev, &evnvl) != 0) {
-		warn("sysevent_get_attr_list");
-		goto done;
-	}
-
-	/* get the current time */
-	if (gettimeofday(&tv, NULL) != 0) {
-		warn("gettimeofday");
-		goto done;
-	}
-	if ((gmt = gmtime(&tv.tv_sec)) == NULL) {
-		warn("gmtime");
-		goto done;
-	}
-	i = strftime(date, sizeof (date), "%Y-%m-%dT%H:%M:%S", gmt);
-	if (i == 0) {
-		warn("strftime");
-		goto done;
-	}
-	/* append milliseconds */
-	i = snprintf(date + i, sizeof (date) - i, ".%03ldZ", tv.tv_usec / 1000);
-	if (i == 0) {
-		warn("snprintf date");
-		goto done;
-	}
+	if (sysevent_get_attr_list(ev, &evnvl) != 0)
+		err(1, "sysevent_get_attr_list");
 
 	/* get sysevent metadata and add to the nvlist */
 	vendor = sysevent_get_vendor_name(ev);
@@ -77,46 +144,25 @@ process_event(sysevent_t *ev, const char *channel)
 	sysevent_get_pid(ev, &pid);
 
 	if (vendor == NULL || publisher == NULL || class == NULL ||
-	    subclass == NULL) {
-		warn("failed to retrieve sysevent metadata");
-		goto done;
-	}
+	    subclass == NULL)
+		err(1, "failed to retrieve sysevent metadata");
 
-	if (nvlist_add_string(nvl, "date", date) != 0 ||
-	    nvlist_add_string(nvl, "vendor", vendor) != 0 ||
-	    nvlist_add_string(nvl, "publisher", publisher) != 0 ||
-	    nvlist_add_string(nvl, "class", class) != 0 ||
-	    nvlist_add_string(nvl, "subclass", subclass) != 0 ||
-	    nvlist_add_int32(nvl, "pid", pid) != 0) {
-		warn("nvlist_add_* nvl");
-		goto done;
-	}
+	ENSURE0(nvlist_add_string(nvl, "vendor", vendor));
+	ENSURE0(nvlist_add_string(nvl, "publisher", publisher));
+	ENSURE0(nvlist_add_string(nvl, "class", class));
+	ENSURE0(nvlist_add_string(nvl, "subclass", subclass));
+	ENSURE0(nvlist_add_int32(nvl, "pid", pid));
 
-	if (evnvl != NULL &&
-	    nvlist_add_nvlist(nvl, "data", evnvl) != 0) {
-		warn("nvlist_add_nvlist evnvl");
-		goto done;
-	}
-
-	if (channel != NULL &&
-	    nvlist_add_string(nvl, "channel", channel) != 0) {
-		warn("nvlist_add_string channel");
-		goto done;
-	}
+	if (evnvl != NULL)
+	    ENSURE0(nvlist_add_nvlist(nvl, "data", evnvl));
 
-	/* print to stdout */
-	if (opts.opt_j) {
-		/* json output */
-		nvlist_print_json(stdout, nvl);
-	} else {
-		/* default  output */
-		nvlist_print(stdout, nvl);
-	}
-	printf("\n");
+	if (channel != NULL)
+	    ENSURE0(nvlist_add_string(nvl, "channel", channel));
 
-	fflush(stdout);
+	mutex_lock(&stdout_mutex);
+	print_nvlist(nvl);
+	mutex_unlock(&stdout_mutex);
 
-done:
 	free(vendor);
 	free(publisher);
 	nvlist_free(evnvl);
@@ -210,6 +256,7 @@ usage(FILE *s)
 	fprintf(s, "  -c <channel>   bind to the event channel\n");
 	fprintf(s, "  -h             print this message and exit\n");
 	fprintf(s, "  -j             JSON output\n");
+	fprintf(s, "  -r             print 'ready' event at start\n");
 }
 
 int
@@ -220,12 +267,13 @@ main(int argc, char **argv)
 	char *class;
 	const char **subclasses;
 	int num_subclasses;
+	nvlist_t *ready_nvl;
 
 	const char *all_subclasses[1];
 	all_subclasses[0] = EC_SUB_ALL;
 
 	opts.opt_j = B_FALSE;
-	while ((opt = getopt(argc, argv, "c:hj")) != -1) {
+	while ((opt = getopt(argc, argv, "c:hjr")) != -1) {
 		switch (opt) {
 		case 'c':
 			channel = optarg;
@@ -236,6 +284,9 @@ main(int argc, char **argv)
 		case 'j':
 			opts.opt_j = B_TRUE;
 			break;
+		case 'r':
+			opts.opt_r = B_TRUE;
+			break;
 		default:
 			usage(stderr);
 			return (1);
@@ -262,12 +313,30 @@ main(int argc, char **argv)
 		num_subclasses = 1;
 	}
 
+	// If the caller wants a "ready" event to be emitted, we must grab the
+	// stdout mutex before registering for any sysevents.  This ensures the
+	// "ready" event is printed before any other event is printed, but
+	// after we are successfully subscribed to the event channel.
+	if (opts.opt_r) {
+		mutex_lock(&stdout_mutex);
+	}
+
 	/* bind and subscribe */
 	if (channel != NULL)
 		sysevc_register(channel, class);
 	else
 		sysev_register(class, subclasses, num_subclasses);
 
+	/* ready event */
+	if (opts.opt_r) {
+		ready_nvl = make_nvlist("ready");
+
+		print_nvlist(ready_nvl);
+		mutex_unlock(&stdout_mutex);
+
+		nvlist_free(ready_nvl);
+	}
+
 	/* halt until events */
 	for (;;)
 		pause();
diff --git a/src/vm/node_modules/sysevent-stream.js b/src/vm/node_modules/sysevent-stream.js
index 2982ca83..98a0e0f0 100644
--- a/src/vm/node_modules/sysevent-stream.js
+++ b/src/vm/node_modules/sysevent-stream.js
@@ -145,7 +145,7 @@ function SyseventStream(opts) {
     }
 
     // construct arguments to give to sysevent(1M)
-    var args = ['-j'];
+    var args = ['-rj'];
     if (self.ses_channel)
         args.push('-c', self.ses_channel);
     if (self.ses_class) {
@@ -207,20 +207,29 @@ util.inherits(SyseventStream, stream.Transform);
  * the transform method to process sysevent(1M) stdout line-by-line
  */
 SyseventStream.prototype._transform = function _transform(chunk, encoding, cb) {
+    var self = this;
+
     var line = chunk.toString('utf8');
     var ev;
     try {
         ev = JSON.parse(line);
+        ev.date = new Date(ev.date);
     } catch (e) {
         // any JSON parse failure is a fatal error
-        this.ses_logger.error({err: e, line: line},
+        self.ses_logger.error({err: e, line: line},
             'failed to parse output line');
-        this._abort();
+        self._abort();
         return;
     }
 
-    ev.date = new Date(ev.date);
-    this.push(ev);
+    switch (ev.type) {
+    case 'ready':
+        self.emit('ready');
+        break;
+    default:
+        self.push(ev);
+        break;
+    }
     cb();
 };
 
@@ -253,6 +262,9 @@ SyseventStream.prototype._abort = function _abort() {
 if (require.main === module) {
     var logger = require('./bunyan').createLogger({name: 'sysevent'});
     var se = new SyseventStream({logger: logger});
+    se.on('ready', function () {
+        console.log('ready');
+    });
     se.on('readable', function () {
         var ev;
         while ((ev = se.read()) !== null) {
diff --git a/src/vm/tests/test-docker.js b/src/vm/tests/test-docker.js
index 3aab4de4..db5cb095 100644
--- a/src/vm/tests/test-docker.js
+++ b/src/vm/tests/test-docker.js
@@ -1310,7 +1310,9 @@ test('test restart delay reset', function (t) {
                     emitter.emit('done');
                 }
             });
-            cb();
+            se.on('ready', function () {
+                cb();
+            });
         }, function (cb) {
             // start the VM
             VM.start(state.uuid, {}, function (err) {
