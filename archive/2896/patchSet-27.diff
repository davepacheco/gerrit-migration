From 429e0a7153933efd646a7149d4a8c44bd4c7ffd8 Mon Sep 17 00:00:00 2001
From: Pedro Palazon Candel <pedro@joyent.com>
Date: Thu, 21 Jun 2018 13:24:34 +0200
Subject: [PATCH] SAPI-294 SAPI first boot (in non-proto mode) depends on SAPI

---
 Makefile                             |   2 +-
 boot/setup.sh                        | 238 ++++++++++++------
 lib/config.js                        | 353 +++++++++++++++++++++++++++
 lib/server/endpoints/applications.js |   5 +-
 lib/server/endpoints/common.js       |  36 +++
 lib/server/endpoints/instances.js    |  20 +-
 lib/server/endpoints/manifests.js    |  28 ++-
 lib/server/endpoints/services.js     |  10 +-
 lib/server/sapi.js                   |   2 +-
 package.json                         |   4 -
 sapi_manifests/sapi/manifest.json    |   2 +-
 sapi_manifests/sapi/template         |  28 ---
 server.js                            |  46 ++--
 13 files changed, 620 insertions(+), 154 deletions(-)
 create mode 100644 lib/config.js
 create mode 100644 lib/server/endpoints/common.js

diff --git a/Makefile b/Makefile
index 8aaad6d..a5d5b98 100644
--- a/Makefile
+++ b/Makefile
@@ -80,12 +80,12 @@ service: all $(SMF_MANIFESTS)
 	@rm -rf $(SVC_PKGDIR)
 	@mkdir -p $(SVC_PKGDIR)/site
 	@mkdir -p $(SVC_INSTDIR)/build
-	@mkdir -p $(SVC_INSTDIR)/lib
 	@mkdir -p $(SVC_INSTDIR)/smf/manifests
 	@mkdir -p $(SVC_INSTDIR)/test
 	@mkdir -p $(SVC_INSTDIR)/tools
 	@touch $(SVC_PKGDIR)/site/.do-not-delete-me
 	cp -r $(TOP)/server.js \
+		$(TOP)/lib \
 		$(TOP)/node_modules \
 		$(TOP)/package.json \
 		$(SVC_INSTDIR)/
diff --git a/boot/setup.sh b/boot/setup.sh
index 63a0965..4cb4c59 100755
--- a/boot/setup.sh
+++ b/boot/setup.sh
@@ -13,6 +13,34 @@
 export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
 set -o xtrace
 
+# Include common utility functions, we run "sdc_common_" functions below.
+source /opt/smartdc/boot/lib/util.sh
+
+
+# ---- support functions
+
+# Get a SAPI url with a few retries.
+function sapi_get
+{
+    local url=$1
+    local retry=3
+    local curlOpts="-sS -H 'Accept:application/json' -H 'Accept-Version:~1'"
+
+    while (( retry-- > 0 )); do
+        if ! curl $curlOpts "$url"; then
+            echo "could not get $url: retrying ..." >&2
+            sleep 3
+            continue
+        fi
+        break
+    done
+
+    return 0
+}
+
+
+# ---- mainline
+
 SAPI_ROOT=/sapi
 ZONE_UUID=$(zonename)
 ZONE_DATASET=zones/$ZONE_UUID/data
@@ -24,15 +52,10 @@ mkdir -p /var/smartdc/sapi
 
 # Add build/node/bin and node_modules/.bin to PATH
 echo "" >>/root/.profile
+#XXX I don't love having node_modules/.bin in the PATH. Why was it added?
 echo "export PATH=\$PATH:/opt/smartdc/sapi/build/node/bin:/opt/smartdc/sapi/node_modules/.bin" >>/root/.profile
 
 
-# Include common utility functions (then run the boilerplate).
-source /opt/smartdc/boot/lib/util.sh
-CONFIG_AGENT_LOCAL_MANIFESTS_DIRS=/opt/smartdc/sapi
-SAPI_PROTO_MODE=$(mdata-get SAPI_PROTO_MODE || true)
-sdc_common_setup
-
 # If there's a zfs dataset, make the mount point /sapi
 zfs list $ZONE_DATASET && rc=$? || rc=$?
 if [[ $rc == 0 ]]; then
@@ -45,78 +68,104 @@ if [[ $rc == 0 ]]; then
     fi
 fi
 
-if [[ "${SAPI_PROTO_MODE}" == "true" ]]; then
-    # During setup/bootstrapping, we do not expect binder to be available, and
-    # rely on the pre-allocated IPs. We grab all the config from the
-    # usbkey_config key in metadata which is assumed to have a copy of
-    # /usbkey/config for us.
+# Add metadata for cmon-agent discovery
+mdata-put metricPorts 8881
+
+
+#
+# The SAPI SMF service requires 'dns_domain' to configure itself. The intent
+# is that `mdata-get sdc:dns_domain` is set (which TRITON-92 will provide).
+# However it accepts `mdata-get dns_domain` as a fallback.
+#
+# Here is where we ensure that one of those exists for all known cases of
+# old and new sdcadm, old and new SAPI images, proto and full mode.
+#
+DNS_DOMAIN=
+
+_VM_DNS_DOMAIN=$(mdata-get sdc:dns_domain)
+_METADATA_DNS_DOMAIN=$(mdata-get dns_domain)
 
-    /usr/sbin/mdata-get usbkey_config > /var/tmp/usbkey.config
-    if [[ $? -ne 0 ]]; then
-        echo "error: Unable to find usbkey/config in SAPI zone." >&2
-        exit 1
+if [[ -n "$_VM_DNS_DOMAIN" && "$_VM_DNS_DOMAIN" != "local" ]]; then
+    echo "dns_domain: using value set on VM: $_VM_DNS_DOMAIN"
+    DNS_DOMAIN=$_VM_DNS_DOMAIN
+
+    # Remove the dns_domain in metadata to avoid potential confusion.
+    if mdata-get dns_domain 2>/dev/null >/dev/null; then
+        echo "dns_domain: remove value set on metadata"
+        mdata-delete dns_domain
     fi
+fi
 
-    eval $(
-    . /var/tmp/usbkey.config
-    cat <<EOF
-DATACENTER_NAME=${datacenter_name}
-IMGAPI_ADMIN_IPS=${imgapi_admin_ips}
-MORAY_ADMIN_IPS=${moray_admin_ips}
-NAPI_ADMIN_IPS=${napi_admin_ips}
-VMAPI_ADMIN_IPS=${vmapi_admin_ips}
-CNAPI_ADMIN_IPS=${cnapi_admin_ips}
-SAPI_ADMIN_IP=${sapi_admin_ips}
-EOF
-    )
-
-    IMGAPI_URL=http://$(echo "${IMGAPI_ADMIN_IPS}" | cut -d',' -f1)
-    MORAY_HOST=$(echo "${MORAY_ADMIN_IPS}" | cut -d ',' -f1)
-    NAPI_URL=http://$(echo "${NAPI_ADMIN_IPS}" | cut -d',' -f1)
-    CNAPI_URL=http://$(echo "${CNAPI_ADMIN_IPS}" | cut -d',' -f1)
-    VMAPI_URL=http://$(echo "${VMAPI_ADMIN_IPS}" | cut -d',' -f1)
-    SERVER_UUID=$(mdata-get sdc:server_uuid)
-
-    # This config file is used during setup to bootstrap SAPI. With the
-    # exception that it requires IP addresses instead of DNS names (as binder is
-    # not expected to be setup yet), it should be kept broadly in sync with the
-    # template at:
-    #   sapi.git/sapi_manifests/sapi/template
-    mkdir -p /opt/smartdc/sapi/etc
-    cat > /opt/smartdc/sapi/etc/config.json <<HERE
-{
-  "log_options": {
-    "name": "sapi",
-    "level": "debug"
-  },
-  "datacenter_name": "$DATACENTER_NAME",
-  "serviceName": "sapi",
-  "instanceUuid": "$ZONE_UUID",
-  "serverUuid": "$SERVER_UUID",
-  "adminIp": "$SAPI_ADMIN_IP",
-  "moray": {
-    "host": "$MORAY_HOST",
-    "port": 2020
-  },
-  "cnapi": {
-    "url": "$CNAPI_URL"
-  },
-  "vmapi": {
-    "url": "$VMAPI_URL"
-  },
-  "napi": {
-    "url": "$NAPI_URL"
-  },
-  "imgapi": {
-    "url": "$IMGAPI_URL"
-  }
-}
-HERE
+if [[ -z "$DNS_DOMAIN" && -n "$_METADATA_DNS_DOMAIN" ]]; then
+    echo "dns_domain: using value set on metadata: $_METADATA_DNS_DOMAIN"
+    DNS_DOMAIN="$_METADATA_DNS_DOMAIN"
+fi
+
+# Try extracting from 'usbkey_config' metadata added for bootstrapping
+# the "sdc" SAPI app.
+if [[ -z "$DNS_DOMAIN" ]]; then
+    _USBKEY_CONFIG=$(mdata-get usbkey_config)
+    if [[ -n "$_USBKEY_CONFIG" ]]; then
+        DNS_DOMAIN=$(echo "$_USBKEY_CONFIG" | grep '^dns_domain=' | cut -d'=' -f2)
+        if [[ -n "$DNS_DOMAIN" ]]; then
+            echo "dns_domain: using value from usbkey_config metadata: $DNS_DOMAIN"
+            mdata-put dns_domain "$DNS_DOMAIN"
+        else
+            echo "warning: have 'usbkey_config' metadata but unexpectedly 'dns_domain' was not in it"
+        fi
+    fi
+fi
+
+# Before TOOLS-1896, 'sdcadm up sapi' would provision a 'sapi0tmp' instance
+# to upgrade 'sapi0' to ensure there was always a running SAPI to use for
+# setting up the SAPI zone. It explicitly passed the DNS name to that running
+# SAPI via the 'sapi-url' metadata. Attempt that if our alias ends in "tmp"
+# (per https://github.com/joyent/sdcadm/blob/09a6a8757/lib/procedures/update-single-hn-sapi-v1.js#L77)
+if [[ -z "$DNS_DOMAIN" ]]; then
+    _VM_ALIAS=$(mdata-get sdc:alias)
+    _SAPI_URL=$(mdata-get sapi-url)
+    if [[ "${_VM_ALIAS: -3}" == "tmp" && -n "$_SAPI_URL" ]]; then
+        DNS_DOMAIN=$(sapi_get "$_SAPI_URL/applications?name=sdc" \
+            | json 0.metadata.dns_domain)
+        if [[ -n "$DNS_DOMAIN" ]]; then
+            echo "dns_domain: using value from given sapi-url for sapiNtmp zone: $DNS_DOMAIN"
+            mdata-put dns_domain "$DNS_DOMAIN"
+        else
+            echo "warning: looks like a sapiNtmp zone and have sapi-url, but could not get 'dns_domain' from $_SAPI_URL"
+        fi
+    fi
+fi
 
+if [[ -z "$DNS_DOMAIN" ]]; then
+    fatal "could not determine 'dns_domain'"
 fi
 
+
+echo "Starting sapi SMF service."
 /usr/sbin/svccfg import /opt/smartdc/sapi/smf/manifests/sapi.xml
 
+
+#
+# Now that the SAPI server is running (or should be soon), we can run
+# 'sdc_common_setup', which calls SAPI.
+#
+# It uses 'sapi-url' in metadata for the SAPI to talk to, so we set that
+# to *this* SAPI's admin ip to (a) ensure it finds it, it isn't yet in
+# DNS; and (b) to not have dependencies between SAPI instances.
+#
+# (Note that sdc_common_setup behavior differs when SAPI is in proto mode for
+# initial headnode setup.)
+#
+ADMIN_IP=$(mdata-get sdc:nics | json -a -c 'this.nic_tag === "admin"' | json ip)
+mdata-put sapi-url http://$ADMIN_IP
+
+CONFIG_AGENT_LOCAL_MANIFESTS_DIRS=/opt/smartdc/sapi
+SAPI_PROTO_MODE=$(mdata-get SAPI_PROTO_MODE || true)
+
+# We rely on the "download_metadata" function internally called here to perform
+# retries on the SAPI server still starting up.
+sdc_common_setup
+
 echo "Adding log rotation"
 sdc_log_rotation_add amon-agent /var/svc/log/*amon-agent*.log 1g
 sdc_log_rotation_add config-agent /var/svc/log/*config-agent*.log 1g
@@ -124,11 +173,56 @@ sdc_log_rotation_add registrar /var/svc/log/*registrar*.log 1g
 sdc_log_rotation_add $role /var/svc/log/*$role*.log 1g
 sdc_log_rotation_setup_end
 
-# Add metadata for cmon-agent discovery
-mdata-put metricPorts 8881
+##XXX I'd suggested this in the CR, but why? ... we could rely on sdcadm
+##    serviceconfig stuff to do this for us?
+##    Could try removing this.
+##
+## If we aren't in proto mode, we can update setups previous to SAPI-294 and add
+## 'dns_domain' metadata variable to SAPI service now, taking advantage of
+## 'pass_vmapi_metadata_keys' SAPI functionality. (Note we do several attempts
+## here b/c the config-agent will restart the SAPI service if the configuration
+## file changes):
+#if [[ ! ${SAPI_PROTO_MODE} ]]; then
+#    i=0
+#    while (( i++ < 30 )); do
+#        CURL_OPTS='-4 --connect-timeout 45 -sSf -i -H accept:application/json -H content-type:application/json'
+#        SAPI_SVC=$(/usr/bin/curl ${CURL_OPTS} "http://${ADMIN_IP}/services?name=sapi"|json -H 0)
+#        if [[ -z "${SAPI_SVC}" ]]; then
+#            echo "error: Unable to find SAPI service (retrying)." >&2
+#            sleep 2
+#            continue
+#        fi
+#
+#        SAPI_SVC_UUID=$(echo ${SAPI_SVC}|json uuid)
+#        SAPI_SVC_DNS_DOMAIN=$(echo ${SAPI_SVC}|json params.dns_domain)
+#        if [[ -z "${SAPI_SVC_DNS_DOMAIN}" ]]; then
+#            echo "Updating sapi service params"
+#            UPDATE_SVC=$(/usr/bin/curl ${CURL_OPTS} "http://${ADMIN_IP}/services/${SAPI_SVC_UUID}" -X PUT -d "{
+#                \"action\": \"update\",
+#                \"params\": {
+#                    \"dns_domain\": \"${DNS_DOMAIN}\"
+#                }
+#            }"|json -H)
+#            if [[ -z "${UPDATE_SVC}" ]]; then
+#                echo "error: Unable to update SAPI service (retrying)." >&2
+#                sleep 2
+#                continue
+#            fi
+#            break;
+#        else
+#            break;
+#        fi
+#    done
+#
+#    if [[ -z "${SAPI_SVC_DNS_DOMAIN}" && -z "${UPDATE_SVC}" ]]; then
+#        echo "error: Unable to update SAPI service after 30 attempts." >&2
+#        exit 1
+#    fi
+#fi
 
 # All done, run boilerplate end-of-setup
 sdc_setup_complete
 
 
 exit 0
+# vim: set shiftwidth=4 tabstop=4 expandtab:
diff --git a/lib/config.js b/lib/config.js
new file mode 100644
index 0000000..c2d415e
--- /dev/null
+++ b/lib/config.js
@@ -0,0 +1,353 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * SAPI config loading.
+ *
+ * SAPI must be able to come online without depending on config-agent to
+ * create its config file, because that creates a circular dependency which
+ * breaks (re)-creating a lone SAPI instance in the datacenter.
+ *
+ * The solution is to have a rule that all config required for base SAPI
+ * server functionality can be gathered from VM metadata (i.e. from
+ * `mdata-get`). Config data for any "non-base" functionality *may* use
+ * config-agent, but SAPI server startup does not depend on it existing.
+ *
+ * Note: Getting `dns_domain` is the most complex. The intent is that SAPI
+ * VMs have `<vm>.dns_domain` set such that `mdata-get sdc:dns_domain` is
+ * available (per https://eng.joyent.com/mdata/datadict.html). However,
+ * initially this was not the case (see TRITON-92). For some releases,
+ * `<vm>.customer_metadata.dns_domain` was set (HEAD-2387, HEAD-2378).
+ * As a last resort for earlier setups, the `dns_domain` can be pulled out
+ * of the `usbkey_config` metadatum that is added to the sapi0 instance
+ * on headnode setup to bootstrap the "sdc" application metadata. This module
+ * expects zone setup (boot/setup.sh) to handle this "last resort" and write
+ * that value to `<vm>.customer_metadata.dns_domain`.
+ */
+
+var cp = require('child_process');
+var fs = require('fs');
+var net = require('net');
+var path = require('path');
+var util = require('util');
+
+var assert = require('assert-plus');
+var bunyan = require('bunyan');
+var vasync = require('vasync');
+
+var NEEDED_SERVICES = [
+    'cnapi',
+    'imgapi',
+    'moray',
+    'napi',
+    'papi',
+    'vmapi'
+];
+
+
+function loadConfig(opts, callback) {
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+    var log = opts.log;
+
+    var context = {
+        cfg: {
+            log: log
+        }
+    };
+    vasync.pipeline({
+        arg: context,
+        funcs: [
+            function getVmDnsDomain(ctx, next) {
+                cp.exec('/usr/sbin/mdata-get sdc:dns_domain',
+                    function cpCb(err, stdout) {
+                        if (err && err.code === 1) {
+                            next();
+                            return;
+                        }
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        var dnsDomain = stdout.trim();
+                        if (dnsDomain !== 'local') {
+                            ctx.dnsDomain = dnsDomain;
+                        }
+                        next();
+                    });
+            },
+            function getMetadataDnsDomain(ctx, next) {
+                if (ctx.dnsDomain) {
+                    next();
+                    return;
+                }
+                cp.exec('/usr/sbin/mdata-get dns_domain',
+                    function cpCb(err, stdout) {
+                        if (err && err.code === 1) {
+                            next();
+                            return;
+                        }
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        ctx.dnsDomain = stdout.trim();
+                        next();
+                    });
+            },
+            // If SAPI_PROTO_MODE is set, it means we're on
+            // first boot, and we need to rely into IPs instead
+            // of domain names
+            function getMdataSapiMode(ctx, next) {
+                cp.exec('/usr/sbin/mdata-get SAPI_PROTO_MODE',
+                    function cpCb(err, stdout) {
+                        // No metadata found:
+                        if (err && err.code === 1) {
+                            ctx.protoMode = false;
+                            next();
+                            return;
+                        }
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+
+                        if (stdout.trim() !== 'true') {
+                            next(new Error(util.format(
+                                'Unexpected value for SAPI proto_mode: %s',
+                                stdout.trim())));
+                            return;
+                        }
+                        ctx.protoMode = (stdout.trim() === 'true');
+                        next();
+                    });
+            },
+            // If still in proto mode (i.e. initial headnode setup has not
+            // yet completed) we don't rely on the needed services being in
+            // DNS, so we pull out IPs from "${service}_admin_ips" in
+            // the `usbkey_config` bootstrap data.
+            // XXX Is this really needed? TODO try it without, I'm curious.
+            //       sdcadm update manatee broken without this?!?
+            function getUsbkeyConfig(ctx, next) {
+                if (!ctx.protoMode) {
+                    next();
+                    return;
+                }
+                cp.exec('/usr/sbin/mdata-get usbkey_config',
+                    function cpCb(err, stdout) {
+                        if (err && err.code === 1) {
+                            next();
+                            return;
+                        }
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        NEEDED_SERVICES.forEach(function (k) {
+                            var re = new RegExp(
+                                '^' + k + '_admin_ips=(.+)', 'm');
+                            var res = stdout.match(re);
+                            if (res !== null && res.length && res[1]) {
+                                var ips = res[1].split(',');
+                                if (ips.length && net.isIP(ips[0])) {
+                                    ctx[k] = ips[0];
+                                }
+                            }
+                        });
+                        next();
+                    });
+
+            },
+            function getInstanceUuid(ctx, next) {
+                cp.exec('zonename',
+                    function cpCb(err, stdout, _) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        ctx.instanceUuid = stdout.trim();
+                        if (!ctx.instanceUuid) {
+                            next(new Error('Missing required ' +
+                                '"sdc:zonename" metadata value'));
+                            return;
+                        }
+                        next();
+                    });
+            },
+            function getServerUuid(ctx, next) {
+                cp.exec('/usr/sbin/mdata-get sdc:server_uuid',
+                    function cpCb(err, stdout, _) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        ctx.serverUuid = stdout.trim();
+                        if (!ctx.serverUuid) {
+                            next(new Error('Missing required ' +
+                                '"server_uuid" metadata value'));
+                            return;
+                        }
+                        next();
+                    });
+            },
+            function getAdminIp(ctx, next) {
+                var cmd = '/usr/sbin/mdata-get sdc:nics';
+                cp.exec(cmd, function cpCb(err, stdout, _) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    var nics = JSON.parse(stdout.trim());
+                    ctx.adminIp = nics.filter(function (nic) {
+                        return (nic.nic_tag === 'admin');
+                    }).ip;
+
+                    if (!ctx.adminIp) {
+                        next(new Error('Missing required ' +
+                            '"adminIp" metadata value'));
+                        return;
+                    }
+                    next();
+                });
+            },
+            function getDcName(ctx, next) {
+                cp.exec('/usr/sbin/mdata-get sdc:datacenter_name',
+                    function cpCb(err, stdout, _) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        ctx.datacenterName = stdout.trim();
+                        if (!ctx.datacenterName) {
+                            next(new Error('Missing required ' +
+                                '"datacenter_name" metadata value'));
+                            return;
+                        }
+                        next();
+                    });
+            },
+            function populateConfig(ctx, next) {
+                ctx.cfg.datacenter_name = ctx.datacenterName;
+                ctx.cfg.instanceUuid = ctx.instanceUuid;
+                ctx.cfg.serverUuid = ctx.serverUuid;
+                ctx.cfg.adminIp = ctx.adminIp;
+
+                if (ctx.dnsDomain) {
+                    NEEDED_SERVICES.forEach(function (c) {
+                        if (c === 'moray') {
+                            ctx.cfg.moray = {
+                                srvDomain: util.format('%s.%s.%s', c,
+                                    ctx.datacenterName, ctx.dnsDomain),
+                                cueballOptions: {
+                                    resolvers: [util.format('binder.%s.%s',
+                                    ctx.datacenterName, ctx.dnsDomain)]
+                                }
+                            };
+                        } else {
+                            ctx.cfg[c] = {
+                                url: util.format('http://%s.%s.%s', c,
+                                    ctx.datacenterName, ctx.dnsDomain)
+                            };
+                        }
+                    });
+                } else if (ctx.protoMode) {
+                    // XXX when is this being run !?!
+                    // because we *always* expect to have dns_domain
+                    console.log('XXX ctx.protoMode and no ctx.dnsDomain !?!');
+                    var missingIps = [];
+                    NEEDED_SERVICES.forEach(function (c) {
+                        if (!ctx[c]) {
+                            missingIps.push(c);
+                        } else {
+                            if (c === 'moray') {
+                                ctx.cfg.moray = {
+                                    host: ctx[c],
+                                    port: 2020
+                                };
+                            } else {
+                                ctx.cfg[c] = {
+                                    url: 'http://' + ctx[c]
+                                };
+                            }
+                        }
+                    });
+
+                    if (missingIps.length) {
+                        next(new Error(util.format(
+                            'Missing required admin IPs for the services: "%s"',
+                            missingIps.join('","'))));
+                        return;
+                    }
+                } else {
+                    next(new Error(
+                        'Missing required "dns_domain" metadata value'));
+                    return;
+                }
+
+                next();
+            },
+
+            // Load additional config from config-agent, *if available*. This
+            // is non-fatal.
+            function loadMasterCfg(ctx, next) {
+                var masterCfg = path.resolve(__dirname,
+                            '../etc/sapi-master.config.json');
+                log.debug('Trying to read file: ' + masterCfg);
+                fs.readFile(masterCfg, {
+                    encoding: 'utf8'
+                }, function readFileCb(err, data) {
+                    if (err && err.code !== 'ENOENT') {
+                        next(err);
+                        return;
+                    }
+                    if (!err) {
+                        var mConfig;
+                        try {
+                            mConfig = JSON.parse(data);
+                            if (mConfig.moray &&
+                                mConfig.moray.master_host &&
+                                mConfig.moray.master_port) {
+                                ctx.cfg.moray.master_host =
+                                    mConfig.moray.master_host;
+                                ctx.cfg.moray.master_port =
+                                    mConfig.moray.master_port;
+                            } else {
+                                ctx.cfg.moray.master_host = null;
+                            }
+                        } catch (e) {
+                            next(e);
+                            return;
+                        }
+                    }
+                    next();
+                });
+            }
+        ]
+    }, function pipeCb(pipeErr) {
+        if (pipeErr) {
+            log.error({err: pipeErr}, 'loadConfig error');
+            callback(pipeErr);
+            return;
+        }
+
+        // If we're in proto mode, we want log level set to debug:
+        if (context.protoMode) {
+            log.level(bunyan.DEBUG);
+        }
+
+
+        callback(null, context.cfg);
+    });
+}
+
+module.exports = {
+    loadConfig: loadConfig
+};
diff --git a/lib/server/endpoints/applications.js b/lib/server/endpoints/applications.js
index b52dd5e..951010f 100644
--- a/lib/server/endpoints/applications.js
+++ b/lib/server/endpoints/applications.js
@@ -17,6 +17,7 @@ var verror = require('verror');
 
 var validateParams =
     require('./validation').validateParams;
+var common = require('./common');
 
 function Applications() {}
 
@@ -69,8 +70,9 @@ Applications.list = function (req, res, next) {
         filters.owner_uuid = req.params.owner_uuid;
 
     var opts = {};
-    if (req.params.include_master)
+    if (req.include_master) {
         opts.include_master = true;
+    }
 
     model.listApplications(filters, opts, function (err, apps) {
         if (err) {
@@ -169,6 +171,7 @@ function attachTo(sapi, model) {
 
     // List all applications
     sapi.get({ path: '/applications', name: 'ListApplications' },
+        common.ensureMasterConfigLoaded.bind(toModel),
         Applications.list.bind(toModel));
 
     // Get an application
diff --git a/lib/server/endpoints/common.js b/lib/server/endpoints/common.js
new file mode 100644
index 0000000..b276985
--- /dev/null
+++ b/lib/server/endpoints/common.js
@@ -0,0 +1,36 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Handlers shared by several end-points
+ */
+var restify = require('restify');
+
+function ensureMasterConfigLoaded(req, res, next) {
+    var model = this.model;
+
+    if (req.params.include_master) {
+        if (typeof (model.config.moray.master_host) === 'undefined') {
+            next(new restify.ServiceUnavailableError(
+                'Parameter \'include_master\' has been specified but ' +
+                'this SAPI instance has not yet loaded master details'));
+            return;
+        }
+        if (model.config.moray.master_host !== '' &&
+            model.config.moray.master_host !== null) {
+            req.include_master = true;
+        }
+    }
+    next();
+}
+
+module.exports = {
+    ensureMasterConfigLoaded: ensureMasterConfigLoaded
+};
diff --git a/lib/server/endpoints/instances.js b/lib/server/endpoints/instances.js
index 4f9cf43..070462f 100644
--- a/lib/server/endpoints/instances.js
+++ b/lib/server/endpoints/instances.js
@@ -18,6 +18,7 @@ var verror = require('verror');
 var semverGter = require('../../common/util').semverGter;
 var validateParams =
     require('./validation').validateParams;
+var common = require('./common');
 
 function Instances() {}
 
@@ -129,20 +130,23 @@ Instances.list = function (req, res, next) {
     }
 
     var opts = {};
-    if (req.params.include_master)
+
+    if (req.include_master) {
         opts.include_master = true;
+    }
 
     model.listInstances(filters, opts, function (err, insts) {
         if (err) {
             model.log.error(err, 'failed to list instances');
-            return (next(err));
+            next(err);
+            return;
         }
 
         var acceptVersion = req.getVersion();
         res.send(insts.map(function (inst) {
             return (serialize(inst, acceptVersion));
         }));
-        return (next());
+        next();
     });
 };
 
@@ -221,18 +225,19 @@ Instances.upgrade = function (req, res, next) {
     var image_uuid = req.params.image_uuid;
 
     if (!image_uuid) {
-        return (next(new restify.MissingParameterError(
-            'missing image_uuid')));
+        next(new restify.MissingParameterError('missing image_uuid'));
+        return;
     }
 
     model.upgradeInstance(uuid, image_uuid, function (err, inst) {
         if (err) {
             model.log.error(err, 'failed to upgrade instance');
-            return (next(err));
+            next(err);
+            return;
         }
 
         res.send(serialize(inst, req.getVersion()));
-        return (next());
+        next();
     });
 };
 
@@ -277,6 +282,7 @@ function attachTo(sapi, model) {
 
     // List all instances
     sapi.get({ path: '/instances', name: 'ListInstances' },
+        common.ensureMasterConfigLoaded.bind(toModel),
         Instances.list.bind(toModel));
 
     // Get an instance
diff --git a/lib/server/endpoints/manifests.js b/lib/server/endpoints/manifests.js
index 6a2d62c..1636473 100644
--- a/lib/server/endpoints/manifests.js
+++ b/lib/server/endpoints/manifests.js
@@ -19,6 +19,7 @@ var verror = require('verror');
 
 var validateParams =
     require('./validation').validateParams;
+var common = require('./common');
 
 function Manifests() {}
 
@@ -49,38 +50,40 @@ Manifests.create = function (req, res, next) {
 
     if (params.version && !semver.valid(params.version)) {
         log.error({ version: params.version }, 'invalid version');
-        return (next(new restify.InvalidArgumentError(
-            'invalid version')));
+        next(new restify.InvalidArgumentError('invalid version'));
+        return;
     }
 
     model.createManifest(params, function (err, mfest) {
         if (err) {
             model.log.error(err, 'failed to create manifest');
-            return (next(err));
+            next(err);
+            return;
         }
 
         res.send(mfest);
-        return (next());
+        next();
     });
 
-    return (null);
 };
 
 Manifests.list = function (req, res, next) {
     var model = this.model;
 
     var opts = {};
-    if (req.params.include_master)
+    if (req.include_master) {
         opts.include_master = true;
+    }
 
     model.listManifests(opts, function (err, mfests) {
         if (err) {
             model.log.error(err, 'failed to list manifests');
-            return (next(err));
+            next(err);
+            return;
         }
 
         res.send(mfests);
-        return (next());
+        next();
     });
 };
 
@@ -88,11 +91,13 @@ Manifests.get = function (req, res, next) {
     var model = this.model;
 
     model.getManifest(req.params.uuid, function (err, mfest) {
-        if (err)
-            return (next(err));
+        if (err) {
+            next(err);
+            return;
+        }
 
         res.send(mfest);
-        return (next());
+        next();
     });
 };
 
@@ -127,6 +132,7 @@ function attachTo(sapi, model) {
 
     // List all manifests
     sapi.get({ path: '/manifests', name: 'ListManifests' },
+        common.ensureMasterConfigLoaded.bind(toModel),
         Manifests.list.bind(toModel));
 
     // Get a manifest
diff --git a/lib/server/endpoints/services.js b/lib/server/endpoints/services.js
index 46a6b82..370011c 100644
--- a/lib/server/endpoints/services.js
+++ b/lib/server/endpoints/services.js
@@ -18,6 +18,7 @@ var verror = require('verror');
 var semverGter = require('../../common/util').semverGter;
 var validateParams =
     require('./validation').validateParams;
+var common = require('./common');
 
 function Services() {}
 
@@ -109,13 +110,15 @@ Services.list = function (req, res, next) {
         filters.type = req.params.type;
 
     var opts = {};
-    if (req.params.include_master)
+    if (req.include_master) {
         opts.include_master = true;
+    }
 
     model.listServices(filters, opts, function (err, svcs) {
         if (err) {
             model.log.error(err, 'failed to list services');
-            return (next(err));
+            next(err);
+            return;
         }
 
         var acceptVersion = req.getVersion();
@@ -123,7 +126,7 @@ Services.list = function (req, res, next) {
             return (serialize(svc, acceptVersion));
         }));
 
-        return (next());
+        next();
     });
 };
 
@@ -209,6 +212,7 @@ function attachTo(sapi, model) {
 
     // List all services
     sapi.get({ path: '/services', name: 'ListServices' },
+        common.ensureMasterConfigLoaded.bind(toModel),
         Services.list.bind(toModel));
 
     // Get a service
diff --git a/lib/server/sapi.js b/lib/server/sapi.js
index 67fd668..abf4f89 100644
--- a/lib/server/sapi.js
+++ b/lib/server/sapi.js
@@ -82,7 +82,7 @@ SAPI.prototype.start = function start(cb) {
                     datacenter: config.datacenter_name,
                     instance: config.instanceUuid,
                     server: config.serverUuid,
-                    service: config.serviceName
+                    service: 'sapi'
                 }
             });
 
diff --git a/package.json b/package.json
index ecfea9c..cd1db3c 100644
--- a/package.json
+++ b/package.json
@@ -9,19 +9,15 @@
     "assert-plus": "1.0.0",
     "async": "0.1.22",
     "bunyan": "1.8.12",
-    "hogan.js": "2.0.0",
     "jsprim": "2.0.0",
-    "lru-cache": "2.3.0",
     "mkdirp": "0.3.4",
     "moray": "3.5.0",
     "moray-filter": "1.0.0",
     "node-uuid": "1.4.0",
     "once": "1.3.0",
-    "optimist": "0.3.5",
     "restify": "4.3.2",
     "sdc-clients": "10.5.0",
     "semver": "5.4.1",
-    "sprintf-js": "0.0.7",
     "triton-metrics": "0.1.1",
     "vasync": "2.2.0",
     "verror": "1.10.0"
diff --git a/sapi_manifests/sapi/manifest.json b/sapi_manifests/sapi/manifest.json
index bed37b2..f982ca6 100644
--- a/sapi_manifests/sapi/manifest.json
+++ b/sapi_manifests/sapi/manifest.json
@@ -1,5 +1,5 @@
 {
 	"name": "sapi",
-	"path": "/opt/smartdc/sapi/etc/config.json",
+	"path": "/opt/smartdc/sapi/etc/sapi-master.config.json",
 	"post_cmd": "/usr/sbin/svcadm restart sapi"
 }
diff --git a/sapi_manifests/sapi/template b/sapi_manifests/sapi/template
index 2dbf452..84c47ba 100644
--- a/sapi_manifests/sapi/template
+++ b/sapi_manifests/sapi/template
@@ -1,34 +1,6 @@
 {
-    "log_options": {
-        "name": "sapi",
-        "level": "info"
-    },
-    "datacenter_name": "{{{datacenter_name}}}",
-    "serviceName": "{{SERVICE_NAME}}",
-    "instanceUuid": "{{auto.ZONENAME}}",
-    "serverUuid": "{{auto.SERVER_UUID}}",
-    "adminIp": "{{auto.ADMIN_IP}}",
     "moray": {
-        "srvDomain": "{{MORAY_SERVICE}}",
-        "cueballOptions": {
-            "resolvers": ["{{{BINDER_SERVICE}}}"]
-        },
         "master_host": "{{{MASTER_MORAY_IP}}}",
         "master_port": "{{{MASTER_MORAY_PORT}}}"
-    },
-    "cnapi": {
-        "url": "http://{{{CNAPI_SERVICE}}}"
-    },
-    "vmapi": {
-        "url": "http://{{{VMAPI_SERVICE}}}"
-    },
-    "napi": {
-        "url": "http://{{{NAPI_SERVICE}}}"
-    },
-    "imgapi": {
-        "url": "http://{{{IMGAPI_SERVICE}}}"
-    },
-    "papi": {
-        "url": "http://{{{PAPI_SERVICE}}}"
     }
 }
diff --git a/server.js b/server.js
index cf2d72d..f3de0b6 100644
--- a/server.js
+++ b/server.js
@@ -5,45 +5,41 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
  * server.js: Main entry point for the Services API
  */
 
-var assert = require('assert-plus');
+
 var bunyan = require('bunyan');
-var fs = require('fs');
-var optimist = require('optimist');
 
 var SAPI = require('./lib/server/sapi');
+var mod_config = require('./lib/config');
 
+var log = bunyan.createLogger({
+    name: 'sapi',
+    level: 'info',
+    serializers: bunyan.stdSerializers
+});
 
 
-optimist.usage('Usage:\t node server.js [ -f <config file> ]');
-var ARGV = optimist.options({
-    'f': {
-        'alias': 'file',
-        'describe': 'location of configuration file'
-    }
-}).argv;
-
-var file = ARGV.f ? ARGV.f : './etc/config.json';
-var config = JSON.parse(fs.readFileSync(file));
-
+mod_config.loadConfig({ log: log }, function (configErr, config) {
 
-assert.object(config.log_options);
-config.log_options.serializers = bunyan.stdSerializers;
-var log = bunyan.createLogger(config.log_options);
-config.log = log;
+    if (configErr) {
+        log.fatal({err: configErr}, 'Load config error');
+        process.exit(1);
+    }
 
+    log.info({ config: config }, 'loadConfig');
 
-var sapi = new SAPI(config);
+    var sapi = new SAPI(config);
 
-sapi.start(function (err) {
-    if (err) {
-        log.fatal(err, 'failure to start SAPI');
-        process.exit(1);
-    }
+    sapi.start(function initCb(err) {
+        if (err) {
+            log.fatal(err, 'failure to start SAPI');
+            process.exit(1);
+        }
+    });
 });
-- 
2.21.0

