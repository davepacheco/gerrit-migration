commit bef0e120f57b2a0870e131ae06fd0012f2793a44 (refs/changes/96/2896/23)
Author: Pedro Palazon Candel <pedro@joyent.com>
Date:   2018-06-14T18:53:33+02:00 (1 year, 4 months ago)
    
    SAPI-294 SAPI first boot (in non-proto mode) depends on SAPI

diff --git a/Makefile b/Makefile
index 8aaad6d..a5d5b98 100644
--- a/Makefile
+++ b/Makefile
@@ -80,12 +80,12 @@ service: all $(SMF_MANIFESTS)
 	@rm -rf $(SVC_PKGDIR)
 	@mkdir -p $(SVC_PKGDIR)/site
 	@mkdir -p $(SVC_INSTDIR)/build
-	@mkdir -p $(SVC_INSTDIR)/lib
 	@mkdir -p $(SVC_INSTDIR)/smf/manifests
 	@mkdir -p $(SVC_INSTDIR)/test
 	@mkdir -p $(SVC_INSTDIR)/tools
 	@touch $(SVC_PKGDIR)/site/.do-not-delete-me
 	cp -r $(TOP)/server.js \
+		$(TOP)/lib \
 		$(TOP)/node_modules \
 		$(TOP)/package.json \
 		$(SVC_INSTDIR)/
diff --git a/boot/setup.sh b/boot/setup.sh
index 6969b9e..2e57672 100755
--- a/boot/setup.sh
+++ b/boot/setup.sh
@@ -26,12 +26,10 @@ mkdir -p /var/smartdc/sapi
 echo "" >>/root/.profile
 echo "export PATH=\$PATH:/opt/smartdc/sapi/build/node/bin:/opt/smartdc/sapi/node_modules/.bin" >>/root/.profile
 
-
 # Include common utility functions (then run the boilerplate).
 source /opt/smartdc/boot/lib/util.sh
 CONFIG_AGENT_LOCAL_MANIFESTS_DIRS=/opt/smartdc/sapi
 SAPI_PROTO_MODE=$(mdata-get SAPI_PROTO_MODE || true)
-sdc_common_setup
 
 # If there's a zfs dataset, make the mount point /sapi
 zfs list $ZONE_DATASET && rc=$? || rc=$?
@@ -45,78 +43,41 @@ if [[ $rc == 0 ]]; then
     fi
 fi
 
-if [[ "${SAPI_PROTO_MODE}" == "true" ]]; then
-    # During setup/bootstrapping, we do not expect binder to be available, and
-    # rely on the pre-allocated IPs. We grab all the config from the
-    # usbkey_config key in metadata which is assumed to have a copy of
-    # /usbkey/config for us.
-
-    /usr/sbin/mdata-get usbkey_config > /var/tmp/usbkey.config
-    if [[ $? -ne 0 ]]; then
-        echo "error: Unable to find usbkey/config in SAPI zone." >&2
-        exit 1
-    fi
-
-    eval $(
-    . /var/tmp/usbkey.config
-    cat <<EOF
-DATACENTER_NAME=${datacenter_name}
-IMGAPI_ADMIN_IPS=${imgapi_admin_ips}
-MORAY_ADMIN_IPS=${moray_admin_ips}
-NAPI_ADMIN_IPS=${napi_admin_ips}
-VMAPI_ADMIN_IPS=${vmapi_admin_ips}
-CNAPI_ADMIN_IPS=${cnapi_admin_ips}
-SAPI_ADMIN_IP=${sapi_admin_ips}
-EOF
-    )
-
-    IMGAPI_URL=http://$(echo "${IMGAPI_ADMIN_IPS}" | cut -d',' -f1)
-    MORAY_HOST=$(echo "${MORAY_ADMIN_IPS}" | cut -d ',' -f1)
-    NAPI_URL=http://$(echo "${NAPI_ADMIN_IPS}" | cut -d',' -f1)
-    CNAPI_URL=http://$(echo "${CNAPI_ADMIN_IPS}" | cut -d',' -f1)
-    VMAPI_URL=http://$(echo "${VMAPI_ADMIN_IPS}" | cut -d',' -f1)
-    SERVER_UUID=$(mdata-get sdc:server_uuid)
-
-    # This config file is used during setup to bootstrap SAPI. With the
-    # exception that it requires IP addresses instead of DNS names (as binder is
-    # not expected to be setup yet), it should be kept broadly in sync with the
-    # template at:
-    #   sapi.git/sapi_manifests/sapi/template
-    mkdir -p /opt/smartdc/sapi/etc
-    cat > /opt/smartdc/sapi/etc/config.json <<HERE
-{
-  "log_options": {
-    "name": "sapi",
-    "level": "debug"
-  },
-  "datacenter_name": "$DATACENTER_NAME",
-  "serviceName": "sapi",
-  "instanceUuid": "$ZONE_UUID",
-  "serverUuid": "$SERVER_UUID",
-  "adminIp": "$SAPI_ADMIN_IP",
-  "moray": {
-    "host": "$MORAY_HOST",
-    "port": 2020
-  },
-  "cnapi": {
-    "url": "$CNAPI_URL"
-  },
-  "vmapi": {
-    "url": "$VMAPI_URL"
-  },
-  "napi": {
-    "url": "$NAPI_URL"
-  },
-  "imgapi": {
-    "url": "$IMGAPI_URL"
-  }
-}
-HERE
-
+# We need to set the current sapi instance's admin IP as the url for the SAPI
+# service because we don't want to have dependencies between SAPI instances.
+# This way, can always create a new functional SAPI instance, even if there
+# aren't any more instances functional at that moment.
+
+# Ensure we always have the current VM admin ip as sapi-url:
+ADMIN_IP=$(mdata-get sdc:nics | json -a -c 'this.nic_tag === "admin"' | json ip)
+mdata-put sapi-url http://$ADMIN_IP
+
+# Since 'dns_domain' usage from sapi's config library has been introduced by
+# SAPI-294, we need to make sure that, for instances running on systems created
+# before such change, we'll properly populate 'dns_domain' metadata variable.
+# Given that variable is used by the SAPI service, this variable must be set
+# before we import the manifest.
+
+# Set dns_domain if already not set:
+DNS_DOMAIN=$(mdata-get dns_domain)
+USBKEY_CONFIG=$(mdata-get usbkey_config)
+if [[ -z "${DNS_DOMAIN}" && ! -z "${USBKEY_CONFIG}" ]]; then
+    DNS_DOMAIN=$(mdata-get usbkey_config | grep '^dns_domain' | tr '=' '\n' | tail -n 1)
+    mdata-put dns_domain $DNS_DOMAIN
 fi
 
+# As soon as we import the manifest, SAPI service will be available for this
+# instance, and all the 'sdc_common_setup' requests to 'http://$ADMIN_IP' will
+# have a reply.
+echo "Importing sapi.xml"
 /usr/sbin/svccfg import /opt/smartdc/sapi/smf/manifests/sapi.xml
 
+# Wait until we have SAPI manifest imported before we attempt to setup
+# registrar and config-agent. In case the SAPI service takes some time to
+# be up and running, we rely into 'download_metadata' ability to perform
+# retries in order to have a successful setup.
+sdc_common_setup
+
 echo "Adding log rotation"
 sdc_log_rotation_add amon-agent /var/svc/log/*amon-agent*.log 1g
 sdc_log_rotation_add config-agent /var/svc/log/*config-agent*.log 1g
@@ -124,8 +85,53 @@ sdc_log_rotation_add registrar /var/svc/log/*registrar*.log 1g
 sdc_log_rotation_add $role /var/svc/log/*$role*.log 1g
 sdc_log_rotation_setup_end
 
+
+# If we aren't in proto mode, we can update setups previous to SAPI-294 and add
+# 'dns_domain' metadata variable to SAPI service now, taking advantage of
+# 'pass_vmapi_metadata_keys' SAPI functionality. (Note we do several attempts
+# here b/c the config-agent will restart the SAPI service if the configuration
+# file changes):
+if [[ ! ${SAPI_PROTO_MODE} ]]; then
+    i=0
+    while (( i++ < 30 )); do
+        CURL_OPTS='-4 --connect-timeout 45 -sSf -i -H accept:application/json -H content-type:application/json'
+        SAPI_SVC=$(/usr/bin/curl ${CURL_OPTS} "http://${ADMIN_IP}/services?name=sapi"|json -H 0)
+        if [[ -z "${SAPI_SVC}" ]]; then
+            echo "error: Unable to find SAPI service (retrying)." >&2
+            sleep 2
+            continue
+        fi
+
+        SAPI_SVC_UUID=$(echo ${SAPI_SVC}|json uuid)
+        SAPI_SVC_MDATA_KEYS=$(echo ${SAPI_SVC}|json metadata.pass_vmapi_metadata_keys)
+        if [[ -z "${SAPI_SVC_MDATA_KEYS}" ]]; then
+            echo "Updating sapi service metadata"
+            UPDATE_SVC=$(/usr/bin/curl ${CURL_OPTS} "http://${ADMIN_IP}/services/${SAPI_SVC_UUID}" -X PUT -d "{
+                \"action\": \"update\",
+                \"metadata\": {
+                    \"pass_vmapi_metadata_keys\": [\"dns_domain\"]
+                }
+            }"|json -H)
+            if [[ -z "${UPDATE_SVC}" ]]; then
+                echo "error: Unable to update SAPI service (retrying)." >&2
+                sleep 2
+                continue
+            fi
+            break;
+        else
+            break;
+        fi
+    done
+
+    if [[ -z "${SAPI_SVC_MDATA_KEYS}" && -z "${UPDATE_SVC}" ]]; then
+        echo "error: Unable to update SAPI service after 30 attempts." >&2
+        exit 1
+    fi
+fi
+
 # All done, run boilerplate end-of-setup
 sdc_setup_complete
 
 
 exit 0
+# vim: set shiftwidth=4 tabstop=4 expandtab:
diff --git a/lib/config.js b/lib/config.js
new file mode 100644
index 0000000..4ca4641
--- /dev/null
+++ b/lib/config.js
@@ -0,0 +1,318 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * SAPI configuration library.
+ *
+ * Sapi configuration must not be dependent on config-agent synchronization
+ * (since config-agent itself depends on SAPI). Therefore, this library loads
+ * some of the configuration details from sapi VMs metadata values.
+ * Information about sapi master is stored into a separate file when required
+ * and loaded by this library.
+ * Note that this library expects the existence of 'dns_domain' metadata
+ * variable being set into sapi VM, either by the initial headnode setup
+ * (see HEAD-2378 and HEAD-2387), or during VM initial setup, extracting
+ * it from usbkey_config metadata value.
+ */
+
+var cp = require('child_process');
+var fs = require('fs');
+var net = require('net');
+var path = require('path');
+var util = require('util');
+
+var assert = require('assert-plus');
+var bunyan = require('bunyan');
+var vasync = require('vasync');
+
+var NEEDED_SERVICES = [
+    'cnapi',
+    'imgapi',
+    'moray',
+    'napi',
+    'papi',
+    'vmapi'
+];
+
+
+
+function loadConfig(config, callback) {
+    assert.object(config, 'config');
+    assert.object(config.log, 'config.log');
+    var log = config.log;
+
+    var context = {
+        cfg: {
+            log: log
+        },
+        // Used by Artedi Metrics
+        serviceName: 'sapi'
+    };
+    vasync.pipeline({
+        arg: context,
+        funcs: [
+            function getDnsDomain(ctx, next) {
+                cp.exec('/usr/sbin/mdata-get dns_domain',
+                    function cpCb(err, stdout) {
+                        if (err && err.code === 1) {
+                            next();
+                            return;
+                        }
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        ctx.dnsDomain = stdout.trim();
+                        next();
+                    });
+
+            },
+            // If SAPI_PROTO_MODE is set, it means we're on
+            // first boot, and we need to rely into IPs instead
+            // of domain names
+            function getMdataSapiMode(ctx, next) {
+                cp.exec('/usr/sbin/mdata-get SAPI_PROTO_MODE',
+                    function cpCb(err, stdout) {
+                        // No metadata found:
+                        if (err && err.code === 1) {
+                            ctx.protoMode = false;
+                            next();
+                            return;
+                        }
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+
+                        if (stdout.trim() !== 'true') {
+                            next(new Error(util.format(
+                                'Unexpected value for SAPI proto_mode: %s',
+                                stdout.trim())));
+                            return;
+                        }
+                        ctx.protoMode = (stdout.trim() === 'true');
+                        next();
+                    });
+            },
+            // If usbkey_config exists, we're at the initial bootstrap
+            // and on this case we need to grab IP addresses
+            // to configure our services, instead of using domain names.
+            function getUsbkeyConfig(ctx, next) {
+                if (!ctx.protoMode) {
+                    next();
+                    return;
+                }
+                cp.exec('/usr/sbin/mdata-get usbkey_config',
+                    function cpCb(err, stdout) {
+                        if (err && err.code === 1) {
+                            next();
+                            return;
+                        }
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        NEEDED_SERVICES.forEach(function (k) {
+                            var re = new RegExp(
+                                '^' + k + '_admin_ips=(.+)', 'm');
+                            var res = stdout.match(re);
+                            if (res !== null && res.length && res[1]) {
+                                var ips = res[1].split(',');
+                                if (ips.length && net.isIP(ips[0])) {
+                                    ctx[k] = ips[0];
+                                }
+                            }
+                        });
+                        next();
+                    });
+
+            },
+            // Used by Artedi Metrics
+            function getInstanceUuid(ctx, next) {
+                cp.exec('/usr/sbin/mdata-get sdc:zonename',
+                    function cpCb(err, stdout, _) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        ctx.instanceUuid = stdout.trim();
+                        if (!ctx.instanceUuid) {
+                            next(new Error('Missing required ' +
+                                '"sdc:zonename" metadata value'));
+                            return;
+                        }
+                        next();
+                    });
+            },
+
+            // Used by Artedi Metrics
+            function getServerUuid(ctx, next) {
+                cp.exec('/usr/sbin/mdata-get sdc:server_uuid',
+                    function cpCb(err, stdout, _) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        ctx.serverUuid = stdout.trim();
+                        if (!ctx.serverUuid) {
+                            next(new Error('Missing required ' +
+                                '"server_uuid" metadata value'));
+                            return;
+                        }
+                        next();
+                    });
+            },
+            // Used by Artedi Metrics
+            function getAdminIp(ctx, next) {
+                var cmd = '/usr/sbin/mdata-get sdc:nics | /usr/bin/json' +
+                    ' -a -c \'this.nic_tag === "admin"\' | /usr/bin/json ip';
+                cp.exec(cmd, function cpCb(err, stdout, _) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+                    ctx.adminIp = stdout.trim();
+                    if (!ctx.adminIp) {
+                        next(new Error('Missing required ' +
+                            '"adminIp" metadata value'));
+                        return;
+                    }
+                    next();
+                });
+            },
+            function getDcName(ctx, next) {
+                cp.exec('/usr/sbin/mdata-get sdc:datacenter_name',
+                    function cpCb(err, stdout, _) {
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+                        ctx.datacenterName = stdout.trim();
+                        if (!ctx.datacenterName) {
+                            next(new Error('Missing required ' +
+                                '"datacenter_name" metadata value'));
+                            return;
+                        }
+                        next();
+                    });
+            },
+            function populateConfig(ctx, next) {
+                ctx.cfg.datacenter_name = ctx.datacenterName;
+                ctx.cfg.serviceName = ctx.serviceName;
+                ctx.cfg.instanceUuid = ctx.instanceUuid;
+                ctx.cfg.serverUuid = ctx.serverUuid;
+                ctx.cfg.adminIp = ctx.adminIp;
+
+                if (ctx.dnsDomain) {
+                    NEEDED_SERVICES.forEach(function (c) {
+                        if (c === 'moray') {
+                            ctx.cfg.moray = {
+                                srvDomain: util.format('%s.%s.%s', c,
+                                    ctx.datacenterName, ctx.dnsDomain),
+                                cueballOptions: {
+                                    resolvers: [util.format('binder.%s.%s',
+                                    ctx.datacenterName, ctx.dnsDomain)]
+                                }
+                            };
+                        } else {
+                            ctx.cfg[c] = {
+                                url: util.format('http://%s.%s.%s', c,
+                                    ctx.datacenterName, ctx.dnsDomain)
+                            };
+                        }
+                    });
+                } else if (ctx.protoMode) {
+                    var missingIps = [];
+                    NEEDED_SERVICES.forEach(function (c) {
+                        if (!ctx[c]) {
+                            missingIps.push(c);
+                        } else {
+                            if (c === 'moray') {
+                                ctx.cfg.moray = {
+                                    host: ctx[c],
+                                    port: 2020
+                                };
+                            } else {
+                                ctx.cfg[c] = {
+                                    url: 'http://' + ctx[c]
+                                };
+                            }
+                        }
+                    });
+
+                    if (missingIps.length) {
+                        next(new Error(util.format(
+                            'Missing required admin IPs for the services: "%s"',
+                            missingIps.join('","'))));
+                        return;
+                    }
+                } else {
+                    next(new Error(
+                        'Missing required "dns_domain" metadata value'));
+                    return;
+                }
+
+                next();
+            },
+            function loadMasterCfg(ctx, next) {
+                // Try to load sapi-master.config.json if exists:
+                var masterCfg = path.resolve(__dirname,
+                            '../etc/sapi-master.config.json');
+                log.debug('Trying to read file: ' + masterCfg);
+                fs.readFile(masterCfg, {
+                    encoding: 'utf8'
+                }, function readFileCb(err, data) {
+                    if (err && err.code !== 'ENOENT') {
+                        next(err);
+                        return;
+                    }
+                    if (!err) {
+                        var mConfig;
+                        try {
+                            mConfig = JSON.parse(data);
+                            if (mConfig.moray &&
+                                mConfig.moray.master_host &&
+                                mConfig.moray.master_port) {
+                                ctx.cfg.moray.master_host =
+                                    mConfig.moray.master_host;
+                                ctx.cfg.moray.master_port =
+                                    mConfig.moray.master_port;
+                            } else {
+                                ctx.cfg.moray.master_host = null;
+                            }
+                        } catch (e) {
+                            next(e);
+                            return;
+                        }
+                    }
+                    next();
+                });
+            }
+        ]
+    }, function pipeCb(pipeErr) {
+        if (pipeErr) {
+            log.error({err: pipeErr}, 'loadConfig error');
+            callback(pipeErr);
+            return;
+        }
+
+        // If we're in proto mode, we want log level set to debug:
+        if (context.protoMode) {
+            log.level(bunyan.DEBUG);
+        }
+
+
+        callback(null, context.cfg);
+    });
+}
+
+module.exports = {
+    loadConfig: loadConfig
+};
diff --git a/lib/server/endpoints/applications.js b/lib/server/endpoints/applications.js
index b52dd5e..951010f 100644
--- a/lib/server/endpoints/applications.js
+++ b/lib/server/endpoints/applications.js
@@ -17,6 +17,7 @@ var verror = require('verror');
 
 var validateParams =
     require('./validation').validateParams;
+var common = require('./common');
 
 function Applications() {}
 
@@ -69,8 +70,9 @@ Applications.list = function (req, res, next) {
         filters.owner_uuid = req.params.owner_uuid;
 
     var opts = {};
-    if (req.params.include_master)
+    if (req.include_master) {
         opts.include_master = true;
+    }
 
     model.listApplications(filters, opts, function (err, apps) {
         if (err) {
@@ -169,6 +171,7 @@ function attachTo(sapi, model) {
 
     // List all applications
     sapi.get({ path: '/applications', name: 'ListApplications' },
+        common.ensureMasterConfigLoaded.bind(toModel),
         Applications.list.bind(toModel));
 
     // Get an application
diff --git a/lib/server/endpoints/common.js b/lib/server/endpoints/common.js
new file mode 100644
index 0000000..b276985
--- /dev/null
+++ b/lib/server/endpoints/common.js
@@ -0,0 +1,36 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Handlers shared by several end-points
+ */
+var restify = require('restify');
+
+function ensureMasterConfigLoaded(req, res, next) {
+    var model = this.model;
+
+    if (req.params.include_master) {
+        if (typeof (model.config.moray.master_host) === 'undefined') {
+            next(new restify.ServiceUnavailableError(
+                'Parameter \'include_master\' has been specified but ' +
+                'this SAPI instance has not yet loaded master details'));
+            return;
+        }
+        if (model.config.moray.master_host !== '' &&
+            model.config.moray.master_host !== null) {
+            req.include_master = true;
+        }
+    }
+    next();
+}
+
+module.exports = {
+    ensureMasterConfigLoaded: ensureMasterConfigLoaded
+};
diff --git a/lib/server/endpoints/instances.js b/lib/server/endpoints/instances.js
index 4f9cf43..070462f 100644
--- a/lib/server/endpoints/instances.js
+++ b/lib/server/endpoints/instances.js
@@ -18,6 +18,7 @@ var verror = require('verror');
 var semverGter = require('../../common/util').semverGter;
 var validateParams =
     require('./validation').validateParams;
+var common = require('./common');
 
 function Instances() {}
 
@@ -129,20 +130,23 @@ Instances.list = function (req, res, next) {
     }
 
     var opts = {};
-    if (req.params.include_master)
+
+    if (req.include_master) {
         opts.include_master = true;
+    }
 
     model.listInstances(filters, opts, function (err, insts) {
         if (err) {
             model.log.error(err, 'failed to list instances');
-            return (next(err));
+            next(err);
+            return;
         }
 
         var acceptVersion = req.getVersion();
         res.send(insts.map(function (inst) {
             return (serialize(inst, acceptVersion));
         }));
-        return (next());
+        next();
     });
 };
 
@@ -221,18 +225,19 @@ Instances.upgrade = function (req, res, next) {
     var image_uuid = req.params.image_uuid;
 
     if (!image_uuid) {
-        return (next(new restify.MissingParameterError(
-            'missing image_uuid')));
+        next(new restify.MissingParameterError('missing image_uuid'));
+        return;
     }
 
     model.upgradeInstance(uuid, image_uuid, function (err, inst) {
         if (err) {
             model.log.error(err, 'failed to upgrade instance');
-            return (next(err));
+            next(err);
+            return;
         }
 
         res.send(serialize(inst, req.getVersion()));
-        return (next());
+        next();
     });
 };
 
@@ -277,6 +282,7 @@ function attachTo(sapi, model) {
 
     // List all instances
     sapi.get({ path: '/instances', name: 'ListInstances' },
+        common.ensureMasterConfigLoaded.bind(toModel),
         Instances.list.bind(toModel));
 
     // Get an instance
diff --git a/lib/server/endpoints/manifests.js b/lib/server/endpoints/manifests.js
index 6a2d62c..1636473 100644
--- a/lib/server/endpoints/manifests.js
+++ b/lib/server/endpoints/manifests.js
@@ -19,6 +19,7 @@ var verror = require('verror');
 
 var validateParams =
     require('./validation').validateParams;
+var common = require('./common');
 
 function Manifests() {}
 
@@ -49,38 +50,40 @@ Manifests.create = function (req, res, next) {
 
     if (params.version && !semver.valid(params.version)) {
         log.error({ version: params.version }, 'invalid version');
-        return (next(new restify.InvalidArgumentError(
-            'invalid version')));
+        next(new restify.InvalidArgumentError('invalid version'));
+        return;
     }
 
     model.createManifest(params, function (err, mfest) {
         if (err) {
             model.log.error(err, 'failed to create manifest');
-            return (next(err));
+            next(err);
+            return;
         }
 
         res.send(mfest);
-        return (next());
+        next();
     });
 
-    return (null);
 };
 
 Manifests.list = function (req, res, next) {
     var model = this.model;
 
     var opts = {};
-    if (req.params.include_master)
+    if (req.include_master) {
         opts.include_master = true;
+    }
 
     model.listManifests(opts, function (err, mfests) {
         if (err) {
             model.log.error(err, 'failed to list manifests');
-            return (next(err));
+            next(err);
+            return;
         }
 
         res.send(mfests);
-        return (next());
+        next();
     });
 };
 
@@ -88,11 +91,13 @@ Manifests.get = function (req, res, next) {
     var model = this.model;
 
     model.getManifest(req.params.uuid, function (err, mfest) {
-        if (err)
-            return (next(err));
+        if (err) {
+            next(err);
+            return;
+        }
 
         res.send(mfest);
-        return (next());
+        next();
     });
 };
 
@@ -127,6 +132,7 @@ function attachTo(sapi, model) {
 
     // List all manifests
     sapi.get({ path: '/manifests', name: 'ListManifests' },
+        common.ensureMasterConfigLoaded.bind(toModel),
         Manifests.list.bind(toModel));
 
     // Get a manifest
diff --git a/lib/server/endpoints/services.js b/lib/server/endpoints/services.js
index 46a6b82..370011c 100644
--- a/lib/server/endpoints/services.js
+++ b/lib/server/endpoints/services.js
@@ -18,6 +18,7 @@ var verror = require('verror');
 var semverGter = require('../../common/util').semverGter;
 var validateParams =
     require('./validation').validateParams;
+var common = require('./common');
 
 function Services() {}
 
@@ -109,13 +110,15 @@ Services.list = function (req, res, next) {
         filters.type = req.params.type;
 
     var opts = {};
-    if (req.params.include_master)
+    if (req.include_master) {
         opts.include_master = true;
+    }
 
     model.listServices(filters, opts, function (err, svcs) {
         if (err) {
             model.log.error(err, 'failed to list services');
-            return (next(err));
+            next(err);
+            return;
         }
 
         var acceptVersion = req.getVersion();
@@ -123,7 +126,7 @@ Services.list = function (req, res, next) {
             return (serialize(svc, acceptVersion));
         }));
 
-        return (next());
+        next();
     });
 };
 
@@ -209,6 +212,7 @@ function attachTo(sapi, model) {
 
     // List all services
     sapi.get({ path: '/services', name: 'ListServices' },
+        common.ensureMasterConfigLoaded.bind(toModel),
         Services.list.bind(toModel));
 
     // Get a service
diff --git a/sapi_manifests/sapi/manifest.json b/sapi_manifests/sapi/manifest.json
index bed37b2..f982ca6 100644
--- a/sapi_manifests/sapi/manifest.json
+++ b/sapi_manifests/sapi/manifest.json
@@ -1,5 +1,5 @@
 {
 	"name": "sapi",
-	"path": "/opt/smartdc/sapi/etc/config.json",
+	"path": "/opt/smartdc/sapi/etc/sapi-master.config.json",
 	"post_cmd": "/usr/sbin/svcadm restart sapi"
 }
diff --git a/server.js b/server.js
index cf2d72d..200dc75 100644
--- a/server.js
+++ b/server.js
@@ -5,45 +5,41 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
  * server.js: Main entry point for the Services API
  */
 
-var assert = require('assert-plus');
+
 var bunyan = require('bunyan');
-var fs = require('fs');
-var optimist = require('optimist');
 
 var SAPI = require('./lib/server/sapi');
+var mod_config = require('./lib/config');
 
+var log = bunyan.createLogger({
+    name: 'sapi',
+    level: 'info',
+    serializers: bunyan.stdSerializers
+});
 
 
-optimist.usage('Usage:\t node server.js [ -f <config file> ]');
-var ARGV = optimist.options({
-    'f': {
-        'alias': 'file',
-        'describe': 'location of configuration file'
-    }
-}).argv;
-
-var file = ARGV.f ? ARGV.f : './etc/config.json';
-var config = JSON.parse(fs.readFileSync(file));
-
+mod_config.loadConfig({ log: log }, function (cfgErr, cfg) {
 
-assert.object(config.log_options);
-config.log_options.serializers = bunyan.stdSerializers;
-var log = bunyan.createLogger(config.log_options);
-config.log = log;
+    if (cfgErr) {
+        log.fatal({err: cfgErr}, 'Load config error');
+        process.exit(1);
+    }
 
+    log.info({ cfg: cfg }, 'loadConfig');
 
-var sapi = new SAPI(config);
+    var sapi = new SAPI(cfg);
 
-sapi.start(function (err) {
-    if (err) {
-        log.fatal(err, 'failure to start SAPI');
-        process.exit(1);
-    }
+    sapi.start(function initCb(err) {
+        if (err) {
+            log.fatal(err, 'failure to start SAPI');
+            process.exit(1);
+        }
+    });
 });
diff --git a/smf/manifests/sapi.xml b/smf/manifests/sapi.xml
index 06a43d4..fad0716 100644
--- a/smf/manifests/sapi.xml
+++ b/smf/manifests/sapi.xml
@@ -20,7 +20,9 @@
 	<service_fmri value="svc:/system/filesystem/local" />
 </dependency>
 
+
 <exec_method type="method" name="start" exec="/opt/smartdc/sapi/build/node/bin/node --abort-on-uncaught-exception /opt/smartdc/sapi/server.js -f /opt/smartdc/sapi/etc/config.json &amp;" timeout_seconds="30" />
+
 <exec_method type="method" name="stop" exec=":kill" timeout_seconds="30" />
 
 <instance name="default" enabled="true" />
