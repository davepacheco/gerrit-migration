From 18f49af7a3177c2c18de6f303003806ea97aabc8 Mon Sep 17 00:00:00 2001
From: Josh Wilsdon <josh@wilsdon.ca>
Date: Sun, 4 Feb 2018 23:34:01 -0800
Subject: [PATCH] TRITON-99 vm-agent should have the ability to load
 configuration differently on different systems

---
 bin/vm-agent.js                | 165 ++-------------------------------
 lib/backend.smartos.js         | 126 +++++++++++++++++++++++++
 lib/vm-agent.js                | 111 +++++++++++++++-------
 tests/mocks.js                 |  18 +++-
 tests/test.VmAgentMockVmadm.js |  18 ++--
 tests/test.VmAgentRealVmadm.js |  20 ++--
 6 files changed, 255 insertions(+), 203 deletions(-)
 create mode 100644 lib/backend.smartos.js

diff --git a/bin/vm-agent.js b/bin/vm-agent.js
index 8d5d2f4..1d567bd 100644
--- a/bin/vm-agent.js
+++ b/bin/vm-agent.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -14,12 +14,7 @@
  *
  */
 
-var fs = require('fs');
-var execFile = require('child_process').execFile;
-
-var assert = require('assert-plus');
 var bunyan = require('bunyan');
-var vasync = require('vasync');
 
 var VmAgent = require('../lib');
 
@@ -31,155 +26,11 @@ var logger = bunyan.createLogger({
 });
 
 
-/*
- * This loads the config file (managed by config-agent) and adds all the
- * key/value pairs to the config object for those keys which do not already
- * exist in config.
- */
-function loadConfig(config, callback) {
-    var _config;
-    var configPath = '/opt/smartdc/agents/etc/vm-agent.config.json';
-
-    assert.object(config);
-    assert.func(callback);
-
-    try {
-        _config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
-    } catch (e) {
-        // not fatal, because we'll attempt to get the config by other means
-        logger.error(e, 'Could not parse agent config: %s', configPath);
-    }
-
-    if (_config) {
-        Object.keys(_config).forEach(function _copyToConfig(key) {
-            // we'll not clobber existing keys, order of precedence can then be
-            // established via ordering of the waterfall.
-            if (!config[key]) {
-                config[key] = _config[key];
-            }
-        });
-    }
-
-    // pass (potentially modified) config to next function in waterfall
-    return callback(null, config);
-}
-
-// If we are unable to read a config-agent managed configuration, then we
-// have to rely on sdc/config.sh to get the VMAPI URL.
-function loadSdcConfig(config, callback) {
-    assert.object(config);
-    assert.func(callback);
-
-    if (config.hasOwnProperty('vmapi_url')) {
-        // we already have the vmapi URL, no need to fallback to config.sh
-        callback(null, config);
-        return;
-    }
-
-    execFile('/bin/bash', ['/lib/sdc/config.sh', '-json'],
-        function _loadConfig(err, stdout, stderr) {
-            var sdcConfig;
-
-            if (err) {
-                logger.fatal(err, 'Could not load sdc config: ' + stderr);
-                return callback(err);
-            }
-
-            try {
-                sdcConfig = JSON.parse(stdout);
-            } catch (e) {
-                logger.fatal(e, 'Could not parse sdc config: ' + e.message);
-                return callback(e);
-            }
-
-            if (sdcConfig.vmapi_domain) {
-                config.vmapi_url = 'http://' + sdcConfig.vmapi_domain;
-            } else {
-                logger.warn('SDC config did not include vmapi_domain');
-            }
-
-            // pass (potentially modified) config to next function in waterfall
-            return callback(null, config);
-        }
-    );
-}
-
-// Load this server's UUID from sysinfo and add to the config.
-function loadSysinfo(config, callback) {
-    var sysinfo;
-
-    assert.object(config);
-    assert.func(callback);
-
-    if (config.hasOwnProperty('server_uuid')) {
-        // already have server_uuid, no need to gather from sysinfo
-        callback(null, config);
-        return;
-    }
-
-    execFile('/usr/bin/sysinfo', [], function _sysinfoCb(err, stdout, stderr) {
-        if (err) {
-            logger.fatal('Could not load sysinfo: ' + stderr.toString());
-            callback(err);
-            return;
-        }
-
-        try {
-            sysinfo = JSON.parse(stdout);
-        } catch (e) {
-            logger.fatal(e, 'Could not parse sysinfo: ' + e.message);
-            callback(e);
-            return;
-        }
-
-        if (!sysinfo.UUID) {
-            logger.fatal('Could not find "UUID" in `sysinfo` output.');
-            callback(new Error('No UUID in `sysinfo`'));
-            return;
-        }
-
-        config.server_uuid = sysinfo.UUID;
-
-        callback(null, config);
-        return;
-    });
-}
-
-/*
- * This waterfall should be ordered by config precedence. Each of the functions
- * will avoid clobbering keys, so the first value loaded by any of these
- * functions for a given key will be the value in the final config object.
- */
-vasync.waterfall([
-    function _createConfig(callback) {
-        var config = {};
-
-        assert.func(callback, 'callback');
-
-        // This first function exists because the first function in the
-        // waterfall is "special" in that it doesn't get a first arg. So all we
-        // do here is create the config the other functions will add to.
-        callback(null, config);
-    },
-    loadConfig,
-    loadSdcConfig,
-    loadSysinfo
-], function _waterfallComplete(err, config) {
-    var vmagent;
-
-    assert.ifError(err, 'Failed to load configuration');
-    assert.object(config, 'config');
-    assert.uuid(config.server_uuid, 'config.server_uuid');
-    assert.string(config.vmapi_url, 'config.vmapi_url');
-    assert.optionalNumber(config.periodic_interval);
-    assert.ok(!config.log, 'config.log must not be set');
-
-    logger.info({config: config}, 'loaded vm-agent configuration');
-
-    // Pass along our logger
-    config.log = logger;
-
-    // Start the agent with our fresh config
-    vmagent = new VmAgent(config);
-    vmagent.start();
+// Start the agent with our fresh config
+var vmagent = new VmAgent({
+    // allow overriding the backend via environment (for testing)
+    backendName: process.env.VM_AGENT_BACKEND,
+    log: logger
 });
+
+vmagent.start();
diff --git a/lib/backend.smartos.js b/lib/backend.smartos.js
new file mode 100644
index 0000000..81f4067
--- /dev/null
+++ b/lib/backend.smartos.js
@@ -0,0 +1,126 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2018, Joyent, Inc.
+ */
+
+/*
+ * This provides the system-specific configuration functions for SmartOS
+ * platforms.
+ */
+
+var fs = require('fs');
+var execFile = require('child_process').execFile;
+
+var assert = require('assert-plus');
+var vasync = require('vasync');
+
+var VM_AGENT_CONFIG = '/opt/smartdc/agents/etc/vm-agent.config.json';
+
+
+function SmartosBackend(opts) {
+    var self = this;
+
+    self.log = opts.log;
+    self.name = opts.backendName;
+}
+
+// Load the configuration, starting with the agent config (managed by
+// config-agent) and then filling in missing data from sysinfo and the SDC
+// config if necessary.
+SmartosBackend.prototype.loadConfig = function loadConfig(callback) {
+    var self = this;
+    var config;
+
+    assert.func(callback);
+
+    vasync.pipeline({funcs: [
+        function _loadAgentConfig(_, cb) {
+            try {
+                config = JSON.parse(fs.readFileSync(VM_AGENT_CONFIG, 'utf-8'));
+            } catch (e) {
+                // not fatal, because we'll attempt to get the config by other
+                // means
+                self.log.error(e, 'Could not parse agent config: %s',
+                    VM_AGENT_CONFIG);
+                cb(e);
+                return;
+            }
+
+            cb();
+        }, function _loadSdcConfig(_, cb) {
+            // If vm-agent config didn't include vmapi_url, we'll attempt to
+            // figure that out from SDC config.
+            if (config.vmapi_url) {
+                cb();
+                return;
+            }
+
+            execFile('/bin/bash', ['/lib/sdc/config.sh', '-json'],
+                function _loadConfig(err, stdout, stderr) {
+                    var sdcConfig;
+
+                    if (err) {
+                        self.log.fatal(err, 'Could not load sdc config: '
+                            + stderr);
+                        cb(err);
+                        return;
+                    }
+
+                    try {
+                        sdcConfig = JSON.parse(stdout);
+                    } catch (e) {
+                        self.log.fatal(e, 'Could not parse sdc config: '
+                            + e.message);
+                        cb(e);
+                        return;
+                    }
+
+                    config.vmapi_url = 'http://' + sdcConfig.vmapi_domain;
+
+                    cb();
+                }
+            );
+        }, function _loadSysinfo(_, cb) {
+            // If vm-agent config didn't include a server_uuid, get that from
+            // sysinfo.
+            if (config.server_uuid) {
+                cb();
+                return;
+            }
+
+            execFile('/usr/bin/sysinfo', [],
+                function _sysinfoCb(err, stdout, stderr) {
+                    var sysinfo;
+
+                    if (err) {
+                        self.log.fatal('Could not load sysinfo: '
+                            + stderr.toString());
+                        cb(err);
+                        return;
+                    }
+
+                    try {
+                        sysinfo = JSON.parse(stdout);
+                    } catch (e) {
+                        self.log.fatal(e, 'Could not parse sysinfo: '
+                            + e.message);
+                        cb(e);
+                        return;
+                    }
+
+                    config.server_uuid = sysinfo.UUID;
+                    cb();
+                }
+            );
+        }
+    ]}, function _afterPipeline(err) {
+        callback(err, config);
+    });
+};
+
+module.exports = SmartosBackend;
diff --git a/lib/vm-agent.js b/lib/vm-agent.js
index c093e15..f99cbce 100644
--- a/lib/vm-agent.js
+++ b/lib/vm-agent.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 /*
@@ -115,6 +115,7 @@
  */
 
 var fs = require('fs');
+var os = require('os');
 var path = require('path');
 
 var assert = require('assert-plus');
@@ -139,19 +140,46 @@ var INITIAL_UPDATE_DELAY_MS = 500;
 var MAX_UPDATE_DELAY_MS = 30000;
 
 
+// Helper: loads ./backend.<backendName>
+function loadBackend(opts) {
+    var Backend;
+    var backendName = os.platform();
+
+    assert.object(opts, 'opts');
+    assert.object(opts.log, 'opts.log');
+
+    if (opts.backendName) {
+        // allow overriding the backend (useful for testing)
+        backendName = opts.backendName;
+    } else if (backendName === 'sunos') {
+        backendName = 'smartos';
+    }
+
+    // This will throw if backend doesn't exist
+    // eslint-disable-next-line
+    Backend = require(path.join(__dirname, 'backend.' + backendName));
+
+    // Backends should set self.name = opts.backendName.
+    opts.backendName = backendName;
+
+    return (new Backend(opts));
+}
+
+
 function VmAgent(options) {
     var self = this;
-    var agent;
     var packageJson = path.join(path.dirname(__dirname), 'package.json');
-    var userAgent;
 
     assert.object(options, 'options');
     assert.object(options.log, 'options.log');
-    assert.optionalNumber(options.periodic_interval,
-        'options.periodic_interval');
-    assert.uuid(options.server_uuid, 'options.server_uuid');
-    assert.string(options.vmapi_url, 'options.vmapi_url');
-    assert.optionalObject(options.cueballHttpAgent, 'options.cueballHttpAgent');
+    assert.optionalString(options.backendName, 'options.backendName');
+
+    if (options.backend) {
+        self.backend = options.backend;
+    } else {
+        self.backend = loadBackend(options);
+    }
+    assert.object(self.backend, 'self.backend');
 
     // Load the list of fields that VmWatcher will be watching, which we'll
     // use when comparing objects. Since VMAPI and vmadm have different default
@@ -165,31 +193,11 @@ function VmAgent(options) {
         self.comparisonFields.push('boot_timestamp');
     }
 
-    if (options.periodic_interval) {
-        self.periodicInterval = options.periodic_interval;
-    }
-
     self.log = options.log;
-    self.server_uuid = options.server_uuid;
-    self.version = JSON.parse(fs.readFileSync(packageJson)).version;
 
+    self.version = JSON.parse(fs.readFileSync(packageJson)).version;
     assert(self.version, 'missing package.json version');
 
-    if (options.cueballHttpAgent) {
-        agent = new cueball.HttpAgent(options.cueballHttpAgent);
-    }
-
-    userAgent = 'vm-agent/' + self.version
-        + ' (node/' + process.versions.node + ')'
-        + ' server/' + self.server_uuid;
-
-    self.vmapiClient = new VMAPI({
-        agent: agent,
-        log: options.log,
-        url: options.vmapi_url,
-        userAgent: userAgent
-    });
-
     // Now setup the properties that we can reset later (on .stop() for example)
     self.initializeProperties();
 }
@@ -842,8 +850,47 @@ VmAgent.prototype.start = function start(callback) {
 
     assert.optionalFunc(callback, 'callback');
 
-    vasync.pipeline({arg: {}, funcs: [
-        function _setupWatcher(stash, cb) {
+    self.log.info('vm-agent starting with backend "' + self.backend.name + '"');
+
+    vasync.pipeline({funcs: [
+        function _loadConfig(_, cb) {
+            self.backend.loadConfig(function _onConfig(err, config) {
+                var agent;
+                var userAgent;
+
+                assert.ifError(err, 'Failed to load configuration');
+                assert.object(config, 'config');
+                assert.uuid(config.server_uuid, 'config.server_uuid');
+                assert.string(config.vmapi_url, 'config.vmapi_url');
+                assert.optionalNumber(config.periodic_interval,
+                    'config.periodic_interval');
+                assert.optionalObject(config.cueballHttpAgent,
+                    'config.cueballHttpAgent');
+
+                self.log.info({config: config},
+                    'loaded vm-agent configuration');
+
+                self.periodicInterval = config.periodic_interval;
+                self.server_uuid = config.server_uuid;
+
+                if (config.cueballHttpAgent) {
+                    agent = new cueball.HttpAgent(config.cueballHttpAgent);
+                }
+
+                userAgent = 'vm-agent/' + self.version
+                    + ' (node/' + process.versions.node + ')'
+                    + ' server/' + self.server_uuid;
+
+                self.vmapiClient = new VMAPI({
+                    agent: agent,
+                    log: self.log,
+                    url: config.vmapi_url,
+                    userAgent: userAgent
+                });
+
+                cb();
+            });
+        }, function _setupWatcher(_, cb) {
             // initialize the watcher if we've not already done so
             if (self.watcher) {
                 cb();
@@ -851,7 +898,7 @@ VmAgent.prototype.start = function start(callback) {
             }
 
             self.setupWatcher(cb);
-        }, function _initialUpdate(stash, cb) {
+        }, function _initialUpdate(_, cb) {
             var startUpdate = (new Date()).getTime();
 
             function _doInitialUpdate() {
diff --git a/tests/mocks.js b/tests/mocks.js
index 2c7567c..a887dad 100644
--- a/tests/mocks.js
+++ b/tests/mocks.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var util = require('util');
@@ -363,6 +363,21 @@ fakeVmWatcher.prototype.stop = function stop() {
 fakeVmWatcher.WATCHED_FIELDS = VmWatcher.WATCHED_FIELDS;
 
 
+function fakeBackend(opts) {
+    var self = this;
+
+    self.config = opts.config;
+    self.log = opts.log;
+    self.name = 'fakeBackend';
+}
+
+fakeBackend.prototype.loadConfig = function loadConfig(callback) {
+    var self = this;
+
+    callback(null, self.config);
+};
+
+
 // Anything tests should do between runs to cleanup should go in resetState().
 function resetState() {
     coordinator.removeAllListeners();
@@ -374,6 +389,7 @@ function resetState() {
 }
 
 module.exports = {
+    backend: fakeBackend,
     coordinator: coordinator,
     Logger: Logger,
     resetState: resetState,
diff --git a/tests/test.VmAgentMockVmadm.js b/tests/test.VmAgentMockVmadm.js
index 8469442..b358bd1 100644
--- a/tests/test.VmAgentMockVmadm.js
+++ b/tests/test.VmAgentMockVmadm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var assert = require('assert-plus');
@@ -59,11 +59,17 @@ function createVm(template, properties) {
 }
 
 function newConfig() {
-    var config = {
-        log: mocks.Logger,
-        server_uuid: node_uuid.v4(),
-        vmapi_url: 'http://127.0.0.1/'
-    };
+    var config = {};
+
+    config.log = mocks.Logger;
+    config.server_uuid = node_uuid.v4();
+    config.backend = new mocks.backend({
+        config: {
+            server_uuid: config.server_uuid,
+            vmapi_url: 'http://127.0.0.1/'
+        },
+        log: config.log
+    });
 
     return (config);
 }
diff --git a/tests/test.VmAgentRealVmadm.js b/tests/test.VmAgentRealVmadm.js
index 438f5db..2f90167 100644
--- a/tests/test.VmAgentRealVmadm.js
+++ b/tests/test.VmAgentRealVmadm.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright (c) 2018, Joyent, Inc.
  */
 
 var execFile = require('child_process').execFile;
@@ -46,12 +46,18 @@ mockery.disable();
 
 
 function newConfig() {
-    var config = {
-        log: mocks.Logger,
-        server_uuid: node_uuid.v4(),
-        periodic_interval: PERIODIC_INTERVAL_MS,
-        vmapi_url: 'http://127.0.0.1/'
-    };
+    var config = {};
+
+    config.log = mocks.Logger;
+    config.server_uuid = node_uuid.v4();
+    config.backend = new mocks.backend({
+        config: {
+            periodic_interval: PERIODIC_INTERVAL_MS,
+            server_uuid: config.server_uuid,
+            vmapi_url: 'http://127.0.0.1/'
+        },
+        log: config.log
+    });
 
     return (config);
 }
-- 
2.21.0

