From f9e239ad7b86c64185b0d969ec778d53664f92f0 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Wed, 13 Jul 2016 19:22:57 +0000
Subject: [PATCH] OS-5482 SIGAR cannot report disk I/O Reviewed by: Patrick
 Mooney <patrick.mooney@joyent.com>

---
 .../lib/brand/lx/zone/lx_boot_zone_ubuntu.ksh |  2 +-
 .../uts/common/brand/lx/devfs/lxd_vfsops.c    |  3 ++
 usr/src/uts/common/brand/lx/syscall/lx_stat.c | 44 +++++++++++++++++--
 3 files changed, 45 insertions(+), 4 deletions(-)

diff --git a/usr/src/lib/brand/lx/zone/lx_boot_zone_ubuntu.ksh b/usr/src/lib/brand/lx/zone/lx_boot_zone_ubuntu.ksh
index 2d664be89d..1353e38201 100644
--- a/usr/src/lib/brand/lx/zone/lx_boot_zone_ubuntu.ksh
+++ b/usr/src/lib/brand/lx/zone/lx_boot_zone_ubuntu.ksh
@@ -122,7 +122,7 @@ emits filesystem
 emits mounted
 
 script
-    echo "$ROOTDEV / zfs rw 0 0" > /etc/mtab
+    echo "/dev/zfds0 / zfs rw 0 0" > /etc/mtab
     echo "proc /proc proc rw,noexec,nosuid,nodev 0 0" >> /etc/mtab
 
     /sbin/initctl emit --no-wait virtual-filesystems
diff --git a/usr/src/uts/common/brand/lx/devfs/lxd_vfsops.c b/usr/src/uts/common/brand/lx/devfs/lxd_vfsops.c
index b6c65c8b3b..b550bf6954 100644
--- a/usr/src/uts/common/brand/lx/devfs/lxd_vfsops.c
+++ b/usr/src/uts/common/brand/lx/devfs/lxd_vfsops.c
@@ -516,6 +516,9 @@ lxd_mount(vfs_t *vfsp, vnode_t *mvp, struct mounta *uap, cred_t *cr)
 		vd = list_next(lxzdata->lxzd_vdisks, vd);
 	}
 
+	/* Create a symlink for the root "disk" using /dev/zfs as the device */
+	(void) lxd_symlink(LDNTOV(ldn), "zfds0", &vattr, "./zfs", cr, NULL, 0);
+
 	/* Apply any persistent attribute changes. */
 	lxd_apply_db(lxdm);
 
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_stat.c b/usr/src/uts/common/brand/lx/syscall/lx_stat.c
index 2ec8a4542d..dbeb02a057 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_stat.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_stat.c
@@ -114,14 +114,50 @@ static void
 lx_stat_xlate_dev(vattr_t *vattr)
 {
 	lx_zone_data_t *lxzd = ztolxzd(curproc->p_zone);
-	dev_t dev = vattr->va_fsid;
+	dev_t dev;
 	lx_virt_disk_t *vd;
+	boolean_t is_dev, is_zfds;
 
-	/* Substitute emulated major/minor on mounted datasets */
+#define	DEV_MATCH(v, d)	(is_zfds ? \
+	    (strcmp((v)->lxvd_name, "zfsds0") == 0) : \
+	    ((v)->lxvd_real_dev == d))
+
+	if (S_ISCHR(vattr->va_mode) || S_ISBLK(vattr->va_mode)) {
+		dev = vattr->va_rdev;
+		is_dev = B_TRUE;
+	} else {
+		dev = vattr->va_fsid;
+		is_dev = B_FALSE;
+	}
+
+	/*
+	 * See if this is the /dev/zfs device. If it is, the device number has
+	 * already been converted to Linux format in the lx devfs so we have
+	 * to check for that and not a native major/minor style.
+	 */
+	if (S_ISCHR(vattr->va_mode) &&
+	    LX_GETMAJOR(dev) == getmajor(lxzd->lxzd_zfs_dev) &&
+	    LX_GETMINOR(dev) == 0) {
+		/*
+		 * We use the /dev/zfs device as a placeholder for our in-zone
+		 * fabricated /dev/zfds0 device that we're pretending / is
+		 * mounted on. lx_zone_get_zfsds has pre-allocated this
+		 * entry in the emulated device list.
+		 */
+		is_zfds = B_TRUE;
+	} else {
+		is_zfds = B_FALSE;
+	}
+
+	/* Substitute emulated major/minor on zvols or mounted datasets. */
 	vd = list_head(lxzd->lxzd_vdisks);
 	while (vd != NULL) {
-		if (vd->lxvd_real_dev == dev) {
+		if (DEV_MATCH(vd, dev)) {
 			dev = vd->lxvd_emul_dev;
+			if (is_dev) {
+				vattr->va_rdev = LX_MAKEDEVICE(getmajor(dev),
+				    getminor(dev));
+			}
 			break;
 		}
 		vd = list_next(lxzd->lxzd_vdisks, vd);
@@ -129,6 +165,8 @@ lx_stat_xlate_dev(vattr_t *vattr)
 
 	/* Mangle st_dev into expected format */
 	vattr->va_fsid = LX_MAKEDEVICE(getmajor(dev), getminor(dev));
+
+#undef	DEV_MATCH
 }
 
 static long
-- 
2.21.0

