commit a075e69fe0419936a3c70685c970e0c93f7f73a2 (refs/changes/86/2186/1)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-07-05T16:50:06-07:00 (2 years, 3 months ago)
    
    joyent/node-zkstream#19 drop eventemitter request API
    joyent/node-zkstream#20 add 'session' event as well as 'connect' to keep track of new sessions

diff --git a/README.md b/README.md
index cc077ff..1821fc5 100644
--- a/README.md
+++ b/README.md
@@ -26,6 +26,11 @@ Parameters:
 
 ### Events
 
+#### `session`
+
+Emitted when the client establishes a new session with the ZK server. Will
+generally be followed immediately by a `connect` event.
+
 #### `connect`
 
 Emitted when the client successfully connects to a ZooKeeper server, either
@@ -65,7 +70,7 @@ Parameters
  - `cb`: an optional Function `(err, children)` with parameters:
    - `children`: an Array of Strings
 
-Returns a request emitter (see below).
+
 
 ### `Client#stat(path[, cb])`
 
@@ -84,7 +89,7 @@ Parameters
      - `ephemeralOwner`: a Buffer, ID of connection that owns this node
                          if it is ephemeral
 
-Returns a request emitter (see below).
+
 
 ### `Client#get(path[, cb])`
 
@@ -96,7 +101,7 @@ Parameters
    - `data`: a Buffer
    - `stat`: an Object, same format as `stat` in `Client#stat`
 
-Returns a request emitter (see below).
+
 
 ### `Client#delete(path, version[, cb])`
 
@@ -107,7 +112,7 @@ Parameters
  - `version`: a Number, latest version to check against
  - `cb`: an optional Function `(err)`
 
-Returns a request emitter (see below).
+
 
 ### `Client#create(path, data[, options[, cb]])`
 
@@ -122,7 +127,7 @@ Parameters
    - `acl`: an optional Array of ACL objects
  - `cb`: an optional Function `(err)`
 
-Returns a request emitter (see below).
+
 
 ### `Client#set(path, data, version[, cb])`
 
@@ -135,7 +140,7 @@ Parameters
  - `version`: a Number, version number as returned from `Client#stat`
  - `cb`: an optional Function `(err)`
 
-Returns a request emitter (see below).
+
 
 ### `Client#sync(path[, cb])`
 
@@ -146,7 +151,7 @@ Parameters
  - `path`: a String, path to the node
  - `cb`: an optional Function `(err)`
 
-Returns a request emitter (see below).
+
 
 ### `Client#watcher(path)`
 
@@ -194,15 +199,6 @@ Parameters
  - `cb`: a Function `(children)` with arguments:
    - `children`: an Array of Strings
 
-## Request emitters
-
-An interface returned by most functions on Client. A subclass of EventEmitter,
-emits the following events:
-
- - `'reply'` `(pkt)`: emitted when a reply to this request is received.
-                      Argument is the decoded ZooKeeper protocol packet.
- - `'error'` `(err)`: emitted when the request fails
-
 ## ACL objects
 
 Some methods return or take ACL objects as a parameter. These are plain
diff --git a/lib/client.js b/lib/client.js
index 2a5a3eb..099d65c 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -175,40 +175,52 @@ ZKClient.prototype._newSession = function () {
 		if (st === 'attached') {
 			s.removeListener('stateChanged', initialHandler);
 			s.on('stateChanged', finalHandler);
-
-			/*
-			 * This is a bit yucky, but we don't want to emit
-			 * 'connect' until someone can safely call .list() or
-			 * similar functions on us.
-			 *
-			 * So we have to sync up with the ConnectionFSM here,
-			 * as well as the ZKSession.
-			 */
-			var c = s.getConnection();
-			if (c.isInState('connected')) {
-				setImmediate(function () {
-					self.emit('connect');
-				});
-			} else {
-				c.on('stateChanged', onConnCh);
-				function onConnCh(cst) {
-					if (cst === 'connected') {
-						c.removeListener(
-						    'stateChanged', onConnCh);
-						self.emit('connect');
-					}
-				}
-			}
+			self._emitAfterConnected('session');
+			self._emitAfterConnected('connect');
 		}
 	}
 	function finalHandler(st) {
-		if (st === 'expired') {
+		if (st === 'attached') {
+			self._emitAfterConnected('connect');
+		} else if (st === 'detached') {
+			self.emit('disconnect');
+		} else if (st === 'expired') {
 			self.emit('expire');
 		}
 	}
 	this.zc_session.on('stateChanged', initialHandler);
 };
 
+ZKClient.prototype.isConnected = function () {
+	var conn = this.getConnection();
+	return (conn !== undefined && conn.isInState('connected'));
+};
+
+ZKClient.prototype._emitAfterConnected = function (evt) {
+	/*
+	 * We don't want to emit 'connect' until someone can safely call
+	 * .list() or similar functions on us.
+	 *
+	 * So we have to sync up with the ConnectionFSM here.
+	 */
+	var self = this;
+	var c = this.currentConnection();
+	if (c.isInState('connected')) {
+		setImmediate(function () {
+			self.emit(evt);
+		});
+	} else {
+		c.on('stateChanged', onConnCh);
+		function onConnCh(cst) {
+			if (cst === 'connected') {
+				c.removeListener(
+				    'stateChanged', onConnCh);
+				self.emit(evt);
+			}
+		}
+	}
+};
+
 ZKClient.prototype.getSession = function () {
 	if (!this.isInState('normal'))
 		return (undefined);
@@ -268,49 +280,47 @@ ZKClient.prototype.ping = function (cb) {
 
 ZKClient.prototype.list = function (path, cb) {
 	mod_assert.string(path, 'path');
-	mod_assert.optionalFunc(cb, 'callback');
+	mod_assert.func(cb, 'callback');
 	var conn = this.currentConnection();
-	if (conn === undefined)
-		throw (new Error('Not connected to ZooKeeper'));
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
 	var req = conn.request({
 		opcode: 'GET_CHILDREN2',
 		path: path,
 		watch: false
 	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.children, pkt.stat);
-		});
-		req.once('error', cb);
-	}
-	return (req);
+	req.once('reply', function onReply(pkt) {
+		cb(null, pkt.children, pkt.stat);
+	});
+	req.once('error', cb);
 };
 
 ZKClient.prototype.get = function (path, cb) {
 	mod_assert.string(path, 'path');
-	mod_assert.optionalFunc(cb, 'callback');
+	mod_assert.func(cb, 'callback');
 	var conn = this.currentConnection();
-	if (conn === undefined)
-		throw (new Error('Not connected to ZooKeeper'));
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
 	var req = conn.request({
 		opcode: 'GET_DATA',
 		path: path,
 		watch: false
 	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.data, pkt.stat);
-		});
-		req.once('error', cb);
-	}
-	return (req);
+	req.once('reply', function onReply(pkt) {
+		cb(null, pkt.data, pkt.stat);
+	});
+	req.once('error', cb);
 };
 
 ZKClient.prototype.create = function (path, data, options, cb) {
 	mod_assert.string(path, 'path');
 	mod_assert.buffer(data, 'data');
 	mod_assert.optionalObject(options, 'options');
-	mod_assert.optionalFunc(cb, 'callback');
+	mod_assert.func(cb, 'callback');
 	if (options === undefined || options === null)
 		options = {};
 	mod_assert.optionalArrayOfObject(options.acl, 'options.acl');
@@ -328,8 +338,10 @@ ZKClient.prototype.create = function (path, data, options, cb) {
 	}
 
 	var conn = this.currentConnection();
-	if (conn === undefined)
-		throw (new Error('Not connected to ZooKeeper'));
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
 	var req = conn.request({
 		opcode: 'CREATE',
 		path: path,
@@ -337,103 +349,96 @@ ZKClient.prototype.create = function (path, data, options, cb) {
 		acl: options.acl,
 		flags: options.flags
 	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.path);
-		});
-		req.once('error', cb);
-	}
-	return (req);
+	req.once('reply', function onReply(pkt) {
+		cb(null, pkt.path);
+	});
+	req.once('error', cb);
 };
 
 ZKClient.prototype.set = function (path, data, version, cb) {
 	mod_assert.string(path, 'path');
 	mod_assert.buffer(data, 'data');
 	mod_assert.optionalNumber(version, 'version');
-	mod_assert.optionalFunc(cb, 'callback');
+	mod_assert.func(cb, 'callback');
 
 	if (version === undefined || version === null)
 		version = -1;
 
 	var conn = this.currentConnection();
-	if (conn === undefined)
-		throw (new Error('Not connected to ZooKeeper'));
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
 	var req = conn.request({
 		opcode: 'SET_DATA',
 		path: path,
 		data: data,
 		version: version
 	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.path);
-		});
-		req.once('error', cb);
-	}
-	return (req);
+	req.once('reply', function onReply(pkt) {
+		cb(null, pkt.path);
+	});
+	req.once('error', cb);
 };
 
 ZKClient.prototype.delete = function (path, version, cb) {
 	mod_assert.string(path, 'path');
 	mod_assert.number(version, 'version');
-	mod_assert.optionalFunc(cb, 'callback');
+	mod_assert.func(cb, 'callback');
 
 	var conn = this.currentConnection();
-	if (conn === undefined)
-		throw (new Error('Not connected to ZooKeeper'));
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
 	var req = conn.request({
 		opcode: 'DELETE',
 		path: path,
 		version: version
 	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null);
-		});
-		req.once('error', cb);
-	}
-	return (req);
+	req.once('reply', function onReply(pkt) {
+		cb(null);
+	});
+	req.once('error', cb);
 };
 
 ZKClient.prototype.stat = function (path, cb) {
 	mod_assert.string(path, 'path');
-	mod_assert.optionalFunc(cb, 'callback');
+	mod_assert.func(cb, 'callback');
 
 	var conn = this.currentConnection();
-	if (conn === undefined)
-		throw (new Error('Not connected to ZooKeeper'));
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
 	var req = conn.request({
 		opcode: 'EXISTS',
 		path: path,
 		watch: false
 	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null, pkt.stat);
-		});
-		req.once('error', cb);
-	}
-	return (req);
+	req.once('reply', function onReply(pkt) {
+		cb(null, pkt.stat);
+	});
+	req.once('error', cb);
 };
 
 ZKClient.prototype.sync = function (path, cb) {
 	mod_assert.string(path, 'path');
-	mod_assert.optionalFunc(cb, 'callback');
+	mod_assert.func(cb, 'callback');
 
 	var conn = this.currentConnection();
-	if (conn === undefined)
-		throw (new Error('Not connected to ZooKeeper'));
+	if (conn === undefined || !conn.isInState('connected')) {
+		setImmediate(cb, new mod_errors.ZKNotConnectedError());
+		return;
+	}
 	var req = conn.request({
 		opcode: 'SYNC',
 		path: path
 	});
-	if (cb) {
-		req.once('reply', function onReply(pkt) {
-			cb(null);
-		});
-		req.once('error', cb);
-	}
-	return (req);
+	req.once('reply', function onReply(pkt) {
+		cb(null);
+	});
+	req.once('error', cb);
 };
 
 ZKClient.prototype.watcher = function (path) {
diff --git a/lib/connection-fsm.js b/lib/connection-fsm.js
index 4d21973..cfdcdef 100644
--- a/lib/connection-fsm.js
+++ b/lib/connection-fsm.js
@@ -53,7 +53,8 @@ ZKConnectionFSM.prototype.connect = function () {
 };
 
 ZKConnectionFSM.prototype.close = function () {
-	mod_assert.ok(!this.isInState('closed'));
+	if (this.isInState('closed'))
+		return;
 	this.emit('closeAsserted');
 };
 
diff --git a/lib/errors.js b/lib/errors.js
index d34323b..fba6f06 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -9,7 +9,8 @@
 module.exports = {
 	ZKProtocolError: ZKProtocolError,
 	ZKError: ZKError,
-	ZKPingTimeoutError: ZKPingTimeoutError
+	ZKPingTimeoutError: ZKPingTimeoutError,
+	ZKNotConnectedError: ZKNotConnectedError
 };
 
 const mod_assert = require('assert-plus');
@@ -32,6 +33,15 @@ function ZKPingTimeoutError() {
 }
 mod_util.inherits(ZKPingTimeoutError, ZKProtocolError);
 
+function ZKNotConnectedError() {
+	if (Error.captureStackTrace)
+		Error.captureStackTrace(this, ZKNotConnectedError);
+	ZKProtocolError.call(this, 'CONNECTION_LOSS',
+	    'The ZooKeeper client is not currently connected and cannot ' +
+	    'accept new requests.');
+}
+mod_util.inherits(ZKNotConnectedError, ZKProtocolError);
+
 function ZKError(code, msg) {
 	if (Error.captureStackTrace)
 		Error.captureStackTrace(this, ZKError);
diff --git a/package.json b/package.json
index 4b96f4c..a9d8f23 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "zkstream",
-  "version": "0.8.2",
+  "version": "0.9.0",
   "description": "",
   "main": "lib/index.js",
   "dependencies": {
diff --git a/test/basic.test.js b/test/basic.test.js
index f6b92d5..1479e88 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -168,26 +168,16 @@ mod_tape.test('find the test object', function (t) {
 	});
 
 	zkc.on('connect', function () {
-		var req = zkc.list('/');
-		req.once('reply', function (pkt) {
-			t.strictEqual(pkt.opcode, 'GET_CHILDREN2');
-			t.deepEqual(pkt.children.sort(), ['foo', 'zookeeper']);
-
-			var req2 = zkc.get('/foo');
-			req2.once('reply', function (pkt2) {
-				t.strictEqual(
-				    pkt2.data.toString('ascii'), 'hi');
-				zkc.close();
-			});
-			req2.once('error', function (err) {
-				t.error(err);
+		zkc.list('/', function (err, kids, stat) {
+			t.error(err);
+			t.deepEqual(kids.sort(), ['foo', 'zookeeper']);
+
+			zkc.get('/foo', function (err2, data) {
+				t.error(err2);
+				t.strictEqual(data.toString('ascii'), 'hi');
 				zkc.close();
 			});
 		});
-		req.once('error', function (err) {
-			t.error(err);
-			zkc.close();
-		});
 	});
 });
 
@@ -222,12 +212,7 @@ mod_tape.test('ask for a non-existent node', function (t) {
 	});
 
 	zkc.on('connect', function () {
-		var req = zkc.stat('/foo');
-		req.once('reply', function (pkt) {
-			t.fail('Expected an error');
-			zkc.close();
-		});
-		req.once('error', function (err) {
+		zkc.stat('/foo', function (err, stat) {
 			t.ok(err);
 			t.strictEqual(err.code, 'NO_NODE');
 			zkc.close();
@@ -502,7 +487,15 @@ mod_tape.test('session resumption with watcher', function (t) {
 		port: 2181
 	});
 
+	var ev1 = [];
+	zkc1.on('connect', ev1.push.bind(ev1, 'connect'));
+	zkc1.on('session', ev1.push.bind(ev1, 'session'));
+	zkc1.on('expire', ev1.push.bind(ev1, 'expire'));
+	zkc1.on('disconnect', ev1.push.bind(ev1, 'disconnect'));
+
 	zkc1.on('close', function () {
+		t.deepEqual(ev1,
+		    ['session', 'connect', 'disconnect', 'connect']);
 		if (++closed >= 2)
 			t.end();
 	});
