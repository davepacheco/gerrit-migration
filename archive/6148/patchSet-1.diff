From 233e260eac9a009f5319445af7fafad8e786a89d Mon Sep 17 00:00:00 2001
From: Marsell Kukuljevic <marsell@joyent.com>
Date: Tue, 23 Apr 2019 17:44:17 +0200
Subject: [PATCH] TRITON-1387 node-triton's startMachineFromSnapshot and
 deleteMachine calls do not handle -w correctly

---
 CHANGES.md                             |   3 +
 lib/cloudapi2.js                       |  87 ++++++++++++-
 lib/do_instance/gen_do_ACTION.js       | 174 ++++++++++++++++++-------
 lib/tritonapi.js                       |  67 +---------
 test/integration/cli-snapshots.test.js |   1 -
 5 files changed, 221 insertions(+), 111 deletions(-)

diff --git a/CHANGES.md b/CHANGES.md
index 925b040..2eed2a0 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -6,6 +6,9 @@ Known issues:
 
 ## not yet released
 
+- [TRITON-1387] Fixed -w so it works properly with both instance deletion and
+  starting with a snapshot. Also added support for --with-timeout to both.
+
 ## 7.0.2
 
 - [TRITON-1347] Changing to node-tap as the test runner. Also some
diff --git a/lib/cloudapi2.js b/lib/cloudapi2.js
index b5fb949..8695814 100644
--- a/lib/cloudapi2.js
+++ b/lib/cloudapi2.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  *
  * Client library for the SmartDataCenter Cloud API (cloudapi).
  * http://apidocs.joyent.com/cloudapi/
@@ -1532,6 +1532,91 @@ CloudApi.prototype.machineAudit = function machineAudit(id, cb) {
 };
 
 
+/**
+ * Wait (poll) until a specific action completes, whether successfully or not.
+ *
+ * @param {Object} opts
+ *      - id {UUID} Required. The machine id.
+ *      - action {String} Required. Action to wait on for completion.
+ *      - minAge {Number} Required. Minimum timestamp that the completed job
+ *            could be in milliseconds since Epoch.
+ *      - waitTimeout {Number} Optional. How long to wait for completion in
+ *            milliseconds.
+ * @param {Function} callback of the form `function (err)`
+ */
+CloudApi.prototype.waitForAudit = function waitForAudit(opts, cb) {
+    assert.uuid(opts.id, 'opts.id');
+    assert.string(opts.action, 'opts.string');
+    assert.number(opts.minAge, 'opts.minAge');
+    assert.optionalNumber(opts.waitTimeout, 'opts.waitTimeout');
+    assert.func(cb, 'cb');
+
+    var self = this;
+    var id = opts.id;
+    var minAge = opts.minAge;
+    var action = opts.action;
+    var POLL_INTERVAL = 2 * 1000; // in ms
+    var startTime = process.hrtime();
+
+    function randrange(min, max) {
+        return Math.floor(Math.random() * (max - min + 1)) + min;
+    }
+
+    function pollMachineAudit() {
+        self.machineAudit(id, function pollCb(err, audit) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            // Search the top few audit records, in case some other action
+            // slipped in.
+            var theRecord = null;
+            for (var i = 0; i < audit.length; i++) {
+                var rec = audit[i];
+                if (rec.action === action && Date.parse(rec.time) > minAge) {
+                    theRecord = rec;
+                    break;
+                }
+            }
+
+            if (!theRecord) {
+                if (opts.waitTimeout) {
+                    var elapsedMs = common.monotonicTimeDiffMs(startTime);
+
+                    if (elapsedMs > opts.waitTimeout) {
+                        cb(new errors.TimeoutError(format('timeout waiting ' +
+                           'for instance %s %s (elapsed %ds)',
+                           id,
+                           action,
+                           Math.round(elapsedMs / 1000))));
+                        return;
+                    }
+                }
+
+                setTimeout(pollMachineAudit, POLL_INTERVAL);
+            } else if (theRecord.success !== 'yes') {
+                cb(new errors.TritonError(format(
+                    '%s failed (audit id %s)', action, theRecord.id)));
+            } else {
+                cb();
+            }
+         });
+    }
+
+
+    self.log.trace({id: id, minAge: minAge},
+                   'wait for ' + action + ' audit record');
+
+    /*
+     * Add a random start delay to avoid a number of concurrent reboots
+     * all polling at the same time.
+     */
+    setTimeout(pollMachineAudit, (POLL_INTERVAL / 2) +
+               randrange(0, POLL_INTERVAL));
+};
+
+
 /**
  * Wait for a machine's `firewall_enabled` field to go true/false.
  *
diff --git a/lib/do_instance/gen_do_ACTION.js b/lib/do_instance/gen_do_ACTION.js
index 41ed069..f327e81 100644
--- a/lib/do_instance/gen_do_ACTION.js
+++ b/lib/do_instance/gen_do_ACTION.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  *
  * Shared support for:
  * `triton instance start ...`
@@ -15,6 +15,7 @@
 
 var assert = require('assert-plus');
 var vasync = require('vasync');
+var format = require('util').format;
 
 var common = require('../common');
 var errors = require('../errors');
@@ -76,6 +77,16 @@ function gen_do_ACTION(opts) {
         });
     }
 
+    if (action === 'start' || action === 'delete') {
+        do_ACTION.options.push({
+            names: ['wait-timeout'],
+            type: 'positiveInteger',
+            default: 120,
+            help: 'The number of seconds to wait before timing out with an '
+                + 'error. The default is 120 seconds.'
+        });
+    }
+
     return do_ACTION;
 }
 
@@ -120,79 +131,146 @@ function _doTheAction(action, subcmd, opts, args, callback) {
 
 function _doOnEachInstance(self, action, command, state, instances,
                            opts, callback) {
+    var tritonapi = self.top.tritonapi;
+    var cloudapi = tritonapi.cloudapi;
     var now = Date.now();
+
     vasync.forEachParallel({
         func: function (arg, cb) {
             var alias, uuid;
             if (common.isUUID(arg)) {
                 uuid = arg;
-                done();
-            } else {
-                self.top.tritonapi.getInstance(arg, function (err, inst) {
-                    if (err) {
-                        perror(err);
-                        cb(err);
-                        return;
-                    }
-                    alias = arg;
-                    uuid = inst.id;
-                    done();
-                });
+                doAction();
+                return;
             }
 
+            tritonapi.getInstance(arg, function getInstCb(err, inst) {
+                if (err) {
+                    perror(err);
+                    cb(err);
+                    return;
+                }
+
+                alias = arg;
+                uuid = inst.id;
+                doAction();
+            });
+
             // called when "uuid" is set
-            function done() {
+            function doAction() {
                 var cOpts = uuid;
+                var wait = waitOnState;
+
                 if (command === 'startMachineFromSnapshot') {
                     cOpts = { id: uuid, name: opts.snapshot };
+                    wait = waitOnJob;
+                } else if (command === 'deleteMachine') {
+                    wait = waitOnJob;
                 }
 
-                self.top.tritonapi.cloudapi[command](cOpts,
-                    function (err, body, res) {
+                cloudapi[command](cOpts, function commandCb(err, body, res) {
+                    if (err) {
+                        perror(err);
+                        cb(err);
+                        return;
+                    }
+
+                    res = res || body; // delete callbacks return (err, res)
+                    if (opts.wait) {
+                        wait(res.headers['date'],
+                             res.headers['request-id'],
+                             opts.wait_timeout);
+                        return;
+                    }
+
+                    var actionStr = common.capitalize(action);
+                    if (alias)
+                        console.log('%s (async) instance %s (%s)', actionStr,
+                            alias, uuid);
+                    else
+                        console.log('%s (async) instance %s', actionStr, uuid);
+                    cb();
+                });
+            }
 
+            function waitOnState(dateHeader, reqId, waitTimeout) {
+                cloudapi.waitForMachineStates({
+                    id: uuid,
+                    states: [state]
+                }, function waitMachineCb(err, inst, res) {
                     if (err) {
                         perror(err);
                         cb(err);
                         return;
                     }
 
-                    if (!opts.wait) {
-                        if (alias)
-                            console.log('%s (async) instance %s (%s)',
-                                common.capitalize(action), alias, uuid);
-                        else
-                            console.log('%s (async) instance %s',
-                                common.capitalize(action), uuid);
-                        cb();
+                    report();
+               });
+            }
+
+            /*
+             * Polling on the instance `state` doesn't work for when switching
+             * an instance to a snapshot, because a first poll value of
+             * "running" is ambiguous: was it a fast reboot, or has the instance
+             * not yet left the running state? Instead we check the audit log.
+             */
+            function waitOnJob(dateHeader, reqId, waitTimeout) {
+                var resTime = Date.parse(dateHeader);
+
+                if (!dateHeader) {
+                    cb(new errors.InternalError(format(
+                        'cannot wait for rollback_snapshot: CloudAPI ' +
+                        'response did not include a "Date" header (req %s)',
+                        reqId)));
+                    return;
+                } else if (isNaN(resTime)) {
+                    cb(new errors.InternalError(format(
+                        'cannot wait for reboot: could not parse CloudAPI ' +
+                        'response "Date" header: "%s" (req %s)',
+                        dateHeader, reqId)));
+                    return;
+                }
+
+                if (waitTimeout !== undefined) {
+                    waitTimeout *= 1000; // convert to ms
+                }
+
+                var auditAction;
+                if (command === 'startMachineFromSnapshot') {
+                    auditAction = 'rollback_snapshot';
+                } else if (command === 'deleteMachine') {
+                    auditAction = 'destroy';
+                } else {
+                    throw 'Unrecognized action'; // shouldn't get here
+                }
+
+                cloudapi.waitForAudit({
+                    id: uuid,
+                    action: auditAction,
+                    minAge: resTime,
+                    waitTimeout: waitTimeout
+                }, function waitAuditCb(err) {
+                    if (err) {
+                        perror(err);
+                        cb(err);
                         return;
                     }
 
-                    self.top.tritonapi.cloudapi.waitForMachineStates({
-                        id: uuid,
-                        states: [state]
-                    }, function (err2, inst2, res2) {
-                        if (action === 'delete' &&
-                            res2 && res2.statusCode === 410) {
-                            // This is success, fall through to bottom.
-                            /* jsl:pass */
-                        } else if (err2) {
-                            perror(err2);
-                            cb(err2);
-                            return;
-                        }
-
-                        var dur = common.humanDurationFromMs(Date.now() - now);
-                        if (alias)
-                            console.log('%s instance %s (%s, %s)',
-                                common.capitalize(action), alias, uuid, dur);
-                        else
-                            console.log('%s instance %s (%s)',
-                                common.capitalize(action), uuid, dur);
-
-                        cb();
-                    });
+                    report();
                 });
             }
+
+            function report() {
+                var dur = common.humanDurationFromMs(Date.now() - now);
+                if (alias)
+                    console.log('%s instance %s (%s, %s)',
+                        common.capitalize(action), alias, uuid, dur);
+                else
+                    console.log('%s instance %s (%s)',
+                        common.capitalize(action), uuid, dur);
+
+                cb();
+            }
         },
         inputs: instances
     }, function (err, results) {
diff --git a/lib/tritonapi.js b/lib/tritonapi.js
index 77575c1..032059d 100644
--- a/lib/tritonapi.js
+++ b/lib/tritonapi.js
@@ -3358,10 +3358,6 @@ TritonApi.prototype.rebootInstance = function rebootInstance(opts, cb) {
     var self = this;
     var res;
 
-    function randrange(min, max) {
-        return Math.floor(Math.random() * (max - min + 1)) + min;
-    }
-
     vasync.pipeline({arg: {client: self, id: opts.id}, funcs: [
         _stepInstId,
 
@@ -3393,13 +3389,7 @@ TritonApi.prototype.rebootInstance = function rebootInstance(opts, cb) {
              *       "time":"2017-02-08T20:55:44.045Z",
              *       "action":"reboot",
              *       ...}
-             *
-             * Hardcoded 2s poll interval for now (randomized for the first
-             * poll). Not yet configurable, being mindful of avoiding lots of
-             * clients naively swamping a CloudAPI and hitting throttling.
              */
-            var POLL_INTERVAL = 2 * 1000;
-            var startTime = process.hrtime();
             var dateHeader = res.headers['date'];
             var resTime = Date.parse(dateHeader);
             if (!dateHeader) {
@@ -3415,58 +3405,13 @@ TritonApi.prototype.rebootInstance = function rebootInstance(opts, cb) {
                     dateHeader, res.headers['request-id'])));
                 return;
             }
-            self.log.trace({id: arg.instId, resTime: resTime},
-                'wait for reboot audit record');
-
-            var pollMachineAudit = function () {
-                self.cloudapi.machineAudit(arg.instId, function (aErr, audit) {
-                    if (aErr) {
-                        next(aErr);
-                        return;
-                    }
 
-                    /*
-                     * Search the top few audit records, in case some other
-                     * action slipped in.
-                     */
-                    var theRecord = null;
-                    for (var i = 0; i < audit.length; i++) {
-                        if (audit[i].action === 'reboot' &&
-                            Date.parse(audit[i].time) > resTime) {
-                            theRecord = audit[i];
-                            break;
-                        }
-                    }
-
-                    if (!theRecord) {
-                        if (opts.waitTimeout) {
-                            var elapsedMs =
-                                common.monotonicTimeDiffMs(startTime);
-                            if (elapsedMs > opts.waitTimeout) {
-                                next(new errors.TimeoutError(format('timeout '
-                                    + 'waiting for instance %s reboot '
-                                    + '(elapsed %ds)',
-                                    arg.instId,
-                                    Math.round(elapsedMs / 1000))));
-                                return;
-                            }
-                        }
-                        setTimeout(pollMachineAudit, POLL_INTERVAL);
-                    } else if (theRecord.success !== 'yes') {
-                        next(new errors.TritonError(format(
-                            'reboot failed (audit id %s)', theRecord.id)));
-                    } else {
-                        next();
-                    }
-                });
-            };
-
-            /*
-             * Add a random start delay to avoid a number of concurrent reboots
-             * all polling at the same time.
-             */
-            setTimeout(pollMachineAudit,
-                (POLL_INTERVAL / 2) + randrange(0, POLL_INTERVAL));
+            self.cloudapi.waitForAudit({
+                id: arg.instId,
+                action: 'reboot',
+                minAge: resTime,
+                waitTimeout: opts.waitTimeout
+            }, next);
         }
     ]}, function (err) {
         cb(err, null, res);
diff --git a/test/integration/cli-snapshots.test.js b/test/integration/cli-snapshots.test.js
index 3b35199..575f2b7 100644
--- a/test/integration/cli-snapshots.test.js
+++ b/test/integration/cli-snapshots.test.js
@@ -25,7 +25,6 @@ var INST;
 
 var testOpts = {
     skip: (
-        (!process.env.TEST_KNOWN_FAIL && 'known failure, see TRITON-1387') ||
         (!h.CONFIG.allowWriteActions && 'requires config.allowWriteActions')
     )
 };
-- 
2.21.0

