commit fc9f57b3c3938e6f00ad666304941f111f4fa3bf
Author: Kelly McLaughlin <kelly.mclaughlin@joyent.com>
Date:   2019-08-02T15:15:49-06:00 (9 weeks ago)
    
    MANTA-4467 Use slog child loggers to capture request id in standard bunyan format

diff --git a/src/bucket/create.rs b/src/bucket/create.rs
index e89446c..3178cae 100644
--- a/src/bucket/create.rs
+++ b/src/bucket/create.rs
@@ -2,7 +2,7 @@
 
 use serde_derive::{Deserialize, Serialize};
 use serde_json::{json, Value};
-use slog::{debug, error, warn, Logger};
+use slog::{debug, error, o, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -28,7 +28,9 @@ pub(crate) fn handler(
     mut conn: &mut PostgresConnection,
     log: &Logger,
 ) -> Result<HandlerResponse, HandlerError> {
-    debug!(log, "handling {} function request", &METHOD);
+    let mut log_child = log.clone();
+
+    debug!(log_child, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<CreateBucketPayload>>(data.clone())
         .map_err(|e| e.to_string())
@@ -39,22 +41,21 @@ pub(crate) fn handler(
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
                                createbucket function";
-                warn!(log, "{}: {}", err_msg, data);
+                warn!(log_child, "{}: {}", err_msg, data);
                 Err(err_msg.to_string())
             }
         })
         .and_then(|payload| {
             // Make database request
             let req_id = payload.request_id;
-            debug!(log, "parsed CreateBucketPayload, req_id: {}", &req_id);
+            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+            debug!(log_child, "parsed CreateBucketPayload");
 
             create(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(
-                        log,
-                        "{} operation was successful, req_id: {}", &METHOD, &req_id
-                    );
+                    debug!(log_child, "{} operation was successful", &METHOD);
                     let value = match maybe_resp {
                         Some(resp) => to_json(resp),
                         None => bucket_already_exists(),
@@ -65,10 +66,7 @@ pub(crate) fn handler(
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(
-                        log,
-                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
-                    );
+                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
diff --git a/src/bucket/delete.rs b/src/bucket/delete.rs
index 311f021..76d87ac 100644
--- a/src/bucket/delete.rs
+++ b/src/bucket/delete.rs
@@ -1,7 +1,7 @@
 // Copyright 2019 Joyent, Inc.
 
 use serde_json::{json, Value};
-use slog::{debug, error, warn, Logger};
+use slog::{debug, error, o, warn, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
@@ -18,7 +18,8 @@ pub(crate) fn handler(
     mut conn: &mut PostgresConnection,
     log: &Logger,
 ) -> Result<HandlerResponse, HandlerError> {
-    debug!(log, "handling {} function request", &METHOD);
+    let mut log_child = log.clone();
+    debug!(log_child, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<DeleteBucketPayload>>(data.clone())
         .map_err(|e| e.to_string())
@@ -29,22 +30,21 @@ pub(crate) fn handler(
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
                                deletebucket function";
-                warn!(log, "{}: {}", err_msg, data);
+                warn!(log_child, "{}: {}", err_msg, data);
                 Err(err_msg.to_string())
             }
         })
         .and_then(|payload| {
             // Make database request
             let req_id = payload.request_id;
-            debug!(log, "parsed DeleteBucketPayload, req_id: {}", &req_id);
+            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+            debug!(log_child, "parsed DeleteBucketPayload");
 
             delete(payload, &mut conn)
                 .and_then(|affected_rows| {
                     // Handle the successful database response
-                    debug!(
-                        log,
-                        "deletebucket operation was successful, req_id: {}", &req_id
-                    );
+                    debug!(log_child, "deletebucket operation was successful");
                     let value = if affected_rows > 0 {
                         // This conversion can fail if the implementation of
                         // Serialize decides to fail, or if the type
@@ -63,10 +63,7 @@ pub(crate) fn handler(
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(
-                        log,
-                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
-                    );
+                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
diff --git a/src/bucket/get.rs b/src/bucket/get.rs
index 334856a..d5beada 100644
--- a/src/bucket/get.rs
+++ b/src/bucket/get.rs
@@ -1,7 +1,7 @@
 // Copyright 2019 Joyent, Inc.
 
 use serde_json::{json, Value};
-use slog::{debug, error, warn, Logger};
+use slog::{debug, error, o, warn, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
@@ -18,7 +18,8 @@ pub(crate) fn handler(
     mut conn: &mut PostgresConnection,
     log: &Logger,
 ) -> Result<HandlerResponse, HandlerError> {
-    debug!(log, "handling {} function request", &METHOD);
+    let mut log_child = log.clone();
+    debug!(log_child, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<GetBucketPayload>>(data.clone())
         .map_err(|e| e.to_string())
@@ -29,22 +30,21 @@ pub(crate) fn handler(
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
                                getbucket function";
-                warn!(log, "{}: {}", err_msg, data);
+                warn!(log_child, "{}: {}", err_msg, data);
                 Err(err_msg.to_string())
             }
         })
         .and_then(|payload| {
             // Make database request
             let req_id = payload.request_id;
-            debug!(log, "parsed GetBucketPayload, req_id: {}", &req_id);
+            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+            debug!(log_child, "parsed GetBucketPayload");
 
             get(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(
-                        log,
-                        "{} operation was successful, req_id: {}", &METHOD, &req_id
-                    );
+                    debug!(log_child, "{} operation was successful", &METHOD);
                     let value = match maybe_resp {
                         Some(resp) => to_json(resp),
                         None => bucket_not_found(),
@@ -55,10 +55,7 @@ pub(crate) fn handler(
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(
-                        log,
-                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
-                    );
+                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
diff --git a/src/bucket/list.rs b/src/bucket/list.rs
index 2b4dc69..4413eca 100644
--- a/src/bucket/list.rs
+++ b/src/bucket/list.rs
@@ -2,7 +2,7 @@
 
 use serde_derive::{Deserialize, Serialize};
 use serde_json::{json, Value};
-use slog::{debug, error, warn, Logger};
+use slog::{debug, error, o, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -30,7 +30,8 @@ pub(crate) fn handler(
     mut conn: &mut PostgresConnection,
     log: &Logger,
 ) -> Result<HandlerResponse, HandlerError> {
-    debug!(log, "handling {} function request", &METHOD);
+    let mut log_child = log.clone();
+    debug!(log_child, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<ListBucketsPayload>>(data.clone())
         .map_err(|e| e.to_string())
@@ -41,31 +42,27 @@ pub(crate) fn handler(
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
                                getbucket function";
-                warn!(log, "{}: {}", err_msg, data);
+                warn!(log_child, "{}: {}", err_msg, data);
                 Err(err_msg.to_string())
             }
         })
         .and_then(|payload| {
             // Make database request
             let req_id = payload.request_id;
-            debug!(log, "parsed ListBucketsPayload, req_id: {}", &req_id);
+            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+            debug!(log_child, "parsed ListBucketsPayload");
 
             if payload.limit > 0 && payload.limit <= 1024 {
                 list(msg_id, payload, &mut conn)
                     .and_then(|resp| {
                         // Handle the successful database response
-                        debug!(
-                            log,
-                            "{} operation was successful, req_id: {}", &METHOD, &req_id
-                        );
+                        debug!(log_child, "{} operation was successful", &METHOD);
                         Ok(HandlerResponse::from(resp))
                     })
                     .or_else(|e| {
                         // Handle database error response
-                        error!(
-                            log,
-                            "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
-                        );
+                        error!(log_child, "{} operation failed: {}", &METHOD, &e);
 
                         // Database errors are returned to as regular Fast messages
                         // to be handled by the calling application
diff --git a/src/object/create.rs b/src/object/create.rs
index 32bcd3f..e3394f7 100644
--- a/src/object/create.rs
+++ b/src/object/create.rs
@@ -5,7 +5,7 @@ use std::vec::Vec;
 use base64;
 use serde_derive::{Deserialize, Serialize};
 use serde_json::{json, Value};
-use slog::{debug, error, warn, Logger};
+use slog::{debug, error, o, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -41,7 +41,8 @@ pub(crate) fn handler(
     mut conn: &mut PostgresConnection,
     log: &Logger,
 ) -> Result<HandlerResponse, HandlerError> {
-    debug!(log, "handling {} function request", &METHOD);
+    let mut log_child = log.clone();
+    debug!(log_child, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<CreateObjectPayload>>(data.clone())
         .map_err(|e| e.to_string())
@@ -52,22 +53,21 @@ pub(crate) fn handler(
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
                                createobject function";
-                warn!(log, "{}: {}", err_msg, data);
+                warn!(log_child, "{}: {}", err_msg, data);
                 Err(err_msg.to_string())
             }
         })
         .and_then(|payload| {
             // Make database request
             let req_id = payload.request_id;
-            debug!(log, "parsed CreateObjectPayload, req_id: {}", &req_id);
+            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+            debug!(log_child, "parsed CreateObjectPayload");
 
             create(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(
-                        log,
-                        "{} operation was successful, req_id: {}", &METHOD, &req_id
-                    );
+                    debug!(log_child, "{} operation was successful", &METHOD);
                     // The `None` branch of the following match statement should
                     // never be reached. If `maybe_resp` was `None` this would
                     // mean that the SQL INSERT for the object was successful
@@ -85,10 +85,7 @@ pub(crate) fn handler(
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(
-                        log,
-                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
-                    );
+                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
diff --git a/src/object/delete.rs b/src/object/delete.rs
index 46dd551..0ce5e00 100644
--- a/src/object/delete.rs
+++ b/src/object/delete.rs
@@ -3,7 +3,7 @@
 use std::vec::Vec;
 
 use serde_json::{json, Value};
-use slog::{debug, error, warn, Logger};
+use slog::{debug, error, o, warn, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
@@ -20,7 +20,8 @@ pub(crate) fn handler(
     mut conn: &mut PostgresConnection,
     log: &Logger,
 ) -> Result<HandlerResponse, HandlerError> {
-    debug!(log, "handling {} function request", &METHOD);
+    let mut log_child = log.clone();
+    debug!(log_child, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<DeleteObjectPayload>>(data.clone())
         .map_err(|e| e.to_string())
@@ -31,22 +32,21 @@ pub(crate) fn handler(
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
                                deleteobject function";
-                warn!(log, "{}: {}", err_msg, data);
+                warn!(log_child, "{}: {}", err_msg, data);
                 Err(err_msg.to_string())
             }
         })
         .and_then(|payload| {
             // Make database request
             let req_id = payload.request_id;
-            debug!(log, "parsed DeleteObjectPayload, req_id: {}", &req_id);
+            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+            debug!(log_child, "parsed DeleteObjectPayload");
 
             delete(payload, &mut conn)
                 .and_then(|affected_rows| {
                     // Handle the successful database response
-                    debug!(
-                        log,
-                        "{} operation was successful, req_id: {}", &METHOD, &req_id
-                    );
+                    debug!(log_child, "{} operation was successful", &METHOD);
                     let value = if affected_rows > 0 {
                         // This conversion can fail if the implementation of
                         // Serialize decides to fail, or if the type
@@ -65,10 +65,7 @@ pub(crate) fn handler(
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(
-                        log,
-                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
-                    );
+                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
diff --git a/src/object/get.rs b/src/object/get.rs
index 59ee59e..2f9df12 100644
--- a/src/object/get.rs
+++ b/src/object/get.rs
@@ -3,7 +3,7 @@
 use std::vec::Vec;
 
 use serde_json::{json, Value};
-use slog::{debug, error, warn, Logger};
+use slog::{debug, error, o, warn, Logger};
 
 use cueball_postgres_connection::PostgresConnection;
 use rust_fast::protocol::{FastMessage, FastMessageData};
@@ -20,7 +20,8 @@ pub(crate) fn handler(
     mut conn: &mut PostgresConnection,
     log: &Logger,
 ) -> Result<HandlerResponse, HandlerError> {
-    debug!(log, "handling getobject function request");
+    let mut log_child = log.clone();
+    debug!(log_child, "handling getobject function request");
 
     serde_json::from_value::<Vec<GetObjectPayload>>(data.clone())
         .map_err(|e| e.to_string())
@@ -31,22 +32,21 @@ pub(crate) fn handler(
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
                                getobject function";
-                warn!(log, "{}: {}", err_msg, data);
+                warn!(log_child, "{}: {}", err_msg, data);
                 Err(err_msg.to_string())
             }
         })
         .and_then(|payload| {
             // Make database request
             let req_id = payload.request_id;
-            debug!(log, "parsed GetObjectPayload, req_id: {}", &req_id);
+            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+            debug!(log_child, "parsed GetObjectPayload");
 
             get(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(
-                        log,
-                        "getobject operation was successful, req_id: {}", &req_id
-                    );
+                    debug!(log_child, "getobject operation was successful");
                     let value = match maybe_resp {
                         Some(resp) => array_wrap(to_json(resp)),
                         None => array_wrap(object_not_found()),
@@ -57,10 +57,7 @@ pub(crate) fn handler(
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(
-                        log,
-                        "getobject operation failed: {}, req_id: {}", &e, &req_id
-                    );
+                    error!(log_child, "getobject operation failed: {}", &e);
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
diff --git a/src/object/list.rs b/src/object/list.rs
index 1859f92..f46c84b 100644
--- a/src/object/list.rs
+++ b/src/object/list.rs
@@ -5,7 +5,7 @@ use std::vec::Vec;
 use base64;
 use serde_derive::{Deserialize, Serialize};
 use serde_json::{json, Value};
-use slog::{debug, error, warn, Logger};
+use slog::{debug, error, o, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -34,7 +34,8 @@ pub(crate) fn handler(
     mut conn: &mut PostgresConnection,
     log: &Logger,
 ) -> Result<HandlerResponse, HandlerError> {
-    debug!(log, "handling {} function request", &METHOD);
+    let mut log_child = log.clone();
+    debug!(log_child, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<ListObjectsPayload>>(data.clone())
         .map_err(|e| e.to_string())
@@ -45,31 +46,27 @@ pub(crate) fn handler(
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
                                getobject function";
-                warn!(log, "{}: {}", err_msg, data);
+                warn!(log_child, "{}: {}", err_msg, data);
                 Err(err_msg.to_string())
             }
         })
         .and_then(|payload| {
             // Make database request
             let req_id = payload.request_id;
-            debug!(log, "parsed ListObjectsPayload, req_id: {}", &req_id);
+            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+            debug!(log_child, "parsed ListObjectsPayload");
 
             if payload.limit > 0 && payload.limit <= 1024 {
                 list(msg_id, payload, &mut conn)
                     .and_then(|resp| {
                         // Handle the successful database response
-                        debug!(
-                            log,
-                            "{} operation was successful, req_id: {}", &METHOD, &req_id
-                        );
+                        debug!(log_child, "{} operation was successful", &METHOD);
                         Ok(HandlerResponse::from(resp))
                     })
                     .or_else(|e| {
                         // Handle database error response
-                        error!(
-                            log,
-                            "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
-                        );
+                        error!(log_child, "{} operation failed: {}", &METHOD, &e);
 
                         // Database errors are returned to as regular Fast messages
                         // to be handled by the calling application
diff --git a/src/object/update.rs b/src/object/update.rs
index 6854f9a..7cb8910 100644
--- a/src/object/update.rs
+++ b/src/object/update.rs
@@ -4,7 +4,7 @@ use std::vec::Vec;
 
 use serde_derive::{Deserialize, Serialize};
 use serde_json::{json, Value};
-use slog::{debug, error, warn, Logger};
+use slog::{debug, error, o, warn, Logger};
 use uuid::Uuid;
 
 use cueball_postgres_connection::PostgresConnection;
@@ -35,7 +35,8 @@ pub(crate) fn handler(
     mut conn: &mut PostgresConnection,
     log: &Logger,
 ) -> Result<HandlerResponse, HandlerError> {
-    debug!(log, "handling {} function request", &METHOD);
+    let mut log_child = log.clone();
+    debug!(log_child, "handling {} function request", &METHOD);
 
     serde_json::from_value::<Vec<UpdateObjectPayload>>(data.clone())
         .map_err(|e| e.to_string())
@@ -46,22 +47,21 @@ pub(crate) fn handler(
             } else {
                 let err_msg = "Failed to parse JSON data as payload for \
                                updateobject function";
-                warn!(log, "{}: {}", err_msg, data);
+                warn!(log_child, "{}: {}", err_msg, data);
                 Err(err_msg.to_string())
             }
         })
         .and_then(|payload| {
             // Make database request
             let req_id = payload.request_id;
-            debug!(log, "parsed UpdateObjectPayload, req_id: {}", &req_id);
+            log_child = log_child.new(o!("req_id" => req_id.to_string()));
+
+            debug!(log_child, "parsed UpdateObjectPayload");
 
             update(payload, &mut conn)
                 .and_then(|maybe_resp| {
                     // Handle the successful database response
-                    debug!(
-                        log,
-                        "{} operation was successful, req_id: {}", &METHOD, &req_id
-                    );
+                    debug!(log_child, "{} operation was successful", &METHOD);
                     let value = match maybe_resp {
                         Some(resp) => to_json(resp),
                         None => object_not_found(),
@@ -72,10 +72,7 @@ pub(crate) fn handler(
                 })
                 .or_else(|e| {
                     // Handle database error response
-                    error!(
-                        log,
-                        "{} operation failed: {}, req_id: {}", &METHOD, &e, &req_id
-                    );
+                    error!(log_child, "{} operation failed: {}", &METHOD, &e);
 
                     // Database errors are returned to as regular Fast messages
                     // to be handled by the calling application
