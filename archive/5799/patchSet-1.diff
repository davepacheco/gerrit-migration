From 989dbb9ed985e093a5600354dfc06781be8943a6 Mon Sep 17 00:00:00 2001
From: Trent Mick <trentm@gmail.com>
Date: Thu, 14 Mar 2019 15:02:05 -0700
Subject: [PATCH] TRITON-884 remove cloud analytics (ca) from Triton

---
 TODO.md                           |  22 -
 etc/defaults.json                 |  10 -
 lib/cli/do_check_config.js        |   1 -
 lib/cli/do_remove_ca.js           | 104 +++++
 lib/cli/experimental.js           |   2 +
 lib/procedures/index.js           |   6 +-
 lib/procedures/remove-services.js | 702 ++++++++++++++++++++++++++++++
 lib/sdcadm.js                     |   3 +-
 package.json                      |   4 +-
 test/common.js                    |   2 +-
 10 files changed, 816 insertions(+), 40 deletions(-)
 create mode 100644 lib/cli/do_remove_ca.js
 create mode 100644 lib/procedures/remove-services.js

diff --git a/TODO.md b/TODO.md
index eb57b2e..507bc41 100644
--- a/TODO.md
+++ b/TODO.md
@@ -31,28 +31,6 @@ Here-in random TODOs and scratchpad notes for sdcadm.
 - extra procedure on update: `sdc-amonadm update` (library equivalent) procedure
   after instance changes
 
-- Allow no-op updates (same image) and downgrades with a "force" flag
-  Want the confirmation to break out instances meaningfully, e.g.:
-
-        download 1 image (69 MiB):
-            image 6261c204-e75d-11e3-91fa-a311fd4ab601 (ca@master-20140529T180636Z-gf4e65ef)
-        update "ca" service (1 instance) to image 6261c204-e75d-11e3-91fa-a311fd4ab601 (ca@master-20140529T180636Z-gf4e65ef)
-
-        update "ca" service (2 instances) to image 6261c204-e75d-11e3-91fa-a311fd4ab601 (ca@master-20140529T180636Z-gf4e65ef)
-
-        update "vm-agent" service (300 instances) to image 6261c204-e75d-11e3-91fa-a311fd4ab601 (vm-agent@1.2.3):
-            289 instances will be updated from image $oldImageUuid1
-            1 instance will be updated from image $oldImageUuid2
-            10 instances already at image $imageUuid
-
-        update "vm-agent" service (300 instances) to image 6261c204-e75d-11e3-91fa-a311fd4ab601 (vm-agent@1.2.3):
-            300 instances forced downgrade from image $oldImageUuid1
-
-  What does that break-out example look like in code path? That
-  needs to be in the result of 'determineProcedures'. A -F will
-  translate to a `'allowNoopOrDowngrade':true` or similar, which
-  'determineProcedures' will handle.
-
 - a way to list available updates (with changelog support)
   Perhaps use this under the hood:
         update-imgadm changes $from-image-uuid $to-image-uuid
diff --git a/etc/defaults.json b/etc/defaults.json
index ae969c2..0cf35dd 100644
--- a/etc/defaults.json
+++ b/etc/defaults.json
@@ -22,7 +22,6 @@
         "mahi": "manta-authcache",
         "sdc": "sdc",
         "manta": "manta-deployment",
-        "ca": "ca",
         "sapi": "sapi",
         "cloudapi": "cloudapi",
         "napi": "napi",
@@ -57,7 +56,6 @@
         "fwapi": "20140618T014938Z",
         "papi": "20140618T113529Z",
         "redis": "20140618T035133Z",
-        "ca": "20140618T013643Z",
         "sapi": "20140618T034916Z",
         "workflow": "20140702T155100Z",
         "cnapi": "20140710T224122Z",
@@ -85,14 +83,6 @@
             "max_physical_memory": 1024,
             "max_locked_memory": 1024,
             "max_swap": 2048
-        },
-        "ca": {
-            "max_physical_memory": 4096,
-            "max_locked_memory": 4096,
-            "max_swap": 8192,
-            "zfs_io_priority": 20,
-            "cpu_cap": 400,
-            "package_name": "sdc_4096"
         }
     }
 }
diff --git a/lib/cli/do_check_config.js b/lib/cli/do_check_config.js
index 9966a79..76c98ab 100644
--- a/lib/cli/do_check_config.js
+++ b/lib/cli/do_check_config.js
@@ -30,7 +30,6 @@ const SVCS_IN_CFG_FILE = [
     'vmapi',
     'sdc',
     'papi',
-    'ca',
     'adminui',
     'mahi',
     'amon',
diff --git a/lib/cli/do_remove_ca.js b/lib/cli/do_remove_ca.js
new file mode 100644
index 0000000..e17d177
--- /dev/null
+++ b/lib/cli/do_remove_ca.js
@@ -0,0 +1,104 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/*
+ * The 'sdcadm experimental remove-ca' CLI subcommand to remove the Cloud
+ * Analytics (CA) service from TritonDC.
+ */
+
+var RemoveServicesProcedure = require('../procedures/remove-services')
+    .RemoveServicesProcedure;
+var runProcs = require('../procedures').runProcs;
+
+function do_remove_ca(subcmd, opts, _args, cb) {
+    var self = this;
+
+    if (opts.help) {
+        this.do_help('help', {}, [subcmd], cb);
+        return;
+    }
+
+    var procs = [
+        new RemoveServicesProcedure({
+            svcNames: ['ca', 'cabase', 'cainstsvc'],
+            includeServerNames: opts.servers,
+            excludeServerNames: opts.exclude_servers
+        })
+    ];
+    runProcs({
+        log: self.log,
+        procs: procs,
+        sdcadm: self.sdcadm,
+        ui: self.ui,
+        dryRun: opts.dry_run,
+        skipConfirm: opts.yes
+    }, function done(err) {
+        cb(err);
+    });
+}
+
+do_remove_ca.options = [
+    {
+        names: ['help', 'h'],
+        type: 'bool',
+        help: 'Show this help.'
+    },
+    {
+        names: ['yes', 'y'],
+        type: 'bool',
+        help: 'Answer yes to all confirmations.'
+    },
+    {
+        names: ['dry-run', 'n'],
+        type: 'bool',
+        help: 'Do a dry-run.'
+    },
+    {
+        group: 'Server selection (by default agents on all setup servers ' +
+            'are removed)'
+    },
+    {
+        names: ['servers', 's'],
+        type: 'arrayOfCommaSepString',
+        helpArg: 'NAMES',
+        help: 'Comma-separated list of servers (either hostnames or uuids) ' +
+            'where agents will be removed.'
+    },
+    {
+        names: ['exclude-servers', 'S'],
+        type: 'arrayOfCommaSepString',
+        helpArg: 'NAMES',
+        help: 'Comma-separated list of servers (either hostnames or uuids) ' +
+            'to exclude from the set of servers on which agents will be ' +
+            'removed.'
+    }
+];
+
+do_remove_ca.helpOpts = {
+    maxHelpCol: 25
+};
+
+do_remove_ca.help = [
+    'Remove the Cloud Analytics services from Triton.',
+    '',
+    'Usage:',
+    '     {{name}} remove-ca',
+    '',
+    '{{options}}',
+    'Cloud Analytics (CA) has been deprecated. This command will remove CA',
+    'related service agents and VMs.'
+].join('\n');
+
+
+// --- exports
+
+module.exports = {
+    do_remove_ca: do_remove_ca
+};
diff --git a/lib/cli/experimental.js b/lib/cli/experimental.js
index 164532a..0f8324b 100644
--- a/lib/cli/experimental.js
+++ b/lib/cli/experimental.js
@@ -92,6 +92,8 @@ ExperimentalCLI.prototype.do_cns = require('../post-setup/cns').do_cns;
 ExperimentalCLI.prototype.do_nfs_volumes =
 require('./do_nfs_volumes').do_nfs_volumes;
 
+ExperimentalCLI.prototype.do_remove_ca = require('./do_remove_ca').do_remove_ca;
+
 // --- exports
 
 module.exports = {
diff --git a/lib/procedures/index.js b/lib/procedures/index.js
index df1a38a..b52b6db 100644
--- a/lib/procedures/index.js
+++ b/lib/procedures/index.js
@@ -202,7 +202,7 @@ function coordinatePlan(opts, cb) {
          */
         function updateSimpleServices(_, next) {
             var simpleServices = [
-                'amon', 'amonredis', 'assets', 'ca',
+                'amon', 'amonredis', 'assets',
                 'cnapi', 'cns', 'dhcpd', 'docker', 'fwapi', 'manta',
                 'napi', 'rabbitmq', 'redis', 'sdc', 'ufds', 'vmapi', 'volapi'
             ].concat(HA_READY_SIMPLE_SVCS);
@@ -709,8 +709,8 @@ function coordinatePlan(opts, cb) {
             // Names of the agents which can be updated using this method:
             var allowed = ['cn-agent', 'vm-agent', 'net-agent',
                 'agents_core', 'firewaller', 'smartlogin', 'config-agent',
-                'amon-agent', 'amon-relay', 'hagfish-watcher', 'cabase',
-                'cainstsvc', 'cmon-agent'
+                'amon-agent', 'amon-relay', 'hagfish-watcher',
+                'cmon-agent'
             ];
 
             var handle = [];
diff --git a/lib/procedures/remove-services.js b/lib/procedures/remove-services.js
new file mode 100644
index 0000000..0e61667
--- /dev/null
+++ b/lib/procedures/remove-services.js
@@ -0,0 +1,702 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+/**
+ * Procedure for removing a given set of Triton services and all their
+ * instances. Originally this was implemented to remove the CA set of services,
+ * but it might be useful as generic functionality at some point.
+ */
+
+'use strict';
+
+var assert = require('assert-plus');
+var semver = require('semver');
+var sprintf = require('extsprintf').sprintf;
+var util = require('util');
+var vasync = require('vasync');
+var VError = require('verror');
+
+var errors = require('../errors');
+var Procedure = require('./procedure').Procedure;
+var steps = require('../steps');
+
+
+// The set of known services for which we'll go the extra mile on removal.
+// Typically we'd bail early if SAPI didn't know about the service anymore.
+// For the following services we'll look harder for instances, even though
+// SAPI doesn't know about them. See related notes in `.viable()` below.
+const TYPE_FROM_KNOWN_SVC_NAME = {
+    'ca': 'vm',
+    'cabase': 'agent',
+    'cainstsvc': 'agent'
+};
+
+// In TRITON-1173, support for uninstalling GZ agent instances was added.
+// The following versions are required for that support.
+const CNAPI_MIN_VERSION = '1.19.0';
+const CN_AGENT_MIN_VERSION = '2.8.0';
+
+
+function RemoveServicesProcedure(opts) {
+    assert.arrayOfString(opts.svcNames, 'opts.svcNames');
+    assert.ok(opts.svcNames.length > 0, 'at least one service name');
+    assert.optionalArrayOfString(opts.includeServerNames,
+        'opts.includeServerNames');
+    assert.optionalArrayOfString(opts.excludeServerNames,
+        'opts.excludeServerNames');
+
+    this.svcNames = opts.svcNames;
+    this.includeServerNames = opts.includeServerNames;
+    this.excludeServerNames = opts.excludeServerNames;
+}
+util.inherits(RemoveServicesProcedure, Procedure);
+
+
+RemoveServicesProcedure.prototype.prepare = function prepare(opts, cb) {
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.log, 'opts.log');
+    assert.object(opts.ui, 'opts.ui');
+
+    var sdcadm = opts.sdcadm;
+    var self = this;
+    var ui = opts.ui;
+
+    self.actions = [];
+
+    vasync.pipeline({arg: {}, funcs: [
+        sdcadm.ensureSdcApp.bind(sdcadm),
+
+        // Gather the service and instance info from SAPI.
+        //
+        // If a given service name isn't in SAPI, typically we would error out
+        // here. However, if it is one of the "known" services, then we will
+        // search for instances in VMAPI and CNAPI that may exist, but not in
+        // SAPI.
+        //
+        // How could this happen? Typically the SAPI entries would only be
+        // removed after actual instance removal. However, say 'cabase' was
+        // removed and then an operator installed an old agentsshar, which
+        // included the cabase agent, on some CNs.
+        function getSapiSvcs(ctx, next) {
+            ui.info('Gathering SAPI service data.');
+
+            let actionItems = [];
+            // At least one svc being removed is of type=agent.
+            ctx.haveAgentSvc = false;
+            self.sapiSvcFromSvcName = {};
+
+            vasync.forEachParallel({
+                inputs: self.svcNames,
+                func: function getSapiSvc(svcName, nextSvc) {
+                    sdcadm.getSvc({
+                        app: 'sdc',
+                        svc: svcName,
+                        allowNone: true
+                    }, function (err, svc) {
+                        if (err) {
+                            nextSvc(err);
+                        } else if (svc) {
+                            self.sapiSvcFromSvcName[svcName] = svc;
+                            actionItems.push({
+                                desc: sprintf('remove "%s" SAPI service',
+                                    svcName),
+                                args: {
+                                    service_uuid: svc.uuid
+                                }
+                            });
+                            if (svc.type === 'agent') {
+                                ctx.haveAgentSvc = true;
+                            }
+                            nextSvc();
+                        } else if (TYPE_FROM_KNOWN_SVC_NAME[svcName]) {
+                            if (TYPE_FROM_KNOWN_SVC_NAME[svcName] === 'agent') {
+                                ctx.haveAgentSvc = true;
+                            }
+                            nextSvc();
+                        } else {
+                            nextSvc(new errors.UsageError(
+                                'unknown SAPI service: ' + svcName));
+                        }
+                    });
+                }
+            }, function doneGetSapiSvcs(err) {
+                if (actionItems.length) {
+                    self.actions.push({
+                        action: 'RemoveSapiSvcs',
+                        items: actionItems
+                    });
+                }
+                next(err);
+            });
+        },
+
+        function getSapiInsts(_, next) {
+            // Dev Note: I'm avoiding using sdcadm.listInst here because it
+            // already avoids SAPI and relies on CNAPI and VMAPI for actual
+            // inst info. Because we are going to remove insts we need to know
+            // if SAPI has the inst or not. Longer term I think the abstraction
+            // sdcadm.listInsts is providing is leaky and should be removed.
+            ui.info('Gathering SAPI instance data.');
+            self.sapiInstsFromSvcName = {};
+            let actionItems = [];
+            vasync.forEachParallel({
+                inputs: self.svcNames,
+                func: function getSapiInstsForSvc(svcName, nextSvc) {
+                    var sapiSvc = self.sapiSvcFromSvcName[svcName];
+                    if (!sapiSvc) {
+                        self.sapiInstsFromSvcName[svcName] = [];
+                        nextSvc();
+                        return;
+                    }
+
+                    sdcadm.sapi.listInstances({
+                        service_uuid: sapiSvc.uuid
+                    }, function onInsts(err, insts) {
+                        if (err) {
+                            nextSvc(err);
+                        } else {
+                            self.sapiInstsFromSvcName[svcName] = insts;
+                            for (let inst of insts) {
+                                actionItems.push({
+                                    desc: sprintf(
+                                        'remove "%s" SAPI instance %s',
+                                        svcName, inst.uuid),
+                                    args: {
+                                        instance_uuid: inst.uuid
+                                    }
+                                });
+                            }
+                            nextSvc();
+                        }
+                    });
+                }
+            }, function finished(err) {
+                if (actionItems.length) {
+                    self.actions.push({
+                        action: 'RemoveSapiInsts',
+                        items: actionItems
+                    });
+                }
+                next(err);
+            });
+        },
+
+        // We may need the CNAPI server version below later to determine if
+        // it has the 'ServerRemoveAgents' functionality we need.
+        function getCnapiVer(ctx, next) {
+            if (!ctx.haveAgentSvc) {
+                next();
+                return;
+            }
+
+            sdcadm.cnapi.ping(function onPing(err, _body, _req, res) {
+                if (err) {
+                    next(err);
+                } else {
+                    ctx.cnapiServerHeader = res.headers['server'];
+                    let match = /^cnapi\/(\d+\.\d+\.\d+)$/.exec(
+                        ctx.cnapiServerHeader);
+                    if (match) {
+                       ctx.cnapiVer = match[1];
+                    }
+                    next();
+                }
+            });
+        },
+
+        function gatherServersForAgentRemovals(ctx, next) {
+            if (!ctx.haveAgentSvc) {
+                next();
+                return;
+            }
+
+            ui.info('Gathering server agent data.');
+            steps.servers.selectServers({
+                log: opts.log,
+                sdcadm: sdcadm,
+                includeServerNames: self.includeServerNames,
+                excludeServerNames: self.excludeServerNames,
+                // Allow not running servers. We warn about them below.
+                allowNotRunning: true,
+                serverExtras: ['agents']
+            }, function selectedServers(err, servers) {
+                self.servers = servers;
+                next(err);
+            });
+        },
+
+        // We use CNAPI data for agent instances because (a) we don't (at
+        // least currently) trust that SAPI knows about all actual instances and
+        // (b) currently SAPI's DeleteInstance for an instance of type=agent
+        // does *not* actually go and uninstall the agent.
+        function determineAgentInsts(ctx, next) {
+            let actionItems = [];
+            let viableErrs = [];
+
+            // Get an array of servers holding an instance of each
+            // service name to remove.
+            self.serversFromSvcName = {};
+            for (let svcName of self.svcNames) {
+                self.serversFromSvcName[svcName] = [];
+            }
+            for (let server of self.servers) {
+                let agentsToRemove = [];
+                let cnAgentInfo;
+
+                for (let agent of server.agents) {
+                    if (agent.name === 'cn-agent') {
+                        cnAgentInfo = agent;
+                    }
+                    let sfsn = self.serversFromSvcName[agent.name];
+                    if (sfsn) {
+                        sfsn.push(server);
+                        agentsToRemove.push(agent.name);
+                    }
+                }
+
+                if (agentsToRemove) {
+                    // Ensure sufficient cn-agent ver for agent uninstall.
+                    if (!cnAgentInfo || !cnAgentInfo.version) {
+                        viableErrs.push(new VError('could not determine ' +
+                            'cn-agent version for server %s (%s)',
+                            server.uuid, server.hostname));
+                    } else if (semver.lt(cnAgentInfo.version,
+                        CN_AGENT_MIN_VERSION)) {
+                        viableErrs.push(new VError('cn-agent on server ' +
+                            '%s (%s) does not support agent uninstall: ' +
+                            'require v%s or later, have v%s',
+                            server.uuid, server.hostname,
+                            CN_AGENT_MIN_VERSION, cnAgentInfo.version));
+                    } else if (agentsToRemove.length > 0) {
+                        agentsToRemove.sort();
+                        actionItems.push({
+                            desc: sprintf(
+                                'uninstall %s from server %s (%s)',
+                                agentsToRemove.join(', '),
+                                server.uuid,
+                                server.hostname),
+                            args: {
+                                server_uuid: server.uuid,
+                                agents: agentsToRemove
+                            }
+                        });
+                    }
+                }
+            }
+
+            if (actionItems.length) {
+                // Ensure sufficient CNAPI version for agent uninstall.
+                if (!ctx.cnapiVer) {
+                    viableErrs.push(new VError('could not determine CNAPI' +
+                        'version from "Server: %s" header',
+                        ctx.cnapiServerHeader));
+                } else if (semver.lt(ctx.cnapiVer, CNAPI_MIN_VERSION)) {
+                    viableErrs.push(new VError('CNAPI does not support ' +
+                        'agent uninstall: require v%s or later, have v%s',
+                        CNAPI_MIN_VERSION, ctx.cnapiVer));
+                } else {
+                    self.actions.push({
+                        action: 'UninstallAgents',
+                        items: actionItems
+                    });
+                }
+            }
+
+            next(VError.errorFromList(viableErrs));
+        },
+
+        // XXX Include actions for VMs that don't have a SAPI instance.
+        function getVmInsts(_, next) {
+            ui.info('Gathering VM instance data.');
+            self.vmInstsFromSvcName = {};
+            vasync.forEachParallel({
+                inputs: self.svcNames,
+                func: function getVmInstsForSvc(svcName, nextSvc) {
+                    var filters = {
+                        state: 'active',
+                        owner_uuid: sdcadm.config.ufds_admin_uuid,
+                        'tag.smartdc_role': svcName
+                    };
+                    sdcadm.vmapi.listVms(filters, function (err, vms) {
+                        if (err) {
+                            nextSvc(new errors.SDCClientError(err, 'vmapi'));
+                        } else {
+                            self.vmInstsFromSvcName[svcName] = vms;
+                            nextSvc();
+                        }
+                    });
+                }
+            }, next);
+        }
+    ]}, function finished(err) {
+        if (err) {
+            cb(err);
+        } else {
+            // We've been adding the actions in the reverse order we want to
+            // execute them.
+            self.actions.reverse();
+
+            var nothingToDo = (self.actions.length === 0);
+            cb(null, nothingToDo);
+        }
+    });
+};
+
+
+RemoveServicesProcedure.prototype.summarize = function summarize() {
+    // Example summary:
+    //      - Remove 'ca' service: SAPI records, 1 vm instance
+    //          - VM $uuid (ca0)
+    //      - Remove 'cabase' service: SAPI records, 230 agent instances
+    //          - warning: 2 servers that have instances are not running:
+    //              - server $uuid ($hostname)
+    //              - server $uuid ($hostname)
+    //      - Remove 'cainstsvc' service: 2 agent instances
+
+    var self = this;
+    var lines = [];
+
+    for (let svcName of self.svcNames) {
+        let vmInsts = self.vmInstsFromSvcName[svcName];
+        let serversWithAgent = self.serversFromSvcName[svcName];
+        let sapiInsts = self.sapiInstsFromSvcName[svcName];
+        let sapiSvc = self.sapiSvcFromSvcName[svcName];
+        let type;
+
+        let line = [sprintf('- Remove "%s" service:', svcName)];
+        let details = [];
+        if (sapiSvc || sapiInsts.length) {
+            details.push('SAPI records');
+        }
+        if (vmInsts.length) {
+            type = 'vm';
+            details.push(sprintf('%d vm instance%s', vmInsts.length,
+                vmInsts.length === 1 ? '' : 's'));
+        } else if (serversWithAgent.length) {
+            type = 'agent';
+            details.push(sprintf('%d agent instance%s', serversWithAgent.length,
+                serversWithAgent.length === 1 ? '' : 's'));
+        }
+        if (details.length === 0) {
+            details.push('nothing to do');
+        }
+        line.push(details.join(', '));
+        lines.push(line.join(' '));
+
+        if (type === 'vm') {
+            for (let vm of vmInsts) {
+                lines.push(sprintf('    - VM %s (%s)', vm.uuid, vm.alias));
+            }
+        } else if (type === 'agent') {
+            var notRunningServers = serversWithAgent
+                .filter(s => s.status !== 'running');
+            if (notRunningServers.length) {
+                lines.push(sprintf('    - warning: %d %s:',
+                    notRunningServers.length,
+                    (notRunningServers.length === 1 ?
+                        'server that has an instance is not running' :
+                        'servers that have instances are not running')));
+                for (let s of notRunningServers) {
+                    lines.push(sprintf('        - server %s (%s)',
+                        s.uuid, s.hostname));
+                }
+            }
+        }
+    }
+
+    return lines.join('\n');
+};
+
+RemoveServicesProcedure.prototype._actionRemoveSapiSvcs =
+function _actionRemoveSapiSvcs(opts, cb) {
+    // An item looks like this:
+    //    {
+    //        "desc": "remove \"cainstsvc\" SAPI service",
+    //        "args": {
+    //            "service_uuid": "f85f3b49-3b87-4dec-934e-195535a2a10d"
+    //        }
+    //    },
+    assert.arrayOfObject(opts.items, 'opts.items');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.ui, 'opts.ui');
+    assert.object(opts.log, 'opts.log');
+    assert.func(cb, 'cb');
+
+    let log = opts.log;
+    let sapi = opts.sdcadm.sapi;
+    let ui = opts.ui;
+    ui.barStart({name: 'remove SAPI services', size: opts.items.length});
+
+    // For now we don't bother parallelizing this. We don't expect the number
+    // of svcs being deleted in one call to be large.
+    vasync.forEachPipeline({
+        inputs: opts.items,
+        func: function removeSapiSvc(item, nextItem) {
+            // ui.info('- start: ' + item.desc);
+
+            sapi.deleteService(item.args.service_uuid, function onDel(err) {
+                opts.log.debug({err: err}, 'sapi.deleteService');
+                if (err) {
+                    var e = new VError(err, 'error deleting SAPI service %s',
+                        item.args.service_uuid);
+                    ui.error(e.message);
+                    ui.barAdvance(1);
+                    nextItem(e);
+                } else {
+                    // ui.info('- completed: ' + item.desc);
+                    ui.barAdvance(1);
+                    nextItem();
+                }
+            });
+        }
+    }, function finish(err) {
+        ui.barEnd();
+        cb(err);
+    });
+};
+
+RemoveServicesProcedure.prototype._actionRemoveSapiInsts =
+function _actionRemoveSapiInsts(opts, cb) {
+    // An item looks like this:
+    //    {
+    //        "desc": "remove \"ca\" SAPI instance c0c9cf3b-...-651f095eb09e",
+    //        "args": {
+    //            "instance_uuid": "c0c9cf3b-3337-454e-940a-651f095eb09e"
+    //        }
+    //    }
+    assert.arrayOfObject(opts.items, 'opts.items');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.ui, 'opts.ui');
+    assert.object(opts.log, 'opts.log');
+    assert.func(cb, 'cb');
+
+    let sapi = opts.sdcadm.sapi;
+    let ui = opts.ui;
+    ui.barStart({name: 'remove SAPI instances', size: opts.items.length});
+
+    // Removing a SAPI *vm* instance will also delete the VM. Removing a
+    // SAPI *agent* instance only deletes the SAPI database record.
+    const CONCURRENCY = 10;
+    let errs = [];
+    let removeSapiInst = function (item, nextItem) {
+        var log = opts.log.child({item: item}, true);
+        // ui.info('- start: ' + item.desc);
+
+        sapi.deleteInstance(item.args.instance_uuid, function onDel(err) {
+            opts.log.debug({err: err}, 'sapi.deleteInstance');
+            if (err) {
+                var e = new VError(err, 'error deleting instance %s',
+                    item.args.instance_uuid);
+                ui.error(e.message);
+                ui.barAdvance(1);
+                nextItem(e);
+            } else {
+                // ui.info('- completed: ' + item.desc);
+                ui.barAdvance(1);
+                nextItem();
+            }
+        });
+    };
+    let queue = vasync.queue(removeSapiInst, CONCURRENCY);
+
+    queue.on('end', function () {
+        cb(VError.errorFromList(errs));
+    });
+
+    queue.push(opts.items, function onItemComplete(err) {
+        ui.barEnd();
+        if (err) {
+            errs.push(err);
+        }
+    });
+
+    queue.close();
+};
+
+RemoveServicesProcedure.prototype._actionUninstallAgents =
+function _actionUninstallAgents(opts, cb) {
+    // An item looks like this:
+    //    {
+    //        "desc": "uninstall cabase, cainstsvc from server 56...b3 (RA123)",
+    //        "args": {
+    //            "server_uuid": "564dfb70-91c8-73d0-4f85-2ac2427c4ab3",
+    //            "agents": [
+    //                "cabase",
+    //                "cainstsvc"
+    //            ]
+    //        }
+    //    }
+    assert.arrayOfObject(opts.items, 'opts.items');
+    assert.object(opts.sdcadm, 'opts.sdcadm');
+    assert.object(opts.ui, 'opts.ui');
+    assert.object(opts.log, 'opts.log');
+    assert.func(cb, 'cb');
+
+    let cnapi = opts.sdcadm.cnapi;
+    const CONCURRENCY = 10;
+    let errs = [];
+    let ui = opts.ui;
+    ui.barStart({name: 'uninstall agents', size: opts.items.length});
+
+    let uninstallAgentsOnServer = function (item, nextItem) {
+        var log = opts.log.child({item: item}, true);
+        // ui.info('- start: ' + item.desc);
+        // var start = Date.now();
+
+        vasync.pipeline({arg: {}, funcs: [
+            function tellCnapi(ctx, next) {
+                // XXX does this client pass along request-id for this sdcadm?
+                cnapi.uninstallAgents(item.args.server_uuid, {
+                    agents: item.args.agents
+                }, function (err, task) {
+                    log.debug({err: err, task: task}, 'cnapi.uninstallAgents');
+                    if (err) {
+                        next(err);
+                    } else {
+                        assert.uuid(task.id,
+                            'have a task from CNAPI ServerUninstallAgents');
+                        ctx.taskId = task.id;
+                        next();
+                    }
+                });
+            },
+
+            function waitForTaskCompletion(ctx, next) {
+                const AGENT_UNINSTALL_TIMEOUT_S = 60;
+
+                cnapi.waitTask(ctx.taskId, {
+                    timeout: AGENT_UNINSTALL_TIMEOUT_S
+                }, function (err, task) {
+                    log.debug({err: err, task: task}, 'cnapi.waitTask');
+                    if (err) {
+                        next(err);
+                    } else {
+                        ctx.task = task;
+                        next();
+                    }
+                });
+            },
+
+            function interpretTask(ctx, next) {
+                // A successful task looks like:
+                //    {
+                //      "id": "16f22ff1-8715-6dae-99ca-905ef15248b2",
+                //      "req_id": "c207a3a1-8a3d-63b4-8946-d63f44f0c8c3",
+                //      "task": "agents_uninstall",
+                //      "server_uuid": "564dfb70-91c8-73d0-4f85-2ac2427c4ab3",
+                //      "status": "complete",
+                //      "timestamp": "2019-02-12T22:18:26.351Z",
+                //      "history": [
+                //        {
+                //          "name": "finish",
+                //          "timestamp": "2019-02-12T22:18:32.892Z",
+                //          "event": {}
+                //        }
+                //      ]
+                //    }
+                //
+                // A failed task looks like:
+                //    {
+                //      "id": "45e47792-fdbb-c332-d58a-c68bae724dc7",
+                //      "req_id": "9912b352-490b-45aa-e547-ab6b5a4300d5",
+                //      "task": "agents_uninstall",
+                //      "server_uuid": "260cac77-0381-4b7e-9ed3-dba43887115f",
+                //      "status": "failure",
+                //      "timestamp": "2019-02-13T00:31:56.624Z",
+                //      "history": [
+                //        {
+                //          "name": "error",
+                //          "timestamp": "2019-02-13T00:31:57.158Z",
+                //          "event": {
+                //            "error": {
+                //              "message": "<error message from cn-agent>"
+                //            }
+                //          }
+                //        },
+                //        {
+                //          "name": "finish",
+                //          "timestamp": "2019-02-13T00:31:57.158Z",
+                //          "event": {}
+                //        }
+                //      ]
+                //    }
+                if (ctx.task.status === "complete") {
+                    next();
+                } else if (ctx.task.status === "failure") {
+                    var errMsg = (ctx.task.history.length > 0
+                        && ctx.task.history[0].name === 'error'
+                        ? ctx.task.history[0].event.error.message
+                        : 'unknown error');
+                    next(new VError('CNAPI agents_uninstall task %s failed: %s',
+                        ctx.task.id, errMsg));
+                } else {
+                    next(new VError('unknown "status" for CNAPI task %s: %s',
+                        ctx.task.id, ctx.task.status));
+                }
+            }
+        ]}, function finishUninstall(err) {
+            if (err) {
+                var e = new VError(err, 'error uninstalling %s on server %s',
+                    item.args.agents.join(', '), item.args.server_uuid);
+                ui.error(e.message);
+                ui.barAdvance(1);
+                nextItem(e);
+            } else {
+                // var elapsed = Math.round((Date.now() - start) / 1000);
+                // ui.info('- completed (' + elapsed + 's): ' + item.desc);
+                ui.barAdvance(1);
+                nextItem();
+            }
+        });
+    };
+    let queue = vasync.queue(uninstallAgentsOnServer, CONCURRENCY);
+
+    queue.on('end', function () {
+        ui.barEnd();
+        cb(VError.errorFromList(errs));
+    });
+
+    queue.push(opts.items, function onItemComplete(err) {
+        if (err) {
+            errs.push(err);
+        }
+    });
+
+    queue.close();
+};
+
+
+RemoveServicesProcedure.prototype.execute = function execute(opts, cb) {
+    var log = opts.log;
+    var self = this;
+
+    log.debug({actions: self.actions}, 'RemoveServicesProcedure.execute');
+
+    vasync.forEachPipeline({
+        inputs: self.actions,
+        func: function dispatchAction(action, nextAction) {
+            self['_action' + action.action].bind(self)({
+                items: action.items,
+                log: log,
+                ui: opts.ui,
+                sdcadm: opts.sdcadm
+            }, nextAction);
+        }
+    }, function done(err) {
+        cb(err);
+    });
+};
+
+
+// --- exports
+
+module.exports = {
+    RemoveServicesProcedure: RemoveServicesProcedure
+};
diff --git a/lib/sdcadm.js b/lib/sdcadm.js
index fd2335b..e999938 100644
--- a/lib/sdcadm.js
+++ b/lib/sdcadm.js
@@ -155,6 +155,7 @@ function SdcAdm(options) {
             if (self._sapi === undefined) {
                 self._sapi = new sdcClients.SAPI({
                     url: self.config.sapi.url,
+                    version: '~2',
                     agent: self.cueballAgent,
                     userAgent: self.userAgent,
                     log: self.log,
@@ -386,7 +387,7 @@ function SdcAdm(options) {
  * messages output when the command in use is given JSON option:
  */
 SdcAdm.prototype.ensureSdcApp = function (arg, cb) {
-    assert.object(arg, 'arg');
+    assert.optionalObject(arg, 'arg');
     assert.func(cb, 'cb');
     var self = this;
     if (self.sdcApp) {
diff --git a/package.json b/package.json
index 5c6135c..36c4d02 100644
--- a/package.json
+++ b/package.json
@@ -9,7 +9,7 @@
     "async": "0.2.9",
     "backoff": "2.5.0",
     "bunyan": "1.8.12",
-    "cmdln": "4.2.1",
+    "cmdln": "4.4.0",
     "cueball": "2.4.0",
     "extsprintf": "^1.3.0",
     "joyent-schemas": "git+https://github.com/joyent/schemas.git#385e6eb",
@@ -22,7 +22,7 @@
     "progbar": "1.2.0",
     "read": "1.0.5",
     "restify-clients": "1.4.0",
-    "sdc-clients": "10.3.0",
+    "sdc-clients": "12.2.0",
     "semver": "5.4.1",
     "strsplit": "1.0.0",
     "tabula": "1.9.0",
diff --git a/test/common.js b/test/common.js
index d227a58..ee92eb7 100644
--- a/test/common.js
+++ b/test/common.js
@@ -14,7 +14,7 @@ var util = require('util');
 var vasync = require('vasync');
 
 var DEFAULT_VM_SERVICES = [
-    'adminui', 'amon', 'amonredis', 'assets', 'binder', 'ca', 'cnapi', 'dhcpd',
+    'adminui', 'amon', 'amonredis', 'assets', 'binder', 'cnapi', 'dhcpd',
     'fwapi', 'imgapi', 'mahi', 'manatee', 'moray', 'napi', 'papi', 'rabbitmq',
     'redis', 'sapi', 'sdc', 'ufds', 'vmapi', 'workflow'
 ];
-- 
2.21.0

