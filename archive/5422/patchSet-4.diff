From ee5745db2c7aa31c6bb026e5b8fbd6b8f0d3eda2 Mon Sep 17 00:00:00 2001
From: Alex Wilson <alex.wilson@joyent.com>
Date: Wed, 23 Jan 2019 17:38:13 -0800
Subject: [PATCH] joyent/node-zkstream#29 unreliable tests assuming after
 sync() all watchers have fired joyent/node-zkstream#41 Move time-consuming
 connect() failure tests to the end

---
 test/basic.test.js      | 160 +++++++++++++++++++++++-----------------
 test/multi-node.test.js |  46 +++++++-----
 test/utils.js           |  38 ++++++++++
 3 files changed, 159 insertions(+), 85 deletions(-)
 create mode 100644 test/utils.js

diff --git a/test/basic.test.js b/test/basic.test.js
index 9b1a265..f74f2af 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -13,6 +13,9 @@ const mod_net = require('net');
 const mod_bunyan = require('bunyan');
 const mod_util = require('util');
 const mod_vasync = require('vasync');
+const mod_assert = require('assert-plus');
+
+var wait = require('./utils').wait;
 
 var log = mod_bunyan.createLogger({
 	name: 'zkstream-test',
@@ -22,63 +25,6 @@ var log = mod_bunyan.createLogger({
 var zk;
 var connCount = 0;
 
-mod_tape.test('connect failure: refused', function (t) {
-	var zkc = new mod_zkc.Client({
-		log: log,
-		address: '127.0.0.1',
-		port: 2181
-	});
-
-	zkc.on('connect', function (st) {
-		t.fail();
-	});
-
-	zkc.on('failed', function () {
-		zkc.close();
-	});
-
-	zkc.on('close', function () {
-		t.end();
-	});
-});
-
-mod_tape.test('start awful zk server', function (t) {
-	zk = mod_net.createServer();
-	zk.on('connection', function (sock) {
-		++connCount;
-		sock.destroy();
-	});
-	zk.listen(2181, function () {
-		t.end();
-	});
-});
-
-mod_tape.test('connect failure: immediate close', function (t) {
-	var zkc = new mod_zkc.Client({
-		log: log,
-		address: '127.0.0.1',
-		port: 2181
-	});
-
-	zkc.on('close', function () {
-		t.end();
-	});
-
-	zkc.on('connect', function () {
-		t.fail();
-	});
-
-	zkc.on('failed', function () {
-		zkc.close();
-	});
-});
-
-mod_tape.test('stop awful zk server', function (t) {
-	zk.close();
-	zk = undefined;
-	t.end();
-});
-
 mod_tape.test('start zk server', function (t) {
 	zk = new mod_zk.ZKServer();
 	zk.on('stateChanged', function (st) {
@@ -678,25 +624,46 @@ mod_tape.test('data watcher', function (t) {
 		t.end();
 	});
 
+	/* This data should have been put in /foo by a previous test */
 	var data = new Buffer('hi there', 'ascii');
 	var count = 0;
+	var presetCount;
 
-	zkc.on('connect', function () {
+	mod_vasync.waterfall(
+	    [connect, makeWatcher, setValue, check],
+	    function (err) {
+		t.error(err);
+		zkc.close();
+	});
+
+	function connect(cb) {
+		zkc.on('connect', cb);
+	}
+
+	function makeWatcher(cb) {
 		zkc.watcher('/foo').on('dataChanged', function (newData) {
 			t.ok(Buffer.isBuffer(newData));
 			t.strictEqual(newData.toString('base64'),
 			    data.toString('base64'));
-			if (++count === 1) {
-				data = new Buffer('hi', 'ascii');
-				console.log('doing set');
-				zk.cli('set', '/foo', 'hi', function (err) {
-					t.error(err);
-					t.strictEqual(count, 2);
-					zkc.close();
-				});
-			}
+			if (++count === 1)
+				cb();
 		});
-	});
+	}
+
+	function setValue(cb) {
+		data = new Buffer('hi', 'ascii');
+		presetCount = count;
+		zk.cli('set', '/foo', 'hi', function (err) {
+			t.error(err);
+			cb();
+		});
+	}
+
+	function check(cb) {
+		wait(t, 'watcher has fired', 30000,
+		    function () { return (count > presetCount); },
+		    cb);
+	}
 });
 
 mod_tape.test('delete it while watching', function (t) {
@@ -1048,3 +1015,60 @@ mod_tape.test('stop zk server', function (t) {
 	});
 	zk.stop();
 });
+
+mod_tape.test('connect failure: refused', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('connect', function (st) {
+		t.fail();
+	});
+
+	zkc.on('failed', function () {
+		zkc.close();
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+});
+
+mod_tape.test('start awful zk server', function (t) {
+	zk = mod_net.createServer();
+	zk.on('connection', function (sock) {
+		++connCount;
+		sock.destroy();
+	});
+	zk.listen(2181, function () {
+		t.end();
+	});
+});
+
+mod_tape.test('connect failure: immediate close', function (t) {
+	var zkc = new mod_zkc.Client({
+		log: log,
+		address: '127.0.0.1',
+		port: 2181
+	});
+
+	zkc.on('close', function () {
+		t.end();
+	});
+
+	zkc.on('connect', function () {
+		t.fail();
+	});
+
+	zkc.on('failed', function () {
+		zkc.close();
+	});
+});
+
+mod_tape.test('stop awful zk server', function (t) {
+	zk.close();
+	zk = undefined;
+	t.end();
+});
diff --git a/test/multi-node.test.js b/test/multi-node.test.js
index 71cac37..269418e 100644
--- a/test/multi-node.test.js
+++ b/test/multi-node.test.js
@@ -11,6 +11,7 @@ const mod_zk = require('./zkserver');
 const mod_zkc = require('../lib/index');
 const mod_net = require('net');
 const mod_bunyan = require('bunyan');
+const mod_vasync = require('vasync');
 
 var log = mod_bunyan.createLogger({
 	name: 'zkstream-test',
@@ -144,7 +145,10 @@ mod_tape.test('write visibility', function (t) {
 		zkc1.create('/foo', data, {}, function (err, path) {
 			t.error(err);
 			t.strictEqual(path, '/foo');
-			get();
+			zkc1.sync('/foo', function (err2) {
+				t.error(err2);
+				get();
+			});
 		});
 	}
 
@@ -197,24 +201,32 @@ mod_tape.test('cross-server data watch', function (t) {
 	});
 
 	function setup() {
-		var watchFired = false;
-		zkc1.watcher('/foo').on('dataChanged',
-		    function (newData, stat) {
-			if (newData.toString() === 'testing') {
-				t.ok(stat.version > 0);
-				watchFired = true;
-			}
-		});
-		var data = new Buffer('testing');
-		zkc2.set('/foo', data, 0, function (err) {
+		mod_vasync.parallel({
+			funcs: [watch1, write2]
+		}, function (err) {
 			t.error(err);
-			zkc2.sync('/foo', function (err2) {
-				t.error(err2);
-				t.ok(watchFired);
-				zkc1.close();
-				zkc2.close();
-			});
+			zkc1.close();
+			zkc2.close();
 		});
+		function watch1(cb) {
+			zkc1.watcher('/foo').on('dataChanged',
+			    function (newData, stat) {
+				if (newData.toString() === 'testing') {
+					t.ok(stat.version > 0);
+					cb();
+				}
+			});
+		}
+		function write2(cb) {
+			var data = new Buffer('testing');
+			zkc2.set('/foo', data, 0, function (err) {
+				t.error(err);
+				zkc2.sync('/foo', function (err2) {
+					t.error(err2);
+					cb();
+				});
+			});
+		}
 	}
 });
 
diff --git a/test/utils.js b/test/utils.js
new file mode 100644
index 0000000..85235e6
--- /dev/null
+++ b/test/utils.js
@@ -0,0 +1,38 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * Copyright (c) 2019, Joyent, Inc.
+ */
+
+var mod_assert = require('assert-plus');
+
+module.exports = {
+	wait: wait
+};
+
+function wait(t, name, maxTimeout, cond, cb) {
+	mod_assert.object(t, 'test object');
+	mod_assert.string(name, 'name');
+	mod_assert.number(maxTimeout, 'maxTimeout');
+	mod_assert.func(cond, 'condition');
+	mod_assert.func(cb, 'cb');
+	var time = 0;
+	function check() {
+		var res = cond();
+		if (res) {
+			t.ok(res, name);
+			cb();
+			return;
+		}
+		time += 100;
+		if (time > maxTimeout) {
+			t.fail('timed out waiting for condition: ' + name);
+			t.end();
+			return;
+		}
+		setTimeout(check, 100);
+	}
+	setTimeout(check, 100);
+}
-- 
2.21.0

