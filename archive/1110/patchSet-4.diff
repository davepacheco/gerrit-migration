From 55ebc7992f31fdb5eb90faf70d63e666f6798147 Mon Sep 17 00:00:00 2001
From: Wyatt Preul <wpreul@gmail.com>
Date: Mon, 12 Dec 2016 14:56:16 -0600
Subject: [PATCH] Add client encryption support

---
 lib/client.js       |  34 ++++++-
 lib/cse.js          | 222 ++++++++++++++++++++++++++++++++++++++++++++
 package.json        |   1 +
 test/client.test.js |  62 +++++++++++++
 4 files changed, 314 insertions(+), 5 deletions(-)
 create mode 100644 lib/cse.js

diff --git a/lib/client.js b/lib/client.js
index 8de4b24..6001f0c 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -23,6 +23,7 @@ var Watershed = require('watershed').Watershed;
 var LOMStream = require('lomstream').LOMStream;
 
 var auth = require('smartdc-auth');
+var cse = require('./cse');
 var jobshare = require('./jobshare');
 var Queue = require('./queue');
 var trackmarker = require('./trackmarker');
@@ -171,7 +172,11 @@ function createOptions(opts, userOpts) {
         headers: normalizeHeaders(userOpts.headers),
         id: id,
         path: opts.path.replace(/\/$/, ''),
-        query: clone(userOpts.query || {})
+        query: clone(userOpts.query || {}),
+        keyId: opts.keyId || userOpts.keyId,
+        key: opts.key || userOpts.key,
+        cipher: opts.cipher || userOpts.cipher,
+        getKey: opts.getKey || userOpts.getKey
     };
 
     if (userOpts.role)
@@ -827,7 +832,13 @@ MantaClient.prototype.get = function get(p, opts, cb) {
 
             res.pause();
 
-            cb(null, stream, res);
+            // Not encrypted, return original file stream
+            if (res.headers['m-encrypt-support'] !== 'client') {
+                cb(null, stream, res);
+            } else {
+                cse.decrypt(opts, stream, res, cb);
+            }
+
 
             if (length === false &&
                 res.headers['content-length'] &&
@@ -1808,6 +1819,8 @@ MantaClient.prototype.mkdirp = function mkdirp(dir, opts, cb) {
  *  - cb: callback of the form f(err)
  */
 MantaClient.prototype.put = function put(p, input, opts, cb) {
+    var self = this;
+
     assert.string(p, 'path');
     assert.stream(input, 'input');
     if (typeof (opts) === 'function') {
@@ -1843,17 +1856,28 @@ MantaClient.prototype.put = function put(p, input, opts, cb) {
             parseInt(opts.copies, 10);
     }
 
-    if (options.headers['content-length'] === undefined)
+    if (options.headers['content-length'] === undefined) {
         options.headers['transfer-encoding'] = 'chunked';
+    }
 
     options._original_path = p; // needed for mkdirp case
 
-    log.debug(options, 'put: entered');
-    doPut(this, log, options, input, cb, opts.mkdirs);
+    if (options.keyId !== null && options.keyId !== undefined) {
+      return cse.encrypt(options, input, function (err, encrypted) {
+        if (err) {
+          return (cb(err));
+        }
+
+        return (doPut(self, log, options, encrypted, cb, opts.mkdirs));
+      });
+    }
+
+    return (doPut(this, log, options, input, cb, opts.mkdirs));
 };
 
 
 function doPut(self, log, options, input, cb, allowretry) {
+    log.debug(options, 'put: entered');
     self.signRequest({
         headers: options.headers
     }, function onSignRequest(err) {
diff --git a/lib/cse.js b/lib/cse.js
new file mode 100644
index 0000000..0a8c305
--- /dev/null
+++ b/lib/cse.js
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+var crypto = require('crypto');
+
+var assert = require('assert-plus');
+var PassThrough = require('stream').PassThrough;
+if (!PassThrough)
+    PassThrough = require('readable-stream/passthrough.js');
+
+var b64 = require('b64');
+
+
+exports.decrypt = function decrypt (opts, stream, res, cb) {
+    var invalidHeaders = validateHeaders(res.headers);
+    if (invalidHeaders) {
+        return (cb(new Error('Headers are missing or invalid: ' +
+          invalidHeaders), null, res));
+    }
+
+    return opts.getKey(res.headers['m-encrypt-key-id'], function (err, key) {
+        if (err) {
+            return (cb(err, null, res));
+        }
+
+        var algorithm = getAlgorithm(res.headers['m-encrypt-cipher']);
+        var decipher = crypto.createDecipheriv(algorithm, key,
+            b64.decode(new Buffer(res.headers['m-encrypt-iv'])));
+        var hmac = crypto.createHmac('sha256', key);
+        var output = new PassThrough();
+        var byteLength = 0;
+
+        stream.on('data', function (data) {
+            hmac.update(data);
+        });
+
+        stream.on('error', function (streamErr) {
+            decipher.removeAllListeners();
+            stream.removeAllListeners();
+            cb(streamErr);
+        });
+
+        decipher.on('data', function (data) {
+            byteLength += Buffer.byteLength(data);
+        });
+
+        decipher.once('error', function (decErr) {
+            decipher.removeAllListeners();
+            cb(decErr);
+        });
+
+        decipher.once('end', function (data) {
+            var digest = hmac.digest('base64');
+
+            if (digest !== res.headers['m-encrypt-mac']) {
+                return (cb(new Error('cipher hmac doesn\'t match stored' +
+                  ' m-encrypt-mac value'), null, res));
+            }
+
+            if (byteLength !== parseInt(
+              res.headers['m-encrypt-original-content-length'], 10)) {
+                return (cb(new Error(
+                  'decrypted file size doesn\'t match original copy'),
+                  null, res));
+            }
+
+            return decryptMetadata(res.headers, key, function () {
+                cb(null, output, res);
+            });
+        });
+
+
+        return (stream.pipe(decipher).pipe(output));
+    });
+}
+
+
+var requiredHeaders = [
+    'm-encrypt-key-id',
+    'm-encrypt-iv',
+    'm-encrypt-cipher',
+    'm-encrypt-mac',
+    'm-encrypt-original-content-length'
+];
+
+function validateHeaders(headers) {
+    var missingHeaders = [];
+    requiredHeaders.forEach(function (header) {
+        if (headers[header] === undefined || headers[header] === null) {
+            missingHeaders.push(header);
+        }
+    });
+
+    if ((headers['m-encrypt-metadata'] !== undefined &&
+      headers['m-encrypt-metadata'] !== null) &&
+      !headers['m-encrypt-metadata-cipher']) {
+
+      missingHeaders.push('m-encrypt-metadata-cipher');
+    }
+
+    return (missingHeaders.length ? missingHeaders : null);
+}
+
+
+function decryptMetadata(headers, key, cb) {
+    if (!headers['m-encrypt-metadata']) {
+        return (cb());
+    }
+
+    var algorithm = getAlgorithm(headers['m-encrypt-metadata-cipher']);
+    var decipher = crypto.createDecipheriv(algorithm, key,
+        b64.decode(new Buffer(headers['m-encrypt-metadata-iv'])));
+    var hmac = crypto.createHmac('sha256', key);
+
+    var bufs = [];
+    decipher.on('data', function (data) {
+        bufs.push(data);
+    });
+
+    decipher.once('finish', function () {
+        hmac.update(b64.decode(new Buffer(headers['m-encrypt-metadata'])));
+        headers['m-encrypt-metadata'] = Buffer.concat(bufs).toString();
+
+        if (headers['m-encrypt-metadata-mac'] !== hmac.digest('base64')) {
+            return (cb(new Error('mac hash doesn\'t match')));
+        }
+
+        return (cb());
+    });
+
+    decipher.write(b64.decode(new Buffer(headers['m-encrypt-metadata'])));
+    return (decipher.end());
+}
+
+exports.encrypt = function encrypt(options, input, cb) {
+    assert.string(options.key, 'key is required when encrypting');
+    assert.string(options.cipher, 'cipher is required when encrypting');
+
+    var iv = crypto.randomBytes(16);
+    var algorithm = getAlgorithm(options.cipher);
+
+    var cipher = crypto.createCipheriv(algorithm, options.key, iv);
+    var hmac = crypto.createHmac('sha256', options.key);
+    var output = new PassThrough();
+    var byteLength = 0;
+
+    cipher.on('data', function (data) {
+        hmac.update(data);
+    });
+
+    cipher.once('error', function (err) {
+        cipher.removeAllListeners();
+        cb(err);
+    });
+
+    input.on('data', function (data) {
+        byteLength += Buffer.byteLength(data);
+    });
+
+    cipher.once('end', function (data) {
+        options.headers['m-encrypt-support'] = 'client';
+        options.headers['m-encrypt-key-id'] = options.keyId;
+        options.headers['m-encrypt-iv'] = b64.encode(iv).toString();
+        options.headers['m-encrypt-cipher'] = options.cipher;
+        options.headers['m-encrypt-mac'] = hmac.digest('base64');
+        options.headers['m-encrypt-original-content-length'] = byteLength;
+
+        if (options.headers && options.headers['m-encrypt-metadata']) {
+            return encryptMetadata(options.headers, iv, options.key,
+                function (err) {
+                    if (err) {
+                        return (cb(err));
+                    }
+
+                    return (cb(null, output));
+                });
+        }
+
+        return (cb(null, output));
+    });
+
+    input.pipe(cipher).pipe(output);
+}
+
+
+function encryptMetadata(headers, iv, key, cb) {
+    headers['m-encrypt-metadata-iv'] = b64.encode(iv).toString();
+    headers['m-encrypt-metadata-cipher'] = headers['m-encrypt-metadata-cipher'];
+
+    var algorithm = getAlgorithm(headers['m-encrypt-metadata-cipher']);
+
+    var cipher = crypto.createCipheriv(algorithm, key, iv);
+    var hmac = crypto.createHmac('sha256', key);
+
+    var bufs = [];
+    cipher.on('data', function (data) {
+        bufs.push(data);
+    });
+
+    cipher.once('finish', function () {
+        var encrypted = Buffer.concat(bufs);
+        headers['m-encrypt-metadata'] = b64.encode(encrypted).toString();
+        hmac.update(encrypted);
+        headers['m-encrypt-metadata-mac'] = hmac.digest('base64');
+        cb();
+    });
+
+    cipher.once('error', function (err) {
+        cipher.removeAllListeners();
+        cb(err);
+    });
+
+    cipher.write(headers['m-encrypt-metadata']);
+    cipher.end();
+}
+
+
+function getAlgorithm(cipher) {
+    var parts = cipher.split('/');
+    return (parts[0] + parts[1]);
+}
diff --git a/package.json b/package.json
index c36677e..298d389 100644
--- a/package.json
+++ b/package.json
@@ -11,6 +11,7 @@
     "main": "./lib/index.js",
     "dependencies": {
         "assert-plus": "^1.0.0",
+        "b64": "^2.0.0",
         "backoff": "~2.3.0",
         "bunyan": "^1.8.1",
         "clone": "~0.1.11",
diff --git a/test/client.test.js b/test/client.test.js
index 7b27aab..ad206bc 100644
--- a/test/client.test.js
+++ b/test/client.test.js
@@ -163,6 +163,27 @@ test('#231: put (special characters)', function (t) {
     });
 });
 
+test('put (encrypt stream)', function (t) {
+    var text = 'The lazy brown fox \nsomething \nsomething foo';
+    var stream = new MemoryStream();
+    var options = {
+      key: 'FFFFFFFBD96783C6C91E2222',
+      keyId: 'dev/test',
+      cipher: 'aes/192/cbc'
+    };
+
+    this.client.put(ROOT + '/encrypted', stream, options, function (err, res) {
+        t.ifError(err);
+        t.ok(res.req._headers['m-encrypt-key-id']);
+        t.done();
+    });
+
+    process.nextTick(function () {
+        stream.write(text);
+        stream.end();
+    });
+});
+
 test('#231: ls (special characters)', function (t) {
     this.client.ls(SUBDIR1, function (err, res) {
         t.ifError(err);
@@ -196,6 +217,47 @@ test('#231: get (special characters)', function (t) {
     });
 });
 
+test('get (decrypt stream)', function (t) {
+    var self = this;
+    var text = 'The lazy brown fox \nsomething \nsomething foo';
+    var stream = new MemoryStream();
+    var fpath = ROOT + '/todecrypt';
+    var key = 'FFFFFFFBD96783C6C91E2222';
+    var options = {
+      key: key,
+      keyId: 'dev/test',
+      cipher: 'aes/192/cbc',
+      getKey: function (keyId, cb) {
+          cb(null, key);
+      }
+    };
+
+    self.client.put(fpath, stream, options, function (putErr, putRes) {
+        t.ifError(putErr);
+        t.ok(putRes.req._headers['m-encrypt-key-id']);
+        setTimeout(function () {
+          self.client.get(fpath, options, function (getErr, decrypted, getRes) {
+              t.ifError(getErr);
+
+              var result = '';
+              decrypted.on('data', function (data) {
+                result += data.toString();
+              });
+
+              decrypted.once('end', function () {
+                t.ok(result === text);
+                t.done();
+              });
+          });
+        }, 10);
+    });
+
+    process.nextTick(function () {
+        stream.write(text);
+        stream.end();
+    });
+});
+
 
 test('#231: rm (special characters)', function (t) {
     this.client.unlink(SPECIALOBJ1, function (err) {
-- 
2.21.0

