commit 09bd28b04820bb42f3be7cdf228bbc962947b38d (refs/changes/10/1110/19)
Author: Wyatt Preul <wpreul@gmail.com>
Date:   2017-01-18T15:14:05-06:00 (2 years, 9 months ago)
    
    joyent/node-manta#296 add client encryption support

diff --git a/lib/client.js b/lib/client.js
index 8de4b24..868bf09 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -23,6 +23,7 @@ var Watershed = require('watershed').Watershed;
 var LOMStream = require('lomstream').LOMStream;
 
 var auth = require('smartdc-auth');
+var cse = require('./cse');
 var jobshare = require('./jobshare');
 var Queue = require('./queue');
 var trackmarker = require('./trackmarker');
@@ -165,13 +166,28 @@ function createOptions(opts, userOpts) {
     assert.object(opts, 'options');
     assert.string(opts.path, 'options.path');
     assert.object(userOpts, 'userOptions');
-
+    assert.ok(!userOpts.encrypt || typeof (userOpts.encrypt) === 'object',
+        'options.encrypt must be false, an object, or not set');
+
+    // userEncrypt defaults to false if client.encrypt is false
+    var userEncrypt = (opts.encrypt === false) || (userOpts.encrypt === false) ?
+        false : (userOpts.encrypt || {});
+    var optsEncrypt = opts.encrypt || {};
+
+    var encrypt = (userEncrypt === false) ? false : {
+        cipher: userEncrypt.cipher || optsEncrypt.cipher,
+        keyId: userEncrypt.keyId || optsEncrypt.keyId,
+        key: userEncrypt.key || optsEncrypt.key,
+        getKey: userEncrypt.getKey || optsEncrypt.getKey,
+        hmacType: userEncrypt.hmacType || optsEncrypt.hmacType
+    };
     var id = opts.req_id || libuuid.v4();
     var options = {
         headers: normalizeHeaders(userOpts.headers),
         id: id,
         path: opts.path.replace(/\/$/, ''),
-        query: clone(userOpts.query || {})
+        query: clone(userOpts.query || {}),
+        encrypt: encrypt
     };
 
     if (userOpts.role)
@@ -492,6 +508,10 @@ function resultToInfoCb(_path, cb) {
  *  - user : optional user to create jobs under
  *  - subuser: optional subuser under the user
  *  - role: optional array of roles that are active for requests
+ *  - encrypt: optional, when false then client-side encryption is disabled.
+ *        When set to an object it can contain defaults for the client-side
+ *        encryption cipher, keyId, key, getKey, and hmacType options provided
+ *        to get()/put()
  *
  * Throws TypeError's if you pass bad arguments.
  */
@@ -505,12 +525,14 @@ function MantaClient(options) {
     assert.optionalString(options.user, 'options.user');
     assert.optionalString(options.subuser, 'options.subuser');
     assert.optionalArrayOfString(options.role, 'options.role');
+    assert.optionalFunc(options.encrypt.getKey, 'options.encrypt.getKey');
     if (options.sign === null)
         delete (options.sign);
     assert.optionalFunc(options.sign, 'options.sign');
     assert.ok(options.url || options.socketPath,
               'one of options.url or options.socketPath is required');
-
+    assert.ok(!options.encrypt || typeof (options.encrypt) === 'object',
+        'options.encrypt must be false, an object, or not set');
     EventEmitter.call(this);
 
     var self = this;
@@ -522,6 +544,17 @@ function MantaClient(options) {
 
     this.user = options.user;
     this.subuser = options.subuser;
+    this.encrypt = (options.encrypt === false) ? false :
+        (options.encrypt || {});
+
+    if (this.encrypt) {
+        assert.optionalString(this.encrypt.cipher, 'options.encrypt.cipher');
+        assert.optionalFunc(this.encrypt.getKey, 'options.encrypt.getKey');
+        assert.optionalString(this.encrypt.hmacType,
+            'options.encrypt.hmacType');
+        assert.optionalString(this.encrypt.key, 'options.encrypt.key')
+        assert.optionalString(this.encrypt.keyId, 'options.encrypt.keyId');
+    }
 
     if (options.role) {
         options.headers = options.headers || {};
@@ -784,7 +817,8 @@ MantaClient.prototype.get = function get(p, opts, cb) {
     var length = false;
     var options = createOptions({
         accept: opts.accept || '*/*',
-        path: _path
+        path: _path,
+        encrypt: this.encrypt
     }, opts);
     var log = this.log.child({
         path: _path,
@@ -827,7 +861,13 @@ MantaClient.prototype.get = function get(p, opts, cb) {
 
             res.pause();
 
-            cb(null, stream, res);
+            // Not encrypted, return original file stream
+            if (!options.encrypt || !cse.isSupported(res.headers)) {
+                cb(null, stream, res);
+            } else {
+                cse.decrypt({getKey: options.encrypt.getKey}, stream, res, cb);
+            }
+
 
             if (length === false &&
                 res.headers['content-length'] &&
@@ -1808,6 +1848,8 @@ MantaClient.prototype.mkdirp = function mkdirp(dir, opts, cb) {
  *  - cb: callback of the form f(err)
  */
 MantaClient.prototype.put = function put(p, input, opts, cb) {
+    var self = this;
+
     assert.string(p, 'path');
     assert.stream(input, 'input');
     if (typeof (opts) === 'function') {
@@ -1831,7 +1873,8 @@ MantaClient.prototype.put = function put(p, input, opts, cb) {
                       mime.lookup(_path)),
         contentLength: opts.size,
         expect: '100-continue',
-        path: _path
+        path: _path,
+        encrypt: this.encrypt
     }, opts);
     var log = this.log.child({
         path: _path,
@@ -1843,17 +1886,38 @@ MantaClient.prototype.put = function put(p, input, opts, cb) {
             parseInt(opts.copies, 10);
     }
 
-    if (options.headers['content-length'] === undefined)
+    if (options.headers['content-length'] === undefined) {
         options.headers['transfer-encoding'] = 'chunked';
+    }
 
     options._original_path = p; // needed for mkdirp case
 
-    log.debug(options, 'put: entered');
+    if (options.encrypt && options.encrypt.cipher) {
+        var encOptions = {
+            cipher: options.encrypt.cipher,
+            key: options.encrypt.key,
+            keyId: options.encrypt.keyId,
+            hmacType: options.encrypt.hmacType,
+            contentLength: options.contentLength,
+            headers: options.headers
+        };
+        cse.encrypt(encOptions, input, function (err, encrypted) {
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            doPut(self, log, options, encrypted, cb, opts.mkdirs);
+        });
+        return;
+    }
+
     doPut(this, log, options, input, cb, opts.mkdirs);
 };
 
 
 function doPut(self, log, options, input, cb, allowretry) {
+    log.debug(options, 'put: entered');
     self.signRequest({
         headers: options.headers
     }, function onSignRequest(err) {
diff --git a/lib/create_client.js b/lib/create_client.js
index 65efe8d..6eedc96 100644
--- a/lib/create_client.js
+++ b/lib/create_client.js
@@ -100,6 +100,7 @@ var DEFAULT_OPTIONS = [
 
 function cloneOptions(options) {
     assert.object(options, 'options');
+    var encrypt = (options.encrypt === false) ? false : (options.encrypt || {});
 
     return ({
         agent: options.agent,
@@ -112,7 +113,14 @@ function cloneOptions(options) {
         user: options.user,
         subuser: options.subuser,
         role: options.role,
-        url: options.url
+        url: options.url,
+        encrypt: (encrypt === false) ? false : {
+            getKey: encrypt.getKey,
+            keyId: encrypt.keyId,
+            key: encrypt.key,
+            cipher: encrypt.cipher,
+            hmac: encrypt.hmac
+        }
     });
 }
 
diff --git a/lib/cse.js b/lib/cse.js
new file mode 100644
index 0000000..5c11e09
--- /dev/null
+++ b/lib/cse.js
@@ -0,0 +1,417 @@
+// Copyright 2017 Joyent, Inc.
+
+/*
+* Client side encryption module that implements RFD 71:
+* https://github.com/joyent/rfd/tree/master/rfd/0071
+*
+* Exports decrypt(), encrypt(), and isSupported() functions for use
+* by the Manta client module to encrypt/decrypt get/put requests to Manta.
+*/
+
+var crypto = require('crypto');
+var assert = require('assert-plus');
+var ParseEtMStream = require('./parse_etm_stream');
+var PassThrough = require('stream').PassThrough;
+var verror = require('verror');
+
+var VError = verror.VError;
+
+
+var VERSION = 1;
+var CIPHERS = {
+    'AES/CBC/PKCS5Padding': {
+        string: 'aes-256-cbc',
+        ivBytes: 16,
+        keyBytes: 32
+    },
+    'AES/CTR/NoPadding': {
+        string: 'aes-256-ctr',
+        ivBytes: 16,
+        keyBytes: 32
+    },
+    'AES/GCM/NoPadding': {
+        string: 'aes-256-gcm',
+        ivBytes: 12,
+        keyBytes: 32
+    }
+};
+var HMACS = [
+    {
+        type: 'HmacMD5',
+        algorithm: 'md5',
+        bytes: 16
+    },
+    {
+        type: 'HmacSHA1',
+        algorithm: 'sha1',
+        bytes: 20
+    },
+    {
+        type: 'HmacSHA256',
+        algorithm: 'sha256',
+        bytes: 32
+    },
+    {
+        type: 'HmacSHA512',
+        algorithm: 'sha512',
+        bytes: 64
+    }
+];
+var REQUIRED_HEADERS = [
+    'm-encrypt-key-id',
+    'm-encrypt-iv',
+    'm-encrypt-cipher',
+    'm-encrypt-hmac-type',
+    'm-encrypt-type'
+];
+
+
+/**
+ * Decrypt an encrypted stream and verify the integrity of the decrypted payload
+ * Any encrypted m-encrypt-metadata headers are also decrypted
+ *
+ * Parameters:
+ *  - options: getKey function used to retrieve key value. Signature for getKey
+*       is getKey(keyId, cb) the cb function should return (err, key)
+ *  - encrypted: readable stream of encrypted data
+ *  - res: raw HTTP response from manta request, used for reading headers
+ *  - cb: callback of the form f(err, output, res)
+ */
+exports.decrypt = function decrypt(options, encrypted, res, cb) {
+    assert.object(options, 'options');
+    assert.object(res, 'res');
+    assert.object(res.headers, 'res.headers');
+    assert.stream(encrypted, 'encrypted');
+    assert.func(options.getKey, 'options.getKey');
+
+    var invalidHeaders = validateHeaders(res.headers);
+    if (invalidHeaders) {
+        cb(new Error('Headers are missing or invalid: ' +
+            invalidHeaders), null, res);
+        return;
+    }
+
+    var algorithm = getAlgorithm(res.headers['m-encrypt-cipher']);
+    if (!algorithm) {
+        cb(new Error('Unsupported cipher algorithm: ' +
+            res.headers['m-encrypt-cipher']), null, res);
+        return;
+    }
+
+    var hmacType = getHmacType(res.headers['m-encrypt-hmac-type']);
+    if (!hmacType) {
+        cb(new Error('Unsupported hmac algorithm: ' +
+            res.headers['m-encrypt-hmac-type']), null, res);
+        return;
+    }
+
+    options.getKey(res.headers['m-encrypt-key-id'], function (err, key) {
+        if (err) {
+            cb(new VError(err, 'failed executing options.getKey'), null, res);
+            return;
+        }
+
+        var decipher = crypto.createDecipheriv(algorithm.string, key,
+            new Buffer(res.headers['m-encrypt-iv'], 'base64'));
+        var hmac = crypto.createHmac(hmacType.algorithm, key);
+        var parseEtMStream = new ParseEtMStream(hmacType,
+            res.headers['content-length']);
+        var output = new PassThrough();
+        var byteLength = 0;
+
+        function handleCipherData(data) {
+            hmac.update(data);
+        }
+
+        function handleEncryptedError(streamErr) {
+            parseEtMStream.removeListener('data', handleCipherData);
+            decipher.removeListener('data', handleDecipherData);
+            decipher.removeListener('error', handleDecipherError);
+            decipher.removeListener('end', handleDecipherEnd);
+
+            output.emit('error', new VError(streamErr,
+                'failed to read encrypted data'));
+        }
+
+        function handleDecipherData(data) {
+            byteLength += Buffer.byteLength(data);
+        }
+
+        function handleDecipherError(decErr) {
+            decipher.removeListener('data', handleDecipherData);
+            decipher.removeListener('end', handleDecipherEnd);
+            output.emit('error', new VError(decErr,
+                'failed to write to decipher'));
+        }
+
+        function handleDecipherEnd(data) {
+            var digest = hmac.digest();
+            if (digest.compare(parseEtMStream.digest()) !== 0) {
+                output.emit('error', new Error('cipher hmac doesn\'t match ' +
+                    'stored hmac value'));
+                return;
+            }
+
+            var origLength = res.headers['m-encrypt-plaintext-content-length'];
+            if (origLength && byteLength !== parseInt(origLength, 10)) {
+                output.emit('error', new Error(
+                    'decrypted file size doesn\'t match original copy'));
+                return;
+            }
+        }
+
+        decryptMetadata(res.headers, key, function (metadataErr) {
+            if (metadataErr) {
+                cb(new VError(metadataErr, 'failed decrypting metadata: %s',
+                    JSON.stringify(res.headers, null, '  ')), null, res);
+                return;
+            }
+
+            parseEtMStream.on('data', handleCipherData);
+            encrypted.once('error', handleEncryptedError);
+
+            decipher.on('data', handleDecipherData);
+            decipher.once('error', handleDecipherError);
+            decipher.once('end', handleDecipherEnd);
+
+            cb(null, output, res);
+            encrypted.pipe(parseEtMStream).pipe(decipher).pipe(output);
+        });
+    });
+};
+
+
+/**
+ * Encrypt a readable stream and any m-encrypt-metadata headers.
+ *
+ * Parameters:
+ *  - options:
+ *      - cipher: (string) encryption algorithm to use, can be
+ *           AES/CBC/PKCS5Padding, AES/CTR/NoPadding, or AES/GCM/NoPadding
+ *      - key: (string) raw encryption key value
+ *      - keyId: (string) identifier for the key, will be saved with object
+ *      - hmacType: (string) type of hmac algorithm to use
+ *      - contentLength: (number) original size of input stream in bytes
+ *      - headers: (object) raw request headers, will be mutated
+ *  - input: readable stream to encrypt
+ *  - cb: callback of the form f(err, output)
+ */
+exports.encrypt = function encrypt(options, input, cb) {
+    assert.object(options, 'options');
+    assert.stream(input, 'input');
+    assert.string(options.cipher, 'options.cipher');
+    assert.string(options.key, 'options.key');
+    assert.string(options.keyId, 'options.keyId');
+    assert.optionalString(options.hmacType, 'options.hmacType');
+    assert.optionalNumber(options.contentLength, 'options.contentLength');
+    assert.object(options.headers, options.headers);
+
+    var algorithm = getAlgorithm(options.cipher);
+    if (!algorithm) {
+        throw new Error('Unsupported cipher algorithm: ' + options.cipher);
+    }
+
+    var hmacType = getHmacType(options.hmacType || 'hmacsha256');
+    if (!hmacType) {
+        throw new Error('Unsupported hmac algorithm: ' + options.hmacType);
+    }
+
+    var iv = crypto.randomBytes(algorithm.ivBytes);
+    var cipher = crypto.createCipheriv(algorithm.string, options.key, iv);
+    var hmac = crypto.createHmac(hmacType.algorithm, options.key);
+    var output = new PassThrough();
+
+    function handleCipherData(data) {
+        hmac.update(data);
+    }
+
+    cipher.on('data', handleCipherData);
+
+    cipher.once('error', function (err) {
+        cipher.removeListener('data', handleCipherData);
+        output.emit('error', new VError(err, 'failed reading cipher'));
+    });
+
+    cipher.once('end', function (data) {
+        var digest = hmac.digest();
+        assert.ok(Buffer.byteLength(digest) === hmacType.bytes, 'hmac digest ' +
+            'not expected size. expected bytes: ' + hmacType.bytes + ' actual' +
+            'bytes: ' + Buffer.byteLength(digest));
+
+        // Append the digest to the end of the payload
+        output.write(digest);
+    });
+
+    if (options.contentLength !== undefined) {
+        options.headers['m-encrypt-plaintext-content-length'] =
+            options.contentLength;
+    }
+    options.headers['m-encrypt-type'] = 'client/' + VERSION;
+    options.headers['m-encrypt-key-id'] = options.keyId;
+    options.headers['m-encrypt-iv'] = new Buffer(iv).toString('base64');
+    options.headers['m-encrypt-cipher'] = options.cipher;
+    options.headers['m-encrypt-hmac-type'] = hmacType.type;
+
+    if (options.headers['m-encrypt-metadata']) {
+        encryptMetadata(options.headers, options.key,
+            function (err) {
+                if (err) {
+                    cb(new VError(err, 'failed encrypting metadata: %s',
+                        JSON.stringify(options.headers, null, '  ')));
+                    return;
+                }
+
+                cb(null, output);
+                input.pipe(cipher).pipe(output);
+            });
+
+        return;
+    }
+
+    cb(null, output);
+    input.pipe(cipher).pipe(output);
+};
+
+
+/**
+ * Determines if the response is encrypted and can be decrypted by this module
+ *
+ * Parameters:
+ *  - headers: (object) raw response headers
+ * Returns:
+ *  boolean indicating if the response is encrypted and if this module can
+ *      decrypt the response.
+ */
+exports.isSupported = function isSupported(headers) {
+    var encTypes = headers['m-encrypt-type'] ?
+        headers['m-encrypt-type'].split('/') : [];
+
+    return (encTypes[0] === 'client' && isSupportedVersion(encTypes[1]));
+};
+
+
+function isSupportedVersion(version) {
+    if (!/\d/.test(version)) {
+        return (false);
+    }
+
+    var major = parseInt(version, 10);
+
+    return (major === VERSION);
+};
+
+
+function validateHeaders(headers) {
+    var missingHeaders = [];
+    REQUIRED_HEADERS.forEach(function (header) {
+        if (headers[header] === undefined || headers[header] === null) {
+            missingHeaders.push(header);
+        }
+    });
+
+    if ((headers['m-encrypt-metadata'] !== undefined &&
+      headers['m-encrypt-metadata'] !== null) &&
+      !headers['m-encrypt-metadata-cipher']) {
+
+      missingHeaders.push('m-encrypt-metadata-cipher');
+    }
+
+    return (missingHeaders.length ? missingHeaders : null);
+}
+
+
+function decryptMetadata(headers, key, cb) {
+    if (!headers['m-encrypt-metadata']) {
+        cb();
+        return;
+    }
+
+    var algorithm = getAlgorithm(headers['m-encrypt-metadata-cipher']);
+    if (!algorithm) {
+        cb(new Error('Unsupported cipher algorithm: ' +
+            headers['m-encrypt-metadata-cipher']));
+        return;
+    }
+    var decipher = crypto.createDecipheriv(algorithm.string, key,
+        new Buffer(headers['m-encrypt-metadata-iv'], 'base64').toString());
+    var hmac = crypto.createHmac('sha256', key);
+
+    var bufs = [];
+    decipher.on('data', function (data) {
+        bufs.push(data);
+    });
+
+    decipher.once('finish', function () {
+        hmac.update(new Buffer(headers['m-encrypt-metadata'],
+            'base64').toString());
+
+        if (headers['m-encrypt-metadata-mac'] !== hmac.digest('base64')) {
+            cb(new Error('mac hash doesn\'t match'));
+            return;
+        }
+
+        headers['m-encrypt-metadata'] = Buffer.concat(bufs).toString();
+
+        cb();
+    });
+
+    decipher.write(new Buffer(headers['m-encrypt-metadata'],
+        'base64').toString());
+    decipher.end();
+}
+
+
+function encryptMetadata(headers, key, cb) {
+    var algorithm = getAlgorithm(headers['m-encrypt-metadata-cipher']);
+    if (!algorithm) {
+        cb(new Error('Unsupported cipher algorithm: ' +
+            headers['m-encrypt-metadata-cipher']));
+        return;
+    }
+
+    var iv = crypto.randomBytes(algorithm.ivBytes);
+    headers['m-encrypt-metadata-iv'] = new Buffer(iv).toString('base64');
+    var cipher = crypto.createCipheriv(algorithm.string, key, iv);
+    var hmac = crypto.createHmac('sha256', key);
+
+    var bufs = [];
+    function handleCipherData(data) {
+        bufs.push(data);
+    }
+
+    function handleCipherFinish() {
+        var encrypted = Buffer.concat(bufs);
+        headers['m-encrypt-metadata'] =
+            new Buffer(encrypted).toString('base64');
+        hmac.update(encrypted);
+        headers['m-encrypt-metadata-mac'] = hmac.digest('base64');
+        cb();
+    }
+
+    cipher.on('data', handleCipherData);
+    cipher.once('finish', handleCipherFinish);
+
+    cipher.once('error', function (err) {
+        cipher.removeListener('data', handleCipherData);
+        cipher.removeListener('finish', handleCipherFinish);
+        cb(new VError(err, 'failed reading cipher'));
+    });
+
+    cipher.write(headers['m-encrypt-metadata']);
+    cipher.end();
+}
+
+
+function getAlgorithm(cipher) {
+    return (CIPHERS.hasOwnProperty(cipher) && CIPHERS[cipher]);
+}
+
+function getHmacType(hmac) {
+    hmac = hmac.toLowerCase();
+    for (var i = 0, il = HMACS.length; i < il; ++i) {
+        var hmacType = HMACS[i];
+        if (hmacType.type.toLowerCase() === hmac) {
+            return (hmacType);
+        }
+    }
+}
diff --git a/lib/parse_etm_stream.js b/lib/parse_etm_stream.js
new file mode 100644
index 0000000..ec09ee8
--- /dev/null
+++ b/lib/parse_etm_stream.js
@@ -0,0 +1,69 @@
+// Copyright 2017 Joyent, Inc.
+
+var assert = require('assert-plus');
+var stream = require('stream');
+var util = require('util');
+
+
+// Takes cipher + hmac digest stream of data and untangles the two
+function ParseEtMStream(hmacType, contentLength, options) {
+    assert.object(hmacType, 'hmacType');
+    assert.number(hmacType.bytes, 'hmacType.bytes');
+
+    contentLength = parseInt(contentLength, 10);
+    assert.number(contentLength);
+
+    this._offset = (contentLength - hmacType.bytes);
+    this._digest = new Buffer('');
+    this._bytesRead = 0;
+    this._contentLength = contentLength;
+
+    stream.Transform.call(this, options);
+}
+util.inherits(ParseEtMStream, stream.Transform);
+
+
+// Pass the chunks through until you have reached the offset for the hmac
+// After the offset is reached, store the chunks in the _digest variable
+ParseEtMStream.prototype._transform =
+    function _transform(chunk, encoding, callback) {
+
+    var chunkSize = Buffer.byteLength(chunk);
+
+    // Check if we have reached the offset
+    if ((chunkSize + this._bytesRead) <= this._offset) {
+        this._bytesRead += chunkSize;
+        callback(null, chunk);
+        return;
+    }
+
+    // Get number of bytes to read from the chunk into the cipher stream
+    var bytesForCipher = this._offset - this._bytesRead;
+    this._bytesRead += chunkSize;
+
+    if (bytesForCipher > 0) {
+        var cipher = chunk.slice(0, bytesForCipher);
+        var hmac = chunk.slice(this._offset);
+        this._digest = Buffer.concat([this._digest, hmac]);
+
+        callback(null, cipher);
+        return;
+    }
+
+    this._digest = Buffer.concat([this._digest, chunk]);
+
+    // Mark the stream as processed
+    if (this._bytesRead === this._contentLength) {
+        this.push(null);
+    }
+
+    callback();
+};
+
+
+ParseEtMStream.prototype.digest = function digest() {
+    return (this._digest);
+};
+
+
+module.exports = ParseEtMStream;
diff --git a/test/client.test.js b/test/client.test.js
index 7b27aab..63d93db 100644
--- a/test/client.test.js
+++ b/test/client.test.js
@@ -33,6 +33,7 @@ var SPECIALOBJ1 = SUBDIR1 + '/' + 'before-\r-after';
 
 var SUBDIR1_NOBJECTS = 1;
 var SUBDIR1_NDIRECTORIES = 2;
+var CSE_KEY = 'FFFFFFFBD96783C6C91E222211112222';
 
 
 /*
@@ -52,6 +53,9 @@ module.exports.setUp = function (cb) {
     var self = this;
     var url = process.env.MANTA_URL || 'http://localhost:8080';
     var user = process.env.MANTA_USER || 'admin';
+    function getKey(keyId, next) {
+        next(null, CSE_KEY);
+    }
 
     function createClient(signer) {
         self.client = manta.createClient({
@@ -61,7 +65,10 @@ module.exports.setUp = function (cb) {
                                     false : true),
             sign: signer,
             url: url,
-            user: user
+            user: user,
+            encrypt: {
+                getKey: getKey
+            }
         });
 
         cb();
@@ -163,6 +170,29 @@ test('#231: put (special characters)', function (t) {
     });
 });
 
+test('put (encrypt stream)', function (t) {
+    var text = 'The lazy brown fox \nsomething \nsomething foo';
+    var stream = new MemoryStream();
+    var options = {
+        encrypt: {
+            key: CSE_KEY,
+            keyId: 'dev/test',
+            cipher: 'AES/CTR/NoPadding'
+        }
+    };
+
+    this.client.put(ROOT + '/encrypted', stream, options, function (err, res) {
+        t.ifError(err);
+        t.ok(res.req._headers['m-encrypt-key-id']);
+        t.done();
+    });
+
+    process.nextTick(function () {
+        stream.write(text);
+        stream.end();
+    });
+});
+
 test('#231: ls (special characters)', function (t) {
     this.client.ls(SUBDIR1, function (err, res) {
         t.ifError(err);
@@ -196,6 +226,97 @@ test('#231: get (special characters)', function (t) {
     });
 });
 
+test('get (decrypt stream)', function (t) {
+    var self = this;
+    var text = 'The lazy brown fox \nsomething \nsomething foo';
+    var stream = new MemoryStream();
+    var fpath = ROOT + '/todecrypt';
+    var key = CSE_KEY;
+    var options = {
+        encrypt: {
+            key: key,
+            keyId: 'dev/test',
+            cipher: 'AES/CTR/NoPadding'
+        }
+    };
+
+    self.client.put(fpath, stream, options, function (putErr, putRes) {
+        t.ifError(putErr);
+        t.ok(putRes.req._headers['m-encrypt-key-id']);
+        setTimeout(function () {
+          self.client.get(fpath, function (getErr, decrypted, getRes) {
+              t.ifError(getErr);
+
+              var result = '';
+              decrypted.on('data', function (data) {
+                  result += data.toString();
+              });
+
+              decrypted.once('end', function () {
+                  t.ok(result === text);
+                  t.done();
+              });
+
+              decrypted.on('error', function (decErr) {
+                  t.ifError(decErr);
+              });
+          });
+        }, 10);
+    });
+
+    process.nextTick(function () {
+        stream.write(text);
+        stream.end();
+    });
+});
+
+
+test('get (decrypt stream) by overriding getKey()', function (t) {
+    var self = this;
+    var text = 'The lazy brown fox';
+    var stream = new MemoryStream();
+    var fpath = ROOT + '/todecrypt_getKey';
+    var key = 'FFFFFFFBD96783C6C91E222211111111';
+    var options = {
+        encrypt: {
+            key: key,
+            keyId: 'dev/test',
+            cipher: 'AES/CTR/NoPadding'
+        }
+    };
+
+    function getKey(keyId, next) {
+        next(null, key);
+    }
+
+    self.client.put(fpath, stream, options, function (putErr, putRes) {
+        t.ifError(putErr);
+        t.ok(putRes.req._headers['m-encrypt-key-id']);
+        setTimeout(function () {
+          self.client.get(fpath, {encrypt: {getKey: getKey}},
+              function (getErr, decrypted, getRes) {
+
+              t.ifError(getErr);
+
+              var result = '';
+              decrypted.on('data', function (data) {
+                result += data.toString();
+              });
+
+              decrypted.once('end', function () {
+                t.ok(result === text);
+                t.done();
+              });
+          });
+        }, 10);
+    });
+
+    process.nextTick(function () {
+        stream.write(text);
+        stream.end();
+    });
+});
+
 
 test('#231: rm (special characters)', function (t) {
     this.client.unlink(SPECIALOBJ1, function (err) {
diff --git a/test/cse.test.js b/test/cse.test.js
new file mode 100644
index 0000000..55672f7
--- /dev/null
+++ b/test/cse.test.js
@@ -0,0 +1,165 @@
+// Copyright 2017 Joyent, Inc.
+
+var MemoryStream = require('readable-stream/passthrough.js');
+
+var cse = require('../lib/cse');
+
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+
+test('isSupported() returns false for invalid versions', function (t) {
+    var versions = [
+        '',
+        null,
+        'client/0',
+        'client/0.',
+        'client/b.b',
+        'client/'
+    ];
+
+    versions.forEach(function (version) {
+        t.ok(!cse.isSupported({ 'm-encrypt-type': version }));
+    });
+    t.done();
+});
+
+
+test('isSupported() returns true for valid versions', function (t) {
+    var versions = [
+        'client/1'
+    ];
+
+    versions.forEach(function (version) {
+        t.ok(cse.isSupported({ 'm-encrypt-type': version }));
+    });
+    t.done();
+});
+
+
+test('encrypt() throws with missing options', function (t) {
+    var input = new MemoryStream();
+
+    t.throws(function () {
+        cse.encrypt(null, input, function (err, res) {
+
+        });
+    }, /options \(object\) is required/);
+
+    t.done();
+});
+
+
+test('encrypt() throws with unsupported cipher alg', function (t) {
+    var options = {
+        key: 'FFFFFFFBD96783C6C91E222211112222',
+        cipher: 'AES/CFB/NoPadding',
+        keyId: 'something',
+        headers: {}
+    };
+    var input = new MemoryStream();
+
+    t.throws(function () {
+        cse.encrypt(options, input, function (err, res) {
+
+        });
+    }, /Unsupported cipher algorithm/);
+
+    t.done();
+});
+
+test('encrypt() throws with alg "toString"', function (t) {
+    var options = {
+        key: 'FFFFFFFBD96783C6C91E222211112222',
+        cipher: 'toString',
+        keyId: 'something',
+        headers: {}
+    };
+    var input = new MemoryStream();
+
+    t.throws(function () {
+        cse.encrypt(options, input, function (err, res) {
+
+        });
+    }, /Unsupported cipher algorithm/);
+
+    t.done();
+});
+
+test('encrypt() throws with invalid key length', function (t) {
+    var options = {
+        key: 'FFFFFF',
+        cipher: 'AES/CTR/NoPadding',
+        keyId: 'something',
+        headers: {}
+    };
+    var input = new MemoryStream();
+
+    t.throws(function () {
+        cse.encrypt(options, input, function (err, res) {
+
+        });
+    }, /Invalid key length/);
+
+    t.done();
+});
+
+test('encrypt() throws with invalid input', function (t) {
+    var options = {
+        key: 'FFFFFFFBD96783C6C91E222211112222',
+        keyId: 'dev/test',
+        cipher: 'AES/CTR/NoPadding',
+        headers: {}
+    };
+
+    t.throws(function () {
+        cse.encrypt(options, null, function (err, res) {
+
+        });
+    }, /input \(stream\) is required/);
+
+    t.done();
+});
+
+
+test('decrypt() throws with missing options', function (t) {
+    var input = new MemoryStream();
+
+    t.throws(function () {
+        cse.decrypt(null, input, { headers: {} }, function (err, res) {
+
+        });
+    }, /options \(object\) is required/);
+
+    t.done();
+});
+
+test('decrypt() throws with missing options.encrypt.getKey', function (t) {
+    var input = new MemoryStream();
+
+    t.throws(function () {
+        cse.decrypt({}, input, { headers: {} }, function (err, res) {
+
+        });
+    }, /options\.getKey \(func\) is required/);
+
+    t.done();
+});
+
+test('decrypt() throws with invalid input', function (t) {
+    var options = {
+        cse_getKey: function (keyId, cb) {
+            cb();
+        }
+    };
+
+    t.throws(function () {
+        cse.decrypt(options, null, { headers: {} }, function (err, res) {
+
+        });
+    }, /encrypted \(stream\) is required/);
+
+    t.done();
+});
diff --git a/test/parse_etm_stream.test.js b/test/parse_etm_stream.test.js
new file mode 100644
index 0000000..50a6068
--- /dev/null
+++ b/test/parse_etm_stream.test.js
@@ -0,0 +1,103 @@
+// Copyright 2017 Joyent, Inc.
+
+var MemoryStream = require('readable-stream/passthrough.js');
+var ParseEtMStream = require('../lib/parse_etm_stream');
+
+
+function test(name, testfunc) {
+    module.exports[name] = testfunc;
+}
+
+
+test('splits a digest from the parse_etm stream', function (t) {
+    var inputCipher = new Buffer(50);
+    var inputDigest = new Buffer(32);
+    inputCipher.fill('3');
+    inputDigest.fill('4');
+
+    var input = new MemoryStream();
+    var output = new ParseEtMStream({ bytes: 32 },
+        Buffer.byteLength(inputCipher) + Buffer.byteLength(inputDigest));
+
+    var cipher = new Buffer('');
+    output.on('data', function (data) {
+        cipher = Buffer.concat([cipher, data]);
+    });
+
+    output.once('end', function () {
+        t.equal(cipher.toString(), inputCipher.toString());
+        t.equal(output.digest().toString(), inputDigest.toString());
+        t.done();
+    });
+
+    input.pipe(output);
+    input.write(inputCipher);
+    input.write(inputDigest);
+});
+
+
+test('splits a multi-chunk digest from the parse_etm stream', function (t) {
+    var inputCipher = new Buffer(50);
+    var inputDigest1 = new Buffer(16);
+    var inputDigest2 = new Buffer(16);
+    inputCipher.fill('3');
+    inputDigest1.fill('4');
+    inputDigest2.fill('4');
+
+    var input = new MemoryStream();
+    var output = new ParseEtMStream({ bytes: 32 },
+        Buffer.byteLength(inputCipher) + Buffer.byteLength(inputDigest1) +
+        Buffer.byteLength(inputDigest2));
+
+    var cipher = new Buffer('');
+    output.on('data', function (data) {
+        cipher = Buffer.concat([cipher, data]);
+    });
+
+    output.once('end', function () {
+        t.equal(cipher.toString(), inputCipher.toString());
+        t.equal(output.digest().toString(), inputDigest1.toString() +
+            inputDigest2.toString());
+        t.done();
+    });
+
+    input.pipe(output);
+    input.write(inputCipher);
+    input.write(inputDigest1);
+    input.write(inputDigest2);
+});
+
+test('splits a multi-chunk digest from multi-chunk cipher', function (t) {
+    var inputCipher1 = new Buffer(50);
+    var inputCipher2 = new Buffer(50);
+    var inputDigest1 = new Buffer(16);
+    var inputDigest2 = new Buffer(16);
+    inputCipher1.fill('3');
+    inputCipher2.fill('3');
+    inputDigest1.fill('4');
+    inputDigest2.fill('4');
+
+    var input = new MemoryStream();
+    var output = new ParseEtMStream({ bytes: 32 },
+        Buffer.byteLength(inputCipher1) + Buffer.byteLength(inputCipher2) +
+        Buffer.byteLength(inputDigest1) + Buffer.byteLength(inputDigest2));
+
+    var cipher = new Buffer('');
+    output.on('data', function (data) {
+        cipher = Buffer.concat([cipher, data]);
+    });
+
+    output.once('end', function () {
+        t.equal(cipher.toString(), inputCipher1.toString() +
+            inputCipher2.toString());
+        t.equal(output.digest().toString(), inputDigest1.toString() +
+            inputDigest2.toString());
+        t.done();
+    });
+
+    input.pipe(output);
+    input.write(inputCipher1);
+    input.write(inputCipher2);
+    input.write(inputDigest1);
+    input.write(inputDigest2);
+});
