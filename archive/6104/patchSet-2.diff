commit 520d2ebbc5f8b12a2b6197af99d8aaeb2fa8c16d
Author: Dave Eddy <dave@daveeddy.com>
Date:   2019-04-11T20:06:50-04:00 (6 months ago)
    
    joyent/node-boray#6 want sort, limit, and prefix support for listing buckets and objects

diff --git a/lib/buckets.js b/lib/buckets.js
index 6571596..eb85909 100644
--- a/lib/buckets.js
+++ b/lib/buckets.js
@@ -16,6 +16,7 @@
  */
 
 var EventEmitter = require('events').EventEmitter;
+var stream = require('stream');
 
 var assert = require('assert-plus');
 var libuuid = require('libuuid');
@@ -238,21 +239,32 @@ function deleteBucketNoVnode(rpcctx, owner, bucket, callback) {
     });
 }
 
-function listBuckets(rpcctx, owner, vnode) {
+/*
+ * This function talks to boray
+ */
+function listBuckets(rpcctx, owner, orderby, prefix, limit, offset, vnode) {
     assert.object(rpcctx, 'rpcctx');
     assert.string(owner, 'owner');
+    assert.string(orderby, 'orderby');
+    assert.string(prefix, 'prefix');
+    assert.number(limit, 'limit');
+    assert.number(offset, 'offset');
     assert.number(vnode, 'vnode');
 
     var opts = makeBucketOptions({});
 
     var arg = {
         owner: owner,
+        orderby: orderby,
+        prefix: prefix,
+        limit: limit,
+        offset: offset,
         vnode: vnode
     };
 
     var log = rpc.childLogger(rpcctx, opts);
 
-    var res = new EventEmitter();
+    var res = new stream.PassThrough({objectMode: true});
 
     var req = rpc.rpcCommon({
         rpcctx: rpcctx,
@@ -269,19 +281,26 @@ function listBuckets(rpcctx, owner, vnode) {
         res.emit('_boray_internal_rpc_done');
     });
 
-    req.on('data', function (msg) {
-        res.emit('record', msg);
-    });
+    req.pipe(res, {end: false});
 
     return (res);
 }
 
-function listBucketsNoVnode(rpcctx, owner) {
+/*
+ * This function talks to electric-boray
+ */
+function listBucketsNoVnode(rpcctx, owner, sorted, orderby, prefix, limit) {
     assert.object(rpcctx, 'rpcctx');
     assert.string(owner, 'owner');
+    assert.bool(sorted, 'sorted');
+    assert.string(orderby, 'orderby');
+    assert.string(prefix, 'prefix');
+    assert.number(limit, 'limit');
 
     var opts = makeBucketOptions({});
 
+    var arg = [owner, sorted, orderby, prefix, limit];
+
     var log = rpc.childLogger(rpcctx, opts);
 
     var res = new EventEmitter();
@@ -289,7 +308,7 @@ function listBucketsNoVnode(rpcctx, owner) {
     var req = rpc.rpcCommon({
         rpcctx: rpcctx,
         rpcmethod: 'listbuckets',
-        rpcargs: [owner],
+        rpcargs: arg,
         log: log
     }, function (err) {
         if (err) {
diff --git a/lib/client.js b/lib/client.js
index d208580..66b7b0d 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -596,7 +596,9 @@ BorayClient.prototype.getBucketNoVnode = function getBucketNoVnode(o, b, cb) {
 /**
  * Lists buckets
  */
-BorayClient.prototype.listBuckets = function listBuckets(owner, vnode) {
+BorayClient.prototype.listBuckets =
+    function listBuckets(owner, orderby, prefix, limit, offset, vnode) {
+
     var rpcctx = this.ctxCreateForEmitter();
     var rv;
 
@@ -604,13 +606,16 @@ BorayClient.prototype.listBuckets = function listBuckets(owner, vnode) {
         return (emitUnavailable());
     }
 
-    rv = buckets.listBuckets(rpcctx, owner, vnode);
+    rv = buckets.listBuckets(rpcctx, owner, orderby, prefix, limit, offset,
+        vnode);
     this.releaseWhenDone(rpcctx, rv);
 
     return (rv);
 };
 
-BorayClient.prototype.listBucketsNoVnode = function listBucketsNoVnode(owner) {
+BorayClient.prototype.listBucketsNoVnode =
+    function listBucketsNoVnode(owner, sorted, orderby, prefix, limit) {
+
     var rpcctx = this.ctxCreateForEmitter();
     var rv;
 
@@ -618,7 +623,8 @@ BorayClient.prototype.listBucketsNoVnode = function listBucketsNoVnode(owner) {
         return (emitUnavailable());
     }
 
-    rv = buckets.listBucketsNoVnode(rpcctx, owner);
+    rv = buckets.listBucketsNoVnode(rpcctx, owner, sorted, orderby, prefix,
+        limit);
     this.releaseWhenDone(rpcctx, rv);
 
     return (rv);
@@ -802,10 +808,11 @@ BorayClient.prototype.getObjectNoVnode =
 };
 
 /**
- * Lists objects
+ * List objects - talks to boray
  */
 BorayClient.prototype.listObjects =
-    function listObjects(owner, bucket_id, vnode) {
+    function listObjects(owner, bucket_id, orderby, prefix, limit, offset,
+        vnode) {
 
     var rpcctx = this.ctxCreateForEmitter();
     var rv;
@@ -814,14 +821,19 @@ BorayClient.prototype.listObjects =
         return (emitUnavailable());
     }
 
-    rv = objects.listObjects(rpcctx, owner, bucket_id, vnode);
+    rv = objects.listObjects(rpcctx, owner, bucket_id, orderby, prefix, limit,
+        offset, vnode);
     this.releaseWhenDone(rpcctx, rv);
 
     return (rv);
 };
 
+/**
+ * Lists objects - talks to electric-boray
+ */
 BorayClient.prototype.listObjectsNoVnode =
-    function listObjectsNoVnode(owner, bucket_id) {
+    function listObjectsNoVnode(owner, bucket_id, sorted, orderby, prefix,
+        limit) {
 
     var rpcctx = this.ctxCreateForEmitter();
     var rv;
@@ -830,7 +842,8 @@ BorayClient.prototype.listObjectsNoVnode =
         return (emitUnavailable());
     }
 
-    rv = objects.listObjectsNoVnode(rpcctx, owner, bucket_id);
+    rv = objects.listObjectsNoVnode(rpcctx, owner, bucket_id, sorted, orderby,
+        prefix, limit);
     this.releaseWhenDone(rpcctx, rv);
 
     return (rv);
@@ -878,6 +891,89 @@ BorayClient.prototype.deleteObjectNoVnode =
 };
 
 
+/**
+ * Finds object matching a given filter
+ *
+ * See https://mo.joyent.com/docs/moray/master/#FindObjects for more info.
+ *
+ * @param {String} b      - Bucket name
+ * @param {Object} opts   - request parameters
+ * @return {EventEmitter} - listen for 'record', 'end' and 'error'
+ */
+BorayClient.prototype.findObjects = function findObjects(b, opts) {
+    assert.string(b, 'bucket');
+    assert.object(opts, 'opts');
+    assert.string(opts.path, 'opts.path');
+    assert.bool(opts.sorted, 'opts.sorted');
+    assert.string(opts.orderby, 'opts.orderby');
+    assert.number(opts.limit, 'opts.limit');
+    assert.string(opts.prefix, 'opts.prefix');
+    assert.optionalObject(opts.bucket_data, 'opts.bucket_data');
+
+    this.log.warn({b: b, opts: opts},
+        'BorayClient.prototype.findObjects');
+
+    var bucket_data = opts.bucket_data || {};
+
+    opts = jsprim.mergeObjects(opts, null, {
+        requireIndexes: this.requireIndexes,
+        requireOnlineReindexing: this.requireOnlineReindexing
+    });
+
+    var rpcctx = this.ctxCreateForEmitter();
+    if (!rpcctx) {
+        return (emitUnavailable());
+    }
+
+    /*
+     * For manta buckets, we do some special work to break down the hash key
+     * and figure out if the request is to list the buckets, or the contents of
+     * a bucket.
+     *
+     * XXX I don't know if this is the best way to do this or the best place
+     * for the logic but yolo.
+     */
+    var key = path.normalize(opts.path);
+
+    this.log.debug({key: key}, 'findObjects key: %s', key);
+
+    assert.equal(key[0], '/', 'path begin with /');
+    var parts = key.substr(1).split('/');
+    var owner = parts[0];
+    var bucket;
+
+    assert.equal(parts[1], 'buckets', 'part 2 buckets');
+
+    // check if user wants to list bucket contents
+    if (parts[2]) {
+        bucket = parts[2];
+        assert.string(bucket, 'bucket');
+        assert(bucket.length > 0, 'bucket.length > 0');
+
+        assert.equal(parts[3], 'objects', 'part 3 objects');
+        assert(!parts[4], 'extra garbage in path');
+    }
+
+    this.log.debug({parts: parts, bucket: bucket},
+        'findObjects key parsed');
+
+    var rv;
+
+    if (bucket) {
+        assert.equal(bucket, bucket_data.name, 'bucket_data.name the same');
+        assert.equal(owner, bucket_data.owner, 'bucket_data.owner the same');
+        rv = objects.listObjectsNoVnode(rpcctx, owner, bucket_data.id,
+            opts.sorted, opts.orderby, opts.prefix, opts.limit);
+    } else {
+        rv = buckets.listBucketsNoVnode(rpcctx, owner, opts.sorted,
+            opts.orderby, opts.prefix, opts.limit);
+    }
+
+    this.releaseWhenDone(rpcctx, rv);
+    return (rv);
+};
+BorayClient.prototype.find = BorayClient.prototype.findObjects;
+
 /**
  * Performs a ping check against the server.
  *
@@ -969,16 +1065,14 @@ BorayRpcContext.prototype.unwrapErrors = function unwrapErrors() {
 };
 
 BorayRpcContext.prototype.createLog = function createLog(options) {
-    var reqid;
     assert.optionalObject(options, 'options');
+    options = jsprim.deepCopy(options || {});
 
-    if (options && options.req_id) {
-        reqid = options.req_id;
-    } else {
-        reqid = libuuid.create();
+    if (!options.req_id) {
+        options.req_id = libuuid.create();
     }
 
-    return (this.mc_boray.log.child({ 'req_id': reqid }, true));
+    return (this.mc_boray.log.child(options, true));
 };
 
 
diff --git a/lib/object.js b/lib/objects.js
similarity index 91%
rename from lib/object.js
rename to lib/objects.js
index 9da2e28..62060f1 100644
--- a/lib/object.js
+++ b/lib/objects.js
@@ -16,6 +16,7 @@
  */
 
 var EventEmitter = require('events').EventEmitter;
+var stream = require('stream');
 
 var assert = require('assert-plus');
 var jsprim = require('jsprim');
@@ -273,25 +274,33 @@ function deleteObjectNoVnode(rpcctx, owner, bucket_id, name, callback) {
 }
 
 
-function listObjects(rpcctx, owner, bucket_id, vnode) {
-    var opts, log;
+function listObjects(rpcctx, owner, bucket_id, orderby, prefix, limit, offset,
+    vnode) {
 
     assert.object(rpcctx, 'rpcctx');
     assert.string(owner, 'owner');
     assert.string(bucket_id, 'bucket_id');
+    assert.string(orderby, 'orderby');
+    assert.string(prefix, 'prefix');
+    assert.number(limit, 'limit');
+    assert.number(offset, 'offset');
     assert.number(vnode, 'vnode');
 
-    opts = makeOptions({});
-
     var arg = {
         owner: owner,
         bucket_id: bucket_id,
+        orderby: orderby,
+        prefix: prefix,
+        limit: limit,
+        offset: offset,
         vnode: vnode
     };
 
-    log = rpc.childLogger(rpcctx, opts);
+    var opts = makeOptions(arg);
 
-    var res = new EventEmitter();
+    var log = rpc.childLogger(rpcctx, opts);
+
+    var res = new stream.PassThrough({objectMode: true});
 
     var req = rpc.rpcCommon({
         rpcctx: rpcctx,
@@ -308,19 +317,23 @@ function listObjects(rpcctx, owner, bucket_id, vnode) {
         res.emit('_boray_internal_rpc_done');
     });
 
-    req.on('data', function (msg) {
-        res.emit('record', msg);
-    });
+    req.pipe(res, {end: false});
 
     return (res);
 }
 
-function listObjectsNoVnode(rpcctx, owner, bucket_id) {
+function listObjectsNoVnode(rpcctx, owner, bucket_id, sorted, orderby, prefix,
+    limit) {
+
     var opts, log;
 
     assert.object(rpcctx, 'rpcctx');
     assert.string(owner, 'owner');
     assert.string(bucket_id, 'bucket_id');
+    assert.bool(sorted, 'sorted');
+    assert.string(orderby, 'orderby');
+    assert.string(prefix, 'prefix');
+    assert.number(limit, 'limit');
 
     opts = makeOptions({});
 
@@ -331,7 +344,7 @@ function listObjectsNoVnode(rpcctx, owner, bucket_id) {
     var req = rpc.rpcCommon({
         rpcctx: rpcctx,
         rpcmethod: 'listobjects',
-        rpcargs: [owner, bucket_id],
+        rpcargs: [owner, bucket_id, sorted, orderby, prefix, limit],
         log: log
     }, function (err) {
         if (err) {
