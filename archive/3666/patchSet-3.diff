commit 29a0e0fee839b4cb7ee3e8f39e2dc1162274569d (refs/changes/66/3666/3)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-03-16T21:08:21+00:00 (1 year, 7 months ago)
    
    TRITON-75 Allow firewall rules to be applied in order of priority (sync w/ smartos-live)
    TRITON-77 Add support for ESP and AH protocols in firewall rules (sync w/ smartos-live)
    TRITON-95 Failure to write ipf(6).conf for a zone shouldn't block reloading other zones' firewalls (sync w/ smartos-live)
    Reviewed by: Alex Wilson <alex.wilson@joyent.com>
    Approved by: Alex Wilson <alex.wilson@joyent.com>

diff --git a/deps/fw/lib/fw.js b/deps/fw/lib/fw.js
index ebc0a0a..669fc83 100644
--- a/deps/fw/lib/fw.js
+++ b/deps/fw/lib/fw.js
@@ -21,7 +21,7 @@
  * CDDL HEADER END
  *
  *
- * Copyright 2017, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: Main entry points
@@ -32,6 +32,7 @@ var clone = require('clone');
 var filter = require('./filter');
 var fs = require('fs');
 var mkdirp = require('mkdirp');
+var mod_addr = require('ip6addr');
 var mod_ipf = require('./ipf');
 var mod_lock = require('./locker');
 var mod_obj = require('./util/obj');
@@ -64,6 +65,8 @@ var IPF_CONF = '%s/config/ipf.conf';
 var IPF_CONF_OLD = '%s/config/ipf.conf.old';
 var IPF6_CONF = '%s/config/ipf6.conf';
 var IPF6_CONF_OLD = '%s/config/ipf6.conf.old';
+var KEEP_FRAGS = ' keep frags';
+var KEEP_STATE = ' keep state';
 var NOT_RUNNING_MSG = 'Could not find running zone';
 // VM fields that affect filtering
 var VM_FIELDS = [
@@ -121,10 +124,17 @@ function assertStringOrObject(obj, name) {
  * For a rule and a direction, return whether or not we actually need to
  * write ipf rules. FROM+ALLOW and TO+BLOCK are essentially no-ops, as
  * they will be caught by the block / allow catch-all default rules.
+ *
+ * If the rule has a priority greater than 0, then we always need to write
+ * out ipf rules.
  */
 function noRulesNeeded(dir, rule) {
+    if (rule.priority !== 0) {
+        return false;
+    }
+
     if ((dir === 'from' && rule.action === 'allow')
-            || (dir === 'to' && rule.action === 'block')) {
+        || (dir === 'to' && rule.action === 'block')) {
         return true;
     }
     return false;
@@ -443,7 +453,7 @@ function createVMlookup(vms, log, callback) {
 
         var vm = {
             enabled: fullVM.firewall_enabled || false,
-            ips: util_vm.ipsFromNICs(fullVM.nics),
+            ips: util_vm.ipsFromNICs(fullVM.nics).sort(mod_addr.compare),
             owner_uuid: fullVM.owner_uuid,
             state: fullVM.state,
             tags: fullVM.tags,
@@ -900,6 +910,166 @@ function protoTarget(rule, target) {
 }
 
 
+/**
+ * Compare two port targets. Valid values are "all", numbers, or an object
+ * representing a port range containing "start" and "end" fields.
+ */
+function comparePorts(p1, p2) {
+    // "all" comes before any port numbers
+    if (p1 === 'all') {
+        if (p2 === 'all') {
+            return 0;
+        } else {
+            return -1;
+        }
+    } else if (p2 === 'all') {
+        return 1;
+    }
+
+    var n1 = p1.hasOwnProperty('start') ? p1.start : p1;
+    var n2 = p2.hasOwnProperty('start') ? p2.start : p2;
+
+    return Number(n1) - Number(n2);
+}
+
+
+/**
+ * Compare two ICMP type targets. Valid values are "all" or strings like "5" or
+ * "5:3", representing the ICMP type number and code.
+ */
+function compareTypes(t1, t2) {
+    // "all" comes before any types
+    if (t1 === 'all') {
+        if (t2 === 'all') {
+            return 0;
+        } else {
+            return -1;
+        }
+    } else if (t2 === 'all') {
+        return 1;
+    }
+
+    var p1 = t1.split(':');
+    var p2 = t2.split(':');
+    var c = Number(p1[0]) - Number(p2[0]);
+    if (c !== 0) {
+        return c;
+    }
+
+    if (p1.length === 1) {
+        if (p2.length === 1) {
+            return 0;
+        } else {
+            return -1;
+        }
+    } else if (p2.length === 1) {
+        return 1;
+    } else {
+        return Number(p1[1]) - Number(p2[1]);
+    }
+}
+
+
+/**
+ * Compare IP and subnet targets from an ipf rule object.
+ */
+function compareAddrs(a1, a2) {
+    var s1 = a1.split('/');
+    var s2 = a2.split('/');
+
+    return mod_addr.compare(s1[0], s2[0]);
+}
+
+
+/**
+ * This comparison function is used to sort the output ipf rule objects
+ * in the following order:
+ *
+ * 1. First by protocol: icmp, icmp6, tcp, udp.
+ * 2. Then by direction: outbound rules, then inbound.
+ * 3. By priority level (higher priorities come first).
+ * 4. By action:
+ *   a) For outbound traffic, block comes before allow.
+ *   b) For inbound traffic, allow comes before block.
+ * 5. By the first port or type listed.
+ * 6. By the first targeted IP.
+ *
+ * 1 and 2 help apply some organization to the output file.
+ * 5 and 6 help make testing easier by putting things in a predictable order.
+ *
+ * 3 and 4 are the actual, important metric to sort on: priority and action
+ * are important for ensuring that the actions taken by ipfilter are applied in
+ * the order that fwadm(1M) describes.
+ */
+function compareRules(r1, r2) {
+    var res;
+
+    // Protocol:
+    if (r1.protocol < r2.protocol) {
+        return -1;
+    }
+
+    if (r1.protocol > r2.protocol) {
+        return 1;
+    }
+
+    // Direction:
+    if (r1.direction < r2.direction) {
+        return -1;
+    }
+
+    if (r1.direction > r2.direction) {
+        return 1;
+    }
+
+    // Priority levels:
+    if (r1.priority < r2.priority) {
+        return 1;
+    }
+
+    if (r1.priority > r2.priority) {
+        return -1;
+    }
+
+    // Action:
+    if (r1.direction === 'from') {
+        if (r1.action === 'allow') {
+            if (r2.action === 'block') {
+                return 1;
+            }
+        } else if (r2.action === 'allow') {
+            if (r1.action === 'block') {
+                return -1;
+            }
+        }
+    } else {
+        if (r1.action === 'allow') {
+            if (r2.action === 'block') {
+                return -1;
+            }
+        } else if (r2.action === 'allow') {
+            if (r1.action === 'block') {
+                return 1;
+            }
+        }
+    }
+
+    // Ports and types:
+    if (icmpr.test(r1.protocol)) {
+        res = compareTypes(r1.protoTargets[0], r2.protoTargets[0]);
+    } else {
+        res = comparePorts(r1.protoTargets[0], r2.protoTargets[0]);
+    }
+
+    if (res !== 0) {
+        return res;
+    }
+
+    // Target IPs and subnets:
+    return compareAddrs(r1.targets[0], r2.targets[0]);
+}
+
+
 /**
  * Returns an object containing ipf rule text and enough data to sort on
  */
@@ -907,19 +1077,23 @@ function ipfRuleObj(opts) {
     var dir = opts.direction;
     var rule = opts.rule;
 
+    var targets = Array.isArray(opts.targets) ?
+        opts.targets : [ opts.targets ];
+
     // ipfilter uses /etc/protocols which calls ICMPv6 'ipv6-icmp'
     var ipfProto = (rule.protocol === 'icmp6') ? 'ipv6-icmp' : rule.protocol;
 
     var sortObj = {
         action: rule.action,
         direction: dir,
+        priority: rule.priority,
         protocol: rule.protocol,
-        v4text: [ '', util.format('# rule=%s, version=%s, %s=%s',
-            rule.uuid, rule.version, opts.type, opts.value)
-        ],
-        v6text: [ '', util.format('# rule=%s, version=%s, %s=%s',
-            rule.uuid, rule.version, opts.type, opts.value)
-        ],
+        header: util.format('\n# rule=%s, version=%s, %s=%s',
+            rule.uuid, rule.version, opts.type, opts.value),
+        v4text: [],
+        v6text: [],
+        targets: targets,
+        protoTargets: rule.protoTargets,
         type: opts.type,
         uuid: rule.uuid,
         value: opts.value,
@@ -927,7 +1101,7 @@ function ipfRuleObj(opts) {
     };
 
     if (opts.type === 'wildcard' && opts.value === 'any') {
-        rule.protoTargets.sort().forEach(function (t) {
+        rule.protoTargets.forEach(function (t) {
             var wild = util.format('%s %s quick proto %s from any to any %s',
                 rule.action === 'allow' ? 'pass' : 'block',
                 dir === 'from' ? 'out' : 'in',
@@ -942,9 +1116,6 @@ function ipfRuleObj(opts) {
         return sortObj;
     }
 
-    var targets = Array.isArray(opts.targets) ?
-        opts.targets : [ opts.targets ];
-
     targets.forEach(function (target) {
         var isv6 = target.indexOf(':') !== -1;
 
@@ -956,8 +1127,7 @@ function ipfRuleObj(opts) {
 
         var text = isv6 ? sortObj.v6text : sortObj.v4text;
 
-        // XXX: need to do Number() on these before sorting?
-        rule.protoTargets.sort().forEach(function (t) {
+        rule.protoTargets.forEach(function (t) {
             text.push(
                 util.format('%s %s quick proto %s from %s to %s %s',
                     rule.action === 'allow' ? 'pass' : 'block',
@@ -1008,15 +1178,45 @@ function prepareIPFdata(opts, log, callback) {
         }, {});
     }
 
-    rules.forEach(function (rule) {
+    /* Gather the VMs targeted on each side of every enabled rule. */
+    var targetVMs = rules.map(function (rule) {
         if (!rule.enabled) {
-            return;
+            return null;
         }
 
-        var ruleVMs = {
+        return {
             from: vmsOnSide(allVMs, rule, 'from', log),
             to: vmsOnSide(allVMs, rule, 'to', log)
         };
+    });
+
+    /*
+     * If we block outbound traffic for a protocol, make sure to also track
+     * inbound state for anything allowed, so that we'll allow response
+     * packets.
+     *
+     * We could just always enable state tracking for all of our inbound
+     * allow rules, but state tracking can get pretty expensive. There's no
+     * need to penalize all firewall users.
+     */
+    var keepInboundState = { };
+    rules.forEach(function (rule, i) {
+        if (!rule.enabled || rule.action === 'allow') {
+            return;
+        }
+
+        targetVMs[i].from.forEach(function (uuid) {
+            if (!hasKey(keepInboundState, uuid)) {
+                keepInboundState[uuid] = {};
+            }
+            keepInboundState[uuid][rule.protocol] = true;
+        });
+    });
+
+    rules.forEach(function (rule, i) {
+        if (!rule.enabled) {
+            return;
+        }
 
         DIRECTIONS.forEach(function (dir) {
             // XXX: add to errors here if missing
@@ -1027,65 +1227,69 @@ function prepareIPFdata(opts, log, callback) {
                 return;
             }
 
-            var otherSideRules = rulesFromOtherSide(rule, dir, allVMs,
-                remoteVMs);
+            var otherSideRules =
+                rulesFromOtherSide(rule, dir, allVMs, remoteVMs);
 
-            ruleVMs[dir].forEach(function (uuid) {
-                // If the VM's firewall is disabled, we don't need to write out
-                // rules for it
-                if (!allVMs.all[uuid].enabled) {
+            targetVMs[i][dir].forEach(function (uuid) {
+                /*
+                 * If the VM's firewall is disabled, we don't need to write out
+                 * rules for it.
+                 */
+                if (!allVMs.all[uuid].enabled || !hasKey(conf, uuid)) {
                     return;
                 }
 
-                otherSideRules.forEach(function (oRule) {
-                    if (!hasKey(conf, uuid)) {
-                        return;
-                    }
-
-                    conf[uuid].push(oRule);
-                });
+                conf[uuid] = conf[uuid].concat(otherSideRules);
             });
         });
     });
 
-    var toReturn = { files: {}, vms: [] };
+    var toReturn = [];
     for (var vm in conf) {
         var rulesIncluded = {};
-        var v4filename = util.format(IPF_CONF, allVMs.all[vm].zonepath);
-        var v6filename = util.format(IPF6_CONF, allVMs.all[vm].zonepath);
-        var ipfConf = [
+        var ipf4Conf = [
             '# DO NOT EDIT THIS FILE. THIS FILE IS AUTO-GENERATED BY fwadm(1M)',
             '# AND MAY BE OVERWRITTEN AT ANY TIME.',
             '#',
             '# File generated at ' + date.toString(),
             '#',
             ''];
-        var ipf6Conf = ipfConf.slice();
+        var ipf6Conf = ipf4Conf.slice();
+        var iks = hasKey(keepInboundState, vm) ? keepInboundState[vm] : {};
 
-        toReturn.vms.push(vm);
+        conf[vm].sort(compareRules).forEach(function (sortObj) {
+            var ktxt = KEEP_FRAGS;
+            if (sortObj.direction === 'to' && iks[sortObj.protocol]) {
+                ktxt += KEEP_STATE;
+            }
 
-        // XXX: sort here
-        conf[vm].forEach(function (sortObj) {
             if (!hasKey(rulesIncluded, sortObj.uuid)) {
                 rulesIncluded[sortObj.uuid] = [];
             }
             rulesIncluded[sortObj.uuid].push(sortObj.direction);
 
+            ipf4Conf.push(sortObj.header);
+            ipf6Conf.push(sortObj.header);
+
             sortObj.v4text.forEach(function (line) {
-                ipfConf.push(line);
+                ipf4Conf.push(line + ktxt);
             });
             sortObj.v6text.forEach(function (line) {
-                ipf6Conf.push(line);
+                ipf6Conf.push(line + ktxt);
             });
         });
 
         log.debug(rulesIncluded, 'VM %s: generated ipf(6).conf', vm);
 
-        var v4rules = ipfConf.concat(v4fallbacks);
+        var v4rules = ipf4Conf.concat(v4fallbacks);
         var v6rules = ipf6Conf.concat(v6fallbacks);
 
-        toReturn.files[v4filename] = v4rules.join('\n') + '\n';
-        toReturn.files[v6filename] = v6rules.join('\n') + '\n';
+        toReturn.push({
+            uuid: vm,
+            zonepath: allVMs.all[vm].zonepath,
+            v4text: v4rules.join('\n') + '\n',
+            v6text: v6rules.join('\n') + '\n'
+        });
     }
 
     return callback(null, toReturn);
@@ -1148,12 +1352,13 @@ function rulesFromOtherSide(rule, dir, localVMs, remoteVMs) {
     var ipfRules = [];
 
     if (rule[otherSide].wildcards.indexOf('any') !== -1) {
-            ipfRules.push(ipfRuleObj({
-                rule: rule,
-                direction: dir,
-                type: 'wildcard',
-                value: 'any'
-            }));
+        ipfRules.push(ipfRuleObj({
+            rule: rule,
+            direction: dir,
+            targets: [ '0.0.0.0' ],
+            type: 'wildcard',
+            value: 'any'
+        }));
 
         return ipfRules;
     }
@@ -1212,6 +1417,10 @@ function rulesFromOtherSide(rule, dir, localVMs, remoteVMs) {
                         return;
                     }
 
+                    if (vm.ips.length === 0) {
+                        return;
+                    }
+
                     ipfRules.push(ipfRuleObj({
                         rule: rule,
                         direction: dir,
@@ -1221,7 +1430,6 @@ function rulesFromOtherSide(rule, dir, localVMs, remoteVMs) {
                     }));
                 });
             });
-
         });
     });
 
@@ -1296,93 +1504,150 @@ function addOtherSideRemoteTargets(vms, rule, targets, dir, log) {
 
 
 /**
- * Saves all of the files in ipfData to disk
+ * Carefully move the new ipfilter configuration file into place. It's
+ * important to make sure that if we fail or crash at any point that we
+ * leave a file in place, since its presence is what determines whether
+ * to enable the firewall at zone boot.
  */
-function saveIPFfiles(ipfData, log, callback) {
+function replaceIPFconf(file, data, ver, callback) {
+    var tempFile = util.format('%s.%s', file, ver);
+    var oldFile = util.format('%s.old', file);
+
+    vasync.pipeline({
+    funcs: [
+        function _write(_, cb) {
+            fs.writeFile(tempFile, data, cb);
+        },
+        function _unlinkOld(_, cb) {
+            fs.unlink(oldFile, function (err) {
+                if (err && err.code === 'ENOENT') {
+                    cb(null);
+                    return;
+                }
+
+                cb(err);
+            });
+        },
+        function _linkOld(_, cb) {
+            fs.link(file, oldFile, function (err) {
+                if (err && err.code === 'ENOENT') {
+                    cb(null);
+                    return;
+                }
+
+                cb(err);
+            });
+        },
+        function _renameTemp(_, cb) {
+            fs.rename(tempFile, file, cb);
+        }
+    ]}, callback);
+}
+
+
+/**
+ * Saves all of the generated ipfilter rules in ipfData to disk. We handle
+ * each VM separately in parallel, so that failures for one don't impact
+ * reloading others. For example, a VM may have filled up its disk, and we
+ * now can't write out its configuration, or a VM may have stopped on us
+ * before we had a chance to run ipf(1M) on it.
+ */
+function saveConfsAndReload(opts, ipfData, log, callback) {
     var ver = Date.now(0) + '.' + sprintf('%06d', process.pid);
+    var files = {};
+    var uuids = [];
 
-    return vasync.forEachParallel({
-        inputs: Object.keys(ipfData),
-        func: function _apply(file, cb) {
-            var tempFile = util.format('%s.%s', file, ver);
-            var oldFile = util.format('%s.old', file);
+    vasync.forEachParallel({
+        inputs: ipfData,
+        func: function (vm, cb) {
+            uuids.push(vm.uuid);
 
             vasync.pipeline({
             funcs: [
-                function _write(_, cb2) {
-                    log.trace('saveIPFfiles: writing temp file "%s"', tempFile);
-                    return fs.writeFile(tempFile, ipfData[file], cb2);
-                },
-                function _unlinkOld(_, cb2) {
-                    return fs.unlink(oldFile, function (err) {
-                        if (err && err.code === 'ENOENT') {
-                            return cb2(null);
-                        }
-                        return cb2(err);
-                    });
+                // Write the new ipf.conf for IPv4 rules:
+                function writeV4(_, cb2) {
+                    var filename = util.format(IPF_CONF, vm.zonepath);
+                    files[filename] = vm.v4text;
+
+                    if (opts.dryrun) {
+                        cb2(null);
+                        return;
+                    }
+
+                    replaceIPFconf(filename, vm.v4text, ver, cb2);
                 },
-                function _linkOld(_, cb2) {
-                    return fs.link(file, oldFile, function (err) {
-                        if (err && err.code === 'ENOENT') {
-                            return cb2(null);
-                        }
-                        return cb2(err);
-                    });
+
+                // Write the new ipf6.conf for IPv6 rules:
+                function writeV6(_, cb2) {
+                    var filename = util.format(IPF6_CONF, vm.zonepath);
+                    files[filename] = vm.v6text;
+
+                    if (opts.dryrun) {
+                        cb2(null);
+                        return;
+                    }
+
+                    replaceIPFconf(filename, vm.v6text, ver, cb2);
                 },
-                function _renameTemp(_, cb2) {
-                    return fs.rename(tempFile, file, cb2);
+
+                // Restart the VM's firewall:
+                function reload(_, cb2) {
+                    if (opts.dryrun) {
+                        cb2(null);
+                        return;
+                    }
+
+                    restartFirewall(opts.allVMs, vm.uuid, log, cb2);
                 }
             ]}, cb);
         }
-    }, function (err, res) {
-        return callback(err, res);
+    }, function (err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+
+        callback(null, {
+            files: files,
+            vms: uuids
+        });
     });
 }
 
 
 /**
- * Restart the firewalls for VMs listed in uuids
+ * Restart the given VMs firewall.
  *
  * @param vms {Object}: VM lookup table, as returned by createVMlookup()
- * @param rules {Array}: array of VM UUIDs to restart
- * @param callback {Function} `function (err, restarted)`
- * - Where restarted is a list of UUIDs for VMs that were actually restarted
+ * @param uuid {UUID}: The UUID of the target VM
+ * @param callback {Function} `function (err)`
  */
-function restartFirewalls(vms, uuids, log, callback) {
-    log.trace(uuids, 'restartFirewalls: entry');
-    var restarted = [];
-
-    return vasync.forEachParallel({
-        inputs: uuids,
-        func: function _restart(uuid, cb) {
-            if (!vms.all[uuid].enabled || vms.all[uuid].state !== 'running') {
-                log.debug('restartFirewalls: VM "%s": not restarting '
-                    + '(enabled=%s, state=%s)', uuid, vms.all[uuid].enabled,
-                    vms.all[uuid].state);
-                return cb(null);
-            }
-
-            log.debug('restartFirewalls: reloading firewall for VM "%s" '
-                + '(enabled=%s, state=%s)', uuid, vms.all[uuid].enabled,
-                vms.all[uuid].state);
-
-            // Reload the firewall, and start it if necessary.
-            reloadIPF({ vm: uuid, zonepath: vms.all[uuid].zonepath },
-                log, function (err, res) {
-                restarted.push(uuid);
-                if (err && zoneNotRunning(res)) {
-                    // An error starting the firewall due to the zone not
-                    // running isn't really an error
-                    cb();
-                    return;
-                }
+function restartFirewall(vms, uuid, log, cb) {
+    if (!vms.all[uuid].enabled || vms.all[uuid].state !== 'running') {
+        log.debug('restartFirewalls: VM "%s": not restarting '
+            + '(enabled=%s, state=%s)', uuid, vms.all[uuid].enabled,
+            vms.all[uuid].state);
+        cb(null);
+        return;
+    }
 
-                cb(err);
-            });
+    log.debug('restartFirewalls: reloading firewall for VM "%s" '
+        + '(enabled=%s, state=%s)', uuid, vms.all[uuid].enabled,
+        vms.all[uuid].state);
+
+    // Reload the firewall, and start it if necessary.
+    reloadIPF({ vm: uuid, zonepath: vms.all[uuid].zonepath }, log,
+        function (err, res) {
+        if (err && zoneNotRunning(res)) {
+            /*
+             * An error starting the firewall due to the zone not
+             * running isn't really an error.
+             */
+            cb();
+            return;
         }
-    }, function (err, res) {
-        // XXX: Does this stop on the first error?
-        return callback(err, restarted);
+
+        cb(err);
     });
 }
 
@@ -1423,7 +1688,7 @@ function applyChanges(opts, log, callback) {
     pipeline({
     funcs: [
         // Generate the ipf files for each VM
-        function ipfData(res, cb) {
+        function reloadPlan(res, cb) {
             prepareIPFdata({
                 allVMs: opts.allVMs,
                 remoteVMs: opts.allRemoteVMs,
@@ -1468,25 +1733,14 @@ function applyChanges(opts, log, callback) {
             mod_rvm.del(opts.del.rvms, log, cb);
         },
 
-        // Write the new ipf files to disk
-        function writeIPF(res, cb) {
-            if (opts.dryrun) {
-                return cb(null);
-            }
-            saveIPFfiles(res.ipfData.files, log, cb);
-        },
-
-        // Restart the firewalls for all of the affected VMs
-        function restart(res, cb) {
-            if (opts.dryrun) {
-                return cb(null);
-            }
-            restartFirewalls(opts.allVMs, res.ipfData.vms, log, cb);
+        // Write the new ipf files to disk and restart affected VMs
+        function ipfData(res, cb) {
+            saveConfsAndReload(opts, res.reloadPlan, log, cb);
         }
-
     ] }, function (err, res) {
         if (err) {
-            return callback(err);
+            callback(err);
+            return;
         }
 
         var toReturn = {
@@ -1521,7 +1775,7 @@ function applyChanges(opts, log, callback) {
             toReturn.files = res.state.ipfData.files;
         }
 
-        return callback(null, toReturn);
+        callback(null, toReturn);
     });
 }
 
diff --git a/deps/fw/lib/rvm.js b/deps/fw/lib/rvm.js
index 57a8402..6331d9a 100644
--- a/deps/fw/lib/rvm.js
+++ b/deps/fw/lib/rvm.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2016, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: functions for manipulating remote VMs
diff --git a/deps/fw/lib/util/log.js b/deps/fw/lib/util/log.js
index 1a9d82f..777d441 100644
--- a/deps/fw/lib/util/log.js
+++ b/deps/fw/lib/util/log.js
@@ -32,7 +32,7 @@ var events = require('events');
 var fs = require('fs');
 var mkdirp = require('mkdirp');
 var mod_obj = require('./obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var path = require('path');
 var sprintf = require('extsprintf').sprintf;
 var util = require('util');
diff --git a/deps/fw/lib/util/vm.js b/deps/fw/lib/util/vm.js
index f27ebe0..971b5c7 100644
--- a/deps/fw/lib/util/vm.js
+++ b/deps/fw/lib/util/vm.js
@@ -26,7 +26,7 @@
  * fwadm: shared VM logic
  */
 
-var mod_net = require('net');
+var mod_addr = require('ip6addr');
 var mod_obj = require('./obj');
 var VError = require('verror').VError;
 
@@ -64,6 +64,9 @@ function notAuto(i) {
     return (i !== 'dhcp') && (i !== 'addrconf');
 }
 
+function toStr(o) {
+    return o.toString();
+}
 
 
 // --- Exports
@@ -111,15 +114,17 @@ function createRemoteVM(vm) {
         });
     }
 
-    rvm.ips = Object.keys(ips).sort();
-
-    rvm.ips.forEach(function (ip) {
-        if (!mod_net.isIPv4(ip) && !mod_net.isIPv6(ip)) {
+    function parseIP(ip) {
+        try {
+            return mod_addr.parse(ip);
+        } catch (_) {
             err = new VError('Invalid IP address: %s', ip);
             err.details = vm;
             throw err;
         }
-    });
+    }
+
+    rvm.ips = Object.keys(ips).map(parseIP).sort(mod_addr.compare).map(toStr);
 
     if (hasKey(vm, 'tags') && !objEmpty(vm.tags)) {
         rvm.tags = {};
diff --git a/deps/fw/node_modules/fwrule/index.js b/deps/fw/node_modules/fwrule/index.js
index f42f6a9..c27c9dd 100644
--- a/deps/fw/node_modules/fwrule/index.js
+++ b/deps/fw/node_modules/fwrule/index.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  *
  * firewall rule parser: entry point
@@ -39,8 +39,6 @@ var validators = require('./validators');
 
 
 
-var uuidRE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
-
 /**
  * The fwrule language is versioned so that use of new features can be
  * restricted. These versions are:
@@ -48,8 +46,13 @@ var uuidRE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  * 1 - Initial version of language
  * 2 - PORTS keyword & support for ranges of ports
  * 3 - Support for IPv6 targets, the ICMPv6 protocol, and the TYPE ALL keyword
+ * 4 - Support for priority levels, longer protocol targets list, and the AH and
+ *     ESP protocols (for IPsec)
  */
-var CURR_VERSION = 3;
+var CURR_VERSION = 4;
+
+
+var NON_DIGIT_RE = /[^0-9]/;
 
 
 // --- Internal helper functions
@@ -93,14 +96,6 @@ parser.yy.validateIPv4address = function validateIPv4address(ip) {
 };
 
 
-parser.yy.validateIPv4subnet = function validateIPv4subnet(subnet) {
-    if (!validators.validateIPv4subnet(subnet)) {
-        throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
-    }
-};
-
-
 parser.yy.validateIPv6address = function validateIPv6address(ip) {
     if (!mod_net.isIPv6(ip)) {
         throw new validators.InvalidParamError('rule',
@@ -109,16 +104,19 @@ parser.yy.validateIPv6address = function validateIPv6address(ip) {
 };
 
 
-parser.yy.validateIPv6subnet = function validateIPv6subnet(subnet) {
-    if (!validators.validateIPv6subnet(subnet)) {
+parser.yy.validateSubnet = function validateSubnet(input) {
+    validators.validateSubnet('rule', input, parser.yy.enforceSubnetMask);
+};
+
+parser.yy.validatePriorityLevel = function validatePriorityLevel(num) {
+    if (NON_DIGIT_RE.test(num) || Number(num) < 0 || Number(num) > 100) {
         throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
+            'Priority level "%s" is invalid', num);
     }
 };
 
-
 parser.yy.validatePortNumber = function validatePortNumber(num) {
-    if (isNaN(num) || Number(num) < 1 || Number(num) > 65535) {
+    if (NON_DIGIT_RE.test(num) || Number(num) < 1 || Number(num) > 65535) {
         throw new validators.InvalidParamError('rule',
             'Port number "%s" is invalid', num);
     }
@@ -152,7 +150,7 @@ parser.yy.createMaybePortRange = function createMaybePortRange(num) {
 
 
 parser.yy.validateICMPcode = function validateICMPcode(num) {
-    if (isNaN(num) || Number(num) < 0 || Number(num) > 255) {
+    if (NON_DIGIT_RE.test(num) || Number(num) < 0 || Number(num) > 255) {
         throw new validators.InvalidParamError('rule',
             'ICMP code "%s" is invalid', num);
     }
@@ -160,7 +158,7 @@ parser.yy.validateICMPcode = function validateICMPcode(num) {
 
 
 parser.yy.validateICMPtype = function validateICMPtype(num) {
-    if (isNaN(num) || Number(num) < 0 || Number(num) > 255) {
+    if (NON_DIGIT_RE.test(num) || Number(num) < 0 || Number(num) > 255) {
         throw new validators.InvalidParamError('rule',
             'ICMP type "%s" is invalid', num);
     }
@@ -168,7 +166,7 @@ parser.yy.validateICMPtype = function validateICMPtype(num) {
 
 
 parser.yy.validateUUID = function validateUUID(text) {
-    if (!uuidRE.test(text)) {
+    if (!validators.validateUUID(text)) {
         throw new validators.InvalidParamError('rule',
             'UUID "%s" is invalid', text);
     }
@@ -231,6 +229,9 @@ function parse(input, opts) {
     // If a version hasn't been specified, use most recent
     parser.yy.maxVersion = opts.maxVersion || CURR_VERSION;
 
+    // Whether we should check if CIDRs have bits set past mask
+    parser.yy.enforceSubnetMask = !!opts.enforceSubnetMask;
+
     return parser.parse(input);
 }
 
@@ -244,7 +245,7 @@ module.exports = {
     FwRule: rule.FwRule,
     generateVersion: rule.generateVersion,
     parse: parse,
-    PROTOCOLS: ['tcp', 'udp', 'icmp', 'icmp6'],
+    PROTOCOLS: ['tcp', 'udp', 'icmp', 'icmp6', 'ah', 'esp'],
     TARGET_TYPES: rule.TARGET_TYPES,
     validators: validators
 };
diff --git a/deps/fw/node_modules/fwrule/parser.js b/deps/fw/node_modules/fwrule/parser.js
index f50b0ab..ea7ef45 100644
--- a/deps/fw/node_modules/fwrule/parser.js
+++ b/deps/fw/node_modules/fwrule/parser.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: firewall rule parser
@@ -31,61 +31,63 @@
 var parser = (function(){
 var parser = {trace: function trace() { },
 yy: {},
-symbols_: {"error":2,"start":3,"FROM":4,"target_list":5,"TO":6,"action":7,"protocol":8,"EOF":9,"any":10,"all":11,"(":12,"target_or_list":13,")":14,"target":15,"OR":16,"ipv4":17,"ipv4_subnet":18,"ipv6":19,"ipv6_subnet":20,"tag":21,"vm":22,"ALL":23,"VMS":24,"ANY":25,"IP":26,"IPV4ADDR":27,"SUBNET":28,"CIDRSUFFIX":29,"IPV6ADDR":30,"VM":31,"uuid":32,"WORD":33,"TAG":34,"tag_string":35,"=":36,"STRING":37,"BLOCK":38,"ALLOW":39,"TCP":40,"port_list":41,"ports":42,"UDP":43,"ICMP":44,"type_list":45,"ICMP6":46,"port_and_list":47,"port":48,"port_all":49,"AND":50,"PORT":51,"portnumber":52,"PORTS":53,"portnumbers":54,"portrange":55,"-":56,",":57,"type_and_list":58,"type":59,"type_all":60,"TYPE":61,"icmptype":62,"CODE":63,"icmpcode":64,"$accept":0,"$end":1},
-terminals_: {2:"error",4:"FROM",6:"TO",9:"EOF",12:"(",14:")",16:"OR",23:"ALL",24:"VMS",25:"ANY",26:"IP",27:"IPV4ADDR",28:"SUBNET",29:"CIDRSUFFIX",30:"IPV6ADDR",31:"VM",33:"WORD",34:"TAG",36:"=",37:"STRING",38:"BLOCK",39:"ALLOW",40:"TCP",43:"UDP",44:"ICMP",46:"ICMP6",50:"AND",51:"PORT",53:"PORTS",56:"-",57:",",61:"TYPE",63:"CODE"},
-productions_: [0,[3,7],[5,1],[5,1],[5,3],[5,1],[13,1],[13,3],[15,1],[15,1],[15,1],[15,1],[15,1],[15,1],[11,2],[11,4],[10,1],[10,3],[17,2],[18,3],[19,2],[20,3],[22,2],[32,1],[21,2],[21,4],[35,1],[35,1],[7,1],[7,1],[8,2],[8,2],[8,2],[8,2],[8,2],[8,2],[41,3],[41,1],[41,3],[41,1],[47,1],[47,3],[48,2],[42,2],[49,2],[52,1],[55,1],[55,3],[54,1],[54,3],[45,3],[45,1],[45,3],[45,1],[58,1],[58,3],[59,4],[59,2],[60,2],[62,1],[64,1]],
+symbols_: {"error":2,"start":3,"FROM":4,"target_list":5,"TO":6,"action":7,"protocol":8,"EOF":9,"PRIORITY":10,"priolevel":11,"WORD":12,"any":13,"all":14,"(":15,"target_or_list":16,")":17,"target":18,"OR":19,"ipv4":20,"ipv4_subnet":21,"ipv6":22,"ipv6_subnet":23,"tag":24,"vm":25,"ALL":26,"VMS":27,"ANY":28,"IP":29,"IPV4ADDR":30,"SUBNET":31,"CIDRSUFFIX":32,"IPV6ADDR":33,"VM":34,"uuid":35,"TAG":36,"tag_string":37,"=":38,"STRING":39,"BLOCK":40,"ALLOW":41,"TCP":42,"port_list":43,"ports":44,"UDP":45,"ICMP":46,"type_list":47,"ICMP6":48,"AH":49,"ESP":50,"port_and_list":51,"port":52,"port_all":53,"AND":54,"PORT":55,"portnumber":56,"PORTS":57,"portnumbers":58,"portrange":59,"-":60,",":61,"type_and_list":62,"type":63,"type_all":64,"TYPE":65,"icmptype":66,"CODE":67,"icmpcode":68,"$accept":0,"$end":1},
+terminals_: {2:"error",4:"FROM",6:"TO",9:"EOF",10:"PRIORITY",12:"WORD",15:"(",17:")",19:"OR",26:"ALL",27:"VMS",28:"ANY",29:"IP",30:"IPV4ADDR",31:"SUBNET",32:"CIDRSUFFIX",33:"IPV6ADDR",34:"VM",36:"TAG",38:"=",39:"STRING",40:"BLOCK",41:"ALLOW",42:"TCP",45:"UDP",46:"ICMP",48:"ICMP6",49:"AH",50:"ESP",54:"AND",55:"PORT",57:"PORTS",60:"-",61:",",65:"TYPE",67:"CODE"},
+productions_: [0,[3,7],[3,9],[11,1],[5,1],[5,1],[5,3],[5,1],[16,1],[16,3],[18,1],[18,1],[18,1],[18,1],[18,1],[18,1],[14,2],[14,4],[13,1],[13,3],[20,2],[21,3],[22,2],[23,3],[25,2],[35,1],[24,2],[24,4],[37,1],[37,1],[7,1],[7,1],[8,2],[8,2],[8,2],[8,2],[8,2],[8,2],[8,1],[8,1],[43,3],[43,1],[43,3],[43,1],[51,1],[51,3],[52,2],[44,2],[53,2],[56,1],[59,1],[59,3],[58,1],[58,3],[47,3],[47,1],[47,3],[47,1],[62,1],[62,3],[63,4],[63,2],[64,2],[66,1],[68,1]],
 performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {
 
 var $0 = $$.length - 1;
 switch (yystate) {
 case 1: return { 'from': $$[$0-5], 'to': $$[$0-3], 'action': $$[$0-2], 'protocol': $$[$0-1] }; 
 break;
-case 4:this.$ = $$[$0-1];
+case 2: yy.validateOKVersion(4, 'priority levels');
+          return { 'from': $$[$0-7], 'to': $$[$0-5], 'action': $$[$0-4], 'protocol': $$[$0-3], 'priority': $$[$0-1] }; 
 break;
-case 7: this.$ = $$[$0-2].concat($$[$0]); 
+case 3: yy.validatePriorityLevel($$[$0]);
+          this.$ = Number($$[$0]) 
 break;
-case 14: this.$ = [ ['wildcard', 'vmall'] ]; 
+case 6:this.$ = $$[$0-1];
 break;
-case 15: this.$ = [ ['wildcard', 'vmall'] ]; 
+case 9: this.$ = $$[$0-2].concat($$[$0]); 
 break;
-case 16: this.$ = [ ['wildcard', 'any'] ]; 
+case 16: this.$ = [ ['wildcard', 'vmall'] ]; 
 break;
-case 17: this.$ = [ ['wildcard', 'any'] ]; 
+case 17: this.$ = [ ['wildcard', 'vmall'] ]; 
 break;
-case 18: yy.validateIPv4address($$[$0]);
+case 18: this.$ = [ ['wildcard', 'any'] ]; 
+break;
+case 19: this.$ = [ ['wildcard', 'any'] ]; 
+break;
+case 20: yy.validateIPv4address($$[$0]);
           this.$ = [ ['ip', $$[$0]] ]; 
 break;
-case 19: yy.validateIPv4subnet($$[$0-1] + $$[$0]);
+case 21: yy.validateSubnet($$[$0-1] + $$[$0]);
             this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
 break;
-case 20: yy.validateOKVersion(3, 'IPv6');
+case 22: yy.validateOKVersion(3, 'IPv6');
           yy.validateIPv6address($$[$0]);
           this.$ = [ ['ip', $$[$0]] ]; 
 break;
-case 21: yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6subnet($$[$0-1] + $$[$0]);
+case 23: yy.validateOKVersion(3, 'IPv6');
+          yy.validateSubnet($$[$0-1] + $$[$0]);
             this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
 break;
-case 22: this.$ = [ ['vm', $$[$0]] ]; 
+case 24: this.$ = [ ['vm', $$[$0]] ]; 
 break;
-case 23: yy.validateUUID($$[$0]);
+case 25: yy.validateUUID($$[$0]);
           this.$ = $$[$0]; 
 break;
-case 24: this.$ = [ ['tag', $$[$0]] ]; 
-break;
-case 25: this.$ = [ ['tag', [ $$[$0-2], $$[$0] ] ] ]; 
-break;
-case 26: this.$ = yytext; 
+case 26: this.$ = [ ['tag', $$[$0]] ]; 
 break;
-case 27: this.$ = $$[$0]; 
+case 27: this.$ = [ ['tag', [ $$[$0-2], $$[$0] ] ] ]; 
 break;
-case 28: this.$ = $$[$0].toLowerCase() 
+case 28: this.$ = yytext; 
 break;
-case 29: this.$ = $$[$0].toLowerCase() 
+case 29: this.$ = $$[$0]; 
 break;
-case 30: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
+case 30: this.$ = $$[$0].toLowerCase() 
 break;
-case 31: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
+case 31: this.$ = $$[$0].toLowerCase() 
 break;
 case 32: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
 break;
@@ -95,54 +97,65 @@ case 34: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] }
 break;
 case 35: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
 break;
-case 36: this.$ = $$[$0-1]; 
+case 36: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
+break;
+case 37: yy.validateOKVersion(3, 'IPv6');
+          this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] }; 
+break;
+case 38: yy.validateOKVersion(4, 'AH');
+          this.$ = { 'name': $$[$0].toLowerCase(), 'targets': [ 'all' ] }; 
+break;
+case 39: yy.validateOKVersion(4, 'ESP');
+          this.$ = { 'name': $$[$0].toLowerCase(), 'targets': [ 'all' ] }; 
 break;
-case 38: this.$ = $$[$0-1]; 
+case 40: this.$ = $$[$0-1]; 
 break;
-case 41: this.$ = $$[$0-2].concat(Number($$[$0])); 
+case 42: this.$ = $$[$0-1]; 
 break;
-case 42: this.$ = [ $$[$0] ]; 
+case 45: this.$ = $$[$0-2].concat(Number($$[$0])); 
 break;
-case 43: yy.validateOKVersion(2, 'port ranges');
+case 46: this.$ = [ $$[$0] ]; 
+break;
+case 47: yy.validateOKVersion(2, 'port ranges');
           this.$ = $$[$0]; 
 break;
-case 44: this.$ = [ 'all' ]; 
+case 48: this.$ = [ 'all' ]; 
 break;
-case 45: yy.validatePortNumber($$[$0]);
+case 49: yy.validatePortNumber($$[$0]);
           this.$ = Number($$[$0]); 
 break;
-case 46: this.$ = [ yy.createMaybePortRange($$[$0]) ]; 
+case 50: this.$ = [ yy.createMaybePortRange($$[$0]) ]; 
 break;
-case 47: yy.validatePortNumber($$[$0-2]);
+case 51: yy.validatePortNumber($$[$0-2]);
           yy.validatePortNumber($$[$0]);
           yy.validateRangeOrder($$[$0-2], $$[$0]);
           this.$ = [{ 'start': Number($$[$0-2]), 'end': Number($$[$0]) }]; 
 break;
-case 49: this.$ = $$[$0-2].concat($$[$0]); 
+case 53: this.$ = $$[$0-2].concat($$[$0]); 
 break;
-case 50: this.$ = $$[$0-1]; 
+case 54: this.$ = $$[$0-1]; 
 break;
-case 52: this.$ = $$[$0-1]; 
+case 56: this.$ = $$[$0-1]; 
 break;
-case 55: this.$ = $$[$0-2].concat($$[$0]); 
+case 59: this.$ = $$[$0-2].concat($$[$0]); 
 break;
-case 56: this.$ = [ $$[$0-2] + ':' + $$[$0] ]; 
+case 60: this.$ = [ $$[$0-2] + ':' + $$[$0] ]; 
 break;
-case 57: this.$ = [ $$[$0] ]; 
+case 61: this.$ = [ $$[$0] ]; 
 break;
-case 58: yy.validateOKVersion(3, 'all ICMP types');
+case 62: yy.validateOKVersion(3, 'all ICMP types');
           this.$ = [ 'all' ]; 
 break;
-case 59: yy.validateICMPtype($$[$0]);
+case 63: yy.validateICMPtype($$[$0]);
           this.$ = Number($$[$0]); 
 break;
-case 60: yy.validateICMPcode($$[$0]);
+case 64: yy.validateICMPcode($$[$0]);
           this.$ = Number($$[$0]); 
 break;
 }
 },
-table: [{3:1,4:[1,2]},{1:[3]},{5:3,10:4,11:5,12:[1,6],15:7,17:10,18:11,19:12,20:13,21:14,22:15,23:[1,9],25:[1,8],26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{6:[1,20]},{6:[2,2],38:[2,2],39:[2,2]},{6:[2,3],38:[2,3],39:[2,3]},{13:21,15:24,17:10,18:11,19:12,20:13,21:14,22:15,23:[1,23],25:[1,22],26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{6:[2,5],38:[2,5],39:[2,5]},{6:[2,16],38:[2,16],39:[2,16]},{24:[1,25]},{6:[2,8],14:[2,8],16:[2,8],38:[2,8],39:[2,8]},{6:[2,9],14:[2,9],16:[2,9],38:[2,9],39:[2,9]},{6:[2,10],14:[2,10],16:[2,10],38:[2,10],39:[2,10]},{6:[2,11],14:[2,11],16:[2,11],38:[2,11],39:[2,11]},{6:[2,12],14:[2,12],16:[2,12],38:[2,12],39:[2,12]},{6:[2,13],14:[2,13],16:[2,13],38:[2,13],39:[2,13]},{27:[1,26],30:[1,27]},{27:[1,28],30:[1,29]},{33:[1,32],35:30,37:[1,31]},{32:33,33:[1,34]},{5:35,10:4,11:5,12:[1,6],15:7,17:10,18:11,19:12,20:13,21:14,22:15,23:[1,9],25:[1,8],26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{14:[1,36],16:[1,37]},{14:[1,38]},{24:[1,39]},{14:[2,6],16:[2,6]},{6:[2,14],38:[2,14],39:[2,14]},{6:[2,18],14:[2,18],16:[2,18],38:[2,18],39:[2,18]},{6:[2,20],14:[2,20],16:[2,20],38:[2,20],39:[2,20]},{29:[1,40]},{29:[1,41]},{6:[2,24],14:[2,24],16:[2,24],36:[1,42],38:[2,24],39:[2,24]},{6:[2,26],14:[2,26],16:[2,26],36:[2,26],38:[2,26],39:[2,26]},{6:[2,27],14:[2,27],16:[2,27],36:[2,27],38:[2,27],39:[2,27]},{6:[2,22],14:[2,22],16:[2,22],38:[2,22],39:[2,22]},{6:[2,23],14:[2,23],16:[2,23],38:[2,23],39:[2,23]},{7:43,38:[1,44],39:[1,45]},{6:[2,4],38:[2,4],39:[2,4]},{15:46,17:10,18:11,19:12,20:13,21:14,22:15,26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{6:[2,17],38:[2,17],39:[2,17]},{14:[1,47]},{6:[2,19],14:[2,19],16:[2,19],38:[2,19],39:[2,19]},{6:[2,21],14:[2,21],16:[2,21],38:[2,21],39:[2,21]},{33:[1,32],35:48,37:[1,31]},{8:49,40:[1,50],43:[1,51],44:[1,52],46:[1,53]},{40:[2,28],43:[2,28],44:[2,28],46:[2,28]},{40:[2,29],43:[2,29],44:[2,29],46:[2,29]},{14:[2,7],16:[2,7]},{6:[2,15],38:[2,15],39:[2,15]},{6:[2,25],14:[2,25],16:[2,25],38:[2,25],39:[2,25]},{9:[1,54]},{12:[1,57],41:55,42:56,48:58,49:59,51:[1,61],53:[1,60]},{12:[1,57],41:62,42:63,48:58,49:59,51:[1,61],53:[1,60]},{12:[1,65],45:64,59:66,60:67,61:[1,68]},{12:[1,65],45:69,59:66,60:67,61:[1,68]},{1:[2,1]},{9:[2,30]},{9:[2,31]},{47:70,48:72,49:71,51:[1,61]},{9:[2,37]},{9:[2,39]},{33:[1,75],54:73,55:74},{23:[1,77],33:[1,78],52:76},{9:[2,32]},{9:[2,33]},{9:[2,34]},{58:79,59:81,60:80,61:[1,68]},{9:[2,51]},{9:[2,53]},{23:[1,83],33:[1,84],62:82},{9:[2,35]},{14:[1,85],50:[1,86]},{14:[1,87]},{14:[2,40],50:[2,40]},{9:[2,43],57:[1,88]},{9:[2,48],57:[2,48]},{9:[2,46],56:[1,89],57:[2,46]},{9:[2,42],14:[2,42],50:[2,42]},{9:[2,44],14:[2,44]},{9:[2,45],14:[2,45],50:[2,45]},{14:[1,90],50:[1,91]},{14:[1,92]},{14:[2,54],50:[2,54]},{9:[2,57],14:[2,57],50:[2,57],63:[1,93]},{9:[2,58],14:[2,58]},{9:[2,59],14:[2,59],50:[2,59],63:[2,59]},{9:[2,36]},{48:94,51:[1,95]},{9:[2,38]},{33:[1,75],55:96},{33:[1,97]},{9:[2,50]},{59:98,61:[1,99]},{9:[2,52]},{33:[1,101],64:100},{14:[2,41],50:[2,41]},{33:[1,78],52:76},{9:[2,49],57:[2,49]},{9:[2,47],57:[2,47]},{14:[2,55],50:[2,55]},{33:[1,84],62:82},{9:[2,56],14:[2,56],50:[2,56]},{9:[2,60],14:[2,60],50:[2,60]}],
-defaultActions: {54:[2,1],55:[2,30],56:[2,31],58:[2,37],59:[2,39],62:[2,32],63:[2,33],64:[2,34],66:[2,51],67:[2,53],69:[2,35],85:[2,36],87:[2,38],90:[2,50],92:[2,52]},
+table: [{3:1,4:[1,2]},{1:[3]},{5:3,13:4,14:5,15:[1,6],18:7,20:10,21:11,22:12,23:13,24:14,25:15,26:[1,9],28:[1,8],29:[1,16],31:[1,17],34:[1,19],36:[1,18]},{6:[1,20]},{6:[2,4],40:[2,4],41:[2,4]},{6:[2,5],40:[2,5],41:[2,5]},{16:21,18:24,20:10,21:11,22:12,23:13,24:14,25:15,26:[1,23],28:[1,22],29:[1,16],31:[1,17],34:[1,19],36:[1,18]},{6:[2,7],40:[2,7],41:[2,7]},{6:[2,18],40:[2,18],41:[2,18]},{27:[1,25]},{6:[2,10],17:[2,10],19:[2,10],40:[2,10],41:[2,10]},{6:[2,11],17:[2,11],19:[2,11],40:[2,11],41:[2,11]},{6:[2,12],17:[2,12],19:[2,12],40:[2,12],41:[2,12]},{6:[2,13],17:[2,13],19:[2,13],40:[2,13],41:[2,13]},{6:[2,14],17:[2,14],19:[2,14],40:[2,14],41:[2,14]},{6:[2,15],17:[2,15],19:[2,15],40:[2,15],41:[2,15]},{30:[1,26],33:[1,27]},{30:[1,28],33:[1,29]},{12:[1,32],37:30,39:[1,31]},{12:[1,34],35:33},{5:35,13:4,14:5,15:[1,6],18:7,20:10,21:11,22:12,23:13,24:14,25:15,26:[1,9],28:[1,8],29:[1,16],31:[1,17],34:[1,19],36:[1,18]},{17:[1,36],19:[1,37]},{17:[1,38]},{27:[1,39]},{17:[2,8],19:[2,8]},{6:[2,16],40:[2,16],41:[2,16]},{6:[2,20],17:[2,20],19:[2,20],40:[2,20],41:[2,20]},{6:[2,22],17:[2,22],19:[2,22],40:[2,22],41:[2,22]},{32:[1,40]},{32:[1,41]},{6:[2,26],17:[2,26],19:[2,26],38:[1,42],40:[2,26],41:[2,26]},{6:[2,28],17:[2,28],19:[2,28],38:[2,28],40:[2,28],41:[2,28]},{6:[2,29],17:[2,29],19:[2,29],38:[2,29],40:[2,29],41:[2,29]},{6:[2,24],17:[2,24],19:[2,24],40:[2,24],41:[2,24]},{6:[2,25],17:[2,25],19:[2,25],40:[2,25],41:[2,25]},{7:43,40:[1,44],41:[1,45]},{6:[2,6],40:[2,6],41:[2,6]},{18:46,20:10,21:11,22:12,23:13,24:14,25:15,29:[1,16],31:[1,17],34:[1,19],36:[1,18]},{6:[2,19],40:[2,19],41:[2,19]},{17:[1,47]},{6:[2,21],17:[2,21],19:[2,21],40:[2,21],41:[2,21]},{6:[2,23],17:[2,23],19:[2,23],40:[2,23],41:[2,23]},{12:[1,32],37:48,39:[1,31]},{8:49,42:[1,50],45:[1,51],46:[1,52],48:[1,53],49:[1,54],50:[1,55]},{42:[2,30],45:[2,30],46:[2,30],48:[2,30],49:[2,30],50:[2,30]},{42:[2,31],45:[2,31],46:[2,31],48:[2,31],49:[2,31],50:[2,31]},{17:[2,9],19:[2,9]},{6:[2,17],40:[2,17],41:[2,17]},{6:[2,27],17:[2,27],19:[2,27],40:[2,27],41:[2,27]},{9:[1,56],10:[1,57]},{15:[1,60],43:58,44:59,52:61,53:62,55:[1,64],57:[1,63]},{15:[1,60],43:65,44:66,52:61,53:62,55:[1,64],57:[1,63]},{15:[1,68],47:67,63:69,64:70,65:[1,71]},{15:[1,68],47:72,63:69,64:70,65:[1,71]},{9:[2,38],10:[2,38]},{9:[2,39],10:[2,39]},{1:[2,1]},{11:73,12:[1,74]},{9:[2,32],10:[2,32]},{9:[2,33],10:[2,33]},{51:75,52:77,53:76,55:[1,64]},{9:[2,41],10:[2,41]},{9:[2,43],10:[2,43]},{12:[1,80],58:78,59:79},{12:[1,83],26:[1,82],56:81},{9:[2,34],10:[2,34]},{9:[2,35],10:[2,35]},{9:[2,36],10:[2,36]},{62:84,63:86,64:85,65:[1,71]},{9:[2,55],10:[2,55]},{9:[2,57],10:[2,57]},{12:[1,89],26:[1,88],66:87},{9:[2,37],10:[2,37]},{9:[1,90]},{9:[2,3]},{17:[1,91],54:[1,92]},{17:[1,93]},{17:[2,44],54:[2,44]},{9:[2,47],10:[2,47],61:[1,94]},{9:[2,52],10:[2,52],61:[2,52]},{9:[2,50],10:[2,50],60:[1,95],61:[2,50]},{9:[2,46],10:[2,46],17:[2,46],54:[2,46]},{9:[2,48],10:[2,48],17:[2,48]},{9:[2,49],10:[2,49],17:[2,49],54:[2,49]},{17:[1,96],54:[1,97]},{17:[1,98]},{17:[2,58],54:[2,58]},{9:[2,61],10:[2,61],17:[2,61],54:[2,61],67:[1,99]},{9:[2,62],10:[2,62],17:[2,62]},{9:[2,63],10:[2,63],17:[2,63],54:[2,63],67:[2,63]},{1:[2,2]},{9:[2,40],10:[2,40]},{52:100,55:[1,101]},{9:[2,42],10:[2,42]},{12:[1,80],59:102},{12:[1,103]},{9:[2,54],10:[2,54]},{63:104,65:[1,105]},{9:[2,56],10:[2,56]},{12:[1,107],68:106},{17:[2,45],54:[2,45]},{12:[1,83],56:81},{9:[2,53],10:[2,53],61:[2,53]},{9:[2,51],10:[2,51],61:[2,51]},{17:[2,59],54:[2,59]},{12:[1,89],66:87},{9:[2,60],10:[2,60],17:[2,60],54:[2,60]},{9:[2,64],10:[2,64],17:[2,64],54:[2,64]}],
+defaultActions: {56:[2,1],74:[2,3],90:[2,2]},
 parseError: function parseError(str, hash) {
     throw new Error(str);
 },
@@ -436,106 +449,118 @@ case 4:return 6;
 break;
 case 5:return 6;
 break;
-case 6:return 26;
+case 6:return 29;
+break;
+case 7:return 29;
+break;
+case 8:return 31;
+break;
+case 9:return 31;
+break;
+case 10:return 28;
+break;
+case 11:return 28;
+break;
+case 12:return 26;
 break;
-case 7:return 26;
+case 13:return 26;
 break;
-case 8:return 28;
+case 14:return 36;
 break;
-case 9:return 28;
+case 15:return 36;
 break;
-case 10:return 25;
+case 16:return 34;
 break;
-case 11:return 25;
+case 17:return 34;
 break;
-case 12:return 23;
+case 18:return 27;
 break;
-case 13:return 23;
+case 19:return 27;
 break;
-case 14:return 34;
+case 20:return 60;
 break;
-case 15:return 34;
+case 21:return 61;
 break;
-case 16:return 31;
+case 22:return 38;
 break;
-case 17:return 31;
+case 23:return 15;
 break;
-case 18:return 24;
+case 24:return 17;
 break;
-case 19:return 24;
+case 25:return 19;
 break;
-case 20:return 56;
+case 26:return 19;
 break;
-case 21:return 57;
+case 27:return 54;
 break;
-case 22:return 36;
+case 28:return 54;
 break;
-case 23:return 12;
+case 29:return 40;
 break;
-case 24:return 14;
+case 30:return 40;
 break;
-case 25:return 16;
+case 31:return 41;
 break;
-case 26:return 16;
+case 32:return 41;
 break;
-case 27:return 50;
+case 33:return 55;
 break;
-case 28:return 50;
+case 34:return 55;
 break;
-case 29:return 38;
+case 35:return 57;
 break;
-case 30:return 38;
+case 36:return 57;
 break;
-case 31:return 39;
+case 37:return 42;
 break;
-case 32:return 39;
+case 38:return 42;
 break;
-case 33:return 51;
+case 39:return 45;
 break;
-case 34:return 51;
+case 40:return 45;
 break;
-case 35:return 53;
+case 41:return 46;
 break;
-case 36:return 53;
+case 42:return 46;
 break;
-case 37:return 40;
+case 43:return 48;
 break;
-case 38:return 40;
+case 44:return 48;
 break;
-case 39:return 43;
+case 45:return 49;
 break;
-case 40:return 43;
+case 46:return 49;
 break;
-case 41:return 44;
+case 47:return 50;
 break;
-case 42:return 44;
+case 48:return 50;
 break;
-case 43:return 46;
+case 49:return 65;
 break;
-case 44:return 46;
+case 50:return 65;
 break;
-case 45:return 61;
+case 51:return 67;
 break;
-case 46:return 61;
+case 52:return 67;
 break;
-case 47:return 63;
+case 53:return 10;
 break;
-case 48:return 63;
+case 54:return 10;
 break;
-case 49:yy_.yytext = yy.tagUnescape(yy_.yytext.substr(1,yy_.yyleng-2)); return 37;
+case 55:yy_.yytext = yy.tagUnescape(yy_.yytext.substr(1,yy_.yyleng-2)); return 39;
 break;
-case 50:return 27;
+case 56:return 30;
 break;
-case 51:return 30;
+case 57:return 33;
 break;
-case 52:return 29;
+case 58:return 32;
 break;
-case 53:return 33
+case 59:return 12
 break;
 }
 },
-rules: [/^(?:\s+)/,/^(?:$)/,/^(?:FROM\b)/,/^(?:from\b)/,/^(?:TO\b)/,/^(?:to\b)/,/^(?:IP\b)/,/^(?:ip\b)/,/^(?:SUBNET\b)/,/^(?:subnet\b)/,/^(?:ANY\b)/,/^(?:any\b)/,/^(?:ALL\b)/,/^(?:all\b)/,/^(?:TAG\b)/,/^(?:tag\b)/,/^(?:VM\b)/,/^(?:vm\b)/,/^(?:VMS\b)/,/^(?:vms\b)/,/^(?:-)/,/^(?:,)/,/^(?:=)/,/^(?:\()/,/^(?:\))/,/^(?:OR\b)/,/^(?:or\b)/,/^(?:AND\b)/,/^(?:and\b)/,/^(?:BLOCK\b)/,/^(?:block\b)/,/^(?:ALLOW\b)/,/^(?:allow\b)/,/^(?:PORT\b)/,/^(?:port\b)/,/^(?:PORTS\b)/,/^(?:ports\b)/,/^(?:TCP\b)/,/^(?:tcp\b)/,/^(?:UDP\b)/,/^(?:udp\b)/,/^(?:ICMP\b)/,/^(?:icmp\b)/,/^(?:ICMP6\b)/,/^(?:icmp6\b)/,/^(?:TYPE\b)/,/^(?:type\b)/,/^(?:CODE\b)/,/^(?:code\b)/,/^(?:"(?:\\["bfnrt/()\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/,/^(?:(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3}))/,/^(?:([0-9a-f])*:([0-9a-f])*:[:0-9a-f]*)/,/^(?:\/([0-9]){1,3})/,/^(?:[-a-zA-Z0-9_]+)/],
-conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53],"inclusive":true}}
+rules: [/^(?:\s+)/,/^(?:$)/,/^(?:FROM\b)/,/^(?:from\b)/,/^(?:TO\b)/,/^(?:to\b)/,/^(?:IP\b)/,/^(?:ip\b)/,/^(?:SUBNET\b)/,/^(?:subnet\b)/,/^(?:ANY\b)/,/^(?:any\b)/,/^(?:ALL\b)/,/^(?:all\b)/,/^(?:TAG\b)/,/^(?:tag\b)/,/^(?:VM\b)/,/^(?:vm\b)/,/^(?:VMS\b)/,/^(?:vms\b)/,/^(?:-)/,/^(?:,)/,/^(?:=)/,/^(?:\()/,/^(?:\))/,/^(?:OR\b)/,/^(?:or\b)/,/^(?:AND\b)/,/^(?:and\b)/,/^(?:BLOCK\b)/,/^(?:block\b)/,/^(?:ALLOW\b)/,/^(?:allow\b)/,/^(?:PORT\b)/,/^(?:port\b)/,/^(?:PORTS\b)/,/^(?:ports\b)/,/^(?:TCP\b)/,/^(?:tcp\b)/,/^(?:UDP\b)/,/^(?:udp\b)/,/^(?:ICMP\b)/,/^(?:icmp\b)/,/^(?:ICMP6\b)/,/^(?:icmp6\b)/,/^(?:AH\b)/,/^(?:ah\b)/,/^(?:ESP\b)/,/^(?:esp\b)/,/^(?:TYPE\b)/,/^(?:type\b)/,/^(?:CODE\b)/,/^(?:code\b)/,/^(?:PRIORITY\b)/,/^(?:priority\b)/,/^(?:"(?:\\["bfnrt/()\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/,/^(?:(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3}))/,/^(?:([0-9a-f])*:([0-9a-f])*:[:0-9a-f]*)/,/^(?:\/([0-9]){1,3})/,/^(?:[-a-zA-Z0-9_]+)/],
+conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59],"inclusive":true}}
 };
 return lexer;
 })();
diff --git a/deps/fw/node_modules/fwrule/rule.js b/deps/fw/node_modules/fwrule/rule.js
index d9eab02..8032a3f 100644
--- a/deps/fw/node_modules/fwrule/rule.js
+++ b/deps/fw/node_modules/fwrule/rule.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  *
  * fwadm: firewall rule model
@@ -29,7 +29,7 @@
 'use strict';
 
 var mod_net = require('net');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var sprintf = require('extsprintf').sprintf;
 var util = require('util');
 var validators = require('./validators');
@@ -55,8 +55,12 @@ var FIELDS = [
 ];
 // Maximum number of targets per side:
 var MAX_TARGETS_PER_SIDE = 24;
-// Maximum number of ports:
-var MAX_PORTS = 8;
+// Maximum number of protocol targets:
+var MAX_PROTOCOL_TARGETS = 24;
+// Minimum version for using a larger list of protocol targets:
+var MINVER_LGPROTOTARG = 4;
+// The old maximum number of protocol targets:
+var OLD_MAX_PORTS = 8;
 var STRING_PROPS = ['created_by', 'description'];
 var TARGET_TYPES = ['wildcard', 'ip', 'subnet', 'tag', 'vm'];
 
@@ -393,14 +397,14 @@ function FwRule(data, opts) {
                 'global must be true or false'));
         }
 
-        if (hasOwnProperty(data, 'global')
-            && hasOwnProperty(data, 'owner_uuid') && data.global) {
+        if (hasOwnProperty(data, 'global') &&
+            hasOwnProperty(data, 'owner_uuid') && data.global) {
             errs.push(new validators.InvalidParamError('global',
                 'cannot specify both global and owner_uuid'));
         }
 
-        if (!hasOwnProperty(data, 'global')
-            && !hasOwnProperty(data, 'owner_uuid')) {
+        if (!hasOwnProperty(data, 'global') &&
+            !hasOwnProperty(data, 'owner_uuid')) {
             errs.push(new validators.InvalidParamError('owner_uuid',
                 'owner_uuid required'));
         }
@@ -420,24 +424,42 @@ function FwRule(data, opts) {
     var dir;
 
     this.action = parsed.action;
+    this.priority = parsed.priority || 0;
     this.protocol = parsed.protocol.name;
 
-    if (icmpr.test(this.protocol)) {
+    switch (this.protocol) {
+    case 'icmp':
+    case 'icmp6':
         this.types = icmpTypeSort(parsed.protocol.targets);
         this.protoTargets = this.types;
-    } else {
+        break;
+    case 'ah':
+    case 'esp':
+        this.protoTargets = parsed.protocol.targets;
+        break;
+    case 'tcp':
+    case 'udp':
         this.ports = parsed.protocol.targets.sort(function (a, b) {
             var first = hasOwnProperty(a, 'start') ? a.start : a;
             var second = hasOwnProperty(b, 'start') ? b.start : b;
             return Number(first) - Number(second);
         });
         this.protoTargets = this.ports;
+        break;
+    default:
+        throw new validators.InvalidParamError('rule',
+            'unknown protocol "%s"', this.protocol);
     }
 
-    if (this.protoTargets.length > MAX_PORTS) {
+    if (opts.maxVersion < MINVER_LGPROTOTARG) {
+        if (this.protoTargets.length > OLD_MAX_PORTS) {
+            throw new validators.InvalidParamError('rule',
+                'maximum of %d %s allowed', OLD_MAX_PORTS,
+                icmpr.test(this.protocol) ? 'types' : 'ports');
+        }
+    } else if (this.protoTargets.length > MAX_PROTOCOL_TARGETS) {
         throw new validators.InvalidParamError('rule',
-            'maximum of %d %s allowed',
-            MAX_TARGETS_PER_SIDE,
+            'maximum of %d %s allowed', MAX_PROTOCOL_TARGETS,
             icmpr.test(this.protocol) ? 'types' : 'ports');
     }
 
@@ -570,6 +592,7 @@ FwRule.prototype.raw = function () {
         action: this.action,
         enabled: this.enabled,
         from: this.from,
+        priority: this.priority,
         protocol: this.protocol,
         to: this.to,
         uuid: this.uuid,
@@ -580,10 +603,20 @@ FwRule.prototype.raw = function () {
         raw.owner_uuid = this.owner_uuid;
     }
 
-    if (icmpr.test(this.protocol)) {
+    switch (this.protocol) {
+    case 'icmp':
+    case 'icmp6':
         raw.types = this.types;
-    } else {
+        break;
+    case 'ah':
+    case 'esp':
+        break;
+    case 'tcp':
+    case 'udp':
         raw.ports = this.ports;
+        break;
+    default:
+        throw new Error('unknown protocol: ' + this.protocol);
     }
 
     for (var s in STRING_PROPS) {
@@ -635,6 +668,7 @@ FwRule.prototype.text = function () {
     var containsRange;
     var ports;
     var protoTxt;
+    var prioTxt = '';
     var targets = {
         from: [],
         to: []
@@ -659,8 +693,10 @@ FwRule.prototype.text = function () {
     });
 
     // Protocol-specific text: different for ICMP rather than TCP/UDP
-    if (icmpr.test(this.protocol)) {
-        protoTxt = util.format('%sTYPE %s%s',
+    switch (this.protocol) {
+    case 'icmp':
+    case 'icmp6':
+        protoTxt = util.format(' %sTYPE %s%s',
             this.types.length > 1 ? '(' : '',
             this.types.map(function (type) {
                 return type.toString().split(':');
@@ -669,10 +705,16 @@ FwRule.prototype.text = function () {
             }).join(' AND TYPE '),
             this.types.length > 1 ? ')' : ''
         );
-    } else {
+        break;
+    case 'ah':
+    case 'esp':
+        protoTxt = '';
+        break;
+    case 'tcp':
+    case 'udp':
         ports = this.ports.map(function (port) {
-            if (hasOwnProperty(port, 'start')
-                && hasOwnProperty(port, 'end')) {
+            if (hasOwnProperty(port, 'start') &&
+                hasOwnProperty(port, 'end')) {
                 /*
                  * We only output PORTS when we have a range, since we don't
                  * distinguish PORTS 1, 2 from (PORT 1 AND PORT 2) after
@@ -685,17 +727,24 @@ FwRule.prototype.text = function () {
             }
         });
         if (containsRange) {
-            protoTxt = util.format('PORTS %s', ports.join(', '));
+            protoTxt = util.format(' PORTS %s', ports.join(', '));
         } else {
-            protoTxt = util.format('%sPORT %s%s',
+            protoTxt = util.format(' %sPORT %s%s',
                 ports.length > 1 ? '(' : '',
                 ports.join(' AND PORT '),
                 ports.length > 1 ? ')' : ''
             );
         }
+        break;
+    default:
+        throw new Error('unknown protocol: ' + this.protocol);
+    }
+
+    if (this.priority > 0) {
+        prioTxt += ' PRIORITY ' + this.priority.toString();
     }
 
-    return util.format('FROM %s%s%s TO %s%s%s %s %s',
+    return util.format('FROM %s%s%s TO %s%s%s %s %s%s%s',
             targets.from.length > 1 ? '(' : '',
             targets.from.join(' OR '),
             targets.from.length > 1 ? ')' : '',
@@ -704,7 +753,8 @@ FwRule.prototype.text = function () {
             targets.to.length > 1 ? ')' : '',
             this.action.toUpperCase(),
             this.protocol.toLowerCase(),
-            protoTxt
+            protoTxt,
+            prioTxt
     );
 };
 
diff --git a/deps/fw/node_modules/fwrule/validators.js b/deps/fw/node_modules/fwrule/validators.js
index 651df74..817eb5e 100644
--- a/deps/fw/node_modules/fwrule/validators.js
+++ b/deps/fw/node_modules/fwrule/validators.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  */
 
@@ -30,6 +30,7 @@
 
 'use strict';
 
+var ipaddr = require('ip6addr');
 var net = require('net');
 var util = require('util');
 var VError = require('verror').VError;
@@ -40,7 +41,6 @@ var VError = require('verror').VError;
 
 
 
-var icmpr = /^icmp6?$/;
 var portRE = /^[0-9]{1,5}$/;
 var UUID_REGEX =
     /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
@@ -92,24 +92,6 @@ function validateIPv4subnet(subnet) {
 }
 
 
-/**
- * Returns true if subnet is a valid IPv6 CIDR range
- */
-function validateIPv6subnet(subnet) {
-    var parts = subnet.split('/');
-    var plen = Number(parts[1]);
-    if (!net.isIPv6(parts[0])) {
-        return false;
-    }
-
-    if (!plen || (plen < 1) || (plen > 128)) {
-        return false;
-    }
-
-    return true;
-}
-
-
 /**
  * Returns true if port is a valid port number
  */
@@ -147,16 +129,25 @@ function validatePortOrAll(port) {
 }
 
 /**
- * Returns true if protocol is one of tcp, udp, icmp (mixing of upper
- * and lower-case allowed)
+ * Returns true if protocol is one of the protocols recognized by the
+ * fwrule language. (Mixing of upper and lower-case is allowed.)
  */
 function validateProtocol(protocol) {
     if (typeof (protocol) !== 'string') {
         return false;
     }
 
-    var protoLC = protocol.toLowerCase();
-    return ((protoLC === 'tcp') || (protoLC === 'udp') || icmpr.test(protoLC));
+    switch (protocol.toLowerCase()) {
+    case 'ah':
+    case 'esp':
+    case 'icmp':
+    case 'icmp6':
+    case 'tcp':
+    case 'udp':
+        return true;
+    default:
+        return false;
+    }
 }
 
 
@@ -201,6 +192,35 @@ function validateString(name, str) {
 }
 
 
+/**
+ * Throws an InvalidParamError if the subnet is invalid
+ */
+function validateSubnet(name, input, enforceSubnetMask) {
+    var parts = input.split('/');
+    var addr, plen, subnet;
+
+    try {
+        addr = ipaddr.parse(parts[0]);
+        plen = Number(parts[1]);
+    } catch (_) {
+        throw new InvalidParamError(name,
+            'Subnet "%s" is invalid (bad address component)', input);
+    }
+
+    try {
+        subnet = ipaddr.createCIDR(addr, plen);
+    } catch (_) {
+        throw new InvalidParamError(name,
+            'Subnet "%s" is invalid (bad prefix length)', input);
+    }
+
+    if (enforceSubnetMask && subnet.address().compare(addr) !== 0) {
+        throw new InvalidParamError(name,
+            'Subnet "%s" is invalid (bits set to right of mask)', input);
+    }
+}
+
+
 /**
  * Returns true if uuid is a valid UUID
  */
@@ -215,7 +235,7 @@ module.exports = {
     validateAction: validateAction,
     validateIPv4address: validateIPv4address,
     validateIPv4subnet: validateIPv4subnet,
-    validateIPv6subnet: validateIPv6subnet,
+    validateSubnet: validateSubnet,
     validatePort: validatePort,
     validatePortOrAll: validatePortOrAll,
     validateProtocol: validateProtocol,
diff --git a/deps/fw/node_modules/ip6addr.js b/deps/fw/node_modules/ip6addr.js
new file mode 100644
index 0000000..a63808c
--- /dev/null
+++ b/deps/fw/node_modules/ip6addr.js
@@ -0,0 +1,716 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var util = require('util');
+
+
+///--- Helpers
+
+function ParseError(input, message, index) {
+  if (Error.captureStackTrace)
+    Error.captureStackTrace(this, ParseError);
+
+  this.input = input;
+  this.message = message;
+  if (index !== undefined) {
+    this.message += ' at index ' + index;
+  }
+}
+util.inherits(ParseError, Error);
+
+function modulo(a, n) {
+  return (n + (a % n)) % n;
+}
+
+function _arrayToOctetString(input) {
+  var out;
+  out = (input[0] >> 8) + '.' + (input[0] & 0xff) + '.';
+  out += (input[1] >> 8) + '.' + (input[1] & 0xff);
+  return out;
+}
+
+function _isAddr(addr) {
+  if (typeof (addr) === 'object') {
+    /* It must resemble an Addr object */
+    if (Array.isArray(addr._fields) && typeof (addr._attrs) === 'object') {
+      return true;
+    }
+  }
+  return false;
+}
+
+function _toAddr(input) {
+  if (typeof (input) === 'string') {
+    return ip6addrParse(input);
+  } else if (_isAddr(input)) {
+    return input;
+  } else {
+    throw new Error('Invalid argument: Addr or parsable string expected');
+  }
+}
+
+function _arrayToHex(input, zeroElide, zeroPad) {
+  var i;
+  var elStart = null;
+  var elLen = 0;
+  if (zeroElide) {
+    /* find longest run of zeroes to potentially elide */
+    var start = null;
+    var len = null;
+    for (i = 0; i < input.length; i++) {
+      if (input[i] === 0) {
+        if (start === null) {
+          start = i;
+          len = 1;
+        } else {
+          len++;
+        }
+      } else if (start !== null) {
+        if (len > elLen) {
+          elStart = start;
+          elLen = len;
+        }
+        start = null;
+      }
+    }
+    /* capturing last potential zero */
+    if (start !== null && len > elLen) {
+      elStart = start;
+      elLen = len;
+    }
+  }
+
+  var output = [];
+  var num;
+  for (i = 0; i < input.length; i++) {
+    if (elStart !== null) {
+      if (i === elStart) {
+        if (elLen === 8) {
+          /* all-zeroes is just '::' */
+          return ['::'];
+        } else if (elStart === 0 || elStart + elLen === input.length) {
+          /*
+           * For elided zeroes at the beginning/end of the address, an extra
+           * ':' is needed during the join step.
+           */
+          output.push(':');
+        } else {
+          output.push('');
+        }
+      }
+      if (i >= elStart && i < elStart + elLen) {
+        continue;
+      }
+    }
+    num = input[i].toString(16);
+    if (zeroPad && num.length != 4) {
+      num = '0000'.slice(num.length) + num;
+    }
+    output.push(num);
+  }
+  return output;
+}
+
+function _ipv4Mapped(input) {
+  var comp = [0, 0, 0, 0, 0, 0xffff];
+  var i;
+  for (i = 0; i < 6; i++) {
+    if (input[i] != comp[i])
+      return false;
+  }
+  return true;
+}
+
+function _prefixToAddr(len) {
+  assert.number(len);
+  len = len | 0;
+  assert.ok(len <= 128);
+  assert.ok(len >= 0);
+
+  var output = new Addr();
+  var i;
+  for (i = 0; len > 16; i++, len -= 16) {
+    output._fields[i] = 0xffff;
+  }
+  if (len > 0) {
+    output._fields[i] = 0xffff - ((1 << (16 - len)) - 1);
+  }
+  return output;
+}
+
+function _toCIDR(input) {
+  if (typeof (input) === 'string') {
+    return new CIDR(input);
+  } else if (input instanceof CIDR) {
+    return input;
+  } else {
+    throw new Error('Invalid argument: CIDR or parsable string expected');
+  }
+}
+
+var strDefaults = {
+  format: 'auto', // Control format of printed address
+  zeroElide: true, // Elide longest run of zeros
+  zeroPad: false // Pad with zeros when a group would print as < 4 chars
+};
+
+function getStrOpt(opts, name) {
+  if (opts && opts.hasOwnProperty(name)) {
+    return opts[name];
+  } else {
+    return strDefaults[name];
+  }
+}
+
+///--- Public Classes
+
+/**
+ * IPv6/IPv4 address representation.
+ *
+ * It should not be instantiated directly by library consumers.
+ */
+function Addr() {
+  this._fields = [0, 0, 0, 0, 0, 0, 0, 0];
+  this._attrs = {};
+}
+
+Addr.prototype.kind = function getKind() {
+  if (v4subnet.contains(this)) {
+    return 'ipv4';
+  } else {
+    return 'ipv6';
+  }
+};
+
+Addr.prototype.toString = function toString(opts) {
+  assert.optionalObject(opts, 'opts');
+  var format = getStrOpt(opts, 'format');
+  var zeroElide = getStrOpt(opts, 'zeroElide');
+  var zeroPad = getStrOpt(opts, 'zeroPad');
+
+  assert.string(format, 'opts.format');
+  assert.bool(zeroElide, 'opts.zeroElide');
+  assert.bool(zeroPad, 'opts.zeroPad');
+
+  // Try to print the address the way it was originally formatted
+  if (format === 'auto') {
+    if (this._attrs.ipv4Bare) {
+      format = 'v4';
+    } else if (this._attrs.ipv4Mapped) {
+      format = 'v4-mapped';
+    } else {
+      format = 'v6';
+    }
+  }
+
+  switch (format) {
+  // Print in dotted-quad notation (but only if truly IPv4)
+  case 'v4':
+    if (!v4subnet.contains(this)) {
+        throw new Error('cannot print non-v4 address in dotted quad notation');
+    }
+    return _arrayToOctetString(this._fields.slice(6));
+
+  // Print as an IPv4-mapped IPv6 address
+  case 'v4-mapped':
+    if (!v4subnet.contains(this)) {
+        throw new Error('cannot print non-v4 address as a v4-mapped address');
+    }
+    var output = _arrayToHex(this._fields.slice(0, 6), zeroElide, zeroPad);
+    output.push(_arrayToOctetString(this._fields.slice(6)));
+    return output.join(':');
+
+  // Print as an IPv6 address
+  case 'v6':
+    return _arrayToHex(this._fields, zeroElide, zeroPad).join(':');
+
+  // Unrecognized formatting method
+  default:
+    throw new Error('unrecognized format method "' + format + '"');
+  }
+};
+
+Addr.prototype.toBuffer = function toBuffer(buf) {
+  if (buf !== undefined) {
+    if (!Buffer.isBuffer(buf)) {
+      throw new Error('optional arg must be Buffer');
+    }
+  } else {
+    buf = new Buffer(16);
+  }
+  var i;
+  for (i = 0; i < 8; i++) {
+    buf.writeUInt16BE(this._fields[i], i*2);
+  }
+  return buf;
+};
+
+Addr.prototype.toLong = function toLong() {
+  if (!v4subnet.contains(this)) {
+    throw new Error('only possible for ipv4-mapped addresses');
+  }
+  return ((this._fields[6] << 16) >>> 0) + this._fields[7];
+};
+
+Addr.prototype.clone = function cloneAddr() {
+  var out = new Addr();
+  out._fields = this._fields.slice();
+  for (var k in this._attrs) {
+      out._attrs[k] = this._attrs[k];
+  }
+  return out;
+};
+
+Addr.prototype.offset = function offset(num) {
+  if (num < -4294967295 || num > 4294967295) {
+    throw new Error('offsets should be between -4294967295 and 4294967295');
+  }
+  var out = this.clone();
+  var i, moved;
+  for (i = 7; i >= 0; i--) {
+    moved = out._fields[i] + num;
+    if (moved > 65535) {
+      num = moved >>> 16;
+      moved = moved & 0xffff;
+    } else if (moved < 0) {
+      num = Math.floor(moved / (1 << 16));
+      moved = modulo(moved, 1 << 16);
+    } else {
+      num = 0;
+    }
+    out._fields[i] = moved;
+
+    /* Prevent wrap-around for both ipv6 and ipv4-mapped addresses */
+    if (num !== 0) {
+      if ((i === 0) || (i === 6 && this._attrs.ipv4Mapped)) {
+        return null;
+      }
+    } else {
+      break;
+    }
+  }
+  return out;
+};
+
+Addr.prototype.and = function addrAnd(input) {
+  input = _toAddr(input);
+  var i;
+  var output = this.clone();
+  for (i = 0; i < 8; i++) {
+    output._fields[i] = output._fields[i] & input._fields[i];
+  }
+  return output;
+};
+
+Addr.prototype.or = function addrOr(input) {
+  input = _toAddr(input);
+  var i;
+  var output = this.clone();
+  for (i = 0; i < 8; i++) {
+    output._fields[i] = output._fields[i] | input._fields[i];
+  }
+  return output;
+};
+
+Addr.prototype.not = function addrNot() {
+  var i;
+  var output = this.clone();
+  for (i = 0; i < 8; i++) {
+    output._fields[i] = (~ output._fields[i]) & 0xffff;
+  }
+  return output;
+};
+
+Addr.prototype.compare = function compareMember(addr) {
+  return ip6addrCompare(this, addr);
+};
+
+/**
+ * CIDR Block
+ * @param addr CIDR network address
+ * @param prefixLen Length of network prefix
+ *
+ * The addr parameter can be an Addr object or a parseable string.
+ * If prefixLen is omitted, then addr must contain a parseable string in the
+ * form '<address>/<prefix>'.
+ */
+function CIDR(addr, prefixLen) {
+  if (prefixLen === undefined) {
+    /* OK to pass pass string of "<addr>/<prefix>" */
+    assert.string(addr);
+    var fields = addr.match(/^([a-fA-F0-9:.]+)\/([0-9]+)$/);
+    if (fields === null) {
+      throw new Error('Invalid argument: <addr>/<prefix> expected');
+    }
+    addr = fields[1];
+    prefixLen = parseInt(fields[2], 10);
+  }
+  assert.number(prefixLen);
+  prefixLen = prefixLen | 0;
+  addr = _toAddr(addr);
+
+  /* Expand prefix to ipv6 length of bare ipv4 address provided */
+  if (addr._attrs.ipv4Bare) {
+    prefixLen += 96;
+  }
+  if (prefixLen < 0 || prefixLen > 128) {
+    throw new Error('Invalid prefix length');
+  }
+  this._prefix = prefixLen;
+  this._mask = _prefixToAddr(prefixLen);
+  this._addr = addr.and(this._mask);
+}
+
+CIDR.prototype.contains = function cidrContains(input) {
+  input = _toAddr(input);
+  return (this._addr.compare(input.and(this._mask)) === 0);
+};
+
+CIDR.prototype.first = function cidrFirst(input) {
+  if (this._prefix >= 127) {
+    /* Support single-address and point-to-point networks */
+    return this._addr;
+  } else {
+    return this._addr.offset(1);
+  }
+};
+
+CIDR.prototype.last = function cidrLast(input) {
+  var ending = this._addr.or(this._mask.not());
+  if (this._prefix >= 127) {
+    /* Support single-address and point-to-point networks */
+    return ending;
+  } else {
+    if (this._addr._attrs.ipv4Mapped) {
+      /* don't include the broadcast for ipv4 */
+      return ending.offset(-1);
+    } else {
+      return ending;
+    }
+  }
+};
+
+CIDR.prototype.broadcast = function getBroadcast() {
+  if (!v4subnet.contains(this._addr)) {
+    throw new Error('Only IPv4 networks have broadcast addresses');
+  }
+  return this._addr.or(this._mask.not());
+};
+
+CIDR.prototype.compare = function compareCIDR(cidr) {
+  return ip6cidrCompare(this, cidr);
+};
+
+CIDR.prototype.prefixLength = function getPrefixLength(format) {
+  assert.optionalString(format, 'format');
+  if (format === undefined || format === 'auto') {
+    format = this._addr._attrs.ipv4Bare ? 'v4' : 'v6';
+  }
+
+  switch (format) {
+  case 'v4':
+    if (!v4subnet.contains(this._addr)) {
+        throw new Error('cannot return v4 prefix length for non-v4 address');
+    }
+    return this._prefix - 96;
+  case 'v6':
+    return this._prefix;
+  default:
+    throw new Error('unrecognized format method "' + format + '"');
+  }
+};
+
+CIDR.prototype.address = function getAddressComponent() {
+  return this._addr;
+};
+
+CIDR.prototype.toString = function cidrString(opts) {
+  assert.optionalObject(opts, 'opts');
+
+  var format = getStrOpt(opts, 'format');
+  if (format === 'v4-mapped') {
+    format = 'v6';
+  }
+
+  return this._addr.toString(opts) + '/' + this.prefixLength(format);
+};
+
+var v4subnet = new CIDR('::ffff:0:0', 96);
+
+function ip6cidrCompare(a, b) {
+  a = _toCIDR(a);
+  b = _toCIDR(b);
+
+  /*
+   * We compare first on the address component, and then on the prefix length,
+   * such that the network with the smaller prefix length (the larger subnet)
+   * is greater than the network with the smaller prefix (the smaller subnet).
+   * This is the same ordering used in Postgres.
+   */
+  var cmp = ip6addrCompare(a._addr, b._addr);
+  return cmp === 0 ? b._prefix - a._prefix : cmp;
+}
+
+/**
+ * Range of addresses.
+ * @param begin Beginning address of the range
+ * @param end Ending address of the range
+ *
+ * Parameters can be Addr objects or parsable address strings.
+ */
+function AddrRange(begin, end) {
+  begin = _toAddr(begin);
+  end = _toAddr(end);
+
+  if (begin.compare(end) > 0) {
+    throw new Error('begin address must be <= end address');
+  }
+
+  this._begin = begin;
+  this._end = end;
+}
+
+AddrRange.prototype.contains = function addrRangeContains(input) {
+  input = _toAddr(input);
+  return (this._begin.compare(input) <= 0 && this._end.compare(input) >= 0);
+};
+
+AddrRange.prototype.first = function addrRangeFirst() {
+  return this._begin;
+};
+
+AddrRange.prototype.last = function addrRangeLast() {
+  return this._end;
+};
+
+
+///--- Public Functions
+
+function ip6addrParse(input) {
+  if (typeof (input) === 'string') {
+    return parseString(input);
+  } else if (typeof (input) === 'number') {
+    return parseLong(input);
+  } else if (typeof (input) === 'object' && _isAddr(input)) {
+    return input;
+  } else {
+    throw new Error('Invalid argument: only string|number allowed');
+  }
+}
+
+function parseString(input) {
+  assert.string(input);
+  input = input.toLowerCase();
+  var result = new Addr();
+
+  var ip6Fields = []; // hold unparsed hex fields
+  var ip4Fields = []; // hold unparsed decimal fields
+  var expIndex = null; // field index of '::' delimiter
+  var value = '';  // accumulate unparsed hex/dec field
+  var i, c;
+
+  /*
+   * No valid ipv6 is longer than 39 characters.
+   * An extra character of leeway is there to tolerate some :: funny business.
+   */
+  if (input.length > 40) {
+    throw new ParseError(input, 'Input too long');
+  }
+
+  for (i = 0; i < input.length; i++) {
+    c = input[i];
+    if (c === ':') {
+      if ((i+1) < input.length && input[i+1] === ':') {
+        /*
+         * Variable length '::' delimiter.
+         * Multiples would be ambiguous
+         */
+        if (expIndex !== null) {
+          throw new ParseError(input, 'Multiple :: delimiters', i);
+        }
+
+        /*
+         * The value buffer can be empty for cases where the '::' delimiter is
+         * the first portion of the address.
+         */
+        if (value !== '') {
+          ip6Fields.push(value);
+          value = '';
+        }
+        expIndex = ip6Fields.length;
+        i++;
+      } else {
+        /*
+         * Standard ':' delimiter
+         * The value buffer cannot be empty since that would imply an illegal
+         * pattern such as ':::' or ':.'.
+         */
+        if (value === '') {
+          throw new ParseError(input, 'illegal delimiter', i);
+        }
+        ip6Fields.push(value);
+        value = '';
+      }
+    } else if (c === '.') {
+      /*
+       * Handle dotted quad notation for ipv4 and ipv4-mapped addresses.
+       */
+      ip4Fields.push(value);
+      value = '';
+    } else {
+      value = value + c;
+    }
+  }
+  /* Handle the last stashed value */
+  if (value !== '') {
+    if (ip4Fields.length !== 0) {
+      ip4Fields.push(value);
+    } else {
+      ip6Fields.push(value);
+    }
+    value = '';
+  } else {
+    /* With no stashed value, the address must end with '::'. */
+    if (expIndex !== ip6Fields.length || ip4Fields.length > 0) {
+      throw new ParseError(input, 'Cannot end with delimiter besides ::');
+    }
+  }
+
+  /* With values collected, ensure we don't have too many/few */
+  if (ip4Fields.length === 0) {
+    if (ip6Fields.length > 8) {
+      throw new ParseError(input, 'Too many fields');
+    } else if (ip6Fields.length < 8 && expIndex === null) {
+      throw new ParseError(input, 'Too few fields');
+    }
+  } else {
+    if (ip4Fields.length !== 4) {
+      throw new ParseError(input, 'IPv4 portion must have 4 fields');
+    }
+    /* If this is a bare IP address, implicitly convert to IPv4 mapped */
+    if (ip6Fields.length === 0 && expIndex === null) {
+      result._attrs.ipv4Bare = true;
+      ip6Fields = ['ffff'];
+      expIndex = 0;
+    }
+
+    if (ip6Fields.length > 6) {
+      throw new ParseError(input, 'Too many fields');
+    } else if (ip6Fields.length < 6 && expIndex === null) {
+      throw new ParseError(input, 'Too few fields');
+    }
+  }
+
+  /* Parse integer values */
+  var field, num;
+  for (i = 0; i < ip6Fields.length; i++) {
+    field = ip6Fields[i];
+    num = Number('0x' + field);
+    if (isNaN(num) || num < 0 || num > 65535) {
+      throw new ParseError(input, 'Invalid field value: ' + field);
+    }
+    ip6Fields[i] = num;
+  }
+  for (i = 0; i < ip4Fields.length; i++) {
+    field = ip4Fields[i];
+    num = Number(field);
+    if (parseInt(field, 10) !== num || num < 0 || num > 255) {
+      throw new ParseError(input, 'Invalid field value: ' + field);
+    }
+    ip4Fields[i] = num;
+  }
+
+  /* Collapse IPv4 portion, if necessary */
+  if (ip4Fields.length !== 0) {
+    ip6Fields.push((ip4Fields[0]*256) + ip4Fields[1]);
+    ip6Fields.push((ip4Fields[2]*256) + ip4Fields[3]);
+  }
+
+  /* Expand '::' delimiter into implied 0s */
+  if (ip6Fields.length < 8 && expIndex !== null) {
+    var filler = [];
+    for (i = 0; i < (8 - ip6Fields.length); i++) {
+      filler.push(0);
+    }
+    ip6Fields = Array.prototype.concat(
+      ip6Fields.slice(0, expIndex),
+      filler,
+      ip6Fields.slice(expIndex)
+    );
+  }
+
+  /*
+   * If dotted-quad notation was used, ensure the input was either a bare ipv4
+   * address or a valid ipv4-mapped address.
+   */
+  if (ip4Fields.length !== 0) {
+    if (!_ipv4Mapped(ip6Fields)) {
+      throw new ParseError(input, 'invalid dotted-quad notation');
+    } else {
+      result._attrs.ipv4Mapped = true;
+    }
+  }
+
+  result._fields = ip6Fields;
+
+  return result;
+}
+
+function parseLong(input) {
+  assert.number(input);
+  if (input !== Math.floor(input)) {
+    throw new Error('Value must be integer');
+  }
+  if (input < 0 || input > 0xffffffff) {
+    throw new Error('Value must be 32 bit');
+  }
+  var out = new Addr();
+  out._fields[7] = input & 0xffff;
+  out._fields[6] = (input >>> 16);
+  /* this is ipv4-mapped */
+  out._fields[5] = 0xffff;
+  out._attrs.ipv4Bare = true;
+  out._attrs.ipv4Mapped = true;
+  return out;
+}
+
+/**
+ * Compare Addr objects in a manner suitable for Array.sort().
+ */
+function ip6addrCompare(a, b) {
+  a = _toAddr(a);
+  b = _toAddr(b);
+
+  var i;
+  for (i = 0; i < 8; i++) {
+    if (a._fields[i] < b._fields[i]) {
+      return -1;
+    } else if (a._fields[i] > b._fields[i]) {
+      return 1;
+    }
+  }
+  return 0;
+}
+
+
+///--- Exports
+
+module.exports = {
+  parse: ip6addrParse,
+  compare: ip6addrCompare,
+  createCIDR: function (addr, len) {
+    return new CIDR(addr, len);
+  },
+  compareCIDR: ip6cidrCompare,
+  createAddrRange: function (begin, end) {
+    return new AddrRange(begin, end);
+  }
+};
diff --git a/deps/fw/node_modules/node-uuid/LICENSE.md b/deps/fw/node_modules/node-uuid/LICENSE.md
deleted file mode 100644
index bcdddf9..0000000
--- a/deps/fw/node_modules/node-uuid/LICENSE.md
+++ /dev/null
@@ -1,3 +0,0 @@
-Copyright (c) 2010 Robert Kieffer
-
-Dual licensed under the [MIT](http://en.wikipedia.org/wiki/MIT_License) and [GPL](http://en.wikipedia.org/wiki/GNU_General_Public_License) licenses.
diff --git a/deps/fw/node_modules/node-uuid/index.js b/deps/fw/node_modules/node-uuid/index.js
deleted file mode 100644
index 76328cd..0000000
--- a/deps/fw/node_modules/node-uuid/index.js
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * Generate RFC4122 (v1 and v4) UUIDs
- *
- * Documentation at https://github.com/broofa/node-uuid
- */
-(function() {
-  // Use WHATWG crypto api if available, otherwise shim it
-  // http://wiki.whatwg.org/wiki/Crypto
-  //
-  // (Create a static _rnds array here as well, which lets us avoid per-uuid
-  // array creation)
-  var crypto, _rnds;
-  if (crypto && crypto.getRandomValues) {
-    _rnds = new Uint32Array(4);
-  } else {
-    _rnds = new Array(4);
-    // Math.random does not have the cryptographic-quality guarantee for
-    // randomness that crypto.getRandomValues has, but it's the best we have.
-    crypto = {
-      getRandomValues: function(arr) {
-        for (var i = 0, l = arr.length; i < l; i++) {
-          _rnds[i] = Math.random() * 0x100000000;
-        }
-      }
-    };
-  }
-
-  // Use node.js Buffer class if available, otherwise use the Array class
-  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;
-
-  // Maps for number <-> hex string conversion
-  var _octetToHex = [];
-  var _hexToOctet = {};
-  for (var i = 0; i < 256; i++) {
-    _octetToHex[i] = (i + 0x100).toString(16).substr(1);
-    _hexToOctet[_octetToHex[i]] = i;
-  }
-
-  /**
-   * Parse a uuid string into it's component octets.
-   *
-   * This is a loose parser.  It parses the first 16 octet pairs as hex
-   * values.  If fewer than 16 are found, any remaining entries in the array
-   * are set to zero.
-   *
-   * @param s (String) string to parse.
-   * @param buf (Array|Buffer) Optional buffer to capture parsed values in
-   * @param offset (Number) Optional starting offset into buf
-   */
-  function parse(s, buf, offset) {
-    var buf = buf || new BufferClass(16),
-        i = offset || 0,
-        ii = 0;
-    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(octet) {
-      if (ii < 16) { // Don't overflow!
-        buf[i + ii++] = _hexToOctet[octet];
-      }
-    });
-
-    // Zero out remaining octets if string was short
-    while (ii < 16) {
-      buf[i + ii] = 0;
-    }
-
-    return buf;
-  }
-
-  /**
-   * Generate a uuid string from octet array
-   *
-   * @param buf (Array|Buffer) Optional buffer to pull octets from
-   * @param offset (Number) Optional starting offset into buf
-   */
-  function unparse(buf, offset) {
-    var oth = _octetToHex,
-        b = buf,
-        i = offset || 0;
-    return  oth[b[i + 0]] + oth[b[i + 1]] +
-            oth[b[i + 2]] + oth[b[i + 3]] + '-' +
-            oth[b[i + 4]] + oth[b[i + 5]] + '-' +
-            oth[b[i + 6]] + oth[b[i + 7]] + '-' +
-            oth[b[i + 8]] + oth[b[i + 9]] + '-' +
-            oth[b[i + 10]] + oth[b[i + 11]] +
-            oth[b[i + 12]] + oth[b[i + 13]] +
-            oth[b[i + 14]] + oth[b[i + 15]];
-  }
-
-  /**
-   * Create and return octets for a 48-bit node id:
-   * 47 bits random, 1 bit (multicast) set to 1
-   */
-  function _randomNodeId() {
-    crypto.getRandomValues(_rnds);
-
-    return [
-      _rnds[0] & 0xff | 0x01, // Set multicast bit, per 4.1.6 and 4.5
-      _rnds[0] >>> 8 & 0xff,
-      _rnds[0] >>> 16 & 0xff,
-      _rnds[0] >>> 24 & 0xff,
-      _rnds[1] & 0xff,
-      _rnds[1] >>> 8 & 0xff
-    ];
-  }
-
-  // Pre-allocate arrays to avoid per-uuid array creation
-  var _buf = new BufferClass(16);
-
-  //
-  // v1 UUID support
-  //
-  // Inspired by https://github.com/LiosK/UUID.js
-  // and http://docs.python.org/library/uuid.html
-  //
-
-  // Per 4.1.4 - Offset (in msecs) from JS time to UUID (gregorian) time
-  var EPOCH_OFFSET = 12219292800000;
-
-  // Per 4.1.4 - UUID time has 100ns resolution
-  // Per 4.2.1.2 - Count of uuids may be used with low resolution clocks
-  var UUIDS_PER_TICK = 10000;
-
-  // Per 4.5, use a random node id
-  var _nodeId = _randomNodeId();
-
-  // Per 4.2.2, use 14 bit random unsigned integer to initialize clock_seq
-  var _clockSeq = _rnds[2] & 0x3fff;
-
-  // Time of previous uuid creation
-  var _last = 0;
-
-  // # of UUIDs that have been created during current millisecond time tick
-  var _count = 0;
-
-  /**
-   * See docs at https://github.com/broofa/node-uuid
-   */
-  function v1(options, buf, offset) {
-    options = typeof(options) == 'string' ? {format: options} : options || {};
-
-    var b = options.format != 'binary' ? _buf :
-            (buf ? buf : new BufferClass(16));
-    var i = buf && offset || 0;
-
-    // JS Numbers don't have sufficient resolution for keeping time in
-    // 100-nanosecond units, as spec'ed by the RFC, so we kind of kludge things
-    // here by tracking time in JS-msec units, with a second var for the
-    // additional 100-nanosecond units to add to the millisecond-based time.
-    var msecs = 0; // JS time (msecs since Unix epoch)
-    var nsecs = 0; // Additional time (100-nanosecond units), added to msecs
-
-    // Get msecs & nsecs
-    if (options.msecs == null) {
-      // Per 4.2.1.2, use uuid count to simulate higher resolution clock
-      // Get current time and simulate higher clock resolution
-      msecs = new Date().getTime() + EPOCH_OFFSET;
-      _count = (msecs == _last) ? _count + 1 : 0;
-
-      // Per 4.2.1.2 If generator overruns, throw an error
-      // (*Highly* unlikely - requires generating > 10M uuids/sec)
-      if (_count == UUIDS_PER_TICK) {
-        throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
-      }
-
-      // Per 4.2.1.2, if time regresses bump the clock sequence.
-      if (msecs < _last) {
-        _clockSeq++;
-        _count = 0;
-      }
-
-      _last = msecs;
-      nsecs = _count;
-    } else {
-      msecs = options.msecs + EPOCH_OFFSET;
-      nsecs = options.nsecs || 0;
-    }
-    // Per 4.1.4, timestamp composition
-    // time is uuid epoch time in _msecs_
-    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
-    var tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;
-    var tm = tmh & 0xffff, th = tmh >> 16;
-    var thav = (th & 0xfff) | 0x1000; // Set version, per 4.1.3
-
-    // Clock sequence
-    var cs = options.clockseq != null ? options.clockseq : _clockSeq;
-
-    // time_low
-    b[i++] = tl >>> 24 & 0xff;
-    b[i++] = tl >>> 16 & 0xff;
-    b[i++] = tl >>> 8 & 0xff;
-    b[i++] = tl & 0xff;
-
-    // time_mid
-    b[i++] = tm >>> 8 & 0xff;
-    b[i++] = tm & 0xff;
-
-    // time_high_and_version
-    b[i++] = thav >>> 8 & 0xff;
-    b[i++] = thav & 0xff;
-
-    // clock_seq_hi_and_reserved (include variant, per 4.2.2)
-    b[i++] = (cs >>> 8) | 0x80;
-
-    // clock_seq_low
-    b[i++] = cs & 0xff;
-
-    // node
-    var node = options.node || _nodeId;
-    for (var n = 0; n < 6; n++) {
-      b[i + n] = node[n];
-    }
-
-    return options.format == null ? unparse(b) : b;
-  }
-
-  //
-  // v4 UUID support
-  //
-
-  /**
-   * See docs at https://github.com/broofa/node-uuid
-   */
-  function v4(options, buf, offset) {
-    options = typeof(options) == 'string' ? {format: options} : options || {};
-
-    var b = options.format != 'binary' ? _buf :
-            (buf ? buf : new BufferClass(16));
-    var i = buf && offset || 0;
-
-    var rnds = options.random || crypto.getRandomValues(_rnds);
-
-    // v4 ideas are all random bits
-    for (var c = 0 ; c < 16; c++) {
-      var ri = c >> 2,
-          rb = (c & 0x03) * 8;
-      b[i + c] = _rnds[ri] >>> rb & 0xff;
-    }
-
-    // ... except for this
-    b[i + 6] = (b[i + 6] & 0x0f) | 0x40; // Per RFC4122 sect. 4.1.3
-    b[i + 8] = (b[i + 8] & 0x3f) | 0x80; // Per RFC4122 sect. 4.4
-
-    return options.format == null ? unparse(b) : b;
-  }
-
-  var uuid = v4;
-  uuid.v1 = v1;
-  uuid.v4 = v4;
-  uuid.parse = parse;
-  uuid.unparse = unparse;
-  uuid.BufferClass = BufferClass;
-
-  if (typeof(module) != 'undefined') {
-    module.exports = uuid;
-  } else {
-    this.uuid = uuid;
-  }
-}());
diff --git a/deps/fw/node_modules/uuid/LICENSE.md b/deps/fw/node_modules/uuid/LICENSE.md
new file mode 100644
index 0000000..8c84e39
--- /dev/null
+++ b/deps/fw/node_modules/uuid/LICENSE.md
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2010-2016 Robert Kieffer and other contributors
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/deps/fw/node_modules/uuid/index.js b/deps/fw/node_modules/uuid/index.js
new file mode 100644
index 0000000..e96791a
--- /dev/null
+++ b/deps/fw/node_modules/uuid/index.js
@@ -0,0 +1,8 @@
+var v1 = require('./v1');
+var v4 = require('./v4');
+
+var uuid = v4;
+uuid.v1 = v1;
+uuid.v4 = v4;
+
+module.exports = uuid;
diff --git a/deps/fw/node_modules/uuid/lib/bytesToUuid.js b/deps/fw/node_modules/uuid/lib/bytesToUuid.js
new file mode 100644
index 0000000..2c9a223
--- /dev/null
+++ b/deps/fw/node_modules/uuid/lib/bytesToUuid.js
@@ -0,0 +1,23 @@
+/**
+ * Convert array of 16 byte values to UUID string format of the form:
+ * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
+ */
+var byteToHex = [];
+for (var i = 0; i < 256; ++i) {
+  byteToHex[i] = (i + 0x100).toString(16).substr(1);
+}
+
+function bytesToUuid(buf, offset) {
+  var i = offset || 0;
+  var bth = byteToHex;
+  return bth[buf[i++]] + bth[buf[i++]] +
+          bth[buf[i++]] + bth[buf[i++]] + '-' +
+          bth[buf[i++]] + bth[buf[i++]] + '-' +
+          bth[buf[i++]] + bth[buf[i++]] + '-' +
+          bth[buf[i++]] + bth[buf[i++]] + '-' +
+          bth[buf[i++]] + bth[buf[i++]] +
+          bth[buf[i++]] + bth[buf[i++]] +
+          bth[buf[i++]] + bth[buf[i++]];
+}
+
+module.exports = bytesToUuid;
diff --git a/deps/fw/node_modules/uuid/lib/rng.js b/deps/fw/node_modules/uuid/lib/rng.js
new file mode 100644
index 0000000..58f0dc9
--- /dev/null
+++ b/deps/fw/node_modules/uuid/lib/rng.js
@@ -0,0 +1,8 @@
+// Unique ID creation requires a high quality random # generator.  In node.js
+// this is pretty straight-forward - we use the crypto API.
+
+var crypto = require('crypto');
+
+module.exports = function nodeRNG() {
+  return crypto.randomBytes(16);
+};
diff --git a/deps/fw/node_modules/uuid/v1.js b/deps/fw/node_modules/uuid/v1.js
new file mode 100644
index 0000000..d84c0f4
--- /dev/null
+++ b/deps/fw/node_modules/uuid/v1.js
@@ -0,0 +1,109 @@
+var rng = require('./lib/rng');
+var bytesToUuid = require('./lib/bytesToUuid');
+
+// **`v1()` - Generate time-based UUID**
+//
+// Inspired by https://github.com/LiosK/UUID.js
+// and http://docs.python.org/library/uuid.html
+
+var _nodeId;
+var _clockseq;
+
+// Previous uuid creation time
+var _lastMSecs = 0;
+var _lastNSecs = 0;
+
+// See https://github.com/broofa/node-uuid for API details
+function v1(options, buf, offset) {
+  var i = buf && offset || 0;
+  var b = buf || [];
+
+  options = options || {};
+  var node = options.node || _nodeId;
+  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
+
+  // node and clockseq need to be initialized to random values if they're not
+  // specified.  We do this lazily to minimize issues related to insufficient
+  // system entropy.  See #189
+  if (node == null || clockseq == null) {
+    var seedBytes = rng();
+    if (node == null) {
+      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
+      node = _nodeId = [
+        seedBytes[0] | 0x01,
+        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
+      ];
+    }
+    if (clockseq == null) {
+      // Per 4.2.2, randomize (14 bit) clockseq
+      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
+    }
+  }
+
+  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
+  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
+  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
+  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
+  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();
+
+  // Per 4.2.1.2, use count of uuid's generated during the current clock
+  // cycle to simulate higher resolution clock
+  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
+
+  // Time since last uuid creation (in msecs)
+  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;
+
+  // Per 4.2.1.2, Bump clockseq on clock regression
+  if (dt < 0 && options.clockseq === undefined) {
+    clockseq = clockseq + 1 & 0x3fff;
+  }
+
+  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
+  // time interval
+  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
+    nsecs = 0;
+  }
+
+  // Per 4.2.1.2 Throw error if too many uuids are requested
+  if (nsecs >= 10000) {
+    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
+  }
+
+  _lastMSecs = msecs;
+  _lastNSecs = nsecs;
+  _clockseq = clockseq;
+
+  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
+  msecs += 12219292800000;
+
+  // `time_low`
+  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
+  b[i++] = tl >>> 24 & 0xff;
+  b[i++] = tl >>> 16 & 0xff;
+  b[i++] = tl >>> 8 & 0xff;
+  b[i++] = tl & 0xff;
+
+  // `time_mid`
+  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
+  b[i++] = tmh >>> 8 & 0xff;
+  b[i++] = tmh & 0xff;
+
+  // `time_high_and_version`
+  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
+  b[i++] = tmh >>> 16 & 0xff;
+
+  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
+  b[i++] = clockseq >>> 8 | 0x80;
+
+  // `clock_seq_low`
+  b[i++] = clockseq & 0xff;
+
+  // `node`
+  for (var n = 0; n < 6; ++n) {
+    b[i + n] = node[n];
+  }
+
+  return buf ? buf : bytesToUuid(b);
+}
+
+module.exports = v1;
diff --git a/deps/fw/node_modules/uuid/v4.js b/deps/fw/node_modules/uuid/v4.js
new file mode 100644
index 0000000..1f07be1
--- /dev/null
+++ b/deps/fw/node_modules/uuid/v4.js
@@ -0,0 +1,29 @@
+var rng = require('./lib/rng');
+var bytesToUuid = require('./lib/bytesToUuid');
+
+function v4(options, buf, offset) {
+  var i = buf && offset || 0;
+
+  if (typeof(options) == 'string') {
+    buf = options === 'binary' ? new Array(16) : null;
+    options = null;
+  }
+  options = options || {};
+
+  var rnds = options.random || (options.rng || rng)();
+
+  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
+  rnds[6] = (rnds[6] & 0x0f) | 0x40;
+  rnds[8] = (rnds[8] & 0x3f) | 0x80;
+
+  // Copy bytes to buffer, if provided
+  if (buf) {
+    for (var ii = 0; ii < 16; ++ii) {
+      buf[i + ii] = rnds[ii];
+    }
+  }
+
+  return buf || bytesToUuid(rnds);
+}
+
+module.exports = v4;
diff --git a/deps/fw/package.json b/deps/fw/package.json
index 313cbce..9131120 100644
--- a/deps/fw/package.json
+++ b/deps/fw/package.json
@@ -16,8 +16,10 @@
     "clone": "0.1.4",
     "cmdln": "4.1.1",
     "extsprintf": "1.0.2",
+    "fwrule": "2.0.0",
+    "ip6addr": "0.2.2",
     "mkdirp": "0.3.4",
-    "node-uuid": "1.2.0",
+    "uuid": "3.2.1",
     "tab": "0.1.0",
     "vasync": "1.6.3",
     "verror": "1.6.0"
diff --git a/deps/fw/test/integration/examples.test.js b/deps/fw/test/integration/examples.test.js
index 2864569..449f2fb 100644
--- a/deps/fw/test/integration/examples.test.js
+++ b/deps/fw/test/integration/examples.test.js
@@ -8,6 +8,7 @@
 var async = require('async');
 var exec = require('child_process').exec;
 var fs = require('fs');
+var mod_fw = require('../lib/fw');
 var mod_vm = require('../lib/vm');
 var path = require('path');
 var util = require('util');
@@ -30,6 +31,8 @@ var VMS = [
     '60e90d15-fb48-4bb9-90e6-1e1bb8269d1e'
 ];
 
+var KS = ' keep state';
+var KF = ' keep frags';
 
 
 // --- Helpers
@@ -80,48 +83,6 @@ function addRulesAndRVMs(stdout) {
 }
 
 
-/**
- * Test whether the ipf rules show up in 'fwadm status' for a VM
- */
-function fwStatsContain(t, uuid, inLines, inDesc, cb) {
-    var cmd = 'fwadm stats ' + uuid;
-    var desc = inDesc + ': ';
-    // clone the input:
-    var lines = inLines.map(function (l) { return l; });
-
-    exec(cmd, function (err, stdout, stderr) {
-        t.ifError(err, desc + 'error running: ' + cmd);
-        t.equal(stderr, '', desc + 'stderr: ' + cmd);
-
-        var rules = [];
-
-        stdout.split('\n').forEach(function (line) {
-            if (line === '') {
-                return;
-            }
-
-            var parts = line.split(/\s+/g);
-            parts.shift();
-            var rule = parts.join(' ');
-            var idx = lines.indexOf(rule);
-            if (idx !== -1) {
-                t.ok(true, desc + 'found rule: ' + rule);
-                lines.splice(idx, 1);
-            }
-
-            rules.push(rule);
-        });
-
-        t.deepEqual(lines, [], desc + 'found all rules');
-        if (lines.length !== 0) {
-            t.deepEqual(rules, [], desc + 'rules found');
-        }
-
-        return cb();
-    });
-}
-
-
 
 // --- Setup
 
@@ -305,8 +266,8 @@ exports['vmadm'] = {
     },
 
     'stats after vmadm_vm1': function (t) {
-        fwStatsContain(t, VMS[0], [
-            'block out quick proto tcp from any to any port = smtp'
+        mod_fw.statsContain(t, VMS[0], [
+            'block out quick proto tcp from any to any port = smtp' + KF
         ], 'smtp block rule applied', function () {
             return t.done();
         });
@@ -338,10 +299,10 @@ exports['vmadm'] = {
     },
 
     'stats after vmadm_cmd1': function (t) {
-        fwStatsContain(t, VMS[0], [
-            'block out quick proto tcp from any to any port = smtp',
-            'pass in quick proto tcp from any to any port = www',
-            'pass in quick proto tcp from any to any port = https'
+        mod_fw.statsContain(t, VMS[0], [
+            'block out quick proto tcp from any to any port = smtp' + KF,
+            'pass in quick proto tcp from any to any port = www' + KS + KF,
+            'pass in quick proto tcp from any to any port = https' + KS + KF
         ], 'smtp block rule applied', function () {
             return t.done();
         });
@@ -387,10 +348,10 @@ exports['vmadm'] = {
     },
 
     'stats after start': function (t) {
-        fwStatsContain(t, VMS[0], [
-            'block out quick proto tcp from any to any port = smtp',
-            'pass in quick proto tcp from any to any port = www',
-            'pass in quick proto tcp from any to any port = https'
+        mod_fw.statsContain(t, VMS[0], [
+            'block out quick proto tcp from any to any port = smtp' + KF,
+            'pass in quick proto tcp from any to any port = www' + KS + KF,
+            'pass in quick proto tcp from any to any port = https' + KS + KF
         ], 'smtp block rule applied', function () {
             return t.done();
         });
diff --git a/deps/fw/test/integration/ipsec.test.js b/deps/fw/test/integration/ipsec.test.js
new file mode 100644
index 0000000..38875ba
--- /dev/null
+++ b/deps/fw/test/integration/ipsec.test.js
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ *
+ * Integration tests for rules that allow IPsec traffic into an instance.
+ */
+
+var mod_cp = require('child_process');
+var mod_fw = require('../lib/fw');
+var mod_vm = require('../lib/vm');
+var util = require('util');
+var uuid = require('uuid');
+
+
+// --- Globals
+
+var KS = ' keep state';
+var KF = ' keep frags';
+
+var d = {
+    owner_uuid: uuid.v4()
+};
+
+
+// --- Tests
+
+exports['create vm and rules'] = {
+    'create': function (t) {
+        mod_vm.create(t, {
+            params: {
+                owner_uuid: d.owner_uuid,
+                firewall_enabled: true,
+                image_uuid: mod_vm.images.smartos,
+                nics: [
+                    {
+                        nic_tag: 'admin',
+                        ip: '10.4.0.30',
+                        netmask: '255.255.255.0'
+                    }
+                ]
+            },
+            partialExp: {
+                firewall_enabled: true
+            }
+        });
+    },
+
+    'fw status after create': function (t) {
+        d.vm = mod_vm.lastCreated();
+        t.ok(d.vm, 'have last created VM');
+
+        mod_fw.status(t, {
+            uuid: d.vm.uuid,
+            partialExp: {
+                running: true
+            }
+        });
+    },
+
+    'add rules': function (t) {
+        var child = mod_cp.execFile('fwadm', [ 'add' ], {
+            stdio: 'pipe'
+        }, function (err, stdout, stderr) {
+            t.ifError(err, '"fwadm add" error');
+            if (err !== null) {
+                t.equal(err.code, 0, '"fwadm add" exited non-zero');
+                t.equal(stderr, '', '"fwadm add" stderr');
+                t.equal(stdout, '', '"fwadm add" stdout');
+            }
+            t.done();
+        });
+
+        child.stdin.write(JSON.stringify({
+            rules: [
+                {
+                    owner_uuid: d.owner_uuid,
+                    rule: util.format('FROM any TO vm %s ALLOW ah', d.vm.uuid),
+                    enabled: true
+                },
+                {
+                    owner_uuid: d.owner_uuid,
+                    rule: util.format('FROM any TO vm %s ALLOW esp', d.vm.uuid),
+                    enabled: true
+                },
+                {
+                    owner_uuid: d.owner_uuid,
+                    rule: util.format('FROM any TO vm %s ALLOW '
+                        + 'udp (PORT 500 AND PORT 4500)', d.vm.uuid),
+                    enabled: true
+                }
+            ]
+        }));
+
+        child.stdin.end();
+    },
+
+    'check ipf rules': function (t) {
+        mod_fw.statsContain(t, d.vm.uuid, [
+            'pass in quick proto ah from any to any' + KF,
+            'pass in quick proto esp from any to any' + KF,
+            'pass in quick proto udp from any to any port = isakmp' + KF,
+            'pass in quick proto udp from any to any port = ipsec-nat-t' + KF
+        ], 'ipsec rules applied', function () {
+            t.done();
+        });
+    }
+};
+
+
+
+// --- Teardown
+
+exports['teardown'] = function (t) {
+    mod_vm.delAllCreated(t, {});
+};
diff --git a/deps/fw/test/lib/fw.js b/deps/fw/test/lib/fw.js
index a33c266..185b51b 100644
--- a/deps/fw/test/lib/fw.js
+++ b/deps/fw/test/lib/fw.js
@@ -6,6 +6,7 @@
 
 var assert = require('assert-plus');
 var common = require('./common');
+var mod_cp = require('child_process');
 var mod_log = require('./log');
 var util = require('util');
 
@@ -14,6 +15,47 @@ var util = require('util');
 // --- Exports
 
 
+/**
+ * Test whether the ipf rules show up in 'fwadm status' for a VM
+ */
+function statsContain(t, uuid, inLines, inDesc, cb) {
+    var cmd = 'fwadm stats ' + uuid;
+    var desc = inDesc + ': ';
+    // clone the input:
+    var lines = inLines.slice();
+
+    mod_cp.exec(cmd, function compareStats(err, stdout, stderr) {
+        t.ifError(err, desc + 'error running: ' + cmd);
+        t.equal(stderr, '', desc + 'stderr: ' + cmd);
+
+        var rules = [];
+
+        stdout.split('\n').forEach(function (line) {
+            if (line === '') {
+                return;
+            }
+
+            var parts = line.split(/\s+/g);
+            parts.shift();
+            var rule = parts.join(' ');
+            var idx = lines.indexOf(rule);
+            if (idx !== -1) {
+                t.ok(true, desc + 'found rule: ' + rule);
+                lines.splice(idx, 1);
+            }
+
+            rules.push(rule);
+        });
+
+        t.deepEqual(lines, [], desc + 'found all rules');
+        if (lines.length !== 0) {
+            t.deepEqual(rules, [], desc + 'rules found');
+        }
+
+        return cb();
+    });
+}
+
 
 /**
  * `fwadm status <uuid>`
@@ -114,6 +156,7 @@ function zoneRunning(t, opts, callback) {
 
 
 module.exports = {
+    statsContain: statsContain,
     status: status,
     zoneEnable: zoneEnable,
     zoneRunning: zoneRunning
diff --git a/deps/fw/test/lib/helpers.js b/deps/fw/test/lib/helpers.js
index dba0dd3..22c7474 100644
--- a/deps/fw/test/lib/helpers.js
+++ b/deps/fw/test/lib/helpers.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  * Unit test helper functions
  */
@@ -28,9 +28,10 @@
 var assert = require('assert-plus');
 var clone = require('clone');
 var fwrule = require('fwrule');
+var mod_addr = require('ip6addr');
 var mod_obj = require('../../lib/util/obj');
 var mocks = require('./mocks');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 var VError = require('verror');
@@ -121,8 +122,8 @@ function addZoneRules(exp, toAdd) {
 function defaultZoneRules(uuids) {
     var toReturn = {};
     if (!uuids) {
-        createSubObjects(toReturn, 'out', 'pass', { any: 'any' });
-        createSubObjects(toReturn, 'in', 'block', { any: 'any' });
+        createSubObjects(toReturn, 'out', {});
+        createSubObjects(toReturn, 'in', {});
         return toReturn;
     }
 
@@ -131,8 +132,8 @@ function defaultZoneRules(uuids) {
     }
 
     uuids.forEach(function (uuid) {
-        createSubObjects(toReturn, uuid, 'out', 'pass', { any: 'any' });
-        createSubObjects(toReturn, uuid, 'in', 'block', { any: 'any' });
+        createSubObjects(toReturn, uuid, 'out', {});
+        createSubObjects(toReturn, uuid, 'in', {});
     });
 
     return toReturn;
@@ -366,6 +367,13 @@ function zoneIPFconfigs(version) {
             continue;
         }
 
+        var zone = dir.split('/')[2];
+        var rules = {
+            in: {},
+            out: {}
+        };
+        firewalls[zone] = rules;
+
         if (DEBUG_FILES) {
             console.log('%s:\n+-', dir);
         }
@@ -380,9 +388,7 @@ function zoneIPFconfigs(version) {
 
             // block out quick proto tcp from any to 10.99.99.254 port = 3000
             // pass in quick proto tcp from 10.2.0.1 to any port = 80
-            var zone = dir.split('/')[2];
             var tok = l.split(' ');
-            var action = tok[0];
             var d = tok[1];
 
             if (l === 'block in all'
@@ -392,8 +398,6 @@ function zoneIPFconfigs(version) {
                 || l === ICMPV6_STATE_LINE
                 || l === ICMPV6_WILD_LINE
                 || /^pass out proto \w+ from any to any/.test(l)) {
-                var act = createSubObjects(firewalls, zone, d, action);
-                act.any = 'any';
                 return;
             }
 
@@ -403,44 +407,11 @@ function zoneIPFconfigs(version) {
                 proto = 'icmp6';
             }
 
-            var dest = action === 'block' ? tok[8] : tok[6];
-            var code, port, portMatch;
-            if (icmpr.test(proto)) {
-                /* JSSTYLED */
-                portMatch = l.match(/icmp-type (\d+)/);
-                if (portMatch) {
-                    port = portMatch[1];
-                    /* JSSTYLED */
-                    code = l.match(/code (\d+)/);
-                    if (code) {
-                        port = port + ':' + code[1];
-                    }
-                } else {
-                    port = 'all';
-                }
-            } else {
-                portMatch = l.match(/port = (\d+)/);
-                if (portMatch) {
-                    port = portMatch[1];
-                } else {
-                    port = 'all';
-                }
+            if (!hasKey(rules[d], proto)) {
+                rules[d][proto] = [];
             }
 
-            // block out quick proto tcp to any port = 8080
-            if (tok[6] === 'any' && tok.length < 12) {
-                dest = 'any';
-            }
-
-            var dests = createSubObjects(firewalls, zone, d, action, proto);
-            if (!hasKey(dests, dest)) {
-                dests[dest] = [];
-            }
-
-            if (dests[dest].indexOf(port) == -1) {
-                dests[dest] = dests[dest].concat([port]).sort(function (a, b) {
-                    return (a - b); });
-            }
+            rules[d][proto].push(l);
         });
 
         if (DEBUG_FILES) {
@@ -615,9 +586,167 @@ function vmsAffected(opts, callback) {
     });
 }
 
+function compareIPArrays(a, b) {
+    return mod_addr.compare(a[0], b[0]);
+}
+
+function concat(acc, curr) {
+    return acc.concat(curr);
+}
+
+function getIPsFromVMs(vms) {
+    var ips = [];
+
+    vms.forEach(function (vm) {
+        var arr = util_vm.ipsFromNICs(vm.nics);
+        if (arr.length > 0) {
+            ips.push(arr);
+        }
+    });
+
+    return ips.sort(compareIPArrays).reduce(concat, []);
+}
+
+function forEachVMsIPs(vms, f) {
+    getIPsFromVMs(vms).forEach(f);
+}
+
+function createPortRule(action, dir, proto, who, port, rest) {
+    var suffix = '';
+    if (port) {
+        suffix += 'port = ' + port;
+    }
+    suffix += ' keep frags';
+    if (rest) {
+        suffix += ' ' + rest;
+    }
+    return util.format(
+        '%s %s quick proto %s from %s %s', action, dir, proto, who, suffix);
+}
+
+function createRangeRule(action, dir, proto, who, p1, p2, rest) {
+    var suffix = 'port ' + p1 + ' : ' + p2 + ' keep frags';
+    if (rest) {
+        suffix += ' ' + rest;
+    }
+    return util.format(
+        '%s %s quick proto %s from %s %s', action, dir, proto, who, suffix);
+}
+
+function allowInAH(src, rest) {
+    return createPortRule('pass', 'in', 'ah', src + ' to any', null, rest);
+}
+
+function allowInESP(src, rest) {
+    return createPortRule('pass', 'in', 'esp', src + ' to any', null, rest);
+}
+
+function blockOutAH(dst) {
+    return createPortRule('block', 'out', 'ah', 'any to ' + dst);
+}
+
+function blockOutESP(dst) {
+    return createPortRule('block', 'out', 'esp', 'any to ' + dst);
+}
+
+function allowPortInTCP(src, port, rest) {
+    return createPortRule('pass', 'in', 'tcp', src + ' to any', port, rest);
+}
+
+function allowRangeInTCP(src, p1, p2) {
+    return createRangeRule('pass', 'in', 'tcp', src + ' to any', p1, p2);
+}
+
+function blockPortInTCP(src, port, rest) {
+    return createPortRule('block', 'in', 'tcp', src + ' to any', port, rest);
+}
+
+function blockRangeInTCP(src, p1, p2) {
+    return createRangeRule('block', 'in', 'tcp', src + ' to any', p1, p2);
+}
+
+function allowPortInUDP(src, port, rest) {
+    return createPortRule('pass', 'in', 'udp', src + ' to any', port, rest);
+}
+
+function allowInICMP(src, type, code) {
+    var suffix = '';
+    if (type !== undefined) {
+        suffix += 'icmp-type ' + type;
+    }
+    if (code !== undefined) {
+        suffix += ' code ' + code;
+    }
+    suffix += ' keep frags';
+    return util.format(
+        'pass in quick proto icmp from %s to any %s', src, suffix);
+}
+
+function allowInICMP6(src, type, code) {
+    var suffix = '';
+    if (type !== undefined) {
+        suffix += 'icmp-type ' + type;
+    }
+    if (code !== undefined) {
+        suffix += ' code ' + code;
+    }
+    suffix += ' keep frags';
+    return util.format(
+        'pass in quick proto ipv6-icmp from %s to any %s', src, suffix);
+}
+
+
+function allowPortOutTCP(dst, port) {
+    return createPortRule('pass', 'out', 'tcp', 'any to ' + dst, port);
+}
+
+function blockPortOutTCP(dst, port) {
+    return createPortRule('block', 'out', 'tcp', 'any to ' + dst, port);
+}
+
+function allowPortOutUDP(dst, port) {
+    return createPortRule('pass', 'out', 'udp', 'any to ' + dst, port);
+}
+
+function allowRangeOutUDP(dst, p1, p2) {
+    return createRangeRule('pass', 'out', 'udp', 'any to ' + dst, p1, p2);
+}
+
+function blockPortOutUDP(dst, port) {
+    return createPortRule('block', 'out', 'udp', 'any to ' + dst, port);
+}
+
+function blockRangeOutUDP(dst, p1, p2) {
+    return createRangeRule('block', 'out', 'udp', 'any to ' + dst, p1, p2);
+}
 
 
 module.exports = {
+    allowPortInTCP: allowPortInTCP,
+    blockPortInTCP: blockPortInTCP,
+    allowRangeInTCP: allowRangeInTCP,
+    blockRangeInTCP: blockRangeInTCP,
+
+    allowPortOutTCP: allowPortOutTCP,
+    blockPortOutTCP: blockPortOutTCP,
+
+    allowPortInUDP: allowPortInUDP,
+
+    allowPortOutUDP: allowPortOutUDP,
+    blockPortOutUDP: blockPortOutUDP,
+
+    allowRangeOutUDP: allowRangeOutUDP,
+    blockRangeOutUDP: blockRangeOutUDP,
+
+    allowInICMP: allowInICMP,
+    allowInICMP6: allowInICMP6,
+
+    allowInAH: allowInAH,
+    allowInESP: allowInESP,
+
+    blockOutAH: blockOutAH,
+    blockOutESP: blockOutESP,
+
     addZoneRules: addZoneRules,
     defaultZoneRules: defaultZoneRules,
     fillInRuleBlanks: fillInRuleBlanks,
@@ -627,6 +756,8 @@ module.exports = {
     fwRulesEqual: fwRulesEqual,
     fwRvmRulesEqual: fwRvmRulesEqual,
     getIPFenabled: getIPFenabled,
+    getIPsFromVMs: getIPsFromVMs,
+    forEachVMsIPs: forEachVMsIPs,
     generateVM: generateVM,
     ipKey: ipKey,
     printVM: printVM,
diff --git a/deps/fw/test/lib/mocks.js b/deps/fw/test/lib/mocks.js
index ac159fa..d2fb122 100644
--- a/deps/fw/test/lib/mocks.js
+++ b/deps/fw/test/lib/mocks.js
@@ -471,13 +471,15 @@ function setup(opts) {
         'events',
         'extsprintf',
         'fwrule',
+        'ip6addr',
         'net',
-        'node-uuid',
         'path',
         'stream',
         'vasync',
         'verror',
         'util',
+        'uuid',
+        './',
         './clonePrototype.js',
         './filter',
         './ipf',
diff --git a/deps/fw/test/node_modules/nodeunit/lib/assert.js b/deps/fw/test/node_modules/nodeunit/lib/assert.js
index 55ef744..a5bb34f 100644
--- a/deps/fw/test/node_modules/nodeunit/lib/assert.js
+++ b/deps/fw/test/node_modules/nodeunit/lib/assert.js
@@ -48,6 +48,7 @@ var _keys = function(obj){
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 
+var clone = require('clone');
 var pSlice = Array.prototype.slice;
 
 // 1. The assert module provides functions that throw
@@ -62,8 +63,8 @@ var assert = exports;
 assert.AssertionError = function AssertionError (options) {
   this.name = "AssertionError";
   this.message = options.message;
-  this.actual = options.actual;
-  this.expected = options.expected;
+  this.actual = clone(options.actual);
+  this.expected = clone(options.expected);
   this.operator = options.operator;
   var stackStartFunction = options.stackStartFunction || fail;
 
diff --git a/deps/fw/test/runtest b/deps/fw/test/runtest
index 60727cd..f63b7f7 100755
--- a/deps/fw/test/runtest
+++ b/deps/fw/test/runtest
@@ -1,5 +1,7 @@
 #!/bin/bash
 
+set -o errexit
+
 UNAME=$(uname -s)
 NODE=node
 TOP=$(unset CDPATH; cd $(dirname $0)/../; pwd)
@@ -12,7 +14,7 @@ fi
 function usage
 {
     echo "Usage:"
-    echo "  runtest [OPTIONS...]"
+    echo "  runtest [OPTIONS...] file"
     echo ""
     echo "Options:"
     echo "  -r REPORTER  Nodeunit test reporter to use (default is 'tap')."
@@ -38,6 +40,12 @@ do
     esac
 done
 
+# Should have only one argument left.
+if [[ $OPTIND -ne $# ]]; then
+    usage
+    exit 1
+fi
+
 if [[ $UNAME == "SunOS" ]]; then
     echo "# Adding images.joyent.com as an imgadm source"
     imgadm sources -a "https://images.joyent.com/"
diff --git a/deps/fw/test/runtests b/deps/fw/test/runtests
index fb5e814..bba381f 100755
--- a/deps/fw/test/runtests
+++ b/deps/fw/test/runtests
@@ -88,6 +88,8 @@ mkdir -p $OUTPUT_DIR
 
 #---- start tests
 
+FINAL_EXIT_CODE=0
+
 for test in $(ls $TOP/test/integration | grep "\.test.js$"); do
     test_name=$(basename $test)
     set +o errexit
@@ -111,14 +113,21 @@ echo "# test output in $OUTPUT_DIR:"
 cd $OUTPUT_DIR
 ls *.tap
 
+if [[ ${test_errors} -gt 0 ]]; then
+    echo ""
+    echo "# failing tests:"
+    echo "$failed_tests"
+    FINAL_EXIT_CODE=1
+fi
+
 echo ""
 echo "# test results:"
 
 end_time=$(date +%s)
 elapsed=$((${end_time} - ${start_time}))
 
-tests=$(grep "^# tests [0-9]" $OUTPUT_DIR/*.tap | cut -d ' ' -f3 | xargs | tr ' ' '+' | bc)
-passed=$(grep "^# pass  [0-9]" $OUTPUT_DIR/*.tap | tr -s ' ' | cut -d ' ' -f3 | xargs | tr ' ' '+' | bc)
+tests=$(awk '/^# tests +[0-9]/ { sum += $(NF) } END { print sum }' $OUTPUT_DIR/*.tap)
+passed=$(awk '/^# pass +[0-9]/ { sum += $(NF) } END { print sum }' $OUTPUT_DIR/*.tap)
 [[ -z ${tests} ]] && tests=0
 [[ -z ${passed} ]] && passed=0
 fail=$((${tests} - ${passed}))
@@ -127,9 +136,11 @@ echo "# Completed in ${elapsed} seconds."
 echo -e "# \033[32mPASS: ${passed} / ${tests}\033[39m"
 if [[ ${fail} -gt 0 ]]; then
     echo -e "# \033[31mFAIL: ${fail} / ${tests}\033[39m"
+    FINAL_EXIT_CODE=1
+elif [[ ${test_errors} -gt 0 ]]; then
+    echo -e "# \033[31mFAIL: ? / ${tests}\033[39m"
+    FINAL_EXIT_CODE=1
 fi
 echo ""
 
-if [[ ${tests} != ${passed} ]]; then
-    exit 1
-fi
+exit $FINAL_EXIT_CODE
diff --git a/deps/fw/test/unit/add.test.js b/deps/fw/test/unit/add.test.js
index 76c8f0b..1dd634b 100644
--- a/deps/fw/test/unit/add.test.js
+++ b/deps/fw/test/unit/add.test.js
@@ -10,7 +10,7 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 
@@ -201,7 +201,7 @@ exports['created_by'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
diff --git a/deps/fw/test/unit/fw.test.js b/deps/fw/test/unit/fw.test.js
index a8ee090..cee1515 100644
--- a/deps/fw/test/unit/fw.test.js
+++ b/deps/fw/test/unit/fw.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  * fwadm tests
  */
@@ -31,11 +31,10 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 
-var createSubObjects = mod_obj.createSubObjects;
 var mergeObjects = mod_obj.mergeObjects;
 
 
@@ -141,10 +140,10 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
 
             var v4rules = helpers.defaultZoneRules(vm.uuid);
             var v6rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v4rules, vm.uuid, 'out', 'block', 'tcp',
-                {
-                    '10.99.99.254': [ 8080 ]
-                });
+
+            v4rules[vm.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.99.99.254', 8080)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
@@ -207,11 +206,11 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
 
             var v4rules = helpers.defaultZoneRules(vm.uuid);
             var v6rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v4rules, vm.uuid, 'out', 'block', 'tcp',
-                {
-                    '10.99.99.254': [ 8080 ],
-                    '10.88.88.2': [ 8080 ]
-                });
+
+            v4rules[vm.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.88.88.2', 8080),
+                helpers.blockPortOutTCP('10.99.99.254', 8080)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
@@ -296,7 +295,7 @@ exports['add / update: vm to IP: BLOCK'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -373,7 +372,7 @@ exports['add / update: vm to IP: ALLOW'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -417,10 +416,11 @@ exports['add: tag to IP'] = function (t) {
 
             var v4rules = helpers.defaultZoneRules(vm1.uuid);
             var v6rules = helpers.defaultZoneRules(vm1.uuid);
-            createSubObjects(v4rules, vm1.uuid, 'out', 'block', 'tcp',
-                {
-                    '10.99.99.254': [ 25 ]
-                });
+
+            v4rules[vm1.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.99.99.254', 25)
+            ];
+
             v4rules[vm2.uuid] = v4rules[vm1.uuid];
             v6rules[vm2.uuid] = v6rules[vm1.uuid];
 
@@ -473,7 +473,7 @@ exports['add: tag to IP'] = function (t) {
         }, cb);
     }
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -525,14 +525,14 @@ exports['add: tag to subnet'] = function (t) {
 
             var v4rules = helpers.defaultZoneRules(vm1.uuid);
             var v6rules = helpers.defaultZoneRules(vm1.uuid);
-            createSubObjects(v4rules, vm1.uuid, 'out', 'block', 'tcp',
-                {
-                    '10.99.99.0/24': [ 25 ]
-                });
-            createSubObjects(v4rules, vm1.uuid, 'in', 'pass', 'tcp',
-                {
-                    '10.99.99.0/24': [ 80 ]
-                });
+
+            v4rules[vm1.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.99.99.0/24', 25)
+            ];
+            v4rules[vm1.uuid].in.tcp = [
+                helpers.allowPortInTCP('10.99.99.0/24', 80, 'keep state')
+            ];
+
             v4rules[vm2.uuid] = v4rules[vm1.uuid];
             v6rules[vm2.uuid] = v6rules[vm1.uuid];
 
@@ -605,7 +605,7 @@ exports['add: tag to subnet'] = function (t) {
         }, cb);
     }
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -660,14 +660,10 @@ exports['add: vm to subnet'] = function (t) {
 
             var v4rules = helpers.defaultZoneRules(vm1.uuid);
             var v6rules = helpers.defaultZoneRules(vm1.uuid);
-            createSubObjects(v4rules, vm1.uuid, 'out', 'block', 'tcp',
-                {
-                    '10.99.99.0/24': [ 25 ]
-                });
-            createSubObjects(v4rules, vm1.uuid, 'in', 'pass', 'tcp',
-                {
-                    '10.99.99.0/24': [ 80 ]
-                });
+            v4rules[vm1.uuid].out.tcp =
+                [ helpers.blockPortOutTCP('10.99.99.0/24', 25) ];
+            v4rules[vm1.uuid].in.tcp =
+                [ helpers.allowPortInTCP('10.99.99.0/24', 80, 'keep state') ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
@@ -748,7 +744,253 @@ exports['add: vm to subnet'] = function (t) {
         }, cb);
     }
     ], function () {
-            t.done();
+        t.done();
+    });
+};
+
+
+exports['sorting: multiple ip and subnet rules'] = function (t) {
+    var vm = helpers.generateVM();
+    var payload = {
+        rules: [
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM subnet 10.99.99.0/24 TO vm %s ALLOW tcp PORT 25',
+                    vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM subnet 10.88.88.0/24 TO vm %s ALLOW tcp PORT 25',
+                    vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM subnet 10.66.66.0/24 TO vm %s ALLOW tcp PORT 25',
+                    vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM ip 10.77.77.77 TO vm %s ALLOW tcp PORT 25',
+                    vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM ip 10.77.77.99 TO vm %s ALLOW tcp PORT 25',
+                    vm.uuid),
+                enabled: true
+            }
+        ],
+        vms: [vm]
+    };
+
+    var rule1 = clone(payload.rules[0]);
+    var rule2 = clone(payload.rules[1]);
+    var rule3 = clone(payload.rules[2]);
+    var rule4 = clone(payload.rules[3]);
+    var rule5 = clone(payload.rules[4]);
+
+    var rules = [ rule1, rule2, rule3, rule4, rule5 ];
+
+    async.series([
+    function (cb) {
+        fw.validatePayload(payload, function (err, res) {
+            t.ifError(err);
+            cb();
+        });
+
+    }, function (cb) {
+        fw.add(payload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            helpers.fillInRuleBlanks(res.rules, rules);
+            rules.sort(helpers.uuidSort);
+
+            t.deepEqual(helpers.sortRes(res), {
+                vms: [ vm.uuid ],
+                rules: rules
+            }, 'rules returned');
+
+            var v4rules = helpers.defaultZoneRules(vm.uuid);
+            var v6rules = helpers.defaultZoneRules(vm.uuid);
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('10.66.66.0/24', 25),
+                helpers.allowPortInTCP('10.77.77.77', 25),
+                helpers.allowPortInTCP('10.77.77.99', 25),
+                helpers.allowPortInTCP('10.88.88.0/24', 25),
+                helpers.allowPortInTCP('10.99.99.0/24', 25)
+            ];
+
+            t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
+                'zone ipf.conf files correct');
+            t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
+                'zone ipf6.conf files correct');
+
+            var vmsEnabled = {};
+            vmsEnabled[vm.uuid] = true;
+            t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
+                'ipf enabled in VMs');
+
+            var expRulesOnDisk = {};
+            expRulesOnDisk[rule1.uuid] = clone(rule1);
+            expRulesOnDisk[rule2.uuid] = clone(rule2);
+            expRulesOnDisk[rule3.uuid] = clone(rule3);
+            expRulesOnDisk[rule4.uuid] = clone(rule4);
+            expRulesOnDisk[rule5.uuid] = clone(rule5);
+            t.deepEqual(helpers.rulesOnDisk(), expRulesOnDisk, 'rules on disk');
+
+            cb();
+        });
+
+    }, function (cb) {
+        helpers.fwListEquals(t, rules.sort(helpers.uuidSort), cb);
+
+    }, function (cb) {
+        helpers.fwRulesEqual({
+            t: t,
+            rules: rules,
+            vm: vm,
+            vms: [vm]
+        }, cb);
+
+    }
+    ], function () {
+        t.done();
+    });
+};
+
+
+exports['sorting: multiple icmp types'] = function (t) {
+    var vm = helpers.generateVM();
+    var payload = {
+        rules: [
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM any TO vm %s ALLOW icmp TYPE 1',
+                    vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM ip 1.2.3.4 TO vm %s ALLOW icmp TYPE all',
+                    vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM ip 1.2.3.5 TO vm %s ALLOW icmp TYPE all',
+                    vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM any TO vm %s ALLOW icmp TYPE 5 CODE 1',
+                    vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM any TO vm %s ALLOW icmp TYPE 5 CODE 3',
+                    vm.uuid),
+                enabled: true
+            }
+        ],
+        vms: [vm]
+    };
+
+    var rule1 = clone(payload.rules[0]);
+    var rule2 = clone(payload.rules[1]);
+    var rule3 = clone(payload.rules[2]);
+    var rule4 = clone(payload.rules[3]);
+    var rule5 = clone(payload.rules[4]);
+
+    var rules = [ rule1, rule2, rule3, rule4, rule5 ];
+
+    async.series([
+    function (cb) {
+        fw.validatePayload(payload, function (err, res) {
+            t.ifError(err);
+            cb();
+        });
+
+    }, function (cb) {
+        fw.add(payload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb(err);
+                return;
+            }
+
+            helpers.fillInRuleBlanks(res.rules, rules);
+            rules.sort(helpers.uuidSort);
+
+            t.deepEqual(helpers.sortRes(res), {
+                vms: [ vm.uuid ],
+                rules: rules
+            }, 'rules returned');
+
+            var v4rules = helpers.defaultZoneRules(vm.uuid);
+            var v6rules = helpers.defaultZoneRules(vm.uuid);
+            v4rules[vm.uuid].in.icmp = [
+                helpers.allowInICMP('1.2.3.4'),
+                helpers.allowInICMP('1.2.3.5'),
+                helpers.allowInICMP('any', 1),
+                helpers.allowInICMP('any', 5, 1),
+                helpers.allowInICMP('any', 5, 3)
+            ];
+
+            t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
+                'zone ipf.conf files correct');
+            t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
+                'zone ipf6.conf files correct');
+
+            var vmsEnabled = {};
+            vmsEnabled[vm.uuid] = true;
+            t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
+                'ipf enabled in VMs');
+
+            var expRulesOnDisk = {};
+            expRulesOnDisk[rule1.uuid] = clone(rule1);
+            expRulesOnDisk[rule2.uuid] = clone(rule2);
+            expRulesOnDisk[rule3.uuid] = clone(rule3);
+            expRulesOnDisk[rule4.uuid] = clone(rule4);
+            expRulesOnDisk[rule5.uuid] = clone(rule5);
+            t.deepEqual(helpers.rulesOnDisk(), expRulesOnDisk, 'rules on disk');
+
+            cb();
+        });
+
+    }, function (cb) {
+        helpers.fwListEquals(t, rules.sort(helpers.uuidSort), cb);
+
+    }, function (cb) {
+        helpers.fwRulesEqual({
+            t: t,
+            rules: rules,
+            vm: vm,
+            vms: [vm]
+        }, cb);
+
+    }
+    ], function () {
+        t.done();
     });
 };
 
@@ -888,14 +1130,11 @@ exports['enable / disable rule'] = function (t) {
                 vms: [ vm.uuid ]
             }, 'rules returned');
 
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 33 ]
-                });
-            createSubObjects(v6rules, vm.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 33 ]
-                });
+            v4rules[vm.uuid].in.tcp =
+                [ helpers.allowPortInTCP('any', 33) ];
+            v6rules[vm.uuid].in.tcp =
+                [ helpers.allowPortInTCP('any', 33) ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files still the same');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -925,7 +1164,7 @@ exports['enable / disable rule'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
diff --git a/deps/fw/test/unit/global.test.js b/deps/fw/test/unit/global.test.js
index e96a09e..dfbea8f 100644
--- a/deps/fw/test/unit/global.test.js
+++ b/deps/fw/test/unit/global.test.js
@@ -10,7 +10,7 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 
diff --git a/deps/fw/test/unit/icmp.test.js b/deps/fw/test/unit/icmp.test.js
index b642681..53deb35 100644
--- a/deps/fw/test/unit/icmp.test.js
+++ b/deps/fw/test/unit/icmp.test.js
@@ -31,7 +31,7 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 
@@ -112,10 +112,9 @@ exports['add / update ICMPv4'] = function (t) {
                 rules: [ expRule ]
             }, 'rules returned');
 
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'icmp',
-                {
-                    '10.99.99.254': [ '8' ]
-                });
+            v4rules[vm.uuid].in.icmp = [
+                helpers.allowInICMP('10.99.99.254', '8')
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
@@ -162,7 +161,10 @@ exports['add / update ICMPv4'] = function (t) {
                 rules: [ expRule ]
             }, 'rules returned');
 
-            v4rules[vm.uuid].in.pass.icmp['10.99.99.254'] = [ '8:0' ];
+            v4rules[vm.uuid].in.icmp = [
+                helpers.allowInICMP('10.99.99.254', '8', '0')
+            ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -207,7 +209,10 @@ exports['add / update ICMPv4'] = function (t) {
                 rules: [ expRule ]
             }, 'rules returned');
 
-            v4rules[vm.uuid].in.pass.icmp['10.99.99.254'] = [ 'all' ];
+            v4rules[vm.uuid].in.icmp = [
+                helpers.allowInICMP('10.99.99.254')
+            ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -286,7 +291,7 @@ exports['add / update ICMPv4'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -328,10 +333,9 @@ exports['add / update ICMPv6'] = function (t) {
                 rules: [ expRule ]
             }, 'rules returned');
 
-            createSubObjects(v6rules, vm.uuid, 'in', 'pass', 'icmp6',
-                {
-                    'fe80::92b8:d0ff:fe4b:c73b': [ '128' ]
-                });
+            v6rules[vm.uuid].in.icmp6 = [
+                helpers.allowInICMP6('fe80::92b8:d0ff:fe4b:c73b', '128')
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
@@ -379,8 +383,10 @@ exports['add / update ICMPv6'] = function (t) {
                 rules: [ expRule ]
             }, 'rules returned');
 
-            v6rules[vm.uuid].in.pass.icmp6['fe80::92b8:d0ff:fe4b:c73b'] =
-                [ '128:0' ];
+            v6rules[vm.uuid].in.icmp6 = [
+                helpers.allowInICMP6('fe80::92b8:d0ff:fe4b:c73b', '128', '0')
+            ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -426,8 +432,10 @@ exports['add / update ICMPv6'] = function (t) {
                 rules: [ expRule ]
             }, 'rules returned');
 
-            v6rules[vm.uuid].in.pass.icmp6['fe80::92b8:d0ff:fe4b:c73b'] =
-                [ 'all' ];
+            v6rules[vm.uuid].in.icmp6 = [
+                helpers.allowInICMP6('fe80::92b8:d0ff:fe4b:c73b')
+            ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'zone ipf.conf files correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -505,7 +513,7 @@ exports['add / update ICMPv6'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
diff --git a/deps/fw/test/unit/ipsec.test.js b/deps/fw/test/unit/ipsec.test.js
new file mode 100644
index 0000000..8b60bc5
--- /dev/null
+++ b/deps/fw/test/unit/ipsec.test.js
@@ -0,0 +1,189 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ *
+ * fwadm tests: AH and ESP protocols for IPsec
+ */
+
+var async = require('async');
+var clone = require('clone');
+var fw;
+var helpers = require('../lib/helpers');
+var mocks = require('../lib/mocks');
+var mod_obj = require('../../lib/util/obj');
+var mod_uuid = require('uuid');
+var util = require('util');
+var util_vm = require('../../lib/util/vm');
+
+
+// --- Globals
+
+// Set this to any of the exports in this file to only run that test,
+// plus setup and teardown
+var runOne;
+
+
+// --- Setup
+
+exports['setup'] = function (t) {
+    fw = mocks.setup();
+    t.ok(fw, 'fw loaded');
+    t.done();
+};
+
+
+// run before every test
+exports.setUp = function (cb) {
+    if (fw) {
+        mocks.reset();
+    }
+    cb();
+};
+
+
+// --- Tests
+
+exports['IPsec rules and keepstate'] = function (t) {
+    var vm = helpers.generateVM();
+    var payload = {
+        rules: [
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM ip 1.2.3.4 TO vm %s ALLOW ah', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format(
+                    'FROM ip 1.2.3.4 TO vm %s ALLOW esp', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM vm %s TO any BLOCK ah', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM vm %s TO any BLOCK esp', vm.uuid),
+                enabled: true
+            }
+        ],
+        vms: [vm]
+    };
+
+    var expRules = clone(payload.rules);
+    var vmsEnabled = {};
+    var v4rules = helpers.defaultZoneRules(vm.uuid);
+    var v6rules = helpers.defaultZoneRules(vm.uuid);
+
+    async.series([
+    function addAndCheckRules(cb) {
+        fw.add(payload, function checkRules(err, res) {
+            t.ifError(err);
+            if (err) {
+                cb();
+                return;
+            }
+
+            helpers.fillInRuleBlanks(res.rules, expRules);
+
+            t.deepEqual(res, {
+                rules: expRules,
+                vms: [ vm.uuid ]
+            }, 'rules returned');
+
+            v4rules[vm.uuid].in.ah = [
+                helpers.allowInAH('1.2.3.4', 'keep state')
+            ];
+
+            v4rules[vm.uuid].in.esp = [
+                helpers.allowInESP('1.2.3.4', 'keep state')
+            ];
+
+            v4rules[vm.uuid].out.ah = [
+                helpers.blockOutAH('any')
+            ];
+
+            v4rules[vm.uuid].out.esp = [
+                helpers.blockOutESP('any')
+            ];
+
+            v6rules[vm.uuid].out = clone(v4rules[vm.uuid].out);
+
+            t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
+                'zone ipf.conf files correct');
+            t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
+                'zone ipf6.conf files correct');
+
+            vmsEnabled[vm.uuid] = true;
+            t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
+                'ipf enabled in VMs');
+
+            cb();
+        });
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[0], cb);
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[1], cb);
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[2], cb);
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[3], cb);
+
+    }, function (cb) {
+        helpers.fwListEquals(t, expRules, cb);
+
+    }
+
+    ], function () {
+        t.done();
+    });
+};
+
+
+
+// --- Teardown
+
+
+
+exports['teardown'] = function (t) {
+    mocks.teardown();
+    t.done();
+};
+
+
+// Use to run only one test in this file:
+if (runOne) {
+    module.exports = {
+        setup: exports.setup,
+        setUp: exports.setUp,
+        oneTest: runOne,
+        teardown: exports.teardown
+    };
+}
diff --git a/deps/fw/test/unit/list.test.js b/deps/fw/test/unit/list.test.js
index 1b032c1..95f88a8 100644
--- a/deps/fw/test/unit/list.test.js
+++ b/deps/fw/test/unit/list.test.js
@@ -10,7 +10,7 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 
@@ -139,7 +139,7 @@ exports['fields'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
diff --git a/deps/fw/test/unit/owner.test.js b/deps/fw/test/unit/owner.test.js
index c1adc8d..9e229b9 100644
--- a/deps/fw/test/unit/owner.test.js
+++ b/deps/fw/test/unit/owner.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  * test rules with owner_uuid set
  */
@@ -31,7 +31,7 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 
 var createSubObjects = mod_obj.createSubObjects;
@@ -113,8 +113,10 @@ exports['tag to IP'] = function (t) {
 
             var v4rules = helpers.defaultZoneRules(vm2.uuid);
             var v6rules = helpers.defaultZoneRules(vm2.uuid);
-            createSubObjects(v4rules, vm2.uuid, 'out', 'block', 'tcp',
-                        { '10.99.99.254': [ 25 ] });
+
+            v4rules[vm2.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.99.99.254', 25)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -179,10 +181,15 @@ exports['tag to IP'] = function (t) {
 
             var v4rules = helpers.defaultZoneRules([vm1.uuid, vm2.uuid]);
             var v6rules = helpers.defaultZoneRules([vm1.uuid, vm2.uuid]);
-            createSubObjects(v4rules, vm2.uuid, 'out', 'block', 'tcp',
-                { '10.99.99.254': [ 25, 250 ] });
-            createSubObjects(v4rules, vm1.uuid, 'out', 'block', 'tcp',
-                { '10.99.99.254': [ 250 ] });
+
+            v4rules[vm1.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.99.99.254', 250)
+            ];
+
+            v4rules[vm2.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.99.99.254', 25),
+                helpers.blockPortOutTCP('10.99.99.254', 250)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -242,8 +249,11 @@ exports['tag to IP'] = function (t) {
 
             var v4rules = helpers.defaultZoneRules([vm1.uuid, vm2.uuid]);
             var v6rules = helpers.defaultZoneRules([vm1.uuid, vm2.uuid]);
-            createSubObjects(v4rules, vm2.uuid, 'out', 'block', 'tcp',
-                { '10.99.99.254': [ 25, 250 ] });
+
+            v4rules[vm2.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.99.99.254', 25),
+                helpers.blockPortOutTCP('10.99.99.254', 250)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -280,8 +290,10 @@ exports['tag to IP'] = function (t) {
 
             var v4rules = helpers.defaultZoneRules([vm1.uuid, vm2.uuid]);
             var v6rules = helpers.defaultZoneRules([vm1.uuid, vm2.uuid]);
-            createSubObjects(v4rules, vm2.uuid, 'out', 'block', 'tcp',
-                { '10.99.99.254': [ 25 ] });
+
+            v4rules[vm2.uuid].out.tcp = [
+                helpers.blockPortOutTCP('10.99.99.254', 25)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -299,7 +311,7 @@ exports['tag to IP'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -382,20 +394,18 @@ exports['all vms (local and remote)'] = function (t) {
 
             [vm1, vm2].forEach(function (vm) {
                 vmsEnabled[vm.uuid] = true;
-                createSubObjects(v4rules, vm.uuid, 'out', 'block', 'tcp',
-                    {
-                        '10.1.1.1': [ 8082 ],
-                        '10.1.1.2': [ 8082 ],
-                        '10.1.1.3': [ 8082 ],
-                        '10.1.1.4': [ 8082 ]
-                    });
-                createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp',
-                    {
-                        '10.1.1.1': [ 8081 ],
-                        '10.1.1.2': [ 8081 ],
-                        '10.1.1.3': [ 8081 ],
-                        '10.1.1.4': [ 8081 ]
-                    });
+                v4rules[vm.uuid].out.tcp = [
+                    helpers.blockPortOutTCP('10.1.1.1', 8082),
+                    helpers.blockPortOutTCP('10.1.1.2', 8082),
+                    helpers.blockPortOutTCP('10.1.1.3', 8082),
+                    helpers.blockPortOutTCP('10.1.1.4', 8082)
+                ];
+                v4rules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('10.1.1.1', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.2', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.3', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.4', 8081, 'keep state')
+                ];
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -444,34 +454,36 @@ exports['all vms (local and remote)'] = function (t) {
             }, 'rules returned');
 
             [vm1, vm2].forEach(function (vm) {
-                v4rules[vm.uuid].in.pass.tcp = {
-                        '10.1.1.1': [ 8081, 8083 ],
-                        '10.1.1.2': [ 8081, 8083 ],
-                        '10.1.1.3': [ 8081, 8083 ],
-                        '10.1.1.4': [ 8081, 8083 ],
-                        '10.8.8.1': [ 8083 ],
-                        '10.8.8.2': [ 8083 ]
-                    };
+                v4rules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('10.1.1.1', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.2', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.3', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.4', 8081, 'keep state'),
+
+                    helpers.allowPortInTCP('10.1.1.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.2', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.3', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.4', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.8.8.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.8.8.2', 8083, 'keep state')
+                ];
             });
 
             v4rules[vm3.uuid] = helpers.defaultZoneRules();
             v6rules[vm3.uuid] = helpers.defaultZoneRules();
-            createSubObjects(v4rules, vm3.uuid, 'in', 'pass', 'tcp',
-                {
-                    '10.1.1.1': [ 8083 ],
-                    '10.1.1.2': [ 8083 ],
-                    '10.1.1.3': [ 8083 ],
-                    '10.1.1.4': [ 8083 ],
-                    '10.8.8.1': [ 8083 ],
-                    '10.8.8.2': [ 8083 ]
-                });
+            v4rules[vm3.uuid].in.tcp = [
+                helpers.allowPortInTCP('10.1.1.1', 8083),
+                helpers.allowPortInTCP('10.1.1.2', 8083),
+                helpers.allowPortInTCP('10.1.1.3', 8083),
+                helpers.allowPortInTCP('10.1.1.4', 8083),
+                helpers.allowPortInTCP('10.8.8.1', 8083),
+                helpers.allowPortInTCP('10.8.8.2', 8083)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
                 'IPv6 firewall rules correct');
-            t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
-                'IPv4 firewall rules correct');
 
             vmsEnabled[vm3.uuid] = true;
             t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
@@ -521,14 +533,15 @@ exports['all vms (local and remote)'] = function (t) {
 
 
             [vm1, vm2].forEach(function (vm) {
-                v4rules[vm.uuid].in.pass.tcp = {
-                        '10.1.1.1': [ 8083 ],
-                        '10.1.1.2': [ 8083 ],
-                        '10.1.1.3': [ 8083 ],
-                        '10.1.1.4': [ 8081, 8083 ],
-                        '10.8.8.1': [ 8083 ],
-                        '10.8.8.2': [ 8083 ]
-                    };
+                v4rules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('10.1.1.4', 8081, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.2', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.3', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.1.1.4', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.8.8.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('10.8.8.2', 8083, 'keep state')
+                ];
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -568,7 +581,16 @@ exports['all vms (local and remote)'] = function (t) {
             }, 'results returned');
 
             [vm1, vm2].forEach(function (vm) {
-                delete v4rules[vm.uuid].out.block;
+                v4rules[vm.uuid].out = {};
+                v4rules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('10.1.1.4', 8081),
+                    helpers.allowPortInTCP('10.1.1.1', 8083),
+                    helpers.allowPortInTCP('10.1.1.2', 8083),
+                    helpers.allowPortInTCP('10.1.1.3', 8083),
+                    helpers.allowPortInTCP('10.1.1.4', 8083),
+                    helpers.allowPortInTCP('10.8.8.1', 8083),
+                    helpers.allowPortInTCP('10.8.8.2', 8083)
+                ];
             });
 
             expRules = expRules.filter(function (r) {
@@ -596,7 +618,7 @@ exports['all vms (local and remote)'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -674,11 +696,10 @@ exports['remote vms: tags'] = function (t) {
             v6rules = helpers.defaultZoneRules(vm1.uuid);
 
             vmsEnabled[vm1.uuid] = true;
-            createSubObjects(v4rules, vm1.uuid, 'in', 'pass', 'tcp',
-                {
-                    '10.1.1.1': [ 8081 ],
-                    '10.1.1.4': [ 8081 ]
-                });
+            v4rules[vm1.uuid].in.tcp = [
+                helpers.allowPortInTCP('10.1.1.1', 8081),
+                helpers.allowPortInTCP('10.1.1.4', 8081)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -703,7 +724,7 @@ exports['remote vms: tags'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -770,10 +791,9 @@ exports['remote vms: vms'] = function (t) {
             v6rules = helpers.defaultZoneRules(vm1.uuid);
 
             vmsEnabled[vm1.uuid] = true;
-            createSubObjects(v4rules, vm1.uuid, 'in', 'pass', 'tcp',
-                {
-                    '10.1.1.4': [ 8081 ]
-                });
+            v4rules[vm1.uuid].in.tcp = [
+                helpers.allowPortInTCP('10.1.1.4', 8081)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -798,7 +818,7 @@ exports['remote vms: vms'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
diff --git a/deps/fw/test/unit/priority.test.js b/deps/fw/test/unit/priority.test.js
new file mode 100644
index 0000000..d31fc0a
--- /dev/null
+++ b/deps/fw/test/unit/priority.test.js
@@ -0,0 +1,415 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at http://smartos.org/CDDL
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file.
+ *
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ *
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
+ *
+ * fwadm tests: Sorting based on PRIORITY keyword
+ */
+
+var async = require('async');
+var clone = require('clone');
+var fw;
+var helpers = require('../lib/helpers');
+var mocks = require('../lib/mocks');
+var mod_obj = require('../../lib/util/obj');
+var mod_uuid = require('uuid');
+var util = require('util');
+var util_vm = require('../../lib/util/vm');
+
+
+// --- Globals
+
+
+
+// Set this to any of the exports in this file to only run that test,
+// plus setup and teardown
+var runOne;
+
+
+
+// --- Setup
+
+
+
+exports['setup'] = function (t) {
+    fw = mocks.setup();
+    t.ok(fw, 'fw loaded');
+    t.done();
+};
+
+
+// run before every test
+exports.setUp = function (cb) {
+    if (fw) {
+        mocks.reset();
+    }
+    cb();
+};
+
+
+
+// --- Tests
+
+
+exports['Overriding inbound rules'] = function (t) {
+    var vm = helpers.generateVM();
+    var payload = {
+        rules: [
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.254 TO vm %s BLOCK '
+                    + 'tcp PORT 22 PRIORITY 2', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM subnet 10.99.99.0/24 TO vm %s BLOCK '
+                    + 'tcp PORT all PRIORITY 1', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.254 TO vm %s ALLOW '
+                    + 'tcp PORTS 15 - 30 PRIORITY 1', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM any TO vm %s ALLOW tcp PORT all',
+                    vm.uuid),
+                enabled: true
+            }
+        ],
+        vms: [vm]
+    };
+
+    var expRules = clone(payload.rules);
+    var vmsEnabled = {};
+    var v4rules = helpers.defaultZoneRules(vm.uuid);
+    var v6rules = helpers.defaultZoneRules(vm.uuid);
+
+    async.series([
+    function (cb) {
+        fw.add(payload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb();
+                return;
+            }
+
+            helpers.fillInRuleBlanks(res.rules, expRules);
+
+            t.deepEqual(res, {
+                rules: expRules,
+                vms: [ vm.uuid ]
+            }, 'rules returned');
+
+            v4rules[vm.uuid].in.tcp = [
+                helpers.blockPortInTCP('10.99.99.254', 22),
+                helpers.allowRangeInTCP('10.99.99.254', 15, 30),
+                helpers.blockPortInTCP('10.99.99.0/24'),
+                helpers.allowPortInTCP('any')
+            ];
+
+            v6rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any')
+            ];
+
+            t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
+                'zone ipf.conf files correct');
+            t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
+                'zone ipf6.conf files correct');
+
+            vmsEnabled[vm.uuid] = true;
+            t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
+                'ipf enabled in VMs');
+
+            cb();
+        });
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[0], cb);
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[1], cb);
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[2], cb);
+
+    }, function (cb) {
+        helpers.fwListEquals(t, expRules, cb);
+
+    }
+
+    ], function () {
+        t.done();
+    });
+};
+
+exports['Overriding outbound rules'] = function (t) {
+    var vm = helpers.generateVM();
+    var payload = {
+        rules: [
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM vm %s TO ip 10.99.99.254 ALLOW '
+                    + 'udp PORT 22 PRIORITY 15', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM vm %s TO subnet 10.99.99.0/24 ALLOW '
+                    + 'udp PORT all PRIORITY 2', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM vm %s TO ip 10.99.99.254 BLOCK '
+                    + 'udp PORTS 15 - 30 PRIORITY 2', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM vm %s TO any BLOCK udp PORT all',
+                    vm.uuid),
+                enabled: true
+            }
+        ],
+        vms: [vm]
+    };
+
+    var expRules = clone(payload.rules);
+    var vmsEnabled = {};
+    var v4rules = helpers.defaultZoneRules(vm.uuid);
+    var v6rules = helpers.defaultZoneRules(vm.uuid);
+
+    async.series([
+    function (cb) {
+        fw.add(payload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb();
+                return;
+            }
+
+            helpers.fillInRuleBlanks(res.rules, expRules);
+
+            t.deepEqual(res, {
+                rules: expRules,
+                vms: [ vm.uuid ]
+            }, 'rules returned');
+
+            v4rules[vm.uuid].out.udp = [
+                helpers.allowPortOutUDP('10.99.99.254', 22),
+                helpers.blockRangeOutUDP('10.99.99.254', 15, 30),
+                helpers.allowPortOutUDP('10.99.99.0/24'),
+                helpers.blockPortOutUDP('any')
+            ];
+
+            v6rules[vm.uuid].out.udp = [
+                helpers.blockPortOutUDP('any')
+            ];
+
+            t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
+                'zone ipf.conf files correct');
+            t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
+                'zone ipf6.conf files correct');
+
+            vmsEnabled[vm.uuid] = true;
+            t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
+                'ipf enabled in VMs');
+
+            cb();
+        });
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[0], cb);
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[1], cb);
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[2], cb);
+
+    }, function (cb) {
+        helpers.fwListEquals(t, expRules, cb);
+
+    }
+
+    ], function () {
+        t.done();
+    });
+};
+
+exports['Priority levels sorted correctly'] = function (t) {
+    var vm = helpers.generateVM();
+    var payload = {
+        /*
+         * The goal here is to assert that we sort the priority levels
+         * correctly: higher priorities come earlier than lower priorities,
+         * and priority levels are sorted numerically and not lexicographically.
+         * That is, 100 > 23 > 2 > 1, and not 23 > 2 > 100 > 1.
+         */
+        rules: [
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.1 TO vm %s ALLOW '
+                    + 'tcp PORT all PRIORITY 1', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.2 TO vm %s ALLOW '
+                    + 'tcp PORT all PRIORITY 100', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.3 TO vm %s ALLOW '
+                    + 'tcp PORT all PRIORITY 10', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.4 TO vm %s ALLOW '
+                    + 'tcp PORT all PRIORITY 15', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.5 TO vm %s ALLOW '
+                    + 'tcp PORT all PRIORITY 2', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.6 TO vm %s ALLOW '
+                    + 'tcp PORT all PRIORITY 23', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.7 TO vm %s ALLOW '
+                    + 'tcp PORT all PRIORITY 25', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.8 TO vm %s ALLOW '
+                    + 'tcp PORT all PRIORITY 55', vm.uuid),
+                enabled: true
+            },
+            {
+                owner_uuid: vm.owner_uuid,
+                rule: util.format('FROM ip 10.99.99.9 TO vm %s ALLOW '
+                    + 'tcp PORT all PRIORITY 50', vm.uuid),
+                enabled: true
+            }
+        ],
+        vms: [vm]
+    };
+
+    var expRules = clone(payload.rules);
+    var vmsEnabled = {};
+    var v4rules = helpers.defaultZoneRules(vm.uuid);
+    var v6rules = helpers.defaultZoneRules(vm.uuid);
+
+    async.series([
+    function (cb) {
+        fw.add(payload, function (err, res) {
+            t.ifError(err);
+            if (err) {
+                cb();
+                return;
+            }
+
+            helpers.fillInRuleBlanks(res.rules, expRules);
+
+            t.deepEqual(res, {
+                rules: expRules,
+                vms: [ vm.uuid ]
+            }, 'rules returned');
+
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('10.99.99.2'),
+                helpers.allowPortInTCP('10.99.99.8'),
+                helpers.allowPortInTCP('10.99.99.9'),
+                helpers.allowPortInTCP('10.99.99.7'),
+                helpers.allowPortInTCP('10.99.99.6'),
+                helpers.allowPortInTCP('10.99.99.4'),
+                helpers.allowPortInTCP('10.99.99.3'),
+                helpers.allowPortInTCP('10.99.99.5'),
+                helpers.allowPortInTCP('10.99.99.1')
+            ];
+
+            t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
+                'zone ipf.conf files correct');
+            t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
+                'zone ipf6.conf files correct');
+
+            vmsEnabled[vm.uuid] = true;
+            t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
+                'ipf enabled in VMs');
+
+            cb();
+        });
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[0], cb);
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[1], cb);
+
+    }, function (cb) {
+        helpers.fwGetEquals(t, expRules[2], cb);
+
+    }, function (cb) {
+        helpers.fwListEquals(t, expRules, cb);
+
+    }
+
+    ], function () {
+        t.done();
+    });
+};
+
+
+
+// --- Teardown
+
+
+
+exports['teardown'] = function (t) {
+    mocks.teardown();
+    t.done();
+};
+
+
+// Use to run only one test in this file:
+if (runOne) {
+    module.exports = {
+        setup: exports.setup,
+        setUp: exports.setUp,
+        oneTest: runOne,
+        teardown: exports.teardown
+    };
+}
diff --git a/deps/fw/test/unit/remote-targets.test.js b/deps/fw/test/unit/remote-targets.test.js
index fd6d8d5..22579d8 100644
--- a/deps/fw/test/unit/remote-targets.test.js
+++ b/deps/fw/test/unit/remote-targets.test.js
@@ -10,7 +10,7 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 
 var createSubObjects = mod_obj.createSubObjects;
diff --git a/deps/fw/test/unit/remote-vms.test.js b/deps/fw/test/unit/remote-vms.test.js
index c6bb5fe..3e99b58 100644
--- a/deps/fw/test/unit/remote-vms.test.js
+++ b/deps/fw/test/unit/remote-vms.test.js
@@ -31,11 +31,10 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 
-var createSubObjects = mod_obj.createSubObjects;
 var ipKey = helpers.ipKey;
 
 
@@ -152,13 +151,15 @@ exports['local VM to remote VM'] = function (t) {
             }, 'rules returned');
 
             v4rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp');
-            v4rules[vm.uuid]['in'].pass.tcp[ipKey(rvmNICs[0].ips[0])] = [ 80 ];
-            v4rules[vm.uuid]['in'].pass.tcp[rvm.nics[1].ip] = [ 80 ];
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP(ipKey(rvmNICs[0].ips[0]), 80),
+                helpers.allowPortInTCP(rvm.nics[1].ip, 80)
+            ];
 
             v6rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v6rules, vm.uuid, 'in', 'pass', 'tcp');
-            v6rules[vm.uuid]['in'].pass.tcp[ipKey(rvmNICs[0].ips[1])] = [ 80 ];
+            v6rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP(ipKey(rvmNICs[0].ips[1]), 80)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
@@ -236,12 +237,13 @@ exports['local VM to remote VM'] = function (t) {
 
             helpers.fillInRuleBlanks(res.rules, rule3);
 
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'udp');
-            v4rules[vm.uuid]['in'].pass.udp[ipKey(rvmNICs[0].ips[0])] = [ 161 ];
-            v4rules[vm.uuid]['in'].pass.udp[rvm.nics[1].ip] = [ 161 ];
-
-            createSubObjects(v6rules, vm.uuid, 'in', 'pass', 'udp');
-            v6rules[vm.uuid]['in'].pass.udp[ipKey(rvmNICs[0].ips[1])] = [ 161 ];
+            v4rules[vm.uuid].in.udp = [
+                helpers.allowPortInUDP(ipKey(rvmNICs[0].ips[0]), 161),
+                helpers.allowPortInUDP(rvm.nics[1].ip, 161)
+            ];
+            v6rules[vm.uuid].in.udp = [
+                helpers.allowPortInUDP(ipKey(rvmNICs[0].ips[1]), 161)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
@@ -300,8 +302,8 @@ exports['local VM to remote VM'] = function (t) {
                 return cb(err);
             }
 
-            delete v4rules[vm.uuid]['in'].pass.udp;
-            delete v6rules[vm.uuid]['in'].pass.udp;
+            delete v4rules[vm.uuid].in.udp;
+            delete v6rules[vm.uuid].in.udp;
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -425,8 +427,9 @@ exports['local VM to remote VM'] = function (t) {
 
             helpers.fillInRuleBlanks(res.rules, rule4);
 
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp');
-            v4rules[vm.uuid]['in'].pass.tcp[rvm2.nics[0].ip] = [ 90 ];
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP(rvm2.nics[0].ip, 90)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
@@ -541,8 +544,9 @@ exports['local VM to remote tag'] = function (t) {
 
             v4rules = helpers.defaultZoneRules(vm.uuid);
             v6rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp');
-            v4rules[vm.uuid]['in'].pass.tcp[rvm.nics[0].ip] = [ 80 ];
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP(rvm.nics[0].ip, 80)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
@@ -605,8 +609,9 @@ exports['local VM to remote tag'] = function (t) {
 
             helpers.fillInRuleBlanks(res.rules, rule3);
 
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'udp');
-            v4rules[vm.uuid]['in'].pass.udp[rvm.nics[0].ip] = [ 161 ];
+            v4rules[vm.uuid].in.udp = [
+                helpers.allowPortInUDP(rvm.nics[0].ip, 161)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
@@ -657,7 +662,7 @@ exports['local VM to remote tag'] = function (t) {
                 return cb(err);
             }
 
-            delete v4rules[vm.uuid]['in'].pass.udp;
+            delete v4rules[vm.uuid].in.udp;
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -788,8 +793,9 @@ exports['local VM and remote VM to IP'] = function (t) {
 
             v4rules = helpers.defaultZoneRules(vm.uuid);
             v6rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp');
-            v4rules[vm.uuid]['in'].pass.tcp['10.0.0.1'] = [ 80 ];
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('10.0.0.1', 80)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
@@ -834,7 +840,7 @@ exports['local VM and remote VM to IP'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -886,9 +892,10 @@ exports['all vms to local VM'] = function (t) {
 
             v4rules = helpers.defaultZoneRules(vm.uuid);
             v6rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp');
-            v4rules[vm.uuid]['in'].pass.tcp[vm.nics[0].ip] = [ 44 ];
-            v4rules[vm.uuid]['in'].pass.tcp[rvm.nics[0].ip] = [ 44 ];
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP(vm.nics[0].ip, 44),
+                helpers.allowPortInTCP(rvm.nics[0].ip, 44)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
@@ -932,7 +939,8 @@ exports['all vms to local VM'] = function (t) {
 
             helpers.fillInRuleBlanks(res.rules, [rule2]);
 
-            v4rules[vm.uuid]['in'].pass.tcp['10.6.0.1'] = [ 45 ];
+            v4rules[vm.uuid].in.tcp.push(
+                helpers.allowPortInTCP('10.6.0.1', 45));
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
@@ -955,7 +963,7 @@ exports['all vms to local VM'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -1014,8 +1022,9 @@ exports['owner_uuid filtering'] = function (t) {
 
             v4rules = helpers.defaultZoneRules(vm.uuid);
             v6rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp');
-            v4rules[vm.uuid]['in'].pass.tcp[vm.nics[0].ip] = [ 25 ];
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP(vm.nics[0].ip, 25)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
@@ -1057,7 +1066,9 @@ exports['owner_uuid filtering'] = function (t) {
                 remoteVMs: [ rvm1.uuid ]
             }, 'rules returned');
 
-            v4rules[vm.uuid]['in'].pass.tcp[rvm1.nics[0].ip] = [ 25 ];
+            v4rules[vm.uuid].in.tcp.push(
+                helpers.allowPortInTCP(rvm1.nics[0].ip, 25));
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -1120,7 +1131,7 @@ exports['owner_uuid filtering'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -1129,7 +1140,7 @@ exports['delete: different VMs than RVMs in rule'] = function (t) {
     var vms = [ helpers.generateVM(), helpers.generateVM() ];
     var rvms = [ helpers.generateVM(), helpers.generateVM() ];
 
-    var v4rules = {}, v6rules;
+    var v4rules, v6rules;
     var expRulesOnDisk = {};
     var remoteVMsOnDisk = {};
     var vmsEnabled = {};
@@ -1188,13 +1199,17 @@ exports['delete: different VMs than RVMs in rule'] = function (t) {
                 remoteVMs: helpers.sortedUUIDs(rvms)
             }, 'rules returned');
 
-            helpers.addZoneRules(v4rules, [
-                [vms[0], 'in', 'pass', 'tcp', rvms[0].nics[0].ip, 80],
-                [vms[1], 'in', 'pass', 'tcp', '10.2.0.2', 81],
-                [vms[1], 'in', 'pass', 'tcp', rvms[1].nics[0].ip, 82]
-            ]);
+            v4rules = helpers.defaultZoneRules([vms[0].uuid, vms[1].uuid]);
             v6rules = helpers.defaultZoneRules([vms[0].uuid, vms[1].uuid]);
 
+            v4rules[vms[0].uuid].in.tcp = [
+                helpers.allowPortInTCP(rvms[0].nics[0].ip, 80)
+            ];
+            v4rules[vms[1].uuid].in.tcp = [
+                helpers.allowPortInTCP('10.2.0.2', 81),
+                helpers.allowPortInTCP(rvms[1].nics[0].ip, 82)
+            ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -1233,7 +1248,8 @@ exports['delete: different VMs than RVMs in rule'] = function (t) {
                 return cb(err);
             }
 
-            delete v4rules[vms[1].uuid]['in'].pass.tcp[rvms[1].nics[0].ip];
+            v4rules[vms[1].uuid].in.tcp.pop();
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -1266,8 +1282,8 @@ exports['delete: different VMs than RVMs in rule'] = function (t) {
                 return cb(err);
             }
 
-            delete v4rules[vms[0].uuid]['in'].pass;
-            delete v4rules[vms[1].uuid]['in'].pass;
+            delete v4rules[vms[0].uuid].in.tcp;
+            delete v4rules[vms[1].uuid].in.tcp;
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
diff --git a/deps/fw/test/unit/stats.test.js b/deps/fw/test/unit/stats.test.js
index 5cb045a..35f7dfb 100644
--- a/deps/fw/test/unit/stats.test.js
+++ b/deps/fw/test/unit/stats.test.js
@@ -7,7 +7,7 @@
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 
 
diff --git a/deps/fw/test/unit/tags.test.js b/deps/fw/test/unit/tags.test.js
index eb581af..27dbc24 100644
--- a/deps/fw/test/unit/tags.test.js
+++ b/deps/fw/test/unit/tags.test.js
@@ -30,13 +30,13 @@ var clone = require('clone');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
+var mod_addr = require('ip6addr');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var net = require('net');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 
-var createSubObjects = mod_obj.createSubObjects;
 var mergeObjects = mod_obj.mergeObjects;
 
 
@@ -71,6 +71,9 @@ function reset() {
     d = {};
 }
 
+function getUUID(vm) {
+    return vm.uuid;
+}
 
 
 // --- Tests
@@ -179,28 +182,24 @@ exports['add / update: tag to tag'] = function (t) {
             rule1.uuid = res.rules[0].uuid;
             rule1.version = res.rules[0].version;
             t.deepEqual(helpers.sortRes(res), {
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort(),
+                vms: tagOneVMs.map(getUUID).sort(),
                 rules: [ rule1 ]
             }, 'rules returned');
 
-            v4rules = helpers.defaultZoneRules(
-                tagOneVMs.map(function (vm) { return vm.uuid; }));
-            v6rules = helpers.defaultZoneRules(
-                tagOneVMs.map(function (vm) { return vm.uuid; }));
+            v4rules = helpers.defaultZoneRules(tagOneVMs.map(getUUID));
+            v6rules = helpers.defaultZoneRules(tagOneVMs.map(getUUID));
             vmsEnabled = {};
 
             tagOneVMs.forEach(function (vm) {
-                createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp',
-                    {
-                        '10.2.0.1': [ 80 ],
-                        '10.2.0.2': [ 80 ],
-                        '10.2.0.3': [ 80 ],
-                        '165.225.132.33': [ 80 ]
-                    });
-                createSubObjects(v6rules, vm.uuid, 'in', 'pass', 'tcp',
-                    {
-                        'fd22::45': [ 80 ]
-                    });
+                v4rules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('10.2.0.1', 80),
+                    helpers.allowPortInTCP('165.225.132.33', 80),
+                    helpers.allowPortInTCP('10.2.0.2', 80),
+                    helpers.allowPortInTCP('10.2.0.3', 80)
+                ];
+                v6rules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('fd22::45', 80)
+                ];
                 vmsEnabled[vm.uuid] = true;
             });
 
@@ -242,28 +241,24 @@ exports['add / update: tag to tag'] = function (t) {
 
             t.deepEqual(helpers.sortRes(res), {
                 rules: [],
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
-            v4rules = helpers.defaultZoneRules(
-                tagOneVMs.map(function (vm) { return vm.uuid; }));
-            v6rules = helpers.defaultZoneRules(
-                tagOneVMs.map(function (vm) { return vm.uuid; }));
+            v4rules = helpers.defaultZoneRules(tagOneVMs.map(getUUID));
+            v6rules = helpers.defaultZoneRules(tagOneVMs.map(getUUID));
             vmsEnabled = {};
 
             tagOneVMs.forEach(function (vm) {
-                createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp',
-                    {
-                        '10.2.0.1': [ 80 ],
-                        '10.2.0.2': [ 80 ],
-                        '10.2.0.3': [ 80 ],
-                        '10.2.0.5': [ 80 ],
-                        '165.225.132.33': [ 80 ]
-                    });
-                createSubObjects(v6rules, vm.uuid, 'in', 'pass', 'tcp',
-                    {
-                        'fd22::45': [ 80 ]
-                    });
+                v4rules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('10.2.0.1', 80),
+                    helpers.allowPortInTCP('165.225.132.33', 80),
+                    helpers.allowPortInTCP('10.2.0.2', 80),
+                    helpers.allowPortInTCP('10.2.0.3', 80),
+                    helpers.allowPortInTCP('10.2.0.5', 80)
+                ];
+                v6rules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('fd22::45', 80)
+                ];
                 vmsEnabled[vm.uuid] = true;
             });
 
@@ -364,11 +359,12 @@ exports['add / update: tag to tag'] = function (t) {
 
             t.deepEqual(helpers.sortRes(res), {
                 rules: [],
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
             tagOneVMs.forEach(function (vm) {
-                v4rules[vm.uuid]['in'].pass.tcp['10.2.0.8'] = [80];
+                v4rules[vm.uuid].in.tcp.push(
+                    helpers.allowPortInTCP('10.2.0.8', 80));
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -399,11 +395,12 @@ exports['add / update: tag to tag'] = function (t) {
             t.deepEqual(helpers.sortRes(res), {
                 remoteVMs: [vm9.uuid],
                 rules: [],
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
             tagOneVMs.forEach(function (vm) {
-                v4rules[vm.uuid]['in'].pass.tcp['10.2.0.9'] = [80];
+                v4rules[vm.uuid].in.tcp.push(
+                    helpers.allowPortInTCP('10.2.0.9', 80));
             });
 
             // XXX: compare VM files written to disk
@@ -442,7 +439,7 @@ exports['add / update: tag to tag'] = function (t) {
 
             t.deepEqual(helpers.sortRes(res), {
                 rules: [],
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
             v4rules[vm8.uuid] = clone(v4rules[vm1.uuid]);
@@ -513,11 +510,12 @@ exports['add / update: tag to tag'] = function (t) {
             t.deepEqual(helpers.sortRes(res), {
                 remoteVMs: [vm10.uuid],
                 rules: [],
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
             tagOneVMs.forEach(function (vm) {
-                v4rules[vm.uuid]['in'].pass.tcp['10.2.0.10'] = [80];
+                v4rules[vm.uuid].in.tcp.push(
+                    helpers.allowPortInTCP('10.2.0.10', 80));
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -601,14 +599,14 @@ exports['add / update: tag to tag'] = function (t) {
 
             t.deepEqual(helpers.sortRes(res), {
                 rules: [rule2, rule3].sort(helpers.uuidSort),
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
             tagOneVMs.forEach(function (vm) {
-                createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'udp',
-                    {
-                        '10.2.0.11': [ 1000, 1001 ]
-                    });
+                v4rules[vm.uuid].in.udp = [
+                    helpers.allowPortInUDP('10.2.0.11', 1000),
+                    helpers.allowPortInUDP('10.2.0.11', 1001)
+                ];
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -659,7 +657,7 @@ exports['add / update: tag to tag'] = function (t) {
                 vms: [],
                 // This will re-write the files for tag one VMs, but the
                 // file contents won't have actually changed
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -708,15 +706,17 @@ exports['add / update: tag to tag'] = function (t) {
 
             t.deepEqual(helpers.sortRes(res), {
                 rules: [rule2],
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
             tagOneVMs.forEach(function (vm) {
-                createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'udp',
-                    {
-                        '10.2.0.11': [ 1000, 1001, 1050 ],
-                        '10.2.0.12': [ 1000, 1050 ]
-                    });
+                v4rules[vm.uuid].in.udp = [
+                    helpers.allowPortInUDP('10.2.0.11', 1000),
+                    helpers.allowPortInUDP('10.2.0.11', 1050),
+                    helpers.allowPortInUDP('10.2.0.12', 1000),
+                    helpers.allowPortInUDP('10.2.0.12', 1050),
+                    helpers.allowPortInUDP('10.2.0.11', 1001)
+                ];
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -793,13 +793,14 @@ exports['add / update: tag to tag'] = function (t) {
 
             t.deepEqual(helpers.sortRes(res), {
                 rules: [],
-                vms: tagOneVMs.map(function (vm) { return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
             v4rules[vm13.uuid] = clone(v4rules[vm1.uuid]);
             v6rules[vm13.uuid] = clone(v6rules[vm1.uuid]);
             tagOneVMs.forEach(function (vm) {
-                v4rules[vm.uuid]['in'].pass.tcp['10.2.0.13'] = [ 80 ];
+                v4rules[vm.uuid].in.tcp.push(
+                    helpers.allowPortInTCP('10.2.0.13', 80));
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -851,34 +852,31 @@ exports['add / update: tag to tag'] = function (t) {
 
             t.deepEqual(helpers.sortRes(res), {
                 rules: [rule5, rule6].sort(helpers.uuidSort),
-                vms: tagOneVMs.map(function (vm) {
-                    return vm.uuid;
-                }).concat(vm4.uuid).sort()
+                vms: tagOneVMs.map(getUUID).concat(vm4.uuid).sort()
             }, 'result returned');
 
             v4rules[vm4.uuid] = helpers.defaultZoneRules();
             v6rules[vm4.uuid] = helpers.defaultZoneRules();
-            createSubObjects(v4rules, vm4.uuid, 'in', 'pass', 'tcp');
-            createSubObjects(v6rules, vm4.uuid, 'in', 'pass', 'tcp');
 
             tagOneVMs.forEach(function (vm) {
                 // Add vm4 to all of the tag one rules
-                v4rules[vm.uuid]['in'].pass.tcp['10.2.0.4'] = [ 8080 ];
-                v6rules[vm.uuid]['in'].pass.tcp['fd22::367'] = [ 8080 ];
-                // and add the tag one ips to vm4's rules
-                util_vm.ipsFromNICs(vm.nics).forEach(function (ip) {
-                    if (net.isIPv6(ip)) {
-                        v6rules[vm4.uuid]['in'].pass.tcp[ip] = [ 8080 ];
-                    } else {
-                        v4rules[vm4.uuid]['in'].pass.tcp[ip] = [ 8080 ];
-                    }
-                });
+                v4rules[vm.uuid].in.tcp.push(
+                    helpers.allowPortInTCP('10.2.0.4', 8080));
+                v6rules[vm.uuid].in.tcp.push(
+                    helpers.allowPortInTCP('fd22::367', 8080));
             });
 
-            // Add the 2 remote tag one VMs (vm9, vm10) to vm4's rules
-            v4rules[vm4.uuid]['in'].pass.tcp[vm9.nics[0].ip] = [ 8080 ];
-            v4rules[vm4.uuid]['in'].pass.tcp[vm10.nics[0].ip] = [ 8080 ];
+            // Collect ips for vm4's rules from local and remote tag one vms.
+            helpers.forEachVMsIPs(tagOneVMs.concat([vm9, vm10]), function (ip) {
+                var rules = net.isIPv6(ip)
+                    ? v6rules[vm4.uuid]
+                    : v4rules[vm4.uuid];
+                if (!rules.in.tcp) {
+                    rules.in.tcp = [];
+                }
 
+                rules.in.tcp.push(helpers.allowPortInTCP(ip, 8080));
+            });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules updated to include vm4');
@@ -923,23 +921,22 @@ exports['add / update: tag to tag'] = function (t) {
 
             t.deepEqual(helpers.sortRes(res), {
                 rules: [rule7],
-                vms: tagOneVMs.map(function (vm) {
-                    return vm.uuid; }).sort()
+                vms: tagOneVMs.map(getUUID).sort()
             }, 'result returned');
 
-            tagOneVMs.forEach(function (vm) {
-                util_vm.ipsFromNICs(vm.nics).forEach(function (ip) {
-                    if (net.isIPv6(ip)) {
-                        v6rules[vm2.uuid].in.pass.tcp[ip] = [ 80, 125 ];
-                    } else {
-                        v4rules[vm2.uuid].in.pass.tcp[ip] = [ 80, 125 ];
-                    }
-                });
-            });
+            function insertP125(ip) {
+                var rules = net.isIPv6(ip)
+                    ? v6rules[vm2.uuid]
+                    : v4rules[vm2.uuid];
+                if (!rules.in.tcp) {
+                    rules.in.tcp = [];
+                }
+
+                // Insert just before the last 8080 rule
+                rules.in.tcp.splice(-1, 0, helpers.allowPortInTCP(ip, 125));
+            }
 
-            // Add the 2 remote tag one VMs (vm9, vm10) to vm4's rules
-            v4rules[vm2.uuid]['in'].pass.tcp[vm9.nics[0].ip] = [ 80, 125 ];
-            v4rules[vm2.uuid]['in'].pass.tcp[vm10.nics[0].ip] = [ 80, 125 ];
+            helpers.forEachVMsIPs(tagOneVMs.concat([vm9, vm10]), insertP125);
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules updated to include vm4');
@@ -958,7 +955,7 @@ exports['add / update: tag to tag'] = function (t) {
         });
     }
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -1024,14 +1021,8 @@ exports['tags with values'] = function (t) {
             v4rules = helpers.defaultZoneRules([vm2.uuid, vm4.uuid]);
             v6rules = helpers.defaultZoneRules([vm2.uuid, vm4.uuid]);
             [vm2, vm4].forEach(function (vm) {
-                createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp',
-                    {
-                        any: [ 80 ]
-                    });
-                createSubObjects(v6rules, vm.uuid, 'in', 'pass', 'tcp',
-                    {
-                        any: [ 80 ]
-                    });
+                v4rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 80) ];
+                v6rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 80) ];
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -1093,13 +1084,13 @@ exports['tags with values'] = function (t) {
 
             v4rules[vm5.uuid] = helpers.defaultZoneRules();
             v6rules[vm5.uuid] = helpers.defaultZoneRules();
-            var udpPorts = {};
-            udpPorts[vm2.nics[0].ip] = [ 514 ];
-            udpPorts[vm4.nics[0].ip] = [ 514 ];
-            udpPorts[rvm2.nics[0].ip] = [ 514 ];
 
-            createSubObjects(v4rules, vm5.uuid, 'in', 'pass', 'udp',
-                udpPorts);
+            function allowP514(ip) {
+                return helpers.allowPortInUDP(ip, 514);
+            }
+
+            v4rules[vm5.uuid].in.udp =
+                helpers.getIPsFromVMs([ vm2, vm4, rvm2 ]).map(allowP514);
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -1174,14 +1165,9 @@ exports['tags with values'] = function (t) {
 
             v4rules[vm3.uuid] = helpers.defaultZoneRules();
             v6rules[vm3.uuid] = helpers.defaultZoneRules();
-            createSubObjects(v4rules, vm3.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 80 ]
-                });
-            createSubObjects(v6rules, vm3.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 80 ]
-                });
+
+            v4rules[vm3.uuid].in.tcp = [ helpers.allowPortInTCP('any', 80) ];
+            v6rules[vm3.uuid].in.tcp = [ helpers.allowPortInTCP('any', 80) ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -1239,7 +1225,9 @@ exports['tags with values'] = function (t) {
                 rules: [ ]
             }, 'rules returned');
 
-            v4rules[vm5.uuid].in.pass.udp[rvm4.nics[0].ip] = [ 514 ];
+            v4rules[vm5.uuid].in.udp.push(
+                helpers.allowPortInUDP(rvm4.nics[0].ip, 514));
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -1272,8 +1260,8 @@ exports['tags with values'] = function (t) {
             }, 'results returned');
 
             [vm2, vm3, vm4].forEach(function (vm) {
-                delete v4rules[vm.uuid].in.pass;
-                delete v6rules[vm.uuid].in.pass;
+                delete v4rules[vm.uuid].in.tcp;
+                delete v6rules[vm.uuid].in.tcp;
             });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
@@ -1344,8 +1332,6 @@ exports['add a local provisioning VM with a tag'] = {
                 return t.done();
             }
 
-            var ipfRules = {};
-
             t.deepEqual(helpers.getIPFenabled(), {},
                 'firewall not active for VM');
 
@@ -1353,10 +1339,11 @@ exports['add a local provisioning VM with a tag'] = {
             // because it's still provisioning, ipfilter will not be reloaded
             // for the zone. Rather, rules will get loaded by the brand
             // during zone boot
-            helpers.addZoneRules(ipfRules, [
-                [d.vm, 'default'],
-                [d.vm, 'out', 'block', 'tcp', 'any', 25]
-            ]);
+            var ipfRules = helpers.defaultZoneRules([ d.vm.uuid ]);
+            ipfRules[d.vm.uuid].out.tcp = [
+                helpers.blockPortOutTCP('any', 25)
+            ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), ipfRules,
                 'IPv4 zone ipf rules');
             t.deepEqual(helpers.zoneIPFconfigs(6), ipfRules,
@@ -1406,7 +1393,7 @@ exports['tags with escaped characters or odd names/values'] = function (t) {
         }
     ];
 
-    var expRules = {};
+    var expRules;
     var expRulesOnDisk = {};
     var remoteVMsOnDisk = {};
     var vmsEnabled = {};
@@ -1450,31 +1437,20 @@ exports['tags with escaped characters or odd names/values'] = function (t) {
                 rules: rules.slice().sort(helpers.uuidSort)
             }, 'rules returned');
 
-            helpers.addZoneRules(expRules, [
-                [vms[0], 'default'],
-                [vms[1], 'default'],
-                [vms[2], 'default'],
-                [vms[3], 'default'],
-                [vms[4], 'default'],
+            expRules = helpers.defaultZoneRules(vms.map(getUUID));
 
-                [vms[0], 'in', 'pass', 'tcp', 'any', 80],
-                [vms[1], 'in', 'pass', 'tcp', 'any', 81],
-                [vms[2], 'in', 'pass', 'tcp', 'any', 82],
-                [vms[3], 'in', 'pass', 'tcp', 'any', 83],
-                [vms[4], 'in', 'pass', 'tcp', 'any', 84]
-            ]);
+            vms.forEach(function (vm, i) {
+                expRules[vm.uuid].in.tcp = [
+                    helpers.allowPortInTCP('any', 80 + i)
+                ];
+
+                vmsEnabled[vm.uuid] = true;
+            });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), expRules,
                 'IPv4 firewall rules');
             t.deepEqual(helpers.zoneIPFconfigs(6), expRules,
                 'IPv6 firewall rules');
-
-            vmsEnabled[vms[0].uuid] = true;
-            vmsEnabled[vms[1].uuid] = true;
-            vmsEnabled[vms[2].uuid] = true;
-            vmsEnabled[vms[3].uuid] = true;
-            vmsEnabled[vms[4].uuid] = true;
-
             t.deepEqual(helpers.getIPFenabled(), vmsEnabled,
                 'firewalls enabled');
 
@@ -1583,10 +1559,7 @@ exports['tags that target no VMs'] = function (t) {
                 rules: [ rules[0], rules[1] ].sort(helpers.uuidSort)
             }, 'rules returned');
 
-            helpers.addZoneRules(expRules, [
-                [vms[0], 'default'],
-                [vms[1], 'default']
-            ]);
+            expRules = helpers.defaultZoneRules(vms.map(getUUID));
 
             t.deepEqual(helpers.zoneIPFconfigs(4), expRules,
                 'IPv4 firewall rules');
@@ -1635,9 +1608,11 @@ exports['tags that target no VMs'] = function (t) {
                 rules: []
             }, 'vms returned');
 
-            helpers.addZoneRules(expRules, [
-                [vms[2], 'in', 'pass', 'tcp', 'any', 80]
-            ]);
+            expRules[vms[2].uuid] = helpers.defaultZoneRules();
+            expRules[vms[2].uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 80)
+            ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), expRules,
                 'IPv4 firewall rules');
             t.deepEqual(helpers.zoneIPFconfigs(6), expRules,
@@ -1672,7 +1647,7 @@ exports['FWAPI-273: Tag without a value following one with'] = function (t) {
         enabled: true
     };
 
-    var expRules = {};
+    var expRules;
     var expRulesOnDisk = {};
     var vmsEnabled = {};
 
@@ -1689,10 +1664,10 @@ exports['FWAPI-273: Tag without a value following one with'] = function (t) {
             rules: [ rule ]
         }, 'result');
 
-        helpers.addZoneRules(expRules, [
-            [ vm, 'default' ],
-            [ vm, 'in', 'pass', 'tcp', 'any', 25 ]
-        ]);
+        expRules = helpers.defaultZoneRules([ vm.uuid ]);
+        expRules[vm.uuid].in.tcp = [
+            helpers.allowPortInTCP('any', 25)
+        ];
 
         t.deepEqual(helpers.zoneIPFconfigs(4), expRules,
             'IPv4 firewall rules');
diff --git a/deps/fw/test/unit/update.test.js b/deps/fw/test/unit/update.test.js
index 1e8a62d..7193120 100644
--- a/deps/fw/test/unit/update.test.js
+++ b/deps/fw/test/unit/update.test.js
@@ -31,11 +31,10 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 
-var createSubObjects = mod_obj.createSubObjects;
 var mergeObjects = mod_obj.mergeObjects;
 
 
@@ -123,10 +122,9 @@ exports['update non-existent rule'] = function (t) {
             }, 'rules returned');
 
             allRules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(allRules, vm.uuid, 'out', 'block', 'tcp',
-                {
-                    any: [ 8080 ]
-                });
+            allRules[vm.uuid].out.tcp = [
+                helpers.blockPortOutTCP('any', 8080)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), allRules,
                 'IPv4 firewall rules correct');
@@ -145,7 +143,7 @@ exports['update non-existent rule'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -237,7 +235,7 @@ exports['description and created_by'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
diff --git a/deps/fw/test/unit/validate.test.js b/deps/fw/test/unit/validate.test.js
index 5606b08..15d99cb 100644
--- a/deps/fw/test/unit/validate.test.js
+++ b/deps/fw/test/unit/validate.test.js
@@ -8,7 +8,7 @@ var async = require('async');
 var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 
 
diff --git a/deps/fw/test/unit/vms.test.js b/deps/fw/test/unit/vms.test.js
index 3872f94..2f80231 100644
--- a/deps/fw/test/unit/vms.test.js
+++ b/deps/fw/test/unit/vms.test.js
@@ -10,7 +10,7 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 
 var createSubObjects = mod_obj.createSubObjects;
diff --git a/deps/fw/test/unit/wildcards.test.js b/deps/fw/test/unit/wildcards.test.js
index cf38efc..af8d267 100644
--- a/deps/fw/test/unit/wildcards.test.js
+++ b/deps/fw/test/unit/wildcards.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  * fwadm tests: all and any targets
  */
@@ -31,7 +31,7 @@ var fw;
 var helpers = require('../lib/helpers');
 var mocks = require('../lib/mocks');
 var mod_obj = require('../../lib/util/obj');
-var mod_uuid = require('node-uuid');
+var mod_uuid = require('uuid');
 var util = require('util');
 var util_vm = require('../../lib/util/vm');
 
@@ -117,14 +117,13 @@ exports['any <-> vm: add / update'] = function (t) {
 
             v4rules = helpers.defaultZoneRules(vm.uuid);
             v6rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v4rules, vm.uuid, 'out', 'block', 'tcp',
-                {
-                    any: [ 8080 ]
-                });
-            createSubObjects(v6rules, vm.uuid, 'out', 'block', 'tcp',
-                {
-                    any: [ 8080 ]
-                });
+
+            v4rules[vm.uuid].out.tcp = [
+                helpers.blockPortOutTCP('any', 8080)
+            ];
+            v6rules[vm.uuid].out.tcp = [
+                helpers.blockPortOutTCP('any', 8080)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -176,14 +175,12 @@ exports['any <-> vm: add / update'] = function (t) {
                 rules: [ expRules[1] ]
             }, 'rules returned');
 
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ]
-                });
-            createSubObjects(v6rules, vm.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ]
-                });
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081, 'keep state')
+            ];
+            v6rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081, 'keep state')
+            ];
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -237,14 +234,12 @@ exports['any <-> vm: add / update'] = function (t) {
 
             v4rules[vm2.uuid] = helpers.defaultZoneRules();
             v6rules[vm2.uuid] = helpers.defaultZoneRules();
-            createSubObjects(v4rules, vm2.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ]
-                });
-            createSubObjects(v6rules, vm2.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ]
-                });
+            v4rules[vm2.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081)
+            ];
+            v6rules[vm2.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081)
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -308,8 +303,12 @@ exports['any <-> vm: add / update'] = function (t) {
                 rules: [ expRules[0] ]
             }, 'results returned');
 
-            delete v4rules[vm.uuid].out.block;
-            delete v6rules[vm.uuid].out.block;
+            delete v4rules[vm.uuid].out.tcp;
+            delete v6rules[vm.uuid].out.tcp;
+
+            v4rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
+            v6rules[vm.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -331,7 +330,7 @@ exports['any <-> vm: add / update'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -398,43 +397,27 @@ exports['any <-> all vms: add / update'] = function (t) {
 
             v4rules = helpers.defaultZoneRules([vm1.uuid, vm2.uuid]);
             v6rules = helpers.defaultZoneRules([vm1.uuid, vm2.uuid]);
-            createSubObjects(v4rules, vm1.uuid, 'out', 'block', 'tcp',
-                {
-                    '192.168.4.1': [ 8080, 8082 ],
-                    '192.168.4.2': [ 8082 ],
-                    '192.168.0.1': [ 8082 ]
-                });
-            createSubObjects(v4rules, vm2.uuid, 'out', 'block', 'tcp',
-                {
-                    '192.168.4.1': [ 8080, 8082 ],
-                    '192.168.4.2': [ 8082 ],
-                    '192.168.0.1': [ 8082 ]
-                });
-            createSubObjects(v4rules, vm1.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ],
-                    '192.168.0.1': [ 8083 ],
-                    '192.168.4.1': [ 8083 ],
-                    '192.168.4.2': [ 8083 ]
-                });
-            createSubObjects(v6rules, vm1.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ]
-                });
-            createSubObjects(v4rules, vm2.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ],
-                    '192.168.0.1': [ 8083 ],
-                    '192.168.4.1': [ 8083 ],
-                    '192.168.4.2': [ 8083 ]
-                });
-            createSubObjects(v6rules, vm2.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ]
-                });
+
+            [ vm1.uuid, vm2.uuid ].forEach(function (uuid) {
+                v4rules[uuid].out.tcp = [
+                    helpers.blockPortOutTCP('192.168.4.1', 8080),
+                    helpers.blockPortOutTCP('192.168.0.1', 8082),
+                    helpers.blockPortOutTCP('192.168.4.1', 8082),
+                    helpers.blockPortOutTCP('192.168.4.2', 8082)
+                ];
+                v4rules[uuid].in.tcp = [
+                    helpers.allowPortInTCP('any', 8081, 'keep state'),
+                    helpers.allowPortInTCP('192.168.0.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.4.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.4.2', 8083, 'keep state')
+                ];
+                v6rules[uuid].in.tcp = [
+                    helpers.allowPortInTCP('any', 8081, 'keep state')
+                ];
+            });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
-                'IPv4 firewall rules correct');
+                'IPv4 firewall rules correct (test)');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
                 'IPv6 firewall rules correct');
 
@@ -476,10 +459,22 @@ exports['any <-> all vms: add / update'] = function (t) {
                 rules: [ ]
             }, 'rules returned');
 
-            v4rules[vm1.uuid].out.block.tcp['192.168.0.2'] = [ 8082 ];
-            v4rules[vm2.uuid].out.block.tcp['192.168.0.2'] = [ 8082 ];
-            v4rules[vm1.uuid].in.pass.tcp['192.168.0.2'] = [ 8083 ];
-            v4rules[vm2.uuid].in.pass.tcp['192.168.0.2'] = [ 8083 ];
+            [ vm1.uuid, vm2.uuid ].forEach(function (uuid) {
+                v4rules[uuid].out.tcp = [
+                    helpers.blockPortOutTCP('192.168.4.1', 8080),
+                    helpers.blockPortOutTCP('192.168.0.1', 8082),
+                    helpers.blockPortOutTCP('192.168.0.2', 8082),
+                    helpers.blockPortOutTCP('192.168.4.1', 8082),
+                    helpers.blockPortOutTCP('192.168.4.2', 8082)
+                ];
+                v4rules[uuid].in.tcp = [
+                    helpers.allowPortInTCP('any', 8081, 'keep state'),
+                    helpers.allowPortInTCP('192.168.0.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.0.2', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.4.1', 8083, 'keep state'),
+                    helpers.allowPortInTCP('192.168.4.2', 8083, 'keep state')
+                ];
+            });
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -523,13 +518,13 @@ exports['any <-> all vms: add / update'] = function (t) {
                 rules: [ expRules[1] ]
             }, 'rules returned');
 
-            delete v4rules[vm1.uuid].in.pass.tcp.any;
-            delete v4rules[vm2.uuid].in.pass.tcp.any;
-            delete v6rules[vm1.uuid].in.pass;
-            delete v6rules[vm2.uuid].in.pass;
+            delete v6rules[vm1.uuid].in.tcp;
+            delete v6rules[vm2.uuid].in.tcp;
 
-            v4rules[vm1.uuid].in.pass.tcp['192.168.0.2'] = [ 8081, 8083 ];
-            v4rules[vm2.uuid].in.pass.tcp['192.168.0.2'] = [ 8081, 8083 ];
+            v4rules[vm1.uuid].in.tcp[0] =
+                helpers.allowPortInTCP('192.168.0.2', 8081, 'keep state');
+            v4rules[vm2.uuid].in.tcp[0] =
+                helpers.allowPortInTCP('192.168.0.2', 8081, 'keep state');
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -572,10 +567,9 @@ exports['any <-> all vms: add / update'] = function (t) {
             }, 'results returned');
 
             [vm1, vm2].forEach(function (vm) {
-                delete v4rules[vm.uuid].out.block.tcp['192.168.0.1'];
-                delete v4rules[vm.uuid].out.block.tcp['192.168.0.2'];
-                v4rules[vm.uuid].out.block.tcp['192.168.4.1'] = [ 8080 ];
-                delete v4rules[vm.uuid].out.block.tcp['192.168.4.2'];
+                v4rules[vm.uuid].out.tcp = [
+                    helpers.blockPortOutTCP('192.168.4.1', 8080)
+                ];
             });
 
             expRules = expRules.filter(function (r) {
@@ -603,7 +597,7 @@ exports['any <-> all vms: add / update'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
@@ -650,14 +644,8 @@ exports['add / update: all ports'] = function (t) {
 
             v4rules = helpers.defaultZoneRules(vm.uuid);
             v6rules = helpers.defaultZoneRules(vm.uuid);
-            createSubObjects(v4rules, vm.uuid, 'out', 'block', 'tcp',
-                {
-                    any: [ 'all' ]
-                });
-            createSubObjects(v6rules, vm.uuid, 'out', 'block', 'tcp',
-                {
-                    any: [ 'all' ]
-                });
+            v4rules[vm.uuid].out.tcp = [ helpers.blockPortOutTCP('any') ];
+            v6rules[vm.uuid].out.tcp = [ helpers.blockPortOutTCP('any') ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -709,14 +697,12 @@ exports['add / update: all ports'] = function (t) {
                 rules: [ expRules[1] ]
             }, 'rules returned');
 
-            createSubObjects(v4rules, vm.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 'all' ]
-                });
-            createSubObjects(v6rules, vm.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 'all' ]
-                });
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', null, 'keep state')
+            ];
+            v6rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', null, 'keep state')
+            ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -769,18 +755,17 @@ exports['add / update: all ports'] = function (t) {
                 rules: [ expRules[1] ]
             }, 'rules returned');
 
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081, 'keep state')
+            ];
+            v6rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081, 'keep state')
+            ];
+
             v4rules[vm2.uuid] = helpers.defaultZoneRules();
-            v4rules[vm.uuid].in.pass.tcp.any = [ 8081 ];
             v6rules[vm2.uuid] = helpers.defaultZoneRules();
-            v6rules[vm.uuid].in.pass.tcp.any = [ 8081 ];
-            createSubObjects(v4rules, vm2.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ]
-                });
-            createSubObjects(v6rules, vm2.uuid, 'in', 'pass', 'tcp',
-                {
-                    any: [ 8081 ]
-                });
+            v4rules[vm2.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
+            v6rules[vm2.uuid].in.tcp = [ helpers.allowPortInTCP('any', 8081) ];
 
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
@@ -844,8 +829,16 @@ exports['add / update: all ports'] = function (t) {
                 rules: [ expRules[0] ]
             }, 'results returned');
 
-            delete v4rules[vm.uuid].out.block;
-            delete v6rules[vm.uuid].out.block;
+            delete v4rules[vm.uuid].out.tcp;
+            delete v6rules[vm.uuid].out.tcp;
+
+            v4rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081)
+            ];
+            v6rules[vm.uuid].in.tcp = [
+                helpers.allowPortInTCP('any', 8081)
+            ];
+
             t.deepEqual(helpers.zoneIPFconfigs(4), v4rules,
                 'IPv4 firewall rules correct');
             t.deepEqual(helpers.zoneIPFconfigs(6), v6rules,
@@ -867,7 +860,7 @@ exports['add / update: all ports'] = function (t) {
     }
 
     ], function () {
-            t.done();
+        t.done();
     });
 };
 
diff --git a/deps/fw/tools/bin/rebuild-node-modules b/deps/fw/tools/bin/rebuild-node-modules
index c0b585a..2d0b281 100755
--- a/deps/fw/tools/bin/rebuild-node-modules
+++ b/deps/fw/tools/bin/rebuild-node-modules
@@ -1,6 +1,6 @@
 #!/bin/bash
 #
-# Copyright 2014, Joyent, Inc. All rights reserved.
+# Copyright (c) 2018, Joyent, Inc. All rights reserved.
 #
 # Creates a node modules suitable for checking in and installing in
 # the platform
@@ -25,6 +25,7 @@ mkdir ${NM}
 
 # The following are all Joyent-licensed
 cp ${NM_ORIG}/extsprintf/lib/extsprintf.js \
+    ${NM_ORIG}/ip6addr/ip6addr.js \
     ${NM_ORIG}/verror/lib/verror.js \
     ${NM_ORIG}/vasync/lib/vasync.js \
     ${NM_ORIG}/tab/lib/tab.js \
@@ -34,9 +35,10 @@ mkdir ${NM}/assert-plus
 cp ${NM_ORIG}/assert-plus/assert.js ${NM}/assert-plus/index.js
 cp ${NM_ORIG}/assert-plus/README.md ${NM}/assert-plus/README.md
 
-mkdir ${NM}/node-uuid
-cp ${NM_ORIG}/node-uuid/uuid.js ${NM}/node-uuid/index.js
-cp ${NM_ORIG}/node-uuid/LICENSE.md ${NM}/node-uuid/LICENSE.md
+mkdir -p ${NM}/uuid/lib
+cp ${NM_ORIG}/uuid/{index,v1,v4}.js ${NM}/uuid/
+cp ${NM_ORIG}/uuid/lib/{bytesToUuid,rng}.js ${NM}/uuid/lib
+cp ${NM_ORIG}/uuid/LICENSE.md ${NM}/uuid/LICENSE.md
 
 mkdir ${NM}/mkdirp
 cp ${NM_ORIG}/mkdirp/index.js ${NM}/mkdirp/index.js
@@ -47,7 +49,9 @@ cp ${NM_ORIG}/clone/clone.js ${NM}/clone/index.js
 cp ${NM_ORIG}/clone/{LICENSE,clonePrototype.js} ${NM}/clone/
 
 mkdir ${NM}/fwrule
-cp tools/fwrule/lib/* ${NM}/fwrule/
+cp ${NM_ORIG}/fwrule/lib/* ${NM}/fwrule/
+cp -r ${NM_ORIG}/fwrule/docs tools/fwrule/
+cp -r ${NM_ORIG}/fwrule/etc tools/fwrule/
 
 mkdir ${NM}/cmdln
 cp ${NM_ORIG}/cmdln/lib/cmdln.js ${NM}/cmdln/index.js
@@ -86,6 +90,8 @@ mkdir -p ${TEST_MODULES}/nodeunit/deps/ejs
 for F in ${NODEUNIT_FILES}; do
     cp -r ${NM_ORIG}/nodeunit/$F ${TEST_MODULES}/nodeunit/
 done
+patch -p3 < tools/nodeunit.patch
+
 cp ${NM_ORIG}/nodeunit/deps/*.js ${TEST_MODULES}/nodeunit/deps
 cp -r ${NM_ORIG}/nodeunit/deps/ejs/lib ${TEST_MODULES}/nodeunit/deps/ejs/lib
 cp ${NM_ORIG}/nodeunit/deps/ejs/package.json ${TEST_MODULES}/nodeunit/deps/ejs/package.json
diff --git a/deps/fw/tools/fwrule/Makefile b/deps/fw/tools/fwrule/Makefile
deleted file mode 100644
index d041e35..0000000
--- a/deps/fw/tools/fwrule/Makefile
+++ /dev/null
@@ -1,142 +0,0 @@
-#
-# CDDL HEADER START
-#
-# The contents of this file are subject to the terms of the
-# Common Development and Distribution License, Version 1.0 only
-# (the "License").  You may not use this file except in compliance
-# with the License.
-#
-# You can obtain a copy of the license at http://smartos.org/CDDL
-#
-# See the License for the specific language governing permissions
-# and limitations under the License.
-#
-# When distributing Covered Code, include this CDDL HEADER in each
-# file.
-#
-# If applicable, add the following below this CDDL HEADER, with the
-# fields enclosed by brackets "[]" replaced with your own identifying
-# information: Portions Copyright [yyyy] [name of copyright owner]
-#
-# CDDL HEADER END
-#
-# Copyright 2016, Joyent, Inc. All rights reserved.
-#
-#
-# fwrule Makefile
-#
-
-
-#
-# Tools
-#
-JISON	:= ./node_modules/jison/lib/cli.js
-ISTANBUL := node_modules/.bin/istanbul
-FAUCET := node_modules/.bin/faucet
-RAMSEY := node_modules/ramsey/bin/ramsey
-NPM := npm
-JS_FILES	:= $(shell find lib test -name '*.js' | grep -v parser.js)
-JSL_CONF_NODE	 = tools/jsl.node.conf
-JSL_FILES_NODE   = $(JS_FILES)
-JSL_FLAGS  	?= --nologo --nosummary
-JSL_FLAGS_NODE 	 = --conf=$(JSL_CONF_NODE)
-JSSTYLE_FILES	 = $(JS_FILES)
-JSSTYLE_FLAGS    = -o indent=4,strict-indent=1,doxygen,unparenthesized-return=0,continuation-at-front=1,leading-right-paren-ok=1
-ESLINT		= ./node_modules/.bin/eslint
-ESLINT_CONF	= tools/eslint.node.conf
-ESLINT_FILES	= $(JS_FILES)
-
-
-#
-# Repo-specific targets
-#
-
-.PHONY: parser
-parser: $(JISON)
-	@cp ./src/header.js ./lib/parser.js
-	@cat ./src/fwrule.jison | $(JISON)  >> ./lib/parser.js
-
-$(ESLINT):
-	$(NPM) install
-
-$(ISTANBUL):
-	$(NPM) install
-
-$(FAUCET):
-	$(NPM) install
-
-$(JISON):
-	$(NPM) install
-
-$(RAMSEY):
-	$(NPM) install
-
-
-#
-# test / check targets
-#
-
-.PHONY: test
-test: $(ISTANBUL) $(FAUCET)
-	$(ISTANBUL) cover --print none test/run.js | $(FAUCET)
-
-.PHONY: check
-check: check-jsl check-jsstyle check-eslint
-	@echo check ok
-
-.PHONY: prepush
-prepush: check test
-
-.PHONY: docs
-docs: $(RAMSEY) docs/examples.md docs/rules.md
-
-docs/examples.md: docs/examples.md.in
-	$(RAMSEY) -d etc/examples -f etc/examples.json docs/examples.md.in $@
-
-docs/rules.md: docs/rules.md.in
-	$(RAMSEY) -p wrap=0 docs/rules.md.in $@
-
-#
-# This rule enables other rules that use files from a git submodule to have
-# those files depend on deps/module/.git and have "make" automatically check
-# out the submodule as needed.
-#
-deps/%/.git:
-	git submodule update --init deps/$*
-
-#
-# javascriptlint
-#
-
-JSL_EXEC	?= deps/javascriptlint/build/install/jsl
-JSL		?= $(JSL_EXEC)
-
-$(JSL_EXEC): | deps/javascriptlint/.git
-	cd deps/javascriptlint && make install
-
-distclean::
-	if [[ -f deps/javascriptlint/Makefile ]]; then \
-		cd deps/javascriptlint && make clean; \
-	fi
-
-
-#
-# jsstyle
-#
-
-JSSTYLE_EXEC	?= deps/jsstyle/jsstyle
-JSSTYLE		?= $(JSSTYLE_EXEC)
-
-$(JSSTYLE_EXEC): | deps/jsstyle/.git
-
-.PHONY: check-jsl
-check-jsl: $(JSL_EXEC)
-	@$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $(JSL_FILES_NODE)
-
-.PHONY: check-jsstyle
-check-jsstyle:  $(JSSTYLE_EXEC)
-	@$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)
-
-.PHONY: check-eslint
-check-eslint: $(ESLINT)
-	@$(ESLINT) -c $(ESLINT_CONF) $(ESLINT_FILES)
diff --git a/deps/fw/tools/fwrule/README.md b/deps/fw/tools/fwrule/README.md
deleted file mode 100644
index b735d06..0000000
--- a/deps/fw/tools/fwrule/README.md
+++ /dev/null
@@ -1,56 +0,0 @@
-# sdc-fwrule
-
-Joyent firewall rule object wrapper. This is a copy of the sdc-fwrule repo. For
-contribution guidelines, issues, and general documentation, visit the main
-[sdc-fwrule](http://github.com/joyent/sdc-fwrule) project page.
-
-This contains shared code for manipulating Triton firewall rules.
-There are two parts to this package:
-
-* A Jison grammar (src/fwrule.jison) that specifies a DSL for writing
-  firewall rules. This is used to generate the parser (lib/parser.js)
-* A rule object that wraps the parser and provides various convenience
-  and serialization methods.
-
-The parser is currently checked in to avoid requiring jison to be installed
-in order to use this package.
-
-
-# Repository
-
-    docs/           Documentation (restdown format)
-    lib/            Source files
-    node_modules/   node.js dependencies (populate by running "npm install")
-    src/            Contains the jison grammar for creating the firewall rule
-                    parser
-    tools/          Tools and configuration files
-    test/           Test suite (using nodeunit)
-
-
-# Development
-
-If you update the jison grammar, run the following to regenerate the parser:
-
-    make parser
-
-Before checking in, please run:
-
-    make check
-
-and fix any warnings. Note that jsstyle will stop after the first file with an
-error, so you may need to run this multiple times while fixing.
-
-For non-trivial changes, please add a unit test that covers the functionality
-of the change. If this is a syntax change, update docs/rules.md.in and
-docs/examples.md.in accordingly.
-
-
-# Testing
-
-To run all tests:
-
-    make test
-
-To run an individual test:
-
-    ./node_modules/.bin/nodeunit <path to test file>
diff --git a/deps/fw/tools/fwrule/docs/fwrules.ebnf b/deps/fw/tools/fwrule/docs/fwrules.ebnf
index 77360ad..284625b 100644
--- a/deps/fw/tools/fwrule/docs/fwrules.ebnf
+++ b/deps/fw/tools/fwrule/docs/fwrules.ebnf
@@ -1,37 +1,28 @@
-
-/* 
-    Converted from https://mo.joyent.com/fwrule/raw/master/src/fwrule.jison
-    with http://bottlecaps.de/convert/ 
-    then elided for simplicity
-    then generated with http://bottlecaps.de/rr/ui
- */ 
-
-/* converted on Mon Dec 16, 2013, 20:22 (UTC-05) by jison-to-w3c v0.33.722 which is Copyright (c) 2011-2013 by Gunther Rademacher <grd@gmx.net> */
-
-rule     ::= 'FROM' target_list 'TO' target_list action protocol 
-target_list
-         ::= 'ANY'
-           | 'ALL VMS'
-           | '(' target ( 'OR' target )* ')'
-           | target
-target   ::= 'IP ADDRESS'
-           | 'SUBNET'
-           | 'TAG' tag_string
-           | 'TAG' tag_string '=' tag_value
-           | 'VM' uuid
-action   ::= 'BLOCK'
-           | 'ALLOW'
-protocol ::= 'TCP' port_list
-           | 'UDP' port_list
-           | 'ICMP' type_list
-port_list
-         ::= '(' port ( 'AND' port )* ')'
-           | port
-           | '(' 'PORT ALL' ')'
-           | 'PORT ALL'
-port     ::= 'PORT' '1 - 65535'
-type_list
-         ::= '(' type ( 'AND' type )* ')'
-           | type
-type     ::= 'TYPE' '0 - 255' 'CODE' '0 - 255'
-           | 'TYPE' '0 - 255'
+rule        ::= 'FROM' target_list 'TO' target_list action protocol
+target_list ::= 'ANY'
+              | 'ALL VMS'
+              | '(' target ( 'OR' target )* ')'
+              | target
+target      ::= 'IP' address
+              | 'SUBNET' cidr
+              | 'TAG' tag_string
+              | 'TAG' tag_string '=' tag_value
+              | 'VM' uuid
+action      ::= 'BLOCK'
+              | 'ALLOW'
+protocol    ::= 'TCP' port_list
+              | 'UDP' port_list
+              | 'ICMP' type_list
+              | 'ICMP6' type_list
+port_list   ::= '(' port ( 'AND' port )* ')'
+              | port
+              | 'PORTS' portrange ( ',' portrange )*
+              | 'PORT ALL'
+portnumber  ::= '1 - 65535'
+port        ::= 'PORT' portnumber
+portrange   ::= portnumber
+              | portnumber '-' portnumber
+type_list   ::= '(' type ( 'AND' type )* ')'
+              | type
+type        ::= 'TYPE' '0 - 255' ( 'CODE' '0 - 255' )?
+              | 'TYPE ALL'
diff --git a/deps/fw/tools/fwrule/docs/media/img/port-list.svg b/deps/fw/tools/fwrule/docs/media/img/port-list.svg
new file mode 100644
index 0000000..695f31a
--- /dev/null
+++ b/deps/fw/tools/fwrule/docs/media/img/port-list.svg
@@ -0,0 +1,136 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="railroad-diagram" width="401" height="182" viewBox="0 0 401 182">
+<defs><style type="text/css"><![CDATA[
+svg.railroad-diagram path {
+  stroke-width: 3;
+  stroke: black;
+  fill: none;
+}
+svg.railroad-diagram text {
+  font: bold 14px monospace;
+  text-anchor: middle;
+}
+svg.railroad-diagram text.label {
+  text-anchor: start;
+}
+svg.railroad-diagram text.comment {
+  font: italic 12px monospace;
+}
+svg.railroad-diagram rect {
+  stroke-width: 3;
+  stroke: black;
+  fill: hsl(120,100%,90%);
+}
+ ]]></style></defs>
+<g transform="translate(.5 .5)">
+<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
+<g>
+<path d="M40 31h0"></path>
+<path d="M360 31h0"></path>
+<path d="M40 31h20"></path>
+<g>
+<path d="M60 31h0"></path>
+<path d="M340 31h0"></path>
+<path d="M60 31h10"></path>
+<g>
+<path d="M70 31h0"></path>
+<path d="M98 31h0"></path>
+<rect x="70" y="20" width="28" height="22" rx="10" ry="10"></rect>
+<text x="84" y="35">(</text>
+</g>
+<path d="M98 31h10"></path>
+<path d="M108 31h10"></path>
+<g>
+<path d="M118 31h0"></path>
+<path d="M282 31h0"></path>
+<path d="M118 31h10"></path>
+<g>
+<path d="M128 31h0"></path>
+<path d="M272 31h0"></path>
+<path d="M128 31h10"></path>
+<g>
+<path d="M138 31h0"></path>
+<path d="M190 31h0"></path>
+<rect x="138" y="20" width="52" height="22" rx="10" ry="10"></rect>
+<text x="164" y="35">PORT</text>
+</g>
+<path d="M190 31h10"></path>
+<path d="M200 31h10"></path>
+<g>
+<path d="M210 31h0"></path>
+<path d="M262 31h0"></path>
+<rect x="210" y="20" width="52" height="22"></rect>
+<text x="236" y="35">port</text>
+</g>
+<path d="M262 31h10"></path>
+</g>
+<path d="M272 31h10"></path>
+<path d="M128 31a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M128 61h50"></path>
+<path d="M222 61h50"></path>
+<rect x="178" y="50" width="44" height="22" rx="10" ry="10"></rect>
+<text x="200" y="65">AND</text>
+</g>
+<path d="M272 61a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path>
+</g>
+<path d="M282 31h10"></path>
+<path d="M292 31h10"></path>
+<g>
+<path d="M302 31h0"></path>
+<path d="M330 31h0"></path>
+<rect x="302" y="20" width="28" height="22" rx="10" ry="10"></rect>
+<text x="316" y="35">)</text>
+</g>
+<path d="M330 31h10"></path>
+</g>
+<path d="M340 31h20"></path>
+<path d="M40 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 91h34"></path>
+<path d="M306 91h34"></path>
+<path d="M94 91h10"></path>
+<g>
+<path d="M104 91h0"></path>
+<path d="M164 91h0"></path>
+<rect x="104" y="80" width="60" height="22" rx="10" ry="10"></rect>
+<text x="134" y="95">PORTS</text>
+</g>
+<path d="M164 91h10"></path>
+<path d="M174 91h10"></path>
+<g>
+<path d="M184 91h0"></path>
+<path d="M296 91h0"></path>
+<path d="M184 91h10"></path>
+<g>
+<path d="M194 91h0"></path>
+<path d="M286 91h0"></path>
+<rect x="194" y="80" width="92" height="22"></rect>
+<text x="240" y="95">portrange</text>
+</g>
+<path d="M286 91h10"></path>
+<path d="M194 91a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M194 121h32"></path>
+<path d="M254 121h32"></path>
+<rect x="226" y="110" width="28" height="22" rx="10" ry="10"></rect>
+<text x="240" y="125">,</text>
+</g>
+<path d="M286 121a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path>
+</g>
+<path d="M296 91h10"></path>
+</g>
+<path d="M340 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v100a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 151h98"></path>
+<path d="M242 151h98"></path>
+<rect x="158" y="140" width="84" height="22" rx="10" ry="10"></rect>
+<text x="200" y="155">PORT ALL</text>
+</g>
+<path d="M340 151a10 10 0 0 0 10 -10v-100a10 10 0 0 1 10 -10"></path>
+</g>
+<path d="M 360 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
+</g>
+</svg>
diff --git a/deps/fw/tools/fwrule/docs/media/img/protocol.svg b/deps/fw/tools/fwrule/docs/media/img/protocol.svg
new file mode 100644
index 0000000..fdc74a2
--- /dev/null
+++ b/deps/fw/tools/fwrule/docs/media/img/protocol.svg
@@ -0,0 +1,138 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="railroad-diagram" width="313" height="212" viewBox="0 0 313 212">
+<defs><style type="text/css"><![CDATA[
+svg.railroad-diagram path {
+  stroke-width: 3;
+  stroke: black;
+  fill: none;
+}
+svg.railroad-diagram text {
+  font: bold 14px monospace;
+  text-anchor: middle;
+}
+svg.railroad-diagram text.label {
+  text-anchor: start;
+}
+svg.railroad-diagram text.comment {
+  font: italic 12px monospace;
+}
+svg.railroad-diagram rect {
+  stroke-width: 3;
+  stroke: black;
+  fill: hsl(120,100%,90%);
+}
+ ]]></style></defs>
+<g transform="translate(.5 .5)">
+<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
+<g>
+<path d="M40 31h0"></path>
+<path d="M272 31h0"></path>
+<path d="M40 31h20"></path>
+<g>
+<path d="M60 31h8"></path>
+<path d="M244 31h8"></path>
+<path d="M68 31h10"></path>
+<g>
+<path d="M78 31h0"></path>
+<path d="M122 31h0"></path>
+<rect x="78" y="20" width="44" height="22" rx="10" ry="10"></rect>
+<text x="100" y="35">TCP</text>
+</g>
+<path d="M122 31h10"></path>
+<path d="M132 31h10"></path>
+<g>
+<path d="M142 31h0"></path>
+<path d="M234 31h0"></path>
+<rect x="142" y="20" width="92" height="22"></rect>
+<text x="188" y="35">port&#95;list</text>
+</g>
+<path d="M234 31h10"></path>
+</g>
+<path d="M252 31h20"></path>
+<path d="M40 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 61h8"></path>
+<path d="M244 61h8"></path>
+<path d="M68 61h10"></path>
+<g>
+<path d="M78 61h0"></path>
+<path d="M122 61h0"></path>
+<rect x="78" y="50" width="44" height="22" rx="10" ry="10"></rect>
+<text x="100" y="65">UDP</text>
+</g>
+<path d="M122 61h10"></path>
+<path d="M132 61h10"></path>
+<g>
+<path d="M142 61h0"></path>
+<path d="M234 61h0"></path>
+<rect x="142" y="50" width="92" height="22"></rect>
+<text x="188" y="65">port&#95;list</text>
+</g>
+<path d="M234 61h10"></path>
+</g>
+<path d="M252 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 91h4"></path>
+<path d="M248 91h4"></path>
+<path d="M64 91h10"></path>
+<g>
+<path d="M74 91h0"></path>
+<path d="M126 91h0"></path>
+<rect x="74" y="80" width="52" height="22" rx="10" ry="10"></rect>
+<text x="100" y="95">ICMP</text>
+</g>
+<path d="M126 91h10"></path>
+<path d="M136 91h10"></path>
+<g>
+<path d="M146 91h0"></path>
+<path d="M238 91h0"></path>
+<rect x="146" y="80" width="92" height="22"></rect>
+<text x="192" y="95">type&#95;list</text>
+</g>
+<path d="M238 91h10"></path>
+</g>
+<path d="M252 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 121h0"></path>
+<path d="M252 121h0"></path>
+<path d="M60 121h10"></path>
+<g>
+<path d="M70 121h0"></path>
+<path d="M130 121h0"></path>
+<rect x="70" y="110" width="60" height="22" rx="10" ry="10"></rect>
+<text x="100" y="125">ICMP6</text>
+</g>
+<path d="M130 121h10"></path>
+<path d="M140 121h10"></path>
+<g>
+<path d="M150 121h0"></path>
+<path d="M242 121h0"></path>
+<rect x="150" y="110" width="92" height="22"></rect>
+<text x="196" y="125">type&#95;list</text>
+</g>
+<path d="M242 121h10"></path>
+</g>
+<path d="M252 121a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v100a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 151h78"></path>
+<path d="M174 151h78"></path>
+<rect x="138" y="140" width="36" height="22" rx="10" ry="10"></rect>
+<text x="156" y="155">AH</text>
+</g>
+<path d="M252 151a10 10 0 0 0 10 -10v-100a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v130a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 181h74"></path>
+<path d="M178 181h74"></path>
+<rect x="134" y="170" width="44" height="22" rx="10" ry="10"></rect>
+<text x="156" y="185">ESP</text>
+</g>
+<path d="M252 181a10 10 0 0 0 10 -10v-130a10 10 0 0 1 10 -10"></path>
+</g>
+<path d="M 272 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
+</g>
+</svg>
diff --git a/deps/fw/tools/fwrule/docs/media/img/rule.svg b/deps/fw/tools/fwrule/docs/media/img/rule.svg
new file mode 100644
index 0000000..d07f515
--- /dev/null
+++ b/deps/fw/tools/fwrule/docs/media/img/rule.svg
@@ -0,0 +1,121 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="railroad-diagram" width="925" height="92" viewBox="0 0 925 92">
+<defs><style type="text/css"><![CDATA[
+svg.railroad-diagram path {
+  stroke-width: 3;
+  stroke: black;
+  fill: none;
+}
+svg.railroad-diagram text {
+  font: bold 14px monospace;
+  text-anchor: middle;
+}
+svg.railroad-diagram text.label {
+  text-anchor: start;
+}
+svg.railroad-diagram text.comment {
+  font: italic 12px monospace;
+}
+svg.railroad-diagram rect {
+  stroke-width: 3;
+  stroke: black;
+  fill: hsl(120,100%,90%);
+}
+ ]]></style></defs>
+<g transform="translate(.5 .5)">
+<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
+<path d="M40 31h10"></path>
+<g>
+<path d="M50 31h0"></path>
+<path d="M102 31h0"></path>
+<rect x="50" y="20" width="52" height="22" rx="10" ry="10"></rect>
+<text x="76" y="35">FROM</text>
+</g>
+<path d="M102 31h10"></path>
+<path d="M112 31h10"></path>
+<g>
+<path d="M122 31h0"></path>
+<path d="M230 31h0"></path>
+<rect x="122" y="20" width="108" height="22"></rect>
+<text x="176" y="35">target&#95;list</text>
+</g>
+<path d="M230 31h10"></path>
+<path d="M240 31h10"></path>
+<g>
+<path d="M250 31h0"></path>
+<path d="M286 31h0"></path>
+<rect x="250" y="20" width="36" height="22" rx="10" ry="10"></rect>
+<text x="268" y="35">TO</text>
+</g>
+<path d="M286 31h10"></path>
+<path d="M296 31h10"></path>
+<g>
+<path d="M306 31h0"></path>
+<path d="M414 31h0"></path>
+<rect x="306" y="20" width="108" height="22"></rect>
+<text x="360" y="35">target&#95;list</text>
+</g>
+<path d="M414 31h10"></path>
+<g>
+<path d="M424 31h0"></path>
+<path d="M524 31h0"></path>
+<path d="M424 31h20"></path>
+<g>
+<path d="M444 31h0"></path>
+<path d="M504 31h0"></path>
+<rect x="444" y="20" width="60" height="22" rx="10" ry="10"></rect>
+<text x="474" y="35">ALLOW</text>
+</g>
+<path d="M504 31h20"></path>
+<path d="M424 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M444 61h0"></path>
+<path d="M504 61h0"></path>
+<rect x="444" y="50" width="60" height="22" rx="10" ry="10"></rect>
+<text x="474" y="65">BLOCK</text>
+</g>
+<path d="M504 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
+</g>
+<path d="M524 31h10"></path>
+<g>
+<path d="M534 31h0"></path>
+<path d="M618 31h0"></path>
+<rect x="534" y="20" width="84" height="22"></rect>
+<text x="576" y="35">protocol</text>
+</g>
+<path d="M618 31h10"></path>
+<g>
+<path d="M628 31h0"></path>
+<path d="M884 31h0"></path>
+<path d="M628 31h20"></path>
+<g>
+<path d="M648 31h216"></path>
+</g>
+<path d="M864 31h20"></path>
+<path d="M628 31a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M648 51h0"></path>
+<path d="M864 51h0"></path>
+<path d="M648 51h10"></path>
+<g>
+<path d="M658 51h0"></path>
+<path d="M742 51h0"></path>
+<rect x="658" y="40" width="84" height="22" rx="10" ry="10"></rect>
+<text x="700" y="55">PRIORITY</text>
+</g>
+<path d="M742 51h10"></path>
+<path d="M752 51h10"></path>
+<g>
+<path d="M762 51h0"></path>
+<path d="M854 51h0"></path>
+<rect x="762" y="40" width="92" height="22"></rect>
+<text x="808" y="55">priolevel</text>
+</g>
+<path d="M854 51h10"></path>
+</g>
+<path d="M864 51a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
+</g>
+<path d="M 884 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
+</g>
+</svg>
diff --git a/deps/fw/tools/fwrule/docs/media/img/target-list.svg b/deps/fw/tools/fwrule/docs/media/img/target-list.svg
new file mode 100644
index 0000000..017e127
--- /dev/null
+++ b/deps/fw/tools/fwrule/docs/media/img/target-list.svg
@@ -0,0 +1,102 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="railroad-diagram" width="325" height="182" viewBox="0 0 325 182">
+<defs><style type="text/css"><![CDATA[
+svg.railroad-diagram path {
+  stroke-width: 3;
+  stroke: black;
+  fill: none;
+}
+svg.railroad-diagram text {
+  font: bold 14px monospace;
+  text-anchor: middle;
+}
+svg.railroad-diagram text.label {
+  text-anchor: start;
+}
+svg.railroad-diagram text.comment {
+  font: italic 12px monospace;
+}
+svg.railroad-diagram rect {
+  stroke-width: 3;
+  stroke: black;
+  fill: hsl(120,100%,90%);
+}
+ ]]></style></defs>
+<g transform="translate(.5 .5)">
+<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
+<g>
+<path d="M40 31h0"></path>
+<path d="M284 31h0"></path>
+<path d="M40 31h20"></path>
+<g>
+<path d="M60 31h80"></path>
+<path d="M184 31h80"></path>
+<rect x="140" y="20" width="44" height="22" rx="10" ry="10"></rect>
+<text x="162" y="35">ANY</text>
+</g>
+<path d="M264 31h20"></path>
+<path d="M40 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 61h64"></path>
+<path d="M200 61h64"></path>
+<rect x="124" y="50" width="76" height="22" rx="10" ry="10"></rect>
+<text x="162" y="65">ALL VMS</text>
+</g>
+<path d="M264 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 91h0"></path>
+<path d="M264 91h0"></path>
+<path d="M60 91h10"></path>
+<g>
+<path d="M70 91h0"></path>
+<path d="M98 91h0"></path>
+<rect x="70" y="80" width="28" height="22" rx="10" ry="10"></rect>
+<text x="84" y="95">(</text>
+</g>
+<path d="M98 91h10"></path>
+<path d="M108 91h10"></path>
+<g>
+<path d="M118 91h0"></path>
+<path d="M206 91h0"></path>
+<path d="M118 91h10"></path>
+<g>
+<path d="M128 91h0"></path>
+<path d="M196 91h0"></path>
+<rect x="128" y="80" width="68" height="22"></rect>
+<text x="162" y="95">target</text>
+</g>
+<path d="M196 91h10"></path>
+<path d="M128 91a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M128 121h16"></path>
+<path d="M180 121h16"></path>
+<rect x="144" y="110" width="36" height="22" rx="10" ry="10"></rect>
+<text x="162" y="125">OR</text>
+</g>
+<path d="M196 121a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path>
+</g>
+<path d="M206 91h10"></path>
+<path d="M216 91h10"></path>
+<g>
+<path d="M226 91h0"></path>
+<path d="M254 91h0"></path>
+<rect x="226" y="80" width="28" height="22" rx="10" ry="10"></rect>
+<text x="240" y="95">)</text>
+</g>
+<path d="M254 91h10"></path>
+</g>
+<path d="M264 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v100a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 151h68"></path>
+<path d="M196 151h68"></path>
+<rect x="128" y="140" width="68" height="22"></rect>
+<text x="162" y="155">target</text>
+</g>
+<path d="M264 151a10 10 0 0 0 10 -10v-100a10 10 0 0 1 10 -10"></path>
+</g>
+<path d="M 284 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
+</g>
+</svg>
diff --git a/deps/fw/tools/fwrule/docs/media/img/target.svg b/deps/fw/tools/fwrule/docs/media/img/target.svg
new file mode 100644
index 0000000..a90ed03
--- /dev/null
+++ b/deps/fw/tools/fwrule/docs/media/img/target.svg
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="railroad-diagram" width="465" height="182" viewBox="0 0 465 182">
+<defs><style type="text/css"><![CDATA[
+svg.railroad-diagram path {
+  stroke-width: 3;
+  stroke: black;
+  fill: none;
+}
+svg.railroad-diagram text {
+  font: bold 14px monospace;
+  text-anchor: middle;
+}
+svg.railroad-diagram text.label {
+  text-anchor: start;
+}
+svg.railroad-diagram text.comment {
+  font: italic 12px monospace;
+}
+svg.railroad-diagram rect {
+  stroke-width: 3;
+  stroke: black;
+  fill: hsl(120,100%,90%);
+}
+ ]]></style></defs>
+<g transform="translate(.5 .5)">
+<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
+<g>
+<path d="M40 31h0"></path>
+<path d="M424 31h0"></path>
+<path d="M40 31h20"></path>
+<g>
+<path d="M60 31h96"></path>
+<path d="M308 31h96"></path>
+<path d="M156 31h10"></path>
+<g>
+<path d="M166 31h0"></path>
+<path d="M202 31h0"></path>
+<rect x="166" y="20" width="36" height="22" rx="10" ry="10"></rect>
+<text x="184" y="35">IP</text>
+</g>
+<path d="M202 31h10"></path>
+<path d="M212 31h10"></path>
+<g>
+<path d="M222 31h0"></path>
+<path d="M298 31h0"></path>
+<rect x="222" y="20" width="76" height="22"></rect>
+<text x="260" y="35">address</text>
+</g>
+<path d="M298 31h10"></path>
+</g>
+<path d="M404 31h20"></path>
+<path d="M40 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 61h92"></path>
+<path d="M312 61h92"></path>
+<path d="M152 61h10"></path>
+<g>
+<path d="M162 61h0"></path>
+<path d="M230 61h0"></path>
+<rect x="162" y="50" width="68" height="22" rx="10" ry="10"></rect>
+<text x="196" y="65">SUBNET</text>
+</g>
+<path d="M230 61h10"></path>
+<path d="M240 61h10"></path>
+<g>
+<path d="M250 61h0"></path>
+<path d="M302 61h0"></path>
+<rect x="250" y="50" width="52" height="22"></rect>
+<text x="276" y="65">cidr</text>
+</g>
+<path d="M302 61h10"></path>
+</g>
+<path d="M404 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 91h80"></path>
+<path d="M324 91h80"></path>
+<path d="M140 91h10"></path>
+<g>
+<path d="M150 91h0"></path>
+<path d="M194 91h0"></path>
+<rect x="150" y="80" width="44" height="22" rx="10" ry="10"></rect>
+<text x="172" y="95">TAG</text>
+</g>
+<path d="M194 91h10"></path>
+<path d="M204 91h10"></path>
+<g>
+<path d="M214 91h0"></path>
+<path d="M314 91h0"></path>
+<rect x="214" y="80" width="100" height="22"></rect>
+<text x="264" y="95">tag&#95;string</text>
+</g>
+<path d="M314 91h10"></path>
+</g>
+<path d="M404 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 121h0"></path>
+<path d="M404 121h0"></path>
+<path d="M60 121h10"></path>
+<g>
+<path d="M70 121h0"></path>
+<path d="M114 121h0"></path>
+<rect x="70" y="110" width="44" height="22" rx="10" ry="10"></rect>
+<text x="92" y="125">TAG</text>
+</g>
+<path d="M114 121h10"></path>
+<path d="M124 121h10"></path>
+<g>
+<path d="M134 121h0"></path>
+<path d="M234 121h0"></path>
+<rect x="134" y="110" width="100" height="22"></rect>
+<text x="184" y="125">tag&#95;string</text>
+</g>
+<path d="M234 121h10"></path>
+<path d="M244 121h10"></path>
+<g>
+<path d="M254 121h0"></path>
+<path d="M282 121h0"></path>
+<rect x="254" y="110" width="28" height="22" rx="10" ry="10"></rect>
+<text x="268" y="125">=</text>
+</g>
+<path d="M282 121h10"></path>
+<path d="M292 121h10"></path>
+<g>
+<path d="M302 121h0"></path>
+<path d="M394 121h0"></path>
+<rect x="302" y="110" width="92" height="22"></rect>
+<text x="348" y="125">tag&#95;value</text>
+</g>
+<path d="M394 121h10"></path>
+</g>
+<path d="M404 121a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
+<path d="M40 31a10 10 0 0 1 10 10v100a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 151h108"></path>
+<path d="M296 151h108"></path>
+<path d="M168 151h10"></path>
+<g>
+<path d="M178 151h0"></path>
+<path d="M214 151h0"></path>
+<rect x="178" y="140" width="36" height="22" rx="10" ry="10"></rect>
+<text x="196" y="155">VM</text>
+</g>
+<path d="M214 151h10"></path>
+<path d="M224 151h10"></path>
+<g>
+<path d="M234 151h0"></path>
+<path d="M286 151h0"></path>
+<rect x="234" y="140" width="52" height="22"></rect>
+<text x="260" y="155">uuid</text>
+</g>
+<path d="M286 151h10"></path>
+</g>
+<path d="M404 151a10 10 0 0 0 10 -10v-100a10 10 0 0 1 10 -10"></path>
+</g>
+<path d="M 424 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
+</g>
+</svg>
diff --git a/deps/fw/tools/fwrule/docs/media/img/type-list.svg b/deps/fw/tools/fwrule/docs/media/img/type-list.svg
new file mode 100644
index 0000000..c2ca2ab
--- /dev/null
+++ b/deps/fw/tools/fwrule/docs/media/img/type-list.svg
@@ -0,0 +1,131 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="railroad-diagram" width="633" height="132" viewBox="0 0 633 132">
+<defs><style type="text/css"><![CDATA[
+svg.railroad-diagram path {
+  stroke-width: 3;
+  stroke: black;
+  fill: none;
+}
+svg.railroad-diagram text {
+  font: bold 14px monospace;
+  text-anchor: middle;
+}
+svg.railroad-diagram text.label {
+  text-anchor: start;
+}
+svg.railroad-diagram text.comment {
+  font: italic 12px monospace;
+}
+svg.railroad-diagram rect {
+  stroke-width: 3;
+  stroke: black;
+  fill: hsl(120,100%,90%);
+}
+ ]]></style></defs>
+<g transform="translate(.5 .5)">
+<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
+<g>
+<path d="M40 41h0"></path>
+<path d="M592 41h0"></path>
+<path d="M40 41h20"></path>
+<g>
+<path d="M60 41h0"></path>
+<path d="M572 41h0"></path>
+<path d="M60 41h10"></path>
+<g>
+<path d="M70 41h0"></path>
+<path d="M98 41h0"></path>
+<rect x="70" y="30" width="28" height="22" rx="10" ry="10"></rect>
+<text x="84" y="45">(</text>
+</g>
+<path d="M98 41h10"></path>
+<path d="M108 41h10"></path>
+<g>
+<path d="M118 41h0"></path>
+<path d="M514 41h0"></path>
+<path d="M118 41h10"></path>
+<g>
+<path d="M128 41h0"></path>
+<path d="M504 41h0"></path>
+<path d="M128 41h10"></path>
+<g>
+<path d="M138 41h0"></path>
+<path d="M190 41h0"></path>
+<rect x="138" y="30" width="52" height="22" rx="10" ry="10"></rect>
+<text x="164" y="45">TYPE</text>
+</g>
+<path d="M190 41h10"></path>
+<path d="M200 41h10"></path>
+<g>
+<path d="M210 41h0"></path>
+<path d="M286 41h0"></path>
+<rect x="210" y="30" width="76" height="22" rx="10" ry="10"></rect>
+<text x="248" y="45">0 - 255</text>
+</g>
+<path d="M286 41h10"></path>
+<g>
+<path d="M296 41h0"></path>
+<path d="M504 41h0"></path>
+<path d="M296 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
+<g>
+<path d="M316 21h168"></path>
+</g>
+<path d="M484 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
+<path d="M296 41h20"></path>
+<g>
+<path d="M316 41h0"></path>
+<path d="M484 41h0"></path>
+<path d="M316 41h10"></path>
+<g>
+<path d="M326 41h0"></path>
+<path d="M378 41h0"></path>
+<rect x="326" y="30" width="52" height="22" rx="10" ry="10"></rect>
+<text x="352" y="45">CODE</text>
+</g>
+<path d="M378 41h10"></path>
+<path d="M388 41h10"></path>
+<g>
+<path d="M398 41h0"></path>
+<path d="M474 41h0"></path>
+<rect x="398" y="30" width="76" height="22" rx="10" ry="10"></rect>
+<text x="436" y="45">0 - 255</text>
+</g>
+<path d="M474 41h10"></path>
+</g>
+<path d="M484 41h20"></path>
+</g>
+</g>
+<path d="M504 41h10"></path>
+<path d="M128 41a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M128 71h166"></path>
+<path d="M338 71h166"></path>
+<rect x="294" y="60" width="44" height="22" rx="10" ry="10"></rect>
+<text x="316" y="75">AND</text>
+</g>
+<path d="M504 71a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path>
+</g>
+<path d="M514 41h10"></path>
+<path d="M524 41h10"></path>
+<g>
+<path d="M534 41h0"></path>
+<path d="M562 41h0"></path>
+<rect x="534" y="30" width="28" height="22" rx="10" ry="10"></rect>
+<text x="548" y="45">)</text>
+</g>
+<path d="M562 41h10"></path>
+</g>
+<path d="M572 41h20"></path>
+<path d="M40 41a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
+<g>
+<path d="M60 101h214"></path>
+<path d="M358 101h214"></path>
+<rect x="274" y="90" width="84" height="22" rx="10" ry="10"></rect>
+<text x="316" y="105">TYPE ALL</text>
+</g>
+<path d="M572 101a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
+</g>
+<path d="M 592 41 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
+</g>
+</svg>
diff --git a/deps/fw/tools/fwrule/docs/rules.md b/deps/fw/tools/fwrule/docs/rules.md
index 60f71e9..230fd25 100644
--- a/deps/fw/tools/fwrule/docs/rules.md
+++ b/deps/fw/tools/fwrule/docs/rules.md
@@ -13,14 +13,16 @@ Adding and updating rules takes effect immediately.  Adding or removing
 tags on a VM causes rules that apply to those tags to be added or removed
 immediately.
 
-In the case of two rules that affect the same VM and port, the rule that
-goes counter to the default policy takes precedence.  This means:
+In the case of two rules that affect the same VM and port and have the same
+priority level (0 when one isn't specified), the rule that goes counter to
+the default policy takes precedence by default. This means:
 
 * If you have an incoming BLOCK and an incoming ALLOW rule for the
-  same VM and port, the ALLOW will override.
+  same VM and port of the same priority, the ALLOW will override.
+  Give the BLOCK a higher priority to have it applied first.
 * If you have an outgoing BLOCK and an outgoing ALLOW rule for the
-  same VM and port, the BLOCK will override.
-
+  same VM and port of the same priority, the BLOCK will override.
+  Give the ALLOW a higher priority to have it applied first.
 
 # Rule payload
 
@@ -51,40 +53,30 @@ a rule.
 
 Firewall rules are in the following format:
 
-    FROM &lt;from targets> TO &lt;to targets> &lt;action> &lt;protocol> &lt;ports or types>
-    
-The parameters are the following:
-
-**from targets** and **to targets** can be any of the following types
-(see the Target Types section below):
+<p style="text-align: center">
+<img alt="Rules are of the form: FROM target_list TO target_list action protocol ports/types" src="./media/img/rule.svg" />
+</p>
 
-* vm &lt;uuid>
-* ip &lt;IPv4 or IPv6 address>
-* subnet &lt;subnet CIDR>
-* tag &lt;tag name>
-* tag &lt;tag name>=&lt;tag value>
-* a target list of up to 32 of the above
-* all vms
-* any
+Affected sources and destinations can be defined as a list of targets in the
+following syntax:
 
-**action** can be one of (see the Actions section below):
+<p style="text-align: center">
+<img alt="Target List Keywords: ALL VMS, ANY, or a list of targets separated by OR" src="./media/img/target-list.svg" />
+</p>
 
-* ALLOW
-* BLOCK
+**from targets** and **to targets** can be any of the following types
+(see the Target Types section below):
 
-**protocol** can be one of (see the Protocols section below):
+<p style="text-align: center">
+<img alt="Target Keywords: VM, IP, SUBNET, TAG" src="./media/img/target.svg" />
+</p>
 
-* tcp
-* udp
-* icmp
-* icmp6
+Protocols can be targeted using:
 
-**ports** or **types** can be one of (see the Ports section below):
+<p style="text-align: center">
+<img alt="Protocol Keywords: TCP, UDP, ICMP, ICMP6, AH, ESP" src="./media/img/protocol.svg" />
+</p>
 
-* port &lt;port number> (if protocol is tcp or udp)
-* ports &lt;port numbers and ranges> (if protocol is tcp or udp)
-* type &lt;ICMP type> (if protocol is icmp)
-* type &lt;ICMP type> code &lt;ICMP code> (if protocol is icmp)
 
 
 The limits for the parameters are:
@@ -98,7 +90,7 @@ The limits for the parameters are:
 
 ## vm
 
-    vm &lt;uuid>
+    vm <uuid>
 
 Targets the VM with that UUID.
 
@@ -110,7 +102,7 @@ Allows HTTP traffic from any host to VM 04128...
 
 ## ip
 
-    ip &lt;IP address>
+    ip <IP address>
 
 Targets the specified IPv4 or IPv6 address.
 
@@ -122,7 +114,7 @@ Blocks SMTP traffic to that IP.
 
 ## subnet
 
-    subnet &lt;subnet CIDR>
+    subnet <subnet CIDR>
 
 Targets the specified IPv4 or IPv6 subnet range.
 
@@ -140,9 +132,9 @@ Allows HTTPS traffic from a private IPv6 /64 to the specified VM.
 
 ## tag
 
-    tag &lt;name>
-    tag &lt;name> = &lt;value>
-    tag "&lt;name with spaces>" = "&lt;value with spaces>"
+    tag <name>
+    tag <name> = <value>
+    tag "<name with spaces>" = "<value with spaces>"
 
 Targets all VMs with the specified tag, or all VMs with the specified tag
 and value.  Both tag name and value can be quoted if they contain spaces.
@@ -188,7 +180,7 @@ Allows HTTP traffic from any IP to all VMs.
 
 ## target list
 
-    ( &lt;target> OR &lt;target> OR ... )
+    ( <target> OR <target> OR ... )
 
 The vm, ip, subnet and tag target types can be combined into a list surrounded
 by parentheses and joined by OR.
@@ -226,20 +218,18 @@ have an effect.
     udp
     icmp
     icmp6
+    ah
+    esp
 
-The protocol can be one of tcp, udp or icmp(6). The protocol dictates whether
-ports or types can be used (see the Ports section below).
+The protocol can be one of tcp, udp, icmp(6), ah or esp. The protocol dictates
+whether ports or types can be used (see the Ports section below).
 
 
 # Ports
 
-    port &lt;port number>
-    ( port &lt;port number> AND port &lt;port number> ... )
-    ports &lt;port number or range>
-    ports &lt;port number or range>, &lt;port number or range>, ...
-    type &lt;icmp type>
-    type &lt;icmp type> code &lt;icmp code>
-    ( type &lt;icmp type> AND type &lt;icmp type> code &lt;icmp code> AND ... )
+<p style="text-align: center">
+<img alt="All, specific, or ranges of ports can be allowed and blocked" src="./media/img/port-list.svg" />
+</p>
 
 For TCP and UDP, this specifies the port numbers that the rule applies to.
 Port numbers must be between 1 and 65535, inclusive. Ranges are written as two
@@ -247,9 +237,6 @@ port numbers separated by a - (hyphen), with the lower number coming first, with
 optional spaces around the hyphen. Port ranges are inclusive, so writing the
 range "20 - 22" would cause the rule to apply to the ports 20, 21 and 22.
 
-For ICMP, this specifies the ICMP type and optional code that the rule
-applies to.  Types and codes must be between 0 and 255, inclusive.
-
 **Examples:**
 
     FROM tag www TO any ALLOW tcp (port 80 AND port 443)
@@ -261,6 +248,18 @@ Allows HTTP and HTTPS traffic from any IP to all webservers.
 Allows traffic on HTTP, HTTPS and common alternative HTTP ports from any IP to
 all webservers.
 
+
+# ICMP Types
+
+<p style="text-align: center">
+<img alt="All ICMP types can be specified, or a list of specific ones" src="./media/img/type-list.svg" />
+</p>
+
+For ICMP, this specifies the ICMP type and optional code that the rule
+applies to.  Types and codes must be between 0 and 255, inclusive.
+
+**Examples:**
+
     FROM any TO all vms ALLOW icmp TYPE 8 CODE 0
 
 Allows pinging all VMs. The IPv6 equivalent would be:
@@ -273,6 +272,28 @@ And to block outgoing replies:
     FROM all vms TO any BLOCK icmp6 TYPE 129
 
 
+# Priority
+
+    priority <level>
+
+Specifying a priority for a rule allows defining its relation with other rules.
+By default, a rule has a priority level of 0, the lowest priority. Rules with a
+higher priority will be used before ones with a lower priority. The highest
+level that can be specified is 100.
+
+**Examples:**
+
+    FROM any TO tag mta ALLOW tcp PORT 25
+    FROM subnet 10.20.30.0/24 TO tag mta BLOCK tcp PORT 25 PRIORITY 1
+
+Allows traffic from anyone but 10.20.30.0/24 to access an MTA.
+
+    FROM all vms TO any BLOCK tcp PORT all
+    FROM all vms TO any ALLOW tcp PORT 22 PRIORITY 1
+
+Blocks all outbound traffic, overriding the default outbound policy,
+except for SSH.
+
 # Examples
 
     FROM all vms TO tag syslog ALLOW udp port 514
@@ -291,6 +312,13 @@ Allows ssh traffic between all VMs.
 
 Allow HTTP traffic from any host to all VMs.
 
+    FROM any TO all vms ALLOW ah
+    FROM any TO all vms ALLOW esp
+    FROM any TO all vms ALLOW udp (PORT 500 and PORT 4500)
+
+Allows [IPsec](https://en.wikipedia.org/wiki/IPsec) traffic from any host to
+all VMs.
+
 
 # Error Messages
 
diff --git a/deps/fw/tools/fwrule/docs/rules.md.in b/deps/fw/tools/fwrule/docs/rules.md.in
index 51f83cb..dc9847c 100644
--- a/deps/fw/tools/fwrule/docs/rules.md.in
+++ b/deps/fw/tools/fwrule/docs/rules.md.in
@@ -13,14 +13,16 @@ Adding and updating rules takes effect immediately.  Adding or removing
 tags on a VM causes rules that apply to those tags to be added or removed
 immediately.
 
-In the case of two rules that affect the same VM and port, the rule that
-goes counter to the default policy takes precedence.  This means:
+In the case of two rules that affect the same VM and port and have the same
+priority level (0 when one isn't specified), the rule that goes counter to
+the default policy takes precedence by default. This means:
 
 * If you have an incoming BLOCK and an incoming ALLOW rule for the
-  same VM and port, the ALLOW will override.
+  same VM and port of the same priority, the ALLOW will override.
+  Give the BLOCK a higher priority to have it applied first.
 * If you have an outgoing BLOCK and an outgoing ALLOW rule for the
-  same VM and port, the BLOCK will override.
-
+  same VM and port of the same priority, the BLOCK will override.
+  Give the ALLOW a higher priority to have it applied first.
 
 # Rule payload
 
@@ -51,8 +53,35 @@ a rule.
 
 Firewall rules are in the following format:
 
+{{#images}}
+<p style="text-align: center">
+<img alt="Rules are of the form: FROM target_list TO target_list action protocol ports/types" src="./media/img/rule.svg" />
+</p>
+
+Affected sources and destinations can be defined as a list of targets in the
+following syntax:
+
+<p style="text-align: center">
+<img alt="Target List Keywords: ALL VMS, ANY, or a list of targets separated by OR" src="./media/img/target-list.svg" />
+</p>
+
+**from targets** and **to targets** can be any of the following types
+(see the Target Types section below):
+
+<p style="text-align: center">
+<img alt="Target Keywords: VM, IP, SUBNET, TAG" src="./media/img/target.svg" />
+</p>
+
+Protocols can be targeted using:
+
+<p style="text-align: center">
+<img alt="Protocol Keywords: TCP, UDP, ICMP, ICMP6, AH, ESP" src="./media/img/protocol.svg" />
+</p>
+
+{{/images}}
+{{^images}}
     {{#indent_and_wrap}}
-    FROM &lt;from targets> TO &lt;to targets> &lt;action> &lt;protocol> &lt;ports or types>
+    FROM <from targets> TO <to targets> <action> <protocol> <ports or types>
     {{/indent_and_wrap}}
 
 The parameters are the following:
@@ -80,6 +109,8 @@ The parameters are the following:
 * udp
 * icmp
 * icmp6
+* ah
+* esp
 
 **ports** or **types** can be one of (see the Ports section below):
 
@@ -87,6 +118,7 @@ The parameters are the following:
 * ports &lt;port numbers and ranges> (if protocol is tcp or udp)
 * type &lt;ICMP type> (if protocol is icmp)
 * type &lt;ICMP type> code &lt;ICMP code> (if protocol is icmp)
+{{/images}}
 
 
 The limits for the parameters are:
@@ -100,7 +132,7 @@ The limits for the parameters are:
 
 ## vm
 
-    vm &lt;uuid>
+    vm <uuid>
 
 Targets the VM with that UUID.
 
@@ -112,7 +144,7 @@ Allows HTTP traffic from any host to VM 04128...
 
 ## ip
 
-    ip &lt;IP address>
+    ip <IP address>
 
 Targets the specified IPv4 or IPv6 address.
 
@@ -124,7 +156,7 @@ Blocks SMTP traffic to that IP.
 
 ## subnet
 
-    subnet &lt;subnet CIDR>
+    subnet <subnet CIDR>
 
 Targets the specified IPv4 or IPv6 subnet range.
 
@@ -146,9 +178,9 @@ Allows HTTPS traffic from a private IPv6 /64 to the specified VM.
 
 ## tag
 
-    tag &lt;name>
-    tag &lt;name> = &lt;value>
-    tag "&lt;name with spaces>" = "&lt;value with spaces>"
+    tag <name>
+    tag <name> = <value>
+    tag "<name with spaces>" = "<value with spaces>"
 
 Targets all VMs with the specified tag, or all VMs with the specified tag
 and value.  Both tag name and value can be quoted if they contain spaces.
@@ -194,7 +226,7 @@ Allows HTTP traffic from any IP to all VMs.
 
 ## target list
 
-    ( &lt;target> OR &lt;target> OR ... )
+    ( <target> OR <target> OR ... )
 
 The vm, ip, subnet and tag target types can be combined into a list surrounded
 by parentheses and joined by OR.
@@ -234,20 +266,27 @@ have an effect.
     udp
     icmp
     icmp6
+    ah
+    esp
 
-The protocol can be one of tcp, udp or icmp(6). The protocol dictates whether
-ports or types can be used (see the Ports section below).
+The protocol can be one of tcp, udp, icmp(6), ah or esp. The protocol dictates
+whether ports or types can be used (see the Ports section below).
 
 
 # Ports
 
-    port &lt;port number>
-    ( port &lt;port number> AND port &lt;port number> ... )
-    ports &lt;port number or range>
-    ports &lt;port number or range>, &lt;port number or range>, ...
-    type &lt;icmp type>
-    type &lt;icmp type> code &lt;icmp code>
-    ( type &lt;icmp type> AND type &lt;icmp type> code &lt;icmp code> AND ... )
+{{#images}}
+<p style="text-align: center">
+<img alt="All, specific, or ranges of ports can be allowed and blocked" src="./media/img/port-list.svg" />
+</p>
+{{/images}}
+{{^images}}
+    port all
+    port <port number>
+    ( port <port number> AND port <port number> ... )
+    ports <port number or range>
+    ports <port number or range>, <port number or range>, ...
+{{/images}}
 
 For TCP and UDP, this specifies the port numbers that the rule applies to.
 Port numbers must be between 1 and 65535, inclusive. Ranges are written as two
@@ -255,9 +294,6 @@ port numbers separated by a - (hyphen), with the lower number coming first, with
 optional spaces around the hyphen. Port ranges are inclusive, so writing the
 range "20 - 22" would cause the rule to apply to the ports 20, 21 and 22.
 
-For ICMP, this specifies the ICMP type and optional code that the rule
-applies to.  Types and codes must be between 0 and 255, inclusive.
-
 **Examples:**
 
     FROM tag www TO any ALLOW tcp (port 80 AND port 443)
@@ -269,6 +305,26 @@ Allows HTTP and HTTPS traffic from any IP to all webservers.
 Allows traffic on HTTP, HTTPS and common alternative HTTP ports from any IP to
 all webservers.
 
+
+# ICMP Types
+
+{{#images}}
+<p style="text-align: center">
+<img alt="All ICMP types can be specified, or a list of specific ones" src="./media/img/type-list.svg" />
+</p>
+{{/images}}
+{{^images}}
+    type all
+    type <icmp type>
+    type <icmp type> code <icmp code>
+    ( type <icmp type> AND type <icmp type> code <icmp code> AND ... )
+{{/images}}
+
+For ICMP, this specifies the ICMP type and optional code that the rule
+applies to.  Types and codes must be between 0 and 255, inclusive.
+
+**Examples:**
+
     FROM any TO all vms ALLOW icmp TYPE 8 CODE 0
 
 Allows pinging all VMs. The IPv6 equivalent would be:
@@ -281,6 +337,28 @@ And to block outgoing replies:
     FROM all vms TO any BLOCK icmp6 TYPE 129
 
 
+# Priority
+
+    priority <level>
+
+Specifying a priority for a rule allows defining its relation with other rules.
+By default, a rule has a priority level of 0, the lowest priority. Rules with a
+higher priority will be used before ones with a lower priority. The highest
+level that can be specified is 100.
+
+**Examples:**
+
+    FROM any TO tag mta ALLOW tcp PORT 25
+    FROM subnet 10.20.30.0/24 TO tag mta BLOCK tcp PORT 25 PRIORITY 1
+
+Allows traffic from anyone but 10.20.30.0/24 to access an MTA.
+
+    FROM all vms TO any BLOCK tcp PORT all
+    FROM all vms TO any ALLOW tcp PORT 22 PRIORITY 1
+
+Blocks all outbound traffic, overriding the default outbound policy,
+except for SSH.
+
 # Examples
 
     FROM all vms TO tag syslog ALLOW udp port 514
@@ -299,6 +377,13 @@ Allows ssh traffic between all VMs.
 
 Allow HTTP traffic from any host to all VMs.
 
+    FROM any TO all vms ALLOW ah
+    FROM any TO all vms ALLOW esp
+    FROM any TO all vms ALLOW udp (PORT 500 and PORT 4500)
+
+Allows [IPsec](https://en.wikipedia.org/wiki/IPsec) traffic from any host to
+all VMs.
+
 
 # Error Messages
 
diff --git a/deps/fw/tools/fwrule/etc/rules.json b/deps/fw/tools/fwrule/etc/rules.json
new file mode 100644
index 0000000..8056063
--- /dev/null
+++ b/deps/fw/tools/fwrule/etc/rules.json
@@ -0,0 +1,3 @@
+{
+    "images": true
+}
diff --git a/deps/fw/tools/fwrule/lib/index.js b/deps/fw/tools/fwrule/lib/index.js
deleted file mode 100644
index f42f6a9..0000000
--- a/deps/fw/tools/fwrule/lib/index.js
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * firewall rule parser: entry point
- */
-
-'use strict';
-
-var mod_net = require('net');
-var parser = require('./parser').parser;
-var rule = require('./rule');
-var validators = require('./validators');
-
-
-
-// --- Globals
-
-
-
-var uuidRE = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
-
-/**
- * The fwrule language is versioned so that use of new features can be
- * restricted. These versions are:
- *
- * 1 - Initial version of language
- * 2 - PORTS keyword & support for ranges of ports
- * 3 - Support for IPv6 targets, the ICMPv6 protocol, and the TYPE ALL keyword
- */
-var CURR_VERSION = 3;
-
-
-// --- Internal helper functions
-
-
-/**
- * Translates an internal parser name (usually all one word, all caps, for
- * brevity), to a friendlier user-facing name
- */
-function translateParserNames(name) {
-    var translated;
-    switch (name) {
-        case '\'ALL\'':
-        case '\'ANY\'':
-        case '\'IP\'':
-        case '\'SUBNET\'':
-        case '\'TAG\'':
-        case '\'VM\'':
-        case 'WORD':
-            translated = name.toLowerCase();
-            break;
-        default:
-            translated = name;
-            break;
-    }
-
-    return translated;
-}
-
-
-
-// --- Parser extension methods
-
-
-
-parser.yy.validateIPv4address = function validateIPv4address(ip) {
-    if (!validators.validateIPv4address(ip)) {
-        throw new validators.InvalidParamError('rule',
-            'IPv4 address "%s" is invalid', ip);
-    }
-};
-
-
-parser.yy.validateIPv4subnet = function validateIPv4subnet(subnet) {
-    if (!validators.validateIPv4subnet(subnet)) {
-        throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
-    }
-};
-
-
-parser.yy.validateIPv6address = function validateIPv6address(ip) {
-    if (!mod_net.isIPv6(ip)) {
-        throw new validators.InvalidParamError('rule',
-            'IPv6 address "%s" is invalid', ip);
-    }
-};
-
-
-parser.yy.validateIPv6subnet = function validateIPv6subnet(subnet) {
-    if (!validators.validateIPv6subnet(subnet)) {
-        throw new validators.InvalidParamError('rule',
-            'Subnet "%s" is invalid (must be in CIDR format)', subnet);
-    }
-};
-
-
-parser.yy.validatePortNumber = function validatePortNumber(num) {
-    if (isNaN(num) || Number(num) < 1 || Number(num) > 65535) {
-        throw new validators.InvalidParamError('rule',
-            'Port number "%s" is invalid', num);
-    }
-};
-
-parser.yy.validateRangeOrder = function validateRangeOrder(start, end) {
-    if (Number(end) < Number(start)) {
-        throw new validators.InvalidParamError('rule',
-            'The end of the range (%s) cannot be less than the start (%s)',
-            end, start);
-    }
-};
-
-parser.yy.createMaybePortRange = function createMaybePortRange(num) {
-    var range = num.split('-');
-
-    switch (range.length) {
-    case 1:
-            parser.yy.validatePortNumber(range[0]);
-            return Number(range[0]);
-    case 2:
-            parser.yy.validatePortNumber(range[0]);
-            parser.yy.validatePortNumber(range[1]);
-            parser.yy.validateRangeOrder(range[0], range[1]);
-            return { 'start': Number(range[0]), 'end': Number(range[1]) };
-    default:
-            throw new validators.InvalidParamError('rule',
-                '"%s" is not a valid port number or range', num);
-    }
-};
-
-
-parser.yy.validateICMPcode = function validateICMPcode(num) {
-    if (isNaN(num) || Number(num) < 0 || Number(num) > 255) {
-        throw new validators.InvalidParamError('rule',
-            'ICMP code "%s" is invalid', num);
-    }
-};
-
-
-parser.yy.validateICMPtype = function validateICMPtype(num) {
-    if (isNaN(num) || Number(num) < 0 || Number(num) > 255) {
-        throw new validators.InvalidParamError('rule',
-            'ICMP type "%s" is invalid', num);
-    }
-};
-
-
-parser.yy.validateUUID = function validateUUID(text) {
-    if (!uuidRE.test(text)) {
-        throw new validators.InvalidParamError('rule',
-            'UUID "%s" is invalid', text);
-    }
-};
-
-parser.yy.validateOKVersion = function validateOKVersion(ver, feature) {
-    if (ver > parser.yy.maxVersion) {
-        throw new validators.InvalidParamError('rule',
-            'The rule uses a feature (%s) newer than this API allows', feature);
-    }
-};
-
-
-parser.yy.parseError = function parseError(_, details) {
-    var err;
-    if (details.token === null) {
-        var pre = this.yy.lexer.pastInput();
-        var post = this.yy.lexer.upcomingInput();
-        err = new validators.InvalidParamError('rule',
-            'Error at character %d: \'%s\', found: unexpected text',
-            pre.length, post);
-        err.details = details;
-        throw err;
-    }
-
-    if (details.text === '') {
-        err = new validators.InvalidParamError('rule',
-            'Error at character 0: \'\', expected: \'FROM\', found: '
-            + 'empty string');
-        err.details = details;
-        throw err;
-    }
-
-    err = new validators.InvalidParamError('rule',
-        'Error at character %d: \'%s\', expected: %s, found: %s',
-        details.loc.last_column,
-        details.text,
-        details.expected.map(function (exp) {
-            return translateParserNames(exp);
-        }).join(', '),
-        translateParserNames(details.token));
-
-    err.details = details;
-    throw err;
-};
-
-
-parser.yy.tagUnescape = rule.tagUnescape;
-
-
-// --- Exports
-
-
-
-function parse(input, opts) {
-    if (!opts) {
-        opts = {};
-    }
-
-    // If a version hasn't been specified, use most recent
-    parser.yy.maxVersion = opts.maxVersion || CURR_VERSION;
-
-    return parser.parse(input);
-}
-
-
-
-module.exports = {
-    ACTIONS: ['allow', 'block'],
-    DIRECTIONS: rule.DIRECTIONS,
-    FIELDS: rule.FIELDS,
-    create: rule.create,
-    FwRule: rule.FwRule,
-    generateVersion: rule.generateVersion,
-    parse: parse,
-    PROTOCOLS: ['tcp', 'udp', 'icmp', 'icmp6'],
-    TARGET_TYPES: rule.TARGET_TYPES,
-    validators: validators
-};
diff --git a/deps/fw/tools/fwrule/lib/parser.js b/deps/fw/tools/fwrule/lib/parser.js
deleted file mode 100644
index f50b0ab..0000000
--- a/deps/fw/tools/fwrule/lib/parser.js
+++ /dev/null
@@ -1,561 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * fwadm: firewall rule parser
- */
-
-
-/* parser generated by jison 0.4.2 */
-var parser = (function(){
-var parser = {trace: function trace() { },
-yy: {},
-symbols_: {"error":2,"start":3,"FROM":4,"target_list":5,"TO":6,"action":7,"protocol":8,"EOF":9,"any":10,"all":11,"(":12,"target_or_list":13,")":14,"target":15,"OR":16,"ipv4":17,"ipv4_subnet":18,"ipv6":19,"ipv6_subnet":20,"tag":21,"vm":22,"ALL":23,"VMS":24,"ANY":25,"IP":26,"IPV4ADDR":27,"SUBNET":28,"CIDRSUFFIX":29,"IPV6ADDR":30,"VM":31,"uuid":32,"WORD":33,"TAG":34,"tag_string":35,"=":36,"STRING":37,"BLOCK":38,"ALLOW":39,"TCP":40,"port_list":41,"ports":42,"UDP":43,"ICMP":44,"type_list":45,"ICMP6":46,"port_and_list":47,"port":48,"port_all":49,"AND":50,"PORT":51,"portnumber":52,"PORTS":53,"portnumbers":54,"portrange":55,"-":56,",":57,"type_and_list":58,"type":59,"type_all":60,"TYPE":61,"icmptype":62,"CODE":63,"icmpcode":64,"$accept":0,"$end":1},
-terminals_: {2:"error",4:"FROM",6:"TO",9:"EOF",12:"(",14:")",16:"OR",23:"ALL",24:"VMS",25:"ANY",26:"IP",27:"IPV4ADDR",28:"SUBNET",29:"CIDRSUFFIX",30:"IPV6ADDR",31:"VM",33:"WORD",34:"TAG",36:"=",37:"STRING",38:"BLOCK",39:"ALLOW",40:"TCP",43:"UDP",44:"ICMP",46:"ICMP6",50:"AND",51:"PORT",53:"PORTS",56:"-",57:",",61:"TYPE",63:"CODE"},
-productions_: [0,[3,7],[5,1],[5,1],[5,3],[5,1],[13,1],[13,3],[15,1],[15,1],[15,1],[15,1],[15,1],[15,1],[11,2],[11,4],[10,1],[10,3],[17,2],[18,3],[19,2],[20,3],[22,2],[32,1],[21,2],[21,4],[35,1],[35,1],[7,1],[7,1],[8,2],[8,2],[8,2],[8,2],[8,2],[8,2],[41,3],[41,1],[41,3],[41,1],[47,1],[47,3],[48,2],[42,2],[49,2],[52,1],[55,1],[55,3],[54,1],[54,3],[45,3],[45,1],[45,3],[45,1],[58,1],[58,3],[59,4],[59,2],[60,2],[62,1],[64,1]],
-performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {
-
-var $0 = $$.length - 1;
-switch (yystate) {
-case 1: return { 'from': $$[$0-5], 'to': $$[$0-3], 'action': $$[$0-2], 'protocol': $$[$0-1] }; 
-break;
-case 4:this.$ = $$[$0-1];
-break;
-case 7: this.$ = $$[$0-2].concat($$[$0]); 
-break;
-case 14: this.$ = [ ['wildcard', 'vmall'] ]; 
-break;
-case 15: this.$ = [ ['wildcard', 'vmall'] ]; 
-break;
-case 16: this.$ = [ ['wildcard', 'any'] ]; 
-break;
-case 17: this.$ = [ ['wildcard', 'any'] ]; 
-break;
-case 18: yy.validateIPv4address($$[$0]);
-          this.$ = [ ['ip', $$[$0]] ]; 
-break;
-case 19: yy.validateIPv4subnet($$[$0-1] + $$[$0]);
-            this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
-break;
-case 20: yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6address($$[$0]);
-          this.$ = [ ['ip', $$[$0]] ]; 
-break;
-case 21: yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6subnet($$[$0-1] + $$[$0]);
-            this.$ = [ ['subnet', $$[$0-1] + $$[$0]] ]; 
-break;
-case 22: this.$ = [ ['vm', $$[$0]] ]; 
-break;
-case 23: yy.validateUUID($$[$0]);
-          this.$ = $$[$0]; 
-break;
-case 24: this.$ = [ ['tag', $$[$0]] ]; 
-break;
-case 25: this.$ = [ ['tag', [ $$[$0-2], $$[$0] ] ] ]; 
-break;
-case 26: this.$ = yytext; 
-break;
-case 27: this.$ = $$[$0]; 
-break;
-case 28: this.$ = $$[$0].toLowerCase() 
-break;
-case 29: this.$ = $$[$0].toLowerCase() 
-break;
-case 30: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 31: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 32: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 33: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 34: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 35: this.$ = { 'name': $$[$0-1].toLowerCase(), 'targets': $$[$0] } 
-break;
-case 36: this.$ = $$[$0-1]; 
-break;
-case 38: this.$ = $$[$0-1]; 
-break;
-case 41: this.$ = $$[$0-2].concat(Number($$[$0])); 
-break;
-case 42: this.$ = [ $$[$0] ]; 
-break;
-case 43: yy.validateOKVersion(2, 'port ranges');
-          this.$ = $$[$0]; 
-break;
-case 44: this.$ = [ 'all' ]; 
-break;
-case 45: yy.validatePortNumber($$[$0]);
-          this.$ = Number($$[$0]); 
-break;
-case 46: this.$ = [ yy.createMaybePortRange($$[$0]) ]; 
-break;
-case 47: yy.validatePortNumber($$[$0-2]);
-          yy.validatePortNumber($$[$0]);
-          yy.validateRangeOrder($$[$0-2], $$[$0]);
-          this.$ = [{ 'start': Number($$[$0-2]), 'end': Number($$[$0]) }]; 
-break;
-case 49: this.$ = $$[$0-2].concat($$[$0]); 
-break;
-case 50: this.$ = $$[$0-1]; 
-break;
-case 52: this.$ = $$[$0-1]; 
-break;
-case 55: this.$ = $$[$0-2].concat($$[$0]); 
-break;
-case 56: this.$ = [ $$[$0-2] + ':' + $$[$0] ]; 
-break;
-case 57: this.$ = [ $$[$0] ]; 
-break;
-case 58: yy.validateOKVersion(3, 'all ICMP types');
-          this.$ = [ 'all' ]; 
-break;
-case 59: yy.validateICMPtype($$[$0]);
-          this.$ = Number($$[$0]); 
-break;
-case 60: yy.validateICMPcode($$[$0]);
-          this.$ = Number($$[$0]); 
-break;
-}
-},
-table: [{3:1,4:[1,2]},{1:[3]},{5:3,10:4,11:5,12:[1,6],15:7,17:10,18:11,19:12,20:13,21:14,22:15,23:[1,9],25:[1,8],26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{6:[1,20]},{6:[2,2],38:[2,2],39:[2,2]},{6:[2,3],38:[2,3],39:[2,3]},{13:21,15:24,17:10,18:11,19:12,20:13,21:14,22:15,23:[1,23],25:[1,22],26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{6:[2,5],38:[2,5],39:[2,5]},{6:[2,16],38:[2,16],39:[2,16]},{24:[1,25]},{6:[2,8],14:[2,8],16:[2,8],38:[2,8],39:[2,8]},{6:[2,9],14:[2,9],16:[2,9],38:[2,9],39:[2,9]},{6:[2,10],14:[2,10],16:[2,10],38:[2,10],39:[2,10]},{6:[2,11],14:[2,11],16:[2,11],38:[2,11],39:[2,11]},{6:[2,12],14:[2,12],16:[2,12],38:[2,12],39:[2,12]},{6:[2,13],14:[2,13],16:[2,13],38:[2,13],39:[2,13]},{27:[1,26],30:[1,27]},{27:[1,28],30:[1,29]},{33:[1,32],35:30,37:[1,31]},{32:33,33:[1,34]},{5:35,10:4,11:5,12:[1,6],15:7,17:10,18:11,19:12,20:13,21:14,22:15,23:[1,9],25:[1,8],26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{14:[1,36],16:[1,37]},{14:[1,38]},{24:[1,39]},{14:[2,6],16:[2,6]},{6:[2,14],38:[2,14],39:[2,14]},{6:[2,18],14:[2,18],16:[2,18],38:[2,18],39:[2,18]},{6:[2,20],14:[2,20],16:[2,20],38:[2,20],39:[2,20]},{29:[1,40]},{29:[1,41]},{6:[2,24],14:[2,24],16:[2,24],36:[1,42],38:[2,24],39:[2,24]},{6:[2,26],14:[2,26],16:[2,26],36:[2,26],38:[2,26],39:[2,26]},{6:[2,27],14:[2,27],16:[2,27],36:[2,27],38:[2,27],39:[2,27]},{6:[2,22],14:[2,22],16:[2,22],38:[2,22],39:[2,22]},{6:[2,23],14:[2,23],16:[2,23],38:[2,23],39:[2,23]},{7:43,38:[1,44],39:[1,45]},{6:[2,4],38:[2,4],39:[2,4]},{15:46,17:10,18:11,19:12,20:13,21:14,22:15,26:[1,16],28:[1,17],31:[1,19],34:[1,18]},{6:[2,17],38:[2,17],39:[2,17]},{14:[1,47]},{6:[2,19],14:[2,19],16:[2,19],38:[2,19],39:[2,19]},{6:[2,21],14:[2,21],16:[2,21],38:[2,21],39:[2,21]},{33:[1,32],35:48,37:[1,31]},{8:49,40:[1,50],43:[1,51],44:[1,52],46:[1,53]},{40:[2,28],43:[2,28],44:[2,28],46:[2,28]},{40:[2,29],43:[2,29],44:[2,29],46:[2,29]},{14:[2,7],16:[2,7]},{6:[2,15],38:[2,15],39:[2,15]},{6:[2,25],14:[2,25],16:[2,25],38:[2,25],39:[2,25]},{9:[1,54]},{12:[1,57],41:55,42:56,48:58,49:59,51:[1,61],53:[1,60]},{12:[1,57],41:62,42:63,48:58,49:59,51:[1,61],53:[1,60]},{12:[1,65],45:64,59:66,60:67,61:[1,68]},{12:[1,65],45:69,59:66,60:67,61:[1,68]},{1:[2,1]},{9:[2,30]},{9:[2,31]},{47:70,48:72,49:71,51:[1,61]},{9:[2,37]},{9:[2,39]},{33:[1,75],54:73,55:74},{23:[1,77],33:[1,78],52:76},{9:[2,32]},{9:[2,33]},{9:[2,34]},{58:79,59:81,60:80,61:[1,68]},{9:[2,51]},{9:[2,53]},{23:[1,83],33:[1,84],62:82},{9:[2,35]},{14:[1,85],50:[1,86]},{14:[1,87]},{14:[2,40],50:[2,40]},{9:[2,43],57:[1,88]},{9:[2,48],57:[2,48]},{9:[2,46],56:[1,89],57:[2,46]},{9:[2,42],14:[2,42],50:[2,42]},{9:[2,44],14:[2,44]},{9:[2,45],14:[2,45],50:[2,45]},{14:[1,90],50:[1,91]},{14:[1,92]},{14:[2,54],50:[2,54]},{9:[2,57],14:[2,57],50:[2,57],63:[1,93]},{9:[2,58],14:[2,58]},{9:[2,59],14:[2,59],50:[2,59],63:[2,59]},{9:[2,36]},{48:94,51:[1,95]},{9:[2,38]},{33:[1,75],55:96},{33:[1,97]},{9:[2,50]},{59:98,61:[1,99]},{9:[2,52]},{33:[1,101],64:100},{14:[2,41],50:[2,41]},{33:[1,78],52:76},{9:[2,49],57:[2,49]},{9:[2,47],57:[2,47]},{14:[2,55],50:[2,55]},{33:[1,84],62:82},{9:[2,56],14:[2,56],50:[2,56]},{9:[2,60],14:[2,60],50:[2,60]}],
-defaultActions: {54:[2,1],55:[2,30],56:[2,31],58:[2,37],59:[2,39],62:[2,32],63:[2,33],64:[2,34],66:[2,51],67:[2,53],69:[2,35],85:[2,36],87:[2,38],90:[2,50],92:[2,52]},
-parseError: function parseError(str, hash) {
-    throw new Error(str);
-},
-parse: function parse(input) {
-    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
-    this.lexer.setInput(input);
-    this.lexer.yy = this.yy;
-    this.yy.lexer = this.lexer;
-    this.yy.parser = this;
-    if (typeof this.lexer.yylloc == "undefined")
-        this.lexer.yylloc = {};
-    var yyloc = this.lexer.yylloc;
-    lstack.push(yyloc);
-    var ranges = this.lexer.options && this.lexer.options.ranges;
-    if (typeof this.yy.parseError === "function")
-        this.parseError = this.yy.parseError;
-    function popStack(n) {
-        stack.length = stack.length - 2 * n;
-        vstack.length = vstack.length - n;
-        lstack.length = lstack.length - n;
-    }
-    function lex() {
-        var token;
-        token = self.lexer.lex() || 1;
-        if (typeof token !== "number") {
-            token = self.symbols_[token] || token;
-        }
-        return token;
-    }
-    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
-    while (true) {
-        state = stack[stack.length - 1];
-        if (this.defaultActions[state]) {
-            action = this.defaultActions[state];
-        } else {
-            if (symbol === null || typeof symbol == "undefined") {
-                symbol = lex();
-            }
-            action = table[state] && table[state][symbol];
-        }
-        if (typeof action === "undefined" || !action.length || !action[0]) {
-            var errStr = "";
-            if (!recovering) {
-                expected = [];
-                for (p in table[state])
-                    if (this.terminals_[p] && p > 2) {
-                        expected.push("'" + this.terminals_[p] + "'");
-                    }
-                if (this.lexer.showPosition) {
-                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
-                } else {
-                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
-                }
-                this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
-            }
-        }
-        if (action[0] instanceof Array && action.length > 1) {
-            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
-        }
-        switch (action[0]) {
-        case 1:
-            stack.push(symbol);
-            vstack.push(this.lexer.yytext);
-            lstack.push(this.lexer.yylloc);
-            stack.push(action[1]);
-            symbol = null;
-            if (!preErrorSymbol) {
-                yyleng = this.lexer.yyleng;
-                yytext = this.lexer.yytext;
-                yylineno = this.lexer.yylineno;
-                yyloc = this.lexer.yylloc;
-                if (recovering > 0)
-                    recovering--;
-            } else {
-                symbol = preErrorSymbol;
-                preErrorSymbol = null;
-            }
-            break;
-        case 2:
-            len = this.productions_[action[1]][1];
-            yyval.$ = vstack[vstack.length - len];
-            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
-            if (ranges) {
-                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
-            }
-            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
-            if (typeof r !== "undefined") {
-                return r;
-            }
-            if (len) {
-                stack = stack.slice(0, -1 * len * 2);
-                vstack = vstack.slice(0, -1 * len);
-                lstack = lstack.slice(0, -1 * len);
-            }
-            stack.push(this.productions_[action[1]][0]);
-            vstack.push(yyval.$);
-            lstack.push(yyval._$);
-            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
-            stack.push(newState);
-            break;
-        case 3:
-            return true;
-        }
-    }
-    return true;
-}
-};
-/* generated by jison-lex 0.1.0 */
-var lexer = (function(){
-var lexer = {
-EOF:1,
-parseError:function parseError(str, hash) {
-        if (this.yy.parser) {
-            this.yy.parser.parseError(str, hash);
-        } else {
-            throw new Error(str);
-        }
-    },
-setInput:function (input) {
-        this._input = input;
-        this._more = this._less = this.done = false;
-        this.yylineno = this.yyleng = 0;
-        this.yytext = this.matched = this.match = '';
-        this.conditionStack = ['INITIAL'];
-        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
-        if (this.options.ranges) this.yylloc.range = [0,0];
-        this.offset = 0;
-        return this;
-    },
-input:function () {
-        var ch = this._input[0];
-        this.yytext += ch;
-        this.yyleng++;
-        this.offset++;
-        this.match += ch;
-        this.matched += ch;
-        var lines = ch.match(/(?:\r\n?|\n).*/g);
-        if (lines) {
-            this.yylineno++;
-            this.yylloc.last_line++;
-        } else {
-            this.yylloc.last_column++;
-        }
-        if (this.options.ranges) this.yylloc.range[1]++;
-
-        this._input = this._input.slice(1);
-        return ch;
-    },
-unput:function (ch) {
-        var len = ch.length;
-        var lines = ch.split(/(?:\r\n?|\n)/g);
-
-        this._input = ch + this._input;
-        this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
-        //this.yyleng -= len;
-        this.offset -= len;
-        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
-        this.match = this.match.substr(0, this.match.length-1);
-        this.matched = this.matched.substr(0, this.matched.length-1);
-
-        if (lines.length-1) this.yylineno -= lines.length-1;
-        var r = this.yylloc.range;
-
-        this.yylloc = {first_line: this.yylloc.first_line,
-          last_line: this.yylineno+1,
-          first_column: this.yylloc.first_column,
-          last_column: lines ?
-              (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
-              this.yylloc.first_column - len
-          };
-
-        if (this.options.ranges) {
-            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
-        }
-        return this;
-    },
-more:function () {
-        this._more = true;
-        return this;
-    },
-less:function (n) {
-        this.unput(this.match.slice(n));
-    },
-pastInput:function () {
-        var past = this.matched.substr(0, this.matched.length - this.match.length);
-        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
-    },
-upcomingInput:function () {
-        var next = this.match;
-        if (next.length < 20) {
-            next += this._input.substr(0, 20-next.length);
-        }
-        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
-    },
-showPosition:function () {
-        var pre = this.pastInput();
-        var c = new Array(pre.length + 1).join("-");
-        return pre + this.upcomingInput() + "\n" + c+"^";
-    },
-next:function () {
-        if (this.done) {
-            return this.EOF;
-        }
-        if (!this._input) this.done = true;
-
-        var token,
-            match,
-            tempMatch,
-            index,
-            col,
-            lines;
-        if (!this._more) {
-            this.yytext = '';
-            this.match = '';
-        }
-        var rules = this._currentRules();
-        for (var i=0;i < rules.length; i++) {
-            tempMatch = this._input.match(this.rules[rules[i]]);
-            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
-                match = tempMatch;
-                index = i;
-                if (!this.options.flex) break;
-            }
-        }
-        if (match) {
-            lines = match[0].match(/(?:\r\n?|\n).*/g);
-            if (lines) this.yylineno += lines.length;
-            this.yylloc = {first_line: this.yylloc.last_line,
-                           last_line: this.yylineno+1,
-                           first_column: this.yylloc.last_column,
-                           last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
-            this.yytext += match[0];
-            this.match += match[0];
-            this.matches = match;
-            this.yyleng = this.yytext.length;
-            if (this.options.ranges) {
-                this.yylloc.range = [this.offset, this.offset += this.yyleng];
-            }
-            this._more = false;
-            this._input = this._input.slice(match[0].length);
-            this.matched += match[0];
-            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
-            if (this.done && this._input) this.done = false;
-            if (token) return token;
-            else return;
-        }
-        if (this._input === "") {
-            return this.EOF;
-        } else {
-            return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
-                    {text: "", token: null, line: this.yylineno});
-        }
-    },
-lex:function lex() {
-        var r = this.next();
-        if (typeof r !== 'undefined') {
-            return r;
-        } else {
-            return this.lex();
-        }
-    },
-begin:function begin(condition) {
-        this.conditionStack.push(condition);
-    },
-popState:function popState() {
-        return this.conditionStack.pop();
-    },
-_currentRules:function _currentRules() {
-        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
-    },
-topState:function () {
-        return this.conditionStack[this.conditionStack.length-2];
-    },
-pushState:function begin(condition) {
-        this.begin(condition);
-    },
-options: {},
-performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
-
-var YYSTATE=YY_START;
-switch($avoiding_name_collisions) {
-case 0:/* skip whitespace */
-break;
-case 1:return 9;
-break;
-case 2:return 4;
-break;
-case 3:return 4;
-break;
-case 4:return 6;
-break;
-case 5:return 6;
-break;
-case 6:return 26;
-break;
-case 7:return 26;
-break;
-case 8:return 28;
-break;
-case 9:return 28;
-break;
-case 10:return 25;
-break;
-case 11:return 25;
-break;
-case 12:return 23;
-break;
-case 13:return 23;
-break;
-case 14:return 34;
-break;
-case 15:return 34;
-break;
-case 16:return 31;
-break;
-case 17:return 31;
-break;
-case 18:return 24;
-break;
-case 19:return 24;
-break;
-case 20:return 56;
-break;
-case 21:return 57;
-break;
-case 22:return 36;
-break;
-case 23:return 12;
-break;
-case 24:return 14;
-break;
-case 25:return 16;
-break;
-case 26:return 16;
-break;
-case 27:return 50;
-break;
-case 28:return 50;
-break;
-case 29:return 38;
-break;
-case 30:return 38;
-break;
-case 31:return 39;
-break;
-case 32:return 39;
-break;
-case 33:return 51;
-break;
-case 34:return 51;
-break;
-case 35:return 53;
-break;
-case 36:return 53;
-break;
-case 37:return 40;
-break;
-case 38:return 40;
-break;
-case 39:return 43;
-break;
-case 40:return 43;
-break;
-case 41:return 44;
-break;
-case 42:return 44;
-break;
-case 43:return 46;
-break;
-case 44:return 46;
-break;
-case 45:return 61;
-break;
-case 46:return 61;
-break;
-case 47:return 63;
-break;
-case 48:return 63;
-break;
-case 49:yy_.yytext = yy.tagUnescape(yy_.yytext.substr(1,yy_.yyleng-2)); return 37;
-break;
-case 50:return 27;
-break;
-case 51:return 30;
-break;
-case 52:return 29;
-break;
-case 53:return 33
-break;
-}
-},
-rules: [/^(?:\s+)/,/^(?:$)/,/^(?:FROM\b)/,/^(?:from\b)/,/^(?:TO\b)/,/^(?:to\b)/,/^(?:IP\b)/,/^(?:ip\b)/,/^(?:SUBNET\b)/,/^(?:subnet\b)/,/^(?:ANY\b)/,/^(?:any\b)/,/^(?:ALL\b)/,/^(?:all\b)/,/^(?:TAG\b)/,/^(?:tag\b)/,/^(?:VM\b)/,/^(?:vm\b)/,/^(?:VMS\b)/,/^(?:vms\b)/,/^(?:-)/,/^(?:,)/,/^(?:=)/,/^(?:\()/,/^(?:\))/,/^(?:OR\b)/,/^(?:or\b)/,/^(?:AND\b)/,/^(?:and\b)/,/^(?:BLOCK\b)/,/^(?:block\b)/,/^(?:ALLOW\b)/,/^(?:allow\b)/,/^(?:PORT\b)/,/^(?:port\b)/,/^(?:PORTS\b)/,/^(?:ports\b)/,/^(?:TCP\b)/,/^(?:tcp\b)/,/^(?:UDP\b)/,/^(?:udp\b)/,/^(?:ICMP\b)/,/^(?:icmp\b)/,/^(?:ICMP6\b)/,/^(?:icmp6\b)/,/^(?:TYPE\b)/,/^(?:type\b)/,/^(?:CODE\b)/,/^(?:code\b)/,/^(?:"(?:\\["bfnrt/()\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/,/^(?:(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3})\.(([0-9]){1,3}))/,/^(?:([0-9a-f])*:([0-9a-f])*:[:0-9a-f]*)/,/^(?:\/([0-9]){1,3})/,/^(?:[-a-zA-Z0-9_]+)/],
-conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53],"inclusive":true}}
-};
-return lexer;
-})();
-parser.lexer = lexer;
-function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
-return new Parser;
-})();
-if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
-exports.parser = parser;
-exports.Parser = parser.Parser;
-exports.parse = function () { return parser.parse.apply(parser, arguments); };
-exports.main = function commonjsMain(args) {
-    if (!args[1]) {
-        console.log('Usage: '+args[0]+' FILE');
-        process.exit(1);
-    }
-    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
-    return exports.parser.parse(source);
-};
-if (typeof module !== 'undefined' && require.main === module) {
-  exports.main(process.argv.slice(1));
-}
-}
diff --git a/deps/fw/tools/fwrule/lib/rule.js b/deps/fw/tools/fwrule/lib/rule.js
deleted file mode 100644
index d9eab02..0000000
--- a/deps/fw/tools/fwrule/lib/rule.js
+++ /dev/null
@@ -1,748 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * fwadm: firewall rule model
- */
-
-'use strict';
-
-var mod_net = require('net');
-var mod_uuid = require('node-uuid');
-var sprintf = require('extsprintf').sprintf;
-var util = require('util');
-var validators = require('./validators');
-var verror = require('verror');
-
-
-
-// --- Globals
-
-
-
-var DIRECTIONS = ['to', 'from'];
-// Exported fields that can be in the serialized rule:
-var FIELDS = [
-    'created_by',
-    'description',
-    'enabled',
-    'global',
-    'owner_uuid',
-    'rule',
-    'uuid',
-    'version'
-];
-// Maximum number of targets per side:
-var MAX_TARGETS_PER_SIDE = 24;
-// Maximum number of ports:
-var MAX_PORTS = 8;
-var STRING_PROPS = ['created_by', 'description'];
-var TARGET_TYPES = ['wildcard', 'ip', 'subnet', 'tag', 'vm'];
-
-var icmpr = /^icmp6?$/;
-
-// --- Internal functions
-
-
-/**
- * Safely check if an object has a property
- */
-function hasOwnProperty(obj, prop) {
-    return Object.prototype.hasOwnProperty.call(obj, prop);
-}
-
-
-/**
- * Calls callback for all of the firewall target types
- */
-function forEachTarget(obj, callback) {
-    DIRECTIONS.forEach(function (dir) {
-        if (!hasOwnProperty(obj, dir)) {
-            return;
-        }
-
-        TARGET_TYPES.forEach(function (type) {
-            var name = type + 's';
-            if (!hasOwnProperty(obj[dir], name)) {
-                return;
-            }
-
-            callback(dir, type, name, obj[dir][name]);
-        });
-    });
-}
-
-
-/**
- * Sorts a list of ICMP types (with optional codes)
- */
-function icmpTypeSort(types) {
-    return types.map(function (type) {
-        return type.toString().split(':');
-    }).sort(function (a, b) {
-        var aTot = (Number(a[0]) << 8) + (a.length === 1 ? 0 : Number(a[1]));
-        var bTot = (Number(b[0]) << 8) + (a.length === 1 ? 0 : Number(b[1]));
-        return aTot - bTot;
-    }).map(function (typeArr) {
-        return typeArr.join(':');
-    });
-}
-
-
-/**
- * Adds a tag to an object
- */
-function addTag(obj, tag, val) {
-    if (!hasOwnProperty(obj, tag)) {
-        obj[tag] = {};
-    }
-
-    if (val === undefined || val === null) {
-        obj[tag].all = true;
-        return;
-    }
-
-    if (!hasOwnProperty(obj[tag], 'values')) {
-        obj[tag].values = {};
-    }
-
-    obj[tag].values[val] = true;
-}
-
-
-/**
- * Creates a list of tags based on an object populated by addTag() above
- */
-function tagList(obj) {
-    var tags = [];
-    Object.keys(obj).sort().forEach(function (tag) {
-        if (hasOwnProperty(obj[tag], 'all')) {
-            tags.push(tag);
-        } else {
-            Object.keys(obj[tag].values).sort().forEach(function (val) {
-                tags.push([tag, val]);
-            });
-        }
-    });
-    return tags;
-}
-
-
-/**
- * The following characters are allowed to come after an escape, and get
- * escaped when producing rule text.
- *
- * Parentheses don't need to be escaped with newer parsers, but will cause
- * errors with older parsers which expect them to be escaped. We therefore
- * always escape them when generating rule text, to make sure we don't
- * cause issues for older parsers.
- */
-var escapes = {
-    '"': '"',
-    'b': '\b',
-    'f': '\f',
-    'n': '\n',
-    'r': '\r',
-    't': '\t',
-    '/': '/',
-    '(': '(',
-    ')': ')',
-    '\\': '\\'
-};
-
-
-/**
- * When producing text versions of a rule, we escape Unicode whitespace
- * characters. These characters don't need to be escaped, but we do so
- * to reduce the chance that an operator will look at a rule and mistake
- * any of them for the ASCII space character (\u0020), or not see them
- * because they're non-printing.
- */
-var unescapes = {
-    // Things that need to be escaped for the fwrule parser
-    '"': '"',
-    '(': '(',
-    ')': ')',
-    '\\': '\\',
-
-    // Special ASCII characters we don't want to print
-    '\u0000': 'u0000', // null (NUL)
-    '\u0001': 'u0001', // start of heading (SOH)
-    '\u0002': 'u0002', // start of text (STX)
-    '\u0003': 'u0003', // end of text (ETX)
-    '\u0004': 'u0004', // end of transmission (EOT)
-    '\u0005': 'u0005', // enquiry (ENQ)
-    '\u0006': 'u0006', // acknowledgement (ACK)
-    '\u0007': 'u0007', // bell (BEL)
-    '\u0008': 'b',     // backspace (BS)
-    '\u0009': 't',     // horizontal tab (HT)
-    '\u000A': 'n',     // newline (NL)
-    '\u000B': 'u000B', // vertical tab (VT)
-    '\u000C': 'f',     // form feed/next page (NP)
-    '\u000D': 'r',     // carriage return (CR)
-    '\u000E': 'u000E', // shift out (SO)
-    '\u000F': 'u000F', // shift in (SI)
-    '\u0010': 'u0010', // data link escape (DLE)
-    '\u0011': 'u0011', // device control 1 (DC1)/XON
-    '\u0012': 'u0012', // device control 2 (DC2)
-    '\u0013': 'u0013', // device control 3 (DC3)/XOFF
-    '\u0014': 'u0014', // device control 4 (DC4)
-    '\u0015': 'u0015', // negative acknowledgement (NAK)
-    '\u0016': 'u0016', // synchronous idle (SYN)
-    '\u0017': 'u0017', // end of transmission block (ETB)
-    '\u0018': 'u0018', // cancel (CAN)
-    '\u0019': 'u0019', // end of medium (EM)
-    '\u001A': 'u001A', // substitute (SUB)
-    '\u001B': 'u001B', // escape (ESC)
-    '\u001C': 'u001C', // file separator (FS)
-    '\u001D': 'u001D', // group separator (GS)
-    '\u001E': 'u001E', // record separator (RS)
-    '\u001F': 'u001F', // unit separator (US)
-    '\u007F': 'u007F', // delete (DEL)
-
-    // Unicode whitespace characters
-    '\u0085': 'u0085', // next line
-    '\u00A0': 'u00A0', // non-breaking space
-    '\u1680': 'u1680', // ogham space mark
-    '\u180E': 'u180E', // mongolian vowel separator
-    '\u2000': 'u2000', // en quad
-    '\u2001': 'u2001', // em quad
-    '\u2002': 'u2002', // en space
-    '\u2003': 'u2003', // em space
-    '\u2004': 'u2004', // three-per-em space
-    '\u2005': 'u2005', // four-per-em space
-    '\u2006': 'u2006', // six-per-em space
-    '\u2007': 'u2007', // figure space
-    '\u2008': 'u2008', // punctuation space
-    '\u2009': 'u2009', // thin space
-    '\u200A': 'u200A', // hair space
-    '\u200B': 'u200B', // zero width space
-    '\u200C': 'u200C', // zero width non-joiner
-    '\u200D': 'u200D', // zero width joiner
-    '\u2028': 'u2028', // line separator
-    '\u2029': 'u2029', // paragraph separator
-    '\u202F': 'u202F', // narrow no-break space
-    '\u205F': 'u205F', // medium mathematical space
-    '\u2060': 'u2060', // word joiner
-    '\u3000': 'u3000', // ideographic space
-    '\uFEFF': 'uFEFF'  // zero width no-break space
-};
-
-
-/**
- * Unescape a string that's been escaped so that it can be used
- * in a firewall rule.
- */
-function tagUnescape(ostr) {
-    var nstr = '';
-    var len = ostr.length;
-
-    for (var cur = 0; cur < len; cur += 1) {
-        var val = ostr[cur];
-        if (val === '\\') {
-            var escaped = ostr[cur + 1];
-            if (escaped === 'u') {
-                nstr += String.fromCharCode(
-                    parseInt(ostr.substring(cur + 2, cur + 6), 16));
-                cur += 5;
-            } else if (escapes[escaped] !== undefined) {
-                nstr += escapes[escaped];
-                cur += 1;
-            } else {
-                throw new Error('Invalid escape sequence "\\' + escaped + '"!');
-            }
-        } else {
-            nstr += val;
-        }
-    }
-
-    return nstr;
-}
-
-
-/**
- * Escape a string so that it can be placed, quoted, into a
- * firewall rule.
- */
-function tagEscape(ostr) {
-    var nstr = '';
-    var len = ostr.length;
-
-    for (var cur = 0; cur < len; cur += 1) {
-        var val = ostr[cur];
-        if (unescapes[val] !== undefined) {
-            nstr += '\\' + unescapes[val];
-        } else {
-            nstr += val;
-        }
-    }
-
-    return nstr;
-}
-
-
-/**
- * Quotes a string in case it contains non-alphanumeric
- * characters or keywords for firewall rules.
- */
-function quote(str) {
-    return '"' + tagEscape(str) + '"';
-}
-
-
-
-// --- Firewall object and methods
-
-
-
-/**
- * Firewall rule constructor
- */
-function FwRule(data, opts) {
-    var errs = [];
-    var parsed;
-
-    if (!opts) {
-        opts = {};
-    }
-
-    // -- validation --
-
-    if (!data.rule && !data.parsed) {
-        errs.push(new validators.InvalidParamError('rule',
-            'No rule specified'));
-    } else {
-        try {
-            parsed = data.parsed || require('./').parse(data.rule, opts);
-        } catch (err) {
-            errs.push(err);
-        }
-    }
-
-    if (hasOwnProperty(data, 'uuid')) {
-        if (!validators.validateUUID(data.uuid)) {
-            errs.push(new validators.InvalidParamError('uuid',
-                'Invalid rule UUID'));
-        }
-
-        this.uuid = data.uuid;
-    } else {
-        this.uuid = mod_uuid.v4();
-    }
-
-    this.version = data.version || generateVersion();
-
-    if (hasOwnProperty(data, 'owner_uuid')) {
-        if (!validators.validateUUID(data.owner_uuid)) {
-            errs.push(new validators.InvalidParamError('owner_uuid',
-                'Invalid owner UUID'));
-        }
-        this.owner_uuid = data.owner_uuid;
-    } else {
-        // No owner: this rule will affect all VMs
-        this.global = true;
-    }
-
-    if (hasOwnProperty(data, 'enabled')) {
-        if (!validators.bool(data.enabled)) {
-            errs.push(new validators.InvalidParamError('enabled',
-                'enabled must be true or false'));
-        }
-
-        this.enabled = data.enabled;
-    } else {
-        this.enabled = false;
-    }
-
-    for (var s in STRING_PROPS) {
-        var str = STRING_PROPS[s];
-        if (hasOwnProperty(data, str)) {
-            try {
-                validators.validateString(str, data[str]);
-                this[str] = data[str];
-            } catch (valErr) {
-                errs.push(valErr);
-            }
-        }
-    }
-
-    if (opts.enforceGlobal) {
-        if (hasOwnProperty(data, 'global') && !validators.bool(data.global)) {
-            errs.push(new validators.InvalidParamError('global',
-                'global must be true or false'));
-        }
-
-        if (hasOwnProperty(data, 'global')
-            && hasOwnProperty(data, 'owner_uuid') && data.global) {
-            errs.push(new validators.InvalidParamError('global',
-                'cannot specify both global and owner_uuid'));
-        }
-
-        if (!hasOwnProperty(data, 'global')
-            && !hasOwnProperty(data, 'owner_uuid')) {
-            errs.push(new validators.InvalidParamError('owner_uuid',
-                'owner_uuid required'));
-        }
-    }
-
-    if (errs.length !== 0) {
-        if (errs.length === 1) {
-            throw errs[0];
-        }
-
-        throw new verror.MultiError(errs);
-    }
-
-    // -- translate into the internal rule format --
-
-    var d;
-    var dir;
-
-    this.action = parsed.action;
-    this.protocol = parsed.protocol.name;
-
-    if (icmpr.test(this.protocol)) {
-        this.types = icmpTypeSort(parsed.protocol.targets);
-        this.protoTargets = this.types;
-    } else {
-        this.ports = parsed.protocol.targets.sort(function (a, b) {
-            var first = hasOwnProperty(a, 'start') ? a.start : a;
-            var second = hasOwnProperty(b, 'start') ? b.start : b;
-            return Number(first) - Number(second);
-        });
-        this.protoTargets = this.ports;
-    }
-
-    if (this.protoTargets.length > MAX_PORTS) {
-        throw new validators.InvalidParamError('rule',
-            'maximum of %d %s allowed',
-            MAX_TARGETS_PER_SIDE,
-            icmpr.test(this.protocol) ? 'types' : 'ports');
-    }
-
-    this.from = {};
-    this.to = {};
-
-    this.allVMs = false;
-    this.ips = {};
-    this.tags = {};
-    this.vms = {};
-    this.subnets = {};
-    this.wildcards = {};
-
-    var dirs = {
-        'to': {},
-        'from': {}
-    };
-    var numTargets;
-
-    for (d in DIRECTIONS) {
-        dir = DIRECTIONS[d];
-        numTargets = 0;
-        for (var j in parsed[dir]) {
-            var target = parsed[dir][j];
-            var targetName;
-            var name = target[0] + 's';
-
-            numTargets++;
-            if (!hasOwnProperty(dirs[dir], name)) {
-                dirs[dir][name] = {};
-            }
-
-            if (name === 'tags') {
-                var targetVal = null;
-                if (typeof (target[1]) === 'string') {
-                    targetName = target[1];
-                } else {
-                    targetName = target[1][0];
-                    targetVal = target[1][1];
-                }
-
-                addTag(this[name], targetName, targetVal);
-                addTag(dirs[dir][name], targetName, targetVal);
-
-            } else {
-                targetName = target[1];
-                this[name][targetName] = target[1];
-                dirs[dir][name][targetName] = target[1];
-            }
-        }
-
-        if (numTargets > MAX_TARGETS_PER_SIDE) {
-            throw new validators.InvalidParamError('rule',
-                'maximum of %d targets allowed per side',
-                MAX_TARGETS_PER_SIDE);
-        }
-    }
-
-    // Now dedup and sort
-    for (d in DIRECTIONS) {
-        dir = DIRECTIONS[d];
-        for (var t in TARGET_TYPES) {
-            var type = TARGET_TYPES[t] + 's';
-            if (hasOwnProperty(dirs[dir], type)) {
-                if (type === 'tags') {
-                    this[dir][type] = tagList(dirs[dir][type]);
-
-                } else {
-                    this[dir][type] = Object.keys(dirs[dir][type]).sort();
-                }
-            } else {
-                this[dir][type] = [];
-            }
-        }
-    }
-
-    this.ips = Object.keys(this.ips).sort();
-    this.tags = tagList(this.tags);
-    this.vms = Object.keys(this.vms).sort();
-    this.subnets = Object.keys(this.subnets).sort();
-    this.wildcards = Object.keys(this.wildcards).sort();
-
-    if (this.wildcards.length !== 0 && this.wildcards.indexOf('vmall') !== -1) {
-        this.allVMs = true;
-    }
-
-    // Check for rules that obviously don't make sense
-    if (this.protocol === 'icmp') {
-        this.ips.map(function (ip) {
-            if (!mod_net.isIPv4(ip)) {
-                throw new validators.InvalidParamError('rule',
-                    'rule affects ICMPv4 but contains a non-IPv4 address');
-            }
-        });
-        this.subnets.map(function (subnet) {
-            if (!mod_net.isIPv4(subnet.split('/')[0])) {
-                throw new validators.InvalidParamError('rule',
-                    'rule affects ICMPv4 but contains a non-IPv4 subnet');
-            }
-        });
-    } else if (this.protocol === 'icmp6') {
-        this.ips.map(function (ip) {
-            if (!mod_net.isIPv6(ip)) {
-                throw new validators.InvalidParamError('rule',
-                    'rule affects ICMPv6 but contains a non-IPv6 address');
-            }
-        });
-        this.subnets.map(function (subnet) {
-            if (!mod_net.isIPv6(subnet.split('/')[0])) {
-                throw new validators.InvalidParamError('rule',
-                    'rule affects ICMPv6 but contains a non-IPv6 subnet');
-            }
-        });
-    }
-
-    // Final check: does this rule actually contain targets that can actually
-    // affect VMs?
-    if (!this.allVMs && this.tags.length === 0 && this.vms.length === 0) {
-        throw new validators.InvalidParamError('rule',
-            'rule does not affect VMs');
-    }
-}
-
-
-/**
- * Returns the internal representation of the rule
- */
-FwRule.prototype.raw = function () {
-    var raw = {
-        action: this.action,
-        enabled: this.enabled,
-        from: this.from,
-        protocol: this.protocol,
-        to: this.to,
-        uuid: this.uuid,
-        version: this.version
-    };
-
-    if (this.owner_uuid) {
-        raw.owner_uuid = this.owner_uuid;
-    }
-
-    if (icmpr.test(this.protocol)) {
-        raw.types = this.types;
-    } else {
-        raw.ports = this.ports;
-    }
-
-    for (var s in STRING_PROPS) {
-        var str = STRING_PROPS[s];
-        if (hasOwnProperty(this, str)) {
-            raw[str] = this[str];
-        }
-    }
-
-    return raw;
-};
-
-
-/**
- * Returns the serialized version of the rule, suitable for storing
- *
- * @param fields {Array}: fields to return (optional)
- */
-FwRule.prototype.serialize = function (fields) {
-    var ser = {};
-    if (!fields) {
-        fields = FIELDS;
-    }
-
-    for (var f in fields) {
-        var field = fields[f];
-        if (field === 'rule') {
-            ser.rule = this.text();
-        } else if (field === 'global') {
-            // Only display the global flag if true
-            if (this.global) {
-                ser.global = true;
-            }
-        } else {
-            if (hasOwnProperty(this, field)) {
-                ser[field] = this[field];
-            }
-        }
-    }
-
-    return ser;
-};
-
-
-/**
- * Returns the text of the rule
- */
-FwRule.prototype.text = function () {
-    var containsRange;
-    var ports;
-    var protoTxt;
-    var targets = {
-        from: [],
-        to: []
-    };
-
-    forEachTarget(this, function (dir, type, _, arr) {
-        for (var i in arr) {
-            var txt;
-            if (type === 'tag') {
-                txt = util.format('%s %s', type,
-                    typeof (arr[i]) === 'string' ? quote(arr[i])
-                    : (quote(arr[i][0]) + ' = ' + quote(arr[i][1])));
-            } else {
-                txt = util.format('%s %s', type, arr[i]);
-            }
-
-            if (type === 'wildcard') {
-                txt = arr[i] === 'vmall' ? 'all vms' : arr[i];
-            }
-            targets[dir].push(txt);
-        }
-    });
-
-    // Protocol-specific text: different for ICMP rather than TCP/UDP
-    if (icmpr.test(this.protocol)) {
-        protoTxt = util.format('%sTYPE %s%s',
-            this.types.length > 1 ? '(' : '',
-            this.types.map(function (type) {
-                return type.toString().split(':');
-            }).map(function (code) {
-                return code[0] + (code.length === 1 ? '' : ' CODE ' + code[1]);
-            }).join(' AND TYPE '),
-            this.types.length > 1 ? ')' : ''
-        );
-    } else {
-        ports = this.ports.map(function (port) {
-            if (hasOwnProperty(port, 'start')
-                && hasOwnProperty(port, 'end')) {
-                /*
-                 * We only output PORTS when we have a range, since we don't
-                 * distinguish PORTS 1, 2 from (PORT 1 AND PORT 2) after
-                 * parsing.
-                 */
-                containsRange = true;
-                return port.start + ' - ' + port.end;
-            } else {
-                return port;
-            }
-        });
-        if (containsRange) {
-            protoTxt = util.format('PORTS %s', ports.join(', '));
-        } else {
-            protoTxt = util.format('%sPORT %s%s',
-                ports.length > 1 ? '(' : '',
-                ports.join(' AND PORT '),
-                ports.length > 1 ? ')' : ''
-            );
-        }
-    }
-
-    return util.format('FROM %s%s%s TO %s%s%s %s %s',
-            targets.from.length > 1 ? '(' : '',
-            targets.from.join(' OR '),
-            targets.from.length > 1 ? ')' : '',
-            targets.to.length > 1 ? '(' : '',
-            targets.to.join(' OR '),
-            targets.to.length > 1 ? ')' : '',
-            this.action.toUpperCase(),
-            this.protocol.toLowerCase(),
-            protoTxt
-    );
-};
-
-
-/**
- * Returns the string representation of the rule
- */
-FwRule.prototype.toString = function () {
-    return util.format('[%s,%s%s] %s', this.uuid, this.enabled,
-            (this.owner_uuid ? ',' + this.owner_uuid : ''),
-            this.text());
-};
-
-
-
-// --- Exported functions
-
-
-
-/**
- * Creates a new firewall rule from the payload
- */
-function createRule(payload, opts) {
-    return new FwRule(payload, opts);
-}
-
-
-function generateVersion() {
-    return Date.now(0) + '.' + sprintf('%06d', process.pid);
-}
-
-module.exports = {
-    create: createRule,
-    generateVersion: generateVersion,
-    tagEscape: tagEscape,
-    tagUnescape: tagUnescape,
-    DIRECTIONS: DIRECTIONS,
-    FIELDS: FIELDS,
-    FwRule: FwRule,
-    TARGET_TYPES: TARGET_TYPES
-};
diff --git a/deps/fw/tools/fwrule/lib/validators.js b/deps/fw/tools/fwrule/lib/validators.js
deleted file mode 100644
index 651df74..0000000
--- a/deps/fw/tools/fwrule/lib/validators.js
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- */
-
-/*
- * firewall rule parser: validation functions
- */
-
-'use strict';
-
-var net = require('net');
-var util = require('util');
-var VError = require('verror').VError;
-
-
-
-// --- Globals
-
-
-
-var icmpr = /^icmp6?$/;
-var portRE = /^[0-9]{1,5}$/;
-var UUID_REGEX =
-    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
-
-
-
-// --- Exports
-
-
-
-/**
- * Constructor for an invalid parameter error
- */
-function InvalidParamError(field) {
-    VError.apply(this, Array.prototype.slice.call(arguments, 1));
-    this.field = field;
-}
-
-util.inherits(InvalidParamError, VError);
-
-
-/**
- * Returns true if ip is a valid IPv4 address, and not all zeroes or
- * the broadcast address
- */
-function validateIPv4address(ip) {
-    if (!net.isIPv4(ip) || (ip === '255.255.255.255') || (ip === '0.0.0.0')) {
-        return false;
-    }
-
-    return true;
-}
-
-
-/**
- * Returns true if subnet is in valid CIDR form
- */
-function validateIPv4subnet(subnet) {
-    var parts = subnet.split('/');
-    if (!validateIPv4address(parts[0])) {
-        return false;
-    }
-
-    if (!Number(parts[1]) || (parts[1] < 1) || (parts[1] > 32)) {
-        return false;
-    }
-
-    return true;
-}
-
-
-/**
- * Returns true if subnet is a valid IPv6 CIDR range
- */
-function validateIPv6subnet(subnet) {
-    var parts = subnet.split('/');
-    var plen = Number(parts[1]);
-    if (!net.isIPv6(parts[0])) {
-        return false;
-    }
-
-    if (!plen || (plen < 1) || (plen > 128)) {
-        return false;
-    }
-
-    return true;
-}
-
-
-/**
- * Returns true if port is a valid port number
- */
-function validatePort(port) {
-    if (!portRE.exec(port)) {
-        return false;
-    }
-
-    var portNum = Number(port);
-
-    if (isNaN(portNum) || portNum > 65535 || portNum < 1) {
-        return false;
-    }
-
-    return true;
-}
-
-/**
- * Returns true if port is a valid port number or 'all'
- */
-function validatePortOrAll(port) {
-    if (validatePort(port)) {
-        return true;
-    }
-
-    if (typeof (port) !== 'string') {
-        return false;
-    }
-
-    if (port.toLowerCase() === 'all') {
-        return true;
-    }
-
-    return false;
-}
-
-/**
- * Returns true if protocol is one of tcp, udp, icmp (mixing of upper
- * and lower-case allowed)
- */
-function validateProtocol(protocol) {
-    if (typeof (protocol) !== 'string') {
-        return false;
-    }
-
-    var protoLC = protocol.toLowerCase();
-    return ((protoLC === 'tcp') || (protoLC === 'udp') || icmpr.test(protoLC));
-}
-
-
-/**
- * Returns true if action is a valid firewall action ('allow' or 'block',
- * mixed case allowed)
- */
-function validateAction(action) {
-    if (typeof (action) !== 'string') {
-        return false;
-    }
-
-    var actionLC = action.toLowerCase();
-    return ((actionLC === 'allow') || (actionLC === 'block'));
-}
-
-
-/**
- * Returns true if bool is a valid boolean value, false otherwise
- */
-function validateBoolean(bool) {
-    if (typeof (bool) !== 'boolean' && bool !== 'true' && bool !== 'false') {
-        return false;
-    }
-
-    return true;
-}
-
-
-/**
- * Throws an InvalidParamError if the string is invalid
- */
-function validateString(name, str) {
-    if (typeof (str) !== 'string') {
-        throw new InvalidParamError(name, name + ' must be a string');
-    }
-
-    if (str.length > 255) {
-        throw new InvalidParamError(name,
-            name + ' must be shorter than 255 characters');
-    }
-}
-
-
-/**
- * Returns true if uuid is a valid UUID
- */
-function validateUUID(uuid) {
-    return UUID_REGEX.test(uuid);
-}
-
-
-module.exports = {
-    bool: validateBoolean,
-    InvalidParamError: InvalidParamError,
-    validateAction: validateAction,
-    validateIPv4address: validateIPv4address,
-    validateIPv4subnet: validateIPv4subnet,
-    validateIPv6subnet: validateIPv6subnet,
-    validatePort: validatePort,
-    validatePortOrAll: validatePortOrAll,
-    validateProtocol: validateProtocol,
-    validateString: validateString,
-    validateUUID: validateUUID
-};
diff --git a/deps/fw/tools/fwrule/package.json b/deps/fw/tools/fwrule/package.json
deleted file mode 100644
index e3660f4..0000000
--- a/deps/fw/tools/fwrule/package.json
+++ /dev/null
@@ -1,33 +0,0 @@
-{
-  "name": "fwrule",
-  "description": "Parser for Joyent firewall rules",
-  "version": "1.3.1",
-  "author": "Joyent (joyent.com)",
-  "keywords": [ "smartos", "triton" ],
-  "repository": {
-    "type": "git",
-    "url": "git://github.com/joyent/sdc-fwrule.git"
-  },
-  "dependencies": {
-    "node-uuid": "1.2.0",
-    "extsprintf": "1.0.1",
-    "verror": "1.3.4"
-  },
-  "devDependencies": {
-    "eslint": "2.13.1",
-    "eslint-plugin-joyent": "1.0.1",
-    "faucet": "0.0.1",
-    "istanbul": "^0.4.0",
-    "jison": "0.4.2",
-    "tape": "^4.2.2",
-    "ramsey": "0.1.2"
-  },
-  "engines": {
-    "node": ">=0.10"
-  },
-  "main": "lib/index.js",
-  "scripts": {
-    "test": "make test"
-  },
-  "license": "CDDL-1.0"
-}
diff --git a/deps/fw/tools/fwrule/src/fwrule.jison b/deps/fw/tools/fwrule/src/fwrule.jison
deleted file mode 100644
index cc6140a..0000000
--- a/deps/fw/tools/fwrule/src/fwrule.jison
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * fwadm: firewall rule parser grammar
- */
-
-%lex
-
-digit                   [0-9]
-hex                     [0-9a-f]
-t                       {digit}{1,3}
-
-%%
-
-\s+                     /* skip whitespace */
-<<EOF>>                 return 'EOF';
-
-"FROM"                  return 'FROM';
-"from"                  return 'FROM';
-"TO"                    return 'TO';
-"to"                    return 'TO';
-
-"IP"                    return 'IP';
-"ip"                    return 'IP';
-"SUBNET"                return 'SUBNET';
-"subnet"                return 'SUBNET';
-"ANY"                   return 'ANY';
-"any"                   return 'ANY';
-"ALL"                   return 'ALL';
-"all"                   return 'ALL';
-"TAG"                   return 'TAG';
-"tag"                   return 'TAG';
-"VM"                    return 'VM';
-"vm"                    return 'VM';
-"VMS"                   return 'VMS';
-"vms"                   return 'VMS';
-
-'-'                     return '-';
-','                     return ',';
-'='                     return '=';
-'('                     return '(';
-')'                     return ')';
-"OR"                    return 'OR';
-"or"                    return 'OR';
-"AND"                   return 'AND';
-"and"                   return 'AND';
-
-"BLOCK"                 return 'BLOCK';
-"block"                 return 'BLOCK';
-"ALLOW"                 return 'ALLOW';
-"allow"                 return 'ALLOW';
-"PORT"                  return 'PORT';
-"port"                  return 'PORT';
-"PORTS"                 return 'PORTS';
-"ports"                 return 'PORTS';
-"TCP"                   return 'TCP';
-"tcp"                   return 'TCP';
-"UDP"                   return 'UDP';
-"udp"                   return 'UDP';
-"ICMP"                  return 'ICMP';
-"icmp"                  return 'ICMP';
-"ICMP6"                 return 'ICMP6';
-"icmp6"                 return 'ICMP6';
-"TYPE"                  return 'TYPE';
-"type"                  return 'TYPE';
-"CODE"                  return 'CODE';
-"code"                  return 'CODE';
-
-\"(?:\\["bfnrt/()\\]|\\"u"[a-fA-F0-9]{4}|[^"\\])*\"  yytext = yy.tagUnescape(yytext.substr(1,yyleng-2)); return 'STRING';
-{t}'.'{t}'.'{t}'.'{t}          return 'IPV4ADDR';
-{hex}*':'{hex}*':'[:0-9a-f]*   return 'IPV6ADDR';
-'/'{digit}{1,3}                return 'CIDRSUFFIX';
-
-[-a-zA-Z0-9_]+          return 'WORD'
-
-/lex
-
-%%      /* Language grammar */
-
-start
-    : FROM target_list TO target_list action protocol EOF
-        { return { 'from': $2, 'to': $4, 'action': $5, 'protocol': $6 }; }
-    ;
-
-
-/* List of targets for 'FROM' and 'TO' */
-target_list
-    : any
-    | all
-    | '(' target_or_list ')'
-        {$$ = $2;}
-    | target
-    ;
-
-target_or_list
-    : target
-    | target_or_list 'OR' target
-        { $$ = $1.concat($3); }
-    ;
-
-target
-    : ipv4
-    | ipv4_subnet
-    | ipv6
-    | ipv6_subnet
-    | tag
-    | vm
-    ;
-
-
-/* Targets for 'FROM' and 'TO' */
-all
-    : ALL VMS
-        { $$ = [ ['wildcard', 'vmall'] ]; }
-    | '(' ALL VMS ')'
-        { $$ = [ ['wildcard', 'vmall'] ]; }
-    ;
-
-any
-    : ANY
-        { $$ = [ ['wildcard', 'any'] ]; }
-    | '(' ANY ')'
-        { $$ = [ ['wildcard', 'any'] ]; }
-    ;
-
-ipv4
-    : IP IPV4ADDR
-        { yy.validateIPv4address($2);
-          $$ = [ ['ip', $2] ]; }
-    ;
-
-ipv4_subnet
-    : SUBNET IPV4ADDR CIDRSUFFIX
-        { yy.validateIPv4subnet($2 + $3);
-            $$ = [ ['subnet', $2 + $3] ]; }
-    ;
-
-ipv6
-    : IP IPV6ADDR
-        { yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6address($2);
-          $$ = [ ['ip', $2] ]; }
-    ;
-
-ipv6_subnet
-    : SUBNET IPV6ADDR CIDRSUFFIX
-        { yy.validateOKVersion(3, 'IPv6');
-          yy.validateIPv6subnet($2 + $3);
-            $$ = [ ['subnet', $2 + $3] ]; }
-    ;
-
-vm
-    : VM uuid
-        { $$ = [ ['vm', $2] ]; }
-    ;
-
-uuid
-    : WORD
-        { yy.validateUUID($1);
-          $$ = $1; }
-    ;
-
-tag
-    : TAG tag_string
-        { $$ = [ ['tag', $2] ]; }
-    | TAG tag_string '=' tag_string
-        { $$ = [ ['tag', [ $2, $4 ] ] ]; }
-    ;
-
-tag_string
-    : STRING
-        { $$ = yytext; }
-    | WORD
-        { $$ = $1; }
-    ;
-
-action
-    : BLOCK
-        { $$ = $1.toLowerCase() }
-    | ALLOW
-        { $$ = $1.toLowerCase() }
-    ;
-
-
-protocol
-    : TCP port_list
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | TCP ports
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | UDP port_list
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | UDP ports
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | ICMP type_list
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    | ICMP6 type_list
-        { $$ = { 'name': $1.toLowerCase(), 'targets': $2 } }
-    ;
-
-
-/* TCP / UDP port list */
-port_list
-    : '(' port_and_list ')'
-        { $$ = $2; }
-    | port
-    | '(' port_all ')'
-        { $$ = $2; }
-    | port_all
-    ;
-
-port_and_list
-    : port
-    | port_and_list AND port
-        { $$ = $1.concat(Number($3)); }
-    ;
-
-port
-    : PORT portnumber
-        { $$ = [ $2 ]; }
-    ;
-
-ports
-    : PORTS portnumbers
-        { yy.validateOKVersion(2, 'port ranges');
-          $$ = $2; }
-    ;
-
-port_all
-    : PORT ALL
-        { $$ = [ 'all' ]; }
-    ;
-
-portnumber
-    : WORD
-        { yy.validatePortNumber($1);
-          $$ = Number($1); }
-    ;
-
-portrange
-    : WORD
-        { $$ = [ yy.createMaybePortRange($1) ]; }
-    | WORD '-' WORD
-        { yy.validatePortNumber($1);
-          yy.validatePortNumber($3);
-          yy.validateRangeOrder($1, $3);
-          $$ = [{ 'start': Number($1), 'end': Number($3) }]; }
-    ;
-
-portnumbers
-    : portrange
-    | portnumbers ',' portrange
-        { $$ = $1.concat($3); }
-    ;
-
-type_list
-    : '(' type_and_list ')'
-        { $$ = $2; }
-    | type
-    | '(' type_all ')'
-        { $$ = $2; }
-    | type_all
-    ;
-
-type_and_list
-    : type
-    | type_and_list AND type
-        { $$ = $1.concat($3); }
-    ;
-
-type
-    : TYPE icmptype CODE icmpcode
-        { $$ = [ $2 + ':' + $4 ]; }
-    | TYPE icmptype
-        { $$ = [ $2 ]; }
-    ;
-
-type_all
-    : TYPE ALL
-        { yy.validateOKVersion(3, 'all ICMP types');
-          $$ = [ 'all' ]; }
-    ;
-
-icmptype
-    : WORD
-        { yy.validateICMPtype($1);
-          $$ = Number($1); }
-    ;
-
-icmpcode
-    : WORD
-        { yy.validateICMPcode($1);
-          $$ = Number($1); }
-    ;
diff --git a/deps/fw/tools/fwrule/src/header.js b/deps/fw/tools/fwrule/src/header.js
deleted file mode 100644
index c7e8f7a..0000000
--- a/deps/fw/tools/fwrule/src/header.js
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * fwadm: firewall rule parser
- */
-
-
diff --git a/deps/fw/tools/fwrule/test/invalid.test.js b/deps/fw/tools/fwrule/test/invalid.test.js
deleted file mode 100644
index 379899c..0000000
--- a/deps/fw/tools/fwrule/test/invalid.test.js
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * Negative unit tests for the firewall rule object
- */
-
-'use strict';
-
-var fwrule = require('../lib/index');
-var test = require('tape');
-
-
-function longStr() {
-    var str = '';
-    for (var i = 0; i < 256; i++) {
-        str += '0';
-    }
-
-    return str;
-}
-
-
-function nIPs(n) {
-    var ips = [];
-    for (var i = 0; i < n; i++) {
-        ips.push('10.0.0.' + i);
-    }
-
-    return '( ip ' + ips.join(' OR ip ') + ' )';
-}
-
-
-function nPorts(n) {
-    var ports = [];
-    for (var i = 0; i < n; i++) {
-        ports.push('1' + i);
-    }
-
-    return '( port ' + ports.join(' AND port ') + ' )';
-}
-
-
-function nTypes(n) {
-    var types = [];
-    for (var i = 0; i < n; i++) {
-        types.push(i.toString());
-    }
-
-    return '( type ' + types.join(' AND type ') + ' )';
-}
-
-
-
-var VALID_RULE = 'FROM ip 10.0.0.1 TO all vms ALLOW TCP port 53';
-var INVALID = [
-    [ 'invalid IP: too many numbers',
-        {
-            rule: 'FROM ip 10.99.99.99.254 TO tag smartdc_role ALLOW tcp '
-                + 'port 22' },
-            'rule', 'Error at character 19: \'.254 TO tag smartdc_\', '
-                            + 'found: unexpected text'],
-
-    [ 'invalid UUID',
-        { uuid: 'invalid',
-            rule: 'FROM tag foo TO ip 8.8.8.8 ALLOW udp port 53'
-        }, 'uuid', 'Invalid rule UUID' ],
-
-    [ 'invalid owner UUID',
-        { owner_uuid: 'invalid',
-            rule: 'FROM tag foo TO ip 8.8.8.8 ALLOW udp port 53'
-        }, 'owner_uuid', 'Invalid owner UUID' ],
-
-    [ 'non-target type in FROM',
-        { rule: 'FROM foo TO ip 8.8.8.8 ALLOW udp port 53' },
-        'rule', 'Error at character 4: \'foo\', '
-                        + 'expected: \'(\', \'all\', \'any\', \'ip\', '
-                        + '\'subnet\', \'vm\', \'tag\', found: word'],
-
-    [ 'invalid IPv4',
-        { rule: 'FROM tag foo TO ip 10.288.0.0 ALLOW udp port 53' },
-        'rule', 'IPv4 address "10.288.0.0" is invalid' ],
-
-    [ 'invalid IPv6',
-        { rule: 'FROM tag foo TO ip fd00::12345 ALLOW udp port 53' },
-        'rule', 'IPv6 address "fd00::12345" is invalid' ],
-
-    [ 'invalid IPv4 subnet: bad address component',
-        { rule: 'FROM tag foo TO subnet 10.350.0.0/24 ALLOW udp port 53' },
-        'rule', 'Subnet "10.350.0.0/24" is invalid (must be in CIDR format)' ],
-
-    [ 'invalid IPv4 subnet: bad prefix length',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/33 ALLOW udp port 53' },
-        'rule', 'Subnet "10.8.0.0/33" is invalid (must be in CIDR format)' ],
-
-    [ 'invalid IPv6 subnet: bad address component',
-        { rule: 'FROM tag foo TO subnet fd005::/64 ALLOW udp port 53' },
-        'rule', 'Subnet "fd005::/64" is invalid (must be in CIDR format)' ],
-
-    [ 'invalid IPv6 subnet: bad prefix length',
-        { rule: 'FROM tag foo TO subnet fd00::/130 ALLOW udp port 53' },
-        'rule', 'Subnet "fd00::/130" is invalid (must be in CIDR format)' ],
-
-    [ 'invalid port: too small',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW udp port 0' },
-        'rule', 'Port number "0" is invalid' ],
-
-    [ 'invalid port: too big',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW udp port 65537' },
-        'rule', 'Port number "65537" is invalid' ],
-
-    [ 'invalid port range: too many numbers',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 1-20-30' },
-        'rule', '"1-20-30" is not a valid port number or range' ],
-
-    [ 'invalid port range: too small',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 0-20' },
-        'rule', 'Port number "0" is invalid' ],
-
-    [ 'invalid port range: too big',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 20-65537' },
-        'rule', 'Port number "65537" is invalid' ],
-
-    [ 'invalid port range: not a port (at end)',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 20-bar' },
-        'rule', 'Port number "bar" is invalid' ],
-
-    [ 'invalid port range: not a port (at beginning)',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports bar-20' },
-        'rule', 'Port number "bar" is invalid' ],
-
-    [ 'invalid port range: incorrect range ordering',
-        { rule: 'FROM tag foo TO subnet 10.8.0.0/24 ALLOW tcp ports 20 - 10' },
-        'rule',
-        'The end of the range (10) cannot be less than the start (20)' ],
-
-    [ 'invalid VM UUID',
-        { rule: 'FROM vm asdf TO subnet 10.8.0.0/24 ALLOW udp port 50' },
-        'rule', 'UUID "asdf" is invalid'],
-
-    [ 'all vms with other targets on FROM side',
-        { rule: 'FROM (all vms OR tag one) TO ip 10.0.0.1 ALLOW udp port 53' },
-        'rule', 'Error at character 13: \'OR\', expected: \')\', found: OR' ],
-
-    [ 'all vms with other targets on TO side',
-        { rule: 'FROM tag one TO (all vms OR tag two) ALLOW udp port 53' },
-        'rule', 'Error at character 24: \'OR\', expected: \')\', found: OR' ],
-
-    [ 'any with other targets on FROM side',
-        { rule: 'FROM (any OR tag one) TO ip 10.0.0.1 ALLOW udp port 53' },
-        'rule', 'Error at character 9: \'OR\', expected: \')\', found: OR' ],
-
-    [ 'any with other targets on TO side',
-        { rule: 'FROM ip 10.0.0.1 TO (any OR tag one) ALLOW udp port 53' },
-        'rule', 'Error at character 24: \'OR\', expected: \')\', found: OR' ],
-
-    [ 'other ports listed with ALL first', {
-        rule: 'FROM ip 10.0.0.1 TO all vms ALLOW TCP (port ALL AND port 53)' },
-        'rule',
-        'Error at character 47: \'AND\', expected: \'EOF\', \')\', found: AND'
-    ],
-
-    [ 'other ports listed with ALL second', {
-        rule: 'FROM ip 10.0.0.1 TO all vms ALLOW TCP (port 53 AND port ALL)'
-        }, 'rule',
-        'Error at character 55: \'ALL\', expected: \'WORD\', found: ALL' ],
-
-    [ 'created_by: object instead of string', {
-        created_by: { },
-        rule: VALID_RULE
-        }, 'created_by',
-        'created_by must be a string'],
-
-    [ 'created_by: array instead of string', {
-        created_by: ['asdf'],
-        rule: VALID_RULE
-        }, 'created_by',
-        'created_by must be a string'],
-
-    [ 'created_by: number instead of string', {
-        created_by: 42,
-        rule: VALID_RULE
-        }, 'created_by',
-        'created_by must be a string'],
-
-    [ 'created_by: string too long', {
-        created_by: longStr(),
-        rule: VALID_RULE
-        }, 'created_by',
-        'created_by must be shorter than 255 characters'],
-
-    [ 'description: object instead of string', {
-        description: { },
-        rule: VALID_RULE
-        }, 'description',
-        'description must be a string'],
-
-    [ 'description: array instead of string', {
-        description: ['asdf'],
-        rule: VALID_RULE
-        }, 'description',
-        'description must be a string'],
-
-    [ 'description: number instead of string', {
-        description: 42,
-        rule: VALID_RULE
-        }, 'description',
-        'description must be a string'],
-
-    [ 'description: string too long', {
-        description: longStr(),
-        rule: VALID_RULE
-        }, 'description',
-        'description must be shorter than 255 characters'],
-
-    [ 'rule: from any to any', {
-        rule: 'FROM any TO any ALLOW TCP port 53'
-        }, 'rule',
-        'rule does not affect VMs'],
-
-    [ 'rule: from any to any', {
-        rule: 'FROM any TO any ALLOW TCP port 53'
-        }, 'rule',
-        'rule does not affect VMs'],
-
-    [ 'rule: from ip to subnet', {
-        rule: 'FROM ip 10.8.0.1 TO subnet 10.9.0.0/16 ALLOW TCP port 53'
-        }, 'rule',
-        'rule does not affect VMs'],
-
-    [ 'rule: from ip to any', {
-        rule: 'FROM ip 10.9.0.1 TO any ALLOW TCP port 53'
-        }, 'rule',
-        'rule does not affect VMs'],
-
-    [ 'global: not boolean', {
-        rule: VALID_RULE,
-        global: 'asdf'
-        }, 'global',
-        'global must be true or false'],
-
-    [ 'both global and owner_uuid set', {
-        rule: VALID_RULE,
-        global: true,
-        owner_uuid: 'e7d9d022-6272-11e3-a746-131978000f45'
-        }, 'global',
-        'cannot specify both global and owner_uuid'],
-
-    [ 'rule: max number per side', {
-        rule: 'FROM ' + nIPs(25) + ' TO all vms ALLOW TCP port 53'
-        }, 'rule',
-        'maximum of 24 targets allowed per side'],
-
-    [ 'rule: max number per side', {
-        rule: 'FROM all vms TO ' + nIPs(25) + ' BLOCK TCP port 53'
-        }, 'rule',
-        'maximum of 24 targets allowed per side'],
-
-    [ 'rule: max number of ports', {
-        rule: 'FROM all vms TO ip 192.168.5.4 BLOCK TCP ' + nPorts(9)
-        }, 'rule',
-        'maximum of 24 ports allowed'],
-
-    [ 'rule: bad ip target for ICMPv4', {
-        rule: 'FROM all vms TO ip fd00::45 BLOCK ICMP TYPE 8'
-        }, 'rule',
-        'rule affects ICMPv4 but contains a non-IPv4 address'],
-
-    [ 'rule: bad subnet target for ICMPv4', {
-        rule: 'FROM all vms TO subnet fe80::/64 BLOCK ICMP TYPE 8'
-        }, 'rule',
-        'rule affects ICMPv4 but contains a non-IPv4 subnet'],
-
-    [ 'rule: bad ip target for ICMPv6', {
-        rule: 'FROM all vms TO ip 1.2.3.4 BLOCK ICMP6 TYPE 128'
-        }, 'rule',
-        'rule affects ICMPv6 but contains a non-IPv6 address'],
-
-    [ 'rule: bad subnet target for ICMPv6', {
-        rule: 'FROM all vms TO subnet 10.0.0.0/8 BLOCK ICMP6 TYPE 128'
-        }, 'rule',
-        'rule affects ICMPv6 but contains a non-IPv6 subnet'],
-
-    [ 'rule: bad ICMP type', {
-        rule: 'FROM all vms TO ip 192.168.5.4 BLOCK ICMP TYPE 260'
-        }, 'rule',
-        'ICMP type \"260\" is invalid'],
-
-    [ 'rule: bad ICMP code', {
-        rule: 'FROM all vms TO ip 192.168.5.4 BLOCK ICMP TYPE 8 CODE 270'
-        }, 'rule',
-        'ICMP code \"270\" is invalid'],
-
-    [ 'rule: bad ICMPv6 type', {
-        rule: 'FROM all vms TO ip fd00::45 BLOCK ICMP6 TYPE 260'
-        }, 'rule',
-        'ICMP type \"260\" is invalid'],
-
-    [ 'rule: bad ICMPv6 code', {
-        rule: 'FROM all vms TO ip fd00::45 BLOCK ICMP6 TYPE 128 CODE 270'
-        }, 'rule',
-        'ICMP code \"270\" is invalid'],
-
-    [ 'rule: max number of ICMPv6 types', {
-        rule: 'FROM all vms TO ip fd00::45 BLOCK ICMP ' + nTypes(9)
-        }, 'rule',
-        'maximum of 24 types allowed'],
-
-    [ 'rule: max number of ICMP types', {
-        rule: 'FROM all vms TO ip 192.168.5.4 BLOCK ICMP ' + nTypes(9)
-        }, 'rule',
-        'maximum of 24 types allowed']
-];
-
-
-test('Invalid rules', function (t) {
-    INVALID.forEach(function (data) {
-        var testName = data[0];
-        var expMsg = data[3];
-        var field = data[2];
-        var opts;
-        var rule = data[1];
-        var thrown = false;
-
-        try {
-            opts = (field === 'global' ? { enforceGlobal: true } : {});
-            fwrule.create(rule, opts);
-        } catch (err) {
-            thrown = true;
-            t.equal(err.message, expMsg, 'Error message correct: ' + testName);
-            t.equal(err.field, field, 'Error field correct: ' + testName);
-        }
-
-        t.ok(thrown, 'Error thrown: ' + testName);
-    });
-
-    t.end();
-});
-
-
-test('Invalid parameters', function (t) {
-    var thrown = false;
-    var invalid = {
-        enabled: 'invalid',
-        rule: 'invalid',
-        owner_uuid: 'invalid',
-        uuid: 'invalid'
-    };
-
-    try {
-        fwrule.create(invalid);
-    } catch (err) {
-        thrown = true;
-
-        t.ok(err.hasOwnProperty('ase_errors'), 'multiple errors');
-        if (err.hasOwnProperty('ase_errors')) {
-            t.equal(err.ase_errors.length, 4, '4 sub-errors');
-            t.deepEqual(err.ase_errors.map(function (e) {
-                return [ e.field, e.message ];
-            }), [
-                ['rule', 'Error at character 0: \'invalid\', '
-                    + 'expected: \'FROM\', found: word'],
-                ['uuid', 'Invalid rule UUID'],
-                ['owner_uuid', 'Invalid owner UUID'],
-                ['enabled', 'enabled must be true or false']
-            ], 'sub-errors');
-        }
-    }
-
-    t.ok(thrown, 'error thrown');
-    t.end();
-});
-
-
-test('Missing rule field', function (t) {
-    var thrown = false;
-
-    try {
-        fwrule.create({});
-    } catch (err) {
-        thrown = true;
-        t.equal(err.message, 'No rule specified', 'error message');
-        t.equal(err.field, 'rule', 'err.field');
-    }
-
-    t.ok(thrown, 'error thrown');
-    t.end();
-});
-
-
-test('global and owner_uuid not set', function (t) {
-    var thrown = false;
-
-    try {
-        fwrule.create({
-            rule: 'FROM any to all vms ALLOW tcp port 80'
-        }, { enforceGlobal: true });
-    } catch (err) {
-        thrown = true;
-        t.equal(err.message, 'owner_uuid required', 'error message');
-        t.equal(err.field, 'owner_uuid', 'err.field');
-    }
-
-    t.ok(thrown, 'error thrown');
-    t.end();
-});
diff --git a/deps/fw/tools/fwrule/test/parser.test.js b/deps/fw/tools/fwrule/test/parser.test.js
deleted file mode 100644
index 55373eb..0000000
--- a/deps/fw/tools/fwrule/test/parser.test.js
+++ /dev/null
@@ -1,602 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * Unit tests for the firewall rule parser
- */
-
-'use strict';
-
-var util = require('util');
-var parser = require('../lib/index');
-var test = require('tape');
-
-
-// --- Helpers
-
-function checkInvalidRules(t, toCheck) {
-    toCheck.forEach(function (rule) {
-        try {
-            parser.parse(rule);
-            t.fail('Parsing bad rule didn\'t fail: ' + rule);
-        } catch (err) {
-            t.ok(err.message, 'Failed to parse bad rule: ' + rule);
-        }
-    });
-
-    t.end();
-}
-
-
-// --- Tests
-
-
-test('empty input', function (t) {
-    try {
-        parser.parse('');
-        t.ok(false, 'Empty input to the parser should throw!');
-    } catch (err) {
-        t.deepEqual(err.message,
-            'Error at character 0: \'\', expected: \'FROM\', '
-            + 'found: empty string');
-    }
-    t.end();
-});
-
-
-test('tags', function (t) {
-    t.deepEqual(parser.parse(
-        'FROM ip 1.2.3.4 TO tag some-tag ALLOW tcp PORT 80'),
-        { from: [ [ 'ip', '1.2.3.4' ] ],
-            to: [ [ 'tag', 'some-tag' ] ],
-            action: 'allow',
-            protocol: {
-                name: 'tcp',
-                targets: [ 80 ]
-            }
-        }, 'tag containing dashes');
-
-    t.end();
-});
-
-
-test('icmp', function (t) {
-    var vm = 'b0b92cd9-1fe7-4636-8477-81d2742566c2';
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp type 8', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ 8 ]
-            }
-        }, 'icmp with type');
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp type 8 code 0', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ '8:0' ]
-            }
-        }, 'icmp with type and code');
-
-    t.end();
-});
-
-
-test('case insensitivity', function (t) {
-    var vm = 'b5ff85db-fc33-4471-b045-5688cb7fa6a8';
-    var ipToTag = {
-        from: [ [ 'ip', '1.2.3.4' ] ],
-        to: [ [ 'tag', 'some-tag' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'tcp',
-            targets: [ 80 ]
-        }
-    };
-
-    var anyToVM = {
-        from: [ [ 'wildcard', 'any' ] ],
-        to: [ [ 'vm', vm ] ],
-        action: 'allow',
-        protocol: {
-            name: 'udp',
-            targets: [ 50 ]
-        }
-    };
-
-    var subnetToAll = {
-        from: [ [ 'subnet', '10.8.0.0/16' ] ],
-        to: [ [ 'wildcard', 'vmall' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'icmp',
-            targets: [ 30 ]
-        }
-    };
-
-    var ipTag = {
-        from: [ [ 'subnet', '10.8.0.0/16' ],
-                        [ 'ip', '10.9.0.1' ] ],
-        to: [ [ 'wildcard', 'vmall' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'icmp',
-            targets: [ '8:0', 9 ]
-        }
-    };
-
-    [
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP PORTS 80', ipToTag ],
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP ports 80', ipToTag ],
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP PORT 80', ipToTag ],
-        [ 'from ip 1.2.3.4 to tag some-tag allow tcp port 80', ipToTag ],
-        [ util.format('from ANY to VM %s allow UDP ports 50', vm), anyToVM ],
-        [ util.format('from any to vm %s allow udp ports 50', vm), anyToVM ],
-        [ util.format('from ANY to VM %s allow UDP port 50', vm), anyToVM ],
-        [ util.format('from any to vm %s allow udp port 50', vm), anyToVM ],
-        [ 'FROM SUBNET 10.8.0.0/16 TO ALL VMS ALLOW ICMP TYPE 30',
-            subnetToAll ],
-        [ 'FROM subnet 10.8.0.0/16 TO all vms ALLOW icmp type 30',
-            subnetToAll ],
-        [ 'FROM (subnet 10.8.0.0/16 OR ip 10.9.0.1) TO all vms ALLOW '
-            + 'icmp (TYPE 8 CODE 0 AND TYPE 9)', ipTag ],
-        [ 'FROM (subnet 10.8.0.0/16 OR ip 10.9.0.1) TO all vms ALLOW '
-            + 'icmp (type 8 code 0 and type 9)', ipTag ]
-
-    ].forEach(function (data) {
-        try {
-            t.deepEqual(parser.parse(data[0]), data[1], data[0]);
-        } catch (err) {
-            t.ifError(err, data[0]);
-        }
-    });
-
-    t.end();
-});
-
-
-test('parentheses around wildcards', function (t) {
-    var anyToAll = {
-        from: [ [ 'wildcard', 'any' ] ],
-        to: [ [ 'wildcard', 'vmall' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'udp',
-            targets: [ 50 ]
-        }
-    };
-
-    [
-        [ 'from (ANY) to ALL VMS allow UDP ports 50', anyToAll ],
-        [ 'from (any) to all vms allow udp ports 50', anyToAll ],
-        [ 'from ANY to (ALL VMS) allow UDP ports 50', anyToAll ],
-        [ 'from any to (all vms) allow udp ports 50', anyToAll ],
-        [ 'FROM ( ANY ) TO ALL VMS ALLOW UDP ports 50', anyToAll ],
-        [ 'FROM ( ANY ) TO all vms ALLOW udp ports 50', anyToAll ],
-        [ 'from ANY to ( ALL VMS ) allow UDP ports 50', anyToAll ],
-        [ 'from any to ( all vms ) allow udp ports 50', anyToAll ],
-        [ 'from ( any ) to ( all vms ) allow udp ports 50', anyToAll ],
-        [ 'from (any) to (all vms) allow udp ports 50', anyToAll ]
-    ].forEach(function (data) {
-        try {
-            t.deepEqual(parser.parse(data[0]), data[1], data[0]);
-        } catch (err) {
-            t.ifError(err, data[0]);
-        }
-    });
-
-    t.end();
-});
-
-
-test('incomplete rule text', function (t) {
-    var check = [ ];
-
-    var to = [ 'TO' ];
-    var targets = [
-        'any', 'all vms', 'ip 1.2.3.4', 'ip fd00::1', 'subnet 1.2.3.0/24',
-        'subnet fd00::/64', 'tag foo', 'tag foo = bar',
-        'vm ca3eb1d6-1555-44fb-ea1a-ab66f4685214'
-    ];
-    var endings = [ 'port', 'ports', 'ports 1 -', 'ports 1-', 'type',
-        'type 128 code' ];
-
-    function buildStr(str, remains) {
-        check.push(str);
-
-        if (remains[0] !== undefined) {
-            remains[0].forEach(function (strB) {
-                buildStr(str + ' ' + strB, remains.slice(1));
-            });
-        }
-    }
-
-    buildStr('FROM',
-        [ targets, to, targets, parser.ACTIONS, parser.PROTOCOLS, endings ]);
-
-    checkInvalidRules(t, check);
-});
-
-
-test('Invalid: Logical operations', function (t) {
-    checkInvalidRules(t, [
-        'FROM (tag a foo tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a xor tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a nand tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a not tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a nor tag b) TO any ALLOW tcp PORT 80',
-        'FROM (tag a xnor tag b) TO any ALLOW tcp PORT 80'
-    ]);
-});
-
-
-test('Invalid: Actions', function (t) {
-    checkInvalidRules(t, [
-        'FROM any TO any DENY tcp PORT 80',
-        'FROM any TO any FORWARD tcp PORT 80',
-        'FROM any TO any OBSTRUCT tcp PORT 80',
-        'FROM any TO any PASS tcp PORT 80',
-        'FROM any TO any PASSTHROUGH tcp PORT 80',
-        'FROM any TO any PERMIT tcp PORT 80'
-    ]);
-});
-
-
-test('Invalid: Protocols', function (t) {
-    checkInvalidRules(t, [
-        'FROM any TO any ALLOW foo PORT 80',
-        'FROM any TO any ALLOW bar PORT 80',
-        'FROM any TO any ALLOW ftp PORT 80',
-        'FROM any TO any ALLOW ssh PORT 80',
-        'FROM any TO any ALLOW http PORT 80',
-        'FROM any TO any ALLOW sctp PORT 80',
-        'FROM any TO any ALLOW dccp PORT 80',
-        'FROM any TO any ALLOW mtcp PORT 80'
-    ]);
-});
-
-test('Invalid: Parameters for TCP & UDP', function (t) {
-    checkInvalidRules(t, [
-        'FROM any TO any ALLOW tcp PORT hello',
-        'FROM any TO any ALLOW udp PORT hello',
-        'FROM any TO any ALLOW tcp PORT ssh',
-        'FROM any TO any ALLOW udp PORT ssh',
-        'FROM any TO any ALLOW tcp PORT _',
-        'FROM any TO any ALLOW udp PORT _',
-        'FROM any TO any ALLOW tcp PORT *',
-        'FROM any TO any ALLOW udp PORT *',
-        'FROM any TO any ALLOW tcp PORTS hello',
-        'FROM any TO any ALLOW udp PORTS hello',
-        'FROM any TO any ALLOW tcp PORTS ssh',
-        'FROM any TO any ALLOW udp PORTS ssh',
-        'FROM any TO any ALLOW tcp PORTS ssh-http',
-        'FROM any TO any ALLOW udp PORTS ssh-http',
-        'FROM any TO any ALLOW tcp PORTS _',
-        'FROM any TO any ALLOW udp PORTS _',
-        'FROM any TO any ALLOW tcp PORTS *',
-        'FROM any TO any ALLOW udp PORTS *',
-        'FROM any TO any ALLOW tcp TYPE 128',
-        'FROM any TO any ALLOW udp TYPE 128',
-        'FROM any TO any ALLOW tcp TYPE 128 CODE 0',
-        'FROM any TO any ALLOW udp TYPE 128 CODE 0'
-    ]);
-});
-
-test('Invalid: Parameters for ICMP(6)', function (t) {
-    checkInvalidRules(t, [
-        'FROM any TO any ALLOW icmp PORT 80',
-        'FROM any TO any ALLOW icmp6 PORT 80',
-        'FROM any TO any ALLOW icmp PORTS 80',
-        'FROM any TO any ALLOW icmp6 PORTS 80',
-        'FROM any TO any ALLOW icmp PORTS 80-85',
-        'FROM any TO any ALLOW icmp6 PORTS 80-85',
-        'FROM any TO any ALLOW icmp TYPE foo',
-        'FROM any TO any ALLOW icmp6 TYPE foo',
-        'FROM any TO any ALLOW icmp TYPE *',
-        'FROM any TO any ALLOW icmp6 TYPE *',
-        'FROM any TO any ALLOW icmp TYPE 1:0',
-        'FROM any TO any ALLOW icmp6 TYPE 1:0',
-        'FROM any TO any ALLOW icmp 1:0',
-        'FROM any TO any ALLOW icmp6 1:0',
-        'FROM any TO any ALLOW icmp TYPE 128 CODE foo',
-        'FROM any TO any ALLOW icmp6 TYPE 128 CODE foo',
-        'FROM any TO any ALLOW icmp TYPE 128 CODE *',
-        'FROM any TO any ALLOW icmp6 TYPE 128 CODE *',
-        'FROM any TO any ALLOW icmp TYPE 128 CODE _',
-        'FROM any TO any ALLOW icmp6 TYPE 128 CODE _'
-    ]);
-});
-
-
-test('port ranges', function (t) {
-    var rangeA = {
-        from: [ [ 'ip', '1.2.3.4' ] ],
-        to: [ [ 'tag', 'some-tag' ] ],
-        action: 'allow',
-        protocol: {
-            name: 'tcp',
-            targets: [ { start: 20, end: 40 } ]
-        }
-    };
-
-    [
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP PORTS 20-40', rangeA ],
-        [ 'FROM IP 1.2.3.4 TO TAG some-tag ALLOW TCP PORTS 20 - 40', rangeA ]
-    ].forEach(function (data) {
-        try {
-            t.deepEqual(parser.parse(data[0]), data[1], data[0]);
-        } catch (err) {
-            t.ifError(err);
-        }
-    });
-    t.end();
-});
-
-
-test('version mismatch', function (t) {
-    try {
-        parser.parse('FROM tag foo TO tag bar ALLOW TCP PORTS 20-30',
-            { maxVersion: 1 });
-        t.ok(false,
-            'Using port ranges is a newer feature and should fail in v1');
-    } catch (err) {
-        t.deepEqual(err.message,
-            'The rule uses a feature (port ranges) newer than this API allows',
-            'Correct error message for using ports in version 1');
-    }
-    t.end();
-});
-
-
-test('icmp with code', function (t) {
-    var vm = 'b0b92cd9-1fe7-4636-8477-81d2742566c2';
-    var ruleTxt = util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp type 8 '
-        + 'code 0', vm);
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ '8:0' ]
-            }
-        }, 'icmp with type');
-
-    t.end();
-});
-
-
-test('icmp type all', function (t) {
-    var vm = 'b0b92cd9-1fe7-4636-8477-81d2742566c2';
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp type all', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ 'all' ]
-            }
-        }, 'icmp type all');
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp ( TYPE ALL )', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp',
-                targets: [ 'all' ]
-            }
-        }, 'icmp type all in parens');
-
-    t.end();
-});
-
-
-test('icmp6 type all', function (t) {
-    var vm = 'b0b92cd9-1fe7-4636-8477-81d2742566c2';
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp6 type all', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp6',
-                targets: [ 'all' ]
-            }
-        }, 'icmp6 type all');
-
-    t.deepEqual(parser.parse(
-        util.format('FROM ip 10.0.0.2 TO vm %s ALLOW icmp6 ( TYPE ALL )', vm)),
-        { from: [ [ 'ip', '10.0.0.2' ] ],
-            to: [ [ 'vm', vm ] ],
-            action: 'allow',
-            protocol: {
-                name: 'icmp6',
-                targets: [ 'all' ]
-            }
-        }, 'icmp6 type all in parens');
-
-    t.end();
-});
-
-
-test('Tags: With value', function (t) {
-    var ruleTxt = 'FROM tag foo = bar TO ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [ [ 'tag', [ 'foo', 'bar' ] ] ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
-
-
-test('Tags: Multiple values', function (t) {
-    var ruleTxt = 'FROM (tag foo = bar OR tag some = value) TO '
-        + 'ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [
-            [ 'tag', [ 'foo', 'bar' ] ],
-            [ 'tag', [ 'some', 'value' ] ]
-        ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
-
-
-test('Tags: Quoted value', function (t) {
-    var ruleTxt = 'FROM tag foo = "some value" TO ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [ [ 'tag', [ 'foo', 'some value' ] ] ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
-
-
-test('Tags: Quoted name and value', function (t) {
-    var ruleTxt = 'FROM (tag "tag one" = "some value" OR '
-        + 'tag "tag two" = "another value")'
-        + 'TO ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [
-                [ 'tag', [ 'tag one', 'some value' ] ],
-                [ 'tag', [ 'tag two', 'another value' ] ]
-            ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
-
-
-test('Tags: Escaped characters', function (t) {
-    var ruleTxt = 'FROM (tag "\\"" = "\\)" OR tag "\\n" = "\\b") TO tag "\\(" '
-        + 'BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt), {
-        from: [ [ 'tag', [ '"', ')' ] ],
-                [ 'tag', [ '\n', '\b' ] ] ],
-        to: [ [ 'tag', '(' ] ],
-        action: 'block',
-        protocol: {
-            name: 'udp',
-            targets: [ 53 ]
-        }
-    });
-
-    t.end();
-});
-
-
-test('Tags: Parens shouldn\'t have to be escaped', function (t) {
-    var ruleTxt = 'FROM tag "(" = "(" TO tag ")" = ")" '
-        + 'BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt), {
-        from: [ [ 'tag', [ '(', '(' ] ] ],
-        to: [ [ 'tag', [ ')', ')' ] ] ],
-        action: 'block',
-        protocol: {
-            name: 'udp',
-            targets: [ 53 ]
-        }
-    });
-
-    t.end();
-});
-
-
-test('Tags: UTF-8 characters can be written using \\u', function (t) {
-    var escapedTxt = 'FROM tag "\\u2603" = "\\u0631\\u062c\\u0644 '
-        + '\\u0627\\u0644\\u062b\\u0644\\u062c" TO tag "\\u26C4" '
-        + 'BLOCK udp PORT 53';
-    var unicodeTxt = 'FROM tag "☃" = "رجل الثلج" TO tag "⛄" '
-        + 'BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(escapedTxt), parser.parse(unicodeTxt));
-
-    t.end();
-});
-
-
-test('Tags: Unicode characters', function (t) {
-    var ruleTxt = 'FROM (tag "☂" = "ທ" OR '
-        + 'tag "삼겹살" = "불고기")'
-        + 'TO ip 8.8.8.8 BLOCK udp PORT 53';
-
-    t.deepEqual(parser.parse(ruleTxt),
-        { from: [
-                [ 'tag', [ '☂', 'ທ' ] ],
-                [ 'tag', [ '삼겹살', '불고기' ] ]
-            ],
-            to: [ [ 'ip', '8.8.8.8' ] ],
-            action: 'block',
-            protocol: {
-                name: 'udp',
-                targets: [ 53 ]
-            }
-        }, 'tag = value');
-
-    t.end();
-});
diff --git a/deps/fw/tools/fwrule/test/rule.test.js b/deps/fw/tools/fwrule/test/rule.test.js
deleted file mode 100644
index a855982..0000000
--- a/deps/fw/tools/fwrule/test/rule.test.js
+++ /dev/null
@@ -1,1700 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright (c) 2016, Joyent, Inc. All rights reserved.
- *
- *
- * Unit tests for the firewall rule object
- */
-
-'use strict';
-
-var fwrule = require('../lib/index');
-var util = require('util');
-var test = require('tape');
-
-var TAG_TEST =
-    'FROM tag "%s" = "%s" TO tag "%s" = "%s" ALLOW tcp PORT 80';
-var TAG_TEST_UNQUOTED = 'FROM tag %s = %s TO tag %s = %s ALLOW tcp PORT 80';
-
-
-function stringify(val) {
-    switch (val) {
-    case '\u0085':
-        return '"\\u0085"';
-    default:
-        return JSON.stringify(val);
-    }
-}
-
-
-function testTagInRules(t, unquotedOK, txtIn, txtOut, val) {
-    var desc = util.format('txtIn=%s, txtOut=%s, val=%s',
-        stringify(txtIn), stringify(txtOut), stringify(val));
-    var ruleOut = util.format(TAG_TEST, txtOut, txtOut, txtOut, txtOut);
-    var toParse = [ util.format(TAG_TEST, txtIn, txtIn, txtIn, txtIn) ];
-
-    if (unquotedOK) {
-        toParse.push(
-            util.format(TAG_TEST_UNQUOTED, txtIn, txtIn, txtIn, txtIn));
-    }
-
-    toParse.forEach(function (ruleIn) {
-        var rule = fwrule.create({
-            rule: ruleIn,
-            created_by: 'fwadm',
-            description: desc,
-            enabled: true,
-            version: fwrule.generateVersion()
-        });
-
-        var raw = {
-            from: {
-                ips: [],
-                subnets: [],
-                vms: [],
-                tags: [ [ val, val ] ],
-                wildcards: []
-            },
-            to: {
-                ips: [],
-                subnets: [],
-                vms: [],
-                tags: [ [ val, val ] ],
-                wildcards: []
-            },
-            created_by: 'fwadm',
-            description: desc,
-            enabled: true,
-            ports: [ 80 ],
-            action: 'allow',
-            protocol: 'tcp',
-            uuid: rule.uuid,
-            version: rule.version
-        };
-
-        t.deepEqual(rule.raw(), raw, desc + ': rule.raw()');
-        t.deepEqual(rule.from, raw.from, desc + ': rule.from');
-        t.deepEqual(rule.to, raw.to, desc + ': rule.to');
-        t.ok(!rule.allVMs, desc + ': rule.allVMs');
-
-        var ser = {
-            created_by: 'fwadm',
-            description: desc,
-            enabled: true,
-            global: true,
-            rule: ruleOut,
-            uuid: rule.uuid,
-            version: rule.version
-        };
-
-        t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-        t.deepEqual(rule.serialize(['enabled', 'version']),
-            { enabled: ser.enabled, version: ser.version },
-            'rule.serialize(): enabled, version');
-    });
-}
-
-
-function checkTagsInRules(t, toCheck) {
-    toCheck.forEach(function (cfg) {
-        testTagInRules(t, cfg.unquotedOK, cfg.in, cfg.out, cfg.val);
-    });
-
-    t.end();
-}
-
-
-// --- Tests
-
-
-
-test('rule exports', function (t) {
-    ['ACTIONS', 'DIRECTIONS', 'FIELDS', 'PROTOCOLS', 'TARGET_TYPES'].forEach(
-        function (field) {
-        t.ok(fwrule[field].length > 0, 'fwrule.' + field);
-    });
-
-    t.end();
-});
-
-
-test('all target types', function (t) {
-    var desc = 'all target types';
-    var ips = ['192.168.1.1', '10.2.0.3'];
-    var vms = ['9a343ca8-b42a-4a27-a9c5-800f57d1e8ed',
-        '518908b6-8299-466d-8ea5-20a0ceff63ec'];
-    var tags = ['tag1', 'tag2'];
-    var subnets = ['192.168.2.0/24', '10.2.1.0/24'];
-    var ruleTxt = util.format('FROM (ip %s OR vm %s OR tag %s OR subnet %s) ',
-        ips[0], vms[0], tags[0], subnets[0])
-        + util.format('TO (ip %s OR vm %s OR tag %s OR subnet %s)',
-        ips[1], vms[1], tags[1], subnets[1])
-        + ' ALLOW tcp port 80';
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [ips[0]],
-            subnets: [subnets[0]],
-            vms: [vms[0]],
-            tags: [tags[0]],
-            wildcards: []
-        },
-        to: {
-            ips: [ips[1]],
-            subnets: [subnets[1]],
-            vms: [vms[1]],
-            tags: [tags[1]],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: util.format('FROM (ip %s OR subnet %s OR tag "%s" OR vm %s) '
-            + 'TO (ip %s OR subnet %s OR tag "%s" OR vm %s) ALLOW tcp PORT 80',
-            ips[0], subnets[0], tags[0], vms[0],
-            ips[1], subnets[1], tags[1], vms[1]),
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('any', function (t) {
-    var ip = '192.168.3.2';
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var tag = 'tag3';
-    var subnet = '192.168.0.0/16';
-
-    var ruleTxt = util.format(
-        'FROM (ip %s OR subnet %s OR tag "%s" OR vm %s) TO any'
-        + ' ALLOW tcp PORT 80', ip, subnet, tag, vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [ip],
-            subnets: [subnet],
-            vms: [vm],
-            tags: [tag],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('all vms', function (t) {
-    var ip = '192.168.3.2';
-    var owner = '50716241-ac8d-4e63-a9e4-77ff07cede61';
-
-    var ruleTxt = util.format('FROM ip %s TO all vms ALLOW tcp PORT 80', ip);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        owner_uuid: owner,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [ip],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['vmall']
-        },
-        enabled: true,
-        owner_uuid: owner,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.deepEqual(rule.wildcards, raw.to.wildcards, 'rule.wildcards');
-    t.ok(rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        // no global flag set because the rule has an owner_uuid
-        owner_uuid: owner,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('tags', function (t) {
-    var ruleTxt = 'FROM ip 1.2.3.4 TO tag some-tag ALLOW tcp PORT 80';
-    var rule = new fwrule.create({
-        rule: ruleTxt,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [ '1.2.3.4' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'some-tag' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        rule: 'FROM ip 1.2.3.4 TO tag "some-tag" ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.end();
-});
-
-
-test('tag "hasOwnProperty"', function (t) {
-    var ruleTxt = 'FROM ip 1.2.3.4 TO (tag hasOwnProperty OR tag some-tag) '
-        + 'ALLOW tcp PORT 80';
-    var rule = new fwrule.create({
-        rule: ruleTxt,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [ '1.2.3.4' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'hasOwnProperty', 'some-tag' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        rule: 'FROM ip 1.2.3.4 TO (tag "hasOwnProperty" OR tag "some-tag") '
-            + 'ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.end();
-});
-
-
-test('multiple ports and owner_uuid', function (t) {
-    var inRule1 = {
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + '(PORT 1002 AND PORT 1052)',
-        enabled: true,
-        owner_uuid: '930896af-bf8c-48d4-885c-6573a94b1853',
-        version: fwrule.generateVersion()
-    };
-    var inRule2 = {
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + 'PORTS 1002, 1052',
-        enabled: true,
-        owner_uuid: '930896af-bf8c-48d4-885c-6573a94b1853',
-        version: fwrule.generateVersion()
-    };
-
-
-    var rule1 = fwrule.create(inRule1);
-    var rule2 = fwrule.create(inRule2);
-    var raw = {
-        action: 'allow',
-        enabled: inRule1.enabled,
-        from: {
-            ips: [ '10.88.88.1' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        owner_uuid: inRule1.owner_uuid,
-        protocol: 'tcp',
-        ports: [ 1002, 1052 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'tag2' ],
-            wildcards: []
-        },
-        uuid: rule1.uuid,
-        version: rule1.version
-    };
-
-    t.deepEqual(rule1.raw(), raw, 'rule1.raw()');
-    t.deepEqual(rule1.ports, raw.ports, 'rule1.ports');
-    t.deepEqual(rule1.protoTargets, raw.ports, 'rule1.protoTargets');
-
-    t.deepEqual(rule1.serialize(), {
-        enabled: true,
-        owner_uuid: inRule1.owner_uuid,
-        rule: inRule1.rule,
-        uuid: rule1.uuid,
-        version: rule1.version
-    }, 'rule1.serialize()');
-
-    raw.uuid = rule2.uuid;
-    raw.version = rule2.version;
-
-    t.deepEqual(rule2.raw(), raw, 'rule2.raw()');
-    t.deepEqual(rule2.ports, raw.ports, 'rule2.ports');
-    t.deepEqual(rule2.protoTargets, raw.ports, 'rule2.protoTargets');
-
-    t.deepEqual(rule2.serialize(), {
-        enabled: true,
-        owner_uuid: inRule2.owner_uuid,
-        rule: inRule1.rule,
-        uuid: rule2.uuid,
-        version: rule2.version
-    }, 'rule2.serialize()');
-
-    t.end();
-});
-
-
-test('icmp', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var ruleTxt = util.format(
-        'FROM any TO vm %s ALLOW icmp TYPE 8', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '8' ],
-        action: 'allow',
-        protocol: 'icmp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('icmp with code', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var ruleTxt = util.format(
-        'FROM any TO vm %s ALLOW icmp TYPE 8 CODE 0', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '8:0' ],
-        action: 'allow',
-        protocol: 'icmp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('icmp: multiple types', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var ruleTxt = util.format(
-        'FROM any TO vm %s ALLOW icmp (TYPE 8 CODE 0 AND TYPE 11 CODE 0 '
-        + 'AND TYPE 30)', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '8:0', '11:0', '30' ],
-        action: 'allow',
-        protocol: 'icmp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.types, raw.types, 'rule.types');
-    t.deepEqual(rule.protoTargets, raw.types, 'rule.protoTargets');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('sorting: icmp codes', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var rule = fwrule.create({
-        rule: util.format(
-        'FROM any TO vm %s ALLOW icmp '
-        + '(TYPE 8 CODE 0 AND TYPE 3 CODE 11 AND TYPE 40 AND TYPE 3 CODE 1 '
-        + 'AND TYPE 30 AND TYPE 3 CODE 5)', vm),
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '3:1', '3:5', '3:11', '8:0', '30', '40' ],
-        action: 'allow',
-        protocol: 'icmp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: util.format(
-        'FROM any TO vm %s ALLOW icmp '
-        + '(TYPE 3 CODE 1 AND TYPE 3 CODE 5 AND TYPE 3 CODE 11 '
-        + 'AND TYPE 8 CODE 0 AND TYPE 30 AND TYPE 40)', vm),
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('sorting: icmp6 codes', function (t) {
-    var vm = '8a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-
-    var rule = fwrule.create({
-        rule: util.format(
-        'FROM any TO vm %s ALLOW icmp6 '
-        + '(TYPE 8 CODE 0 AND TYPE 3 CODE 11 AND TYPE 40 AND TYPE 3 CODE 1 '
-        + 'AND TYPE 30 AND TYPE 3 CODE 5)', vm),
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: ['any']
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        enabled: true,
-        types: [ '3:1', '3:5', '3:11', '8:0', '30', '40' ],
-        action: 'allow',
-        protocol: 'icmp6',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: util.format(
-        'FROM any TO vm %s ALLOW icmp6 '
-        + '(TYPE 3 CODE 1 AND TYPE 3 CODE 5 AND TYPE 3 CODE 11 '
-        + 'AND TYPE 8 CODE 0 AND TYPE 30 AND TYPE 40)', vm),
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('sorting: ports', function (t) {
-    var inRule = {
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
-            + '(PORT 1002 AND PORT 10 AND PORT 1052 AND PORT 80 AND PORT 30245 '
-            + 'AND PORT 6)',
-        enabled: true,
-        version: fwrule.generateVersion()
-    };
-
-    var rule = fwrule.create(inRule);
-    var raw = {
-        action: 'allow',
-        enabled: inRule.enabled,
-        from: {
-            ips: [ '10.88.88.1' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 6, 10, 80, 1002, 1052, 30245 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'tag2' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + '(PORT 6 AND PORT 10 AND PORT 80 AND PORT 1002 AND PORT 1052 '
-            + 'AND PORT 30245)',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('sorting: port ranges', function (t) {
-    var inRule = {
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
-            + 'PORTS 1002, 20-40, 10, 1052, 80, 30245, 6 - 11',
-        enabled: true,
-        version: fwrule.generateVersion()
-    };
-
-    var rule = fwrule.create(inRule);
-    var raw = {
-        action: 'allow',
-        enabled: inRule.enabled,
-        from: {
-            ips: [ '10.88.88.1' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ { start: 6, end: 11 }, 10, { start: 20, end: 40 },
-            80, 1002, 1052, 30245 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'tag2' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.strictEqual(rule.raw().ports[0].start, raw.ports[0].start,
-        'Both starts are Numbers');
-    t.strictEqual(rule.raw().ports[0].end, raw.ports[0].end,
-        'Both ends are Numbers');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + 'PORTS 6 - 11, 10, 20 - 40, 80, 1002, 1052, 30245',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('single port range', function (t) {
-    var inRule = {
-        rule: 'FROM ip 10.88.88.1 TO tag tag2 ALLOW tcp '
-            + 'PORTS 50-50',
-        enabled: true,
-        version: fwrule.generateVersion()
-    };
-
-    var rule = fwrule.create(inRule);
-    var raw = {
-        action: 'allow',
-        enabled: inRule.enabled,
-        from: {
-            ips: [ '10.88.88.1' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ { start: 50, end: 50 } ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'tag2' ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: true,
-        global: true,
-        rule: 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp '
-            + 'PORTS 50 - 50',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.end();
-});
-
-
-test('port ALL', function (t) {
-    var normalText = 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp PORT all';
-    var parenText = 'FROM ip 10.88.88.1 TO tag "tag2" ALLOW tcp ( PORT all )';
-    var ruleTexts = [ normalText, parenText ];
-
-    ruleTexts.forEach(function (ruleText) {
-        var inRule = {
-            rule: ruleText,
-            enabled: true,
-            version: fwrule.generateVersion()
-        };
-
-        var rule = fwrule.create(inRule);
-        var raw = {
-            action: 'allow',
-            enabled: inRule.enabled,
-            from: {
-                ips: [ '10.88.88.1' ],
-                vms: [],
-                subnets: [],
-                tags: [],
-                wildcards: []
-            },
-            protocol: 'tcp',
-            ports: [ 'all' ],
-            to: {
-                ips: [],
-                vms: [],
-                subnets: [],
-                tags: [ 'tag2' ],
-                wildcards: []
-            },
-            uuid: rule.uuid,
-            version: rule.version
-        };
-
-        t.deepEqual(rule.raw(), raw, 'rule.raw()');
-        t.deepEqual(rule.ports, raw.ports, 'rule.ports');
-        t.deepEqual(rule.protoTargets, raw.ports, 'rule.protoTargets');
-
-        t.deepEqual(rule.serialize(), {
-            enabled: true,
-            global: true,
-            rule: normalText,
-            uuid: rule.uuid,
-            version: rule.version
-        }, 'rule.serialize()');
-    });
-
-    t.end();
-});
-
-
-test('tags: equal', function (t) {
-    var ruleTxt =
-        'FROM ip 1.2.3.4 TO tag some-tag = value ALLOW tcp PORT 80';
-    var rule = new fwrule.create({
-        rule: ruleTxt,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [ '1.2.3.4' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ [ 'some-tag', 'value' ] ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        rule: 'FROM ip 1.2.3.4 TO tag "some-tag" = "value" ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.ok(!rule.allVMs, 'rule.allVMs');
-    t.deepEqual(rule.tags, raw.to.tags, 'rule.tags');
-
-    t.end();
-});
-
-
-test('multiple tags: equal', function (t) {
-    var ruleTxt = 'FROM ip 1.2.3.4 TO '
-        + '(tag some-tag = value OR tag some-tag = value2) ALLOW tcp PORT 80';
-    var rule = new fwrule.create({
-        rule: ruleTxt,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [ '1.2.3.4' ],
-            vms: [],
-            subnets: [],
-            tags: [],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [
-                [ 'some-tag', 'value' ],
-                [ 'some-tag', 'value2' ]
-            ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        rule: 'FROM ip 1.2.3.4 TO '
-            + '(tag "some-tag" = "value" OR tag "some-tag" = "value2")'
-            + ' ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.ok(!rule.allVMs, 'rule.allVMs');
-    t.deepEqual(rule.tags, raw.to.tags, 'rule.tags');
-
-    t.end();
-});
-
-
-test('multiple tags: multiple values', function (t) {
-    var rule = new fwrule.create({
-        rule: 'FROM (tag some-tag OR tag some-tag = value0) TO '
-            + '(tag some-tag = value OR tag some-tag = value2) '
-            + 'ALLOW tcp PORT 80',
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [ 'some-tag' ],
-            wildcards: []
-        },
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [
-                [ 'some-tag', 'value' ],
-                [ 'some-tag', 'value2' ]
-            ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        global: true,
-        // 'some-tag = value0' is a subset of 'tag some-tag', so it is not
-        // included in the rule text
-        rule: 'FROM tag "some-tag" TO '
-            + '(tag "some-tag" = "value" OR tag "some-tag" = "value2") '
-            + 'ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.ok(!rule.allVMs, 'rule.allVMs');
-    t.deepEqual(rule.tags, raw.from.tags, 'rule.tags');
-
-    t.end();
-});
-
-
-test('multiple tags: multiple quoted values', function (t) {
-    var owner = 'ace1da4b-9ab2-4991-8298-700bec1b70ed';
-    var rule = new fwrule.create({
-        owner_uuid: owner,
-        rule: 'FROM '
-            + '(tag "김치" = "백김치" '
-            + 'OR tag "김치" = "白김치") TO '
-            + '(tag "some tag" = value '
-            + 'OR tag some-tag = "another value") '
-            + 'ALLOW tcp PORT 80',
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        action: 'allow',
-        enabled: false,
-        from: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [
-                [ '김치', '白김치' ],
-                [ '김치', '백김치' ]
-            ],
-            wildcards: []
-        },
-        owner_uuid: owner,
-        protocol: 'tcp',
-        ports: [ 80 ],
-        to: {
-            ips: [],
-            vms: [],
-            subnets: [],
-            tags: [
-                [ 'some tag', 'value' ],
-                [ 'some-tag', 'another value' ]
-            ],
-            wildcards: []
-        },
-        uuid: rule.uuid,
-        version: rule.version
-    };
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-
-    t.deepEqual(rule.serialize(), {
-        enabled: false,
-        owner_uuid: owner,
-        rule: 'FROM (tag "김치" = "白김치" '
-            + 'OR tag "김치" = "백김치") TO '
-            + '(tag "some tag" = "value" OR tag "some-tag" = "another value") '
-            + 'ALLOW tcp PORT 80',
-        uuid: rule.uuid,
-        version: rule.version
-    }, 'rule.serialize()');
-
-    t.ok(!rule.allVMs, 'rule.allVMs');
-    t.deepEqual(rule.tags, [
-                [ 'some tag', 'value' ],
-                [ 'some-tag', 'another value' ],
-                [ '김치', '白김치' ],
-                [ '김치', '백김치' ]
-        ], 'rule.tags');
-
-    t.end();
-});
-
-
-test('IPv6 sources', function (t) {
-    var desc = 'IPv6 sources';
-    var vm = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var ips = ['fd00::2', 'fe80::8:20ff:fe40:65e4'];
-    var ruleTxt = util.format('FROM (ip %s OR ip %s) ', ips[0], ips[1])
-        + util.format('TO vm %s ALLOW tcp PORT 80', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: ips,
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('IPv6 subnet sources', function (t) {
-    var desc = 'IPv6 subnet sources';
-    var vm = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var cidr = 'fd00::/64';
-    var ruleTxt = util.format('FROM subnet %s ', cidr)
-        + util.format('TO vm %s ALLOW tcp PORT 80', vm);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [cidr],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('IPv6 destinations', function (t) {
-    var desc = 'IPv6 destinations';
-    var vm = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var ips = ['fd00::1', 'fd00::2'];
-    var ruleTxt = util.format('FROM vm %s ', vm)
-        + util.format('TO (ip %s OR ip %s) ALLOW tcp PORT 80', ips[0], ips[1]);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: ips,
-            subnets: [],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('IPv6 subnet destinations', function (t) {
-    var desc = 'IPv6 subnet destinations';
-    var vm = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var cidr = 'fd00::/64';
-    var ruleTxt = util.format('FROM vm %s ', vm)
-        + util.format('TO subnet %s BLOCK tcp PORT 80', cidr);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: [],
-            subnets: [],
-            vms: [vm],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [cidr],
-            vms: [],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'block',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('Mixed IPv4 and IPv6', function (t) {
-    var desc = 'Mixed IPv4 and IPv6';
-    var vm1 = '9a343ca8-b42a-4a27-a9c5-800f57d1e8ed';
-    var vm2 = '518908b6-8299-466d-8ea5-20a0ceff63ec';
-    var ips = ['10.10.10.5', 'fd00::1'];
-    var ruleTxt =
-        util.format('FROM (ip %s OR ip %s OR vm %s) ', ips[0], ips[1], vm1)
-        + util.format('TO vm %s ALLOW tcp PORT 80', vm2);
-
-    var rule = fwrule.create({
-        rule: ruleTxt,
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        version: fwrule.generateVersion()
-    });
-
-    var raw = {
-        from: {
-            ips: ips,
-            subnets: [],
-            vms: [vm1],
-            tags: [],
-            wildcards: []
-        },
-        to: {
-            ips: [],
-            subnets: [],
-            vms: [vm2],
-            tags: [],
-            wildcards: []
-        },
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        ports: [ 80 ],
-        action: 'allow',
-        protocol: 'tcp',
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.raw(), raw, 'rule.raw()');
-    t.deepEqual(rule.from, raw.from, 'rule.from');
-    t.deepEqual(rule.to, raw.to, 'rule.to');
-    t.ok(!rule.allVMs, 'rule.allVMs');
-
-    var ser = {
-        created_by: 'fwadm',
-        description: desc,
-        enabled: true,
-        global: true,
-        rule: ruleTxt,
-        uuid: rule.uuid,
-        version: rule.version
-    };
-
-    t.deepEqual(rule.serialize(), ser, 'rule.serialize()');
-    t.deepEqual(rule.serialize(['enabled', 'version']),
-        { enabled: ser.enabled, version: ser.version },
-        'rule.serialize(): enabled, version');
-
-    t.end();
-});
-
-
-test('Tag names and values: Normal', function (t) {
-    var tags = [ 'foo', 'foo-bar', 'foo_bar', 'db2', 'foo_bar-baz', '_' ];
-
-    var check = [];
-    tags.forEach(function (tag) {
-        check.push({ unquotedOK: true, in: tag, out: tag, val: tag });
-        var tagUpper = tag.toUpperCase();
-        check.push({
-            unquotedOK: true,
-            in: tagUpper,
-            out: tagUpper,
-            val: tagUpper
-        });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: IP addresses and subnets', function (t) {
-    checkTagsInRules(t, [
-        { in: '1.2.3.4', out: '1.2.3.4', val: '1.2.3.4' },
-        { in: '1.2.3.0/24', out: '1.2.3.0/24', val: '1.2.3.0/24' },
-        { in: '1.2.3.0\\/24', out: '1.2.3.0/24', val: '1.2.3.0/24' },
-        { in: 'fd00::a:b:c:5', out: 'fd00::a:b:c:5', val: 'fd00::a:b:c:5' },
-        { in: 'fc00::/7', out: 'fc00::/7', val: 'fc00::/7' },
-        { in: 'fc00::\\/7', out: 'fc00::/7', val: 'fc00::/7' }
-    ]);
-});
-
-
-test('Tag names and values: Numeric', function (t) {
-    var numbers = [
-        '0', '1', '5', '2000', '1234567890', '987654321', '23', '00000', '0',
-        '01', '10', '111111111'
-    ];
-
-    var check = [];
-    numbers.forEach(function (num) {
-        check.push({ unquotedOK: true, in: num, out: num, val: num });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: Keywords', function (t) {
-    var kws = [
-        'tag', 'from', 'to', 'ip', 'subnet', 'vm', 'any', 'all', 'all vms',
-        'vms', 'or', 'and', 'block', 'allow', 'port', 'ports', 'tcp', 'udp',
-        'icmp', 'icmp6', 'type', 'code'
-    ];
-
-    var check = [];
-    kws.forEach(function (kw) {
-        check.push({ in: kw, out: kw, val: kw });
-        var kwUpper = kw.toUpperCase();
-        check.push({ in: kwUpper, out: kwUpper, val: kwUpper });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: Escaped characters', function (t) {
-    checkTagsInRules(t, [
-        { val: ' ', in: ' ', out: ' ' },
-        { val: ' ', in: '\\u0020', out: ' ' },
-        { val: '\t', in: '\t', out: '\\t' },
-        { val: '\t', in: '\\t', out: '\\t' },
-        { val: '\t', in: '\\u0009', out: '\\t' },
-        { val: '\n', in: '\n', out: '\\n' },
-        { val: '\n', in: '\\n', out: '\\n' },
-        { val: '\n', in: '\\u000A', out: '\\n' },
-        { val: '\b', in: '\b', out: '\\b' },
-        { val: '\b', in: '\\b', out: '\\b' },
-        { val: '\b', in: '\\u0008', out: '\\b' },
-        { val: '\f', in: '\f', out: '\\f' },
-        { val: '\f', in: '\\f', out: '\\f' },
-        { val: '\f', in: '\\u000C', out: '\\f' },
-        { val: '\r', in: '\r', out: '\\r' },
-        { val: '\r', in: '\\r', out: '\\r' },
-        { val: '\r', in: '\\u000D', out: '\\r' },
-        { val: '/', in: '/', out: '/' },
-        { val: '/', in: '\\/', out: '/' },
-        { val: '(', in: '(', out: '\\(' },
-        { val: '(', in: '\\(', out: '\\(' },
-        { val: ')', in: ')', out: '\\)' },
-        { val: ')', in: '\\)', out: '\\)' },
-        { val: '"', in: '\\"', out: '\\"' },
-        { val: '\\', in: '\\\\', out: '\\\\' }
-    ]);
-});
-
-
-test('Tag names and values: Odd characters', function (t) {
-    var chars = [
-        '!', '@', '#', '$', '%', '^', '&', '*', ',', '.', '<', '>', '?', ';',
-        ':', '\'', '[', ']', '{', '}', '|', '=', '+', '~', '`', '-', '_'
-    ];
-
-    var check = [];
-    chars.forEach(function (c) {
-        check.push({ in: c, out: c, val: c });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: ASCII control characters', function (t) {
-    var chars = [
-        '0000', // null (NUL)
-        '0001', // start of heading (SOH)
-        '0002', // start of text (STX)
-        '0003', // end of text (ETX)
-        '0004', // end of transmission (EOT)
-        '0005', // enquiry (ENQ)
-        '0006', // acknowledgement (ACK)
-        '0007', // bell (BEL)
-        '000B', // vertical tab (VT)
-        '000E', // shift out (SO)
-        '000F', // shift in (SI)
-        '0010', // data link escape (DLE)
-        '0011', // device control 1 (DC1)/XON
-        '0012', // device control 2 (DC2)
-        '0013', // device control 3 (DC3)/XOFF
-        '0014', // device control 4 (DC4)
-        '0015', // negative acknowledgement (NAK)
-        '0016', // synchronous idle (SYN)
-        '0017', // end of transmission block (ETB)
-        '0018', // cancel (CAN)
-        '0019', // end of medium (EM)
-        '001A', // substitute (SUB)
-        '001B', // escape (ESC)
-        '001C', // file separator (FS)
-        '001D', // group separator (GS)
-        '001E', // record separator (RS)
-        '001F', // unit separator (US)
-        '007F'  // delete (DEL)
-    ];
-
-    var check = [];
-    chars.forEach(function (str) {
-        var space = String.fromCharCode(parseInt(str, 16));
-        var escaped = '\\u' + str;
-        var escapedLC = '\\u' + str.toLowerCase();
-        check.push({ in: space, out: escaped, val: space });
-        check.push({ in: escaped, out: escaped, val: space });
-        check.push({ in: escapedLC, out: escaped, val: space });
-    });
-
-    checkTagsInRules(t, check);
-});
-
-
-test('Tag names and values: Unicode whitespace characters', function (t) {
-    var chars = [
-        '000B', // vertical tab
-        '0085', // next line
-        '00A0', // non-breaking space
-        '1680', // ogham space mark
-        '180E', // mongolian vowel separator
-        '2000', // en quad
-        '2001', // em quad
-        '2002', // en space
-        '2003', // em space
-        '2004', // three-per-em space
-        '2005', // four-per-em space
-        '2006', // six-per-em space
-        '2007', // figure space
-        '2008', // punctuation space
-        '2009', // thin space
-        '200A', // hair space
-        '200B', // zero width space
-        '200C', // zero width non-joiner
-        '200D', // zero width joiner
-        '2028', // line separator
-        '2029', // paragraph separator
-        '202F', // narrow no-break space
-        '205F', // medium mathematical space
-        '2060', // word joiner
-        '3000', // ideographic space
-        'FEFF'  // zero width no-break space
-    ];
-
-    var check = [];
-    chars.forEach(function (str) {
-        var space = String.fromCharCode(parseInt(str, 16));
-        var escaped = '\\u' + str;
-        var escapedLC = '\\u' + str.toLowerCase();
-        check.push({ in: space, out: escaped, val: space });
-        check.push({ in: escaped, out: escaped, val: space });
-        check.push({ in: escapedLC, out: escaped, val: space });
-    });
-
-    checkTagsInRules(t, check);
-});
diff --git a/deps/fw/tools/fwrule/test/run.js b/deps/fw/tools/fwrule/test/run.js
deleted file mode 100644
index 276bc30..0000000
--- a/deps/fw/tools/fwrule/test/run.js
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2014 Patrick Mooney.  All rights reserved.
-
-'use strict';
-
-var assert = require('assert');
-var fs = require('fs');
-var path = require('path');
-
-function runTests(directory) {
-    fs.readdir(directory, function (err, files) {
-        assert.ifError(err);
-        files.filter(function (f) {
-            return (/\.test\.js$/.test(f));
-        }).map(function (f) {
-            return (path.join(directory, f));
-        }).forEach(require);
-    });
-}
-
-// --- Run All Tests
-
-(function main() {
-    runTests(__dirname);
-})();
diff --git a/deps/fw/tools/fwrule/test/validators.test.js b/deps/fw/tools/fwrule/test/validators.test.js
deleted file mode 100644
index 65c62b8..0000000
--- a/deps/fw/tools/fwrule/test/validators.test.js
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at http://smartos.org/CDDL
- *
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file.
- *
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- *
- * Copyright 2016, Joyent, Inc. All rights reserved.
- *
- */
-
-/*
- * Unit tests for the firewall rule validators
- */
-
-'use strict';
-
-var test = require('tape');
-var validator = require('../lib/validators.js');
-
-
-
-// --- Tests
-
-
-test('IPv4 addresses', function (t) {
-    var i;
-    var valid = [
-        '1.2.3.4',
-        '1.0.0.0'
-    ];
-
-    var invalid = [
-        '1',
-        'asdf',
-        '0.0.0.0',
-        '01.02.03.04',
-        '255.255.255.255',
-        '256.0.0.1'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validateIPv4address(valid[i]), valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validateIPv4address(invalid[i]), invalid[i]);
-    }
-
-    t.end();
-});
-
-
-test('IPv4 subnets', function (t) {
-    var i;
-    var valid = [
-        '1.2.3.4/24',
-        '1.0.0.0/32',
-        '10.88.88.24/32',
-        '10.88.88.24/1'
-    ];
-
-    var invalid = [
-        '1',
-        'asdf',
-        '0.0.0.0/32',
-        '1.0.0.0/33',
-        '01.02.03.04/24',
-        '1.0.0.0/0'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validateIPv4subnet(valid[i]), 'valid: ' + valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validateIPv4subnet(invalid[i]),
-            'invalid: ' + invalid[i]);
-    }
-
-    t.end();
-});
-
-
-test('ports', function (t) {
-    var i;
-    var valid = [
-        1,
-        20,
-        200,
-        2000,
-        65535,
-        '1',
-        '65535',
-        'all',
-        'All',
-        'ALL'
-    ];
-
-    var invalid = [
-        0,
-        {},
-        65536,
-        '65536',
-        '',
-        [],
-        -1,
-        'something'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validatePortOrAll(valid[i]), 'valid: ' + valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validatePortOrAll(invalid[i]),
-            'invalid: ' + invalid[i]);
-    }
-
-    return t.end();
-});
-
-
-test('protocols', function (t) {
-    var i;
-    var valid = [
-        'tcp',
-        'TCP',
-        'udp',
-        'UDP',
-        'icmp',
-        'ICMP',
-        'icmp6',
-        'ICMP6'
-    ];
-
-    var invalid = [
-        0,
-        {},
-        65536,
-        '65536',
-        '',
-        [],
-        -1,
-        'something',
-        'ethernet',
-        'ftp'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validateProtocol(valid[i]), 'valid: ' + valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validateProtocol(invalid[i]),
-            'invalid: ' + invalid[i]);
-    }
-
-    return t.end();
-});
-
-test('actions', function (t) {
-    var i;
-    var valid = [
-        'block',
-        'BLOCK',
-        'allow',
-        'ALLOW'
-    ];
-
-    var invalid = [
-        0,
-        {},
-        65536,
-        '65536',
-        '',
-        'something',
-        'permit',
-        'obstruct'
-    ];
-
-    for (i in valid) {
-        t.ok(validator.validateAction(valid[i]), 'valid: ' + valid[i]);
-    }
-
-    for (i in invalid) {
-        t.notOk(validator.validateAction(invalid[i]),
-            'invalid: ' + invalid[i]);
-    }
-
-    return t.end();
-});
diff --git a/deps/fw/tools/fwrule/tools/eslint.node.conf b/deps/fw/tools/fwrule/tools/eslint.node.conf
deleted file mode 100644
index ae6d704..0000000
--- a/deps/fw/tools/fwrule/tools/eslint.node.conf
+++ /dev/null
@@ -1,20 +0,0 @@
-{
-    "plugins": [ "joyent" ],
-    "extends": [
-        "eslint:recommended",
-        "plugin:joyent/style",
-        "plugin:joyent/lint"
-    ],
-    "parserOptions": {
-        "ecmaVersion": 5,
-        "sourceType": "script",
-        "ecmaFeatures": {
-        }
-    },
-    "env": {
-        "node": true
-    },
-    "rules": {
-        "strict": [ "error", "global" ]
-    }
-}
diff --git a/deps/fw/tools/fwrule/tools/jsl.node.conf b/deps/fw/tools/fwrule/tools/jsl.node.conf
deleted file mode 100644
index 591cb8c..0000000
--- a/deps/fw/tools/fwrule/tools/jsl.node.conf
+++ /dev/null
@@ -1,138 +0,0 @@
-#
-# Configuration File for JavaScript Lint 
-#
-# This configuration file can be used to lint a collection of scripts, or to enable
-# or disable warnings for scripts that are linted via the command line.
-#
-
-### Warnings
-# Enable or disable warnings based on requirements.
-# Use "+WarningName" to display or "-WarningName" to suppress.
-#
-+ambiguous_else_stmt          # the else statement could be matched with one of multiple if statements (use curly braces to indicate intent
-+ambiguous_nested_stmt        # block statements containing block statements should use curly braces to resolve ambiguity
-+ambiguous_newline            # unexpected end of line; it is ambiguous whether these lines are part of the same statement
-+anon_no_return_value         # anonymous function does not always return value
-+assign_to_function_call      # assignment to a function call
--block_without_braces         # block statement without curly braces
-+comma_separated_stmts        # multiple statements separated by commas (use semicolons?)
-+comparison_type_conv         # comparisons against null, 0, true, false, or an empty string allowing implicit type conversion (use === or !==)
-+default_not_at_end           # the default case is not at the end of the switch statement
-+dup_option_explicit          # duplicate "option explicit" control comment
-+duplicate_case_in_switch     # duplicate case in switch statement
-+duplicate_formal             # duplicate formal argument {name}
-+empty_statement              # empty statement or extra semicolon
-+identifier_hides_another     # identifer {name} hides an identifier in a parent scope
--inc_dec_within_stmt          # increment (++) and decrement (--) operators used as part of greater statement
-+incorrect_version            # Expected /*jsl:content-type*/ control comment. The script was parsed with the wrong version.
-+invalid_fallthru             # unexpected "fallthru" control comment
-+invalid_pass                 # unexpected "pass" control comment
-+jsl_cc_not_understood        # couldn't understand control comment using /*jsl:keyword*/ syntax
-+leading_decimal_point        # leading decimal point may indicate a number or an object member
-+legacy_cc_not_understood     # couldn't understand control comment using /*@keyword@*/ syntax
-+meaningless_block            # meaningless block; curly braces have no impact
-+mismatch_ctrl_comments       # mismatched control comment; "ignore" and "end" control comments must have a one-to-one correspondence
-+misplaced_regex              # regular expressions should be preceded by a left parenthesis, assignment, colon, or comma
-+missing_break                # missing break statement
-+missing_break_for_last_case  # missing break statement for last case in switch
-+missing_default_case         # missing default case in switch statement
-+missing_option_explicit      # the "option explicit" control comment is missing
-+missing_semicolon            # missing semicolon
-+missing_semicolon_for_lambda # missing semicolon for lambda assignment
-+multiple_plus_minus          # unknown order of operations for successive plus (e.g. x+++y) or minus (e.g. x---y) signs
-+nested_comment               # nested comment
-+no_return_value              # function {name} does not always return a value
-+octal_number                 # leading zeros make an octal number
-+parseint_missing_radix       # parseInt missing radix parameter
-+partial_option_explicit      # the "option explicit" control comment, if used, must be in the first script tag
-+redeclared_var               # redeclaration of {name}
-+trailing_comma_in_array      # extra comma is not recommended in array initializers
-+trailing_decimal_point       # trailing decimal point may indicate a number or an object member
-+undeclared_identifier        # undeclared identifier: {name}
-+unreachable_code             # unreachable code
--unreferenced_argument        # argument declared but never referenced: {name}
--unreferenced_function        # function is declared but never referenced: {name}
-+unreferenced_variable        # variable is declared but never referenced: {name}
-+unsupported_version          # JavaScript {version} is not supported
-+use_of_label                 # use of label
-+useless_assign               # useless assignment
-+useless_comparison           # useless comparison; comparing identical expressions
--useless_quotes               # the quotation marks are unnecessary
-+useless_void                 # use of the void type may be unnecessary (void is always undefined)
-+var_hides_arg                # variable {name} hides argument
--want_assign_or_call          # expected an assignment or function call
-+with_statement               # with statement hides undeclared variables; use temporary variable instead
-
-
-### Output format
-# Customize the format of the error message.
-#    __FILE__ indicates current file path
-#    __FILENAME__ indicates current file name
-#    __LINE__ indicates current line
-#    __COL__ indicates current column
-#    __ERROR__ indicates error message (__ERROR_PREFIX__: __ERROR_MSG__)
-#    __ERROR_NAME__ indicates error name (used in configuration file)
-#    __ERROR_PREFIX__ indicates error prefix
-#    __ERROR_MSG__ indicates error message
-#
-# For machine-friendly output, the output format can be prefixed with
-# "encode:". If specified, all items will be encoded with C-slashes.
-#
-# Visual Studio syntax (default):
-+output-format __FILE__(__LINE__): __ERROR__
-# Alternative syntax:
-#+output-format __FILE__:__LINE__: __ERROR__
-
-
-### Context
-# Show the in-line position of the error.
-# Use "+context" to display or "-context" to suppress.
-#
-+context
-
-
-### Control Comments
-# Both JavaScript Lint and the JScript interpreter confuse each other with the syntax for
-# the /*@keyword@*/ control comments and JScript conditional comments. (The latter is
-# enabled in JScript with @cc_on@). The /*jsl:keyword*/ syntax is preferred for this reason,
-# although legacy control comments are enabled by default for backward compatibility.
-#
--legacy_control_comments
-
-
-### Defining identifiers
-# By default, "option explicit" is enabled on a per-file basis.
-# To enable this for all files, use "+always_use_option_explicit"
--always_use_option_explicit
-
-# Define certain identifiers of which the lint is not aware.
-# (Use this in conjunction with the "undeclared identifier" warning.)
-#
-# Common uses for webpages might be:
-+define __dirname
-+define clearInterval
-+define clearTimeout
-+define console
-+define exports
-+define global
-+define module
-+define process
-+define require
-+define setInterval
-+define setTimeout
-+define Buffer
-+define JSON
-+define Math
-
-### JavaScript Version
-# To change the default JavaScript version:
-#+default-type text/javascript;version=1.5
-#+default-type text/javascript;e4x=1
-
-### Files
-# Specify which files to lint
-# Use "+recurse" to enable recursion (disabled by default).
-# To add a set of files, use "+process FileName", "+process Folder\Path\*.js",
-# or "+process Folder\Path\*.htm".
-#
-
diff --git a/deps/fw/tools/nodeunit.patch b/deps/fw/tools/nodeunit.patch
new file mode 100644
index 0000000..8018510
--- /dev/null
+++ b/deps/fw/tools/nodeunit.patch
@@ -0,0 +1,31 @@
+nodeunit outputs objects as they exist in memory at the time of rendering, and
+not as they exist at the time of comparison. This makes debugging failures
+rather difficult, since the output can be misleading since the fwadm unit tests
+update the same object before calling t.deepEqual() in several places.
+
+We patch nodeunit to clone its inputs after a comparison fails so that we can
+get better output.
+---
+
+diff --git a/src/fw/test/node_modules/nodeunit/lib/assert.js b/src/fw/test/node_modules/nodeunit/lib/assert.js
+index 55ef744..a5bb34f 100644
+--- a/src/fw/test/node_modules/nodeunit/lib/assert.js
++++ b/src/fw/test/node_modules/nodeunit/lib/assert.js
+@@ -48,6 +48,7 @@ var _keys = function(obj){
+ // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
++var clone = require('clone');
+ var pSlice = Array.prototype.slice;
+
+ // 1. The assert module provides functions that throw
+@@ -62,8 +63,8 @@ var assert = exports;
+ assert.AssertionError = function AssertionError (options) {
+   this.name = "AssertionError";
+   this.message = options.message;
+-  this.actual = options.actual;
+-  this.expected = options.expected;
++  this.actual = clone(options.actual);
++  this.expected = clone(options.expected);
+   this.operator = options.operator;
+   var stackStartFunction = options.stackStartFunction || fail;
diff --git a/test/lib/vm.js b/test/lib/vm.js
index 14ef5d5..e27f1f5 100644
--- a/test/lib/vm.js
+++ b/test/lib/vm.js
@@ -61,12 +61,13 @@ function ipfRule(t, opts) {
     assert.object(opts.vm, 'opts.vm');
     assert.string(opts.vm.uuid, 'opts.vm.uuid');
 
+    // XXX: allow setting more config options
+    assert.equal(opts.direction, 'in', 'limited to inbound for now');
+
     var ipfConfs = fwHelper.zoneIPFconfigs(4);
     var cur = ipfConfs;
     var curStr;
-    // XXX: allow setting pass / block
-    var subProps = [ opts.vm.uuid, opts.direction, 'pass', opts.proto,
-        opts.target ];
+    var subProps = [ opts.vm.uuid, opts.direction, opts.proto ];
     for (var p in subProps) {
         cur = cur[subProps[p]];
         curStr = curStr ? (curStr + '.' + subProps[p]) : subProps[p];
@@ -87,8 +88,10 @@ function ipfRule(t, opts) {
     }
 
     curStr = curStr + ', port ' + opts.port;
-    // The ports are stored as strings, unfortunately:
-    var portIdx = cur.indexOf(opts.port.toString());
+    var rule = util.format(
+        'pass %s quick proto %s from %s to any port = %d keep frags',
+        opts.direction, opts.proto, opts.target, opts.port);
+    var portIdx = cur.indexOf(rule);
     if (opts.doesNotExist) {
         if (portIdx === -1) {
             t.ok(true, curStr + ' not found');
