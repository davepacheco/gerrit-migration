From 71284089e792c3b9ddca3e8b42706dc359b67da2 Mon Sep 17 00:00:00 2001
From: Jordan Hendricks <jordan.hendricks@joyent.com>
Date: Fri, 6 Oct 2017 17:13:02 +0000
Subject: [PATCH] Added mpu GC unit tests, some other cleanup based on tests.

---
 bin/mpu_gc.js                          |   4 -
 bin/mpu_gc_pg_transform.js             |  11 +-
 bin/mpu_gc_transform.js                |   4 +
 lib/mpu/common.js                      |  56 +-
 lib/mpu_garbage_collector.js           |   8 +-
 lib/mpu_gc_pg_row_transformer.js       |  29 +-
 test/mpu/mpuMorayCleanerStream.test.js | 241 +++++++
 test/mpu_garbage_collector.test.js     | 892 +++++++++++++++++++++++++
 8 files changed, 1210 insertions(+), 35 deletions(-)
 create mode 100644 test/mpu/mpuMorayCleanerStream.test.js
 create mode 100644 test/mpu_garbage_collector.test.js

diff --git a/bin/mpu_gc.js b/bin/mpu_gc.js
index 8798c44..9d99822 100755
--- a/bin/mpu_gc.js
+++ b/bin/mpu_gc.js
@@ -62,10 +62,6 @@ _garbageCollector.on('moray', function (moray) {
         console.log('moray\t' + moray.toString());
 });
 
-_garbageCollector.on('mako', function (mako) {
-        console.log('mako\t' + mako.toString());
-});
-
 _garbageCollector.on('error', function (err) {
         console.error({ err: err }, 'Error with line, exiting.');
         process.exit(1);
diff --git a/bin/mpu_gc_pg_transform.js b/bin/mpu_gc_pg_transform.js
index e6a1364..0f6676d 100755
--- a/bin/mpu_gc_pg_transform.js
+++ b/bin/mpu_gc_pg_transform.js
@@ -7,7 +7,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 var getopt = require('posix-getopt');
@@ -15,7 +15,9 @@ var lib = require('../lib');
 var path = require('path');
 var util = require('util');
 
-
+/*
+ * TODO
+ */
 
 ///--- Helpers
 
@@ -24,7 +26,7 @@ function isValidDate(date) {
 }
 
 function parseDate(dateString) {
-        //So we're forcing a weird format here.  File dates come in the format
+        // So we're forcing a weird format here.  File dates come in the format
         // 2012-10-18-23-00-02.
         var parts = dateString.split('-');
         if (parts.length != 6) {
@@ -36,7 +38,7 @@ function parseDate(dateString) {
         if (isValidDate(date)) {
                 return (date);
         }
-        //We'll let the caller catch this.
+        // We'll let the caller catch this.
         return (dateString);
 }
 
@@ -62,6 +64,7 @@ function parseOptions() {
                         break;
                 }
         }
+
         if (!opts.dumpDate) {
                 usage('-d [dump_date] is a required argument');
         }
diff --git a/bin/mpu_gc_transform.js b/bin/mpu_gc_transform.js
index 016756b..d2b86ee 100755
--- a/bin/mpu_gc_transform.js
+++ b/bin/mpu_gc_transform.js
@@ -10,6 +10,7 @@
  * Copyright (c) 2017, Joyent, Inc.
  */
 
+var assert = require('assert-plus');
 var getopt = require('posix-getopt');
 var lib = require('../lib');
 var path = require('path');
@@ -94,6 +95,9 @@ _opts.reader = process.stdin;
 
 var _gcPgRowTransformer = lib.createMpuGcPgRowTransformer(_opts);
 _gcPgRowTransformer.on('row', function (row) {
+        assert.string(row, 'row');
+        assert.func(row.toString, 'row.toString');
+
         console.log(row.toString());
 });
 
diff --git a/lib/mpu/common.js b/lib/mpu/common.js
index 30f2a39..85825f6 100644
--- a/lib/mpu/common.js
+++ b/lib/mpu/common.js
@@ -17,9 +17,6 @@ var sprintf = util.format;
 
 var MPU_MORAY_BUCKET = 'manta_uploads';
 
-var MPU_PART_OBJECT = 'part';
-var MPU_UPLOAD_DIRECTORY = 'directory';
-
 var MPUOBJ_PART = '2_partRecord';
 var MPUOBJ_UPLOADDIR = '1_uploadRecord';
 var MPUOBJ_FINALIZINGRECORD = '0_finalizingRecord';
@@ -27,19 +24,23 @@ var MPUOBJ_FINALIZINGRECORD = '0_finalizingRecord';
 var MPU_FR_TYPE_COMMIT = 'commit';
 var MPU_FR_TYPE_ABORT = 'abort';
 
+var MPU_PART = 'partRecord';
+var MPU_UPLOADDIR = 'uploadDirectory';
+
 var MPU_RECORD_ATTR_UPLOADID = 'uploadId';
 var MPU_RECORD_ATTR_MPUOBJ = 'mpuObject';
 var MPU_RECORD_ATTR_DATE = 'date';
 var MPU_RECORD_ATTR_SHARD = 'shard';
 var MPU_RECORD_ATTR_KEY = 'key';
 
-var mulrs = require('./mpuUnlinkLiveRecordStream');
-var MULRS_TYPE_PART = mulrs.MULRS_TYPE_PART;
-var MULRS_TYPE_UPLOADDIR = mulrs.MULRS_TYPE_UPLOADDIR;
-
-
 /*
  * TODO this one needs a comment!
+ *
+ * fr
+ * id obj date shard type key
+ *
+ * pr/fr
+ * id obj date key
  */
 function recordToObject(record) {
         assert.string(record);
@@ -63,11 +64,13 @@ function recordToObject(record) {
                         'contain 6 tab-separated fields: \"%s\"', record));
 
                 var shard = split[3];
-                key = split[4];
-                var finalizingType = split[5];
+                var finalizingType = split[4];
+                key = split[5];
 
                 assert.ok(finalizingType === MPU_FR_TYPE_COMMIT ||
-                          finalizingType === MPU_FR_TYPE_ABORT);
+                          finalizingType === MPU_FR_TYPE_ABORT,
+                          sprintf('invalid finalizing type: %s',
+                                finalizingType));
 
                 return new FinalizingRecord({
                         uploadId: uploadId,
@@ -84,9 +87,9 @@ function recordToObject(record) {
 
                 var mulrsType;
                 if (mpuObject === MPUOBJ_UPLOADDIR) {
-                        mulrsType = MULRS_TYPE_UPLOADDIR;
+                        mulrsType = MPU_UPLOADDIR;
                 } else {
-                        mulrsType = MULRS_TYPE_PART;
+                        mulrsType = MPU_PART;
                 }
                 assert.string(mulrsType);
 
@@ -126,7 +129,7 @@ function FinalizingRecord(opts) {
         this.type = opts.type;
 }
 
-FinalizingRecord.prototype.toString = function toString() {
+FinalizingRecord.prototype.toString = function frToString() {
         return (this.uploadId + '\t' +
                 MPUOBJ_FINALIZINGRECORD + '\t' +
                 this.date + '\t' +
@@ -153,8 +156,9 @@ function LiveRecord(opts) {
         assert.string(opts.key, 'opts.key');
         assert.string(opts.date, 'opts.date');
         assert.string(opts.type, 'opts.type');
-        assert.ok(opts.type === MULRS_TYPE_PART ||
-                  opts.type === MULRS_TYPE_UPLOADDIR);
+        assert.ok(opts.type === MPU_PART ||
+                  opts.type === MPU_UPLOADDIR,
+                  sprintf('invalid type: %s', opts.type));
 
         this.uploadId = opts.uploadId;
         this.key = opts.key;
@@ -162,6 +166,22 @@ function LiveRecord(opts) {
         this.type = opts.type;
 }
 
+LiveRecord.prototype.toString = function lrToString() {
+        var mpuObj;
+        if (this.type === MPU_PART) {
+                mpuObj = MPUOBJ_PART;
+        } else {
+                mpuObj = MPUOBJ_UPLOADDIR;
+        }
+
+        return (this.uploadId + '\t' +
+                mpuObj + '\t' +
+                this.date + '\t' +
+                this.key);
+};
+
+
+
 /*
  * Represents a collection of all of the records related to a given multipart
  * upload.
@@ -222,8 +242,8 @@ module.exports = {
         LiveRecord: LiveRecord,
         FinalizingRecord: FinalizingRecord,
 
-        MPU_PART_OBJECT: MPU_PART_OBJECT,
-        MPU_UPLOAD_DIRECTORY: MPU_UPLOAD_DIRECTORY,
+        MPU_PART: MPU_PART,
+        MPU_UPLOADDIR: MPU_UPLOADDIR,
 
         MPUOBJ_PART: MPUOBJ_PART,
         MPUOBJ_UPLOADDIR: MPUOBJ_UPLOADDIR,
diff --git a/lib/mpu_garbage_collector.js b/lib/mpu_garbage_collector.js
index 4f751b7..8a25c37 100644
--- a/lib/mpu_garbage_collector.js
+++ b/lib/mpu_garbage_collector.js
@@ -37,6 +37,10 @@ var DEFAULT_GRACE_PERIOD_MILLIS = 1000 * 60 * 60 * 24 * 2;  // 2 days
  * record to purge.
  */
 function MpuGarbageCollector(opts, listener) {
+        assert.object(opts, 'opts');
+        assert.object(opts.reader, 'opts.reader');
+        assert.optionalObject(opts.listener, 'opts.listener');
+
         var self = this;
 
         var prev, curr, currFR;
@@ -51,7 +55,6 @@ function MpuGarbageCollector(opts, listener) {
 
         self.carrier.on('line', function (line) {
                 curr = mpuCommon.recordToObject(line);
-                curr.line = line;
                 currFR = takeAction(self, prev, curr, currFR);
                 prev = curr;
                 curr = null;
@@ -59,6 +62,7 @@ function MpuGarbageCollector(opts, listener) {
 
         self.carrier.on('end', function () {
                 takeAction(self, prev, curr, currFR);
+                self.emit('end');
         });
 }
 
@@ -95,7 +99,7 @@ function takeAction(gc, prev, curr, currFR) {
         }
 
         if (curr) {
-                if (curr.mpuObject === mpuCommon.MPUOBJ_FINALIZINGRECORD) {
+                if (curr instanceof mpuCommon.FinalizingRecord) {
                         currFR = curr;
                 } else {
                         // Don't garbage collect any records for uploads that
diff --git a/lib/mpu_gc_pg_row_transformer.js b/lib/mpu_gc_pg_row_transformer.js
index 7b4abfb..10854f2 100644
--- a/lib/mpu_gc_pg_row_transformer.js
+++ b/lib/mpu_gc_pg_row_transformer.js
@@ -14,8 +14,12 @@ var path = require('path');
 var util = require('util');
 
 var mpuCommon = require('./mpu/common');
+
 var SchemaReader = require('./schema_reader');
 
+/*
+ * TODO
+ */
 
 ///--- GLOBALS
 var PG_LIVE_MANTA_TABLE_NAME = 'manta';
@@ -27,8 +31,7 @@ var UPLOADS_ROOT_PATH = /^\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f
 
 ///--- API
 
-//TODO: may need the object ID. Not sure yet.
-/**
+/*
  * This tranforms pg-dumped rows to rows useable for multipart upload
  * garbage collection.
  *
@@ -48,6 +51,11 @@ var UPLOADS_ROOT_PATH = /^\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f
  * suitable for sorting.
  */
 function MpuGcPgRowTransformer(opts, listener) {
+        assert.object(opts, 'opts');
+        assert.object(opts.reader, 'opts.reader');
+        assert.ok(opts.dumpDate, 'opts.dumpDate');
+        assert.string(opts.morayHostname, 'opts.morayHostname');
+
         var self = this;
         var reader = opts.reader;
         var dumpDate = opts.dumpDate;
@@ -106,7 +114,7 @@ module.exports = MpuGcPgRowTransformer;
 function transformFinalizingRecord(obj, dumpDate, morayHostname) {
         assert.string(obj['__table'], PG_MANTA_UPLOADS_TABLE_NAME);
         var value = obj['_value'];
-        var date = new Date(parseInt(obj['_mtime'], 10));
+        var date = new Date(parseInt(obj['_mtime'], 10)).toISOString();
 
         return new mpuCommon.FinalizingRecord({
                 uploadId: value.uploadId,
@@ -123,26 +131,33 @@ function transformMpuRecord(obj, dumpDate, morayHostname) {
 
         var mpuObject, uploadId;
         if (value.type === 'directory') {
-            mpuObject = mpuCommon.MPUOBJ_UPLOADDIR;
+            mpuObject = mpuCommon.MPU_UPLOADDIR;
             uploadId = value.upload.id;
         } else if (value.type === 'object') {
-            mpuObject = mpuCommon.MPUOBJ_PART;
+            mpuObject = mpuCommon.MPU_PART;
             uploadId = path.basename(path.dirname(obj._key));
         } else {
             return (null);
         }
+        assert.string(uploadId, 'uploadId');
+        assert.string(mpuObject, 'mpuObject');
 
         // TODO: why is this check here?
         if (!obj._key.match(UPLOADS_ROOT_PATH)) {
                 return (null);
         }
 
-        var record = mpuCommon.LiveRecord({
+        var date = dumpDate.toISOString();
+        assert.string(date, 'date');
+        assert.string(mpuObject);
+
+        var record = new mpuCommon.LiveRecord({
                 key: obj._key,
-                date: dumpDate,
+                date: date,
                 type: mpuObject,
                 uploadId: uploadId
         });
+        assert.object(record);
 
 
         if (mpuObject === mpuCommon.MPUOBJ_PART) {
diff --git a/test/mpu/mpuMorayCleanerStream.test.js b/test/mpu/mpuMorayCleanerStream.test.js
new file mode 100644
index 0000000..9e152e0
--- /dev/null
+++ b/test/mpu/mpuMorayCleanerStream.test.js
@@ -0,0 +1,241 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var fs = require('fs');
+var jsprim = require('jsprim');
+var lstream = require('lstream');
+var MemoryStream = require('memorystream');
+var util = require('util');
+var uuid = require('libuuid');
+var stream = require('stream');
+
+var helper = require('../helper');
+var inputs = require('./testInputs');
+var mpu = require('../../lib/mpu');
+var mpuCommon = require('../../lib/mpu/common');
+
+///--- Globals
+
+var test = helper.test;
+var sprintf = util.format;
+
+var LOG = helper.createLogger('mpuBatchStream test');
+
+var MPU_MORAY_BUCKET = 'manta_uploads';
+
+
+///--- Helpers
+
+function testMpuMorayCleanerStream(args) {
+        assert.object(args, 'args');
+        assert.arrayOfObject(args.input, 'args.input');
+        assert.arrayOfString(args.shards, 'args.shards');
+        assert.ok(args.shards.length > 0, 'at least 1 shard must be specified');
+        assert.func(args.delObjectFunc, 'args.delObjectFunc');
+        assert.func(args.testCb, 'args.testCb');
+
+        var mockMorayClients = {};
+        var clientsClosed = [];
+        args.shards.forEach(function (i) {
+                mockMorayClients[i] = {
+                        id: i,
+                        delObject: args.delObjectFunc,
+                        close: function close() {
+                                clientsClosed.push(i);
+                        }
+                };
+        });
+
+        var mmcs = new mpu.createMpuMorayCleanerStream({
+                log: LOG
+        });
+        mmcs.morayClients = mockMorayClients;
+
+        var r = new stream.Readable({
+                objectMode: true
+        });
+
+        args.input.forEach(function (i) {
+                r.push(i);
+        });
+        r.push(null);
+        r.pipe(mmcs);
+
+        mmcs.on('finish', function () {
+                args.testCb(clientsClosed);
+        });
+}
+
+///--- Tests
+
+test('one batch', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0
+                }
+        ];
+
+        var shards = [ inputs.SHARD_0 ];
+        var keys = [];
+        var expected = [
+                inputs.KEY_FR0
+        ];
+
+        function delObject(bucket, key, dcb) {
+                t.ok(bucket === MPU_MORAY_BUCKET);
+                t.ok(key === inputs.KEY_FR0);
+
+                keys.push(key);
+                dcb();
+        }
+
+        var args = {
+                input: input,
+                testCb: function cb(clientsClosed) {
+                        t.ok(jsprim.deepEqual(clientsClosed, shards));
+                        t.ok(jsprim.deepEqual(keys, expected));
+                        t.done();
+                },
+                delObjectFunc: delObject,
+                shards: shards
+        };
+
+        testMpuMorayCleanerStream(args);
+});
+
+test('multiple batches', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                }
+        ];
+
+        var shards = [ inputs.SHARD_0, inputs.SHARD_1, inputs.SHARD_2 ];
+        var keys = [];
+        var expected = [
+                inputs.KEY_FR0,
+                inputs.KEY_FR2,
+                inputs.KEY_FR1
+        ];
+
+        function delObject(bucket, key, dcb) {
+                t.ok(bucket === MPU_MORAY_BUCKET);
+                t.ok(key === inputs.KEY_FR0 ||
+                        key === inputs.KEY_FR1 ||
+                        key === inputs.KEY_FR2);
+
+                keys.push(key);
+                dcb();
+        }
+
+        var args = {
+                input: input,
+                testCb: function cb(clientsClosed) {
+                        shards.forEach(function (s) {
+                                t.ok(clientsClosed.indexOf(s) !== -1);
+                        });
+                        t.ok(jsprim.deepEqual(keys, expected));
+                        t.done();
+                },
+                delObjectFunc: delObject,
+                shards: shards
+        };
+
+        testMpuMorayCleanerStream(args);
+});
+
+test('deleteFinalizingRecord returns error', function (t) {
+        var input = [
+                {
+                        uploadId: inputs.ID_0,
+                        finalizingRecord: inputs.OBJ_FR0,
+                        uploadRecord: inputs.OBJ_UR0,
+                        partRecords: [
+                                inputs.OBJ_PR0[0]
+                        ]
+                },
+                {
+                        uploadId: inputs.ID_2,
+                        finalizingRecord: inputs.OBJ_FR2,
+                        uploadRecord: inputs.OBJ_UR2
+                },
+                {
+                        uploadId: inputs.ID_1,
+                        finalizingRecord: inputs.OBJ_FR1,
+                        uploadRecord: inputs.OBJ_UR1,
+                        partRecords: [
+                                inputs.OBJ_PR1[0],
+                                inputs.OBJ_PR1[1],
+                                inputs.OBJ_PR1[2]
+                        ]
+                }
+        ];
+
+        var shards = [ inputs.SHARD_0, inputs.SHARD_1, inputs.SHARD_2 ];
+        var keys = [];
+        var expected = [
+                inputs.KEY_FR0,
+                inputs.KEY_FR2,
+                inputs.KEY_FR1
+        ];
+
+        function delObject(bucket, key, dcb) {
+                t.ok(bucket === MPU_MORAY_BUCKET);
+                t.ok(key === inputs.KEY_FR0 ||
+                        key === inputs.KEY_FR1 ||
+                        key === inputs.KEY_FR2);
+
+                keys.push(key);
+                var err;
+                if (key === inputs.KEY_FR2) {
+                        err = new Error('simulated moray error');
+                }
+
+                dcb(err);
+        }
+
+        var args = {
+                input: input,
+                testCb: function cb(clientsClosed) {
+                        shards.forEach(function (s) {
+                                t.ok(clientsClosed.indexOf(s) !== -1);
+                        });
+                        t.ok(jsprim.deepEqual(keys, expected));
+                        t.done();
+                },
+                delObjectFunc: delObject,
+                shards: shards
+        };
+
+        testMpuMorayCleanerStream(args);
+});
diff --git a/test/mpu_garbage_collector.test.js b/test/mpu_garbage_collector.test.js
new file mode 100644
index 0000000..06b5772
--- /dev/null
+++ b/test/mpu_garbage_collector.test.js
@@ -0,0 +1,892 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var libuuid = require('libuuid');
+var util = require('util');
+var vstream = require('vstream');
+
+var helper = require('./helper.js');
+var lib = require('../lib');
+var mpuCommon = require('../lib/mpu/common');
+var MemoryStream = require('memorystream');
+
+
+// test cases:
+// committed: no parts, some parts
+// aborted: no parts, some parts
+// not finalized: no parts, some parts
+// grace period?
+
+///--- Globals
+
+var GRACE_PERIOD_MILLIS = 60 * 60 * 24 * 2 * 1000; //2 days
+var MORAY_1 = '1.moray.coal.joyent.us';
+var MORAY_2 = '2.moray.coal.joyent.us';
+var test = helper.test;
+
+
+
+///--- Helpers
+
+function uploadRecord(id, date, key) {
+        assert.uuid(id, 'id');
+        assert.string(date, 'date');
+        assert.string(key, 'key');
+
+        return (id + '\t1_uploadRecord\t' + date + '\t' + key);
+}
+
+function partRecord(id, date, key) {
+        assert.uuid(id, 'id');
+        assert.string(date, 'date');
+        assert.string(key, 'key');
+
+        return (id + '\t2_partRecord\t' + date + '\t' + key);
+}
+
+function commitRecord(id, date, owner, shard) {
+        assert.uuid(id, 'id');
+        assert.string(date, 'date');
+        assert.string(owner, 'owner');
+        assert.string(shard, 'shard');
+
+        var key = finalizingRecordKey(id, owner);
+
+        return (id + '\t0_finalizingRecord\t' + date + '\t' + shard +
+                '\tcommit\t' + key);
+}
+
+function abortRecord(id, date, key, shard) {
+        assert.uuid(id, 'id');
+        assert.string(date, 'date');
+        assert.string(key, 'key');
+        assert.string(shard, 'shard');
+
+        return (id + '\t0_finalizingRecord\t' + date + '\t' + shard +
+                '\tabort\t' + key);
+}
+
+function checkMoray(moray, morayHostname, objectId, date) {
+        assert.equal(moray.morayHostname, morayHostname);
+        assert.equal(moray.objectId, objectId);
+        assert.equal(moray.date - 0, date - 0);
+}
+
+function partRecordKey(id, owner, partNum) {
+        assert.uuid(id, 'id');
+        assert.uuid(owner, 'owner');
+        assert.number(partNum, 'partNum');
+        assert.ok(partNum >= 0 && partNum < 10000, 'invalid partNum');
+
+        return ('/' + owner + '/uploads/' + id.substring(0, 2) + '/' + id +
+                '/' + partNum);
+}
+
+function uploadRecordKey(id, owner) {
+        assert.uuid(id, 'id');
+        assert.uuid(owner, 'owner');
+
+        return ('/' + owner + '/uploads/' + id.substring(0, 2) + '/' + id);
+}
+
+function finalizingRecordKey(id, owner) {
+        assert.uuid(id, 'id');
+        assert.uuid(owner, 'owner');
+
+        return (id + ':' + uploadRecordKey(id, owner));
+}
+
+///--- Tests
+
+test('single batch: finalizing record only', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var id0 = libuuid.create();
+
+        var inputs = [
+                commitRecord(id0, date, owner0, MORAY_1),
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+        expect.push(mpuCommon.recordToObject(inputs[0]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('single batch: upload record only', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var id0 = libuuid.create();
+
+        var inputs = [
+                uploadRecord(id0, date, uploadRecordKey(id0, owner0)),
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('single batch: part record only', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var id0 = libuuid.create();
+
+        var inputs = [
+                partRecord(id0, date, partRecordKey(id0, owner0, 0)),
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('single batch: upload and part records', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var id0 = libuuid.create();
+
+        var inputs = [
+                uploadRecord(id0, date, uploadRecordKey(id0, owner0)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 0)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 1)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 2)),
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('single batch: finalizing record and upload record', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var id0 = libuuid.create();
+
+        var inputs = [
+                commitRecord(id0, date, owner0, MORAY_1),
+                uploadRecord(id0, date, uploadRecordKey(id0, owner0)),
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+        expect.push(mpuCommon.recordToObject(inputs[1]));
+        expect.push(mpuCommon.recordToObject(inputs[0]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('single batch: finalizing record, uplaod record, part records',
+function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var id0 = libuuid.create();
+
+        var inputs = [
+                abortRecord(id0, date, owner0, MORAY_1),
+                uploadRecord(id0, date, uploadRecordKey(id0, owner0)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 0)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 1)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 2)),
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+
+        expect.push(mpuCommon.recordToObject(inputs[1]));
+        expect.push(mpuCommon.recordToObject(inputs[2]));
+        expect.push(mpuCommon.recordToObject(inputs[3]));
+        expect.push(mpuCommon.recordToObject(inputs[4]));
+        expect.push(mpuCommon.recordToObject(inputs[0]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('finalizing records only', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                commitRecord(id0, date, owner0, MORAY_1),
+                commitRecord(id1, date, owner0, MORAY_2),
+                abortRecord(id2, date, owner1, MORAY_1),
+                abortRecord(id3, date, owner1, MORAY_2),
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+        inputs.forEach(function (r) {
+                if (r !== '') {
+                        expect.push(mpuCommon.recordToObject(r));
+                }
+        });
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('all upload records', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                uploadRecord(id0, date, uploadRecordKey(id0, owner0)),
+                uploadRecord(id1, date, uploadRecordKey(id1, owner1)),
+                uploadRecord(id2, date, uploadRecordKey(id2, owner1)),
+                uploadRecord(id3, date, uploadRecordKey(id3, owner0)),
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('all part records', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                partRecord(id0, date, partRecordKey(id0, owner0, 0)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 1)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 2)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 3)),
+                partRecord(id1, date, partRecordKey(id1, owner1, 0)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 2)),
+                partRecord(id3, date, partRecordKey(id3, owner0, 0)),
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('no finalizing records', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                uploadRecord(id0, date, uploadRecordKey(id0, owner0)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 0)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 1)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 2)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 3)),
+
+                uploadRecord(id1, date, uploadRecordKey(id1, owner1)),
+                partRecord(id1, date, partRecordKey(id1, owner1, 0)),
+
+                uploadRecord(id2, date, uploadRecordKey(id2, owner1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 0)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 2)),
+
+                uploadRecord(id3, date, uploadRecordKey(id3, owner0)),
+                partRecord(id3, date, partRecordKey(id3, owner0, 0)),
+
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('all finalized', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                commitRecord(id0, date, owner0, MORAY_1),
+                uploadRecord(id0, date, uploadRecordKey(id0, owner0)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 0)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 1)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 2)),
+                partRecord(id0, date, partRecordKey(id0, owner0, 3)),
+
+                commitRecord(id1, date, owner1, MORAY_2),
+                uploadRecord(id1, date, uploadRecordKey(id1, owner1)),
+
+                abortRecord(id2, date, owner1, MORAY_2),
+                uploadRecord(id2, date, uploadRecordKey(id2, owner1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 0)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 2)),
+
+                abortRecord(id3, date, owner0, MORAY_2),
+                uploadRecord(id3, date, uploadRecordKey(id3, owner0)),
+                partRecord(id3, date, partRecordKey(id3, owner0, 0)),
+
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+
+        expect.push(mpuCommon.recordToObject(inputs[1]));
+        expect.push(mpuCommon.recordToObject(inputs[2]));
+        expect.push(mpuCommon.recordToObject(inputs[3]));
+        expect.push(mpuCommon.recordToObject(inputs[4]));
+        expect.push(mpuCommon.recordToObject(inputs[5]));
+        expect.push(mpuCommon.recordToObject(inputs[0]));
+
+        expect.push(mpuCommon.recordToObject(inputs[7]));
+        expect.push(mpuCommon.recordToObject(inputs[6]));
+
+        expect.push(mpuCommon.recordToObject(inputs[9]));
+        expect.push(mpuCommon.recordToObject(inputs[10]));
+        expect.push(mpuCommon.recordToObject(inputs[11]));
+        expect.push(mpuCommon.recordToObject(inputs[12]));
+        expect.push(mpuCommon.recordToObject(inputs[8]));
+
+        expect.push(mpuCommon.recordToObject(inputs[14]));
+        expect.push(mpuCommon.recordToObject(inputs[15]));
+        expect.push(mpuCommon.recordToObject(inputs[13]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('finalizing record only batch at beginning', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                commitRecord(id0, date, owner0, MORAY_1),
+
+                uploadRecord(id1, date, uploadRecordKey(id1, owner1)),
+
+                uploadRecord(id2, date, uploadRecordKey(id2, owner1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 0)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 2)),
+
+                uploadRecord(id3, date, uploadRecordKey(id3, owner0)),
+                partRecord(id3, date, partRecordKey(id3, owner0, 0)),
+
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+        expect.push(mpuCommon.recordToObject(inputs[0]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('finalizing record only batch at end', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                uploadRecord(id1, date, uploadRecordKey(id1, owner1)),
+
+                uploadRecord(id2, date, uploadRecordKey(id2, owner1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 0)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 2)),
+
+                uploadRecord(id3, date, uploadRecordKey(id3, owner0)),
+                partRecord(id3, date, partRecordKey(id3, owner0, 0)),
+
+                commitRecord(id0, date, owner0, MORAY_1),
+
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+        expect.push(mpuCommon.recordToObject(inputs[7]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('upload record only batch at beginning', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                uploadRecord(id0, date, uploadRecordKey(id0, owner0)),
+
+                commitRecord(id1, date, owner1, MORAY_2),
+                uploadRecord(id1, date, uploadRecordKey(id1, owner1)),
+
+                abortRecord(id2, date, owner1, MORAY_2),
+                uploadRecord(id2, date, uploadRecordKey(id2, owner1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 0)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 2)),
+
+                abortRecord(id3, date, owner0, MORAY_2),
+                uploadRecord(id3, date, uploadRecordKey(id3, owner0)),
+
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+
+        expect.push(mpuCommon.recordToObject(inputs[2]));
+        expect.push(mpuCommon.recordToObject(inputs[1]));
+
+        expect.push(mpuCommon.recordToObject(inputs[4]));
+        expect.push(mpuCommon.recordToObject(inputs[5]));
+        expect.push(mpuCommon.recordToObject(inputs[6]));
+        expect.push(mpuCommon.recordToObject(inputs[7]));
+        expect.push(mpuCommon.recordToObject(inputs[3]));
+
+        expect.push(mpuCommon.recordToObject(inputs[9]));
+        expect.push(mpuCommon.recordToObject(inputs[8]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('upload record only batch at end', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                commitRecord(id0, date, owner0, MORAY_2),
+                uploadRecord(id0, date, uploadRecordKey(id0, owner0)),
+
+                commitRecord(id1, date, owner1, MORAY_2),
+                uploadRecord(id1, date, uploadRecordKey(id1, owner1)),
+
+                abortRecord(id2, date, owner1, MORAY_2),
+                uploadRecord(id2, date, uploadRecordKey(id2, owner1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 0)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 2)),
+
+                uploadRecord(id3, date, uploadRecordKey(id3, owner0)),
+
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+
+        expect.push(mpuCommon.recordToObject(inputs[1]));
+        expect.push(mpuCommon.recordToObject(inputs[0]));
+
+        expect.push(mpuCommon.recordToObject(inputs[3]));
+        expect.push(mpuCommon.recordToObject(inputs[2]));
+
+        expect.push(mpuCommon.recordToObject(inputs[5]));
+        expect.push(mpuCommon.recordToObject(inputs[6]));
+        expect.push(mpuCommon.recordToObject(inputs[7]));
+        expect.push(mpuCommon.recordToObject(inputs[8]));
+        expect.push(mpuCommon.recordToObject(inputs[4]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
+
+test('part record only batch at beginning', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                partRecord(id0, date, partRecordKey(id0, owner0, 0)),
+
+                commitRecord(id1, date, owner1, MORAY_2),
+                uploadRecord(id1, date, uploadRecordKey(id1, owner1)),
+
+                abortRecord(id2, date, owner1, MORAY_2),
+                uploadRecord(id2, date, uploadRecordKey(id2, owner1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 0)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 2)),
+
+                commitRecord(id3, date, owner0, MORAY_2),
+                uploadRecord(id3, date, uploadRecordKey(id3, owner0)),
+
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+
+        expect.push(mpuCommon.recordToObject(inputs[2]));
+        expect.push(mpuCommon.recordToObject(inputs[1]));
+
+        expect.push(mpuCommon.recordToObject(inputs[4]));
+        expect.push(mpuCommon.recordToObject(inputs[5]));
+        expect.push(mpuCommon.recordToObject(inputs[6]));
+        expect.push(mpuCommon.recordToObject(inputs[7]));
+        expect.push(mpuCommon.recordToObject(inputs[3]));
+
+        expect.push(mpuCommon.recordToObject(inputs[9]));
+        expect.push(mpuCommon.recordToObject(inputs[8]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+
+});
+
+test('part record at end', function (t) {
+        var date = new Date().toISOString();
+
+        var owner0 = libuuid.create();
+        var owner1 = libuuid.create();
+        var id0 = libuuid.create();
+        var id1 = libuuid.create();
+        var id2 = libuuid.create();
+        var id3 = libuuid.create();
+
+        var inputs = [
+                commitRecord(id1, date, owner1, MORAY_2),
+                uploadRecord(id1, date, uploadRecordKey(id1, owner1)),
+
+                abortRecord(id2, date, owner1, MORAY_2),
+                uploadRecord(id2, date, uploadRecordKey(id2, owner1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 0)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 1)),
+                partRecord(id2, date, partRecordKey(id2, owner1, 2)),
+
+                commitRecord(id3, date, owner0, MORAY_2),
+                uploadRecord(id3, date, uploadRecordKey(id3, owner0)),
+
+                partRecord(id0, date, partRecordKey(id0, owner0, 0)),
+
+                ''
+        ];
+
+        var stream = new MemoryStream(inputs.join('\n'));
+        var gc = lib.createMpuGarbageCollector({ reader: stream });
+        var expect = [];
+
+        expect.push(mpuCommon.recordToObject(inputs[1]));
+        expect.push(mpuCommon.recordToObject(inputs[0]));
+
+        expect.push(mpuCommon.recordToObject(inputs[3]));
+        expect.push(mpuCommon.recordToObject(inputs[4]));
+        expect.push(mpuCommon.recordToObject(inputs[5]));
+        expect.push(mpuCommon.recordToObject(inputs[6]));
+        expect.push(mpuCommon.recordToObject(inputs[2]));
+
+        expect.push(mpuCommon.recordToObject(inputs[8]));
+        expect.push(mpuCommon.recordToObject(inputs[7]));
+
+        var output = [];
+
+        gc.on('moray', function (action) {
+                output.push(action);
+        });
+
+        gc.on('end', function () {
+                t.ok(jsprim.deepEqual(expect, output));
+                t.done();
+        });
+
+        process.nextTick(function () {
+                stream.end();
+        });
+});
-- 
2.21.0

