commit 0249c4df95bda94c191a1ecdbaff4206a43f3bbb (refs/changes/61/2561/1)
Author: Jerry Jelinek <jerry.jelinek@joyent.com>
Date:   2017-09-13T21:21:18+00:00 (2 years, 1 month ago)
    
    OS-6337 Add support for splice() system call to LX brand zones

diff --git a/usr/src/lib/brand/lx/testing/ltp_skiplist b/usr/src/lib/brand/lx/testing/ltp_skiplist
index 48d56f180c..7340a37b58 100644
--- a/usr/src/lib/brand/lx/testing/ltp_skiplist
+++ b/usr/src/lib/brand/lx/testing/ltp_skiplist
@@ -240,11 +240,7 @@ setxattr02
 setxattr03
 sgetmask01
 shmget05		# OS-3326
-splice01
-splice02
-splice03
-splice04
-splice05
+splice02		# bad test, fails on Linux too
 ssetmask01
 sync_file_range01
 sysconf01		# OS-3305
diff --git a/usr/src/uts/common/brand/lx/os/lx_syscall.c b/usr/src/uts/common/brand/lx/os/lx_syscall.c
index 832686f17a..ccabe9aa0d 100644
--- a/usr/src/uts/common/brand/lx/os/lx_syscall.c
+++ b/usr/src/uts/common/brand/lx/os/lx_syscall.c
@@ -836,7 +836,7 @@ lx_sysent_t lx_sysent32[] = {
 	{"unshare",	lx_unshare,		0,		1}, /* 310 */
 	{"set_robust_list", lx_set_robust_list,	0,		2}, /* 311 */
 	{"get_robust_list", lx_get_robust_list,	0,		3}, /* 312 */
-	{"splice",	NULL,			NOSYS_NULL,	0}, /* 313 */
+	{"splice",	lx_splice,		LX_SYS_EBPARG6,	6}, /* 313 */
 	{"sync_file_range", lx_sync_file_range,	0,		4}, /* 314 */
 	{"tee",		NULL,			NOSYS_NULL,	0}, /* 315 */
 	{"vmsplice",	NULL,			NOSYS_NULL,	0}, /* 316 */
@@ -1165,7 +1165,7 @@ lx_sysent_t lx_sysent64[] = {
 	{"unshare",	lx_unshare,		0,		1}, /* 272 */
 	{"set_robust_list", lx_set_robust_list,	0,		2}, /* 273 */
 	{"get_robust_list", lx_get_robust_list,	0,		3}, /* 274 */
-	{"splice",	NULL,			NOSYS_NULL,	0}, /* 275 */
+	{"splice",	lx_splice,		0,		6}, /* 275 */
 	{"tee",		NULL,			NOSYS_NULL,	0}, /* 276 */
 	{"sync_file_range", lx_sync_file_range,	0,		4}, /* 277 */
 	{"vmsplice",	NULL,			NOSYS_NULL,	0}, /* 278 */
diff --git a/usr/src/uts/common/brand/lx/sys/lx_misc.h b/usr/src/uts/common/brand/lx/sys/lx_misc.h
index 19c50b9151..60eecbe09f 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_misc.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_misc.h
@@ -121,6 +121,9 @@ extern void lx_check_strict_failure(lx_lwp_data_t *);
 
 extern boolean_t lx_is_eventfd(file_t *);
 
+extern int lx_read_common(file_t *, uio_t *, size_t *, boolean_t);
+extern int lx_write_common(file_t *, uio_t *, size_t *, boolean_t);
+
 #endif
 
 #ifdef	__cplusplus
diff --git a/usr/src/uts/common/brand/lx/sys/lx_syscalls.h b/usr/src/uts/common/brand/lx/sys/lx_syscalls.h
index c998adbca7..54f11a71f2 100644
--- a/usr/src/uts/common/brand/lx/sys/lx_syscalls.h
+++ b/usr/src/uts/common/brand/lx/sys/lx_syscalls.h
@@ -239,6 +239,7 @@ extern long lx_shutdown();
 extern long lx_socket();
 extern long lx_socketcall();
 extern long lx_socketpair();
+extern long lx_splice();
 extern long lx_stat32();
 extern long lx_stat64();
 extern long lx_stime();
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_rw.c b/usr/src/uts/common/brand/lx/syscall/lx_rw.c
index d04e5fea18..34aafcaf5d 100644
--- a/usr/src/uts/common/brand/lx/syscall/lx_rw.c
+++ b/usr/src/uts/common/brand/lx/syscall/lx_rw.c
@@ -103,7 +103,7 @@ lx_iovec_copyin(void *uiovp, int iovcnt, iovec_t *kiovp, ssize_t *count)
 	return (0);
 }
 
-static int
+int
 lx_read_common(file_t *fp, uio_t *uiop, size_t *nread, boolean_t positioned)
 {
 	vnode_t *vp = fp->f_vnode;
@@ -205,7 +205,7 @@ out:
 	return (error);
 }
 
-static int
+int
 lx_write_common(file_t *fp, uio_t *uiop, size_t *nwrite, boolean_t positioned)
 {
 	vnode_t *vp = fp->f_vnode;
diff --git a/usr/src/uts/common/brand/lx/syscall/lx_splice.c b/usr/src/uts/common/brand/lx/syscall/lx_splice.c
new file mode 100644
index 0000000000..4de9632b91
--- /dev/null
+++ b/usr/src/uts/common/brand/lx/syscall/lx_splice.c
@@ -0,0 +1,236 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017, Joyent, Inc.
+ */
+
+#include <sys/types.h>
+#include <sys/systm.h>
+#include <sys/thread.h>
+#include <sys/proc.h>
+#include <sys/zone.h>
+#include <sys/brand.h>
+#include <sys/sunddi.h>
+#include <sys/fs/fifonode.h>
+#include <sys/lx_brand.h>
+#include <sys/lx_types.h>
+#include <sys/lx_misc.h>
+#include <sys/lx_signal.h>
+
+/* Splice flags (currently unused) */
+#define	LX_SPLICE_F_MOVE	0x01
+#define	LX_SPLICE_F_NONBLOCK	0x02
+#define	LX_SPLICE_F_MORE	0x04
+#define	LX_SPLICE_F_GIFT	0x08
+
+/*
+ * We only want to read as much from the input fd as we can write into the
+ * output fd, up to our buffer size. Figure out what that quantity is.
+ * Note that len will continuously decrease to 0 which triggers the typical
+ * end of the splice loop.
+ */
+static size_t
+can_write(file_t *fp_out, u_offset_t fileoff, size_t bsz, size_t len)
+{
+	size_t sz;
+
+	sz = MIN(bsz, len);
+	if (fp_out->f_vnode->v_type == VFIFO) {
+		/*
+		 * If no readers on pipe, or if it would go over high water
+		 * mark then return 0.
+		 */
+		fifonode_t *fn_dest = VTOF(fp_out->f_vnode)->fn_dest;
+
+		if (fn_dest->fn_rcnt == 0 ||
+		    (sz + fn_dest->fn_count) > fn_dest->fn_hiwat) {
+			sz = 0;
+		}
+	} else if (fp_out->f_vnode->v_type == VREG) {
+		if ((fileoff + sz) >= curproc->p_fsz_ctl ||
+		    (fileoff + sz) >= OFFSET_MAX(fp_out)) {
+			sz = 0;
+		}
+	}
+
+	return (sz);
+}
+
+/*
+ * Transfer data from the input file descriptor to the output file descriptor
+ * without leaving the kernel. For Linux this is limited by it's kernel
+ * implementation which forces at least one of the file descriptors to be a
+ * pipe. Our implementation is likely quite different from the Linux
+ * one, which appears to play some VM tricks with shared pages from the pipe
+ * code. Instead, our implementation simply use our normal VOP_READ/VOP_WRITE
+ * operations to internally move the data while using a single uio buffer. We
+ * implement the additional Linux behavior around the various checks and
+ * limitations.
+ */
+/*ARGSUSED*/
+long
+lx_splice(int fd_in, off_t *off_in, int fd_out, off_t *off_out, size_t len,
+    uint_t flags)
+{
+	int error = 0;
+	file_t *fp_in = NULL, *fp_out = NULL;
+	boolean_t found_pipe = B_FALSE, rd_pos = B_FALSE, wr_pos = B_FALSE;
+	iovec_t iov;
+	uio_t uio;
+	void *buf = NULL;
+	off_t r_off = 0, w_off = 0;
+	ushort_t r_flag, w_flag;
+	size_t bsize, wr_sz, nread, nwrite, total = 0;
+
+	/*
+	 * Start by validating the inputs.
+	 *
+	 * Linux doesn't seem to bother to check for valid flags, so neither do
+	 * we. Also, we ignore the flags since they're all basically just
+	 * hints to the Linux kernel implementation and have no effect on the
+	 * proper functioning of the syscall.
+	 */
+
+	if (len == 0)
+		return (0);
+
+	if ((fp_in = getf(fd_in)) == NULL) {
+		error = EBADF;
+		goto done;
+	}
+	if (fp_in->f_vnode->v_type == VFIFO ||
+	    fp_in->f_vnode->v_type == VSOCK) {
+		if (off_in != NULL) {
+			error = ESPIPE;
+			goto done;
+		}
+		if (fp_in->f_vnode->v_type == VFIFO)
+			found_pipe = B_TRUE;
+	} else if (off_in != NULL) {
+		if (copyin(off_in, &r_off, sizeof (r_off)) != 0) {
+			error = EFAULT;
+			goto done;
+		}
+		rd_pos = B_TRUE;
+	}
+	r_flag = fp_in->f_flag;
+	if ((r_flag & FREAD) == 0) {
+		error = EBADF;
+		goto done;
+	}
+
+	if ((fp_out = getf(fd_out)) == NULL) {
+		error = EBADF;
+		goto done;
+	}
+	if (fp_out->f_vnode->v_type == VFIFO ||
+	    fp_out->f_vnode->v_type == VSOCK) {
+		if (off_out != NULL) {
+			error = ESPIPE;
+			goto done;
+		}
+		if (fp_out->f_vnode->v_type == VFIFO)
+			found_pipe = B_TRUE;
+	} else if (off_out != NULL) {
+		if (copyin(off_out, &w_off, sizeof (w_off)) != 0) {
+			error = EFAULT;
+			goto done;
+		}
+		wr_pos = B_TRUE;
+	}
+	w_flag = fp_out->f_flag;
+	if ((w_flag & FWRITE) == 0) {
+		error = EBADF;
+		goto done;
+	}
+	/* Appending is invalid for output fd in splice */
+	if ((w_flag & FAPPEND) != 0) {
+		error = EINVAL;
+		goto done;
+	}
+
+	if (!found_pipe) {
+		error = EINVAL;
+		goto done;
+	}
+
+	/*
+	 * Use a max buffer size of 32k. This is a good compromise between
+	 * doing I/O in large chunks, the limit on how much data we can write
+	 * into an lx pipe by default (LX_DEFAULT_PIPE_SIZE), and how much
+	 * kernel memory we'll allocate.
+	 */
+	bsize = MIN((32 * 1024), len);
+
+	buf = kmem_alloc(bsize, KM_SLEEP);
+	bzero(&uio, sizeof (uio));
+	uio.uio_iovcnt = 1;
+	uio.uio_iov = &iov;
+	uio.uio_segflg = UIO_SYSSPACE;
+	uio.uio_llimit = curproc->p_fsz_ctl;
+
+	/*
+	 * Loop reading data from fd_in and writing to fd_out. This is
+	 * controlled by how much of the requested data we can actually write,
+	 * particularly when the destination is a pipe. This matches the Linux
+	 * behavior, which may terminate earlier than the full 'len' if the
+	 * pipe fills up. The intention is that we don't read data that we
+	 * cannot then write.
+	 */
+	while ((wr_sz = can_write(fp_out, w_off, bsize, len)) > 0) {
+		/* (re)setup for a read */
+		uio.uio_resid = iov.iov_len = wr_sz; /* only rd. max writable */
+		iov.iov_base = buf;
+		uio.uio_offset = r_off;
+		uio.uio_extflg = UIO_COPY_CACHED;
+		uio.uio_fmode = r_flag;
+		error = lx_read_common(fp_in, &uio, &nread, rd_pos);
+		if (error != 0 || nread == 0)
+			break;
+		r_off = uio.uio_offset;
+
+		/* Setup and perform a write from the same buffer */
+		uio.uio_resid = iov.iov_len = nread;
+		iov.iov_base = buf;
+		uio.uio_offset = w_off;
+		uio.uio_extflg = UIO_COPY_DEFAULT;
+		uio.uio_fmode = w_flag;
+		error = lx_write_common(fp_out, &uio, &nwrite, wr_pos);
+		if (error != 0)
+			break;
+		if (nread != nwrite) {
+			/*
+			 * We don't expect this to occur since we first checked
+			 * the write side in can_write(). There is not much we
+			 * can do here except return an error.
+			 */
+			error = EIO;
+			break;
+		}
+		w_off  = uio.uio_offset;
+
+		total += nread;
+		len -= nread;
+	}
+
+done:
+	if (buf != NULL)
+		kmem_free(buf, bsize);
+	if (fp_in != NULL)
+		releasef(fd_in);
+	if (fp_out != NULL)
+		releasef(fd_out);
+	if (error != 0)
+		return (set_errno(error));
+
+	return (total);
+}
diff --git a/usr/src/uts/intel/Makefile.files b/usr/src/uts/intel/Makefile.files
index 962ac24afa..8f8a70d22f 100644
--- a/usr/src/uts/intel/Makefile.files
+++ b/usr/src/uts/intel/Makefile.files
@@ -353,6 +353,7 @@ LX_BRAND_OBJS  =		\
 	lx_signal.o		\
 	lx_signum.o		\
 	lx_socket.o		\
+	lx_splice.o		\
 	lx_stat.o		\
 	lx_sync.o		\
 	lx_syscall.o		\
