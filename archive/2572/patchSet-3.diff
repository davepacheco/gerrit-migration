commit 20e09857ada41c54d9ae7fd617c699d6c588ad6e (refs/changes/72/2572/3)
Author: Jason King <jason.brian.king@gmail.com>
Date:   2017-09-21T02:26:51+00:00 (2 years, 1 month ago)
    
    Bits for review

diff --git a/usr/src/cmd/cmd-inet/usr.lib/Makefile b/usr/src/cmd/cmd-inet/usr.lib/Makefile
index 718d4ed15a..ffeffe9295 100644
--- a/usr/src/cmd/cmd-inet/usr.lib/Makefile
+++ b/usr/src/cmd/cmd-inet/usr.lib/Makefile
@@ -27,7 +27,7 @@
 SUBDIRS=	bridged ilbd in.chargend in.daytimed \
 		in.discardd in.echod in.mpathd in.ndpd \
 		in.ripngd in.timed inetd mdnsd ncaconfd pppoe \
-		slpd vrrpd wanboot wpad
+		slpd vrrpd wanboot wpad in.ikev2d
 
 MSGSUBDIRS=	ilbd inetd ncaconfd vrrpd wanboot
 
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile
new file mode 100644
index 0000000000..32e56aa6fc
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile
@@ -0,0 +1,58 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+PROG= in.ikev2d
+
+include ../../../Makefile.cmd
+
+SUBDIRS=
+$(INTEL_BLD)SUBDIRS += $(MACH)
+$(BUILD64)SUBDIRS += $(MACH64)
+
+all	:=	TARGET = all
+install	:=	TARGET = install
+clean	:=	TARGET = clean
+clobber	:=	TARGET = clobber
+lint	:=	TARGET = lint
+
+.KEEP_STATE:
+
+all:	$(SUBDIRS)
+
+clean clobber lint:	$(SUBDIRS)
+
+include ../Makefile.lib
+
+install:	$(SUBDIRS)
+	-$(RM) $(ROOTLIBINETPROG)
+	-$(LN) $(ISAEXEC) $(ROOTLIBINETPROG)
+
+$(SUBDIRS):	FRC
+	@cd $@; pwd; $(MAKE) $(TARGET)
+
+FRC:
+
+include ../../../Makefile.targ
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile.com b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile.com
new file mode 100644
index 0000000000..f4a9e07a97
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/Makefile.com
@@ -0,0 +1,103 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Copyright 2017 Jason King.
+# Copyright (c) 2017, Joyent, Inc.
+#
+
+PROG = in.ikev2d
+
+OBJS =	config.o	\
+	config_parse.o	\
+	dh.o		\
+	fromto.o	\
+	ikev2_common.o	\
+	ikev2_cookie.o	\
+	ikev2_enum.o	\
+	ikev2_pkt.o	\
+	ikev2_proto.o	\
+	ikev2_sa.o	\
+	ikev2_sa_init.o	\
+	inbound.o	\
+	list.o		\
+	main.o		\
+	pfkey.o		\
+	preshared.o	\
+	prf.o		\
+	pkcs11.o	\
+	pkt.o		\
+	random.o	\
+	timer.o		\
+	util.o		\
+	worker.o
+
+SRCS = $(OBJS:%.o=../common/%.c)
+
+include $(SRC)/cmd/Makefile.cmd
+include $(SRC)/cmd/Makefile.ctf
+
+CPPFLAGS += -D__EXTENSIONS__
+CPPFLAGS += -D_POSIX_PTHREAD_SEMANTICS
+
+# Use X/Open sockets for fromto.c
+fromto.o := CPPFLAGS += -D_XOPEN_SOURCE=600
+
+# ... but as a consequence, you have to disable a few lint checks.
+LINTFLAGS += -erroff=E_INCONS_ARG_DECL2 -erroff=E_INCONS_VAL_TYPE_DECL2
+LINTFLAGS64 += -erroff=E_INCONS_ARG_DECL2 -erroff=E_INCONS_VAL_TYPE_DECL2
+
+C99MODE = $(C99_ENABLE)
+CFLAGS += $(CCVERBOSE) -D_REENTRANT
+CFLAGS64 += $(CCVERBOSE) -D_REENTRANT
+LDLIBS += -lnsl -lsecdb -lumem -lxnet -lipsecutil -lpkcs11 -lcryptoutil
+LDLIBS += -lnvpair -lbunyan
+
+FILEMODE = 0555
+GROUP = bin
+
+CLEANFILES += $(OBJS)
+
+.KEEP_STATE:
+
+.PARALLEL:
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(LINK.c) -o $@ $(OBJS) $(LDLIBS)
+	$(POST_PROCESS)
+
+clean:
+	-$(RM) $(CLEANFILES)
+
+lint: lint_SRCS
+
+%.o: ../common/%.c
+	$(COMPILE.c) $<
+	$(POST_PROCESS_O)
+
+%.o: $(SRC)/common/list/%.c
+	$(COMPILE.c) $<
+	$(POST_PROCESS_O)
+
+include $(SRC)/cmd/Makefile.targ
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE
new file mode 100644
index 0000000000..4c2439f5ce
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE
@@ -0,0 +1,26 @@
+ * Copyright (C) 1995-2009 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE.descrip b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE.descrip
new file mode 100644
index 0000000000..e8d43870fb
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/THIRDPARTYLICENSE.descrip
@@ -0,0 +1 @@
+PORTIONS OF IKEv2 FROM "racoon2"
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/amd64/Makefile b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/amd64/Makefile
new file mode 100644
index 0000000000..930b865dd8
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/amd64/Makefile
@@ -0,0 +1,30 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+include ../Makefile.com
+include ../../../../Makefile.cmd.64
+
+install: all $(ROOTLIBINETPROG64)
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.c
new file mode 100644
index 0000000000..ce85920fd8
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.c
@@ -0,0 +1,211 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#include <sys/types.h>
+#include <sys/debug.h>
+#include <pthread.h>
+#include "defs.h"
+#include "config.h"
+#include "ikev2_enum.h"
+
+pthread_rwlock_t cfg_lock = PTHREAD_RWLOCK_INITIALIZER;
+config_t *config;
+
+static boolean_t cfg_addr_match(const sockaddr_u_t,
+    const config_addr_t *restrict);
+
+config_t *
+config_get(void)
+{
+	config_t *cfg = NULL;
+
+	VERIFY0(pthread_rwlock_rdlock(&cfg_lock));
+	cfg = config;
+	CONFIG_REFHOLD(cfg);
+	VERIFY0(pthread_rwlock_unlock(&cfg_lock));
+	return (cfg);
+}
+
+void
+config_xf_log(bunyan_logger_t *b, bunyan_level_t level, const char *msg,
+    const config_xf_t *xf)
+{
+	getlog(level)(b, msg,
+	    BUNYAN_T_STRING, "xf_encralg", ikev2_xf_encr_str(xf->xf_encr),
+	    BUNYAN_T_UINT32, "xf_minbits", (uint32_t)xf->xf_minbits,
+	    BUNYAN_T_UINT32, "xf_maxbits", (uint32_t)xf->xf_maxbits,
+	    BUNYAN_T_STRING, "xf_authalg", ikev2_xf_auth_str(xf->xf_auth),
+	    BUNYAN_T_STRING, "xf_authtype",
+	    ikev2_auth_type_str(xf->xf_authtype),
+	    BUNYAN_T_STRING, "xf_dh", ikev2_dh_str(xf->xf_dh),
+	    BUNYAN_T_END);
+}
+
+/*
+ * Return the first rule that matches the given local and remote addresses.
+ * If no rule matches, return the default rule.  The config is refheld on
+ * return.
+ */
+config_rule_t *
+config_get_rule(sockaddr_u_t local, sockaddr_u_t remote)
+{
+	config_t *cfg = config_get();
+
+	for (size_t i = 0; cfg->cfg_rules[i] != NULL; i++) {
+		config_rule_t *rule = cfg->cfg_rules[i];
+		boolean_t local_match = B_FALSE;
+		boolean_t remote_match = B_FALSE;
+
+		for (size_t j = 0; j < rule->rule_nlocal_addr; j++) {
+			if (cfg_addr_match(local, &rule->rule_local_addr[j])) {
+				local_match = B_TRUE;
+				break;
+			}
+		}
+		for (size_t j = 0; j < rule->rule_nremote_addr; j++) {
+			if (cfg_addr_match(remote,
+			    &rule->rule_remote_addr[j])) {
+				remote_match = B_TRUE;
+				break;
+			}
+		}
+		if (local_match && remote_match)
+			return (rule);
+	}
+
+	return (&cfg->cfg_default);
+}
+
+static boolean_t
+cfg_addr_match(const sockaddr_u_t l, const config_addr_t *restrict r)
+{
+	uint32_t mask;
+
+	switch (r->cfa_type) {
+	case CFG_ADDR_IPV4:
+		if (l.sau_ss->ss_family != AF_INET)
+			return (B_FALSE);
+		if (l.sau_sin->sin_addr.s_addr != r->cfa_start4)
+			return (B_FALSE);
+		return (B_TRUE);
+	case CFG_ADDR_IPV4_PREFIX:
+		/* XXX: this needs testing */
+		if (l.sau_ss->ss_family != AF_INET)
+			return (B_FALSE);
+		mask = (0xffffffff << (32 - r->cfa_endu.cfa_num)) &
+		    0xffffffff;
+		if ((l.sau_sin->sin_addr.s_addr & mask) ==
+		    (r->cfa_start4 & mask))
+			return (B_TRUE);
+		return (B_FALSE);
+	case CFG_ADDR_IPV4_RANGE:
+		if (l.sau_ss->ss_family != AF_INET)
+			return (B_FALSE);
+		if (l.sau_sin->sin_addr.s_addr >= r->cfa_start4 &&
+		    l.sau_sin->sin_addr.s_addr <= r->cfa_end4)
+			return (B_TRUE);
+		return (B_FALSE);
+	case CFG_ADDR_IPV6:
+		if (l.sau_ss->ss_family != AF_INET6)
+			return (B_FALSE);
+		if (IN6_ARE_ADDR_EQUAL(&l.sau_sin6->sin6_addr,
+		    &r->cfa_start6))
+			return (B_TRUE);
+		return (B_FALSE);
+	case CFG_ADDR_IPV6_PREFIX:
+		if (l.sau_ss->ss_family != AF_INET6)
+			return (B_FALSE);
+		if (IN6_ARE_PREFIXEDADDR_EQUAL(&l.sau_sin6->sin6_addr,
+		    &r->cfa_start6, r->cfa_endu.cfa_num))
+			return (B_TRUE);
+		return (B_FALSE);
+	case CFG_ADDR_IPV6_RANGE:
+		if (l.sau_ss->ss_family != AF_INET6)
+			return (B_FALSE);
+		for (size_t i = 0; i < 16; i++) {
+			if ((l.sau_sin6->sin6_addr.s6_addr[i] <
+			    r->cfa_start6.s6_addr[i]) ||
+			    (l.sau_sin6->sin6_addr.s6_addr[i] >
+			    r->cfa_end6.s6_addr[i]))
+				return (B_FALSE);
+		}
+		return (B_TRUE);
+	}
+	return (B_FALSE);
+}
+
+void
+cfg_rule_free(config_rule_t *rule)
+{
+	if (rule == NULL)
+		return;
+
+	if (rule->rule_xf != NULL) {
+		for (size_t i = 0; rule->rule_xf[i] != NULL; i++) {
+			free(rule->rule_xf[i]->xf_str);
+			free(rule->rule_xf[i]);
+		}
+	}
+
+	if (rule->rule_remote_id != NULL) {
+		for (size_t i = 0; rule->rule_remote_id[i] != NULL; i++)
+			free(rule->rule_remote_id[i]);
+		free(rule->rule_remote_id);
+	}
+
+	free(rule->rule_xf);
+	free(rule->rule_local_addr);
+	free(rule->rule_remote_addr);
+	free(rule->rule_label);
+	free(rule);
+}
+
+void
+cfg_free(config_t *cfg)
+{
+	if (cfg == NULL)
+		return;
+
+	size_t i;
+
+	VERIFY3U(cfg->cfg_refcnt, ==, 0);
+
+	for (i = 0;
+	    cfg->cfg_cert_root != NULL && cfg->cfg_cert_root[i] != NULL;
+	    i++)
+		free(cfg->cfg_cert_root[i]);
+
+	if (cfg->cfg_cert_trust != NULL) {
+		for (i = 0; cfg->cfg_cert_trust[i] != NULL; i++)
+			free(cfg->cfg_cert_trust[i]);
+	}
+
+	if (cfg->cfg_default.rule_xf != NULL) {
+		for (i = 0; cfg->cfg_default.rule_xf[i] != NULL; i++)
+			free(cfg->cfg_default.rule_xf[i]);
+	}
+
+	if (cfg->cfg_rules != NULL) {
+		for (i = 0; cfg->cfg_rules[i] != NULL; i++)
+			cfg_rule_free(cfg->cfg_rules[i]);
+	}
+
+	free(cfg->cfg_rules);
+	free(cfg->cfg_default.rule_xf);
+	free(cfg->cfg_proxy);
+	free(cfg->cfg_socks);
+	free(cfg->cfg_cert_root);
+	free(cfg->cfg_cert_trust);
+	free(cfg);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.h
new file mode 100644
index 0000000000..6f5451d72e
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config.h
@@ -0,0 +1,170 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2014 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#ifndef _CONFIG_H
+#define	_CONFIG_H
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <netinet/in.h>
+#include <stdio.h>
+#include <bunyan.h>
+#include <pthread.h>
+#include <atomic.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum config_auth_id_e {
+	CFG_AUTH_ID_DN,
+	CFG_AUTH_ID_DNS,
+	CFG_AUTH_ID_GN,
+	CFG_AUTH_ID_IPV4,
+	CFG_AUTH_ID_IPV4_PREFIX,
+	CFG_AUTH_ID_IPV4_RANGE,
+	CFG_AUTH_ID_IPV6,
+	CFG_AUTH_ID_IPV6_PREFIX,
+	CFG_AUTH_ID_IPV6_RANGE,
+	CFG_AUTH_ID_EMAIL
+} config_auth_id_t;
+
+typedef enum config_addr_e {
+	CFG_ADDR_IPV4,
+	CFG_ADDR_IPV4_PREFIX,
+	CFG_ADDR_IPV4_RANGE,
+	CFG_ADDR_IPV6,
+	CFG_ADDR_IPV6_PREFIX,
+	CFG_ADDR_IPV6_RANGE
+} config_addr_type_t;
+
+typedef struct config_addr_s {
+	config_addr_type_t	cfa_type;
+	union {
+		in_addr_t	cfa_ip4;
+		in6_addr_t	cfa_ip6;
+	} cfa_startu;
+	union {
+		in_addr_t	cfa_ip4;
+		in6_addr_t	cfa_ip6;
+		uint8_t		cfa_num;
+	} cfa_endu;
+#define	cfa_start4	cfa_startu.cfa_ip4
+#define	cfa_start6	cfa_startu.cfa_ip6
+#define	cfa_end4	cfa_endu.cfa_ip4
+#define	cfa_end6	cfa_endu.cfa_ip6
+} config_addr_t;
+
+typedef struct config_id_s {
+	config_auth_id_t	id_type;
+	union {
+		char *id_str;
+		struct {
+			uint8_t	*id_buf;
+			size_t	id_len;
+		} id_buf;
+		in_addr_t	id_ipv4;
+		in6_addr_t	id_ipv6;
+	} id_val;
+#define	idu_str	id_val.id_str
+#define	idu_buf	id_val.id_buf.id_buf
+#define	idu_len	id_val.id_buf.id_len
+#define	idu_ip4	id_val.id_ipv4
+#define	idu_ip6	id_val.id_ipv6
+} config_id_t;
+
+typedef struct config_xf_s {
+	char			*xf_str;
+	ikev2_xf_encr_t		xf_encr;
+	size_t			xf_minbits;
+	size_t			xf_maxbits;
+	ikev2_xf_auth_t		xf_auth;
+	ikev2_dh_t		xf_dh;
+	ikev2_auth_type_t	xf_authtype;
+	size_t			xf_lifetime_secs;
+	size_t			xf_nonce_len;
+} config_xf_t;
+
+struct config_s;
+typedef struct config_rule_s {
+	struct config_s		*rule_config;
+	char			*rule_label;
+	config_auth_id_t	rule_local_id_type;
+	config_addr_t		*rule_local_addr;
+	size_t			rule_nlocal_addr;
+	config_addr_t		*rule_remote_addr;
+	size_t			rule_nremote_addr;
+	config_id_t		*rule_id;
+	config_xf_t		**rule_xf;
+	size_t			rule_nxf;
+	ikev2_dh_t		rule_p2_dh;
+	char			*rule_local_id;
+	char			**rule_remote_id;
+	size_t			rule_remote_id_alloc;
+	boolean_t		rule_immediate;
+} config_rule_t;
+
+struct config_s {
+	volatile uint32_t	cfg_refcnt;
+	config_rule_t		cfg_default;
+	config_rule_t		**cfg_rules;
+	size_t			cfg_rules_alloc;
+	size_t			cfg_xforms_alloc;
+	char			*cfg_proxy;
+	char			*cfg_socks;
+	char			**cfg_cert_root;
+	size_t			cfg_cert_root_alloc;
+	char			**cfg_cert_trust;
+	size_t			cfg_cert_trust_alloc;
+	hrtime_t		cfg_expire_timer;	/* ns */
+	hrtime_t		cfg_lifetime_secs;	/* ns */
+	hrtime_t		cfg_retry_max;		/* ns */
+	hrtime_t		cfg_retry_init;		/* ns */
+	size_t			cfg_retry_limit;
+	boolean_t		cfg_ignore_crls;
+	boolean_t		cfg_use_http;
+	size_t			cfg_p1_lifetime_secs;
+	size_t			cfg_p1_nonce_len;
+	size_t			cfg_p2_lifetime_secs;
+	size_t			cfg_p2_softlife_secs;
+	size_t			cfg_p2_idletime_secs;
+	size_t			cfg_p2_lifetime_kb;
+	size_t			cfg_p2_softlife_kb;
+	size_t			cfg_p2_nonce_len;
+};
+typedef struct config_s config_t;
+#define	CONFIG_REFHOLD(cp) (void)atomic_inc_32(&(cp)->cfg_refcnt)
+#define	CONFIG_REFRELE(cp) \
+	(void) ((atomic_dec_32_nv(&(cp)->cfg_refcnt) != 0) || \
+	    (cfg_free(cp), 0))
+#define	RULE_IS_DEFAULT(r) (!!(&(r)->rule_config->cfg_default == (r)))
+
+union sockaddr_u_s;
+extern pthread_rwlock_t cfg_lock;
+extern config_t *config;
+
+void process_config(FILE *, boolean_t, bunyan_logger_t *);
+config_t *config_get(void);
+config_rule_t *config_get_rule(union sockaddr_u_s,
+    union sockaddr_u_s);
+void cfg_rule_free(config_rule_t *);
+void cfg_free(config_t *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _CONFIG_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config_parse.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config_parse.c
new file mode 100644
index 0000000000..3cbf1685ab
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/config_parse.c
@@ -0,0 +1,1647 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#include <sys/time.h>
+#include <sys/debug.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/sysmacros.h>
+#include <sys/stat.h>
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <umem.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <bunyan.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <err.h>
+#include "defs.h"
+#include "config.h"
+#include "ikev2.h"
+#include "ikev2_enum.h"
+
+#ifndef ARRAY_SIZE
+#define	ARRAY_SIZE(x)	(sizeof (x) / sizeof (x[0]))
+#endif
+
+#define	CONFIG_MAX	((size_t)(1024*1024))
+#define	CONFIG_CHUNK	((size_t)1024)
+
+typedef enum keyword_e {
+	KW_NONE = 0,
+	KW_CERT_ROOT,
+	KW_CERT_TRUST,
+	KW_EXPIRE_TIMER,
+	KW_IGNORE_CRLS,
+	KW_LDAP_SERVER,
+	KW_PKCS11_PATH,
+	KW_RETRY_LIMIT,
+	KW_RETRY_TIMER_INIT,
+	KW_RETRY_TIMER_MAX,
+	KW_PROXY,
+	KW_SOCKS,
+	KW_USE_HTTP,
+	KW_P1_LIFETIME_SECS,
+	KW_P1_NONCE_LEN,
+	KW_P2_LIFETIME_SECS,
+	KW_P2_SOFTLIFE_SECS,
+	KW_P2_IDLETIME_SECS,
+	KW_P2_LIFETIME_KB,
+	KW_P2_SOFTLIFE_KB,
+	KW_P2_NONCE_LEN,
+	KW_LOCAL_ID_TYPE,
+	KW_P1_XFORM,
+	KW_AUTH_METHOD,
+	KW_OAKLEY_GROUP,
+	KW_AUTH_ALG,
+	KW_ENCR_ALG,
+	KW_LABEL,
+	KW_LOCAL_ADDR,
+	KW_REMOTE_ADDR,
+	KW_P2_PFS,
+	KW_LOCAL_ID,
+	KW_REMOTE_ID,
+	KW_IMMEDIATE,
+	KW_MAX
+} keyword_t;
+
+#define	KWF_ARG		(1 << 0)	/* keyword has argument */
+#define	KWF_MINUS	(1 << 1)	/* minus is a separator for arg */
+#define	KWF_MULTI	(1 << 2)	/* keyword can appear multiple times */
+
+#define	KW_HAS_ARG(k)	(!!(keyword_tab[(k)].kw_flags & KWF_ARG))
+#define	KW_IS_MULTI(k)	(!!(keyword_tab[(k)].kw_flags & KWF_MULTI))
+#define	KW_USE_MINUS(k)	(!!(keyword_tab[(k)].kw_flags & KWF_MINUS))
+
+static struct {
+	const char	*kw_str;
+	uint_t		kw_flags;
+} keyword_tab[] = {
+	{ "",			0 },
+	{ "cert_root",		KWF_ARG|KWF_MULTI },
+	{ "cert_trust",		KWF_ARG|KWF_MULTI },
+	{ "expire_timer",	KWF_ARG },
+	{ "ignore_crls",	0 },
+	{ "ldap_server",	KWF_ARG|KWF_MULTI },
+	{ "pkcs11_path",	KWF_ARG|KWF_MULTI },
+	{ "retry_limit",	KWF_ARG },
+	{ "retry_timer_init",	KWF_ARG },
+	{ "retry_timer_max",	KWF_ARG },
+	{ "proxy",		KWF_ARG },
+	{ "socks",		KWF_ARG },
+	{ "use_http",		0 },
+	{ "p1_lifetime_secs",	KWF_ARG },
+	{ "p1_nonce_len",	KWF_ARG },
+	{ "p2_lifetime_secs",	KWF_ARG },
+	{ "p2_softlife_secs",	KWF_ARG },
+	{ "p2_idletime_secs",	KWF_ARG },
+	{ "p2_lifetime_kb",	KWF_ARG },
+	{ "p2_softlife_kb",	KWF_ARG },
+	{ "p2_nonce_len",	KWF_ARG },
+	{ "local_id_type",	KWF_ARG },
+	{ "p1_xform",		KWF_MULTI },
+	{ "auth_method",	KWF_ARG },
+	{ "oakley_group",	KWF_ARG },
+	{ "auth_alg",		KWF_ARG },
+	{ "encr_alg",		KWF_ARG },
+	{ "label",		KWF_ARG },
+	{ "local_addr",		KWF_ARG|KWF_MINUS|KWF_MULTI },
+	{ "remote_addr",	KWF_ARG|KWF_MINUS|KWF_MULTI },
+	{ "p2_pfs",		KWF_ARG },
+	/*
+	 * XXX: The manpage implies local_id can appear multiple times, but
+	 * only the first one is used.  This may just be poor phrasing.
+	 */
+	{ "local_id",		KWF_ARG },
+	{ "remote_id",		KWF_ARG|KWF_MULTI },
+	{ "immediate",		0 },
+};
+
+static struct {
+	ikev2_auth_type_t	a_id;
+	const char		*a_str;
+} auth_tab[] = {
+	{ IKEV2_AUTH_NONE, "" },
+	{ IKEV2_AUTH_RSA_SIG, "rsa_sig" },
+	{ IKEV2_AUTH_SHARED_KEY_MIC, "preshared" },
+	{ IKEV2_AUTH_DSS_SIG, "dss_sig" }
+};
+
+static struct {
+	config_auth_id_t	p1_id;
+	const char		*p1_str;
+} p1_id_tab[] = {
+	{ CFG_AUTH_ID_DN, "dn" },
+	{ CFG_AUTH_ID_DN, "DN" },
+	{ CFG_AUTH_ID_DNS, "dns" },
+	{ CFG_AUTH_ID_DNS, "DNS" },
+	{ CFG_AUTH_ID_DNS, "fqdn" },
+	{ CFG_AUTH_ID_DNS, "FQDN" },
+	{ CFG_AUTH_ID_GN, "gn" },
+	{ CFG_AUTH_ID_GN, "GN" },
+	{ CFG_AUTH_ID_IPV4, "ip" },
+	{ CFG_AUTH_ID_IPV4, "IP" },
+	{ CFG_AUTH_ID_IPV4, "ipv4" },
+	{ CFG_AUTH_ID_IPV4_PREFIX, "ipv4_prefix" },
+	{ CFG_AUTH_ID_IPV4_RANGE, "ipv4_range" },
+	{ CFG_AUTH_ID_IPV6, "ipv6" },
+	{ CFG_AUTH_ID_IPV6_PREFIX, "ipv6_prefix" },
+	{ CFG_AUTH_ID_IPV6_RANGE, "ipv6_range" },
+	{ CFG_AUTH_ID_EMAIL, "mbox" },
+	{ CFG_AUTH_ID_EMAIL, "MBOX" },
+	{ CFG_AUTH_ID_EMAIL, "user_fqdn" }
+};
+
+static struct {
+	ikev2_xf_auth_t xfa_id;
+	const char	*xfa_str;
+} xf_auth_tab[] = {
+	{ IKEV2_XF_AUTH_HMAC_MD5_128, "md5" },	/* XXX: verify this */
+	{ IKEV2_XF_AUTH_HMAC_SHA1_160, "sha" },
+	{ IKEV2_XF_AUTH_HMAC_SHA1_160, "sha1" },
+	{ IKEV2_XF_AUTH_HMAC_SHA2_256_128, "sha256" },
+	{ IKEV2_XF_AUTH_HMAC_SHA2_384_192, "sha384" },
+	{ IKEV2_XF_AUTH_HMAC_SHA2_512_256, "sha512" }
+};
+
+static struct {
+	ikev2_xf_encr_t xfe_id;
+	const char	*xfe_str;
+} xf_encr_tab[] = {
+	{ IKEV2_ENCR_DES, "des" },
+	{ IKEV2_ENCR_DES, "des-cbc" },
+	{ IKEV2_ENCR_3DES, "3des" },
+	{ IKEV2_ENCR_3DES, "3des-cbc" },
+	{ IKEV2_ENCR_BLOWFISH, "blowfish" },
+	{ IKEV2_ENCR_BLOWFISH, "blowfish-cbc" },
+	{ IKEV2_ENCR_AES_CBC, "aes" },
+	{ IKEV2_ENCR_AES_CBC, "aes-cbc" },
+	{ IKEV2_ENCR_AES_CCM_16, "aes-ccm" },
+	{ IKEV2_ENCR_AES_GCM_16, "aes-gcm" }
+};
+
+/*
+ * size_t would be a more appropriate type for t_{line,col}, but using
+ * uint32_t makes it cleaner for logging with bunyan
+ */
+typedef struct token {
+	char		*t_str;
+	const char	*t_linep;
+	uint32_t	t_line;
+	uint32_t	t_col;
+} token_t;
+
+typedef struct input {
+	char 	*in_buf;
+	size_t	in_buflen;
+	char	**in_lines;
+} input_t;
+
+typedef struct input_cursor {
+	input_t 	*ic_input;
+	char		*ic_p;
+	token_t		*ic_peek;
+	bunyan_logger_t	*ic_log;
+} input_cursor_t;
+
+static void add_str(char ***restrict, size_t *restrict, const char *restrict);
+static void add_addr(config_addr_t **restrict, size_t *restrict,
+    const config_addr_t *restrict);
+static void add_xf(config_rule_t *restrict, config_xf_t *restrict);
+static void add_rule(config_t *restrict, config_rule_t *restrict);
+
+static token_t *tok_new(const char *, const char *, const char *, size_t,
+    size_t);
+static void tok_free(token_t *);
+static void tok_log(const token_t *restrict, bunyan_logger_t *restrict,
+    bunyan_level_t, const char *restrict, const char *restrict);
+static void tok_error(const token_t *restrict, bunyan_logger_t *restrict,
+    const char *restrict, const char *restrict);
+static void tok_invalid(token_t *restrict, bunyan_logger_t *restrict,
+    keyword_t);
+
+static boolean_t parse_rule(input_cursor_t *restrict, const token_t *restrict,
+    config_rule_t **restrict);
+static boolean_t parse_address(input_cursor_t *restrict, token_t *restrict,
+    config_addr_t *restrict);
+
+static boolean_t parse_xform(input_cursor_t *restrict, config_xf_t **restrict);
+static boolean_t parse_encrbits(input_cursor_t *restrict,
+    config_xf_t *restrict);
+
+static boolean_t parse_kw(const char *restrict, keyword_t *restrict);
+static boolean_t parse_auth(const char *restrict, ikev2_auth_type_t *restrict);
+static boolean_t parse_authalg(const char *restrict, ikev2_xf_auth_t *restrict);
+static boolean_t parse_encralg(const char *restrict, ikev2_xf_encr_t *restrict);
+static boolean_t parse_p1_id(const char *restrict, config_auth_id_t *restrict);
+static boolean_t parse_p2_pfs(const char *restrict, ikev2_dh_t *restrict);
+static boolean_t parse_ip(const char *restrict, in_addr_t *restrict);
+static boolean_t parse_ip6(const char *restrict, in6_addr_t *restrict);
+static boolean_t parse_int(const char *restrict, uint64_t *restrict);
+static boolean_t parse_fp(const char *restrict, double *restrict);
+
+static input_t *input_new(FILE *restrict, bunyan_logger_t *restrict);
+static void input_free(input_t *);
+
+static void input_cursor_init(input_cursor_t *, input_t *, bunyan_logger_t *);
+static void input_cursor_fini(input_cursor_t *);
+static token_t *input_token(input_cursor_t *, boolean_t);
+static const token_t *input_peek(input_cursor_t *, boolean_t);
+static token_t *input_next_token(input_cursor_t *, boolean_t);
+static void input_cursor_getpos(input_cursor_t *restrict, const char *restrict,
+    const char **restrict, uint32_t *restrict, uint32_t *restrict);
+
+static boolean_t issep(char c, boolean_t);
+
+/*
+ * When processing a configuration file, we first load the entire contents
+ * into memory before doing any parsing.  This is to hopefully allow more
+ * contextual error messages (such as being able to output the full line of
+ * text where an error occurs, as well as the location where the error occurs).
+ * Once successfully parsed, the contents are discarded.
+ *
+ * The general approach is to then generate a stream of string tokens.  We
+ * defer interpretation of the tokens (e.g. 'IP address') since there are
+ * some instances where it'd be complicated to do so due to potential
+ * ambiguities.  Instead it's simpler to wait until there's more context.
+ *
+ * For example, once the 'local_addr' keyword has been seen, we know the next
+ * token should be either an IPV4 or IPV6 address, an IPV[46] address prefix
+ * (address/masklen), or an IPV[46] range (start address-end address).  We can
+ * attempt to convert the string accordingly without ambiguity.
+ *
+ * To assist in that, there is a (currently) limited ability to peek (view
+ * without advancing the stream) at the next token.  This has (so far)
+ * proven sufficient.
+ *
+ * To check the configuration, we build a new copy of config_t, and if it
+ * succeeds to completion, we know the configuration does not have any
+ * errors, and then discard it (instead of replacing the current configuration).
+ *
+ * TODO: We should probably support the ability to add and remove individual
+ * rules.
+ */
+void
+process_config(FILE *f, boolean_t check_only, bunyan_logger_t *blog)
+{
+	input_t *in = input_new(f, blog);
+	token_t *t = NULL, *targ = NULL;
+	config_t *cfg = NULL;
+	config_xf_t *xf = NULL;
+	input_cursor_t ic = { 0 };
+	union {
+		uint64_t	ui;
+		double		d;
+	} val;
+	size_t rule_count = 0;
+
+	bunyan_trace(log, "process_config() enter", BUNYAN_T_END);
+
+	if (in == NULL) {
+		STDERR(error, blog, "failure reading input");
+		bunyan_trace(log, "process_config() exit", BUNYAN_T_END);
+		return;
+	}
+
+	cfg = calloc(1, sizeof (*cfg));
+	VERIFY3P(cfg, !=, NULL);
+
+	/* Set defaults */
+	cfg->cfg_expire_timer = SEC2NSEC(300);
+	cfg->cfg_retry_init = MSEC2NSEC(500);
+	cfg->cfg_retry_max = SEC2NSEC(30);
+	cfg->cfg_retry_limit = 5;
+
+	input_cursor_init(&ic, in, blog);
+	while ((t = input_token(&ic, B_TRUE)) != NULL) {
+		keyword_t kw;
+
+		if (strcmp(t->t_str, "{") == 0) {
+			config_rule_t *rule = NULL;
+
+			if (!parse_rule(&ic, t, &rule))
+				goto fail;
+
+			add_rule(cfg, rule);
+			tok_free(t);
+			rule_count++;
+			continue;
+		}
+
+		if (!parse_kw(t->t_str, &kw)) {
+			tok_error(t, blog,
+			    "Unrecognized configuration parameter",
+			    "parameter");
+			goto fail;
+		}
+
+		VERIFY3S(kw, !=, KW_NONE);
+		VERIFY3S(kw, !=, KW_MAX);
+
+		if (KW_HAS_ARG(kw)) {
+			targ = input_token(&ic, KW_USE_MINUS(kw));
+			if (targ == NULL) {
+				tok_error(t, blog,
+				    "Parameter is missing argument",
+				    "parameter");
+				goto fail;
+			}
+		}
+
+		switch (kw) {
+		case KW_NONE:
+		case KW_MAX:
+			INVALID("t->t_val.t_kw");
+			break;
+		case KW_CERT_ROOT:
+			add_str(&cfg->cfg_cert_root, &cfg->cfg_cert_root_alloc,
+			    targ->t_str);
+			break;
+		case KW_CERT_TRUST:
+			add_str(&cfg->cfg_cert_trust,
+			    &cfg->cfg_cert_trust_alloc, targ->t_str);
+			break;
+		case KW_EXPIRE_TIMER:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(t, blog, KW_EXPIRE_TIMER);
+				goto fail;
+			}
+			cfg->cfg_expire_timer = val.ui * NANOSEC;
+			break;
+		case KW_IGNORE_CRLS:
+			cfg->cfg_ignore_crls = B_TRUE;
+			break;
+		case KW_LDAP_SERVER:
+		case KW_PKCS11_PATH:
+			tok_log(t, blog, BUNYAN_L_INFO,
+			    "Ignoring deprecated configuration parameter",
+			    "parameter");
+			break;
+		case KW_RETRY_LIMIT:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(t, blog, KW_RETRY_LIMIT);
+				goto fail;
+			}
+			cfg->cfg_retry_limit = val.ui;
+			break;
+		case KW_PROXY:
+			cfg->cfg_proxy = strdup(targ->t_str);
+			VERIFY3P(cfg->cfg_proxy, !=, NULL);
+			break;
+		case KW_SOCKS:
+			cfg->cfg_socks = strdup(targ->t_str);
+			VERIFY3P(cfg->cfg_socks, !=, NULL);
+			break;
+		case KW_RETRY_TIMER_INIT:
+			if (parse_int(targ->t_str, &val.ui)) {
+				cfg->cfg_retry_init = val.ui * NANOSEC;
+			} else if (parse_fp(targ->t_str, &val.d)) {
+				cfg->cfg_retry_init =
+				    (hrtime_t)(val.d * NANOSEC);
+			} else {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			break;
+		case KW_RETRY_TIMER_MAX:
+			if (parse_int(targ->t_str, &val.ui)) {
+				cfg->cfg_retry_max = val.ui * NANOSEC;
+			} else if (parse_fp(targ->t_str, &val.d)) {
+				cfg->cfg_retry_max =
+				    (hrtime_t)(val.d * NANOSEC);
+			} else {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			break;
+		case KW_P1_LIFETIME_SECS:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			cfg->cfg_p1_lifetime_secs = val.ui;
+			break;
+		case KW_P1_NONCE_LEN:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p1_nonce_len = val.ui;
+			break;
+		case KW_P2_LIFETIME_SECS:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_lifetime_secs = val.ui;
+			break;
+		case KW_P2_SOFTLIFE_SECS:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_softlife_secs = val.ui;
+			break;
+		case KW_P2_IDLETIME_SECS:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_idletime_secs = val.ui;
+			break;
+		case KW_P2_LIFETIME_KB:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_lifetime_kb = val.ui;
+			break;
+		case KW_P2_SOFTLIFE_KB:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_softlife_kb = val.ui;
+			break;
+		case KW_P2_NONCE_LEN:
+			if (!parse_int(targ->t_str, &val.ui)) {
+				tok_invalid(targ, blog, kw);
+				goto fail;
+			}
+			/* XXX: check size */
+			cfg->cfg_p2_nonce_len = val.ui;
+			break;
+		case KW_LOCAL_ID_TYPE:
+			tok_log(t, blog, BUNYAN_L_INFO, "Unimplemented "
+			    "configuration parameter", "keyword");
+			break;
+		case KW_USE_HTTP:
+			cfg->cfg_use_http = B_TRUE;
+			break;
+		case KW_P2_PFS:
+			if (!parse_p2_pfs(targ->t_str,
+			    &cfg->cfg_default.rule_p2_dh)) {
+				tok_error(targ, blog, "Invalid p2_pfs value",
+				    "value");
+				goto fail;
+			}
+			break;
+		case KW_P1_XFORM:
+			if (!parse_xform(&ic, &xf))
+				goto fail;
+			add_xf(&cfg->cfg_default, xf);
+			xf = NULL;
+			break;
+		case KW_AUTH_METHOD:
+		case KW_OAKLEY_GROUP:
+		case KW_AUTH_ALG:
+		case KW_ENCR_ALG:
+			tok_error(t, blog, "Configuration parameter cannot be "
+			    "used outside of a transform definition",
+			    "parameter");
+			goto fail;
+		case KW_LABEL:
+		case KW_LOCAL_ADDR:
+		case KW_REMOTE_ADDR:
+		case KW_LOCAL_ID:
+		case KW_REMOTE_ID:
+		case KW_IMMEDIATE:
+			tok_error(t, blog, "Configuration parameter cannot be "
+			    "used outside of a rule definition", "parameter");
+			goto fail;
+		}
+
+		tok_free(t);
+		tok_free(targ);
+		t = NULL;
+		targ = NULL;
+	}
+
+	tok_free(t);
+	tok_free(targ);
+	input_cursor_fini(&ic);
+	input_free(in);
+
+	bunyan_info(blog, "Finished processing config",
+	    BUNYAN_T_UINT32, "numrules", (uint32_t)rule_count,
+	    BUNYAN_T_END);
+
+	if (check_only) {
+		cfg_free(cfg);
+	} else {
+		config_t *old = NULL;
+
+		cfg->cfg_refcnt = 1;
+
+		VERIFY0(pthread_rwlock_wrlock(&cfg_lock));
+		old = config;
+		config = cfg;
+		VERIFY0(pthread_rwlock_unlock(&cfg_lock));
+		if (old != NULL)
+			CONFIG_REFRELE(old);
+	}
+	bunyan_trace(log, "process_config() exit", BUNYAN_T_END);
+	return;
+
+fail:
+	tok_free(t);
+	tok_free(targ);
+	input_cursor_fini(&ic);
+	input_free(in);
+	cfg_free(cfg);
+	cfg = NULL;
+
+	if (!check_only)
+		exit(1);
+}
+
+static boolean_t
+parse_xform(input_cursor_t *restrict ic, config_xf_t **restrict xfp)
+{
+	config_xf_t *xf = NULL;
+	token_t *start_t = NULL, *t = NULL, *targ = NULL;
+	uint64_t val = 0;
+	const char *start = NULL, *end = NULL;
+	size_t kwcount[KW_MAX] = { 0 };
+	boolean_t ok = B_TRUE;
+
+	xf = calloc(1, sizeof (*xf));
+	VERIFY3P(xf, !=, NULL);
+
+	if ((start_t = input_token(ic, B_FALSE)) == NULL) {
+		bunyan_error(ic->ic_log, "Unexpected end of input processing "
+		    "transform", BUNYAN_T_END);
+		goto fail;
+	}
+
+	if (strcmp(start_t->t_str, "{") != 0) {
+		bunyan_error(ic->ic_log, "Expected '{' after p1_xform",
+		    BUNYAN_T_STRING, "string", start_t->t_str,
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	start = start_t->t_linep + start_t->t_col;
+
+	/*CONSTCOND*/
+	while (1) {
+		t = input_token(ic, B_FALSE);
+		if (t == NULL) {
+			bunyan_error(ic->ic_log,
+			    "Unexpected end of input processing transform",
+			    BUNYAN_T_END);
+			goto fail;
+		}
+		if (strcmp(t->t_str, "}") == 0)
+			break;
+
+		keyword_t kw = KW_NONE;
+		if (!parse_kw(t->t_str, &kw)) {
+			tok_error(t, ic->ic_log,
+			    "Unknown configuration parameter", "parameter");
+			goto fail;
+		}
+
+		if (kwcount[kw] > 0 && !KW_IS_MULTI(kw)) {
+			tok_error(t, ic->ic_log,
+			    "Parameter can only appear once in a transform",
+			    "parameter");
+			goto fail;
+		}
+
+		if (KW_HAS_ARG(kw)) {
+			targ = input_token(ic, KW_USE_MINUS(kw));
+			if (targ == NULL) {
+				tok_error(t, ic->ic_log,
+				    "Parameter is missing an argument",
+				    "parameter");
+				goto fail;
+			}
+		}
+
+		switch (kw) {
+		case KW_AUTH_METHOD:
+			if (!parse_auth(targ->t_str, &xf->xf_authtype)) {
+				tok_error(targ, ic->ic_log,
+				    "Unknown authentication method",
+				    "authmethod");
+				goto fail;
+			}
+			break;
+		case KW_OAKLEY_GROUP:
+			if (!parse_int(targ->t_str, &val)) {
+				tok_error(targ, ic->ic_log,
+				    "Unknown oakley (DH) group",
+				    "group");
+				goto fail;
+			}
+			/* XXX: Should have a way to validate the value */
+			xf->xf_dh = (ikev2_dh_t)val;
+			break;
+		case KW_AUTH_ALG:
+			if (!parse_authalg(targ->t_str, &xf->xf_auth)) {
+				tok_error(targ, ic->ic_log,
+				    "Unknown authentication algorithm",
+				    "algorithm");
+				goto fail;
+			}
+			break;
+		case KW_ENCR_ALG:
+			if (!parse_encralg(targ->t_str, &xf->xf_encr)) {
+				tok_error(targ, ic->ic_log,
+				    "Unknown encryption algorithm",
+				    "algorithm");
+				goto fail;
+			}
+			if (!parse_encrbits(ic, xf))
+				goto fail;
+			break;
+		case KW_P1_LIFETIME_SECS:
+			if (!parse_int(targ->t_str, &val)) {
+				tok_error(targ, ic->ic_log, "Invalid value",
+				    "value");
+				goto fail;
+			}
+			xf->xf_lifetime_secs = (uint32_t)val;
+			break;
+		case KW_P1_NONCE_LEN:
+			if (!parse_int(targ->t_str, &val)) {
+				tok_error(targ, ic->ic_log, "Invalid value",
+				    "value");
+				goto fail;
+			}
+			/* XXX: validate length */
+			xf->xf_nonce_len = (uint32_t)val;
+			break;
+		default:
+			bunyan_error(ic->ic_log, "Parameter keyword not "
+			    "allowed in transform definition",
+			    BUNYAN_T_STRING, "keyword", t->t_str,
+			    BUNYAN_T_END);
+			goto fail;
+		}
+
+		kwcount[kw]++;
+
+		tok_free(t);
+		tok_free(targ);
+		t = NULL;
+		targ = NULL;
+	}
+
+	if (kwcount[KW_ENCR_ALG] == 0) {
+		tok_error(start_t, ic->ic_log,
+		    "Transform missing encryption algorithm", NULL);
+		ok = B_FALSE;
+	}
+	if (kwcount[KW_AUTH_ALG] == 0) {
+		tok_error(start_t, ic->ic_log,
+		    "Transform missing authentication algorithm", NULL);
+		ok = B_FALSE;
+	}
+
+	end = t->t_linep + t->t_col;
+
+	/*
+ 	 * end points to closing '}' of transform, so end - start + 2
+ 	 * includes closing } plus room for NUL
+ 	 */
+	val = (uint64_t)(end - start) + 2;
+	xf->xf_str = calloc(1, val);
+	VERIFY3P(xf->xf_str, !=, NULL);
+	(void) strlcpy(xf->xf_str, start, val);
+
+	tok_free(start_t);
+	tok_free(t);
+	tok_free(targ);
+	*xfp = xf;
+	return (B_TRUE);
+
+fail:
+	tok_free(start_t);
+	tok_free(t);
+	tok_free(targ);
+	free(xf);
+	*xfp = NULL;
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_encrbits(input_cursor_t *restrict ic, config_xf_t *restrict xf)
+{
+	const token_t *tpeek = NULL;
+	token_t *t = NULL;
+	uint64_t val = 0;
+
+	if ((tpeek = input_peek(ic, B_FALSE)) == NULL)
+		goto truncated;
+
+	/* No key length given, that's ok */
+	if (strcmp(tpeek->t_str, "(") != 0)
+		return (B_TRUE);
+
+	/* consume '(' */
+	tok_free(input_token(ic, B_FALSE));
+
+	if ((t = input_token(ic, B_FALSE)) == NULL)
+		goto truncated;
+
+	if (!parse_int(t->t_str, &val))
+		goto invalid;
+	if (val > SIZE_MAX)
+		goto toobig;
+	xf->xf_minbits = (size_t)val;
+	tok_free(t);
+
+	if ((t = input_token(ic, B_FALSE)) == NULL)
+		goto truncated;
+	if (strcmp(t->t_str, ")") == 0) {
+		xf->xf_maxbits = xf->xf_minbits;
+		goto done;
+	}
+
+	if (strcmp(t->t_str, "..") != 0)
+		goto unexpected;
+	tok_free(t);
+
+	if ((t = input_token(ic, B_TRUE)) == NULL)
+		goto truncated;
+	if (!parse_int(t->t_str, &val))
+		goto invalid;
+	if (val > SIZE_MAX)
+		goto toobig;
+	xf->xf_maxbits = val;
+
+	if (xf->xf_maxbits < xf->xf_minbits) {
+		bunyan_error(ic->ic_log,
+		    "Maximum keysize is smaller than minimum keysize",
+		    BUNYAN_T_STRING, "value", t->t_str,
+		    BUNYAN_T_UINT32, "line", t->t_line,
+		    BUNYAN_T_UINT32, "col", t->t_col,
+		    BUNYAN_T_END);
+		tok_free(t);
+		return (B_FALSE);
+	}
+
+	tok_free(t);
+	if ((t = input_token(ic, B_TRUE)) == NULL)
+		goto truncated;
+	if (strcmp(t->t_str, ")") != 0)
+		goto unexpected;
+
+done:
+	tok_free(t);
+	return (B_TRUE);
+
+unexpected:
+	bunyan_error(ic->ic_log, "Unexpected value after key length",
+	    BUNYAN_T_STRING, "value", t->t_str,
+	    BUNYAN_T_UINT32, "line", t->t_line,
+	    BUNYAN_T_UINT32, "col", t->t_col,
+	    BUNYAN_T_END);
+	tok_free(t);
+	return (B_FALSE);
+
+invalid:
+	bunyan_error(ic->ic_log, "Invalid key bitlength",
+	    BUNYAN_T_STRING, "bitlength", t->t_str,
+	    BUNYAN_T_UINT32, "line", t->t_line,
+	    BUNYAN_T_UINT32, "col", t->t_col,
+	    BUNYAN_T_END);
+	tok_free(t);
+	return (B_FALSE);
+
+toobig:
+	bunyan_error(ic->ic_log, "Keysize is too large",
+	    BUNYAN_T_UINT64, "keysize", val,
+	    BUNYAN_T_UINT32, "line", t->t_line,
+	    BUNYAN_T_UINT32, "col", t->t_col,
+	    BUNYAN_T_END);
+	tok_free(t);
+	return (B_FALSE);
+
+truncated:
+	tok_free(t);
+	bunyan_error(ic->ic_log, "Truncated input while reading transform",
+	    BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_rule(input_cursor_t *restrict ic, const token_t *start,
+    config_rule_t **restrict rulep)
+{
+	token_t *t = NULL, *targ = NULL;
+	config_rule_t *rule = NULL;
+	config_xf_t *xf = NULL;
+	config_addr_t addr = { 0 };
+	size_t kwcount[KW_MAX] = { 0 };
+	boolean_t ok = B_TRUE;
+
+	*rulep = NULL;
+
+	rule = calloc(1, sizeof (*rule));
+	VERIFY3P(rule, !=, NULL);
+
+	while ((t = input_token(ic, B_FALSE)) != NULL) {
+		keyword_t kw = KW_NONE;
+
+		if (strcmp(t->t_str, "}") == 0)
+			break;
+
+		if (!parse_kw(t->t_str, &kw)) {
+			tok_log(t, ic->ic_log, BUNYAN_L_ERROR,
+			    "Unrecognized configuration parameter",
+			    "parameter");
+			goto fail;
+		}
+
+		if (KW_HAS_ARG(kw)) {
+			targ = input_token(ic, KW_USE_MINUS(kw));
+			if (targ == NULL) {
+				bunyan_error(ic->ic_log, "Input truncated "
+				    "while reading rule", BUNYAN_T_END);
+				goto fail;
+			}
+		}
+
+		if (kwcount[kw] > 0 && !KW_IS_MULTI(kw)) {
+			tok_log(t, ic->ic_log, BUNYAN_L_ERROR,
+	    		    "Configuration parameter can only appear once in a "
+			    "transform definition", "parameter");
+			goto fail;
+		}
+
+		switch (kw) {
+		case KW_LABEL:
+			rule->rule_label = strdup(targ->t_str);
+			if (rule->rule_label == NULL)
+				goto fail;
+			break;
+		case KW_P2_PFS:
+			if (!parse_p2_pfs(targ->t_str, &rule->rule_p2_dh)) {
+				tok_invalid(targ, ic->ic_log, KW_P2_PFS);
+				goto fail;
+			}
+			break;
+		case KW_P1_XFORM:
+			if (!parse_xform(ic, &xf))
+				goto fail;
+
+			add_xf(rule, xf);
+			xf = NULL;
+			break;
+		case KW_LOCAL_ADDR:
+			(void) memset(&addr, 0, sizeof (addr));
+			if (!parse_address(ic, targ, &addr))
+				goto fail;
+			add_addr(&rule->rule_local_addr,
+			    &rule->rule_nlocal_addr, &addr);
+			break;
+		case KW_REMOTE_ADDR:
+			(void) memset(&addr, 0, sizeof (addr));
+			if (!parse_address(ic, targ, &addr))
+				goto fail;
+			add_addr(&rule->rule_remote_addr,
+			    &rule->rule_nremote_addr, &addr);
+			break;
+		case KW_LOCAL_ID:
+			rule->rule_local_id = strdup(targ->t_str);
+			if (rule->rule_local_id == NULL)
+				goto fail;
+			break;
+		case KW_REMOTE_ID:
+			add_str(&rule->rule_remote_id,
+			    &rule->rule_remote_id_alloc, targ->t_str);
+			break;
+		case KW_LOCAL_ID_TYPE:
+			if (!parse_p1_id(targ->t_str,
+			    &rule->rule_local_id_type)) {
+				tok_log(t, ic->ic_log, BUNYAN_L_ERROR,
+				    "Unable to parse local_id_type", "value");
+				goto fail;
+			}
+			break;
+		case KW_IMMEDIATE:
+			rule->rule_immediate = B_TRUE;
+			break;
+		default:
+			tok_log(t, ic->ic_log, BUNYAN_L_ERROR, "Configuration "
+			    "parameter is invalid inside a rule definition",
+			    "parameter");
+			goto fail;
+		}
+
+		kwcount[(kw)]++;
+
+		tok_free(t);
+		tok_free(targ);
+		t = NULL;
+		targ = NULL;
+	}
+
+	if (t == NULL) {
+		bunyan_error(ic->ic_log, "Input truncated while reading rule",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	/* Try to show as many errors as we can */
+	if (kwcount[KW_LABEL] == 0) {
+		tok_error(start, ic->ic_log, "Rule is missing a required label",
+		    NULL);
+		ok = B_FALSE;
+	}
+	if (kwcount[KW_LOCAL_ADDR] == 0) {
+		tok_error(start, ic->ic_log,
+		    "Rule is missing a required local address", NULL);
+		ok = B_FALSE;
+	}
+	if (kwcount[KW_REMOTE_ADDR] == 0) {
+		tok_error(start, ic->ic_log,
+		    "Rule is missing a required remote address", NULL);
+		ok = B_FALSE;
+	}
+	if (kwcount[KW_P1_XFORM] > 1) {
+		ikev2_auth_type_t authtype = rule->rule_xf[0]->xf_authtype;
+
+		for (size_t i = 1; rule->rule_xf[i] != NULL; i++) {
+			if (rule->rule_xf[i]->xf_authtype == authtype)
+				continue;
+			tok_error(start, ic->ic_log,
+			    "All transforms in rule must use the same "
+			    "authentication type", NULL);
+			ok = B_FALSE;
+			break;
+		}
+	}
+
+	if (!ok)
+		goto fail;
+
+	tok_free(t);
+	tok_free(targ);
+	*rulep = rule;
+	return (B_TRUE);
+
+fail:
+	tok_free(t);
+	tok_free(targ);
+	free(rule);
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_address(input_cursor_t *restrict ic, token_t *restrict taddr,
+    config_addr_t *restrict addrp)
+{
+	const token_t *tpeek = NULL;
+	token_t *t = NULL;
+	boolean_t ip6 = B_FALSE;
+	boolean_t ok = B_FALSE;
+
+	t = taddr;
+
+	if (!parse_ip(t->t_str, &addrp->cfa_start4)) {
+		if (!parse_ip6(t->t_str, &addrp->cfa_start6)) {
+			tok_log(t, ic->ic_log, BUNYAN_L_ERROR,
+			    "Unable to parse address", "address");
+			return (B_FALSE);
+		}
+		ip6 = B_TRUE;
+	}
+
+	tpeek = input_peek(ic, B_TRUE);
+	if (strcmp(tpeek->t_str, "-") == 0) {
+		/* consume - */
+		tok_free(input_token(ic, B_TRUE));
+
+		addrp->cfa_type =
+		    ip6 ? CFG_ADDR_IPV6_RANGE : CFG_ADDR_IPV4_RANGE;
+
+		t = input_token(ic, B_FALSE);
+		if (t == NULL)
+			goto truncated;
+
+		ok = ip6 ? parse_ip6(t->t_str, &addrp->cfa_end6) :
+		    parse_ip(t->t_str, &addrp->cfa_end4);
+		if (!ok) {
+			tok_log(t, ic->ic_log, BUNYAN_L_ERROR,
+			    "Unable to parse address range", "address");
+		}
+		tok_free(t);
+		return (ok);
+	} else if (strcmp(tpeek->t_str, "/") == 0) {
+		uint64_t val = 0;
+
+		addrp->cfa_type =
+		    ip6 ? CFG_ADDR_IPV6_PREFIX : CFG_ADDR_IPV4_PREFIX;
+
+		/* consume "/" */
+		tok_free(input_token(ic, B_TRUE));
+
+		t = input_token(ic, B_FALSE);
+		if (t == NULL)
+			goto truncated;
+
+		if (!parse_int(t->t_str, &val)) {
+			tok_log(t, ic->ic_log, BUNYAN_L_ERROR,
+			    "Cannot parse mask length", "mask_len");
+			return (B_FALSE);
+		}
+		tok_free(t);
+		t = NULL;
+		if ((ip6 && val > 128) || (!ip6 && val > 32)) {
+			bunyan_error(ic->ic_log, "Mask length too long",
+			    BUNYAN_T_UINT64, "mask", val,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+		addrp->cfa_endu.cfa_num = (uint8_t)val;
+		return (B_TRUE);
+	} else {
+		addrp->cfa_type =
+		    ip6 ? CFG_ADDR_IPV6 : CFG_ADDR_IPV4;
+	}
+
+	return (B_TRUE);
+
+truncated:
+	bunyan_error(ic->ic_log, "Input truncated while parsing address",
+	    BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_p2_pfs(const char *restrict str, ikev2_dh_t *dhp)
+{
+	uint64_t val = 0;
+
+	if (!parse_int(str, &val))
+		return (B_FALSE);
+
+	/* XXX: validate value */
+
+	if (dhp != NULL)
+		*dhp = (int)val;
+	return (B_TRUE);
+}
+
+static boolean_t
+parse_ip(const char *restrict str, in_addr_t *restrict addrp)
+{
+	if (inet_pton(AF_INET, str, addrp) != 1)
+		return (B_FALSE);
+	return (B_TRUE);
+}
+
+static boolean_t
+parse_ip6(const char *restrict str, in6_addr_t *restrict addrp)
+{
+	if (inet_pton(AF_INET6, str, addrp) != 1)
+		return (B_FALSE);
+	return (B_TRUE);
+}
+
+static boolean_t
+parse_int(const char *restrict str, uint64_t *restrict intp)
+{
+	errno = 0;
+	*intp = strtoull(str, NULL, 0);
+	return ((errno == 0) ? B_TRUE : B_FALSE);
+}
+
+static boolean_t
+parse_fp(const char *restrict str, double *restrict dp)
+{
+	errno = 0;
+	*dp = strtod(str, NULL);
+	return ((errno == 0) ? B_TRUE : B_FALSE);
+}
+
+static boolean_t
+parse_kw(const char *restrict str, keyword_t *restrict kwp)
+{
+	for (keyword_t kw = KW_NONE; kw < KW_MAX; kw++) {
+		if (strcmp(keyword_tab[kw].kw_str, str) == 0) {
+			*kwp = kw;
+			VERIFY3S(*kwp, <, KW_MAX);
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_auth(const char *restrict str, ikev2_auth_type_t *restrict authp)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(auth_tab); i++) {
+		if (strcmp(auth_tab[i].a_str, str) == 0) {
+			*authp = auth_tab[i].a_id;
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_authalg(const char *restrict str, ikev2_xf_auth_t *authp)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(xf_auth_tab); i++) {
+		if (strcmp(xf_auth_tab[i].xfa_str, str) == 0) {
+			*authp = xf_auth_tab[i].xfa_id;
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_encralg(const char *restrict str, ikev2_xf_encr_t *restrict encp)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(xf_encr_tab); i++) {
+		if (strcmp(xf_encr_tab[i].xfe_str, str) == 0) {
+			*encp = xf_encr_tab[i].xfe_id;
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+parse_p1_id(const char *restrict str, config_auth_id_t *restrict p1p)
+{
+	for (size_t i = 0; i < ARRAY_SIZE(p1_id_tab); i++) {
+		if (strcmp(p1_id_tab[i].p1_str, str) == 0) {
+			*p1p = p1_id_tab[i].p1_id;
+			return (B_TRUE);
+		}
+	}
+	return (B_FALSE);
+}
+
+static token_t *
+tok_new(const char *startp, const char *endp, const char *linep, size_t line,
+    size_t col)
+{
+	VERIFY3P(endp, >=, startp);
+
+	token_t *t = NULL;
+	size_t len = (size_t)(endp - startp) + 1;
+
+	t = calloc(1, sizeof (*t));
+	VERIFY3P(t, !=, NULL);
+
+	t->t_str = calloc(1, len);
+	VERIFY3P(t, !=, NULL);
+
+	(void) strlcpy(t->t_str, startp, len);
+	t->t_linep = linep;
+	t->t_line = line;
+	t->t_col = col;
+	return (t);
+}
+
+static void
+tok_free(token_t *t)
+{
+	if (t == NULL)
+		return;
+	free(t->t_str);
+	free(t);
+}
+
+#define	STR(x) case x: return (#x)
+static const char *
+cfg_auth_id_str(config_auth_id_t id)
+{
+	switch (id) {
+	STR(CFG_AUTH_ID_DN);
+	STR(CFG_AUTH_ID_DNS);
+	STR(CFG_AUTH_ID_GN);
+	STR(CFG_AUTH_ID_IPV4);
+	STR(CFG_AUTH_ID_IPV4_PREFIX);
+	STR(CFG_AUTH_ID_IPV4_RANGE);
+	STR(CFG_AUTH_ID_IPV6);
+	STR(CFG_AUTH_ID_IPV6_PREFIX);
+	STR(CFG_AUTH_ID_IPV6_RANGE);
+	STR(CFG_AUTH_ID_EMAIL);
+	}
+	return ("UNKNOWN");
+}
+#undef	STR
+
+static void
+tok_log(const token_t *restrict t, bunyan_logger_t *restrict blog,
+    bunyan_level_t level, const char *msg, const char *strname)
+{
+	char *linecpy = NULL;
+	const char *endp = strchr(t->t_linep, '\n');
+	size_t len = 0;
+
+	if (endp != NULL)
+		len = endp - t->t_linep + 1;
+	else
+		len = strlen(t->t_linep) + 1;
+
+	linecpy = malloc(len);
+	VERIFY3P(linecpy, !=, NULL);
+	(void) strlcpy(linecpy, t->t_linep, len);
+
+	getlog(level)(blog, msg,
+	    BUNYAN_T_STRING, "line", linecpy,
+	    BUNYAN_T_UINT32, "lineno", t->t_line + 1,
+	    BUNYAN_T_UINT32, "col", t->t_col + 1,
+	    (strname != NULL) ? BUNYAN_T_STRING : BUNYAN_T_END,
+	    strname, t->t_str, BUNYAN_T_END);
+
+	free(linecpy);
+}
+
+static void
+tok_error(const token_t *restrict t, bunyan_logger_t *restrict b,
+    const char *restrict msg, const char *restrict tname)
+{
+	tok_log(t, b, BUNYAN_L_ERROR, msg, tname);
+}
+
+static void
+tok_invalid(token_t *restrict t, bunyan_logger_t *restrict b, keyword_t kw)
+{
+	char buf[128] = { 0 };
+	(void) snprintf(buf, sizeof (buf), "Invalid %s parameter",
+	    keyword_tab[kw]);
+	tok_error(t, b, buf, "parameter");
+}
+
+static input_t *
+input_new(FILE *restrict f, bunyan_logger_t *restrict blog)
+{
+	input_t *in = NULL;
+	char *p = NULL;
+	ssize_t n = 0;
+	size_t cnt = 0;
+	size_t nlines = 0;
+	struct stat sb = { 0 };
+	int fd = -1;
+
+	in = calloc(1, sizeof (*in));
+	VERIFY3P(in, !=, NULL);
+
+	fd = fileno(f);
+	if (fstat(fd, &sb) == -1) {
+		STDERR(error, blog, "stat failed");
+		goto fail;
+	}
+
+	/*
+	 * Try to read in one go, however the input could be a pipe instead
+	 * of a file, in which case we have to keep growing the buffer
+	 * (up to the limit)
+	 */
+	if (S_ISREG(sb.st_mode)) {
+		in->in_buflen = sb.st_size + 2;
+	} else {
+		in->in_buflen = CONFIG_CHUNK;
+	}
+	in->in_buf = calloc(1, in->in_buflen);
+	VERIFY3P(in->in_buf, !=, NULL);
+
+	do {
+		n = fread(in->in_buf + cnt, 1, in->in_buflen - cnt - 1, f);
+		if (n < 0) {
+			STDERR(error, blog, "read failed");
+			goto fail;
+		}
+		cnt += n;
+
+		if (cnt + 1 >= in->in_buflen) {
+			if (in->in_buflen >= CONFIG_MAX) {
+				bunyan_error(blog, "Input size exceeds limits",
+				    BUNYAN_T_UINT32, "size",
+				    (uint32_t)in->in_buflen,
+				    BUNYAN_T_UINT32, "limit",
+				    (uint32_t)CONFIG_MAX,
+				    BUNYAN_T_END);
+				goto fail;
+			}
+
+			size_t newlen = P2ROUNDUP(in->in_buflen + CONFIG_CHUNK,
+			    CONFIG_CHUNK);
+
+			char *newp = realloc(in->in_buf, newlen);
+			VERIFY3P(newp, !=, NULL);
+
+			in->in_buf = newp;
+			in->in_buflen = newlen;
+		}
+	} while (n > 0);
+	in->in_buf[cnt] = '\0';
+
+	for (p = in->in_buf, nlines = 0; p != NULL; p = strchr(p + 1, '\n'))
+		nlines++;
+
+	in->in_lines = calloc(nlines + 1, sizeof (char *));
+	VERIFY3P(in->in_lines, !=, NULL);
+
+	for (p = in->in_buf, nlines = 0; p != NULL; p = strchr(p + 1, '\n'))
+		in->in_lines[nlines++] = p;
+
+	return (in);
+
+fail:
+	input_free(in);
+	return (NULL);
+}
+
+static token_t *
+input_token(input_cursor_t *ic, boolean_t minus_is_sep)
+{
+	token_t *t = NULL;
+	if (ic->ic_peek != NULL) {
+		t = ic->ic_peek;
+		ic->ic_peek = NULL;
+	} else {
+		t = input_next_token(ic, minus_is_sep);
+	}
+
+	return (t);
+}
+
+/* NOTE: Results of input_peek() should NOT be freed */
+static const token_t *
+input_peek(input_cursor_t *ic, boolean_t minus_is_sep)
+{
+	if (ic->ic_peek != NULL)
+		return (ic->ic_peek);
+
+	ic->ic_peek = input_next_token(ic, minus_is_sep);
+	return (ic->ic_peek);
+}
+
+/*
+ * Actually get the next token from the input.  This is used both by
+ * input_token() and input_peek() and shouldn't be called by anything else.
+ */
+static token_t *
+input_next_token(input_cursor_t *ic, boolean_t minus_is_sep)
+{
+	char *start = NULL, *end = NULL;
+	const char *linep = NULL;
+	uint32_t line = 0, col = 0;
+
+	VERIFY3P(ic->ic_p, >=, ic->ic_input->in_buf);
+	VERIFY3P(ic->ic_p, <, ic->ic_input->in_buf + ic->ic_input->in_buflen);
+
+again:
+	while (*ic->ic_p != '\0' && isspace(*ic->ic_p))
+		ic->ic_p++;
+
+	if (*ic->ic_p == '#') {
+		/* skip to next line */
+		while (*ic->ic_p != '\0' && *ic->ic_p != '\n')
+			ic->ic_p++;
+		goto again;
+	}
+
+	if (*ic->ic_p == '\0')
+		return (NULL);
+
+	start = ic->ic_p;
+	end = start + 1;
+
+	/* If the first character is a separator, we're done */
+	if (issep(*start, minus_is_sep)) {
+		ic->ic_p = end;
+		goto done;
+	}
+
+	if (*start == '"') {
+		while (*end != '\0' && *end != '\n' && *end != '"')
+			end++;
+
+		if (*end != '"') {
+			input_cursor_getpos(ic, start, &linep, &line, &col);
+			bunyan_error(ic->ic_log, "Unterminated quoted string",
+			    BUNYAN_T_UINT32, "line", line,
+			    BUNYAN_T_UINT32, "col", col,
+			    BUNYAN_T_END);
+			return (NULL);
+		}
+
+		start++;
+		ic->ic_p = end + 1;
+		goto done;
+	}
+
+	while (*end != '\0' && !isspace(*end)) {
+		if (issep(*end, minus_is_sep) || isspace(*end))
+			break;
+		end++;
+	}
+	ic->ic_p = end;
+
+done:
+	input_cursor_getpos(ic, start, &linep, &line, &col);
+	return (tok_new(start, end, linep, line, col));
+}
+
+static void
+input_cursor_getpos(input_cursor_t *restrict ic, const char *restrict p,
+    const char **restrict linepp, uint32_t *restrict linep,
+    uint32_t *restrict colp)
+{
+	VERIFY3P(ic->ic_input->in_buf, <=, p);
+	VERIFY3P(ic->ic_input->in_buf + ic->ic_input->in_buflen, >, p);
+
+	char **lineidx = ic->ic_input->in_lines;
+	uint32_t line;
+	for (line = 1; lineidx[line] != NULL && lineidx[line] <= p; line++)
+		;
+
+	line--;
+	*linep = line;
+	*colp = (uint32_t)(p - lineidx[line]);
+	*linepp = lineidx[line];
+}
+
+static void
+input_cursor_init(input_cursor_t *restrict ic, input_t *restrict in,
+    bunyan_logger_t *blog)
+{
+	(void) memset(ic, 0, sizeof (*ic));
+	ic->ic_input = in;
+	ic->ic_p = in->in_buf;
+	ic->ic_log = blog;
+}
+
+static void
+input_cursor_fini(input_cursor_t *ic)
+{
+	free(ic->ic_peek);
+	(void) memset(ic, 0, sizeof (*ic));
+}
+
+static void
+input_free(input_t *in)
+{
+	if (in == NULL)
+		return;
+
+	free(in->in_buf);
+	free(in->in_lines);
+	free(in);
+}
+
+#define	CHUNK_SZ	(8)
+/*
+ * Append a string onto an array of strings.  Since these shouldn't be heavily
+ * called, we're not (currently at least) worried about the possibility
+ * of excessive realloc() calls.
+ */
+static void
+add_str(char ***restrict ppp, size_t *restrict allocp, const char *restrict str)
+{
+	char *newstr = NULL;
+	char **array = *ppp;
+	size_t nelems = 0;
+
+	while (nelems < *allocp && array[nelems] != NULL)
+		nelems++;
+
+	if (nelems + 2 > *allocp) {
+		char **newarray = NULL;
+		size_t newsize = *allocp + CHUNK_SZ;
+		size_t amt = newsize * sizeof (char *);
+
+		VERIFY3U(amt, >, newsize);
+		VERIFY3U(amt, >=, sizeof (char *));
+
+		/* realloc_array() would be nice */
+		newarray = realloc(array, amt);
+		VERIFY3P(newarray, !=, NULL);
+
+		*ppp = array = newarray;
+		*allocp = newsize;
+	}
+
+	newstr = strdup(str);
+	VERIFY3P(newstr, !=, NULL);
+
+	array[nelems++] = newstr;
+	array[nelems] = NULL;
+}
+
+static void
+add_xf(config_rule_t *restrict rule, config_xf_t *restrict xf)
+{
+	size_t nxf = 0;
+
+	while (nxf < rule->rule_nxf && rule->rule_xf[nxf] != NULL)
+		nxf++;
+
+	if (nxf + 2 > rule->rule_nxf) {
+		config_xf_t **newxf = NULL;
+		size_t newalloc = rule->rule_nxf + CHUNK_SZ;
+		size_t amt = newalloc * sizeof (config_xf_t *);
+
+		VERIFY3U(amt, >, newalloc);
+		VERIFY3U(amt, >=, sizeof (config_xf_t *));
+
+		newxf = realloc(rule->rule_xf, amt);
+		VERIFY3P(newxf, !=, NULL);
+
+		rule->rule_nxf = newalloc;
+		rule->rule_xf = newxf;
+	}
+
+	rule->rule_xf[nxf++] = xf;
+	rule->rule_xf[nxf] = NULL;
+}
+
+static void
+add_rule(config_t *restrict cfg, config_rule_t *restrict rule)
+{
+	/* TODO: validate label value is unique */
+	size_t nrules = 0;
+
+	while (nrules < cfg->cfg_rules_alloc && cfg->cfg_rules[nrules] != NULL)
+		nrules++;
+
+	if (nrules + 2 > cfg->cfg_rules_alloc) {
+		config_rule_t **newrules = NULL;
+		size_t newalloc = cfg->cfg_rules_alloc + CHUNK_SZ;
+		size_t amt = newalloc * sizeof (config_rule_t *);
+
+		VERIFY3U(amt, >, newalloc);
+		VERIFY3U(amt, >=, sizeof (config_rule_t *));
+
+		newrules = realloc(cfg->cfg_rules, amt);
+		VERIFY3P(newrules, !=, NULL);
+
+		cfg->cfg_rules = newrules;
+		cfg->cfg_rules_alloc = newalloc;
+	}
+
+	rule->rule_config = cfg;
+	cfg->cfg_rules[nrules++] = rule;
+	cfg->cfg_rules[nrules] = NULL;
+}
+
+static void
+add_addr(config_addr_t **restrict addrs, size_t *restrict naddrs,
+    const config_addr_t *restrict src)
+{
+	config_addr_t *newaddrs = NULL;
+	size_t newlen = *naddrs + 1;
+	size_t newamt = newlen * sizeof (config_addr_t);
+
+	VERIFY3U(newamt, >=, sizeof (config_addr_t));
+	VERIFY3U(newamt, >, newlen);
+
+	newaddrs = realloc(*addrs, newamt);
+	VERIFY3P(newaddrs, !=, NULL);
+
+	(void) memcpy(&newaddrs[*naddrs], src, sizeof (*src));
+
+	*addrs = newaddrs;
+	*naddrs += 1;
+}
+
+/* Is the given character a token separator? */
+static boolean_t
+issep(char c, boolean_t minus_is_sep)
+{
+	switch (c) {
+	case '{': case '}':
+	case '(': case ')':
+	case '/':
+		return (B_TRUE);
+	case '-':
+		if (minus_is_sep)
+			return (B_TRUE);
+		break;
+	}
+	return (B_FALSE);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/defs.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/defs.h
new file mode 100644
index 0000000000..8f722e62bf
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/defs.h
@@ -0,0 +1,228 @@
+
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _DEFS_H
+#define	_DEFS_H
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/debug.h>
+#include <ikedoor.h>
+#include <cryptoutil.h>
+#include <security/cryptoki.h>
+#include <stdio.h>
+#include <assert.h>
+#include <umem.h>
+#include <bunyan.h>
+#include <libintl.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifndef SOCKADDR_U_T
+#define	SOCKADDR_U_T
+typedef union sockaddr_u_s {
+	struct sockaddr_storage *sau_ss;
+	struct sockaddr_in	*sau_sin;
+	struct sockaddr_in6	*sau_sin6;
+} sockaddr_u_t;
+#endif /* SOCKADDR_U_T */
+
+/* Parsed-out PF_KEY message. */
+typedef struct parsedmsg_s {
+	struct parsedmsg_s *pmsg_next;
+	sadb_msg_t *pmsg_samsg;
+	sadb_ext_t *pmsg_exts[SADB_EXT_MAX + 2]; /* 2 for alignment */
+	sockaddr_u_t pmsg_sau;
+	sockaddr_u_t pmsg_dau;
+	sockaddr_u_t pmsg_isau;
+	sockaddr_u_t pmsg_idau;
+	sockaddr_u_t pmsg_nlau;
+	sockaddr_u_t pmsg_nrau;
+} parsedmsg_t;
+
+#define	pmsg_sss pmsg_sau.sau_ss
+#define	pmsg_ssin pmsg_sau.sau_sin
+#define	pmsg_ssin6 pmsg_sau.sau_sin6
+#define	pmsg_dss pmsg_dau.sau_ss
+#define	pmsg_dsin pmsg_dau.sau_sin
+#define	pmsg_dsin6 pmsg_dau.sau_sin6
+#define	pmsg_isss pmsg_isau.sau_ss
+#define	pmsg_issin pmsg_isau.sau_sin
+#define	pmsg_issin6 pmsg_isau.sau_sin6
+#define	pmsg_idss pmsg_idau.sau_ss
+#define	pmsg_idsin pmsg_idau.sau_sin
+#define	pmsg_idsin6 pmsg_idau.sau_sin6
+#define	pmsg_nlss pmsg_nlau.sau_ss
+#define	pmsg_nlsin pmsg_nlau.sau_sin
+#define	pmsg_nlsin6 pmsg_nlau.sau_sin6
+#define	pmsg_nrss pmsg_nrau.sau_ss
+#define	pmsg_nrsin pmsg_rnau.sau_sin
+#define	pmsg_nrsin6 pmsg_nrau.sau_sin6
+
+typedef void (*pfreq_cb_t)(sadb_msg_t *, void *);
+typedef struct algindex {
+	const char *desc;
+	int doi_num;
+} algindex_t;
+
+/*
+ * Compare two AF_INET{,6} sockaddrs (no port).  Assume sockaddr_storage
+ * pointers are passed, and also verifies the address families match and
+ * are either AF_INET or AF_INET6.
+ */
+#define	SA_ADDR_EQ(sa1, sa2)						\
+	(((sa1)->ss_family == (sa2)->ss_family) &&			\
+	    ((((sa1)->ss_family == AF_INET) &&				\
+		((struct sockaddr_in *)(sa1))->sin_addr.s_addr ==	\
+		((struct sockaddr_in *)(sa2))->sin_addr.s_addr) ||	\
+		(((sa1)->ss_family == AF_INET6) &&			\
+		IN6_ARE_ADDR_EQUAL(&((struct sockaddr_in6 *)(sa1))->sin6_addr,\
+		    &((struct sockaddr_in6 *)(sa2))->sin6_addr))))
+
+/*
+ * Compare two AF_INET{,6} sockaddr ports.  Exploit the identical offsets for
+ * sin_port/sin6_port.  (Does not check sockaddr families a priori.)
+ */
+#define	SA_PORT_EQ(sa1, sa2) (((struct sockaddr_in *)(sa1))->sin_port == \
+	    ((struct sockaddr_in *)(sa2))->sin_port)
+
+/*
+ * Compare two AF_INET{,6} sockaddrs (including ports).  Exploit the
+ * identical offsets for sin_port/sin6_port.
+ */
+#define	SA_FULL_EQ(sa1, sa2) (SA_ADDR_EQ(sa1, sa2) && SA_PORT_EQ(sa1, sa2))
+
+#define	NOMEM assfail("Out of memory", __FILE__, __LINE__)
+#define	INVALID(var) assfail("Invalid value of " # var, __FILE__, __LINE__)
+
+#ifndef ARRAY_SIZE
+#define	ARRAY_SIZE(x) (sizeof (x) / sizeof (x[0]))
+#endif
+
+/* cstyle cannot handle ## __VA_ARGS */
+/* BEGIN CSTYLED */
+#define	STDERR(_lvl, _log, _msg, ...)			\
+	(void) bunyan_##_lvl((_log), (_msg),		\
+	BUNYAN_T_STRING, "err", strerror(errno),	\
+	BUNYAN_T_INT32, "errno", (int32_t)(errno),	\
+	BUNYAN_T_STRING, "func", __func__,		\
+	BUNYAN_T_STRING, "file", __FILE__,		\
+	BUNYAN_T_INT32, "line", __LINE__,		\
+	## __VA_ARGS__,					\
+	BUNYAN_T_END)
+/* END CSTYLED */
+
+static inline uint32_t
+ss_port(const struct sockaddr_storage *ss)
+{
+	sockaddr_u_t sau;
+	sau.sau_ss = (struct sockaddr_storage *)ss;
+	switch (ss->ss_family) {
+	case AF_INET:
+		return ((uint32_t)ntohs(sau.sau_sin->sin_port));
+	case AF_INET6:
+		return ((uint32_t)ntohs(sau.sau_sin6->sin6_port));
+	default:
+		INVALID("ss->ss_family");
+		/*NOTREACHED*/
+		return (0);
+	}
+}
+
+static inline const void *
+ss_addr(const struct sockaddr_storage *ss)
+{
+	sockaddr_u_t sau;
+	sau.sau_ss = (struct sockaddr_storage *)ss;
+	switch (ss->ss_family) {
+	case AF_INET:
+		return (&sau.sau_sin->sin_addr);
+	case AF_INET6:
+		return (&sau.sau_sin6->sin6_addr);
+	default:
+		INVALID("ss->ss_family");
+		/*NOTREACHED*/
+		return (NULL);
+	}
+}
+
+static inline int
+ss_bunyan(const struct sockaddr_storage *ss)
+{
+	switch (ss->ss_family) {
+	case AF_INET:
+		return (BUNYAN_T_IP);
+	case AF_INET6:
+		return (BUNYAN_T_IP6);
+	default:
+		INVALID("ss->ss_family");
+		/*NOTREACHED*/
+		return (BUNYAN_T_END);
+	}
+}
+
+/* BEGIN CSTYLED */
+#define	NETLOG(_level, _log, _msg, _src, _dest, ...)	\
+	(void) bunyan_##_level((_log), (_msg),		\
+	BUNYAN_T_STRING, "func", __func__,		\
+	BUNYAN_T_STRING, "file", __FILE__,		\
+	BUNYAN_T_INT32, "line", __LINE__,		\
+	ss_bunyan(_src), "srcaddr", ss_addr(_src),	\
+	BUNYAN_T_UINT32, "srcport", ss_port(_src),	\
+	ss_bunyan(_dest), "destaddr", ss_addr(_dest),	\
+	BUNYAN_T_UINT32, "destport", ss_port(_dest),	\
+	## __VA_ARGS__,					\
+	BUNYAN_T_END)
+/* END CSTYLED */
+
+typedef enum event {
+	EVENT_NONE,
+	EVENT_SIGNAL
+} event_t;
+
+extern char *my_fmri;
+extern bunyan_logger_t *log;
+extern int port;
+
+typedef int (*bunyan_logfn_t)(bunyan_logger_t *, const char *, ...);
+bunyan_logfn_t getlog(bunyan_level_t);
+
+const char *afstr(sa_family_t);
+const char *symstr(void *);
+const char *event_str(event_t);
+const char *port_source_str(ushort_t);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif  /* _DEFS_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.c
new file mode 100644
index 0000000000..2894e03447
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.c
@@ -0,0 +1,407 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <sys/types.h>
+#include <security/cryptoki.h>
+#include <bunyan.h>
+#include "dh.h"
+#include "ikev2_enum.h"
+#include "pkcs11.h"
+
+typedef struct {
+	ikev2_dh_t	id;
+	size_t		bits;
+	size_t		genbits;
+	uint8_t		*prime;
+	uint8_t		*generator;
+} dhgroup_t;
+
+
+static dhgroup_t dh_groups[] = {
+	{
+		.id = IKEV2_DH_MODP_768,
+		.bits = 768,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45"
+	},
+	{
+		.id = IKEV2_DH_MODP_1024,
+		.bits = 1024,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE6\x53\x81\xFF\xFF"
+		    "\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_1536,
+		.bits = 1536,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x23\x73\x27\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_2048,
+		.bits = 2048,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAC\xAA\x68"
+		    "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_3072,
+		.bits = 3072,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAA\xC4\x2D"
+		    "\xAD\x33\x17\x0D\x04\x50\x7A\x33\xA8\x55\x21\xAB\xDF\x1C"
+		    "\xBA\x64\xEC\xFB\x85\x04\x58\xDB\xEF\x0A\x8A\xEA\x71\x57"
+		    "\x5D\x06\x0C\x7D\xB3\x97\x0F\x85\xA6\xE1\xE4\xC7\xAB\xF5"
+		    "\xAE\x8C\xDB\x09\x33\xD7\x1E\x8C\x94\xE0\x4A\x25\x61\x9D"
+		    "\xCE\xE3\xD2\x26\x1A\xD2\xEE\x6B\xF1\x2F\xFA\x06\xD9\x8A"
+		    "\x08\x64\xD8\x76\x02\x73\x3E\xC8\x6A\x64\x52\x1F\x2B\x18"
+		    "\x17\x7B\x20\x0C\xBB\xE1\x17\x57\x7A\x61\x5D\x6C\x77\x09"
+		    "\x88\xC0\xBA\xD9\x46\xE2\x08\xE2\x4F\xA0\x74\xE5\xAB\x31"
+		    "\x43\xDB\x5B\xFC\xE0\xFD\x10\x8E\x4B\x82\xD1\x20\xA9\x3A"
+		    "\xD2\xCA\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_4096,
+		.bits = 4096,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAA\xC4\x2D"
+		    "\xAD\x33\x17\x0D\x04\x50\x7A\x33\xA8\x55\x21\xAB\xDF\x1C"
+		    "\xBA\x64\xEC\xFB\x85\x04\x58\xDB\xEF\x0A\x8A\xEA\x71\x57"
+		    "\x5D\x06\x0C\x7D\xB3\x97\x0F\x85\xA6\xE1\xE4\xC7\xAB\xF5"
+		    "\xAE\x8C\xDB\x09\x33\xD7\x1E\x8C\x94\xE0\x4A\x25\x61\x9D"
+		    "\xCE\xE3\xD2\x26\x1A\xD2\xEE\x6B\xF1\x2F\xFA\x06\xD9\x8A"
+		    "\x08\x64\xD8\x76\x02\x73\x3E\xC8\x6A\x64\x52\x1F\x2B\x18"
+		    "\x17\x7B\x20\x0C\xBB\xE1\x17\x57\x7A\x61\x5D\x6C\x77\x09"
+		    "\x88\xC0\xBA\xD9\x46\xE2\x08\xE2\x4F\xA0\x74\xE5\xAB\x31"
+		    "\x43\xDB\x5B\xFC\xE0\xFD\x10\x8E\x4B\x82\xD1\x20\xA9\x21"
+		    "\x08\x01\x1A\x72\x3C\x12\xA7\x87\xE6\xD7\x88\x71\x9A\x10"
+		    "\xBD\xBA\x5B\x26\x99\xC3\x27\x18\x6A\xF4\xE2\x3C\x1A\x94"
+		    "\x68\x34\xB6\x15\x0B\xDA\x25\x83\xE9\xCA\x2A\xD4\x4C\xE8"
+		    "\xDB\xBB\xC2\xDB\x04\xDE\x8E\xF9\x2E\x8E\xFC\x14\x1F\xBE"
+		    "\xCA\xA6\x28\x7C\x59\x47\x4E\x6B\xC0\x5D\x99\xB2\x96\x4F"
+		    "\xA0\x90\xC3\xA2\x23\x3B\xA1\x86\x51\x5B\xE7\xED\x1F\x61"
+		    "\x29\x70\xCE\xE2\xD7\xAF\xB8\x1B\xDD\x76\x21\x70\x48\x1C"
+		    "\xD0\x06\x91\x27\xD5\xB0\x5A\xA9\x93\xB4\xEA\x98\x8D\x8F"
+		    "\xDD\xC1\x86\xFF\xB7\xDC\x90\xA6\xC0\x8F\x4D\xF4\x35\xC9"
+		    "\x34\x06\x31\x99\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_6144,
+		.bits = 6144,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAA\xC4\x2D"
+		    "\xAD\x33\x17\x0D\x04\x50\x7A\x33\xA8\x55\x21\xAB\xDF\x1C"
+		    "\xBA\x64\xEC\xFB\x85\x04\x58\xDB\xEF\x0A\x8A\xEA\x71\x57"
+		    "\x5D\x06\x0C\x7D\xB3\x97\x0F\x85\xA6\xE1\xE4\xC7\xAB\xF5"
+		    "\xAE\x8C\xDB\x09\x33\xD7\x1E\x8C\x94\xE0\x4A\x25\x61\x9D"
+		    "\xCE\xE3\xD2\x26\x1A\xD2\xEE\x6B\xF1\x2F\xFA\x06\xD9\x8A"
+		    "\x08\x64\xD8\x76\x02\x73\x3E\xC8\x6A\x64\x52\x1F\x2B\x18"
+		    "\x17\x7B\x20\x0C\xBB\xE1\x17\x57\x7A\x61\x5D\x6C\x77\x09"
+		    "\x88\xC0\xBA\xD9\x46\xE2\x08\xE2\x4F\xA0\x74\xE5\xAB\x31"
+		    "\x43\xDB\x5B\xFC\xE0\xFD\x10\x8E\x4B\x82\xD1\x20\xA9\x21"
+		    "\x08\x01\x1A\x72\x3C\x12\xA7\x87\xE6\xD7\x88\x71\x9A\x10"
+		    "\xBD\xBA\x5B\x26\x99\xC3\x27\x18\x6A\xF4\xE2\x3C\x1A\x94"
+		    "\x68\x34\xB6\x15\x0B\xDA\x25\x83\xE9\xCA\x2A\xD4\x4C\xE8"
+		    "\xDB\xBB\xC2\xDB\x04\xDE\x8E\xF9\x2E\x8E\xFC\x14\x1F\xBE"
+		    "\xCA\xA6\x28\x7C\x59\x47\x4E\x6B\xC0\x5D\x99\xB2\x96\x4F"
+		    "\xA0\x90\xC3\xA2\x23\x3B\xA1\x86\x51\x5B\xE7\xED\x1F\x61"
+		    "\x29\x70\xCE\xE2\xD7\xAF\xB8\x1B\xDD\x76\x21\x70\x48\x1C"
+		    "\xD0\x06\x91\x27\xD5\xB0\x5A\xA9\x93\xB4\xEA\x98\x8D\x8F"
+		    "\xDD\xC1\x86\xFF\xB7\xDC\x90\xA6\xC0\x8F\x4D\xF4\x35\xC9"
+		    "\x34\x02\x84\x92\x36\xC3\xFA\xB4\xD2\x7C\x70\x26\xC1\xD4"
+		    "\xDC\xB2\x60\x26\x46\xDE\xC9\x75\x1E\x76\x3D\xBA\x37\xBD"
+		    "\xF8\xFF\x94\x06\xAD\x9E\x53\x0E\xE5\xDB\x38\x2F\x41\x30"
+		    "\x01\xAE\xB0\x6A\x53\xED\x90\x27\xD8\x31\x17\x97\x27\xB0"
+		    "\x86\x5A\x89\x18\xDA\x3E\xDB\xEB\xCF\x9B\x14\xED\x44\xCE"
+		    "\x6C\xBA\xCE\xD4\xBB\x1B\xDB\x7F\x14\x47\xE6\xCC\x25\x4B"
+		    "\x33\x20\x51\x51\x2B\xD7\xAF\x42\x6F\xB8\xF4\x01\x37\x8C"
+		    "\xD2\xBF\x59\x83\xCA\x01\xC6\x4B\x92\xEC\xF0\x32\xEA\x15"
+		    "\xD1\x72\x1D\x03\xF4\x82\xD7\xCE\x6E\x74\xFE\xF6\xD5\x5E"
+		    "\x70\x2F\x46\x98\x0C\x82\xB5\xA8\x40\x31\x90\x0B\x1C\x9E"
+		    "\x59\xE7\xC9\x7F\xBE\xC7\xE8\xF3\x23\xA9\x7A\x7E\x36\xCC"
+		    "\x88\xBE\x0F\x1D\x45\xB7\xFF\x58\x5A\xC5\x4B\xD4\x07\xB2"
+		    "\x2B\x41\x54\xAA\xCC\x8F\x6D\x7E\xBF\x48\xE1\xD8\x14\xCC"
+		    "\x5E\xD2\x0F\x80\x37\xE0\xA7\x97\x15\xEE\xF2\x9B\xE3\x28"
+		    "\x06\xA1\xD5\x8B\xB7\xC5\xDA\x76\xF5\x50\xAA\x3D\x8A\x1F"
+		    "\xBF\xF0\xEB\x19\xCC\xB1\xA3\x13\xD5\x5C\xDA\x56\xC9\xEC"
+		    "\x2E\xF2\x96\x32\x38\x7F\xE8\xD7\x6E\x3C\x04\x68\x04\x3E"
+		    "\x8F\x66\x3F\x48\x60\xEE\x12\xBF\x2D\x5B\x0B\x74\x74\xD6"
+		    "\xE6\x94\xF9\x1E\x6D\xCC\x40\x24\xFF\xFF\xFF\xFF\xFF\xFF"
+		    "\xFF\xFF"
+	},
+	{
+		.id = IKEV2_DH_MODP_8192,
+		.bits = 8192,
+		.genbits = 8,
+		.generator = (uint8_t *)"\x02",
+		.prime = (uint8_t *)"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x0F"
+		    "\xDA\xA2\x21\x68\xC2\x34\xC4\xC6\x62\x8B\x80\xDC\x1C\xD1"
+		    "\x29\x02\x4E\x08\x8A\x67\xCC\x74\x02\x0B\xBE\xA6\x3B\x13"
+		    "\x9B\x22\x51\x4A\x08\x79\x8E\x34\x04\xDD\xEF\x95\x19\xB3"
+		    "\xCD\x3A\x43\x1B\x30\x2B\x0A\x6D\xF2\x5F\x14\x37\x4F\xE1"
+		    "\x35\x6D\x6D\x51\xC2\x45\xE4\x85\xB5\x76\x62\x5E\x7E\xC6"
+		    "\xF4\x4C\x42\xE9\xA6\x37\xED\x6B\x0B\xFF\x5C\xB6\xF4\x06"
+		    "\xB7\xED\xEE\x38\x6B\xFB\x5A\x89\x9F\xA5\xAE\x9F\x24\x11"
+		    "\x7C\x4B\x1F\xE6\x49\x28\x66\x51\xEC\xE4\x5B\x3D\xC2\x00"
+		    "\x7C\xB8\xA1\x63\xBF\x05\x98\xDA\x48\x36\x1C\x55\xD3\x9A"
+		    "\x69\x16\x3F\xA8\xFD\x24\xCF\x5F\x83\x65\x5D\x23\xDC\xA3"
+		    "\xAD\x96\x1C\x62\xF3\x56\x20\x85\x52\xBB\x9E\xD5\x29\x07"
+		    "\x70\x96\x96\x6D\x67\x0C\x35\x4E\x4A\xBC\x98\x04\xF1\x74"
+		    "\x6C\x08\xCA\x18\x21\x7C\x32\x90\x5E\x46\x2E\x36\xCE\x3B"
+		    "\xE3\x9E\x77\x2C\x18\x0E\x86\x03\x9B\x27\x83\xA2\xEC\x07"
+		    "\xA2\x8F\xB5\xC5\x5D\xF0\x6F\x4C\x52\xC9\xDE\x2B\xCB\xF6"
+		    "\x95\x58\x17\x18\x39\x95\x49\x7C\xEA\x95\x6A\xE5\x15\xD2"
+		    "\x26\x18\x98\xFA\x05\x10\x15\x72\x8E\x5A\x8A\xAA\xC4\x2D"
+		    "\xAD\x33\x17\x0D\x04\x50\x7A\x33\xA8\x55\x21\xAB\xDF\x1C"
+		    "\xBA\x64\xEC\xFB\x85\x04\x58\xDB\xEF\x0A\x8A\xEA\x71\x57"
+		    "\x5D\x06\x0C\x7D\xB3\x97\x0F\x85\xA6\xE1\xE4\xC7\xAB\xF5"
+		    "\xAE\x8C\xDB\x09\x33\xD7\x1E\x8C\x94\xE0\x4A\x25\x61\x9D"
+		    "\xCE\xE3\xD2\x26\x1A\xD2\xEE\x6B\xF1\x2F\xFA\x06\xD9\x8A"
+		    "\x08\x64\xD8\x76\x02\x73\x3E\xC8\x6A\x64\x52\x1F\x2B\x18"
+		    "\x17\x7B\x20\x0C\xBB\xE1\x17\x57\x7A\x61\x5D\x6C\x77\x09"
+		    "\x88\xC0\xBA\xD9\x46\xE2\x08\xE2\x4F\xA0\x74\xE5\xAB\x31"
+		    "\x43\xDB\x5B\xFC\xE0\xFD\x10\x8E\x4B\x82\xD1\x20\xA9\x21"
+		    "\x08\x01\x1A\x72\x3C\x12\xA7\x87\xE6\xD7\x88\x71\x9A\x10"
+		    "\xBD\xBA\x5B\x26\x99\xC3\x27\x18\x6A\xF4\xE2\x3C\x1A\x94"
+		    "\x68\x34\xB6\x15\x0B\xDA\x25\x83\xE9\xCA\x2A\xD4\x4C\xE8"
+		    "\xDB\xBB\xC2\xDB\x04\xDE\x8E\xF9\x2E\x8E\xFC\x14\x1F\xBE"
+		    "\xCA\xA6\x28\x7C\x59\x47\x4E\x6B\xC0\x5D\x99\xB2\x96\x4F"
+		    "\xA0\x90\xC3\xA2\x23\x3B\xA1\x86\x51\x5B\xE7\xED\x1F\x61"
+		    "\x29\x70\xCE\xE2\xD7\xAF\xB8\x1B\xDD\x76\x21\x70\x48\x1C"
+		    "\xD0\x06\x91\x27\xD5\xB0\x5A\xA9\x93\xB4\xEA\x98\x8D\x8F"
+		    "\xDD\xC1\x86\xFF\xB7\xDC\x90\xA6\xC0\x8F\x4D\xF4\x35\xC9"
+		    "\x34\x02\x84\x92\x36\xC3\xFA\xB4\xD2\x7C\x70\x26\xC1\xD4"
+		    "\xDC\xB2\x60\x26\x46\xDE\xC9\x75\x1E\x76\x3D\xBA\x37\xBD"
+		    "\xF8\xFF\x94\x06\xAD\x9E\x53\x0E\xE5\xDB\x38\x2F\x41\x30"
+		    "\x01\xAE\xB0\x6A\x53\xED\x90\x27\xD8\x31\x17\x97\x27\xB0"
+		    "\x86\x5A\x89\x18\xDA\x3E\xDB\xEB\xCF\x9B\x14\xED\x44\xCE"
+		    "\x6C\xBA\xCE\xD4\xBB\x1B\xDB\x7F\x14\x47\xE6\xCC\x25\x4B"
+		    "\x33\x20\x51\x51\x2B\xD7\xAF\x42\x6F\xB8\xF4\x01\x37\x8C"
+		    "\xD2\xBF\x59\x83\xCA\x01\xC6\x4B\x92\xEC\xF0\x32\xEA\x15"
+		    "\xD1\x72\x1D\x03\xF4\x82\xD7\xCE\x6E\x74\xFE\xF6\xD5\x5E"
+		    "\x70\x2F\x46\x98\x0C\x82\xB5\xA8\x40\x31\x90\x0B\x1C\x9E"
+		    "\x59\xE7\xC9\x7F\xBE\xC7\xE8\xF3\x23\xA9\x7A\x7E\x36\xCC"
+		    "\x88\xBE\x0F\x1D\x45\xB7\xFF\x58\x5A\xC5\x4B\xD4\x07\xB2"
+		    "\x2B\x41\x54\xAA\xCC\x8F\x6D\x7E\xBF\x48\xE1\xD8\x14\xCC"
+		    "\x5E\xD2\x0F\x80\x37\xE0\xA7\x97\x15\xEE\xF2\x9B\xE3\x28"
+		    "\x06\xA1\xD5\x8B\xB7\xC5\xDA\x76\xF5\x50\xAA\x3D\x8A\x1F"
+		    "\xBF\xF0\xEB\x19\xCC\xB1\xA3\x13\xD5\x5C\xDA\x56\xC9\xEC"
+		    "\x2E\xF2\x96\x32\x38\x7F\xE8\xD7\x6E\x3C\x04\x68\x04\x3E"
+		    "\x8F\x66\x3F\x48\x60\xEE\x12\xBF\x2D\x5B\x0B\x74\x74\xD6"
+		    "\xE6\x94\xF9\x1E\x6D\xBE\x11\x59\x74\xA3\x92\x6F\x12\xFE"
+		    "\xE5\xE4\x38\x77\x7C\xB6\xA9\x32\xDF\x8C\xD8\xBE\xC4\xD0"
+		    "\x73\xB9\x31\xBA\x3B\xC8\x32\xB6\x8D\x9D\xD3\x00\x74\x1F"
+		    "\xA7\xBF\x8A\xFC\x47\xED\x25\x76\xF6\x93\x6B\xA4\x24\x66"
+		    "\x3A\xAB\x63\x9C\x5A\xE4\xF5\x68\x34\x23\xB4\x74\x2B\xF1"
+		    "\xC9\x78\x23\x8F\x16\xCB\xE3\x9D\x65\x2D\xE3\xFD\xB8\xBE"
+		    "\xFC\x84\x8A\xD9\x22\x22\x2E\x04\xA4\x03\x7C\x07\x13\xEB"
+		    "\x57\xA8\x1A\x23\xF0\xC7\x34\x73\xFC\x64\x6C\xEA\x30\x6B"
+		    "\x4B\xCB\xC8\x86\x2F\x83\x85\xDD\xFA\x9D\x4B\x7F\xA2\xC0"
+		    "\x87\xE8\x79\x68\x33\x03\xED\x5B\xDD\x3A\x06\x2B\x3C\xF5"
+		    "\xB3\xA2\x78\xA6\x6D\x2A\x13\xF8\x3F\x44\xF8\x2D\xDF\x31"
+		    "\x0E\xE0\x74\xAB\x6A\x36\x45\x97\xE8\x99\xA0\x25\x5D\xC1"
+		    "\x64\xF3\x1C\xC5\x08\x46\x85\x1D\xF9\xAB\x48\x19\x5D\xED"
+		    "\x7E\xA1\xB1\xD5\x10\xBD\x7E\xE7\x4D\x73\xFA\xF3\x6B\xC3"
+		    "\x1E\xCF\xA2\x68\x35\x90\x46\xF4\xEB\x87\x9F\x92\x40\x09"
+		    "\x43\x8B\x48\x1C\x6C\xD7\x88\x9A\x00\x2E\xD5\xEE\x38\x2B"
+		    "\xC9\x19\x0D\xA6\xFC\x02\x6E\x47\x95\x58\xE4\x47\x56\x77"
+		    "\xE9\xAA\x9E\x30\x50\xE2\x76\x56\x94\xDF\xC8\x1F\x56\xE8"
+		    "\x80\xB9\x6E\x71\x60\xC9\x80\xDD\x98\xED\xD3\xDF\xFF\xFF"
+		    "\xFF\xFF\xFF\xFF\xFF\xFF"
+	}
+};
+#define	NUM_DHGROUPS	(ARRAY_SIZE(dh_groups))
+
+static dhgroup_t *
+dh_get_group(ikev2_dh_t id)
+{
+	int i;
+
+	for (i = 0; i < NUM_DHGROUPS; i++) {
+		if (dh_groups[i].id == id)
+			return (&dh_groups[i]);
+	}
+
+	return (NULL);
+}
+
+boolean_t
+dh_genpair(ikev2_dh_t group, CK_OBJECT_HANDLE_PTR restrict pub,
+    CK_OBJECT_HANDLE_PTR restrict priv, bunyan_logger_t *restrict l)
+{
+	dhgroup_t *dh;
+	CK_MECHANISM mech = { CKM_DH_PKCS_KEY_PAIR_GEN, NULL_PTR, 0 };
+	CK_ATTRIBUTE template[2];
+	CK_RV rc;
+
+	dh = dh_get_group(group);
+	if (dh == NULL) {
+		bunyan_error(l, "Invalid DH group",
+		    BUNYAN_T_STRING, "dhgrp", ikev2_dh_str(group),
+		    BUNYAN_T_INT32, "val", (int32_t)group,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	template[0].type = CKA_PRIME;
+	template[0].pValue = dh->prime;
+	template[0].ulValueLen = dh->bits / 8;
+	template[1].type = CKA_BASE;
+	template[1].pValue = dh->generator;
+	template[1].ulValueLen = dh->genbits / 8;
+
+	rc = C_GenerateKeyPair(p11h(), &mech, template, ARRAY_SIZE(template),
+	    NULL_PTR, 0, pub, priv);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, l, "C_GenerateKeyPair", rc);
+		return (B_FALSE);
+	} else {
+		bunyan_trace(l, "Created DH keypair",
+		    BUNYAN_T_UINT64, "pub_handle", (uint64_t)*pub,
+		    BUNYAN_T_UINT64, "priv_handle", (uint64_t)*priv,
+		    BUNYAN_T_END);
+	}
+
+	return (B_TRUE);
+}
+
+boolean_t
+dh_derivekey(CK_OBJECT_HANDLE privkey, uint8_t *restrict pub, size_t len,
+    CK_OBJECT_HANDLE_PTR restrict seckey, bunyan_logger_t *restrict l)
+{
+	CK_OBJECT_CLASS key_class = CKO_SECRET_KEY;
+	CK_KEY_TYPE key_type = CKK_GENERIC_SECRET;
+	CK_ULONG key_len = 0;
+	CK_BBOOL trueval = CK_TRUE;
+	CK_MECHANISM mech = { CKM_DH_PKCS_DERIVE, pub, len };
+	CK_ATTRIBUTE template[] = {
+		{ CKA_CLASS, &key_class, sizeof (key_class) },
+		{ CKA_KEY_TYPE, &key_type, sizeof (key_type) },
+		{ CKA_VALUE_LEN, &key_len, sizeof (key_len) },
+		{ CKA_ENCRYPT, &trueval, sizeof (trueval) },
+		{ CKA_DECRYPT, &trueval, sizeof (trueval) }
+	};
+	CK_RV rc;
+
+	rc = C_DeriveKey(p11h(), &mech, privkey, template,
+	    ARRAY_SIZE(template), seckey);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, l, "C_DeriveKey", rc);
+		return (B_FALSE);
+	}
+	return (B_TRUE);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.h
new file mode 100644
index 0000000000..e78bfb248d
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/dh.h
@@ -0,0 +1,39 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _DH_H
+#define	_DH_H
+
+#include <sys/types.h>
+#include <security/cryptoki.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct bunyan_logger;
+
+boolean_t dh_genpair(ikev2_dh_t, CK_OBJECT_HANDLE_PTR restrict,
+    CK_OBJECT_HANDLE_PTR restrict, struct bunyan_logger *restrict);
+boolean_t dh_derivekey(CK_OBJECT_HANDLE, uint8_t *restrict, size_t,
+    CK_OBJECT_HANDLE_PTR restrict, struct bunyan_logger *restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _DH_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.c
new file mode 100644
index 0000000000..81d078adba
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.c
@@ -0,0 +1,280 @@
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/* Portions of the following are... */
+/*
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * These functions provide an easy way to receive a packet with FULL address
+ * information, and send one using precise addresses.
+ */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/int_fmtio.h>
+#include <sys/debug.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include "defs.h"
+#include "fromto.h"
+#include "ike.h"
+
+/* BEGIN CSTYLED */
+/* cstyle doesn't deal with ## __VA_ARGS__ well */
+#define	SOCKLOG(level, log, msg, sock, from, to, ...)	\
+	NETLOG(level, log, msg, from, to,		\
+	BUNYAN_T_INT32, "sockfd", (int32_t)(sock),	\
+	## __VA_ARGS__,					\
+	BUNYAN_T_END)
+/* END CSTYLED */
+
+/*
+ * Receive packet, with src/dst information.  It is assumed that necessary
+ * setsockopt()s (e.g. IP_SEC_OPT(NEVER)) have already performed on socket.
+ */
+ssize_t
+recvfromto(int s, uint8_t *restrict buf, size_t buflen, int flags,
+    struct sockaddr_storage *restrict from, socklen_t *restrict fromlen,
+    struct sockaddr_storage *restrict to, socklen_t *restrict tolen)
+{
+	socklen_t otolen;
+	ssize_t len;
+	socklen_t sslen;
+	struct sockaddr_storage ss;
+	struct msghdr m;
+	struct iovec iov[1] = { 0 };
+	uint32_t cmsgbuf[64] = { 0 };
+	struct cmsghdr *cm = (struct cmsghdr *)cmsgbuf;
+	struct in6_pktinfo *pi;
+	struct sockaddr_in6 *sin6;
+	struct sockaddr_in *sin;
+	boolean_t toset = _B_FALSE;
+
+	sslen = sizeof (ss);
+	if (getsockname(s, (struct sockaddr *)&ss, &sslen) < 0) {
+		STDERR(error, log, "getsockname() failed",
+		    BUNYAN_T_INT32, "socket", (int32_t)s);
+		return (-1);
+	}
+
+	/* Quick hack -- snapshot the current socket's port, at least. */
+	(void) memcpy(to, &ss, sslen < *tolen ? sslen : *tolen);
+
+	m.msg_name = (caddr_t)from;
+	m.msg_namelen = *fromlen;
+	iov[0].iov_base = buf;
+	iov[0].iov_len = buflen;
+	m.msg_iov = iov;
+	m.msg_iovlen = 1;
+	m.msg_control = (caddr_t)cm;
+	m.msg_controllen = sizeof (cmsgbuf);
+	if ((len = recvmsg(s, &m, flags)) < 0) {
+		SOCKLOG(error, log, "recvmsg() failed", s, from, to,
+		    BUNYAN_T_STRING, "err", strerror(errno),
+		    BUNYAN_T_INT32, "errno", (int32_t)errno);
+		return (-1);
+	}
+	if (len > buflen) {
+		/*
+		 * size_t and ssize_t should always be "long", but not in 32-
+		 * bit apps for some bizarre reason.
+		 */
+		SOCKLOG(warn, log, "Received oversized message", s, from, to,
+		    BUNYAN_T_UINT32, "msglen", (uint32_t)len,
+		    BUNYAN_T_UINT32, "buflen", (uint32_t)buflen);
+
+		errno = E2BIG;	/* Not returned from normal recvmsg()... */
+		return (-1);
+	}
+
+	if (len < sizeof (ike_header_t)) {
+		SOCKLOG(warn, log, "Received undersized message", s, from, to,
+		    BUNYAN_T_UINT32, "msglen", (uint32_t)len);
+		return (-1);
+	}
+
+	*fromlen = m.msg_namelen;
+
+	otolen = *tolen;
+	*tolen = 0;
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&m);
+	    m.msg_controllen != 0 && cm;
+	    cm = (struct cmsghdr *)CMSG_NXTHDR(&m, cm)) {
+		if (!toset && ss.ss_family == AF_INET6 &&
+		    cm->cmsg_level == IPPROTO_IPV6 &&
+		    cm->cmsg_type == IPV6_PKTINFO &&
+		    otolen >= sizeof (*sin6)) {
+			/* LINTED */
+			pi = (struct in6_pktinfo *)(CMSG_DATA(cm));
+			*tolen = sizeof (*sin6);
+			sin6 = (struct sockaddr_in6 *)to;
+			(void) memset(sin6, 0, sizeof (*sin6));
+			sin6->sin6_family = AF_INET6;
+			sin6->sin6_addr = pi->ipi6_addr;
+			/* XXX other cases, such as site-local? */
+			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr))
+				sin6->sin6_scope_id = pi->ipi6_ifindex;
+			else
+				sin6->sin6_scope_id = 0;
+			sin6->sin6_port =
+			    ((struct sockaddr_in6 *)&ss)->sin6_port;
+			toset = _B_TRUE;
+			continue;
+		}
+
+		if (!toset &&
+		    ss.ss_family == AF_INET && cm->cmsg_level == IPPROTO_IP &&
+		    cm->cmsg_type == IP_RECVDSTADDR &&
+		    otolen >= sizeof (struct sockaddr_in)) {
+			*tolen = sizeof (*sin);
+			sin = (struct sockaddr_in *)to;
+			(void) memset(sin, 0, sizeof (*sin));
+			sin->sin_family = AF_INET;
+			(void) memcpy(&sin->sin_addr, CMSG_DATA(cm),
+			    sizeof (sin->sin_addr));
+			sin->sin_port = ((struct sockaddr_in *)&ss)->sin_port;
+			toset = _B_TRUE;
+			continue;
+		}
+	}
+
+	SOCKLOG(debug, log, "Received datagram", s, from, to,
+	    BUNYAN_T_UINT32, "msglen", (uint32_t)len);
+
+	return (len);
+}
+
+/*
+ * Send packet, with fixing src/dst address pair. It should be noted
+ * that the source port value used is the one that was set on the
+ * socket being used (i.e. the port value in 'src' is ignored), while
+ * the port value in 'dest' IS used to determine the destination port of
+ * the datagram.
+ */
+ssize_t
+sendfromto(int s, const uint8_t *restrict buf, size_t buflen,
+    struct sockaddr_storage *restrict src,
+    struct sockaddr_storage *restrict dst)
+{
+	uint32_t cmsgbuf[64] = { 0 };
+	struct msghdr m = { 0 };
+	struct iovec iov[1];
+	struct cmsghdr *cm = (struct cmsghdr *)&cmsgbuf;
+	struct in6_pktinfo *pi6;
+	struct in_pktinfo *pi;
+	ssize_t n;
+
+	if (src->ss_family != AF_INET && src->ss_family != AF_INET6) {
+		(void) bunyan_error(log, "Unsupported address family",
+		    BUNYAN_T_STRING, "func", __func__,
+		    BUNYAN_T_STRING, "file", __FILE__,
+		    BUNYAN_T_INT32, "line", __LINE__,
+		    BUNYAN_T_UINT32, "af", (uint32_t)src->ss_family,
+		    BUNYAN_T_END);
+		errno = EAFNOSUPPORT;
+		return (-1);
+	}
+
+	if (src->ss_family != dst->ss_family) {
+		SOCKLOG(error, log, "Address family mismatch",
+		    s, src, dst,
+		    BUNYAN_T_UINT32, "srcaf", (uint32_t)src->ss_family,
+		    BUNYAN_T_UINT32, "destaf", (uint32_t)src->ss_family);
+
+		errno = EADDRNOTAVAIL;	/* XXX KEBE ASKS - Better ideas? */
+		return (-1);
+	}
+
+	SOCKLOG(debug, log, "Sending datagram", s, src, dst,
+	    BUNYAN_T_UINT32, "msglen", buflen);
+
+	m.msg_name = (caddr_t)dst;
+	iov[0].iov_base = (caddr_t)buf;
+	iov[0].iov_len = buflen;
+	m.msg_iov = iov;
+	m.msg_iovlen = 1;
+	m.msg_control = (caddr_t)cm;
+	if (src->ss_family == AF_INET6) {
+		/* v6 setup */
+		struct sockaddr_in6 *src6;
+
+		src6 = (struct sockaddr_in6 *)src;
+		m.msg_namelen = sizeof (*src6);
+		m.msg_controllen = CMSG_SPACE(sizeof (*pi6));
+		cm->cmsg_len = CMSG_LEN(sizeof (*pi6));
+		cm->cmsg_level = IPPROTO_IPV6;
+		cm->cmsg_type = IPV6_PKTINFO;
+		/* LINTED */
+		pi6 = (struct in6_pktinfo *)CMSG_DATA(cm);
+		pi6->ipi6_addr = src6->sin6_addr;
+		if (IN6_IS_ADDR_LINKLOCAL(&src6->sin6_addr) ||
+		    IN6_IS_ADDR_MULTICAST(&src6->sin6_addr)) {
+			pi6->ipi6_ifindex = src6->sin6_scope_id;
+		} else {
+			pi6->ipi6_ifindex = 0;
+		}
+	} else if (src->ss_family == AF_INET) {
+		/* v4 setup */
+		struct sockaddr_in *src4;
+
+		src4 = (struct sockaddr_in *)src;
+		m.msg_namelen = sizeof (*src4);
+		m.msg_controllen = CMSG_SPACE(sizeof (*pi));
+		cm->cmsg_len = CMSG_LEN(sizeof (*pi));
+		cm->cmsg_level = IPPROTO_IP;
+		cm->cmsg_type = IP_PKTINFO;
+		/* LINTED */
+		pi = (struct in_pktinfo *)CMSG_DATA(cm);
+		pi->ipi_addr = src4->sin_addr;
+		/* Zero out the other fields for IPv4. */
+		pi->ipi_spec_dst.s_addr = 0;
+		pi->ipi_ifindex = 0;
+	} else {
+		/*NOTREACHED*/
+		INVALID("src->ss_family");
+	}
+
+	n = sendmsg(s, &m, 0);
+	if (n < 0) {
+		SOCKLOG(error, log, "sendmsg() failed", s, src, dst,
+		    BUNYAN_T_STRING, "err", strerror(errno),
+		    BUNYAN_T_UINT32, "errno", (int32_t)errno);
+	}
+
+	return (n);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.h
new file mode 100644
index 0000000000..0290a0b704
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/fromto.h
@@ -0,0 +1,37 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc
+ */
+
+#ifndef _FROMTO_H
+#define	_FROMTO_H
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ssize_t recvfromto(int, uint8_t *restrict, size_t, int,
+    struct sockaddr_storage *restrict, socklen_t *restrict,
+    struct sockaddr_storage *restrict, socklen_t *restrict);
+
+ssize_t sendfromto(int, const uint8_t *restrict, size_t,
+    struct sockaddr_storage *restrict, struct sockaddr_storage *restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FROMTO_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ike.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ike.h
new file mode 100644
index 0000000000..ec010e6956
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ike.h
@@ -0,0 +1,120 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2014 Jason King.
+ */
+
+#ifndef _IKE_H
+#define	_IKE_H
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Stuff that is the same between IKEv1 and IKEv2 */
+
+#define	IKE_GET_MAJORV(v)	(((v) & 0xf0) >> 4)
+#define	IKE_GET_MINORV(v)	((v) & 0x0f)
+#define	IKE_VERSION(_maj, _min) (((_maj) & 0xf0 << 4) | (_min) & 0x0f)
+
+#ifndef __packed
+#define	__packed __attribute__((packed))
+#endif
+
+struct ike_header {
+	uint64_t	initiator_spi;
+	uint64_t	responder_spi;
+	uint8_t		next_payload;
+	uint8_t		version;
+	uint8_t		exch_type;
+	uint8_t		flags;
+	uint32_t	msgid;
+	uint32_t	length;
+} __packed;
+typedef struct ike_header ike_header_t;
+#define	IKE_HEADER_LEN	(sizeof (ike_header_t))
+
+struct ike_payload {
+	uint8_t		pay_next;
+	uint8_t		pay_reserved;
+	uint16_t	pay_length;
+} __packed;
+typedef struct ike_payload ike_payload_t;
+
+#define	IKE_PAYLOAD_NONE	0
+
+/* Of the IKEv1 and IKEv2 payloads we recognize, this is MAX of the two */
+#define	IKE_NUM_PAYLOADS 17
+
+struct ike_prop {
+	uint8_t		prop_more;
+	uint8_t		prop_resv;
+	uint16_t	prop_len;
+	uint8_t		prop_num;
+	uint8_t		prop_proto;
+	uint8_t		prop_spilen;
+	uint8_t		prop_numxform;
+} __packed;
+typedef struct ike_prop ike_prop_t;
+#define	IKE_PROP_NONE	(0)
+#define	IKE_PROP_MORE	(2)
+
+struct ike_xform {
+	uint8_t		xf_more;
+	uint8_t		xf_resv;
+	uint16_t	xf_len;
+	uint8_t		xf_type;
+	uint8_t		xf_resv2;
+	uint16_t	xf_id;
+} __packed;
+typedef struct ike_xform ike_xform_t;
+#define	IKE_XFORM_NONE	(0)
+#define	IKE_XFORM_MORE	(3)
+
+#define	IKE_ATTR_MAXTYPE	(0x7fff)
+#define	IKE_ATTR_MAXLEN		(UINT16_MAX - sizeof (ike_xf_attr_t))
+#define	IKE_ATTR_MAXVAL		(UINT16_MAX)
+struct ike_xf_attr {
+	uint16_t	attr_type;
+	uint16_t	attr_len;
+};
+typedef struct ike_xf_attr ike_xf_attr_t;
+#define	IKE_ATTR_TV			(1)
+#define	IKE_ATTR_TLV			(0)
+#define	IKE_ATTR_GET_TYPE(type)		((type) & 0x7fff)
+#define	IKE_ATTR_GET_FORMAT(type)	((type) & 0x8000) >> 15)
+#define	IKE_ATTR_TYPE(fmt, type) \
+	(((fmt) << 15) | ((type) & 0x7fff))
+
+struct ike_ke {
+	uint16_t	ke_group;
+	uint16_t	ke_resv;
+};
+typedef struct ike_ke ike_ke_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKE_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1.h
new file mode 100644
index 0000000000..e1a22c229c
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1.h
@@ -0,0 +1,174 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2014 Jason King.
+ */
+
+#ifndef _IKEV1_H
+#define	_IKEV1_H
+
+#include <sys/types.h>
+#include "ike.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	IKEV1_MAJOR_VERSION	1
+#define	IKEV1_MINOR_VERSION	0
+#define	IKEV1_VERSION		0x10
+
+typedef struct ike_header ikev1_header_t;
+
+enum ikev1_exch {
+	IKEV1_EXCH_BASE			= 1,
+	IKEV1_EXCH_IDPROT		= 2,
+	IKEV1_EXCH_AUTH_ONLY		= 3,
+	IKEV1_EXCH_AGGRESSIVE		= 4,
+	IKEV1_EXCH_INFORMATIONAL	= 5,
+};
+#define	IKEV1_VALID_EXCH(exch) \
+	(((exch) >= IKEV1_EXCH_BASE) && (exch) <= ((IKEV1_EXCH_INFORMATIONAL)))
+typedef enum ikev1_exch ikev1_exch_t;
+
+#define	IKEV1_FLAG_ENCR		(1 << 0)
+#define	IKEV1_FLAG_COMMIT	(1 << 1)
+#define	IKEV1_FLAG_AUTH_ONLY	(1 << 2)
+#define	IKEV1_FLAGS \
+	(IKEV1_FLAG_ENCR|IKEV1_FLAG_COMMIT|IKEV1_FLAG_AUTH_ONLY)
+
+typedef struct ike_payload ikev1_payload_t;
+
+enum ikev1_pay_type {
+	IKEV1_PAYLOAD_SA	= 1,
+	IKEV1_PAYLOAD_PROP	= 2,
+	IKEV1_PAYLOAD_XFORM	= 3,
+	IKEV1_PAYLOAD_KE	= 4,
+	IKEV1_PAYLOAD_ID	= 5,
+	IKEV1_PAYLOAD_CERT	= 6,
+	IKEV1_PAYLOAD_CREQ	= 7,
+	IKEV1_PAYLOAD_HASH	= 8,
+	IKEV1_PAYLOAD_SIG	= 9,
+	IKEV1_PAYLOAD_NONCE	= 10,
+	IKEV1_PAYLOAD_NOTIFY	= 11,
+	IKEV1_PAYLOAD_DELETE	= 12,
+	IKEV1_PAYLOAD_VENDOR	= 13,
+};
+typedef enum ikev1_pay_type ikev1_pay_t;
+#define	IKEV1_VALID_PAYLOAD(p) \
+	(((p) >= IKEV1_PAYLOAD_SA) && ((p) <= IKEV1_PAYLOAD_VENDOR))
+
+#define	IKEV1_SIT_IDENTITY_ONLY	(0x01)
+#define	IKEV1_SIT_SECRECY	(0x02)
+#define	IKEV1_SIT_INTEGRITY	(0x04)
+
+typedef enum ikev1_spi_proto_e {
+	IKEV1_SPI_PROTO_ISAKMP		= 1,
+	IKEV1_SPI_PROTO_IPSEC_AH	= 2,
+	IKEV1_SPI_PROTO_IPSEC_ESP	= 3,
+	IKEV1_SPI_PROTO_IPCOMP		= 4
+} ikev1_spi_proto_t;
+
+typedef struct ike_prop ikev1_prop_t;
+#define	IKEV1_PROP_LAST	0
+#define	IKEV1_PROP_MORE	2
+
+typedef struct ike_xform ikev1_xform_t;
+#define	IKEV1_XFORM_LAST	0
+#define	IKEV1_XFORM_MORE	3
+
+enum ikev1_xf_type {
+	IKEV1_XF_ENCR		= 1,
+	IKEV1_XF_HASH		= 2,
+	IKEV1_XF_AUTH		= 3,
+	IKEV1_XF_GROUP_DESC	= 4,
+	IKEV1_XF_GROUP_TYPE	= 5,
+	IKEV1_XF_GROUP_PRIME	= 6,
+	IKEV1_XF_GROUP_GEN_1	= 7,
+	IKEV1_XF_GROUP_GEN_2	= 8,
+	IKEV1_XF_GROUP_CURVE_A	= 9,
+	IKEV1_XF_GROUP_CURVE_B	= 10,
+	IKEV1_XF_LIFE_TYPE	= 11,
+	IKEV1_XF_LIFE_DUR	= 12,
+	IKEV1_XF_PRF		= 13,
+	IKEV1_XF_KEYLEN		= 14,
+	IKEV1_XF_FIELD_SIZE	= 15,
+	IKEV1_XF_GROUP_ORDER	= 16
+};
+typedef enum ikev1_xf_type ikev1_xf_type_t;
+
+typedef struct ike_xf_attr ikev1_xf_attr_t;
+#define	IKEV1_ATTR_TV			IKE_ATTR_TV
+#define	IKEV1_ATTR_TLV			IKE_ATTR_TLV
+#define	IKEV1_ATTR_GET_TYPE(t)		IKE_GET_TYPE(t)
+#define	IKEV1_ATTR_GET_FORMAT(t)	IKE_GET_FORMAT(t)
+#define	IKEV1_ATTR_TYPE(f, t)		IKE_ATTR_TYPE(f, t)
+
+struct ikev1_notify {
+	uint32_t	n_doi;
+	uint8_t		n_protoid;
+	uint8_t		n_spisize;
+	uint16_t	n_type;
+	/* Followed by variable length SPI */
+	/* Followed by notification data */
+} __packed;
+typedef struct ikev1_notify ikev1_notify_t;
+
+enum ikev1_notify_e {
+	IKEV1_N_INVALID_PAYLOAD_TYPE	= 1,
+	IKEV1_N_DOI_NOT_SUPPORTED	= 2,
+	IKEV1_N_SITUATION_NOT_SUPPORTED	= 3,
+	IKEV1_N_INVALID_COOKIE		= 4,
+	IKEV1_N_INVALID_MAJOR_VERSION	= 5,
+	IKEV1_N_INVALID_MINOR_VERSION	= 6,
+	IKEV1_N_INVALID_EXCHANGE_TYPE	= 7,
+	IKEV1_N_INVALID_FLAGS		= 8,
+	IKEV1_N_INVALID_MESSAGE_ID	= 9,
+	IKEV1_N_INVALID_PROTOCOL_ID	= 10,
+	IKEV1_N_INVALID_SPI		= 11,
+	IKEV1_N_INVALID_TRANSFORM_ID	= 12,
+	IKEV1_N_ATTRIBUTES_NOT_SUPPORTED = 13,
+	IKEV1_N_NO_PROPOSAL_CHOSEN	= 14,
+	IKEV1_N_BAD_PROPOSAL_SYNTAX	= 15,
+	IKEV1_N_PAYLOAD_MALFORMED	= 16,
+	IKEV1_N_INVALID_KEY_INFORMATION	= 17,
+	IKEV1_N_INVALID_ID_INFORMATION	= 18,
+	IKEV1_N_INVALID_CERT_ENCODING	= 19,
+	IKEV1_N_INVALID_CERTIFICATE	= 20,
+	IKEV1_N_CERT_TYPE_UNSUPPORTED	= 21,
+	IKEV1_N_INVALID_CERT_AUTHORITY	= 22,
+	IKEV1_N_INVALID_HASH_INFORMATION = 23,
+	IKEV1_N_AUTHENTICATION_FAILED	= 24,
+	IKEV1_N_INVALID_SIGNATURE	= 25,
+	IKEV1_N_ADDRESS_NOTIFICATION	= 26,
+	IKEV1_N_NOTIFY_SA_LIFETIME	= 27,
+	IKEV1_N_CERTIFICATE_UNAVAILABLE	= 28,
+	IKEV1_N_UNSUPPORTED_EXCHANGE_TYPE = 29,
+	IKEV1_N_UNEQUAL_PAYLOAD_LENGTHS	= 30,
+};
+typedef enum ikev1_notify_e ikev1_notify_type_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV1_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1_pkt.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1_pkt.c
new file mode 100644
index 0000000000..c3be1cd518
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev1_pkt.c
@@ -0,0 +1,78 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Jason King.  All rights reserved.
+ */
+
+#include <stddef.h>
+#include <assert.h>
+#include <umem.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/byteorder.h>
+#include <ipsec_util.h>
+#include <locale.h>
+#include <netinet/in.h>
+#include <security/cryptoki.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <pthread.h>
+#include <sys/debug.h>
+#include <note.h>
+#include "ikev2.h"
+#include "ikev2_sa.h"
+#include "pkt.h"
+#include "pkt_impl.h"
+#include "pkcs11.h"
+
+static void
+ikev1_add_payload(pkt_t *pkt, ikev1_pay_t type)
+{
+	ASSERT(IKEV1_VALID_PAYLOAD(type));
+	ASSERT(IKE_GET_MAJORV(pkt->header.version) == IKEV1_VERSION);
+	pkt_add_payload(pkt, type, 0);
+}
+
+
+void
+ikev1_add_sa(pkt_t *pkt, uint32_t doi, uint32_t sit)
+{
+	ikev1_add_payload(pkt, IKEV1_PAYLOAD_SA);
+	buf_put32(&pkt->buf, doi);
+	buf_put32(&pkt->buf, sit);
+}
+
+void
+ikev1_add_prop(pkt_t *pkt, uint8_t propnum, ikev1_spi_proto_t spitype,
+    uint64_t spi)
+{
+	size_t spilen;
+
+	switch (spitype) {
+	case IKEV1_SPI_PROTO_ISAKMP:
+		spilen = sizeof (uint64_t);
+		break;
+	case IKEV1_SPI_PROTO_IPSEC_AH:
+	case IKEV1_SPI_PROTO_IPSEC_ESP:
+	case IKEV1_SPI_PROTO_IPCOMP:
+		spilen = sizeof (uint32_t);
+		break;
+	default:
+		INVALID(spitype);
+	}
+
+	pkt_add_prop(pkt, propnum, spitype, spi);
+}
+
+
+/* TODO */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2.h
new file mode 100644
index 0000000000..6d35462b58
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2.h
@@ -0,0 +1,532 @@
+/*
+ * Copyright (c) 2010-2013 Reyk Floeter <reyk@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _IKEV2_H
+#define	_IKEV2_H
+
+#include <inttypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	__packed __attribute__((packed))
+
+#define	IKEV2_VERSION		0x20	/* IKE version 2.0 */
+#define	IKEV2_KEYPAD		"Key Pad for IKEv2"	/* don't change! */
+
+/* RFC7296 3.9 - Nonce size must be between 16 and 256 octets (inclusive) */
+#define	IKEV2_NONCE_MIN		(16)
+#define	IKEV2_NONCE_MAX		(256)
+
+/*
+ * "IKEv2 Parameters" based on the official RFC-based assignments by IANA
+ * (http://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.txt)
+ *
+ * GSA parameters are based on the draft Group Key Management RFC
+ * https://tools.ietf.org/html/draft-yeung-g-ikev2-11
+ */
+
+/*
+ * IKEv2 definitions of the IKE header
+ */
+
+/* IKEv2 exchange types */
+typedef enum ikev2_exch_e {
+	IKEV2_EXCH_IKE_SA_INIT		= 34,
+	IKEV2_EXCH_IKE_AUTH		= 35,
+	IKEV2_EXCH_CREATE_CHILD_SA	= 36,
+	IKEV2_EXCH_INFORMATIONAL	= 37,
+	IKEV2_EXCH_IKE_SESSION_RESUME	= 38,
+	IKEV2_EXCH_GSA_AUTH		= 39,	/* draft-yeung-g-ikev2 */
+	IKEV2_EXCH_GSA_REGISTRATION	= 40,	/* draft-yeung-g-ikev2 */
+	IKEV2_EXCH_GSA_REKEY		= 41,	/* draft-yeung-g-ikev2 */
+} ikev2_exch_t;
+
+/* IKEv2 message flags */
+#define	IKEV2_FLAG_INITIATOR	0x08	/* Sent by the initiator */
+#define	IKEV2_FLAG_VERSION	0x10	/* Supports a higher IKE version */
+#define	IKEV2_FLAG_RESPONSE	0x20	/* Message is a response */
+
+/*
+ * IKEv2 payloads
+ */
+struct ikev2_payload {
+	uint8_t		pld_nextpayload;	/* Next payload type */
+	uint8_t		pld_reserved;		/* Contains the critical bit */
+	uint16_t	pld_length;		/* Payload length with header */
+} __packed;
+
+#define	IKEV2_CRITICAL_PAYLOAD	0x01	/* First bit in the reserved field */
+
+/* IKEv2 payload types */
+typedef enum ikev2_pay_type {
+	IKEV2_PAYLOAD_NONE =	0,	/* No payload */
+	IKEV2_PAYLOAD_SA =	33,	/* Security Association */
+	IKEV2_PAYLOAD_KE =	34,	/* Key Exchange */
+	IKEV2_PAYLOAD_IDi =	35,	/* Identification - Initiator */
+	IKEV2_PAYLOAD_IDr =	36,	/* Identification - Responder */
+	IKEV2_PAYLOAD_CERT =	37,	/* Certificate */
+	IKEV2_PAYLOAD_CERTREQ =	38,	/* Certificate Request */
+	IKEV2_PAYLOAD_AUTH =	39,	/* Authentication */
+	IKEV2_PAYLOAD_NONCE =	40,	/* Nonce */
+	IKEV2_PAYLOAD_NOTIFY =	41,	/* Notify */
+	IKEV2_PAYLOAD_DELETE =	42,	/* Delete */
+	IKEV2_PAYLOAD_VENDOR =	43,	/* Vendor ID */
+	IKEV2_PAYLOAD_TSi =	44,	/* Traffic Selector - Initiator */
+	IKEV2_PAYLOAD_TSr =	45,	/* Traffic Selector - Responder */
+	IKEV2_PAYLOAD_SK =	46,	/* Encrypted */
+	IKEV2_PAYLOAD_CP =	47,	/* Configuration Payload */
+	IKEV2_PAYLOAD_EAP =	48,	/* Extensible Authentication */
+	IKEV2_PAYLOAD_GSPM =	49,	/* RFC6467 Generic Secure Password */
+	IKEV2_PAYLOAD_IDg =	50,	/* draft-yeung-g-ikev2 */
+	IKEV2_PAYLOAD_GSA =	51,	/* draft-yeung-g-ikev2 */
+	IKEV2_PAYLOAD_KD =	52,	/* draft-yeung-g-ikev2 */
+	IKEV2_PAYLOAD_SKF =	53,	/* RFC7383 */
+	IKEV2_PAYLOAD_PS =	54,	/* RFC8019 */
+} ikev2_pay_type_t;
+
+#define	IKEV2_PAYLOAD_MIN	IKEV2_PAYLOAD_SA
+#define	IKEV2_PAYLOAD_MAX	IKEV2_PAYLOAD_PS
+#define	IKEV2_NUM_PAYLOADS	(IKEV2_PAYLOAD_MAX - IKEV2_PAYLOAD_MIN + 1)
+#define	IKEV2_VALID_PAYLOAD(paytype) \
+	(((paytype) >= IKEV2_PAYLOAD_MIN) && ((paytype) <= IKEV2_PAYLOAD_MAX))
+
+/*
+ * SA payload
+ */
+
+struct ikev2_sa_proposal {
+	uint8_t		proto_more;		/* Last proposal or more */
+	uint8_t		proto_reserved;		/* Must be set to zero */
+	uint16_t	proto_length;		/* Proposal length */
+	uint8_t		proto_proposalnr;	/* Proposal number */
+	uint8_t		proto_protoid;		/* Protocol Id */
+	uint8_t		proto_spisize;		/* SPI size */
+	uint8_t		proto_transforms;	/* Number of transforms */
+	/* Followed by variable-length SPI */
+	/* Followed by variable-length transforms */
+} __packed;
+
+#define	IKEV2_PROP_LAST	0
+#define	IKEV2_PROP_MORE	2
+
+typedef enum ikev2_spi_proto_e {
+	IKEV2_PROTO_NONE		= 0,	/* None */
+	IKEV2_PROTO_IKE			= 1,	/* IKEv2 */
+	IKEV2_PROTO_AH			= 2,	/* AH */
+	IKEV2_PROTO_ESP			= 3,	/* ESP */
+	IKEV2_PROTO_FC_ESP_HEADER	= 4,	/* RFC4595 */
+	IKEV2_PROTO_FC_CT_AUTH		= 5	/* RFC4595 */
+} ikev2_spi_proto_t;
+
+struct ikev2_transform {
+	uint8_t		xf_more;		/* Last transform or more */
+	uint8_t		xf_reserved;		/* Must be set to zero */
+	uint16_t	xf_length;		/* Transform length */
+	uint8_t		xf_type;		/* Transform type */
+	uint8_t		xf_reserved1;		/* Must be set to zero */
+	uint16_t	xf_id;		/* Transform Id */
+	/* Followed by variable-length transform attributes */
+} __packed;
+
+#define	IKEV2_XF_LAST		0
+#define	IKEV2_XF_MORE		3
+
+typedef enum ikev2_xf_type_e {
+	IKEV2_XF_ENCR	= 1,	/* Encryption */
+	IKEV2_XF_PRF	= 2,	/* Pseudo-Random Function */
+	IKEV2_XF_AUTH	= 3,	/* Integrity Algorithm */
+	IKEV2_XF_DH	= 4,	/* Diffie-Hellman Group */
+	IKEV2_XF_ESN	= 5	/* Extended Sequence Numbers */
+} ikev2_xf_type_t;
+#define	IKEV2_XF_MAX		6
+
+typedef enum ikev2_encr_e {
+	IKEV2_ENCR_NONE			= 0,	/* None */
+	IKEV2_ENCR_DES_IV64		= 1,	/* RFC1827 */
+	IKEV2_ENCR_DES			= 2,	/* RFC2405 */
+	IKEV2_ENCR_3DES			= 3,	/* RFC2451 */
+	IKEV2_ENCR_RC5			= 4,	/* RFC2451 */
+	IKEV2_ENCR_IDEA			= 5,	/* RFC2451 */
+	IKEV2_ENCR_CAST			= 6,	/* RFC2451 */
+	IKEV2_ENCR_BLOWFISH		= 7,	/* RFC2451 */
+	IKEV2_ENCR_3IDEA		= 8,	/* RFC2451 */
+	IKEV2_ENCR_DES_IV32		= 9,	/* DESIV32 */
+	IKEV2_ENCR_RC4			= 10,	/* RFC2451 */
+	IKEV2_ENCR_NULL			= 11,	/* RFC2410 */
+	IKEV2_ENCR_AES_CBC		= 12,	/* RFC3602 */
+	IKEV2_ENCR_AES_CTR		= 13,	/* RFC3664 */
+	IKEV2_ENCR_AES_CCM_8		= 14,	/* RFC5282 */
+	IKEV2_ENCR_AES_CCM_12		= 15,	/* RFC5282 */
+	IKEV2_ENCR_AES_CCM_16		= 16,	/* RFC5282 */
+	IKEV2_ENCR_AES_GCM_8		= 18,	/* RFC5282 */
+	IKEV2_ENCR_AES_GCM_12		= 19,	/* RFC5282 */
+	IKEV2_ENCR_AES_GCM_16		= 20,	/* RFC5282 */
+	IKEV2_ENCR_NULL_AES_GMAC	= 21,	/* RFC4543 */
+	IKEV2_ENCR_XTS_AES		= 22,	/* IEEE P1619 */
+	IKEV2_ENCR_CAMELLIA_CBC		= 23,	/* RFC5529 */
+	IKEV2_ENCR_CAMELLIA_CTR		= 24,	/* RFC5529 */
+	IKEV2_ENCR_CAMELLIA_CCM_8	= 25,	/* RFC5529 */
+	IKEV2_ENCR_CAMELLIA_CCM_12	= 26,	/* RFC5529 */
+	IKEV2_ENCR_CAMELLIA_CCM_16	= 27,	/* RFC5529 */
+} ikev2_xf_encr_t;
+#define	IKEV2_ENCR_MAX	IKEV2_ENCR_CAMELLIA_CCM_16
+
+#define	IKEV2_IPCOMP_OUI		1	/* RFC5996 */
+#define	IKEV2_IPCOMP_DEFLATE		2	/* RFC2394 */
+#define	IKEV2_IPCOMP_LZS		3	/* RFC2395 */
+#define	IKEV2_IPCOMP_LZJH		4	/* RFC3051 */
+
+typedef enum ikev2_prf {
+	IKEV2_PRF_HMAC_MD5		= 1,	/* RFC2104 */
+	IKEV2_PRF_HMAC_SHA1		= 2,	/* RFC2104 */
+	IKEV2_PRF_HMAC_TIGER		= 3,	/* RFC2104 */
+	IKEV2_PRF_AES128_XCBC		= 4,	/* RFC3664 */
+	IKEV2_PRF_HMAC_SHA2_256		= 5,	/* RFC4868 */
+	IKEV2_PRF_HMAC_SHA2_384		= 6,	/* RFC4868 */
+	IKEV2_PRF_HMAC_SHA2_512		= 7,	/* RFC4868 */
+	IKEV2_PRF_AES128_CMAC		= 8	/* RFC4615 */
+} ikev2_prf_t;
+
+typedef enum ikev2_xf_auth_e {
+	IKEV2_XF_AUTH_NONE			= 0,	/* No Authentication */
+	IKEV2_XF_AUTH_HMAC_MD5_96		= 1,	/* RFC2403 */
+	IKEV2_XF_AUTH_HMAC_SHA1_96		= 2,	/* RFC2404 */
+	IKEV2_XF_AUTH_DES_MAC			= 3,	/* DES-MAC */
+	IKEV2_XF_AUTH_KPDK_MD5			= 4,	/* RFC1826 */
+	IKEV2_XF_AUTH_AES_XCBC_96		= 5,	/* RFC3566 */
+	IKEV2_XF_AUTH_HMAC_MD5_128		= 6,	/* RFC4595 */
+	IKEV2_XF_AUTH_HMAC_SHA1_160		= 7,	/* RFC4595 */
+	IKEV2_XF_AUTH_AES_CMAC_96		= 8,	/* RFC4494 */
+	IKEV2_XF_AUTH_AES_128_GMAC		= 9,	/* RFC4543 */
+	IKEV2_XF_AUTH_AES_192_GMAC		= 10,	/* RFC4543 */
+	IKEV2_XF_AUTH_AES_256_GMAC		= 11,	/* RFC4543 */
+	IKEV2_XF_AUTH_HMAC_SHA2_256_128 	= 12,	/* RFC4868 */
+	IKEV2_XF_AUTH_HMAC_SHA2_384_192 	= 13,	/* RFC4868 */
+	IKEV2_XF_AUTH_HMAC_SHA2_512_256 	= 14	/* RFC4868 */
+} ikev2_xf_auth_t;
+#define	IKEV2_XF_AUTH_MAX	IKEV2_XF_AUTH_HMAC_SHA2_512_256
+
+typedef enum ikev2_dh {
+	IKEV2_DH_NONE			= 0,	/* No DH */
+	IKEV2_DH_MODP_768		= 1,	/* DH Group 1 */
+	IKEV2_DH_MODP_1024		= 2,	/* DH Group 2 */
+	IKEV2_DH_EC2N_155		= 3,	/* DH Group 3 */
+	IKEV2_DH_EC2N_185		= 4,	/* DH Group 3 */
+	IKEV2_DH_MODP_1536		= 5,	/* DH Group 5 */
+	IKEV2_DH_MODP_2048		= 14,	/* DH Group 14 */
+	IKEV2_DH_MODP_3072		= 15,	/* DH Group 15 */
+	IKEV2_DH_MODP_4096		= 16,	/* DH Group 16 */
+	IKEV2_DH_MODP_6144		= 17,	/* DH Group 17 */
+	IKEV2_DH_MODP_8192		= 18,	/* DH Group 18 */
+	IKEV2_DH_ECP_256		= 19,	/* DH Group 19 */
+	IKEV2_DH_ECP_384		= 20,	/* DH Group 20 */
+	IKEV2_DH_ECP_521		= 21,	/* DH Group 21 */
+	IKEV2_DH_MODP_1024_160		= 22,	/* DH Group 22 */
+	IKEV2_DH_MODP_2048_224		= 23,	/* DH Group 23 */
+	IKEV2_DH_MODP_2048_256		= 24,	/* DH Group 24 */
+	IKEV2_DH_ECP_192		= 25,	/* DH Group 25 */
+	IKEV2_DH_ECP_224		= 26,	/* DH Group 26 */
+	IKEV2_DH_BRAINPOOL_P224R1	= 27,	/* DH Group 27 */
+	IKEV2_DH_BRAINPOOL_P256R1	= 28,	/* DH Group 28 */
+	IKEV2_DH_BRAINPOOL_P384R1	= 29,	/* DH Group 29 */
+	IKEV2_DH_BRAINPOOL_P512R1	= 30	/* DH Group 30 */
+} ikev2_dh_t;
+#define	IKEV2_DH_MAX			31
+
+typedef enum ikev2_esn_e {
+	IKEV2_ESN_NONE = 0,
+	IKEV2_ESN_YES = 1
+} ikev2_esn_t;
+
+struct ikev2_attribute {
+	uint16_t	attr_type;	/* Attribute type */
+	uint16_t	attr_length;	/* Attribute length or value */
+	/* Followed by variable length (TLV) */
+} __packed;
+
+#define	IKEV2_ATTRAF_TLV		0x0000	/* Type-Length-Value format */
+#define	IKEV2_ATTRAF_TV			0x8000	/* Type-Value format */
+
+typedef enum ikev2_xf_attr_type {
+	IKEV2_XF_ATTR_KEYLEN	= 14		/* Key length */
+} ikev2_xf_attr_type_t;
+
+/*
+ * KE Payload
+ */
+struct ikev2_ke {
+	uint16_t	 kex_dhgroup;		/* DH Group # */
+	uint16_t	 kex_reserved;		/* Reserved */
+} __packed;
+
+/*
+ * N payload
+ */
+struct ikev2_notify {
+	uint8_t		n_protoid;		/* Protocol Id */
+	uint8_t		n_spisize;		/* SPI size */
+	uint16_t	n_type;		/* Notify message type */
+	/* Followed by variable length SPI */
+	/* Followed by variable length notification data */
+} __packed;
+
+/*
+ * NOTIFY types.  We don't support all of these, however for observability
+ * and debugging purposes, we try to maintain a list of all known values.
+ */
+typedef enum ikev2_notify_type {
+	IKEV2_N_UNSUPPORTED_CRITICAL_PAYLOAD	= 1,		/* RFC4306 */
+	IKEV2_N_INVALID_IKE_SPI			= 4,		/* RFC4306 */
+	IKEV2_N_INVALID_MAJOR_VERSION		= 5,		/* RFC4306 */
+	IKEV2_N_INVALID_SYNTAX			= 7,		/* RFC4306 */
+	IKEV2_N_INVALID_MESSAGE_ID		= 9,		/* RFC4306 */
+	IKEV2_N_INVALID_SPI			= 11,		/* RFC4306 */
+	IKEV2_N_NO_PROPOSAL_CHOSEN		= 14,		/* RFC4306 */
+	IKEV2_N_INVALID_KE_PAYLOAD		= 17,		/* RFC4306 */
+	IKEV2_N_AUTHENTICATION_FAILED		= 24,		/* RFC4306 */
+	IKEV2_N_SINGLE_PAIR_REQUIRED		= 34,		/* RFC4306 */
+	IKEV2_N_NO_ADDITIONAL_SAS		= 35,		/* RFC4306 */
+	IKEV2_N_INTERNAL_ADDRESS_FAILURE	= 36,		/* RFC4306 */
+	IKEV2_N_FAILED_CP_REQUIRED		= 37,		/* RFC4306 */
+	IKEV2_N_TS_UNACCEPTABLE			= 38,		/* RFC4306 */
+	IKEV2_N_INVALID_SELECTORS		= 39,		/* RFC4306 */
+	IKEV2_N_UNACCEPTABLE_ADDRESSES		= 40,		/* RFC4555 */
+	IKEV2_N_UNEXPECTED_NAT_DETECTED		= 41,		/* RFC4555 */
+	IKEV2_N_USE_ASSIGNED_HoA		= 42,		/* RFC5026 */
+	IKEV2_N_TEMPORARY_FAILURE		= 43,		/* RFC5996 */
+	IKEV2_N_CHILD_SA_NOT_FOUND		= 44,		/* RFC5996 */
+	IKEV2_N_INITIAL_CONTACT			= 16384,	/* RFC4306 */
+	IKEV2_N_SET_WINDOW_SIZE			= 16385,	/* RFC4306 */
+	IKEV2_N_ADDITIONAL_TS_POSSIBLE		= 16386,	/* RFC4306 */
+	IKEV2_N_IPCOMP_SUPPORTED		= 16387,	/* RFC4306 */
+	IKEV2_N_NAT_DETECTION_SOURCE_IP		= 16388,	/* RFC4306 */
+	IKEV2_N_NAT_DETECTION_DESTINATION_IP	= 16389,	/* RFC4306 */
+	IKEV2_N_COOKIE				= 16390,	/* RFC4306 */
+	IKEV2_N_USE_TRANSPORT_MODE		= 16391,	/* RFC4306 */
+	IKEV2_N_HTTP_CERT_LOOKUP_SUPPORTED	= 16392,	/* RFC4306 */
+	IKEV2_N_REKEY_SA			= 16393,	/* RFC4306 */
+	IKEV2_N_ESP_TFC_PADDING_NOT_SUPPORTED	= 16394,	/* RFC4306 */
+	IKEV2_N_NON_FIRST_FRAGMENTS_ALSO	= 16395,	/* RFC4306 */
+	IKEV2_N_MOBIKE_SUPPORTED		= 16396,	/* RFC4555 */
+	IKEV2_N_ADDITIONAL_IP4_ADDRESS		= 16397,	/* RFC4555 */
+	IKEV2_N_ADDITIONAL_IP6_ADDRESS		= 16398,	/* RFC4555 */
+	IKEV2_N_NO_ADDITIONAL_ADDRESSES		= 16399,	/* RFC4555 */
+	IKEV2_N_UPDATE_SA_ADDRESSES		= 16400,	/* RFC4555 */
+	IKEV2_N_COOKIE2				= 16401,	/* RFC4555 */
+	IKEV2_N_NO_NATS_ALLOWED			= 16402,	/* RFC4555 */
+	IKEV2_N_AUTH_LIFETIME			= 16403,	/* RFC4478 */
+	IKEV2_N_MULTIPLE_AUTH_SUPPORTED		= 16404,	/* RFC4739 */
+	IKEV2_N_ANOTHER_AUTH_FOLLOWS		= 16405,	/* RFC4739 */
+	IKEV2_N_REDIRECT_SUPPORTED		= 16406,	/* RFC5685 */
+	IKEV2_N_REDIRECT			= 16407,	/* RFC5685 */
+	IKEV2_N_REDIRECTED_FROM			= 16408,	/* RFC5685 */
+	IKEV2_N_TICKET_LT_OPAQUE		= 16409,	/* RFC5723 */
+	IKEV2_N_TICKET_REQUEST			= 16410,	/* RFC5723 */
+	IKEV2_N_TICKET_ACK			= 16411,	/* RFC5723 */
+	IKEV2_N_TICKET_NACK			= 16412,	/* RFC5723 */
+	IKEV2_N_TICKET_OPAQUE			= 16413,	/* RFC5723 */
+	IKEV2_N_LINK_ID				= 16414,	/* RFC5739 */
+	IKEV2_N_USE_WESP_MODE			= 16415,
+			/* RFC-ietf-ipsecme-traffic-visibility-12.txt */
+	IKEV2_N_ROHC_SUPPORTED			= 16416,
+			/* RFC-ietf-rohc-ikev2-extensions-hcoipsec-12.txt */
+	IKEV2_N_EAP_ONLY_AUTHENTICATION		= 16417,	/* RFC5998 */
+	IKEV2_N_CHILDLESS_IKEV2_SUPPORTED	= 16418,	/* RFC6023 */
+	IKEV2_N_QUICK_CRASH_DETECTION		= 16419,	/* RFC6290 */
+	IKEV2_N_IKEV2_MESSAGE_ID_SYNC_SUPPORTED	= 16420,	/* RFC6311 */
+	IKEV2_N_IPSEC_REPLAY_CTR_SYNC_SUPPORTED	= 16421,	/* RFC6311 */
+	IKEV2_N_IKEV2_MESSAGE_ID_SYNC		= 16422,	/* RFC6311 */
+	IKEV2_N_IPSEC_REPLAY_CTR_SYNC		= 16423,	/* RFC6311 */
+	IKEV2_N_SECURE_PASSWORD_METHODS		= 16424,	/* RFC6467 */
+	IKEV2_N_PSK_PERSIST			= 16425,	/* RFC6631 */
+	IKEV2_N_PSK_CONFIRM			= 16426,	/* RFC6631 */
+	IKEV2_N_ERX_SUPPORTED			= 16427,	/* RFC6867 */
+	IKEV2_N_IFOM_CAPABILITY			= 16428		/* OA3GPP */
+} ikev2_notify_type_t;
+
+/*
+ * DELETE payload
+ */
+struct ikev2_delete {
+	uint8_t 	del_protoid;		/* Protocol Id */
+	uint8_t		del_spisize;		/* SPI size */
+	uint16_t	del_nspi;		/* Number of SPIs */
+	/* Followed by variable length SPIs */
+} __packed;
+
+/*
+ * ID payload
+ */
+struct ikev2_id {
+	uint8_t	 id_type;		/* Id type */
+	uint8_t	 id_reserved[3];	/* Reserved */
+	/* Followed by the identification data */
+} __packed;
+
+typedef enum ikev2_id_type {
+	IKEV2_ID_IPV4_ADDR	= 1,	/* RFC7296 */
+	IKEV2_ID_FQDN		= 2,	/* RFC7296 */
+	IKEV2_ID_RFC822_ADDR	= 3,	/* RFC7296 */
+	IKEV2_ID_IPV6_ADDR	= 5,	/* RFC7296 */
+	IKEV2_ID_DER_ASN1_DN	= 9,	/* RFC7296 */
+	IKEV2_ID_DER_ASN1_GN	= 10,	/* RFC7296 */
+	IKEV2_ID_KEY_ID		= 11,	/* RFC7296 */
+	IKEV2_ID_FC_NAME	= 12	/* RFC4595 */
+} ikev2_id_type_t;
+
+/*
+ * CERT/CERTREQ payloads
+ */
+typedef enum ikev2_cert {
+	IKEV2_CERT_NONE =			0,	/* None */
+	IKEV2_CERT_X509_PKCS7 =			1,	/* RFC4306 */
+	IKEV2_CERT_PGP =			2,	/* RFC4306 */
+	IKEV2_CERT_DNS_SIGNED_KEY =		3,	/* RFC4306 */
+	IKEV2_CERT_X509_CERT =			4,	/* RFC4306 */
+	IKEV2_CERT_KERBEROS_TOKEN =		6,	/* RFC4306 */
+	IKEV2_CERT_CRL =			7,	/* RFC4306 */
+	IKEV2_CERT_ARL =			8,	/* RFC4306 */
+	IKEV2_CERT_SPKI =			9,	/* RFC4306 */
+	IKEV2_CERT_X509_ATTR =			10,	/* RFC4306 */
+	IKEV2_CERT_RSA_KEY =			11,	/* RFC4306 */
+	IKEV2_CERT_HASHURL_X509 =		12,	/* RFC4306 */
+	IKEV2_CERT_HASHURL_X509_BUNDLE =	13,	/* RFC4306 */
+	IKEV2_CERT_OCSP =			14	/* RFC4806 */
+} ikev2_cert_t;
+
+/*
+ * TSi/TSr payloads
+ */
+struct ikev2_tsp {
+	uint8_t	tsp_count;		/* Number of TSs */
+	uint8_t	tsp_reserved[3];	/* Reserved */
+	/* Followed by the traffic selectors */
+} __packed;
+
+struct ikev2_ts {
+	uint8_t		ts_type;		/* TS type */
+	uint8_t		ts_protoid;		/* Protocol Id */
+	uint16_t	ts_length;		/* Length */
+	uint16_t	ts_startport;		/* Start port */
+	uint16_t	ts_endport;		/* End port */
+} __packed;
+
+typedef enum ikev2_ts_type {
+	IKEV2_TS_IPV4_ADDR_RANGE =	7,	/* RFC4306 */
+	IKEV2_TS_IPV6_ADDR_RANGE =	8,	/* RFC4306 */
+	IKEV2_TS_FC_ADDR_RANGE =	9	/* RFC4595 */
+} ikev2_ts_type_t;
+
+/*
+ * AUTH payload
+ */
+struct ikev2_auth {
+	uint8_t	auth_method;		/* Signature type */
+	uint8_t	auth_reserved[3];	/* Reserved */
+	/* Followed by the signature */
+} __packed;
+
+typedef enum ikev2_auth_type {
+	IKEV2_AUTH_NONE =		0,	/* None */
+	IKEV2_AUTH_RSA_SIG =		1,	/* RFC4306 */
+	IKEV2_AUTH_SHARED_KEY_MIC =	2,	/* RFC4306 */
+	IKEV2_AUTH_DSS_SIG =		3,	/* RFC4306 */
+	IKEV2_AUTH_ECDSA_256 =		9,	/* RFC4754 */
+	IKEV2_AUTH_ECDSA_384 =		10,	/* RFC4754 */
+	IKEV2_AUTH_ECDSA_512 =		11,	/* RFC4754 */
+	IKEV2_AUTH_GSPM =		12	/* RFC6467 */
+} ikev2_auth_type_t;
+
+/*
+ * CP payload
+ */
+struct ikev2_cp {
+	uint8_t	cp_type;
+	uint8_t	cp_reserved[3];
+	/* Followed by the attributes */
+} __packed;
+
+typedef enum ikev2_cfg_type {
+	IKEV2_CP_REQUEST	= 1,	/* CFG-Request */
+	IKEV2_CP_REPLY		= 2,	/* CFG-Reply */
+	IKEV2_CP_SET		= 3,	/* CFG-SET */
+	IKEV2_CP_ACK		= 4	/* CFG-ACK */
+} ikev2_cfg_type_t;
+
+struct ikev2_cfg {
+	uint16_t	cfg_type;	/* first bit must be set to zero */
+	uint16_t	cfg_length;
+	/* Followed by variable-length data */
+} __packed;
+
+typedef enum ikev2_cfg_attr_type {
+	IKEV2_CFG_INTERNAL_IP4_ADDRESS		= 1,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP4_NETMASK		= 2,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP4_DNS		= 3,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP4_NBNS		= 4,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_ADDRESS_EXPIRY	= 5,	/* RFC4306 */
+	IKEV2_CFG_INTERNAL_IP4_DHCP		= 6,	/* RFC5996 */
+	IKEV2_CFG_APPLICATION_VERSION		= 7,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP6_ADDRESS		= 8,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP6_DNS		= 10,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP6_NBNS		= 11,	/* RFC4306 */
+	IKEV2_CFG_INTERNAL_IP6_DHCP		= 12,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP4_SUBNET		= 13,	/* RFC5996 */
+	IKEV2_CFG_SUPPORTED_ATTRIBUTES		= 14,	/* RFC5996 */
+	IKEV2_CFG_INTERNAL_IP6_SUBNET		= 15,	/* RFC5996 */
+	IKEV2_CFG_MIP6_HOME_PREFIX		= 16,	/* RFC5026 */
+	IKEV2_CFG_INTERNAL_IP6_LINK		= 17,	/* RFC5739 */
+	IKEV2_CFG_INTERNAL_IP6_PREFIX		= 18,	/* RFC5739 */
+	IKEV2_CFG_HOME_AGENT_ADDRESS		= 19,
+/* BEGIN CSTYLED */
+		/* http://www.3gpp.org/ftp/Specs/html-info/24302.htm */
+/* END CSTYLED */
+	IKEV2_CFG_INTERNAL_IP4_SERVER		= 23456, /* MS-IKEE */
+	IKEV2_CFG_INTERNAL_IP6_SERVER		= 23457  /* MS-IKEE */
+} ikev2_cfg_attr_type_t;
+
+/* MD5 sum of "ILLUMOS_1 2017/08/21 29.718 -95.390" */
+#define	VENDOR_STR_ILLUMOS_1	"6a3b8d3af106854d3a2c56c50df729cf"
+
+/* The vendor types + versions we recognize */
+typedef enum vendor {
+	VENDOR_UNKNOWN			= 0,
+	VENDOR_ILLUMOS_1		= 1
+} vendor_t;
+
+typedef struct ikev2_payload ikev2_payload_t;
+typedef struct ikev2_sa_proposal ikev2_sa_proposal_t;
+typedef struct ikev2_transform ikev2_transform_t;
+typedef struct ikev2_attribute ikev2_attribute_t;
+typedef struct ikev2_ke ikev2_ke_t;
+typedef struct ikev2_notify ikev2_notify_t;
+typedef struct ikev2_delete ikev2_delete_t;
+typedef struct ikev2_id ikev2_id_t;
+typedef struct ikev2_tsp ikev2_tsp_t;
+typedef struct ikev2_ts ikev2_ts_t;
+typedef struct ikev2_auth ikev2_auth_t;
+typedef struct ikev2_cp ikev2_cp_t;
+typedef struct ikev2_cfg ikev2_cfg_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.c
new file mode 100644
index 0000000000..891200438e
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.c
@@ -0,0 +1,713 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+#include <sys/types.h>
+#include <net/pfkeyv2.h>
+#include <sys/debug.h>
+#include <string.h>
+#include "defs.h"
+#include "ikev2_sa.h"
+#include "ikev2_pkt.h"
+#include "ikev2_common.h"
+#include "ikev2_enum.h"
+#include "ikev2_proto.h"
+#include "config.h"
+#include "pkcs11.h"
+#include "pkt.h"
+
+/*
+ * XXX: IKEv1 selected the PRF based on the authentication algorithm.
+ * IKEv2 allows the PRF to be negotiated separately.  Eventually, we
+ * should probably add the ability to specify PRFs in the configuration
+ * file.  For now, we just include all the ones we support in decreasing
+ * order of preference.
+ */
+static ikev2_prf_t prf_supported[] = {
+	IKEV2_PRF_HMAC_SHA2_512,
+	IKEV2_PRF_HMAC_SHA2_384,
+	IKEV2_PRF_HMAC_SHA2_256,
+	IKEV2_PRF_HMAC_SHA1,
+	IKEV2_PRF_HMAC_MD5
+};
+
+boolean_t
+ikev2_sa_from_acquire(pkt_t *restrict pkt, parsedmsg_t *restrict pmsg,
+    uint32_t spi, ikev2_dh_t dh)
+{
+	sadb_msg_t *samsg = pmsg->pmsg_samsg;
+	sadb_sa_t *sa;
+	sadb_prop_t *prop;
+	sadb_comb_t *comb;
+	boolean_t ok;
+	ikev2_spi_proto_t spi_type = IKEV2_PROTO_NONE;
+	pkt_sa_state_t pss;
+
+	ASSERT3U(samsg->sadb_msg_type, ==, SADB_ACQUIRE);
+
+	switch (samsg->sadb_msg_satype) {
+	case SADB_SATYPE_AH:
+		spi_type = IKEV2_PROTO_AH;
+		break;
+	case SADB_SATYPE_ESP:
+		spi_type = IKEV2_PROTO_ESP;
+		break;
+	default:
+		INVALID("sadb_msg_satype");
+	}
+
+	prop = (sadb_prop_t *)pmsg->pmsg_exts[SADB_EXT_PROPOSAL];
+	ASSERT3U(prop->sadb_prop_exttype, ==, SADB_EXT_PROPOSAL);
+
+	ok = ikev2_add_sa(pkt, &pss);
+
+	comb = (sadb_comb_t *)(prop + 1);
+	for (size_t i = 0; i < prop->sadb_x_prop_numecombs; i++, comb++) {
+		ok &= ikev2_add_prop(&pss, i + 1, spi_type, spi);
+
+		if (comb->sadb_comb_encrypt != SADB_EALG_NONE) {
+			ikev2_xf_encr_t encr;
+			uint16_t minbits, maxbits;
+
+			encr = ikev2_pfkey_to_encr(comb->sadb_comb_encrypt);
+			minbits = comb->sadb_comb_encrypt_minbits;
+			maxbits = comb->sadb_comb_encrypt_maxbits;
+			ok &= ikev2_add_xf_encr(&pss, encr, minbits, maxbits);
+		}
+
+		if (comb->sadb_comb_auth != SADB_AALG_NONE) {
+			ikev2_xf_auth_t xf_auth;
+			/*
+			 * Neither the auth algorithms currently supported
+			 * nor the IKE protocol itself supports specifying
+			 * a key/bits size for the auth alg.
+			 */
+			VERIFY3U(comb->sadb_comb_auth_minbits, ==, 0);
+			VERIFY3U(comb->sadb_comb_auth_maxbits, ==, 0);
+
+			xf_auth = ikev2_pfkey_to_auth(comb->sadb_comb_auth);
+			ok &= ikev2_add_xform(&pss, IKEV2_XF_AUTH, xf_auth);
+		}
+
+		if (dh != IKEV2_DH_NONE)
+			ok &= ikev2_add_xform(&pss, IKEV2_XF_DH, dh);
+
+		/* We currently don't support ESNs */
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_ESN, IKEV2_ESN_NONE);
+	}
+
+	return (ok);
+}
+
+ikev2_xf_auth_t
+ikev2_pfkey_to_auth(int alg)
+{
+	switch (alg) {
+	case SADB_AALG_NONE:
+	case SADB_AALG_SHA256HMAC:
+	case SADB_AALG_SHA384HMAC:
+	case SADB_AALG_SHA512HMAC:
+		/* these values all correspond */
+		return (alg);
+	case SADB_AALG_MD5HMAC:
+		/* this one does not */
+		return (IKEV2_XF_AUTH_HMAC_MD5_96);
+	case SADB_AALG_SHA1HMAC:
+		/* nor does this one */
+		return (IKEV2_XF_AUTH_HMAC_SHA1_96);
+	default:
+		INVALID("alg");
+		/*NOTREACHED*/
+		return (alg);
+	}
+}
+
+ikev2_xf_encr_t
+ikev2_pfkey_to_encr(int alg)
+{
+	switch (alg) {
+	case SADB_EALG_NONE:
+	case SADB_EALG_DESCBC:
+	case SADB_EALG_3DESCBC:
+	case SADB_EALG_BLOWFISH:
+	case SADB_EALG_NULL:
+	case SADB_EALG_AES:	/* CBC */
+	case SADB_EALG_AES_CCM_8:
+	case SADB_EALG_AES_CCM_12:
+	case SADB_EALG_AES_CCM_16:
+	case SADB_EALG_AES_GCM_8:
+	case SADB_EALG_AES_GCM_12:
+	case SADB_EALG_AES_GCM_16:
+		return (alg);
+	default:
+		INVALID("alg");
+		/*NOTREACHED*/
+		return (alg);
+	}
+}
+
+static boolean_t add_rule_xform(pkt_sa_state_t *restrict,
+    const config_xf_t *restrict);
+
+boolean_t
+ikev2_sa_from_rule(pkt_t *restrict pkt, const config_rule_t *restrict rule,
+    uint64_t spi)
+{
+	boolean_t ok = B_TRUE;
+	pkt_sa_state_t pss;
+
+	if (!ikev2_add_sa(pkt, &pss))
+		return (B_FALSE);
+
+	for (uint8_t i = 0; rule->rule_xf[i] != NULL; i++) {
+		/* RFC 7296 3.3.1 - Proposal numbers start with 1 */
+		ok &= ikev2_add_prop(&pss, i + 1, IKEV2_PROTO_IKE, spi);
+		ok &= add_rule_xform(&pss, rule->rule_xf[i]);
+	}
+	return (ok);
+}
+
+static boolean_t
+add_rule_xform(pkt_sa_state_t *restrict pss, const config_xf_t *restrict xf)
+{
+	encr_modes_t mode = encr_data[xf->xf_encr].ed_mode;
+	boolean_t ok = B_TRUE;
+
+	ok &= ikev2_add_xf_encr(pss, xf->xf_encr, xf->xf_minbits,
+	    xf->xf_maxbits);
+
+	/*
+	 * For all currently known combined mode ciphers, we can omit an
+	 * integrity transform
+	 */
+	if (!MODE_IS_COMBINED(mode))
+		ok &= ikev2_add_xform(pss, IKEV2_XF_AUTH, xf->xf_auth);
+	ok &= ikev2_add_xform(pss, IKEV2_XF_DH, xf->xf_dh);
+
+	for (size_t i = 0; ok && i < ARRAY_SIZE(prf_supported); i++)
+		ok &= ikev2_add_xform(pss, IKEV2_XF_PRF, prf_supported[i]);
+
+	return (ok);
+}
+
+boolean_t
+ikev2_sa_add_result(pkt_t *restrict pkt,
+    const ikev2_sa_result_t *restrict result)
+{
+	boolean_t ok;
+	pkt_sa_state_t pss;
+
+	ok = ikev2_add_sa(pkt, &pss);
+	ok &= ikev2_add_prop(&pss, result->sar_propnum, result->sar_proto,
+	    result->sar_spi);
+
+	if (SA_RESULT_HAS(result, IKEV2_XF_ENCR)) {
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_ENCR, result->sar_encr);
+		if (result->sar_encr_keylen != 0)
+			ok &= ikev2_add_xf_attr(&pss, IKEV2_XF_ATTR_KEYLEN,
+			    result->sar_encr_keylen);
+	}
+	if (SA_RESULT_HAS(result, IKEV2_XF_AUTH))
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_AUTH, result->sar_auth);
+	if (SA_RESULT_HAS(result, IKEV2_XF_DH))
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_DH, result->sar_dh);
+	if (SA_RESULT_HAS(result, IKEV2_XF_PRF))
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_PRF, result->sar_prf);
+	if (SA_RESULT_HAS(result, IKEV2_XF_ESN))
+		ok &= ikev2_add_xform(&pss, IKEV2_XF_ESN, result->sar_esn);
+
+	return (ok);
+}
+
+struct rule_data_s {
+	bunyan_logger_t		*rd_log;
+	config_rule_t		*rd_rule;
+	config_xf_t		*rd_xf;
+	ikev2_sa_result_t	*rd_res;
+	ikev2_prf_t		rd_prf;
+	boolean_t		rd_match;
+	boolean_t		rd_skip;
+	boolean_t		rd_has_auth;
+	boolean_t		rd_keylen_match;
+};
+
+static boolean_t match_rule_prop_cb(ikev2_sa_proposal_t *, uint64_t, uint8_t *,
+    size_t, void *);
+static boolean_t match_rule_xf_cb(ikev2_transform_t *, uint8_t *, size_t,
+    void *);
+static boolean_t match_rule_attr_cb(ikev2_attribute_t *, void *);
+
+boolean_t
+ikev2_sa_match_rule(config_rule_t *restrict rule, pkt_t *restrict pkt,
+    ikev2_sa_result_t *restrict result)
+{
+	pkt_payload_t *pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_SA, NULL);
+	bunyan_logger_t *l = pkt->pkt_sa->i2sa_log;
+
+	VERIFY3P(pay, !=, NULL);
+
+	bunyan_debug(l, "Checking rules against proposals",
+	    BUNYAN_T_STRING, "rule", rule->rule_label,
+	    BUNYAN_T_END);
+
+	for (size_t i = 0; rule->rule_xf[i] != NULL; i++) {
+		for (size_t j = 0; j < ARRAY_SIZE(prf_supported); j++) {
+			struct rule_data_s data = {
+				.rd_log = l,
+				.rd_rule = rule,
+				.rd_xf = rule->rule_xf[i],
+				.rd_res = result,
+				.rd_prf = prf_supported[j],
+				.rd_match = B_FALSE
+			};
+
+			(void) memset(result, 0, sizeof (*result));
+
+			bunyan_trace(l,
+			    "Checking rule transform against proposals",
+			    BUNYAN_T_UINT32, "xfnum", (uint32_t)i,
+			    BUNYAN_T_STRING, "xf", rule->rule_xf[i]->xf_str,
+			    BUNYAN_T_END);
+
+			VERIFY(ikev2_walk_proposals(pay->pp_ptr, pay->pp_len,
+			    match_rule_prop_cb, &data, l, B_FALSE));
+
+			if (data.rd_match) {
+				bunyan_debug(l, "Found proposal match",
+				    BUNYAN_T_STRING, "xf",
+				    rule->rule_xf[i]->xf_str,
+				    BUNYAN_T_UINT32, "propnum",
+				    (uint32_t)result->sar_propnum,
+				    BUNYAN_T_UINT64, "spi", result->sar_spi,
+				    BUNYAN_T_STRING, "encr",
+				    ikev2_xf_encr_str(result->sar_encr),
+				    BUNYAN_T_UINT32, "keylen",
+				    (uint32_t)result->sar_encr_keylen,
+				    BUNYAN_T_STRING, "auth",
+				    ikev2_xf_auth_str(result->sar_auth),
+				    BUNYAN_T_STRING, "prf",
+				    ikev2_prf_str(result->sar_prf),
+				    BUNYAN_T_STRING, "dh",
+				    ikev2_dh_str(result->sar_dh),
+				    BUNYAN_T_END);
+				return (B_TRUE);
+			}
+		}
+	}
+
+	bunyan_debug(l, "No matching proposals found", BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+static boolean_t
+match_rule_prop_cb(ikev2_sa_proposal_t *prop, uint64_t spi, uint8_t *buf,
+    size_t buflen, void *cookie)
+{
+	struct rule_data_s *data = cookie;
+
+	bunyan_trace(data->rd_log, "Checking proposal",
+	    BUNYAN_T_UINT32, "propnum", (uint32_t)prop->proto_proposalnr,
+	    BUNYAN_T_END);
+
+	if (prop->proto_protoid != IKEV2_PROTO_IKE) {
+		bunyan_trace(data->rd_log, "Proposal is not for IKE",
+		    BUNYAN_T_STRING, "protocol",
+		    ikev2_spi_str(prop->proto_protoid),
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	(void) memset(data->rd_res, 0, sizeof (*data->rd_res));
+	data->rd_skip = B_FALSE;
+	data->rd_has_auth = B_FALSE;
+
+	VERIFY(ikev2_walk_xfs(buf, buflen, match_rule_xf_cb, cookie,
+	    data->rd_log));
+
+	if (data->rd_skip)
+		return (B_TRUE);
+
+	/* These must all match, otherwise next proposal */
+	if (!SA_RESULT_HAS(data->rd_res, IKEV2_XF_ENCR) ||
+	    !SA_RESULT_HAS(data->rd_res, IKEV2_XF_PRF) ||
+	    !SA_RESULT_HAS(data->rd_res, IKEV2_XF_DH) ||
+	    (!MODE_IS_COMBINED(encr_data[data->rd_res->sar_encr].ed_mode) &&
+	    !SA_RESULT_HAS(data->rd_res, IKEV2_XF_AUTH)))
+		return (B_TRUE);
+
+	/* A match.  Stop walk of remaining proposals */
+	data->rd_res->sar_proto = prop->proto_protoid;
+	data->rd_res->sar_spi = spi;
+	data->rd_res->sar_propnum = prop->proto_proposalnr;
+	data->rd_match = B_TRUE;
+	return (B_FALSE);
+}
+
+static boolean_t
+match_rule_xf_cb(ikev2_transform_t *xf, uint8_t *buf, size_t buflen,
+    void *cookie)
+{
+	struct rule_data_s *data = cookie;
+	boolean_t match = B_FALSE;
+
+	(void) bunyan_trace(data->rd_log, "Checking transform",
+		    BUNYAN_T_STRING, "xftype", ikev2_xf_type_str(xf->xf_type),
+		    BUNYAN_T_UINT32, "val", (uint32_t)xf->xf_id,
+		    BUNYAN_T_END);
+
+	switch (xf->xf_type) {
+	case IKEV2_XF_ENCR:
+		if (data->rd_xf->xf_encr != xf->xf_id)
+			break;
+
+		if (buflen > 0) {
+			/*
+			 * XXX: Verify if there should be attributes for this
+			 * particular alg?
+			 */
+			data->rd_keylen_match = B_FALSE;
+			VERIFY(ikev2_walk_xfattrs(buf, buflen,
+			    match_rule_attr_cb, cookie, data->rd_log));
+
+			/*
+			 * RFC7296 3.3.6 - Unknown attribute means skip
+			 * the transform, but not the whole proposal.
+			 */
+			if (data->rd_skip) {
+				data->rd_skip = B_FALSE;
+				break;
+			}
+			if (!data->rd_keylen_match)
+				break;
+		}
+		data->rd_res->sar_encr = xf->xf_id;
+		match = B_TRUE;
+		break;
+	case IKEV2_XF_AUTH:
+		data->rd_has_auth = B_TRUE;
+		if (data->rd_xf->xf_auth == xf->xf_id) {
+			data->rd_res->sar_auth = xf->xf_id;
+			match = B_TRUE;
+		}
+		break;
+	case IKEV2_XF_PRF:
+		if (xf->xf_id == data->rd_prf) {
+			match = B_TRUE;
+			data->rd_res->sar_prf = data->rd_prf;
+		}
+		break;
+	case IKEV2_XF_DH:
+		if (data->rd_xf->xf_dh == xf->xf_id) {
+			match = B_TRUE;
+			data->rd_res->sar_dh = xf->xf_id;
+		}
+		break;
+	case IKEV2_XF_ESN:
+		/* Not valid in IKE proposals */
+		(void) bunyan_info(data->rd_log,
+		    "Encountered ESN transform in IKE transform", BUNYAN_T_END);
+		data->rd_skip = B_TRUE;
+		break;
+	default:
+		/*
+		 * RFC7296 3.3.6 - An unrecognized transform type means the
+		 * proposal should be ignored.
+		 */
+		(void) bunyan_info(data->rd_log,
+		    "Unknown transform type in proposal",
+		    BUNYAN_T_UINT32, "xftype", (uint32_t)xf->xf_type,
+		    BUNYAN_T_END);
+		data->rd_skip = B_TRUE;
+	}
+
+	if (match) {
+		(void) bunyan_trace(data->rd_log, "Partial match",
+		    BUNYAN_T_STRING, "type", ikev2_xf_type_str(xf->xf_type),
+		    BUNYAN_T_UINT32, "val", (uint32_t)xf->xf_id,
+		    BUNYAN_T_END);
+		data->rd_res->sar_match |= (uint32_t)1 << xf->xf_type;
+	}
+
+	return (!data->rd_skip);
+}
+
+static boolean_t
+match_rule_attr_cb(ikev2_attribute_t *attr, void *cookie)
+{
+	struct rule_data_s *data = cookie;
+
+	/* Only one attribute type is recognized currently */
+	if (IKE_ATTR_GET_TYPE(attr->attr_type) != IKEV2_XF_ATTR_KEYLEN) {
+		data->rd_skip = B_TRUE;
+		return (B_FALSE);
+	}
+
+	if (attr->attr_length >= data->rd_xf->xf_minbits &&
+	    attr->attr_length <= data->rd_xf->xf_maxbits) {
+		data->rd_res->sar_encr_keylen = attr->attr_length;
+		data->rd_keylen_match = B_TRUE;
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+struct acquire_data_s {
+	bunyan_logger_t		*ad_log;
+	sadb_comb_t		*ad_comb;
+	ikev2_sa_result_t	*ad_res;
+	ikev2_spi_proto_t	ad_spitype;
+	ikev2_dh_t		ad_dh;
+	boolean_t		ad_skip;
+	boolean_t		ad_match;
+	boolean_t		ad_keylen_match;
+};
+
+static boolean_t match_acq_prop_cb(ikev2_sa_proposal_t *, uint64_t,
+    uint8_t *, size_t, void *);
+static boolean_t match_acq_xf_cb(ikev2_transform_t *, uint8_t *, size_t,
+    void *);
+static boolean_t match_acq_attr_cb(ikev2_attribute_t *, void *);
+
+boolean_t
+ikev2_sa_match_acquire(parsedmsg_t *restrict pmsg, ikev2_dh_t dh,
+    pkt_t *restrict pkt, ikev2_sa_result_t *restrict result)
+{
+	pkt_payload_t *pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_SA, NULL);
+	bunyan_logger_t *l = pkt->pkt_sa->i2sa_log;
+	sadb_msg_t *samsg = pmsg->pmsg_samsg;
+	sadb_prop_t *prop;
+	sadb_comb_t *comb;
+	ikev2_spi_proto_t spitype = IKEV2_PROTO_NONE;
+
+	VERIFY3P(pay, !=, NULL);
+
+	(void) bunyan_debug(l, "Checking rules against acquire", BUNYAN_T_END);
+
+	switch (samsg->sadb_msg_satype) {
+	case SADB_SATYPE_AH:
+		spitype = IKEV2_PROTO_AH;
+		break;
+	case SADB_SATYPE_ESP:
+		spitype = IKEV2_PROTO_ESP;
+		break;
+	default:
+		INVALID("sadb_msg_satype");
+	}
+
+	prop = (sadb_prop_t *)pmsg->pmsg_exts[SADB_EXT_PROPOSAL];
+	comb = (sadb_comb_t *)(prop + 1);
+
+	for (size_t i = 0; i < prop->sadb_x_prop_numecombs; i++, comb++) {
+		struct acquire_data_s data = {
+			.ad_log = l,
+			.ad_comb = comb,
+			.ad_res = result,
+			.ad_spitype = spitype,
+			.ad_dh = dh
+		};
+
+		(void) memset(result, 0, sizeof (*result));
+
+		VERIFY(ikev2_walk_proposals(pay->pp_ptr, pay->pp_len,
+		    match_acq_prop_cb, &data, l, B_FALSE));
+
+		if (data.ad_match) {
+			(void) bunyan_debug(l, "Found proposal match",
+			    BUNYAN_T_UINT32, "propnum",
+			    (uint32_t)result->sar_propnum,
+			    BUNYAN_T_UINT64, "spi", result->sar_spi,
+			    BUNYAN_T_STRING, "encr",
+			    ikev2_xf_encr_str(result->sar_encr),
+			    BUNYAN_T_UINT32, "keylen",
+			    (uint32_t)result->sar_encr_keylen,
+			    BUNYAN_T_STRING, "auth",
+			    ikev2_xf_auth_str(result->sar_auth),
+			    BUNYAN_T_STRING, "prf",
+			    ikev2_prf_str(result->sar_prf),
+			    BUNYAN_T_STRING, "dh", ikev2_dh_str(result->sar_dh),
+			    BUNYAN_T_UINT32, "esn", (uint32_t)result->sar_esn,
+			    BUNYAN_T_END);
+			return (B_TRUE);
+		}
+	}
+
+	bunyan_debug(l, "No matching proposals found", BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+static boolean_t
+match_acq_prop_cb(ikev2_sa_proposal_t *prop, uint64_t spi, uint8_t *buf,
+    size_t buflen, void *cookie)
+{
+	struct acquire_data_s *data = cookie;
+
+	if (prop->proto_protoid != data->ad_spitype) {
+		bunyan_debug(data->ad_log, "Proposal is not for this SA type",
+		    BUNYAN_T_STRING, "exp_satype",
+		    ikev2_spi_str(data->ad_spitype),
+		    BUNYAN_T_STRING, "prop_satype",
+		    ikev2_spi_str(prop->proto_protoid),
+		    BUNYAN_T_UINT32, "prop_satype_val",
+		    (uint32_t)prop->proto_protoid, BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	(void) memset(data->ad_res, 0, sizeof (*data->ad_res));
+	data->ad_skip = B_FALSE;
+
+	VERIFY(ikev2_walk_xfs(buf, buflen, match_acq_xf_cb, cookie,
+	    data->ad_log));
+
+	if (data->ad_skip)
+		return (B_TRUE);
+
+	/*
+	 * Go on to the next proposal if no match.  Check mandatory types
+	 * and optional types if we've specified one.
+	 * RFC7296 3.3.3 Lists mandatory and optional transform types
+	 */
+	switch (data->ad_spitype) {
+	case IKEV2_PROTO_ESP:
+		/* Mandatory: ENCR, ESN  Optional: AUTH, DH */
+		if (!SA_RESULT_HAS(data->ad_res, IKEV2_XF_ENCR) ||
+		    !SA_RESULT_HAS(data->ad_res, IKEV2_XF_ESN) ||
+		    (data->ad_comb->sadb_comb_auth != SADB_AALG_NONE &&
+		    !SA_RESULT_HAS(data->ad_res, IKEV2_XF_AUTH)) ||
+		    (data->ad_dh != IKEV2_DH_NONE &&
+		    !SA_RESULT_HAS(data->ad_res, IKEV2_XF_DH)))
+			return (B_TRUE);
+		break;
+	case IKEV2_PROTO_AH:
+		/* Mandatory: AUTH, ESN, Optional: DH */
+		if (!SA_RESULT_HAS(data->ad_res, IKEV2_XF_AUTH) ||
+		    !SA_RESULT_HAS(data->ad_res, IKEV2_XF_ESN) ||
+		    (data->ad_dh != IKEV2_DH_NONE &&
+		    !SA_RESULT_HAS(data->ad_res, IKEV2_XF_DH)))
+			return (B_TRUE);
+		break;
+	case IKEV2_PROTO_NONE:
+	case IKEV2_PROTO_IKE:
+	case IKEV2_PROTO_FC_ESP_HEADER:
+	case IKEV2_PROTO_FC_CT_AUTH:
+		INVALID("data->ad_spitype");
+		break;
+	}
+
+	return (B_FALSE);
+}
+static boolean_t
+match_acq_xf_cb(ikev2_transform_t *xf, uint8_t *buf, size_t buflen,
+    void *cookie)
+{
+	struct acquire_data_s *data = cookie;
+	boolean_t match = B_FALSE;
+
+	switch (xf->xf_type) {
+	case IKEV2_XF_ENCR:
+		if (xf->xf_id != data->ad_comb->sadb_comb_encrypt)
+			break;
+		/* XXX: match attr */
+		break;
+	case IKEV2_XF_PRF:
+		bunyan_debug(data->ad_log,
+		    "Encountered PRF transform in AH/ESP transform",
+		    BUNYAN_T_END);
+		data->ad_skip = B_TRUE;
+		break;
+	case IKEV2_XF_AUTH:
+		if (xf->xf_id != data->ad_comb->sadb_comb_auth)
+			break;
+		match = B_TRUE;
+		data->ad_res->sar_auth = xf->xf_id;
+		break;
+	case IKEV2_XF_DH:
+		if (xf->xf_id != data->ad_dh)
+			break;
+		match = B_TRUE;
+		data->ad_res->sar_dh = xf->xf_id;
+		break;
+	case IKEV2_XF_ESN:
+		/* XXX: At some point, pf_key(7P) will need support for this */
+		if (xf->xf_id != IKEV2_ESN_NONE)
+			break;
+		match = B_TRUE;
+		data->ad_res->sar_esn = B_FALSE;
+		break;
+	}
+
+	if (match)
+		data->ad_res->sar_match |= (uint32_t)1 << xf->xf_type;
+
+	return (!data->ad_skip);
+}
+
+static boolean_t
+match_acq_attr_cb(ikev2_attribute_t *attr, void *cookie)
+{
+	struct acquire_data_s *data = cookie;
+
+	if (attr->attr_type != IKEV2_XF_ATTR_KEYLEN) {
+		data->ad_skip = B_TRUE;
+		return (B_FALSE);
+	}
+
+	if (attr->attr_length >= data->ad_comb->sadb_comb_encrypt_minbits &&
+	    attr->attr_length <= data->ad_comb->sadb_comb_encrypt_maxbits) {
+		data->ad_res->sar_encr_keylen = attr->attr_length;
+		data->ad_keylen_match = B_TRUE;
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+void
+ikev2_no_proposal_chosen(ikev2_sa_t *restrict i2sa, const pkt_t *restrict src,
+    ikev2_spi_proto_t proto, uint64_t spi)
+{
+	pkt_t *resp = ikev2_pkt_new_response(src);
+
+	if (resp == NULL)
+		return;
+
+	if (!ikev2_add_notify(resp, proto, spi, IKEV2_N_NO_PROPOSAL_CHOSEN,
+	    NULL, 0)) {
+		ikev2_pkt_free(resp);
+		return;
+	}
+
+	/* Nothing can be done if send fails for this, so ignore return val */
+	(void) ikev2_send(resp, B_TRUE);
+
+	/* ikev2_send consumes packet, no need to free afterwards */
+}
+
+void
+ikev2_invalid_ke(const pkt_t *src, ikev2_spi_proto_t proto, uint64_t spi,
+    ikev2_dh_t dh)
+{
+	pkt_t *resp = ikev2_pkt_new_response(src);
+	uint16_t val = htons((uint16_t)dh);
+
+	if (resp == NULL)
+		return;
+
+	if (!ikev2_add_notify(resp, proto, spi, IKEV2_N_INVALID_KE_PAYLOAD,
+	    &val, sizeof (val))) {
+		ikev2_pkt_free(resp);
+		return;
+	}
+
+	(void) ikev2_send(resp, B_TRUE);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.h
new file mode 100644
index 0000000000..9cbe5621f1
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_common.h
@@ -0,0 +1,69 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _IKEV2_COMMON_H
+#define	_IKEV2_COMMON_H
+
+#include <inttypes.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct ikev2_sa_result_s {
+	uint64_t		sar_spi;
+	uint32_t		sar_match;
+	ikev2_spi_proto_t	sar_proto;
+	ikev2_xf_encr_t		sar_encr;
+	ikev2_xf_auth_t		sar_auth;
+	ikev2_prf_t		sar_prf;
+	ikev2_dh_t		sar_dh;
+	uint16_t		sar_encr_keylen;
+	boolean_t		sar_esn;
+	uint8_t			sar_propnum;
+} ikev2_sa_result_t;
+#define	SA_RESULT_HAS(res, which) ((res)->sar_match & ((uint32_t)1 << (which)))
+
+struct pkt_s;
+struct config_rule_s;
+struct parsedmsg_s;
+struct ikev2_sa_s;
+
+ikev2_xf_auth_t ikev2_pfkey_to_auth(int);
+ikev2_xf_encr_t ikev2_pfkey_to_encr(int);
+
+boolean_t ikev2_sa_from_acquire(struct pkt_s *restrict,
+    struct parsedmsg_s *restrict, uint32_t, ikev2_dh_t);
+boolean_t ikev2_sa_add_result(struct pkt_s *restrict,
+    const ikev2_sa_result_t *restrict);
+boolean_t ikev2_sa_from_rule(struct pkt_s *restrict,
+    const struct config_rule_s *restrict, uint64_t);
+
+boolean_t ikev2_sa_match_rule(struct config_rule_s *restrict,
+    struct pkt_s *restrict, ikev2_sa_result_t *restrict);
+boolean_t ikev2_sa_match_acquire(struct parsedmsg_s *restrict, ikev2_dh_t,
+    struct pkt_s *restrict, ikev2_sa_result_t *restrict);
+
+void ikev2_no_proposal_chosen(struct ikev2_sa_s *restrict,
+    const struct pkt_s *restrict, ikev2_spi_proto_t, uint64_t);
+void ikev2_invalid_ke(const struct pkt_s *, ikev2_spi_proto_t, uint64_t,
+    ikev2_dh_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_COMMON_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.c
new file mode 100644
index 0000000000..9a11185738
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.c
@@ -0,0 +1,333 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <errno.h>
+#include <netinet/in.h>
+#include <signal.h>
+#include <string.h>
+#include <sys/debug.h>
+#include <sys/time.h>
+#include <time.h>
+#include <pthread.h>
+#include <port.h>
+#include "defs.h"
+#include "ikev2_cookie.h"
+#include "ikev2_pkt.h"
+#include "ikev2_proto.h"
+#include "pkcs11.h"
+#include "random.h"
+
+#define	COOKIE_MECH		CKM_SHA_1
+#define	COOKIE_SECRET_LEN	(64)
+#define	COOKIE_LEN		(16 + 1)
+#define	COOKIE_SECRET_LIFETIME	SEC2NSEC(60)
+#define	COOKIE_GRACE		SEC2NSEC(5)
+
+size_t ikev2_cookie_threshold = 128;
+
+/*
+ * For cookies, we follow the guidance in RFC7296 2.6 and generate cookies
+ * such that:
+ *
+ *	Cookie = <VersionIDofSecret> | Hash(Ni | IPi | SPIi | <secret>)
+ *
+ * where <secret> is a random value of length COOKE_SECRET_LEN bytes,
+ * hash is the hash algorithm designated by COOKIE_MECH (currently CKM_SHA_1),
+ * and <VersionIDofSecret> is a monotonically increasing 8-bit unsigned
+ * value that corresponds to a given value of <secret>.  Note that the remote
+ * peer treats the cookie value as opaque and should not attempt to divine
+ * any structure in the value -- it is merely meant as a reasonably hard to
+ * predict value the remote peer must include in an IKE_SA_INIT exchange
+ * (when we request it) to prevent a remote peer from being able to generate
+ * large amounts of larval (half-open) IKE SAs.
+ *
+ * Whenever cookies are enabled, we arm cookie_timer to fire every
+ * COOKIE_SECRET_LIFETIME seconds to trigger the generation of a new secret
+ * and increment of the version.  When the cookie_timer fires, it generates
+ * an event on the event port used by the main thread which calls
+ * cookie_update_secret() to create the new secret and increment the version
+ * number.
+ *
+ * This rotation is done to minimize the ability of a remote attacker from
+ * being able to determine the value of secret.  When we generate a new
+ * secret, we do retain the previous version and allow the old secret to
+ * be used for up to COOKIE_GRACE seconds after a new cookie is created.  This
+ * should minimize excessive IKE_SA_INIT exchanges if they happen to occur
+ * right before a new secret is generated, while hopefully having a minimal
+ * impact on the effectiveness of the cookies themselves.
+ *
+ * The cookie secrets are not used in any way in deriving keying material
+ * and only serve to make the prediction of the cookie value by a remote
+ * attacker relatively expensive.  As such, we are not concerned about old
+ * secret values lingering around in memory after they expire.
+ *
+ * While it is possible the version value could wrap around (being only 8-bits),
+ * this is also not a concern as we generally only are concerned if the returned
+ * cookie value has the same version as ours, or for COOKIE_GRACE seconds after
+ * a new secret is generated, if the returned cookie version is the previous
+ * version.  With the currently defined values, if cookies are continuously
+ * enabled, it will take approximately 4.25 hours to wrap around.  In the worst
+ * (and largely absurd) case, if a remote peer send back a cookie derived using
+ * an 4.25 hour old secret that was derived using the same version (having
+ * wrapped-around), the cookie check will merely fail and the remote peer will
+ * need to resend its IKE_SA_INIT request with a current cookie.  This does
+ * mean that we impose a maximum latency of
+ * COOKIE_SECRET_LIFETIME + COOKIE_GRACE (currently 65) seconds on packets,
+ * regardless of configured IKE timeouts.  Since we currently do not currently
+ * have networks that span beyond Earth, this seems like a reasonable limitation
+ * for the time being.
+ */
+static struct secret_s {
+	uint8_t s_val[COOKIE_SECRET_LEN];
+	hrtime_t s_birth;
+} secret[2];
+#define	SECRET(v) secret[(v) & 0x1].s_val
+#define	SECRET_BIRTH(v) secret[(v) & 0x1].s_birth
+#define	SECRET_AGE(v) (gethrtime() - SECRET_BIRTH(v))
+
+static pthread_rwlock_t lock = PTHREAD_RWLOCK_INITIALIZER;
+static uint8_t version;
+static boolean_t enabled;
+static timer_t cookie_timer;
+
+static void cookie_update_secret(void);
+
+void
+ikev2_cookie_enable(void)
+{
+	VERIFY0(pthread_rwlock_wrlock(&lock));
+	if (enabled)
+		goto done;
+
+	if (SECRET_AGE(version) < COOKIE_SECRET_LIFETIME) {
+		struct itimerspec it = { 0 };
+		hrtime_t exp = SECRET_BIRTH(version) + COOKIE_SECRET_LIFETIME;
+
+		it.it_value.tv_sec = NSEC2SEC(exp);
+		it.it_value.tv_nsec = exp % NANOSEC;
+
+		if (timer_settime(cookie_timer, TIMER_ABSTIME, &it,
+		    NULL) != 0) {
+			STDERR(fatal, log, "timer_settime() failed");
+			exit(EXIT_FAILURE);
+		}
+		goto done;
+	}
+
+	cookie_update_secret();
+
+done:
+	VERIFY0(pthread_rwlock_unlock(&lock));
+}
+
+void
+ikev2_cookie_disable(void)
+{
+	struct itimerspec it = { 0 };
+	VERIFY0(pthread_rwlock_wrlock(&lock));
+	enabled = B_FALSE;
+	if (timer_settime(cookie_timer, 0, &it, NULL) != 0) {
+		STDERR(fatal, log, "timer_settime() failed");
+		exit(EXIT_FAILURE);
+	}
+	VERIFY0(pthread_rwlock_wrlock(&lock));
+}
+
+static boolean_t
+cookie_calc(uint8_t v, uint8_t *restrict nonce, size_t noncelen,
+    const struct sockaddr_storage *restrict ip, uint64_t spi,
+    uint8_t *out, CK_ULONG outlen)
+{
+	CK_SESSION_HANDLE h = p11h();
+	CK_MECHANISM mech = { COOKIE_MECH, NULL_PTR, 0 };
+	CK_ULONG iplen = 0;
+	CK_RV rc = CKR_OK;
+
+	rc = C_DigestInit(h, &mech);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, log, "C_DigestInit", rc);
+		goto done;
+	}
+
+	rc = C_DigestUpdate(h, nonce, noncelen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, log, "C_DigestUpdate", rc);
+		goto done;
+	}
+
+	switch (ip->ss_family) {
+	case AF_INET:
+		iplen = sizeof (in_addr_t);
+		break;
+	case AF_INET6:
+		iplen = sizeof (in6_addr_t);
+		break;
+	default:
+		INVALID("ss_family");
+	}
+	rc = C_DigestUpdate(h, (CK_BYTE_PTR)ss_addr(ip), iplen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, log, "C_DigestUpdate", rc);
+		goto done;
+	}
+
+	rc = C_DigestUpdate(h, (CK_BYTE_PTR)&spi, sizeof (spi));
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, log, "C_DigestUpdate", rc);
+		goto done;
+	}
+
+	rc = C_DigestUpdate(h, SECRET(v), COOKIE_SECRET_LEN);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, log, "C_DigestUpdate", rc);
+		goto done;
+	}
+
+	rc = C_DigestFinal(h, out, &outlen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, log, "C_DigestFinal", rc);
+		goto done;
+	}
+
+done:
+	return ((rc == CKR_OK) ? B_TRUE : B_FALSE);
+}
+
+static void
+send_cookie(pkt_t *restrict pkt,
+    const struct sockaddr_storage *restrict laddr,
+    const struct sockaddr_storage *restrict raddr)
+{
+	pkt_payload_t *nonce = pkt_get_payload(pkt, IKEV2_PAYLOAD_NONCE, NULL);
+	pkt_t *resp = ikev2_pkt_new_response(pkt);
+	uint8_t buf[COOKIE_LEN] = { 0 };
+
+	if (resp == NULL || nonce == NULL)
+		return;
+
+	buf[0] = version;
+	if (!cookie_calc(version, nonce->pp_ptr, nonce->pp_len, raddr,
+	    pkt->pkt_raw[0], buf + 1, sizeof (buf) - 1)) {
+		ikev2_pkt_free(resp);
+		return;
+	}
+
+	if (!ikev2_add_notify(resp, IKEV2_PROTO_IKE, 0, IKEV2_N_COOKIE, buf,
+	    sizeof (buf))) {
+		ikev2_pkt_free(resp);
+		return;
+	}
+
+	(void) ikev2_send(resp, B_TRUE);
+}
+
+static boolean_t
+cookie_compare(uint8_t *restrict nonce, size_t noncelen,
+    const struct sockaddr_storage *restrict ip, uint64_t spi,
+    uint8_t *restrict cmp, size_t cmplen)
+{
+	uint8_t buf[COOKIE_LEN] = { 0 };
+
+	VERIFY3U(cmplen, ==, sizeof (buf));
+
+	buf[0] = cmp[0];
+	if (!cookie_calc(cmp[0], nonce, noncelen, ip, spi, buf + 1,
+	    sizeof (buf) - 1))
+		return (B_FALSE);
+	return (!!(memcmp(buf, cmp, cmplen) == 0));
+}
+
+/*
+ * If cookies are enabled, perform cookie check and response. Return B_TRUE
+ * if cookie check succeeds.
+ * If cookies aren't enabled, just return B_TRUE to continue processing.
+ */
+boolean_t
+ikev2_cookie_check(pkt_t *restrict pkt,
+    const struct sockaddr_storage *restrict laddr,
+    const struct sockaddr_storage *restrict raddr)
+{
+	pkt_notify_t *cookie = pkt_get_notify(pkt, IKEV2_N_COOKIE, NULL);
+	pkt_payload_t *nonce = pkt_get_payload(pkt, IKEV2_PAYLOAD_NONCE, NULL);
+	boolean_t ok = B_TRUE;
+
+	VERIFY0(pthread_rwlock_rdlock(&lock));
+	if (!enabled)
+		goto done;
+
+	if (cookie == NULL) {
+		ok = B_FALSE;
+		send_cookie(pkt, laddr, raddr);
+		goto done;
+	}
+
+	if (cookie->pn_len != COOKIE_LEN) {
+		ok = B_FALSE;
+		goto done;
+	}
+
+	if (cookie->pn_ptr[0] != version && (cookie->pn_ptr[0] != version - 1 ||
+	    SECRET_AGE(version - 1) > COOKIE_GRACE)) {
+		ok = B_FALSE;
+		goto done;
+	}
+
+	ok = cookie_compare(nonce->pp_ptr, nonce->pp_len, raddr,
+	    pkt->pkt_raw[0], cookie->pn_ptr, cookie->pn_len);
+
+done:
+	VERIFY0(pthread_rwlock_unlock(&lock));
+	return (ok);
+}
+
+static void
+cookie_update_secret(void)
+{
+	struct itimerspec it = { 0 };
+
+	VERIFY0(pthread_rwlock_wrlock(&lock));
+
+	if (SECRET_BIRTH(version) != 0)
+		version++;
+	random_low(SECRET(version), COOKIE_SECRET_LEN);
+	SECRET_BIRTH(version) = gethrtime();
+
+	VERIFY0(pthread_rwlock_unlock(&lock));
+
+	it.it_value.tv_sec = NSEC2SEC(COOKIE_SECRET_LIFETIME);
+	it.it_value.tv_nsec = COOKIE_SECRET_LIFETIME % NANOSEC;
+	it.it_interval = it.it_value;
+	if (timer_settime(cookie_timer, 0, &it, NULL) != 0) {
+		STDERR(fatal, log, "timer_settime() failed");
+		exit(EXIT_FAILURE);
+	}
+}
+
+void
+ikev2_cookie_init(void)
+{
+	struct sigevent se = { 0 };
+	port_notify_t pn;
+
+	pn.portnfy_port = port;
+	pn.portnfy_user = cookie_update_secret;
+	se.sigev_notify = SIGEV_PORT;
+	se.sigev_value.sival_ptr = &pn;
+
+	if (timer_create(CLOCK_REALTIME, &se, &cookie_timer) != 0) {
+		STDERR(fatal, log, "timer_create() failed");
+		exit(EXIT_FAILURE);
+	}
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.h
new file mode 100644
index 0000000000..be38233f5b
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_cookie.h
@@ -0,0 +1,41 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _IKEV2_COOKIE_H
+#define	_IKEV2_COOKIE_H
+
+#include <inttypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	IKEV2_COOKIE_OFF_ADJ	(5)	/* XXX: Better name? */
+extern size_t ikev2_cookie_threshold;
+
+struct sockaddr_storage;
+struct pkt_s;
+
+void ikev2_cookie_enable(void);
+void ikev2_cookie_disable(void);
+boolean_t ikev2_cookie_check(struct pkt_s *restrict,
+    const struct sockaddr_storage *restrict,
+    const struct sockaddr_storage *restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_COOKIE_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.c
new file mode 100644
index 0000000000..5cc2931f4e
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.c
@@ -0,0 +1,430 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+#include "ikev2_enum.h"
+#include "ikev2.h"
+
+#define	STR(x) case x: return (#x)
+
+/*
+ * NOTE: We intentionally use switch statements instead of arrays for
+ * mapping enumerated constants to strings.  Doing so will allow the
+ * compiler to flag missing conversions for any entries that get added
+ * to enumerated types as long as no default clause is used in the switch.
+ */
+
+const char *
+ikev2_exch_str(ikev2_exch_t id)
+{
+	switch (id) {
+	case IKEV2_EXCH_IKE_SA_INIT:
+		return ("SA_INIT");
+	case IKEV2_EXCH_IKE_AUTH:
+		return ("AUTH");
+	case IKEV2_EXCH_CREATE_CHILD_SA:
+		return ("CREATE_CHILD_SA");
+	case IKEV2_EXCH_INFORMATIONAL:
+		return ("INFORMATIONAL");
+	case IKEV2_EXCH_IKE_SESSION_RESUME:
+		return ("SESSION_RESUME");
+	case IKEV2_EXCH_GSA_AUTH:
+		return ("GSA_AUTH");
+	case IKEV2_EXCH_GSA_REGISTRATION:
+		return ("GSA_REGISTRATION");
+	case IKEV2_EXCH_GSA_REKEY:
+		return ("GSA_REKEY");
+	}
+	return ("UNKNOWN");
+}
+
+const char *
+ikev2_pay_str(ikev2_pay_type_t id)
+{
+	switch (id) {
+	STR(IKEV2_PAYLOAD_NONE);
+	STR(IKEV2_PAYLOAD_SA);
+	STR(IKEV2_PAYLOAD_KE);
+	STR(IKEV2_PAYLOAD_IDi);
+	STR(IKEV2_PAYLOAD_IDr);
+	STR(IKEV2_PAYLOAD_CERT);
+	STR(IKEV2_PAYLOAD_CERTREQ);
+	STR(IKEV2_PAYLOAD_AUTH);
+	STR(IKEV2_PAYLOAD_NONCE);
+	STR(IKEV2_PAYLOAD_NOTIFY);
+	STR(IKEV2_PAYLOAD_DELETE);
+	STR(IKEV2_PAYLOAD_VENDOR);
+	STR(IKEV2_PAYLOAD_TSi);
+	STR(IKEV2_PAYLOAD_TSr);
+	STR(IKEV2_PAYLOAD_SK);
+	STR(IKEV2_PAYLOAD_CP);
+	STR(IKEV2_PAYLOAD_EAP);
+	STR(IKEV2_PAYLOAD_GSPM);
+	STR(IKEV2_PAYLOAD_IDg);
+	STR(IKEV2_PAYLOAD_GSA);
+	STR(IKEV2_PAYLOAD_KD);
+	STR(IKEV2_PAYLOAD_SKF);
+	STR(IKEV2_PAYLOAD_PS);
+	}
+	return ("UNKNOWN");
+}
+
+const char *
+ikev2_pay_short_str(ikev2_pay_type_t id)
+{
+	switch (id) {
+	case IKEV2_PAYLOAD_NONE:
+		return ("NONE");
+	case IKEV2_PAYLOAD_SA:
+		return ("SA");
+	case IKEV2_PAYLOAD_KE:
+		return ("KE");
+	case IKEV2_PAYLOAD_IDi:
+		return ("IDi");
+	case IKEV2_PAYLOAD_IDr:
+		return ("IDr");
+	case IKEV2_PAYLOAD_CERT:
+		return ("CERT");
+	case IKEV2_PAYLOAD_CERTREQ:
+		return ("CERTREQ");
+	case IKEV2_PAYLOAD_AUTH:
+		return ("AUTH");
+	case IKEV2_PAYLOAD_NONCE:
+		return ("No");
+	case IKEV2_PAYLOAD_NOTIFY:
+		return ("N");
+	case IKEV2_PAYLOAD_DELETE:
+		return ("D");
+	case IKEV2_PAYLOAD_VENDOR:
+		return ("V");
+	case IKEV2_PAYLOAD_TSi:
+		return ("TSi");
+	case IKEV2_PAYLOAD_TSr:
+		return ("TSr");
+	case IKEV2_PAYLOAD_SK:
+		return ("SK");
+	case IKEV2_PAYLOAD_CP:
+		return ("CP");
+	case IKEV2_PAYLOAD_EAP:
+		return ("EAP");
+	case IKEV2_PAYLOAD_GSPM:
+		return ("GSPM");
+	case IKEV2_PAYLOAD_IDg:
+		return ("IDg");
+	case IKEV2_PAYLOAD_GSA:
+		return ("GSA");
+	case IKEV2_PAYLOAD_KD:
+		return ("KD");
+	case IKEV2_PAYLOAD_SKF:
+		return ("SKF");
+	case IKEV2_PAYLOAD_PS:
+		return ("PS");
+	}
+	return ("UNKNOWN");
+}
+const char *
+ikev2_spi_str(ikev2_spi_proto_t id)
+{
+	switch (id) {
+	case IKEV2_PROTO_NONE:
+		return ("NONE");
+	case IKEV2_PROTO_IKE:
+		return ("IKE");
+	case IKEV2_PROTO_AH:
+		return ("AH");
+	case IKEV2_PROTO_ESP:
+		return ("ESP");
+	case IKEV2_PROTO_FC_ESP_HEADER:
+		return ("FC_ESP_HEADER");
+	case IKEV2_PROTO_FC_CT_AUTH:
+		return ("FC_CT_AUTH");
+	}
+	return ("UNKNOWN");
+}
+
+const char *
+ikev2_xf_type_str(ikev2_xf_type_t id)
+{
+	switch (id) {
+	case IKEV2_XF_ENCR:
+		return ("ENCR");
+	case IKEV2_XF_PRF:
+		return ("PRF");
+	case IKEV2_XF_AUTH:
+		return ("AUTH");
+	case IKEV2_XF_DH:
+		return ("DH");
+	case IKEV2_XF_ESN:
+		return ("ESN");
+	}
+	return ("UNKNOWN");
+}
+
+const char *
+ikev2_xf_encr_str(ikev2_xf_encr_t id)
+{
+	switch (id) {
+	STR(IKEV2_ENCR_NONE);
+	STR(IKEV2_ENCR_DES_IV64);
+	STR(IKEV2_ENCR_DES);
+	STR(IKEV2_ENCR_3DES);
+	STR(IKEV2_ENCR_RC5);
+	STR(IKEV2_ENCR_IDEA);
+	STR(IKEV2_ENCR_CAST);
+	STR(IKEV2_ENCR_BLOWFISH);
+	STR(IKEV2_ENCR_3IDEA);
+	STR(IKEV2_ENCR_DES_IV32);
+	STR(IKEV2_ENCR_RC4);
+	STR(IKEV2_ENCR_NULL);
+	STR(IKEV2_ENCR_AES_CBC);
+	STR(IKEV2_ENCR_AES_CTR);
+	STR(IKEV2_ENCR_AES_CCM_8);
+	STR(IKEV2_ENCR_AES_CCM_12);
+	STR(IKEV2_ENCR_AES_CCM_16);
+	STR(IKEV2_ENCR_AES_GCM_8);
+	STR(IKEV2_ENCR_AES_GCM_12);
+	STR(IKEV2_ENCR_AES_GCM_16);
+	STR(IKEV2_ENCR_NULL_AES_GMAC);
+	STR(IKEV2_ENCR_XTS_AES);
+	STR(IKEV2_ENCR_CAMELLIA_CBC);
+	STR(IKEV2_ENCR_CAMELLIA_CTR);
+	STR(IKEV2_ENCR_CAMELLIA_CCM_8);
+	STR(IKEV2_ENCR_CAMELLIA_CCM_12);
+	STR(IKEV2_ENCR_CAMELLIA_CCM_16);
+	}
+	return ("UNKNOWN");
+}
+
+const char *
+ikev2_xf_auth_str(ikev2_xf_auth_t id)
+{
+	switch (id) {
+	STR(IKEV2_XF_AUTH_NONE);
+	STR(IKEV2_XF_AUTH_HMAC_MD5_96);
+	STR(IKEV2_XF_AUTH_HMAC_SHA1_96);
+	STR(IKEV2_XF_AUTH_DES_MAC);
+	STR(IKEV2_XF_AUTH_KPDK_MD5);
+	STR(IKEV2_XF_AUTH_AES_XCBC_96);
+	STR(IKEV2_XF_AUTH_HMAC_MD5_128);
+	STR(IKEV2_XF_AUTH_HMAC_SHA1_160);
+	STR(IKEV2_XF_AUTH_AES_CMAC_96);
+	STR(IKEV2_XF_AUTH_AES_128_GMAC);
+	STR(IKEV2_XF_AUTH_AES_192_GMAC);
+	STR(IKEV2_XF_AUTH_AES_256_GMAC);
+	STR(IKEV2_XF_AUTH_HMAC_SHA2_256_128);
+	STR(IKEV2_XF_AUTH_HMAC_SHA2_384_192);
+	STR(IKEV2_XF_AUTH_HMAC_SHA2_512_256);
+	}
+	return ("UNKNOWN");
+}
+
+const char *
+ikev2_auth_type_str(ikev2_auth_type_t id)
+{
+	switch (id) {
+	STR(IKEV2_AUTH_NONE);
+	STR(IKEV2_AUTH_RSA_SIG);
+	STR(IKEV2_AUTH_SHARED_KEY_MIC);
+	STR(IKEV2_AUTH_DSS_SIG);
+	STR(IKEV2_AUTH_ECDSA_256);
+	STR(IKEV2_AUTH_ECDSA_384);
+	STR(IKEV2_AUTH_ECDSA_512);
+	STR(IKEV2_AUTH_GSPM);
+	}
+	return ("UNKNOWN");
+}
+
+const char *
+ikev2_dh_str(ikev2_dh_t id)
+{
+	switch (id) {
+	STR(IKEV2_DH_NONE);
+	STR(IKEV2_DH_MODP_768);
+	STR(IKEV2_DH_MODP_1024);
+	STR(IKEV2_DH_EC2N_155);
+	STR(IKEV2_DH_EC2N_185);
+	STR(IKEV2_DH_MODP_1536);
+	STR(IKEV2_DH_MODP_2048);
+	STR(IKEV2_DH_MODP_3072);
+	STR(IKEV2_DH_MODP_4096);
+	STR(IKEV2_DH_MODP_6144);
+	STR(IKEV2_DH_MODP_8192);
+	STR(IKEV2_DH_ECP_256);
+	STR(IKEV2_DH_ECP_384);
+	STR(IKEV2_DH_ECP_521);
+	STR(IKEV2_DH_MODP_1024_160);
+	STR(IKEV2_DH_MODP_2048_224);
+	STR(IKEV2_DH_MODP_2048_256);
+	STR(IKEV2_DH_ECP_192);
+	STR(IKEV2_DH_ECP_224);
+	STR(IKEV2_DH_BRAINPOOL_P224R1);
+	STR(IKEV2_DH_BRAINPOOL_P256R1);
+	STR(IKEV2_DH_BRAINPOOL_P384R1);
+	STR(IKEV2_DH_BRAINPOOL_P512R1);
+	}
+	return ("UNKNOWN");
+}
+
+const char *
+ikev2_prf_str(ikev2_prf_t id)
+{
+	switch (id) {
+	STR(IKEV2_PRF_HMAC_MD5);
+	STR(IKEV2_PRF_HMAC_SHA1);
+	STR(IKEV2_PRF_HMAC_TIGER);
+	STR(IKEV2_PRF_AES128_XCBC);
+	STR(IKEV2_PRF_HMAC_SHA2_256);
+	STR(IKEV2_PRF_HMAC_SHA2_384);
+	STR(IKEV2_PRF_HMAC_SHA2_512);
+	STR(IKEV2_PRF_AES128_CMAC);
+	}
+	return ("UNKNOWN");
+}
+const char *
+ikev2_notify_str(ikev2_notify_type_t id)
+{
+	switch (id) {
+	case IKEV2_N_UNSUPPORTED_CRITICAL_PAYLOAD:
+		return ("UNSUPPORTED_CRITICAL_PAYLOAD");
+	case IKEV2_N_INVALID_IKE_SPI:
+		return ("INVALID_IKE_SPI");
+	case IKEV2_N_INVALID_MAJOR_VERSION:
+		return ("INVALID_MAJOR_VERSION");
+	case IKEV2_N_INVALID_SYNTAX:
+		return ("INVALID_SYNTAX");
+	case IKEV2_N_INVALID_MESSAGE_ID:
+		return ("INVALID_MESSAGE_ID");
+	case IKEV2_N_INVALID_SPI:
+		return ("INVALID_SPI");
+	case IKEV2_N_NO_PROPOSAL_CHOSEN:
+		return ("NO_PROPOSAL_CHOSEN");
+	case IKEV2_N_INVALID_KE_PAYLOAD:
+		return ("INVALID_KE_PAYLOAD");
+	case IKEV2_N_AUTHENTICATION_FAILED:
+		return ("AUTHENTICATION_FAILED");
+	case IKEV2_N_SINGLE_PAIR_REQUIRED:
+		return ("SINGLE_PAIR_REQUIRED");
+	case IKEV2_N_NO_ADDITIONAL_SAS:
+		return ("NO_ADDITIONAL_SAS");
+	case IKEV2_N_INTERNAL_ADDRESS_FAILURE:
+		return ("INTERNAL_ADDRESS_FAILURE");
+	case IKEV2_N_FAILED_CP_REQUIRED:
+		return ("FAILED_CP_REQUIRED");
+	case IKEV2_N_TS_UNACCEPTABLE:
+		return ("TS_UNACCEPTABLE");
+	case IKEV2_N_INVALID_SELECTORS:
+		return ("INVALID_SELECTORS");
+	case IKEV2_N_UNACCEPTABLE_ADDRESSES:
+		return ("UNACCEPTABLE_ADDRESSES");
+	case IKEV2_N_UNEXPECTED_NAT_DETECTED:
+		return ("UNEXPECTED_NAT_DETECTED");
+	case IKEV2_N_USE_ASSIGNED_HoA:
+		return ("USE_ASSIGNED_HoA");
+	case IKEV2_N_TEMPORARY_FAILURE:
+		return ("TEMPORARY_FAILURE");
+	case IKEV2_N_CHILD_SA_NOT_FOUND:
+		return ("CHILD_SA_NOT_FOUND");
+	case IKEV2_N_INITIAL_CONTACT:
+		return ("INITIAL_CONTACT");
+	case IKEV2_N_SET_WINDOW_SIZE:
+		return ("SET_WINDOW_SIZE");
+	case IKEV2_N_ADDITIONAL_TS_POSSIBLE:
+		return ("ADDITIONAL_TS_POSSIBLE");
+	case IKEV2_N_IPCOMP_SUPPORTED:
+		return ("IPCOMP_SUPPORTED");
+	case IKEV2_N_NAT_DETECTION_SOURCE_IP:
+		return ("NAT_DETECTION_SOURCE_IP");
+	case IKEV2_N_NAT_DETECTION_DESTINATION_IP:
+		return ("NAT_DETECTION_DESTINATION_IP");
+	case IKEV2_N_COOKIE:
+		return ("COOKIE");
+	case IKEV2_N_USE_TRANSPORT_MODE:
+		return ("USE_TRANSPORT_MODE");
+	case IKEV2_N_HTTP_CERT_LOOKUP_SUPPORTED:
+		return ("HTTP_CERT_LOOKUP_SUPPORTED");
+	case IKEV2_N_REKEY_SA:
+		return ("REKEY_SA");
+	case IKEV2_N_ESP_TFC_PADDING_NOT_SUPPORTED:
+		return ("ESP_TFC_PADDING_NOT_SUPPORTED");
+	case IKEV2_N_NON_FIRST_FRAGMENTS_ALSO:
+		return ("NON_FIRST_FRAGMENTS_ALSO");
+	case IKEV2_N_MOBIKE_SUPPORTED:
+		return ("MOBIKE_SUPPORTED");
+	case IKEV2_N_ADDITIONAL_IP4_ADDRESS:
+		return ("ADDITIONAL_IP4_ADDRESS");
+	case IKEV2_N_ADDITIONAL_IP6_ADDRESS:
+		return ("ADDITIONAL_IP6_ADDRESS");
+	case IKEV2_N_NO_ADDITIONAL_ADDRESSES:
+		return ("NO_ADDITIONAL_ADDRESSES");
+	case IKEV2_N_UPDATE_SA_ADDRESSES:
+		return ("UPDATE_SA_ADDRESSES");
+	case IKEV2_N_COOKIE2:
+		return ("COOKIE2");
+	case IKEV2_N_NO_NATS_ALLOWED:
+		return ("NO_NATS_ALLOWED");
+	case IKEV2_N_AUTH_LIFETIME:
+		return ("AUTH_LIFETIME");
+	case IKEV2_N_MULTIPLE_AUTH_SUPPORTED:
+		return ("MULTIPLE_AUTH_SUPPORTED");
+	case IKEV2_N_ANOTHER_AUTH_FOLLOWS:
+		return ("ANOTHER_AUTH_FOLLOWS");
+	case IKEV2_N_REDIRECT_SUPPORTED:
+		return ("REDIRECT_SUPPORTED");
+	case IKEV2_N_REDIRECT:
+		return ("REDIRECT");
+	case IKEV2_N_REDIRECTED_FROM:
+		return ("REDIRECTED_FROM");
+	case IKEV2_N_TICKET_LT_OPAQUE:
+		return ("TICKET_LT_OPAQUE");
+	case IKEV2_N_TICKET_REQUEST:
+		return ("TICKET_REQUEST");
+	case IKEV2_N_TICKET_ACK:
+		return ("TICKET_ACK");
+	case IKEV2_N_TICKET_NACK:
+		return ("TICKET_NACK");
+	case IKEV2_N_TICKET_OPAQUE:
+		return ("TICKET_OPAQUE");
+	case IKEV2_N_LINK_ID:
+		return ("LINK_ID");
+	case IKEV2_N_USE_WESP_MODE:
+		return ("USE_WESP_MODE");
+	case IKEV2_N_ROHC_SUPPORTED:
+		return ("ROHC_SUPPORTED");
+	case IKEV2_N_EAP_ONLY_AUTHENTICATION:
+		return ("EAP_ONLY_AUTHENTICATION");
+	case IKEV2_N_CHILDLESS_IKEV2_SUPPORTED:
+		return ("CHILDLESS_IKEV2_SUPPORTED");
+	case IKEV2_N_QUICK_CRASH_DETECTION:
+		return ("QUICK_CRASH_DETECTION");
+	case IKEV2_N_IKEV2_MESSAGE_ID_SYNC_SUPPORTED:
+		return ("IKEV2_MESSAGE_ID_SYNC_SUPPORTED");
+	case IKEV2_N_IPSEC_REPLAY_CTR_SYNC_SUPPORTED:
+		return ("IPSEC_REPLAY_CTR_SYNC_SUPPORTED");
+	case IKEV2_N_IKEV2_MESSAGE_ID_SYNC:
+		return ("IKEV2_MESSAGE_ID_SYNC");
+	case IKEV2_N_IPSEC_REPLAY_CTR_SYNC:
+		return ("IPSEC_REPLAY_CTR_SYNC");
+	case IKEV2_N_SECURE_PASSWORD_METHODS:
+		return ("SECURE_PASSWORD_METHODS");
+	case IKEV2_N_PSK_PERSIST:
+		return ("PSK_PERSIST");
+	case IKEV2_N_PSK_CONFIRM:
+		return ("PSK_CONFIRM");
+	case IKEV2_N_ERX_SUPPORTED:
+		return ("ERX_SUPPORTED");
+	case IKEV2_N_IFOM_CAPABILITY:
+		return ("IFOM_CAPABILITY");
+	}
+	return ("UNKNOWN");
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.h
new file mode 100644
index 0000000000..1d079c7934
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_enum.h
@@ -0,0 +1,41 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#ifndef _IKEV2_ENUM_H
+#define	_IKEV2_ENUM_H
+
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+const char *ikev2_exch_str(ikev2_exch_t);
+const char *ikev2_pay_str(ikev2_pay_type_t);
+const char *ikev2_pay_short_str(ikev2_pay_type_t);
+const char *ikev2_spi_str(ikev2_spi_proto_t);
+const char *ikev2_xf_type_str(ikev2_xf_type_t);
+const char *ikev2_xf_encr_str(ikev2_xf_encr_t);
+const char *ikev2_xf_auth_str(ikev2_xf_auth_t);
+const char *ikev2_auth_type_str(ikev2_auth_type_t);
+const char *ikev2_dh_str(ikev2_dh_t);
+const char *ikev2_notify_str(ikev2_notify_type_t);
+const char *ikev2_prf_str(ikev2_prf_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_ENUM_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.c
new file mode 100644
index 0000000000..e200c6d2f0
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.c
@@ -0,0 +1,1437 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <stddef.h>
+#include <assert.h>
+#include <umem.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/byteorder.h>
+#include <netinet/in.h>
+#include <security/cryptoki.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <pthread.h>
+#include <sys/debug.h>
+#include <note.h>
+#include <stdarg.h>
+#include <alloca.h>
+#include "defs.h"
+#include "pkt_impl.h"
+#include "ikev2.h"
+#include "ikev2_sa.h"
+#include "ikev2_pkt.h"
+#include "ikev2_enum.h"
+#include "pkcs11.h"
+#include "random.h"
+#include "worker.h"
+
+#define	PKT_IS_V2(p) \
+	(IKE_GET_MAJORV((p)->header.version) == IKE_GET_MAJORV(IKEV2_VERSION))
+
+static boolean_t check_payloads(pkt_t *);
+
+/* Allocate an outbound IKEv2 pkt for a new exchange */
+pkt_t *
+ikev2_pkt_new_exchange(ikev2_sa_t *i2sa, ikev2_exch_t exch_type)
+{
+	pkt_t *pkt = NULL;
+	uint32_t msgid = 0;
+	uint8_t flags = 0;
+
+	VERIFY0(pthread_mutex_lock(&i2sa->lock));
+	if (exch_type != IKEV2_EXCH_IKE_SA_INIT)
+		msgid = i2sa->outmsgid++;
+
+	if (i2sa->flags & I2SA_INITIATOR)
+		flags |= IKEV2_FLAG_INITIATOR;
+
+	pkt = pkt_out_alloc(I2SA_LOCAL_SPI(i2sa),
+	    I2SA_REMOTE_SPI(i2sa),
+	    IKEV2_VERSION,
+	    exch_type, msgid, flags);
+
+	if (pkt == NULL) {
+		i2sa->outmsgid--;
+		VERIFY0(pthread_mutex_unlock(&i2sa->lock));
+		return (NULL);
+	}
+
+	VERIFY0(pthread_mutex_unlock(&i2sa->lock));
+
+	pkt->pkt_sa = i2sa;
+	I2SA_REFHOLD(i2sa);
+	return (pkt);
+}
+
+/* Allocate a ikev2_pkt_t for an IKEv2 outbound response */
+pkt_t *
+ikev2_pkt_new_response(const pkt_t *init)
+{
+	pkt_t *pkt;
+	ike_header_t *hdr = pkt_header(init);
+	uint8_t flags = IKEV2_FLAG_RESPONSE;
+
+	ASSERT(PKT_IS_V2(init));
+
+	if (init->pkt_sa->flags & I2SA_INITIATOR)
+		flags |= IKEV2_FLAG_INITIATOR;
+
+	pkt = pkt_out_alloc(hdr->initiator_spi,
+	    hdr->responder_spi,
+	    IKEV2_VERSION,
+	    hdr->exch_type,
+	    ntohl(hdr->msgid), flags);
+	if (pkt == NULL)
+		return (NULL);
+
+	pkt->pkt_sa = init->pkt_sa;
+	I2SA_REFHOLD(pkt->pkt_sa);
+	return (pkt);
+}
+
+/* Allocate a ikev2_pkt_t for an inbound datagram in raw */
+pkt_t *
+ikev2_pkt_new_inbound(uint8_t *restrict buf, size_t buflen,
+    bunyan_logger_t *restrict l)
+{
+	const ike_header_t	*hdr = NULL;
+	pkt_t			*pkt = NULL;
+	size_t			*counts = NULL;
+	size_t			i = 0;
+	boolean_t		keep = B_TRUE;
+
+	(void) bunyan_trace(l, "Creating new inbound IKEV2 packet",
+	    BUNYAN_T_END);
+
+	ASSERT(IS_P2ALIGNED(buf, sizeof (uint64_t)));
+
+	hdr = (const ike_header_t *)buf;
+
+	ASSERT(IKE_GET_MAJORV(hdr->version) == IKE_GET_MAJORV(IKEV2_VERSION));
+
+	switch ((ikev2_exch_t)hdr->exch_type) {
+	case IKEV2_EXCH_IKE_SA_INIT:
+	case IKEV2_EXCH_IKE_AUTH:
+	case IKEV2_EXCH_CREATE_CHILD_SA:
+	case IKEV2_EXCH_INFORMATIONAL:
+		break;
+	case IKEV2_EXCH_IKE_SESSION_RESUME:
+	case IKEV2_EXCH_GSA_AUTH:
+	case IKEV2_EXCH_GSA_REGISTRATION:
+	case IKEV2_EXCH_GSA_REKEY:
+	default:
+		(void) bunyan_info(l, "Unknown/unsupported exchange type",
+		    BUNYAN_T_STRING, "exch_type",
+		    ikev2_exch_str(hdr->exch_type), BUNYAN_T_END);
+		return (NULL);
+	}
+
+	/* pkt_in_alloc() will log any errors messages */
+	if ((pkt = pkt_in_alloc(buf, buflen, l)) == NULL)
+		return (NULL);
+
+	if (!check_payloads(pkt)) {
+		ikev2_pkt_free(pkt);
+		return (NULL);
+	}
+
+	return (pkt);
+}
+
+/*
+ * Slightly subtle point about the *_walk_* functions - they return B_FALSE
+ * on an error during the walk (mostly if payload lengths don't agree). The
+ * callback functions however return B_FALSE to terminate the walk early or
+ * B_TRUE to continue the walk.  Any error state that needs to propagate up
+ * from the walker callbacks needs to be sent through the cookie parameter
+ */
+boolean_t
+ikev2_walk_proposals(uint8_t *restrict start, size_t len,
+    ikev2_prop_cb_t cb, void *restrict cookie,
+    bunyan_logger_t *restrict l, boolean_t quiet)
+{
+	uint8_t *ptr = start, *end = start + len;
+	while (ptr < end) {
+		ikev2_sa_proposal_t prop = { 0 };
+		uint64_t spi = 0;
+		size_t datalen = 0;
+
+		if (ptr + sizeof (prop) > end) {
+			if (!quiet) {
+				(void) bunyan_error(l,
+				    "Proposal length mismatch",
+				    BUNYAN_T_END);
+			}
+			return (B_FALSE);
+		}
+
+		(void) memcpy(&prop, ptr, sizeof (prop));
+		prop.proto_length = ntohs(prop.proto_length);
+
+		if (ptr + prop.proto_length > end) {
+			if (!quiet) {
+				(void) bunyan_error(l,
+				    "Proposal overruns SA payload",
+				    BUNYAN_T_UINT32, "propnum",
+				    (uint32_t)prop.proto_proposalnr,
+				    BUNYAN_T_UINT32, "proplen",
+				    (uint32_t)prop.proto_length, BUNYAN_T_END);
+			}
+			return (B_FALSE);
+		}
+
+		if (sizeof (prop) + prop.proto_spisize > prop.proto_length) {
+			if (!quiet) {
+				(void) bunyan_error(l,
+				    "SPI length overruns proposal length",
+				    BUNYAN_T_UINT32, "proplen",
+				    (uint32_t)prop.proto_length,
+				    BUNYAN_T_UINT32, "spisize",
+				    (uint32_t)prop.proto_spisize,
+				    BUNYAN_T_END);
+			}
+			return (B_FALSE);
+		}
+
+		if (ptr + prop.proto_length == end) {
+			if (prop.proto_more != IKEV2_PROP_LAST) {
+				if (!quiet) {
+					(void) bunyan_error(l,
+					    "Last proposal does not have "
+					    "IKEV2_PROP_LAST set",
+					    BUNYAN_T_END);
+				}
+				return (B_FALSE);
+			}
+		} else {
+			if (prop.proto_more != IKEV2_PROP_MORE) {
+				if (!quiet) {
+					(void) bunyan_error(l,
+					    "Non-last proposal does not "
+					    "have IKEV2_PROP_MORE set",
+					    BUNYAN_T_END);
+				}
+				return (B_FALSE);
+			}
+		}
+
+		ptr += sizeof (prop);
+
+		if (!pkt_get_spi(&ptr, prop.proto_spisize, &spi)) {
+			if (!quiet) {
+				(void) bunyan_error(l,
+				    "Unsupported SPI length",
+				    BUNYAN_T_UINT32, "spisize",
+				    (uint32_t)prop.proto_spisize,
+				    BUNYAN_T_END);
+			}
+			return (B_FALSE);
+		}
+
+		datalen = prop.proto_length - sizeof (prop) -
+		    prop.proto_spisize;
+
+		if (cb != NULL && !cb(&prop, spi, ptr, datalen, cookie))
+			return (B_TRUE);
+
+		ptr += datalen;
+	}
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_walk_xfs(uint8_t *restrict start, size_t len, ikev2_xf_cb_t cb,
+    void *restrict cookie, bunyan_logger_t *restrict l)
+{
+	uint8_t *ptr = start, *end = start + len;
+
+	while (ptr < end) {
+		ikev2_transform_t xf = { 0 };
+		uint8_t *attrp = NULL;
+		size_t attrlen = 0;
+
+		if (ptr + sizeof (xf) > end) {
+			bunyan_error(l, "Transform length mismatch",
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		(void) memcpy(&xf, ptr, sizeof (xf));
+		xf.xf_length = ntohs(xf.xf_length);
+		xf.xf_id = ntohs(xf.xf_id);
+
+		if (ptr + xf.xf_length > end) {
+			bunyan_error(l, "Transform overruns SA payload",
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		if (ptr + xf.xf_length == end) {
+			if (xf.xf_more != IKEV2_XF_LAST) {
+				bunyan_error(l, "Last transform does not have "
+				    "IKEV2_XF_LAST set", BUNYAN_T_END);
+				return (B_FALSE);
+			}
+		} else {
+			if (xf.xf_more != IKEV2_XF_MORE) {
+				bunyan_error(l, "Non-last transform does not "
+				    "have IKEV2_XF_MORE set", BUNYAN_T_END);
+				return (B_FALSE);
+			}
+		}
+
+		if (xf.xf_length > sizeof (xf)) {
+			attrp = ptr + sizeof (xf);
+			attrlen = xf.xf_length - sizeof (xf);
+		}
+
+		if (cb != NULL && !cb(&xf, attrp, attrlen, cookie))
+			return (B_TRUE);
+
+		ptr += xf.xf_length;
+	}
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_walk_xfattrs(uint8_t *restrict start, size_t len, ikev2_xfattr_cb_t cb,
+    void *restrict cookie, bunyan_logger_t *restrict l)
+{
+	uint8_t *ptr = start, *end = start + len;
+
+	while (ptr < end) {
+		size_t amt = 0;
+		ikev2_attribute_t attr = { 0 };
+
+		if (ptr + sizeof (attr) > end) {
+			bunyan_error(l, "Attribute length overruns end of "
+			    "transform", BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		(void) memcpy(&attr, ptr, sizeof (attr));
+		attr.attr_type = ntohs(attr.attr_type);
+		attr.attr_length = ntohs(attr.attr_length);
+
+		if (attr.attr_type & IKEV2_ATTRAF_TV) {
+			amt = sizeof (attr);
+		} else {
+			/*
+			 * XXX: it's unclear if this length includes the
+			 * attribute length includes the header.  Need to check
+			 */
+			amt = attr.attr_length;
+		}
+
+		if (ptr + amt > end) {
+			bunyan_error(l, "Attribute value overruns end of "
+			    "transform", BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		if (cb != NULL && !cb(&attr, cookie))
+			return (B_TRUE);
+
+		ptr += amt;
+	}
+
+	return (B_TRUE);
+}
+
+void
+ikev2_pkt_free(pkt_t *pkt)
+{
+	if (pkt == NULL)
+		return;
+
+	if (pkt->pkt_sa != NULL)
+		I2SA_REFRELE(pkt->pkt_sa);
+
+	pkt_free(pkt);
+}
+
+static boolean_t
+ikev2_add_payload(pkt_t *pkt, ikev2_pay_type_t ptype, boolean_t critical,
+    size_t len)
+{
+	uint8_t *payptr;
+	uint8_t resv = 0;
+
+	ASSERT(IKEV2_VALID_PAYLOAD(ptype));
+
+	if (critical)
+		resv |= IKEV2_CRITICAL_PAYLOAD;
+
+	return (pkt_add_payload(pkt, ptype, resv, len));
+}
+
+boolean_t
+ikev2_add_sa(pkt_t *restrict pkt, pkt_sa_state_t *restrict pss)
+{
+	return (pkt_add_sa(pkt, pss));
+}
+
+boolean_t
+ikev2_add_prop(pkt_sa_state_t *pss, uint8_t propnum, ikev2_spi_proto_t proto,
+    uint64_t spi)
+{
+	size_t spilen = ikev2_spilen(proto);
+
+	if (proto == IKEV2_PROTO_IKE && spi == 0)
+		spilen = 0;
+
+	return (pkt_add_prop(pss, propnum, proto, spilen, spi));
+}
+
+boolean_t
+ikev2_add_xform(pkt_sa_state_t *pss, ikev2_xf_type_t xftype, int xfid)
+{
+	return (pkt_add_xform(pss, xftype, xfid));
+}
+
+boolean_t
+ikev2_add_xf_attr(pkt_sa_state_t *pss, ikev2_xf_attr_type_t xf_attr_type,
+    uintptr_t arg)
+{
+	switch (xf_attr_type) {
+	case IKEV2_XF_ATTR_KEYLEN:
+		ASSERT3U(arg, <, 0x10000);
+		return (pkt_add_xform_attr_tv(pss, IKEV2_XF_ATTR_KEYLEN,
+		    (uint16_t)arg));
+	}
+
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_add_xf_encr(pkt_sa_state_t *pss, ikev2_xf_encr_t encr, uint16_t minbits,
+    uint16_t maxbits)
+{
+	encr_data_t *ed = &encr_data[encr];
+	uint16_t incr = 0;
+	boolean_t ok = B_TRUE;
+
+	if (encr == IKEV2_ENCR_NONE || encr == IKEV2_ENCR_NULL) {
+		INVALID("encr");
+		/*NOTREACHED*/
+		return (B_FALSE);
+	}
+
+	if (!ENCR_KEYLEN_ALLOWED(ed)) {
+		VERIFY3U(minbits, ==, 0);
+		VERIFY3U(maxbits, ==, 0);
+		return (ikev2_add_xform(pss, IKEV2_XF_ENCR, encr));
+	}
+
+	if (minbits == 0 && maxbits == 0 && !ENCR_KEYLEN_REQ(ed))
+		return (ikev2_add_xform(pss, IKEV2_XF_ENCR, encr));
+
+	VERIFY3U(minbits, >=, ed->ed_keymin);
+	VERIFY3U(maxbits, <=, ed->ed_keymax);
+
+	if (ed->ed_keyincr == 1) {
+		/*
+		 * For encryption methods that allow arbitrary key sizes,
+		 * instead of adding a transform with every key length
+		 * between the minimum and maximum values, we just add the
+		 * minimum and maximum values.
+		 */
+		if (minbits != maxbits) {
+			ok &= ikev2_add_xform(pss, IKEV2_XF_ENCR, encr);
+			ok &= ikev2_add_xf_attr(pss, IKEV2_XF_ATTR_KEYLEN,
+			    minbits);
+		}
+		ok &= ikev2_add_xform(pss, IKEV2_XF_ENCR, encr);
+		ok &= ikev2_add_xf_attr(pss, IKEV2_XF_ATTR_KEYLEN, maxbits);
+		return (ok);
+	}
+
+	for (size_t bits = minbits; bits <= maxbits; bits += ed->ed_keyincr) {
+		ok &= ikev2_add_xform(pss, IKEV2_XF_ENCR, encr);
+		ok &= ikev2_add_xf_attr(pss, IKEV2_XF_ATTR_KEYLEN, bits);
+	}
+
+	return (ok);
+}
+
+boolean_t
+ikev2_add_ke(pkt_t *restrict pkt, ikev2_dh_t group, CK_OBJECT_HANDLE key)
+{
+	bunyan_logger_t		*l = pkt->pkt_sa->i2sa_log;
+	ikev2_ke_t		ke = { 0 };
+	CK_SESSION_HANDLE	h = p11h();
+	CK_ULONG		keylen = 0;
+	CK_ATTRIBUTE		template = {
+		.type = CKA_VALUE,
+		.pValue = NULL_PTR,
+		.ulValueLen = 0
+	};
+	CK_RV			rc = CKR_OK;
+
+	rc = C_GetAttributeValue(h, key, &template, 1);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, l, "C_GetAttributeValue", rc);
+		return (B_FALSE);
+	}
+	keylen = template.ulValueLen;
+
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_KE, B_FALSE,
+	    sizeof (ke) + keylen)) {
+		bunyan_error(l, "Not enough space in packet for DH pubkey",
+		    BUNYAN_T_UINT64, "keylen", (uint64_t)keylen,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	ke.kex_dhgroup = htons((uint16_t)group);
+	PKT_APPEND_STRUCT(pkt, ke);
+
+	template.type = CKA_VALUE;
+	template.pValue = pkt->pkt_ptr;
+	template.ulValueLen = pkt_write_left(pkt);
+
+	rc = C_GetAttributeValue(h, key, &template, 1);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, l, "C_GetAttributeValue", rc);
+		return (B_FALSE);
+	}
+	pkt->pkt_ptr += keylen;
+
+	return (B_TRUE);
+}
+
+static boolean_t
+ikev2_add_id_common(pkt_t *restrict pkt, boolean_t id_i, ikev2_id_type_t idtype,
+    va_list ap)
+{
+	ikev2_id_t		id = { 0 };
+	ikev2_pay_type_t 	paytype =
+	    (id_i) ? IKEV2_PAYLOAD_IDi : IKEV2_PAYLOAD_IDr;
+	const uint8_t		*data;
+	size_t			len = 0;
+
+	data = va_arg(ap, const uint8_t *);
+
+	switch (idtype) {
+	case IKEV2_ID_IPV4_ADDR:
+		len = sizeof (in_addr_t);
+		break;
+	case IKEV2_ID_FQDN:
+	case IKEV2_ID_RFC822_ADDR:
+		len = strlen((const char *)data);
+		break;
+	case IKEV2_ID_IPV6_ADDR:
+		len = sizeof (in6_addr_t);
+		break;
+	case IKEV2_ID_DER_ASN1_DN:
+	case IKEV2_ID_DER_ASN1_GN:
+	case IKEV2_ID_KEY_ID:
+		len = va_arg(ap, size_t);
+		break;
+	case IKEV2_ID_FC_NAME:
+		INVALID("idtype");
+		break;
+	}
+
+	if (!ikev2_add_payload(pkt, paytype, B_FALSE, sizeof (id) + len))
+		return (B_FALSE);	/* XXX: log? */
+
+	id.id_type = (uint8_t)idtype;
+	PKT_APPEND_STRUCT(pkt, id);
+	PKT_APPEND_DATA(pkt, data, len);
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_id_i(pkt_t *restrict pkt, ikev2_id_type_t idtype, ...)
+{
+	va_list ap;
+	boolean_t ret;
+
+	va_start(ap, idtype);
+	ret = ikev2_add_id_common(pkt, B_TRUE, idtype, ap);
+	va_end(ap);
+	return (ret);
+}
+
+boolean_t
+ikev2_add_id_r(pkt_t *restrict pkt, ikev2_id_type_t idtype, ...)
+{
+	va_list ap;
+	boolean_t ret;
+
+	va_start(ap, idtype);
+	ret = ikev2_add_id_common(pkt, B_FALSE, idtype, ap);
+	va_end(ap);
+	return (ret);
+}
+
+boolean_t
+ikev2_add_cert(pkt_t *restrict pkt, ikev2_cert_t cert_type, const uint8_t *cert,
+    size_t len)
+{
+	return (pkt_add_cert(pkt, IKEV2_PAYLOAD_CERT, cert_type, cert, len));
+}
+
+boolean_t
+ikev2_add_certreq(pkt_t *restrict pkt, ikev2_cert_t cert_type,
+    const uint8_t *cert, size_t len)
+{
+	return (pkt_add_cert(pkt, IKEV2_PAYLOAD_CERTREQ, cert_type, cert, len));
+}
+
+boolean_t
+ikev2_add_auth(pkt_t *restrict pkt, ikev2_auth_type_t auth_method,
+    const uint8_t *restrict data, size_t len)
+{
+	ikev2_auth_t auth = { 0 };
+
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_AUTH, B_FALSE,
+	    sizeof (auth) + len))
+		return (B_FALSE);
+
+	auth.auth_method = (uint8_t)auth_method;
+	PKT_APPEND_STRUCT(pkt, auth);
+	PKT_APPEND_DATA(pkt, data, len);
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_nonce(pkt_t *restrict pkt, uint8_t *restrict nonce, size_t len)
+{
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_NONCE, B_FALSE, len))
+		return (B_FALSE);
+
+	/*
+	 * We allow a NULL value to generate a new nonce of size len,
+	 * and otherwise use the existing one passed in to simplify
+	 * creating a new initiator packet for a IKE_SA_INIT exchange
+	 * when we have to add additional payloads (COOKIE, new DH group).
+	 */
+	if (nonce != NULL) {
+		PKT_APPEND_DATA(pkt, nonce, len);
+	} else {
+		random_high(pkt->pkt_ptr, len);
+		pkt->pkt_ptr += len;
+	}
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_notify(pkt_t *restrict pkt, ikev2_spi_proto_t proto, uint64_t spi,
+    ikev2_notify_type_t ntfy_type, const void *restrict data, size_t len)
+{
+	size_t spisize = ikev2_spilen(proto);
+
+	if (proto == IKEV2_PROTO_IKE && spi == 0)
+		spisize = 0;
+
+	return (pkt_add_notify(pkt, 0, proto, spisize, spi, ntfy_type, data,
+	    len));
+}
+
+static boolean_t delete_finish(pkt_t *restrict, uint8_t *restrict, uintptr_t,
+    size_t);
+
+boolean_t
+ikev2_add_delete(pkt_t *restrict pkt, ikev2_spi_proto_t proto,
+    uint64_t *restrict spis, size_t nspi)
+{
+	ikev2_delete_t del = { 0 };
+	size_t len = sizeof (del);
+
+	VERIFY(proto != IKEV2_PROTO_IKE || nspi == 0);
+
+	del.del_protoid = (uint8_t)proto;
+	del.del_spisize = (proto == IKEV2_PROTO_IKE) ? 0 : ikev2_spilen(proto);
+
+	len += del.del_spisize * nspi;
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_DELETE, B_FALSE, len))
+		return (B_FALSE);
+
+	PKT_APPEND_STRUCT(pkt, del);
+	for (size_t i = 0; i < nspi; i++)
+		VERIFY(pkt_add_spi(pkt, del.del_spisize, spis[i]));
+
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_vendor(pkt_t *restrict pkt, const void *restrict vid, size_t len)
+{
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_VENDOR, B_FALSE, len))
+		return (B_FALSE);
+	PKT_APPEND_DATA(pkt, vid, len);
+	return (B_TRUE);
+}
+
+/*
+ * This will need to be adjusted once we have a better idea how we will
+ * obtain the traffic selectors to better tailor the interface for adding
+ * them to the IKE datagram.  For now, we'll just leave them out.
+ */
+#if 0
+static boolean_t add_ts_common(pkt_t *, boolean_t);
+
+boolean_t
+ikev2_add_ts_i(pkt_t *restrict pkt)
+{
+	return (add_ts_common(pkt, B_TRUE));
+}
+
+boolean_t
+ikev2_add_ts_r(pkt_t *restrict pkt)
+{
+	return (add_ts_common(pkt, B_FALSE));
+}
+
+static boolean_t ts_finish(pkt_t *restrict, uint8_t *restrict, uintptr_t,
+    size_t);
+
+static boolean_t
+add_ts_common(pkt_t *pkt, boolean_t ts_i)
+{
+	ikev2_ts_t ts = { 0 };
+
+	if (pkt_write_left(pkt) < sizeof (ikev2_payload_t) +
+	    sizeof (ikev2_ts_t))
+		return (B_FALSE);
+
+	ikev2_add_payload(pkt, (ts_i) ? IKEV2_PAYLOAD_TSi : IKEV2_PAYLOAD_TSr,
+	    B_FALSE);
+	pkt_stack_push(pkt, PSI_TSP, ts_finish, 0);
+	PKT_APPEND_STRUCT(pkt, ts);
+	return (B_TRUE);
+}
+
+static boolean_t
+ts_finish(pkt_t *restrict pkt, uint8_t *restrict buf, uintptr_t swaparg,
+    size_t numts)
+{
+	ikev2_tsp_t	ts = { 0 };
+
+	ASSERT3U(numts, <, 0x100);
+
+	(void) memcpy(&ts, buf, sizeof (ts));
+	ts.tsp_count = (uint8_t)numts;
+	(void) memcpy(buf, &ts, sizeof (ts));
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_ts(pkt_t *restrict pkt, ikev2_ts_type_t type, uint8_t ip_proto,
+    const sockaddr_u_t *restrict start, const sockaddr_u_t *restrict end)
+{
+	ikev2_ts_t	ts = { 0 };
+	void		*startptr = NULL, *endptr = NULL;
+	size_t		len = 0;
+
+	ASSERT3U(ip_proto, <, 0x100);
+	ASSERT3U(start->sau_ss->ss_family, ==, end->sau_ss->ss_family);
+
+	pkt_stack_push(pkt, PSI_TS, 0, NULL);
+
+	ts.ts_length = sizeof (ts);
+	ts.ts_type = (uint8_t)type;
+
+	switch (type) {
+	case IKEV2_TS_IPV4_ADDR_RANGE:
+		ASSERT3U(start->sau_ss->ss_family, ==, AF_INET);
+		ASSERT3U(end->sau_ss->ss_family, ==, AF_INET);
+		ts.ts_startport = start->sau_sin->sin_port;
+		ts.ts_endport = end->sau_sin->sin_port;
+		startptr = &start->sau_sin->sin_addr;
+		endptr = &end->sau_sin->sin_addr;
+		len = sizeof (in_addr_t);
+		ts.ts_length += 2 * len;
+		break;
+	case IKEV2_TS_IPV6_ADDR_RANGE:
+		ASSERT3U(start->sau_ss->ss_family, ==, AF_INET6);
+		ASSERT3U(end->sau_ss->ss_family, ==, AF_INET6);
+		ts.ts_startport = start->sau_sin6->sin6_port;
+		ts.ts_endport = end->sau_sin6->sin6_port;
+		startptr = &start->sau_sin6->sin6_addr;
+		endptr = &end->sau_sin6->sin6_addr;
+		len = sizeof (in6_addr_t);
+		ts.ts_length += 2 * len;
+		break;
+	case IKEV2_TS_FC_ADDR_RANGE:
+		INVALID("type");
+	}
+
+	if (pkt_write_left(pkt) < ts.ts_length)
+		return (B_FALSE);
+
+	ts.ts_protoid = ip_proto;
+	ts.ts_length = htons(ts.ts_length);
+	PKT_APPEND_STRUCT(pkt, ts);
+	PKT_APPEND_DATA(pkt, startptr, len);
+	PKT_APPEND_DATA(pkt, endptr, len);
+	return (B_TRUE);
+}
+#else
+/* Placeholders */
+boolean_t
+ikev2_add_ts_i(pkt_t *restrict pkt)
+{
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_add_ts_r(pkt_t *restrict pkt)
+{
+	return (B_FALSE);
+}
+boolean_t
+ikev2_add_ts(pkt_t *restrict pkt, ikev2_ts_type_t type, uint8_t ip_proto,
+    const sockaddr_u_t *restrict start, const sockaddr_u_t *restrict end)
+{
+	return (B_FALSE);
+}
+#endif
+
+static boolean_t add_iv(pkt_t *restrict pkt);
+
+boolean_t
+ikev2_add_sk(pkt_t *restrict pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	ikev2_payload_t *payp = (ikev2_payload_t *)pkt->pkt_ptr;
+
+	if (!ikev2_add_payload(pkt, IKEV2_PAYLOAD_SK, B_FALSE, 0))
+		return (B_FALSE);
+
+	return (add_iv(pkt));
+}
+
+static boolean_t
+add_iv(pkt_t *restrict pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	size_t len = encr_data[sa->encr].ed_blocklen;
+	encr_modes_t mode = encr_data[sa->encr].ed_mode;
+
+	if (pkt_write_left(pkt) < len)
+		return (B_FALSE);
+
+	switch (mode) {
+	case MODE_CCM:
+	case MODE_GCM: {
+		uint32_t msgid = ntohl(pkt_header(pkt)->msgid);
+		/*
+		 * For these modes, it's sufficient that the IV + key
+		 * is unique.  The packet message id satisifies these
+		 * requirements.
+		 */
+		put32(pkt, msgid);
+		pkt->pkt_ptr += (len - sizeof (msgid));
+		return (B_TRUE);
+	}
+	case MODE_CTR:
+		/* TODO */
+		return (B_FALSE);
+	case MODE_CBC:
+		/* Done below */
+		break;
+	case MODE_NONE:
+		INVALID("mode");
+		break;
+	}
+
+	/*
+	 * NIST 800-38A, Appendix C indicates that encrypting a counter
+	 * should be acceptable to produce a unique, unpredictable IV.
+	 */
+	CK_SESSION_HANDLE h = p11h();
+	CK_MECHANISM mech;
+	CK_OBJECT_HANDLE key;
+	CK_ULONG blocklen = 0;
+	CK_RV rc = CKR_OK;
+	uint32_t msgid = ntohl(pkt_header(pkt)->msgid);
+
+	if (pkt->pkt_sa->flags & I2SA_INITIATOR)
+		key = sa->sk_ei;
+	else
+		key = sa->sk_er;
+
+	switch (pkt->pkt_sa->encr) {
+	case IKEV2_ENCR_AES_CBC:
+		mech.mechanism = CKM_AES_ECB;
+		mech.pParameter = NULL_PTR;
+		mech.ulParameterLen = 0;
+		blocklen = 16;
+		break;
+	case IKEV2_ENCR_CAMELLIA_CBC:
+		mech.mechanism = CKM_CAMELLIA_ECB;
+		mech.pParameter = NULL_PTR;
+		mech.ulParameterLen = 0;
+		blocklen = 16;
+		break;
+	default:
+		INVALID("encr");
+		/*NOTREACHED*/
+		return (B_FALSE);
+	}
+	CK_BYTE buf[blocklen];
+
+	(void) memset(buf, 0, blocklen);
+	(void) memcpy(buf, &msgid, sizeof (msgid));
+
+	rc = C_EncryptInit(h, &mech, key);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, sa->i2sa_log, "C_EncryptInit", rc);
+		return (B_FALSE);
+	}
+
+	rc = C_Encrypt(h, buf, blocklen, buf, &blocklen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, sa->i2sa_log, "C_Encrypt", rc);
+		return (B_FALSE);
+	}
+
+	(void) memcpy(pkt->pkt_ptr, buf, MIN(len, blocklen));
+	explicit_bzero(buf, blocklen);
+	pkt->pkt_ptr += MIN(len, blocklen);
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_add_config(pkt_t *pkt, ikev2_cfg_type_t cfg_type)
+{
+	/* TODO */
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_add_config_attr(pkt_t *restrict pkt,
+    ikev2_cfg_attr_type_t cfg_attr_type, const void *restrict data)
+{
+	/* TODO */
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_pkt_encryptdecrypt(pkt_t *pkt, boolean_t encrypt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	pkt_payload_t *sk = pkt_get_payload(pkt, IKEV2_PAYLOAD_SK, NULL);
+	const char *fn = NULL;
+	CK_SESSION_HANDLE h = p11h();
+	CK_MECHANISM mech;
+	CK_OBJECT_HANDLE key;
+	union {
+		CK_AES_CTR_PARAMS	aes_ctr;
+		CK_CAMELLIA_CTR_PARAMS	cam_ctr;
+		CK_GCM_PARAMS		gcm;
+		CK_CCM_PARAMS		ccm;
+	} params;
+	CK_BYTE_PTR salt = NULL, iv = NULL, data = NULL, icv = NULL;
+	CK_ULONG ivlen = encr_data[sa->encr].ed_blocklen;
+	CK_ULONG icvlen = ikev2_auth_icv_size(sa->encr, sa->auth);
+	CK_ULONG blocklen = encr_data[sa->encr].ed_blocklen;
+	CK_ULONG noncelen = ivlen + sa->saltlen;
+	CK_ULONG datalen = 0, outlen = 0;
+	CK_BYTE nonce[noncelen];
+	CK_RV rc = CKR_OK;
+	encr_modes_t mode = encr_data[sa->encr].ed_mode;
+	uint8_t padlen = 0;
+
+	if (sa->flags & I2SA_INITIATOR) {
+		key = sa->sk_ei;
+		salt = sa->salt_i;
+	} else {
+		key = sa->sk_er;
+		salt = sa->salt_r;
+	}
+
+	(void) memcpy(nonce, iv, ivlen);
+	if (sa->saltlen > 0)
+		(void) memcpy(nonce + ivlen, salt, sa->saltlen);
+
+	iv = sk->pp_ptr;
+
+	data = iv + ivlen;
+	datalen = (CK_ULONG)(pkt->pkt_ptr - data) - icvlen;
+	outlen = pkt_write_left(pkt) + icvlen;
+
+	icv = data + datalen;
+
+	if (encrypt) {
+		/* If we're creating it, it better be correct */
+		VERIFY3U(sk->pp_len, ==, ivlen + datalen + icvlen);
+	} else {
+		/* Otherwise check first */
+		if (sk->pp_len != ivlen + datalen + icvlen) {
+			bunyan_info(sa->i2sa_log,
+			    "Encrypted payload invalid length",
+			    BUNYAN_T_UINT32, "paylen", (uint32_t)sk->pp_len,
+			    BUNYAN_T_UINT32, "ivlen", (uint32_t)ivlen,
+			    BUNYAN_T_UINT32, "datalen", (uint32_t)datalen,
+			    BUNYAN_T_UINT32, "icvlen", (uint32_t)icvlen,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+	}
+
+	mech.mechanism = encr_data[sa->encr].ed_p11id;
+	switch (mode) {
+	case MODE_NONE:
+		break;
+	case MODE_CBC:
+		mech.pParameter = nonce;
+		mech.ulParameterLen = noncelen;
+		break;
+	case MODE_CTR:
+		/* TODO */
+		break;
+	case MODE_CCM:
+		params.ccm.pAAD = pkt_start(pkt);
+		params.ccm.ulAADLen = (CK_ULONG)(iv - pkt_start(pkt));
+		params.ccm.ulMACLen = icvlen;
+		params.ccm.pNonce = nonce;
+		params.ccm.ulNonceLen = noncelen;
+		mech.pParameter = &params.ccm;
+		mech.ulParameterLen = sizeof (CK_CCM_PARAMS);
+		break;
+	case MODE_GCM:
+		params.gcm.pIv = nonce;
+		params.gcm.ulIvLen = noncelen;
+		/*
+		 * There is a 'ulIvBits' field in CK_GCM_PARAMS.  This is from
+		 * the pkcs11t.h file published from OASIS.  However, it does
+		 * not appear to actually be used for anything, and looks to
+		 * be a leftover from the unpublished PKCS#11 v2.30 standard.
+		 * It is currently not set and ignored.
+		 */
+		params.gcm.pAAD = pkt_start(pkt);
+		params.gcm.ulAADLen = (CK_ULONG)(iv - params.gcm.pAAD);
+		params.gcm.ulTagBits = icvlen * 8;
+		mech.pParameter = &params.gcm;
+		mech.ulParameterLen = sizeof (CK_GCM_PARAMS);
+		break;
+	}
+
+	/*
+	 * As nice as it would be, it appears the combined mode functions
+	 * (e.g. C_SignEncrypt) both operate on the plaintext.  However
+	 * we must sign the encrypted text, so must do it in different
+	 * operations.
+	 */
+	if (encrypt) {
+		fn = "C_EncryptInit";
+		rc = C_EncryptInit(h, &mech, key);
+	} else {
+		fn = "C_DecryptInit";
+		rc = C_DecryptInit(h, &mech, key);
+	}
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, sa->i2sa_log, fn, rc);
+		return (B_FALSE);
+	}
+
+	if (encrypt) {
+		fn = "C_Encrypt";
+		rc = C_Encrypt(h, data, datalen, data, &outlen);
+	} else {
+		fn = "C_Decrypt";
+		rc = C_Decrypt(h, data, datalen, data, &outlen);
+	}
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, sa->i2sa_log, "C_Encrypt", rc,
+		    BUNYAN_T_UINT64, "outlen", (uint64_t)outlen,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	if (encrypt)
+		return (B_TRUE);
+
+	/*
+	 * As described in ikev2_pkt_done(), we choose to use PKCS#7 style
+	 * padding, however our peer can use arbitrary values for padding.
+	 * When we know we are communicating with another illumos peer, we
+	 * explicity verify the padding.  This is due to the lessons learned
+	 * from exploits from TLS, etc. that exploit lack of padding checks.
+	 */
+	if (pkt->pkt_sa->vendor == VENDOR_ILLUMOS_1) {
+		uint8_t *pad;
+
+		padlen = icv[-1];
+		pad = icv - padlen - 1;
+
+		for (size_t i = 0; i <= padlen; i++) {
+			if (pad[i] == padlen)
+				continue;
+
+			bunyan_warn(sa->i2sa_log, "Padding validation failed",
+			    BUNYAN_T_UINT32, "padlen", (uint32_t)padlen,
+			    BUNYAN_T_UINT32, "offset", (uint32_t)i,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+	}
+	datalen -= padlen + 1;
+
+	ike_payload_t *skpay = ((ike_payload_t *)sk->pp_ptr) - 1;
+
+	if (!pkt_index_payloads(pkt, data, datalen, skpay->pay_next,
+	    sa->i2sa_log))
+		return (B_FALSE);
+
+	return (B_TRUE);
+}
+
+boolean_t
+ikev2_pkt_signverify(pkt_t *pkt, boolean_t sign)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+
+	if (MODE_IS_COMBINED(encr_data[sa->encr].ed_mode))
+		return (B_TRUE);
+
+	const char *fn = NULL;
+	pkt_payload_t *sk = pkt_get_payload(pkt, IKEV2_PAYLOAD_SK, NULL);
+	CK_SESSION_HANDLE h = p11h();
+	CK_OBJECT_HANDLE key;
+	CK_MECHANISM mech = {
+		.mechanism = auth_data[sa->auth].ad_p11id,
+		.pParameter = NULL_PTR,
+		.ulParameterLen = 0
+	};
+	CK_BYTE_PTR icv;
+	CK_ULONG signlen, icvlen;
+	CK_ULONG outlen = auth_data[sa->auth].ad_outlen;
+	CK_BYTE outbuf[outlen];
+	CK_RV rc;
+
+	if (sa->flags & I2SA_INITIATOR)
+		key = sa->sk_ai;
+	else
+		key = sa->sk_ar;
+
+	icvlen = ikev2_auth_icv_size(sa->encr, sa->auth);
+	signlen = pkt_len(pkt) - icvlen;
+	icv = pkt->pkt_ptr - icvlen;
+
+	rc = C_SignInit(h, &mech, key);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, sa->i2sa_log, "C_SignInit", rc);
+		return (B_FALSE);
+	}
+
+	rc = C_Sign(h, pkt_start(pkt), signlen, outbuf, &outlen);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, sa->i2sa_log, "C_Sign", rc);
+		return (B_FALSE);
+	}
+
+	if (sign) {
+		(void) memcpy(icv, outbuf, auth_data[sa->auth].ad_icvlen);
+		return (B_TRUE);
+	}
+
+	if (memcmp(icv, outbuf, auth_data[sa->auth].ad_icvlen) == 0)
+		return (B_TRUE);
+
+	bunyan_info(sa->i2sa_log, "Payload signature validation failed",
+	    BUNYAN_T_END);
+	return (B_FALSE);
+}
+
+boolean_t
+ikev2_pkt_done(pkt_t *pkt)
+{
+	if (pkt->pkt_done)
+		return (B_TRUE);
+
+	pkt_payload_t *sk = pkt_get_payload(pkt, IKEV2_PAYLOAD_SK, NULL);
+
+	if (pkt_header(pkt)->exch_type == IKEV2_EXCH_IKE_SA_INIT) {
+		VERIFY3P(sk, ==, NULL);
+		return (pkt_done(pkt));
+	}
+
+	VERIFY3P(sk, !=, NULL);
+
+	ike_payload_t *skpay = ((ike_payload_t *)sk->pp_ptr) - 1;
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	CK_ULONG datalen = (CK_ULONG)(pkt->pkt_ptr - sk->pp_ptr);
+	CK_ULONG icvlen = ikev2_auth_icv_size(sa->encr, sa->auth);
+	CK_ULONG blocklen = encr_data[sa->encr].ed_blocklen;
+	uint16_t sklen = sizeof (ike_payload_t);
+	boolean_t ok = B_TRUE;
+	uint8_t padlen = 0;
+
+	/*
+	 * Per RFC7296 3.14, the sender can choose any value for the padding.
+	 * We elect to use PKCS#7 style padding (repeat the pad value as the
+	 * padding).  This is well studied and appears to work.
+	 */
+	if ((datalen + 1) % blocklen != 0)
+		padlen = blocklen - ((datalen + 1) % blocklen);
+
+	if (pkt_write_left(pkt) < padlen + 1 + icvlen) {
+		bunyan_info(sa->i2sa_log, "Not enough space for packet",
+		    BUNYAN_T_END);
+		goto done;
+	}
+
+	for (size_t i = 0; i <= padlen; i++)
+		pkt->pkt_ptr[i] = padlen;
+	pkt->pkt_ptr += padlen;
+
+	/*
+	 * Skip over the space for the ICV.  This is necessary so that all
+	 * the lengths (packet, payload) are updated with the final values
+	 * prior to encryption and signing.
+	 */
+	pkt->pkt_ptr += icvlen;
+
+	sklen += (uint16_t)(pkt->pkt_ptr - sk->pp_ptr);
+	BE_OUT16(&skpay->pay_length, sklen);
+
+	ok = pkt_done(pkt);
+	ok &= ikev2_pkt_encryptdecrypt(pkt, B_TRUE);
+	ok &= ikev2_pkt_signverify(pkt, B_TRUE);
+
+done:
+	return (ok);
+}
+
+static boolean_t
+check_payloads(pkt_t *pkt)
+{
+	size_t paycount[IKEV2_NUM_PAYLOADS] = { 0 };
+
+#define	PAYCOUNT(type)	paycount[(type) - IKEV2_PAYLOAD_MIN]
+
+	for (size_t i = 0; i < pkt->pkt_payload_count; i++) {
+		pkt_payload_t *idx = pkt_payload(pkt, i);
+		ike_payload_t *pay = pkt_idx_to_payload(idx);
+
+		/* All known payloads should not have the critical bit set */
+		if (pay->pay_reserved & IKEV2_CRITICAL_PAYLOAD) {
+			(void) bunyan_info(log,
+			    "Packet payload has critical bit set",
+			    BUNYAN_T_UINT32, "payload", (uint32_t)idx->pp_type,
+			    BUNYAN_T_END);
+			return (B_FALSE);
+		}
+
+		if (!IKEV2_VALID_PAYLOAD(idx->pp_type)) {
+			(void) bunyan_trace(log,
+			    "Ignoring unknown payload",
+			    BUNYAN_T_UINT32, "payload", (uint32_t)idx->pp_type,
+			    BUNYAN_T_END);
+			continue;
+		}
+
+		PAYCOUNT(idx->pp_type)++;
+	}
+
+	if (pkt_header(pkt)->exch_type != IKEV2_EXCH_IKE_SA_INIT) {
+		if (PAYCOUNT(IKEV2_PAYLOAD_SK) == 0) {
+			ikev2_pkt_log(pkt, log, BUNYAN_L_INFO,
+			    "Non IKE_SA_INIT exchange is missing SK payload");
+			return (B_FALSE);
+		}
+
+		/* XXX: Figure out way to ignore unprotected payloads */
+
+		return (B_TRUE);
+	}
+
+	if ((pkt_header(pkt)->flags & IKEV2_FLAG_RESPONSE) &&
+	    (pkt_header(pkt)->responder_spi == 0)) {
+		if (PAYCOUNT(IKEV2_PAYLOAD_SA) > 0) {
+			ikev2_pkt_log(pkt, log, BUNYAN_L_INFO,
+			    "IKE_SA_INIT error response contains SA payload");
+			return (B_FALSE);
+		}
+
+		/* XXX: Other IKE_SA_INIT error repsonse checks? */
+	}
+
+	/*
+	 * XXX: Possibly add more checks on which payloads are or aren't allowed
+	 * for IKE_SA_INIT
+	 */
+
+	return (B_TRUE);
+#undef PAYCOUNT
+}
+
+/*
+ * Create a abbreviated string listing the payload types (in order).
+ * Mostly for diagnostic purposes.
+ *
+ * Example: 'N(COOKIE), SA, KE, No'
+ */
+char *
+ikev2_pkt_desc(pkt_t *pkt)
+{
+	char *s = NULL;
+	size_t len = 0;
+	uint16_t i;
+	uint16_t j;
+
+	for (i = j = 0; i < pkt->pkt_payload_count; i++) {
+		pkt_payload_t *pay = pkt_payload(pkt, i);
+		const char *paystr =
+		    ikev2_pay_short_str((ikev2_pay_type_t)pay->pp_type);
+
+		len += strlen(paystr) + 2;
+		if (pay->pp_type == IKEV2_PAYLOAD_NOTIFY) {
+			pkt_notify_t *n = pkt_notify(pkt, j++);
+			const char *nstr =
+			    ikev2_notify_str((ikev2_notify_type_t)n->pn_type);
+
+			len += strlen(nstr) + 2;
+		}
+	}
+
+	s = calloc(1, len);
+	VERIFY3P(s, !=, len);
+
+	for (i = j = 0; i < pkt->pkt_payload_count; i++) {
+		pkt_payload_t *pay = pkt_payload(pkt, i);
+		const char *paystr =
+		    ikev2_pay_short_str((ikev2_pay_type_t)pay->pp_type);
+
+		if (i > 0)
+			(void) strlcat(s, ", ", len);
+
+		(void) strlcat(s, paystr, len);
+		if (pay->pp_type == IKEV2_PAYLOAD_NOTIFY) {
+			pkt_notify_t *n = pkt_notify(pkt, j++);
+			const char *nstr =
+			    ikev2_notify_str((ikev2_notify_type_t)n->pn_type);
+
+			/*
+			 * Notify type is 16-bits, so (XXXXX) (7 chars) is
+			 * the largest it can be (and is < than "UNKNOWN"),
+			 * so no worries about truncation.
+			 */
+			if (strcmp(nstr, "UNKNOWN") == 0) {
+				char buf[8] = { 0 };
+				(void) snprintf(buf, sizeof (buf), "(%hhu)",
+				    (uint16_t)n->pn_type);
+				(void) strlcat(s, buf, len);
+			} else {
+				(void) strlcat(s, "(", len);
+				(void) strlcat(s, nstr, len);
+				(void) strlcat(s, ")", len);
+			}
+		}
+	}
+
+	return (s);
+}
+
+static struct {
+	const char *str;
+	uint8_t val;
+} flagtbl[] = {
+	{ "RESPONSE", IKEV2_FLAG_RESPONSE },
+	{ "VERSION", IKEV2_FLAG_VERSION },
+	{ "INITIATOR", IKEV2_FLAG_INITIATOR }
+};
+
+void
+ikev2_pkt_log(pkt_t *restrict pkt, bunyan_logger_t *restrict log,
+    bunyan_level_t level, const char *msg)
+{
+	ike_header_t *hdr = pkt_header(pkt);
+	char *descstr = ikev2_pkt_desc(pkt);
+	char ispi[19];
+	char rspi[19];
+	char flag[30];
+
+	VERIFY3P(descstr, !=, NULL);
+
+	(void) snprintf(ispi, sizeof (ispi), "0x%" PRIX64,
+	    ntohll(hdr->initiator_spi));
+	(void) snprintf(rspi, sizeof (rspi), "0x%" PRIX64,
+	    ntohll(hdr->responder_spi));
+	(void) snprintf(flag, sizeof (flag), "0x%" PRIx8, hdr->flags);
+	if (hdr->flags != 0) {
+		size_t count = 0;
+
+		(void) strlcat(flag, "<", sizeof (flag));
+		for (size_t i = 0; i < ARRAY_SIZE(flagtbl); i++) {
+			if (hdr->flags & flagtbl[i].val) {
+				if (count > 0) {
+					(void) strlcat(flag, ",",
+					    sizeof (flag));
+				}
+				(void) strlcat(flag, flagtbl[i].str,
+				    sizeof (flag));
+				count++;
+			}
+		}
+		(void) strlcat(flag, ">", sizeof (flag));
+	}
+
+	getlog(level)(log, msg,
+	    BUNYAN_T_POINTER, "pkt", pkt,
+	    BUNYAN_T_STRING, "initiator_spi", ispi,
+	    BUNYAN_T_UINT64, "responder_spi", rspi,
+	    BUNYAN_T_STRING, "exch_type",
+	    ikev2_exch_str(hdr->exch_type),
+	    BUNYAN_T_UINT32, "msgid", ntohl(pkt_header(pkt)->msgid),
+	    BUNYAN_T_UINT32, "msglen", ntohl(pkt_header(pkt)->length),
+	    BUNYAN_T_STRING, "flags", flag,
+	    BUNYAN_T_UINT32, "nxmit", (uint32_t)pkt->pkt_xmit,
+	    BUNYAN_T_STRING, "payloads", descstr,
+	    BUNYAN_T_END);
+	free(descstr);
+}
+
+/* Retrieve the DH group value from a key exchange payload */
+ikev2_dh_t
+ikev2_get_dhgrp(pkt_t *pkt)
+{
+	pkt_payload_t *ke = pkt_get_payload(pkt, IKEV2_PAYLOAD_KE, NULL);
+	uint16_t val = 0;
+
+	if (ke == NULL)
+		return (IKEV2_DH_NONE);
+
+	VERIFY3U(ke->pp_len, >, sizeof (val));
+	(void) memcpy(&val, ke->pp_ptr, sizeof (val));
+	return ((ikev2_dh_t)ntohs(val));
+}
+
+size_t
+ikev2_spilen(ikev2_spi_proto_t proto)
+{
+	switch (proto) {
+	case IKEV2_PROTO_NONE:
+		return (0);
+	case IKEV2_PROTO_AH:
+	case IKEV2_PROTO_ESP:
+	case IKEV2_PROTO_FC_ESP_HEADER:
+	case IKEV2_PROTO_FC_CT_AUTH:
+		return (sizeof (uint32_t));
+	case IKEV2_PROTO_IKE:
+		return (sizeof (uint64_t));
+	}
+
+	/*NOTREACHED*/
+	return (0);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.h
new file mode 100644
index 0000000000..6b82723689
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_pkt.h
@@ -0,0 +1,114 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _IKEV2_PKT_H
+#define	_IKEV2_PKT_H
+
+#include <sys/types.h>
+#include <bunyan.h>
+#include <security/cryptoki.h>
+#include "ikev2.h"
+#include "pkt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ikev2_sa_s;
+struct bunyan_logger;
+
+#define	INBOUND_LOCAL_SPI(hdr) \
+	(((hdr)->flags == IKEV2_FLAG_INITIATOR) ? \
+	    (hdr)->responder_spi : (hdr)->initiator_spi)
+
+#define	INBOUND_REMOTE_SPI(hdr) \
+	(((hdr)->flags == IKEV2_FLAG_INITIATOR) ? \
+	    (hdr)->initiator_spi : (hdr)->responder_spi)
+
+pkt_t *ikev2_pkt_new_inbound(uint8_t *restrict, size_t,
+    struct bunyan_logger *restrict);
+pkt_t *ikev2_pkt_new_exchange(struct ikev2_sa_s *, ikev2_exch_t);
+pkt_t *ikev2_pkt_new_response(const pkt_t *);
+void ikev2_pkt_free(pkt_t *);
+
+boolean_t ikev2_add_sa(pkt_t *restrict, pkt_sa_state_t *restrict);
+boolean_t ikev2_add_prop(pkt_sa_state_t *, uint8_t, ikev2_spi_proto_t,
+    uint64_t);
+boolean_t ikev2_add_xform(pkt_sa_state_t *, ikev2_xf_type_t, int);
+boolean_t ikev2_add_xf_attr(pkt_sa_state_t *, ikev2_xf_attr_type_t, uintptr_t);
+boolean_t ikev2_add_xf_encr(pkt_sa_state_t *, ikev2_xf_encr_t, uint16_t,
+    uint16_t);
+boolean_t ikev2_add_ke(pkt_t *restrict, ikev2_dh_t, CK_OBJECT_HANDLE);
+boolean_t ikev2_add_id_i(pkt_t *restrict, ikev2_id_type_t, ...);
+boolean_t ikev2_add_id_r(pkt_t *restrict, ikev2_id_type_t, ...);
+boolean_t ikev2_add_cert(pkt_t *restrict, ikev2_cert_t,
+    const uint8_t *restrict, size_t);
+boolean_t ikev2_add_certreq(pkt_t *restrict, ikev2_cert_t,
+    const uint8_t *restrict, size_t);
+boolean_t ikev2_add_auth(pkt_t *restrict, ikev2_auth_type_t,
+    const uint8_t *restrict, size_t);
+boolean_t ikev2_add_nonce(pkt_t *restrict, uint8_t *restrict, size_t);
+boolean_t ikev2_add_notify(pkt_t *restrict, ikev2_spi_proto_t, uint64_t,
+    ikev2_notify_type_t, const void *restrict, size_t);
+
+boolean_t ikev2_add_delete(pkt_t *, ikev2_spi_proto_t, uint64_t *restrict,
+    size_t);
+boolean_t ikev2_add_delete_spi(pkt_t *, uint64_t);
+
+boolean_t ikev2_add_vendor(pkt_t *restrict, const void *restrict,
+    size_t);
+
+boolean_t ikev2_add_ts_i(pkt_t *);
+boolean_t ikev2_add_ts_r(pkt_t *);
+boolean_t ikev2_add_ts(pkt_t *restrict, ikev2_ts_type_t, uint8_t,
+    const sockaddr_u_t *restrict,
+    const sockaddr_u_t *restrict);
+
+boolean_t ikev2_add_sk(pkt_t *);
+
+boolean_t ikev2_add_config(pkt_t *restrict, ikev2_cfg_type_t);
+boolean_t ikev2_add_config_attr(pkt_t *restrict, ikev2_cfg_attr_type_t,
+    const void *restrict);
+
+boolean_t ikev2_pkt_done(pkt_t *);
+boolean_t ikev2_pkt_signverify(pkt_t *, boolean_t);
+boolean_t ikev2_pkt_decrypt(pkt_t *);
+
+typedef boolean_t (*ikev2_prop_cb_t)(ikev2_sa_proposal_t *, uint64_t, uint8_t *,
+    size_t, void *);
+typedef boolean_t (*ikev2_xf_cb_t)(ikev2_transform_t *, uint8_t *, size_t,
+    void *);
+typedef boolean_t (*ikev2_xfattr_cb_t)(ikev2_attribute_t *, void *);
+
+boolean_t ikev2_walk_proposals(uint8_t *restrict, size_t, ikev2_prop_cb_t,
+    void *restrict, bunyan_logger_t *restrict, boolean_t);
+boolean_t ikev2_walk_xfs(uint8_t *restrict, size_t, ikev2_xf_cb_t,
+    void *restrict, bunyan_logger_t *restrict);
+boolean_t ikev2_walk_xfattrs(uint8_t *restrict, size_t, ikev2_xfattr_cb_t,
+    void *restrict, bunyan_logger_t *restrict);
+
+void ikev2_pkt_log(pkt_t *restrict, bunyan_logger_t *restrict, bunyan_level_t,
+    const char *);
+
+char *ikev2_pkt_desc(pkt_t *);
+ikev2_dh_t ikev2_get_dhgrp(pkt_t *);
+size_t ikev2_spilen(ikev2_spi_proto_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_PKT_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.c
new file mode 100644
index 0000000000..55d35b66b5
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.c
@@ -0,0 +1,497 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc
+ */
+
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include "defs.h"
+#include "config.h"
+#include "ikev2_cookie.h"
+#include "ikev2_enum.h"
+#include "ikev2_sa.h"
+#include "ikev2_pkt.h"
+#include "worker.h"
+#include "inbound.h"
+#include "timer.h"
+#include "fromto.h"
+#include "ikev2_proto.h"
+#include "config.h"
+#include "pkt.h"
+
+#define	SPILOG(_level, _log, _msg, _src, _dest, _lspi, _rspi, ...)	\
+	NETLOG(_level, _log, _msg, _src, _dest,				\
+	BUNYAN_T_UINT64, "local_spi", (_lspi),				\
+	BUNYAN_T_UINT64, "remote_spi", (_rspi),				\
+	## __VA_ARGS__)
+
+static void ikev2_retransmit_cb(te_event_t, void *);
+static int select_socket(const ikev2_sa_t *);
+
+static ikev2_sa_t *ikev2_try_new_sa(pkt_t *restrict,
+    const struct sockaddr_storage *restrict,
+    const struct sockaddr_storage *restrict);
+
+/*
+ * Find the IKEv2 SA for a given inbound packet (or create a new one if
+ * an IKE_SA_INIT exchange) and send packet to worker.
+ */
+void
+ikev2_dispatch(pkt_t *pkt, const struct sockaddr_storage *restrict src_addr,
+    const struct sockaddr_storage *restrict dest_addr)
+{
+	ikev2_sa_t *i2sa = NULL;
+	ike_header_t *hdr = pkt_header(pkt);
+	uint64_t local_spi = INBOUND_LOCAL_SPI(hdr);
+	uint64_t remote_spi = INBOUND_REMOTE_SPI(hdr);
+
+	ikev2_pkt_log(pkt, log, BUNYAN_L_TRACE,
+	    "Looking for IKE SA for packet");
+
+	i2sa = ikev2_sa_get(local_spi, remote_spi, dest_addr, src_addr, pkt);
+	if (i2sa == NULL) {
+		if (local_spi != 0) {
+			/*
+			 * If the local SPI is set, we should be able to find it
+			 * in our hash.  This may be a packet destined for a
+			 * condemned or recently deleted IKE SA.
+			 *
+			 * RFC7296 2.21.4 we may send an INVALID_IKE_SPI
+			 * notification if we wish, but it is suggested the
+			 * responses be rate limited.
+			 *
+			 * For now, discard.
+			 */
+			ikev2_pkt_log(pkt, log, BUNYAN_L_DEBUG,
+			    "Cannot find IKE SA for packet; discarding");
+			ikev2_pkt_free(pkt);
+			return;
+		}
+
+		/*
+		 * XXX: This might require special processing.
+		 * Discard for now.
+		 */
+		if (remote_spi == 0) {
+			ikev2_pkt_log(pkt, log, BUNYAN_L_DEBUG,
+			    "Received packet with a 0 remote SPI; discarding");
+			ikev2_pkt_free(pkt);
+			return;
+		}
+
+		i2sa = ikev2_try_new_sa(pkt, dest_addr, src_addr);
+		if (i2sa == NULL)
+			return;
+	}
+
+	local_spi = I2SA_LOCAL_SPI(i2sa);
+
+	/*
+	 * ikev2_sa_get and ikev2_try_new_sa both return refheld ikev2_sa_t's
+	 * that we then give to the inbound packet.
+	 */
+	pkt->pkt_sa = i2sa;
+
+	if (worker_dispatch(WMSG_PACKET, pkt, local_spi % wk_nworkers))
+		return;
+
+	SPILOG(info, log, "worker queue full; discarding packet",
+	    src_addr, dest_addr, local_spi, remote_spi);
+	ikev2_pkt_free(pkt);
+}
+
+/*
+ * Determine if this pkt is an request for a new IKE SA.  If so, create
+ * a larval IKE SA and return it, otherwise discard the packet.
+ */
+static ikev2_sa_t *
+ikev2_try_new_sa(pkt_t *restrict pkt,
+    const struct sockaddr_storage *restrict l_addr,
+    const struct sockaddr_storage *restrict r_addr)
+{
+	ikev2_sa_t *i2sa = NULL;
+	ike_header_t *hdr = pkt_header(pkt);
+	const char *errmsg = NULL;
+
+	/* ikev2_dispatch() should guarantee this */
+	VERIFY3U(INBOUND_LOCAL_SPI(hdr), ==, 0);
+
+	/*
+	 * RFC7296 2.2 - The only exchange where our SPI is zero is when
+	 * the remote peer has started an IKE_SA_INIT exchange.  All others
+	 * must have both SPIs set (non-zero).
+	 */
+	if (hdr->exch_type != IKEV2_EXCH_IKE_SA_INIT) {
+		errmsg = "Received a non-IKE_SA_INIT message with a local "
+		    "SPI of 0; discarding";
+		goto discard;
+	}
+
+	/*
+	 * RFC7296 2.2 -- IKE_SA_INIT exchanges always have msgids == 0
+	 */
+	if (hdr->msgid != 0) {
+		errmsg = "Received an IKE_SA_INIT message with a non-zero "
+		    "message id; discarding";
+		goto discard;
+	}
+
+	/*
+	 * It also means it must be the initiator and not a response
+	 */
+	if ((hdr->flags & IKEV2_FLAG_INITIATOR) != hdr->flags) {
+		errmsg = "Invalid flags on packet; discarding";
+		goto discard;
+	}
+
+	/*
+	 * XXX: Since cookies are enabled in high traffic situations,
+	 * might we want to silently discard these?
+	 */
+	if (!ikev2_cookie_check(pkt, l_addr, r_addr)) {
+		errmsg = "Cookies missing or failed check; discarding";
+		goto discard;
+	}
+
+	/* otherwise create a larval SA */
+	i2sa = ikev2_sa_alloc(B_FALSE, pkt, l_addr, r_addr);
+	if (i2sa == NULL) {
+		errmsg = "Could not create larval IKEv2 SA; discarding";
+		goto discard;
+	}
+
+	return (i2sa);
+
+discard:
+	if (errmsg != NULL)
+		ikev2_pkt_log(pkt, log, BUNYAN_L_DEBUG, errmsg);
+
+	ikev2_pkt_free(pkt);
+	return (NULL);
+}
+
+/*
+ * Sends a packet out.  If pkt is an error reply, is_error should be
+ * set so that it is not saved for possible retransmission.
+ */
+boolean_t
+ikev2_send(pkt_t *pkt, boolean_t is_error)
+{
+	VERIFY(IS_WORKER);
+
+	ikev2_sa_t *i2sa = pkt->pkt_sa;
+	ike_header_t *hdr = pkt_header(pkt);
+	ssize_t len = 0;
+	int s = -1;
+	boolean_t resp = !!(hdr->flags & IKEV2_FLAG_RESPONSE);
+
+	if (!ikev2_pkt_done(pkt)) {
+		ikev2_pkt_free(pkt);
+		return (B_FALSE);
+	}
+
+	/*
+	 * We should not send out a new exchange while still waiting
+	 * on a response from a previous request
+	 */
+	if (!resp)
+		VERIFY3P(i2sa->last_sent, ==, NULL);
+
+	char *str = ikev2_pkt_desc(pkt);
+	bunyan_debug(i2sa->i2sa_log, "Sending packet",
+	    BUNYAN_T_STRING, "pktdesc", str,
+	    BUNYAN_T_BOOLEAN, "response", resp,
+	    BUNYAN_T_UINT32, "nxmit", (uint32_t)pkt->pkt_xmit,
+	    BUNYAN_T_END);
+	free(str);
+	str = NULL;
+
+	s = select_socket(i2sa);
+	len = sendfromto(s, pkt_start(pkt), pkt_len(pkt), &i2sa->laddr,
+	    &i2sa->raddr);
+	if (len == -1) {
+		if (pkt != i2sa->init_i && pkt != i2sa->init_r) {
+			/*
+			 * If the send failed, should we still save it and let
+			 * ikev2_retransmit attempt?  For now, no.
+			 *
+			 * Note: sendfromto() should have logged any relevant
+			 * errors
+			 */
+			ikev2_pkt_free(pkt);
+		}
+		return (B_FALSE);
+	}
+
+	/*
+	 * For error messages, don't expect a response, so also don't try
+	 * to retransmit
+	 */
+	if (is_error) {
+		ikev2_pkt_free(pkt);
+		return (B_TRUE);
+	}
+
+	if (!resp) {
+		config_t *cfg = config_get();
+		hrtime_t retry = cfg->cfg_retry_init;
+
+		CONFIG_REFRELE(cfg);
+
+		VERIFY0(pthread_mutex_lock(&i2sa->lock));
+		i2sa->last_sent = pkt;
+		VERIFY0(pthread_mutex_unlock(&i2sa->lock));
+
+		(void) schedule_timeout(TE_TRANSMIT, ikev2_retransmit_cb, i2sa,
+		    retry, i2sa->i2sa_log);
+		return (B_TRUE);
+	}
+
+	/*
+	 * Normally, we save the last repsonse packet we've sent in order to
+	 * re-send the last response in case the remote system retransmits
+	 * the last exchange it initiated.  However for IKE_SA_INIT exchanges,
+	 * responses of the form HDR(A,0) are not saved, as these should be
+	 * either a request for cookies, a new DH group, or a failed exchange
+	 * (no proposal chosen).
+	 */
+	if (hdr->exch_type != IKEV2_EXCH_IKE_SA_INIT ||
+	    hdr->responder_spi != 0) {
+		VERIFY0(pthread_mutex_lock(&i2sa->lock));
+		i2sa->last_resp_sent = pkt;
+		VERIFY0(pthread_mutex_unlock(&i2sa->lock));
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * Retransmit callback
+ */
+static void
+ikev2_retransmit_cb(te_event_t event, void *data)
+{
+	VERIFY(IS_WORKER);
+
+	ikev2_sa_t *sa = data;
+	pkt_t *pkt = sa->last_sent;
+	ike_header_t *hdr = pkt_header(pkt);
+	hrtime_t retry = 0, retry_init = 0, retry_max = 0;
+	size_t limit = 0;
+	ssize_t len;
+
+	VERIFY0(pthread_mutex_lock(&sa->lock));
+
+	/* XXX: what about condemned SAs */
+	if (sa->outmsgid > ntohl(hdr->msgid) || sa->last_sent == NULL) {
+		/* already acknowledged */
+		VERIFY0(pthread_mutex_unlock(&sa->lock));
+		ikev2_pkt_free(pkt);
+		return;
+	}
+	VERIFY0(pthread_mutex_unlock(&sa->lock));
+
+	config_t *cfg = config_get();
+	retry_init = cfg->cfg_retry_init;
+	retry_max = cfg->cfg_retry_max;
+	limit = cfg->cfg_retry_limit;
+	CONFIG_REFRELE(cfg);
+	cfg = NULL;
+
+	retry = retry_init * (1ULL << ++pkt->pkt_xmit);
+	if (retry > retry_max)
+		retry = retry_max;
+	if (pkt->pkt_xmit > limit) {
+		bunyan_info(sa->i2sa_log,
+		    "Transmit timeout on packet; deleting IKE SA",
+		    BUNYAN_T_END);
+		ikev2_sa_condemn(sa);
+		return;
+	}
+
+	ikev2_pkt_log(pkt, sa->i2sa_log, BUNYAN_L_DEBUG, "Sending packet");
+
+	/*
+	 * If sendfromto() errors, it will log the error, but being a
+	 * retransmit callback, there's not much more we can do here, so
+	 * just ignore the return value.
+	 */
+	(void) sendfromto(select_socket(sa), pkt_start(pkt), pkt_len(pkt),
+	    &sa->laddr, &sa->raddr);
+
+	VERIFY(schedule_timeout(TE_TRANSMIT, ikev2_retransmit_cb, sa, retry,
+	    sa->i2sa_log));
+}
+
+/*
+ * Determine if packet is a retransmit, if so, retransmit our last
+ * response and discard.  Otherwise return B_FALSE and continue processing.
+ *
+ * XXX better function name?
+ */
+static boolean_t
+ikev2_retransmit_check(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	ike_header_t *hdr = pkt_header(pkt);
+	uint32_t msgid = ntohl(hdr->msgid);
+	boolean_t discard = B_TRUE;
+
+	VERIFY0(pthread_mutex_lock(&sa->lock));
+	if (sa->flags & I2SA_CONDEMNED)
+		goto done;
+
+	if (hdr->flags & IKEV2_FLAG_RESPONSE) {
+		pkt_t *last = sa->last_sent;
+
+		if (msgid != sa->outmsgid) {
+			/*
+			 * Not a response to our last message.
+			 *
+			 * XXX: Send INVALID_MESSAGE_ID notification in
+			 * certain circumstances.  Drop for now.
+			 */
+			goto done;
+		}
+
+		/* A response to our last message */
+		VERIFY3S(cancel_timeout(TE_TRANSMIT, sa,
+		    sa->i2sa_log), ==, 1);
+
+		/*
+		 * Corner case: this isn't the actual response in the
+		 * IKE_SA_INIT exchange, but a request to either use
+		 * cookies or a different DH group.  In that case we don't
+		 * want to treat it like a response (ending the exchange
+		 * and resetting sa->last_sent).
+		 */
+		if (hdr->exch_type != IKEV2_EXCH_IKE_SA_INIT ||
+		    hdr->responder_spi != 0)
+			sa->last_sent = NULL;
+
+		/* Keep IKE_SA_INIT packets until we've authed or time out */
+		if (last != sa->init_i && last != sa->init_r)
+			ikev2_pkt_free(last);
+
+		discard = B_FALSE;
+		goto done;
+	}
+
+	VERIFY(hdr->flags & IKEV2_FLAG_INITIATOR);
+
+	if (msgid == sa->inmsgid) {
+		pkt_t *resp = sa->last_resp_sent;
+		ssize_t len = 0;
+
+		if (resp == NULL) {
+			discard = B_FALSE;
+			goto done;
+		}
+
+		ikev2_pkt_log(pkt, sa->i2sa_log, BUNYAN_L_DEBUG,
+		    "Resending last response");
+
+		len = sendfromto(select_socket(sa), pkt_start(resp),
+		    pkt_len(pkt), &sa->laddr, &sa->raddr);
+		goto done;
+	}
+
+	if (msgid != sa->inmsgid + 1) {
+		ikev2_pkt_log(pkt, sa->i2sa_log, BUNYAN_L_INFO,
+		    "Message id is out of sequence");
+
+		/*
+		 * TODO: Create in informational exchange & send
+		 * INVALID_MESSAGE_ID if this is a fully-formed IKE SA
+		 *
+		 * For now, just discard.
+		 */
+		goto done;
+	}
+
+	/* New exchange, free last response and get going */
+	ikev2_pkt_free(sa->last_resp_sent);
+	sa->last_resp_sent = NULL;
+	sa->inmsgid++;
+	discard = B_FALSE;
+
+done:
+	VERIFY0(pthread_mutex_unlock(&sa->lock));
+	return (discard);
+}
+
+/*
+ * Worker inbound function -- handle retransmits or do processing for
+ * the given message exchange type;
+ */
+void
+ikev2_inbound(pkt_t *pkt)
+{
+	VERIFY(IS_WORKER);
+
+	(void) bunyan_trace(worker->w_log, "Starting IKEV2 inbound processing",
+	    BUNYAN_T_END);
+
+	if (ikev2_retransmit_check(pkt)) {
+		ikev2_pkt_free(pkt);
+		return;
+	}
+
+	/* XXX: Might this log msg be better in ikev2_dispatch() instead? */
+	ikev2_pkt_log(pkt, pkt->pkt_sa->i2sa_log, BUNYAN_L_DEBUG,
+	    "Received packet");
+
+	switch (pkt_header(pkt)->exch_type) {
+	case IKEV2_EXCH_IKE_SA_INIT:
+		ikev2_sa_init_inbound(pkt);
+		break;
+	case IKEV2_EXCH_IKE_AUTH:
+	case IKEV2_EXCH_CREATE_CHILD_SA:
+	case IKEV2_EXCH_INFORMATIONAL:
+	case IKEV2_EXCH_IKE_SESSION_RESUME:
+		/* TODO */
+		ikev2_pkt_log(pkt, pkt->pkt_sa->i2sa_log, BUNYAN_L_INFO,
+		    "Exchange not implemented yet");
+		ikev2_pkt_free(pkt);
+		break;
+	default:
+		ikev2_pkt_log(pkt, pkt->pkt_sa->i2sa_log, BUNYAN_L_ERROR,
+		    "Unknown IKEv2 exchange");
+		ikev2_pkt_free(pkt);
+	}
+}
+
+static int
+select_socket(const ikev2_sa_t *i2sa)
+{
+	if (i2sa->laddr.ss_family == AF_INET6)
+		return (ikesock6);
+	if (I2SA_IS_NAT(i2sa))
+		return (nattsock);
+	return (ikesock4);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.h
new file mode 100644
index 0000000000..b9a74bdb35
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_proto.h
@@ -0,0 +1,44 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#ifndef _IKEV2_PROTO_H
+#define	_IKEV2_PROTO_H
+
+#include <inttypes.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+struct pkt_s;
+struct ikev2_sa_s;
+struct sockaddr_storage;
+
+void ikev2_dispatch(struct pkt_s *, const struct sockaddr_storage *,
+    const struct sockaddr_storage *);
+boolean_t ikev2_send(struct pkt_s *, boolean_t);
+void ikev2_inbound(struct pkt_s *);
+
+void ikev2_sa_init_inbound(struct pkt_s *);
+void ikev2_sa_init_outbound(struct ikev2_sa_s *restrict, uint8_t *restrict,
+    size_t, ikev2_dh_t, uint8_t *restrict, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IKEV2_PROTO_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.c
new file mode 100644
index 0000000000..b838a7a224
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.c
@@ -0,0 +1,1050 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * Manipulation and storage of IKEv2 Security Associations (SAs).
+ */
+#include <umem.h>
+#include <errno.h>
+#include <ipsec_util.h>
+#include <limits.h>
+#include <locale.h>
+#include <note.h>
+#include <pthread.h>
+#include <stddef.h>
+#include <strings.h>
+#include <sys/debug.h>
+#include <sys/list.h>
+#include <sys/sysmacros.h>
+#include <sys/types.h>
+#include <umem.h>
+#include "config.h"
+#include "defs.h"
+#include "ikev2_cookie.h"
+#include "ikev2_pkt.h"
+#include "ikev2_sa.h"
+#include "ilist.h"
+#include "pkcs11.h"
+#include "pkt.h"
+#include "random.h"
+#include "timer.h"
+#include "worker.h"
+
+struct i2sa_bucket {
+	mutex_t		lock;	/* bucket lock */
+	ilist_t		chain;	/* hash chain of ikev2_sa_t's */
+};
+
+typedef struct i2sa_cmp_s {
+	const struct sockaddr_storage	*ic_laddr;
+	const struct sockaddr_storage	*ic_raddr;
+	const pkt_t			*ic_init_pkt;
+	uint64_t			ic_l_spi;
+	uint64_t			ic_r_spi;
+} i2sa_cmp_t;
+
+size_t ikev2_sa_buckets = 16;
+
+static volatile uint_t	half_open;	/* # of larval/half open IKEv2 SAs */
+static uint_t		num_buckets;	/* Use same value for all hashes */
+static uint32_t		remote_noise;	/* random noise for rhash */
+static i2sa_bucket_t	*hash[I2SA_NUM_HASH];
+static umem_cache_t	*i2sa_cache;
+
+#define	I2SA_KEY_I2SA		"i2sa"
+#define	I2SA_KEY_LADDR		"local_addr"
+#define	I2SA_KEY_LPORT		"local_port"
+#define	I2SA_KEY_RADDR		"remote_addr"
+#define	I2SA_KEY_RPORT		"remote_port"
+#define	I2SA_KEY_LSPI		"local_spi"
+#define	I2SA_KEY_RSPI		"remote_spi"
+#define	I2SA_KEY_INITIATOR	"sa_initiator"
+
+#define	IKEV2_SA_HASH_SPI(spi) \
+    P2PHASE_TYPED((spi), num_buckets, uint64_t)
+
+#define	IKEV2_SA_RHASH(ss, spi) \
+    P2PHASE_TYPED(i2sa_rhash((ss), (spi)), num_buckets, uint64_t)
+
+static void	i2sa_init(ikev2_sa_t *);
+static uint32_t	i2sa_rhash(const struct sockaddr_storage *, uint64_t);
+static int i2sa_compare(const ikev2_sa_t *, const i2sa_cmp_t *);
+
+static ikev2_sa_t *i2sa_verify(ikev2_sa_t *restrict, uint64_t,
+    const struct sockaddr_storage *restrict,
+    const struct sockaddr_storage *restrict);
+static boolean_t i2sa_add_to_hash(i2sa_hash_t, ikev2_sa_t *);
+
+static void i2sa_unlink(ikev2_sa_t *);
+static void i2sa_expire_cb(te_event_t, void *data);
+
+static boolean_t i2sa_key_add_addr(ikev2_sa_t *, const char *, const char *,
+    const struct sockaddr_storage *);
+static int i2sa_ctor(void *, void *, int);
+static void i2sa_dtor(void *, void *);
+
+static void inc_half_open(void);
+static void dec_half_open(void);
+
+/*
+ * Attempt to find an IKEv2 SA that matches the given criteria, or return
+ * NULL if not found.
+ */
+ikev2_sa_t *
+ikev2_sa_get(uint64_t l_spi, uint64_t r_spi,
+    const struct sockaddr_storage *restrict l_addr,
+    const struct sockaddr_storage *restrict r_addr,
+    const pkt_t *restrict init_pkt)
+{
+	i2sa_bucket_t *bucket = NULL;
+	ikev2_sa_t *sa = NULL, *node = NULL;
+	i2sa_cmp_t cmp = {
+		.ic_l_spi = l_spi,
+		.ic_r_spi = r_spi,
+		.ic_init_pkt = init_pkt,
+		.ic_laddr = l_addr,
+		.ic_raddr = r_addr
+	};
+
+	if (l_spi != 0) {
+		/*
+		 * We assign the local SPIs, so if it is set (!= 0), that
+		 * should be sufficient to find the IKE SA.
+		 */
+		bucket = hash[I2SA_LSPI] + IKEV2_SA_HASH_SPI(l_spi);
+	} else {
+		/* Otherwise need to look at the other parameters */
+		bucket = hash[I2SA_RHASH] + IKEV2_SA_RHASH(r_addr, r_spi);
+	}
+
+	mutex_enter(&bucket->lock);
+	for (node = ilist_head(&bucket->chain);
+	    node != NULL;
+	    node = ilist_next(&bucket->chain, node)) {
+		int rc = i2sa_compare(node, &cmp);
+
+		if (rc < 0)
+			continue;
+
+		if (rc == 0)
+			sa = node;
+		/*
+ 		 * The list is sorted, so if we reach a node > than what
+ 		 * we're looking for, it's not there.
+ 		 */
+		break;
+	}
+
+	if (sa != NULL)
+		I2SA_REFHOLD(sa);
+	mutex_exit(&bucket->lock);
+
+	return (i2sa_verify(sa, r_spi, l_addr, r_addr));
+}
+
+/*
+ * Allocate a larval IKEv2 SA.
+ *
+ * Obtains a unique local SPI and assigns it to the SA and adds the SA to
+ * the local SPI hash.  If the packet used to trigger the creation of the SA
+ * is given, take over management of it.  Also create an SA expiration timer.
+ *
+ * If we initiated the SA creation, the remote SPI will not be known initially.
+ * Once the protocol has proceeded enough to determine the remote SPI,
+ * ikev2_sa_set_rspi() should be called.
+ *
+ * Parameters:
+ * 	initiator	Was this SA locally initiated
+ * 	init_pkt	The packet that trigged the creation of the SA.
+ * 	laddr,
+ * 	raddr		The local and remote addresses of this SA.
+ *
+ * On successful create, the larval IKEv2 SA is returned.
+ * On failure, NULL is returned.  Caller maintains responsibility for
+ * init_pkt in this instance.
+ *
+ * XXX: We could probably refactor this so that the presence of the initiator
+ * packet indicates the request was remotely initiated -- when we initiate,
+ * we create the IKE SA then the IKE_SA_INIT initiator packet.
+ */
+ikev2_sa_t *
+ikev2_sa_alloc(boolean_t initiator,
+    pkt_t *restrict init_pkt,
+    const struct sockaddr_storage *restrict laddr,
+    const struct sockaddr_storage *restrict raddr)
+{
+	ikev2_sa_t	*i2sa = NULL;
+
+	bunyan_trace(log, "Attempting to create new larval IKE SA",
+	    BUNYAN_T_BOOLEAN, I2SA_KEY_INITIATOR, initiator,
+	    ss_bunyan(laddr), I2SA_KEY_LADDR, ss_addr(laddr),
+	    ss_bunyan(raddr), I2SA_KEY_RADDR, ss_addr(raddr),
+	    BUNYAN_T_END);
+
+	if ((i2sa = umem_cache_alloc(i2sa_cache, UMEM_DEFAULT)) == NULL)
+		return (NULL);
+
+	/* Keep anyone else out while we initialize */
+	VERIFY0(pthread_mutex_lock(&i2sa->lock));
+
+	ASSERT((init_pkt == NULL) ||
+	    (init_pkt->hdr.exch_type == IKEV2_EXCHANGE_IKE_SA_INIT));
+
+	i2sa->flags |= (initiator) ? I2SA_INITIATOR : 0;
+
+	(void) memcpy(&i2sa->laddr, laddr, sizeof (i2sa->laddr));
+	(void) memcpy(&i2sa->raddr, raddr, sizeof (i2sa->raddr));
+
+	/*
+	 * Generate a random local SPI and try to add it.  Almost always this
+	 * will succeed on the first attempt.  However if on the rare occasion
+	 * we generate a duplicate, just retry until we pick a value that's
+	 * not in use.
+	 */
+	while (1) {
+		/*CONSTCOND*/
+		uint64_t spi = random_low_64();
+
+		/*
+ 		 * Incredibly unlikely we'll ever randomly generate 0, but
+ 		 * if we do, just try again.
+ 		 */
+		if (spi == 0)
+			continue;
+
+		if (initiator)
+			i2sa->i_spi = spi;
+		else
+			i2sa->r_spi = spi;
+
+		if (i2sa_add_to_hash(I2SA_LSPI, i2sa)) {
+			VERIFY3U(i2sa->refcnt, ==, 1);
+
+			i2sa->init_i = init_pkt;
+
+			/* refhold for caller */
+			I2SA_REFHOLD(i2sa);
+			break;
+		}
+	};
+
+	inc_half_open();
+
+	/* 0x + 64bit hex value + NUL */
+	char buf[19] = { 0 };
+
+	/*
+	 * For protocol processing, the SPIs are treated as opaque values,
+	 * however for debugging/diagnostic/admin purposes, we want to output
+	 * them in native byte order so the SPI values will match
+	 * what other implementations and tools (such as wireshark) display
+	 */
+	(void) snprintf(buf, sizeof (buf), "0x%016" PRIX64,
+	    ntohll(I2SA_LOCAL_SPI(i2sa)));
+
+	if (bunyan_child(log, &i2sa->i2sa_log,
+	    BUNYAN_T_POINTER, I2SA_KEY_I2SA, i2sa,
+	    BUNYAN_T_STRING, I2SA_KEY_LSPI, buf,
+	    ss_bunyan(laddr), I2SA_KEY_LADDR, ss_addr(laddr),
+	    BUNYAN_T_UINT32, I2SA_KEY_LPORT, ss_port(laddr),
+	    ss_bunyan(raddr), I2SA_KEY_RADDR, ss_addr(raddr),
+	    BUNYAN_T_UINT32, I2SA_KEY_RPORT, ss_port(raddr),
+	    BUNYAN_T_BOOLEAN, I2SA_KEY_INITIATOR, initiator,
+	    BUNYAN_T_END) != 0) {
+		bunyan_error(log, "Cannot create IKE SA logger",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	/*
+	 * If we're the initiator, we don't know the remote SPI until after
+	 * the remote peer responds.  However if we are the responder,
+	 * we know what it is and can set it now.
+	 */
+	if (!initiator) {
+		ikev2_sa_set_remote_spi(i2sa,
+		    pkt_header(init_pkt)->initiator_spi);
+	}
+
+	/*
+	 * Start SA expiration timer.  We cannot call schedule_timeout()
+	 * from there because we are almost certaintly not running in one
+	 * of the worker threads -- the local SPI cannot be known until
+	 * we exit.  The answer is to have the correct worker schedule it
+	 * for us.
+	 *
+	 * XXX: Should this be reset after we've successfully authenticated?
+	 * My hunch is no, and should only be cleared once the AUTH exchange
+	 * has successfully completed.
+	 */
+	I2SA_REFHOLD(i2sa);
+	if (!worker_dispatch(WMSG_START_P1_TIMER, i2sa,
+	    I2SA_LOCAL_SPI(i2sa) % wk_nworkers)) {
+		(void) bunyan_error(i2sa->i2sa_log,
+		    "Cannot dispatch WMSG_START_P1_TIMER event; aborting",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	VERIFY0(pthread_mutex_unlock(&i2sa->lock));
+
+	(void) bunyan_debug(i2sa->i2sa_log, "New larval IKE SA created",
+	    BUNYAN_T_POINTER, "sa", i2sa,
+	    BUNYAN_T_END);
+
+	return (i2sa);
+
+fail:
+	VERIFY0(pthread_mutex_unlock(&i2sa->lock));
+	i2sa_unlink(i2sa);
+
+	/*
+	 * When refcnt goes from 1->0, i2sa will get freed, so do last one
+	 * explicitly
+	 */
+	while (i2sa->refcnt > 1)
+		I2SA_REFRELE(i2sa);
+	I2SA_REFRELE(i2sa);
+
+	bunyan_debug(log, "Larval IKE SA creation failed", BUNYAN_T_END);
+	return (NULL);
+}
+
+void
+ikev2_sa_start_timer(ikev2_sa_t *i2sa)
+{
+	config_t *cfg = config_get();
+	hrtime_t expire = cfg->cfg_expire_timer;
+
+	CONFIG_REFRELE(cfg);
+	cfg = NULL;
+
+	/* Pass i2sa reference to timer */
+	if (schedule_timeout(TE_P1_SA_EXPIRE, i2sa_expire_cb, i2sa, expire,
+	    i2sa->i2sa_log))
+		return;
+
+	bunyan_error(i2sa->i2sa_log, "Unable to schedule larval IKE SA timeout",
+	    BUNYAN_T_END);
+
+	ikev2_sa_condemn(i2sa);
+	I2SA_REFRELE(i2sa);
+}
+/*
+ * Invoked when an SA has expired.  REF from timer is passed to this
+ * function.
+ */
+static void
+i2sa_expire_cb(te_event_t evt, void *data)
+{
+	NOTE(ARGUNUSED(evt))
+
+	ikev2_sa_t *i2sa = data;
+
+	bunyan_info(i2sa->i2sa_log, "Larval IKE SA timeout; deleting",
+	    BUNYAN_T_END);
+
+	ikev2_sa_condemn(i2sa);
+	/* XXX: Anything else? */
+	I2SA_REFRELE(i2sa);
+}
+
+void
+ikev2_sa_flush(void)
+{
+	/* TODO: implement me */
+}
+
+void
+ikev2_sa_condemn(ikev2_sa_t *i2sa)
+{
+	size_t num = 0;
+	I2SA_REFHOLD(i2sa);
+
+	i2sa_unlink(i2sa);
+
+	VERIFY0(pthread_mutex_lock(&i2sa->lock));
+
+	(void) bunyan_info(i2sa->i2sa_log, "Condemning IKE SA", BUNYAN_T_END);
+
+	i2sa->flags |= I2SA_CONDEMNED;
+
+	if (i2sa->last_sent != NULL)
+		(void) cancel_timeout(TE_TRANSMIT, i2sa, i2sa->i2sa_log);
+
+	if (cancel_timeout(TE_P1_SA_EXPIRE, i2sa, i2sa->i2sa_log) > 0)
+		I2SA_REFRELE(i2sa);
+
+	/*
+ 	* Since packets keep a reference to the SA they are associated with,
+ 	* we must free them here so that their references go away
+ 	*/
+	if (i2sa->init_i != i2sa->last_resp_sent &&
+	    i2sa->init_i != i2sa->last_sent)
+		ikev2_pkt_free(i2sa->init_i);
+
+	if (i2sa->init_r != i2sa->last_resp_sent &&
+	    i2sa->init_r != i2sa->last_sent)
+		ikev2_pkt_free(i2sa->init_r);
+
+	ikev2_pkt_free(i2sa->last_resp_sent);
+	ikev2_pkt_free(i2sa->last_sent);
+	ikev2_pkt_free(i2sa->last_recvd);
+	i2sa->init_i = NULL;
+	i2sa->init_r = NULL;
+	i2sa->last_resp_sent = NULL;
+	i2sa->last_sent = NULL;
+	i2sa->last_recvd = NULL;
+
+	VERIFY0(pthread_mutex_unlock(&i2sa->lock));
+
+	I2SA_REFRELE(i2sa);
+	/* XXX: should we do anything else here? */
+}
+
+/*
+ * Should normally only be called as a result of I2SA_REFRELE()
+ */
+void
+ikev2_sa_free(ikev2_sa_t *i2sa)
+{
+	if (i2sa == NULL)
+		return;
+
+	VERIFY3U(i2sa->refcnt, ==, 0);
+	VERIFY3P(i2sa->init_i, ==, NULL);
+	VERIFY3P(i2sa->init_r, ==, NULL);
+	VERIFY3P(i2sa->last_resp_sent, ==, NULL);
+	VERIFY3P(i2sa->last_sent, ==, NULL);
+	VERIFY3P(i2sa->last_recvd, ==, NULL);
+
+	if (i2sa->i2sa_rule != NULL)
+		CONFIG_REFRELE(i2sa->i2sa_rule->rule_config);
+
+	/* All unauthenticated IKEv2 SAs are considered larval */
+	if (!(i2sa->flags & I2SA_AUTHENTICATED))
+		dec_half_open();
+
+#define	DESTROY(x, y) pkcs11_destroy_obj(#y, &(x)->y, i2sa->i2sa_log)
+	DESTROY(i2sa, dh_pubkey);
+	DESTROY(i2sa, dh_privkey);
+	DESTROY(i2sa, dh_key);
+	DESTROY(i2sa, sk_d);
+	DESTROY(i2sa, sk_ai);
+	DESTROY(i2sa, sk_ar);
+	DESTROY(i2sa, sk_ei);
+	DESTROY(i2sa, sk_er);
+	DESTROY(i2sa, sk_pi);
+	DESTROY(i2sa, sk_pr);
+#undef  DESTROY
+
+	/* TODO: free child SAs */
+
+	bunyan_fini(i2sa->i2sa_log);
+
+	i2sa_dtor(i2sa, NULL);
+	i2sa_ctor(i2sa, NULL, 0);
+	umem_cache_free(i2sa_cache, i2sa);
+}
+
+void
+ikev2_sa_set_hashsize(uint_t newamt)
+{
+	i2sa_bucket_t *old[I2SA_NUM_HASH];
+	size_t nold = num_buckets;
+	int i, hashtbl;
+	boolean_t startup = B_FALSE;
+
+	for (i = 0; i < I2SA_NUM_HASH; i++)
+		old[i] = hash[i];
+
+	if (old[0] != NULL) {
+		startup = B_FALSE;
+		worker_suspend();
+	}
+
+	/* Round up to a power of two if not already */
+	if (!ISP2(newamt)) {
+		--newamt;
+		for (i = 1; i <= 16; i++)
+			newamt |= (newamt >> i);
+		++newamt;
+	}
+	VERIFY(ISP2(newamt));
+
+	bunyan_debug(log, "Creating IKE SA hash buckets",
+	    BUNYAN_T_UINT32, "numbuckets", (uint32_t)newamt,
+	    BUNYAN_T_BOOLEAN, "startup", startup,
+	    BUNYAN_T_END);
+
+	for (i = 0; i < I2SA_NUM_HASH; i++)
+		hash[i] = NULL;
+
+	/* Allocate new buckets */
+	for (i = 0; i < I2SA_NUM_HASH; i++) {
+		size_t amt = newamt * sizeof (i2sa_bucket_t);
+		VERIFY3U(amt, >, sizeof (i2sa_bucket_t));
+		VERIFY3U(amt, >=, newamt);
+
+		hash[i] = umem_zalloc(amt, UMEM_DEFAULT);
+		if (hash[i] == NULL)
+			goto nomem;
+
+		size_t offset = 0;
+
+		switch (i) {
+		case I2SA_LSPI:
+			offset = offsetof(ikev2_sa_t, i2sa_lspi_node);
+			break;
+		case I2SA_RHASH:
+			offset = offsetof(ikev2_sa_t, i2sa_rspi_node);
+			break;
+		}
+
+		for (size_t j = 0; j < newamt; j++) {
+			i2sa_bucket_t *b = &hash[i][j];
+
+			ilist_create(&b->chain, sizeof (ikev2_sa_t), offset);
+			VERIFY0(mutex_init(&b->lock, LOCK_ERRORCHECK, NULL));
+		}
+	}
+
+	/* New tables means a new fudge factor.  Pick one randomly. */
+	remote_noise = random_low_32();
+
+	i = num_buckets;
+
+	/* Set this so the hash functions work on the new buckets */
+	num_buckets = newamt;
+
+	if (startup)
+		return;
+
+	/*
+	 * At this point, we've allocated all the necessary structures, so
+	 * we can just move everything over to the new buckets.  Since the
+	 * only remaining reference to the old number of buckets here is i,
+	 * we work backwards to free each chain, and invert the normal
+	 * inner/outer loop order.
+	 */
+	while (--i >= 0) {
+		for (hashtbl = 0; hashtbl < I2SA_NUM_HASH; hashtbl++) {
+			ilist_t *list, *oldlist;
+			ikev2_sa_t *i2sa;
+
+			list = &hash[hashtbl][i].chain;
+			oldlist = &old[hashtbl][i].chain;
+
+			while ((i2sa = ilist_remove_head(oldlist)) != NULL) {
+				VERIFY(i2sa_add_to_hash(hashtbl, i2sa));
+				/* Remove ref from old list */
+				I2SA_REFRELE(i2sa);
+			}
+
+			VERIFY0(mutex_destroy(&old[hashtbl][i].lock));
+			VERIFY(ilist_is_empty(oldlist));
+		}
+	}
+
+	for (hashtbl = 0; hashtbl < I2SA_NUM_HASH; hashtbl++)
+		umem_free(old[hashtbl], sizeof (i2sa_bucket_t) * nold);
+
+	worker_resume();
+	return;
+
+nomem:
+	if (startup)
+		errx(EXIT_FAILURE, "out of memory");
+
+	/* This will probably fail too, but worth a shot */
+	(void) bunyan_error(log, "out of memory", BUNYAN_T_STRING);
+
+	/*
+	 * Free what the new stuff we've constructed so far, and put the
+	 * old buckets back into place
+	 */
+	for (hashtbl = 0; hashtbl < I2SA_NUM_HASH; hashtbl++) {
+		if (hash[hashtbl] == NULL)
+			continue;
+		for (i = 0; i < newamt; i++)
+			VERIFY(ilist_is_empty(&hash[hashtbl][i].chain));
+
+		umem_free(hash[hashtbl], newamt * sizeof (i2sa_bucket_t));
+		hash[hashtbl] = old[hashtbl];
+	}
+
+	worker_resume();
+}
+
+/*
+ * Set the remote SPI of an IKEv2 SA and add to the rhash
+ */
+void
+ikev2_sa_set_remote_spi(ikev2_sa_t *i2sa, uint64_t remote_spi)
+{
+	/* Never a valid SPI value */
+	VERIFY3U(remote_spi, !=, 0);
+
+	/*
+	 * A bit confusing at times, but if we are the initiator of the
+	 * SA, the responder (ikev2_sa_t->remote_spi) is the remote spi,
+	 * otherwise we are the responder, so the remote spi is the
+	 * initiator (ikev2_sa_t->i_spi)
+	 */
+	if (i2sa->flags & I2SA_INITIATOR) {
+		/* Should not be set already */
+		VERIFY3U(i2sa->r_spi, ==, 0);
+		i2sa->r_spi = remote_spi;
+	} else {
+		/* Should not be set already */
+		VERIFY3U(i2sa->i_spi, ==, 0);
+		i2sa->i_spi = remote_spi;
+	}
+
+	VERIFY(i2sa_add_to_hash(I2SA_RHASH, i2sa));
+	char buf[19];	/* 0x + 64bit hex value + NUL */
+
+	(void) snprintf(buf, sizeof (buf), "0x%016" PRIX64,
+	    ntohll(I2SA_REMOTE_SPI(i2sa)));
+	(void) bunyan_key_add(i2sa->i2sa_log,
+	    BUNYAN_T_STRING, I2SA_KEY_RSPI, buf, BUNYAN_T_END);
+
+	(void) bunyan_trace(i2sa->i2sa_log, "Set remote SPI", BUNYAN_T_END);
+}
+
+static i2sa_bucket_t *
+i2sa_get_bucket(i2sa_hash_t hashtype, ikev2_sa_t *i2sa)
+{
+	i2sa_bucket_t *bucket = hash[hashtype];
+	size_t n = 0;
+
+	switch (hashtype) {
+	case I2SA_LSPI:
+		n = IKEV2_SA_HASH_SPI(I2SA_LOCAL_SPI(i2sa));
+		break;
+	case I2SA_RHASH:
+		n = IKEV2_SA_RHASH(&i2sa->raddr, I2SA_REMOTE_SPI(i2sa));
+		break;
+	}
+	VERIFY3U(n, <, num_buckets);
+
+	return (bucket + n);
+}
+
+
+/*
+ * Add an IKEv2 SA to the given hash.
+ *
+ * Returns:
+ * 	B_TRUE	successfully added, hash holds ref to IKEv2 SA
+ * 	B_FALSE	IKEv2 SA already exists in hash, no ref held.
+ *
+ */
+static boolean_t
+i2sa_add_to_hash(i2sa_hash_t hashtbl, ikev2_sa_t *i2sa)
+{
+	i2sa_bucket_t	*bucket;
+	ikev2_sa_t	*node = NULL;
+	int		rc = 1;
+
+	bucket = i2sa_get_bucket(hashtbl, i2sa);
+
+	mutex_enter(&bucket->lock);
+
+	for (node = ilist_head(&bucket->chain);
+	    node != NULL;
+	    node = ilist_next(&bucket->chain, node)) {
+		i2sa_cmp_t cmp = {
+			.ic_laddr = &node->laddr,
+			.ic_raddr = &node->raddr,
+			.ic_init_pkt = I2SA_REMOTE_INIT(node),
+			.ic_l_spi = I2SA_LOCAL_SPI(node),
+			.ic_r_spi = I2SA_REMOTE_SPI(node)
+		};
+
+		rc = i2sa_compare(i2sa, &cmp);
+		if (rc >= 0)
+			break;
+	}
+
+	if (rc == 0) {
+		/*
+		 * Found a match, should only happen while choosing
+		 * a local SPI value and we happen to pick one already
+		 * in use.
+		 */
+
+		VERIFY3P(node, !=, i2sa);
+
+		/*
+		 * XXX: Should we do anything different for an rhash
+		 * match?
+		 */
+		mutex_exit(&bucket->lock);
+		return (B_FALSE);
+	}
+
+	I2SA_REFHOLD(i2sa);	/* ref for chain */
+	i2sa->bucket[hashtbl] = bucket;
+	ilist_insert_before(&bucket->chain, node, i2sa);
+	mutex_exit(&bucket->lock);
+
+	return (B_TRUE);
+}
+
+static ikev2_sa_t *
+i2sa_verify(ikev2_sa_t *restrict i2sa, uint64_t rem_spi,
+    const struct sockaddr_storage *laddr,
+    const struct sockaddr_storage *raddr)
+{
+	if (i2sa == NULL)
+		return (NULL);
+
+	/*
+	 * If we initiate an IKE_SA_INIT request, when we receive a non-error
+	 * (cookie, new DH pair, no proposal chosen) response, our IKE SA
+	 * will not yet have it's remote SPI set as the response will be
+	 * the first time the remote SPI is known to us.  That means, in
+	 * that situation, our remote SPI == 0, but we will be called with
+	 * rem_spi set to the value chosen by the peer.  As such we don't
+	 * want to fail verification when given a remote SPI value and ours
+	 * hasn't been set yet.
+	 */
+	if (I2SA_REMOTE_SPI(i2sa) != 0 && I2SA_REMOTE_SPI(i2sa) != rem_spi) {
+		char spistr[19];
+		(void) snprintf(spistr, sizeof (spistr), "0x%" PRIX64, rem_spi);
+		(void) bunyan_error(i2sa->i2sa_log,
+		    "Found an IKEv2 SA, but remote SPI does not match",
+		    BUNYAN_T_STRING, "spi", spistr,
+		    BUNYAN_T_END);
+		goto bad_match;
+	}
+
+	if (laddr != NULL && !SA_ADDR_EQ(laddr, &i2sa->laddr)) {
+		(void) bunyan_error(i2sa->i2sa_log,
+		    "Found an IKEv2 SA, but local address does not match",
+		    ss_bunyan(laddr), "addr", ss_addr(laddr),
+		    BUNYAN_T_END);
+		goto bad_match;
+	}
+
+	if (raddr != NULL && !SA_ADDR_EQ(raddr, &i2sa->raddr)) {
+		(void) bunyan_error(i2sa->i2sa_log,
+		    "Found an IKEv2 SA, but remote address does not match",
+		    ss_bunyan(raddr), "addr", ss_addr(raddr),
+		    BUNYAN_T_END);
+		goto bad_match;
+	}
+
+	/*
+	 * XXX KEBE ASKS - if remote port changes, do remap?
+	 * Probably have caller do this after packet is really legit.
+	 */
+
+	/* XXX KEBE SAYS FILL IN OTHER REALITY CHECKS HERE. */
+
+	(void) bunyan_trace(i2sa->i2sa_log, "IKEv2 SA found",
+	    BUNYAN_T_STRING, "func", __func__,
+	    BUNYAN_T_END);
+	return (i2sa);
+
+bad_match:
+	I2SA_REFRELE(i2sa);
+	return (NULL);
+}
+
+static void
+i2sa_hash_remove(size_t hashtbl, ikev2_sa_t *i2sa)
+{
+	i2sa_bucket_t *bucket;
+
+	VERIFY3U(hashtbl, <, I2SA_NUM_HASH);
+
+	switch (hashtbl) {
+	case I2SA_LSPI:
+		if (!list_link_active(&i2sa->i2sa_lspi_node))
+			return;
+		break;
+	case I2SA_RHASH:
+		if (!list_link_active(&i2sa->i2sa_rspi_node))
+			return;
+		break;
+	}
+
+	bucket = i2sa->bucket[hashtbl];
+
+	mutex_enter(&bucket->lock);
+	ilist_remove(&bucket->chain, i2sa);
+	i2sa->bucket[hashtbl] = NULL;
+	mutex_exit(&bucket->lock);
+
+	I2SA_REFRELE(i2sa);
+}
+
+static void
+i2sa_unlink(ikev2_sa_t *i2sa)
+{
+	for (size_t i = 0; i < I2SA_NUM_HASH; i++)
+		i2sa_hash_remove(i, i2sa);
+}
+
+/*
+ * Generate a hash value for a remote SA based off the
+ * address and remote SPI.
+ */
+static uint32_t
+i2sa_rhash(const struct sockaddr_storage *ss, uint64_t spi)
+{
+	uint32_t rc = remote_noise;
+	const uint32_t *ptr = (const uint32_t *)&spi;
+	sockaddr_u_t ssu;
+
+	rc ^= ptr[0];
+	rc ^= ptr[1];
+
+	ssu.sau_ss = (struct sockaddr_storage *)ss;
+	if (ss->ss_family == AF_INET6) {
+		ptr = (const uint32_t *)&ssu.sau_sin6->sin6_addr;
+		rc ^= ptr[0];
+		rc ^= ptr[1];
+		rc ^= ptr[2];
+		rc ^= ptr[3];
+	} else {
+		ASSERT(ss->ss_family == AF_INET);
+		rc ^= ssu.sau_sin->sin_addr.s_addr;
+	}
+
+	return (rc);
+}
+
+/*
+ * Increase the count of larval SAs.  If we reach our threshold for larval SAs,
+ * enable the use of cookies.
+ */
+static void
+inc_half_open(void)
+{
+	if (atomic_inc_uint_nv(&half_open) == ikev2_cookie_threshold)
+		ikev2_cookie_enable();
+}
+
+/*
+ * Decrease the count of larval SAs.  Disable cookies if the count falls
+ * below the threshold
+ */
+static void
+dec_half_open(void)
+{
+	/*
+	 * Instead of merely disabling cookies once we're below
+	 * ikev2_cookie_threshold half-open IKE SAs, we wait for
+	 * IKEV2_COOKIE_OFF_ADD additional half-open IKE SAs to
+	 * disappear to add a small amount of hysteresis and prevent
+	 * constantly flopping on and off once we're at the threshold.
+	 */
+	if (atomic_dec_uint_nv(&half_open) ==
+	    ikev2_cookie_threshold - IKEV2_COOKIE_OFF_ADJ)
+		ikev2_cookie_disable();
+}
+
+static int
+i2sa_ctor(void *buf, void *dummy, int flags)
+{
+	_NOTE(ARGUNUSUED(dummy, flags))
+
+	ikev2_sa_t *i2sa = buf;
+
+	(void) memset(i2sa, 0, sizeof (*i2sa));
+	i2sa->msgwin = 1;
+
+	VERIFY0(pthread_mutex_init(&i2sa->lock, NULL));
+	list_link_init(&i2sa->i2sa_lspi_node);
+	list_link_init(&i2sa->i2sa_rspi_node);
+
+	return (0);
+}
+
+static void
+i2sa_dtor(void *buf, void *dummy)
+{
+	_NOTE(ARGUNUSUED(dummy))
+
+	ikev2_sa_t *i2sa = (ikev2_sa_t *)buf;
+
+	VERIFY0(pthread_mutex_destroy(&i2sa->lock));
+}
+
+static int
+sockaddr_compare(const struct sockaddr_storage *restrict l,
+    const struct sockaddr_storage *restrict r)
+{
+	sockaddr_u_t lu;
+	sockaddr_u_t ru;
+	int cmp;
+
+	if (l->ss_family > r->ss_family)
+		return (1);
+	if (l->ss_family < r->ss_family)
+		return (-1);
+
+	lu.sau_ss = (struct sockaddr_storage *)l;
+	ru.sau_ss = (struct sockaddr_storage *)r;
+
+	if (l->ss_family == AF_INET) {
+		cmp = memcmp(&lu.sau_sin->sin_addr, &ru.sau_sin->sin_addr,
+		    sizeof (lu.sau_sin->sin_addr));
+		if (cmp > 0)
+			return (1);
+		if (cmp < 0)
+			return (-1);
+
+		if (lu.sau_sin->sin_port > ru.sau_sin->sin_port)
+			return (1);
+		if (lu.sau_sin->sin_port < ru.sau_sin->sin_port)
+			return (-1);
+		return (0);
+	}
+
+	ASSERT(l->ss_family == AF_INET6);
+
+	cmp = memcmp(&lu.sau_sin6->sin6_addr, &ru.sau_sin6->sin6_addr,
+	    sizeof (lu.sau_sin6->sin6_addr));
+	if (cmp > 0)
+		return (1);
+	if (cmp < 0)
+		return (-1);
+
+	if (lu.sau_sin6->sin6_port > ru.sau_sin6->sin6_port)
+		return (1);
+	if (lu.sau_sin6->sin6_port < ru.sau_sin6->sin6_port)
+		return (-1);
+	return (0);
+}
+
+static int
+i2sa_compare(const ikev2_sa_t *sa, const i2sa_cmp_t *cmp)
+{
+	if (cmp->ic_l_spi != 0) {
+		/*
+		 * Since we assign the local SPI, we enforce that
+		 * they are globally unique
+		 */
+		if (I2SA_LOCAL_SPI(sa) > cmp->ic_l_spi)
+			return (1);
+		if (I2SA_LOCAL_SPI(sa) < cmp->ic_l_spi)
+			return (-1);
+		return (0);
+	}
+
+	VERIFY3U(cmp->ic_r_spi, !=, 0);
+
+	if (I2SA_REMOTE_SPI(sa) > cmp->ic_r_spi)
+		return (1);
+	if (I2SA_REMOTE_SPI(sa) < cmp->ic_r_spi)
+		return (-1);
+
+	/* More likely to be different, so check these first */
+	int rc = sockaddr_compare(&sa->raddr, cmp->ic_raddr);
+	if (rc > 0)
+		return (1);
+	if (rc < 0)
+		return (-1);
+
+	/* A multihomed system might have different local addresses */
+	rc = sockaddr_compare(&sa->laddr, cmp->ic_laddr);
+	if (rc > 0)
+		return (1);
+	if (rc < 0)
+		return (-1);
+
+	/*
+	 * RFC5996 2.1 - We cannot merely rely on the remote SPI and
+	 * address as clients behind NATs might choose the same SPI by chance.
+	 * We must in addition look at the initial packet.  This is only
+	 * an issue for half-opened remotely initiated SAs, as this is the
+	 * only time the local SPI is not yet known.
+	 */
+	rc = memcmp(I2SA_REMOTE_INIT(sa)->pkt_raw,
+	    cmp->ic_init_pkt->pkt_raw,
+	    MIN(pkt_len(I2SA_REMOTE_INIT(sa)), pkt_len(cmp->ic_init_pkt)));
+	if (rc != 0)
+		return ((rc < 0) ? -1 : 1);
+	if (pkt_len(I2SA_REMOTE_INIT(sa)) < pkt_len(cmp->ic_init_pkt))
+		return (-1);
+	if (pkt_len(I2SA_REMOTE_INIT(sa)) > pkt_len(cmp->ic_init_pkt))
+		return (1);
+
+	return (0);
+}
+
+static boolean_t
+i2sa_key_add_addr(ikev2_sa_t *i2sa, const char *addr_key, const char *port_key,
+    const struct sockaddr_storage *addr)
+{
+	sockaddr_u_t sau;
+	sau.sau_ss = (struct sockaddr_storage *)addr;
+	int rc = 0;
+
+	switch (addr->ss_family) {
+	case AF_INET:
+		rc = bunyan_key_add(i2sa->i2sa_log,
+		    BUNYAN_T_IP, addr_key, &sau.sau_sin->sin_addr,
+		    BUNYAN_T_UINT32, port_key, (uint32_t)sau.sau_sin->sin_port,
+		    BUNYAN_T_END);
+		break;
+	case AF_INET6:
+		rc = bunyan_key_add(i2sa->i2sa_log,
+		    BUNYAN_T_IP6, addr_key, &sau.sau_sin6->sin6_addr,
+		    BUNYAN_T_UINT32, port_key,
+		    (uint32_t)sau.sau_sin6->sin6_port,
+		    BUNYAN_T_END);
+		break;
+	default:
+		INVALID("addr->ss_family");
+	}
+
+	return ((rc == 0) ? B_TRUE : B_FALSE);
+}
+
+void
+ikev2_sa_init(void)
+{
+	if ((i2sa_cache = umem_cache_create("IKEv2 SAs", sizeof (ikev2_sa_t),
+	    0, i2sa_ctor, i2sa_dtor, NULL, NULL, NULL, 0)) == NULL)
+		err(EXIT_FAILURE, "Unable to allocate IKEv2 SA cache");
+
+	/* XXX: Change to tunable */
+	ikev2_sa_set_hashsize(ikev2_sa_buckets);
+}
+
+void
+ikev2_sa_fini(void)
+{
+	umem_cache_destroy(i2sa_cache);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.h
new file mode 100644
index 0000000000..7b38e791d0
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa.h
@@ -0,0 +1,218 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2014 Jason King.
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#ifndef _IKEV2_SA_H
+#define	_IKEV2_SA_H
+
+#include <atomic.h>
+#include <security/cryptoki.h>
+#include <sys/list.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <stddef.h>
+#include <synch.h>
+#include <pthread.h>
+#include "defs.h"
+#include "ikev2.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+struct ikev2_sa_s;
+struct ikev2_child_sa;
+struct i2sa_bucket;
+struct pkt_s;
+
+#ifndef IKEV2_SA_T
+#define	IKEV2_SA_T
+typedef struct ikev2_sa_s ikev2_sa_t;
+typedef struct ikev2_child_sa ikev2_child_sa_t;
+typedef struct i2sa_bucket i2sa_bucket_t;
+#endif /* IKEV2_SA_T */
+
+struct config_rule_s;
+
+typedef enum i2sa_hash_e {
+	I2SA_LSPI	= 0,
+	I2SA_RHASH	= 1,
+} i2sa_hash_t;
+#define	I2SA_NUM_HASH	2	/* The number of IKEv2 SA hashes we have */
+
+#define	I2SA_SALT_LEN	(32)	/* Maximum size of salt, may be smaller */
+
+/*
+ * The IKEv2 SA.
+ *
+ * This is the central data structure to the IKEv2 daemon.  It is a
+ * reference-counted node, where the lookup key is either the local
+ * SPI/cookie, or a hash based on the remote address and remote SPI.  (See
+ * ikev2_pkt.h for the _SPI() macros.)  It should be allocated with a umem
+ * cache.  It contains a mutex to lock certain fields if need be.
+ *
+ * Because of the distinct sets of lookup keys, it requires two linkages.
+ */
+struct ikev2_sa_s {
+	pthread_mutex_t lock;
+	list_node_t	i2sa_lspi_node;
+	list_node_t	i2sa_rspi_node;
+
+	bunyan_logger_t	*i2sa_log;
+
+			/* Link to the bucket we are in for each hash */
+	i2sa_bucket_t	*bucket[I2SA_NUM_HASH];
+
+	struct config_rule_s	*i2sa_rule;
+
+	uint64_t		i_spi;	  /* Initiator SPI. */
+	uint64_t		r_spi;	  /* Responder SPI. */
+	uint32_t		flags;
+	volatile uint32_t	refcnt;
+
+	struct sockaddr_storage laddr;  /* Local address & port. */
+	struct sockaddr_storage raddr;  /* Remote address & port. */
+
+				/*
+				 * What IKEv2 daemon are we talking to.
+				 * Currently it is just used to determine if
+				 * we can validate padding in SK payloads.
+				 * If there are any additional custom behaviors
+				 * we want to support in the future, this
+				 * will probably need to evolve into
+				 * feature flags or such.
+				 */
+	vendor_t		vendor;
+
+	/* Current number of outstanding messages prior to outmsgid. */
+	int		msgwin;
+
+	ikev2_xf_encr_t	encr;		/* Encryption algorithm */
+	size_t		encr_key_len;	/* Key length (bytes) for encr */
+	ikev2_xf_auth_t	auth;		/* Authentication algorithm */
+	ikev2_prf_t	prf;		/* PRF algorithm */
+	ikev2_dh_t	dhgrp;		/* Diffie-Hellman group. */
+
+	uint32_t	outmsgid;	/* Next msgid for outbound packets. */
+	uint32_t	inmsgid;	/* Next expected inbound msgid. */
+
+	struct pkt_s	*init_i;  	/* IKE_SA_INIT packet. */
+	struct pkt_s	*init_r;
+	struct pkt_s	*last_resp_sent;
+	struct pkt_s	*last_sent;
+	struct pkt_s	*last_recvd;
+
+	time_t		birth;		/* When was AUTH completed */
+	hrtime_t	softexpire;
+	hrtime_t	hardexpire;
+
+	ikev2_child_sa_t	*child_sas;
+
+	CK_OBJECT_HANDLE dh_pubkey;
+	CK_OBJECT_HANDLE dh_privkey;
+	CK_OBJECT_HANDLE dh_key;
+	CK_OBJECT_HANDLE sk_d;
+	CK_OBJECT_HANDLE sk_ai;
+	CK_OBJECT_HANDLE sk_ar;
+	CK_OBJECT_HANDLE sk_ei;
+	CK_OBJECT_HANDLE sk_er;
+	CK_OBJECT_HANDLE sk_pi;
+	CK_OBJECT_HANDLE sk_pr;
+
+	/* Salt size may be smaller, but no larger than I2SA_SALT_LEN */
+	uint8_t		salt_i[I2SA_SALT_LEN];
+	uint8_t		salt_r[I2SA_SALT_LEN];
+	size_t		saltlen;
+};
+
+struct ikev2_child_sa {
+	ikev2_child_sa_t	*next;
+	ikev2_spi_proto_t	i2c_satype;
+	uint32_t		i2c_spi;
+
+	/* Nonces */
+	uint8_t			i2c_ni[IKEV2_NONCE_MAX];
+	size_t			i2c_nilen;
+	uint8_t			i2c_nr[IKEV2_NONCE_MAX];
+	size_t			i2c_nrlen;
+	/* XXX: more to come probably */
+};
+
+/* SA flags */
+#define	I2SA_INITIATOR		0x1	/* Am I the initiator of this IKE SA? */
+#define	I2SA_NAT_LOCAL		0x2	/* I am behind a NAT. */
+#define	I2SA_NAT_REMOTE		0x4	/* My peer is behind a NAT. */
+#define	I2SA_CONDEMNED		0x8	/* SA is unlinked from a tree. */
+#define	I2SA_AUTHENTICATED	0x10	/* SA has been authenticated */
+
+#define	I2SA_LOCAL_SPI(i2sa) \
+	(((i2sa)->flags & I2SA_INITIATOR) ? (i2sa)->i_spi : \
+	    (i2sa)->r_spi)
+
+#define	I2SA_REMOTE_SPI(i2sa) \
+	(((i2sa)->flags & I2SA_INITIATOR) ? (i2sa)->r_spi : \
+	    (i2sa)->i_spi)
+
+#define	I2SA_REMOTE_INIT(i2sa) \
+	(((i2sa)->flags & I2SA_INITIATOR) ? (i2sa)->init_r : \
+	    (i2sa)->init_i)
+
+#define	I2SA_IS_NAT(i2sa) \
+	(!!((i2sa)->flags & (I2SA_NAT_LOCAL|I2SA_NAT_REMOTE)))
+
+#define	I2SA_REFHOLD(i2sa) \
+	atomic_inc_32(&(i2sa)->refcnt)
+
+/* Stupid C tricks stolen from <assert.h>. */
+#define	I2SA_REFRELE(i2sa) \
+	(void) ((atomic_dec_32_nv(&(i2sa)->refcnt) != 0) || \
+	    (ikev2_sa_free(i2sa), 0))
+
+extern size_t ikev2_sa_buckets;		/* Number of HASH buckets */
+
+ikev2_sa_t *ikev2_sa_get(uint64_t, uint64_t,
+    const struct sockaddr_storage *restrict,
+    const struct sockaddr_storage *restrict,
+    const struct pkt_s *restrict);
+ikev2_sa_t *ikev2_sa_alloc(boolean_t, struct pkt_s *restrict,
+    const struct sockaddr_storage *restrict,
+    const struct sockaddr_storage *restrict);
+
+void	ikev2_sa_start_timer(ikev2_sa_t *);
+void	ikev2_sa_set_remote_spi(ikev2_sa_t *, uint64_t);
+void	ikev2_sa_free(ikev2_sa_t *);
+void	ikev2_sa_condemn(ikev2_sa_t *);
+
+void	ikev2_sa_flush(void);
+void	ikev2_sa_set_hashsize(uint_t);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif  /* _IKEV2_SA_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa_init.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa_init.c
new file mode 100644
index 0000000000..f2afa336c5
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ikev2_sa_init.c
@@ -0,0 +1,867 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+#include <pthread.h>
+#include <umem.h>
+#include <err.h>
+#include <sys/debug.h>
+#include <bunyan.h>
+#include <time.h>
+#include <string.h>
+#include "defs.h"
+#include "worker.h"
+#include "pkt.h"
+#include "timer.h"
+#include "pkcs11.h"
+#include "ikev2_proto.h"
+#include "ikev2_sa.h"
+#include "config.h"
+#include "ikev2_pkt.h"
+#include "ikev2_enum.h"
+#include "ikev2_common.h"
+#include "prf.h"
+#include "dh.h"
+
+static void ikev2_sa_init_inbound_init(pkt_t *);
+static void ikev2_sa_init_inbound_resp(pkt_t *);
+
+static boolean_t find_config(pkt_t *, sockaddr_u_t, sockaddr_u_t);
+static boolean_t add_nat(pkt_t *);
+static boolean_t check_nats(pkt_t *);
+static void check_vendor(pkt_t *);
+static boolean_t add_vendor(pkt_t *);
+static boolean_t add_cookie(pkt_t *restrict, void *restrict, size_t len);
+static boolean_t ikev2_sa_keygen(ikev2_sa_result_t *restrict, pkt_t *restrict,
+    pkt_t *restrict);
+
+void
+ikev2_sa_init_inbound(pkt_t *pkt)
+{
+	if (pkt_header(pkt)->flags & IKEV2_FLAG_INITIATOR)
+		ikev2_sa_init_inbound_init(pkt);
+	else
+		ikev2_sa_init_inbound_resp(pkt);
+}
+
+/*
+ * New inbound IKE_SA_INIT exchange, we are the responder.
+ */
+static void
+ikev2_sa_init_inbound_init(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	pkt_t *resp = NULL;
+	sockaddr_u_t laddr = { .sau_ss = &sa->laddr };
+	sockaddr_u_t raddr = { .sau_ss = &sa->raddr };
+	pkt_payload_t *ke_i = pkt_get_payload(pkt, IKEV2_PAYLOAD_KE, NULL);
+	ikev2_sa_result_t sa_result = { 0 };
+	size_t noncelen = 0;
+
+	/* Verify inbound sanity checks */
+	VERIFY(!(sa->flags & I2SA_INITIATOR));
+	VERIFY3P(ke_i, !=, NULL);
+
+	bunyan_info(sa->i2sa_log,
+	    "Starting new IKE_SA_INIT exchange as responder",
+	    BUNYAN_T_END);
+
+	if (!find_config(pkt, laddr, raddr))
+		goto fail;
+	if (!check_nats(pkt))
+		goto fail;
+	check_vendor(pkt);
+
+	if (!ikev2_sa_match_rule(sa->i2sa_rule, pkt, &sa_result)) {
+		/*
+		 * It seems very unlikely that an initiator will be able to
+		 * react and resend a new payload in this situation (as opposed
+		 * to a DH group mismatch or if we were to respond with a
+		 * cookie).  Therefore, we can delete the larval IKE SA.
+		 */
+		ikev2_no_proposal_chosen(sa, pkt, IKEV2_PROTO_IKE, 0);
+		goto fail;
+	}
+
+	/*
+	 * A bit annoying, but it's possible the negotiated DH group is
+	 * different than the public key value that was sent in the IKE_SA_INIT
+	 * exchange.  In that case, we respond with an INVALID_KE_PAYLOAD
+	 * notification and include the result we want.  In this instance, we
+	 * expect that the initiator will respond with a new KE payload
+	 * containing the desired DH group (and otherwise identical).
+	 * Therefore, keep the larval IKE SA around until we either proceed to
+	 * an AUTH exchange, or we time out.
+	 */
+	if (ikev2_get_dhgrp(pkt) != sa_result.sar_dh) {
+		ikev2_invalid_ke(pkt, IKEV2_PROTO_IKE, 0, sa_result.sar_dh);
+		ikev2_pkt_free(pkt);
+		return;
+	}
+
+	sa->init_i = pkt;
+
+	/* RFC7296 2.10 nonce length should be at least half key size of PRF */
+	noncelen = ikev2_prf_keylen(sa_result.sar_prf) / 2;
+
+	/* But must still be within defined limits */
+	if (noncelen < IKEV2_NONCE_MIN)
+		noncelen = IKEV2_NONCE_MIN;
+	if (noncelen > IKEV2_NONCE_MAX)
+		noncelen = IKEV2_NONCE_MAX;
+
+	resp = ikev2_pkt_new_response(pkt);
+	if (resp == NULL)
+		goto fail;
+
+	/*
+	 * The packet response functions take their SPI values from the
+	 * initating packet, so for this one instance we must set it
+	 * manually since the initiator doesn't yet know our local SPI.
+	 */
+	pkt_header(resp)->responder_spi = I2SA_LOCAL_SPI(sa);
+
+	if (!ikev2_sa_add_result(resp, &sa_result))
+		goto fail;
+	/*
+	 * While premissible, we do not currently reuse DH exponentials.  Since
+	 * generating them is a potentially an expensive operation, we wait
+	 * until necessary to create them.
+	 */
+	if (!dh_genpair(sa_result.sar_dh, &sa->dh_pubkey, &sa->dh_privkey,
+	    sa->i2sa_log))
+		goto fail;
+	if (!dh_derivekey(sa->dh_privkey, ke_i->pp_ptr + sizeof (ikev2_ke_t),
+	    ke_i->pp_len - sizeof (ikev2_ke_t), &sa->dh_key, sa->i2sa_log))
+		goto fail;
+	if (!ikev2_add_ke(resp, sa_result.sar_dh, sa->dh_pubkey))
+		goto fail;
+
+	if (!ikev2_add_nonce(resp, NULL, noncelen))
+		goto fail;
+	if (!add_nat(resp))
+		goto fail;
+
+	/* XXX: CERTREQ? */
+	/* XXX: other notifications */
+
+	if (!add_vendor(resp))
+		goto fail;
+
+	if (!ikev2_sa_keygen(&sa_result, pkt, resp))
+		goto fail;
+	if (!ikev2_send(resp, B_FALSE))
+		goto fail;
+
+	sa->init_r = resp;
+	return;
+
+fail:
+	(void) bunyan_error(sa->i2sa_log,
+	    "Could not send response in IKE_SA_INIT exchange",
+	    BUNYAN_T_END);
+
+	sa->init_r = NULL;
+	ikev2_sa_condemn(sa);
+	ikev2_pkt_free(pkt);
+	ikev2_pkt_free(resp);
+	/* XXX: Anything else? */
+}
+
+/*
+ * If we get a cookie request or a new DH group in response to our
+ * initiated IKE_SA_INIT exchange, restart with the new parameters.
+ *
+ * XXX: Better name?
+ */
+static boolean_t
+redo_init(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	pkt_notify_t *cookie = pkt_get_notify(pkt, IKEV2_N_COOKIE, NULL);
+	pkt_notify_t *invalid_ke = pkt_get_notify(pkt,
+	    IKEV2_N_INVALID_KE_PAYLOAD, NULL);
+
+	if (cookie == NULL && invalid_ke == NULL)
+		return (B_FALSE);
+
+	pkt_t *out = sa->init_i;
+	pkt_payload_t *nonce = pkt_get_payload(out, IKEV2_PAYLOAD_NONCE, NULL);
+	ikev2_dh_t dh = IKEV2_DH_NONE;
+
+	sa->init_i = NULL;
+
+	if (invalid_ke != NULL) {
+		if (invalid_ke->pn_len != sizeof (uint16_t)) {
+			/*
+			 * The notification does not have the correct format
+			 */
+			bunyan_info(sa->i2sa_log,
+			    "INVALID_KE_PAYLOAD notification does not "
+			    "include a 16-bit DH group payload",
+			    BUNYAN_T_UINT32, "ntfylen",
+			    (uint32_t)invalid_ke->pn_len, BUNYAN_T_END);
+
+			/* We will just ignore it for now */
+			ikev2_pkt_free(pkt);
+			return (B_FALSE);
+		}
+
+		uint16_t val = BE_IN16(invalid_ke->pn_ptr);
+		dh = val;
+	}
+
+	(void) cancel_timeout(TE_TRANSMIT, out, sa->i2sa_log);
+	ikev2_sa_init_outbound(sa, cookie->pn_ptr, cookie->pn_len,
+	    dh, nonce->pp_ptr, nonce->pp_len);
+
+	ikev2_pkt_free(pkt);
+	ikev2_pkt_free(out);
+	return (B_TRUE);
+}
+
+/*
+ * We initiated the IKE_SA_INIT exchange, this is the remote response
+ */
+static void
+ikev2_sa_init_inbound_resp(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	pkt_payload_t *ke_r = pkt_get_payload(pkt, IKEV2_PAYLOAD_KE, NULL);
+	ikev2_sa_result_t sa_result = { 0 };
+
+	if (pkt_get_notify(pkt, IKEV2_N_NO_PROPOSAL_CHOSEN, NULL) != NULL) {
+		bunyan_error(sa->i2sa_log,
+		    "IKE_SA_INIT exchange failed, no proposal chosen",
+		    BUNYAN_T_END);
+		ikev2_sa_condemn(sa);
+		ikev2_pkt_free(pkt);
+		return;
+	}
+
+	/* Did we get a request for cookies or a new DH group? */
+	if (redo_init(pkt))
+		return;
+	if (!check_nats(pkt))
+		goto fail;
+	check_vendor(pkt);
+
+	if (!ikev2_sa_match_rule(sa->i2sa_rule, pkt, &sa_result)) {
+		/*
+		 * XXX: Tried to send back something that wasn't in the propsals
+		 * we sent.  What should we do?  Just destroy the IKE SA?
+		 * Ignore?  For now ignore and hope a valid answer comes
+		 * back before we timeout.
+		 */
+		ikev2_pkt_free(pkt);
+		return;
+	}
+
+	if (!dh_derivekey(sa->dh_privkey, ke_r->pp_ptr, ke_r->pp_len,
+	    &sa->dh_key, sa->i2sa_log))
+		goto fail;
+	if (!ikev2_sa_keygen(&sa_result, sa->init_i, pkt))
+		goto fail;
+
+	ikev2_sa_set_remote_spi(sa, INBOUND_REMOTE_SPI(pkt_header(pkt)));
+	sa->init_r = pkt;
+	return;
+
+fail:
+	ikev2_sa_condemn(sa);
+	ikev2_pkt_free(pkt);
+	/* XXX: Anything else? */
+}
+
+/*
+ * Start a new IKE_SA_INIT using the given larval refheld IKE SA.
+ * The other parameters are normally NULL / 0 and are used when the response
+ * requests a cookie or a new DH group.
+ */
+void
+ikev2_sa_init_outbound(ikev2_sa_t *restrict i2sa, uint8_t *restrict cookie,
+    size_t cookielen, ikev2_dh_t dh, uint8_t *restrict nonce, size_t noncelen)
+{
+	pkt_t *pkt = NULL;
+	sockaddr_u_t laddr = { .sau_ss = &i2sa->laddr };
+	sockaddr_u_t raddr = { .sau_ss = &i2sa->raddr };
+
+	if (nonce == NULL) {
+		bunyan_info(i2sa->i2sa_log,
+		    "Starting new IKE_SA_INIT exchange as initiator",
+		    BUNYAN_T_END);
+	}
+
+	VERIFY(i2sa->flags & I2SA_INITIATOR);
+
+	pkt = ikev2_pkt_new_exchange(i2sa, IKEV2_EXCH_IKE_SA_INIT);
+
+	if (!find_config(pkt, laddr, raddr))
+		goto fail;
+
+	if (!add_cookie(pkt, cookie, cookielen))
+		goto fail;
+
+	if (!ikev2_sa_from_rule(pkt, i2sa->i2sa_rule, 0))
+		goto fail;
+
+	/* These will do nothing if there isn't an existing key */
+	pkcs11_destroy_obj("dh_pubkey", &i2sa->dh_pubkey, i2sa->i2sa_log);
+	pkcs11_destroy_obj("dh_privkey", &i2sa->dh_privkey, i2sa->i2sa_log);
+
+	/* Start with the first DH group in the first rule */
+	if (dh == IKEV2_DH_NONE)
+		dh = i2sa->i2sa_rule->rule_xf[0]->xf_dh;
+
+	if (!dh_genpair(dh, &i2sa->dh_pubkey, &i2sa->dh_privkey,
+	    i2sa->i2sa_log))
+		goto fail;
+
+	if (!ikev2_add_ke(pkt, dh, i2sa->dh_pubkey))
+		goto fail;
+
+	/*
+	 * XXX: This is half the largest keysize of all the PRF functions
+	 * we support.
+	 */
+	if (noncelen == 0)
+		noncelen = 32;
+
+	if (!ikev2_add_nonce(pkt, nonce, noncelen))
+		goto fail;
+	if (!add_nat(pkt))
+		goto fail;
+	if (!add_vendor(pkt))
+		goto fail;
+
+	/* XXX: CERTREQ */
+
+	i2sa->init_i = pkt;
+
+	if (!ikev2_send(pkt, B_FALSE))
+		goto fail;
+
+	I2SA_REFRELE(i2sa);
+	return;
+
+fail:
+	i2sa->init_i = NULL;
+	ikev2_sa_condemn(i2sa);
+	ikev2_pkt_free(pkt);
+	I2SA_REFRELE(i2sa);
+}
+
+static boolean_t
+find_config(pkt_t *pkt, sockaddr_u_t laddr, sockaddr_u_t raddr)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+
+	if (sa->i2sa_rule != NULL)
+		goto done;
+
+	sa->i2sa_rule = config_get_rule(laddr, raddr);
+
+done:
+	if (RULE_IS_DEFAULT(sa->i2sa_rule)) {
+		bunyan_debug(sa->i2sa_log, "Using default rule", BUNYAN_T_END);
+	} else {
+		bunyan_debug(sa->i2sa_log, "Found rule",
+		    BUNYAN_T_STRING, "label", sa->i2sa_rule->rule_label,
+		    BUNYAN_T_END);
+	}
+
+	if (sa->i2sa_rule->rule_nxf == 0) {
+		bunyan_debug(sa->i2sa_log, "No transforms found", BUNYAN_T_END);
+		ikev2_no_proposal_chosen(sa, pkt, IKEV2_PROTO_IKE, 0);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * Size of a SHA1 hash.  NAT detection always uses SHA1 to compute the
+ * NAT detection payload contents.
+ */
+#define	NAT_LEN	(20)
+
+/* Compute a NAT detection payload and place result into buf */
+static boolean_t
+compute_nat(uint64_t *restrict spi, struct sockaddr_storage *restrict addr,
+    uint8_t *restrict buf, size_t buflen, bunyan_logger_t *l)
+{
+	const char *p11f = NULL;
+	CK_SESSION_HANDLE h = p11h();
+	CK_MECHANISM mech = {
+		.mechanism = CKM_SHA_1,
+		.pParameter = NULL_PTR,
+		.ulParameterLen = 0
+	};
+	CK_BYTE_PTR addrp = (CK_BYTE_PTR)ss_addr(addr);
+	CK_ULONG len = buflen;
+	CK_RV ret = CKR_OK;
+	size_t addrlen = (addr->ss_family == AF_INET) ?
+	    sizeof (in_addr_t) : sizeof (in6_addr_t);
+	uint16_t port = (addr->ss_family == AF_INET) ?
+	    ((struct sockaddr_in *)addr)->sin_port :
+	    ((struct sockaddr_in6 *)addr)->sin6_port;
+
+	VERIFY3U(buflen, >=, NAT_LEN);
+	VERIFY(addr->ss_family == AF_INET || addr->ss_family == AF_INET6);
+
+	p11f = "C_DigestInit";
+	ret = C_DigestInit(h, &mech);
+	if (ret != CKR_OK)
+		goto fail;
+
+	/* Both SPIs (in order) */
+	p11f = "C_DigestUpdate";
+	ret = C_DigestUpdate(h, (CK_BYTE_PTR)spi, 2 * sizeof (uint64_t));
+	if (ret != CKR_OK)
+		goto fail;
+
+	ret = C_DigestUpdate(h, addrp, addrlen);
+	if (ret != CKR_OK)
+		goto fail;
+
+	ret = C_DigestUpdate(h, (CK_BYTE_PTR)&port, sizeof (port));
+	if (ret != CKR_OK)
+		goto fail;
+
+	p11f = "C_DigestFinal";
+	ret = C_DigestFinal(h, buf, &len);
+	if (ret != CKR_OK)
+		goto fail;
+
+	return (B_TRUE);
+
+fail:
+	PKCS11ERR(error, l, p11f, ret);
+	return (B_FALSE);
+}
+
+/*
+ * Perform NAT detection and update IKEV2 SA accordingly.  Return B_FALSE on
+ * error, B_TRUE if no error.
+ */
+static boolean_t
+check_nats(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	struct {
+		ikev2_notify_type_t	ntype;
+		struct sockaddr_storage *addr;
+		const char		*msg;
+		uint32_t		flag;
+	} params[] = {
+		/*
+		 * Since these are from the perspective of the remote system,
+		 * we check the local address against the NAT destination IP
+		 * and vice versa.
+		 */
+		{
+			IKEV2_N_NAT_DETECTION_DESTINATION_IP,
+			&pkt->pkt_sa->laddr,
+			"Local NAT detected",
+			I2SA_NAT_LOCAL
+		},
+		{
+			IKEV2_N_NAT_DETECTION_SOURCE_IP,
+			&pkt->pkt_sa->raddr,
+			"Remote NAT detected",
+			I2SA_NAT_REMOTE
+		}
+	};
+
+	/*
+	 * RFC7296 2.23 goes into more detail, but briefly, each side
+	 * generates an SHA1 hash of the packet SPIs (in the order they
+	 * appear in the header), the IP address of the source/destination
+	 * (based on which NAT payload is being constructed) and port number.
+	 * It is permissible that an implementation may include multiple
+	 * NAT_DETECTION_SOURCE_IP payloads if the host has multiple addresses
+	 * and is unsure which one was used to send the datagram.
+	 *
+	 * We perform the same hash (using the IP and port we see) and if
+	 * there are no matches, then the side (local/remote) being checked
+	 * is behind a NAT.  If either side is behind a NAT,  we switch to
+	 * using the NATT port (4500) for all subsequent traffic.
+	 *
+	 * While the presense of a NAT on one side of the connection is all
+	 * that is necessary to switch to NAT traversal mode, we still
+	 * retain knowledge of which side is behind the NAT as we will
+	 * (eventually) want to enable UDP keepalives when we are the ones
+	 * behind a NAT.
+	 */
+	for (size_t i = 0; i < 2; i++) {
+		pkt_notify_t *n = pkt_get_notify(pkt, params[i].ntype, NULL);
+		uint8_t data[NAT_LEN] = { 0 };
+		boolean_t match = B_FALSE;
+
+		/* If notification isn't present, assume no NAT */
+		if (n == NULL)
+			continue;
+
+		if (!compute_nat(pkt->pkt_raw, params[i].addr, data,
+		    sizeof (data), sa->i2sa_log))
+			return (B_FALSE);
+
+		while (n != NULL) {
+			/*
+			 * XXX: Should these validation failures just ignore
+			 * the individual payload, or discard the packet
+			 * entirely?
+			 */
+			if (n->pn_proto != IKEV2_PROTO_IKE) {
+				bunyan_error(sa->i2sa_log,
+				    "Invalid SPI protocol in notification",
+				    BUNYAN_T_STRING, "notification",
+				    ikev2_notify_str(params[i].ntype),
+				    BUNYAN_T_STRING, "protocol",
+				    ikev2_spi_str(n->pn_proto),
+				    BUNYAN_T_UINT32, "protonum",
+				    (uint32_t)n->pn_proto, BUNYAN_T_END);
+				return (B_FALSE);
+			}
+			if (n->pn_spi != 0) {
+				bunyan_error(sa->i2sa_log,
+				    "Non-zero SPI size in NAT notification",
+				    BUNYAN_T_STRING, "notification",
+				    ikev2_notify_str(params[i].ntype),
+				    BUNYAN_T_END);
+				return (B_FALSE);
+			}
+			if (n->pn_len != NAT_LEN) {
+				bunyan_error(sa->i2sa_log,
+				    "NAT notification size mismatch",
+				    BUNYAN_T_STRING, "notification",
+				    ikev2_notify_str(params[i].ntype),
+				    BUNYAN_T_UINT32, "notifylen",
+				    (uint32_t)n->pn_len,
+				    BUNYAN_T_UINT32, "expected",
+				    (uint32_t)NAT_LEN,
+				    BUNYAN_T_END);
+				return (B_FALSE);
+			}
+
+			/* If we have a match, update the respective */
+			if (memcmp(data, n->pn_ptr, NAT_LEN) == 0) {
+				match = B_TRUE;
+				break;
+			}
+
+			n = pkt_get_notify(pkt, params[i].ntype, n);
+		}
+
+		if (!match) {
+			sa->flags |= params[i].flag;
+			bunyan_debug(sa->i2sa_log, params[i].msg, BUNYAN_T_END);
+		}
+	}
+
+	/* Switch to using the NAT port if either side is NATted */
+	if (sa->flags & (I2SA_NAT_LOCAL|I2SA_NAT_REMOTE)) {
+		sockaddr_u_t local_addr = { .sau_ss = &sa->laddr };
+		sockaddr_u_t remote_addr = { .sau_ss = &sa->raddr };
+
+		VERIFY3S(local_addr.sau_ss->ss_family, ==,
+		    remote_addr.sau_ss->ss_family);
+
+		switch (local_addr.sau_ss->ss_family) {
+		case AF_INET:
+			local_addr.sau_sin->sin_port = htons(IPPORT_IKE_NATT);
+			remote_addr.sau_sin->sin_port = htons(IPPORT_IKE_NATT);
+			break;
+		case AF_INET6:
+			local_addr.sau_sin6->sin6_port = htons(IPPORT_IKE_NATT);
+			remote_addr.sau_sin6->sin6_port =
+			    htons(IPPORT_IKE_NATT);
+			break;
+		default:
+			INVALID("ss_family");
+		}
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * RFC7296 2.23 -- Add NAT detection notifiation payloads.  The notification
+ * payload consists of the SHA-1 has of the SPIs (in order as they appear in
+ * the header), IP address, and port.
+ */
+static boolean_t
+add_nat(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	struct {
+		ikev2_notify_type_t	ntype;
+		struct sockaddr_storage *addr;
+	} params[] = {
+		/*
+		 * Since these are from our perspective, the local address
+		 * corresponds to the source address and remote to the
+		 * destination address.
+		 */
+		{
+			IKEV2_N_NAT_DETECTION_SOURCE_IP,
+			&pkt->pkt_sa->laddr,
+		},
+		{
+			IKEV2_N_NAT_DETECTION_DESTINATION_IP,
+			&pkt->pkt_sa->raddr,
+		}
+	};
+
+	for (int i = 0; i < 2; i++) {
+		uint8_t data[NAT_LEN] = { 0 };
+
+		/* The SPIs are always at the start of the packet */
+		if (!compute_nat(pkt->pkt_raw, params[i].addr, data,
+		    sizeof (data), sa->i2sa_log))
+			return (B_FALSE);
+
+		if (!ikev2_add_notify(pkt, IKEV2_PROTO_IKE, 0, params[i].ntype,
+		    data, sizeof (data)))
+			return (B_FALSE);
+	}
+	return (B_TRUE);
+
+fail:
+	return (B_FALSE);
+}
+
+static void
+check_vendor(pkt_t *pkt)
+{
+	ikev2_sa_t *sa = pkt->pkt_sa;
+	pkt_payload_t *pay = NULL;
+
+	for (pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_VENDOR, NULL);
+	    pay != NULL;
+	    pay = pkt_get_payload(pkt, IKEV2_PAYLOAD_VENDOR, pay)) {
+		if (pay->pp_len != sizeof (VENDOR_STR_ILLUMOS_1))
+			continue;
+
+		if (memcmp(VENDOR_STR_ILLUMOS_1, pay->pp_ptr,
+		    sizeof (VENDOR_STR_ILLUMOS_1)) == 0) {
+			bunyan_debug(sa->i2sa_log,
+			    "Found illumos_1 vendor payload", BUNYAN_T_END);
+			sa->vendor = VENDOR_ILLUMOS_1;
+		}
+	}
+}
+
+static boolean_t
+add_vendor(pkt_t *pkt)
+{
+	return (ikev2_add_vendor(pkt, (uint8_t *)VENDOR_STR_ILLUMOS_1,
+	    sizeof (VENDOR_STR_ILLUMOS_1)));
+}
+
+static boolean_t
+add_cookie(pkt_t *restrict pkt, void *restrict cookie, size_t len)
+{
+	if (cookie == NULL)
+		return (B_TRUE);
+
+	/* Should be the first payload */
+	VERIFY3U(pkt->pkt_payload_count, ==, 0);
+
+	return (ikev2_add_notify(pkt, IKEV2_PROTO_IKE, 0, IKEV2_N_COOKIE,
+	    cookie, len));
+}
+
+static size_t
+skeyseed_noncelen(ikev2_prf_t prf, size_t len)
+{
+	switch (prf) {
+	/*
+	 * RFC7296 2.14 - For these PRFs, only the first 64 bits of Ni and Nr
+	 * are used when calculating skeyseed, though all bits are used for
+	 * the prf+ function
+	 */
+	case IKEV2_PRF_AES128_XCBC:
+	case IKEV2_PRF_AES128_CMAC:
+		if (len > 8)
+			return (8);
+		/*FALLTHRU*/
+	default:
+		return (len);
+	}
+}
+
+/* Create a PKCS#11 object of Ni | Nr */
+static boolean_t
+create_nonceobj(ikev2_prf_t prf, pkt_payload_t *restrict ni,
+    pkt_payload_t *restrict nr, CK_OBJECT_HANDLE_PTR restrict objp,
+    bunyan_logger_t *restrict l)
+{
+	size_t noncelen = MAX(ni->pp_len + nr->pp_len, ikev2_prf_outlen(prf));
+	uint8_t nonce[noncelen];
+	size_t ni_len = skeyseed_noncelen(prf, ni->pp_len);
+	size_t nr_len = skeyseed_noncelen(prf, nr->pp_len);
+	CK_RV rc;
+
+	(void) memset(nonce, 0, noncelen);
+	(void) memcpy(nonce, ni->pp_ptr, ni_len);
+	(void) memcpy(nonce + ni_len, nr->pp_ptr, nr_len);
+	rc = SUNW_C_KeyToObject(p11h(), ikev2_prf_to_p11(prf), nonce, noncelen,
+	    objp);
+	explicit_bzero(nonce, noncelen);
+
+	if (rc != CKR_OK)
+		PKCS11ERR(error, l, "SUNW_C_KeyToObject", rc,
+		    BUNYAN_T_STRING, "objname", "Ni|Nr");
+
+	return ((rc == CKR_OK) ? B_TRUE : B_FALSE);
+}
+
+static boolean_t
+create_skeyseed(ikev2_sa_t *restrict sa, CK_OBJECT_HANDLE nonce,
+    CK_OBJECT_HANDLE_PTR restrict keyp)
+{
+	CK_SESSION_HANDLE h = p11h();
+	uint8_t *dh_key = NULL, *skeyseed = NULL;
+	size_t dh_key_len = 0, skeyseed_len = 0;
+	CK_RV rc = CKR_OK;
+	boolean_t ok = B_TRUE;
+
+	skeyseed_len = ikev2_prf_outlen(sa->prf);
+	skeyseed = umem_zalloc(skeyseed_len, UMEM_DEFAULT);
+	if (skeyseed == NULL)
+		goto fail;
+
+	/*
+	 * Unfortunately, to generate SKEYSEED, we need to copy down the g^ir
+	 * value to perform the prf function since there is no C_SignKey
+	 * function in PKCS#11. As such we try to keep the value in memory for
+	 * as short a time as possible.
+	 */
+	rc = pkcs11_ObjectToKey(h, sa->dh_key, (void **)&dh_key, &dh_key_len,
+	    B_FALSE);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, sa->i2sa_log, "pkcs11_ObjectToKey", rc,
+		    BUNYAN_T_STRING, "objname", "dh_key");
+		goto fail;
+	}
+
+	ok = prf(sa->prf, nonce, skeyseed, skeyseed_len, sa->i2sa_log, dh_key,
+	    dh_key_len, NULL);
+	explicit_bzero(dh_key, dh_key_len);
+	free(dh_key);
+	dh_key = NULL;
+	dh_key_len = 0;
+
+	if (!ok) {
+		explicit_bzero(skeyseed, skeyseed_len);
+		goto fail;
+	}
+
+	rc = SUNW_C_KeyToObject(h, ikev2_prf_to_p11(sa->prf), skeyseed,
+	    skeyseed_len, keyp);
+	explicit_bzero(skeyseed, skeyseed_len);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, sa->i2sa_log, "SUNW_C_KeyToObject", rc,
+		    BUNYAN_T_STRING, "objname", "skeyseed");
+		goto fail;
+	}
+
+	(void) bunyan_trace(sa->i2sa_log, "Created SKEYSEED", BUNYAN_T_END);
+
+	return (B_TRUE);
+
+fail:
+	if (dh_key != NULL) {
+		explicit_bzero(dh_key, dh_key_len);
+		free(dh_key);
+	}
+	if (skeyseed != NULL) {
+		explicit_bzero(skeyseed, skeyseed_len);
+		umem_free(skeyseed, skeyseed_len);
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+ikev2_sa_keygen(ikev2_sa_result_t *restrict result, pkt_t *restrict init,
+    pkt_t *restrict resp)
+{
+	ikev2_sa_t *sa = resp->pkt_sa;
+	pkt_payload_t *ni = pkt_get_payload(init, IKEV2_PAYLOAD_NONCE, NULL);
+	pkt_payload_t *nr = pkt_get_payload(resp, IKEV2_PAYLOAD_NONCE, NULL);
+	CK_SESSION_HANDLE h = p11h();
+	CK_OBJECT_HANDLE nonce = CK_INVALID_HANDLE;
+	CK_OBJECT_HANDLE skeyseed = CK_INVALID_HANDLE;
+	size_t encrlen = result->sar_encr_keylen;
+	size_t prflen = ikev2_prf_keylen(result->sar_prf);
+	size_t authlen = auth_data[result->sar_auth].ad_keylen;
+	int p11prf = ikev2_prf_to_p11(result->sar_prf);
+	int p11encr = encr_data[result->sar_encr].ed_p11id;
+	int p11auth = auth_data[result->sar_auth].ad_p11id;
+	prfp_t prfp = { 0 };
+
+	if (encrlen == 0)
+		encrlen = encr_data[sa->encr].ed_keydefault;
+
+	sa->encr = result->sar_encr;
+	sa->auth = result->sar_auth;
+	sa->prf = result->sar_prf;
+	sa->dhgrp = result->sar_dh;
+	sa->saltlen = encr_data[result->sar_encr].ed_saltlen;
+	sa->encr_key_len = encrlen / 8;
+
+	if (!create_nonceobj(sa->prf, ni, nr, &nonce, sa->i2sa_log))
+		goto fail;
+	if (!create_skeyseed(sa, nonce, &skeyseed))
+		goto fail;
+	pkcs11_destroy_obj("Ni|Nr", &nonce, sa->i2sa_log);
+
+	if (!prfplus_init(&prfp, sa->prf, skeyseed, sa->i2sa_log,
+	    ni->pp_ptr, (size_t)ni->pp_len,
+	    nr->pp_ptr, (size_t)nr->pp_len,
+	    pkt_start(init), sizeof (uint64_t) * 2, NULL))
+		goto fail;
+	if (!prf_to_p11key(&prfp, "SK_d", p11prf, prflen, &sa->sk_d))
+		goto fail;
+	if (!prf_to_p11key(&prfp, "SK_ai", p11auth, authlen, &sa->sk_ai))
+		goto fail;
+	if (!prf_to_p11key(&prfp, "SK_ar", p11auth, authlen, &sa->sk_ar))
+		goto fail;
+	if (!prf_to_p11key(&prfp, "SK_ei", p11encr, sa->encr_key_len,
+	    &sa->sk_ei))
+		goto fail;
+	if (!prfplus(&prfp, sa->salt_i, sa->saltlen))
+		goto fail;
+	if (!prf_to_p11key(&prfp, "SK_er", p11encr, sa->encr_key_len,
+	    &sa->sk_er))
+		goto fail;
+	if (!prfplus(&prfp, sa->salt_r, sa->saltlen))
+		goto fail;
+	if (!prf_to_p11key(&prfp, "SK_pi", p11prf, prflen, &sa->sk_pi))
+		goto fail;
+	if (!prf_to_p11key(&prfp, "SK_pr", p11prf, prflen, &sa->sk_pr))
+		goto fail;
+
+	pkcs11_destroy_obj("Ni|Nr", &nonce, sa->i2sa_log);
+	pkcs11_destroy_obj("skeyseed", &skeyseed, sa->i2sa_log);
+	prfplus_fini(&prfp);
+	return (B_TRUE);
+
+fail:
+	pkcs11_destroy_obj("Ni|Nr", &nonce, sa->i2sa_log);
+	pkcs11_destroy_obj("skeyseed", &skeyseed, sa->i2sa_log);
+	prfplus_fini(&prfp);
+	return (B_FALSE);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ilist.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ilist.h
new file mode 100644
index 0000000000..12c493f431
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/ilist.h
@@ -0,0 +1,156 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _ILIST_H
+#define	_ILIST_H
+
+/* A very thin wrapper around list_t to include the size of the list */
+
+#include <inttypes.h>
+#include <sys/list.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct ilist {
+	list_t	ilist_list;
+	size_t	ilist_size;
+} ilist_t;
+
+/* Use inline functions instead of macros for better type checking */
+inline void
+ilist_create(ilist_t *list, size_t size, size_t offset)
+{
+	list_create(&list->ilist_list, size, offset);
+	list->ilist_size = 0;
+}
+
+inline void
+ilist_destroy(ilist_t *list)
+{
+	list_destroy(&list->ilist_list);
+}
+
+inline void
+ilist_insert_after(ilist_t *list, void *object, void *nobject)
+{
+	list_insert_after(&list->ilist_list, object, nobject);
+	list->ilist_size++;
+}
+
+inline void
+ilist_insert_before(ilist_t *list, void *object, void *nobject)
+{
+	list_insert_before(&list->ilist_list, object, nobject);
+	list->ilist_size++;
+}
+
+inline void
+ilist_insert_head(ilist_t *list, void *object)
+{
+	list_insert_head(&list->ilist_list, object);
+	list->ilist_size++;
+}
+
+inline void
+ilist_insert_tail(ilist_t *list, void *object)
+{
+	list_insert_tail(&list->ilist_list, object);
+	list->ilist_size++;
+}
+
+inline void
+ilist_remove(ilist_t *list, void *object)
+{
+	list_remove(&list->ilist_list, object);
+	list->ilist_size--;
+}
+
+inline void *
+ilist_remove_head(ilist_t *list)
+{
+	void *obj = list_remove_head(&list->ilist_list);
+	if (obj != NULL) {
+		VERIFY3U(list->ilist_size, >, 0);
+		list->ilist_size--;
+	}
+	return (obj);
+}
+
+inline void *
+ilist_remove_tail(ilist_t *list)
+{
+	void *obj = list_remove_tail(&list->ilist_list);
+	if (obj != NULL) {
+		VERIFY3U(list->ilist_size, >, 0);
+		list->ilist_size--;
+	}
+	return (obj);
+}
+
+inline void *
+ilist_head(ilist_t *list)
+{
+	return (list_head(&list->ilist_list));
+}
+
+inline void *
+ilist_tail(ilist_t *list)
+{
+	return (list_tail(&list->ilist_list));
+}
+
+inline void *
+ilist_next(ilist_t *list, void *object)
+{
+	return (list_next(&list->ilist_list, object));
+}
+
+inline void *
+ilist_prev(ilist_t *list, void *object)
+{
+	return (list_prev(&list->ilist_list, object));
+}
+
+inline void
+ilist_move_tail(ilist_t *dst, ilist_t *src)
+{
+	list_move_tail(&dst->ilist_list, &src->ilist_list);
+}
+
+inline int
+ilist_is_empty(ilist_t *list)
+{
+	int ret = list_is_empty(&list->ilist_list);
+	if (ret == 0)
+		VERIFY3S(list->ilist_size, >, 0);
+	else
+		VERIFY3S(list->ilist_size, ==, 0);
+
+	return (ret);
+}
+
+inline size_t
+ilist_size(ilist_t *list)
+{
+	return (list->ilist_size);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ILIST_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.c
new file mode 100644
index 0000000000..2d0fa5e3d0
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.c
@@ -0,0 +1,329 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <arpa/inet.h>
+#include <bunyan.h>
+#include <inttypes.h>
+#include <err.h>
+#include <errno.h>
+#include <ipsec_util.h>
+#include <locale.h>
+#include <netinet/in.h>
+#include <netinet/udp.h>
+#include <note.h>
+#include <port.h>
+#include <string.h>
+#include <sys/debug.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <thread.h>
+#include "inbound.h"
+#include "defs.h"
+#include "fromto.h"
+#include "ikev1.h"
+#include "ikev2.h"
+#include "ikev2_pkt.h"
+#include "ikev2_proto.h"
+
+typedef struct inbound_s {
+	thread_t	ib_tid;
+	bunyan_logger_t	*ib_log;
+	uint8_t		*ib_buf;
+	size_t		ib_buflen;
+} inbound_t;
+
+int ikesock4 = -1;
+int ikesock6 = -1;
+int nattsock = -1;
+size_t ninbound = 0;
+int inbound_port = -1;
+
+static rwlock_t ib_lock = DEFAULTRWLOCK;
+static inbound_t *ibdata;
+static size_t ibdata_alloc;
+static __thread inbound_t *ib = NULL;
+
+static void *
+inbound_main(void *ibarg)
+{
+	port_event_t pe;
+	int rc;
+
+	ib = ibarg;
+
+	(void) bunyan_trace(ib->ib_log, "Inbound main loop starting",
+	    BUNYAN_T_END);
+
+	while (1) {
+		if (port_get(inbound_port, &pe, NULL) < 0) {
+			STDERR(fatal, ib->ib_log, "port_get() failed");
+			exit(EXIT_FAILURE);
+		}
+
+		(void) bunyan_debug(ib->ib_log, "Received port event",
+		    BUNYAN_T_INT32, "event", pe.portev_events,
+		    BUNYAN_T_STRING, "source",
+		    port_source_str(pe.portev_source),
+		    BUNYAN_T_POINTER, "object", pe.portev_object,
+		    BUNYAN_T_POINTER, "cookie", pe.portev_user,
+		    BUNYAN_T_END);
+
+		VERIFY3S(pe.portev_source, ==, PORT_SOURCE_FD);
+
+		void (*fn)(int) = (void (*)(int))pe.portev_user;
+		int fd = (int)pe.portev_object;
+		fn(fd);
+	}
+
+	return (NULL);
+}
+
+static void
+inbound(int s)
+{
+	pkt_t *pkt = NULL;
+	struct sockaddr_storage to = { 0 };
+	struct sockaddr_storage from = { 0 };
+	socklen_t tolen = sizeof (to);
+	socklen_t fromlen = sizeof (from);
+	ssize_t pktlen;
+
+	(void) memset(ib->ib_buf, 0, ib->ib_buflen);
+	pktlen = recvfromto(s, ib->ib_buf, ib->ib_buflen, 0, &from, &fromlen,
+	    &to, &tolen);
+
+	/*
+	 * Once we've received the datagram, re-arm socket to other threads
+	 * can receive datagrams from this socket.
+	 */
+	schedule_socket(s, inbound);
+
+	/* recvfromto() should have dumped enough debug info */
+	if (pktlen == -1)
+		return;
+
+	/* recvfromto() should discard truncated packets, if not, it's a bug */
+	VERIFY3U(pktlen, >=, sizeof (ike_header_t));
+
+	/* sanity checks */
+	ike_header_t *hdr = (ike_header_t *)ib->ib_buf;
+	size_t hdrlen = ntohl(hdr->length);
+
+	VERIFY(bunyan_key_add(ib->ib_log,
+	    ss_bunyan(&from), "src", ss_addr(&from),
+	    BUNYAN_T_UINT32, "srcport", ss_port(&from),
+	    ss_bunyan(&to), "dest", ss_addr(&to),
+	    BUNYAN_T_UINT32, "destport", ss_port(&to),
+	    BUNYAN_T_END) == 0);
+
+	if (hdrlen != pktlen) {
+		(void) bunyan_info(ib->ib_log,
+		    "ISAKMP/IKE header length doesn't match received length",
+		    BUNYAN_T_UINT32, "hdrlen", (uint32_t)hdrlen,
+		    BUNYAN_T_UINT32, "pktlen", (uint32_t)pktlen,
+		    BUNYAN_T_END);
+		return;
+	}
+
+	switch (hdr->version) {
+	case IKEV1_VERSION:
+		/* XXX: Until we support V1 */
+		bunyan_info(ib->ib_log, "Discarding ISAKMP/IKEV1 packet",
+		    BUNYAN_T_END);
+		return;
+	case IKEV2_VERSION:
+		pkt = ikev2_pkt_new_inbound(ib->ib_buf, pktlen, ib->ib_log);
+		if (pkt == NULL)
+			return;
+		ikev2_dispatch(pkt, &from, &to);
+		return;
+	default:
+		bunyan_info(ib->ib_log, "Unsupported ISAKMP/IKE version",
+		    BUNYAN_T_UINT32, "version", hdr->version,
+		    BUNYAN_T_END);
+		return;
+	}
+}
+
+void
+schedule_socket(int fd, void (*cb)(int))
+{
+	if (port_associate(inbound_port, PORT_SOURCE_FD, fd, POLLIN, cb) < 0) {
+		STDERR(error, log, "port_associate() failed",
+		    BUNYAN_T_INT32, "fd", (int32_t)fd,
+		    BUNYAN_T_END);
+
+		/*
+		 * If port_associate() fails, we'll stop receiving messages
+		 * in the corresponding socket, so no use in trying to stay
+		 * alive.
+		 *
+		 * XXX: abort() instead of exit()?
+		 */
+		exit(EXIT_FAILURE);
+	}
+}
+
+static int
+udp_listener_socket(sa_family_t af, uint16_t port)
+{
+	struct sockaddr_storage storage = { 0 };
+	sockaddr_u_t sau = { .sau_ss = &storage };
+	size_t socksize = 0;
+	int sock = -1;
+	int yes = 1;
+	ipsec_req_t ipsr = { 0 };
+
+	ipsr.ipsr_ah_req = ipsr.ipsr_esp_req = IPSEC_PREF_NEVER;
+
+	switch (af) {
+	case AF_INET:
+		socksize = sizeof (struct sockaddr_in);
+		break;
+	case AF_INET6:
+		socksize = sizeof (struct sockaddr_in6);
+		break;
+	default:
+		INVALID("af");
+	}
+
+	if ((sock = socket(af, SOCK_DGRAM, 0)) == -1) {
+		STDERR(fatal, log, "socket(af, SOCK_DGRAM) call failed",
+		    BUNYAN_T_STRING, "af", afstr(af),
+		    BUNYAN_T_END);
+		exit(EXIT_FAILURE);
+	}
+
+	(void) bunyan_trace(log, "UDP socket created",
+	    BUNYAN_T_INT32, "fd", (int32_t)sock,
+	    BUNYAN_T_STRING, "af", afstr(af),
+	    BUNYAN_T_UINT32, "port", (uint32_t)port,
+	    BUNYAN_T_END);
+
+	sau.sau_ss->ss_family = af;
+	/* Exploit that sin_port and sin6_port live at the same offset. */
+	sau.sau_sin->sin_port = htons(port);
+	if (bind(sock, (const struct sockaddr *)sau.sau_ss, socksize) == -1) {
+		STDERR(fatal, log, "bind(fd, addr) failed",
+		    BUNYAN_T_INT32, "fd", (int32_t)sock,
+		    ss_bunyan(sau.sau_ss), "addr", ss_addr(sau.sau_ss),
+		    BUNYAN_T_UINT32, "port", ss_port(sau.sau_ss),
+		    BUNYAN_T_END);
+		exit(EXIT_FAILURE);
+	}
+
+	switch (af) {
+	case AF_INET:
+		/* Make sure we can receive the destination address */
+		if (setsockopt(sock, IPPROTO_IP, IP_RECVDSTADDR,
+		    (const void *)&yes, sizeof (yes)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IP_RECVDSTADDR)",
+			    __func__);
+
+		if (setsockopt(sock, IPPROTO_IP, IP_SEC_OPT,
+		    (const void *)&ipsr, sizeof (ipsr)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IP_SEC_OPT)",
+			    __func__);
+		break;
+	case AF_INET6:
+		if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
+		    (const void *)&yes, sizeof (yes)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IPV6_RECVPKTINFO)",
+			    __func__);
+
+		if (setsockopt(sock, IPPROTO_IPV6, IPV6_SEC_OPT,
+		    (const void *)&ipsr, sizeof (ipsr)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IPV6_SEC_OPT)",
+			    __func__);
+		break;
+	default:
+		INVALID(af);
+	}
+
+	/* Setup IPv4 NAT Traversal */
+	if (af == AF_INET && port == IPPORT_IKE_NATT) {
+		int nat_t = 1;
+
+		if (setsockopt(sock, IPPROTO_UDP, UDP_NAT_T_ENDPOINT,
+		    &nat_t, sizeof (nat_t)) == -1)
+			err(EXIT_FAILURE, "%s: setsockopt(IPPROTO_UDP, "
+			    "UDP_NAT_T_ENDPOINT", __func__);
+	}
+
+	return (sock);
+}
+
+void
+inbound_init(size_t n)
+{
+	/* main() should initialize inbound_port */
+	VERIFY3S(inbound_port, >=, 0);
+
+	ikesock4 = udp_listener_socket(AF_INET, IPPORT_IKE);
+	nattsock = udp_listener_socket(AF_INET, IPPORT_IKE_NATT);
+	ikesock6 = udp_listener_socket(AF_INET6, IPPORT_IKE);
+
+	size_t amt = n * sizeof (inbound_t);
+	VERIFY3U(amt, >, sizeof (inbound_t));
+	VERIFY3U(amt, >=, n);
+
+	ibdata = umem_zalloc(amt, UMEM_DEFAULT);
+	if (ibdata == NULL)
+		NOMEM;
+
+	for (size_t i = 0; i < n; i++) {
+		ibdata[i].ib_buf = umem_alloc(MAX_PACKET_SIZE, UMEM_DEFAULT);
+		if (ibdata[i].ib_buf == NULL)
+			NOMEM;
+		ibdata[i].ib_buflen = MAX_PACKET_SIZE;
+
+		if (bunyan_child(log, &ibdata[i].ib_log, BUNYAN_T_END) != 0)
+			NOMEM;
+
+		int rc = thr_create(NULL, 0, inbound_main, &ibdata[i], 0,
+		    &ibdata[i].ib_tid);
+
+		if (rc != 0) {
+			bunyan_fatal(log, "Cannot create inbound thread",
+			    BUNYAN_T_STRING, "errmsg", strerror(rc),
+			    BUNYAN_T_INT32, "errno", rc,
+			    BUNYAN_T_STRING, "file", __FILE__,
+			    BUNYAN_T_INT32, "line", __LINE__,
+			    BUNYAN_T_STRING, "func", __func__,
+			    BUNYAN_T_END);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	ninbound = n;
+
+	schedule_socket(ikesock4, inbound);
+	schedule_socket(nattsock, inbound);
+	schedule_socket(ikesock6, inbound);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.h
new file mode 100644
index 0000000000..12e0ae8cba
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/inbound.h
@@ -0,0 +1,37 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2015 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _INBOUND_H
+#define	_INBOUND_H
+
+#include <inttypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int ikesock4, ikesock6, nattsock;
+extern int inbound_port;
+extern size_t ninbound;
+
+void inbound_init(size_t);
+void schedule_socket(int, void (*)(int));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _INBOUND_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/main.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/main.c
new file mode 100644
index 0000000000..8a74ac07fa
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/main.c
@@ -0,0 +1,404 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <bunyan.h>
+#include <errno.h>
+#include <err.h>
+#include <fcntl.h>
+#include <locale.h>
+#include <libgen.h>
+#include <netinet/in.h>
+#include <port.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/debug.h>
+#include <thread.h>
+#include <unistd.h>
+#include "config.h"
+#include "defs.h"
+#include "defs.h"
+#include "ikev2_sa.h"
+#include "inbound.h"
+#include "pkcs11.h"
+#include "timer.h"
+#include "worker.h"
+
+extern void pkt_init(void);
+extern void pkt_fini(void);
+extern void ikev2_sa_init(void);
+extern void random_init(void);
+extern void pfkey_init(void);
+static void signal_init(void);
+static void event(event_t, void *);
+static void do_signal(int);
+static void main_loop(void);
+
+static void do_immediate(void);
+
+static boolean_t done;
+static pthread_t signal_tid;
+
+bunyan_logger_t *log = NULL;
+int port = -1;
+
+static void
+usage(const char *name)
+{
+	(void) fprintf(stderr, "Usage: %s [-d] [-f cfgfile]\n"
+	    "      %s -c [-f cfgfile]\n", name, name);
+	exit(1);
+}
+
+#ifdef	DEBUG
+const char *
+_umem_debug_init(void)
+{
+	return ("default,verbose");
+}
+
+const char *
+_umem_logging_init(void)
+{
+	return ("fail,contents");
+}
+#else
+const char *
+_umem_debug_init(void)
+{
+	return ("guards");
+}
+#endif
+
+int
+main(int argc, char **argv)
+{
+	FILE *f = NULL;
+	char *cfgfile = "/etc/inet/ike/config";
+	int c, rc;
+	boolean_t debug_mode = B_FALSE;
+	boolean_t check_cfg = B_FALSE;
+
+	(void) setlocale(LC_ALL, "");
+#if !defined(TEXT_DOMAIN)
+#define	TEXT_DOMAIN "SYS_TEST"
+#endif
+	(void) textdomain(TEXT_DOMAIN);
+
+	while ((c = getopt(argc, argv, "cdf:")) != -1) {
+		switch (c) {
+		case 'd':
+			debug_mode = B_TRUE;
+			break;
+		case 'c':
+			check_cfg = B_TRUE;
+			break;
+		case 'f':
+			cfgfile = optarg;
+			break;
+		case '?':
+			(void) fprintf(stderr,
+			    "Unrecognized option: -%c\n", optopt);
+			usage(argv[0]);
+			break;
+		}
+	}
+
+	if (check_cfg && debug_mode) {
+		(void) fprintf(stderr, "-d and -c options cannot both be "
+		    "set\n");
+		usage(argv[0]);
+		return (1);
+	}
+
+	if ((rc = bunyan_init(basename(argv[0]), &log)) < 0)
+		errx(EXIT_FAILURE, "bunyan_init() failed: %s", strerror(errno));
+
+	/* hard coded just during development */
+	if ((rc = bunyan_stream_add(log, "stdout", BUNYAN_L_TRACE,
+	    bunyan_stream_fd, (void *)STDOUT_FILENO)) < 0)
+		errx(EXIT_FAILURE, "bunyan_stream_add() failed: %s",
+		    strerror(errno));
+
+	if ((f = fopen(cfgfile, "rF")) == NULL) {
+		STDERR(fatal, log, "cannot open config file",
+		    BUNYAN_T_STRING, "filename", cfgfile);
+		exit(EXIT_FAILURE);
+	}
+
+	process_config(f, check_cfg, log);
+
+	(void) fclose(f);
+
+	if (check_cfg)
+		return (0);
+
+	if (!debug_mode) {
+		/* Explicitly handle closing of fds below */
+		if (daemon(0, 1) != 0) {
+			STDERR(fatal, log, "Could not run as daemon");
+			exit(EXIT_FAILURE);
+		}
+
+		/*
+		 * This assumes that STDERR_FILENO > STDOUT_FILENO &&
+		 * STDERR_FILENO > STDIN_FILENO.  Since this has been the
+		 * case for over 40 years, this seems a safe assumption.
+		 */
+		closefrom(STDERR_FILENO + 1);
+
+		int fd = open("/dev/null", O_RDONLY);
+
+		if (fd < 0) {
+			STDERR(fatal, log,
+			    "Could not open /dev/null for stdin");
+			exit(EXIT_FAILURE);
+		}
+
+		if (dup2(fd, STDIN_FILENO) < 0) {
+			STDERR(fatal, log,
+			    "dup2 failed for stdin");
+			exit(EXIT_FAILURE);
+		}
+
+		(void) close(fd);
+	}
+
+	if ((port = port_create()) < 0) {
+		STDERR(fatal, log, "main port_create() failed");
+		exit(EXIT_FAILURE);
+	}
+
+	if ((inbound_port = port_create()) < 0) {
+		STDERR(fatal, log, "inbound port_create() failed");
+		exit(EXIT_FAILURE);
+	}
+
+	signal_init();
+	random_init();
+	pkcs11_init();
+	pkt_init();
+	ike_timer_init();
+	ikev2_sa_init();
+
+	/* XXX: make these configurable */
+	worker_init(8, 8);
+	pfkey_init();
+	inbound_init(2);
+	main_loop();
+
+	pkt_fini();
+	pkcs11_fini();
+	return (0);
+}
+
+/* Temp function to fire off IKE_SA_INIT exchanges */
+static void
+do_immediate(void)
+{
+	config_t *cfg = config_get();
+
+	for (size_t i = 0; cfg->cfg_rules[i] != NULL; i++) {
+		if (!cfg->cfg_rules[i]->rule_immediate)
+			continue;
+
+		config_rule_t *rule = cfg->cfg_rules[i];
+		ikev2_sa_t *sa = NULL;
+		struct sockaddr_storage laddr = { 0 };
+		struct sockaddr_storage raddr = { 0 };
+		sockaddr_u_t sl = { .sau_ss = &laddr };
+		sockaddr_u_t sr = { .sau_ss = &raddr };
+
+		VERIFY3S(rule->rule_local_addr[0].cfa_type, ==, CFG_ADDR_IPV4);
+		VERIFY3S(rule->rule_remote_addr[0].cfa_type, ==, CFG_ADDR_IPV4);
+
+		sl.sau_sin->sin_family = AF_INET;
+		sl.sau_sin->sin_port = htons(IPPORT_IKE);
+		(void) memcpy(&sl.sau_sin->sin_addr,
+		    &rule->rule_local_addr[0].cfa_startu.cfa_ip4,
+		    sizeof (in_addr_t));
+
+		sr.sau_sin->sin_family = AF_INET;
+		sr.sau_sin->sin_port = htons(IPPORT_IKE);
+		(void) memcpy(&sr.sau_sin->sin_addr,
+		    &rule->rule_remote_addr[0].cfa_startu.cfa_ip4,
+		    sizeof (in_addr_t));
+
+		sa = ikev2_sa_alloc(B_TRUE, NULL, &laddr, &raddr);
+		VERIFY3P(sa, !=, NULL);
+
+		bunyan_trace(sa->i2sa_log, "Dispatching larval SA to worker",
+		    BUNYAN_T_STRING, "rule", rule->rule_label,
+		    BUNYAN_T_END);
+
+		worker_dispatch(WMSG_START, sa,
+		    I2SA_LOCAL_SPI(sa) % wk_nworkers);
+	}
+
+	CONFIG_REFRELE(cfg);
+}
+
+static void
+main_loop(void)
+{
+	port_event_t pe;
+	int rc;
+
+	(void) bunyan_trace(log, "starting main loop", BUNYAN_T_END);
+
+	do_immediate();
+
+	/*CONSTCOND*/
+	while (!done) {
+		if (port_get(port, &pe, NULL) < 0) {
+			STDERR(error, log, "port_get() failed");
+			continue;
+		}
+
+		(void) bunyan_trace(log, "received event",
+		    BUNYAN_T_STRING, "source",
+		    port_source_str(pe.portev_source),
+		    BUNYAN_T_STRING, "event",
+		    event_str(pe.portev_events),
+		    BUNYAN_T_UINT32, "event num",
+		    (int32_t)pe.portev_events,
+		    BUNYAN_T_POINTER, "event arg", pe.portev_user,
+		    BUNYAN_T_END);
+
+		switch (pe.portev_source) {
+		case PORT_SOURCE_USER:
+			event(pe.portev_events, pe.portev_user);
+			break;
+
+		case PORT_SOURCE_ALERT:
+			break;
+
+		case PORT_SOURCE_TIMER: {
+			void (*fn)(void) = (void (*)(void))pe.portev_user;
+			fn();
+			break;
+		}
+		default:
+			INVALID("pe.portev_source");
+		}
+	}
+
+	(void) bunyan_info(log, "Exiting", BUNYAN_T_END);
+}
+
+static void
+event(event_t evt, void *arg)
+{
+	switch (evt) {
+	case EVENT_NONE:
+		return;
+	case EVENT_SIGNAL:
+		do_signal((int)(uintptr_t)arg);
+		break;
+	}
+}
+
+void
+reload(void)
+{
+}
+
+static void
+do_signal(int signum)
+{
+	switch (signum) {
+	case SIGINT:
+	case SIGTERM:
+	case SIGQUIT:
+		done = B_TRUE;
+		break;
+	case SIGHUP:
+		reload();
+		break;
+	case SIGUSR1:
+		(void) worker_add();
+		break;
+	case SIGUSR2:
+		(void) worker_del();
+		break;
+	default:
+		break;
+	}
+}
+
+/*ARGSUSED*/
+static void *
+signal_thread(void *arg)
+{
+	char sigbuf[SIG2STR_MAX + 3]; /* add room for 'SIG' */
+	sigset_t sigset;
+	int signo, ret;
+
+	bunyan_trace(log, "signal thread awaiting signals", BUNYAN_T_END);
+
+	(void) sigfillset(&sigset);
+
+	/*CONSTCOND*/
+	while (1) {
+		if (sigwait(&sigset, &signo) != 0) {
+			STDERR(error, log, "sigwait() failed");
+			continue;
+		}
+
+		(void) memset(sigbuf, 0, sizeof (sigbuf));
+		(void) strlcat(sigbuf, "SIG", sizeof (sigbuf));
+		sig2str(signo, sigbuf + 3);
+
+		(void) bunyan_info(log, "signal received",
+		    BUNYAN_T_STRING, "signal", sigbuf,
+		    BUNYAN_T_INT32, "signum", (int32_t)signo,
+		    BUNYAN_T_END);
+
+		if (port_send(port, EVENT_SIGNAL, (void *)(uintptr_t)signo) < 0)
+			STDERR(error, log, "port_send() failed");
+	}
+
+	/*NOTREACHED*/
+	return (NULL);
+}
+
+static void
+signal_init(void)
+{
+	pthread_attr_t attr;
+	sigset_t nset;
+	int rc;
+
+	bunyan_trace(log, "Creating signal handling thread", BUNYAN_T_END);
+
+	/* block all signals in main thread */
+	(void) sigfillset(&nset);
+	VERIFY0(thr_sigsetmask(SIG_SETMASK, &nset, NULL));
+
+	rc = thr_create(NULL, 0, signal_thread, NULL, THR_DETACHED,
+	    &signal_tid);
+	if (rc != 0) {
+		bunyan_fatal(log, "Signal handling thread creation failed",
+		    BUNYAN_T_STRING, "errmsg", strerror(rc),
+		    BUNYAN_T_INT32, "errno", (int32_t)rc,
+		    BUNYAN_T_STRING, "file", __FILE__,
+		    BUNYAN_T_INT32, "line", (int32_t)__LINE__,
+		    BUNYAN_T_STRING, "func", __func__,
+		    BUNYAN_T_END);
+		exit(EXIT_FAILURE);
+	}
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pfkey.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pfkey.c
new file mode 100644
index 0000000000..7bc93bd04b
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pfkey.c
@@ -0,0 +1,738 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <sys/types.h>
+#include <net/pfkeyv2.h>
+#include <ipsec_util.h>
+#include <string.h>
+#include <errno.h>
+#include <locale.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <note.h>
+#include <atomic.h>
+#include <pthread.h>
+#include <sys/list.h>
+#include <sys/stropts.h>	/* For I_NREAD */
+#include <bunyan.h>
+#include <ucontext.h>
+
+#include "defs.h"
+#include "ikev2.h"
+#include "ikev2_pkt.h"
+#include "ikev2_sa.h"
+#include "inbound.h"
+#include "pkcs11.h"
+
+struct pfreq;
+typedef struct pfreq {
+	list_node_t	pr_node;
+	pfreq_cb_t	*pr_cb;
+	void		*pr_data;
+	uint32_t	pr_msgid;
+} pfreq_t;
+
+static bunyan_logger_t	*pflog;
+static umem_cache_t	*pfreq_cache;
+static pthread_mutex_t	pfreq_lock = PTHREAD_MUTEX_INITIALIZER;
+static list_t		pfreq_list;
+
+/* PF_KEY socket. */
+int pfkey;
+
+/* our msgids */
+static volatile uint32_t msgid = 0;
+
+static int pfreq_ctor(void *, void *, int);
+static pfreq_t *pfreq_new(pfreq_cb_t *, void *);
+static void pfreq_free(pfreq_t *);
+
+static void handle_reply(sadb_msg_t *);
+static void handle_delete(sadb_msg_t *);
+static void handle_flush(sadb_msg_t *);
+static void handle_expire(sadb_msg_t *);
+static void handle_acquire(sadb_msg_t *, boolean_t);
+static void handle_register(sadb_msg_t *);
+
+static void sadb_log(bunyan_logger_t *restrict, bunyan_level_t,
+    const char *restrict, sadb_msg_t *restrict);
+
+#if 0
+static ikev2_pay_sa_t *convert_acquire(parsedmsg_t *);
+static ikev2_pay_sa_t *convert_ext_acquire(parsedmsg_t *, ikev2_spi_proto_t);
+static ikev2_xf_auth_t ikev2_pf_to_auth(int);
+#endif
+
+static const char *pfkey_opcodes[] = {
+	"RESERVED", "GETSPI", "UPDATE", "ADD", "DELETE", "GET",
+	"ACQUIRE", "REGISTER", "EXPIRE", "FLUSH", "DUMP", "X_PROMISC",
+	"X_INVERSE_ACQUIRE", "X_UPDATEPAIR", "X_DELPAIR"
+};
+
+static const char *
+pfkey_type(unsigned int type)
+{
+	if (type > SADB_MAX)
+		return ("ILLEGAL");
+	else
+		return (pfkey_opcodes[type]);
+}
+
+static const char *pfkey_satypes[] = {
+	"UNSPEC", "<undef>", "AH", "ESP", "<undef>", "RSVP", "OSPFV2",
+	"RIPV2", "MIP"
+};
+
+static const char *
+pfkey_satype(unsigned int type)
+{
+	if (type > SADB_SATYPE_MAX)
+		return ("ILLEGAL");
+	else
+		return (pfkey_satypes[type]);
+}
+
+/* Deal with algorithm name lookups */
+
+static const char *
+alg_to_string(int doi_number, const algindex_t *algindex)
+{
+	int i;
+
+	for (i = 0; algindex[i].desc; i++)
+		if (doi_number == algindex[i].doi_num)
+			return (algindex[i].desc);
+	return ("unknown");
+}
+
+char *
+kef_alg_to_string(int algnum, int protonum, char *algname)
+{
+	struct ipsecalgent *testentry;
+	int error;
+
+	testentry = getipsecalgbynum(algnum, protonum, &error);
+	if (testentry == NULL || testentry->a_names[0] == NULL)
+		(void) snprintf(algname, 80, "unknown");
+	else
+		(void) snprintf(algname, 80, "%s", testentry->a_names[0]);
+
+	/* safe to use on a NULL pointer */
+	(void) freeipsecalgent(testentry);
+	return (algname);
+}
+
+/*
+ * The passed in parsedmsg_t looks like this (see defs.h):
+ *
+ * {
+ *	*pmsg_next
+ *	*pmsg_samsg
+ *	*pmsg_exts[0][1][2][3].....[SADB_EXT_MAX + 2]
+ *	*pmsg_sss  (struct sockaddr_storage *)
+ *	*pmsg_dss  (struct sockaddr_storage *)
+ *	*pmsg_isss (struct sockaddr_storage *)
+ *	*pmsg_idss (struct sockaddr_storage *)
+ *	*pmsg_nlss (struct sockaddr_storage *)
+ *	*pmsg_nrss (struct sockaddr_storage *)
+ * } parsedmsg_t;
+ *
+ * This function parses through the whole samsg looking for valid PF_KEY
+ * extensions. Each extension type found is saved in the pmsg_exts array.
+ * As the parsedmsg_t is initialised as zero's when entering the function, it's
+ * easy to check later to see which extensions exist in the samsg by
+ * checking for NULL.
+ *
+ * Some extensions will have a sockaddr_storage associated with the type
+ * EG: SADB_EXT_ADDRESS_SRC, in these cases a pointer to the appropriate
+ * structure in samsg is set in the parsedmsg_t.
+ *
+ * After parsing the whole samsg, the optional arguments (which is a list
+ * of required extensions) are checked for in the parsedmsg_t. If all of the
+ * required extensions are valid then the function returns B_TRUE.
+ *
+ * Even if the required extensions are not in the samsg (and the function
+ * returns B_FALSE) the pmsg->pmsg_exts array will still contain the headers
+ * that were in the samsg.
+ *
+ * Assume the kernel knows what it's doing with messages that get passed up.
+ * The variable arguments are a list of ints with SADB_EXT_* values.
+ */
+static boolean_t
+extract_exts(sadb_msg_t *samsg, parsedmsg_t *pmsg, int numexts, ...)
+{
+	sadb_ext_t *ext;
+	sadb_ext_t **exts = pmsg->pmsg_exts;
+	int current_ext;
+	va_list ap;
+	boolean_t rc = B_TRUE;
+
+	(void) memset(pmsg, 0, sizeof (parsedmsg_t));
+
+	ext = (sadb_ext_t *)(samsg + 1);
+	pmsg->pmsg_samsg = samsg;
+
+	do {
+		exts[ext->sadb_ext_type] = ext;
+		if (ext->sadb_ext_type == SADB_EXT_ADDRESS_SRC)
+			pmsg->pmsg_sss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_EXT_ADDRESS_DST)
+			pmsg->pmsg_dss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_X_EXT_ADDRESS_INNER_SRC)
+			pmsg->pmsg_isss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_X_EXT_ADDRESS_INNER_DST)
+			pmsg->pmsg_idss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_X_EXT_ADDRESS_NATT_REM)
+			pmsg->pmsg_nrss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+		if (ext->sadb_ext_type == SADB_X_EXT_ADDRESS_NATT_LOC)
+			pmsg->pmsg_nlss = (struct sockaddr_storage *)
+			    (((sadb_address_t *)ext) + 1);
+
+		ext = (sadb_ext_t *)(((uint64_t *)ext) + ext->sadb_ext_len);
+
+	} while (((uint8_t *)ext) - ((uint8_t *)samsg) <
+	    SADB_64TO8(samsg->sadb_msg_len));
+
+	va_start(ap, numexts);
+	while (numexts-- > 0) {
+		current_ext = va_arg(ap, int);
+		if (exts[current_ext] == NULL) {
+			rc = B_FALSE;
+			break;
+		}
+	}
+	va_end(ap);
+
+	return (rc);
+}
+
+static void
+pfkey_inbound(int s)
+{
+	sadb_msg_t *samsg;
+	ssize_t rc;
+	int length;
+
+	if (ioctl(s, I_NREAD, &length) < 0) {
+		STDERR(error, log, "ioctl(I_NREAD) failed");
+		schedule_socket(s, pfkey_inbound);
+		return;
+	}
+
+	if (length == 0) {
+		bunyan_info(log, "ioctl: zero length message",
+		    BUNYAN_T_STRING, "func", __func__,
+		    BUNYAN_T_STRING, "file", __FILE__,
+		    BUNYAN_T_INT32, "line", __LINE__,
+		    BUNYAN_T_END);
+		schedule_socket(s, pfkey_inbound);
+		return;
+	}
+
+	samsg = malloc(length);
+	if (samsg == NULL) {
+		bunyan_error(log, "No memory for pfkey message", BUNYAN_T_END);
+		schedule_socket(s, pfkey_inbound);
+		return;
+	}
+
+	rc = read(s, samsg, length);
+	if (rc <= 0) {
+		if (rc == -1) {
+			STDERR(error, log, "read failed");
+			/* XXX: Should I exit()? */
+		}
+		free(samsg);
+		schedule_socket(s, pfkey_inbound);
+		return;
+	}
+
+	/* At this point, we can safely re-schedule the socket for reading. */
+	schedule_socket(s, pfkey_inbound);
+
+	sadb_log(log, BUNYAN_L_DEBUG, "SADB message received", samsg);
+
+	/*
+	 * XXX KEBE SAYS for now don't print the full inbound message.  An
+	 * "ipseckey monitor" instance is useful here.
+	 */
+
+	/*
+	 * If it might be a reply to us, handle it.
+	 */
+	if (samsg->sadb_msg_pid == getpid()) {
+		handle_reply(samsg);
+		return;
+	}
+
+	/*
+	 * Silently pitch the message if it's an error reply to someone else.
+	 */
+	if (samsg->sadb_msg_errno != 0) {
+		bunyan_debug(log, "Reply not for us, dropped", BUNYAN_T_END);
+		free(samsg);
+		return;
+	}
+
+	/*
+	 * At this point, we have a kernel-emitted message.  Typically this
+	 * will be an ACQUIRE, EXPIRE, or DELETE/DELPAIR.  Other ones include
+	 * FLUSH (which if we follow in.iked semantics, will nuke all IKE SA
+	 * state) and REGISTER (indicating a change in kernel algorithm
+	 * support).
+	 */
+
+	switch (samsg->sadb_msg_type) {
+	case SADB_ACQUIRE:
+		handle_acquire(samsg, B_TRUE);
+		return;
+	case SADB_EXPIRE:
+		handle_expire(samsg);
+		return;
+	case SADB_DELETE:
+	case SADB_X_DELPAIR:
+		handle_delete(samsg);
+		return;
+	case SADB_FLUSH:
+		handle_flush(samsg);
+		return;
+	case SADB_REGISTER:
+		handle_register(samsg);
+		/*
+		 * Explicitly free it here because handle_register() is also
+		 * called from pfkey_init(), which has samsg on the stack
+		 * instead.
+		 */
+		free(samsg);
+		return;
+	}
+
+	bunyan_debug(log, "SADB message type unknown, ignored.",
+	    BUNYAN_T_UINT32, "msg_type_val", (uint32_t)samsg->sadb_msg_type,
+	    BUNYAN_T_END);
+	free(samsg);
+}
+
+/*
+ * Send a pfkey message 'msg'.  The reply will invoke the callback
+ * function 'cb' with data as an argument.
+ * Returns B_TRUE if the request is successfully sent,
+ * B_FALSE if there was an error.
+ */
+boolean_t
+pfkey_send_msg(sadb_msg_t *msg, pfreq_cb_t *cb, void *data)
+{
+	pfreq_t *req;
+	ssize_t n;
+
+	req = pfreq_new(cb, data);
+	if (req == NULL)
+		return (B_FALSE);
+
+	msg->sadb_msg_seq = req->pr_msgid;
+	msg->sadb_msg_pid = getpid();
+
+	VERIFY0(pthread_mutex_lock(&pfreq_lock));
+	list_insert_tail(&pfreq_list, req);
+	VERIFY0(pthread_mutex_unlock(&pfreq_lock));
+
+	n = write(pfkey, msg, msg->sadb_msg_len);
+	if (n != msg->sadb_msg_len) {
+		if (n < 0) {
+			STDERR(error, log, "pf_key write failed");
+		} else {
+			bunyan_error(log, "pf_key truncated write",
+			    BUNYAN_T_UINT32, "n", (uint32_t)n,
+			    BUNYAN_T_END);
+		}
+
+		VERIFY0(pthread_mutex_lock(&pfreq_lock));
+		list_remove(&pfreq_list, req);
+		VERIFY0(pthread_mutex_unlock(&pfreq_lock));
+
+		pfreq_free(req);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * Inform the kernel of an error.
+ * src is the pfkey message the error is a response to, reason is
+ * the reason for the error
+ */
+void
+pfkey_send_error(const sadb_msg_t *src, uint8_t reason)
+{
+	sadb_msg_t msg = { 0 };
+	ssize_t n;
+
+	/* Errors consists of just the sadb header */
+	msg.sadb_msg_len = SADB_8TO64(sizeof (sadb_msg_t));
+	msg.sadb_msg_version = PF_KEY_V2;
+	msg.sadb_msg_type = src->sadb_msg_type;
+	msg.sadb_msg_errno = reason;
+	msg.sadb_msg_satype = src->sadb_msg_satype;
+	msg.sadb_x_msg_diagnostic = SADB_X_DIAGNOSTIC_NONE;
+	msg.sadb_msg_seq = src->sadb_msg_seq;
+	msg.sadb_msg_pid = src->sadb_msg_pid;
+
+	n = write(pfkey, &msg, sizeof (sadb_msg_t));
+	if (n != sizeof (sadb_msg_t))
+		STDERR(error, log, "Unable to send PFKEY error notification");
+}
+
+static void
+handle_reply(sadb_msg_t *reply)
+{
+	pfreq_t *req = NULL;
+
+	VERIFY0(pthread_mutex_lock(&pfreq_lock));
+
+	req = list_head(&pfreq_list);
+	while (req != NULL && req->pr_msgid != reply->sadb_msg_seq)
+		req = list_next(&pfreq_list, req);
+
+	if (req != NULL)
+		list_remove(&pfreq_list, req);
+	VERIFY0(pthread_mutex_unlock(&pfreq_lock));
+
+	if (req == NULL) {
+		sadb_log(pflog, BUNYAN_L_INFO,
+		    "Received a reply to an unknown request", reply);
+		free(reply);
+		return;
+	}
+
+#if 0
+	req->pr_cb(reply, req->pr_data);
+#endif
+	pfreq_free(req);
+
+	switch (reply->sadb_msg_type) {
+	case SADB_ACQUIRE:
+	{
+		/* Should be a response to our inverse acquire */
+		parsedmsg_t pmsg = { 0 };
+
+		if (!extract_exts(reply, &pmsg, 1, SADB_X_EXT_EPROP)) {
+			bunyan_info(pflog, "No extended proposal found in "
+			    "ACQUIRE reply.", BUNYAN_T_END);
+			free(reply);
+			return;
+		}
+
+		/*
+		 * XXX: lookup what we queried based on msgid, extract
+		 * SA type and pass to convert_ext_acquire
+		 */
+
+		/* XXX: continue CHILD SA processing */
+		break;
+	}
+	default:
+		/* XXX: More to come */
+		;
+	}
+
+	free(reply);
+}
+
+static void
+handle_flush(sadb_msg_t *samsg)
+{
+	bunyan_trace(pflog, "Handling SADB flush message", BUNYAN_T_END);
+
+	/* Return if just AH or ESP SAs are being freed. */
+	if (samsg->sadb_msg_satype != SADB_SATYPE_UNSPEC)
+		return;
+
+	/* XXX KEBE SAYS FILL ME IN! */
+
+	ikev2_sa_flush();
+
+	/*
+	 * If we receive an SADB_FLUSH for all SA types, get rid of any IKE
+	 * SAs.
+	 */
+
+	free(samsg);
+}
+
+/*
+ * Handle the PF_KEY SADB_EXPIRE message for idle timeout.
+ *
+ * XXX KEBE SAYS this'll most likely kick off Dead Peer Detection if we can
+ * find an IKE SA.
+ */
+static void
+handle_idle_timeout(sadb_msg_t *samsg)
+{
+	bunyan_trace(pflog, "Handling SADB idle expire message", BUNYAN_T_END);
+
+	/* XXX KEBE SAYS FILL ME IN! */
+	free(samsg);
+}
+
+static void
+handle_expire(sadb_msg_t *samsg)
+{
+	parsedmsg_t pmsg;
+
+	/*
+	 * If SOFT expire, see if the SADB_X_SAFLAGS_KM1 (initiator) is set,
+	 * if so, consider treating this expire as an ACQUIRE message.
+	 *
+	 * If HARD expire, treat this message like a DELETE.
+	 *
+	 * If IDLE expire, see if we need to do a little DPD or not.
+	 */
+
+	if (extract_exts(samsg, &pmsg, 1, SADB_EXT_LIFETIME_HARD)) {
+		bunyan_debug(pflog, "Handling SADB hard expire message",
+		    BUNYAN_T_END);
+		handle_delete(samsg);
+		return;
+	}
+
+	if (pmsg.pmsg_exts[SADB_X_EXT_LIFETIME_IDLE] != NULL) {
+		handle_idle_timeout(samsg);
+		return;
+	}
+
+	/*
+	 * extract_exts() has already filled in pmsg with data from
+	 * samsg. pmsg.pmsg_exts[foo] will be NULL if this was
+	 * not set in samsg. Bail out if the message appears to be
+	 * poorly formed. If everything looks good, create a new
+	 * "ACQUIRE like" message and pass off to handle_acquire().
+	 */
+
+	if (pmsg.pmsg_exts[SADB_EXT_LIFETIME_SOFT] == NULL) {
+		/* XXX: more fields */
+		bunyan_info(pflog, "SADB EXPIRE message is missing both "
+		    "hard and soft lifetimes", BUNYAN_T_END);
+		/* XXX: ignore? */
+	}
+
+	bunyan_debug(pflog, "Handling SADB soft expire message", BUNYAN_T_END);
+	/* XXX KEBE SAYS FILL ME IN! */
+
+	free(samsg);
+}
+
+static void
+handle_register(sadb_msg_t *samsg)
+{
+	_NOTE(ARGUNUSED(samsg))
+	/* XXX KEBE SAYS FILL ME IN! */
+
+	/*
+	 * XXX KEBE wonders if this is as necessary as 2367 first imagined?
+	 *
+	 * With inverse-ACQUIRE, you know better what algorithms are available
+	 * and acceptable.  This may go away or remain a mere stub.
+	 */
+}
+
+static void
+handle_delete(sadb_msg_t *samsg)
+{
+	bunyan_trace(pflog, "Handling SADB delete", BUNYAN_T_END);
+
+	/* XXX KEBE SAYS FILL ME IN! */
+	free(samsg);
+}
+
+/*
+ * Handle a PF_KEY ACQUIRE message.  This function, or something that it
+ * calls (either directly or via callbacks) must free samsg.
+ */
+/* XXX KEBE wonders if create_child_sa will be needed here or not. */
+static void
+handle_acquire(sadb_msg_t *samsg, boolean_t create_child_sa)
+{
+	/* XXX: for now */
+	_NOTE(ARGUNUSED(create_child_sa))
+
+	parsedmsg_t pmsg;
+
+	bunyan_debug(pflog, "Handling SADB acquire", BUNYAN_T_END);
+
+	if (!extract_exts(samsg, &pmsg, 1, SADB_EXT_PROPOSAL)) {
+		bunyan_info(pflog, "No proposal found in ACQUIRE message",
+		    BUNYAN_T_END);
+		free(samsg);
+		return;
+	}
+
+	/* XXX KEBE SAYS FILL ME IN! */
+	free(samsg);
+}
+
+static int
+pfreq_ctor(void *buf, void *ignore, int flags)
+{
+	_NOTE(ARGUNUSED(ignore, flags))
+
+	pfreq_t *req = buf;
+
+	(void) memset(buf, 0, sizeof (pfreq_t));
+	list_link_init(&req->pr_node);
+	return (0);
+}
+
+static pfreq_t *
+pfreq_new(pfreq_cb_t *cb, void *data)
+{
+	pfreq_t *req = umem_cache_alloc(pfreq_cache, UMEM_DEFAULT);
+
+	if (req == NULL)
+		return (NULL);
+
+	req->pr_msgid = atomic_inc_32_nv(&msgid);
+	req->pr_cb = cb;
+	req->pr_data = data;
+	return (req);
+}
+
+static void
+pfreq_free(pfreq_t *req)
+{
+	(void) pfreq_ctor(req, NULL, 0);
+	umem_cache_free(pfreq_cache, req);
+}
+
+static void
+pfkey_register(uint8_t satype)
+{
+	uint64_t buffer[128] = { 0 };
+	sadb_msg_t *samsg = (sadb_msg_t *)buffer;
+	ssize_t n;
+	uint32_t msgid = atomic_inc_32_nv(&msgid);
+	pid_t pid = getpid();
+
+	CTASSERT(sizeof (buffer) >= sizeof (*samsg));
+
+	samsg->sadb_msg_version = PF_KEY_V2;
+	samsg->sadb_msg_type = SADB_REGISTER;
+	samsg->sadb_msg_errno = 0;
+	samsg->sadb_msg_satype = satype;
+	samsg->sadb_msg_reserved = 0;
+	samsg->sadb_msg_seq = msgid;
+	samsg->sadb_msg_pid = pid;
+	samsg->sadb_msg_len = SADB_8TO64(sizeof (*samsg));
+
+	n = write(pfkey, buffer, sizeof (*samsg));
+	if (n < 0)
+		err(EXIT_FAILURE, "pf_key write error");
+	if (n < sizeof (*samsg))
+		errx(EXIT_FAILURE, "Unable to write pf_key register message");
+
+	do {
+		(void) memset(buffer, 0, sizeof (buffer));
+		n = read(pfkey, buffer, sizeof (buffer));
+		if (n < 0)
+			err(EXIT_FAILURE, "pf_key read failure");
+	} while (samsg->sadb_msg_seq != msgid ||
+	    samsg->sadb_msg_pid != pid ||
+	    samsg->sadb_msg_type != SADB_REGISTER);
+
+	if (samsg->sadb_msg_errno != 0) {
+		if (samsg->sadb_msg_errno != EPROTONOSUPPORT)
+			errx(EXIT_FAILURE, "pf_key register returned %s (%d).",
+			    strerror(samsg->sadb_msg_errno),
+			    samsg->sadb_msg_errno);
+		bunyan_error(pflog, "Protocol not supported",
+		    BUNYAN_T_UINT32, "msg_satype",
+		    (uint32_t)samsg->sadb_msg_satype, BUNYAN_T_END);
+	}
+
+	bunyan_debug(pflog, "Initial REGISTER with SADB",
+	    BUNYAN_T_STRING, "satype", pfkey_satype(samsg->sadb_msg_satype),
+	    BUNYAN_T_END);
+
+	handle_register(samsg);
+}
+
+static void
+sadb_log(bunyan_logger_t *restrict blog, bunyan_level_t level,
+    const char *restrict msg, sadb_msg_t *restrict samsg)
+{
+	getlog(level)(blog, msg,
+	    BUNYAN_T_STRING, "msg_type", pfkey_type(samsg->sadb_msg_type),
+	    BUNYAN_T_UINT32, "msg_type_val", (uint32_t)samsg->sadb_msg_type,
+	    BUNYAN_T_STRING, "sa_type", pfkey_satype(samsg->sadb_msg_satype),
+	    BUNYAN_T_UINT32, "sa_type_val", (uint32_t)samsg->sadb_msg_satype,
+	    BUNYAN_T_UINT32, "msg_pid", samsg->sadb_msg_pid,
+	    BUNYAN_T_UINT32, "msg_seq", samsg->sadb_msg_seq,
+	    BUNYAN_T_UINT32, "msg_errno_val", (uint32_t)samsg->sadb_msg_errno,
+	    BUNYAN_T_STRING, "msg_errno", strerror(samsg->sadb_msg_errno),
+	    BUNYAN_T_UINT32, "msg_diagnostic_val",
+	    (uint32_t)samsg->sadb_x_msg_diagnostic,
+	    BUNYAN_T_UINT32, "msg_diagnostic",
+	    keysock_diag(samsg->sadb_x_msg_diagnostic),
+	    BUNYAN_T_UINT32, "length", (uint32_t)samsg->sadb_msg_len,
+	    BUNYAN_T_END);
+}
+
+void
+pfkey_init(void)
+{
+	int rc;
+
+	list_create(&pfreq_list, sizeof (pfreq_t), offsetof (pfreq_t, pr_node));
+
+	pfreq_cache = umem_cache_create("pfreq cache", sizeof (pfreq_t),
+	    sizeof (uint64_t), pfreq_ctor, NULL, NULL, NULL, NULL, 0);
+	if (pfreq_cache == NULL)
+		err(EXIT_FAILURE, "Unable to create pfreq cache");
+
+	pfkey = socket(PF_KEY, SOCK_RAW, PF_KEY_V2);
+	if (pfkey == -1)
+		err(EXIT_FAILURE, "Unable to create pf_key socket");
+
+	rc = bunyan_child(log, &pflog,
+	    BUNYAN_T_INT32, "socketfd", (int32_t)pfkey,
+	    BUNYAN_T_END);
+	if (rc != 0)
+		errx(EXIT_FAILURE, "Unable to create child logger: %s",
+		    strerror(rc));
+
+	pfkey_register(SADB_SATYPE_ESP);
+	pfkey_register(SADB_SATYPE_AH);
+
+	schedule_socket(pfkey, pfkey_inbound);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.c
new file mode 100644
index 0000000000..bb6c1ad27d
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.c
@@ -0,0 +1,506 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <errno.h>
+#include <ipsec_util.h>
+#include <locale.h>
+#include <note.h>
+#include <security/cryptoki.h>
+#include <stdarg.h>
+#include <string.h>
+#include <synch.h>
+#include <syslog.h>
+#include <sys/debug.h>
+#include "defs.h"
+#include "pkcs11.h"
+#include "worker.h"
+
+/*
+ * This largely handles PKCS#11 session handles as well as providing information
+ * and mapping from PKCS#11 mechanisms to their IKE equivalents.
+ *
+ * PKCS#11 session handles are somewhat quirky.  The documentation isn't
+ * explicit, but strongly implies that a given session handle
+ * (CK_SESSION_HANDLE) can only perform one crypto operation at a time.  As
+ * such, we create a PKCS#11 session handle for each worker thread (in fact
+ * worker.c`worker_init_one() guarantees that each worker thread has it's own
+ * session handle at worker thread creation.  PKCS#11 states (in the
+ * PKCS#11 Usage Guide) that all objects created on a given token are visible
+ * to any other session handles within the same process.  It also states that
+ * the PKCS#11 library is responsible for doing any necessary locking when
+ * a PKCS#11 object is manipulated.
+ *
+ * One quirk of how PKCS#11 handles session, is that when a session handle
+ * is destroyed, any non-presistent objects created by that session handle
+ * are destroyed (though as stated above, the PKCS#11 library takes care
+ * so that if one session is using an object in a PKCS#11 operation while
+ * another session tries to the same object while it's in use, the destruction
+ * will not intefere with the in-progress operation in the other session).
+ * Because the PKCS#11 objects in.ikev2d creates are associated with an
+ * IKE SA, the lifetime of the objects is tied to the lifetime of the IKE SA
+ * and not necessairly that of the worker thread.  As such, any session
+ * handles that are created need to be retained for the lifetime of the
+ * in.ikev2d process.  To accomplish this, we maintain a 'free list' of
+ * session handles.  Any worker threads that exit will have their
+ * session handles placed on the free list, and any requests for a new
+ * session handle will first try to grab a session handle from the
+ * free list before attempting to create a new session.
+ *
+ * If in the future, we wish to allow the use of multiple tokens, this
+ * will likely need to be reworked a bit.  Our pkcs11_softtoken allows
+ * effectively unlimited sessions (bounded by memory), but a hardware
+ * token may have a limit on the number of sessions that can be created,
+ * which might require a more complicated method of managing PKCS#11
+ * session handles.
+ */
+
+/*
+ * Per usr/src/lib/pkcs11/libpkcs11/common/metaGlobal.h, the metaslot
+ * is always slot 0
+ */
+#define	METASLOT_ID	(0)
+
+/*
+ * Unfortunately, the PKCS#11 header files don't define constants for the
+ * string fields in the CK_SLOT_INFO and CK_TOKEN_INFO structures, so
+ * we define them here based on their definitions in <security/pkcs11t.h>
+ */
+
+/* Sizes of CK_SLOT_INFO string fields + NUL */
+#define	PKCS11_MANUF_LEN	(33)
+#define	PKCS11_DESC_LEN		(65)
+
+/* Sizes of CK_TOKEN_INFO string fields + NUL */
+#define	PKCS11_LABEL_LEN	(33)
+#define	PKCS11_MODEL_LEN	(17)
+#define	PKCS11_SERIAL_LEN	(17)
+#define	PKCS11_UTCTIME_LEN	(17)
+
+/* pkcs11_init() sets this during startup and is never altered afterwards */
+CK_INFO			pkcs11_info = { 0 };
+
+static mutex_t			pkcs11_handle_lock;
+static CK_SESSION_HANDLE	*pkcs11_handles;
+static size_t			pkcs11_nhandles;
+static size_t			pkcs11_handlesz;
+
+#define	PKCS11_FUNC		"func"
+#define	PKCS11_RC		"errnum"
+#define	PKCS11_ERRMSG		"err"
+
+static void pkcs11_free(void *);
+static void fmtstr(char *, size_t, CK_UTF8CHAR *, size_t);
+static CK_RV pkcs11_callback_handler(CK_SESSION_HANDLE, CK_NOTIFICATION,
+    void *);
+static void log_slotinfo(CK_SLOT_ID);
+
+/*
+ * Entries with 0 for the PKCS#11 mechanism are ones that aren't supported
+ * by PKCS#11, so their values aren't used beyond the stringified name.
+ */
+encr_data_t encr_data[IKEV2_ENCR_MAX + 1] = {
+	/* p11, desc, mode, min, max, incr, default, blocksz, iv, icv */
+	{ 0, "NONE", MODE_NONE, 0, 0, 0, 0, 0, 0, 0, 0 },
+	{ CKM_DES_CBC, "DES_IV64", MODE_CBC, 64, 64, 0, 64, 8, 8, 0, 0 },
+	{ CKM_DES_CBC, "DES", MODE_CBC, 64, 64, 0, 64, 64, 8, 0, 0 },
+	{ CKM_DES3_CBC, "3DES", MODE_CBC, 192, 192, 0, 192, 8, 8, 0, 0 },
+	{ CKM_RC5_CBC, "RC5", MODE_CBC, 40, 2040, 1, 128, 8, 8, 0, 0 },
+	{ CKM_IDEA_CBC, "IDEA", MODE_CBC, 128, 128, 0, 128, 8, 8, 0, 0 },
+	{ CKM_CAST5_CBC, "CAST", MODE_CBC, 40, 128, 1, 128, 8, 8, 0, 0 },
+	{ CKM_BLOWFISH_CBC, "BLOWFISH", MODE_CBC, 40, 448, 1, 128, 8, 8, 0, 0 },
+	{ 0, "3IDEA", MODE_CBC, 128, 128, 0, 16, 8, 8, 0, 0 },
+	{ CKM_DES_CBC, "DES_IV32", MODE_CBC, 64, 64, 0, 64, 8, 4, 0, 0 },
+	{ CKM_RC4, "RC4", MODE_CBC, 0, 0, 0, 0, 0, 0, 0, 0 },
+	{ CKM_AES_CBC, "AES_CBC", MODE_CBC, 128, 256, 64, 0, 16, 16, 0, 0 },
+	{ CKM_AES_CTR, "AES_CTR", MODE_CTR,  128, 256, 64, 0, 16, 16, 0, 0 },
+	{ CKM_AES_CCM, "AES_CCM_8", MODE_CCM, 128, 256, 64, 0, 16, 16, 8, 3 },
+	{ CKM_AES_CCM, "AES_CCM_12", MODE_CCM, 128, 256, 64, 0, 16, 16, 12, 3 },
+	{ CKM_AES_CCM, "AES_CCM_12", MODE_CCM, 128, 256, 64, 0, 16, 16, 16, 3 },
+	{ CKM_AES_GCM, "AES_GCM_8", MODE_GCM, 128, 256, 64, 0, 16, 16, 8, 4 },
+	{ CKM_AES_GCM, "AES_GCM_12", MODE_GCM, 128, 256, 64, 0, 16, 16, 12, 4 },
+	{ CKM_AES_GCM, "AES_GCM_16", MODE_GCM, 128, 256, 64, 0, 16, 16, 16, 4 },
+	{ 0, "NULL_AES_GMAC", MODE_NONE, 128, 256, 64, 0, 16, 16, 16, 0 },
+	{ 0, "AES_XTS_AES", MODE_NONE, 128, 256, 64, 0, 0, 0, 0, 0 },
+	{ CKM_CAMELLIA_CBC, "CAMELLIA_CBC", MODE_CBC,
+	    128, 256, 64, 0, 16, 16, 0, 0 },
+	{ CKM_CAMELLIA_CTR, "CAMELLIA_CTR", MODE_CTR,
+	    128, 256, 64, 0, 16, 16, 0, 0 },
+	{ 0, "CAMELLIA_CCM_8", MODE_CCM, 128, 256, 64, 0, 16, 16, 8, 3 },
+	{ 0, "CAMELLIA_CCM_12", MODE_CCM, 128, 256, 64, 0, 16, 16, 12, 3 },
+	{ 0, "CAMELLIA_CCM_16", MODE_CCM, 128, 256, 64, 0, 16, 16, 16, 3 },
+};
+
+auth_data_t auth_data[IKEV2_XF_AUTH_MAX + 1] = {
+	{ 0, "NONE", 0, 0, 0 },
+	{ CKM_MD5_HMAC, "HMAC_MD5_96", 16, 16, 12 },
+	{ CKM_SHA_1_HMAC, "HMAC_SHA1_96", 20, 20, 12 },
+	{ CKM_DES_MAC, "DES_MAC", 0, 0, 0 },
+	{ 0, "KPDK_MD5", 0, 0, 0 },
+	{ CKM_AES_XCBC_MAC_96, "AES_XCBC_96", 16, 16, 12 },
+	{ CKM_MD5_HMAC, "HMAC_MD5_128", 16, 16, 16 },
+	{ CKM_SHA_1_HMAC, "HMAC_SHA1_160", 20, 20, 20 },
+	{ CKM_AES_CMAC, "AES_CMAC_96", 16, 16, 12 },
+
+	/*
+ 	 * These three aren't specified for IKE, just AH and ESP, so
+ 	 * their key length, etc. aren't needed.
+ 	 */
+	{ CKM_AES_GMAC, "AES_128_GMAC", 16, 0, 0 },
+	{ CKM_AES_GMAC, "AES_192_GMAC", 24, 0, 0 },
+	{ CKM_AES_GMAC, "AES_256_GMAC", 32, 0, 0 },
+
+	{ CKM_SHA256_HMAC, "HMAC_SHA2_256_128", 32, 32, 16 },
+	{ CKM_SHA384_HMAC, "HMAC_SHA2_384_192", 48, 48, 24 },
+	{ CKM_SHA512_HMAC, "HMAC_SHA2_512_256", 64, 64, 32 },
+};
+
+/*
+ * Locates the metaslot among the available slots.  If the metaslot
+ * is inable to be located, we terminate.
+ */
+void
+pkcs11_init(void)
+{
+	CK_RV			rv = CKR_OK;
+	CK_ULONG 		nslot = 0;
+	CK_C_INITIALIZE_ARGS	args = {
+		NULL_PTR,		/* CreateMutex */
+		NULL_PTR,		/* DestroyMutex */
+		NULL_PTR,		/* LockMutex */
+		NULL_PTR,		/* UnlockMutex */
+		CKF_OS_LOCKING_OK,	/* flags */
+		NULL_PTR		/* reserved */
+	};
+
+	VERIFY0(mutex_init(&pkcs11_handle_lock, USYNC_THREAD|LOCK_ERRORCHECK,
+	    NULL));
+
+	if ((rv = C_Initialize(&args)) != CKR_OK) {
+		PKCS11ERR(fatal, log, "C_Initialize", rv);
+		exit(EXIT_FAILURE);
+	}
+
+	if ((rv = C_GetInfo(&pkcs11_info)) != CKR_OK) {
+		PKCS11ERR(fatal, log, "C_Info", rv);
+		exit(EXIT_FAILURE);
+	}
+
+	if ((rv = C_GetSlotList(CK_FALSE, NULL, &nslot)) != CKR_OK) {
+		PKCS11ERR(fatal, log, "C_GetSlotList", rv);
+		exit(EXIT_FAILURE);
+	}
+
+	CK_SLOT_ID slots[nslot];
+
+	if ((rv = C_GetSlotList(CK_FALSE, slots, &nslot)) != CKR_OK) {
+		PKCS11ERR(fatal, log, "C_GetSlotList", rv);
+		exit(EXIT_FAILURE);
+	}
+
+	{
+		char manf[PKCS11_MANUF_LEN];
+		char libdesc[PKCS11_DESC_LEN];
+
+		fmtstr(manf, sizeof (manf), pkcs11_info.manufacturerID,
+		    sizeof (pkcs11_info.manufacturerID));
+		fmtstr(libdesc, sizeof (libdesc),
+		    pkcs11_info.libraryDescription,
+		    sizeof (pkcs11_info.libraryDescription));
+
+		(void) bunyan_debug(log, "PKCS#11 provider info",
+		    BUNYAN_T_STRING, "manufacturer", manf,
+		    BUNYAN_T_UINT32, "version.major",
+		    (uint32_t)pkcs11_info.cryptokiVersion.major,
+		    BUNYAN_T_UINT32, "version.minor",
+		    (uint32_t)pkcs11_info.cryptokiVersion.minor,
+		    BUNYAN_T_UINT64, "flags",
+		    (uint64_t)pkcs11_info.flags,
+		    BUNYAN_T_STRING, "library", libdesc,
+		    BUNYAN_T_UINT32, "lib.major",
+		    (uint32_t)pkcs11_info.libraryVersion.major,
+		    BUNYAN_T_UINT32, "lib.minor",
+		    (uint32_t)pkcs11_info.libraryVersion.minor,
+		    BUNYAN_T_UINT32, "numslots", nslot,
+		    BUNYAN_T_END);
+	}
+
+	for (size_t i = 0; i < nslot; i++)
+		log_slotinfo(slots[i]);
+}
+
+static void
+log_slotinfo(CK_SLOT_ID slot)
+{
+	CK_SLOT_INFO info = { 0 };
+	char manuf[PKCS11_MANUF_LEN];
+	CK_RV rv;
+
+	rv = C_GetSlotInfo(slot, &info);
+	if (rv != CKR_OK) {
+		PKCS11ERR(error, log, "C_GetSlotInfo", rv);
+		return;
+	}
+
+	{
+		char desc[PKCS11_DESC_LEN];
+		fmtstr(desc, sizeof (desc), info.slotDescription,
+		    sizeof (info.slotDescription));
+		fmtstr(manuf, sizeof (manuf), info.manufacturerID,
+		    sizeof (info.manufacturerID));
+
+		(void) bunyan_debug(log, "PKCS#11 slot Info",
+		    BUNYAN_T_UINT64, "slot", (uint64_t)slot,
+		    BUNYAN_T_STRING, "desc", desc,
+		    BUNYAN_T_STRING, "manufacturer", manuf,
+		    BUNYAN_T_UINT32, "hwversion.major",
+		    (uint32_t)info.hardwareVersion.major,
+		    BUNYAN_T_UINT32, "hwversion.minor",
+		    (uint32_t)info.hardwareVersion.minor,
+		    BUNYAN_T_UINT32, "fwversion.major",
+		    (uint32_t)info.firmwareVersion.major,
+		    BUNYAN_T_UINT32, "fwversion.minor",
+		    (uint32_t)info.firmwareVersion.minor,
+		    BUNYAN_T_UINT64, "flags", (uint64_t)info.flags,
+		    BUNYAN_T_BOOLEAN, "present",
+		    !!(info.flags & CKF_TOKEN_PRESENT),
+		    BUNYAN_T_BOOLEAN, "removable",
+		    !!(info.flags & CKF_REMOVABLE_DEVICE),
+		    BUNYAN_T_BOOLEAN, "hwslot", !!(info.flags & CKF_HW_SLOT),
+		    BUNYAN_T_END);
+	}
+
+	if (!(info.flags & CKF_TOKEN_PRESENT))
+		return;
+
+	CK_TOKEN_INFO tinfo = { 0 };
+	rv = C_GetTokenInfo(slot, &tinfo);
+	if (rv != CKR_OK)
+		PKCS11ERR(error, log, "C_GetTokenInfo", rv);
+
+	char label[PKCS11_LABEL_LEN];
+	char model[PKCS11_MODEL_LEN];
+	char serial[PKCS11_SERIAL_LEN];
+	char utctime[PKCS11_UTCTIME_LEN];
+
+	fmtstr(manuf, sizeof (manuf), tinfo.manufacturerID,
+	    sizeof (tinfo.manufacturerID));
+	fmtstr(label, sizeof (label), tinfo.label, sizeof (tinfo.label));
+	fmtstr(model, sizeof (model), tinfo.model, sizeof (tinfo.model));
+	fmtstr(serial, sizeof (serial), tinfo.serialNumber,
+	    sizeof (tinfo.serialNumber));
+	fmtstr(utctime, sizeof (utctime), tinfo.utcTime,
+	    sizeof (tinfo.utcTime));
+
+#define	F(_inf, _flg) BUNYAN_T_BOOLEAN, #_flg, ((_inf).flags & (_flg))
+	char flagstr[19];
+	(void) snprintf(flagstr, sizeof (flagstr), "0x%lu", info.flags);
+
+	(void) bunyan_debug(log, "PKCS#11 token info",
+	    BUNYAN_T_UINT32, "slot", (uint32_t)slot,
+	    BUNYAN_T_STRING, "label", label,
+	    BUNYAN_T_STRING, "manuf", manuf,
+	    BUNYAN_T_STRING, "model", model,
+	    BUNYAN_T_STRING, "serial", serial,
+	    BUNYAN_T_STRING, "flags", flagstr,
+	    F(info, CKF_RNG),
+	    F(info, CKF_WRITE_PROTECTED),
+	    F(info, CKF_LOGIN_REQUIRED),
+	    F(info, CKF_USER_PIN_INITIALIZED),
+	    F(info, CKF_RESTORE_KEY_NOT_NEEDED),
+	    F(info, CKF_CLOCK_ON_TOKEN),
+	    F(info, CKF_PROTECTED_AUTHENTICATION_PATH),
+	    F(info, CKF_DUAL_CRYPTO_OPERATIONS),
+	    F(info, CKF_TOKEN_INITIALIZED),
+	    F(info, CKF_SECONDARY_AUTHENTICATION),
+	    F(info, CKF_USER_PIN_COUNT_LOW),
+	    F(info, CKF_USER_PIN_FINAL_TRY),
+	    F(info, CKF_USER_PIN_LOCKED),
+	    F(info, CKF_USER_PIN_TO_BE_CHANGED),
+	    F(info, CKF_SO_PIN_COUNT_LOW),
+	    F(info, CKF_SO_PIN_FINAL_TRY),
+	    F(info, CKF_SO_PIN_LOCKED),
+	    F(info, CKF_SO_PIN_TO_BE_CHANGED),
+	    F(info, CKF_ERROR_STATE),
+	    BUNYAN_T_END);
+#undef F
+}
+
+void
+pkcs11_fini(void)
+{
+	CK_RV rv;
+
+	for (size_t i = 0; i < pkcs11_nhandles; i++) {
+		rv = C_CloseSession(pkcs11_handles[i]);
+		if (rv != CKR_OK)
+			PKCS11ERR(error, log, "C_CloseSession", rv);
+	}
+	free(pkcs11_handles);
+	pkcs11_handles = NULL;
+	pkcs11_nhandles = 0;
+	pkcs11_handlesz = 0;
+
+	rv = C_Finalize(NULL_PTR);
+	if (rv != CKR_OK)
+		PKCS11ERR(error, log, "C_Finalize", rv);
+}
+
+size_t
+ikev2_auth_icv_size(ikev2_xf_encr_t encr, ikev2_xf_auth_t auth)
+{
+	VERIFY3S(encr, >=, IKEV2_ENCR_NONE);
+	VERIFY3S(encr, <=, IKEV2_ENCR_MAX);
+	VERIFY3S(auth, >=, IKEV2_XF_AUTH_NONE);
+	VERIFY3S(auth, <=, IKEV2_XF_AUTH_MAX);
+
+	if (encr_data[encr].ed_icvlen != 0)
+		return (encr_data[encr].ed_icvlen);
+	return (auth_data[auth].ad_icvlen);
+}
+
+/*
+ * Destroy a PKCS#11 object with nicer error messages in case of failure.
+ */
+void
+pkcs11_destroy_obj(const char *name, CK_OBJECT_HANDLE_PTR objp,
+    bunyan_logger_t *l)
+{
+	CK_RV ret;
+
+	if (objp == NULL || *objp == CK_INVALID_HANDLE)
+		return;
+
+	if ((ret = C_DestroyObject(p11h(), *objp)) != CKR_OK) {
+		PKCS11ERR(error, (l == NULL) ? log : l, "C_DestroyObject", ret,
+		    BUNYAN_T_STRING, "objname", name);
+	} else {
+		*objp = CK_INVALID_HANDLE;
+	}
+}
+
+static CK_RV
+pkcs11_callback_handler(CK_SESSION_HANDLE session, CK_NOTIFICATION surrender,
+    void *context)
+{
+	_NOTE(ARGUNUSED(session, context));
+	VERIFY3U(surrender, ==, CKN_SURRENDER);
+
+	return (CKR_OK);
+}
+
+#define	CHUNK_SZ (8)
+void
+pkcs11_session_free(CK_SESSION_HANDLE h)
+{
+	if (h == CK_INVALID_HANDLE)
+		return;
+
+	/*
+	 * Per the PKCS#11 standard, multiple handles in the same process
+	 * share any objects created.  However, when a particular handle is
+	 * closed, any objects created by that handle are deleted.  Due to
+	 * this behavior, we do not close any sessions and instead keep
+	 * unused sessions around on a free list for re-use.
+	 *
+	 * It also means in the (hopefully) rare instance we cannot expand
+	 * 'handles' to hold additional unused handles, we just leak them.
+	 * In practice if we are so low on memory that we cannot expand
+	 * 'handles', things are likely messed up enough we'll probably
+	 * end up restarting things anyway.
+	 */
+	mutex_enter(&pkcs11_handle_lock);
+	if (pkcs11_nhandles + 1 > pkcs11_handlesz) {
+		CK_SESSION_HANDLE *nh = NULL;
+		size_t newamt = pkcs11_handlesz + CHUNK_SZ;
+
+		nh = reallocarray(pkcs11_handles, newamt,
+		    sizeof (CK_SESSION_HANDLE));
+		if (nh == NULL) {
+			STDERR(error, log,
+			    "reallocarray failed; PKCS#11 session handles"
+			    "will leak");
+			mutex_exit(&pkcs11_handle_lock);
+			return;
+		}
+
+		pkcs11_handles = nh;
+		pkcs11_handlesz = newamt;
+	}
+
+	pkcs11_handles[pkcs11_nhandles++] = h;
+	mutex_exit(&pkcs11_handle_lock);
+}
+
+CK_SESSION_HANDLE
+p11h(void)
+{
+	return (worker->w_p11);
+}
+
+CK_SESSION_HANDLE
+pkcs11_new_session(void)
+{
+	CK_SESSION_HANDLE h;
+	CK_RV ret;
+
+	mutex_enter(&pkcs11_handle_lock);
+	if (pkcs11_nhandles > 0) {
+		h = pkcs11_handles[--pkcs11_nhandles];
+		mutex_exit(&pkcs11_handle_lock);
+		return (h);
+	}
+	mutex_exit(&pkcs11_handle_lock);
+
+	ret = C_OpenSession(METASLOT_ID, CKF_SERIAL_SESSION, NULL,
+	    pkcs11_callback_handler, &h);
+
+	if (ret != CKR_OK) {
+		PKCS11ERR(error, log, "C_OpenSession", ret);
+		return (CK_INVALID_HANDLE);
+	}
+
+	return (h);
+}
+
+/*
+ * Sadly, string fields in PKCS#11 structs are not NUL-terminated and
+ * are space padded, so this converts it into a more traditional C-string
+ * with quoting so space padding is evident
+ */
+static void
+fmtstr(char *buf, size_t buflen, CK_UTF8CHAR *src, size_t srclen)
+{
+	ASSERT3U(srclen + 1, <=, buflen);
+
+	(void) memset(buf, 0, buflen);
+	(void) memcpy(buf, src, srclen);
+
+	for (char *p = buf + strlen(buf) - 1; p >= buf && *p == ' '; p--)
+		*p = '\0';
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.h
new file mode 100644
index 0000000000..5e17938a90
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkcs11.h
@@ -0,0 +1,112 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _PKCS11_H
+#define	_PKCS11_H
+
+#include <sys/types.h>
+#include <security/cryptoki.h>
+#include <bunyan.h>
+#include "defs.h"
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	PKCS11ERR(_lvl, _log, _p11f, _rv, ...)				\
+	(void) bunyan_##_lvl((_log), "PKCS#11 call failed",		\
+	BUNYAN_T_STRING, "file", __FILE__,				\
+	BUNYAN_T_UINT32, "line", (uint32_t)__LINE__,			\
+	BUNYAN_T_STRING, "func", __func__,				\
+	BUNYAN_T_STRING, "p11func", _p11f,				\
+	BUNYAN_T_UINT64, "errnum", (uint64_t)(_rv),			\
+	BUNYAN_T_STRING, "err", pkcs11_strerror(_rv),			\
+	## __VA_ARGS__,							\
+	BUNYAN_T_END)
+
+typedef enum encr_mode_e {
+	MODE_NONE,
+	MODE_CBC,
+	MODE_CTR,
+	MODE_CCM,
+	MODE_GCM
+} encr_modes_t;
+#define	MODE_IS_COMBINED(m) ((m) == MODE_CCM || (m) == MODE_GCM)
+
+typedef struct encr_data_s {
+	CK_MECHANISM_TYPE	ed_p11id;
+	const char		*ed_name;
+	encr_modes_t		ed_mode;
+	size_t			ed_keymin;	/* bits */
+	size_t			ed_keymax;	/* bits */
+	size_t			ed_keyincr;	/* bits */
+	size_t			ed_keydefault;
+	size_t			ed_blocklen;
+	size_t			ed_ivlen;
+	size_t			ed_icvlen;	/* For combined modes */
+	size_t			ed_saltlen;	/* For combined modes */
+} encr_data_t;
+#define	ENCR_KEYLEN_REQ(_e)	((_e)->ed_keydefault == 0)
+#define	ENCR_KEYLEN_ALLOWED(_e)	(!((_e)->ed_keymin == (_e)->ed_keymax))
+
+typedef struct auth_data_s {
+	CK_MECHANISM_TYPE	ad_p11id;
+	const char		*ad_name;
+	size_t			ad_keylen;
+	size_t			ad_outlen;
+	size_t			ad_icvlen;
+} auth_data_t;
+
+/*
+ * These are sized off IKEV2_{ENCR,XF_AUTH}_MAX.  Entries are intended to be
+ * directly indexed off the respective encryption or authentication value
+ * (e.g. encr_data[IKEV2_ENCR_AES_CBC] or
+ * auth_data[IKEV2_XF_AUTH_HMAC_SHA2_256_128).
+ */
+extern encr_data_t encr_data[];
+extern auth_data_t auth_data[];
+
+extern CK_INFO pkcs11_info;
+
+void pkcs11_init(void);
+void pkcs11_fini(void);
+
+CK_SESSION_HANDLE p11h(void);
+CK_SESSION_HANDLE pkcs11_new_session(void);
+void pkcs11_session_free(CK_SESSION_HANDLE);
+void pkcs11_destroy_obj(const char *, CK_OBJECT_HANDLE_PTR, bunyan_logger_t *);
+
+size_t ikev2_auth_icv_size(ikev2_xf_encr_t, ikev2_xf_auth_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PKCS11_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.c
new file mode 100644
index 0000000000..6677ba91b5
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.c
@@ -0,0 +1,831 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King.
+ * Copyright 2017 Joyent, Inc.
+ */
+#include <stddef.h>
+#include <assert.h>
+#include <umem.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/byteorder.h>
+#include <ipsec_util.h>
+#include <locale.h>
+#include <netinet/in.h>
+#include <security/cryptoki.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <pthread.h>
+#include <sys/debug.h>
+#include <note.h>
+#include <err.h>
+#include <limits.h>
+#include <bunyan.h>
+#include "ikev1.h"
+#include "ikev2.h"
+#include "ikev2_sa.h"
+#include "pkt.h"
+#include "pkt_impl.h"
+#include "pkcs11.h"
+
+static umem_cache_t	*pkt_cache;
+
+static int pkt_reset(void *);
+
+pkt_t *
+pkt_out_alloc(uint64_t i_spi, uint64_t r_spi, uint8_t version,
+    uint8_t exch_type, uint32_t msgid, uint8_t flags)
+{
+	pkt_t *pkt = umem_cache_alloc(pkt_cache, UMEM_DEFAULT);
+	ike_header_t *hdr = pkt_header(pkt);
+
+	if (pkt == NULL)
+		return (NULL);
+
+	hdr->initiator_spi = i_spi;
+	hdr->responder_spi = r_spi;
+	hdr->version = version;
+	hdr->exch_type = exch_type;
+	hdr->msgid = htonl(msgid);
+	hdr->flags = flags;
+
+	pkt->pkt_ptr += sizeof (ike_header_t);
+	return (pkt);
+}
+
+/*
+ * Allocate an pkt_t for an inbound packet, populate the local byte order
+ * header, and cache the location of the payloads in the payload field.
+ */
+pkt_t *
+pkt_in_alloc(uint8_t *restrict buf, size_t buflen, bunyan_logger_t *restrict l)
+{
+	ike_header_t *hdr = (ike_header_t *)buf;
+	pkt_t *pkt = NULL;
+	uint8_t first;
+
+	/* If inbound checks didn't catch these, it's a bug */
+	VERIFY3U(buflen, >=, sizeof (ike_header_t));
+	VERIFY3U(buflen, ==, ntohl(hdr->length));
+	VERIFY3U(buflen, <=, MAX_PACKET_SIZE);
+
+	first = hdr->next_payload;
+
+	if ((pkt = umem_cache_alloc(pkt_cache, UMEM_DEFAULT)) == NULL) {
+		STDERR(error, l, "umem_cache_alloc failed");
+		return (NULL);
+	}
+
+	(void) bunyan_trace(l, "Allocated new pkt_t",
+	    BUNYAN_T_POINTER, "pkt", pkt,
+	    BUNYAN_T_END);
+
+	(void) memcpy(pkt->pkt_raw, buf, buflen);
+	pkt->pkt_ptr += buflen;
+
+	if (!pkt_index_payloads(pkt, pkt_start(pkt) + sizeof (ike_header_t),
+	    pkt_len(pkt) - sizeof (ike_header_t), first, l)) {
+		pkt_free(pkt);
+		return (NULL);
+	}
+
+	(void) bunyan_trace(l, "Finished indexing payloads",
+	    BUNYAN_T_POINTER, "pkt", pkt,
+	    BUNYAN_T_UINT32, "num_payloads", pkt->pkt_payload_count,
+	    BUNYAN_T_END);
+
+	return (pkt);
+}
+
+struct index_data {
+	pkt_t		*id_pkt;
+	bunyan_logger_t	*id_log;
+};
+
+static pkt_walk_ret_t
+pkt_index_cb(uint8_t paytype, uint8_t resv, uint8_t *restrict ptr, size_t len,
+    void *restrict cookie)
+{
+	struct index_data *restrict data = cookie;
+	pkt_t *pkt = data->id_pkt;
+
+	if (!pkt_add_index(pkt, paytype, ptr, len)) {
+		(void) bunyan_info(data->id_log,
+		    "Could not add index to packet",
+		    BUNYAN_T_POINTER, "pkt", pkt,
+		    BUNYAN_T_END);
+		return (PKT_WALK_ERROR);
+	}
+
+	if (paytype != IKEV1_PAYLOAD_NOTIFY && paytype != IKEV2_PAYLOAD_NOTIFY)
+		return (PKT_WALK_OK);
+
+	ikev2_notify_t ntfy = { 0 };
+	uint64_t spi = 0;
+	uint32_t doi = 0;
+
+	if (len < sizeof (ikev2_notify_t)) {
+		bunyan_warn(data->id_log, "Notify payload is truncated",
+		    BUNYAN_T_END);
+		return (PKT_WALK_ERROR);
+	}
+
+	if (pkt_header(pkt)->version == IKEV1_VERSION) {
+		/*
+		 * The IKEv1 notification payload is identical to the IKEv2
+		 * with the exception of the 32-bit DOI field at the begining
+		 * of the struct.
+		 */
+	 	if (len < sizeof (ikev2_notify_t) + sizeof (uint32_t)) {
+			(void) bunyan_warn(data->id_log,
+			    "Notify payload is truncated",
+			    BUNYAN_T_END);
+			return (PKT_WALK_ERROR);
+		}
+
+		doi = BE_IN32(ptr);
+		ptr += sizeof (uint32_t);
+		len -= sizeof (uint32_t);
+	}
+
+	(void) memcpy(&ntfy, ptr, sizeof (ntfy));
+	ptr += sizeof (ntfy);
+	len -= sizeof (ntfy);
+
+	if (ntfy.n_spisize > 0) {
+		if (len < ntfy.n_spisize) {
+			(void) bunyan_warn(data->id_log,
+			    "Notify payload SPI length overruns payload",
+			    BUNYAN_T_UINT32, "spilen", (uint32_t)ntfy.n_spisize,
+			    BUNYAN_T_UINT32, "len", (uint32_t)len,
+			    BUNYAN_T_END);
+			return (PKT_WALK_ERROR);
+		}
+
+		/* This advances ptr for us */
+		if (!pkt_get_spi(&ptr, ntfy.n_spisize, &spi)) {
+			(void) bunyan_warn(data->id_log,
+			    "Invalid SPI length in notify payload",
+			    BUNYAN_T_UINT32, "spilen", (uint32_t)ntfy.n_spisize,
+			    BUNYAN_T_END);
+			return (PKT_WALK_ERROR);
+		}
+
+		len -= ntfy.n_spisize;
+	}
+
+	if (!pkt_add_nindex(pkt, spi, doi, ntfy.n_protoid, ntohs(ntfy.n_type),
+	    ptr, len))
+		return (PKT_WALK_ERROR);
+
+	return (PKT_WALK_OK);
+}
+
+/*
+ * Add entries to pkt->pkt_payloads and pkt->pkt_notify.
+ * NOTE: buf points to the ike_payload_t where it should start.  This
+ * allows embedded encrypted IKEv2 payloads to be able to be indexed
+ * after decryption by running this after decryption with the address of the
+ * first embedded encrypted payload.
+ */
+boolean_t
+pkt_index_payloads(pkt_t *pkt, uint8_t *buf, size_t buflen, uint8_t first,
+    bunyan_logger_t *restrict l)
+{
+	VERIFY3P(pkt_start(pkt), <=, buf);
+	VERIFY3P(pkt->pkt_ptr, >=, buf + buflen);
+
+	struct index_data data = {
+		.id_pkt = pkt,
+		.id_log = l
+	};
+
+	if (pkt_payload_walk(buf, buflen, pkt_index_cb, first,
+	    &data, l) != PKT_WALK_OK)
+		return (B_FALSE);
+	return (B_TRUE);
+}
+
+#define	PKT_CHUNK_SZ	(8)
+boolean_t
+pkt_add_index(pkt_t *pkt, uint8_t type, uint8_t *buf, uint16_t buflen)
+{
+	pkt_payload_t *pay = NULL;
+	ssize_t idx = pkt->pkt_payload_count - PKT_PAYLOAD_NUM;
+
+	if (pkt->pkt_payload_count < PKT_PAYLOAD_NUM) {
+		VERIFY3S(idx, <, 0);
+		pay = &pkt->pkt_payloads[pkt->pkt_payload_count];
+	} else if (idx < pkt->pkt_payload_alloc) {
+		VERIFY3S(idx, >=, 0);
+		pay = &pkt->pkt_payload_extra[idx];
+	} else {
+		pkt_payload_t *newpay = NULL;
+		size_t newsz = pkt->pkt_payload_alloc + PKT_CHUNK_SZ;
+		size_t amt = newsz * sizeof (pkt_payload_t);
+
+		VERIFY3U(amt, <, newsz);
+		VERIFY3U(amt, <=, sizeof (pkt_payload_t));
+
+		newpay = umem_zalloc(amt, UMEM_DEFAULT);
+		if (newpay == NULL)
+			return (B_FALSE);
+
+		if (pkt->pkt_payload_extra != NULL) {
+			/*
+			 * If the new size doesn't overflow, the original,
+			 * smaller size cannot either.
+			 */
+			(void) memcpy(newpay, pkt->pkt_payload_extra,
+			    pkt->pkt_payload_count * sizeof (pkt_payload_t));
+			umem_free(pkt->pkt_payload_extra,
+			    pkt->pkt_payload_alloc * sizeof (pkt_payload_t));
+		}
+
+		pkt->pkt_payload_extra = newpay;
+		pkt->pkt_payload_alloc = newsz;
+
+		VERIFY3S(idx, >=, 0);
+		pay = &pkt->pkt_payload_extra[idx];
+	}
+
+	pkt->pkt_payload_count++;
+	pay->pp_type = type;
+	pay->pp_ptr = buf;
+	pay->pp_len = buflen;
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_nindex(pkt_t *pkt, uint64_t spi, uint32_t doi, uint8_t proto,
+    uint16_t type, uint8_t *buf, size_t buflen)
+{
+	pkt_notify_t *n = NULL;
+	ssize_t idx = pkt->pkt_notify_count - PKT_NOTIFY_NUM;
+
+	if (pkt->pkt_notify_count < PKT_NOTIFY_NUM) {
+		VERIFY3S(idx, <, 0);
+		n = &pkt->pkt_notify[pkt->pkt_notify_count];
+	} else if (idx < pkt->pkt_notify_alloc) {
+		VERIFY3S(idx, >=, 0);
+		n = &pkt->pkt_notify_extra[idx];
+	} else {
+		pkt_notify_t *newn = NULL;
+		size_t newsz = pkt->pkt_notify_alloc + PKT_CHUNK_SZ;
+		size_t amt = newsz * sizeof (pkt_notify_t);
+
+		VERIFY3U(amt, <, newsz);
+		VERIFY3U(amt, <=, sizeof (pkt_notify_t));
+
+		newn = umem_zalloc(amt, UMEM_DEFAULT);
+		if (newn == NULL)
+			return (B_FALSE);
+
+		if (pkt->pkt_notify_extra != NULL) {
+			(void) memcpy(newn, pkt->pkt_notify_extra,
+			    pkt->pkt_notify_count * sizeof (pkt_notify_t));
+			umem_free(pkt->pkt_notify_extra,
+			    pkt->pkt_notify_alloc * sizeof (pkt_notify_t));
+		}
+
+		pkt->pkt_notify_extra = newn;
+		pkt->pkt_notify_alloc = newsz;
+
+		VERIFY3S(idx, >=, 0);
+		n = &pkt->pkt_notify_extra[idx];
+	}
+
+	pkt->pkt_notify_count++;
+	n->pn_type = type;
+	n->pn_ptr = buf;
+	n->pn_len = buflen;
+	n->pn_doi = doi;
+	n->pn_spi = spi;
+	n->pn_proto = proto;
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_payload(pkt_t *pkt, uint8_t ptype, uint8_t resv, size_t len)
+{
+	VERIFY(!pkt->pkt_done);
+
+	if (len > UINT16_MAX)
+		return (B_FALSE);
+	if (pkt_write_left(pkt) < len + sizeof (ike_payload_t))
+		return (B_FALSE);
+
+	ike_payload_t pld = {
+		.pay_next = 0,
+		.pay_reserved = resv,
+		.pay_length = htons(len + sizeof (ike_payload_t))
+	};
+
+	/* Special case for first payload */
+	if (pkt->pkt_payload_count == 0) {
+		VERIFY3U(pkt_len(pkt), ==, sizeof (ike_header_t));
+		pkt_header(pkt)->next_payload = ptype;
+	} else {
+		pkt_payload_t *pp =
+		    pkt_payload(pkt, pkt->pkt_payload_count - 1);
+		ike_payload_t *payp = ((ike_payload_t *)pp->pp_ptr) - 1;
+		payp->pay_next = ptype;
+	}
+
+	PKT_APPEND_STRUCT(pkt, pld);
+	return (pkt_add_index(pkt, ptype, pkt->pkt_ptr, len));
+}
+
+boolean_t
+pkt_add_sa(pkt_t *restrict pkt, pkt_sa_state_t *restrict pss)
+{
+	ike_payload_t *payp = (ike_payload_t *)pkt->pkt_ptr;
+	boolean_t ok;
+
+	if (pkt_header(pkt)->version == IKEV1_VERSION)
+		ok = pkt_add_payload(pkt, IKEV1_PAYLOAD_SA, 0, 0);
+	else
+		ok = pkt_add_payload(pkt, IKEV2_PAYLOAD_SA, 0, 0);
+
+	if (!ok)
+		return (B_FALSE);
+
+	(void) memset(pss, 0, sizeof (*pss));
+	pss->pss_pkt = pkt;
+	pss->pss_lenp = &payp->pay_length;
+	pss->pss_pld = pkt_payload(pkt, pkt->pkt_payload_count - 1);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_prop(pkt_sa_state_t *pss, uint8_t propnum, uint8_t proto, size_t spilen,
+    uint64_t spi)
+{
+	ike_prop_t	prop = { 0 };
+	uint16_t	val = 0, amt = sizeof (prop) + spilen;
+
+	VERIFY(!pss->pss_pkt->pkt_done);
+
+	if (pkt_write_left(pss->pss_pkt) < amt)
+		return (B_FALSE);
+
+	if (pss->pss_prop != NULL)
+		pss->pss_prop->prop_more = IKE_PROP_MORE;
+
+	pss->pss_prop = (ike_prop_t *)pss->pss_pkt->pkt_ptr;
+
+	prop.prop_len = htons(amt);
+	prop.prop_more = IKE_PROP_NONE;
+	prop.prop_num = propnum;
+	prop.prop_proto = proto;
+	prop.prop_spilen = spilen;
+	PKT_APPEND_STRUCT(pss->pss_pkt, prop);
+	/*
+	 * We've already checked there's enough room for the SPI with the
+	 * pkt_write_left() check above, so this better succeed.
+	 */
+	VERIFY(pkt_add_spi(pss->pss_pkt, spilen, spi));
+
+	pss->pss_pld->pp_len += amt;
+	pss->pss_xf = NULL;
+
+	val = BE_IN16(pss->pss_lenp);
+	val += amt;
+	BE_OUT16(pss->pss_lenp, val);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_xform(pkt_sa_state_t *pss, uint8_t xftype, uint16_t xfid)
+{
+	ike_xform_t	xf = { 0 };
+	size_t		proplen = BE_IN16(&pss->pss_prop->prop_len);
+	size_t		paylen = BE_IN16(pss->pss_lenp);
+
+	VERIFY(!pss->pss_pkt->pkt_done);
+	VERIFY3U(paylen, ==, pss->pss_pld->pp_len + sizeof (ike_payload_t));
+
+	proplen += sizeof (xf);
+	paylen += sizeof (xf);
+
+	if (pkt_write_left(pss->pss_pkt) < sizeof (xf) ||
+	    proplen > UINT16_MAX || paylen > UINT16_MAX)
+		return (B_FALSE);
+	if (pss->pss_prop->prop_numxform == UINT8_MAX)
+		return (B_FALSE);
+
+	if (pss->pss_xf != NULL)
+		pss->pss_xf->xf_more = IKE_XFORM_MORE;
+
+	pss->pss_xf = (ike_xform_t *)pss->pss_pkt->pkt_ptr;
+
+	xf.xf_len = htons(sizeof (xf));
+	xf.xf_more = IKE_XFORM_NONE;
+	xf.xf_type = xftype;
+	xf.xf_id = htons(xfid);
+	PKT_APPEND_STRUCT(pss->pss_pkt, xf);
+
+	/* This is uint8_t so it can be derefenced directly */
+	pss->pss_prop->prop_numxform++;
+
+	BE_OUT16(&pss->pss_prop->prop_len, proplen);
+	BE_OUT16(pss->pss_lenp, paylen);
+	pss->pss_pld->pp_len += sizeof (xf);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_xform_attr_tv(pkt_sa_state_t *pss, uint16_t type, uint16_t val)
+{
+	ike_xf_attr_t	attr = { 0 };
+	size_t		xflen = BE_IN16(&pss->pss_xf->xf_len);
+	size_t		proplen = BE_IN16(&pss->pss_prop->prop_len);
+	size_t		paylen = BE_IN16(pss->pss_lenp);
+
+	VERIFY3U(type, <=, IKE_ATTR_MAXTYPE);
+	VERIFY(!pss->pss_pkt->pkt_done);
+	VERIFY3U(paylen, ==, pss->pss_pld->pp_len + sizeof (ike_payload_t));
+
+	xflen += sizeof (attr);
+	proplen += sizeof (attr);
+	paylen += sizeof (attr);
+
+	if (pkt_write_left(pss->pss_pkt) < sizeof (attr) ||
+	    xflen > UINT16_MAX || proplen > UINT16_MAX || paylen > UINT16_MAX)
+		return (B_FALSE);
+
+	attr.attr_type = htons(IKE_ATTR_TYPE(IKE_ATTR_TV, type));
+	attr.attr_len = htons(val);
+	PKT_APPEND_STRUCT(pss->pss_pkt, attr);
+
+	BE_OUT16(&pss->pss_xf->xf_len, xflen);
+	BE_OUT16(&pss->pss_prop->prop_len, proplen);
+	BE_OUT16(pss->pss_lenp, paylen);
+	pss->pss_pld->pp_len += sizeof (attr);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_xform_attr_tlv(pkt_sa_state_t *pss, uint16_t type, const uint8_t *attrp,
+    size_t attrlen)
+{
+	ike_xf_attr_t attr = { 0 };
+	size_t		xflen = BE_IN16(&pss->pss_xf->xf_len);
+	size_t		proplen = BE_IN16(&pss->pss_prop->prop_len);
+	size_t		paylen = BE_IN16(pss->pss_lenp);
+	size_t		len = sizeof (attr) + attrlen;
+
+	VERIFY3U(type, <=, IKE_ATTR_MAXTYPE);
+
+	VERIFY(!pss->pss_pkt->pkt_done);
+	VERIFY3U(paylen, ==, pss->pss_pld->pp_len + sizeof (ike_payload_t));
+
+	/*
+	 * IKE_ATTR_MAXLEN is < UINT16_MAX, so if attrlen <= IKE_ATTR_MAXLEN,
+	 * len cannot have overflowed
+	 */
+	if (attrlen > IKE_ATTR_MAXLEN ||
+	    pkt_write_left(pss->pss_pkt) < len || paylen > UINT16_MAX ||
+	    proplen > UINT16_MAX || xflen > UINT16_MAX)
+		return (B_FALSE);
+
+	attr.attr_type = htons(IKE_ATTR_TYPE(IKE_ATTR_TLV, type));
+	attr.attr_len = htons(len);
+	PKT_APPEND_STRUCT(pss->pss_pkt, attr);
+	PKT_APPEND_DATA(pss->pss_pkt, attrp, attrlen);
+
+	BE_OUT16(&pss->pss_xf->xf_len, xflen);
+	BE_OUT16(&pss->pss_prop->prop_len, proplen);
+	BE_OUT16(pss->pss_lenp, paylen);
+	pss->pss_pld->pp_len += sizeof (attr);
+
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_add_notify(pkt_t *restrict pkt, uint32_t doi, uint8_t proto,
+    uint8_t spilen, uint64_t spi, uint16_t type, const void *restrict data,
+    size_t datalen)
+{
+	union {
+		ikev1_notify_t n1;
+		ikev2_notify_t n2;
+	} n;
+	uint8_t *ptr = NULL;
+	size_t len = spilen + datalen;
+
+	if (pkt_header(pkt)->version == IKEV1_VERSION) {
+		len += sizeof (ikev1_notify_t);
+
+		if (!pkt_add_payload(pkt, IKEV1_PAYLOAD_NOTIFY, 0, len))
+			return (B_FALSE);
+
+		n.n1.n_doi = htonl(doi);
+		n.n1.n_protoid = proto;
+		n.n1.n_spisize = spilen;
+		n.n1.n_type = htons(type);
+		PKT_APPEND_STRUCT(pkt, n.n1);
+	} else if (pkt_header(pkt)->version == IKEV2_VERSION) {
+		len += sizeof (ikev2_notify_t);
+
+		if (!pkt_add_payload(pkt, IKEV2_PAYLOAD_NOTIFY, 0, len))
+			return (B_FALSE);
+
+		n.n2.n_protoid = proto;
+		n.n2.n_spisize = spilen;
+		n.n2.n_type = htons(type);
+		PKT_APPEND_STRUCT(pkt, n.n2);
+	}
+
+	VERIFY(pkt_add_spi(pkt, spilen, spi));
+	ptr = pkt->pkt_ptr;
+	PKT_APPEND_DATA(pkt, data, datalen);
+
+	return (pkt_add_nindex(pkt, spi, doi, proto, type, ptr, datalen));
+}
+
+boolean_t
+pkt_add_cert(pkt_t *restrict pkt, uint8_t paytype, uint8_t encoding,
+    const void *data, size_t datalen)
+{
+	if (!pkt_add_payload(pkt, paytype, 0, datalen + 1))
+		return (B_FALSE);
+
+	pkt->pkt_ptr[0] = encoding;
+	pkt->pkt_ptr += 1;
+	PKT_APPEND_DATA(pkt, data, datalen);
+	return (B_TRUE);
+}
+
+/* pops off all the callbacks in preparation for sending */
+boolean_t
+pkt_done(pkt_t *pkt)
+{
+	ike_header_t *hdr = pkt_header(pkt);
+	hdr->length = htonl(pkt_len(pkt));
+	pkt->pkt_done = B_TRUE;
+	return (B_TRUE);
+}
+
+/*
+ * Call cb on each encountered payload.
+ * data - the first payload to walk
+ * len - total size of the buffer to walk (should end on payload boundary)
+ * cb - callback function to invoke on each payload
+ * first - payload type of the first payload
+ * cookie - data passed to callback
+ */
+pkt_walk_ret_t
+pkt_payload_walk(uint8_t *restrict data, size_t len, pkt_walk_fn_t cb,
+    uint8_t first, void *restrict cookie, bunyan_logger_t *restrict l)
+{
+	uint8_t			*ptr = data;
+	uint8_t			paytype = first;
+	pkt_walk_ret_t		ret = PKT_WALK_OK;
+
+	/* 0 is used for both IKEv1 and IKEv2 to indicate last payload */
+	while (len > 0 && paytype != 0) {
+		ike_payload_t pay = { 0 };
+
+		if (len < sizeof (pay)) {
+			bunyan_info(l, "Payload header is truncated",
+			    BUNYAN_T_UINT32, "paylen", (uint32_t)len,
+			    BUNYAN_T_END);
+			return (PKT_WALK_ERROR);
+		}
+
+		(void) memcpy(&pay, ptr, sizeof (pay));
+
+		/* this length includes the size of the header */
+		pay.pay_length = ntohs(pay.pay_length);
+
+		if (pay.pay_length > len) {
+			bunyan_info(l, "Payload size overruns end of packet",
+			    BUNYAN_T_UINT32, "paylen", (uint32_t)pay.pay_length,
+			    BUNYAN_T_END);
+			return (PKT_WALK_ERROR);
+		}
+
+		if (cb != NULL) {
+			ret = cb(paytype, pay.pay_reserved, ptr + sizeof (pay),
+			    pay.pay_length - sizeof (pay), cookie);
+			if (ret != PKT_WALK_OK)
+				break;
+		}
+
+		paytype = pay.pay_next;
+		ptr += pay.pay_length;
+		len -= pay.pay_length;
+	}
+
+	if (ret == PKT_WALK_OK && len > 0) {
+		bunyan_info(l, "Packet contains extranenous data",
+		    BUNYAN_T_UINT32, "amt", (uint32_t)len,
+		    BUNYAN_T_END);
+		return (PKT_WALK_ERROR);
+	}
+
+	return ((ret != PKT_WALK_OK) ? PKT_WALK_ERROR : PKT_WALK_OK);
+}
+
+static size_t
+pay_to_idx(pkt_t *pkt, pkt_payload_t *pay)
+{
+	if (pay == NULL)
+		return (0);
+
+	size_t idx = 0;
+	if (pay >= pkt->pkt_payloads &&
+	    pay < &pkt->pkt_payloads[PKT_PAYLOAD_NUM]) {
+		idx = (size_t)(pay - pkt->pkt_payloads);
+		VERIFY3U(idx, <, pkt->pkt_payload_count);
+		return (idx);
+	}
+
+	VERIFY3P(pay, >=, pkt->pkt_payload_extra);
+	VERIFY3P(pay, <, pkt->pkt_payload_extra + pkt->pkt_payload_count -
+	    PKT_PAYLOAD_NUM);
+	idx = (size_t)(pay - pkt->pkt_payload_extra);
+	return (idx);
+}
+
+pkt_payload_t *
+pkt_get_payload(pkt_t *pkt, uint8_t type, pkt_payload_t *start)
+{
+	size_t idx = pay_to_idx(pkt, start);
+
+	if (start != NULL)
+		idx++;
+
+	for (size_t i = idx; i < pkt->pkt_payload_count; i++) {
+		pkt_payload_t *pay = pkt_payload(pkt, i);
+
+		if (pay->pp_type == (uint8_t)type)
+			return (pay);
+	}
+	return (NULL);
+}
+
+static size_t
+notify_to_idx(pkt_t *pkt, pkt_notify_t *n)
+{
+	if (n == NULL)
+		return (0);
+
+	size_t idx = 0;
+
+	if (n >= pkt->pkt_notify &&
+	    n < &pkt->pkt_notify[PKT_NOTIFY_NUM]) {
+		idx = (size_t)(n - pkt->pkt_notify);
+		VERIFY3U(idx, <, pkt->pkt_notify_count);
+		return (idx);
+	}
+
+	VERIFY3P(n, >=, pkt->pkt_notify_extra);
+	VERIFY3P(n, <, pkt->pkt_notify_extra + pkt->pkt_notify_count -
+	    PKT_NOTIFY_NUM);
+
+	idx = (size_t)(n - pkt->pkt_notify_extra);
+	return (idx);
+}
+
+pkt_notify_t *
+pkt_get_notify(pkt_t *pkt, uint16_t type, pkt_notify_t *start)
+{
+	size_t idx = notify_to_idx(pkt, start);
+
+	if (start != NULL)
+		idx++;
+
+	for (uint16_t i = idx; i < pkt->pkt_notify_count; i++) {
+		pkt_notify_t *n = pkt_notify(pkt, i);
+
+		if (n->pn_type == (uint16_t)type)
+			return (n);
+	}
+	return (NULL);
+}
+
+boolean_t
+pkt_add_spi(pkt_t *pkt, size_t spilen, uint64_t spi)
+{
+	if (pkt_write_left(pkt) < spilen)
+		return (B_FALSE);
+
+	switch (spilen) {
+	case sizeof (uint32_t):
+		VERIFY3U(spi, <=, UINT_MAX);
+		put32(pkt, (uint32_t)spi);
+		break;
+	case sizeof (uint64_t):
+		put64(pkt, spi);
+		break;
+	case 0:
+		break;
+	default:
+		INVALID(spilen);
+	}
+	return (B_TRUE);
+}
+
+boolean_t
+pkt_get_spi(uint8_t *restrict *pptr, size_t len, uint64_t *restrict spip)
+{
+	*spip = 0;
+
+	/*
+	 * When writing an SPI, we only support 3 sizes -- 0, 4 (32-bits),
+	 * and 8 (64-bits) corresponding to the IKE SPI and AH/ESP SPI sizes.
+	 * Thus, trying to write an unsupported value is a programming error.
+	 * However it is possible we might encounter an unsupported SPI length
+	 * (though it would need to be for an unsupported protocol), so
+	 * if we encounter such a situation, we return an error instead of
+	 * aborting.
+	 */
+	switch (len) {
+	case 0:
+		return (B_TRUE);
+	case sizeof (uint32_t):
+		*spip = BE_IN32(*pptr);
+		*pptr += sizeof (uint32_t);
+		return (B_TRUE);
+	case sizeof (uint64_t):
+		*spip = BE_IN64(*pptr);
+		*pptr += sizeof (uint64_t);
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
+static int
+pkt_ctor(void *buf, void *ignore, int flags)
+{
+	_NOTE(ARGUNUSUED(ignore, flags))
+
+	pkt_t *pkt = buf;
+	(void) memset(pkt, 0, sizeof (pkt_t));
+	pkt->pkt_ptr = pkt_start(pkt);
+	return (0);
+}
+
+void
+pkt_free(pkt_t *pkt)
+{
+	if (pkt == NULL)
+		return;
+
+	size_t len = 0;
+	if (pkt->pkt_payload_extra != NULL) {
+		len = pkt->pkt_payload_alloc * sizeof (pkt_payload_t);
+		umem_free(pkt->pkt_payload_extra, len);
+	}
+
+	if (pkt->pkt_notify_extra != NULL) {
+		len = pkt->pkt_notify_alloc * sizeof (pkt_notify_t);
+		umem_free(pkt->pkt_notify_extra, len);
+	}
+
+	pkt_ctor(pkt, NULL, 0);
+	umem_cache_free(pkt_cache, pkt);
+}
+
+void
+pkt_init(void)
+{
+	pkt_cache = umem_cache_create("pkt cache", sizeof (pkt_t),
+	    sizeof (uint64_t), pkt_ctor, NULL, NULL, NULL, NULL, 0);
+	if (pkt_cache == NULL)
+		err(EXIT_FAILURE, "Unable to create pkt umem cache");
+}
+
+void
+pkt_fini(void)
+{
+	umem_cache_destroy(pkt_cache);
+}
+
+extern inline void put32(pkt_t *, uint32_t);
+extern inline void put64(pkt_t *, uint64_t);
+extern inline uint8_t *pkt_start(pkt_t *);
+extern inline ike_header_t *pkt_header(const pkt_t *pkt);
+extern inline size_t pkt_len(const pkt_t *);
+extern inline size_t pkt_write_left(const pkt_t *);
+extern inline pkt_payload_t *pkt_payload(pkt_t *, uint16_t);
+extern inline pkt_notify_t *pkt_notify(pkt_t *, uint16_t);
+extern inline ike_payload_t *pkt_idx_to_payload(pkt_payload_t *);
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.h
new file mode 100644
index 0000000000..3f6cdda132
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt.h
@@ -0,0 +1,250 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyirght 2017 Joyent, Inc.
+ */
+
+#ifndef _PKT_H
+#define	_PKT_H
+
+#include <stddef.h>
+#include <sys/types.h>
+#include "ike.h"
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ikev2_sa_s;
+struct pkt_s;
+struct pkt_stack_s;
+
+typedef struct pkt_s		pkt_t;
+
+/*
+ * For both payload and notify indices, the pointers point to start of
+ * the payload data, which immediately follows the respective headers.
+ * If either type of index (more likely notify) has no associated data,
+ * the length will equal zero, however the data pointer will still contain
+ * the start of where the data would be if present.  This makes it possible
+ * to still access the respective headers if necessary.
+ */
+typedef struct pkt_payload {
+	uint8_t		*pp_ptr;	/* Start of payload data */
+	uint16_t	pp_len;		/* Excludes payload header */
+	uint8_t		pp_type;
+} pkt_payload_t;
+/*
+ * All of the documented exchanges in RFC7296 use less than 16 payloads
+ * in any given packet of an exchange.  However certain payloads (CERT,
+ * CERTREQ, N, and V) can appear an arbitrary number of times in a packet.
+ * Typically this would be if a large number of certificates are being
+ * sent or requested in an exchange.  The value of 16 was chosen so
+ * that most of the time, we won't need to use pkt_payload_extra to
+ * hold additional indicies, and is a nice power of two.
+ */
+#define	PKT_PAYLOAD_NUM	(16)	/* usually don't need more than this */
+
+typedef struct pkt_notify {
+	uint8_t		*pn_ptr;	/* Start of payload data */
+	uint32_t	pn_doi;		/* Ignored with IKEv2 */
+	uint16_t	pn_len;		/* Excludes notify header + SPI */
+	uint16_t	pn_type;
+	uint8_t		pn_proto;
+	uint64_t	pn_spi;
+} pkt_notify_t;
+/*
+ * Similar to PKT_PAYLOAD_NUM, we choose a power of two that should be
+ * larger than the typical number of notification payloads that would
+ * appear in a packet of any given exchange.
+ */
+#define	PKT_NOTIFY_NUM	(8)
+
+/*
+ * RFC7296 Section 2 states that an implementation MUST accept
+ * payloads up to 1280 octects long, and SHOULD be able to send,
+ * receive, and support messages up to 3000 octets long.  We elect to
+ * round this up to the next power of two (8192).  Similar to the
+ * rational for the sizing of pkt_t.pkt_payloads and pkt_t.pkt_notify,
+ * unless a large number of certificates or certificate requests are included
+ * this should be more than enough, especially if the recommendation in RFC7296
+ * of using "Hash and URL" formats for the CERT and CERTREQ payloads is
+ * followed (instead of including the certificates and/or certificate chains).
+ */
+#define	MAX_PACKET_SIZE	(8192)
+struct pkt_s {
+				/* refheld */
+	struct ikev2_sa_s	*pkt_sa;
+
+				/* Transmit count */
+	size_t			pkt_xmit;
+
+				/* Raw packet data */
+	uint64_t		pkt_raw[SADB_8TO64(MAX_PACKET_SIZE)];
+
+				/*
+				 * Points to one past last bit of valid data
+				 * in pkt_raw
+				 */
+	uint8_t			*pkt_ptr;
+
+				/* Payload index */
+	pkt_payload_t		pkt_payloads[PKT_PAYLOAD_NUM];
+	pkt_payload_t		*pkt_payload_extra;
+	uint16_t		pkt_payload_count;
+	uint16_t		pkt_payload_alloc;
+
+	pkt_notify_t		pkt_notify[PKT_NOTIFY_NUM];
+	pkt_notify_t		*pkt_notify_extra;
+	uint16_t		pkt_notify_count;
+	uint16_t		pkt_notify_alloc;
+
+				/* Ready for transmit */
+	boolean_t		pkt_done;
+};
+
+/* Used to help construct SA payloads */
+typedef struct pkt_sa_state {
+	pkt_t		*pss_pkt;	/* Packet in question */
+	uint16_t	*pss_lenp;	/* Ptr to SA payload length field */
+	pkt_payload_t	*pss_pld;	/* Ptr to SA payload index */
+	ike_prop_t	*pss_prop;	/* Ptr to current proposal struct */
+	ike_xform_t	*pss_xf;	/* Ptr to current xform struct */
+} pkt_sa_state_t;
+
+inline uint8_t *
+pkt_start(pkt_t *pkt)
+{
+	return ((uint8_t *)&pkt->pkt_raw);
+}
+
+inline ike_header_t *
+pkt_header(const pkt_t *pkt)
+{
+	return ((ike_header_t *)&pkt->pkt_raw);
+}
+
+inline size_t
+pkt_len(const pkt_t *pkt)
+{
+	const uint8_t *start = (const uint8_t *)&pkt->pkt_raw;
+	size_t len = (size_t)(pkt->pkt_ptr - start);
+
+	VERIFY3P(pkt->pkt_ptr, >=, start);
+	VERIFY3U(len, <=, MAX_PACKET_SIZE);
+	return ((size_t)(pkt->pkt_ptr - start));
+}
+
+inline size_t
+pkt_write_left(const pkt_t *pkt)
+{
+	size_t len = pkt_len(pkt);
+	return (MAX_PACKET_SIZE - pkt_len(pkt));
+}
+
+inline pkt_payload_t *
+pkt_payload(pkt_t *pkt, uint16_t idx)
+{
+	VERIFY3U(idx, <, pkt->pkt_payload_count);
+	if (idx < PKT_PAYLOAD_NUM)
+		return (&pkt->pkt_payloads[idx]);
+	return (pkt->pkt_payload_extra + (idx - PKT_PAYLOAD_NUM));
+}
+
+inline ike_payload_t *
+pkt_idx_to_payload(pkt_payload_t *idxp)
+{
+	VERIFY3P(idxp->pp_ptr, !=, NULL);
+
+	/*
+	 * This _always_ points to the first byte after the ISAKMP/IKEV2
+	 * payload header (empty payloads will have pp_len set to 0.
+	 * ike_payload_t is defined as having byte alignment, so
+	 * we can always backup up from pp_ptr to get to the payload
+	 * header.
+	 */
+	ike_payload_t *pay = (ike_payload_t *)idxp->pp_ptr;
+	return (pay - 1);
+}
+
+inline pkt_notify_t *
+pkt_notify(pkt_t *pkt, uint16_t idx)
+{
+	VERIFY3U(idx, <, pkt->pkt_notify_count);
+	if (idx < PKT_NOTIFY_NUM)
+		return (&pkt->pkt_notify[idx]);
+	return (pkt->pkt_notify_extra + (idx - PKT_NOTIFY_NUM));
+}
+
+inline void
+put32(pkt_t *pkt, uint32_t val)
+{
+	BE_OUT32(pkt->pkt_ptr, val);
+	pkt->pkt_ptr += sizeof (uint32_t);
+}
+
+inline void
+put64(pkt_t *pkt, uint64_t val)
+{
+	BE_OUT64(pkt->pkt_ptr, val);
+	pkt->pkt_ptr += sizeof (uint64_t);
+}
+
+#define	PKT_APPEND_STRUCT(_pkt, _struct)				\
+do {									\
+	VERIFY3U(pkt_write_left(_pkt), >=, sizeof (_struct));		\
+	(void) memcpy((_pkt)->pkt_ptr, &(_struct), sizeof (_struct));	\
+	(_pkt)->pkt_ptr += sizeof (_struct);				\
+/*CONSTCOND*/								\
+} while (0)
+
+#define	PKT_APPEND_DATA(_pkt, _ptr, _len)		\
+do {							\
+	if ((_len) == 0)				\
+		break;					\
+	VERIFY3U(pkt_write_left(_pkt), >=, (_len));	\
+	(void) memcpy((_pkt)->pkt_ptr, (_ptr), (_len));	\
+	(_pkt)->pkt_ptr += (_len);			\
+/*CONSTCOND*/						\
+} while (0)
+
+void pkt_hdr_ntoh(ike_header_t *restrict, const ike_header_t *restrict);
+void pkt_hdr_hton(ike_header_t *restrict, const ike_header_t *restrict);
+
+boolean_t pkt_done(pkt_t *);
+void pkt_init(void);
+void pkt_fini(void);
+void pkt_free(pkt_t *);
+
+pkt_payload_t *pkt_get_payload(pkt_t *, uint8_t, pkt_payload_t *);
+pkt_notify_t *pkt_get_notify(pkt_t *, uint16_t, pkt_notify_t *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PKT_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt_impl.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt_impl.h
new file mode 100644
index 0000000000..c08e95d093
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/pkt_impl.h
@@ -0,0 +1,70 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2014 Jason King.  All rights reserved.
+ */
+
+#ifndef _PKT_IMPL_H
+#define	_PKT_IMPL_H
+
+#include "pkt.h"
+#include "ike.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct bunyan_logger;
+
+typedef enum pkt_walk_ret {
+	PKT_WALK_ERROR	= -1,
+	PKT_WALK_OK = 0,
+	PKT_WALK_STOP = 1
+} pkt_walk_ret_t;
+
+typedef pkt_walk_ret_t (*pkt_walk_fn_t)(uint8_t, uint8_t, uint8_t *restrict,
+    size_t, void *restrict);
+pkt_walk_ret_t pkt_payload_walk(uint8_t *restrict, size_t, pkt_walk_fn_t,
+    uint8_t, void *restrict, struct bunyan_logger *restrict);
+
+boolean_t pkt_count_payloads(uint8_t *restrict, size_t, uint8_t, size_t *,
+    size_t *, struct bunyan_logger *restrict);
+boolean_t pkt_index_payloads(pkt_t *, uint8_t *, size_t, uint8_t,
+    struct bunyan_logger *restrict);
+boolean_t pkt_add_index(pkt_t *, uint8_t, uint8_t *, uint16_t);
+boolean_t pkt_add_nindex(pkt_t *, uint64_t, uint32_t, uint8_t, uint16_t,
+    uint8_t *, size_t);
+
+pkt_t *pkt_in_alloc(uint8_t *restrict, size_t, struct bunyan_logger *restrict);
+pkt_t *pkt_out_alloc(uint64_t, uint64_t, uint8_t, uint8_t, uint32_t, uint8_t);
+void pkt_free(pkt_t *);
+
+boolean_t pkt_add_payload(pkt_t *, uint8_t, uint8_t, size_t);
+boolean_t pkt_add_sa(pkt_t *restrict, pkt_sa_state_t *restrict);
+boolean_t pkt_add_prop(pkt_sa_state_t *, uint8_t, uint8_t, size_t, uint64_t);
+boolean_t pkt_add_xform(pkt_sa_state_t *, uint8_t, uint16_t);
+boolean_t pkt_add_xform_attr_tv(pkt_sa_state_t *, uint16_t, uint16_t);
+boolean_t pkt_add_xform_attr_tlv(pkt_sa_state_t *restrict, uint16_t,
+    const uint8_t *restrict, size_t);
+boolean_t pkt_add_notify(pkt_t *restrict, uint32_t, uint8_t, uint8_t,
+    uint64_t, uint16_t, const void *restrict, size_t);
+boolean_t pkt_add_cert(pkt_t *restrict, uint8_t, uint8_t,
+    const void *restrict, size_t);
+
+boolean_t pkt_add_spi(pkt_t *, size_t, uint64_t);
+boolean_t pkt_get_spi(uint8_t *restrict *, size_t len, uint64_t *restrict);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PKT_IMPL_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.c
new file mode 100644
index 0000000000..63d9a9a53a
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.c
@@ -0,0 +1,2041 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <errno.h>
+#include <ctype.h>
+#include <libintl.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <net/pfkeyv2.h>
+#include <pthread.h>
+#include <synch.h>
+#include <assert.h>
+#include <bunyan.h>
+#include <err.h>
+
+#include "preshared.h"
+#include "defs.h"
+#include <ipsec_util.h>
+
+static FILE *fp;
+
+/* Preshared key lock */
+static pthread_rwlock_t ps_rwlock = PTHREAD_RWLOCK_INITIALIZER;
+
+#define	hd2num(hd) (((hd) >= '0' && (hd) <= '9') ? ((hd) - '0') : \
+	(((hd) >= 'a' && (hd) <= 'f') ? ((hd) - 'a' + 10) : ((hd) - 'A' + 10)))
+
+#define	ADDRBITS_V4	32	/* number of bits in IPv4 address */
+#define	ADDRBITS_V6	128	/* number of bits in IPv6 address */
+
+
+#define	CHR_CURLY_BRACE_OPEN		'{'
+#define	CHR_CURLY_BRACE_CLOSE		'}'
+#define	CHR_COMMENT_BEGIN		'#'
+#define	CHR_COLON			':'
+#define	CHR_SLASH			'/'
+#define	CHR_BACKSLASH			'\\'
+#define	CHR_DOUBLEQUOTE			'"'
+#define	CHR_SPACE			' '
+#define	CHR_NEWLINE			'\n'
+#define	CHR_TAB				'\t'
+#define	CHR_NULL			'\0'
+
+/*
+ * Error message strings
+ */
+
+static const char *err_arr [] = {
+#define	ERR_LOCID_MISMATCH		0
+	"Local Id value does not match the specified Localid type",
+#define	ERR_REMID_MISMATCH		1
+	"Remote Id does not match the remoteid type",
+#define	ERR_MAINMODE_LOCID_NOTIP	2
+	"Local Id can only be an IP address",
+#define	ERR_MAINMODE_REMID_NOTIP	3
+	"Remote Id can only be an IP address",
+#define	ERR_ENTRY_NOBEGINBRACE		4
+	"Syntax error - Entry does not start with an open brace",
+#define	ERR_INVALID_FIELDNAME		5
+	"Invalid attribute field name",
+#define	ERR_REPEATED_FIELD		6
+	"Field in an entry is repeated",
+#define	ERR_INVALID_LOCALID_TYPE	7
+	"Invalid Local Id type",
+#define	ERR_MISSING_LOCALID		8
+	"localid not defined",
+#define	ERR_MISSING_REMID		9
+	"remotedid not defined",
+#define	ERR_INVALID_REMID_TYPE		10
+	"Invalid Remote Id type",
+#define	ERR_INVALID_IKE_MODE		11
+	"Invalid Ike Mode",
+#define	ERR_INVALID_BIT_SPECIFIER	12
+	"Invalid Bit Specifier",
+#define	ERR_BITLEN2BIG			13
+	"Bit length too large",
+#define	ERR_WARN_LOWBITS_TRUNC		14
+	"Lower bits will be truncated",
+#define	ERR_STRING_NOT_HEX		15
+	"Invalid string format - hex string expected",
+#define	ERR_BADADDR_PREFIXLEN_PART	16
+	"Invalid prefix length format in address",
+#define	ERR_BADADDR_SLASH_UNEXPECTED	17
+	"Unxpected '/' in address string",
+#define	ERR_BADADDR_TRY_AGAIN		18
+	"Bad address string - try again later",
+#define	ERR_BADADDR_ADDRESS		19
+	"Bad address string",
+#define	ERR_BADADDR_MISMATCH		20
+	"Address versions do not match",
+#define	ERR_BADADDR_MCAST    21
+	"Multicast address not allowed",
+#define	ERR_BADADDR_4MAPPED    22
+	"V4 mapped in v6 address not allowed",
+#define	ERR_BADADDR_4COMPAT    23
+	"V4 compatible in v6 address not allowed",
+#define	ERR_INVALID_ASCII_STRING	24
+	"Syntax error in ASCII string or quotes",
+};
+
+
+/*
+ * Buffer to hold input line
+ */
+static char	linebuf[1024];
+
+
+/*
+ * Types of tokens
+ */
+#define	PS_TOK_BEGIN_CURLY_BRACE	1
+#define	PS_TOK_END_CURLY_BRACE		2
+#define	PS_TOK_FLD_TYPE			3
+#define	PS_TOK_FLD_VALUE		4
+
+
+/*
+ * The prototype syntax of this file used, e.g. "localid" and "localidtype".
+ * The aliases support transitioning to using same keywords as the ike/config
+ * parser, e.g. "local_id" and "local_id_type".
+ *
+ * Also, {local,remote}_addr are aliases for {local,remote}_id for now,
+ * eventually they should be handled differently.
+ */
+static const keywdtab_t fldstab[] = {
+	{ PS_FLD_LOCID,		"localid" },
+	{ PS_FLD_LOCID,		"local_id" },
+	{ PS_FLD_LOCID,		"local_addr" },
+	{ PS_FLD_LOCID_TYPE,	"localidtype" },
+	{ PS_FLD_LOCID_TYPE,	"local_id_type" },
+	{ PS_FLD_REMID,		"remoteid" },
+	{ PS_FLD_REMID,		"remote_id" },
+	{ PS_FLD_REMID,		"remote_addr" },
+	{ PS_FLD_REMID_TYPE,	"remoteidtype" },
+	{ PS_FLD_REMID_TYPE,	"remote_id_type" },
+	{ PS_FLD_IKE_MODE,	"ike_mode" },
+	{ PS_FLD_IKE_MODE,	"mode" },
+	{ PS_FLD_KEY,		"key" },
+};
+
+static const keywdtab_t idstab[] = {
+	{ PS_ID_IP,			"IP" },
+	{ PS_ID_IP4,			"IPv4" },
+	{ PS_ID_IP6,			"IPv6" },
+	{ PS_ID_IP,			"IP_SUBNET" },
+	{ PS_ID_IP4,			"IPv4_SUBNET" },
+	{ PS_ID_IP6,			"IPv6_SUBNET" },
+};
+
+static const keywdtab_t ikmstab[] = {
+	{ PS_IKM_MAIN,			"main" },
+};
+
+/*
+ * Head and tail of linked list of entry data structures
+ */
+static preshared_entry_t *ps_head, *ps_tail;
+
+/*
+ * Global counters for use in reporting approximate error location
+ * in config file
+ */
+static int err_line_number;
+static int err_entry_number;
+
+/*
+ * Function prototypes
+ */
+static int getidtype(char *);
+static int getfldtype(char *);
+static int getikmtype(char *);
+static int postprocess_entry(preshared_entry_t *, char **);
+static char *get_next_token(char **);
+static char *readnextline(FILE *);
+static preshared_entry_t *getnextentry(FILE *, char **);
+static uint8_t *parsekey(char *, uint_t *, uint_t *, char **);
+/* Note: in_get{prefilen,addr}, in6_getaddr stolen from ifconfig.c */
+static int in_getprefixlen(char *, boolean_t, int);
+static int in_getaddr(char *, struct sockaddr_storage *, int *, char **);
+static int in6_getaddr(char *, struct sockaddr_storage *, int *, char **);
+static boolean_t check_if_v6(char *);
+
+
+/*
+ * Functions
+ */
+
+/*
+ * Check for same preshared entry.
+ * Caller holds ps_rwlock as reader
+ */
+static boolean_t
+same_psent(preshared_entry_t *ptr, preshared_entry_t *ps)
+{
+	struct sockaddr_in	*ptr_v4, *ps_v4;
+	struct sockaddr_in6	*ptr_v6, *ps_v6;
+
+	assert(RW_LOCK_HELD(&ps_rwlock));
+
+	/*
+	 * Check for duplicate entries.  Preshared type
+	 * of IPv4/IPv6 has a NULL locid/remid string and
+	 * has the sockaddr_storages structures populated.
+	 * All others store themselves in the aforementioned
+	 * strings.
+	 */
+
+	/* Local and Remote ID types must match */
+	if ((ptr->pe_locidtype != ps->pe_locidtype) ||
+	    (ptr->pe_remidtype != ps->pe_remidtype))
+		return (B_FALSE);
+
+	/* Check local ids */
+	switch (ptr->pe_locidtype) {
+	case PS_ID_IP:
+	case PS_ID_IP4:
+	case PS_ID_SUBNET4:
+		ptr_v4 = (struct sockaddr_in *)&ptr->pe_locid_sa;
+		ps_v4 = (struct sockaddr_in *)&ps->pe_locid_sa;
+		if ((uint32_t)ptr_v4->sin_addr.s_addr !=
+		    (uint32_t)ps_v4->sin_addr.s_addr)
+			return (B_FALSE);
+		/*
+		 * Prefix length either same number or same error
+		 * PS_PLEN_NO_PREFIX for non subnet
+		 */
+		if (&ptr->pe_locid_plen != &ps->pe_locid_plen)
+			return (B_FALSE);
+		break;
+	case PS_ID_IP6:
+	case PS_ID_SUBNET6:
+		ptr_v6 = (struct sockaddr_in6 *)&ptr->pe_locid_sa;
+		ps_v6 = (struct sockaddr_in6 *)&ps->pe_locid_sa;
+		if (!(IN6_ARE_ADDR_EQUAL(&ptr_v6->sin6_addr,
+		    &ps_v6->sin6_addr)))
+			return (B_FALSE);
+		/*
+		 * Prefix length either same number or same error
+		 * PS_PLEN_NO_PREFIX for non subnet
+		 */
+		if (&ptr->pe_locid_plen != &ps->pe_locid_plen)
+			return (B_FALSE);
+		break;
+	default:
+		if (strcmp(ptr->pe_locid, ps->pe_locid) != 0)
+				return (B_FALSE);
+	}
+
+	/* Check remote ids */
+	switch (ptr->pe_remidtype) {
+	case PS_ID_IP:
+	case PS_ID_IP4:
+		ptr_v4 = (struct sockaddr_in *)&ptr->pe_remid_sa;
+		ps_v4 = (struct sockaddr_in *)&ps->pe_remid_sa;
+		if ((uint32_t)ptr_v4->sin_addr.s_addr !=
+		    (uint32_t)ps_v4->sin_addr.s_addr)
+			return (B_FALSE);
+		/*
+		 * Prefix length either same number or same error
+		 * PS_PLEN_NO_PREFIX for non subnet
+		 */
+		if (&ptr->pe_remid_plen != &ps->pe_remid_plen)
+			return (B_FALSE);
+		break;
+	case PS_ID_IP6:
+		ptr_v6 = (struct sockaddr_in6 *)&ptr->pe_remid_sa;
+		ps_v6 = (struct sockaddr_in6 *)&ps->pe_remid_sa;
+		if (!(IN6_ARE_ADDR_EQUAL(&ptr_v6->sin6_addr,
+		    &ps_v6->sin6_addr)))
+			return (B_FALSE);
+		/*
+		 * Prefix length either same number or same error
+		 * PS_PLEN_NO_PREFIX for non subnet
+		 */
+		if (&ptr->pe_remid_plen != &ps->pe_remid_plen)
+			return (B_FALSE);
+		break;
+	default:
+		if (strcmp(ptr->pe_remid, ps->pe_remid) != 0)
+				return (B_FALSE);
+	}
+	return (B_TRUE);
+}
+
+/*
+ * Check for duplicate preshared entry.
+ * Caller holds ps_rwlock as reader
+ */
+static boolean_t
+has_dup(preshared_entry_t *ps, preshared_entry_t **head)
+{
+	preshared_entry_t *ptr;
+
+	assert(RW_LOCK_HELD(&ps_rwlock));
+
+	if (ps == NULL) /* no op */
+		return (B_FALSE);
+
+	ptr = *head;
+
+	while (ptr != NULL) {
+		if (same_psent(ptr, ps))
+			return (B_TRUE);
+		ptr = ptr->pe_next;
+	}
+	return (B_FALSE);
+}
+
+/*
+ * Append entries to list.
+ * Caller holds ps_rwlock as writer
+ */
+static boolean_t
+append_to_list(preshared_entry_t *ps, preshared_entry_t **head,
+    preshared_entry_t **tail)
+{
+	assert(RW_WRITE_HELD(&ps_rwlock));
+
+	if (ps == NULL)		/* no op */
+		return (B_TRUE);
+	assert(ps->pe_refcnt > 0);
+	if (has_dup(ps, head)) {
+		(void) fprintf(stderr,
+		    gettext("Ignoring duplicate preshared entry.\n"));
+		PE_REFRELE(ps);
+		return (B_FALSE);
+	}
+	ps->pe_next = NULL;	/* will be last entry */
+	if (*head == NULL) {
+		/* list initialization  */
+		*head = *tail = ps;
+	} else {
+		(*tail)->pe_next = ps;
+		*tail = (*tail)->pe_next;
+	}
+	return (B_TRUE);
+}
+
+/*
+ * Appends preshared entry to list
+ * Holds ps_rwlock as writer
+ */
+boolean_t
+append_preshared_entry(preshared_entry_t *ps)
+{
+	boolean_t rc;
+
+	(void) pthread_rwlock_wrlock(&ps_rwlock);
+	rc = append_to_list(ps, &ps_head, &ps_tail);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (rc);
+}
+
+/*
+ * Frees preshared list
+ * Caller holds ps_rwlock as writer
+ */
+static void
+free_preshared_list(preshared_entry_t **head, preshared_entry_t **tail)
+{
+	preshared_entry_t	*ps;
+
+	assert(RW_WRITE_HELD(&ps_rwlock));
+
+	while (*head != NULL) {
+		/* Zero the old list in case of reloading. */
+		ps = *head;
+		if (ps == *tail)
+			*tail = NULL;
+		*head = ps->pe_next;
+		PE_REFRELE(ps);
+	}
+}
+
+static char *
+getidstr(int val)
+{
+	const keywdtab_t *idt;
+
+	for (idt = idstab; idt < A_END(idstab); idt++) {
+		if (val == idt->kw_tag)
+			return (idt->kw_str);
+	}
+	return (NULL);		/* not found */
+}
+
+static int
+getidtype(char *valp)
+{
+	const keywdtab_t *idt;
+
+	for (idt = idstab; idt < A_END(idstab); idt++) {
+		if (strcasecmp(valp, idt->kw_str) == 0)
+			return (idt->kw_tag);
+	}
+	return (-1);		/* not found */
+}
+
+static int
+getfldtype(char *valp)
+{
+	const keywdtab_t *fldt;
+
+	for (fldt = fldstab; fldt < A_END(fldstab); fldt++) {
+		if (strcasecmp(valp, fldt->kw_str) == 0)
+			return (fldt->kw_tag);
+	}
+	return (-1);		/* not found */
+}
+
+static char *
+getikmstr(int val)
+{
+	const keywdtab_t *idt;
+
+	for (idt = ikmstab; idt < A_END(ikmstab); idt++) {
+		if (val == idt->kw_tag)
+			return (idt->kw_str);
+	}
+	return (NULL);		/* not found */
+}
+
+static int
+getikmtype(char *valp)
+{
+	const keywdtab_t *ikmt;
+
+	for (ikmt = ikmstab; ikmt < A_END(ikmstab); ikmt++) {
+		if (strcasecmp(valp, ikmt->kw_str) == 0)
+			return (ikmt->kw_tag);
+	}
+	return (-1);		/* not found */
+
+}
+
+/*
+ * unlike the other get*str functions, this one mallocs the returned
+ * string, so the caller will need to free it.
+ */
+char *
+getkeystr(uint8_t *key, uint_t bytes, uint_t bits)
+{
+	uint8_t	*sp;
+	char	*dp, *buf;
+	uint_t	len;
+
+	/* assume two digits per byte, and no more than 4 digits of bitlen */
+	len = (bytes < 1) + 6;
+	if ((buf = malloc(len)) == NULL)
+		return (NULL);
+
+	sp = key;
+	dp = buf;
+	while (bytes-- != 0) {
+		(void) sprintf(dp, "%02x", *sp++);
+		dp += 2;
+	}
+	(void) sprintf(dp, "/%d", bits);
+
+	return (buf);
+}
+
+/*
+ * Parsing for hex key values.
+ * Return value:
+ *	Pointer to allocated buffer containing the key
+ *	Parameter, "len" contains length of key buffer on successful return
+ *	Parameter, "lbits" contains length of key in bits in the key buffer.
+ * Note:Stolen from ipseckey.c and then adapted for use here.
+ */
+static uint8_t *
+parsehexkey(char *input, uint_t *keybuflen, uint_t *lbits, char **errp)
+{
+	uint8_t *keyp, *keybufp;
+	uint_t i, hexlen = 0, bits, alloclen;
+
+	for (i = 0; input[i] != CHR_NULL && input[i] != CHR_SLASH; i++)
+		hexlen++;
+
+	if (input[i] == CHR_NULL) {
+		bits = 0;
+	} else {
+		/* Have /nn. */
+		input[i] = CHR_NULL;
+		if (sscanf((input + i + 1), "%u", &bits) != 1) {
+			*errp = (char *)err_arr[ERR_INVALID_BIT_SPECIFIER];
+			return (NULL);
+		}
+
+		/* hexlen in nibbles */
+		if (((bits + 3) >> 2) > hexlen) {
+			*errp = (char *)err_arr[ERR_BITLEN2BIG];
+			return (NULL);
+		}
+
+		/*
+		 * Adjust hexlen down if user gave us too small of a bit
+		 * count.
+		 */
+		if ((hexlen << 2) > bits + 3) {
+			/*
+			 * NOTE: Callers don't necessarily handle warnings
+			 * a successful return.
+			 */
+			*errp = (char *)err_arr[ERR_WARN_LOWBITS_TRUNC];
+			hexlen = (bits + 3) >> 2;
+			input[hexlen] = CHR_NULL;
+		}
+	}
+
+	/*
+	 * Allocate.  Remember, hexlen is in nibbles.
+	 */
+
+	alloclen = (hexlen/2 + (hexlen & 0x1));
+	keyp = malloc(alloclen);
+
+	if (keyp == NULL) {
+		*errp = strerror(errno);
+		return (NULL);
+	}
+
+	keybufp = keyp;
+	*keybuflen = alloclen;
+	if (bits == 0)
+		*lbits = (hexlen + (hexlen & 0x1)) << 2;
+	else
+		*lbits = bits;
+
+	/*
+	 * Read in nibbles.  Read in odd-numbered as shifted high.
+	 * (e.g. 123 becomes 0x1230).
+	 */
+
+	for (i = 0; input[i] != CHR_NULL; i += 2) {
+		boolean_t second = (input[i + 1] != CHR_NULL);
+
+		if (!isxdigit(input[i]) ||
+		    (!isxdigit(input[i + 1]) && second)) {
+			free(keybufp); /* free allocated memory on error */
+			*errp = (char *)err_arr[ERR_STRING_NOT_HEX];
+			return (NULL);
+		}
+		*keyp = (hd2num(input[i]) << 4);
+		if (second)
+			*keyp |= hd2num(input[i + 1]);
+		else
+			break;	/* out of for loop. */
+		keyp++;
+	}
+
+	/* bzero the remaining bits if we're a non-octet amount. */
+	if (bits & 0x7)
+		*((input[i] == CHR_NULL) ? keyp - 1 : keyp) &=
+		    0xff << (8 - (bits & 0x7));
+	return (keybufp);
+}
+/*
+ * Parsing for ASCII key values.
+ * Return value:
+ *	Pointer to allocated buffer containing the key
+ *	Parameter, "len" contains length of key buffer on successful return
+ *	Parameter, "lbits" contains length of key in bits in the key buffer.
+ * Note:Stolen from ipseckey.c and then adapted for use here.
+ */
+static uint8_t *
+parseasciikey(char *input, uint_t *keybuflen, uint_t *lbits, char **errp)
+{
+	uint8_t *keyp, *keybufp;
+	uint_t i, asciilen = 0;
+
+	/* Make sure the first and last characters are '"', unescaped */
+
+	if (input[0] != CHR_DOUBLEQUOTE)
+		goto invalid_ascii_string;
+
+	/* Set pointer past first quote, then find the end */
+	input++;
+
+	for (i = 0; input[i] != CHR_NULL; i++)
+		asciilen++;
+	/*
+	 * Length without trailing \0 and leading quote lopped off
+	 * from before must be at least 3 for a well formed key
+	 */
+	if (--asciilen < 3)
+		goto invalid_ascii_string;
+	/*
+	 * Make sure the last quote exists and is not escaped,
+	 * but also watch for valid "this string\\" syntax.
+	 */
+	if (input[asciilen] != CHR_DOUBLEQUOTE)
+		goto invalid_ascii_string;
+
+	/* We know we can dereference these because of length check above */
+	if ((input[asciilen - 1] == CHR_BACKSLASH) &&
+	    (input[asciilen - 2] != CHR_BACKSLASH))
+		goto invalid_ascii_string;
+
+	input[asciilen] = CHR_NULL;
+
+	/* Now we have something well-formed in quotes and length set */
+
+	/*
+	 * Allocate.  If we have backslashes, we can shrink later
+	 */
+
+	keyp = malloc(asciilen);
+	if (keyp == NULL) {
+		*errp = strerror(errno);
+		return (NULL);
+	}
+
+	keybufp = keyp;
+	/*
+	 * Read in bytes, but be aware of next byte for escape purposes
+	 */
+
+	for (i = 0; input[i] != CHR_NULL; i++) {
+		boolean_t second = (input[i + 1] != CHR_NULL);
+
+		if (!isascii(input[i]) ||
+		    (second && !isascii(input[i + 1]))) {
+			goto free_key_buffer;
+		}
+		/*
+		 * Consider backslash an escape character for
+		 * itself, single and double quotes, but not
+		 * for anything else
+		 */
+		if (second && (input[i] == CHR_BACKSLASH)) {
+			if (input[i + 1] == CHR_DOUBLEQUOTE ||
+			    input[i + 1] == CHR_BACKSLASH) {
+				*keyp = input[i + 1];
+				i++;
+				keyp++;
+				asciilen--;
+				continue; /* for loop */
+			}
+		}
+		*keyp = input[i];
+		keyp++;
+	}
+	/* Shrink to fit */
+	*keybuflen = asciilen;
+	*lbits = asciilen << 3;
+	keybufp = realloc(keybufp, asciilen);
+
+	return (keybufp);
+
+free_key_buffer:
+	free(keybufp);
+invalid_ascii_string:
+	*errp = (char *)err_arr[ERR_INVALID_ASCII_STRING];
+	return (NULL);
+}
+
+static uint8_t *
+parsekey(char *input, uint_t *keybuflen, uint_t *lbits, char **errp)
+{
+	/* Determine if this is an ASCII key or hex key */
+	if (input[0] == CHR_DOUBLEQUOTE) {
+		return (parseasciikey(input, keybuflen, lbits, errp));
+	} else {
+		return (parsehexkey(input, keybuflen, lbits, errp));
+	}
+}
+
+static boolean_t
+check_if_v6(char *abuf)
+{
+	char *cp;
+	for (cp = abuf; *cp != CHR_NULL; cp++) {
+		if (*cp == CHR_COLON)
+			return (B_TRUE);
+	}
+	return (B_FALSE);
+}
+
+static boolean_t
+valid_ip6_address(struct sockaddr_in6 *addr, char **errmsgp)
+{
+
+		/* is it mcast */
+		if (IN6_IS_ADDR_MULTICAST(&addr->sin6_addr)) {
+			*errmsgp = (char *)err_arr[ERR_BADADDR_MCAST];
+			return (B_FALSE);
+		}
+		/* is it v4 mapped */
+		if (IN6_IS_ADDR_V4MAPPED(&addr->sin6_addr)) {
+			*errmsgp = (char *)err_arr[ERR_BADADDR_4MAPPED];
+			return (B_FALSE);
+		}
+		/* is it v4 compat */
+		if (IN6_IS_ADDR_V4COMPAT(&addr->sin6_addr)) {
+			*errmsgp = (char *)err_arr[ERR_BADADDR_4COMPAT];
+			return (B_FALSE);
+		}
+
+		return (B_TRUE);
+}
+
+/*
+ * Post process preshared key entry.
+ * Caller holds ps_rwlock as reader
+ */
+static int
+postprocess_entry(preshared_entry_t *ps, char **errmsgp)
+{
+	assert(RW_LOCK_HELD(&ps_rwlock));
+
+	/* ID types default to IP. */
+	if ((ps->pe_flds_mask & PS_FLD_LOCID_TYPE) == 0) {
+		ps->pe_flds_mask |= PS_FLD_LOCID_TYPE;
+		ps->pe_locidtype = PS_ID_IP;
+	}
+	if ((ps->pe_flds_mask & PS_FLD_REMID_TYPE) == 0) {
+		ps->pe_flds_mask |= PS_FLD_REMID_TYPE;
+		ps->pe_remidtype = PS_ID_IP;
+	}
+
+	/*
+	 * Verify that all mandatory fields are there.
+	 * mandatory:  local_id and remote_id (or local_addr and remote_addr),
+	 * mode, and key.
+	 */
+
+	/*
+	 * Note: verify that semantic relationships among fields is fine
+	 * Since we only support main mode, we force the mode to be main.
+	 */
+
+	ps->pe_ike_mode = PS_IKM_MAIN;
+	if ((ps->pe_locidtype != PS_ID_IP) &&
+	    (ps->pe_locidtype != PS_ID_IP4) &&
+	    (ps->pe_locidtype != PS_ID_IP6)) {
+		*errmsgp = (char *)err_arr[ERR_MAINMODE_LOCID_NOTIP];
+		return (-1);
+	}
+	if ((ps->pe_remidtype != PS_ID_IP) &&
+	    (ps->pe_remidtype != PS_ID_IP4) &&
+	    (ps->pe_remidtype != PS_ID_IP6)) {
+		*errmsgp = (char *)err_arr[ERR_MAINMODE_REMID_NOTIP];
+		return (-1);
+	}
+
+	/*
+	 * Parse "id" values now and verify that they match the
+	 * "idtype" associated with them.
+	 * NOTE: Real work is TBD
+	 */
+	if (ps->pe_flds_mask & PS_FLD_LOCID_TYPE) {
+		int retval;
+
+		if (ps->pe_locid == NULL) {
+			*errmsgp = (char *)err_arr[ERR_MISSING_LOCALID];
+			return (-1);
+		}
+
+		switch (ps->pe_locidtype) {
+		case PS_ID_IP:
+		{
+			boolean_t isv6 = check_if_v6(ps->pe_locid);
+			if (isv6) {
+				ps->pe_locidtype = PS_ID_IP6;
+				retval = in6_getaddr(ps->pe_locid,
+				    &ps->pe_locid_sa, &ps->pe_locid_plen,
+				    errmsgp);
+			} else {
+				ps->pe_locidtype = PS_ID_IP4;
+				retval = in_getaddr(ps->pe_locid,
+				    &ps->pe_locid_sa, &ps->pe_locid_plen,
+				    errmsgp);
+			}
+			if (retval < 0)
+				return (-1);
+		}
+		break;
+		case PS_ID_IP4:
+		case PS_ID_SUBNET4:
+			retval = in_getaddr(ps->pe_locid, &ps->pe_locid_sa,
+			    &ps->pe_locid_plen, errmsgp);
+			if (retval < 0)
+				return (-1);
+			break;
+		case PS_ID_IP6:
+		case PS_ID_SUBNET6:
+			retval = in6_getaddr(ps->pe_locid, &ps->pe_locid_sa,
+			    &ps->pe_locid_plen, errmsgp);
+			if (retval < 0)
+				return (-1);
+			break;
+		case PS_ID_SUBNET:
+		{
+			boolean_t isv6 = check_if_v6(ps->pe_locid);
+			if (isv6) {
+				ps->pe_locidtype = PS_ID_SUBNET6;
+				retval = in6_getaddr(ps->pe_locid,
+				    &ps->pe_locid_sa, &ps->pe_locid_plen,
+				    errmsgp);
+			} else {
+				ps->pe_locidtype = PS_ID_SUBNET4;
+				retval = in_getaddr(ps->pe_locid,
+				    &ps->pe_locid_sa, &ps->pe_locid_plen,
+				    errmsgp);
+			}
+			if (retval < 0)
+				return (-1);
+		}
+		break;
+		case PS_ID_RANGE:
+			break;
+		case PS_ID_RANGE4:
+			break;
+		case PS_ID_RANGE6:
+			break;
+		case PS_ID_ASN1DN:
+			break;
+		case PS_ID_ASN1GN:
+			break;
+		case PS_ID_KEYID:
+			break;
+		case PS_ID_FQDN:
+			break;
+		case PS_ID_USER_FQDN:
+			break;
+		}
+	}
+	if (ps->pe_flds_mask & PS_FLD_REMID_TYPE) {
+		int retval;
+
+		if (ps->pe_remid == NULL) {
+			*errmsgp = (char *)err_arr[ERR_MISSING_REMID];
+			return (-1);
+		}
+		switch (ps->pe_remidtype) {
+		case PS_ID_IP:
+		{
+			boolean_t isv6 = check_if_v6(ps->pe_remid);
+			if (isv6) {
+				ps->pe_remidtype = PS_ID_IP6;
+				retval = in6_getaddr(ps->pe_remid,
+				    &ps->pe_remid_sa, &ps->pe_remid_plen,
+				    errmsgp);
+			} else {
+				ps->pe_remidtype = PS_ID_IP4;
+				retval = in_getaddr(ps->pe_remid,
+				    &ps->pe_remid_sa, &ps->pe_remid_plen,
+				    errmsgp);
+			}
+			if (retval < 0)
+				return (-1);
+		}
+		break;
+		case PS_ID_IP4:
+		case PS_ID_SUBNET4:
+			retval = in_getaddr(ps->pe_remid, &ps->pe_remid_sa,
+			    &ps->pe_remid_plen, errmsgp);
+			if (retval < 0)
+				return (-1);
+			break;
+		case PS_ID_IP6:
+		case PS_ID_SUBNET6:
+			retval = in6_getaddr(ps->pe_remid, &ps->pe_remid_sa,
+			    &ps->pe_remid_plen, errmsgp);
+			if (retval < 0)
+				return (-1);
+			break;
+		case PS_ID_SUBNET:
+		{
+			boolean_t isv6 = check_if_v6(ps->pe_remid);
+			if (isv6) {
+				ps->pe_remidtype = PS_ID_SUBNET6;
+				retval = in6_getaddr(ps->pe_remid,
+				    &ps->pe_remid_sa, &ps->pe_remid_plen,
+				    errmsgp);
+			} else {
+				ps->pe_remidtype = PS_ID_SUBNET4;
+				retval = in_getaddr(ps->pe_remid,
+				    &ps->pe_remid_sa, &ps->pe_remid_plen,
+				    errmsgp);
+			}
+			if (retval < 0)
+				return (-1);
+		}
+		break;
+		case PS_ID_RANGE:
+			break;
+		case PS_ID_RANGE4:
+			break;
+		case PS_ID_RANGE6:
+			break;
+		case PS_ID_ASN1DN:
+			break;
+		case PS_ID_ASN1GN:
+			break;
+		case PS_ID_KEYID:
+			break;
+		case PS_ID_FQDN:
+			break;
+		case PS_ID_USER_FQDN:
+			break;
+		}
+	}
+
+	/*
+	 * Reality check address families
+	 * Remote and local address families must match
+	 */
+	if (check_if_v6(ps->pe_locid) != check_if_v6(ps->pe_remid)) {
+		*errmsgp = (char *)err_arr[ERR_BADADDR_MISMATCH];
+		return (-1);
+	}
+
+	/* v6 */
+	if (ps->pe_remidtype == PS_ID_IP6 ||
+	    ps->pe_remidtype == PS_ID_SUBNET6) {
+		struct sockaddr_in6 *local =
+		    (struct sockaddr_in6 *)(&ps->pe_locid_sa);
+		struct sockaddr_in6 *remote =
+		    (struct sockaddr_in6 *)(&ps->pe_remid_sa);
+
+		if (!valid_ip6_address(local, errmsgp) ||
+		    !valid_ip6_address(remote, errmsgp)) {
+			return (-1);
+		}
+	} else {
+		/* v4 */
+		struct sockaddr_in *local =
+		    (struct sockaddr_in *)(&ps->pe_locid_sa);
+		struct sockaddr_in *remote =
+		    (struct sockaddr_in *)(&ps->pe_remid_sa);
+
+		/* are either mcast */
+		if (IN_MULTICAST(ntohl(local->sin_addr.s_addr)) ||
+		    IN_MULTICAST(ntohl(remote->sin_addr.s_addr))) {
+			*errmsgp = (char *)err_arr[ERR_BADADDR_MCAST];
+			return (-1);
+		}
+	}
+
+	return (0);		/* OK return */
+}
+
+/*
+ * Note: Code stolen from ifconfig.c and adapted.
+ *
+ * If "slash" is zero this parses the whole string as
+ * an integer. With "slash" non zero it parses the tail part as an integer.
+ *
+ * If it is not a valid integer this returns BAD_ADDR.
+ * If there is /<n> present this returns PS_PLEN_NO_PREFIX.
+ */
+static int
+in_getprefixlen(char *addr, boolean_t slash, int max_plen)
+{
+	int prefixlen;
+	char *str, *end;
+
+	if (slash) {
+		str = strchr(addr, CHR_SLASH);
+		if (str == NULL)
+			return (PS_PLEN_NO_PREFIX);
+		str++;
+	} else
+		str = addr;
+
+	prefixlen = strtol(str, &end, 10);
+	if (prefixlen < 0)
+		return (PS_PLEN_BAD_ADDR);
+	if (str == end)
+		return (PS_PLEN_BAD_ADDR);
+	if (max_plen != 0 && max_plen < prefixlen)
+		return (PS_PLEN_BAD_ADDR);
+	return (prefixlen);
+}
+
+
+/*
+ * Note: code stolen from ifconfig.c and adapted
+ *
+ * If the last argument is non-NULL allow a <addr>/<n> syntax and
+ * pass out <n> in *plenp.
+ * If <n> doesn't parse return PS_PLEN_BAD_ADDR as *plenp.
+ * If no /<n> is present return PS_PLEN_NO_PREFIX as *plenp.
+ */
+static int
+in_getaddr(char *s, struct sockaddr_storage *saddr, int *plenp, char **errp)
+{
+	struct sockaddr_in *sin = (struct sockaddr_in *)saddr;
+	struct hostent *hp;
+	struct netent *np;
+	char str[BUFSIZ];
+	int error_num;
+
+	(void) strncpy(str, s, sizeof (str));
+
+	/*
+	 * Look for '/'<n> (CHR_SLASH)is plenp
+	 */
+	if (plenp != NULL) {
+		char *cp;
+
+		*plenp = in_getprefixlen(str, B_TRUE, ADDRBITS_V4);
+		if (*plenp == PS_PLEN_BAD_ADDR) {
+			*errp = (char *)err_arr[ERR_BADADDR_PREFIXLEN_PART];
+			return (-1);
+		}
+		cp = strchr(str, CHR_SLASH);
+		if (cp != NULL)
+			*cp = CHR_NULL;
+	} else if (strchr(str, CHR_SLASH) != NULL) {
+		*errp = (char *)err_arr[ERR_BADADDR_SLASH_UNEXPECTED];
+		return (-1);
+	}
+
+	(void) memset(sin, 0, sizeof (*sin));
+
+	/*
+	 *	Try to catch attempts to set the broadcast address to all 1's.
+	 */
+	if (strcmp(str, "255.255.255.255") == 0 ||
+	    (strtoul(str, (char **)NULL, 0) == 0xffffffffUL)) {
+		sin->sin_family = AF_INET;
+		sin->sin_addr.s_addr = 0xffffffff;
+		return (0);
+	}
+
+	hp = getipnodebyname(str, AF_INET, 0, &error_num);
+	if (hp) {
+		sin->sin_family = hp->h_addrtype;
+		(void) memcpy(&sin->sin_addr, hp->h_addr, hp->h_length);
+		freehostent(hp);
+		return (0);
+	}
+	np = getnetbyname(str);
+	if (np) {
+		sin->sin_family = np->n_addrtype;
+		sin->sin_addr = inet_makeaddr(np->n_net, INADDR_ANY);
+		return (0);
+	}
+	if (error_num == TRY_AGAIN) {
+		*errp = (char *)err_arr[ERR_BADADDR_TRY_AGAIN];
+	} else {
+		*errp = (char *)err_arr[ERR_BADADDR_ADDRESS];
+	}
+	return (-1);
+}
+
+/*
+ * Note: Code stolen from ifconfig.c and adapted.
+ *
+ * If the third argument is non-NULL allow a <addr>/<n> syntax and
+ * pass out <n> in *plenp.
+ * If <n> doesn't parse return PS_PLEN_BAD_ADDR as *plenp.
+ * If no /<n> is present return PS_PLEN_NO_PREFIX as *plenp.
+ */
+static int
+in6_getaddr(char *s, struct sockaddr_storage *saddr, int *plenp, char **errp)
+{
+	struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)saddr;
+	struct hostent *hp;
+	char str[BUFSIZ];
+	int error_num;
+
+	(void) strncpy(str, s, sizeof (str));
+
+	/*
+	 * Look for '/'<n> (CHR_SLASH) is plenp
+	 */
+	if (plenp != NULL) {
+		char *cp;
+
+		*plenp = in_getprefixlen(str, B_TRUE, ADDRBITS_V6);
+		if (*plenp == PS_PLEN_BAD_ADDR) {
+			*errp = (char *)err_arr[ERR_BADADDR_PREFIXLEN_PART];
+			return (-1);
+		}
+		cp = strchr(str, CHR_SLASH);
+		if (cp != NULL)
+			*cp = CHR_NULL;
+	} else if (strchr(str, CHR_SLASH) != NULL) {
+		*errp = (char *)err_arr[ERR_BADADDR_SLASH_UNEXPECTED];
+		return (-1);
+	}
+
+	(void) memset(sin6, 0, sizeof (*sin6));
+
+	hp = getipnodebyname(str, AF_INET6, 0, &error_num);
+	if (hp) {
+		sin6->sin6_family = hp->h_addrtype;
+		(void) memcpy(&sin6->sin6_addr, hp->h_addr, hp->h_length);
+		freehostent(hp);
+		return (0);
+	}
+	if (error_num == TRY_AGAIN) {
+		*errp = (char *)err_arr[ERR_BADADDR_TRY_AGAIN];
+	} else {
+		*errp = (char *)err_arr[ERR_BADADDR_ADDRESS];
+	}
+	return (-1);
+}
+
+/*
+ * char *get_next_token(cpp)
+ *	cpp - on input should point within a null terminated buffer.
+ *	return value - on output will point to past spaces to first
+ *		non-space character that starts a token
+ *	cpp - on output will point past non-space token string pointed
+ *		by return value.
+ *	Side-effects: modifies a potential space character after token
+ *		to null to form  a null terminated token unless a
+ *		double-quote has been seen in the token
+ */
+static char *
+get_next_token(char **cpp)
+{
+	char *cp = *cpp;
+	char *startcp, *endcp;
+	boolean_t quote_seen = B_FALSE;
+
+	/* skip leading whitespaces */
+	while (*cp == CHR_SPACE || *cp == CHR_TAB || *cp == CHR_NEWLINE)
+		cp++;
+
+	if (*cp == CHR_NULL) {	/* end of string */
+		*cpp = NULL;
+		return (NULL);
+	}
+
+	startcp = endcp = cp;
+	while (*endcp != CHR_NULL &&
+	    ((*endcp != CHR_SPACE && *endcp != CHR_TAB) || quote_seen) &&
+	    *endcp != CHR_NEWLINE) {
+		/*
+		 * Within quotes, ignore spaces and tabs as delimiters
+		 * and take note of start and end quotes, ignoring
+		 * backslash escaped characters.
+		 */
+		if (*endcp == CHR_DOUBLEQUOTE &&
+		    ((endcp == startcp) ||
+		    ((endcp > startcp) && *(endcp - 1) != CHR_BACKSLASH)))
+			quote_seen = !quote_seen;
+		endcp++;
+	}
+	if (*endcp != CHR_NULL)
+		*endcp++ = CHR_NULL;
+	*cpp = endcp;
+	return (startcp);
+}
+
+static char *
+readnextline(FILE *fp)
+{
+	char *cp;
+
+	while ((cp = fgets(linebuf, sizeof (linebuf), fp)) != NULL) {
+		err_line_number++; /* NOTE approx - if long lines */
+		if (*cp == CHR_NEWLINE || *cp == CHR_COMMENT_BEGIN)
+			continue;
+		break;
+	}
+	if (cp == NULL)
+		return (NULL);
+	return (linebuf);
+}
+
+
+/*
+ * static preshared_entry_t *getnextentry(fp, errmpp)
+ *	fp
+ *		file pointer to open config file.
+ *	errmpp
+ *		pointer to pointer to buffer containing error message
+ *	return value
+ *		NULL when EOF is reached
+ *		pointer to valid entry otherwise
+ *
+ *	Function scans open input file to get the next entry read from
+ *	the file and instantiated in the preshared_entry_t data structure.
+ *	In case of invalid syntax entries the function exits and does
+ *	not return and process exits.
+ *
+ *	Caller holds ps_rwlock as reader.
+ */
+static preshared_entry_t *
+getnextentry(FILE *fp, char **errmpp)
+{
+	preshared_entry_t *ps;
+	char *cp;		/* pointer to scan input */
+	char *tp;
+	char *errmsg = NULL;
+	int cur_fld_type = -1;	/* "uninitialized" */
+	int entry_done = FALSE;
+	int next_token_expected = PS_TOK_BEGIN_CURLY_BRACE;
+
+	assert(RW_LOCK_HELD(&ps_rwlock));
+
+	*errmpp = NULL;
+
+	ps = calloc(1, sizeof (preshared_entry_t));	/* Auto-zeroes... */
+	if (ps == NULL) {
+		errmsg = strerror(errno);
+		goto fatal_error;
+	}
+	ps->pe_refcnt = 1;
+nextline:
+	/* get next line  */
+
+	/* skip comment and null lines */
+	while (((cp = readnextline(fp)) != NULL) &&
+	    (*cp == CHR_COMMENT_BEGIN || *cp == CHR_NULL))
+		;
+
+	if (cp == NULL) {
+		/* EOF  */
+		PE_REFRELE(ps);
+		return (NULL);
+	}
+
+	for (;;) {
+		if (entry_done == TRUE)
+			break;
+		tp = get_next_token(&cp);
+		if (tp == NULL)
+			goto nextline;
+process_newtoken:
+		/* skip rest of line if comment token */
+		if (*tp == CHR_COMMENT_BEGIN)
+			goto nextline;
+
+		switch (next_token_expected) {
+
+		case PS_TOK_BEGIN_CURLY_BRACE:
+			if (*tp != CHR_CURLY_BRACE_OPEN) {
+				errmsg = (char *)err_arr[
+				    ERR_ENTRY_NOBEGINBRACE];
+				goto bad_syntax;
+			}
+			err_entry_number++;
+			next_token_expected = PS_TOK_FLD_TYPE;
+
+			/*
+			 * Note: We skip tokens assuming whitespace
+			 * termination but relax that for this token.
+			 *
+			 * Reset scan pointer past this token (one character)
+			 * so pointer does not miss any tokens that may
+			 * be glued to this one with no whitespaces.
+			 */
+			tp++;	/* past brace */
+			if (*tp == CHR_NULL) {
+				/* past whitespace terminated brace */
+				tp++;
+			}
+			cp = tp;
+			break;
+
+		case PS_TOK_END_CURLY_BRACE:
+			/*
+			 * Do sanity checks on entry and other
+			 * post-processing
+			 */
+			if (postprocess_entry(ps, &errmsg) < 0)
+				goto bad_semantics;
+			entry_done = TRUE;
+			break;
+
+		case PS_TOK_FLD_TYPE:
+			/*
+			 * Note: could be end-of-entry too...
+			 * here we assume the closing brace is
+			 * preceded by a whitespace. We gave some latitude to
+			 * opening brace, but not to the closing brace
+			 */
+			if (*tp == CHR_CURLY_BRACE_CLOSE) {
+				/*
+				 * End of fields, reset expected token,
+				 * Also reset scan token so this
+				 */
+				next_token_expected = PS_TOK_END_CURLY_BRACE;
+				goto process_newtoken;
+			}
+
+			/* initialize cur_fld_type */
+			if ((cur_fld_type = getfldtype(tp)) < 0) {
+				errmsg = (char *)err_arr[ERR_INVALID_FIELDNAME];
+				goto bad_syntax;
+			}
+
+			if ((ps->pe_flds_mask & cur_fld_type) != 0) {
+				errmsg = (char *)err_arr[ERR_REPEATED_FIELD];
+				goto bad_syntax;
+			}
+
+			ps->pe_flds_mask |= cur_fld_type;
+
+			next_token_expected = PS_TOK_FLD_VALUE;
+			break;
+
+		case PS_TOK_FLD_VALUE:
+
+			/*
+			 * Note: we assume all value fields do
+			 * not embed any whitespace even for complicated
+			 * value syntax such as for "range". Is that a
+			 * "reasonable" assumption ?
+			 *
+			 * Note++: All things being strdup()'d below need
+			 * to be parsed and put into context dependent data
+			 * structures at some point (after entry is read or
+			 * right here).
+			 */
+			switch (cur_fld_type) {
+			case PS_FLD_LOCID_TYPE:
+				if ((ps->pe_locidtype = getidtype(tp)) < 0) {
+					errmsg = (char *)err_arr[
+					    ERR_INVALID_LOCALID_TYPE];
+					goto bad_syntax;
+				}
+				break;
+			case PS_FLD_LOCID:
+				ps->pe_locid = strdup(tp);
+				if (ps->pe_locid == NULL) {
+					errmsg = strerror(errno);
+					goto fatal_error;
+				}
+				break;
+			case PS_FLD_REMID_TYPE:
+				if ((ps->pe_remidtype = getidtype(tp)) < 0) {
+					errmsg = (char *)err_arr[
+					    ERR_INVALID_REMID_TYPE];
+					goto bad_syntax;
+				}
+				break;
+			case PS_FLD_REMID:
+				ps->pe_remid = strdup(tp);
+				if (ps->pe_remid == NULL) {
+					errmsg = strerror(errno);
+					goto fatal_error;
+				}
+				break;
+			case PS_FLD_IKE_MODE:
+				if ((ps->pe_ike_mode = getikmtype(tp)) < 0) {
+					errmsg = (char *)err_arr[
+					    ERR_INVALID_IKE_MODE];
+					goto bad_syntax;
+				}
+				break;
+			case PS_FLD_KEY:
+				ps->pe_keybuf = parsekey(tp,
+				    &ps->pe_keybuf_bytes,
+				    &ps->pe_keybuf_lbits, &errmsg);
+				if (ps->pe_keybuf == NULL)
+					goto fatal_error;
+				else if (errmsg != NULL) {
+					/*
+					 * Utter warning on otherwise okay
+					 * input.
+					 */
+					(void) fprintf(stderr,
+					    gettext("read_preshared: %s\n"),
+					    errmsg);
+				}
+				break;
+			default:
+				/* Should never happen - assert ? */
+				errmsg = (char *)err_arr[
+				    ERR_INVALID_FIELDNAME];
+				goto fatal_error;
+			}
+
+			next_token_expected = PS_TOK_FLD_TYPE;
+			break;
+		}
+	}
+	return (ps);
+	/*
+	 * TBD any differentiation in these errors ?
+	 */
+bad_semantics:
+bad_syntax:
+fatal_error:
+	if (ps != NULL)
+		PE_REFRELE(ps);
+	*errmpp = errmsg;
+	return (NULL);
+}
+
+
+/*
+ * Load any preshared keys.
+ * Boolean parameter 'replace' determines whether the newly-read entries
+ * will replace the existing list, or be appended to it.
+ * On success, returns a linked list of preshared entries, and sets the
+ * error message pointer *errmp to NULL.
+ * On failure, returns NULL and sets *errmp to an error message string.
+ *
+ * Holds ps_rwlock as writer.
+ */
+char *
+preshared_load(const char *ps_filename, int ps_fd, boolean_t replace)
+{
+	preshared_entry_t *ps, *tmp_head = NULL, *tmp_tail = NULL;
+	char *errmp;
+	boolean_t dupfound = B_FALSE;
+
+	(void) pthread_rwlock_wrlock(&ps_rwlock);
+
+	/* TODO more paranoia/permissions checks on file needed */
+
+	if (ps_filename == NULL)
+		fp = fdopen(ps_fd, "r");
+	else
+		fp = fopen(ps_filename, "r");
+	if (fp == NULL) {
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		if (errno == ENOENT)
+			return (NULL);	/* no file == empty file */
+		return (strerror(errno));
+	}
+
+	while ((ps = getnextentry(fp, &errmp)) != NULL) {
+		/* process the new entry */
+
+		/*
+		 * For now, create a list of just the new entries
+		 */
+		if (!replace) {
+			if (has_dup(ps, &ps_head)) {
+				/* Skip duplicates in master list */
+				PE_REFRELE(ps);
+				dupfound = B_TRUE;
+				continue;
+			}
+		}
+		assert(ps->pe_refcnt >= 1);
+		if (!append_to_list(ps, &tmp_head, &tmp_tail)) {
+			/* Duplicate found within new list */
+			dupfound = B_TRUE;
+		}
+	}
+
+	(void) fclose(fp);
+
+	if (errmp == NULL) {
+		/*
+		 * we read the list in successfully; either
+		 * replace or append to global list now.
+		 */
+		if (replace || ps_tail == NULL) {
+			free_preshared_list(&ps_head, &ps_tail);
+			ps_head = tmp_head;
+			ps_tail = tmp_tail;
+		} else {
+			ps_tail->pe_next = tmp_head;
+			ps_tail = tmp_tail;
+		}
+	} else {
+		/*
+		 * had problems reading new list; free it
+		 */
+		free_preshared_list(&tmp_head, &tmp_tail);
+	}
+
+	if (dupfound && (errmp == NULL)) {
+		/* Hack to key off of later, not user visible */
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		return ("DUP");
+	}
+
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (errmp);
+}
+
+/*
+ * Returns 0 if requested entry not found; 1 if deleted successfully.
+ * Holds ps_rwlock as writer.
+ */
+int
+delete_ps(preshared_entry_t *delp)
+{
+	preshared_entry_t	*curp, *prevp;
+
+	(void) pthread_rwlock_wrlock(&ps_rwlock);
+	if (ps_head == NULL) {
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		return (0);
+	}
+
+	if (delp == ps_head) {
+		/* CORNER CASE: Deletion of last entry */
+		if (ps_head == ps_tail)
+			ps_tail = NULL;
+		ps_head = delp->pe_next;
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		PE_REFRELE(delp);
+		return (1);
+	}
+
+	for (prevp = ps_head, curp = ps_head->pe_next; curp != NULL;
+	    prevp = curp, curp = curp->pe_next) {
+		if (curp == delp)
+			break;
+	}
+	if (curp == NULL) {
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		return (0);
+	}
+
+	prevp->pe_next = curp->pe_next;
+	if (curp == ps_tail)
+		ps_tail = prevp;
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	PE_REFRELE(curp);
+	return (1);
+}
+
+/*
+ * return -1 on error, number of preshared entries written on success
+ * Holds ps_rwlock as reader
+ */
+int
+write_preshared(int fd, char **errmp)
+{
+	preshared_entry_t	*pep;
+	FILE	*ofile;
+	char	*keyp;
+	int	written = 0;
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	if ((ofile = fdopen(fd, "w+")) == NULL) {
+		*errmp = strerror(errno);
+		(void) pthread_rwlock_unlock(&ps_rwlock);
+		return (-1);
+	}
+
+	for (pep = ps_head; pep != NULL; pep = pep->pe_next) {
+		const char *mdstr;
+
+		if ((keyp = getkeystr(pep->pe_keybuf, pep->pe_keybuf_bytes,
+		    pep->pe_keybuf_lbits)) == NULL) {
+			*errmp = strerror(errno);
+			(void) pthread_rwlock_unlock(&ps_rwlock);
+			return (-1);
+		}
+
+		if (pep->pe_locid != NULL) {
+			(void) fprintf(ofile, "{\n"
+			    "\tlocalidtype    %s\n\tlocalid        %s\n",
+			    getidstr(pep->pe_locidtype), pep->pe_locid);
+		} else {
+			(void) fprintf(ofile,
+			    "{\n\tlocalidtype    %s\n\tlocalid        ",
+			    getidstr(pep->pe_locidtype));
+			(void) dump_sockaddr(
+			    (struct sockaddr *)&pep->pe_locid_sa,
+			    (pep->pe_locid_plen > 0) ? pep->pe_locid_plen : 0,
+			    B_TRUE, ofile, B_FALSE);
+			(void) fprintf(ofile, "\n");
+		}
+
+		if (pep->pe_remid != NULL) {
+			(void) fprintf(ofile,
+			    "\tremoteidtype   %s\n\tremoteid       %s\n",
+			    getidstr(pep->pe_remidtype), pep->pe_remid);
+		} else {
+			(void) fprintf(ofile,
+			    "\tremoteidtype   %s\n\tremoteid       ",
+			    getidstr(pep->pe_remidtype));
+			(void) dump_sockaddr(
+			    (struct sockaddr *)&pep->pe_remid_sa,
+			    (pep->pe_remid_plen > 0) ? pep->pe_remid_plen : 0,
+			    B_TRUE, ofile, B_FALSE);
+			(void) fprintf(ofile, "\n");
+		}
+
+		mdstr = getikmstr(pep->pe_ike_mode);
+		if (mdstr != NULL)
+			(void) fprintf(ofile, "\tike_mode       %s\n", mdstr);
+
+		(void) fprintf(ofile, "\tkey            %s\n}\n", keyp);
+		free(memset(keyp, 0, strlen(keyp)));
+		written++;
+	}
+	(void) fclose(ofile);
+
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (written);
+}
+
+/*
+ * Convert a PS_ID_* to an SADB_IDENTTYPE_* constant.
+ * Returns SADB_IDENTTYPE_RESERVED on failure.
+ */
+int
+psid2sadb(int psid)
+{
+	switch (psid) {
+	case PS_ID_IP:
+	case PS_ID_IP4:
+	case PS_ID_IP6:
+		return (SADB_IDENTTYPE_RESERVED);
+	case PS_ID_SUBNET:
+	case PS_ID_SUBNET4:
+	case PS_ID_SUBNET6:
+		return (SADB_IDENTTYPE_PREFIX);
+	case PS_ID_RANGE:
+	case PS_ID_RANGE4:
+	case PS_ID_RANGE6:
+		return (SADB_X_IDENTTYPE_ADDR_RANGE);
+	case PS_ID_ASN1DN:
+		return (SADB_X_IDENTTYPE_DN);
+	case PS_ID_ASN1GN:
+		return (SADB_X_IDENTTYPE_GN);
+	case PS_ID_KEYID:
+		return (SADB_X_IDENTTYPE_KEY_ID);
+	case PS_ID_FQDN:
+		return (SADB_IDENTTYPE_FQDN);
+	case PS_ID_USER_FQDN:
+		return (SADB_IDENTTYPE_USER_FQDN);
+	}
+	return (SADB_IDENTTYPE_RESERVED);
+}
+
+int
+sadb2psid(int sadb)
+{
+	switch (sadb) {
+	case SADB_IDENTTYPE_PREFIX:
+		return (PS_ID_SUBNET);
+	case SADB_X_IDENTTYPE_ADDR_RANGE:
+		return (PS_ID_RANGE);
+	case SADB_X_IDENTTYPE_DN:
+		return (PS_ID_ASN1DN);
+	case SADB_X_IDENTTYPE_GN:
+		return (PS_ID_ASN1GN);
+	case SADB_X_IDENTTYPE_KEY_ID:
+		return (PS_ID_KEYID);
+	case SADB_IDENTTYPE_FQDN:
+		return (PS_ID_FQDN);
+	case SADB_IDENTTYPE_USER_FQDN:
+		return (PS_ID_USER_FQDN);
+	}
+	return (0);
+}
+
+/*
+ * Lookup preshared entry by ident
+ * Holds ps_rwlock as reader
+ */
+preshared_entry_t *
+lookup_ps_by_ident(sadb_ident_t *local, sadb_ident_t *remote)
+{
+	int	ltype, rtype;
+	char	*lid, *rid;
+	preshared_entry_t	*ps;
+
+	if (local == NULL || remote == NULL)
+		return (NULL);
+
+	lid = (char *)(local + 1);
+	rid = (char *)(remote + 1);
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	for (ps = ps_head; ps != NULL; ps = ps->pe_next) {
+
+		/*
+		 * Have to convert for each preshared (rather than converting
+		 * the passed-in sadb ids just once to preshared-style)
+		 * because there are multiple PS_ID_* for each SADB_IDENT_*.
+		 */
+		ltype = psid2sadb(ps->pe_locidtype);
+		rtype = psid2sadb(ps->pe_remidtype);
+
+		if ((local->sadb_ident_type != ltype) ||
+		    (remote->sadb_ident_type != rtype))
+			continue;
+
+		if (ps->pe_locidtype == PS_ID_FQDN ||
+		    ps->pe_locidtype == PS_ID_USER_FQDN) {
+			/*
+			 * Check for case insensitive match.
+			 */
+			if ((strcasecmp(ps->pe_locid, lid) == 0) &&
+			    (strcasecmp(ps->pe_remid, rid) == 0))
+				break;
+		} else {
+			/*
+			 * Otherwise just go for an exact match.
+			 */
+			if ((strcmp(ps->pe_locid, lid) == 0) &&
+			    (strcmp(ps->pe_remid, rid) == 0))
+				break;
+		}
+	}
+	if (ps != NULL)
+		PE_REFHOLD(ps);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (ps);
+}
+
+/*
+ * Stolen from kernel spd.c - maybe this should go in libipsecutil
+ *
+ * sleazy prefix-length-based compare.
+ */
+boolean_t
+ip_addr_match(uint8_t *addr1, int pfxlen, in6_addr_t *addr2p)
+{
+	int offset = pfxlen>>3;
+	int bitsleft = pfxlen & 7;
+	uint8_t *addr2 = (uint8_t *)addr2p;
+
+	/*
+	 * and there was much evil..
+	 * XXX should inline-expand the bcmp here and do this 32 bits
+	 * or 64 bits at a time..
+	 */
+	return ((bcmp(addr1, addr2, offset) == 0) &&
+	    ((bitsleft == 0) ||
+	    (((addr1[offset] ^ addr2[offset]) & (0xff<<(8-bitsleft))) == 0)));
+}
+
+/*
+ * Lookup preshared entry by v4 or v4 mapped v6 address
+ * Holds ps_rwlock as reader
+ */
+preshared_entry_t *
+lookup_ps_by_in_addr(struct in_addr *local, struct in_addr *remote)
+{
+	struct in_addr *inp;
+	struct in_addr in;
+	struct sockaddr_in	*loc_sin, *rem_sin;
+	struct sockaddr_in6	*loc_sin6, *rem_sin6;
+	preshared_entry_t *ps;
+	boolean_t loc_is_v6, rem_is_v6;
+	int pfxlen;
+
+	if (local == NULL || remote == NULL)
+		return (NULL);
+
+	bzero(&in, sizeof (struct in_addr));
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	/*
+	 * Also looks up IPv6 id type entries for mapped addresses
+	 */
+
+	for (ps = ps_head; ps != NULL; ps = ps->pe_next) {
+
+		/* filter on relevant id type first */
+		if ((ps->pe_locidtype != PS_ID_IP4 &&
+		    ps->pe_locidtype != PS_ID_IP6 &&
+		    ps->pe_locidtype != PS_ID_IP &&
+		    ps->pe_locidtype != PS_ID_SUBNET4 &&
+		    ps->pe_locidtype != PS_ID_SUBNET6 &&
+		    ps->pe_locidtype != PS_ID_SUBNET) ||
+		    (ps->pe_remidtype != PS_ID_IP4 &&
+		    ps->pe_remidtype != PS_ID_IP6 &&
+		    ps->pe_remidtype != PS_ID_IP &&
+		    ps->pe_remidtype != PS_ID_SUBNET4 &&
+		    ps->pe_remidtype != PS_ID_SUBNET6 &&
+		    ps->pe_remidtype != PS_ID_SUBNET))
+			continue; /* local and/or remote id types invalid */
+
+		/* establish format of address */
+		if ((ps->pe_locidtype == PS_ID_IP6 ||
+		    ps->pe_locidtype == PS_ID_SUBNET6) ||
+		    ((ps->pe_locidtype == PS_ID_IP ||
+		    ps->pe_locidtype == PS_ID_SUBNET) &&
+		    check_if_v6(ps->pe_locid)))
+			loc_is_v6 = B_TRUE;
+		else
+			loc_is_v6 = B_FALSE;
+		if ((ps->pe_remidtype == PS_ID_IP6 ||
+		    ps->pe_remidtype == PS_ID_SUBNET6) ||
+		    ((ps->pe_locidtype == PS_ID_IP ||
+		    ps->pe_locidtype == PS_ID_SUBNET) &&
+		    check_if_v6(ps->pe_remid)))
+			rem_is_v6 = B_TRUE;
+		else
+			rem_is_v6 = B_FALSE;
+
+		loc_sin = (struct sockaddr_in *)&ps->pe_locid_sa;
+		rem_sin = (struct sockaddr_in *)&ps->pe_remid_sa;
+		loc_sin6 = (struct sockaddr_in6 *)&ps->pe_locid_sa;
+		rem_sin6 = (struct sockaddr_in6 *)&ps->pe_remid_sa;
+
+		/* if v6 format, it is only interesting if v4mapped */
+		if (loc_is_v6 && !IN6_IS_ADDR_V4MAPPED(&loc_sin6->sin6_addr))
+			continue;	/* not v4 mapped v6 address */
+		if (rem_is_v6 && !IN6_IS_ADDR_V4MAPPED(&rem_sin6->sin6_addr))
+			continue;	/* not v4 mapped v6 address */
+
+
+		/* match localid */
+		if (loc_is_v6) {
+			IN6_V4MAPPED_TO_INADDR(&loc_sin6->sin6_addr, &in);
+			inp = &in;
+		} else {
+			inp = &loc_sin->sin_addr;
+		}
+
+		if (ps->pe_locid_plen < 0)
+			pfxlen = ADDRBITS_V4;
+		else
+			pfxlen = ps->pe_locid_plen;
+		if (!ip_addr_match((uint8_t *)&inp->s_addr, pfxlen,
+		    (in6_addr_t *)&local->s_addr))
+			continue; /* local id mismatched */
+
+		/* match remote id */
+		if (rem_is_v6) {
+			IN6_V4MAPPED_TO_INADDR(&rem_sin6->sin6_addr, &in);
+			inp = &in;
+		} else {
+			inp = &rem_sin->sin_addr;
+		}
+
+		if (ps->pe_remid_plen < 0)
+			pfxlen = ADDRBITS_V4;
+		else
+			pfxlen = ps->pe_remid_plen;
+		if (!ip_addr_match((uint8_t *)&inp->s_addr, pfxlen,
+		    (in6_addr_t *)&remote->s_addr))
+			continue; /* remote id mismatched */
+
+		/* match found for both local and remote id */
+		break; /* out of loop */
+	}
+	if (ps != NULL)
+		PE_REFHOLD(ps);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (ps); /* NULL if loop expires on its own */
+}
+
+/*
+ * Lookup preshared entry by v6 address
+ * Holds ps_rwlock as reader
+ */
+preshared_entry_t *
+lookup_ps_by_in6_addr(struct in6_addr *local, struct in6_addr *remote)
+{
+	preshared_entry_t *ps;
+	struct sockaddr_in6	*loc_sin6, *rem_sin6;
+	int pfxlen;
+
+	if (local == NULL || remote == NULL)
+		return (NULL);
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	for (ps = ps_head; ps != NULL; ps = ps->pe_next) {
+
+		/* filter on relevant id type first */
+		if ((ps->pe_locidtype != PS_ID_IP6 &&
+		    ps->pe_locidtype != PS_ID_IP &&
+		    ps->pe_locidtype != PS_ID_SUBNET &&
+		    ps->pe_locidtype != PS_ID_SUBNET6) ||
+		    (ps->pe_remidtype != PS_ID_IP6 &&
+		    ps->pe_remidtype != PS_ID_IP &&
+		    ps->pe_remidtype != PS_ID_SUBNET &&
+		    ps->pe_remidtype != PS_ID_SUBNET6))
+			continue; /* local and/or remote id types invalid */
+
+		/*
+		 * if PS_ID_IP or PS_ID_SUBNET, it is
+		 * only interesting if v6 format
+		 */
+		if ((ps->pe_locidtype == PS_ID_IP ||
+		    ps->pe_locidtype == PS_ID_SUBNET) &&
+		    !check_if_v6(ps->pe_locid))
+			continue; /* not v6 address */
+		if ((ps->pe_remidtype == PS_ID_IP ||
+		    ps->pe_remidtype == PS_ID_SUBNET) &&
+		    !check_if_v6(ps->pe_remid))
+			continue; /* not v6 address */
+
+		loc_sin6 = (struct sockaddr_in6 *)&ps->pe_locid_sa;
+		rem_sin6 = (struct sockaddr_in6 *)&ps->pe_remid_sa;
+
+		if (ps->pe_locid_plen < 0)
+			pfxlen = ADDRBITS_V6;
+		else
+			pfxlen = ps->pe_locid_plen;
+		if (!ip_addr_match((uint8_t *)&loc_sin6->sin6_addr, pfxlen,
+		    (in6_addr_t *)local))
+			continue; /* local id mismatched */
+
+		if (ps->pe_remid_plen < 0)
+			pfxlen = ADDRBITS_V6;
+		else
+			pfxlen = ps->pe_remid_plen;
+		if (!ip_addr_match((uint8_t *)&rem_sin6->sin6_addr, pfxlen,
+		    (in6_addr_t *)remote))
+			continue; /* remote id mismatched */
+		/* match found for both local and remote id */
+		break; /* out of loop */
+	}
+	if (ps != NULL)
+		PE_REFHOLD(ps);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (ps); /* NULL if loop expires on its own */
+}
+
+/*
+ * Lookup nth preshared key entry
+ * Holds ps_rwlock as reader
+ */
+preshared_entry_t *
+lookup_nth_ps(int n)
+{
+	preshared_entry_t	*ps;
+	int			cnt;
+
+	(void) pthread_rwlock_rdlock(&ps_rwlock);
+	for (cnt = 0, ps = ps_head; (cnt < n) && (ps != NULL);
+	    cnt++, ps = ps->pe_next)
+		;
+	if (ps != NULL)
+		PE_REFHOLD(ps);
+	(void) pthread_rwlock_unlock(&ps_rwlock);
+	return (ps);
+}
+
+/*
+ * Actual freeing function.
+ */
+void
+free_preshared(preshared_entry_t *pe)
+{
+	assert(pe->pe_refcnt == 0);
+	free(pe->pe_locid);
+	free(pe->pe_remid);
+	/* Use memset()'s return value to our advantage. */
+	free(memset(pe->pe_keybuf, 0, pe->pe_keybuf_bytes));
+	free(pe);
+}
+
+/*
+ * Read in a list of pre-shared keys.  Called from main() when the daemon first
+ * starts.
+ */
+void
+preshared_init(boolean_t ignore_errors)
+{
+	const char *filename = PRESHARED_KEY_FILE;
+	char *errorstr;
+
+	bunyan_info(log, "Loading preshared keys", BUNYAN_T_END);
+	errorstr = preshared_load(filename, -1, B_TRUE);
+
+	if (errorstr != NULL) {
+		if (strncmp(errorstr, "DUP", 3) == 0)
+			errorstr = gettext("Duplicate entries ignored\n");
+		/*
+		 * Error handling... Print to terminal, if exists.
+		 * Debug logging already taken care of by other functions.
+		 * Don't exit because we want to load other policy.
+		 */
+		bunyan_error(log, "Error reading preshared file",
+		    BUNYAN_T_STRING, "filename", filename,
+		    BUNYAN_T_STRING, "errmsg", errorstr);
+		if (!ignore_errors)
+			err(EXIT_FAILURE, "Fatal errors in %s", filename);
+	}
+}
+
+/*
+ * Called when the daemon catches SIGHUP.
+ * Currently equivalent to preshared_init().
+ */
+void
+preshared_reload(void)
+{
+	preshared_init(B_FALSE);
+}
+
+/*
+ * Random Notes:
+ * (a)
+ * Maybe a better syntax for fields is following which eliminates
+ * semantic relationships between two different fields (id and idtype) ???
+ * E.g.
+ * {
+ *	...
+ *	localid	ipv4		1.2.3.4
+ *	remoteid rangev4	1.2.3.4-5.6.7.8
+ *	...
+ *  }
+ *  Current design causes us to delay certain verifications into a
+ *  postprocess_XXX() routine which otherwise could be done while
+ *  parsing if syntax was as above.
+ *
+ * (b)
+ *	Current error handling has a generic design that prints only
+ *	error message, entry number and line number. Other options are
+ *	possible (e.g. parsekey() "original" code from danmcd prints
+ *	error messages specific to the error context which have more
+ *	detailed context). Perhaps we should change to direct printing
+ *	of specific error messages globally later, but for now stick
+ *	to the simple model coded above.
+ * (c) The getnexttoken() part can be improved by passing it some context
+ *	such as "expected token" and maybe the fieldname. This *may* help
+ *	allow a more flexible syntax for complex tokens such as ranges.
+ *	which cannot currently embed spaces but it would be nice to allow
+ *	them to do that and be delimited with a context sensitive delimiter.
+ * (d) Needs detection of duplicates in the database before inserting new
+ *	entry.
+ * (e) Can be enhanced to do hashes and better structures than a linked list
+ *	of entries.
+ */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.h
new file mode 100644
index 0000000000..71abd77855
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/preshared.h
@@ -0,0 +1,212 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef	_PRESHARED_H
+#define	_PRESHARED_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <sys/atomic.h>
+#include <netinet/in.h>
+#include <net/pfkeyv2.h>
+
+#define	PRESHARED_KEY_FILE	"/etc/inet/secret/ike.preshared"
+
+typedef struct preshared_entry_s {
+	struct preshared_entry_s	*pe_next;
+	int				pe_flds_mask;
+	int				pe_locidtype;
+	char				*pe_locid;
+	int				pe_remidtype;
+	char				*pe_remid;
+	int				pe_ike_mode;
+	uint8_t				*pe_keybuf;
+	uint_t				pe_keybuf_bytes;
+	uint_t				pe_keybuf_lbits;
+	struct sockaddr_storage		pe_locid_sa;
+	struct sockaddr_storage		pe_remid_sa;
+	int				pe_locid_plen;
+	int				pe_remid_plen;
+	volatile uint32_t		pe_refcnt;
+} preshared_entry_t;
+
+#define	PE_REFHOLD(pe)	atomic_inc_32(&(pe)->pe_refcnt)
+
+/* Stupid C tricks stolen from <assert.h>. */
+#define	PE_REFRELE(pe)	\
+	(void) ((atomic_dec_32_nv(&(pe)->pe_refcnt) != 0) ||	\
+	    (free_preshared(pe), 0))
+
+/*
+ * Types of Fields
+ * Note: used in pe_flds_mask; values bitwise distinct, not just unique
+ */
+#define	PS_FLD_COMMENT			0x01
+#define	PS_FLD_LOCID			0x02
+#define	PS_FLD_LOCID_TYPE		0x04
+#define	PS_FLD_REMID			0x08
+#define	PS_FLD_REMID_TYPE		0x10
+#define	PS_FLD_IKE_MODE			0x20
+#define	PS_FLD_KEY			0x40
+
+/*
+ * Type of Remote/Local Ids
+ * Note: used in pe_locidtype and pe_remidtype fields.
+ */
+#define	PS_ID_IP			1
+#define	PS_ID_IP4			2
+#define	PS_ID_IP6			3
+#define	PS_ID_SUBNET			4
+#define	PS_ID_SUBNET4			5
+#define	PS_ID_SUBNET6			6
+#define	PS_ID_RANGE4			7
+#define	PS_ID_RANGE6			8
+#define	PS_ID_ASN1DN			9
+#define	PS_ID_ASN1GN			10
+#define	PS_ID_KEYID			11
+#define	PS_ID_FQDN			12
+#define	PS_ID_USER_FQDN			13
+#define	PS_ID_RANGE			14
+
+
+/*
+ * Types of IKE Modes
+ * Note: used in pe_ike_mode field.
+ */
+#define	PS_IKM_MAIN			1
+#define	PS_IKM_AGGRESSIVE		2
+#define	PS_IKM_BOTH			3
+
+/*
+ * Prefix length "special values"
+ * Note: used in pe_locid_plen and pe_remid_plen fields
+ */
+#define	PS_PLEN_BAD_ADDR	-1	/* prefix is invalid */
+#define	PS_PLEN_NO_PREFIX	-2	/* no prefix was found */
+
+/*
+ * Interface function prototypes
+ *
+ */
+
+/*
+ * char *preshared_load()
+ *	args : char *ps_filename:	config file name
+ *	args : int  fd:			config file descriptor; will
+ *					be used if ps_filename is NULL.
+ *	args : boolean_t replace:	true => replace existing list;
+ *					false => append to existing list
+ * Return value
+ *	- NULL on success; pointer to error string on error.
+ *
+ *	Also on error, globals err_line_number/err_entry_number point
+ *	to approximate location of error.
+ */
+extern char *preshared_load(const char *, int, boolean_t);
+
+/*
+ * Append the given preshared_entry_t to the global list.
+ * Will NOT increase refcnt - the caller must refhold and let the list
+ * take over the reference.
+ */
+extern boolean_t append_preshared_entry(preshared_entry_t *);
+
+/*
+ * Actual freeing function.  Almost always called by the REFRELE macro.
+ */
+extern void free_preshared(preshared_entry_t *);
+
+/*
+ * psid2sadb(): convert PS_ID_* types to SADB_[X_]IDENTTYPE_* types
+ */
+extern int psid2sadb(int);
+
+/*
+ * Look up preshared entries by in_addr (IPv4)
+ *	- first arg localid
+ *	- second arg remoteid
+ *
+ * Returns a reference-held entry.
+ */
+extern preshared_entry_t *lookup_ps_by_in_addr(struct in_addr *,
+    struct in_addr *);
+
+/*
+ * Look up preshared entries by in_addr (IPv6)
+ *	- first arg localid
+ *	- second arg remoteid
+ *
+ * Returns a reference-held entry.
+ */
+extern preshared_entry_t *lookup_ps_by_in6_addr(struct in6_addr *,
+    struct in6_addr *);
+
+/*
+ * Look up preshared entries by identity
+ *	- first arg localid
+ *	- second arg remoteid
+ *
+ * Returns a reference-held entry.
+ */
+extern preshared_entry_t *lookup_ps_by_ident(sadb_ident_t *, sadb_ident_t *);
+
+/*
+ * Look up the nth preshared entry in our list
+ *	- first arg n
+ *
+ * Returns a reference-held entry.
+ */
+extern preshared_entry_t *lookup_nth_ps(int);
+
+/*
+ * Delete an entry from the list of preshareds.
+ *	- first arg points to the entry to be deleted
+ *	- returns 1 if entry successfully deleted; 0 if entry not found
+ */
+extern int delete_ps(preshared_entry_t *);
+
+/*
+ * Write the preshared entries out to a specified file
+ *	args : int  fd:			config file descriptor
+ *	args : char **errmp:		errpr message string
+ * Return value
+ *	- if the list was written successfully, returns the number
+ *	  of entries that were written; returns -1 on error.
+ *	  Also on error, errmp contains pointer to error message
+ *	  string and globals err_line_number/err_entry_number point
+ *	  to approximate location of error.
+ */
+extern int write_preshared(int, char **);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _PRESHARED_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.c
new file mode 100644
index 0000000000..8ad3f4d4eb
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.c
@@ -0,0 +1,411 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2014 Jason King.
+ */
+#include <bunyan.h>
+#include <limits.h>
+#include <security/cryptoki.h>
+#include <stdarg.h>
+#include <string.h>
+#include <sys/debug.h>
+#include <sys/md5.h>	/* For length constants */
+#include <sys/sha1.h>	/* For length constants */
+#include <sys/sha2.h>	/* For length constants */
+#include <umem.h>
+#include "defs.h"
+#include "ikev2.h"
+#include "prf.h"
+#include "pkcs11.h"
+
+/*
+ * This implements the pseudo-random function (PRF) as well as the streaming
+ * variant (prf+ or 'prfp plus') as described in RFC7296 2.13.  Briefly,
+ * the nonces from both the initiator and responder as well as the shared
+ * DH or ECC key from the IKE_SA_INIT are fed through the PRF function to
+ * generate a seed value.   The prfp+ function starts with this seed value
+ * and iteratively uses the previous values to generate new blocks of keying
+ * material.  For child SAs (either AH, ESP, or an IKE SA rekey), some
+ * additional inputs are mixed in.  RFC7206 secions 2.13 and 2.17 go into
+ * the complete details of what inputs are used when.
+ *
+ * As both the PRF and prfp+ functions use multiple disparate inputs that
+ * are concatented together to form the inputs to the functions, both prf()
+ * and prfplus_init() take a variable number of arguments which should be a
+ * sequence of uint8_t *, size_t pairs of parameters with a terminating NULL
+ * value.  The prf() and prfplus_init() functions will then take care of
+ * concatenating the inputs as required (generally the PCKS#11 C_*Update()
+ * functions do all the dirty work here for us).
+ *
+ * This is run per IKE SA, so a given prfp_t instance should never be shared
+ * between ikev2_sa_ts, and the caller must handle any synchronization of
+ * potentially simultaneous prf* calls with the same prfp_t.  Since the
+ * lifetime of any given prfp_t is currently always just the lifetime of the
+ * calling function, this shouldn't make things difficult.
+ */
+
+/*
+ * RFC7296 2.13 -- The prfp+ is only specified for 255 iterations of the
+ * underlying PRF function.
+ */
+#define	PRFP_ITER_MAX	(255)
+
+/*
+ * Output lengths of these digest algs, don't seem to have preexisting
+ * values for these anywhere.
+ */
+#define	AES_CMAC_LENGTH	(16)
+#define	AES_XCBC_LENGTH	(16)
+
+static boolean_t prfplus_update(prfp_t *);
+
+/*
+ * Run the given PRF algorithm for the given key and seed and place
+ * result into out.  The seed is passed as a sequence of uint8_t *, size_t
+ * pairs terminated by a final NULL
+ */
+boolean_t
+prf(ikev2_prf_t alg, CK_OBJECT_HANDLE key, uint8_t *restrict out, size_t outlen,
+    bunyan_logger_t *restrict l, ...)
+{
+	CK_SESSION_HANDLE	h = p11h();
+	CK_MECHANISM		mech;
+	CK_RV			rc = CKR_OK;
+	CK_ULONG		len = outlen;
+	uint8_t			*segp = NULL;
+	va_list			ap;
+
+	VERIFY3U(outlen, >=, ikev2_prf_outlen(alg));
+
+	mech.mechanism = ikev2_prf_to_p11(alg);
+	mech.pParameter = NULL;
+	mech.ulParameterLen = 0;
+
+	if ((rc = C_SignInit(h, &mech, key)) != CKR_OK) {
+		PKCS11ERR(error, l, "C_SignInit", rc);
+		return (B_FALSE);
+	}
+
+	va_start(ap, l);
+	while ((segp = va_arg(ap, uint8_t *)) != NULL) {
+		size_t seglen = va_arg(ap, size_t);
+
+		rc = C_SignUpdate(h, segp, seglen);
+		if (rc != CKR_OK) {
+			/* XXX: should we still call C_SignFinal? */
+			PKCS11ERR(error, l, "C_SignUpdate", rc);
+			return (B_FALSE);
+		}
+	}
+	va_end(ap);
+
+	rc = C_SignFinal(h, out, &len);
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, l, "C_SignFinal", rc,
+		    (rc == CKR_DATA_LEN_RANGE) ? BUNYAN_T_UINT64 : BUNYAN_T_END,
+		    "desiredlen", (uint64_t)len, BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	return (B_TRUE);
+}
+
+/*
+ * Inititalize a prf+ instance for the given algorithm, key, and seed.
+ */
+boolean_t
+prfplus_init(prfp_t *restrict prfp, ikev2_prf_t alg, CK_OBJECT_HANDLE key,
+    bunyan_logger_t *restrict l, ...)
+{
+	uint8_t		*p = NULL;
+	size_t		len = 0;
+	va_list		ap;
+
+	(void) memset(prfp, 0, sizeof (*prfp));
+
+	prfp->prfp_alg = alg;
+	prfp->prfp_key = key;
+	prfp->prfp_tbuflen = ikev2_prf_outlen(alg);
+
+	va_start(ap, l);
+	while (va_arg(ap, uint8_t *) != NULL)
+		prfp->prfp_seedlen += va_arg(ap, size_t);
+	va_end(ap);
+
+	prfp->prfp_tbuf[0] = umem_zalloc(prfp->prfp_tbuflen, UMEM_DEFAULT);
+	prfp->prfp_tbuf[1] = umem_zalloc(prfp->prfp_tbuflen, UMEM_DEFAULT);
+	prfp->prfp_seed = umem_zalloc(prfp->prfp_seedlen, UMEM_DEFAULT);
+	if (prfp->prfp_tbuf[0] == NULL || prfp->prfp_tbuf[1] == NULL ||
+	    prfp->prfp_seed == NULL) {
+		(void) bunyan_error(l, "Could not allocate memory for PRF+",
+		    BUNYAN_T_END);
+		goto fail;
+	}
+
+	va_start(ap, l);
+	while ((p = va_arg(ap, uint8_t *)) != NULL) {
+		size_t seglen = va_arg(ap, size_t);
+
+		(void) memcpy(prfp->prfp_seed + len, p, seglen);
+		len += seglen;
+	}
+	va_end(ap);
+
+	/*
+	 * Per RFC7296 2.13, prf+(K, S) = T1 | T2 | T3 | T4 | ...
+	 *
+	 * where:
+	 * 	T1 = prf (K, S | 0x01)
+	 * 	T2 = prf (K, T1 | S | 0x02)
+	 * 	T3 = prf (K, T2 | S | 0x03)
+	 * 	T4 = prf (K, T3 | S | 0x04)
+	 *
+	 * Since the next iteration uses the previous iteration's output (plus
+	 * the seed and iteration number), we keep a copy of the output of the
+	 * current iteration as well as the previous iteration.  We use the
+	 * low bit of the current iteration number to index into prfp_tbuf
+	 * (and effectively flip flow between the two buffers).
+	 */
+	prfp->prfp_n = 1;
+
+	/*
+	 * Fill prfp->tbuf[1] with T1. T1 is defined as:
+	 * 	T1 = prf (K, S | 0x01)
+	 *
+	 * Note that this is different from subsequent iterations, hence
+	 * starting at prfp->prfp_arg[1], not prfp->arg[0]
+	 */
+	if (!prf(prfp->prfp_alg, prfp->prfp_key,
+	    prfp->prfp_tbuf[1], prfp->prfp_tbuflen,		/* output */
+	    prfp->prfp_log,
+	    prfp->prfp_seed, prfp->prfp_seedlen,		/* S */
+	    &prfp->prfp_n, sizeof (prfp->prfp_n), NULL))	/* 0x01 */
+		goto fail;
+
+	return (B_TRUE);
+fail:
+	prfplus_fini(prfp);
+	return (B_FALSE);
+}
+
+/*
+ * Fill buffer with output of prf+ function.  If outlen == 0, it's explicitly
+ * a no-op.
+ */
+boolean_t
+prfplus(prfp_t *restrict prfp, uint8_t *restrict out, size_t outlen)
+{
+	size_t n = 0;
+	while (n < outlen) {
+		uint8_t *t = prfp->prfp_tbuf[prfp->prfp_n & 0x01];
+		size_t tlen = prfp->prfp_tbuflen - prfp->prfp_pos;
+		size_t amt = 0;
+
+		if (tlen == 0) {
+			if (!prfplus_update(prfp))
+				return (B_FALSE);
+
+			t = prfp->prfp_tbuf[prfp->prfp_n & 0x01];
+			tlen = prfp->prfp_tbuflen - prfp->prfp_pos;
+		}
+
+		amt = MIN(outlen - n, tlen);
+		(void) memcpy(out + n, t + prfp->prfp_pos, amt);
+		prfp->prfp_pos += amt;
+		n += amt;
+	}
+	return (B_TRUE);
+}
+
+/*
+ * Perform a prf+ iteration
+ */
+static boolean_t
+prfplus_update(prfp_t *prfp)
+{
+	uint8_t *t = NULL, *told = NULL;
+	size_t tlen = prfp->prfp_tbuflen;
+
+	/* The sequence (T##) starts with 1 */
+	VERIFY3U(prfp->prfp_n, >, 0);
+
+	if (prfp->prfp_n == PRFP_ITER_MAX) {
+		bunyan_error(prfp->prfp_log,
+		    "prf+ iteration count reached max (0xff)", BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	told = prfp->prfp_tbuf[prfp->prfp_n++ & 0x1];
+	t = prfp->prfp_tbuf[prfp->prfp_n & 0x1];
+
+	if (!prf(prfp->prfp_alg, prfp->prfp_key,
+	    t, tlen, prfp->prfp_log,				/* out */
+	    told, tlen,						/* Tn-1 */
+	    prfp->prfp_seed, prfp->prfp_seedlen,		/* S */
+	    &prfp->prfp_n, sizeof (prfp->prfp_n), NULL))	/* 0xnn */
+		return (B_FALSE);
+
+	prfp->prfp_pos = 0;
+	return (B_TRUE);
+}
+
+void
+prfplus_fini(prfp_t *prfp)
+{
+	if (prfp == NULL)
+		return;
+
+	for (size_t i = 0; i < PRFP_NUM_TBUF; i++) {
+		if (prfp->prfp_tbuf[i] != NULL) {
+			explicit_bzero(prfp->prfp_tbuf[i], prfp->prfp_tbuflen);
+			umem_free(prfp->prfp_tbuf[i], prfp->prfp_tbuflen);
+			prfp->prfp_tbuf[i] = NULL;
+		}
+	}
+	prfp->prfp_tbuflen = 0;
+
+	if (prfp->prfp_seed != NULL) {
+		explicit_bzero(prfp->prfp_seed, prfp->prfp_seedlen);
+		umem_free(prfp->prfp_seed, prfp->prfp_seedlen);
+	}
+
+	prfp->prfp_seed = NULL;
+	prfp->prfp_seedlen = 0;
+}
+
+/*
+ * Take 'len' bytes from the prf+ output stream and create a PKCS#11 object
+ * for use with the given mechanism.  A descriptive name (e.g. 'SK_i') is
+ * passed for debugging purposes.
+ */
+boolean_t
+prf_to_p11key(prfp_t *restrict prfp, const char *restrict name, int alg,
+    size_t len, CK_OBJECT_HANDLE_PTR restrict objp)
+{
+	CK_RV rc = CKR_OK;
+	uint8_t buf[len];
+
+	if (len == 0)
+		return (B_TRUE);
+
+	if (!prfplus(prfp, buf, len))
+		return (B_FALSE);
+
+	rc = SUNW_C_KeyToObject(p11h(), alg, buf, len, objp);
+	explicit_bzero(buf, len);
+
+	/*
+	 * XXX: Might it be worth setting the object label attribute to 'name'
+	 * for diagnostic purposes?
+	 */
+	if (rc != CKR_OK) {
+		PKCS11ERR(error, prfp->prfp_log, "SUNW_C_KeyToObject", rc,
+		    BUNYAN_T_STRING, "objname", name);
+	}
+
+	return ((rc == CKR_OK) ? B_TRUE : B_FALSE);
+}
+
+CK_MECHANISM_TYPE
+ikev2_prf_to_p11(ikev2_prf_t prf)
+{
+	switch (prf) {
+	case IKEV2_PRF_HMAC_MD5:
+		return (CKM_MD5_HMAC);
+	case IKEV2_PRF_HMAC_SHA1:
+		return (CKM_SHA_1_HMAC);
+	case IKEV2_PRF_HMAC_SHA2_256:
+		return (CKM_SHA256_HMAC);
+	case IKEV2_PRF_HMAC_SHA2_384:
+		return (CKM_SHA384_HMAC);
+	case IKEV2_PRF_HMAC_SHA2_512:
+		return (CKM_SHA512_HMAC);
+	case IKEV2_PRF_AES128_CMAC:
+		return (CKM_AES_CMAC);
+	case IKEV2_PRF_AES128_XCBC:
+		return (CKM_AES_XCBC_MAC);
+	case IKEV2_PRF_HMAC_TIGER:
+		INVALID("unsupported prf function");
+	}
+
+	INVALID("invalid PRF value");
+
+	/*NOTREACHED*/
+	return (0);
+}
+
+size_t
+ikev2_prf_keylen(ikev2_prf_t prf)
+{
+	switch (prf) {
+		/*
+		 * RFC7296 2.12 -- For PRFs based on HMAC, preferred key size is
+		 * equal to the output of the underlying hash function.
+		 */
+	case IKEV2_PRF_HMAC_MD5:
+	case IKEV2_PRF_HMAC_SHA1:
+	case IKEV2_PRF_HMAC_SHA2_256:
+	case IKEV2_PRF_HMAC_SHA2_384:
+	case IKEV2_PRF_HMAC_SHA2_512:
+		/*
+		 * However these two are defined elsewhere, and while the
+		 * RFCs (RFC3664 & RFC4615 respectively) don't explicitly
+		 * state they also use the output length as the preferred
+		 * key size, they happen to be the same
+		 */
+	case IKEV2_PRF_AES128_XCBC:
+	case IKEV2_PRF_AES128_CMAC:
+		return (ikev2_prf_outlen(prf));
+	case IKEV2_PRF_HMAC_TIGER:
+		/*
+		 * We should never negotiate this, so if we try to use it,
+		 * it's a progamming bug in the SA negotiation.
+		 */
+		INVALID("TIGER is unsupported");
+	}
+	INVALID("Invalid PRF value");
+
+	/*NOTREACHED*/
+	return (0);
+}
+
+size_t
+ikev2_prf_outlen(ikev2_prf_t prf)
+{
+	switch (prf) {
+	case IKEV2_PRF_HMAC_MD5:
+		return (MD5_DIGEST_LENGTH);
+	case IKEV2_PRF_HMAC_SHA1:
+		return (SHA1_DIGEST_LENGTH);
+	case IKEV2_PRF_HMAC_SHA2_256:
+		return (SHA256_DIGEST_LENGTH);
+	case IKEV2_PRF_HMAC_SHA2_384:
+		return (SHA384_DIGEST_LENGTH);
+	case IKEV2_PRF_HMAC_SHA2_512:
+		return (SHA512_DIGEST_LENGTH);
+	case IKEV2_PRF_AES128_CMAC:
+		return (AES_CMAC_LENGTH);
+	case IKEV2_PRF_AES128_XCBC:
+		return (AES_XCBC_LENGTH);
+	case IKEV2_PRF_HMAC_TIGER:
+		/*
+		 * We should never negotiate this, so if we try to use it,
+		 * it's a progamming bug in the SA negotiation.
+		 */
+		INVALID("TIGER is unsupported");
+	}
+
+	INVALID("Invalid PRF value");
+
+	/*NOTREACHED*/
+	return (0);
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.h
new file mode 100644
index 0000000000..7bebe18082
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/prf.h
@@ -0,0 +1,64 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Jason King
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+#ifndef _PRF_H
+#define	_PRF_H
+
+#include <sys/types.h>
+#include <security/cryptoki.h>
+#include "ikev2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct bunyan_logger;
+
+#define	PRFP_NUM_TBUF	(2)
+typedef struct prfp_s {
+	struct bunyan_logger	*prfp_log;
+	CK_OBJECT_HANDLE	prfp_key;
+	ikev2_prf_t		prfp_alg;
+	uint8_t			*prfp_tbuf[PRFP_NUM_TBUF];
+	size_t			prfp_tbuflen;
+	uint8_t			*prfp_seed;
+	size_t			prfp_seedlen;
+	size_t			prfp_pos;
+	uint8_t			prfp_n;
+} prfp_t;
+
+struct bunyan_logger;
+
+boolean_t prf(ikev2_prf_t, CK_OBJECT_HANDLE, uint8_t *restrict, size_t,
+    struct bunyan_logger *restrict, ...);
+
+boolean_t prfplus_init(prfp_t *restrict, ikev2_prf_t, CK_OBJECT_HANDLE,
+    struct bunyan_logger *restrict, ...);
+void prfplus_fini(prfp_t *);
+boolean_t prfplus(prfp_t *restrict, uint8_t *restrict, size_t);
+
+boolean_t prf_to_p11key(prfp_t *restrict, const char *restrict, int, size_t,
+    CK_OBJECT_HANDLE_PTR restrict);
+
+CK_MECHANISM_TYPE ikev2_prf_to_p11(ikev2_prf_t);
+size_t	ikev2_prf_keylen(ikev2_prf_t);
+size_t	ikev2_prf_outlen(ikev2_prf_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PRF_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/random.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/random.c
new file mode 100644
index 0000000000..c6cd3a7c5a
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/random.c
@@ -0,0 +1,109 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <locale.h>
+#include <ipsec_util.h>
+#include "random.h"
+#include "defs.h"
+
+/* Start off with invalid values until init */
+static int low_random = -1;
+static int high_random = -1;
+
+void
+random_init(void)
+{
+	bunyan_trace(log, "random_init() enter", BUNYAN_T_END);
+
+	if ((low_random = open("/dev/urandom", 0)) == -1)
+		err(EXIT_FAILURE, "/dev/urandom open failed");
+
+	if ((high_random = open("/dev/random", 0)) == -1)
+		err(EXIT_FAILURE, "/dev/random open failed");
+
+	bunyan_trace(log, "random_init() exit", BUNYAN_T_END);
+}
+
+uint64_t
+random_high_64(void)
+{
+	uint64_t rc;
+
+	random_high(&rc, sizeof (rc));
+	return (rc);
+}
+
+uint64_t
+random_low_64(void)
+{
+	uint64_t rc;
+
+	random_low(&rc, sizeof (rc));
+	return (rc);
+}
+
+void
+random_high(void *buf, size_t nbytes)
+{
+	ssize_t rc;
+
+	if ((rc = read(high_random, buf, nbytes)) == -1)
+		err(EXIT_FAILURE, "/dev/random read failed");
+
+	if (rc < nbytes) {
+		errx(EXIT_FAILURE, "/dev/random read insufficient bytes, "
+		    "%zd instead of %zu.", rc, nbytes);
+	}
+}
+
+void
+random_low(void *buf, size_t nbytes)
+{
+	ssize_t rc;
+
+	if ((rc = read(low_random, buf, nbytes)) == -1)
+		err(EXIT_FAILURE, "/dev/urandom read failed");
+
+	if (rc < nbytes) {
+		errx(EXIT_FAILURE, "/dev/urandom read insufficient bytes, "
+		    "%zd instead of %zu.", rc, nbytes);
+	}
+}
+
+extern inline uint32_t random_high_32(void);
+extern inline uint16_t random_high_16(void);
+extern inline uint8_t random_high_8(void);
+extern inline uint32_t random_low_32(void);
+extern inline uint16_t random_low_16(void);
+extern inline uint8_t random_low_8(void);
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/random.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/random.h
new file mode 100644
index 0000000000..3357f29acf
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/random.h
@@ -0,0 +1,77 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2014 Jason King.  All rights reserved.
+ */
+
+#ifndef _RANDOM_H
+#define	_RANDOM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <inttypes.h>
+
+/*
+ * We always grab at least 64-bit of random data (high or low entropy),
+ * when smaller amounts are needed, we include small inline functions
+ * as wrappers around random_{low,high}_64 that chop off the required number
+ * of bytes.
+ */
+extern void random_init(void);
+extern void random_high(void *, size_t);
+extern void random_low(void *, size_t);
+extern uint64_t random_high_64(void);
+extern uint64_t random_low_64(void);
+
+inline uint32_t
+random_high_32(void)
+{
+	return ((uint32_t)random_high_64() & (uint64_t)0xffffffff);
+}
+
+inline uint16_t
+random_high_16(void)
+{
+	return ((uint16_t)random_high_64() & (uint64_t)0xffff);
+}
+
+inline uint8_t
+random_high_8(void)
+{
+	return ((uint8_t)random_high_8() & (uint64_t)0xff);
+}
+
+inline uint32_t
+random_low_32(void)
+{
+	return ((uint32_t)random_low_64() & (uint64_t)0xffffffff);
+}
+
+inline uint16_t
+random_low_16(void)
+{
+	return ((uint16_t)random_low_64() & (uint64_t)0xffff);
+}
+
+inline uint8_t
+random_low_8(void)
+{
+	return ((uint8_t)random_low_8() & (uint64_t)0xff);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _RANDOM_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/timer.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/timer.c
new file mode 100644
index 0000000000..6a247127d5
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/timer.c
@@ -0,0 +1,276 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017 Joyent, Inc.
+ */
+
+#include <errno.h>
+#include <ipsec_util.h>
+#include <locale.h>
+#include <note.h>
+#include <pthread.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/debug.h>
+#include <sys/types.h>
+#include <ucontext.h>
+#include <umem.h>
+
+#include "defs.h"
+#include "ilist.h"
+#include "timer.h"
+#include "worker.h"
+
+struct tevent_s;
+
+typedef struct tevent_s {
+	list_node_t		te_node;
+
+	hrtime_t		te_time;	/* When does the event go off */
+	te_event_t		te_type;	/* Event type */
+	tevent_cb_fn		te_fn;
+	void			*te_arg;
+} tevent_t;
+
+static umem_cache_t	*evt_cache;
+
+static int te_compare(const void *, const void *, void *);
+
+static tevent_t *tevent_alloc(te_event_t, hrtime_t, tevent_cb_fn, void *);
+static void tevent_free(tevent_t *);
+static int evt_ctor(void *, void *, int);
+static const char *te_str(te_event_t);
+static void tevent_log(bunyan_logger_t *restrict, bunyan_level_t,
+    const char *restrict, const tevent_t *restrict);
+
+void
+ike_timer_init(void)
+{
+	/* better be single threaded here! */
+	VERIFY(pthread_self() == 1);
+
+	evt_cache = umem_cache_create("timer events", sizeof (tevent_t), 0,
+	    evt_ctor, NULL, NULL, NULL, NULL, 0);
+	if (evt_cache == NULL)
+		errx(EXIT_FAILURE, "Unable to allocate memory for timer event "
+		    "entries");
+}
+
+void
+ike_timer_worker_init(worker_t *w)
+{
+	ilist_create(&w->w_timers, sizeof (tevent_t),
+	    offsetof(tevent_t, te_node));
+}
+
+void
+ike_timer_worker_fini(void)
+{
+	VERIFY(IS_WORKER);
+	ilist_destroy(&worker->w_timers);
+}
+
+void
+process_timer(timespec_t **tsp)
+{
+	VERIFY(IS_WORKER);
+
+	ilist_t		*events = &worker->w_timers;
+	tevent_t	*te = NULL;
+	hrtime_t	now = gethrtime();
+	hrtime_t	delta = 0;
+	size_t		dispcount = 0;
+
+	(void) bunyan_trace(worker->w_log, "Checking for timeout events",
+	    BUNYAN_T_END);
+
+	/*
+	 * Only look at events that expired when we started. It is
+	 * possible more events may be ready by the time we finish.
+	 * If that happens, they will be processed the next time
+	 * we are called so that other things can proceed in the
+	 * current thread.
+	 *
+	 * This list is sorted in ascending time, so we can stop
+	 * either when it's empty or we see an event later scheduled
+	 * later than 'now'.
+	 */
+	while ((te = ilist_head(events)) != NULL && te->te_time < now) {
+		(void) ilist_remove_head(events);
+
+		tevent_log(worker->w_log, BUNYAN_L_TRACE,
+		    "Dispatching timer event", te);
+		te->te_fn(te->te_type, te->te_arg);
+		dispcount++;
+
+		tevent_free(te);
+	}
+
+	if (te != NULL) {
+		timespec_t ts = { 0 };
+
+		if ((delta = te->te_time - gethrtime()) < 0)
+			delta = 0;
+
+		(*tsp)->tv_sec = NSEC2SEC(delta);
+		(*tsp)->tv_nsec = delta % NANOSEC;
+	} else {
+		*tsp = NULL;
+	}
+
+	(void) bunyan_trace(worker->w_log, "Finished dispatching events",
+	    BUNYAN_T_UINT32, "dispcount", (uint32_t)dispcount,
+	    BUNYAN_T_UINT32, "numqueued", (uint32_t)ilist_size(events),
+	    BUNYAN_T_UINT64, "next_evt_ms", NSEC2MSEC(delta),
+	    BUNYAN_T_END);
+}
+
+size_t
+cancel_timeout(te_event_t type, void *restrict arg, bunyan_logger_t *l)
+{
+	VERIFY(IS_WORKER);
+
+	ilist_t *events = &worker->w_timers;
+	tevent_t *te = ilist_head(events);
+	size_t count = 0;
+
+	(void) bunyan_trace(l, "Cancelling timeouts",
+	    BUNYAN_T_STRING, "event", te_str(type),
+	    BUNYAN_T_POINTER, "arg", arg, BUNYAN_T_END);
+
+	while (te != NULL) {
+		tevent_t *tnext = ilist_next(events, te);
+
+		if ((te->te_arg == arg || arg == NULL) &&
+		    (te->te_type == type || te->te_type == TE_ANY)) {
+			tevent_log(l, BUNYAN_L_DEBUG, "Cancelled timeout", te);
+
+			ilist_remove(events, te);
+			count++;
+			tevent_free(te);
+		}
+
+		te = tnext;
+	}
+
+	return (count);
+}
+
+boolean_t
+schedule_timeout(te_event_t type, tevent_cb_fn fn, void *arg, hrtime_t val,
+    bunyan_logger_t *l)
+{
+	VERIFY(IS_WORKER);
+	VERIFY3P(arg, !=, NULL);
+	VERIFY3S(type, !=, TE_ANY);
+
+	ilist_t *events = &worker->w_timers;
+	tevent_t *te = tevent_alloc(type, val, fn, arg);
+	tevent_t *tnode = ilist_head(events);
+
+	if (te == NULL)
+		return (B_FALSE);
+
+	while (tnode != NULL && tnode->te_time < te->te_time)
+		tnode = ilist_next(events, tnode);
+
+	ilist_insert_before(events, tnode, te);
+	tevent_log(l, BUNYAN_L_TRACE, "Created new timeout", te);
+	return (B_TRUE);
+}
+
+static tevent_t *
+tevent_alloc(te_event_t type, hrtime_t dur, tevent_cb_fn fn, void *arg)
+{
+	tevent_t *te = umem_cache_alloc(evt_cache, UMEM_DEFAULT);
+	hrtime_t now = gethrtime();
+
+	if (te == NULL)
+		return (NULL);
+
+	te->te_time = now + dur;
+	if (te->te_time < now || te->te_time < dur) {
+		errno = EOVERFLOW;
+		tevent_free(te);
+		return (NULL);
+	}
+	te->te_type = type;
+	te->te_fn = fn;
+	te->te_arg = arg;
+
+	return (te);
+}
+
+static void
+tevent_free(tevent_t *te)
+{
+	if (te == NULL)
+		return;
+
+	evt_ctor(te, NULL, 0);
+	umem_cache_free(evt_cache, te);
+}
+
+static void
+tevent_log(bunyan_logger_t *restrict l, bunyan_level_t level,
+    const char *restrict msg, const tevent_t *restrict te)
+{
+	hrtime_t now = gethrtime();
+	int64_t when = NSEC2MSEC(te->te_time - now);
+
+	/* XXX: Get the function name, would dladdr(3C) be better? */
+	(void) getlog(level)(l, msg,
+	    BUNYAN_T_STRING, "event", te_str(te->te_type),
+	    BUNYAN_T_UINT32, "event num", (uint32_t)te->te_type,
+	    BUNYAN_T_INT64, "ms", when,
+	    BUNYAN_T_POINTER, "fn", te->te_fn,
+	    BUNYAN_T_STRING, "fnname", symstr(te->te_fn),
+	    BUNYAN_T_POINTER, "arg", te->te_arg,
+	    BUNYAN_T_END);
+}
+
+static int
+evt_ctor(void *buf, void *cb, int flags)
+{
+	tevent_t *te = buf;
+
+	(void) memset(te, 0, sizeof (*te));
+	list_link_init(&te->te_node);
+	return (0);
+}
+
+static const char *
+te_str(te_event_t te)
+{
+#define	STR(x) case x: return (#x)
+	switch (te) {
+	STR(TE_ANY);
+	STR(TE_P1_SA_EXPIRE);
+	STR(TE_TRANSMIT);
+	STR(TE_PFKEY);
+	}
+	return ("UNKNOWN");
+}
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/timer.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/timer.h
new file mode 100644
index 0000000000..98cfde0580
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/timer.h
@@ -0,0 +1,68 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+
+/*
+ * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Copyright 2017 Jason King.
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+/*
+ * Timer events are sorted into a single mutex-protected list.
+ * They are insertion-sorted by next-to-expire.
+ */
+
+#ifndef _TIMER_H
+#define	_TIMER_H
+
+#include <sys/types.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+	TE_ANY,			/* MUST NOT be passed to schedule_timeout() */
+	TE_P1_SA_EXPIRE,	/* Larval SA expiration */
+	TE_TRANSMIT,		/* Transmit timeout */
+	TE_PFKEY		/* pfkey timeout */
+} te_event_t;
+
+typedef void (*tevent_cb_fn)(te_event_t, void *);
+
+struct bunyan_logger;
+struct worker_s;
+
+extern void		process_timer(timespec_t **);
+extern size_t		cancel_timeout(te_event_t, void *,
+    struct bunyan_logger *);
+extern boolean_t	schedule_timeout(te_event_t, tevent_cb_fn, void *,
+    hrtime_t, struct bunyan_logger *);
+
+extern void ike_timer_init(void);
+extern void ike_timer_worker_init(struct worker_s *);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif  /* _TIMER_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/util.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/util.c
new file mode 100644
index 0000000000..3e0161cff2
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/util.c
@@ -0,0 +1,181 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <port.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <thread.h>
+#include <umem.h>
+#include "defs.h"
+#include "ilist.h"
+
+struct strbuf_s {
+	char	symstr[128];
+	char	portstr[6];	/* Size of ushort_t as string + NUL */
+	char	afstr[6];	/* Same as portstr */
+	char	evtstr[12];	/* Size of int (enum) + NUL */
+};
+
+static thread_key_t strbuf_key = THR_ONCE_KEY;
+
+/* Pick a bunyan log function based on level */
+bunyan_logfn_t
+getlog(bunyan_level_t level)
+{
+	switch (level) {
+	case BUNYAN_L_TRACE:
+		return (bunyan_trace);
+	case BUNYAN_L_DEBUG:
+		return (bunyan_debug);
+	case BUNYAN_L_INFO:
+		return (bunyan_info);
+	case BUNYAN_L_WARN:
+		return (bunyan_warn);
+	case BUNYAN_L_ERROR:
+		return (bunyan_error);
+	case BUNYAN_L_FATAL:
+		return (bunyan_fatal);
+	}
+
+	return (NULL);
+}
+
+static void
+buf_fini(void *arg)
+{
+	struct strbuf_s *buf = arg;
+
+	umem_free(buf, sizeof (*buf));
+}
+
+static struct strbuf_s *
+getbuf(void)
+{
+	struct strbuf_s *buf = NULL;
+
+	VERIFY0(thr_keycreate_once(&strbuf_key, buf_fini));
+	VERIFY0(thr_getspecific(strbuf_key, (void **)&buf));
+	if (buf == NULL) {
+		buf = umem_alloc(sizeof (*buf), UMEM_DEFAULT);
+		if (buf == NULL)
+			return (NULL);
+		VERIFY0(thr_setspecific(strbuf_key, buf));
+	}
+	return (buf);
+}
+
+const char *
+symstr(void *addr)
+{
+	struct strbuf_s *buf = getbuf();
+	Dl_info_t dlinfo = { 0 };
+
+	if (buf == NULL)
+		return ("");
+
+	if (dladdr(addr, &dlinfo) == 0) {
+		(void) snprintf(buf->symstr, sizeof (buf->symstr), "0x%p",
+		    addr);
+	} else {
+		(void) strlcpy(buf->symstr, dlinfo.dli_sname,
+		    sizeof (buf->symstr));
+	}
+
+	return (buf->symstr);
+}
+
+const char *
+afstr(sa_family_t af)
+{
+	switch (af) {
+	case AF_INET:
+		return ("AF_INET");
+	case AF_INET6:
+		return ("AF_INET6");
+	}
+
+	struct strbuf_s *buf = getbuf();
+
+	if (buf == NULL)
+		return ("");
+
+	(void) snprintf(buf->afstr, sizeof (buf->afstr), "%hhu", af);
+	return (buf->afstr);
+}
+
+#define	STR(x) case x: return (#x)
+const char *
+event_str(event_t evt)
+{
+	switch (evt) {
+	STR(EVENT_NONE);
+	STR(EVENT_SIGNAL);
+	}
+
+	struct strbuf_s *buf = getbuf();
+
+	if (buf == NULL)
+		return ("");
+
+	(void) snprintf(buf->evtstr, sizeof (buf->evtstr), "%d", evt);
+	return (buf->evtstr);
+}
+
+const char *
+port_source_str(ushort_t src)
+{
+	switch (src) {
+	STR(PORT_SOURCE_AIO);
+	STR(PORT_SOURCE_FD);
+	STR(PORT_SOURCE_MQ);
+	STR(PORT_SOURCE_TIMER);
+	STR(PORT_SOURCE_USER);
+	STR(PORT_SOURCE_ALERT);
+	STR(PORT_SOURCE_FILE);
+	}
+
+	struct strbuf_s *buf = getbuf();
+
+	if (buf == NULL)
+		return ("");
+
+	(void) snprintf(buf->portstr, sizeof (buf->portstr), "%hhu", src);
+	return (buf->portstr);
+}
+#undef STR
+
+/* inline parking lot */
+extern inline uint32_t ss_port(const struct sockaddr_storage *);
+extern inline const void *ss_addr(const struct sockaddr_storage *);
+extern inline int ss_bunyan(const struct sockaddr_storage *);
+
+extern inline void ilist_create(ilist_t *, size_t, size_t);
+extern inline void ilist_destroy(ilist_t *);
+extern inline void ilist_insert_after(ilist_t *, void *, void *);
+extern inline void ilist_insert_before(ilist_t *, void *, void *);
+extern inline void ilist_insert_head(ilist_t *, void *);
+extern inline void ilist_insert_tail(ilist_t *, void *);
+extern inline void ilist_remove(ilist_t *, void *);
+extern inline void *ilist_remove_head(ilist_t *);
+extern inline void *ilist_remove_tail(ilist_t *);
+extern inline void *ilist_head(ilist_t *);
+extern inline void *ilist_tail(ilist_t *);
+extern inline void *ilist_next(ilist_t *, void *);
+extern inline void *ilist_prev(ilist_t *, void *);
+extern inline void ilist_move_tail(ilist_t *, ilist_t *);
+extern inline int ilist_is_empty(ilist_t *);
+extern inline size_t ilist_size(ilist_t *);
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.c b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.c
new file mode 100644
index 0000000000..d49e7ec168
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.c
@@ -0,0 +1,496 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#include <bunyan.h>
+#include <err.h>
+#include <thread.h>
+#include <string.h>
+#include <synch.h>
+#include <sys/debug.h>
+#include <sys/list.h>
+#include <time.h>
+#include <umem.h>
+#include "defs.h"
+#include "ikev2_proto.h"
+#include "ikev2_sa.h"
+#include "pkcs11.h"
+#include "pkt.h"
+#include "timer.h"
+#include "worker.h"
+
+/*
+ * Workers handle all the heavy lifting (including crypto) in in.ikev2d.
+ * An event port (port) waits for packets from our UDP sockets (IPv4, IPv6,
+ * and IPv4 NAT) as well as for pfkey messages.  For UDP messages, some
+ * minimal sanity checks (such as verifying payload lengths) occur, an IKEv2
+ * SA is located for the message (or if appropriate, a larval IKEv2 SA is
+ * created), and then the packet is handed off to a worker thread to do the
+ * rest of the work.  Currently dispatching works by merely taking the local
+ * IKEv2 SA SPI modulo the number of worker threads.  Since we control
+ * the local IKEv2 SA SPI value (and is randomly chosen), this should prevent
+ * a single connection from saturating the process by making all IKEv2
+ * processing for a given IKEv2 SA occur all within the same thread (it also
+ * simplifies some of the synchronization requirements for manipulating
+ * IKEv2 SAs).  Obviously this does not address a DOS with spoofed source
+ * addresses.  Cookies are used to mitigate such threats (to the extent it
+ * can by dropping inbound packets without valid cookie values when enabled).
+ */
+
+#define	WQ_EMPTY(_wq) ((_wq)->wq_start == (_wq)->wq_end)
+#define	WQ_FULL(_wq) ((((_wq)->wq_end + 1) % wk_queuelen) == (_wq)->wq_start)
+
+__thread worker_t *worker = NULL;
+
+/*
+ * The following group of variables are protected by worker_lock.  Generally
+ * this is used to update the global array of data on workers.  In general,
+ * one should grab the wk_worker_lock prior obtaining w_lock.
+ */
+static rwlock_t wk_worker_lock = DEFAULTRWLOCK;
+size_t		wk_nworkers;
+static worker_t	**wk_workers;
+static size_t	wk_workers_alloc;
+static size_t	wk_queuelen;
+
+static volatile uint_t wk_nsuspended;
+static mutex_t wk_suspend_lock = ERRORCHECKMUTEX;
+static cond_t wk_suspend_cv = DEFAULTCV;
+
+static worker_t *worker_new(size_t);
+static void worker_free(worker_t *);
+static void *worker_main(void *);
+static const char *worker_cmd_str(worker_cmd_t);
+static const char *worker_msg_str(worker_msg_t);
+static void worker_pkt_inbound(pkt_t *);
+
+/*
+ * Create a pool of worker threads with the given queue depth.
+ * Workers are left suspended under the assumption they will be
+ * resumed once main_loop() starts.
+ */
+void
+worker_init(size_t nworkers, size_t queuelen)
+{
+	wk_workers = calloc(nworkers, sizeof (worker_t *));
+	if (wk_workers == NULL)
+		err(EXIT_FAILURE, "out of memory");
+
+	wk_nworkers = wk_workers_alloc = nworkers;
+	wk_queuelen = queuelen;
+
+	for (size_t i = 0; i < nworkers; i++) {
+		worker_t *w = worker_new(i);
+
+		if (w == NULL)
+			err(EXIT_FAILURE, "Out of memory");
+
+		wk_workers[i] = w;
+	}
+
+	for (size_t i = 0; i < nworkers; i++) {
+		worker_t *w = wk_workers[i];
+		int rc;
+
+		rc = thr_create(NULL, 0, worker_main, w, 0, &w->w_tid);
+		if (rc != 0) {
+			(void) bunyan_fatal(log, "Cannot create worker thread",
+			    BUNYAN_T_STRING, "errmsg", strerror(rc),
+			    BUNYAN_T_INT32, "errno", (int32_t)rc,
+			    BUNYAN_T_STRING, "file", __FILE__,
+			    BUNYAN_T_INT32, "line", (int)__LINE__,
+			    BUNYAN_T_STRING, "func", __func__,
+			    BUNYAN_T_END);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	(void) bunyan_trace(log, "Worker threads created",
+	    BUNYAN_T_UINT32, "numworkers", (uint32_t)nworkers,
+	    BUNYAN_T_END);
+}
+
+/* Allocate a worker_t -- but does not create the thread for it */
+static worker_t *
+worker_new(size_t n)
+{
+	worker_t *w = calloc(1, sizeof (worker_t));
+
+	if (w == NULL)
+		return (NULL);
+
+	VERIFY0(mutex_init(&w->w_queue.wq_lock, LOCK_ERRORCHECK, NULL));
+	VERIFY0(cond_init(&w->w_queue.wq_cv, NULL, NULL));
+	ike_timer_worker_init(w);
+
+	w->w_queue.wq_items = calloc(wk_queuelen, sizeof (worker_item_t));
+	if (w->w_queue.wq_items == NULL)
+		goto fail;
+
+	if (bunyan_child(log, &w->w_log,
+	    BUNYAN_T_UINT32, "worker", (uint32_t)n, BUNYAN_T_END) != 0)
+		goto fail;
+
+	if ((w->w_p11 = pkcs11_new_session()) == CK_INVALID_HANDLE)
+		goto fail;
+
+	w->w_queue.wq_cmd = WC_NONE;
+	return (w);
+
+fail:
+	worker_free(w);
+	return (NULL);
+}
+
+static void
+worker_free(worker_t *w)
+{
+	if (w == NULL)
+		return;
+
+	free(w->w_queue.wq_items);
+	if (w->w_log != NULL)
+		bunyan_fini(w->w_log);
+	pkcs11_session_free(w->w_p11);	
+	mutex_destroy(&w->w_queue.wq_lock);
+	cond_destroy(&w->w_queue.wq_cv);
+	ilist_destroy(&w->w_timers);
+	free(w);
+}
+
+/*
+ * Pause all the workers.  The current planned use is when we need to resize
+ * the IKE SA hashes -- it's far simpler to make sure all the workers are
+ * quiesced and rearrange things then restart.
+ */
+void
+worker_suspend(void)
+{
+	VERIFY0(rw_wrlock(&wk_worker_lock));
+	for (size_t i = 0; i < wk_nworkers; i++) {
+		worker_t *w = wk_workers[i];
+		worker_queue_t *wq = &w->w_queue;
+
+		mutex_enter(&wq->wq_lock);
+		w->w_queue.wq_cmd = WC_SUSPEND;
+		VERIFY0(cond_signal(&wq->wq_cv));
+		mutex_exit(&wq->wq_lock);
+	}
+	VERIFY0(rw_unlock(&wk_worker_lock));
+
+	mutex_enter(&wk_suspend_lock);
+	while (wk_nsuspended != wk_nworkers)
+		VERIFY0(cond_wait(&wk_suspend_cv, &wk_suspend_lock));
+	mutex_exit(&wk_suspend_lock);
+}
+
+static void
+worker_do_suspend(worker_t *w)
+{
+	worker_queue_t *wq = &w->w_queue;
+
+	VERIFY(MUTEX_HELD(&wq->wq_lock));
+	mutex_exit(&wq->wq_lock);
+
+	mutex_enter(&wk_suspend_lock);
+	if (++wk_nsuspended == wk_nworkers) {
+		bunyan_trace(w->w_log, "Last one in, signaling", BUNYAN_T_END);
+		VERIFY0(cond_signal(&wk_suspend_cv));
+	}
+	mutex_exit(&wk_suspend_lock);
+
+	mutex_enter(&wq->wq_lock);
+	while (wq->wq_cmd == WC_SUSPEND)
+		VERIFY0(cond_wait(&wq->wq_cv, &wq->wq_lock));
+
+	mutex_enter(&wk_suspend_lock);
+	--wk_nsuspended;
+	mutex_exit(&wk_suspend_lock);
+
+	bunyan_debug(w->w_log, "Worker resuming", BUNYAN_T_END);
+	/* leave wq->wq_lock locked */
+}
+
+void
+worker_resume(void)
+{
+	VERIFY0(rw_wrlock(&wk_worker_lock));
+	for (size_t i = 0; i < wk_nworkers; i++) {
+		worker_t *w = wk_workers[i];
+		worker_queue_t *wq = &w->w_queue;
+
+		bunyan_trace(log, "Waking up worker",
+		    BUNYAN_T_UINT32, "worker", (uint32_t)i,
+		    BUNYAN_T_END);
+
+		mutex_enter(&wq->wq_lock);
+		wq->wq_cmd = WC_NONE;
+		mutex_exit(&wq->wq_lock);
+		VERIFY0(cond_broadcast(&wq->wq_cv));
+	}
+	VERIFY0(rw_unlock(&wk_worker_lock));
+
+	bunyan_trace(log, "Finished resuming workers", BUNYAN_T_END);
+}
+
+boolean_t
+worker_dispatch(worker_msg_t msg, void *data, size_t n)
+{
+	worker_t *w = NULL;
+	worker_queue_t *wq = NULL;
+	worker_item_t *wi = NULL;
+
+	VERIFY0(rw_rdlock(&wk_worker_lock));
+	VERIFY3U(n, <, wk_nworkers);
+	w = wk_workers[n];
+	wq = &w->w_queue;
+	mutex_enter(&wq->wq_lock);
+
+	if (WQ_FULL(wq)) {
+		mutex_exit(&wq->wq_lock);
+		VERIFY0(rw_unlock(&wk_worker_lock));
+
+		(void) bunyan_debug(log, "dispatch failed (queue full)",
+		    BUNYAN_T_UINT32, "worker", (uint32_t)n,
+		    BUNYAN_T_STRING, "event", worker_msg_str(msg),
+		    BUNYAN_T_POINTER, "data", data,
+		    BUNYAN_T_END);
+		return (B_FALSE);
+	}
+
+	wi = &wq->wq_items[wq->wq_end++];
+	wi->wi_msgtype = msg;
+	wi->wi_data = data;
+	wq->wq_end %= wk_queuelen;
+
+	VERIFY0(cond_signal(&wq->wq_cv));
+	mutex_exit(&wq->wq_lock);
+	VERIFY0(rw_unlock(&wk_worker_lock));
+
+	(void) bunyan_debug(w->w_log, "Dispatching message to worker",
+	    BUNYAN_T_UINT32, "worker", (uint32_t)n,
+	    BUNYAN_T_STRING, "msgtype", worker_msg_str(msg),
+	    BUNYAN_T_POINTER, "data", data,
+	    BUNYAN_T_END);
+	return (B_TRUE);
+}
+
+static void *
+worker_main(void *arg)
+{
+	worker_t *w = arg;
+	worker_queue_t *wq = &w->w_queue;
+	timespec_t ts = { 0 };
+	boolean_t done = B_FALSE;
+
+	worker = w;
+	(void) bunyan_trace(w->w_log, "Worker starting", BUNYAN_T_END);
+
+	mutex_enter(&wq->wq_lock);
+
+	/*CONSTCOND*/
+	while (1) {
+		timespec_t *pts = &ts;
+		int rc = 0;
+
+		process_timer(&pts);
+
+		if (pts != NULL)
+			rc = cond_reltimedwait(&wq->wq_cv, &wq->wq_lock, pts);
+		else
+			rc = cond_wait(&wq->wq_cv, &wq->wq_lock);
+
+		if (rc != 0 && rc != ETIME) {
+			(void) bunyan_fatal(w->w_log,
+			    "Unexpected cond_timedwait return value",
+			    BUNYAN_T_STRING, "errmsg", strerror(rc),
+			    BUNYAN_T_INT32, "errno", (int32_t)rc,
+			    BUNYAN_T_STRING, "file", __FILE__,
+			    BUNYAN_T_INT32, "line", (int32_t)__LINE__,
+			    BUNYAN_T_STRING, "func", __func__,
+			    BUNYAN_T_END);
+			abort();
+		}
+
+		if (wq->wq_cmd != WC_NONE)
+			(void) bunyan_info(w->w_log, "Received command",
+			    BUNYAN_T_STRING, "cmd", worker_cmd_str(wq->wq_cmd),
+			    BUNYAN_T_UINT32, "cmdval", (uint32_t)wq->wq_cmd,
+			    BUNYAN_T_END);
+
+		switch (wq->wq_cmd) {
+		case WC_NONE:
+			break;
+		case WC_SUSPEND:
+			bunyan_debug(w->w_log, "Suspending worker",
+			    BUNYAN_T_END);
+			worker_do_suspend(w);
+			VERIFY(MUTEX_HELD(&wq->wq_lock));
+			continue;			
+		case WC_QUIT:
+			done = B_TRUE;
+			break;
+		default:
+			INVALID("wq->wq_cmd");
+		}
+
+		if (done)
+			break;
+
+		while (!WQ_EMPTY(wq)) {
+			const worker_item_t *src = &wq->wq_items[wq->wq_start];
+			worker_item_t wi = {
+				.wi_msgtype = src->wi_msgtype,
+				.wi_data = src->wi_data
+			};
+
+			wq->wq_items[wq->wq_start].wi_msgtype = WMSG_NONE;
+			wq->wq_items[wq->wq_start].wi_data = NULL;
+
+			wq->wq_start++;
+			wq->wq_start %= wk_queuelen;
+			mutex_exit(&wq->wq_lock);
+
+			switch (wi.wi_msgtype) {
+			case WMSG_NONE:
+				INVALID("wi.wi_event");
+				break;
+			case WMSG_PACKET:
+				worker_pkt_inbound(wi.wi_data);
+				break;
+			case WMSG_PFKEY:
+				/* TODO */
+				break;
+			case WMSG_START:
+				ikev2_sa_init_outbound(wi.wi_data, NULL, 0,
+				    IKEV2_DH_NONE, NULL, 0);
+				break;
+			case WMSG_START_P1_TIMER:
+				ikev2_sa_start_timer(wi.wi_data);
+				break;
+			}
+
+			mutex_enter(&wq->wq_lock);
+		}
+	}
+
+	w->w_done;
+	VERIFY0(cond_signal(&wq->wq_cv));
+	mutex_exit(&wq->wq_lock);
+	return (w);
+}
+
+static void
+worker_pkt_inbound(pkt_t *pkt)
+{
+	switch (IKE_GET_MAJORV(pkt_header(pkt)->version)) {
+	case 1:
+		/* XXX: ikev1_inbound(pkt); */
+		break;
+	case 2:
+		ikev2_inbound(pkt);
+		break;
+	default:
+		/* XXX: log? */
+		pkt_free(pkt);
+	}
+}
+
+boolean_t
+worker_add(void)
+{
+	worker_t **new_workers = NULL;
+	worker_t *w = NULL;
+	size_t new_workers_alloc = 0;
+	size_t len = 0, qlen = 0;
+	int rc = 0;
+
+	(void) bunyan_trace(log, "Creating new worker", BUNYAN_T_END);
+
+	VERIFY0(rw_wrlock(&wk_worker_lock));
+	if (wk_workers_alloc == wk_nworkers) {
+		new_workers_alloc = wk_workers_alloc + 1;
+		new_workers = recallocarray(wk_workers, wk_workers_alloc,
+		    new_workers_alloc, sizeof (worker_t *));
+
+		if (new_workers == NULL) {
+			VERIFY0(rw_unlock(&wk_worker_lock));
+			return (B_FALSE);
+		}
+
+		wk_workers = new_workers;
+		wk_workers_alloc = new_workers_alloc;
+	}
+
+	if ((w = worker_new(wk_nworkers + 1)) == NULL) {
+		VERIFY0(rw_unlock(&wk_worker_lock));
+		return (B_FALSE);
+	}
+
+	wk_workers[wk_nworkers++] = w;
+
+	rc = thr_create(NULL, 0, worker_main, w, 0, &w->w_tid);
+	if (rc != 0) {
+		bunyan_fatal(log, "Cannot create additional worker thread",
+		    BUNYAN_T_STRING, "errmsg", strerror(rc),
+		    BUNYAN_T_INT32, "errno", (int32_t)rc,
+		    BUNYAN_T_STRING, "file", __FILE__,
+		    BUNYAN_T_INT32, "line", (int32_t)__LINE__,
+		    BUNYAN_T_STRING, "func", __func__,
+		    BUNYAN_T_END);
+		wk_workers[--wk_nworkers] = NULL;
+		worker_free(w);
+		VERIFY0(rw_unlock(&wk_worker_lock));
+		return (B_FALSE);
+	}
+
+	VERIFY0(rw_unlock(&wk_worker_lock));
+	(void) bunyan_debug(w->w_log, "Worker created", BUNYAN_T_END);
+	return (B_TRUE);
+}
+
+void
+worker_del(void)
+{
+}
+
+#define	STR(x) case x: return (#x)
+static const char *
+worker_cmd_str(worker_cmd_t wc)
+{
+	switch (wc) {
+	STR(WC_NONE);
+	STR(WC_SUSPEND);
+	STR(WC_QUIT);
+	}
+
+	INVALID(wc);
+	return (NULL);
+}
+
+static const char *
+worker_msg_str(worker_msg_t msg)
+{
+	switch (msg) {
+	STR(WMSG_NONE);
+	STR(WMSG_PACKET);
+	STR(WMSG_PFKEY);
+	STR(WMSG_START);
+	STR(WMSG_START_P1_TIMER);
+	}
+
+	INVALID(msg);
+	return (NULL);
+}
+#undef STR
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.h b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.h
new file mode 100644
index 0000000000..b3d6c233e8
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/common/worker.h
@@ -0,0 +1,90 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2017 Joyent, Inc.
+ */
+
+#ifndef _WORKER_H
+#define	_WORKER_H
+
+#include <bunyan.h>
+#include <thread.h>
+#include <security/cryptoki.h>
+#include <stddef.h>
+#include <synch.h>
+#include "ilist.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum worker_msg_e {
+	WMSG_NONE,
+	WMSG_PACKET,
+	WMSG_PFKEY,
+	WMSG_START,		/* Temp. for testing */
+	WMSG_START_P1_TIMER,
+} worker_msg_t;
+
+typedef enum worker_cmd_e {
+	WC_NONE,
+	WC_SUSPEND,
+	WC_QUIT
+} worker_cmd_t;
+
+/*
+ * The full lifetime of the wi_data argument depends on the type of message
+ * associated with it.  For every message type however, it can be assumed
+ * that the worker itself will handle any deallocation and the caller need
+ * not concern themselves with it unless dispatching fails.
+ */
+typedef struct worker_item_s {
+	worker_msg_t	wi_msgtype;
+	void		*wi_data;
+} worker_item_t;
+
+typedef struct worker_queue_s {
+	mutex_t		wq_lock;
+	cond_t		wq_cv;
+	worker_cmd_t	wq_cmd;
+	worker_item_t	*wq_items;
+	size_t		wq_start;
+	size_t		wq_end;
+} worker_queue_t;
+
+typedef struct worker_s {
+	thread_t		w_tid;
+	bunyan_logger_t		*w_log;
+	worker_queue_t		w_queue;
+	ilist_t			w_timers;
+	boolean_t		w_done;
+	CK_SESSION_HANDLE	w_p11;
+} worker_t;
+
+extern __thread worker_t *worker;
+#define	IS_WORKER	(worker != NULL)
+
+extern size_t wk_nworkers;
+
+void worker_init(size_t, size_t);
+void worker_suspend(void);
+void worker_resume(void);
+boolean_t worker_add(void);
+void worker_del(void);
+void worker_stop(void);
+boolean_t worker_dispatch(worker_msg_t, void *, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WORKER_H */
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/i386/Makefile b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/i386/Makefile
new file mode 100644
index 0000000000..55f47cd939
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/i386/Makefile
@@ -0,0 +1,29 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+include ../Makefile.com
+
+install: all $(ROOTLIBINETPROG32)
diff --git a/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/sparcv9/Makefile b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/sparcv9/Makefile
new file mode 100644
index 0000000000..930b865dd8
--- /dev/null
+++ b/usr/src/cmd/cmd-inet/usr.lib/in.ikev2/sparcv9/Makefile
@@ -0,0 +1,30 @@
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+include ../Makefile.com
+include ../../../../Makefile.cmd.64
+
+install: all $(ROOTLIBINETPROG64)
diff --git a/usr/src/lib/libipsecutil/common/ikedoor.h b/usr/src/lib/libipsecutil/common/ikedoor.h
index 95e71012d7..108a9d77d2 100644
--- a/usr/src/lib/libipsecutil/common/ikedoor.h
+++ b/usr/src/lib/libipsecutil/common/ikedoor.h
@@ -33,6 +33,7 @@ extern "C" {
 #include <sys/sysmacros.h>
 #include <net/pfkeyv2.h>
 #include <door.h>
+#include <sys/socket.h>
 
 /*
  * This version number is intended to stop the calling process from
diff --git a/usr/src/lib/libipsecutil/common/ipsec_util.h b/usr/src/lib/libipsecutil/common/ipsec_util.h
index 6c555472cc..1275e954f4 100644
--- a/usr/src/lib/libipsecutil/common/ipsec_util.h
+++ b/usr/src/lib/libipsecutil/common/ipsec_util.h
@@ -455,6 +455,9 @@ extern void ipsec_convert_bslabel_to_hex(bslabel_t *, char **);
 #define	EXIT_BADPERM2(x, y) \
 	ipsecutil_exit(SERVICE_BADPERM, my_fmri, debugfile, \
 	dgettext(TEXT_DOMAIN, x), y)
+#define	EXIT_BADPERM3(x, y, z) \
+	ipsecutil_exit(SERVICE_BADPERM, my_fmri, debugfile, \
+	dgettext(TEXT_DOMAIN, x), y, z)
 #define	EXIT_FATAL(x) \
 	ipsecutil_exit(SERVICE_FATAL, my_fmri, debugfile, \
 	dgettext(TEXT_DOMAIN, x))
@@ -464,6 +467,9 @@ extern void ipsec_convert_bslabel_to_hex(bslabel_t *, char **);
 #define	EXIT_FATAL3(x, y, z) \
 	ipsecutil_exit(SERVICE_FATAL, my_fmri, debugfile, \
 	dgettext(TEXT_DOMAIN, x), y, z)
+#define	EXIT_FATAL4(x, y, z, z2) \
+	ipsecutil_exit(SERVICE_FATAL, my_fmri, debugfile, \
+	dgettext(TEXT_DOMAIN, x), y, z, z2)
 #define	EXIT_RESTART(x) \
 	ipsecutil_exit(SERVICE_RESTART, my_fmri, debugfile, \
 	dgettext(TEXT_DOMAIN, x))
