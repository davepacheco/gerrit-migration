From 7dd4dbdf370edab01f30fd9732e7be9e0c610f73 Mon Sep 17 00:00:00 2001
From: Hans Rosenfeld <hans.rosenfeld@joyent.com>
Date: Mon, 11 Mar 2019 13:55:20 +0100
Subject: [PATCH] build and ship ccid, fix nits, add annotations

---
 manifest                                      |   1 +
 usr/src/cmd/ccidadm/Makefile                  |   2 +-
 usr/src/cmd/ccidadm/ccidadm.c                 |  61 ++-
 usr/src/cmd/devfsadm/cfg_link.c               |   5 +-
 usr/src/cmd/devfsadm/cfg_link.h               |   3 +
 usr/src/cmd/devfsadm/usb_link.c               |   6 +-
 usr/src/cmd/mdb/common/modules/usba/prtusb.c  |   2 +-
 usr/src/common/ccid/atr.c                     |  38 +-
 usr/src/common/ccid/atr.h                     |   6 +-
 usr/src/common/ccid/ccid_t1.c                 |  36 +-
 usr/src/common/ccid/ccid_t1.h                 |  10 +-
 usr/src/lib/cfgadm_plugins/Makefile           |   3 +-
 usr/src/lib/cfgadm_plugins/ccid/Makefile      |   5 +-
 usr/src/lib/cfgadm_plugins/ccid/Makefile.com  |   2 +
 .../lib/cfgadm_plugins/ccid/amd64/Makefile    |   2 +-
 .../cfgadm_plugins/ccid/common/cfga_ccid.c    |  28 +-
 .../cfgadm_plugins/ccid/common/mapfile-vers   |   2 +-
 usr/src/lib/cfgadm_plugins/ccid/i386/Makefile |   2 +-
 .../lib/cfgadm_plugins/ccid/sparc/Makefile    |   2 +-
 .../lib/cfgadm_plugins/ccid/sparcv9/Makefile  |   2 +-
 usr/src/lib/libcmdutils/common/nicenum.c      |   2 +-
 usr/src/lib/libcmdutils/libcmdutils.h         |   2 +-
 usr/src/lib/libpcsc/Makefile                  |   6 +-
 usr/src/lib/libpcsc/Makefile.com              |   2 +-
 usr/src/lib/libpcsc/amd64/Makefile            |   2 +-
 usr/src/lib/libpcsc/common/libpcsc.c          |   6 +-
 usr/src/lib/libpcsc/common/llib-lpcsc         |   2 +-
 usr/src/lib/libpcsc/common/mapfile-vers       |   2 +-
 usr/src/lib/libpcsc/common/winscard.h         |  12 +-
 usr/src/lib/libpcsc/common/wintypes.h         |   2 +-
 usr/src/lib/libpcsc/i386/Makefile             |   2 +-
 usr/src/man/man7d/ccid.7d                     | 419 +++++++---------
 usr/src/man/man7i/uccid.7i                    | 470 ------------------
 usr/src/test/os-tests/tests/Makefile          |   1 +
 usr/src/test/os-tests/tests/uccid/Makefile    |   4 +-
 usr/src/test/os-tests/tests/uccid/atrparse.c  |  14 +-
 .../test/os-tests/tests/uccid/excl-badread.c  |   2 +-
 .../test/os-tests/tests/uccid/excl-basic.c    |   2 +-
 .../test/os-tests/tests/uccid/excl-close.c    |   2 +-
 usr/src/test/os-tests/tests/uccid/excl-loop.c |   2 +-
 .../test/os-tests/tests/uccid/excl-nonblock.c |   2 +-
 .../test/os-tests/tests/uccid/excl-reset.c    |   4 +-
 .../test/os-tests/tests/uccid/notxn-poll.c    |   2 +-
 usr/src/test/os-tests/tests/uccid/pollin.c    |   2 +-
 usr/src/test/os-tests/tests/uccid/pollout.c   |   2 +-
 usr/src/test/os-tests/tests/uccid/status.c    |   2 +-
 .../test/os-tests/tests/uccid/txn-pollerr.c   |   2 +-
 usr/src/test/os-tests/tests/uccid/yk.c        |   2 +-
 usr/src/uts/common/io/usb/clients/ccid/ccid.c | 307 ++++++------
 usr/src/uts/common/sys/Makefile.syshdrs       |   1 +
 .../uts/common/sys/usb/clients/ccid/ccid.h    |   4 +-
 .../uts/common/sys/usb/clients/ccid/uccid.h   |  39 +-
 usr/src/uts/intel/Makefile.intel              |   1 +
 usr/src/uts/intel/ccid/Makefile               |   4 +-
 usr/src/uts/intel/os/driver_aliases           |   1 +
 usr/src/uts/intel/os/name_to_major            |   1 +
 56 files changed, 527 insertions(+), 1023 deletions(-)
 delete mode 100644 usr/src/man/man7i/uccid.7i

diff --git a/manifest b/manifest
index 788007eaf6..242878cb07 100644
--- a/manifest
+++ b/manifest
@@ -634,6 +634,7 @@ f kernel/drv/amd64/blkdev 0755 root sys
 f kernel/drv/amd64/bnx 0755 root sys
 f kernel/drv/amd64/bnxe 0755 root sys
 f kernel/drv/amd64/bridge 0755 root sys
+f kernel/drv/amd64/ccid 0755 root sys
 f kernel/drv/amd64/chxge 0755 root sys
 f kernel/drv/amd64/clone 0755 root sys
 f kernel/drv/amd64/cmdk 0755 root sys
diff --git a/usr/src/cmd/ccidadm/Makefile b/usr/src/cmd/ccidadm/Makefile
index c32282fa65..abcbc92d87 100644
--- a/usr/src/cmd/ccidadm/Makefile
+++ b/usr/src/cmd/ccidadm/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 PROG= ccidadm
diff --git a/usr/src/cmd/ccidadm/ccidadm.c b/usr/src/cmd/ccidadm/ccidadm.c
index 9357008877..a5e4c02781 100644
--- a/usr/src/cmd/ccidadm/ccidadm.c
+++ b/usr/src/cmd/ccidadm/ccidadm.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc. 
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -59,7 +59,7 @@ typedef struct ccid_list_ofmt_arg {
 } ccid_list_ofmt_arg_t;
 
 /*
- * Attempt to open a CCID slot specified by a user. In general, we exepect that
+ * Attempt to open a CCID slot specified by a user. In general, we expect that
  * users will use a path like "ccid0/slot0". However, they may also specify a
  * full path. If the card boolean is set to true, that means that they may have
  * just specified "ccid0", so we need to try to open up the default slot.
@@ -100,7 +100,8 @@ ccidadm_open(const char *base, boolean_t card)
 		}
 	}
 
-	if (snprintf(buf, sizeof (buf), "%s/%s", CCID_ROOT, base) >= sizeof (buf)) {
+	if (snprintf(buf, sizeof (buf), "%s/%s", CCID_ROOT, base) >=
+	    sizeof (buf)) {
 		errno = ENAMETOOLONG;
 		return (-1);
 	}
@@ -137,8 +138,8 @@ ccidadm_iter(boolean_t readeronly, boolean_t newline,
 		}
 
 		if (ent->fts_info == FTS_ERR || ent->fts_info == FTS_NS) {
-			warn("skipping %s, failed to get information: %s", ent->fts_name,
-			    strerror(ent->fts_errno));
+			warn("skipping %s, failed to get information: %s",
+			    ent->fts_name, strerror(ent->fts_errno));
 			continue;
 		}
 
@@ -175,7 +176,8 @@ ccidadm_list_slot_status_str(uccid_cmd_status_t *ucs, char *buf, uint_t buflen)
 }
 
 static boolean_t
-ccidadm_list_slot_transport_str(uccid_cmd_status_t *ucs, char *buf, uint_t buflen)
+ccidadm_list_slot_transport_str(uccid_cmd_status_t *ucs, char *buf,
+    uint_t buflen)
 {
 	const char *prot;
 	const char *tran;
@@ -229,8 +231,8 @@ ccidadm_list_ofmt_cb(ofmt_arg_t *ofmt, char *buf, uint_t buflen)
 		}
 		break;
 	case CCIDADM_LIST_PRODUCT:
-		if (snprintf(buf, buflen, "%s", cloa->cloa_status->ucs_product) >=
-		    buflen) {
+		if (snprintf(buf, buflen, "%s",
+		    cloa->cloa_status->ucs_product) >= buflen) {
 			return (B_FALSE);
 		}
 		break;
@@ -274,8 +276,8 @@ ccidadm_list_slot(int slotfd, const char *name, void *arg)
 
 static ofmt_field_t ccidadm_list_fields[] = {
 	{ "PRODUCT",	24,	CCIDADM_LIST_PRODUCT,	ccidadm_list_ofmt_cb },
-	{ "DEVICE",	16,	CCIDADM_LIST_DEVICE, 	ccidadm_list_ofmt_cb },
-	{ "CARD STATE",	12,	CCIDADM_LIST_STATE, 	ccidadm_list_ofmt_cb },
+	{ "DEVICE",	16,	CCIDADM_LIST_DEVICE,	ccidadm_list_ofmt_cb },
+	{ "CARD STATE",	12,	CCIDADM_LIST_STATE,	ccidadm_list_ofmt_cb },
 	{ "TRANSPORT",  10,	CCIDADM_LIST_TRANSPORT,	ccidadm_list_ofmt_cb },
 	{ NULL,		0,	0,			NULL	}
 };
@@ -398,13 +400,15 @@ ccidadm_atr_props(uccid_cmd_status_t *ucs)
 		    "default %s parameters\n", atr_protocol_to_string(defprot));
 	} else {
 		(void) printf("Card protocol is not negotiable; starts with "
-		    "specific %s parameters\n", atr_protocol_to_string(defprot));
+		    "specific %s parameters\n",
+		    atr_protocol_to_string(defprot));
 	}
 
 	/*
-	 * For each supported protocol, figure out parameters we would negotiate.
-	 * We only need to warn about auto-negotiation if this is TPDU and
-	 * specific bits are missing. XXX Mask for TDPU and maybe character?
+	 * For each supported protocol, figure out parameters we would
+	 * negotiate. We only need to warn about auto-negotiation if this
+	 * is TPDU and specific bits are missing. XXX Mask for TDPU and
+	 * maybe character?
 	 */
 	if ((ucs->ucs_class.ccd_dwFeatures & (CCID_CLASS_F_AUTO_PARAM_NEG |
 	    CCID_CLASS_F_AUTO_PPS)) == 0) {
@@ -476,8 +480,8 @@ ccidadm_atr_props(uccid_cmd_status_t *ucs)
 		    atr_fmax_index_to_string(fi));
 		(void) printf("  + Di Index: %u (Di %s)\n", di,
 		    atr_di_index_to_string(di));
-		(void) printf("  + Checksum: %s\n", cksum == ATR_T1_CHECKSUM_CRC ?
-		    "CRC" : "LRC");
+		(void) printf("  + Checksum: %s\n",
+		    cksum == ATR_T1_CHECKSUM_CRC ? "CRC" : "LRC");
 		(void) printf("  + Extra Guardtime: %u\n",
 		    atr_extra_guardtime(data));
 		(void) printf("  + BWI: %u\n", atr_t1_bwi(data));
@@ -573,7 +577,8 @@ ccidadm_do_atr(int argc, char *argv[])
 			caa.caa_hex = B_TRUE;
 			break;
 		case ':':
-			errx(EXIT_USAGE, "Option -%c requires an argument\n", optopt);
+			errx(EXIT_USAGE, "Option -%c requires an argument\n",
+			    optopt);
 			break;
 		case '?':
 			errx(EXIT_USAGE, "Unknown option: -%c\n", optopt);
@@ -632,7 +637,7 @@ static ccidadm_pair_t ccidadm_p_protocols[] = {
 };
 
 static ccidadm_pair_t ccidadm_p_voltages[] = {
-	{ CCID_CLASS_VOLT_5_0,	"5.0 V" },
+	{ CCID_CLASS_VOLT_5_0, "5.0 V" },
 	{ CCID_CLASS_VOLT_3_0, "3.0 V" },
 	{ CCID_CLASS_VOLT_1_8, "1.8 V" },
 	{ 0x0, NULL }
@@ -654,12 +659,16 @@ static ccidadm_pair_t ccidadm_p_mechanical[] = {
 };
 
 static ccidadm_pair_t ccidadm_p_features[] = {
-	{ CCID_CLASS_F_AUTO_PARAM_ATR, "Automatic parameter configuration based on ATR data" },
-	{ CCID_CLASS_F_AUTO_ICC_ACTIVATE, "Automatic activation on ICC insertion" },
+	{ CCID_CLASS_F_AUTO_PARAM_ATR,
+	    "Automatic parameter configuration based on ATR data" },
+	{ CCID_CLASS_F_AUTO_ICC_ACTIVATE,
+	    "Automatic activation on ICC insertion" },
 	{ CCID_CLASS_F_AUTO_ICC_VOLTAGE, "Automatic ICC voltage selection" },
-	{ CCID_CLASS_F_AUTO_ICC_CLOCK, "Automatic ICC clock frequency change" },
+	{ CCID_CLASS_F_AUTO_ICC_CLOCK,
+	    "Automatic ICC clock frequency change" },
 	{ CCID_CLASS_F_AUTO_BAUD, "Automatic baud rate change" },
-	{ CCID_CLASS_F_AUTO_PARAM_NEG, "Automatic parameter negotiation by CCID" },
+	{ CCID_CLASS_F_AUTO_PARAM_NEG,
+	    "Automatic parameter negotiation by CCID" },
 	{ CCID_CLASS_F_AUTO_PPS, "Automatic PPS made by CCID" },
 	{ CCID_CLASS_F_ICC_CLOCK_STOP, "CCID can set ICC in clock stop mode" },
 	{ CCID_CLASS_F_ALTNAD_SUP, "NAD value other than zero accepted" },
@@ -735,7 +744,8 @@ ccidadm_reader_print(int fd, const char *name, void *unused)
 	(void) printf("  Maximum IFSD (T=1 only): %u\n", cd->ccd_dwMaxIFSD);
 	if (cd->ccd_dwSyncProtocols != 0) {
 		(void) printf("  Synchronous Protocols Supported:\n");
-		ccidadm_print_pairs(cd->ccd_dwSyncProtocols, ccidadm_p_syncprots);
+		ccidadm_print_pairs(cd->ccd_dwSyncProtocols,
+		    ccidadm_p_syncprots);
 	}
 	if (cd->ccd_dwMechanical != 0) {
 		(void) printf("  Mechanical Features:\n");
@@ -763,7 +773,7 @@ ccidadm_reader_print(int fd, const char *name, void *unused)
 	}
 	if (cd->ccd_wLcdLayout != 0) {
 		(void) printf("  %2ux%2u LCD present\n",
-		    cd->ccd_wLcdLayout >> 16, cd->ccd_wLcdLayout & 0xff);
+		    cd->ccd_wLcdLayout >> 8, cd->ccd_wLcdLayout & 0xff);
 	}
 
 	if (cd->ccd_bPinSupport) {
@@ -832,7 +842,8 @@ ccidadm_usage(const char *format, ...)
 		va_end(ap);
 	}
 
-	(void) fprintf(stderr, "usage:  %s <subcommand> <args> ...\n\n", ccidadm_pname);
+	(void) fprintf(stderr, "usage:  %s <subcommand> <args> ...\n\n",
+	    ccidadm_pname);
 	(void) fprintf(stderr, "Subcommands:\n");
 	for (tab = ccidadm_cmds; tab->cc_name != NULL; tab++) {
 		tab->cc_usage(stderr);
diff --git a/usr/src/cmd/devfsadm/cfg_link.c b/usr/src/cmd/devfsadm/cfg_link.c
index 29f3901691..4415ad55ce 100644
--- a/usr/src/cmd/devfsadm/cfg_link.c
+++ b/usr/src/cmd/devfsadm/cfg_link.c
@@ -20,6 +20,7 @@
  */
 
 /*
+ * Copyright 2019, Joyent, Inc.
  * Copyright 2016 Nexenta Systems, Inc.  All rights reserved.
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
@@ -1268,8 +1269,8 @@ ccid_cfg_creat_cb(di_minor_t minor, di_node_t node)
 		return (DEVFSADM_CONTINUE);
 	}
 
-	(void) snprintf(cfg_path, sizeof (cfg_path), "%s/ccid%d/%s", CFG_DIRNAME,
-	    di_instance(node),  minor_nm);
+	(void) snprintf(cfg_path, sizeof (cfg_path), "%s/ccid%d/%s",
+	    CFG_DIRNAME, di_instance(node),  minor_nm);
 
 	(void) devfsadm_mklink(cfg_path, node, minor, 0);
 	return (DEVFSADM_CONTINUE);
diff --git a/usr/src/cmd/devfsadm/cfg_link.h b/usr/src/cmd/devfsadm/cfg_link.h
index fdd78bcfe2..7c3cf13eb8 100644
--- a/usr/src/cmd/devfsadm/cfg_link.h
+++ b/usr/src/cmd/devfsadm/cfg_link.h
@@ -22,6 +22,9 @@
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
 
 /* private devlink info interfaces */
 
diff --git a/usr/src/cmd/devfsadm/usb_link.c b/usr/src/cmd/devfsadm/usb_link.c
index 1136b91d0d..4c092bfdb0 100644
--- a/usr/src/cmd/devfsadm/usb_link.c
+++ b/usr/src/cmd/devfsadm/usb_link.c
@@ -21,6 +21,9 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
+/*
+ * Copyright 2019, Joyent, Inc.
+ */
 
 #include <devfsadm.h>
 #include <stdio.h>
@@ -314,7 +317,8 @@ usb_process(di_minor_t minor, di_node_t node)
 		return (DEVFSADM_CONTINUE);
 	}
 
-	if (strcmp(di_minor_nodetype(minor), DDI_NT_CCID_ATTACHMENT_POINT) == 0) {
+	if (strcmp(di_minor_nodetype(minor), DDI_NT_CCID_ATTACHMENT_POINT)
+	    == 0) {
 		ccid_create_link(p_path, minor_nm, node, minor);
 		free(l_path);
 		free(p_path);
diff --git a/usr/src/cmd/mdb/common/modules/usba/prtusb.c b/usr/src/cmd/mdb/common/modules/usba/prtusb.c
index 7f32ea3d83..a7a68a516d 100644
--- a/usr/src/cmd/mdb/common/modules/usba/prtusb.c
+++ b/usr/src/cmd/mdb/common/modules/usba/prtusb.c
@@ -22,7 +22,7 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  *
- * Copyright 2016 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 
diff --git a/usr/src/common/ccid/atr.c b/usr/src/common/ccid/atr.c
index 52a7cb870c..73e1b714ae 100644
--- a/usr/src/common/ccid/atr.c
+++ b/usr/src/common/ccid/atr.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -49,7 +49,7 @@
 #define	ATR_TS_DIRECT	0x3B
 
 /*
- * After TS, each word is used t indicate a combination of protocol and the
+ * After TS, each word is used to indicate a combination of protocol and the
  * number of bits defined for that protocol. The lower nibble is treated as the
  * protocol. The upper nibble is treated to indicate which of four defined words
  * are present. These are usually referred to as TA, TB, TC, and TD. TD is
@@ -217,7 +217,7 @@ struct atr_data {
 	atr_ti_t	atr_ti[ATR_TI_MAX];
 	uint8_t		atr_nhistoric;
 	uint8_t		atr_historic[ATR_HISTORICAL_MAX];
-	uint8_t 	atr_cksum;
+	uint8_t		atr_cksum;
 	uint8_t		atr_raw[ATR_LEN_MAX];
 	uint8_t		atr_nraw;
 };
@@ -264,7 +264,8 @@ static const char *atr_fi_table[16] = {
 };
 
 /*
- * This table maps the bit values for Fi from 7816-3:2006 section 8.3 Table 7.
+ * This table maps the bit values for f(max) from 7816-3:2006 section 8.3
+ * Table 7.
  */
 static const char *atr_fmax_table[16] = {
 	"4",		/* 0000 */
@@ -286,7 +287,7 @@ static const char *atr_fmax_table[16] = {
 };
 
 /*
- * This table maps the bit values for Fi from 7816-3:2006 section 8.3 Table 8.
+ * This table maps the bit values for Di from 7816-3:2006 section 8.3 Table 8.
  */
 static uint_t atr_di_valtable[16] = {
 	0,		/* 0000 */
@@ -307,9 +308,6 @@ static uint_t atr_di_valtable[16] = {
 	0		/* 1111 */
 };
 
-/*
- * This table maps the bit values for Fi from 7816-3:2006 section 8.3 Table 8.
- */
 static const char *atr_di_table[16] = {
 	"RFU",		/* 0000 */
 	"1",		/* 0001 */
@@ -330,7 +328,8 @@ static const char *atr_di_table[16] = {
 };
 
 /*
- * This table maps the bit values for Fi from 7816-3:2006 section 8.3 Table 9.
+ * This table maps the bit values for the clock stop indicator from 7816-3:2006
+ * section 8.3 Table 9.
  */
 static const char *atr_clock_table[4] = {
 	"disallowed",		/* 00 */
@@ -468,7 +467,7 @@ atr_count_cbits(uint8_t x)
 }
 
 /*
- * Parse out ATR values. Focus on only parsing it and not interpretting it.
+ * Parse out ATR values. Focus on only parsing it and not interpreting it.
  * Interpretation should be done in other functions that can walk over the data
  * and be more protocol-aware.
  */
@@ -1067,10 +1066,9 @@ atr_data_rate(atr_data_t *data, ccid_class_descr_t *class, uint32_t *rates,
 	 * We're allowed any set of data rates between the default and the
 	 * maximum. Check if the maximum data rate will work for either the
 	 * default or maximum clock. If so, then we can use the cards rates.
-	 * Otherwise we should use thwe can use the ICC's rates. Otherwise we
-	 * should use the default rates. To account for the fact that we may
-	 * have had a fractional value, we require a strict greater than
-	 * comparison.
+	 *
+	 * To account for the fact that we may have had a fractional value,
+	 * we require a strict greater than comparison.
 	 */
 	if ((uint64_t)class->ccd_dwMaxDataRate > maxval ||
 	    (uint64_t)class->ccd_dwMaxDataRate > defval) {
@@ -1094,7 +1092,7 @@ atr_data_rate(atr_data_t *data, ccid_class_descr_t *class, uint32_t *rates,
 void
 atr_data_reset(atr_data_t *data)
 {
-	bzero(data, sizeof (&data));
+	bzero(data, sizeof (*data));
 }
 
 #ifdef	_KERNEL
@@ -1114,11 +1112,11 @@ atr_data_free(atr_data_t *data)
 }
 
 /*
- * Make sure that the response we got from the ICC is valid. For the ICC to
- * valid it must pass checksum and have the PPSS value set correctly. The
- * protocol must match what we requested; however, the PPS1-3 bits are a bit
- * different. They may only be set in the response if we set them in the
- * request. However, they do not have to be set in the response.
+ * Make sure that the response we got from the ICC is valid. It must pass
+ * checksum and have the PPSS value set correctly. The protocol must match
+ * what we requested; however, the PPS1-3 bits are a bit different. They may
+ * only be set in the response if we set them in the request. However, they
+ * do not have to be set in the response.
  */
 boolean_t
 atr_pps_valid(void *reqbuf, size_t reqlen, void *respbuf, size_t resplen)
diff --git a/usr/src/common/ccid/atr.h b/usr/src/common/ccid/atr.h
index c559c94115..998ef66e81 100644
--- a/usr/src/common/ccid/atr.h
+++ b/usr/src/common/ccid/atr.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef _ATR_H
@@ -59,8 +59,8 @@ typedef enum atr_protocol {
 } atr_protocol_t;
 
 typedef enum atr_convention {
-	ATR_CONVENTION_DIRECT 	= 0x00,
-	ATR_CONVENTION_INVERSE 	= 0x01
+	ATR_CONVENTION_DIRECT	= 0x00,
+	ATR_CONVENTION_INVERSE	= 0x01
 } atr_convention_t;
 
 typedef enum atr_clock_stop {
diff --git a/usr/src/common/ccid/ccid_t1.c b/usr/src/common/ccid/ccid_t1.c
index 5ce5d1e018..231980d2b5 100644
--- a/usr/src/common/ccid/ccid_t1.c
+++ b/usr/src/common/ccid/ccid_t1.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 /*
@@ -842,33 +842,33 @@ t1_reply_rblock(t1_state_t *t1, const t1_hdr_t *hdr)
  * types of S-Block commands:
  *
  *  o RESYNCH - This is used to reset the communication betwen the reader and
- *  		the ICC. In theory only the reader is allowed to issue this. If
- *  		we receive any kind of RESYNCH request, we note that as an error
- *  		and will issue a warm reset.
+ *		the ICC. In theory only the reader is allowed to issue this. If
+ *		we receive any kind of RESYNCH request, we note that as an error
+ *		and will issue a warm reset.
  *
  *  o IFS -	This is used to change the size of the data that can be
- *  		transmitted. This may be issued by the reader or the ICC. The
- *  		issuer is describing what size it is that they need to change.
- *  		When the ICC is first detected, we will issue an IFS request to
- *  		increase the reader's IFS. At any time, the ICC is allowed to
- *  		issue an IFS request. However, the initial value is determined
- *  		based on the ATR.
+ *		transmitted. This may be issued by the reader or the ICC. The
+ *		issuer is describing what size it is that they need to change.
+ *		When the ICC is first detected, we will issue an IFS request to
+ *		increase the reader's IFS. At any time, the ICC is allowed to
+ *		issue an IFS request. However, the initial value is determined
+ *		based on the ATR.
  *
  *  o ABORT -	This is used to cancel a chain or series of commands. At this
- *  		time, the framework does not issue aborts. If we receive one
- *  		from the card, then we will issue a warm reset and fail the
- *  		command.
+ *		time, the framework does not issue aborts. If we receive one
+ *		from the card, then we will issue a warm reset and fail the
+ *		command.
  *
- *  o WTX -	This is usd by the card to indicate that it is still processing;
- *  		however it requires additional time. When this is received, we
- *  		must acknowledge it. However, we must also increase the default
- *  		waiting time here and in the command.
+ *  o WTX -	This is used by the card to indicate that it is still
+ *		processing; however it requires additional time. When this
+ *		is received, we must acknowledge it. However, we must also
+ *		increase the default waiting time here and in the command.
  */
 t1_validate_t
 t1_reply_sblock(t1_state_t *t1, const t1_hdr_t *hdr)
 {
 	/*
-	 * XXX We need to impelemnt this. For the time being state that there's
+	 * XXX We need to implement this. For the time being state that there's
 	 * an error on this that says we need to reset the device.
 	 */
 	t1->t1_flags |= T1_F_CMD_ERROR;
diff --git a/usr/src/common/ccid/ccid_t1.h b/usr/src/common/ccid/ccid_t1.h
index 763a52cdec..030f687f85 100644
--- a/usr/src/common/ccid/ccid_t1.h
+++ b/usr/src/common/ccid/ccid_t1.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef _T1_H
@@ -87,7 +87,7 @@ typedef struct t1_hdr {
 #define	T1_RBLOCK_STATUS_MASK	0x03
 
 typedef enum t1_rblock_status {
-	T1_RBLOCK_STATUS_OK 	= 0x00,
+	T1_RBLOCK_STATUS_OK	= 0x00,
 	T1_RBLOCK_STATUS_PARITY	= 0x01,
 	T1_RBLOCK_STATUS_ERROR	= 0x02
 } t1_rblock_status_t;
@@ -152,8 +152,8 @@ typedef enum {
 
 typedef enum t1_state_flags {
 	T1_F_ICC_INIT		= 1 << 0,
-	T1_F_CMD_SENDING 	= 1 << 1,
-	T1_F_CMD_RECEIVING 	= 1 << 2,
+	T1_F_CMD_SENDING	= 1 << 1,
+	T1_F_CMD_RECEIVING	= 1 << 2,
 	T1_F_CMD_ERROR		= 1 << 3,
 	T1_F_CMD_DONE		= 1 << 4,
 	T1_F_CMD_SRESP		= 1 << 5,
@@ -259,7 +259,7 @@ typedef enum {
 
 /*
  * These three functions are used to advance the T=1 state machine. The
- * t1_reply() functino should be used when we receive a reply from the ICC.
+ * t1_reply() function should be used when we receive a reply from the ICC.
  *
  * The t1_step() function is used to basically figure out what to do next. This
  * may mean preparing another command or realizing that we're done with
diff --git a/usr/src/lib/cfgadm_plugins/Makefile b/usr/src/lib/cfgadm_plugins/Makefile
index 46ab473ed4..8fa7f73df7 100644
--- a/usr/src/lib/cfgadm_plugins/Makefile
+++ b/usr/src/lib/cfgadm_plugins/Makefile
@@ -20,6 +20,7 @@
 #
 #
 # Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2019 Joyent, Inc.
 #
 # lib/cfgadm_plugins/Makefile
 #
@@ -37,7 +38,7 @@ ALL_SUBDIRS= $(COMMON_SUBDIRS) $(sparc_SUBDIRS) $(i386_SUBDIRS)
 
 MSGSUBDIRS= $(ALL_SUBDIRS)
 
-all:= 		TARGET= all
+all:=		TARGET= all
 install:=	TARGET= install
 clean:=		TARGET= clean
 clobber:=	TARGET= clobber
diff --git a/usr/src/lib/cfgadm_plugins/ccid/Makefile b/usr/src/lib/cfgadm_plugins/ccid/Makefile
index 848d334f97..2f386978a5 100644
--- a/usr/src/lib/cfgadm_plugins/ccid/Makefile
+++ b/usr/src/lib/cfgadm_plugins/ccid/Makefile
@@ -22,6 +22,7 @@
 # Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2019, Joyent, Inc.
 #
 
 include		../../Makefile.lib
@@ -33,9 +34,9 @@ clean :=	TARGET= clean
 clobber :=	TARGET= clobber
 delete :=	TARGET= delete
 install :=	TARGET= install
-lint := 	TARGET= lint
+lint :=	TARGET= lint
 _msg :=		TARGET= _msg
-package := 	TARGET= package
+package :=	TARGET= package
 
 SED=	sed
 GREP=	grep
diff --git a/usr/src/lib/cfgadm_plugins/ccid/Makefile.com b/usr/src/lib/cfgadm_plugins/ccid/Makefile.com
index 84df66a97d..e56eb7533c 100644
--- a/usr/src/lib/cfgadm_plugins/ccid/Makefile.com
+++ b/usr/src/lib/cfgadm_plugins/ccid/Makefile.com
@@ -22,6 +22,8 @@
 # Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
 #
+# Copyright 2019, Joyent, Inc.
+#
 
 LIBRARY= ccid.a
 VERS= .1
diff --git a/usr/src/lib/cfgadm_plugins/ccid/amd64/Makefile b/usr/src/lib/cfgadm_plugins/ccid/amd64/Makefile
index 5901061730..f2eb3c97a2 100644
--- a/usr/src/lib/cfgadm_plugins/ccid/amd64/Makefile
+++ b/usr/src/lib/cfgadm_plugins/ccid/amd64/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 include ../Makefile.com
diff --git a/usr/src/lib/cfgadm_plugins/ccid/common/cfga_ccid.c b/usr/src/lib/cfgadm_plugins/ccid/common/cfga_ccid.c
index 6cc1ee879f..2b396588fd 100644
--- a/usr/src/lib/cfgadm_plugins/ccid/common/cfga_ccid.c
+++ b/usr/src/lib/cfgadm_plugins/ccid/common/cfga_ccid.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -48,7 +48,7 @@ cfga_ccid_error(cfga_err_t err, char **errp, const char *fmt, ...)
 	 * memory, if this fails, then we have no error.
 	 */
 	va_start(ap, fmt);
-	(void) vasprintf(errp, fmt, ap); 
+	(void) vasprintf(errp, fmt, ap);
 	va_end(ap);
 
 	return (err);
@@ -128,7 +128,7 @@ cfga_ccid_modify(uccid_cmd_icc_modify_t *modify, const char *ap,
 
 	if (ioctl(fd, UCCID_CMD_ICC_MODIFY, modify) != 0) {
 		int e = errno;
-		(void) close (fd);
+		(void) close(fd);
 		return (cfga_ccid_error(CFGA_ERROR, errp,
 		    "failed to modify state on ap %s: %s", ap,
 		    strerror(e)));
@@ -247,13 +247,13 @@ cfga_ccid_fill_info(const uccid_cmd_status_t *ucs, char *buf, size_t len)
 	uint_t bits = CCID_CLASS_F_TPDU_XCHG | CCID_CLASS_F_SHORT_APDU_XCHG |
 	    CCID_CLASS_F_EXT_APDU_XCHG;
 
-	if ((ucs->ucs_status & UCCID_STATUS_F_PRODUCT_VALID) != NULL) {
+	if ((ucs->ucs_status & UCCID_STATUS_F_PRODUCT_VALID) != 0) {
 		product = ucs->ucs_product;
 	} else {
 		product = "<unknown>";
 	}
 
-	if ((ucs->ucs_status & UCCID_STATUS_F_SERIAL_VALID) != NULL) {
+	if ((ucs->ucs_status & UCCID_STATUS_F_SERIAL_VALID) != 0) {
 		serial = ucs->ucs_serial;
 	} else {
 		serial = "<unknown>";
@@ -350,14 +350,15 @@ cfga_list_ext(const char *ap, struct cfga_list_data **ap_list, int *nlist,
 	if (snprintf(cld->ap_log_id, sizeof (cld->ap_log_id), "ccid%d/slot%u",
 	    ucs.ucs_instance, ucs.ucs_slot) >= sizeof (cld->ap_log_id)) {
 		free(cld);
-		return (cfga_ccid_error(CFGA_LIB_ERROR, errp, "ap %s logical id "
-		    "was too large", ap));
+		return (cfga_ccid_error(CFGA_LIB_ERROR, errp, "ap %s logical id"
+		    " was too large", ap));
 	}
 
 	if (strlcpy(cld->ap_phys_id, ap, sizeof (cld->ap_phys_id)) >=
 	    sizeof (cld->ap_phys_id)) {
 		free(cld);
-		return (cfga_ccid_error(CFGA_LIB_ERROR, errp, "ap %s physical id was too long", ap));
+		return (cfga_ccid_error(CFGA_LIB_ERROR, errp,
+		    "ap %s physical id was too long", ap));
 	}
 
 	cld->ap_class[0] = '\0';
@@ -384,7 +385,8 @@ cfga_list_ext(const char *ap, struct cfga_list_data **ap_list, int *nlist,
 	cld->ap_busy = 0;
 	cld->ap_status_time = (time_t)-1;
 	cfga_ccid_fill_info(&ucs, cld->ap_info, sizeof (cld->ap_info));
-	if (strlcpy(cld->ap_type, "icc", sizeof (cld->ap_type)) >= sizeof (cld->ap_type)) {
+	if (strlcpy(cld->ap_type, "icc", sizeof (cld->ap_type)) >=
+	    sizeof (cld->ap_type)) {
 		free(cld);
 		return (cfga_ccid_error(CFGA_LIB_ERROR, errp,
 		    "ap %s type overflowed ICC field", ap));
@@ -398,9 +400,11 @@ cfga_list_ext(const char *ap, struct cfga_list_data **ap_list, int *nlist,
 cfga_err_t
 cfga_help(struct cfga_msg *msgp, const char *opts, cfga_flags_t flags)
 {
-	(*msgp->message_routine)(msgp, "CCID specific commands:\n");
-	(*msgp->message_routine)(msgp, " cfgadm -c [configure|unconfigure] ap_id [ap_id...]\n");
-	(*msgp->message_routine)(msgp, " cfgadm -x warm_reset ap_id [ap_id...]\n");
+	(void) (*msgp->message_routine)(msgp, "CCID specific commands:\n");
+	(void) (*msgp->message_routine)(msgp,
+	    " cfgadm -c [configure|unconfigure] ap_id [ap_id...]\n");
+	(void) (*msgp->message_routine)(msgp,
+	    " cfgadm -x warm_reset ap_id [ap_id...]\n");
 
 	return (CFGA_OK);
 }
diff --git a/usr/src/lib/cfgadm_plugins/ccid/common/mapfile-vers b/usr/src/lib/cfgadm_plugins/ccid/common/mapfile-vers
index c67dbed449..7c7f7d2c0e 100644
--- a/usr/src/lib/cfgadm_plugins/ccid/common/mapfile-vers
+++ b/usr/src/lib/cfgadm_plugins/ccid/common/mapfile-vers
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 #
diff --git a/usr/src/lib/cfgadm_plugins/ccid/i386/Makefile b/usr/src/lib/cfgadm_plugins/ccid/i386/Makefile
index 2fac4622dc..66d7a51776 100644
--- a/usr/src/lib/cfgadm_plugins/ccid/i386/Makefile
+++ b/usr/src/lib/cfgadm_plugins/ccid/i386/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 include ../Makefile.com
diff --git a/usr/src/lib/cfgadm_plugins/ccid/sparc/Makefile b/usr/src/lib/cfgadm_plugins/ccid/sparc/Makefile
index 2fac4622dc..66d7a51776 100644
--- a/usr/src/lib/cfgadm_plugins/ccid/sparc/Makefile
+++ b/usr/src/lib/cfgadm_plugins/ccid/sparc/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 include ../Makefile.com
diff --git a/usr/src/lib/cfgadm_plugins/ccid/sparcv9/Makefile b/usr/src/lib/cfgadm_plugins/ccid/sparcv9/Makefile
index 5901061730..f2eb3c97a2 100644
--- a/usr/src/lib/cfgadm_plugins/ccid/sparcv9/Makefile
+++ b/usr/src/lib/cfgadm_plugins/ccid/sparcv9/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 include ../Makefile.com
diff --git a/usr/src/lib/libcmdutils/common/nicenum.c b/usr/src/lib/libcmdutils/common/nicenum.c
index 4c9cf7687f..c59fa8e477 100644
--- a/usr/src/lib/libcmdutils/common/nicenum.c
+++ b/usr/src/lib/libcmdutils/common/nicenum.c
@@ -22,7 +22,7 @@
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2017 Jason king
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <stdio.h>
diff --git a/usr/src/lib/libcmdutils/libcmdutils.h b/usr/src/lib/libcmdutils/libcmdutils.h
index c37a22c770..c2cd35f40a 100644
--- a/usr/src/lib/libcmdutils/libcmdutils.h
+++ b/usr/src/lib/libcmdutils/libcmdutils.h
@@ -26,7 +26,7 @@
  * Copyright (c) 2013 RackTop Systems.
  */
 /*
- * Copyright 2018 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/lib/libpcsc/Makefile b/usr/src/lib/libpcsc/Makefile
index 7f2723b5d1..97831bd7ea 100644
--- a/usr/src/lib/libpcsc/Makefile
+++ b/usr/src/lib/libpcsc/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 include		../Makefile.lib
@@ -30,9 +30,9 @@ lint :=		TARGET = lint
 
 all clean clobber lint: $(SUBDIRS)
 
-install: 	$(SUBDIRS) install_h
+install:	$(SUBDIRS) install_h
 
-install_h: 	$(ROOTHDRS)
+install_h:	$(ROOTHDRS)
 
 check:		$(CHECKHDRS)
 
diff --git a/usr/src/lib/libpcsc/Makefile.com b/usr/src/lib/libpcsc/Makefile.com
index 2ad8acd1d0..d897a3080d 100644
--- a/usr/src/lib/libpcsc/Makefile.com
+++ b/usr/src/lib/libpcsc/Makefile.com
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017 Joyent, Inc.  All rights reserved.
+# Copyright 2019, Joyent, Inc.
 #
 
 LIBRARY =	libpcsc.a
diff --git a/usr/src/lib/libpcsc/amd64/Makefile b/usr/src/lib/libpcsc/amd64/Makefile
index 4d3cfa1f81..6e90b05faa 100644
--- a/usr/src/lib/libpcsc/amd64/Makefile
+++ b/usr/src/lib/libpcsc/amd64/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 include ../Makefile.com
diff --git a/usr/src/lib/libpcsc/common/libpcsc.c b/usr/src/lib/libpcsc/common/libpcsc.c
index 71a1d93aaa..49cb3c65c1 100644
--- a/usr/src/lib/libpcsc/common/libpcsc.c
+++ b/usr/src/lib/libpcsc/common/libpcsc.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #include <stdlib.h>
@@ -421,7 +421,7 @@ SCardBeginTransaction(SCARDHANDLE arg)
 	}
 
 	/*
-	 * The semantics of pcsc are taht this operation does not block, but
+	 * The semantics of pcsc are that this operation does not block, but
 	 * instead fails if we cannot grab it immediately.
 	 */
 	bzero(&txn, sizeof (uccid_cmd_txn_begin_t));
@@ -436,7 +436,7 @@ SCardBeginTransaction(SCARDHANDLE arg)
 		case EEXIST:
 			/*
 			 * This is an odd case. It's used to tell us that we
-			 * already ahve it. For now, just treat it as success.
+			 * already have it. For now, just treat it as success.
 			 */
 			return (SCARD_S_SUCCESS);
 		case EBUSY:
diff --git a/usr/src/lib/libpcsc/common/llib-lpcsc b/usr/src/lib/libpcsc/common/llib-lpcsc
index 095477b210..94ba94bd10 100644
--- a/usr/src/lib/libpcsc/common/llib-lpcsc
+++ b/usr/src/lib/libpcsc/common/llib-lpcsc
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017 Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /* LINTLIBRARY */
diff --git a/usr/src/lib/libpcsc/common/mapfile-vers b/usr/src/lib/libpcsc/common/mapfile-vers
index 2c8929c6e9..5a3786670a 100644
--- a/usr/src/lib/libpcsc/common/mapfile-vers
+++ b/usr/src/lib/libpcsc/common/mapfile-vers
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 #
diff --git a/usr/src/lib/libpcsc/common/winscard.h b/usr/src/lib/libpcsc/common/winscard.h
index f697f8f7ff..0eb61ee7de 100644
--- a/usr/src/lib/libpcsc/common/winscard.h
+++ b/usr/src/lib/libpcsc/common/winscard.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017 Joyent, Inc.
+ * Copyright 2019 Joyent, Inc.
  */
 
 #ifndef _WINSCARD_H
@@ -35,7 +35,7 @@ extern "C" {
 
 /*
  * This is a departure from the PCSC system which treats this as a LONG. We
- * don't, because we'd like a single value that makes sense across j
+ * don't, because we'd like a single value that makes sense across j XXX?
  */
 typedef void *SCARDCONTEXT;
 typedef void **PSCARDCONTEXT;
@@ -45,7 +45,7 @@ typedef void **PSCARDHANDLE;
 typedef void **LPSCARDHANDLE;
 
 /*
- * Convenentionally this is suppsoed to be packed.
+ * Conventionally this is supposed to be packed.
  */
 #pragma pack(1)
 typedef struct {
@@ -85,13 +85,13 @@ extern SCARD_IO_REQUEST g_rgSCardT0Pci, g_rgSCardT1Pci, g_rgSCardRawPci;
 #define	SCARD_E_NO_READERS_AVAILABLE	((LONG)0x8010002E)
 #define	SCARD_W_UNSUPPORTED_CARD	((LONG)0x80100065)
 #define	SCARD_W_UNPOWERED_CARD		((LONG)0x80100067)
-#define	SCARD_W_RESET_CARD   		((LONG)0x80100068)
+#define	SCARD_W_RESET_CARD		((LONG)0x80100068)
 #define	SCARD_W_REMOVED_CARD		((LONG)0x80100069)
 
 #define	SCARD_SCOPE_USER		0x0000
 #define	SCARD_SCOPE_TERMINAL		0x0001
-#define	SCARD_SCOPE_GLOBAL		0x0002
-#define	SCARD_SCOPE_SYSTEM		0x0003
+#define	SCARD_SCOPE_SYSTEM		0x0002
+#define	SCARD_SCOPE_GLOBAL		0x0003
 
 #define	SCARD_SHARE_EXCLUSIVE	0x0001
 #define	SCARD_SHARE_SHARED	0x0002
diff --git a/usr/src/lib/libpcsc/common/wintypes.h b/usr/src/lib/libpcsc/common/wintypes.h
index a4c1189b92..9bb50a87cc 100644
--- a/usr/src/lib/libpcsc/common/wintypes.h
+++ b/usr/src/lib/libpcsc/common/wintypes.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef _WINTYPES_H
diff --git a/usr/src/lib/libpcsc/i386/Makefile b/usr/src/lib/libpcsc/i386/Makefile
index 0a22fa4dc3..8d1d96297f 100644
--- a/usr/src/lib/libpcsc/i386/Makefile
+++ b/usr/src/lib/libpcsc/i386/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017 Joyent, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 include ../Makefile.com
diff --git a/usr/src/man/man7d/ccid.7d b/usr/src/man/man7d/ccid.7d
index bdf6f32d69..00465e619d 100644
--- a/usr/src/man/man7d/ccid.7d
+++ b/usr/src/man/man7d/ccid.7d
@@ -22,6 +22,7 @@
 .In sys/usb/clients/ccid/uccid.h
 .Sh INTERFACE LEVEL
 .Sy Volatile
+.Pp
 The interfaces provided by this driver are private at this time and
 subject to change.
 It should not be relied upon.
@@ -36,23 +37,19 @@ plugged into a reader.
 The driver also provides interfaces to obtain status information, the
 ATR (answer to reset), and obtain exclusive access to the device.
 In addition, the system exposes control of CCID devices through
-.Xr cfgadm 1M
-and allows programs to watch for changes through event ports.
+.Xr cfgadm 1M .
 This is accomplished through a combination of the standard
 .Xr open 2 ,
 .Xr ioctl 2 ,
 .Xr read 2 ,
 and
 .Xr write 2
-system calls as well as through
-.Xr port_associate 3C
-and
-.Xr port_get 3C .
+system calls.
 .Ss Supported Devices
 The CCID specification allows for readers to come in different flavors.
-These different flavors supprot different communciation protocols and
+These different flavors support different communication protocols and
 have different levels of automation for determining the protocol and
-transfers that are requierd.
+transfers that are required.
 At this time, the following protcols are supported:
 .Bl -bullet -offset indent
 .It
@@ -63,7 +60,7 @@ TPDU T=1
 .Pp
 At this time, TPDU T=0 and character level readers are not supported by
 the driver.
-Readers in this category will still attach and generate events; however,
+Readers in this category will still attach; however,
 I/O cannot be performed to them.
 .Pp
 In addition, at this time the driver does not support devices which
@@ -80,8 +77,9 @@ A slot exists regardless of whether or not an ICC is inserted into it.
 As long as a CCID device is present in the system, its device nodes will
 be present.
 .Pp
-Slots are enumerated using the pattern:
+Slots are enumerated using this pattern:
 .Pa /dev/ccid/ccid%instance/slot%slot .
+.Pp
 For example, all the slots that belong to CCID instance 5 will be
 enumerated under the directory
 .Pa /dev/ccid/ccid5 .
@@ -96,7 +94,7 @@ To enumerate all of the ccid devices present on the system, one could
 read all of the directories under
 .Pa /dev/ccid .
 To enumerate all of the slots on a device, one could read all of the
-direcotires under a particular CCID device, such as:
+device nodes under a particular CCID device, such as:
 .Pa /dev/ccid/ccid0 .
 The number of slots is also obtainable through various ioctls that will
 be discussed later on.
@@ -151,14 +149,11 @@ Similarly, if a command has not been submitted, one cannot issue a
 .Xr read 2
 system call to obtain results.
 Only a single thread may be blocked waiting to submit a command or
+read a response.
 .Pp
 To facilitate non-blocking operation, the underlying file descriptor may
 be opened with
 .Dv O_NONBLOCK .
-To determine whether or not certain events have occurred, event ports
-may be used.
-The exact event ports and the semantics of events are detailed in a
-later section.
 .Pp
 One important note is that readers with multiple slots often still only
 allow I/O a single command to be outstanding across all of the slots in
@@ -204,9 +199,8 @@ Programs must request that the device be opened both for reading and
 writing
 .Po Dv O_RDWR Pc .
 .Pp
-Once the device has been opened, the program may issue ioctls or use
-event ports to get status information and watch for events on the
-system.
+Once the device has been opened, the program may issue ioctls to get
+status information.
 .Pp
 To perform general I/O to the card, a program must be in the context of
 a transaction as discussed in the
@@ -249,250 +243,175 @@ command.
 Please see the ioctl listing in the
 .Sx IOCTLS
 section for more information.
-.Ss Event Model
-There are a number of different classes of events that can be watched
-for.
-Watching for events is performed on a per-slot basis and uses event
-ports to allow for a richer set of events than the traditional usage of
-.Xr poll 2.
-The following events can be watched for:
-.Bl -tag -offset indent -width "Ready to retrieve command results"
-.It ICC insertion
-This event fires when the ICC is inserted into a slot.
-For readers that have a non-removable ICC, this event will fire a single
-time.
-This is an edge triggered event.
-.It ICC removal
-This event fires when the ICC is removed from a slot.
-This event will never fire if an ICC cannot physically be removed from a
-device.
-This is an edge triggered event.
-.It ICC powered on
-This event fires whenever the ICC is powered on.
-This is an edge triggered event.
-.It ICC powered off
-This event fires whenever the ICC is powered off.
-This is an edge triggered event.
-.It Ready for transaction
-This event fires whenever a transaction can be initiated on the slot.
-This is a level triggered event, it will remain asserted while it is
-possible to obtain a transaction.
-It is possible that there are multiple programs that are waiting for a
-transaction to occur.
-In such a case, there is no guarantee that a program that obtains this
-event will be the one to obtain the next transaction.
-.It Ready for command submission
-This event fires whenever it is possible for a command to be submitted.
-It should not fire if the user does not have a transaction.
-This is a level triggered event that will remain valid until a command
-is submitted or a transaction error occurs.
-.It Ready to retrieve command results
-This event fires whenever a command has completed.
-This is a level triggered event that will remain valid until a command
-has been consumed.
-.It Transaction Error
-This event fires whenever something occurs that would invalidate a
-transaction.
-The generation of this event cannot be masked though it will only fire
-if a program is in a transaction.
-This event is level triggered and will persist until the transaction
-ends.
-.It Device Removed
-This event fires whenever the reader itself is removed.
-The generation of this event cannot be masked.
-This event is level triggered and will persist until the file descriptor
-is closed.
-.El
-.Pp
-To ensure that level triggered events are not missed, a generation
-number is associated with each event.
-For more information on the detailed event ports structures, please see
-the section
-.Sx IOCTLS .
 .Sh IOCTLS
 This section lists the different commands that may be issued to a CCID
 device through the
 .Xr ioctl 2
 system call.
-.Sh SYSTEM CALLS
-This section lists the different system calls that may be issued to a
-CCID device.
-.Ss open
-.Ss close
-.Ss write
-.Ss read
-.Ss close
-.Sh EVENTS
-This section describes the event payload format that is used with event
-ports.
-An event port is created with the
-.Xr port_create 3C
-function and then events are associated with it through the
-.Xr port_associate 3C
-function.
-Events are retrieved through the
-.Xr port_get 3C
-or
-.Xr port_getn 3C
-functions.
+.Ss Ic UCCID_CMD_STATUS
+This command is used to obtain the status of the slot.
+It may be used regardless of whether or not the caller has exclusive access.
 .Pp
 The
-.Nm
-driver defines its own event source using the
-.Dv PORT_SOURCE_DEVICE
-object type.
-For more background on the types of events and their classes, see the
-section
-.Sx Event Model .
-The following macros represent different events that are used:
-.Bl -hang -offset indent -width UCCID_EVENT_COMMAND_SUBMISSION_READY
-.It Dv UCCID_EVENT_ICC_INSERTED
-Indicates interest in events when the ICC is inserted.
-.It Dv UCCID_EVENT_ICC_REMOVED
-Indicates interest in events when the ICC is removed.
-.It Dv UCCID_EVENT_ICC_POWERED_ON
-Indicates interest in events when the ICC is powered on.
-.It Dv UCCID_EVENT_ICC_POWERED_OFF
-Indicates interest in events when the ICC is powered off.
-.It Dv UCCID_EVENT_TRANSACTION_READY
-Indicates interest in events when a transaction can be initiated.
-.It Dv UCCID_EVENT_COMMAND_SUBMISSION_READY
-Indicates interest in events when a command can be submitted.
-.It Dv UCCID_EVENT_COMMAND_COMPLETED
-Indicates interest in events when a command is completed.
-.It Dv UCCID_EVENT_TRANSACTION_ERROR
-Indicates that a fatal error to the transaction occurred.
-.It Dv UCCID_EVENT_READER_GONE
-Indicates that the CCID reader has been removed from the system.
+.Ic UCCID_CMD_STATUS
+command uses the structure
+.Vt uccid_cmd_status_t ,
+the fields of which have the following meanings:
+.Bl -tag -width Fa
+.It Fa uint32_t ucs_version
+Indicates the current version of the structure.
+Should be set to
+.Dv UCCID_CURRENT_VERSION .
+.It Fa uint32_t ucs_status
+This value is ignored when issuing the command.
+On return, it will be filled in with various flags that describe the
+current status of the slot and the contents returned in the
+.Vt uccid_cmd_status_t .
+The following flags are defined:
+.Bl -tag -width Dv
+.It Dv UCCID_STATUS_F_CARD_PRESENT
+A card has been inserted into the slot of the CCID class device.
+.It Dv UCCID_STATUS_F_CARD_ACTIVE
+The inserted card has been successfully activated.
+This will only be set if the
+.Dv UCCID_STATUS_F_CARD_PRESENT
+flag is also set.
+.It Dv UCCID_STATUS_F_PRODUCT_VALID
+The contents of
+.Fa ucs_product
+are valid.
+.It Dv UCCID_STATUS_F_SERIAL_VALID
+The contents of
+.Fa ucs_serial
+are valid.
+.It Dv UCCID_STATUS_F_PARAMS_VALID
+The parameters returned in
+.Fa ucs_params
+are valid.
 .El
+.It Fa int32_t ucs_instance
+The instance number of the CCID device.
+.It Fa uint32_t ucs_slot
+The slot number currently in use.
+.It Fa uint8_t ucs_atr[UCCID_ATR_MAX]
+The ATR (answer to reset) of the card.
+.It Fa uint8_t ucs_atrlen
+The actual length of the ATR data.
+A length of 0 indicates that there is no ATR data.
+.It Fa int8_t ucs_product[256]
+The product string of the CCID device.
+.It Fa int8_t ucs_serial[256]
+The serial number of the CCID device.
+.It Fa ccid_class_descr_t ucs_class
+The CCID class descriptor of the CCID device.
+.It Fa uccid_prot_t ucs_prot
+The protocol in use by the ICC.
+This can be either
+.Dv UCCID_PROT_T0
+for the TPDU T=0 protocol or
+.Dv UCCID_PROT_T1
+for the TPDU T=1 protocol.
+.It Fa ccid_params_t ucs_params
+The CCID parameters available on the card.
+.El
+.Ss UCCID_CMD_TXN_BEGIN
+This command is used to begin a transaction.
+The command will block until exclusive access is available to the
+caller.
+If the caller does not wish to block, it should set the
+.Dv UCCID_TXN_DONT_BLOCK
+flag.
 .Pp
-The above values are used to select events to listen for and are used to
-indicate what events have fired.
-As discussed in the
-.Sx Event Model
-section, the ICC related events are normally edge triggered.
-To facilitate the detection of such events, there is a 64-bit generation
-associated with each one.
-Every time an event occurs, the generation for that event is increased.
-If the generation of an event does not match the current generation,
-then the event will immediately trigger.
-The current generation is available in the
-.Dv UCCID_CMD_STATUS
-command discussed in the
-.Sx IOCTLS
-section.
-.Pp
-To associate a CCID event with an event port, the program must use the
-following structure and issue a call to
-.Xr port_associate 3C
-with the type
-.Dv PORT_SOURCE_DEVICE .
-The CCID specific structure for this is:
-.Bd -literal -offset indent
-typedef struct uccid_event {
-	int32_t		ce_fd;
-	uint32_t	ce_version;
-	uint64_t	ce_size;
-	uint64_t	ce_desired;
-	uint64_t	ce_fired;
-	uint64_t	ce_icc_insert_gen;
-	uint64_t	ce_icc_remove_gen;
-	uint64_t	ce_icc_on_gen;
-	uint64_t	ce_icc_off_gen;
-} uccid_event_t;
-.Ed
-.Pp
-The
-.Fa ce_fd
-member should be filled in with the value of the file descriptor of the
-slot which you are asking about.
-.Pp
-The
-.Fa ce_version
-member should be set to the value
-.Dv UCCID_VERSION_ONE .
-.Pp
-The
-.Fa ce_size
-member should be set to the size of the
-.Ft uccid_event_t
-structure.
-.Pp
-The
-.Fa ce_desired
-member should be set to the bitwise-inclusive-OR of all of the events
-which are desired.
-There is no need to set either
-.Dv UCCID_EVENT_TRANSACTION_ERROR
-or
-.Dv UCCID_EVENT_READER_GONE
-as these will always be generated.
-.Pp
-The
-.Fa ce_actual
-event should be set to zero.
-This will be filled in with the actual set of events that caused this to
-fire.
+The command uses the structure
+.Vt uccid_cmd_txn_begin_t
+with the following members:
+.Bl -tag -width Fa
+.It Fa uint32_t ucs_version
+Indicates the current version of the structure.
+Should be set to
+.Dv UCCID_CURRENT_VERSION .
+.It Fa uint32_t uct_flags
+Flags that impact the behavior of the command.
+The following flags are
+defined:
+.Bl -tag -width Dv
+.It Dv UCCID_TXN_F_DONT_BLOCK
+The command should not block for exclusive access.
+If exclusive access is not available, then the command will fail
+immediately.
+.El
 .Pp
+If an unknown flag is specified, an error will be returned.
+.El
+.Ss UCCID_CMD_TXN_END
 The
-.Fa ce_icc_insert_gen
-should be set to the current generation of the ICC insertion event that
-has occurred.
-This should be set to the value from the most recent
-.Dv UCCID_CMD_STATUS
-information that was read or set to zero.
-This will be filled in with the new generation of the event when it
-fires.
-If the
-.Dv UCCID_EVENT_ICC_INSERTED
-event is not in
-.Fa ce_desired
-then this field should be set to zero.
+.Dv UCCID_CMD_TXN_END
+command is used to end a transaction and relinquish exclusive access
+to the ICC.
 .Pp
-The
-.Fa ce_icc_remove_gen
-should be set to the current generation of the ICC removal event that
-has occurred.
-This should be set to the value from the most recent
-.Dv UCCID_CMD_STATUS
-information that was read or set to zero.
-This will be filled in with the new generation of the event when it
-fires.
-If the
-.Dv UCCID_EVENT_ICC_REMOVED
-event is not in
-.Fa ce_desired
-then this field should be set to zero.
+The command uses the structure
+.Vt uccid_cmd_txn_end_t
+with the following members:
+.Bl -tag -width Fa
+.It Fa uint32_t uct_version
+Indicates the current version of the structure.
+Should be set to
+.Dv UCCID_CURRENT_VERSION .
+.It Fa uint32_t uct_flags
+.Bl -tag -width Dv
+.It Dv UCCID_TXN_END_RESET
+The ICC should be reset at the end of the transaction.
+.It Dv UCCID_TXN_END_RELEASE
+The ICC should be released without being reset at the end of the
+transaction.
+.El
 .Pp
-The
-.Fa ce_icc_on_gen
-should be set to the current generation of the ICC power on event that
-has occurred.
-This should be set to the value from the most recent
-.Dv UCCID_CMD_STATUS
-information that was read or set to zero.
-This will be filled in with the new generation of the event when it
-fires.
-If the
-.Dv UCCID_EVENT_ICC_POWERED_ON
-event is not in
-.Fa ce_desired
-then this field should be set to zero.
+Exactly one of these two flags must be specified.
+It is an error if neither flag or both flags are specified at the same
+time.
+If the device is closed without ending a transaction first, then the ICC
+will be reset.
+.El
+.Ss UCCID_CMD_ERROR_INFO
+XXX needs to be documented
+.Ss UCCID_CMD_ICC_MODIFY
+This command can be used to change the state of an ICC, if present.
 .Pp
-The
-.Fa ce_icc_off_gen
-should be set to the current generation of the ICC removal event that
-has occurred.
-This should be set to the value from the most recent
-.Dv UCCID_CMD_STATUS
-information that was read or set to zero.
-This will be filled in with the new generation of the event when it
-fires.
-If the
-.Dv UCCID_EVENT_ICC_POWERED_OFF
-event is not in
-.Fa ce_desired
-then this field should be set to zero.
+The command uses the structure
+.Vt uccid_cmd_icc_modify_t
+with the following members:
+.Bl -tag -width Fa
+.It Fa uint32_t uci_version
+Indicates the current version of the structure.
+Should be set to
+.Dv UCCID_CURRENT_VERSION .
+.It Fa uint32_t uci_action
+The action to be taken on the ICC.
+The following actions are defined:
+.Bl -tag -width Dv
+.It Dv UCCID_ICC_POWER_ON
+Power on the ICC.
+.It Dv UCCID_ICC_POWER_OFF
+Power off the ICC.
+.It Dv UCCID_ICC_WARM_RESET
+Perform a warm reset of the ICC.
+.El
+.El
+.Ss FIONREAD
+This command returns the size in bytes of a command response available
+for reading with
+.Xr read 2 .
+The size is returned in an
+.Vt int
+pointed to by the argument.
+.Sh SYSTEM CALLS
+This section lists the different system calls that may be issued to a
+CCID device.
+.Ss open
+.Ss close
+.Ss write
+.Ss read
+.Ss close
 .Sh SEE ALSO
 .Xr ccidadm 1M ,
 .Xr cfgadm 1M ,
@@ -500,9 +419,7 @@ then this field should be set to zero.
 .Xr ioctl 2 ,
 .Xr open 2 ,
 .Xr read 2 ,
-.Xr write 2 ,
-.Xr port_associate 3C ,
-.Xr port_get 3C
+.Xr write 2
 .Rs
 .%T Universal Serial Bus Device Class: Smart Card CCID
 .%O Revision 1.1
diff --git a/usr/src/man/man7i/uccid.7i b/usr/src/man/man7i/uccid.7i
deleted file mode 100644
index 75f767d39b..0000000000
--- a/usr/src/man/man7i/uccid.7i
+++ /dev/null
@@ -1,470 +0,0 @@
-.\"
-.\" This file and its contents are supplied under the terms of the
-.\" Common Development and Distribution License ("CDDL"), version 1.0.
-.\" You may only use this file in accordance with the terms of version
-.\" 1.0 of the CDDL.
-.\"
-.\" A full copy of the text of the CDDL should have accompanied this
-.\" source.  A copy of the CDDL is also available via the Internet at
-.\" http://www.illumos.org/license/CDDL.
-.\"
-.\"
-.\" Copyright 2016 Joyent, Inc.
-.\"
-.Dd September 16, 2017
-.Dt UCCID 7I
-.Os
-.Sh NAME
-.Nm uccid
-.Nd user CCID command interface
-.Sh SYNOPSIS
-.In sys/usb/clients/ccid/uccid.h
-.Pa /dev/ccid/
-.Sh DESCRIPTION
-The
-.Nm
-command allows for a userland daemon to open and perform operations on a CCID class device.
-.Pp
-This interface allows for userland programs to be send APDU (application protocol data unit) to a given smart card and receive information back from the controller.
-This also abstracts out some of the finer grained differences between different classes of controllers and allows for exclusive access to devices.
-.Pp
-The
-.Nm
-commands operate on device nodes through a combination of the standard
-.Xr open 2 ,
-.Xr read 2 ,
-.Xr write 2 ,
-and
-.Xr poll 2
-system calls and provides several commands that may be issued through
-the
-.Xr ioctl 2
-system call.
-.Ss Device Nodes
-A given CCID class device provides a number of slots.
-Inside of each slot a card may or may not be present.
-A character device is created to represent each
-.Em slot
-of a CCID class device.
-This means that as long as a given CCID class device is present, then there will be a minor node for the slot, regardless of whether a card or not is present.
-.Pp
-A character device will be created under
-.Pa /dev
-for each slot of a CCID class device.
-Slots will be enumerated at
-.Pa /dev/ccid/ccid%d/slot%d .
-For example, all the slots under CCID instance 5 will be found in the
-directory
-.Pa /dev/ccid/ccid5/ .
-Slot two on the first enumerated CCID instance 0 will be found at
-.Pa /dev/ccid/ccid0/slot2 .
-While the enumeration of slots within a device should always be
-consistent (subject to the device), the instance number of a device may
-change.
-Additional symlinks to device directories may be present based on
-properties such as a USB serial number.
-.Ss Opening Devices, Exclusive Access, and Transactions
-A given slot may be opened through its path under
-.Pa /dev .
-To open a device, the user must be in the global zone and must have the
-.Sy PRIV_SYS_DEVICES
-privilege.
-To access the device node, the driver should call
-.Xr open 2
-or
-.Xr openat 2 .
-The device node must be opened for both read and write
-.Pq Dv O_RDWR .
-If only one of read or write is specified, the open will fail.
-.Pp
-To send commands to and from the device, a user must have exclusive
-access.
-Exclusive access can be obtained in one of two ways.
-The first is to use the
-.Dv O_EXCL
-flag during a call to
-.Xr open 2 .
-The second is to perform the
-.Dv UCCID_CMD_TXN_BEGIN
-command through
-.Xr ioctl 2 .
-.Pp
-Exclusive access is obtained on a slot level.
-Once granted, exclusive access is maintained regardless if cards are
-inserted or removed.
-To drop exclusive access, the driver may perform the
-.Dv UCCID_CMD_TXN_END
-command or close the file descriptor.
-If a process holding exclusive access exits or crashes, the system will
-behave as though it called
-.Xr close 2
-on the file descriptor.
-.Pp
-If something else already has exclusive access, then callers will block
-until exclusive access is relinquished.
-If there are multiple callers seeking exclusive access blocked, the order
-at which they will be granted that access is undefined.
-If the caller does not wish to block while obtaining exclusive access,
-it may use the
-.Dv O_NDELAY
-or
-.Dv UCCID_TXN_F_DONT_BLOCK
-flag as needed.
-See the later discussions of
-.Xr open 2
-and the
-.Dv UCCID_CMD_TXN_BEGIN
-command for more information.
-.Pp
-Once exclusive access is obtained, a client may send any number of APDUs
-or issue any number of commands that it desires.
-.Pp
-A well behaved client will ensure that it does not have any outstanding
-I/O when it drops exclusive access.
-If any threads are blocked in the read or write family of routines, they
-will error out.
-Any outstanding commands that have not been read, will be dropped.
-.Pp
-It is important that a given caller only attempt to have exclusive
-access to a single slot at any given time.
-Otherwise, if the caller is holding onto exclusive access on one device
-while attempting to obtain exclusive access to another, there is a
-chance of deadlock with another caller that is attempting to obtain
-exclusive access to multiple slots in a different order.
-.Ss Device Status and ATR
-Once the device is open, any caller may issue commands to get the status
-of the slot and to obtain the ATR (answer to reset) data of a card, if
-it is present in the slot.
-.Pp
-A caller may issues these commands if they do not have exclusive access;
-however, there is no guarantee that it will not have changed by the time
-the caller obtains exclusive access.
-As such, it is not recommended to ask for the ATR data while exclusive
-access is not present.
-.Pp
-The status of the slot is used to indicate if a card is present in the
-slot and if so, whether or not the card has been activated and is thus
-ready for use.
-To obtain this information, issue the
-.Dv UCCID_CMD_STATUS
-command.
-See the
-.Sx COMMANDS
-section for details of the structure.
-.Pp
-To obtain the ATR data, callers may issue the
-.Dv UCCID_CMD_GETATR
-command.
-This command can be used to both fetch the actual data and to get the
-size of the ATR payload, which may vary from card to card.
-.Ss Performing I/O
-Once exclusive access is obtained, the caller may use the
-.Xr read 2
-and
-.Xr write 2
-family of system calls to send and receive APDUs to the device.
-I/O to a CCID class device functions must always send and receive an
-entire APDU.
-This is similar to the behavior of reading and writing data to a
-datagram class socket.
-.Pp
-To send a command, the caller should issue a system call from the
-.Xr write 2
-family.
-That command will be sent to the driver by the host.
-Only once the command has been fully sent to the device, will the write
-system call return.
-Once the write is finished, the caller should use the
-.Xr read 2
-family of system calls to obtain the result.
-If the caller would rather use non-blocking I/O, it may poll on the
-device and wait for a
-.Dv POLLIN
-event.
-.Pp
-The caller does not need to worry about the framing of APDU data to and from
-a CCID class device.
-This will be handled by a combination of hardware and the CCID driver
-framework.
-.Pp
-If no card is present or the caller does not have exclusive access, then
-reads and writes will always fail.
-If a card is removed, outstanding I/O operations will all fail, even if
-another card is inserted before all of the commands can be failed.
-.Pp
-CCID class devices may only have one outstanding command on a given
-slot.
-While callers may issue multiple commands to the driver only a single
-command will be issued to a given slot at any given time.
-Other commands will be blocked and processed in turn.
-It is recommended that callers do not issue multiple commands as the
-ordering of said commands is not guaranteed.
-.Ss Card Insertion and Removal Notifications
-XXX
-.Sh SYSTEM CALLS
-.Ss open family
-The
-.Xr open 2
-and
-.Xr openat 2
-system calls are used to open a device.
-For more details, see the
-.Sx Opening Devices, Exclusive Access, and Transactions
-section.
-.Pp
-The following flags that may be passed to open have special
-significance:
-.Bl -tag -width Dv
-.It Dv O_EXCL
-Request exclusive access to the device.
-This will block until access is available unless
-.Dv O_NDELAY
-is also specified.
-.It Dv O_NDELAY
-Indicates that if exclusive access it not available, fail immediately.
-This flag may not be specified without
-.Dv O_EXCL .
-.It Dv O_NONBLOCK
-Indicates that non-blocking
-.Xr read 2
-and
-.Xr write 2
-system calls should be performed.
-This may be changed at any time through the
-.Dv F_SETFL
-command to
-.Xr fcntl 2 .
-.El
-.Ss read family
-The
-.Xr read 2 ,
-.Xr readv 2 ,
-.Xr pread 2 ,
-and
-.Xr preadv 2
-systems calls reads an entire APDU response into one or more buffers.
-Each read of the device will consume an entire CCID APDU response,
-similar to operating on a datagram device.
-If the
-.Dv O_NONBLOCK
-flag has been specified and no data is available, the system call will
-return immediately.
-File offsets are ignored and in the case of
-.Xr read 2
-and
-.Xr readv 2 ,
-explicitly reset.
-.Pp
-If no card is present in the slot or the caller does not have exclusive
-access, a read will always fail.
-.Ss write
-The
-.Xr write 2 ,
-.Xr writev 2 ,
-.Xr pwrite 2 ,
-and
-.Xr pwritev 2
-system calls transmit an entire APDU to a device.
-Once the command has been fully transfered, the write will return.
-If there are multiple outstanding commands in flight, the write will
-block and the order of commands is not guaranteed.
-The
-.Dv O_NONBLOCK
-flag is ignored when writing.
-File offsets are ignored and in the case of
-.Xr write 2
-and
-.Xr writev 2 ,
-explicitly reset.
-.Pp
-If no card is present in the slot or a caller does not have exclusive
-access, a write will always fail.
-.Ss poll
-The slot device can be polled for
-.Dv POLLIN
-which is used to indicate that a command is readable or it may be polled
-for
-.Dv POLLHUP
-which is used to indicate that a card has been removed from a slot.
-No other poll flags will be issued by the device.
-.Pp
-If no card is present in the slot or a caller does not have exclusive
-access, all attempts to poll will fail.
-.Ss ioctl
-The
-.Xr ioctl 2
-system call behaves normally.
-Valid commands are listed in the
-.Sx COMMANDS
-section.
-.Ss close
-The
-.Xr close 2
-system call behaves normally.
-When the final
-.Xr close 2
-is performed from a given handle, any exclusive access will be
-discarded.
-If a file descriptor has been duplicated through the means of the
-.Xr dup 2
-family of system calls, then the final close refers to the time when all
-such duplicated file descriptors have been closed.
-.Sh COMMANDS
-For each of the commands listed below, a specific structure accompanies
-it.
-The first member of each of these structures is a version field which
-represents the current form of the structure.
-Callers should always set this member to
-.Dv UCCID_CURRENT_VERSION .
-.Ss UCCID_CMD_TXN_BEGIN
-The
-.Dv UCCID_CMD_TXN_BEGIN
-command is used to begin a transaction.
-The command will block until exclusive access is available to the
-caller.
-If the caller does not wish to block, it should set the
-.Dv UCCID_TXN_F_DONT_BLOCK
-flag.
-.Pp
-The command uses the following structure:
-.Bd -literal -offset indent
-typedef struct	uccid_cmd_txn_begin {
-	uint_t	uct_version;
-	uint_t	uct_flags;
-} uccid_cmd_txn_begin_t;
-.Ed
-.Pp
-The fields of the
-.Vt uccid_cmd_txn_begin_t
-have the following meanings:
-.Bl -tag -width Fa
-.It Fa uct_version
-Indicates the current version of the structure.
-Should be set to
-.Dv UCCID_CURRENT_VERSION .
-.It Fa uct_flags
-Flags that impact the behavior of the command.
-The following flags are
-defined:
-.Bl -tag -width Dv
-.It Dv UCCID_TXN_F_DONT_BLOCK
-The command should not block for exclusive access.
-If exclusive access is not available, then the command will fail
-immediately.
-.El
-.Pp
-If an unknown flag is specified, an error will be generated.
-.El
-.Ss UCCID_CMD_TXN_END
-The
-.Dv UCCID_CMD_TXN_END
-command is used to end a transaction whether it was started through the
-.Dv UCCID_CMD_TXN_BEGIN
-command or by passing
-.Dv O_EXCL
-to the
-.Xr open 2
-system call.
-.Pp
-The command uses the following structure:
-.Bd -literal -offset indent
-typedef struct	uccid_cmd_txn_end {
-	uint_t	uct_version;
-} uccid_cmd_txn_end_t;
-.Ed
-.Pp
-The fields of the
-.Vt uccid_cmd_txn_end_t
-have the following meanings:
-.Bl -tag -width Fa
-.It Fa uct_version
-Indicates the current version of the structure.
-Should be set to
-.Dv UCCID_CURRENT_VERSION .
-.El
-.Ss UCCID_CMD_STATUS
-This command is used to obtain the status of the slot.
-It may be used regardless of whether or not the caller has exclusive
-access.
-.Pp
-The command uses the following structure:
-.Bd -literal -offset indent
-typedef struct	uccid_cmd_status {
-	uint_t	ucs_version;
-	uint_t	ucs_status;
-} uccid_cmd_status_t;
-.Ed
-.Pp
-The fields of the
-.Vt uccid_cmd_status_t
-have the following meanings:
-.Bl -tag -width Fa
-.It Fa ucs_version
-Indicates the current version of the structure.
-Should be set to
-.Dv UCCID_CURRENT_VERSION .
-.It Fa ucs_status
-This value is ignored when issuing the command.
-On return, it will be filled in with various flags that describe the
-current status of the slot.
-The following flags are defined:
-.Bl -tag -width Dv
-.It Dv UCCID_STATUS_F_CARD_PRESENT
-A card has been inserted into the slot of the CCID class device.
-.It Dv UCCID_STATUS_F_CARD_ACTIVE
-The inserted card has been successfully activated.
-.El
-.Pp
-The
-.Dv UCCID_STATUS_F_CARD_ACTIVE
-flag will only be set if the
-.Dv UCCID_STATUS_F_CARD_PRESENT
-flag is set.
-.El
-.Ss UCCID_CMD_GETATR
-The
-.Dv UCCID_CMD_GETATR
-command is used to obtain the ATR (answer to reset) data from a card
-that is present in the slot.
-This command does not require exclusive access; however, there is
-nothing that guarantees the ATR data will not have changed by the time
-exclusive access is granted.
-To obtain the size of the ATR data, the caller should set the buffer
-length to zero.
-It will be filled in to indicate the required size of the buffer
-otherwise.
-.Pp
-The command uses the following structure:
-.Bd -literal -offset indent
-typedef struct uccid_cmd_getatr {
-	uint_t	ucg_version;
-	uint_t	ucg_buflen;
-	/* XXX should this just be a static buffer with a likely maximum size? */
-	void	*ucg_buffer;
-} uccid_cmd_getattr_t;
-.Ed
-.Pp
-The fields of the
-.Vt uccid_cmd_getatr_t
-have the following meanings:
-.Bl -tag -width Fa
-.It Fa ucg_version
-Indicates the current version of the structure.
-Should be set to
-.Dv UCCID_CURRENT_VERSION .
-.It Fa ucg_buflen
-Indicates the size in bytes of the buffer
-.Fa ucg_buffer .
-.It Fa ucg_buffer
-A pointer to a buffer to place the ATR data.
-.El
-.Pp
-When this command is issued, the system will check the size of
-.Fa ucg_buflen .
-If it is sufficient to hold the ATR data, then the ATR data will be
-copied out into
-.Fa ucb_buffer
-and the number of bytes written will be placed into
-.Fa ucb_buflen .
-If the buffer length is insufficient or zero, then no copying will
-occur; however, the buffer length will be updated.
diff --git a/usr/src/test/os-tests/tests/Makefile b/usr/src/test/os-tests/tests/Makefile
index e3e756c946..3107af540c 100644
--- a/usr/src/test/os-tests/tests/Makefile
+++ b/usr/src/test/os-tests/tests/Makefile
@@ -29,6 +29,7 @@ SUBDIRS =       \
 		stress \
 		timer \
 		tmpfs \
+		uccid \
 		$(SUBDIRS_$(MACH))
 
 PROGS = \
diff --git a/usr/src/test/os-tests/tests/uccid/Makefile b/usr/src/test/os-tests/tests/uccid/Makefile
index 614309c494..73dd6b2381 100644
--- a/usr/src/test/os-tests/tests/uccid/Makefile
+++ b/usr/src/test/os-tests/tests/uccid/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 include $(SRC)/Makefile.master
@@ -18,7 +18,7 @@ include $(SRC)/Makefile.master
 ROOTOPTPKG = $(ROOT)/opt/os-tests
 TESTDIR = $(ROOTOPTPKG)/tests/uccid
 
-PROGS = 		\
+PROGS =		\
 	atrparse	\
 	excl-basic	\
 	excl-badread	\
diff --git a/usr/src/test/os-tests/tests/uccid/atrparse.c b/usr/src/test/os-tests/tests/uccid/atrparse.c
index 034fd37732..f14bbfd34d 100644
--- a/usr/src/test/os-tests/tests/uccid/atrparse.c
+++ b/usr/src/test/os-tests/tests/uccid/atrparse.c
@@ -10,12 +10,11 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
- * Verify that we can grab a basic exclusive lock through an ioctl on the slot.
- * Then that we can release it afterwards.
+ * Verify that we can parse various forms of ATR data and detect invalid data.
  */
 
 #include <err.h>
@@ -69,7 +68,8 @@ atr_test_t atr_tests[] = {
 	{ "Bad TS (2)", 2, { 0xff, 0x00 }, ATR_CODE_INVALID_TS },
 	{ "T0 w/ T=15 and bad cksum", 6, { 0x3b, 0x80, 0x80, 0x1f, 0x00, 0x00 },
 	    ATR_CODE_CHECKSUM_ERROR },
-	{ "T0 w/ T=15 and bad cksum (make sure no TS)", 6, { 0x3b, 0x80, 0x80, 0x1f, 0x00, 0x24 },
+	{ "T0 w/ T=15 and bad cksum (make sure no TS)", 6,
+	    { 0x3b, 0x80, 0x80, 0x1f, 0x00, 0x24 },
 	    ATR_CODE_CHECKSUM_ERROR },
 	{ "T=15 in TD1", 4, { 0x3b, 0x80, 0x0f, 0x8f }, ATR_CODE_INVALID_TD1 },
 	{
@@ -583,7 +583,7 @@ atr_parse_one(atr_data_t *data, atr_test_t *test)
 	atr_convention_t conv;
 	atr_clock_stop_t stop;
 
-	ret = atr_parse(test->ar_buf, test->ar_len, data); 
+	ret = atr_parse(test->ar_buf, test->ar_len, data);
 	if (ret != test->ar_retval) {
 		atr_parse_failed(test, "found unexpected return "
 		    "value: %u (%s), expected: %u", ret, atr_strerror(ret),
@@ -618,8 +618,8 @@ atr_parse_one(atr_data_t *data, atr_test_t *test)
 
 	if (neg != test->ar_neg) {
 		atr_parse_failed(test, "Found mismatched negotiable bit: "
-		   "%u, expected %u", neg, test->ar_neg);
-	       err++;	
+		    "%u, expected %u", neg, test->ar_neg);
+		err++;
 	}
 
 	if (fi != test->ar_fi) {
diff --git a/usr/src/test/os-tests/tests/uccid/excl-badread.c b/usr/src/test/os-tests/tests/uccid/excl-badread.c
index c75d6e8bbd..e5f265d1e7 100644
--- a/usr/src/test/os-tests/tests/uccid/excl-badread.c
+++ b/usr/src/test/os-tests/tests/uccid/excl-badread.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/excl-basic.c b/usr/src/test/os-tests/tests/uccid/excl-basic.c
index 38c52d8321..c6cf30dd5e 100644
--- a/usr/src/test/os-tests/tests/uccid/excl-basic.c
+++ b/usr/src/test/os-tests/tests/uccid/excl-basic.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/excl-close.c b/usr/src/test/os-tests/tests/uccid/excl-close.c
index 1fd1e327aa..3936c73ab0 100644
--- a/usr/src/test/os-tests/tests/uccid/excl-close.c
+++ b/usr/src/test/os-tests/tests/uccid/excl-close.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/excl-loop.c b/usr/src/test/os-tests/tests/uccid/excl-loop.c
index 81bf9366f8..f31fc81a34 100644
--- a/usr/src/test/os-tests/tests/uccid/excl-loop.c
+++ b/usr/src/test/os-tests/tests/uccid/excl-loop.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/excl-nonblock.c b/usr/src/test/os-tests/tests/uccid/excl-nonblock.c
index 9d4a2bc8d5..ee4f1edbd1 100644
--- a/usr/src/test/os-tests/tests/uccid/excl-nonblock.c
+++ b/usr/src/test/os-tests/tests/uccid/excl-nonblock.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/excl-reset.c b/usr/src/test/os-tests/tests/uccid/excl-reset.c
index 58d4956670..7ab1718475 100644
--- a/usr/src/test/os-tests/tests/uccid/excl-reset.c
+++ b/usr/src/test/os-tests/tests/uccid/excl-reset.c
@@ -10,12 +10,12 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
  * Verify that we can grab a basic exclusive lock through an ioctl on the slot.
- * Then that we can release it afterwards.
+ * Then that we can release it afterwards and reset the ICC.
  */
 
 #include <err.h>
diff --git a/usr/src/test/os-tests/tests/uccid/notxn-poll.c b/usr/src/test/os-tests/tests/uccid/notxn-poll.c
index e1fa7b1057..68f8f52619 100644
--- a/usr/src/test/os-tests/tests/uccid/notxn-poll.c
+++ b/usr/src/test/os-tests/tests/uccid/notxn-poll.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/pollin.c b/usr/src/test/os-tests/tests/uccid/pollin.c
index b5ccd0c453..dd81c245cc 100644
--- a/usr/src/test/os-tests/tests/uccid/pollin.c
+++ b/usr/src/test/os-tests/tests/uccid/pollin.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/pollout.c b/usr/src/test/os-tests/tests/uccid/pollout.c
index 38592bc41b..7044d287a8 100644
--- a/usr/src/test/os-tests/tests/uccid/pollout.c
+++ b/usr/src/test/os-tests/tests/uccid/pollout.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/status.c b/usr/src/test/os-tests/tests/uccid/status.c
index 8f9c4173b2..ae2a51226f 100644
--- a/usr/src/test/os-tests/tests/uccid/status.c
+++ b/usr/src/test/os-tests/tests/uccid/status.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/txn-pollerr.c b/usr/src/test/os-tests/tests/uccid/txn-pollerr.c
index c70e5e986e..b19598f711 100644
--- a/usr/src/test/os-tests/tests/uccid/txn-pollerr.c
+++ b/usr/src/test/os-tests/tests/uccid/txn-pollerr.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/test/os-tests/tests/uccid/yk.c b/usr/src/test/os-tests/tests/uccid/yk.c
index 6fc449c742..45bdfd059e 100644
--- a/usr/src/test/os-tests/tests/uccid/yk.c
+++ b/usr/src/test/os-tests/tests/uccid/yk.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
diff --git a/usr/src/uts/common/io/usb/clients/ccid/ccid.c b/usr/src/uts/common/io/usb/clients/ccid/ccid.c
index 0108a81d6e..20db9d4865 100644
--- a/usr/src/uts/common/io/usb/clients/ccid/ccid.c
+++ b/usr/src/uts/common/io/usb/clients/ccid/ccid.c
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc. 
+ * Copyright 2019, Joyent, Inc.
  */
 
 /*
@@ -74,7 +74,7 @@
  * generated as a series of one or more messages on a Bulk-IN pipe. To correlate
  * these commands a sequence number is used. This sequence number is one byte
  * and can be in the range [ CCID_SEQ_MIN, CCID_SEQ_MAX ]. To keep track of the
- * allocatd IDs we leverage an ID space.
+ * allocated IDs we leverage an ID space.
  *
  * A CCID reader contains a number of slots. Each slot can be addressed
  * separately as each slot represents a separate place that a card may be
@@ -144,13 +144,14 @@
  * negotiating this information. If the hardware does not support negotiation,
  * then it likely does not support a PPS and in which case we need to program
  * the hardware with the parameters indicated by the ATR through a
- * CCID_REQUEST_SET_PARAMS command and do not need to negotiation a PPS.
- * 
+ * CCID_REQUEST_SET_PARAMS command and do not need to negotiate a PPS.
+ *
  * Many ICC devices support negotiation. When an ICC supporting negotiation is
  * first turned on then it enters into a default mode and uses the default
  * values while in that mode. The PPS may be used to change the protocol as well
  * as several parameters. Once the PPS has been agreed upon, this driver just
- * send a CCID_REQUEST_SET_PARAMS command to inform the reader what is going on.
+ * sends a CCID_REQUEST_SET_PARAMS command to inform the reader what is going
+ * on.
  *
  * If the CCID reader supports neither of the hardware related mechanisms for a
  * PPS exchange, then we must do both of these. If hardware supports automatic
@@ -158,7 +159,7 @@
  * CCID_REQUEST_SET_PARAMS command.
  *
  * The ATR offers us what the hardware's maximum value of Di and Fi are. If the
- * reader supports higher speeds, then we will 
+ * reader supports higher speeds, then we will XXX
  *
  * XXX At the moment we're not adjusting any of the Di or Fi values beyond their
  * default.
@@ -168,7 +169,7 @@
  *
  *  - If the reader supports APDU transfers, then we are done.
  *     XXX Depending on level of automation we may need to still do things.
- *  - If the reader supports 
+ *  - If the reader supports XXX
  *
  * User I/O Basics
  * ---------------
@@ -261,8 +262,8 @@
  *   While the user I/O thread is a somewhat straightforward, the kernel
  *   protocol level is a bit more complicated. The core problem is that when a
  *   user issues a logical I/O through an APDU, that may result in a series of
- *   one or protocol level, physical commands. The core crux of the issue with
- *   cleaning up this state is twofold:
+ *   one or more protocol level physical commands. The core crux of the issue
+ *   with cleaning up this state is twofold:
  *
  *     1. We don't want to block a user thread while I/O is outstanding
  *     2. We need to take one of several steps to clean up the aforementioned
@@ -370,7 +371,7 @@
  *       o XXX This one is tricky, because we might want to reset our T=1 state
  *         on insertion of a new ICC before this is read. Ugh. Maybe we should
  *         pull out the mblk_t chain when the I/O is completed so we can
- *         disassociate this state. 
+ *         disassociate this state.
  *       o Still need to signal POLLHUP, but POLLIN should already have been
  *         done
  *   + Unread, but completed I/O when the reader is removed
@@ -463,7 +464,7 @@
  * class descriptor's dwMaxCCIDMessageLength member. We got to 64 bytes based on
  * the required size of a bulk transfer packet size. Especially as many CCID
  * devices are these class of speeds. The specification does require that the
- * minimu size of the dwMaxCCIDMessageLength member is at least the size of its
+ * minimum size of the dwMaxCCIDMessageLength member is at least the size of its
  * bulk endpoint packet size.
  */
 #define	CCID_MIN_MESSAGE_LENGTH	64
@@ -498,7 +499,7 @@ typedef enum ccid_minor_flags {
 } ccid_minor_flags_t;
 
 typedef struct ccid_minor {
-	ccid_minor_idx_t	cm_idx;		/* WO */
+	ccid_minor_idx_t	cm_idx;		/* WO */ /* XXX: Whats 'WO'? */
 	cred_t			*cm_opener;	/* WO */
 	struct ccid_slot	*cm_slot;	/* WO */
 	list_node_t		cm_minor_list;
@@ -524,7 +525,8 @@ typedef enum ccid_slot_flags {
     CCID_SLOT_F_INTR_ADD)
 #define	CCID_SLOT_F_WORK_MASK	(CCID_SLOT_F_INTR_MASK | \
     CCID_SLOT_F_NEED_TXN_RESET)
-#define	CCID_SLOT_F_NOEXCL_MASK	(CCID_SLOT_F_NEED_TXN_RESET | CCID_SLOT_F_NEED_IO_TEARDOWN)
+#define	CCID_SLOT_F_NOEXCL_MASK	(CCID_SLOT_F_NEED_TXN_RESET | \
+    CCID_SLOT_F_NEED_IO_TEARDOWN)
 
 typedef void (*icc_init_func_t)(struct ccid *, struct ccid_slot *);
 typedef int (*icc_transmit_func_t)(struct ccid *, struct ccid_slot *);
@@ -576,10 +578,10 @@ typedef enum ccid_io_flags {
 	/*
 	 * This flag is used to indicate that a given I/O has been abandoned by
 	 * the user and that we need to clean things up before the ICC is usable
-	 * again. 
+	 * again.
 	 *
 	 * XXX Should this really be set? I'm now starting to wonder if this
-	 * would make more sent to have like we have the resetting flag.
+	 * would make more sense to have like we have the resetting flag.
 	 * Especially if for T=1 we issue an abort.
 	 */
 	CCID_IO_F_ABANDONED	= 1 << 3
@@ -587,7 +589,7 @@ typedef enum ccid_io_flags {
 
 /*
  * If any of the flags in the POLLOUT group are set, then the device is not
- * writeable. The same distinction isn't true for POLLIN. We are only readable 
+ * writeable. The same distinction isn't true for POLLIN. We are only readable
  * if CCID_IO_F_DONE is set. However, you are allowed to call read as soon as
  * CCID_IO_F_IN_PROGRESS is set.
  */
@@ -869,6 +871,17 @@ ccid_minor_find_user(minor_t m)
 	return (idx);
 }
 
+static void
+ccid_clear_io(ccid_io_t *io)
+{
+	freemsg(io->ci_data);
+	io->ci_data = NULL;
+	io->ci_errno = 0;
+	io->ci_flags &= ~CCID_IO_F_DONE;
+	io->ci_ilen = 0;
+	bzero(io->ci_ibuf, sizeof (io->ci_ibuf));
+}
+
 /*
  * Check if the conditions are met to signal the next exclusive holder. For this
  * to be true, there should be no one holding it. In addition, there must be
@@ -948,14 +961,8 @@ ccid_slot_excl_rele(ccid_slot_t *slot)
 	 * one blocked in read, then we need to clean that up. The ICC teardown
 	 * function is only designed to take care of in-flight I/Os.
 	 */
-	if ((slot->cs_io.ci_flags & CCID_IO_F_DONE) != 0) {
-		freemsg(slot->cs_io.ci_data);
-		slot->cs_io.ci_data = NULL;
-		slot->cs_io.ci_errno = 0;
-		slot->cs_io.ci_flags &= ~CCID_IO_F_DONE;
-		slot->cs_io.ci_ilen = 0;
-		bzero(slot->cs_io.ci_ibuf, sizeof (slot->cs_io.ci_ibuf));
-	}
+	if ((slot->cs_io.ci_flags & CCID_IO_F_DONE) != 0)
+		ccid_clear_io(&slot->cs_io);
 
 	/*
 	 * Regardless of when we're polling, we need to go through and error
@@ -971,6 +978,7 @@ ccid_slot_excl_rele(ccid_slot_t *slot)
 	if (cmp->cm_flags & CCID_MINOR_F_TXN_RESET) {
 		slot->cs_flags |= CCID_SLOT_F_NEED_TXN_RESET;
 		ccid_worker_request(ccid);
+		cmp->cm_flags &= ~CCID_MINOR_F_TXN_RESET;
 	} else {
 		ccid_slot_excl_maybe_signal(slot);
 	}
@@ -1012,11 +1020,11 @@ ccid_slot_excl_req(ccid_slot_t *slot, ccid_minor_t *cmp, boolean_t nosleep)
 	list_insert_tail(&slot->cs_excl_waiters, cmp);
 	while (slot->cs_excl_minor != NULL ||
 	    (slot->cs_flags & CCID_SLOT_F_NOEXCL_MASK) != 0) {
-		if (cv_wait_sig(&cmp->cm_excl_cv, &slot->cs_ccid->ccid_mutex) ==
-		    0) {
+		if (cv_wait_sig(&cmp->cm_excl_cv, &slot->cs_ccid->ccid_mutex)
+		    == 0) {
 			/*
 			 * Remove ourselves from the list, but only signal the
-			 * next thread if 
+			 * next thread if XXX
 			 */
 			list_remove(&slot->cs_excl_waiters, cmp);
 			cmp->cm_flags &= ~CCID_MINOR_F_WAITING;
@@ -1034,11 +1042,12 @@ ccid_slot_excl_req(ccid_slot_t *slot, ccid_minor_t *cmp, boolean_t nosleep)
 			return (ENODEV);
 		}
 
-		/* XXX Waiting on a lock, need to reassert usability of device /
-		 * going awayness */
+		/*
+		 * XXX Waiting on a lock, need to reassert usability of device /
+		 * going awayness
+		 */
 	}
 
-	VERIFY3P(cmp, ==, list_head(&slot->cs_excl_waiters));
 	VERIFY0(slot->cs_flags & CCID_SLOT_F_NOEXCL_MASK);
 	list_remove(&slot->cs_excl_waiters, cmp);
 
@@ -1064,6 +1073,8 @@ ccid_slot_pollin_signal(ccid_slot_t *slot)
 	ccid_minor_t *cmp;
 
 	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+
+	/* XXX */
 }
 
 /*
@@ -1071,7 +1082,7 @@ ccid_slot_pollin_signal(ccid_slot_t *slot)
  * able to signal a POLLOUT (meaning that we can write) the following must be
  * true:
  *
- *   o There is a minor which has an exclusive hold on the device 
+ *   o There is a minor which has an exclusive hold on the device
  *   o There is no outstanding I/O activity going on, meaning that there is no
  *     operation in progress and any write data has been consumed.
  *   o There is an ICC present
@@ -1085,6 +1096,8 @@ ccid_slot_pollout_signal(ccid_slot_t *slot)
 	ccid_minor_t *cmp;
 
 	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
+
+	/* XXX */
 }
 
 static void
@@ -1139,7 +1152,7 @@ ccid_command_resp_param2(ccid_command_t *cc)
 
 /*
  * Complete a single command. The way that a command completes depends on the
- * kind of command that occurs. If this is commad is flagged as a user command,
+ * kind of command that occurs. If this command is flagged as a user command,
  * that implies that it must be handled in a different way from administrative
  * commands. User commands are placed into the minor to consume via a read(9E).
  * Non-user commands are placed into a completion queue and must be picked up
@@ -1204,8 +1217,9 @@ ccid_command_transport_error(ccid_command_t *cc, int usb_status, usb_cr_t cr)
 }
 
 static void
-ccid_command_status_decode(ccid_command_t *cc, ccid_reply_command_status_t *comp,
-    ccid_reply_icc_status_t *iccp, ccid_command_err_t *errp)
+ccid_command_status_decode(ccid_command_t *cc,
+    ccid_reply_command_status_t *comp, ccid_reply_icc_status_t *iccp,
+    ccid_command_err_t *errp)
 {
 	ccid_header_t cch;
 	size_t mblen;
@@ -1220,7 +1234,7 @@ ccid_command_status_decode(ccid_command_t *cc, ccid_reply_command_status_t *comp
 		*comp = CCID_REPLY_STATUS(cch.ch_param0);
 	}
 
-	if (iccp != NULL) { 
+	if (iccp != NULL) {
 		*iccp = CCID_REPLY_ICC(cch.ch_param0);
 	}
 
@@ -1303,7 +1317,7 @@ ccid_reply_bulk_cb(usb_pipe_handle_t ph, usb_bulk_req_t *ubrp)
 	/*
 	 * If the sequence number doesn't match the head of the list then we
 	 * should be very suspect of the hardware at this point. At a minimum we
-	 * should fail this command, 
+	 * should fail this command, XXX
 	 */
 	if (cch.ch_seq != cc->cc_seq) {
 		/*
@@ -1317,7 +1331,7 @@ ccid_reply_bulk_cb(usb_pipe_handle_t ph, usb_bulk_req_t *ubrp)
 
 	/*
 	 * Check that we have all the bytes that we were told we'd have. If we
-	 * dno't, simulate this as an aborted command. XXX is this the right
+	 * don't, simulate this as an aborted command. XXX is this the right
 	 * thing to do?
 	 */
 	if (LE_32(cch.ch_length) + sizeof (ccid_header_t) > mlen) {
@@ -1347,7 +1361,7 @@ ccid_reply_bulk_cb(usb_pipe_handle_t ph, usb_bulk_req_t *ubrp)
 
 		ret = ccid_bulkin_schedule(ccid);
 		if (ret != USB_SUCCESS) {
-			ccid_command_transport_error(cc, ret, USB_CR_OK); 
+			ccid_command_transport_error(cc, ret, USB_CR_OK);
 		}
 		mutex_exit(&ccid->ccid_mutex);
 		usb_free_bulk_req(ubrp);
@@ -1411,8 +1425,8 @@ ccid_bulkin_cache_refresh(ccid_t *ccid)
 	while (ccid->ccid_bulkin_alloced < CCID_BULK_NALLOCED) {
 		usb_bulk_req_t *ubrp;
 
-		ubrp = usb_alloc_bulk_req(ccid->ccid_dip, ccid->ccid_bufsize, 0);
-		if (ubrp == NULL)
+		if ((ubrp = usb_alloc_bulk_req(ccid->ccid_dip,
+		    ccid->ccid_bufsize, 0)) == NULL)
 			return;
 
 		ubrp->bulk_len = ccid->ccid_bufsize;
@@ -1469,7 +1483,8 @@ ccid_bulkin_schedule(ccid_t *ccid)
 
 		if ((ret = usb_pipe_bulk_xfer(ccid->ccid_bulkin_pipe, ubrp,
 		    0)) != USB_SUCCESS) {
-			ccid_error(ccid, "failed to schedule Bulk-In response: %d", ret);
+			ccid_error(ccid,
+			    "failed to schedule Bulk-In response: %d", ret);
 			usb_free_bulk_req(ubrp);
 			return (ret);
 		}
@@ -1512,7 +1527,7 @@ ccid_command_dispatch(ccid_t *ccid)
 		cc->cc_dispatch_time = gethrtime();
 
 		/*
-		 * Drop the global lock while we schedule the USB I/O. 
+		 * Drop the global lock while we schedule the USB I/O.
 		 */
 		mutex_exit(&ccid->ccid_mutex);
 
@@ -1525,7 +1540,8 @@ ccid_command_dispatch(ccid_t *ccid)
 			 * will be taken care of when the command itself is
 			 * freed.
 			 */
-			ccid_error(ccid, "Bulk pipe dispatch failed: %d\n", ret);
+			ccid_error(ccid, "Bulk pipe dispatch failed: %d\n",
+			    ret);
 			ccid_command_transport_error(cc, ret, USB_CR_OK);
 		}
 	}
@@ -1583,7 +1599,7 @@ ccid_dispatch_bulk_cb(usb_pipe_handle_t ph, usb_bulk_req_t *ubrp)
 	 */
 	ret = ccid_bulkin_schedule(ccid);
 	if (ret != USB_SUCCESS) {
-		ccid_command_transport_error(cc, ret, USB_CR_OK); 
+		ccid_command_transport_error(cc, ret, USB_CR_OK);
 	}
 	mutex_exit(&ccid->ccid_mutex);
 }
@@ -1704,7 +1720,8 @@ ccid_command_alloc(ccid_t *ccid, ccid_slot_t *slot, boolean_t block,
 
 	allocsz = datasz + sizeof (ccid_header_t);
 	if (datamp == NULL) {
-		cc->cc_ubrp = usb_alloc_bulk_req(ccid->ccid_dip, allocsz, usbflag);
+		cc->cc_ubrp = usb_alloc_bulk_req(ccid->ccid_dip, allocsz,
+		    usbflag);
 	} else {
 		cc->cc_ubrp = usb_alloc_bulk_req(ccid->ccid_dip, 0, usbflag);
 	}
@@ -1944,7 +1961,7 @@ ccid_command_get_parameters(ccid_t *ccid, ccid_slot_t *slot,
 	const void *cpbuf;
 
 	if ((ret = ccid_command_alloc(ccid, slot, B_TRUE, NULL, 0,
-	   CCID_REQUEST_GET_PARAMS, 0, 0, 0, &cc)) != 0) {
+	    CCID_REQUEST_GET_PARAMS, 0, 0, 0, &cc)) != 0) {
 		return (ret);
 	}
 
@@ -2006,7 +2023,8 @@ done:
 }
 
 static int
-ccid_command_set_parameters(ccid_t *ccid, ccid_slot_t *slot, atr_protocol_t protocol, void *params)
+ccid_command_set_parameters(ccid_t *ccid, ccid_slot_t *slot,
+    atr_protocol_t protocol, void *params)
 {
 	int ret;
 	ccid_command_t *cc;
@@ -2030,7 +2048,7 @@ ccid_command_set_parameters(ccid_t *ccid, ccid_slot_t *slot, atr_protocol_t prot
 	}
 
 	if ((ret = ccid_command_alloc(ccid, slot, B_TRUE, NULL, len,
-	   CCID_REQUEST_SET_PARAMS, prot, 0, 0, &cc)) != 0) {
+	    CCID_REQUEST_SET_PARAMS, prot, 0, 0, &cc)) != 0) {
 		return (ret);
 	}
 	ccid_command_bcopy(cc, params, len);
@@ -2085,7 +2103,7 @@ ccid_command_transfer(ccid_t *ccid, ccid_slot_t *slot, const void *buf,
 
 	*outp = NULL;
 	if ((ret = ccid_command_alloc(ccid, slot, B_TRUE, NULL, len,
-	   CCID_REQUEST_TRANSFER_BLOCK, 0, 0, 0, &cc)) != 0) {
+	    CCID_REQUEST_TRANSFER_BLOCK, 0, 0, 0, &cc)) != 0) {
 		return (ret);
 	}
 
@@ -2453,14 +2471,19 @@ ccid_slot_setup_functions(ccid_t *ccid, ccid_slot_t *slot)
 {
 	uint_t bits = CCID_CLASS_F_TPDU_XCHG | CCID_CLASS_F_SHORT_APDU_XCHG |
 	    CCID_CLASS_F_EXT_APDU_XCHG;
+
+	slot->cs_icc.icc_init = NULL;
+	slot->cs_icc.icc_tx = NULL;
+	slot->cs_icc.icc_complete = NULL;
+	slot->cs_icc.icc_teardown = NULL;
+	slot->cs_icc.icc_fini = NULL;
+
 	switch (ccid->ccid_class.ccd_dwFeatures & bits) {
 	case CCID_CLASS_F_SHORT_APDU_XCHG:
 	case CCID_CLASS_F_EXT_APDU_XCHG:
-		slot->cs_icc.icc_init = NULL;
 		slot->cs_icc.icc_tx = ccid_write_apdu;
 		slot->cs_icc.icc_complete = ccid_complete_apdu;
 		slot->cs_icc.icc_teardown = ccid_teardown_apdu;
-		slot->cs_icc.icc_fini = NULL;
 		break;
 	case CCID_CLASS_F_TPDU_XCHG:
 		switch (slot->cs_icc.icc_cur_protocol) {
@@ -2476,12 +2499,9 @@ ccid_slot_setup_functions(ccid_t *ccid, ccid_slot_t *slot)
 			 */
 			if (atr_t1_checksum(slot->cs_icc.icc_atr_data) ==
 			    ATR_T1_CHECKSUM_CRC) {
-				ccid_error(ccid, "!ICC uses unsupported T=1 CRC "
-				    "checksum. Please report this so support "
+				ccid_error(ccid, "!ICC uses unsupported T=1 CRC"
+				    " checksum. Please report this so support "
 				    "can be added");
-				slot->cs_icc.icc_tx = NULL;
-				slot->cs_icc.icc_complete = NULL;
-				slot->cs_icc.icc_teardown = NULL;
 				break;
 			}
 
@@ -2493,16 +2513,11 @@ ccid_slot_setup_functions(ccid_t *ccid, ccid_slot_t *slot)
 			break;
 		case ATR_P_T0:
 		default:
-			slot->cs_icc.icc_tx = NULL;
-			slot->cs_icc.icc_complete = NULL;
-			slot->cs_icc.icc_teardown = NULL;
 			break;
 		}
 		break;
 	default:
-		slot->cs_icc.icc_tx = NULL;
-		slot->cs_icc.icc_complete = NULL;
-		slot->cs_icc.icc_teardown = NULL;
+		break;
 	}
 
 	/*
@@ -2524,7 +2539,7 @@ ccid_slot_setup_functions(ccid_t *ccid, ccid_slot_t *slot)
  * - Negotiate and send the PPS (CCID_F_NEEDS_PPS)
  * - Set the CCID reader's parameters (CCID_F_NEEDS_PARAMS)
  * - Set the CCID reader's clock and data rate (CCID_F_NEEDS_DATAFREQ)
- * - Snapshot the current paramters being used for userland
+ * - Snapshot the current parameters being used for userland
  * - Set the IFSD for T=1 (CCID_F_NEEDS_IFSD)
  */
 static boolean_t
@@ -2631,8 +2646,8 @@ ccid_slot_params_init(ccid_t *ccid, ccid_slot_t *slot, mblk_t *atr)
 			 * This case covers the times when CCID_F_NEEDS_DATAFREQ
 			 * is set and we'd need to gather those.
 			 */
-			ccid_error(ccid, "!ccid driver does not support "
-			    "manual data rate setting for ICC, cannot activate");
+			ccid_error(ccid, "!ccid driver does not support manual "
+			    "data rate setting for ICC, cannot activate");
 			return (B_FALSE);
 		default:
 			ccid_error(ccid, "!unsupported data rate choice: %u",
@@ -2681,7 +2696,12 @@ ccid_slot_params_init(ccid_t *ccid, ccid_slot_t *slot, mblk_t *atr)
 			} else {
 				fip = dip = NULL;
 			}
-			ccid_slot_send_pps(ccid, slot, data, fip, dip, prot);
+			if (!ccid_slot_send_pps(ccid, slot, data, fip, dip,
+			    prot)) {
+				ccid_error(ccid,
+				    "!failed to send PPS to device");
+				return (B_FALSE);
+			}
 		}
 
 		/*
@@ -2695,12 +2715,14 @@ ccid_slot_params_init(ccid_t *ccid, ccid_slot_t *slot, mblk_t *atr)
 				    fi, di)) {
 					ccid_error(ccid, "!failed to send T=0 "
 					    "paramters to device");
+					return (B_FALSE);
 				}
 			} else if (prot == ATR_P_T1) {
 				if (!ccid_slot_params_t1_init(ccid, slot, data,
 				    fi, di)) {
 					ccid_error(ccid, "!failed to send T=1 "
 					    "paramters to device");
+					return (B_FALSE);
 				}
 			}
 		}
@@ -2870,7 +2892,7 @@ ccid_slot_reset(ccid_t *ccid, ccid_slot_t *slot)
 	int ret;
 
 	VERIFY(MUTEX_HELD(&ccid->ccid_mutex));
-	VERIFY(ccid->ccid_flags & CCID_SLOT_F_NEED_TXN_RESET);
+	VERIFY(slot->cs_flags & CCID_SLOT_F_NEED_TXN_RESET);
 	VERIFY(ccid->ccid_flags & CCID_F_WORKER_RUNNING);
 
 	/*
@@ -2909,10 +2931,9 @@ ccid_slot_reset(ccid_t *ccid, ccid_slot_t *slot)
 		return (B_FALSE);
 	}
 
-	ccid->ccid_flags &= ~CCID_SLOT_F_ACTIVE;
+	slot->cs_flags &= ~CCID_SLOT_F_ACTIVE;
 
 	ccid_slot_teardown(ccid, slot, B_TRUE);
-	mutex_exit(&ccid->ccid_mutex);
 
 	/*
 	 * Mimic a slot insertion to power this back on. Don't worry about
@@ -2920,7 +2941,6 @@ ccid_slot_reset(ccid_t *ccid, ccid_slot_t *slot)
 	 * done our duty once we've powered it off successfully.
 	 */
 	(void) ccid_slot_inserted(ccid, slot);
-	mutex_enter(&ccid->ccid_mutex);
 
 	return (B_TRUE);
 }
@@ -2986,7 +3006,7 @@ ccid_worker(void *arg)
 			 * an attempt to reset it. If this fails, trigger
 			 * another worker that needs to operate.
 			 */
-			if (flags & CCID_SLOT_F_PRESENT) {
+			if (slot->cs_flags & CCID_SLOT_F_PRESENT) {
 				if (!ccid_slot_reset(ccid, slot)) {
 					ccid_worker_request(ccid);
 					continue;
@@ -3036,7 +3056,7 @@ ccid_worker_request(ccid_t *ccid)
 		return;
 	}
 
-	run = (ccid->ccid_flags & CCID_F_WORKER_MASK) == 0; 
+	run = (ccid->ccid_flags & CCID_F_WORKER_MASK) == 0;
 	ccid->ccid_flags |= CCID_F_WORKER_REQUESTED;
 	if (run) {
 		mutex_exit(&ccid->ccid_mutex);
@@ -3064,7 +3084,7 @@ ccid_intr_restart_timeout(void *arg)
 /*
  * Search for the current class descriptor from the configuration cloud and
  * parse it for our use. We do this by first finding the current interface
- * descriptor and expecting it to be one of the next descriptors 
+ * descriptor and expecting it to be one of the next descriptors XXX
  */
 static boolean_t
 ccid_parse_class_desc(ccid_t *ccid)
@@ -3120,8 +3140,8 @@ ccid_supported(ccid_t *ccid)
 
 	if (CCID_VERSION_MAJOR(ver) != CCID_VERSION_ONE) {
 		ccid_error(ccid, "refusing to attach to CCID with unsupported "
-		   "version %x.%2x", CCID_VERSION_MAJOR(ver),
-		   CCID_VERSION_MINOR(ver));
+		    "version %x.%2x", CCID_VERSION_MAJOR(ver),
+		    CCID_VERSION_MINOR(ver));
 		return (B_FALSE);
 	}
 
@@ -3149,7 +3169,7 @@ ccid_supported(ccid_t *ccid)
 	/*
 	 * Try and determine the appropriate buffer size. This can be a little
 	 * tricky. The class descriptor tells us the maximum size that the
-	 * reader excepts. While it may be tempting to try and use a larger
+	 * reader accepts. While it may be tempting to try and use a larger
 	 * value such as the maximum size, the readers really don't like
 	 * receiving bulk transfers that large. However, there are also reports
 	 * of readers that will overwrite to a fixed minimum size. XXX which
@@ -3158,9 +3178,9 @@ ccid_supported(ccid_t *ccid)
 	 */
 	ccid->ccid_bufsize = ccid->ccid_class.ccd_dwMaxCCIDMessageLength;
 	if (ccid->ccid_bufsize < CCID_MIN_MESSAGE_LENGTH) {
-		ccid_error(ccid, "CCID reader maximum CCID message length (%u) is "
-		    "less than minimum packet length (%u)", ccid->ccid_bufsize,
-		    CCID_MIN_MESSAGE_LENGTH);
+		ccid_error(ccid, "CCID reader maximum CCID message length (%u) "
+		    "is less than minimum packet length (%u)",
+		    ccid->ccid_bufsize, CCID_MIN_MESSAGE_LENGTH);
 		return (B_FALSE);
 	}
 
@@ -3178,8 +3198,8 @@ ccid_supported(ccid_t *ccid)
 	 */
 	if (ccid->ccid_class.ccd_bNumDataRatesSupported != 0 &&
 	    (feat & CCID_CLASS_F_AUTO_BAUD) == 0) {
-		ccid_error(ccid, "!CCID reader only supports fixed clock rates, "
-		    "data will be limited to default values");
+		ccid_error(ccid, "!CCID reader only supports fixed clock rates,"
+		    " data will be limited to default values");
 	}
 
 	/*
@@ -3226,7 +3246,7 @@ ccid_supported(ccid_t *ccid)
 		 */
 		if (ccid->ccid_class.ccd_dwMaxIFSD < T1_IFSD_DEFAULT) {
 			ccid_error(ccid, "CCID reader max IFSD (%d) is less "
-			    "T=1 default", ccid->ccid_class.ccd_dwMaxIFSD,
+			    "than T=1 default", ccid->ccid_class.ccd_dwMaxIFSD,
 			    T1_IFSD_DEFAULT);
 			return (B_FALSE);
 		}
@@ -3298,19 +3318,21 @@ ccid_open_pipes(ccid_t *ccid)
 
 	/*
 	 * First determine the maximum number of asynchronous requests. This
-	 * determines the maximum 
+	 * determines the maximum XXX: of what?
 	 */
 	bzero(&policy, sizeof (policy));
 	policy.pp_max_async_reqs = CCID_NUM_ASYNC_REQS;
 
 	if ((ret = usb_pipe_xopen(ccid->ccid_dip, &ccid->ccid_bulkin_xdesc,
-	    &policy, USB_FLAGS_SLEEP, &ccid->ccid_bulkin_pipe)) != USB_SUCCESS) {
+	    &policy, USB_FLAGS_SLEEP, &ccid->ccid_bulkin_pipe)) !=
+	    USB_SUCCESS) {
 		ccid_error(ccid, "failed to open Bulk-IN pipe: %d\n", ret);
 		return (B_FALSE);
 	}
 
 	if ((ret = usb_pipe_xopen(ccid->ccid_dip, &ccid->ccid_bulkout_xdesc,
-	    &policy, USB_FLAGS_SLEEP, &ccid->ccid_bulkout_pipe)) != USB_SUCCESS) {
+	    &policy, USB_FLAGS_SLEEP, &ccid->ccid_bulkout_pipe)) !=
+	    USB_SUCCESS) {
 		ccid_error(ccid, "failed to open Bulk-OUT pipe: %d\n", ret);
 		usb_pipe_close(ccid->ccid_dip, ccid->ccid_bulkin_pipe,
 		    USB_FLAGS_SLEEP, NULL, NULL);
@@ -3378,24 +3400,25 @@ ccid_slots_init(ccid_t *ccid)
 	ccid->ccid_slots = kmem_zalloc(sizeof (ccid_slot_t) * ccid->ccid_nslots,
 	    KM_SLEEP);
 	for (i = 0; i < ccid->ccid_nslots; i++) {
+		ccid_slot_t *slot = &ccid->ccid_slots[i];
+
 		/*
 		 * We initialize every possible slot as having changed to make
 		 * sure that we have a chance to discover it. See the slot
 		 * detection section in the big theory statement for more info.
 		 */
-		ccid->ccid_slots[i].cs_flags |= CCID_SLOT_F_CHANGED;
-		ccid->ccid_slots[i].cs_slotno = i;
-		ccid->ccid_slots[i].cs_ccid = ccid;
-		ccid->ccid_slots[i].cs_icc.icc_atr_data = atr_data_alloc();
-		ccid->ccid_slots[i].cs_idx.cmi_minor = CCID_MINOR_INVALID;
-		ccid->ccid_slots[i].cs_idx.cmi_isslot = B_TRUE;
-		ccid->ccid_slots[i].cs_idx.cmi_data.cmi_slot =
-		    &ccid->ccid_slots[i];
-		cv_init(&ccid->ccid_slots[i].cs_io.ci_cv, NULL, CV_DRIVER, NULL);
-		list_create(&ccid->ccid_slots[i].cs_minors, sizeof (ccid_minor_t),
-		   offsetof(ccid_minor_t, cm_minor_list)); 
-		list_create(&ccid->ccid_slots[i].cs_excl_waiters, sizeof (ccid_minor_t),
-		   offsetof(ccid_minor_t, cm_excl_list)); 
+		slot->cs_flags |= CCID_SLOT_F_CHANGED;
+		slot->cs_slotno = i;
+		slot->cs_ccid = ccid;
+		slot->cs_icc.icc_atr_data = atr_data_alloc();
+		slot->cs_idx.cmi_minor = CCID_MINOR_INVALID;
+		slot->cs_idx.cmi_isslot = B_TRUE;
+		slot->cs_idx.cmi_data.cmi_slot = slot;
+		cv_init(&slot->cs_io.ci_cv, NULL, CV_DRIVER, NULL);
+		list_create(&slot->cs_minors, sizeof (ccid_minor_t),
+		    offsetof(ccid_minor_t, cm_minor_list));
+		list_create(&slot->cs_excl_waiters, sizeof (ccid_minor_t),
+		    offsetof(ccid_minor_t, cm_excl_list));
 	}
 
 	return (B_TRUE);
@@ -3422,7 +3445,8 @@ ccid_minors_init(ccid_t *ccid)
 	for (i = 0; i < ccid->ccid_nslots; i++) {
 		char buf[32];
 
-		(void) ccid_minor_idx_alloc(&ccid->ccid_slots[i].cs_idx, B_TRUE);
+		(void) ccid_minor_idx_alloc(&ccid->ccid_slots[i].cs_idx,
+		    B_TRUE);
 
 		(void) snprintf(buf, sizeof (buf), "slot%d", i);
 		if (ddi_create_minor_node(ccid->ccid_dip, buf, S_IFCHR,
@@ -3534,9 +3558,9 @@ ccid_disconnect_cb(dev_info_t *dip)
 	ccid->ccid_flags |= CCID_F_DISCONNECTED;
 
 	/*
-	 * First, go through any threads that are blocked on a minor for
-	 * exclusive access. They should be woken up and they'll fail due to the
-	 * fact that we've set the disconnected flag above.
+	 * Now, go through any threads that are blocked on a minor for exclusive
+	 * access. They should be woken up and they'll fail due to the fact that
+	 * we've set the disconnected flag above.
 	 */
 	for (i = 0; i < ccid->ccid_nslots; i++) {
 		ccid_minor_t *cmp;
@@ -3549,7 +3573,7 @@ ccid_disconnect_cb(dev_info_t *dip)
 	}
 
 	/*
-	 * Now, we need to basically wake up anyone blocked in read and make
+	 * Finally, we need to basically wake up anyone blocked in read and make
 	 * sure that they don't wait there forever and make sure that anyone
 	 * polling gets a POLLHUP. We can't really distinguish between this and
 	 * an ICC being removed. It will be discovered when someone tries to do
@@ -3824,7 +3848,7 @@ ccid_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 
 cleanup:
 	ccid_cleanup(dip);
-	return (DDI_SUCCESS);
+	return (DDI_FAILURE);
 }
 
 static int
@@ -3908,7 +3932,7 @@ ccid_open(dev_t *devp, int flag, int otyp, cred_t *credp)
 	if (drv_priv(credp) != 0)
 		return (EPERM);
 
-	if (otyp & OTYP_BLK || !(otyp & OTYP_CHR))
+	if (otyp != OTYP_CHR)
 		return (ENOTSUP);
 
 	/* XXX We should maybe reduce this for just getting the status */
@@ -4094,13 +4118,14 @@ ccid_complete_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot, ccid_command_t *cc)
 		/*
 		 * XXX Take out the system until we fix this.
 		 */
-		cmn_err(CE_PANIC, "implement cc->cc_state > CCID_COMMAND_COMPLETED case");
+		cmn_err(CE_PANIC,
+		    "implement cc->cc_state > CCID_COMMAND_COMPLETED case");
 	}
 
 	/*
 	 * Check the CCID command level case. If we were told the slot is going
 	 * away, mark that and notify the user that the command is done.
-	 * 
+	 *
 	 * XXX In terms of failure we should be looking at one of several
 	 * different things here. We should see if there was a bit error, etc.
 	 * and act accordingly per the spec.
@@ -4117,7 +4142,8 @@ ccid_complete_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot, ccid_command_t *cc)
 		return;
 	} else if (crs != CCID_REPLY_STATUS_COMPLETE) {
 		/* XXX */
-		cmn_err(CE_PANIC, "implement crs != CCID_REPLY_STATUS_COMPLETE case");
+		cmn_err(CE_PANIC,
+		    "implement crs != CCID_REPLY_STATUS_COMPLETE case");
 	}
 
 	/*
@@ -4135,7 +4161,8 @@ ccid_complete_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot, ccid_command_t *cc)
 	cc = NULL;
 
 	if ((t1err = t1_reply(t1, mp)) != T1_VALIDATE_OK) {
-		ccid_error(ccid, "!Received t1 error (%u): %s", t1err, t1_errmsg(t1));
+		ccid_error(ccid, "!Received t1 error (%u): %s", t1err,
+		    t1_errmsg(t1));
 	}
 
 	switch (t1_step(t1)) {
@@ -4152,7 +4179,8 @@ ccid_complete_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot, ccid_command_t *cc)
 		 * will be saved for the user.
 		 */
 		slot->cs_io.ci_errno = 0;
-		slot->cs_io.ci_data = t1_state_cmd_reply_take(&slot->cs_io.ci_t1);
+		slot->cs_io.ci_data =
+		    t1_state_cmd_reply_take(&slot->cs_io.ci_t1);
 		t1_state_cmd_fini(&slot->cs_io.ci_t1);
 		VERIFY3P(slot->cs_io.ci_data, !=, NULL);
 		ccid_user_io_done(ccid, slot);
@@ -4166,14 +4194,15 @@ ccid_complete_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot, ccid_command_t *cc)
 	t1_data(t1, &buf, &len);
 	/*
 	 * XXX Right now we're purposefully not dropping the lock across the
-	 * command allocation. I'm not sure if that's good or not. THe problem
+	 * command allocation. I'm not sure if that's good or not. The problem
 	 * is that if we drop it, we need to make sure that the ICC state is
 	 * still good. If not, then we would need to throw this out, but it
 	 * means that the system can advance in the face of memory pressure,
 	 * which is good.
 	 *
 	 * XXX We need to actually ask the T=1 state machine for the WTX for
-	 * this block. We also may need to adjust the timeout on the USB command.
+	 * this block. We also may need to adjust the timeout on the USB
+	 * command.
 	 */
 	if ((ret = ccid_command_alloc(ccid, slot, B_FALSE, NULL, len,
 	    CCID_REQUEST_TRANSFER_BLOCK, 0, 0, 0,
@@ -4196,7 +4225,8 @@ ccid_complete_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot, ccid_command_t *cc)
 
 	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
 		mutex_enter(&ccid->ccid_mutex);
-		/* XXX Do we need to clean up the T=1 state here potentially? Or
+		/*
+		 * XXX Do we need to clean up the T=1 state here potentially? Or
 		 * can we leave it to be cleaned up by something else that next
 		 * uses it? Because we've dropped the lock, it's not clear what
 		 * we can or cannot do.
@@ -4272,7 +4302,8 @@ ccid_write_tpdu_t1(ccid_t *ccid, ccid_slot_t *slot)
 
 	if ((ret = ccid_command_queue(ccid, cc)) != 0) {
 		mutex_enter(&ccid->ccid_mutex);
-		/* XXX Do we need to clean up the T=1 state here potentially? Or
+		/*
+		 * XXX Do we need to clean up the T=1 state here potentially? Or
 		 * can we leave it to be cleaned up by something else that next
 		 * uses it? Becuse we've dropped the lock, it's not clear what
 		 * we can or cannot do.
@@ -4482,13 +4513,14 @@ ccid_read(dev_t dev, struct uio *uiop, cred_t *credp)
 	 * a lot of the surrounding logic and fits with the current consumer
 	 * model.
 	 */
-	if ((slot->cs_io.ci_flags & (CCID_IO_F_IN_PROGRESS | CCID_IO_F_DONE)) == 0) {
+	if ((slot->cs_io.ci_flags & (CCID_IO_F_IN_PROGRESS | CCID_IO_F_DONE))
+	    == 0) {
 		mutex_exit(&ccid->ccid_mutex);
 		return (ENODATA);
 	}
 
 	/*
-	 * If another thread is already blocked in read, then don't allow them
+	 * If another thread is already blocked in read, then don't allow us
 	 * in. We only want to allow one thread to attempt to consume a read,
 	 * just as we only allow one thread to initiate a write.
 	 */
@@ -4554,7 +4586,8 @@ ccid_read(dev_t dev, struct uio *uiop, cred_t *credp)
 		if (mlen > uiop->uio_resid) {
 			ret = EOVERFLOW;
 		} else {
-			if ((ret = ccid_read_copyout(uiop, slot->cs_io.ci_data)) == 0) {
+			if ((ret = ccid_read_copyout(uiop, slot->cs_io.ci_data))
+			    == 0) {
 				done = B_TRUE;
 			}
 		}
@@ -4564,16 +4597,7 @@ ccid_read(dev_t dev, struct uio *uiop, cred_t *credp)
 	}
 
 	if (done) {
-		/*
-		 * XXX Commonize this with the I/O cleanup in
-		 * ccid_slot_excl_rele().
-		 */
-		freemsg(slot->cs_io.ci_data);
-		slot->cs_io.ci_data = NULL;
-		slot->cs_io.ci_errno = 0;
-		slot->cs_io.ci_flags &= ~CCID_IO_F_DONE;
-		slot->cs_io.ci_ilen = 0;
-		bzero(slot->cs_io.ci_ibuf, sizeof (slot->cs_io.ci_ibuf));
+		ccid_clear_io(&slot->cs_io);
 		/* XXX Signal next write may be able to happen at this point */
 	}
 
@@ -4745,8 +4769,8 @@ ccid_ioctl_status(ccid_slot_t *slot, intptr_t arg, int mode)
 	bcopy(&ccid->ccid_class, &ucs.ucs_class, sizeof (ucs.ucs_class));
 
 	if (ccid->ccid_dev_data->dev_product != NULL) {
-		(void) strlcpy(ucs.ucs_product, ccid->ccid_dev_data->dev_product,
-		    sizeof (ucs.ucs_product));
+		(void) strlcpy(ucs.ucs_product,
+		    ccid->ccid_dev_data->dev_product, sizeof (ucs.ucs_product));
 		ucs.ucs_status |= UCCID_STATUS_F_PRODUCT_VALID;
 	} else {
 		ucs.ucs_product[0] = '\0';
@@ -4774,7 +4798,8 @@ ccid_ioctl_status(ccid_slot_t *slot, intptr_t arg, int mode)
 }
 
 static int
-ccid_ioctl_txn_begin(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg, int mode)
+ccid_ioctl_txn_begin(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg,
+    int mode)
 {
 	int ret;
 	uccid_cmd_txn_begin_t uct;
@@ -4822,7 +4847,7 @@ ccid_ioctl_txn_end(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg, int mode)
 	}
 
 	/*
-	 * Require at least one of these flags to be set.
+	 * Require exactly one of these flags to be set.
 	 */
 	if ((((uct.uct_flags & UCCID_TXN_END_RESET) != 0) ^
 	    ((uct.uct_flags & UCCID_TXN_END_RELEASE) != 0)) == 0) {
@@ -4835,10 +4860,9 @@ ccid_ioctl_txn_end(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg, int mode)
 		return (ENODEV);
 	}
 
-	/* XXX ENXIO may not be a good idea here */
 	if (slot->cs_excl_minor != cmp) {
 		mutex_exit(&slot->cs_ccid->ccid_mutex);
-		return (ENXIO);
+		return (EINVAL);
 	}
 	VERIFY3S(cmp->cm_flags & CCID_MINOR_F_HAS_EXCL, !=, 0);
 
@@ -4852,7 +4876,8 @@ ccid_ioctl_txn_end(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg, int mode)
 }
 
 static int
-ccid_ioctl_fionread(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg, int mode)
+ccid_ioctl_fionread(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg,
+    int mode)
 {
 	int data;
 
@@ -4886,7 +4911,8 @@ ccid_ioctl_fionread(ccid_slot_t *slot, ccid_minor_t *cmp, intptr_t arg, int mode
 		data = MIN(s, INT_MAX);
 	}
 
-	if (ddi_copyout(&data, (void *)arg, sizeof (data), mode & FKIOCTL) != 0) {
+	if (ddi_copyout(&data, (void *)arg, sizeof (data), mode & FKIOCTL)
+	    != 0) {
 		mutex_exit(&slot->cs_ccid->ccid_mutex);
 		return (EFAULT);
 	}
@@ -4927,17 +4953,17 @@ ccid_ioctl_icc_modify(ccid_slot_t *slot, intptr_t arg, int mode)
 	}
 
 	/*
-	 * XXX
+	 * XXX do something.
 	 */
 
 	mutex_exit(&ccid->ccid_mutex);
 
-	return (0);
+	return (ENOTSUP);
 }
 
 static int
-ccid_ioctl(dev_t dev, int cmd, intptr_t arg, int mode, cred_t *credp, int
-    *rvalp)
+ccid_ioctl(dev_t dev, int cmd, intptr_t arg, int mode, cred_t *credp,
+    int *rvalp)
 {
 	ccid_minor_idx_t *idx;
 	ccid_slot_t *slot;
@@ -5136,7 +5162,8 @@ _init(void)
 		return (ret);
 	}
 
-	if ((ccid_minors = id_space_create("ccid_minors", CCID_MINOR_MIN, INT_MAX)) == NULL) {
+	if ((ccid_minors = id_space_create("ccid_minors", CCID_MINOR_MIN,
+	    INT_MAX)) == NULL) {
 		ddi_soft_state_fini(&ccid_softstate);
 		return (ret);
 	}
diff --git a/usr/src/uts/common/sys/Makefile.syshdrs b/usr/src/uts/common/sys/Makefile.syshdrs
index c1a354e590..54a89a5e9a 100644
--- a/usr/src/uts/common/sys/Makefile.syshdrs
+++ b/usr/src/uts/common/sys/Makefile.syshdrs
@@ -23,6 +23,7 @@
 # Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 # Copyright 2014 Garrett D'Amore <garrett@damore.org>
 # Copyright 2016 Nexenta Systems, Inc.
+# Copyright 2019 Joyent, Inc.
 #
 
 # Common definitions for open and closed headers.
diff --git a/usr/src/uts/common/sys/usb/clients/ccid/ccid.h b/usr/src/uts/common/sys/usb/clients/ccid/ccid.h
index 20e841141f..12a015aef8 100644
--- a/usr/src/uts/common/sys/usb/clients/ccid/ccid.h
+++ b/usr/src/uts/common/sys/usb/clients/ccid/ccid.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef _SYS_USB_CCID_H
@@ -214,7 +214,7 @@ typedef enum ccid_request_code {
 	CCID_REQUEST_SECURE		= 0x69,	/* PC_to_RDR_Secure */
 	CCID_REQUEST_MECHANICAL		= 0x71,	/* PC_to_RDR_Mechanica */
 	CCID_REQEUST_ABORT		= 0x72,	/* PC_to_RDR_Abort */
-	CCID_REQUEST_DATA_CLOCK		= 0x73 	/* PC_to_RDR_SetDataRateAnd */
+	CCID_REQUEST_DATA_CLOCK		= 0x73	/* PC_to_RDR_SetDataRateAnd */
 						/* ClockFrequency */
 } ccid_request_code_t;
 
diff --git a/usr/src/uts/common/sys/usb/clients/ccid/uccid.h b/usr/src/uts/common/sys/usb/clients/ccid/uccid.h
index d44099c398..29aa65c69b 100644
--- a/usr/src/uts/common/sys/usb/clients/ccid/uccid.h
+++ b/usr/src/uts/common/sys/usb/clients/ccid/uccid.h
@@ -10,7 +10,7 @@
  */
 
 /*
- * Copyright (c) 2017, Joyent, Inc.
+ * Copyright 2019, Joyent, Inc.
  */
 
 #ifndef _SYS_USB_UCCID_H
@@ -44,13 +44,6 @@ extern "C" {
 #define	UCCID_VERSION_ONE	1
 #define	UCCID_CURRENT_VERSION	UCCID_VERSION_ONE
 
-#define	UCCID_TXN_DONT_BLOCK	0x01
-
-typedef struct uccid_cmd_txn_begin {
-	uint32_t	uct_version;
-	uint32_t	uct_flags;
-} uccid_cmd_txn_begin_t;
-
 /*
  * Attempt to obtain exclusive access. If the UCN_TXN_DONT_BLOCK flag is
  * specified, the ioctl will return immediately if exclusive access cannot be
@@ -58,14 +51,15 @@ typedef struct uccid_cmd_txn_begin {
  * a uccid_cmd_txn_begin_t.
  */
 #define	UCCID_CMD_TXN_BEGIN	(UCCID_IOCTL | 0x01)
+#define	UCCID_TXN_DONT_BLOCK	0x01
 
-typedef struct uccid_cmd_txn_end {
+typedef struct uccid_cmd_txn_begin {
 	uint32_t	uct_version;
 	uint32_t	uct_flags;
-} uccid_cmd_txn_end_t;
+} __packed uccid_cmd_txn_begin_t;
 
 /*
- * Reliquish exclusive access. Takes a uccid_cmd_txn_end_t. The callers should
+ * Relinquish exclusive access. Takes a uccid_cmd_txn_end_t. The callers should
  * specify one of UCCID_TXN_END_RESET or UCCID_TXN_END_RELEASE. These indicate
  * what behavior should be taken when we release the transaction. It is
  * considered an error if neither is specified. If the caller exits without
@@ -75,6 +69,16 @@ typedef struct uccid_cmd_txn_end {
 #define	UCCID_TXN_END_RESET	0x01
 #define	UCCID_TXN_END_RELEASE	0x02
 
+typedef struct uccid_cmd_txn_end {
+	uint32_t	uct_version;
+	uint32_t	uct_flags;
+} __packed uccid_cmd_txn_end_t;
+
+/*
+ * Obtain the status of the slot. Fills in ucs_flags.
+ */
+#define	UCCID_CMD_STATUS	(UCCID_IOCTL | 0x3)
+
 /*
  * Protocol definitions. This should match common/ccid/atr.h.
  */
@@ -105,12 +109,12 @@ typedef struct uccid_cmd_status {
 	ccid_class_descr_t	ucs_class;
 	uccid_prot_t	ucs_prot;
 	ccid_params_t	ucs_params;
-} uccid_cmd_status_t;
+} __packed uccid_cmd_status_t;
 
 /*
- * Obtain the status of the slot. Fills in ucs_flags.
+ * Modify the state of the ICC, if present.
  */
-#define	UCCID_CMD_STATUS	(UCCID_IOCTL | 0x3)
+#define	UCCID_CMD_ICC_MODIFY	(UCCID_IOCTL | 0x04)
 
 #define	UCCID_ICC_POWER_ON	0x01
 #define	UCCID_ICC_POWER_OFF	0x02
@@ -119,12 +123,7 @@ typedef struct uccid_cmd_status {
 typedef struct uccid_cmd_icc_modify {
 	uint32_t uci_version;
 	uint32_t uci_action;
-} uccid_cmd_icc_modify_t;
-
-/*
- * Modify the state of the ICC, if present.
- */
-#define	UCCID_CMD_ICC_MODIFY	(UCCID_IOCTL | 0x04)
+} __packed uccid_cmd_icc_modify_t;
 
 #ifdef __cplusplus
 }
diff --git a/usr/src/uts/intel/Makefile.intel b/usr/src/uts/intel/Makefile.intel
index 32f5ff1bad..65b0055ed2 100644
--- a/usr/src/uts/intel/Makefile.intel
+++ b/usr/src/uts/intel/Makefile.intel
@@ -513,6 +513,7 @@ DRV_KMODS	+= ses
 #
 #	USB specific modules
 #
+DRV_KMODS	+= ccid
 DRV_KMODS	+= hid
 DRV_KMODS	+= hubd
 DRV_KMODS	+= uhci
diff --git a/usr/src/uts/intel/ccid/Makefile b/usr/src/uts/intel/ccid/Makefile
index 2237a73d8b..83a8d94ec8 100644
--- a/usr/src/uts/intel/ccid/Makefile
+++ b/usr/src/uts/intel/ccid/Makefile
@@ -10,7 +10,7 @@
 #
 
 #
-# Copyright (c) 2017, Joyent, Inc.
+# Copyright 2019, Joyent, Inc.
 #
 
 UTSBASE = ../..
@@ -25,7 +25,7 @@ include $(UTSBASE)/intel/Makefile.intel
 ALL_TARGET	= $(BINARY)
 LINT_TARGET	= $(MODULE).lint
 INSTALL_TARGET	= $(BINARY) $(ROOTMODULE)
-CPPFLAGS 	+= -I$(SRC)/common/ccid
+CPPFLAGS	+= -I$(SRC)/common/ccid
 
 #
 # XXX For dev
diff --git a/usr/src/uts/intel/os/driver_aliases b/usr/src/uts/intel/os/driver_aliases
index 459d7b98a0..3aca72aee1 100644
--- a/usr/src/uts/intel/os/driver_aliases
+++ b/usr/src/uts/intel/os/driver_aliases
@@ -216,6 +216,7 @@ bnxe "pciex14e4,16a5"
 bnxe "pciex14e4,16ab"
 bnxe "pciex14e4,16ae"
 bscbus "SVI0101"
+ccid "usbif,classb"
 ce "pci100b,35"
 ce "pci108e,abba"
 chxge "pci1425,7"
diff --git a/usr/src/uts/intel/os/name_to_major b/usr/src/uts/intel/os/name_to_major
index 17355a771a..a50496f1fa 100644
--- a/usr/src/uts/intel/os/name_to_major
+++ b/usr/src/uts/intel/os/name_to_major
@@ -308,3 +308,4 @@ ufm 311
 ufmtest 312
 imcstub 313
 imc 314
+ccid 315
-- 
2.17.2 (Apple Git-113)

