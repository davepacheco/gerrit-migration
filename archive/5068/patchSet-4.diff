commit 09b862bb37a204b013988df15ec96d75d2301f7a (refs/changes/68/5068/4)
Author: dyep <dyep49@gmail.com>
Date:   2018-11-27T12:21:41-08:00 (11 months ago)
    
    OS-7343 bhyve image creation blocked by tightening of quota

diff --git a/src/img/lib/imgadm.js b/src/img/lib/imgadm.js
index cc9e9fd5..d9430658 100644
--- a/src/img/lib/imgadm.js
+++ b/src/img/lib/imgadm.js
@@ -3572,6 +3572,37 @@ IMGADM.prototype.createImage = function createImage(options, callback) {
                 next();
             }
         },
+        function removeBhyveQuota(next) {
+            if (vmInfo.brand !== 'bhyve') {
+                next();
+                return;
+            }
+
+            getZfsDataset(vmInfo.zfs_filesystem, ['quota'],
+                function onDataset(err, ds) {
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    zfs.set(vmInfo.zfs_filesystem, {quota: 'none'},
+                        function quotaSet(e) {
+                            if (e) {
+                                next(e);
+                                return;
+                            }
+
+                            if (ds.quota === '0') {
+                                ds.quota = 'none';
+                            }
+
+                            toCleanup.bhyveQuota = ds.quota;
+                            next();
+                        }
+                    );
+                }
+            );
+        },
         function autoprepSnapshotDatasets(next) {
             if (!prepareScript) {
                 next();
@@ -4061,6 +4092,15 @@ IMGADM.prototype.createImage = function createImage(options, callback) {
                     },
                     next);
             },
+            function cleanupBhyveQuota(next) {
+                if (!toCleanup.bhyveQuota) {
+                    next();
+                    return;
+                }
+
+                zfs.set(vmInfo.zfs_filesystem, {quota: toCleanup.bhyveQuota},
+                    next);
+            },
             function cleanupAutoprepStartVm(next) {
                 if (!toCleanup.autoprepStartVm) {
                     next();
diff --git a/src/img/test/create.test.js b/src/img/test/create.test.js
index b111f46f..6f59359b 100644
--- a/src/img/test/create.test.js
+++ b/src/img/test/create.test.js
@@ -20,7 +20,7 @@
  *
  * CDDL HEADER END
  *
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2018, Joyent, Inc. All rights reserved.
  *
  * * *
  *
@@ -35,6 +35,15 @@ var fs = require('fs');
 var rimraf = require('rimraf');
 var mkdirp = require('mkdirp');
 var IMGAPI = require('sdc-clients').IMGAPI;
+var createImgadm = require('/usr/img/lib/imgadm').createTool;
+var VM = require('/usr/vm/node_modules/VM');
+var vminfod = require('/usr/vm/node_modules/vminfod/client');
+var common = require('/usr/vm/test/tests/common');
+var zfs = common.zfs;
+var vasync = require('/usr/img/node_modules/vasync');
+var bunyan = require('/usr/img/node_modules/bunyan');
+
+var log = bunyan.createLogger({name: 'imgadm-create-test'});
 
 // node-tap API
 if (require.cache[__dirname + '/tap4nodeunit.js'])
@@ -48,14 +57,14 @@ var test = tap4nodeunit.test;
 var WRKDIR = '/var/tmp/img-test-create'
 var TESTDIR = __dirname;
 
-// Base image from which we'll be creating a custom images.
+// Base images from which we'll be creating a custom images.
 var BASE_UUID = 'f669428c-a939-11e2-a485-b790efc0f0c1'; // base 13.1.0
+var BHYVE_BASE_UUID = '462d1d03-8457-e134-a408-cf9ea2b9be96'; // centos 7
 
 var envWithTrace = objCopy(process.env);
 envWithTrace.TRACE = '1';
 
 
-
 // ---- internal support stuff
 
 function objCopy(obj, target) {
@@ -81,7 +90,6 @@ test('setup: clean WRKDIR (' + WRKDIR + ')', function (t) {
     });
 });
 
-
 // ---- tests
 
 test('custom image (compression=none)', function (t) {
@@ -216,3 +224,302 @@ test('custom image (incremental, compression=xz)', function (t) {
         });
     });
 });
+
+function waitForUserScript(uuid, callback) {
+    var watchObj = {
+        uuid: uuid
+    };
+
+    var changes = [
+        {
+            path: ['customer_metadata', 'userScriptHasRun'],
+            action: 'changed',
+            oldValue: 'false',
+            newValue: 'true'
+        }
+    ];
+
+    var opts = {
+        timeout: 300 * 1000,
+        teardown: true
+    };
+
+    var vs = new vminfod.VminfodEventStream();
+    vs.watchForChanges(watchObj, changes, opts, callback);
+}
+
+test('create image from bhyve vm', function (t) {
+    var dsQuota;
+    var imgFilePath;
+    var imgadm;
+    var manifest;
+    var manifestPath;
+    var vmobj;
+
+    var payloadCommon = {
+        brand: 'bhyve',
+        autoboot: true,
+        do_not_inventory: true,
+        ram: 128,
+        disks: [
+            {
+                boot: true,
+                image_uuid: BHYVE_BASE_UUID,
+                model: 'virtio'
+            },
+            {
+                size: 512,
+                model: 'virtio'
+            }
+        ]
+    };
+
+    vasync.pipeline({
+        funcs: [
+            function createImgadmTool(_, next) {
+                createImgadm({log: log}, function onCreated(err, tool) {
+                    common.ifError(t, err, 'error creating imgadm');
+
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    imgadm = tool;
+                    next();
+                });
+            },
+            function createVm(_, next) {
+                var payload = JSON.parse(JSON.stringify(payloadCommon));
+                payload.alias = 'test-image-create-' + process.pid;
+                payload.customer_metadata = {
+                    'user-script': [
+                        'mdata-put userScriptHasRun "false"',
+                        'echo -n "foo" > /etc/motd',
+                        'cat /etc/motd | mdata-put disktest',
+                        'mdata-put userScriptHasRun "true"'
+                    ].join('\n')
+                };
+
+                VM.create(payload, function createdVm(err, obj) {
+                    common.ifError(t, err, 'error creating VM');
+
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    vmobj = obj;
+                    next();
+                });
+            },
+            function waitForBoot(_, next) {
+                waitForUserScript(vmobj.uuid, function onUserScript(err) {
+                    common.ifError(t, err, 'error waiting for user script');
+                    next(err);
+                });
+            },
+            function verifyCustomization(_, next) {
+                VM.load(vmobj.uuid, function onLoaded(err, obj) {
+                    common.ifError(t, err, 'loading VM after customization');
+
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    vmobj = obj;
+
+                    t.strictEqual(vmobj.customer_metadata.disktest, 'foo',
+                            'File written to disk');
+                    next();
+                });
+            },
+            function stopVm(_, next) {
+                VM.stop(vmobj.uuid, {}, function vmStopped(err) {
+                    common.ifError(t, err, 'error stopping VM');
+                    next(err);
+                });
+            },
+            function loadQuota(_, next) {
+                var zfsArgs = ['list', '-Hp', '-o', 'quota',
+                    vmobj.zfs_filesystem];
+
+                zfs(zfsArgs, function onList(err, stdout) {
+                    common.ifError(t, err, 'error getting quota');
+
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    dsQuota = stdout;
+                    next();
+                });
+            },
+            function createImageFromVm(_, next) {
+                var createImageOpts = {
+                    vmUuid: vmobj.uuid,
+                    savePrefix: WRKDIR,
+                    manifest: {
+                        name: 'test-image-create-' + process.pid,
+                        version: '1.0.0'
+                    }
+                };
+
+                imgadm.createImage(createImageOpts,
+                    function onCreate(err, info) {
+                        common.ifError(t, err, 'error creating image');
+
+                        if (err) {
+                            next(err);
+                            return;
+                        }
+
+                        t.ok(info.manifest, 'has manifest');
+                        t.ok(info.manifestPath, 'has manifestPath');
+                        t.ok(info.filePath, 'has filePath');
+
+                        manifest = info.manifest;
+                        manifestPath = info.manifestPath;
+                        imgFilePath = info.filePath;
+
+                        next();
+                    }
+                );
+            },
+            function verifyQuotaRestored(_, next) {
+                var zfsArgs = ['list', '-Hp', '-o', 'quota',
+                    vmobj.zfs_filesystem];
+
+                zfs(zfsArgs, function onList(err, stdout) {
+                    common.ifError(t, err, 'error getting quota');
+
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    t.strictEqual(dsQuota, stdout, 'dataset quota is restored');
+                    next();
+                });
+            },
+            function destroyVm(_, next) {
+                if (!vmobj.uuid) {
+                    next();
+                    return;
+                }
+
+                VM.delete(vmobj.uuid, function (err) {
+                    common.ifError(t, err, 'error deleting VM');
+                    next(err);
+                });
+            },
+            function installImage(_, next) {
+                var installArgs = {
+                    manifest: manifest,
+                    zpool: 'zones',
+                    file: imgFilePath,
+                    logCb: console.log
+                };
+
+                imgadm.installImage(installArgs, function installed(err) {
+                    common.ifError(t, err, 'error installing image');
+                    next(err);
+                });
+            },
+            function createVmFromImage(_, next) {
+                var payload = JSON.parse(JSON.stringify(payloadCommon));
+                payload.alias = 'test-new-image-create-' + process.pid;
+                payload.disks[0].image_uuid = manifest.uuid;
+                payload.customer_metadata = {
+                    'user-script': [
+                        'mdata-put userScriptHasRun "false"',
+                        'cat /etc/motd | mdata-put disktest',
+                        'mdata-put userScriptHasRun "true"'
+                    ].join('\n')
+                };
+
+                VM.create(payload, function createVm(err, obj) {
+                    common.ifError(t, err, 'error creating VM');
+
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    vmobj = obj;
+                    next();
+                });
+            },
+            function waitForNewBoot(_, next) {
+                waitForUserScript(vmobj.uuid, function onUserScript(err) {
+                    common.ifError(t, err, 'error waiting for user script');
+                    next(err);
+                });
+            },
+            function verifyCustomization(_, next) {
+                VM.load(vmobj.uuid, function onLoaded(err, obj) {
+                    common.ifError(t, err, 'loading VM after create');
+
+                    if (err) {
+                        next(err);
+                        return;
+                    }
+
+                    t.strictEqual(obj.customer_metadata.disktest, 'foo',
+                            'File written to disk');
+                    next();
+                });
+            },
+            function destroyVm(_, next) {
+                if (!vmobj.uuid) {
+                    next();
+                    return;
+                }
+
+                VM.delete(vmobj.uuid, function (err) {
+                    common.ifError(t, err, 'error deleting VM');
+                    next(err);
+                });
+            },
+            function deleteImage(_, next) {
+                var deleteOpts = {
+                    uuid: manifest.uuid,
+                    zpool: 'zones'
+                };
+
+                imgadm.deleteImage(deleteOpts, function onDelete(err) {
+                    common.ifError(t, err, 'error deleting image');
+                    next(err);
+                    return;
+                });
+            },
+            function deleteImgFiles(_, next) {
+                vasync.parallel({
+                    funcs: [
+                        function deletManifest(done) {
+                            fs.unlink(manifestPath, function onDelete(err) {
+                                common.ifError(t, err,
+                                    'error deleting manifest file');
+                                done(err);
+                            });
+                        },
+                        function deleteFile(done) {
+                            fs.unlink(imgFilePath, function onDelete(err) {
+                                common.ifError(t, err,
+                                'error deleting image file');
+                                done(err);
+                            });
+                        }
+                    ]
+                }, function onFinished(err) {
+                    next(err);
+                });
+            }
+        ]
+    }, function onDone(err) {
+        common.ifError(t, err, 'error testing image create');
+        t.end();
+    });
+});
