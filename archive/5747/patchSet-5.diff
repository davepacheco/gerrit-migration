commit fde96b10bf8ff55d346c47243044f0d154f53785
Author: Josh Wilsdon <jwilsdon@joyent.com>
Date:   2019-03-12T11:07:25-07:00 (7 months ago)
    
    TRITON-1294 TRITON-1217 broke transitional_status being reset after a reboot

diff --git a/lib/heartbeat_reconciler.js b/lib/heartbeat_reconciler.js
index 59dc4d4..edcc042 100644
--- a/lib/heartbeat_reconciler.js
+++ b/lib/heartbeat_reconciler.js
@@ -4,7 +4,7 @@
  */
 
 /*
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -23,6 +23,7 @@ var VError = require('verror');
 
 var buckets = require('./apis/moray').BUCKETS;
 var common = require('./common');
+var ModelServer = require('./models/server');
 
 function HeartbeatReconciler(opts) {
     var self = this;
@@ -107,7 +108,6 @@ function heartbeatServerUpdate(serverUuid, opts, callback) {
     assert.string(opts.stale, 'opts.stale');
 
     var cnapiStatusBucket = buckets.status.name;
-    var cnapiServersBucket = buckets.servers.name;
     var moray = self.moray;
     var observedStatus = self.app.observedHeartbeats[serverUuid];
 
@@ -254,84 +254,53 @@ function heartbeatServerUpdate(serverUuid, opts, callback) {
             }
 
             cb();
-        }, function _getExistingServerObj(ctx, cb) {
+        }, function _updateServerObj(ctx, cb) {
             if (ctx.newServerStatus === undefined) {
-                // We're only here to get the server object so we can update it,
-                // if we're not updating it, no need to grab current object.
+                // If we're not updating the server status, nothing to do here.
                 cb();
                 return;
             }
 
-            moray.getObject(cnapiServersBucket, serverUuid,
-                function _gotServerObject(err, serverObj) {
-                    if (err) {
-                        // If there was any error getting the server (including
-                        // NotFound) we won't be able to do a put even though we
-                        // might already have updated the last_heartbeat in
-                        // cnapi_status. So what we do is remove our in-memory
-                        // record of this server so that next time it heartbeats
-                        // and the reconciler runs, we'll treat it as a new
-                        // server and try again.
-                        self.log.error({
-                            err: err,
-                            serverUuid: serverUuid
-                        }, 'Error getting cnapi_servers object from Moray');
-                        delete self.app.observedHeartbeats[serverUuid];
-                        cb(err);
-                        return;
-                    }
+            ModelServer.upsert(serverUuid, {
+                status: ctx.newServerStatus
+            }, {
+                // If the server doesn't exist, fail instead of creating.
+                allowCreate: false,
+                // We don't currently do any retries here as previous versions
+                // didn't either. This means as a client you'll get an ETag
+                // error if something changes between the getObject and
+                // putObject in the upsert.
+                etagRetries: 0
+            }, function (updateError, results) {
+                if (results.stats.putObjectAttempts) {
+                    self.serverPutsCounter.add(
+                        results.stats.putObjectAttempts);
+                }
+                if (results.stats.putObjectEtagErrors) {
+                    self.serverPutEtagFailuresCounter.add(
+                        results.stats.putObjectEtagErrors);
+                }
+                if (results.stats.putObjectErrors) {
+                    self.serverPutFailuresCounter.add(
+                        results.stats.putObjectErrors);
+                }
 
-                    if (serverObj.value.status === ctx.newServerStatus) {
-                        self.log.debug({
-                            newStatus: ctx.newServerStatus,
-                            serverUuid: serverUuid
-                        }, 'Server already has target status no update needed');
-                    } else {
-                        ctx.serverEtag = serverObj._etag;
-                        ctx.serverObj = serverObj.value;
-                    }
+                if (updateError) {
+                    // If there was any error (including NotFound) we weren't
+                    // able to correctly update the status in Moray even though
+                    // we might already have updated the last_heartbeat in
+                    // cnapi_status. So what we do is remove our in-memory
+                    // record of this server so that next time it heartbeats
+                    // and the reconciler runs, we'll treat it as a new
+                    // server and try again.
+                    delete self.app.observedHeartbeats[serverUuid];
 
-                    cb();
-                });
-        }, function _putServerObj(ctx, cb) {
-            var newServerObj;
+                    cb(updateError);
+                    return;
+                }
 
-            if (ctx.serverObj === undefined) {
-                // We're only here to put the updated server object. If we
-                // didn't load a server record, there's nothing to update.
                 cb();
                 return;
-            }
-
-            assert.string(ctx.newServerStatus, 'ctx.newServerStatus');
-
-            newServerObj = ctx.serverObj;
-            newServerObj.status = ctx.newServerStatus;
-
-            self.serverPutsCounter.increment();
-
-            moray.putObject(cnapiServersBucket, serverUuid, newServerObj,
-                {etag: ctx.serverEtag}, function _onPutServer(err) {
-
-                if (err) {
-                    self.serverPutFailuresCounter.increment();
-                    self.log.error({
-                        err: err,
-                        serverUuid: serverUuid
-                    }, 'Error updating server in moray');
-
-                    if (VError.hasCauseWithName(err, 'EtagConflictError')) {
-                        self.serverPutEtagFailuresCounter.increment();
-                    }
-
-                    // On *any* error putting the new server record, we'll
-                    // remove the in-memory state for this server. This way on
-                    // the next reconciliation after the next heartbeat, we'll
-                    // treat it as a new server and try to update it again.
-                    delete self.app.observedHeartbeats[serverUuid];
-                }
-
-                cb(err);
             });
         }
     ]}, function _updatePipelineComplete(err) {
diff --git a/lib/models/server.js b/lib/models/server.js
index abaa743..a0c00a0 100644
--- a/lib/models/server.js
+++ b/lib/models/server.js
@@ -1030,7 +1030,6 @@ ModelServer.prototype.getFinal = function (opts, callback) {
             //
             if (server.status === 'unknown' && server.transitional_status) {
                 server.status = server.transitional_status;
-                delete server.transitional_status;
             }
             cb();
         }
@@ -1869,35 +1868,66 @@ ModelServer.prototype.getWaitlist = function () {
  * attempt.
  */
 ModelServer._attemptUpsert =
-function _attemptUpsert(opts, serverUuid, properties, etagRetries, callback) {
+function _attemptUpsert(
+    opts, serverUuid, properties, etagRetries, results, callback) {
+
     assert.object(opts, 'opts');
+    assert.optionalBool(opts.allowCreate, 'opts.allowCreate');
     assert.object(opts.log, 'opts.log');
     assert.uuid(serverUuid, 'serverUuid');
     assert.object(properties, 'properties');
     assert.number(etagRetries, 'etagRetries');
+    assert.object(results, 'results');
+    assert.object(results.stats, 'results.stats');
     assert.func(callback, 'callback');
 
     var modified = false;
 
+    if (!results.stats.hasOwnProperty('getObjectAttempts')) {
+        results.stats.getObjectAttempts = 0;
+        results.stats.getObjectErrors = 0;
+        results.stats.getObjectNotFound = 0;
+        results.stats.putObjectAttempts = 0;
+        results.stats.putObjectErrors = 0;
+        results.stats.putObjectEtagErrors = 0;
+    }
+
     vasync.pipeline({arg: {}, funcs: [
         function _getServer(ctx, cb) {
             ModelServer.getMoray().getObject(
                 buckets.servers.name,
                 serverUuid,
                 function (err, obj) {
+                    var requireExist = false;
+
+                    if (opts.allowCreate === false) {
+                        requireExist = true;
+                    }
+
+                    results.stats.getObjectAttempts++;
+
+                    // Default to found until we see ObjectNotFoundError
+                    ctx.serverIsNew = false;
+
                     if (err) {
                         if (VError.hasCauseWithName(err,
                             'ObjectNotFoundError')) {
 
-                            ctx.serverIsNew = true;
-                            cb();
-                            return;
+                            results.stats.getObjectNotFound++;
+
+                            if (!requireExist) {
+                                // We're ok creating a new server.
+                                ctx.serverIsNew = true;
+                                cb();
+                                return;
+                            }
                         }
+
+                        results.stats.getObjectErrors++;
                         cb(err);
                         return;
                     }
 
-                    ctx.serverIsNew = false;
                     ctx.etag = obj._etag;
                     ctx.serverObj = obj.value;
 
@@ -2047,6 +2077,44 @@ function _attemptUpsert(opts, serverUuid, properties, etagRetries, callback) {
             // necessary.
             delete newServerObj.overprovision_ratios;
 
+            //
+            // Since transitional_status is only currently used for 'rebooting',
+            // we can clear it any time it is set and the last_boot value is
+            // changing since that means the server has completed a reboot. But
+            // we only want to do that when the status is 'running' otherwise
+            // we'd potentially have a transition:
+            //
+            //  running -> rebooting -> unknown -> running
+            //
+            // so to ensure this doesn't happen, we clear the transition when:
+            //
+            //  * the last_boot changes and the server is "running"
+            //  * the state changes from unknown -> running
+            //
+            // this way if the server reboots so quickly that it never gets
+            // marked status=unknown, we'll clear the transition when the
+            // last_boot changed (since status=running then). And if the server
+            // reboots more slowly, we'll catch it on the first transition to
+            // running.
+            //
+            if (ctx.serverObj.transitional_status) {
+                // We expect anything other than empty string or undefined
+                // should be 'rebooting'. If someone adds another case without
+                // updating this, we want to blow up.
+                assert.equal(ctx.serverObj.transitional_status, 'rebooting',
+                    'unexpected transitional_status=' +
+                    ctx.serverObj.transitional_status +
+                    ' for server ' + ctx.serverObj.uuid);
+
+                if ((newServerObj.status === 'running') &&
+                    ((ctx.serverObj.last_boot !== newServerObj.last_boot) ||
+                        ctx.serverObj.status === 'unknown')) {
+
+                    delete newServerObj.transitional_status;
+                    modified = true;
+                }
+            }
+
             // END BACKWARD COMPAT SECTION
 
             ctx.newServerObj = newServerObj;
@@ -2097,19 +2165,28 @@ function _attemptUpsert(opts, serverUuid, properties, etagRetries, callback) {
                 serverUuid: ctx.newServerObj.uuid
             }, 'Writing change');
 
+            results.stats.putObjectAttempts++;
+
             ModelServer.getMoray().putObject(
                 buckets.servers.name,
                 ctx.newServerObj.uuid,
                 ctx.newServerObj,
                 putOpts,
-                function (error) {
-                    opts.log[error ? 'warn' : 'trace']({
-                        err: error,
+                function (err) {
+                    opts.log[err ? 'warn' : 'trace']({
+                        err: err,
                         uuid: ctx.newServerObj.uuid,
                         value: ctx.newServerObj
                     }, 'Upsert putObject');
 
-                    cb(error);
+                    if (err) {
+                        results.stats.putObjectErrors++;
+                        if (VError.hasCauseWithName(err, 'EtagConflictError')) {
+                            results.stats.putObjectEtagErrors++;
+                        }
+                    }
+
+                    cb(err);
                 });
         }
     ]}, function _triedPut(err) {
@@ -2121,12 +2198,13 @@ function _attemptUpsert(opts, serverUuid, properties, etagRetries, callback) {
                 serverUuid,
                 properties,
                 etagRetries - 1,
+                results,
                 callback);
 
             return;
         }
 
-        callback(err);
+        callback(err, results);
     });
 };
 
@@ -2146,6 +2224,26 @@ function _attemptUpsert(opts, serverUuid, properties, etagRetries, callback) {
  * The intention is that this is the only function that actually writes server
  * records to Moray, so that we can ensure this is handled in a consistent way.
  *
+ * The callback will be called:
+ *
+ *   callback(err, results)
+ *
+ * where 'err' is an Error object, or undefined. And 'results' is an object that
+ * contains some information about what happened during the course of the
+ * operation. Currently this object contains a 'stats' property which itself
+ * is an object that contains 0 or more counters which indicate operations that
+ * upsert performed. Currently the possible counters are:
+ *
+ * getObjectAttempts    -- number of getObject calls attempted
+ * getObjectErrors      -- total number of getObject errors (excluding NotFound)
+ * getObjectNotFound    -- number of getObject calls that found no object
+ * putObjectAttempts    -- number of putObject calls attempted
+ * putObjectErrors      -- total number of putObject errors
+ * putObjectEtagErrors  -- number of putObject errors that were Etag conflicts
+ *
+ * So, results.stats.putObjectAttempts can be checked in order to see how many
+ * times moray.putObject() was called. If undefined, it was never called.
+ *
  */
 ModelServer.upsert = function upsert(serverUuid, properties, opts, callback) {
     var self = this;
@@ -2154,8 +2252,9 @@ ModelServer.upsert = function upsert(serverUuid, properties, opts, callback) {
     // ModelServer._attemptUpsert.
 
     ModelServer._attemptUpsert({
+        allowCreate: opts.allowCreate,
         log: self.log
-    }, serverUuid, properties, opts.etagRetries || 0, callback);
+    }, serverUuid, properties, opts.etagRetries || 0, {stats: {}}, callback);
 };
 
 
diff --git a/package.json b/package.json
index 6684f38..8249d14 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "cnapi",
   "description": "SmartDataCenter Compute Node API",
-  "version": "1.21.2",
+  "version": "1.21.3",
   "author": "Joyent (joyent.com)",
   "private": true,
   "dependencies": {
