From 63c3bf5d4eae3b4bac90c0aa44b858f34d4bca76 Mon Sep 17 00:00:00 2001
From: Patrick Mooney <pmooney@pfmooney.com>
Date: Thu, 24 May 2018 21:59:57 +0000
Subject: [PATCH] OS-6960 bhyve TSC offsetting should be platform-agnostic

---
 usr/src/uts/i86pc/io/vmm/intel/vmx.c     | 85 ++++++++++--------------
 usr/src/uts/i86pc/io/vmm/intel/vmx.h     |  2 +-
 usr/src/uts/i86pc/io/vmm/intel/vmx_msr.c |  2 +
 usr/src/uts/i86pc/io/vmm/vmm.c           | 46 +++++++++++++
 usr/src/uts/i86pc/sys/vmm.h              |  3 +
 5 files changed, 87 insertions(+), 51 deletions(-)

diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.c b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
index eb33236013..eaad8864c2 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.c
@@ -311,6 +311,9 @@ static int vmx_getreg(void *arg, int vcpu, int reg, uint64_t *retval);
 static int vmxctx_setreg(struct vmxctx *vmxctx, int reg, uint64_t val);
 static void vmx_inject_pir(struct vlapic *vlapic);
 static void vmx_flush_pir_prio(struct vlapic *vlapic);
+#ifndef __FreeBSD__
+static int vmx_apply_tsc_adjust(struct vmx *, int);
+#endif /* __FreeBSD__ */
 
 #ifdef KTR
 static const char *
@@ -980,15 +983,6 @@ vmx_vminit(struct vm *vm, pmap_t pmap)
 	struct vmcs *vmcs;
 	uint32_t exc_bitmap;
 
-#ifndef __FreeBSD__
-	/*
-	 * Grab an initial TSC reading to apply as an offset so the guest
-	 * TSC(s) appear to start from a zeroed value.
-	 */
-	uint64_t init_time = rdtsc();
-#endif
-
-
 	vmx = malloc(sizeof(struct vmx), M_VMX, M_WAITOK | M_ZERO);
 	if ((uintptr_t)vmx & PAGE_MASK) {
 		panic("malloc of struct vmx not aligned on %d byte boundary",
@@ -1100,15 +1094,6 @@ vmx_vminit(struct vm *vm, pmap_t pmap)
 #endif
 		error += vmwrite(VMCS_VPID, vpid[i]);
 
-#ifndef __FreeBSD__
-		/*
-		 * Record initial TSC offset.  It will be loaded into the VMCS
-		 * during each setup for VMX entry.
-		 */
-		vmx->tsc_offset[i] = (uint64_t)(-init_time);
-		VERIFY(procbased_ctls & PROCBASED_TSC_OFFSET);
-#endif
-
 		/* exception bitmap */
 		if (vcpu_trace_exceptions(vm, i))
 			exc_bitmap = 0xffffffff;
@@ -1281,30 +1266,6 @@ vmx_invvpid(struct vmx *vmx, int vcpu, pmap_t pmap, int running)
 	}
 }
 
-#ifndef __FreeBSD__
-/*
- * Set the TSC adjustment, taking into account the offsets measured between
- * host physical CPUs.  This is required even if the guest has not set a TSC
- * offset since vCPUs inherit the TSC offset of whatever physical CPU it has
- * migrated onto.  Without this mitigation, un-synched host TSCs will convey
- * the appearance of TSC time-travel to the guest as its vCPUs migrate.
- */
-static int
-vmx_apply_tsc_adjust(struct vmx *vmx, int vcpu)
-{
-	extern hrtime_t tsc_gethrtime_tick_delta(void);
-	uint64_t host_offset = (uint64_t)tsc_gethrtime_tick_delta();
-	uint64_t guest_offset = vmx->tsc_offset[vcpu];
-	int error;
-
-	ASSERT(vmx->cap[vcpu].proc_ctls & PROCBASED_TSC_OFFSET);
-
-	error = vmwrite(VMCS_TSC_OFFSET, guest_offset + host_offset);
-
-	return (error);
-}
-#endif
-
 static void
 vmx_set_pcpu_defaults(struct vmx *vmx, int vcpu, pmap_t pmap)
 {
@@ -1318,6 +1279,12 @@ vmx_set_pcpu_defaults(struct vmx *vmx, int vcpu, pmap_t pmap)
 	 * trip into the critical section.
 	 */
 	vmcs_write(VMCS_HOST_IA32_SYSENTER_ESP, rdmsr(MSR_SYSENTER_ESP_MSR));
+
+	/*
+	 * Perform any needed TSC_OFFSET adjustment based on TSC_MSR writes or
+	 * migration between host CPUs with differing TSC values.
+	 */
+	VERIFY0(vmx_apply_tsc_adjust(vmx, vcpu));
 #endif
 
 	vmxstate = &vmx->state[vcpu];
@@ -1336,10 +1303,6 @@ vmx_set_pcpu_defaults(struct vmx *vmx, int vcpu, pmap_t pmap)
 	vmcs_write(VMCS_HOST_GDTR_BASE, vmm_get_host_gdtrbase());
 	vmcs_write(VMCS_HOST_GS_BASE, vmm_get_host_gsbase());
 	vmx_invvpid(vmx, vcpu, pmap, 1);
-
-#ifndef __FreeBSD__
-	VERIFY0(vmx_apply_tsc_adjust(vmx, vcpu));
-#endif
 }
 
 /*
@@ -1391,12 +1354,12 @@ vmx_clear_nmi_window_exiting(struct vmx *vmx, int vcpu)
 	VCPU_CTR0(vmx->vm, vcpu, "Disabling NMI window exiting");
 }
 
+#ifdef __FreeBSD__
 int
 vmx_set_tsc_offset(struct vmx *vmx, int vcpu, uint64_t offset)
 {
 	int error;
 
-#ifdef __FreeBSD__
 	if ((vmx->cap[vcpu].proc_ctls & PROCBASED_TSC_OFFSET) == 0) {
 		vmx->cap[vcpu].proc_ctls |= PROCBASED_TSC_OFFSET;
 		vmcs_write(VMCS_PRI_PROC_BASED_CTLS, vmx->cap[vcpu].proc_ctls);
@@ -1404,13 +1367,35 @@ vmx_set_tsc_offset(struct vmx *vmx, int vcpu, uint64_t offset)
 	}
 
 	error = vmwrite(VMCS_TSC_OFFSET, offset);
+
+	return (error);
+}
 #else /* __FreeBSD__ */
-	vmx->tsc_offset[vcpu] = offset;
-	error = vmx_apply_tsc_adjust(vmx, vcpu);
-#endif /* __FreeBSD__ */
+/*
+ * Set the TSC adjustment, taking into account the offsets measured between
+ * host physical CPUs.  This is required even if the guest has not set a TSC
+ * offset since vCPUs inherit the TSC offset of whatever physical CPU it has
+ * migrated onto.  Without this mitigation, un-synched host TSCs will convey
+ * the appearance of TSC time-travel to the guest as its vCPUs migrate.
+ */
+static int
+vmx_apply_tsc_adjust(struct vmx *vmx, int vcpu)
+{
+	extern hrtime_t tsc_gethrtime_tick_delta(void);
+	const uint64_t target_offset = (vcpu_tsc_offset(vmx->vm, vcpu) +
+	    (uint64_t)tsc_gethrtime_tick_delta());
+	int error = 0;
+
+	ASSERT(vmx->cap[vcpu].proc_ctls & PROCBASED_TSC_OFFSET);
+
+	if (vmx->tsc_offset_active[vcpu] != target_offset) {
+		error = vmwrite(VMCS_TSC_OFFSET, target_offset);
+		vmx->tsc_offset_active[vcpu] = target_offset;
+	}
 
 	return (error);
 }
+#endif /* __FreeBSD__ */
 
 #define	NMI_BLOCKING	(VMCS_INTERRUPTIBILITY_NMI_BLOCKING |		\
 			 VMCS_INTERRUPTIBILITY_MOVSS_BLOCKING)
diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx.h b/usr/src/uts/i86pc/io/vmm/intel/vmx.h
index 9c1f7fccbb..0ee83fcc81 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx.h
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx.h
@@ -135,7 +135,7 @@ struct vmx {
 	uint64_t	guest_msrs[VM_MAXCPU][GUEST_MSR_NUM];
 #ifndef	__FreeBSD__
 	uint64_t	host_msrs[VM_MAXCPU][GUEST_MSR_NUM];
-	uint64_t	tsc_offset[VM_MAXCPU];
+	uint64_t	tsc_offset_active[VM_MAXCPU];
 	boolean_t	ctx_loaded[VM_MAXCPU];
 #endif
 	struct vmxctx	ctx[VM_MAXCPU];
diff --git a/usr/src/uts/i86pc/io/vmm/intel/vmx_msr.c b/usr/src/uts/i86pc/io/vmm/intel/vmx_msr.c
index ac97c2bc50..4a1a2cd358 100644
--- a/usr/src/uts/i86pc/io/vmm/intel/vmx_msr.c
+++ b/usr/src/uts/i86pc/io/vmm/intel/vmx_msr.c
@@ -502,9 +502,11 @@ vmx_wrmsr(struct vmx *vmx, int vcpuid, u_int num, uint64_t val, bool *retu)
 		else
 			vm_inject_gp(vmx->vm, vcpuid);
 		break;
+#ifdef __FreeBSD__
 	case MSR_TSC:
 		error = vmx_set_tsc_offset(vmx, vcpuid, val - rdtsc());
 		break;
+#endif /* __FreeBSD__ */
 	default:
 		error = EINVAL;
 		break;
diff --git a/usr/src/uts/i86pc/io/vmm/vmm.c b/usr/src/uts/i86pc/io/vmm/vmm.c
index c4988c6d72..84080d487e 100644
--- a/usr/src/uts/i86pc/io/vmm/vmm.c
+++ b/usr/src/uts/i86pc/io/vmm/vmm.c
@@ -133,6 +133,9 @@ struct vcpu {
 	void		*stats;		/* (a,i) statistics */
 	struct vm_exit	exitinfo;	/* (x) exit reason and collateral */
 	uint64_t	nextrip;	/* (x) next instruction to execute */
+#ifndef __FreeBSD__
+	uint64_t	tsc_offset;	/* (x) offset from host TSC */
+#endif
 };
 
 #define	vcpu_lock_initialized(v) mtx_initialized(&((v)->mtx))
@@ -507,6 +510,9 @@ static void
 vm_init(struct vm *vm, bool create)
 {
 	int i;
+#ifndef __FreeBSD__
+	uint64_t tsc_off;
+#endif
 
 	vm->cookie = VMINIT(vm, vmspace_pmap(vm->vmspace));
 	vm->iommu = NULL;
@@ -535,6 +541,13 @@ vm_init(struct vm *vm, bool create)
 
 	for (i = 0; i < VM_MAXCPU; i++)
 		vcpu_init(vm, i, create);
+
+#ifndef __FreeBSD__
+	tsc_off = (uint64_t)(-(int64_t)rdtsc());
+	for (i = 0; i < VM_MAXCPU; i++) {
+		vm->vcpu[i].tsc_offset = tsc_off;
+	}
+#endif /* __FreeBSD__ */
 }
 
 /*
@@ -1724,6 +1737,24 @@ vm_handle_reqidle(struct vm *vm, int vcpuid, bool *retu)
 	return (0);
 }
 
+#ifndef __FreeBSD__
+static int
+vm_handle_wrmsr(struct vm *vm, int vcpuid, struct vm_exit *vme)
+{
+	struct vcpu *cpu = &vm->vcpu[vcpuid];
+	const uint32_t code = vme->u.msr.code;
+	const uint64_t val = vme->u.msr.wval;
+
+	switch (code) {
+	case MSR_TSC:
+		cpu->tsc_offset = val - rdtsc();
+		return (0);
+	}
+
+	return (-1);
+}
+#endif /* __FreeBSD__ */
+
 int
 vm_suspend(struct vm *vm, enum vm_suspend_how how)
 {
@@ -2050,6 +2081,13 @@ restart:
 		case VM_EXITCODE_MWAIT:
 			vm_inject_ud(vm, vcpuid);
 			break;
+#ifndef __FreeBSD__
+		case VM_EXITCODE_WRMSR:
+			if (vm_handle_wrmsr(vm, vcpuid, vme) != 0) {
+				retu = true;
+			}
+			break;
+#endif
 		default:
 			retu = true;	/* handled in userland */
 			break;
@@ -2654,6 +2692,14 @@ vcpu_get_state(struct vm *vm, int vcpuid, int *hostcpu)
 	return (state);
 }
 
+#ifndef	__FreeBSD__
+uint64_t
+vcpu_tsc_offset(struct vm *vm, int vcpuid)
+{
+	return (vm->vcpu[vcpuid].tsc_offset);
+}
+#endif /* __FreeBSD__ */
+
 int
 vm_activate_cpu(struct vm *vm, int vcpuid)
 {
diff --git a/usr/src/uts/i86pc/sys/vmm.h b/usr/src/uts/i86pc/sys/vmm.h
index dea60c5f76..bd8126cc0d 100644
--- a/usr/src/uts/i86pc/sys/vmm.h
+++ b/usr/src/uts/i86pc/sys/vmm.h
@@ -343,6 +343,9 @@ enum vcpu_state {
 int vcpu_set_state(struct vm *vm, int vcpu, enum vcpu_state state,
     bool from_idle);
 enum vcpu_state vcpu_get_state(struct vm *vm, int vcpu, int *hostcpu);
+#ifndef __FreeBSD__
+uint64_t vcpu_tsc_offset(struct vm *vm, int vcpuid);
+#endif
 
 static __inline int
 vcpu_is_running(struct vm *vm, int vcpu, int *hostcpu)
-- 
2.21.0

