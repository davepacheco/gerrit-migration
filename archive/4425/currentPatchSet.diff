From 3e3c4066d10a00fe60aa0f0a2843a6ca39c4ee27 Mon Sep 17 00:00:00 2001
From: Jason King <jason.king@joyent.com>
Date: Mon, 25 Jun 2018 11:23:11 -0500
Subject: [PATCH] move target cache allocation outside of locks

---
 .../uts/common/io/overlay/overlay_target.c    | 46 +++++++++++--------
 1 file changed, 27 insertions(+), 19 deletions(-)

diff --git a/usr/src/uts/common/io/overlay/overlay_target.c b/usr/src/uts/common/io/overlay/overlay_target.c
index 569e22ed95..b27c72dbe7 100644
--- a/usr/src/uts/common/io/overlay/overlay_target.c
+++ b/usr/src/uts/common/io/overlay/overlay_target.c
@@ -1795,7 +1795,7 @@ overlay_target_cache_set(overlay_target_hdl_t *thdl, void *arg)
 {
 	overlay_dev_t *odd;
 	overlay_target_t *ott;
-	overlay_target_entry_t *ote;
+	overlay_target_entry_t *ote, *new = NULL;
 	overlay_targ_cache_t *otc = arg;
 	mblk_t *mp = NULL;
 
@@ -1811,40 +1811,41 @@ overlay_target_cache_set(overlay_target_hdl_t *thdl, void *arg)
 	if (odd == NULL)
 		return (ENOENT);
 
+	/*
+	 * Optimistically create the new entry.  If not needed, we'll free it.
+	 * We shouldn't be calling this ioctl rapidly enough that any potential
+	 * alloc/free churn should cause a problem.
+	 */
+	new = kmem_cache_alloc(overlay_entry_cache, KM_SLEEP);
+	bcopy(&otc->otc_entry.otce_mac, &new->ote_u.ote_vl2.otvl2_mac,
+	    sizeof (overlay_target_mac_t));
+
 	mutex_enter(&odd->odd_lock);
 	if (!(odd->odd_flags & OVERLAY_F_VARPD)) {
 		mutex_exit(&odd->odd_lock);
 		overlay_hold_rele(odd);
+		overlay_target_entry_dtor(new);
 		return (ENXIO);
 	}
 	ott = odd->odd_target;
 	if (ott->ott_mode != OVERLAY_TARGET_DYNAMIC) {
 		mutex_exit(&odd->odd_lock);
 		overlay_hold_rele(odd);
+		overlay_target_entry_dtor(new);
 		return (ENOTSUP);
 	}
-	mutex_enter(&ott->ott_lock);
-	mutex_exit(&odd->odd_lock);
 
-	ote = sarc_lookup(ott->ott_u.ott_dyn.ott_dhash,
-	    &otc->otc_entry.otce_mac);
-	if (ote == NULL) {
+	new->ote_ott = ott;
+	new->ote_odd = odd;
 
-		ote = kmem_cache_alloc(overlay_entry_cache, KM_SLEEP);
+	mutex_enter(&ott->ott_lock);
+	mutex_exit(&odd->odd_lock);
 
-		bcopy(&otc->otc_entry.otce_mac, &ote->ote_u.ote_vl2.otvl2_mac,
-		    sizeof (overlay_target_mac_t));
-		ote->ote_chead = ote->ote_ctail = NULL;
-		ote->ote_mbsize = 0;
-		ote->ote_ott = ott;
-		ote->ote_odd = odd;
-		mutex_enter(&ote->ote_lock);
-		sarc_insert(ott->ott_u.ott_dyn.ott_dhash, ote);
-		avl_add(&ott->ott_u.ott_dyn.ott_tree, ote);
-	} else {
-		mutex_enter(&ote->ote_lock);
-	}
+	if ((ote = sarc_lookup(ott->ott_u.ott_dyn.ott_dhash,
+	    &otc->otc_entry.otce_mac)) == NULL)
+		ote = new;
 
+	mutex_enter(&ote->ote_lock);
 	if (otc->otc_entry.otce_flags & OVERLAY_TARGET_CACHE_DROP) {
 		ote->ote_flags |= OVERLAY_ENTRY_F_DROP;
 	} else {
@@ -1860,6 +1861,10 @@ overlay_target_cache_set(overlay_target_hdl_t *thdl, void *arg)
 		ote->ote_vtime = gethrtime();
 	}
 
+	if (ote == new) {
+		sarc_insert(ott->ott_u.ott_dyn.ott_dhash, ote);
+		avl_add(&ott->ott_u.ott_dyn.ott_tree, ote);
+	}
 	mutex_exit(&ote->ote_lock);
 	mutex_exit(&ott->ott_lock);
 
@@ -1870,6 +1875,9 @@ overlay_target_cache_set(overlay_target_hdl_t *thdl, void *arg)
 
 	overlay_hold_rele(odd);
 
+	if (ote != new)
+		overlay_target_entry_dtor(new);
+
 	return (0);
 }
 
-- 
2.21.0

