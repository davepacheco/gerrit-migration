commit 16377bd32b74574bc75e6da6375e739c2b0a7066
Author: Kody Kantor <kody@kkantor.com>
Date:   2019-04-08T21:07:45+00:00 (6 months ago)
    
    joyent/pgstatsmon#25 distinguish between vacuum and vacuum to prevent wraparound
    joyent/pgstatsmon#26 vacuum progress function should use SETOF

diff --git a/CHANGES.md b/CHANGES.md
index e9821ae..4570399 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,6 +1,8 @@
 # pgstatsmon Changelog
 
 ## Not yet released
+* #26 vacuum progress function should use SETOF
+* #25 distinguish between vacuum and vacuum to prevent wraparound
 * #24 track vacuum start time
 
 ## 1.1.0
diff --git a/lib/dbinit.js b/lib/dbinit.js
index e86ac70..73d2516 100644
--- a/lib/dbinit.js
+++ b/lib/dbinit.js
@@ -236,6 +236,7 @@ function create_progress_vacuum_function(args, callback) {
 	query = 'DROP FUNCTION IF EXISTS get_stat_progress_vacuum(); '
 	+ 'CREATE FUNCTION public.get_stat_progress_vacuum('
 	+ 'out relname name, '
+	+ 'out is_wraparound boolean, '
 	+ 'out query_start double precision, '
 	+ 'out phase bigint, '
 	+ 'out heap_blks_total bigint, '
@@ -243,9 +244,11 @@ function create_progress_vacuum_function(args, callback) {
 	+ 'out heap_blks_vacuumed bigint, '
 	+ 'out index_vacuum_count bigint, '
 	+ 'out max_dead_tuples bigint, '
-	+ 'out num_dead_tuples bigint)'
+	+ 'out num_dead_tuples bigint) '
+	+ ' RETURNS SETOF record'
 	+ ' AS $$'
 	+ ' SELECT T.relname AS relname,'
+	+ '	  A.query LIKE \'% (to prevent wraparound)\' as is_wraparound,'
 	+ '	  EXTRACT (EPOCH FROM A.query_start) AS query_start,'
 	+ '	  S.param1+1 AS phase,'
 	+ '	  S.param2 AS heap_blks_total,'
diff --git a/lib/pgstatsmon.js b/lib/pgstatsmon.js
index 95d506f..45d1498 100644
--- a/lib/pgstatsmon.js
+++ b/lib/pgstatsmon.js
@@ -3,7 +3,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  *
- * Copyright (c) 2018, Joyent, Inc.
+ * Copyright (c) 2019, Joyent, Inc.
  */
 
 /*
@@ -1017,11 +1017,13 @@ PgMon.prototype.record = function (pi, qi, datum)
 			return;
 		}
 
-		query.q_counters.forEach(function emit_counters(c) {
-			metric = mon.qstatname(pi, qi, row, c);
-			new_value = row[c.attr];
-			old_value = oldrow[c.attr];
-
+		/*
+		 * Common set of checks that we should run against all data
+		 * received from Postgres.
+		 */
+		function check_datum(d) {
+			metric = mon.qstatname(pi, qi, row, d);
+			new_value = row[d.attr];
 			/*
 			 * Ways we can get bad data from Postgres:
 			 * - corruption on the wire
@@ -1047,6 +1049,13 @@ PgMon.prototype.record = function (pi, qi, datum)
 				}, 'null value observed');
 				return;
 			}
+		}
+
+		query.q_counters.forEach(function emit_counters(c) {
+			check_datum(c);
+			metric = mon.qstatname(pi, qi, row, c);
+			new_value = row[c.attr];
+			old_value = oldrow[c.attr];
 
 			if (old_value > new_value) {
 				/* some relations don't advertise stat resets */
@@ -1062,22 +1071,10 @@ PgMon.prototype.record = function (pi, qi, datum)
 		});
 
 		query.q_gauges.forEach(function emit_gauges(g) {
+			check_datum(g);
 			metric = mon.qstatname(pi, qi, row, g);
 			new_value = row[g.attr];
 
-			/* see previous comment for explanation */
-			if (isNaN(new_value)) {
-				record_NaN(metric);
-				return;
-			}
-
-			if (new_value === null) {
-				mon.pm_log.debug({
-					'metric': metric
-				}, 'null value observed');
-				return;
-			}
-
 			if (g.expires) {
 				metric.expires = g.expires;
 				metric.expiryPeriod = g.expiryPeriod;
@@ -1086,6 +1083,20 @@ PgMon.prototype.record = function (pi, qi, datum)
 
 			mon.emitGauge(metric, new_value);
 		});
+
+		query.q_booleans.forEach(function emit_boolean(b) {
+			check_datum(b);
+			metric = mon.qstatname(pi, qi, row, b);
+			new_value = row[b.attr];
+
+			if (b.expires) {
+				metric.expires = b.expires;
+				metric.expiryPeriod = b.expiryPeriod;
+				metric.defaultValue = b.defaultValue;
+			}
+
+			mon.emitBoolean(metric, new_value);
+		});
 	});
 };
 
@@ -1159,6 +1170,17 @@ PgMon.prototype.emitGauge = function (metric, value)
 	this.pm_targets.forEach(function (t) { t.emitGauge(metric, value); });
 };
 
+/*
+ * [private] Emit the named boolean to all targets.
+ */
+PgMon.prototype.emitBoolean = function (metric, value)
+{
+	mod_assertplus.object(metric, 'metric');
+	mod_assertplus.bool(value, 'value');
+
+	this.pm_targets.forEach(function (t) { t.emitBoolean(metric, value); });
+};
+
 /*
  * [private] Emit the named timer to all targets.
  */
@@ -1183,6 +1205,7 @@ function Query(conf, log)
 	this.q_statkey = conf.statkey || null;
 	this.q_gauges = (conf.gauges || []).slice(0);
 	this.q_counters = (conf.counters || []).slice(0);
+	this.q_booleans = (conf.booleans || []).slice(0);
 	this.q_metadata = (conf.metadata || []).slice(0);
 }
 
@@ -1205,6 +1228,11 @@ LogTarget.prototype.emitGauge = function (metric, value)
 	this.lt_log.trace(metric.name, metric.metadata, value);
 };
 
+LogTarget.prototype.emitBoolean = function (metric, value)
+{
+	this.lt_log.trace(metric.name, metric.metadata, value);
+};
+
 LogTarget.prototype.emitTimer = function (metric, duration)
 {
 	this.lt_log.trace(metric.name, metric.metadata, duration);
@@ -1280,6 +1308,22 @@ PrometheusTarget.prototype.emitGauge = function (metric, value)
 	}).set(value, metric.metadata);
 };
 
+/*
+ * Prometheus stores boolean types as gauges of value zero (false) or
+ * one (true).
+ */
+PrometheusTarget.prototype.emitBoolean = function (metric, value)
+{
+	var bool_as_number = value ? 1 : 0;
+	this.pe_collector.gauge({
+		name: metric.name,
+		help: metric.help,
+		expires: metric.expires,
+		expiryPeriod: metric.expiryPeriod,
+		defaultValue: metric.defaultValue
+	}).set(bool_as_number, metric.metadata);
+};
+
 PrometheusTarget.prototype.emitTimer = function (metric, duration)
 {
 	this.pe_collector.histogram({
diff --git a/lib/queries.js b/lib/queries.js
index 52e5187..5844ddd 100644
--- a/lib/queries.js
+++ b/lib/queries.js
@@ -318,16 +318,20 @@ function getQueries(config) {
 	}, {
 	     'name': 'pg_stat_progress_vacuum',
 	     'statkey': 'relname',
-	     'metadata': [ 'relname'],
+	     'metadata': [ 'relname' ],
 	     'sql': [
 	         'SELECT * FROM get_stat_progress_vacuum()'
 	     ].join('\n'),
 	     'gauges': [
+		/*
+		 * The order of these metrics should match the order listed
+		 * in the function defined in lib/dbinit.js.
+		 */
 	         { 'attr': 'phase', 'help': 'current processing phase of ' +
 	           'vacuum', 'expires': true, 'expiryPeriod': expiryPeriod },
 	         { 'attr': 'query_start', 'help': 'unix epoch timestamp of ' +
 	           'the vacuum began', 'expires': true,
-		    'expiryPeriod': expiryPeriod },
+	           'expiryPeriod': expiryPeriod },
 	         { 'attr': 'heap_blks_total', 'help': 'total number of heap ' +
 	           'blocks in the table as of the beginning of the scan',
 	           'expires': true, 'expiryPeriod': expiryPeriod },
@@ -347,6 +351,16 @@ function getQueries(config) {
 	         { 'attr': 'num_dead_tuples', 'help': 'number of dead tuples ' +
 	           'collected since the last index vacuum cycle',
 	           'expires': true, 'expiryPeriod': expiryPeriod }
+	     ],
+	     'booleans': [
+		/*
+		 * Expiration doesn't make as much sense for boolean types, but
+		 * we expire this metric anyway to maintain consistency with
+		 * the other vacuum progress stats.
+		 */
+	         { 'attr': 'is_wraparound', 'help': 'true if vacuum is to ' +
+	           'prevent wraparound', 'expires': true,
+	           'expiryPeriod': expiryPeriod }
 	     ]
 	}];
 
