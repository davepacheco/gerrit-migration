commit 11502903bf6a85c5c154642810689bfd6a932d62 (refs/changes/41/1841/3)
Author: Alex Wilson <alex.wilson@joyent.com>
Date:   2017-04-25T16:33:26-07:00 (2 years, 5 months ago)
    
    joyent/node-zkstream#4 upgrade to mooremachine 2.0

diff --git a/lib/client-fsm.js b/lib/client-fsm.js
index 9faff3d..059f39c 100644
--- a/lib/client-fsm.js
+++ b/lib/client-fsm.js
@@ -17,86 +17,133 @@ const mod_errors = require('./errors');
 const mod_jsbn = require('jsbn');
 const mod_events = require('events');
 const mod_zkstreams = require('./zk-streams');
+const mod_net = require('net');
 
 function ZKClientFSM(opts) {
 	mod_assert.object(opts, 'options');
-	this.zs_decoder = new mod_zkstreams.ZKDecodeStream({
-		fsm: this
-	});
-	this.zs_encoder = new mod_zkstreams.ZKEncodeStream({
-		fsm: this
-	});
-
-	var self = this;
-	function onStreamError() {
-		self.gotoState('error');
-	}
-	this.zs_decoder.on('error', this.emit.bind(this, 'error'));
-	this.zs_decoder.on('error', onStreamError);
-	this.zs_encoder.on('error', this.emit.bind(this, 'error'));
-	this.zs_encoder.on('error', onStreamError);
 
+	mod_assert.string(opts.host, 'options.host');
+	mod_assert.number(opts.port, 'options.port');
+	this.zs_host = opts.host;
+	this.zs_port = opts.port;
+	this.zs_decoder = undefined;
+	this.zs_encoder = undefined;
 	this.zs_xidMap = {};
 	this.zs_xid = 1;
 	this.zs_reqs = {};
 	this.zs_watchers = {};
 	this.zs_socket = undefined;
-	mod_fsm.FSM.call(this, 'connecting');
+	mod_fsm.FSM.call(this, 'init');
 }
 mod_util.inherits(ZKClientFSM, mod_fsm.FSM);
 
-ZKClientFSM.prototype.attach = function (socket) {
-	var self = this;
-	this.zs_socket = socket;
-	socket.pipe(this.zs_decoder);
-	this.zs_encoder.pipe(socket);
-	socket.on('error', this.emit.bind(this, 'error'));
-	socket.on('error', function (err) {
-		self.zs_lastError = err;
-		self.gotoState('error');
-	});
+ZKClientFSM.prototype.connect = function () {
+	mod_assert.ok(this.isInState('closed') || this.isInState('init'));
+	this.emit('connectAsserted');
 };
 
-ZKClientFSM.prototype.close = function (cb) {
-	mod_assert.object(this.zs_socket, 'an open connection');
-	mod_assert.optionalFunc(cb, 'callback');
-	if (cb)
-		this.onState('closed', cb);
-	this.zs_socket.end();
+ZKClientFSM.prototype.close = function () {
+	mod_assert.ok(!this.isInState('closed'));
+	var self = this;
+	self.emit('closeAsserted');
 };
 
 ZKClientFSM.prototype.nextXid = function () {
 	return (this.zs_xid++);
 };
 
-ZKClientFSM.prototype.state_connecting = function (on) {
+ZKClientFSM.prototype.state_init = function (S) {
+	S.on(this, 'connectAsserted', function () {
+		S.gotoState('connecting');
+	});
+};
+
+ZKClientFSM.prototype.state_closed = function (S) {
+	S.on(this, 'connectAsserted', function () {
+		S.gotoState('connecting');
+	});
+	if (this.zs_encoder) {
+		this.zs_encoder.end();
+		this.zs_encoder = undefined;
+	}
+	if (this.zs_socket) {
+		this.zs_socket.destroy();
+		this.zs_socket = undefined;
+		this.emit('close');
+	}
+	if (this.zs_decoder) {
+		this.zs_decoder = undefined;
+	}
+};
+
+ZKClientFSM.prototype.state_connecting = function (S) {
 	var self = this;
-	on(this.zs_decoder, 'readable', function () {
+	this.zs_decoder = new mod_zkstreams.ZKDecodeStream({
+		fsm: this
+	});
+	this.zs_encoder = new mod_zkstreams.ZKEncodeStream({
+		fsm: this
+	});
+	this.zs_socket = mod_net.connect({
+		host: this.zs_host,
+		port: this.zs_port
+	});
+	S.on(this.zs_socket, 'connect', function () {
+		S.gotoState('handshaking');
+	});
+	S.on(this.zs_socket, 'error', function (err) {
+		self.zs_lastError = err;
+		S.gotoState('error');
+	});
+	S.on(this.zs_socket, 'close', function () {
+		S.gotoState('closed');
+	});
+	S.on(this, 'closeAsserted', function () {
+		S.gotoState('closed');
+	});
+};
+
+ZKClientFSM.prototype.state_handshaking = function (S) {
+	var self = this;
+	S.on(this.zs_decoder, 'readable', function () {
 		var pkt = self.zs_decoder.read();
 		if (self.zs_decoder.read() !== null) {
 			self.emit('error', new mod_errors.ZKProtocolError(
 			    'UNEXPECTED_PACKET', 'Received unexpected ' +
 			    'additional packet during connect phase'));
-			self.gotoState('error');
+			S.gotoState('error');
 			return;
 		}
 		if (pkt.protocolVersion !== 0) {
 			self.emit('error', new mod_errors.ZKProtocolError(
 			    'VERSION_INCOMPAT', 'Server version is not ' +
 			    'compatible'));
-			self.gotoState('error');
+			S.gotoState('error');
 			return;
 		}
 		self.zs_cr = pkt;
-		self.gotoState('connected');
+		S.gotoState('connected');
+	});
+	S.on(this.zs_decoder, 'error', function (err) {
+		self.zs_lastError = err;
+		S.gotoState('error');
+	});
+	S.on(this.zs_encoder, 'error', function (err) {
+		self.zs_lastError = err;
+		S.gotoState('error');
 	});
-	on(this.zs_decoder, 'error', function (err) {
+	S.on(this.zs_decoder, 'end', function () {
+		S.gotoState('closed');
+	});
+	S.on(this.zs_socket, 'error', function (err) {
 		self.zs_lastError = err;
-		self.gotoState('error');
+		S.gotoState('error');
 	});
-	on(this.zs_decoder, 'end', function () {
-		self.gotoState('closed');
+	S.on(this, 'closeAsserted', function () {
+		S.gotoState('closed');
 	});
+	this.zs_socket.pipe(this.zs_decoder);
+	this.zs_encoder.pipe(this.zs_socket);
 	this.zs_encoder.write({
 		protocolVersion: 0,
 		lastZxidSeen: new mod_jsbn.BigInteger('0'),
@@ -106,20 +153,21 @@ ZKClientFSM.prototype.state_connecting = function (on) {
 	});
 };
 
-ZKClientFSM.prototype.state_connected = function (on) {
+ZKClientFSM.prototype.state_connected = function (S) {
 	var self = this;
 
 	var pingInterval = this.zs_cr.timeOut / 2;
 	if (pingInterval < 2000)
 		pingInterval = 2000;
-	this.zs_pingTimer = setInterval(function () {
+	var pingTimer = S.interval(pingInterval, function () {
 		self.ping();
-	}, pingInterval);
-	this.zs_pingTimer.unref();
+	});
+	pingTimer.unref();
 
-	on(this.zs_decoder, 'readable', function () {
+	S.on(this.zs_decoder, 'readable', function () {
 		var pkt;
-		while ((pkt = self.zs_decoder.read()) !== null) {
+		while (self.zs_decoder &&
+		    (pkt = self.zs_decoder.read()) !== null) {
 			if (pkt.opcode === 'NOTIFICATION') {
 				if (pkt.state !== 'SYNC_CONNECTED') {
 					continue;
@@ -147,30 +195,37 @@ ZKClientFSM.prototype.state_connected = function (on) {
 			}
 		}
 	});
-	on(this.zs_decoder, 'end', function () {
-		self.gotoState('closed');
+	S.on(this.zs_decoder, 'end', function () {
+		S.gotoState('closed');
+	});
+	S.on(this.zs_decoder, 'error', function (err) {
+		self.zs_lastError = err;
+		S.gotoState('error');
 	});
-	on(this.zs_decoder, 'error', function (err) {
+	S.on(this.zs_encoder, 'error', function (err) {
 		self.zs_lastError = err;
-		self.gotoState('error');
+		S.gotoState('error');
+	});
+	S.on(this.zs_socket, 'error', function (err) {
+		self.zs_lastError = err;
+		S.gotoState('error');
+	});
+	S.on(this, 'closeAsserted', function () {
+		S.gotoState('closed');
+	});
+	S.on(this, 'pingTimeout', function () {
+		self.zs_lastError = new Error('Ping timeout');
+		S.gotoState('error');
 	});
 };
 
-ZKClientFSM.prototype.state_error = function () {
+ZKClientFSM.prototype.state_error = function (S) {
 	var self = this;
-	clearInterval(this.zs_pingTimer);
 	this.emit('error', this.zs_lastError);
 	Object.keys(this.zs_reqs).forEach(function (xid) {
 		self.zs_reqs[xid].emit('error', self.zs_lastError);
 	});
-	if (this.zs_socket)
-		this.zs_socket.destroy();
-};
-
-ZKClientFSM.prototype.state_closed = function () {
-	this.zs_encoder.end();
-	clearInterval(this.zs_pingTimer);
-	this.emit('close');
+	S.gotoState('closed');
 };
 
 ZKClientFSM.prototype.ping = function (cb) {
@@ -203,12 +258,7 @@ ZKClientFSM.prototype.ping = function (cb) {
 	}
 	function onTimeout() {
 		req.removeListener('reply', onPacket);
-		self.zs_lastError = new Error('Ping timeout');
-		self.gotoState('error');
-		/*
-		 * Moving to error state will spit an error on the
-		 * outstanding request.
-		 */
+		self.emit('pingTimeout');
 	}
 	function onError(err) {
 		delete (self.zs_reqs[pkt.xid]);
@@ -246,8 +296,7 @@ ZKClientFSM.prototype.setWatches = function (events, cb) {
 	}
 	function onTimeout() {
 		req.removeListener('reply', onPacket);
-		self.zs_lastError = new Error('Ping timeout');
-		self.gotoState('error');
+		self.emit('pingTimeout');
 	}
 	function onError(err) {
 		delete (self.zs_reqs[pkt.xid]);
@@ -392,7 +441,7 @@ function ZKWatcher(client, path) {
 mod_util.inherits(ZKWatcher, mod_events.EventEmitter);
 
 ZKWatcher.prototype.once = function () {
-	throw (new Error('ZKWatcher does not support once() (use on)'))
+	throw (new Error('ZKWatcher does not support once() (use on)'));
 };
 
 ZKWatcher.prototype.on = function (evt, cb) {
diff --git a/lib/zk-buffer.js b/lib/zk-buffer.js
index d116e16..e12b007 100644
--- a/lib/zk-buffer.js
+++ b/lib/zk-buffer.js
@@ -147,7 +147,7 @@ ZKBuffer.prototype.writeCreateRequest = function (pkt) {
 		var mask = mod_consts.CREATE_FLAGS[k];
 		mod_assert.number(mask, 'unknown flag ' + k);
 		flags |= mask;
-	})
+	});
 	this.writeInt(flags);
 };
 
diff --git a/lib/zk-streams.js b/lib/zk-streams.js
index e721fed..a199542 100644
--- a/lib/zk-streams.js
+++ b/lib/zk-streams.js
@@ -63,7 +63,7 @@ ZKDecodeStream.prototype._transform = function (chunk, enc, cb) {
 	cb();
 	function handlePacket(pktBuf) {
 		var zkb = new ZKBuffer({buffer: pktBuf});
-		if (self.zd_fsm.getState() === 'connecting') {
+		if (self.zd_fsm.isInState('handshaking')) {
 			try {
 				pkt = zkb.readConnectResponse();
 			} catch (e) {
@@ -110,15 +110,15 @@ ZKEncodeStream.prototype._transform = function (pkt, enc, cb) {
 	mod_assert.object(pkt);
 	var zkb = new ZKBuffer({});
 
-	if (this.ze_fsm.getState() === 'connecting') {
+	if (this.ze_fsm.isInState('handshaking')) {
 		zkb.writeLengthPrefixed(function (sub) {
 			sub.writeConnectRequest(pkt);
 		});
 		this.push(zkb.toBuffer());
 		cb();
 	} else {
-		mod_assert.number(pkt.xid);
-		mod_assert.string(pkt.opcode);
+		mod_assert.number(pkt.xid, 'xid');
+		mod_assert.string(pkt.opcode, 'opcode');
 		zkb.writeLengthPrefixed(function (sub) {
 			sub.writeRequest(pkt);
 		});
diff --git a/package.json b/package.json
index e3a9cc4..3b485fb 100644
--- a/package.json
+++ b/package.json
@@ -1,12 +1,12 @@
 {
   "name": "zkstream",
-  "version": "0.1.1",
+  "version": "0.2.0",
   "description": "",
   "main": "lib/index.js",
   "dependencies": {
     "assert-plus": "^1.0.0",
     "jsbn": "^0.1.0",
-    "mooremachine": "^1.2.0",
+    "mooremachine": "^2.0.0",
     "node-uuid": "^1.4.7",
     "vasync": "^1.6.3",
     "verror": "^1.6.1"
diff --git a/test/basic.test.js b/test/basic.test.js
index 5d21003..486fe25 100644
--- a/test/basic.test.js
+++ b/test/basic.test.js
@@ -15,27 +15,28 @@ var zk;
 
 mod_tape.test('start zk server', function (t) {
 	zk = new mod_zk.ZKServer();
-	zk.onState('running', function () {
-		t.end();
+	zk.on('stateChanged', function (st) {
+		if (st === 'running')
+			t.end();
 	});
 });
 
 mod_tape.test('simple connect and ping', function (t) {
-	var zkc = new mod_client.ClientFSM({});
-	var sock = mod_net.connect({
+	var zkc = new mod_client.ClientFSM({
 		host: 'localhost',
 		port: 2181
 	});
-	zkc.attach(sock);
+	zkc.connect();
 
-	zkc.onState('connected', function () {
-		zkc.ping(function (err) {
-			t.error(err);
-			sock.end();
-			zkc.onState('closed', function () {
-				t.end();
+	zkc.on('stateChanged', function (st) {
+		if (st === 'connected') {
+			zkc.ping(function (err) {
+				t.error(err);
+				zkc.close();
 			});
-		});
+		} else if (st === 'closed') {
+			t.end();
+		}
 	});
 });
 
@@ -47,14 +48,18 @@ mod_tape.test('set up test object', function (t) {
 });
 
 mod_tape.test('find the test object', function (t) {
-	var zkc = new mod_client.ClientFSM({});
-	var sock = mod_net.connect({
+	var zkc = new mod_client.ClientFSM({
 		host: 'localhost',
 		port: 2181
 	});
-	zkc.attach(sock);
+	zkc.connect();
+
+	zkc.on('stateChanged', function (st) {
+		if (st === 'closed')
+			t.end();
+		if (st !== 'connected')
+			return;
 
-	zkc.onState('connected', function () {
 		var req = zkc.list('/');
 		req.once('reply', function (pkt) {
 			t.strictEqual(pkt.opcode, 'GET_CHILDREN');
@@ -64,10 +69,7 @@ mod_tape.test('find the test object', function (t) {
 			req2.once('reply', function (pkt2) {
 				t.strictEqual(
 				    pkt2.data.toString('ascii'), 'hi');
-				sock.end();
-				zkc.onState('closed', function () {
-					t.end();
-				});
+				zkc.close();
 			});
 			req2.once('error', function (err) {
 				t.error(err);
@@ -82,89 +84,91 @@ mod_tape.test('find the test object', function (t) {
 });
 
 mod_tape.test('delete the test object', function (t) {
-	var zkc = new mod_client.ClientFSM({});
-	var sock = mod_net.connect({
+	var zkc = new mod_client.ClientFSM({
 		host: 'localhost',
 		port: 2181
 	});
-	zkc.attach(sock);
+	zkc.connect();
 
-	zkc.onState('connected', function () {
+	zkc.on('stateChanged', function (st) {
+		if (st === 'closed')
+			t.end();
+		if (st !== 'connected')
+			return;
 		zkc.delete('/foo', 0, function (err) {
 			t.error(err);
-			sock.end();
-			zkc.onState('closed', function () {
-				t.end();
-			});
+			zkc.close();
 		});
 	});
 });
 
 mod_tape.test('ask for a non-existent node', function (t) {
-	var zkc = new mod_client.ClientFSM({});
-	var sock = mod_net.connect({
+	var zkc = new mod_client.ClientFSM({
 		host: 'localhost',
 		port: 2181
 	});
-	zkc.attach(sock);
+	zkc.connect();
+
+	zkc.on('stateChanged', function (st) {
+		if (st === 'closed')
+			t.end();
+		if (st !== 'connected')
+			return;
 
-	zkc.onState('connected', function () {
 		var req = zkc.stat('/foo');
 		req.once('reply', function (pkt) {
 			t.fail('Expected an error');
-			sock.end();
-			zkc.onState('closed', function () {
-				t.end();
-			});
+			zkc.close();
 		});
 		req.once('error', function (err) {
 			t.ok(err);
 			t.strictEqual(err.code, 'NO_NODE');
-			sock.end();
-			zkc.onState('closed', function () {
-				t.end();
-			});
+			zkc.close();
 		});
 	});
 });
 
 mod_tape.test('create a new node', function (t) {
-	var zkc = new mod_client.ClientFSM({});
-	var sock = mod_net.connect({
+	var zkc = new mod_client.ClientFSM({
 		host: 'localhost',
 		port: 2181
 	});
-	zkc.attach(sock);
+	zkc.connect();
+
+	zkc.on('stateChanged', function (st) {
+		if (st === 'closed')
+			t.end();
+		if (st !== 'connected')
+			return;
 
-	zkc.onState('connected', function () {
 		var d = new Buffer('hi there', 'ascii');
 		zkc.create('/foo', d, {}, function (err, path) {
 			t.error(err);
 			t.strictEqual(path, '/foo');
-			zk.cli('get', '/foo', function (err, output) {
-				t.error(err);
+			zk.cli('get', '/foo', function (err2, output) {
+				t.error(err2);
 				t.strictEqual(output, 'hi there\n');
-				sock.end();
-				zkc.onState('closed', function () {
-					t.end();
-				});
+				zkc.close();
 			});
 		});
 	});
 });
 
 mod_tape.test('data watcher', function (t) {
-	var zkc = new mod_client.ClientFSM({});
-	var sock = mod_net.connect({
+	var zkc = new mod_client.ClientFSM({
 		host: 'localhost',
 		port: 2181
 	});
-	zkc.attach(sock);
+	zkc.connect();
 
 	var data = new Buffer('hi there', 'ascii');
 	var count = 0;
 
-	zkc.onState('connected', function () {
+	zkc.on('stateChanged', function (st) {
+		if (st === 'closed')
+			t.end();
+		if (st !== 'connected')
+			return;
 		zkc.watcher('/foo').on('dataChanged', function (newData) {
 			t.ok(Buffer.isBuffer(newData));
 			t.strictEqual(newData.toString('base64'),
@@ -176,28 +180,26 @@ mod_tape.test('data watcher', function (t) {
 		zk.cli('set', '/foo', 'hi', function (err) {
 			t.error(err);
 			t.strictEqual(count, 2);
-			sock.end();
-			zkc.onState('closed', function () {
-				t.end();
-			});
-		})
+			zkc.close();
+		});
 	});
 });
 
 mod_tape.test('delete it while watching', function (t) {
-	var zkc = new mod_client.ClientFSM({});
-	var sock = mod_net.connect({
+	var zkc = new mod_client.ClientFSM({
 		host: 'localhost',
 		port: 2181
 	});
-	zkc.attach(sock);
+	zkc.connect();
+
+	zkc.on('stateChanged', function (st) {
+		if (st === 'closed')
+			t.end();
+		if (st !== 'connected')
+			return;
 
-	zkc.onState('connected', function () {
 		zkc.watcher('/foo').on('deleted', function () {
-			sock.end();
-			zkc.onState('closed', function () {
-				t.end();
-			});
+			zkc.close();
 		});
 		zkc.stat('/foo', function (err, stat) {
 			t.error(err);
@@ -209,8 +211,9 @@ mod_tape.test('delete it while watching', function (t) {
 });
 
 mod_tape.test('stop zk server', function (t) {
-	zk.onState('stopped', function () {
-		t.end();
+	zk.on('stateChanged', function (st) {
+		if (st === 'stopped')
+			t.end();
 	});
 	zk.stop();
 });
diff --git a/test/zkserver.js b/test/zkserver.js
index e18a4a7..42c62ea 100644
--- a/test/zkserver.js
+++ b/test/zkserver.js
@@ -92,12 +92,12 @@ ZKServer.prototype.cli = function () {
 	});
 };
 
-ZKServer.prototype.state_starting = function (on) {
+ZKServer.prototype.state_starting = function (S) {
 	this.zk_cmd = this.zk_cmds.shift();
-	this.gotoState('spawning');
+	S.gotoState('spawning');
 };
 
-ZKServer.prototype.state_spawning = function (on) {
+ZKServer.prototype.state_spawning = function (S) {
 	var self = this;
 
 	var opts = {};
@@ -111,12 +111,12 @@ ZKServer.prototype.state_spawning = function (on) {
 
 	this.zk_kid = mod_cproc.spawn(this.zk_cmd, ['start-foreground',
 	    this.zk_config], opts);
-	on(this.zk_kid, 'error', function (err) {
+	S.on(this.zk_kid, 'error', function (err) {
 		if (err.code === 'ENOENT') {
-			self.gotoState('starting');
+			S.gotoState('starting');
 		} else {
 			self.zk_lastError = err;
-			self.gotoState('error');
+			S.gotoState('error');
 		}
 	});
 	var output = '';
@@ -126,22 +126,22 @@ ZKServer.prototype.state_spawning = function (on) {
 	this.zk_kid.stdout.on('data', function (data) {
 		console.error('zk: %j', data.toString('ascii'));
 	});
-	on(this.zk_kid.stderr, 'data', function (data) {
+	S.on(this.zk_kid.stderr, 'data', function (data) {
 		output += data.toString('ascii');
 		var lines = output.split('\n');
 		lines = lines.map(function (l) {
 			return (/^Using config: [^ \t]+$/.test(l));
 		});
 		if (lines.length > 0)
-			self.gotoState('findkids');
+			S.gotoState('findkids');
 	});
-	on(this.zk_kid, 'close', function (code) {
+	S.on(this.zk_kid, 'close', function (code) {
 		self.zk_lastError = new Error('Exited with status ' + code);
-		self.gotoState('error');
+		S.gotoState('error');
 	});
 };
 
-ZKServer.prototype.state_findkids = function (on) {
+ZKServer.prototype.state_findkids = function (S) {
 	var self = this;
 	var req = new mod_events.EventEmitter();
 
@@ -153,61 +153,61 @@ ZKServer.prototype.state_findkids = function (on) {
 			req.emit('result', res);
 	});
 
-	on(req, 'error', function (err) {
+	S.on(req, 'error', function (err) {
 		self.zk_lastError = err;
-		self.gotoState('error');
+		S.gotoState('error');
 	});
 
-	on(req, 'result', function (res) {
+	S.on(req, 'result', function (res) {
 		self.zk_tokill = res.map(function (ps) {
 			return (parseInt(ps.pid, 10));
 		});
 		self.zk_tokill.push(self.zk_kid.pid);
-		self.gotoState('testing');
+		S.gotoState('testing');
 	});
 };
 
-ZKServer.prototype.state_testing = function (on, once, timeout) {
+ZKServer.prototype.state_testing = function (S) {
 	var self = this;
 	var cmd = this.zk_cmd.replace('zkServer', 'zkCli');
 
-	timeout(10000, function () {
+	S.timeout(10000, function () {
 		self.zk_lastError = new Error('Timeout');
-		self.gotoState('error');
+		S.gotoState('error');
 	});
 
-	timeout(1000, function () {
+	S.timeout(1000, function () {
 		var kid = mod_cproc.spawn(cmd, ['ls', '/']);
-		on(kid, 'close', function (code) {
+		S.on(kid, 'close', function (code) {
 			if (code === 0) {
-				self.gotoState('running');
+				S.gotoState('running');
 			} else {
 				self.zk_lastError = new Error(
 				    'Testing command exited with status ' +
 				    code);
-				self.gotoState('error');
+				S.gotoState('error');
 			}
 		});
 	});
 
-	on(self.zk_kid, 'close', function (code) {
+	S.on(self.zk_kid, 'close', function (code) {
 		self.zk_lastError = new Error(
 		    'Exited with status ' + code);
-		self.gotoState('error');
+		S.gotoState('error');
 	});
 };
 
-ZKServer.prototype.state_running = function (on) {
+ZKServer.prototype.state_running = function (S) {
 	var self = this;
-	on(this.zk_kid, 'close', function (code) {
+	S.on(this.zk_kid, 'close', function (code) {
 		self.zk_lastError = new Error('Exited with status ' + code);
-		self.gotoState('error');
+		S.gotoState('error');
 	});
-	on(this, 'stopAsserted', function () {
-		self.gotoState('stopping');
+	S.on(this, 'stopAsserted', function () {
+		S.gotoState('stopping');
 	});
-	on(process, 'exit', function () {
-		self.gotoState('stopping');
+	S.on(process, 'exit', function () {
+		S.gotoState('stopping');
 	});
 };
 
@@ -216,10 +216,9 @@ ZKServer.prototype.stop = function () {
 	this.emit('stopAsserted');
 };
 
-ZKServer.prototype.state_stopping = function (on) {
-	var self = this;
-	on(this.zk_kid, 'close', function (code) {
-		self.gotoState('stopped');
+ZKServer.prototype.state_stopping = function (S) {
+	S.on(this.zk_kid, 'close', function (code) {
+		S.gotoState('stopped');
 	});
 	this.zk_tokill.forEach(function (pid) {
 		console.error('zk: killing %d', pid);
