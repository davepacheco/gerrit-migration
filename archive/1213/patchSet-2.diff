commit 3fc31d96ce2206e6d7a57976649e0087d9ad78dd (refs/changes/13/1213/2)
Author: David Pacheco <dap@joyent.com>
Date:   2017-01-11T13:26:09-08:00 (2 years, 9 months ago)
    
    MORAY-280 Support SRV records in node-moray
    MORAY-381 want default values with cueballOptions
    MORAY-380 translateLegacyOptions not setting "service"
    MORAY-383 moray client log entries could include specific backend details
    MORAY-384 moray's default connection backoff need to be much less aggressive
    MORAY-385 moray tools need some cleanup
    MORAY-349 remove "backfill" command

diff --git a/CHANGES.md b/CHANGES.md
index 3ee66cb..2237a29 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,28 @@
 # Changelog
 
+## v3.0.0
+
+* [MORAY-280](http://smartos.org/bugview/MORAY-280) Support SRV records in node-moray
+* [MORAY-381](http://smartos.org/bugview/MORAY-381) want default values with cueballOptions
+* [MORAY-380](http://smartos.org/bugview/MORAY-380) translateLegacyOptions not setting "service"
+* [MORAY-383](http://smartos.org/bugview/MORAY-383) moray client log entries could include specific backend details
+* [MORAY-384](http://smartos.org/bugview/MORAY-384) moray's default connection backoff need to be much less aggressive
+* [MORAY-385](http://smartos.org/bugview/MORAY-385) moray tools need some cleanup
+* [MORAY-349](http://smartos.org/bugview/MORAY-349) remove "backfill" command
+
+**Breaking changes:**
+
+* Constructor arguments have changed.  The only change that will explicitly
+  break existing v2 consumers is that the `cueballOptions.domain` option is no
+  longer supported.  However, it's strongly recommended that all consumers
+  update their constructor arguments to support SRV-based service discovery with
+  bootstrap resolvers.  Best practices (with examples) are included in the
+  `moray(3)` manual page.  See [RFD
+  73](https://github.com/joyent/rfd/tree/master/rfd/0073) for details on the
+  reasons for the change.
+* The `backfill` command has been removed.  Use `reindexobjects` instead.
+
+
 ## v2.0.1
 
 * [MORAY-377](http://smartos.org/bugview/MORAY-377) moray client masks callers'
diff --git a/bin/backfill b/bin/backfill
deleted file mode 100755
index 3983499..0000000
--- a/bin/backfill
+++ /dev/null
@@ -1,314 +0,0 @@
-#!/usr/bin/env node
-// -*- mode: js -*-
-/**
- *
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
- *
- *
- * Backfill a bucket in moray with data for a new index column.
- *
- * When a new field is to be indexed in a Moray bucket, a new column is added
- * for that field. Moray uses the value in that column for (a) indexed searching
- * and (b) as the value for that field in gets. The problem is that the starter
- * value for that cell is *empty*, so we must backfill it from the JSON blob
- * in that row's "_value". This script does that.
- *
- * Examples:
- *      Backfill the 'name' field in the 'wf_jobs' bucket using a limit (really
- *      a batch size) of 10.
- *      $ ./backfill -i name -l 10 wf_jobs
- *
- *      Backfill the 'version' field in the 'ufds_o_smartdc' bucket, limiting
- *      the processing the rows with 'objectclass' equal to 'sdcpackage' or
- *      'sdcimage'.
- *      $ ./backfill -i version -l 50 -P objectclass=sdcpackage \
- *           -P objectclass=sdcimage ufds_o_smartdc
- */
-
-
-var p = console.log;
-var path = require('path');
-var util = require('util');
-var bunyan = require('bunyan');
-var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-var ProgressBar = require('progbar').ProgressBar;
-
-var moray = require('../lib');
-
-
-
-///--- Globals
-
-var format = util.format;
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
-});
-
-// Total number of objects to backfill
-var TOTAL = 0;
-// Number of objects we've already backfilled:
-var PROCESSED = 0;
-var START = Date.now();
-
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg) {
-        console.error(msg);
-    }
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    // "limit" here is really batch size.
-    str += ' [-v] [-h host] [-p port] [-i index] [-l batch-size] ' +
-        '[-P predicate] bucket';
-    console.error(str);
-    process.exit(1);
-}
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020,
-        indexes: [],
-        limit: 100,
-        predicates: {}
-    };
-    var parser = new getopt.BasicParser('vh:p:l:i:P:', process.argv);
-    var tmp;
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
-        switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'i':
-            tmp = option.optarg;
-            opts.indexes.push(tmp);
-            break;
-
-        case 'l':
-            opts.limit = parseInt(option.optarg, 10);
-            break;
-
-        case 'P':
-            var equal = option.optarg.indexOf('=');
-            if (equal === -1) {
-                usage('error: "-P" arg is not of the form "field=value":'
-                      + option.optarg);
-            }
-            var field = option.optarg.slice(0, equal);
-            var value = option.optarg.slice(equal + 1);
-            if (!opts.predicates[field]) {
-                opts.predicates[field] = [];
-            }
-            opts.predicates[field].push(value);
-            break;
-
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
-            break;
-
-        default:
-            process.exit(1);
-            break;
-        }
-    }
-
-    if (parser.optind() >= process.argv.length) {
-        usage('missing required argument: "bucket"');
-    }
-
-    opts.name = process.argv[parser.optind()];
-    return (opts);
-}
-
-
-var options = parseOptions();
-
-
-function backfillBucket() {
-    var client = moray.createClient({
-        mustCloseBeforeNormalProcessExit: true,
-        failFast: true,
-        host: options.host,
-        log: LOG,
-        port: options.port
-    });
-    var bar;
-
-    client.on('error', cmdutil.fail);
-    client.on('connect', function onConnect() {
-        var pred;
-        function getPredicate(cb) {
-            client.getBucket(options.name, function (err, bucket) {
-                if (err) {
-                    cb(err);
-                    return;
-                }
-                var ary = [];
-                options.indexes.forEach(function (i) {
-                    ary.push('\'%' + i + '%\'');
-                });
-                pred = 'from ' + options.name +
-                    ' where _value like any (array[' + ary.join(',') + '])';
-                Object.keys(options.predicates).forEach(function (field) {
-                    var isArray = bucket.index[field] &&
-                        bucket.index[field].type[0] == '[';
-                    var values = options.predicates[field];
-                    if (isArray) {
-                        pred += format(' and %s in (array[\'%s\'])', field,
-                            values.join('\'], array[\''));
-                    } else {
-                        pred += format(' and %s in (\'%s\')', field,
-                            values.join('\', \''));
-                    }
-                });
-                cb(null, pred);
-            });
-        }
-
-        function countObjects(cb) {
-            if (TOTAL === 0) {
-                var sql = 'select count(_id) ' + pred;
-                // console.log(sql);
-
-                var countReq = client.sql(sql);
-
-                countReq.once('error', function (err) {
-                    console.error(err.message);
-                    return (cb(err));
-                });
-
-                countReq.on('record', function (obj) {
-                    if (typeof (obj) === 'object' && obj !== null) {
-                        TOTAL = Number(obj.count);
-                        console.log('Backfilling %d records', TOTAL);
-                        bar = new ProgressBar({
-                            size: TOTAL,
-                            filename: options.name,
-                            bytes: false
-                        });
-                    }
-                });
-
-                countReq.once('end', cb);
-            } else {
-                cb();
-            }
-        }
-
-        function backfillObjects(offset, limit, cb) {
-            var done = 0;
-            var _2update = {};
-
-            function wait() {
-                if (done === limit || TOTAL === PROCESSED) {
-                    return (cb());
-                } else {
-                    return (setTimeout(wait, 1000));
-                }
-            }
-
-            var sql = 'select * ' + pred + ' order by _id limit ' + limit +
-                ' offset ' + offset;
-
-            var req = client.sql(sql);
-
-            req.once('error', function (err) {
-                console.error(err.message);
-                return (cb(err));
-            });
-
-            req.on('record', function (obj) {
-                if (obj) {
-                    _2update[obj._key] = obj;
-                }
-            });
-
-            req.on('end', function () {
-                Object.keys(_2update).forEach(function (key) {
-                    var data = JSON.parse(_2update[key]._value);
-                    var skip = true;
-                    for (var i = 0; i < options.indexes.length; i++) {
-                        // XXX Not sure about a UFDS field with multiple values.
-                        var idx = options.indexes[i];
-                        if (data.hasOwnProperty(idx) &&
-                            String(data[idx]) !== _2update[key][idx]) {
-                            skip = false;
-                            break;
-                        }
-                    }
-                    bar.advance(1);
-                    if (skip) {
-                        done += 1;
-                        PROCESSED += 1;
-                        return;
-                    }
-                    client.putObject(options.name, key, data, function (err) {
-                        done += 1;
-                        PROCESSED += 1;
-                        if (err) {
-                            bar.log('error with _key "' + key + '":'
-                                    + err.message);
-                        } else {
-                            bar.log('Updated ' + options.name
-                                    + ' record with _key "' + key + '"');
-                        }
-                    });
-                });
-                return (wait());
-            });
-
-        }
-
-        function processCb(err) {
-            if (err) {
-                console.log(err.message);
-                if (err.message ===
-                    'the underlying connection has been closed') {
-                    LOG.warn('Waiting for client to reconnect');
-                    client.once('connect', function reconnectCallback() {
-                        backfillObjects(PROCESSED, options.limit, processCb);
-                    });
-                }
-            } else if (PROCESSED < TOTAL) {
-                backfillObjects(PROCESSED, options.limit, processCb);
-            } else {
-                bar.end();
-                client.close();
-                console.log('Backfill of %d objects done (in %d seconds)',
-                            TOTAL, (Date.now() - START) / 1000);
-            }
-        }
-
-        getPredicate(function (pErr, pred_) {
-            countObjects(function (err) {
-                if (err) {
-                    console.error(err.message);
-                }
-                backfillObjects(0, options.limit, processCb);
-            });
-        });
-    });
-
-}
-
-backfillBucket();
diff --git a/bin/delbucket b/bin/delbucket
index 1440ddb..1df4abd 100755
--- a/bin/delbucket
+++ b/bin/delbucket
@@ -7,112 +7,43 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, bucket, client;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'delete a bucket from Moray',
+    'synopses': [ moraycli.commonUsage + ' BUCKET' ]
 });
 
+clientOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': '',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage
+});
 
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-h host] [-p port] bucket';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('vh:p:', process.argv);
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
-        switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
-            break;
-
-        default:
-            process.exit(1);
-            break;
-        }
-    }
-
-    if (parser.optind() >= process.argv.length)
-        usage('missing required argument: "bucket"');
-
-    opts.name = process.argv[parser.optind()];
-    return (opts);
+if (parser.optind() >= process.argv.length) {
+    cmdutil.usage('missing required argument: "bucket"');
 }
 
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
-
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
-
+bucket = process.argv[parser.optind()];
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    client.delBucket(options.name, function callback(err) {
+    client.delBucket(bucket, function callback(err) {
         if (err) {
-            console.error(err.toString());
-            process.exit(1);
+            cmdutil.fail(err);
         }
+
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/delmany b/bin/delmany
index 6a66ba7..951af26 100755
--- a/bin/delmany
+++ b/bin/delmany
@@ -7,137 +7,74 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
-var prettyPrint = true;
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, client;
+var delOptions, bucket, filter, p;
 
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'delete objects from Moray matching a filter',
+    'synopses': [
+        moraycli.commonUsage + ' [-l limit] [-o offset] BUCKET FILTER'
+    ]
 });
 
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-l limit] [-o offset] [-h host] [-p port] bucket filter';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020,
-        sort: {}
-    };
-    var parser = new getopt.BasicParser('vh:l:o:p:', process.argv);
-    var tmp;
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
+clientOptions = {};
+delOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': 'l:o:',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage,
+    'onOption': function (option) {
         switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
         case 'l':
-            opts.limit = parseInt(option.optarg, 10);
+            p = parseInt(option.optarg, 10);
+            if (isNaN(p) || p < 0) {
+                cmdutil.usage('unsupported value for -l: "%s"', option.optarg);
+            }
+            delOptions.limit = p;
             break;
 
         case 'o':
-            opts.offset = parseInt(option.optarg, 10);
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
+            p = parseInt(option.optarg, 10);
+            if (isNaN(p) || p < 0) {
+                cmdutil.usage('unsupported value for -o: "%s"', option.optarg);
+            }
+            delOptions.offset = p;
             break;
 
         default:
-            process.exit(1);
+            cmdutil.usage();
             break;
         }
     }
+});
 
-    if (parser.optind() >= process.argv.length)
-        usage('missing required arguments: "bucket"');
-    if ((parser.optind() + 1) >= process.argv.length)
-        usage('missing required arguments: "filter"');
-
-    tmp = process.argv.slice(parser.optind());
-    opts.bucket = tmp[0];
-    opts.filter = tmp[1];
-
-    return (opts);
-}
-
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
+if (parser.optind() >= process.argv.length)
+    cmdutil.usage('missing required arguments: "bucket"');
+bucket = process.argv[parser.optind()];
 
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
+if ((parser.optind() + 1) >= process.argv.length)
+    cmdutil.usage('missing required arguments: "filter"');
+filter = process.argv[parser.optind() + 1];
 
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    var b = options.bucket;
-    var f = options.filter;
-    var o = {
-        limit: options.limit,
-        offset: options.offset,
-        sort: options.sort
-    };
-
-    client.deleteMany(b, f, o, function (err, meta) {
+    client.deleteMany(bucket, filter, delOptions, function (err, meta) {
         if (err) {
-            console.error(err.message);
-            process.exit(1);
+            cmdutil.fail(err);
         }
 
         console.log(meta.count + ' records deleted');
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/delobject b/bin/delobject
index f304fa9..6334197 100755
--- a/bin/delobject
+++ b/bin/delobject
@@ -7,123 +7,47 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, client;
+var bucket, key;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'delete an object from Moray by key',
+    'synopses': [ moraycli.commonUsage + ' BUCKET KEY' ]
 });
 
+clientOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': '',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage
+});
 
+if (parser.optind() >= process.argv.length)
+    cmdutil.usage('missing required arguments: "bucket"');
+bucket = process.argv[parser.optind()];
 
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-s] [-h host] [-p port] bucket key';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('vsh:p:', process.argv);
-    var tmp;
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
-        switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 's':
-            opts.noCache = true;
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
-            break;
-
-        default:
-            process.exit(1);
-            break;
-        }
-    }
-
-    if (parser.optind() >= process.argv.length)
-        usage('missing required arguments: "bucket"');
-    if ((parser.optind() + 1) >= process.argv.length)
-        usage('missing required arguments: "key"');
-
-    tmp = process.argv.slice(parser.optind());
-    opts.bucket = tmp[0];
-    opts.key = tmp[1];
-
-    return (opts);
-}
-
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
-
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
+if ((parser.optind() + 1) >= process.argv.length)
+    cmdutil.usage('missing required arguments: "key"');
+key = process.argv[parser.optind() + 1];
 
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    client.delObject(options.bucket, options.key, function callback(err, obj) {
+    client.delObject(bucket, key, function callback(err, obj) {
         if (err) {
-            console.error(err.message);
-            process.exit(1);
+            cmdutil.fail(err);
         }
 
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/findobjects b/bin/findobjects
index 975a538..3b27514 100755
--- a/bin/findobjects
+++ b/bin/findobjects
@@ -7,156 +7,103 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
-var prettyPrint = true;
-
+var moraycli = require('../lib/cmd');
 
-///--- Globals
+var clientOptions, parser, client;
+var findOptions, bucket, filter, p;
+var prettyPrint = true;
 
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'fetch objects from Moray matching a filter',
+    'synopses': [
+        moraycli.commonUsage + '[-Hns] [-a attr] [-d attr] [-l limit] ' +
+            '[-o offset] BUCKET FILTER'
+    ]
 });
 
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-H] [-a attr] [-d attr] [-l limit] [-o offset] ' +
-        '[-h host] [-p port] [-s] [-n] bucket filter';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020,
-        sort: {}
-    };
-    var parser = new getopt.BasicParser('nsva:d:Hh:l:o:p:', process.argv);
-    var tmp;
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
+clientOptions = {};
+findOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': 'a:d:Hl:no:s',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage,
+    'onOption': function (option) {
         switch (option.option) {
         case 'a':
-            opts.sort.attribute = option.optarg;
-            opts.sort.order = 'ASC';
+            findOptions.sort = {
+                'order': 'ASC',
+                'attribute': option.optarg
+            };
             break;
 
         case 'd':
-            opts.sort.attribute = option.optarg;
-            opts.sort.order = 'DESC';
+            findOptions.sort = {
+                'order': 'DESC',
+                'attribute': option.optarg
+            };
             break;
 
         case 'H':
             prettyPrint = false;
             break;
 
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
         case 'l':
-            opts.limit = parseInt(option.optarg, 10);
+            p = parseInt(option.optarg, 10);
+            if (isNaN(p) || p < 0) {
+                cmdutil.usage('unsupported value for -l: "%s"', option.optarg);
+            }
+            findOptions.limit = p;
             break;
 
         case 'n':
-            opts.no_count = true;
+            findOptions.no_count = true;
             break;
 
         case 'o':
-            opts.offset = parseInt(option.optarg, 10);
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
+            p = parseInt(option.optarg, 10);
+            if (isNaN(p) || p < 0) {
+                cmdutil.usage('unsupported value for -o / --offset: "%s"',
+                    option.optarg);
+            }
+            findOptions.offset = p;
             break;
 
         case 's':
-            opts.sql_only = true;
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
+            findOptions.sql_only = true;
             break;
 
         default:
-            process.exit(1);
+            cmdutil.usage();
             break;
         }
     }
+});
 
-    if (parser.optind() >= process.argv.length)
-        usage('missing required arguments: "bucket"');
-    if ((parser.optind() + 1) >= process.argv.length)
-        usage('missing required arguments: "filter"');
-
-    tmp = process.argv.slice(parser.optind());
-    opts.bucket = tmp[0];
-    opts.filter = tmp[1];
-
-    return (opts);
-}
-
+if (parser.optind() >= process.argv.length)
+    cmdutil.usage('missing required arguments: "bucket"');
+bucket = process.argv[parser.optind()];
 
+if ((parser.optind() + 1) >= process.argv.length)
+    cmdutil.usage('missing required arguments: "filter"');
+filter = process.argv[parser.optind() + 1];
 
-///--- Mainline
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
+client.on('connect', function onConnect() {
+    var req;
 
-var client;
-var options = parseOptions();
+    req = client.findObjects(bucket, filter, findOptions);
 
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
+    req.on('error', cmdutil.fail);
 
-client.on('connect', function onConnect() {
-    var req = client.findObjects(options.bucket,
-                                 options.filter,
-                                 {
-                                     limit: options.limit,
-                                     no_count: options.no_count,
-                                     offset: options.offset,
-                                     sort: options.sort,
-                                     sql_only: options.sql_only
-                                 });
-    req.on('error', function (err) {
-        console.error(err.message);
-        process.exit(1);
-    });
     req.on('record', function (obj) {
         if (prettyPrint)
             console.log(JSON.stringify(obj, null, 2));
@@ -168,5 +115,3 @@ client.on('connect', function onConnect() {
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/getbucket b/bin/getbucket
index c762133..8597bee 100755
--- a/bin/getbucket
+++ b/bin/getbucket
@@ -7,114 +7,47 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, bucket, client;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'fetch bucket information from Moray',
+    'synopses': [ moraycli.commonUsage + ' BUCKET' ]
 });
 
+clientOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': '',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage
+});
 
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-h host] [-p port] bucket';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('vh:p:', process.argv);
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
-        switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
-            break;
-
-        default:
-            process.exit(1);
-            break;
-        }
-    }
-
-    if (parser.optind() >= process.argv.length)
-        usage('missing required argument: "bucket"');
-
-    opts.name = process.argv[parser.optind()];
-    return (opts);
+if (parser.optind() >= process.argv.length) {
+    cmdutil.usage('missing required argument: "bucket"');
 }
+bucket = process.argv[parser.optind()];
 
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
-
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
-
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    client.getBucket(options.name, function callback(err, b) {
+    client.getBucket(bucket, function callback(err, b) {
         if (err) {
-            console.error(err.message);
-            process.exit(1);
+            cmdutil.fail(err);
         }
 
         b.pre = (b.pre || []).map(function (f) {
             return (f.toString());
         });
+
         b.post = (b.post || []).map(function (f) {
             return (f.toString());
         });
@@ -123,5 +56,3 @@ client.on('connect', function onConnect() {
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/getobject b/bin/getobject
index 4462cce..d498a4d 100755
--- a/bin/getobject
+++ b/bin/getobject
@@ -7,134 +7,70 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, client;
+var bucket, key, getOptions;
 var prettyPrint = true;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'fetch an object from Moray by key',
+    'synopses': [ moraycli.commonUsage + ' [-Hs] BUCKET KEY' ]
 });
 
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-s] [-H] [-h host] [-p port] bucket key';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('vsHh:p:', process.argv);
-    var tmp;
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
+clientOptions = {};
+getOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': 'Hs',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage,
+    'onOption': function (option) {
         switch (option.option) {
         case 'H':
             prettyPrint = false;
             break;
 
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
         case 's':
-            opts.noCache = true;
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
+            getOptions.noCache = true;
             break;
 
         default:
-            process.exit(1);
+            cmdutil.usage();
             break;
         }
     }
+});
 
-    if (parser.optind() >= process.argv.length)
-        usage('missing required arguments: "bucket"');
-    if ((parser.optind() + 1) >= process.argv.length)
-        usage('missing required arguments: "key"');
-
-    tmp = process.argv.slice(parser.optind());
-    opts.bucket = tmp[0];
-    opts.key = tmp[1];
-
-    return (opts);
-}
-
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
+if (parser.optind() >= process.argv.length)
+    cmdutil.usage('missing required arguments: "bucket"');
+bucket = process.argv[parser.optind()];
 
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
+if ((parser.optind() + 1) >= process.argv.length)
+    cmdutil.usage('missing required arguments: "key"');
+key = process.argv[parser.optind() + 1];
 
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    client.getObject(options.bucket, options.key, { noCache: options.noCache },
-        function callback(err, obj) {
-            if (err) {
-                console.error(err.message);
-                process.exit(1);
-            }
+    client.getObject(bucket, key, getOptions, function callback(err, obj) {
+        if (err) {
+            cmdutil.fail(err);
+        }
 
-            if (prettyPrint) {
-                console.log(JSON.stringify(obj, null, 2));
-            } else {
-                console.log(JSON.stringify(obj));
-            }
-            client.close();
-        });
-});
+        if (prettyPrint) {
+            console.log(JSON.stringify(obj, null, 2));
+        } else {
+            console.log(JSON.stringify(obj));
+        }
 
-client.on('error', cmdutil.fail);
+        client.close();
+    });
+});
diff --git a/bin/gettokens b/bin/gettokens
index 508be20..5c5ee5c 100755
--- a/bin/gettokens
+++ b/bin/gettokens
@@ -7,110 +7,40 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, client;
+var bucket, key;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'fetch list of shards from electric-moray',
+    'synopses': [ moraycli.commonUsage ]
 });
 
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-h host] [-p port]';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('vh:p:', process.argv);
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
-        switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
-            break;
-
-        default:
-            process.exit(1);
-            break;
-        }
-    }
-
-    return (opts);
-}
-
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
-
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
+clientOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': '',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage
 });
 
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
     client.getTokens(function callback(err, b) {
         if (err) {
-            console.error(err.message);
-            process.exit(1);
+            cmdutil.fail(err);
         }
 
         console.log(JSON.stringify(b, null, 2));
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/listbuckets b/bin/listbuckets
index fee34c8..f3e9a1b 100755
--- a/bin/listbuckets
+++ b/bin/listbuckets
@@ -7,105 +7,37 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, client;
+var bucket, key;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'fetch all bucket information from Moray',
+    'synopses': [ moraycli.commonUsage ]
 });
 
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-h host] [-p port]';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('vh:p:', process.argv);
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
-        switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
-            break;
-
-        default:
-            process.exit(1);
-            break;
-        }
-    }
-
-    return (opts);
-}
-
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
-
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
+clientOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': '',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage
 });
 
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
     client.listBuckets(function callback(err, b) {
         if (err) {
-            console.error(err.message);
-            process.exit(1);
+            cmdutil.fail(err);
         }
 
         b.pre = (b.pre || []).map(function (f) {
@@ -119,5 +51,3 @@ client.on('connect', function onConnect() {
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/morayping b/bin/morayping
index 3e9bee2..39ca052 100755
--- a/bin/morayping
+++ b/bin/morayping
@@ -7,117 +7,56 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, client, pingOptions, failFast;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'check whether Moray is online',
+    'synopses': [ moraycli.commonUsage + ' -dF' ]
 });
 
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-h host] [-p port] statement';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020,
-        failFast: true
-    };
-    var parser = new getopt.BasicParser('vdFh:p:', process.argv);
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
+clientOptions = {};
+pingOptions = {};
+failFast = true;
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': 'dF',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage,
+    'onOption': function (option) {
         switch (option.option) {
         case 'd':
-            opts.deep = true;
+            pingOptions.deep = true;
             break;
 
         case 'F':
-            opts.failFast = false;
-            break;
-
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
+            failFast = false;
             break;
 
         default:
-            usage('invalid option: ' + option.option);
+            cmdutil.usage();
             break;
         }
     }
-
-    return (opts);
-}
-
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
-
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: options.failFast,
-    host: options.host,
-    log: LOG,
-    port: options.port
 });
 
+clientOptions.failFast = failFast;
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    client.ping({deep: options.deep, log: LOG}, function callback(err) {
+    client.ping(pingOptions, function callback(err) {
         if (err) {
-            console.error(err.toString());
-            process.exit(1);
+            cmdutil.fail(err);
         }
+
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/morayversion b/bin/morayversion
index 86e2194..aa065a0 100755
--- a/bin/morayversion
+++ b/bin/morayversion
@@ -1,4 +1,5 @@
 #!/usr/bin/env node
+// -*- mode: js -*-
 /*
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
@@ -6,113 +7,39 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, client;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'report the version of a Moray server',
+    'synopses': [ moraycli.commonUsage ]
 });
 
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-h host] [-p port] statement';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('vdh:p:', process.argv);
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
-        switch (option.option) {
-        case 'd':
-            opts.deep = true;
-            break;
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
-            break;
-
-        default:
-            usage('invalid option: ' + option.option);
-            break;
-        }
-    }
-
-    return (opts);
-}
-
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
-
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
+clientOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': '',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage
 });
 
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    var rqoptions = {deep: options.deep, log: LOG};
-    client.versionInternal(rqoptions, function callback(err, data) {
+    client.versionInternal(function callback(err, data) {
         if (err) {
-            console.error(err.toString());
-            process.exit(1);
+            cmdutil.fail(err);
         }
+
         console.log(data);
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/putbucket b/bin/putbucket
index 23e8222..d82f7c3 100755
--- a/bin/putbucket
+++ b/bin/putbucket
@@ -7,182 +7,134 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, client;
+var bucket, putOptions, v;
+var useStdin = false;
 
+/*
+ * Reads the bucket configuration from stdin and invokes "next" upon completion.
+ * Failure will abort the program with an appropriate message.
+ */
+function readFromStdin(next) {
+    var config;
+
+    config = '';
+    process.stdin.setEncoding('utf8');
+    process.stdin.resume();
+    process.stdin.on('data', function (chunk) {
+        config += chunk;
+    });
 
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
-});
-
-
-
-///--- Functions
+    process.stdin.on('end', function () {
+        function evalFn(f) {
+            var fn;
+            fn = eval('fn = ' + f);
+            return (fn);
+        }
 
-function usage(msg) {
-    if (msg)
-        console.error(msg);
+        config = JSON.parse(config);
+        config.pre = (config.pre || []).map(evalFn);
+        config.post = (config.post || []).map(evalFn);
+        putOptions = config;
+        next();
+    });
+}
 
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-h host] [-p port] [-i index] [-u index] [-s] name\n';
-    str += 'indexes are of the form "name:type"';
-    console.error(str);
-    process.exit(1);
+/*
+ * Executes the body of this command: connects to Moray and invokes putBucket().
+ */
+function putBucket() {
+    client = moray.createClient(clientOptions);
+    client.on('error', cmdutil.fail);
+    client.on('connect', function onConnect() {
+        client.putBucket(bucket, putOptions, function callback(err) {
+            if (err) {
+                cmdutil.fail(err);
+            }
+            client.close();
+        });
+    });
 }
 
+/*
+ * Parse (and apply) the "-i" or "-u" command-line option.
+ */
+function addIndex(indexObj, arg, unique) {
+    var tmp;
 
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020,
-        index: {},
-        options: {}
+    tmp = arg.split(':', 2);
+    indexObj[tmp[0]] = {
+        type: tmp[1] || 'string',
+        unique: unique
     };
-    var parser = new getopt.BasicParser('svti:h:p:u:x:', process.argv);
-    var tmp;
+}
 
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
+cmdutil.configure({
+    'usageMessage': 'create or update a Moray bucket',
+    'synopses': [ [
+        moraycli.commonUsage, '[-i field:type ...]', '[-u field:type ...]',
+        '[-x version]', '[-st]', 'BUCKET'
+    ].join(' ') ]
+});
 
-    while ((option = parser.getopt()) !== undefined && !option.error) {
+clientOptions = {};
+putOptions = {
+    'index': {},
+    'options': {}
+};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': 'i:stu:x:',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage,
+    'onOption': function (option) {
         switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
         case 'i':
-            tmp = option.optarg.split(':');
-            opts.index[tmp[0]] = {
-                type: tmp[1] || 'string',
-                unique: false
-            };
-            break;
-
-        case 'n':
-            opts.name = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
+            addIndex(putOptions.index, option.optarg, false);
             break;
 
         case 's':
-            opts.stdin = true;
+            useStdin = true;
             break;
 
         case 't':
-            opts.options.trackModification = true;
+            putOptions.options.trackModification = true;
             break;
 
         case 'u':
-            tmp = option.optarg.split(':');
-            opts.index[tmp[0]] = {
-                type: tmp[1] || 'string',
-                unique: true
-            };
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
+            addIndex(putOptions.index, option.optarg, true);
             break;
 
         case 'x':
-            opts.options.version = parseInt(option.optarg, 10);
+            v = parseInt(option.optarg, 10);
+            if (isNaN(v) || v < 0) {
+                cmdutil.usage('unsupported value for -x: "%s"', option.optarg);
+            }
+            putOptions.options.version = v;
             break;
 
         default:
-            process.exit(1);
+            cmdutil.usage();
             break;
         }
     }
+});
 
-    if (parser.optind() >= process.argv.length)
-        usage('missing required argument: "name"');
-    tmp = process.argv.slice(parser.optind());
-    opts.name = tmp[0];
-
-    if (opts.stdin) {
-        opts.config = '';
-        process.stdin.setEncoding('utf8');
-        process.stdin.resume();
-        process.stdin.on('data', function (chunk) {
-            opts.config += chunk;
-        });
-
-        process.stdin.on('end', function () {
-            function evalFn(f) {
-                var fn;
-                fn = eval('fn = ' + f);
-                return (fn);
-            }
-            opts.config = JSON.parse(opts.config);
-            opts.config.pre = (opts.config.pre || []).map(evalFn);
-            opts.config.post = (opts.config.post || []).map(evalFn);
-        });
-    }
-
-    return (opts);
-}
-
-
-
-function putBucket() {
-    var client = moray.createClient({
-        mustCloseBeforeNormalProcessExit: true,
-        failFast: true,
-        host: options.host,
-        log: LOG,
-        port: options.port
-    });
-    var cfg = options.config || {
-        index: options.index,
-        options: options.options
-    };
-    client.on('connect', function onConnect() {
-        client.putBucket(options.name, cfg, function callback(err) {
-            if (err) {
-                console.error(err.message);
-                process.exit(1);
-            }
-            client.close();
-        });
-    });
-
-    client.on('error', cmdutil.fail);
-}
-
-
-
-///--- Mainline
+if (parser.optind() >= process.argv.length)
+    cmdutil.usage('missing required argument: "bucket"');
+bucket = process.argv[parser.optind()];
 
-var options = parseOptions();
-if (options.stdin) {
-    process.stdin.on('end', function () {
-        process.nextTick(putBucket);
-    });
+if (useStdin) {
+    readFromStdin(putBucket);
 } else {
     putBucket();
 }
diff --git a/bin/putobject b/bin/putobject
index b0ad553..d40af27 100755
--- a/bin/putobject
+++ b/bin/putobject
@@ -7,128 +7,70 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
+var VError = require('verror');
 
+var clientOptions, parser, client;
+var bucket, key, value, putOptions;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'create or update an object in Moray',
+    'synopses': [ moraycli.commonUsage + ' [-d DATA] [-e ETAG] ' +
+        'BUCKET KEY' ]
 });
 
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-e etag] [-h host] [-p port] [-d data] bucket key';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('ve:h:p:d:', process.argv);
-    var tmp;
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
+clientOptions = {};
+putOptions = {};
+value = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': 'd:e:',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage,
+    'onOption': function (option) {
         switch (option.option) {
-        case 'e':
-            opts.etag = option.optarg;
-            break;
-
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
         case 'd':
-            opts.data = JSON.parse(option.optarg);
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
+            try {
+                value = JSON.parse(option.optarg);
+            } catch (ex) {
+                cmdutil.fail(new VError(ex, 'parsing value for -d'));
+            }
             break;
 
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
+        case 'e':
+            putOptions.etag = option.optarg;
             break;
 
         default:
-            process.exit(1);
+            cmdutil.usage();
             break;
         }
     }
+});
 
-    if (parser.optind() >= process.argv.length)
-        usage('missing required arguments: "bucket"');
-    if ((parser.optind() + 1) >= process.argv.length)
-        usage('missing required arguments: "key"');
-
-    tmp = process.argv.slice(parser.optind());
-    opts.bucket = tmp[0];
-    opts.key = tmp[1];
-
-    return (opts);
-}
-
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
+if (parser.optind() >= process.argv.length)
+    cmdutil.usage('missing required arguments: "bucket"');
+bucket = process.argv[parser.optind()];
 
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
+if ((parser.optind() + 1) >= process.argv.length)
+    cmdutil.usage('missing required arguments: "key"');
+key = process.argv[parser.optind() + 1];
 
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    client.putObject(options.bucket, options.key, options.data || {},
-        options.etag ? { 'etag': options.etag } : {}, function callback(err) {
-            if (err) {
-                console.error(err.message);
-                process.exit(1);
-            }
+    client.putObject(bucket, key, value, putOptions, function callback(err) {
+        if (err) {
+            cmdutil.fail(err);
+        }
 
-            client.close();
-        });
+        client.close();
+    });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/reindexobjects b/bin/reindexobjects
index a607997..4f8eb9b 100755
--- a/bin/reindexobjects
+++ b/bin/reindexobjects
@@ -7,155 +7,83 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-var vasync = require('vasync');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
-var prettyPrint = true;
-
+var clientOptions, parser, client;
+var bucket, count;
 
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'reindex objects in a Moray bucket',
+    'synopses': [ moraycli.commonUsage + ' BUCKET [COUNT]' ]
 });
 
+clientOptions = {};
+count = 100;
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': '',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage
+});
 
+if (parser.optind() >= process.argv.length)
+    cmdutil.usage('missing required arguments: "bucket"');
+bucket = process.argv[parser.optind()];
 
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-s] [-H] [-h host] [-p port] bucket [count]';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('vsHh:p:', process.argv);
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
-        switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
-            break;
-
-        default:
-            process.exit(1);
-            break;
-        }
+if (parser.optind() + 1 < process.argv.length) {
+    count = parseInt(process.argv[parser.optind() + 1], 10);
+    if (isNaN(count) || count <= 0) {
+        cmdutil.usage('unsupported value for COUNT: "%s"',
+            process.argv[parser.optind() + 1]);
     }
-
-    if (parser.optind() >= process.argv.length)
-        usage('missing required arguments: "bucket"');
-
-    var tmp = process.argv.slice(parser.optind());
-    opts.bucket = tmp[0];
-    opts.count = parseInt(tmp[1], 10) | 100;
-
-    return (opts);
 }
 
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
-
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
-
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    function checkBucket(cb) {
-        client.getBucket(options.bucket, function (err, bucket) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            if (!bucket.reindex_active ||
-                Object.keys(bucket.reindex_active).length === 0) {
-                // reindexing not require (or already complete)
-                client.close();
-                process.exit(0);
-            }
-            cb();
-        });
-    }
-    function reindexLoop(cb) {
-        client.reindexObjects(options.bucket, options.count,
-            function (err, res) {
-            if (err) {
-                cb(err);
-                return;
-            }
-            LOG.info(res, 'reindex');
-            if (res.processed === 0) {
-                cb();
-            } else {
-                process.nextTick(reindexLoop.bind(null, cb));
-            }
-        });
-    }
-
-    checkBucket(function (err) {
+    client.getBucket(bucket, function (err, bucketinfo) {
         if (err) {
-            console.error(err.message);
-            process.exit(1);
+            cmdutil.fail(err);
+            return;
         }
-        reindexLoop(function (err2) {
-            if (err2) {
-                console.error(err2.message);
-                process.exit(1);
-            }
-            client.once('close', process.exit.bind(process, 0));
+
+        if (!bucketinfo.reindex_active ||
+            Object.keys(bucketinfo.reindex_active).length === 0) {
+            console.error('bucket "%s": no reindexing required', bucket);
             client.close();
-        });
+        } else {
+            reindexLoop(function (err2) {
+                if (err2) {
+                    cmdutil.fail(err2);
+                }
+
+                client.close();
+            });
+        }
     });
 });
 
-client.on('error', cmdutil.fail);
+function reindexLoop(cb) {
+    client.reindexObjects(bucket, count, function (err, res) {
+        if (err) {
+            cb(err);
+            return;
+        }
+
+        if (res.processed === 0) {
+            console.error('bucket "%s": all objects processed', bucket);
+            cb();
+        } else {
+            console.error('bucket "%s": %d object%s processed (continuing)',
+                bucket, res.processed, res.processed == 1 ? '' : 's');
+            reindexLoop(cb);
+        }
+    });
+}
diff --git a/bin/sql b/bin/sql
index 1396d48..4656c0c 100755
--- a/bin/sql
+++ b/bin/sql
@@ -7,114 +7,41 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
 
+var clientOptions, parser, sql, client;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'execute raw SQL on Moray-backed database',
+    'synopses': [ moraycli.commonUsage + ' SQL' ]
 });
 
+clientOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': '',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage
+});
 
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-h host] [-p port] statement';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020
-    };
-    var parser = new getopt.BasicParser('vh:p:', process.argv);
-    var tmp;
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
-        switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
-            break;
-
-        default:
-            usage('invalid option: ' + option.option);
-            break;
-        }
-    }
-
-    if (parser.optind() >= process.argv.length)
-        usage('missing required arguments: "statement"');
-
-    tmp = process.argv.slice(parser.optind());
-    opts.statement = tmp[0];
-
-    return (opts);
+if (parser.optind() >= process.argv.length) {
+    cmdutil.usage('missing required argument: "sql"');
 }
 
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
-
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
-
+sql = process.argv[parser.optind()];
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    var req = client.sql(options.statement);
+    var req = client.sql(sql);
 
-    req.once('error', function (err) {
-        console.error(err.message);
-        process.exit(1);
-    });
+    req.once('error', cmdutil.fail);
 
     req.on('record', function (obj) {
         if (typeof (obj) === 'object' && obj !== null)
@@ -125,5 +52,3 @@ client.on('connect', function onConnect() {
         client.close();
     });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/bin/updatemany b/bin/updatemany
index f13eaa9..91e024d 100755
--- a/bin/updatemany
+++ b/bin/updatemany
@@ -7,129 +7,75 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
-var path = require('path');
-var url = require('url');
-
-var bunyan = require('bunyan');
 var cmdutil = require('cmdutil');
-var getopt = require('posix-getopt');
-
 var moray = require('../lib');
+var moraycli = require('../lib/cmd');
+var VError = require('verror');
 
+var clientOptions, parser, client;
+var updateOptions, bucket, filter, changes, p;
 
-
-///--- Globals
-
-var LOG = bunyan.createLogger({
-    name: path.basename(process.argv[1]),
-    level: (process.env.LOG_LEVEL || 'fatal'),
-    stream: process.stderr,
-    serializers: bunyan.stdSerializers
+cmdutil.configure({
+    'usageMessage': 'update objects in Moray matching a filter',
+    'synopses': [ moraycli.commonUsage + '[-d data] [-l limit] BUCKET FILTER' ]
 });
 
-
-
-///--- Functions
-
-function usage(msg) {
-    if (msg)
-        console.error(msg);
-
-    var str = 'usage: ' + path.basename(process.argv[1]);
-    str += '[-v] [-h host] [-p port] [-d data] bucket filter';
-    console.error(str);
-    process.exit(1);
-}
-
-
-function parseOptions() {
-    var option;
-    var opts = {
-        host: '127.0.0.1',
-        port: 2020,
-        options: {}
-    };
-    var parser = new getopt.BasicParser('vh:l:p:d:', process.argv);
-    var tmp;
-
-    if (process.env['MORAY_URL']) {
-        var u = url.parse(process.env['MORAY_URL']);
-        opts.host = u['hostname'] || opts.host;
-        opts.port = parseInt(u['port'], 10) || opts.port;
-    }
-
-    while ((option = parser.getopt()) !== undefined && !option.error) {
+clientOptions = {};
+changes = {};
+updateOptions = {};
+parser = moraycli.parseCliOptions({
+    'argv': process.argv,
+    'env': process.env,
+    'errstream': process.stderr,
+    'extraOptStr': 'd:l:',
+    'clientOptions': clientOptions,
+    'onUsage': cmdutil.usage,
+    'onOption': function (option) {
         switch (option.option) {
-        case 'h':
-            opts.host = option.optarg;
-            break;
-
         case 'd':
-            opts.data = JSON.parse(option.optarg);
+            try {
+                changes = JSON.parse(option.optarg);
+            } catch (ex) {
+                cmdutil.fail(new VError(ex, 'parsing value for -d'));
+            }
             break;
 
         case 'l':
-            opts.options.limit = parseInt(option.optarg, 10);
-            break;
-
-        case 'p':
-            opts.port = parseInt(option.optarg, 10);
-            break;
-
-        case 'v':
-            // Allows us to set -vvv -> this little hackery
-            // just ensures that we're never < TRACE
-            LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
-            if (LOG.level() <= bunyan.DEBUG)
-                LOG = LOG.child({src: true});
+            p = parseInt(option.optarg, 10);
+            if (isNaN(p) || p < 0) {
+                cmdutil.usage('unsupported value for -l: "%s"', option.optarg);
+            }
+            updateOptions.limit = p;
             break;
 
         default:
-            process.exit(1);
+            cmdutil.usage();
             break;
         }
     }
+});
 
-    if (parser.optind() >= process.argv.length)
-        usage('missing required arguments: "bucket"');
-    if ((parser.optind() + 1) >= process.argv.length)
-        usage('missing required arguments: "filter"');
-
-    tmp = process.argv.slice(parser.optind());
-    opts.bucket = tmp[0];
-    opts.filter = tmp[1];
-
-    return (opts);
-}
-
-
-
-///--- Mainline
-
-var client;
-var options = parseOptions();
+if (parser.optind() >= process.argv.length)
+    cmdutil.usage('missing required arguments: "bucket"');
+bucket = process.argv[parser.optind()];
 
-client = moray.createClient({
-    mustCloseBeforeNormalProcessExit: true,
-    failFast: true,
-    host: options.host,
-    log: LOG,
-    port: options.port
-});
+if ((parser.optind() + 1) >= process.argv.length)
+    cmdutil.usage('missing required arguments: "filter"');
+filter = process.argv[parser.optind() + 1];
 
+client = moray.createClient(clientOptions);
+client.on('error', cmdutil.fail);
 client.on('connect', function onConnect() {
-    client.updateObjects(options.bucket, options.data || {}, options.filter,
-        options.options, function callback(err, meta) {
+    client.updateObjects(bucket, changes, filter, updateOptions,
+        function callback(err, meta) {
             if (err) {
-                console.error(err.message);
-                process.exit(1);
+                cmdutil.fail(err);
             }
+
             console.log(meta);
             client.close();
         });
 });
-
-client.on('error', cmdutil.fail);
diff --git a/lib/client.js b/lib/client.js
index 89c935a..424697c 100644
--- a/lib/client.js
+++ b/lib/client.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -30,23 +30,13 @@ var buckets = require('./buckets');
 var meta = require('./meta');
 var objects = require('./objects');
 var tokens = require('./tokens');
+var parseMorayParameters = require('./client_params').parseMorayParameters;
 
 
 ///--- Default values for function arguments
 
-var dflClientTargetConnections = 6;
-var dflClientMaxConnections = 15;
-var dflClientMaxDnsConcurrency = 3;
-var dflClientConnectRetries = 5;
-var dflClientConnectTimeout = 2000;     /* milliseconds */
-var dflClientDnsTimeout = 1000;         /* milliseconds */
-var dflClientDnsDelayMin = 10;          /* milliseconds */
-var dflClientDnsDelayMax = 10000;       /* milliseconds */
-var dflClientDelayMin = 1000;           /* milliseconds */
-var dflClientDelayMax = 60000;          /* milliseconds */
-
-var fastNRecentRequests = 30;
-var dflClientTcpKeepAliveIdle = 10000;  /* milliseconds */
+var fastNRecentRequests         = 30;
+var dflClientTcpKeepAliveIdle   = 10000;  /* milliseconds */
 
 /*
  * See MorayClient() constructor.
@@ -66,248 +56,6 @@ function emitUnavailable() {
     return (emitter);
 }
 
-/*
- * This function constructs a set of node-cueball arguments based on legacy
- * properties accepted by the MorayClient constructor.  Those properties
- * included the following required properties:
- *
- *     url               string describing the URL (host and port) to connect to
- *
- * or:
- *
- *     host              string IP address or DNS name for remote Moray service.
- *                       If this is an IP address, then DNS is not used.
- *                       Otherwise, the string is used as a DNS name to find the
- *                       actual IP addresses, and this list of IPs is maintained
- *                       via periodic re-resolution of the DNS name.
- *
- *     port              positive integer: TCP port for remote Moray service
- *
- * and the following optional properties that, if not specified, have defaults
- * that are assumed to be reasonable:
- *
- *     connectTimeout    non-negative, integer number of milliseconds
- *                       to wait for TCP connections to be established
- *
- *     dns (object)      describes DNS behavior
- *
- *     dns.checkInterval non-negative, integer number of milliseconds
- *                       between periodic resolution of DNS names used to keep
- *                       the set of connected IPs up to date.  This is not used
- *                       by cueball any more.
- *
- *     dns.resolvers     array of string IP addresses to use for DNS resolvers
- *
- *     dns.timeout       non-negative, integer number of milliseconds to wait
- *                       for DNS query responses
- *
- *     maxConnections    non-negative, integer number of TCP connections that
- *                       may ever be opened to each IP address used.  If "host"
- *                       is an IP address, then this is the maximum number of
- *                       connections, but if "host" is a DNS name, then there
- *                       may be up to "maxConnections" per remote IP found in
- *                       DNS.
- *
- *     retry (object)    describes a retry policy used for establishing
- *                       connections.  Historically, the behavior with respect
- *                       to this policy was confusing at best: this policy was
- *                       used for establishing TCP connections to remote
- *                       servers, but a second, hardcoded policy was used when
- *                       this first policy was exhausted.  This policy appears
- *                       to have been intended to cover DNS operations as well,
- *                       but was not actually used.  In the current
- *                       implementation, this policy is the one used for TCP
- *                       connection establishment, and callers wanting to
- *                       specify a DNS policy must specify cueball options
- *                       directly rather than using these legacy options.
- *
- *     retry.retries     non-negative, integer number of retry attempts.  It's
- *                       unspecified whether this is the number of attempts or
- *                       the number of retries (i.e., one fewer than the number
- *                       of attempts).  Today, this is interpreted by
- *                       node-cueball.  Historically, this was interpreted by
- *                       the node-backoff module.
- *
- *     retry.minTimeout  non-negative, integer number of milliseconds to wait
- *                       after the first operation failure before retrying
- *
- *     retry.maxTimeout  non-negative, integer representing the maximum number
- *                       of milliseconds between retries.  Some form of backoff
- *                       (likely exponential) is used to determine the delay,
- *                       but it will always be between retry.minTimeout and
- *                       retry.maxTimeout.
- *
- * Additional properties were at one time documented, but never used:
- * maxIdleTime and pingTimeout.
- */
-function translateLegacyOptions(options) {
-    var cueballOptions, r, u;
-    var host, port;
-
-    /*
-     * This logic mirrors the legacy behavior of createClient, however
-     * unnecessarily complicated.  Specifically:
-     *
-     *     host     comes from "options.host" if present, and otherwise from
-     *              parsing "options.url"
-     *
-     *     port     comes from "options.port" (as a string or number) if
-     *              present.  If "host" was not present and "url" is, then
-     *              "port" MAY come from the parsed URL.  Otherwise, the port is
-     *              2020.
-     */
-    if (typeof (options.url) == 'string' && !options.hasOwnProperty('host')) {
-        u = url.parse(options.url);
-        host = u.hostname;
-
-        if (options.port) {
-            port = options.port;
-        } else if (u.port) {
-            port = u.port;
-        } else {
-            port = 2020;
-        }
-
-        port = parseInt(port, 10);
-        assert.ok(!isNaN(port), 'port must be a number');
-    } else {
-        host = options.host;
-        port = options.port;
-    }
-
-    assert.string(host, 'options.host');
-    assert.number(port, 'options.port');
-    assert.optionalNumber(options.maxConnections, 'options.maxConnections');
-    assert.optionalNumber(options.connectTimeout, 'options.connectTimeout');
-    assert.optionalObject(options.retry, 'options.retry');
-    assert.optionalObject(options.dns, 'options.dns');
-
-    cueballOptions = {
-        /* Resolver parameters */
-        'domain': host,
-        'maxDNSConcurrency': dflClientMaxDnsConcurrency,
-        'defaultPort': port,
-
-        /* ConnectionSet parameters */
-        'target': dflClientTargetConnections,
-        'maximum': options.maxConnections || dflClientMaxConnections,
-
-        /* Shared parameters */
-        'recovery': {}
-    };
-
-    if (cueballOptions.maximum < cueballOptions.target) {
-        cueballOptions.target = cueballOptions.maximum;
-    }
-
-    /*
-     * DNS configuration: The delay and maxDelay values used in the previous
-     * implementation were historically hardcoded to the same values that we use
-     * use as defaults now.
-     */
-    r = cueballOptions.recovery.dns = {
-        'retries': dflClientConnectRetries,
-        'timeout': dflClientDnsTimeout,
-        'delay': dflClientDnsDelayMin,
-        'maxDelay': dflClientDnsDelayMax
-    };
-
-    if (options.dns) {
-        if (Array.isArray(options.dns.resolvers)) {
-            assert.arrayOfString(options.dns.resolvers,
-                'options.dns.resolvers');
-            cueballOptions.resolvers = options.dns.resolvers.slice(0);
-        }
-
-        if (options.dns.timeout) {
-            assert.number(options.dns.timeout, 'options.dns.timeout');
-            assert.ok(options.dns.timeout >= 0,
-                'dns timeout must be non-negative');
-            r.timeout = options.dns.timeout;
-        }
-    }
-
-    /*
-     * Right or wrong, the legacy behavior was that the timeout for each
-     * request never increased.
-     */
-    r.maxTimeout = r.timeout;
-
-    /*
-     * DNS SRV configuration: SRV should fail fast, since it's not widely
-     * deployed yet.
-     */
-    cueballOptions.recovery.dns_srv = jsprim.deepCopy(
-        cueballOptions.recovery.dns);
-    cueballOptions.recovery.dns_srv.retries = 0;
-
-    /*
-     * Default recovery configuration: we specify a 'default' recovery in
-     * the cueball options that will cover both the initial connect attempt
-     * and subsequent connect attempts.
-     */
-    r = cueballOptions.recovery.default = {};
-    if (typeof (options.connectTimeout) == 'number') {
-        assert.ok(options.connectTimeout >= 0,
-            'connect timeout must be non-negative');
-        r.timeout = options.connectTimeout;
-    } else {
-        r.timeout = dflClientConnectTimeout;
-    }
-
-    /*
-     * As with DNS requests, connection operations historically used a fixed
-     * timeout value.
-     */
-    r.maxTimeout = r.timeout;
-
-    if (options.retry) {
-        assert.optionalNumber(options.retry.retries, 'options.retry.retries');
-        if (typeof (options.retry.retries) == 'number') {
-            r.retries = options.retry.retries;
-        } else {
-            r.retries = dflClientConnectRetries;
-        }
-
-        /*
-         * It's confusing, but the "timeout" for a retry policy is
-         * really a delay.
-         */
-        assert.optionalNumber(options.retry.minTimeout,
-            'options.retry.minTimeout');
-        if (typeof (options.retry.minTimeout) == 'number') {
-            r.delay = options.retry.minTimeout;
-
-            if (typeof (options.retry.maxTimeout) == 'number') {
-                assert.ok(options.retry.maxTimeout >=
-                    options.retry.minTimeout,
-                    'retry.maxTimeout must not be smaller ' +
-                    'than retry.minTimeout');
-                r.maxDelay = options.retry.maxTimeout;
-            } else {
-                r.delay = options.retry.minTimeout;
-                r.maxDelay = Math.max(r.delay, dflClientDelayMax);
-            }
-        } else if (typeof (options.retry.maxTimeout) == 'number') {
-            r.maxDelay = options.retry.maxTimeout;
-            r.delay = Math.min(dflClientDelayMin, r.maxDelay);
-        } else {
-            r.delay = dflClientDelayMin;
-            r.maxDelay = dflClientDelayMax;
-        }
-
-        assert.number(r.delay);
-        assert.number(r.maxDelay);
-        assert.ok(r.delay <= r.maxDelay);
-    } else {
-        r.retries = 0;
-        r.delay = 0;
-        r.maxDelay = r.delay;
-    }
-
-    return (cueballOptions);
-}
-
 
 ///--- API
 
@@ -320,44 +68,41 @@ function translateLegacyOptions(options) {
  * appropriate TCP connections, while we maintain a small abstraction for
  * balancing requests across connections.
  *
- * The following named arguments must be specified:
+ * You MUST specify the following named argument:
  *
  *     log             bunyan-style logger
  *
- * You must also specify either:
+ * and ONE of the following:
  *
- *     cueballOptions  An object containing node-cueball configuration
- *                     parameters.  See the node-cueball documentation for
- *                     details on what these mean.  The MorayClient supports the
- *                     following properties:
+ *     srvDomain        for SRV-based backend discovery
  *
- *                         node-cueball Resolver properties: "domain",
- *                         "service", "defaultPort", "resolvers",
- *                         "maxDNSConcurrency"
+ *     url              to connect to backends with the specified hostname
+ *                      (using A records) or IP address and port
  *
- *                         node-cueball ConnectionSet properties: "target",
- *                         "maximum"
+ *     host             like URL, but with separate properties
+ *     (and optional port)
  *
- *                         properties used by both Resolver and ConnectionSet:
- *                         "recovery"
+ * You MAY also specify
  *
- *                     Other cueball parameters (like "log", "resolver",
- *                     "constructor") are supplied by the Moray client and may
- *                     not be specified here.
+ *     cueballOptions   to override cueball-related options, including various
+ *                      timeouts and delays.  For specific options that can be
+ *                      overridden here, see the comment on
+ *                      parseMorayParameters().  NOTE: it's not expected that
+ *                      most consumers would need to specify any of these.
+ *                      Default values ought to work for the port, DNS service,
+ *                      and all the various timeouts, delays, and retry limits.
  *
- * or some combination of legacy options documented with
- * translateLegacyOptions() above.  It's strongly recommended that new consumers
- * use the "cueballOptions" approach because it's much less confusing and allows
- * specifying additional important parameters.
+ * or any number of legacy options documented with populateLegacyOptions().
  *
- * You may also specify:
+ * You MAY also specify:
  *
- *     failFast         If true, this client emits "error" when the underlying
- *                      Cueball set reaches state "failed".  This is intended
- *                      for use by command-line tools to abort when it looks
- *                      like dependent servers are down.  Servers should
- *                      generally wait indefinitely for dependent services to
- *                      come up.
+ *     failFast         If true, this sets a more aggressive retry policy, and
+ *                      the client emits "error" when the underlying Cueball set
+ *                      reaches state "failed".  This is intended for use by
+ *                      command-line tools to abort when it looks like dependent
+ *                      servers are down.  Servers should generally not specify
+ *                      this option because they should wait indefinitely for
+ *                      dependent services to come up.
  *
  *     unwrapErrors     If false (the default), Errors emitted by this client
  *                      and RPC requests will contain a cause chain that
@@ -367,15 +112,16 @@ function translateLegacyOptions(options) {
  *                      by a FastServerError (indicating that the failure was on
  *                      the remote server, as opposed to a local or
  *                      transport-level failure) caused by a SomeError.  In this
- *                      mode, you should use VError.findCause(err, 'SomeError')
- *                      to determine whether the root cause was a SomeError.
+ *                      mode, you should use VError.findCauseByName(err,
+ *                      'SomeError') to determine whether the root cause was a
+ *                      SomeError.
  *
  *                      If the "unwrapErrors" option is true, then Fast-level
  *                      errors are unwrapped and the first non-Fast error in the
  *                      cause chain is returned.  This is provided primarily for
  *                      compatibility with legacy code that uses err.name to
  *                      determine what kind of Error was returned.  New code
- *                      should prefer VError.findCause() instead.
+ *                      should prefer VError.findCauseByName() instead.
  *
  *    mustCloseBeforeNormalProcessExit
  *
@@ -384,35 +130,29 @@ function translateLegacyOptions(options) {
  *                      This is useful for making sure that client consumers
  *                      clean up after themselves.
  *
- * A sample invocation:
+ * A sample server invocation using SRV-record-based service discovery might
+ * look like this:
  *
  *     var client = moray.createClient({
- *         'log': bunyan.createLogger({
- *             'name': 'MorayClient',
- *             'level': process.env.LOG_LEVEL || 'debug',
- *             'stream': process.stdout
- *         }),
+ *         'log': bunyan.createLogger( ... ),
+ *         'srvDomain': 'moray.mydatacenter.joyent.us',
  *         'cueballOptions': {
- *             'domain': 'moray.mydatacenter.joyent.us',
- *             'maxDNSConcurrency': 3,
- *             'defaultPort': 2020,
- *             'target': 6,
- *             'maximum': 15,
- *             'recovery': {
- *                 'default': {
- *                     'retries': 5,
- *                     'timeout': 2000,
- *                     'maxTimeout': 10000,
- *                     'delay': 1000,
- *                     'maxDelay': 60000
- *                 }
- *             }
+ *             'resolvers': [ 'binder.mydatacenter.joyent.us' ]
  *         }
  *     });
+ *
+ * And an analogous CLI invocation might look like this:
+ *
+ *     var client = moray.createClient({
+ *         'log': bunyan.createLogger( ... ),
+ *         'srvDomain': 'moray.mydatacenter.joyent.us'
+ *         'failFast': true,
+ *         'mustCloseBeforeNormalProcessExit': true,
+ *     });
  */
 function MorayClient(options) {
     var self = this;
-    var cueballOptions;
+    var coptions, cueballOptions, resolverInput;
     var resolver;
 
     EventEmitter.call(this);
@@ -422,37 +162,12 @@ function MorayClient(options) {
     assert.optionalBool(options.unwrapErrors, 'options.unwrapErrors');
     assert.optionalBool(options.failFast, 'options.failFast');
 
-    /*
-     * Many of the client options determine how we configure the cueball module.
-     * For compatibility with pre-cueball clients, we accept the old options and
-     * translate them into arguments for cueball.  Modern clients may specify
-     * cueball options directly, in which case we demand that they have not
-     * specified any of these legacy options.
-     */
-    if (options.hasOwnProperty('cueballOptions')) {
-        assert.ok(!options.hasOwnProperty('host'),
-            'cannot combine "cueballOptions" with "host"');
-        assert.ok(!options.hasOwnProperty('port'),
-            'cannot combine "cueballOptions" with "port"');
-        assert.ok(!options.hasOwnProperty('connectTimeout'),
-            'cannot combine "cueballOptions" with "connectTimeout"');
-        assert.ok(!options.hasOwnProperty('dns'),
-            'cannot combine "cueballOptions" with "dns"');
-        assert.ok(!options.hasOwnProperty('maxConnections'),
-            'cannot combine "cueballOptions" with "maxConnections"');
-        assert.ok(!options.hasOwnProperty('retry'),
-            'cannot combine "cueballOptions" with "retry"');
-        assert.string(options.cueballOptions.domain,
-            'options.cueballOptions.domain');
-        cueballOptions = jsprim.deepCopy(options.cueballOptions);
-    } else {
-        cueballOptions = translateLegacyOptions(options);
-    }
-
-    assert.string(cueballOptions.domain, 'cueballOptions.domain');
+    coptions = parseMorayParameters(options);
+    cueballOptions = coptions.cueballOptions;
 
     /* Read-only metadata used for toString() and the like. */
-    this.hostLabel = cueballOptions.domain;
+    this.hostLabel = coptions.label;
+
     this.unwrapErrors = options.unwrapErrors ? true : false;
     this.failFast = options.failFast ? true : false;
 
@@ -462,10 +177,17 @@ function MorayClient(options) {
         domain: cueballOptions.domain
     }, true);
 
-    this.log.debug(cueballOptions, 'init');
+    this.log.debug(coptions, 'init');
+
+    if (coptions.mode == 'srv') {
+        resolverInput = cueballOptions.domain;
+    } else {
+        resolverInput = cueballOptions.domain + ':' +
+            cueballOptions.defaultPort;
+    }
 
     resolver = cueball.resolverForIpOrDomain({
-        'input': cueballOptions.domain + ':' + cueballOptions.defaultPort,
+        'input': resolverInput,
         'resolverConfig': {
             'resolvers': cueballOptions.resolvers,
             'recovery': cueballOptions.recovery,
@@ -1414,10 +1136,10 @@ MorayRpcContext.prototype.createLog = function createLog(options) {
 ///--- Exports
 
 /*
- * Expose translateLegacyOptions privately for testing, not for the outside
+ * Expose privateParseMorayParameters privately for testing, not for the outside
  * world.
  */
-MorayClient.privateTranslateLegacyOptions = translateLegacyOptions;
+MorayClient.privateParseMorayParameters = parseMorayParameters;
 
 module.exports = {
     Client: MorayClient
diff --git a/lib/client_params.js b/lib/client_params.js
new file mode 100644
index 0000000..00a1f49
--- /dev/null
+++ b/lib/client_params.js
@@ -0,0 +1,502 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * lib/client_params.js: normalize the various constructor parameters that the
+ * Moray client supports.
+ */
+
+var assert = require('assert-plus');
+var jsprim = require('jsprim');
+var net = require('net');
+var url = require('url');
+
+/*
+ * Default client parameters
+ */
+
+var dflClientTargetConnections = 6;
+var dflClientMaxConnections = 15;
+var dflClientMaxDnsConcurrency = 3;
+var dflClientConnectRetries = 5;
+var dflClientConnectTimeout = 2000;     /* milliseconds */
+var dflClientConnectTimeoutMax = 30000; /* milliseconds */
+var dflClientDnsTimeout = 1000;         /* milliseconds */
+var dflClientDnsTimeoutMax = 20000;     /* milliseconds */
+var dflClientDnsDelayMin = 10;          /* milliseconds */
+var dflClientDnsDelayMax = 10000;       /* milliseconds */
+var dflClientDelayMin = 1000;           /* milliseconds */
+var dflClientDelayMax = 60000;          /* milliseconds */
+
+/* "service" associated with Moray DNS SRV records */
+var dflClientCueballService = '_moray._tcp';
+/* default TCP port for Moray servers */
+var dflClientCueballDefaultPort = 2020;
+
+/*
+ * Note that correct handling of unspecified legacy options relies on the fact
+ * that the defaults here match the defaults in legacy clients.
+ */
+var dflCueballOptions = {
+    'service': dflClientCueballService,
+    'defaultPort': dflClientCueballDefaultPort,
+    'maxDNSConcurrency': dflClientMaxDnsConcurrency,
+    'target': dflClientTargetConnections,
+    'maximum': dflClientMaxConnections,
+    'recovery': {
+        /*
+         * The 'default' recovery option will cover both the initial connect
+         * attempt and subsequent connect attempts.
+         */
+        'default': {
+            'retries': dflClientConnectRetries,
+            'timeout': dflClientConnectTimeout,
+            'maxTimeout': dflClientConnectTimeoutMax,
+            'delay': dflClientDelayMin,
+            'maxDelay': dflClientDelayMax
+        },
+        'dns': {
+            'retries': dflClientConnectRetries,
+            'timeout': dflClientDnsTimeout,
+            'maxTimeout': dflClientDnsTimeoutMax,
+            'delay': dflClientDnsDelayMin,
+            'maxDelay': dflClientDnsDelayMax
+        },
+        /*
+         * DNS SRV requests fail fast by default because it's not deployed
+         * everywhere yet.
+         */
+        'dns_srv': {
+            'retries': 0,
+            'timeout': dflClientDnsTimeout,
+            'maxTimeout': dflClientDnsTimeoutMax,
+            'delay': dflClientDnsDelayMin,
+            'maxDelay': dflClientDnsDelayMax
+        }
+    }
+};
+
+/*
+ * This function takes the user-specified MorayClient parameters, figures out
+ * what kind of connection the user wants, and returns a description back to the
+ * caller that includes the cueballOptions that will be used for creating a
+ * node-cueball Resolver and ConnectionSet.  This process is surprisingly
+ * complicated, in part because we support a bunch of confusing legacy options,
+ * but also because we need to support both SRV mode (where IP addresses and
+ * ports are looked up in DNS using SRV records) and a direct mode (where the
+ * user either specifies an IP address or -- and this is what makes it confusing
+ * -- a DNS domain whose A records they want us to use to locate a backend).
+ * See RFD 73 for the design background.
+ *
+ * This function accepts one of the following sets of options:
+ *
+ *    "srvDomain" (for SRV-based discovery)
+ *
+ *       OR
+ *
+ *    "url" (for A-based discovery or direct IP/port)
+ *
+ *       OR
+ *
+ *    "host" and optionally "port" (for A-based discovery or direct IP/port)
+ *
+ * along with one of the following sets of options:
+ *
+ *    "cueballOptions"  used to specify options related to the cueball Resolver
+ *    			or ConnectionSet.  Supported cueball-related properties
+ *    			include:
+ *
+ *                        o Resolver properties: "service", "defaultPort",
+ *                          "resolvers", and "maxDNSConcurrency"
+ *
+ *                        o ConnectionSet properties: "target", "maximum"
+ *
+ *                        o common properties: "recovery"
+ *
+ *                      Other cueball parameters like "log", "resolver",
+ *                      "constructor", and "domain" are supplied by the Moray
+ *                      client and may not be specified here.
+ *
+ *       OR
+ *
+ *    any of the options documented under populateLegacyOptions() below.
+ *
+ * The return value is an object describing the configuration, including a set
+ * of options used to create the Cueball Resolver and ConnectionSets.
+ * Properties of the returned object are:
+ *
+ *     mode             either "srv" (for SRV-based discovery) or "direct" (for
+ *                      specific IP/port connections).  This is mostly useful
+ *                      for automated testing.
+ *
+ *     label            human-readable label for this configuration.  This is
+ *                      something like the hostname or hostname and port.  It's
+ *                      intended for log entries and the like.
+ *
+ *     cueballOptions   object specifying options needed to create the Cueball
+ *                      Resolver and ConnectionSet.
+ */
+function parseMorayParameters(args) {
+    var cueballopts, uoptions, port;
+    var havetarget, havemax, u;
+
+    /*
+     * Some combination of "srvDomain", "url", or "host" (with optional "port")
+     * must be specified.  We check the types here, and we'll check for the
+     * presence of various combinations below.
+     */
+    assert.object(args, 'args');
+    assert.optionalString(args.srvDomain, 'args.srvDomain');
+    assert.optionalString(args.url, 'args.url');
+    assert.optionalString(args.host, 'args.host');
+    assert.optionalObject(args.cueballOptions, 'args.cueballOptions');
+
+    /*
+     * For legacy reasons, "port" may be a string or number.
+     */
+    assert.ok(typeof (args.port) == 'undefined' ||
+        typeof (args.port) == 'string' ||
+        typeof (args.port) == 'number',
+        'args.port must be a string or number');
+
+    /*
+     * Process cueball options first, since that's common to each form of input.
+     * We'll start with our default set of cueball options and override whatever
+     * the user asked for.
+     */
+    cueballopts = jsprim.deepCopy(dflCueballOptions);
+    uoptions = args.cueballOptions;
+    if (typeof (uoptions) == 'object' && uoptions !== null) {
+        /*
+         * It's not allowed to specify cueballOptions with any of the legacy
+         * options that we still support.
+         */
+        assert.ok(typeof (args.connectTimeout) == 'undefined',
+            'cannot combine "cueballOptions" with "connectTimeout"');
+        assert.ok(typeof (args.dns) == 'undefined',
+            'cannot combine "cueballOptions" with "dns"');
+        assert.ok(typeof (args.maxConnections) == 'undefined',
+            'cannot combine "cueballOptions" with "maxConnections"');
+        assert.ok(typeof (args.retry) == 'undefined',
+            'cannot combine "cueballOptions" with "retry"');
+
+        /*
+         * It's not allowed to specify "domain" in cueballOptions.  You're
+         * supposed to provide that information via one of the above options.
+         */
+        assert.equal(typeof (uoptions.domain), 'undefined',
+            '"domain" may not be specified in cueballOptions');
+
+        /*
+         * For "defaultPort", "service", "maxDNSConcurrency", and "resolvers",
+         * we'll just take whatever the user provided.
+         */
+        assert.optionalNumber(uoptions.defaultPort,
+            'args.cueballOptions.defaultPort');
+        if (typeof (uoptions.defaultPort) == 'number') {
+            cueballopts.defaultPort = uoptions.defaultPort;
+        }
+
+        assert.optionalString(uoptions.service, 'args.cueballOptions.service');
+        if (typeof (uoptions.service) == 'string') {
+            cueballopts.service = uoptions.service;
+        }
+
+        assert.optionalNumber(uoptions.maxDNSConcurrency,
+            'args.cueballOptions.maxDNSConcurrency');
+        if (typeof (uoptions.maxDNSConcurrency) == 'number') {
+            cueballopts.maxDNSConcurrency = uoptions.maxDNSConcurrency;
+        }
+
+        assert.optionalArrayOfString(uoptions.resolvers,
+            'args.cueballOptions.resolvers');
+        if (typeof (uoptions.resolvers) == 'object' &&
+            uoptions.resolvers !== null) {
+            cueballopts.resolvers = uoptions.resolvers;
+        }
+
+        /*
+         * For "target" and "maximum", we demand that if the user specify one,
+         * then they ought to specify both.  We could relax this and say that if
+         * only one is specified, we'll pick a default for the other, but at
+         * this point it seems clearer to require the consumer to specify both
+         * (and it seems no harder for the them, either).
+         */
+        assert.optionalNumber(uoptions.target, 'args.cueballOptions.target');
+        assert.optionalNumber(uoptions.maximum, 'args.cueballOptions.maximum');
+        havetarget = typeof (uoptions.target) == 'number';
+        havemax = typeof (uoptions.maximum) == 'number';
+        if ((havetarget && !havemax) || (!havetarget && havemax)) {
+            throw (new Error(
+                'must specify neither or both of "target" and "maximum"'));
+        }
+
+        if (havetarget) {
+            cueballopts.target = uoptions.target;
+            cueballopts.maximum = uoptions.maximum;
+        }
+
+        /*
+         * Similarly, if the caller specified "recovery" at all, we will assume
+         * they completely specified what they want and we will not mess with
+         * it.
+         */
+        assert.optionalObject(uoptions.recovery,
+            'args.cueballOptions.recovery');
+        if (typeof (uoptions.recovery) == 'object' &&
+            uoptions.recovery !== null) {
+            cueballopts.recovery = jsprim.deepCopy(uoptions.recovery);
+        }
+    } else {
+        /*
+         * Many of the client options determine how we configure the cueball
+         * module.  For compatibility with pre-cueball clients, we accept the
+         * old options and translate them into arguments for cueball.  Modern
+         * clients may specify cueball options directly, in which case we demand
+         * that they have not specified any of these legacy options.
+         */
+        populateLegacyOptions(cueballopts, args);
+    }
+
+    /*
+     * Now that we've got the easy properties out of the way, pick apart the
+     * options used to configure "domain" and "service".
+     */
+    if (typeof (args.srvDomain) == 'string') {
+        assert.ok(!net.isIP(args.srvDomain),
+            'cannot use "srvDomain" with an IP address');
+        assert.notEqual(typeof (args.host), 'string',
+            'cannot specify "host" with "srvDomain"');
+        assert.equal(typeof (args.port), 'undefined',
+            'cannot specify "port" with "srvDomain"');
+        assert.notEqual(typeof (args.url), 'string',
+            'cannot specify "url" with "srvDomain"');
+
+        cueballopts.domain = args.srvDomain;
+        return ({
+            'mode': 'srv',
+            'cueballOptions': cueballopts,
+            'label': cueballopts.domain
+        });
+    }
+
+    /*
+     * If the user didn't specify "srvDomain", then they must have specified a
+     * hostname or IP address and a port (possibly falling back to the default
+     * port).  In this case, we connect directly to the specified IP (or one of
+     * IPs specified by A records associated with the hostname).  We don't want
+     * cueball to use SRV records in this mode.  There's not currently a way to
+     * disable this, so we set a bogus service name and a very short timeout.
+     */
+    cueballopts.service = '_moraybogus._tcp';
+    assert.strictEqual(cueballopts.recovery.dns_srv.retries, 0);
+    cueballopts.recovery.dns_srv.timeout = 1;
+    cueballopts.recovery.dns_srv.maxTimeout = 1;
+
+    /*
+     * This logic mirrors the legacy behavior of createClient, however
+     * unnecessarily complicated that was.  Specifically, the desired host comes
+     * from "args.host" if present, and otherwise from parsing "args.url".  The
+     * desired port comes from "args.port" (as either a string or number) if
+     * present, and otherwise the URL as long as "host" wasn't also specified,
+     * and otherwise the default port 2020.
+     */
+    if (typeof (args.host) == 'string') {
+        assert.notEqual(typeof (args.url), 'string',
+            'cannot specify "host" with "url"');
+        cueballopts.domain = args.host;
+    } else {
+        /* We've already checked this condition early on. */
+        assert.strictEqual(typeof (args.url), 'string',
+            'at least one of "srvDomain", "url", and "host" must be specified');
+        u = url.parse(args.url);
+        cueballopts.domain = u.hostname;
+        if (u.port !== null) {
+            port = u.port;
+        }
+    }
+
+    if (typeof (args.port) == 'number' || typeof (args.port) == 'string') {
+        port = args.port;
+    }
+
+    if (typeof (port) == 'number') {
+        cueballopts.defaultPort = port;
+    } else if (typeof (port) == 'string') {
+        cueballopts.defaultPort = parseInt(port, 10);
+        assert.ok(!isNaN(cueballopts.defaultPort), '"port" must be a number');
+    }
+
+    return ({
+        'mode': 'direct',
+        'cueballOptions': cueballopts,
+        'label': cueballopts.domain + ':' + cueballopts.defaultPort
+    });
+}
+
+/*
+ * Given an assembled set of cueball options "out" (populated with our default
+ * values) and a set of legacy options "args", process the legacy options and
+ * update the cueball options.
+ *
+ * The following legacy properties are supported:
+ *
+ *     connectTimeout    non-negative, integer number of milliseconds
+ *                       to wait for TCP connections to be established
+ *
+ *     dns (object)      describes DNS behavior
+ *
+ *     dns.checkInterval non-negative, integer number of milliseconds
+ *                       between periodic resolution of DNS names used to keep
+ *                       the set of connected IPs up to date.  This is not used
+ *                       by cueball any more.
+ *
+ *     dns.resolvers     array of string IP addresses to use for DNS resolvers
+ *
+ *     dns.timeout       non-negative, integer number of milliseconds to wait
+ *                       for DNS query responses
+ *
+ *     maxConnections    non-negative, integer number of TCP connections that
+ *                       may ever be opened to each IP address used.  If "host"
+ *                       is an IP address, then this is the maximum number of
+ *                       connections, but if "host" is a DNS name, then there
+ *                       may be up to "maxConnections" per remote IP found in
+ *                       DNS.
+ *
+ *     retry (object)    describes a retry policy used for establishing
+ *                       connections.  Historically, the behavior with respect
+ *                       to this policy was confusing at best: this policy was
+ *                       used for establishing TCP connections to remote
+ *                       servers, but a second, hardcoded policy was used when
+ *                       this first policy was exhausted.  This policy appears
+ *                       to have been intended to cover DNS operations as well,
+ *                       but was not actually used.  In the current
+ *                       implementation, this policy is the one used for TCP
+ *                       connection establishment, and callers wanting to
+ *                       specify a DNS policy must specify cueball options
+ *                       directly rather than using these legacy options.
+ *
+ *     retry.retries     non-negative, integer number of retry attempts.  It's
+ *                       unspecified whether this is the number of attempts or
+ *                       the number of retries (i.e., one fewer than the number
+ *                       of attempts).  Today, this is interpreted by
+ *                       node-cueball.  Historically, this was interpreted by
+ *                       the node-backoff module.
+ *
+ *     retry.minTimeout  non-negative, integer number of milliseconds to wait
+ *                       after the first operation failure before retrying
+ *
+ *     retry.maxTimeout  non-negative, integer representing the maximum number
+ *                       of milliseconds between retries.  Some form of backoff
+ *                       (likely exponential) is used to determine the delay,
+ *                       but it will always be between retry.minTimeout and
+ *                       retry.maxTimeout.
+ *
+ * Additional properties were at one time documented, but never used:
+ * maxIdleTime and pingTimeout.
+ */
+function populateLegacyOptions(out, args) {
+    var r;
+
+    assert.object(out, 'out');
+    assert.object(args, 'args');
+
+    assert.optionalNumber(args.maxConnections, 'args.maxConnections');
+    if (typeof (args.maxConnections) == 'number') {
+        out.maximum = args.maxConnections;
+        out.target = Math.min(out.target, out.maximum);
+    }
+
+    assert.optionalObject(args.dns, 'args.dns');
+    if (args.dns) {
+        assert.optionalArrayOfString(args.dns.resolvers,
+            'args.dns.resolvers');
+        if (Array.isArray(args.dns.resolvers)) {
+            out.resolvers = args.dns.resolvers.slice(0);
+        }
+    }
+
+    r = out.recovery;
+    if (args.dns && typeof (args.dns.timeout) == 'number') {
+        assert.number(args.dns.timeout, 'args.dns.timeout');
+        assert.ok(args.dns.timeout >= 0, 'dns timeout must be non-negative');
+        r.dns.timeout = args.dns.timeout;
+        r.dns_srv.timeout = args.dns.timeout;
+
+        /*
+         * In the old implementation, the timeout never increased.  Based on
+         * experience, that's not reasonable default behavior, so we'll try to
+         * use our default maximum unless that's too small.
+         */
+        if (r.dns.maxTimeout < r.dns.timeout) {
+            r.dns.maxTimeout = r.dns.timeout;
+            r.dns_srv.maxTimeout = r.dns.maxTimeout;
+        }
+    }
+
+    assert.optionalNumber(args.connectTimeout, 'args.connectTimeout');
+    if (typeof (args.connectTimeout) == 'number') {
+        assert.ok(args.connectTimeout >= 0,
+            'connect timeout must be non-negative');
+        r.default.timeout = args.connectTimeout;
+        if (r.default.maxTimeout < r.default.timeout) {
+            r.default.maxTimeout = r.default.timeout;
+        }
+    }
+
+    assert.optionalObject(args.retry, 'args.retry');
+    if (args.retry) {
+        assert.optionalNumber(args.retry.retries, 'args.retry.retries');
+        if (typeof (args.retry.retries) == 'number') {
+            r.default.retries = args.retry.retries;
+        }
+
+        /*
+         * In the legacy interface, the retry policy is specified in terms of
+         * timeouts.  Those timeout values really describe the delay between
+         * attempts, which we now call "delay".
+         */
+        assert.optionalNumber(args.retry.minTimeout,
+            'args.retry.minTimeout');
+        if (typeof (args.retry.minTimeout) == 'number') {
+            r.default.delay = args.retry.minTimeout;
+
+            if (typeof (args.retry.maxTimeout) == 'number') {
+                assert.ok(args.retry.maxTimeout >=
+                    args.retry.minTimeout,
+                    'retry.maxTimeout must not be smaller ' +
+                    'than retry.minTimeout');
+                r.default.maxDelay = args.retry.maxTimeout;
+            } else {
+                r.default.delay = args.retry.minTimeout;
+                if (r.default.maxDelay < r.default.delay) {
+                    r.default.maxDelay = r.default.delay;
+                }
+            }
+        } else if (typeof (args.retry.maxTimeout) == 'number') {
+            r.default.maxDelay = args.retry.maxTimeout;
+            if (r.default.delay > r.default.maxDelay) {
+                r.default.delay = r.default.maxDelay;
+            }
+        }
+
+        assert.number(r.default.delay);
+        assert.number(r.default.maxDelay);
+        assert.ok(r.default.delay <= r.default.maxDelay);
+    }
+
+    if (args.failFast) {
+        r.default.retries = 0;
+        r.default.delay = 0;
+        r.default.maxDelay = 0;
+    }
+}
+
+exports.parseMorayParameters = parseMorayParameters;
diff --git a/lib/cmd.js b/lib/cmd.js
new file mode 100644
index 0000000..5cdbe0b
--- /dev/null
+++ b/lib/cmd.js
@@ -0,0 +1,368 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+/*
+ * lib/cmd.js: common functions used by command-line utilities
+ *
+ * Many of these functions follow a similar pattern: when there's a fatal error
+ * (like failure to parse a numeric option), they emit a message to stderr and
+ * then return false.  Callers use that to eventually print a usage message and
+ * exit.
+ */
+
+var assert = require('assert-plus');
+var bunyan = require('bunyan');
+var getopt = require('posix-getopt');
+var net = require('net');
+var path = require('path');
+var url = require('url');
+var VError = require('verror');
+var fprintf = require('extsprintf').fprintf;
+
+/* Option string for options common to all commands */
+var commonOptStr = 'b:(bootstrap-domain)h:(host)p:(port)S:(service)v';
+
+/*
+ * Currently, we only export parseCliOptions().  If we find we need more (or
+ * less) fine-grained control over option parsing or general CLI execution, we
+ * can provide higher or lower-level interfaces here.
+ */
+exports.parseCliOptions = parseCliOptions;
+exports.commonUsage = '[-b domain] [-h host] [-p port] [-S service] [-v]';
+
+/*
+ * Parse command-line options and common environment variables.  This function
+ * instantiates a node-getopt option parser that will handle the requested
+ * command-line options plus the common options implemented in this file.
+ * Common options are processed to fill in the "clientOptions" object described
+ * below.  Each command-specific option is passed to the "onOption" callback
+ * function described below.
+ *
+ * The returned value is the node-getopt parser itself, which allows callers to
+ * access the index of the last option argument that was parsed.
+ *
+ * Named arguments:
+ *
+ *  argv            command-line arguments, including Node's leading two
+ *                  arguments.  This would usually be `process.argv`.
+ *
+ *  env             process environment.  This would usually be `process.env`.
+ *
+ *  errstream       stream for error messages.  This would usually be
+ *                  `process.stderr`.
+ *
+ *  extraOptStr     getopt-style option string for this command's custom
+ *                  options.  This will be combined with the common option
+ *                  string above and used to parse options with node-getopt.
+ *
+ *  clientOptions   an object that will be populated with arguments used to
+ *                  create a Moray client.  That will include some combination
+ *                  of "host", "port", and "srvDomain" as well as an appropriate
+ *                  bunyan logger, configured based on the environment and
+ *                  presence of "-v" options.  This may also contain
+ *                  cueballOptions.
+ *
+ *  onUsage         function to be invoked when there's a usage error
+ *
+ *  onOption        function to be invoked for each getopt option parsed.  The
+ *                  only argument is the option returned by node-getopt itself.
+ *                  This field should be specified if and only if extraOptStr is
+ *                  a non-empty string.  The function should handle unrecognized
+ *                  options (usually by invoking the caller's usage function).
+ *
+ * This function uses the MORAY_SERVICE and MORAY_URL environment variables from
+ * `env` to fill in common options where possible.  `LOG_LEVEL` is used to
+ * configure the level of the bunyan logger.  Log verbosity is increased with
+ * each instance of the "-v" option.
+ */
+function parseCliOptions(args) {
+    var parser, option, commonOpts, shortOpts;
+
+    assert.object(args, 'args');
+    assert.object(args.argv, 'args.argv');
+    assert.object(args.env, 'args.env');
+    assert.object(args.errstream, 'args.errstream');
+    assert.string(args.extraOptStr, 'args.extraOptStr');
+    assert.object(args.clientOptions, 'args.clientOptions');
+    assert.func(args.onUsage, 'args.onUsage');
+    assert.optionalFunc(args.onOption, 'args.onOption');
+
+    if (args.extraOptStr === '') {
+        assert.ok(typeof (args.onOption) != 'function');
+    } else {
+        assert.func(args.onUsage, 'args.onOption');
+    }
+
+    if (!args.clientOptions.log) {
+        args.clientOptions.log = bunyan.createLogger({
+            'name': path.basename(args.argv[1]),
+            'level': (args.env.LOG_LEVEL || 'fatal'),
+            'stream': process.stderr,
+            'serializers': bunyan.stdSerializers
+        });
+    }
+
+    /*
+     * Validate that the extra option string doesn't try to override any of our
+     * common options.  It's easiest to strip out long option names and then
+     * check for the presence of any of our options.
+     */
+    shortOpts = args.extraOptStr;
+    shortOpts = shortOpts.replace(/\([^)]*\)/g, '');
+    commonOpts = commonOptStr;
+    commonOpts = commonOpts.replace(/\([^)]*\)/g, '');
+    commonOpts = commonOpts.replace(/:/g, '');
+    commonOpts.split('').forEach(function (c) {
+        if (shortOpts.indexOf(c) != -1) {
+            throw (new VError('internal error: ' +
+                'command cannot replace option: -%s', c));
+        }
+    });
+
+    /*
+     * Parse the combination option string.
+     */
+    parser = new getopt.BasicParser(commonOptStr + args.extraOptStr, args.argv);
+    while ((option = parser.getopt()) !== undefined) {
+        switch (option.option) {
+        case 'b':
+        case 'h':
+        case 'p':
+        case 'S':
+        case 'v':
+            if (!parseCommonCliOption(args.errstream,
+                args.clientOptions, option)) {
+                args.onUsage();
+            }
+            break;
+
+        default:
+            if (args.extraOptStr === '') {
+                args.onUsage();
+            } else {
+                args.onOption(option);
+            }
+            break;
+        }
+    }
+
+    /*
+     * For all of our commands, we use failFast by default so that the command
+     * doesn't block indefinitely if Moray is down, and we use
+     * mustCloseBeforeNormalProcessExit to make sure the commands clean up after
+     * themselves.
+     */
+    args.clientOptions.failFast = true;
+    args.clientOptions.mustCloseBeforeNormalProcessExit = true;
+
+    /*
+     * Perform final validation of the common options.
+     */
+    if (!finalizeCliOptions(args.errstream, args.clientOptions, args.env)) {
+        args.onUsage();
+    }
+
+    return (parser);
+}
+
+/*
+ * Parses one of the command-line options that's common to several commands.
+ * See the option string at the top of this file.
+ *
+ * "options" is an object in which we're building the Moray client
+ * configuration.  "option" is a node-getopt option object.
+ *
+ * If there is an error, prints an error message and returns false.
+ */
+function parseCommonCliOption(errstream, options, option) {
+    var p, log;
+
+    assert.object(errstream, 'errstream');
+    assert.object(options, 'options');
+    assert.object(option, 'option');
+
+    switch (option.option) {
+    case 'b':
+        if (!options.hasOwnProperty('cueballOptions')) {
+            options.cueballOptions = {};
+        }
+
+        options.cueballOptions.resolvers = [ option.optarg ];
+        break;
+
+    case 'h':
+        options.host = option.optarg;
+        break;
+
+    case 'p':
+        p = parseTcpPort(option.optarg);
+        if (p === null) {
+            fprintf(errstream, '-p/--port: expected valid TCP port\n');
+            return (false);
+        }
+        options.port = p;
+        break;
+
+    case 'S':
+        if (!validateSrvDomain(errstream, option.optarg)) {
+            return (false);
+        }
+
+        options.srvDomain = option.optarg;
+        break;
+
+    case 'v':
+        /*
+         * This allows "-v" to be used multiple times and ensures that we
+         * never wind up at a level less than TRACE.
+         */
+        log = options.log;
+        log.level(Math.max(bunyan.TRACE, (log.level() - 10)));
+        if (log.level() <= bunyan.DEBUG)
+            log = log.child({src: true});
+        break;
+
+    default:
+        throw (new Error('tried to parse non-common option'));
+    }
+
+    return (true);
+}
+
+/*
+ * Performs final validation on CLI options and populates required arguments
+ * with default values.  Like parseCommonCliOption(), on error this prints an
+ * error message to stderr and returns false.
+ */
+function finalizeCliOptions(errstream, options, env) {
+    /*
+     * Independent of anything else, if the user specified a bootstrap domain in
+     * the environment and didn't specify it on the CLI, incorporate that here.
+     */
+    if ((!options.hasOwnProperty('cueballOptions') ||
+        !options.cueballOptions.hasOwnProperty('resolvers')) &&
+        env['MORAY_BOOTSTRAP_DOMAIN']) {
+        if (!options.hasOwnProperty('cueballOptions')) {
+            options.cueballOptions = {};
+        }
+
+        options.cueballOptions.resolvers = [ env['MORAY_BOOTSTRAP_DOMAIN'] ];
+    }
+
+    if (options.srvDomain !== undefined) {
+        /* The user specified -s/--service. */
+        if (options.port !== undefined || options.host !== undefined) {
+            fprintf(errstream, '-S/--service cannot be combined with ' +
+                '-h/--host or -p/--port\n');
+            return (false);
+        }
+
+        return (true);
+    }
+
+    if (options.host !== undefined && options.port !== undefined) {
+        /* The user specified both -h/--host and -p/--port. */
+        return (true);
+    }
+
+    if (options.host !== undefined || options.port !== undefined) {
+        /*
+         * The user specified one -h/--host and -p/--port.  Assume they want the
+         * direct mode and fill in the other option from MORAY_URL or our
+         * built-in default values.
+         */
+        return (populateDirectArguments(errstream, options, env));
+    }
+
+    /*
+     * The user specified nothing on the command line.  Check for MORAY_SERVICE.
+     */
+    if (env['MORAY_SERVICE']) {
+        if (!validateSrvDomain(errstream, env['MORAY_SERVICE'])) {
+            return (false);
+        }
+
+        options.srvDomain = env['MORAY_SERVICE'];
+        return (true);
+    }
+
+    /*
+     * If we get this far, all that's left to try is MORAY_URL, then fall back
+     * to built-in defaults.
+     */
+    return (populateDirectArguments(errstream, options, env));
+}
+
+function validateSrvDomain(errstream, domain) {
+    if (net.isIP(domain)) {
+        fprintf(errstream,
+            'cannot use an IP address with -S/--service/MORAY_SERVICE\n');
+        return (false);
+    }
+
+    return (true);
+}
+
+/*
+ * Given a set of Moray client arguments, ensure that "host" and "port" are
+ * populated based on MORAY_URL or our default values.  Like the other functions
+ * in this file, on error, prints an error message and then returns "false" on
+ * failure.
+ *
+ * Importantly, don't parse MORAY_URL if we're not going to use it.
+ */
+function populateDirectArguments(errstream, options, env) {
+    var u, p;
+
+    if (options.host === undefined || options.port === undefined) {
+        /*
+         * The user specified one of -h/--host and -p/--port, but not the other.
+         */
+        if (env['MORAY_URL']) {
+            u = url.parse(env['MORAY_URL']);
+            if (options.host === undefined) {
+                options.host = u['hostname'];
+            }
+
+            if (options.port === undefined && u['port'] !== null) {
+                p = parseTcpPort(u['port']);
+                if (p === null) {
+                    fprintf(errstream,
+                        'port in MORAY_URL is not a valid TCP port\n');
+                    return (false);
+                }
+
+                options.port = p;
+            }
+        }
+
+        if (options.host === undefined) {
+            options.host = '127.0.0.1';
+        }
+
+        if (options.port === undefined) {
+            options.port = 2020;
+        }
+    }
+
+    return (true);
+}
+
+function parseTcpPort(portstr) {
+    var p;
+
+    assert.string(portstr, 'portstr');
+    p = parseInt(portstr, 10);
+    if (isNaN(p) || p < 0 || p >= 65536) {
+        return (null);
+    }
+
+    return (p);
+}
diff --git a/lib/pool.js b/lib/pool.js
index 31d33e9..e8bcf4c 100644
--- a/lib/pool.js
+++ b/lib/pool.js
@@ -5,7 +5,7 @@
  */
 
 /*
- * Copyright (c) 2016, Joyent, Inc.
+ * Copyright (c) 2017, Joyent, Inc.
  */
 
 /*
@@ -170,13 +170,14 @@ MorayConnectionPool.prototype.connRelease = function (aconn) {
  * is ready for use.  Just add it to our set of available connections.
  */
 MorayConnectionPool.prototype.connAdd = function connAdd(key, conn) {
-    var mconn;
+    var mconn, extras;
 
     assert.ok(!this.mcp_conns.hasOwnProperty(key));
     assert.ok(!this.mcp_avail.hasOwnProperty(key));
 
-    mconn = new MorayConnection(key, conn,
-        this.mcp_log.child({ 'key': key }, true));
+    extras = conn.socketAddrs();
+    extras.key = key;
+    mconn = new MorayConnection(key, conn, this.mcp_log.child(extras, true));
     this.mcp_conns[key] = mconn;
     this.mcp_avail[key] = true;
     mconn.mc_log.info('new connection');
diff --git a/package.json b/package.json
index 1efe38a..63a9530 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
     "name": "moray",
     "description": "Moray client library",
-    "version": "2.0.1",
+    "version": "3.0.0",
     "author": "Joyent (joyent.com)",
     "keywords": [ "moray" ],
     "main": "./lib/index.js",
@@ -15,9 +15,10 @@
         "bunyan": "^1.3.2",
         "cmdutil": "^1.1.0",
         "cueball": "^1.0.3",
+	"extsprintf": "^1.3.0",
         "fast": "^2.1.0",
         "libuuid": "0.2.1",
-        "jsprim": "^1.2.2",
+        "jsprim": "^1.3.0",
         "posix-getopt": "^1.0.0",
         "progbar": "0.1.0",
         "vasync": "^1.6.4",
