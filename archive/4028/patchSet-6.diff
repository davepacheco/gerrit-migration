From c8867955e0858e3d121e6f0f78b31bc94d98c6bf Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Tue, 22 May 2018 18:07:34 +0000
Subject: [PATCH] MORAY-457 Moray getObject() request hangs

---
 lib/buckets/common.js |  2 +-
 lib/dtrace.js         |  3 +++
 lib/pg.js             | 61 ++++++++++++++++++++++++++++---------------
 3 files changed, 44 insertions(+), 22 deletions(-)

diff --git a/lib/buckets/common.js b/lib/buckets/common.js
index c395460..1af3456 100644
--- a/lib/buckets/common.js
+++ b/lib/buckets/common.js
@@ -121,7 +121,7 @@ function createIndexes(opts, callback) {
     });
 
     log.debug({bucket: bucket}, 'createIndexes: entered');
-    vasync.forEachParallel({
+    vasync.forEachPipeline({
         func: function createIndex(sql, cb) {
             log.debug('createIndexes: running %s', sql);
             var q = pg.query(sql);
diff --git a/lib/dtrace.js b/lib/dtrace.js
index ef4a291..a135c94 100644
--- a/lib/dtrace.js
+++ b/lib/dtrace.js
@@ -77,6 +77,9 @@ var PROBES = {
     // reqid, sql, error message
     'query-error': ['char *', 'char *', 'char *'],
 
+    // reqid, sql, error message
+    'query-conn-error': ['char *', 'char *', 'char *'],
+
     // reqid, sql
     'query-timeout': ['char *', 'char *'],
 
diff --git a/lib/pg.js b/lib/pg.js
index 695f8c6..0368e84 100644
--- a/lib/pg.js
+++ b/lib/pg.js
@@ -101,6 +101,8 @@ PGClient.prototype._handleClientError = function (err) {
     }, 'pg: client emitted an error');
 
     this._moray_had_err = new VError(err, 'Postgres client failed');
+
+    this.emit('conn-error', this._moray_had_err);
 };
 
 
@@ -166,15 +168,27 @@ PGClient.prototype.query = function clientQuery(sql, args) {
     // facility (see pgCheck). These queries originate at Moray and are not
     // associated with an RPC. Therefore, the _reqid member will be null.
     var reqid = (this._reqid === null) ? libuuid.create() : this._reqid;
-    var aborted = false;
+    var ended = false;
 
     function done(event, arg) {
-        if (aborted) {
+        if (ended) {
             return;
         }
 
-        res.emit(event, arg);
+        ended = true;
+
+        self.removeListener('conn-error', onConnError);
         clearTimeout(timer);
+
+        res.emit(event, arg);
+    }
+
+    function onConnError(err) {
+        dtrace['query-conn-error'].fire(function () {
+            return ([reqid, sql, err.toString()]);
+        });
+
+        done('error', err);
     }
 
     req = new pg.Query(sql, args);
@@ -190,7 +204,7 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             row: row
         }, 'query: row');
 
-        if (aborted) {
+        if (ended) {
             return;
         }
 
@@ -212,6 +226,8 @@ PGClient.prototype.query = function clientQuery(sql, args) {
         done('end', arg);
     });
 
+    self.on('conn-error', onConnError);
+
     req.on('error', function onQueryError(err) {
         dtrace['query-error'].fire(function () {
             return ([reqid, sql, err.toString()]);
@@ -223,7 +239,15 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             err: err
         }, 'query: failed');
 
-        done('error', err);
+        /*
+         * node-postgres's client.query() will fire "error" synchronously when
+         * the client's connection dies (or is already dead), sometimes
+         * resulting in this handler firing in the same tick as the
+         * client.query() call. Since the PGClient.query() caller won't have
+         * had an opportunity to set up their own "error" listener, we delay
+         * firing the event until the next tick.
+         */
+        setImmediate(done, 'error', err);
     });
 
     if (this._queryTimeout > 0) {
@@ -231,11 +255,10 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             var err = new QueryTimeoutError(sql);
 
             /*
-             * Don't ROLLBACK, since it may or may not make
-             * it to the server, and the query we just timed
-             * out may have placed things in a weird state;
-             * just force a connection close to happen once
-             * the connection is out of the pool.
+             * Don't ROLLBACK, since it may or may not make it to the server,
+             * and the query we just timed out may have placed things in a
+             * weird state; just force a connection close to happen once the
+             * connection is out of the pool.
              */
             self._moray_had_err = err;
 
@@ -244,18 +267,14 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             });
 
             /*
-             * We're timing out the query inside Moray, but
-             * the Postgres query is still running. It may
-             * still return rows, return a SQL error, or end due
-             * to connection problems. We don't emit anything
-             * after this point, since we've already emitted an
-             * "error" and will have replied to the client. We
-             * do continue logging and firing DTrace probes for
-             * anyone who's observing the process, though.
+             * We're timing out the query inside Moray, but the Postgres query
+             * is still running. It may still return rows, return a SQL error,
+             * or end due to connection problems. We won't emit anything
+             * further on "res" after this point, but we will continue logging
+             * and firing DTrace probes for anyone who's observing the process,
+             * though.
              */
-            aborted = true;
-
-            res.emit('error', err);
+            done('error', err);
         }, this._queryTimeout);
     }
 
-- 
2.21.0

