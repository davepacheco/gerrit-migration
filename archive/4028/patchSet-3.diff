commit a410e5b5b51be841a4b0f1d6d63d156d762638a5 (refs/changes/28/4028/3)
Author: Cody Peter Mello <cody.mello@joyent.com>
Date:   2018-05-30T23:01:37+00:00 (1 year, 4 months ago)
    
    MORAY-457 Moray getObject() request hangs

diff --git a/lib/buckets/common.js b/lib/buckets/common.js
index c395460..1af3456 100644
--- a/lib/buckets/common.js
+++ b/lib/buckets/common.js
@@ -121,7 +121,7 @@ function createIndexes(opts, callback) {
     });
 
     log.debug({bucket: bucket}, 'createIndexes: entered');
-    vasync.forEachParallel({
+    vasync.forEachPipeline({
         func: function createIndex(sql, cb) {
             log.debug('createIndexes: running %s', sql);
             var q = pg.query(sql);
diff --git a/lib/pg.js b/lib/pg.js
index 695f8c6..efa771e 100644
--- a/lib/pg.js
+++ b/lib/pg.js
@@ -101,6 +101,8 @@ PGClient.prototype._handleClientError = function (err) {
     }, 'pg: client emitted an error');
 
     this._moray_had_err = new VError(err, 'Postgres client failed');
+
+    this.emit('conn-error', this._moray_had_err);
 };
 
 
@@ -166,15 +168,27 @@ PGClient.prototype.query = function clientQuery(sql, args) {
     // facility (see pgCheck). These queries originate at Moray and are not
     // associated with an RPC. Therefore, the _reqid member will be null.
     var reqid = (this._reqid === null) ? libuuid.create() : this._reqid;
-    var aborted = false;
+    var ended = false;
 
     function done(event, arg) {
-        if (aborted) {
+        if (ended) {
             return;
         }
 
-        res.emit(event, arg);
+        ended = true;
+
+        self.removeListener(onConnError);
         clearTimeout(timer);
+
+        res.emit(event, arg);
+    }
+
+    function onConnError(err) {
+        dtrace['query-error'].fire(function () {
+            return ([reqid, sql, err.toString()]);
+        });
+
+        done('error', err);
     }
 
     req = new pg.Query(sql, args);
@@ -190,7 +204,7 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             row: row
         }, 'query: row');
 
-        if (aborted) {
+        if (ended) {
             return;
         }
 
@@ -212,6 +226,8 @@ PGClient.prototype.query = function clientQuery(sql, args) {
         done('end', arg);
     });
 
+    self.on('conn-error', onConnError);
+
     req.on('error', function onQueryError(err) {
         dtrace['query-error'].fire(function () {
             return ([reqid, sql, err.toString()]);
@@ -223,7 +239,15 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             err: err
         }, 'query: failed');
 
-        done('error', err);
+        /*
+         * node-postgres's client.query() will fire "error" synchronously when
+         * the client's connection dies (or is already dead), sometimes
+         * resulting in this handler firing in the same tick as the
+         * client.query() call. Since the PGClient.query() caller won't have
+         * had an opportunity to set up their own "error" listener, we delay
+         * firing the event until the next tick.
+         */
+        setImmediate(done, 'error', err);
     });
 
     if (this._queryTimeout > 0) {
@@ -231,11 +255,10 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             var err = new QueryTimeoutError(sql);
 
             /*
-             * Don't ROLLBACK, since it may or may not make
-             * it to the server, and the query we just timed
-             * out may have placed things in a weird state;
-             * just force a connection close to happen once
-             * the connection is out of the pool.
+             * Don't ROLLBACK, since it may or may not make it to the server,
+             * and the query we just timed out may have placed things in a
+             * weird state; just force a connection close to happen once the
+             * connection is out of the pool.
              */
             self._moray_had_err = err;
 
@@ -244,18 +267,14 @@ PGClient.prototype.query = function clientQuery(sql, args) {
             });
 
             /*
-             * We're timing out the query inside Moray, but
-             * the Postgres query is still running. It may
-             * still return rows, return a SQL error, or end due
-             * to connection problems. We don't emit anything
-             * after this point, since we've already emitted an
-             * "error" and will have replied to the client. We
-             * do continue logging and firing DTrace probes for
-             * anyone who's observing the process, though.
+             * We're timing out the query inside Moray, but the Postgres query
+             * is still running. It may still return rows, return a SQL error,
+             * or end due to connection problems. We won't emit anything
+             * further on "res" after this point, but we will continue logging
+             * and firing DTrace probes for anyone who's observing the process,
+             * though.
              */
-            aborted = true;
-
-            res.emit('error', err);
+            done('error', err);
         }, this._queryTimeout);
     }
 
