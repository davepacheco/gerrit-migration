commit c78733726279ff79f248a5ce19150a4e28d1dd7f (refs/changes/22/2822/7)
Author: Jerry Jelinek <jerry.jelinek@joyent.com>
Date:   2017-10-23T20:21:37+00:00 (2 years ago)
    
    OS-6338 panic from kvm_load_gs
    Reviewed by: Dan McDonald <danmcd@joyent.com>
    Reviewed by: Patrick Mooney <patrick.mooney@joyent.com>
    Approved by: Dan McDonald <danmcd@joyent.com>

diff --git a/usr/src/uts/common/brand/lx/os/lx_misc.c b/usr/src/uts/common/brand/lx/os/lx_misc.c
index 53963c0f7d..35e42edaa3 100644
--- a/usr/src/uts/common/brand/lx/os/lx_misc.c
+++ b/usr/src/uts/common/brand/lx/os/lx_misc.c
@@ -183,6 +183,26 @@ lx_cleanlwp(klwp_t *lwp, proc_t *p)
 	if (rb_list != NULL) {
 		lx_futex_robust_exit((uintptr_t)rb_list, lwpd->br_pid);
 	}
+
+	/*
+	 * We need to run our context exit operation (lx_save) here to ensure
+	 * we don't leave any garbage around. This is necessary to handle the
+	 * following calling sequence:
+	 *    exit -> proc_exit -> lx_freelwp -> removectx
+	 * That is, when our branded process exits, proc_exit will call our
+	 * lx_freelwp brand hook which does call this function (lx_cleanlwp),
+	 * but lx_freelwp also removes our context exit operation. The context
+	 * exit functions are run by exitctx, which is called by either
+	 * lwp_exit or thread_exit. The thread_exit function is called at the
+	 * end of proc_exit when we'll swtch() to another thread, but by then
+	 * our context exit function has been removed.
+	 *
+	 * It's ok if this function happens to be called more than once (for
+	 * example, if we exec a native binary).
+	 */
+	kpreempt_disable();
+	lx_save(lwp);
+	kpreempt_enable();
 }
 
 void
