From e817e741e2ba1900c124709cfb621671499a8787 Mon Sep 17 00:00:00 2001
From: Jerry Jelinek <jerry.jelinek@joyent.com>
Date: Mon, 23 Oct 2017 14:48:38 +0000
Subject: [PATCH] OS-6338 panic from kvm_load_gs

---
 usr/src/uts/common/brand/lx/os/lx_misc.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/usr/src/uts/common/brand/lx/os/lx_misc.c b/usr/src/uts/common/brand/lx/os/lx_misc.c
index 53963c0f7d..35e42edaa3 100644
--- a/usr/src/uts/common/brand/lx/os/lx_misc.c
+++ b/usr/src/uts/common/brand/lx/os/lx_misc.c
@@ -183,6 +183,26 @@ lx_cleanlwp(klwp_t *lwp, proc_t *p)
 	if (rb_list != NULL) {
 		lx_futex_robust_exit((uintptr_t)rb_list, lwpd->br_pid);
 	}
+
+	/*
+	 * We need to run our context exit operation (lx_save) here to ensure
+	 * we don't leave any garbage around. This is necessary to handle the
+	 * following calling sequence:
+	 *    exit -> proc_exit -> lx_freelwp -> removectx
+	 * That is, when our branded process exits, proc_exit will call our
+	 * lx_freelwp brand hook which does call this function (lx_cleanlwp),
+	 * but lx_freelwp also removes our context exit operation. The context
+	 * exit functions are run by exitctx, which is called by either
+	 * lwp_exit or thread_exit. The thread_exit function is called at the
+	 * end of proc_exit when we'll swtch() to another thread, but by then
+	 * our context exit function has been removed.
+	 *
+	 * It's ok if this function happens to be called more than once (for
+	 * example, if we exec a native binary).
+	 */
+	kpreempt_disable();
+	lx_save(lwp);
+	kpreempt_enable();
 }
 
 void
-- 
2.21.0

