commit 6cf40d9218f195dd8ea6ec61b8efec3ad9252d10 (refs/changes/22/2822/3)
Author: Jerry Jelinek <jerry.jelinek@joyent.com>
Date:   2017-10-20T16:32:41+00:00 (2 years ago)
    
    OS-6338 panic from kvm_load_gs

diff --git a/usr/src/uts/common/brand/lx/os/lx_misc.c b/usr/src/uts/common/brand/lx/os/lx_misc.c
index 53963c0f7d..6e28d226f7 100644
--- a/usr/src/uts/common/brand/lx/os/lx_misc.c
+++ b/usr/src/uts/common/brand/lx/os/lx_misc.c
@@ -183,6 +183,24 @@ lx_cleanlwp(klwp_t *lwp, proc_t *p)
 	if (rb_list != NULL) {
 		lx_futex_robust_exit((uintptr_t)rb_list, lwpd->br_pid);
 	}
+
+	/*
+	 * We need to run our context exit operation (lx_save) here to ensure
+	 * we don't leave any garbage around. This is necessary to handle the
+	 * following calling sequence:
+	 *    exit -> proc_exit -> lx_freelwp -> removectx
+	 * That is, when our branded process exits, proc_exit will call our
+	 * lx_freelwp brand hook which does call this function (lx_cleanlwp),
+	 * but lx_freelwp also removes our context exit operation. The context
+	 * exit functions are run by exitctx, which is called by either
+	 * lwp_exit or thread_exit. The thread_exit function is called at the
+	 * end of proc_exit when we'll swtch() to another thread, but by then
+	 * our context exit function has been removed.
+	 *
+	 * Its ok if this function happens to be called more than once. For
+	 * example, if we exec a native binary.
+	 */
+	lx_save(lwp);
 }
 
 void
