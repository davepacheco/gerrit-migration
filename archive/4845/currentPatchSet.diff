commit 1d5ed160d3a29de8b55fbca0c9433841e76100ab (refs/changes/45/4845/1)
Author: Joshua M. Clulow <jmc@joyent.com>
Date:   2018-09-16T13:55:51-07:00 (1 year, 1 month ago)
    
    XXX OS-4278 delegated datasets could have better in-zone names Co-authors: myself & alex

diff --git a/usr/src/cmd/zoneadmd/Makefile.com b/usr/src/cmd/zoneadmd/Makefile.com
index 6312c00ad5..f9fe2a366a 100644
--- a/usr/src/cmd/zoneadmd/Makefile.com
+++ b/usr/src/cmd/zoneadmd/Makefile.com
@@ -35,7 +35,7 @@ OBJS= zoneadmd.o zcons.o zfd.o vplat.o log.o
 CFLAGS += $(CCVERBOSE)
 LDLIBS += -lsocket -lzonecfg -lnsl -ldevinfo -ldevice -lnvpair \
 	-lgen -lbsm -lcontract -lzfs -luuid -lbrand -ldladm -ltsnet -ltsol \
-	-linetutil -lproc -lscf -lppt
+	-linetutil -lproc -lscf -lppt -lcmdutils
 
 CSTD= $(CSTD_GNU99)
 
diff --git a/usr/src/cmd/zoneadmd/vplat.c b/usr/src/cmd/zoneadmd/vplat.c
index f466836b96..75299c326d 100644
--- a/usr/src/cmd/zoneadmd/vplat.c
+++ b/usr/src/cmd/zoneadmd/vplat.c
@@ -130,6 +130,8 @@
 #include <sys/priv.h>
 #include <libinetutil.h>
 
+#include <libcmdutils.h>
+
 #define	V4_ADDR_LEN	32
 #define	V6_ADDR_LEN	128
 
@@ -3505,17 +3507,16 @@ get_implicit_datasets(zlog_t *zlogp, char **retstr)
 }
 
 static int
-get_datasets(zlog_t *zlogp, char **bufp, size_t *bufsizep)
+get_datasets(zlog_t *zlogp, custr_t **datasetsp)
 {
 	struct zone_dstab dstab;
-	size_t total, offset, len;
 	int error = -1;
-	char *str = NULL;
 	char *implicit_datasets = NULL;
 	int implicit_len = 0;
+	custr_t *cu = NULL;
+	int count = 0;
 
-	*bufp = NULL;
-	*bufsizep = 0;
+	*datasetsp = NULL;
 
 	if (get_implicit_datasets(zlogp, &implicit_datasets) != 0) {
 		zerror(zlogp, B_FALSE, "getting implicit datasets failed");
@@ -3527,22 +3528,7 @@ get_datasets(zlog_t *zlogp, char **bufp, size_t *bufsizep)
 		goto out;
 	}
 
-	total = 0;
-	while (zonecfg_getdsent(snap_hndl, &dstab) == Z_OK)
-		total += strlen(dstab.zone_dataset_name) + 1;
-	(void) zonecfg_enddsent(snap_hndl);
-
-	if (implicit_datasets != NULL)
-		implicit_len = strlen(implicit_datasets);
-	if (implicit_len > 0)
-		total += implicit_len + 1;
-
-	if (total == 0) {
-		error = 0;
-		goto out;
-	}
-
-	if ((str = malloc(total)) == NULL) {
+	if (custr_alloc(&cu) != 0) {
 		zerror(zlogp, B_TRUE, "memory allocation failed");
 		goto out;
 	}
@@ -3551,29 +3537,48 @@ get_datasets(zlog_t *zlogp, char **bufp, size_t *bufsizep)
 		zerror(zlogp, B_FALSE, "%s failed", "zonecfg_setdsent");
 		goto out;
 	}
-	offset = 0;
 	while (zonecfg_getdsent(snap_hndl, &dstab) == Z_OK) {
-		len = strlen(dstab.zone_dataset_name);
-		(void) strlcpy(str + offset, dstab.zone_dataset_name,
-		    total - offset);
-		offset += len;
-		if (offset < total - 1)
-			str[offset++] = ',';
+		const char *alias = dstab.zone_dataset_alias[0] != '\0' ?
+		    dstab.zone_dataset_alias : NULL;
+
+		if (count++ > 0 && custr_appendc(cu, ',') != 0) {
+			zerror(zlogp, B_TRUE, "memory allocation failed");
+			goto out;
+		}
+
+		if (custr_append(cu, dstab.zone_dataset_name) != 0) {
+			zerror(zlogp, B_TRUE, "memory allocation failed");
+			goto out;
+		}
+
+		if (alias != NULL && custr_append_printf(cu, "|%s",
+		    alias) != 0) {
+			zerror(zlogp, B_TRUE, "memory allocation failed");
+			goto out;
+		}
 	}
 	(void) zonecfg_enddsent(snap_hndl);
 
-	if (implicit_len > 0)
-		(void) strlcpy(str + offset, implicit_datasets, total - offset);
+	if (implicit_len > 0) {
+		if (count++ > 0 && custr_appendc(cu, ',') != 0) {
+			zerror(zlogp, B_TRUE, "memory allocation failed");
+			goto out;
+		}
+		if (custr_append(cu, implicit_datasets) != 0) {
+			zerror(zlogp, B_TRUE, "memory allocation failed");
+			goto out;
+		}
+	}
 
 	error = 0;
-	*bufp = str;
-	*bufsizep = total;
 
 out:
-	if (error != 0 && str != NULL)
-		free(str);
-	if (implicit_datasets != NULL)
-		free(implicit_datasets);
+	if (error != 0) {
+		custr_free(cu);
+	} else {
+		*datasetsp = cu;
+	}
+	free(implicit_datasets);
 
 	return (error);
 }
@@ -4704,8 +4709,9 @@ vplat_create(zlog_t *zlogp, zone_mnt_t mount_cmd, zoneid_t zone_did)
 	char rootpath[MAXPATHLEN];
 	char *rctlbuf = NULL;
 	size_t rctlbufsz = 0;
-	char *zfsbuf = NULL;
+	const char *zfsbuf = NULL;
 	size_t zfsbufsz = 0;
+	custr_t *datasets = NULL;
 	zoneid_t zoneid = -1;
 	int xerr;
 	char *kzone;
@@ -4752,10 +4758,14 @@ vplat_create(zlog_t *zlogp, zone_mnt_t mount_cmd, zoneid_t zone_did)
 		goto error;
 	}
 
-	if (get_datasets(zlogp, &zfsbuf, &zfsbufsz) != 0) {
+	if (get_datasets(zlogp, &datasets) != 0) {
 		zerror(zlogp, B_FALSE, "Unable to get list of ZFS datasets");
 		goto error;
 	}
+	if (datasets != NULL) {
+		zfsbuf = custr_cstr(datasets);
+		zfsbufsz = custr_len(datasets);
+	}
 
 	if (mount_cmd == Z_MNT_BOOT && is_system_labeled()) {
 		zcent = get_zone_label(zlogp, privs);
@@ -4942,10 +4952,8 @@ error:
 		(void) zone_shutdown(zoneid);
 		(void) zone_destroy(zoneid);
 	}
-	if (rctlbuf != NULL)
-		free(rctlbuf);
-	if (zfsbuf != NULL)
-		free(zfsbuf);
+	free(rctlbuf);
+	custr_free(datasets);
 	priv_freeset(privs);
 	if (fp != NULL)
 		zonecfg_close_scratch(fp);
diff --git a/usr/src/cmd/zonecfg/zonecfg.c b/usr/src/cmd/zonecfg/zonecfg.c
index 512f27d1e6..159514b6f2 100644
--- a/usr/src/cmd/zonecfg/zonecfg.c
+++ b/usr/src/cmd/zonecfg/zonecfg.c
@@ -249,6 +249,7 @@ char *prop_types[] = {
 	"default",
 	"lower",
 	"upper",
+	"alias",
 	NULL
 };
 
@@ -1234,6 +1235,8 @@ usage(boolean_t verbose, uint_t flags)
 			(void) fprintf(fp, gettext("Valid commands:\n"));
 			(void) fprintf(fp, "\t%s %s=%s\n", cmd_to_str(CMD_SET),
 			    pt_to_str(PT_NAME), gettext("<name>"));
+			(void) fprintf(fp, "\t%s %s=%s\n", cmd_to_str(CMD_SET),
+			    pt_to_str(PT_ALIAS), gettext("<alias>"));
 			break;
 		case RT_DCPU:
 			(void) fprintf(fp, gettext("The '%s' resource scope "
@@ -1437,8 +1440,8 @@ usage(boolean_t verbose, uint_t flags)
 		(void) fprintf(fp, "\t%s\t\t%s, %s, %s\n", rt_to_str(RT_ATTR),
 		    pt_to_str(PT_NAME), pt_to_str(PT_TYPE),
 		    pt_to_str(PT_VALUE));
-		(void) fprintf(fp, "\t%s\t\t%s\n", rt_to_str(RT_DATASET),
-		    pt_to_str(PT_NAME));
+		(void) fprintf(fp, "\t%s\t\t%s, %s\n", rt_to_str(RT_DATASET),
+		    pt_to_str(PT_NAME), pt_to_str(PT_ALIAS));
 		(void) fprintf(fp, "\t%s\t%s, %s\n", rt_to_str(RT_DCPU),
 		    pt_to_str(PT_NCPUS), pt_to_str(PT_IMPORTANCE));
 		(void) fprintf(fp, "\t%s\t%s\n", rt_to_str(RT_PCAP),
@@ -2168,6 +2171,9 @@ export_func(cmd_t *cmd)
 		(void) fprintf(of, "%s %s\n", cmd_to_str(CMD_ADD),
 		    rt_to_str(RT_DATASET));
 		export_prop(of, PT_NAME, dstab.zone_dataset_name);
+		if (dstab.zone_dataset_alias[0] != '\0') {
+			export_prop(of, PT_ALIAS, dstab.zone_dataset_alias);
+		}
 		(void) fprintf(of, "%s\n", cmd_to_str(CMD_END));
 	}
 	(void) zonecfg_enddsent(handle);
@@ -3169,6 +3175,7 @@ fill_in_dstab(cmd_t *cmd, struct zone_dstab *dstab, boolean_t fill_in_only)
 		return (err);
 
 	dstab->zone_dataset_name[0] = '\0';
+	dstab->zone_dataset_alias[0] = '\0';
 	for (i = 0; i < cmd->cmd_prop_nv_pairs; i++) {
 		pp = cmd->cmd_property_ptr[i];
 		if (pp->pv_type != PROP_VAL_SIMPLE || pp->pv_simple == NULL) {
@@ -3181,6 +3188,10 @@ fill_in_dstab(cmd_t *cmd, struct zone_dstab *dstab, boolean_t fill_in_only)
 			(void) strlcpy(dstab->zone_dataset_name, pp->pv_simple,
 			    sizeof (dstab->zone_dataset_name));
 			break;
+		case PT_ALIAS:
+			(void) strlcpy(dstab->zone_dataset_alias, pp->pv_simple,
+			    sizeof (dstab->zone_dataset_alias));
+			break;
 		default:
 			zone_perror(pt_to_str(cmd->cmd_prop_name[i]),
 			    Z_NO_PROPERTY_TYPE, B_TRUE);
@@ -4069,6 +4080,13 @@ clear_property(cmd_t *cmd)
 			return;
 		}
 		break;
+	case RT_DATASET:
+		if (prop_type == PT_ALIAS) {
+			in_progress_dstab.zone_dataset_alias[0] = '\0';
+			need_to_commit = B_TRUE;
+			return;
+		}
+		break;
 	case RT_DCPU:
 		if (prop_type == PT_IMPORTANCE) {
 			in_progress_psettab.zone_importance[0] = '\0';
@@ -5175,6 +5193,11 @@ set_func(cmd_t *cmd)
 			    prop_id,
 			    sizeof (in_progress_dstab.zone_dataset_name));
 			return;
+		case PT_ALIAS:
+			(void) strlcpy(in_progress_dstab.zone_dataset_alias,
+			    prop_id,
+			    sizeof (in_progress_dstab.zone_dataset_alias));
+			return;
 		default:
 			break;
 		}
@@ -5881,6 +5904,7 @@ output_ds(FILE *fp, struct zone_dstab *dstab)
 {
 	(void) fprintf(fp, "%s:\n", rt_to_str(RT_DATASET));
 	output_prop(fp, PT_NAME, dstab->zone_dataset_name, B_TRUE);
+	output_prop(fp, PT_ALIAS, dstab->zone_dataset_alias, B_TRUE);
 }
 
 static void
@@ -5902,6 +5926,10 @@ info_ds(zone_dochandle_t handle, FILE *fp, cmd_t *cmd)
 		    strcmp(user.zone_dataset_name,
 		    lookup.zone_dataset_name) != 0)
 			continue;	/* no match */
+		if (strlen(user.zone_dataset_alias) > 0 &&
+		    strcmp(user.zone_dataset_alias,
+		    lookup.zone_dataset_alias) != 0)
+			continue;	/* no match */
 		output_ds(fp, &lookup);
 		output = B_TRUE;
 	}
diff --git a/usr/src/cmd/zonecfg/zonecfg.h b/usr/src/cmd/zonecfg/zonecfg.h
index e4ae4d4d61..ae5809a3bb 100644
--- a/usr/src/cmd/zonecfg/zonecfg.h
+++ b/usr/src/cmd/zonecfg/zonecfg.h
@@ -150,9 +150,10 @@ extern "C" {
 #define	PT_DEFAULT	48
 #define	PT_LOWER	49
 #define	PT_UPPER	50
+#define	PT_ALIAS	51
 
 #define	PT_MIN		PT_UNKNOWN
-#define	PT_MAX		PT_UPPER
+#define	PT_MAX		PT_ALIAS
 
 #define	MAX_EQ_PROP_PAIRS	3
 
diff --git a/usr/src/cmd/zonecfg/zonecfg_grammar.y b/usr/src/cmd/zonecfg/zonecfg_grammar.y
index d8b2fadb2f..5245ff3596 100644
--- a/usr/src/cmd/zonecfg/zonecfg_grammar.y
+++ b/usr/src/cmd/zonecfg/zonecfg_grammar.y
@@ -138,7 +138,7 @@ complex_piece_func(int cp_type, const char *str, complex_property_ptr_t cp_next)
 %token MCAP NCPUS IMPORTANCE SHARES MAXLWPS MAXSHMMEM MAXSHMIDS MAXMSGIDS
 %token MAXSEMIDS LOCKED SWAP SCHED CLEAR DEFROUTER ADMIN USER AUTHS MAXPROCS
 %token ZFSPRI MAC VLANID GNIC NPROP UUID SECFLAGS
-%token DEFAULT UPPER LOWER
+%token DEFAULT UPPER LOWER ALIAS
 
 %type <strval> TOKEN EQUAL OPEN_SQ_BRACKET CLOSE_SQ_BRACKET
     property_value OPEN_PAREN CLOSE_PAREN COMMA simple_prop_val
@@ -148,7 +148,7 @@ complex_piece_func(int cp_type, const char *str, complex_property_ptr_t cp_next)
 %type <ival> property_name SPECIAL RAW DIR OPTIONS TYPE ADDRESS PHYSICAL NAME
     MATCH ZONENAME ZONEPATH AUTOBOOT POOL LIMITPRIV BOOTARGS VALUE PRIV LIMIT
     ACTION BRAND SCHED IPTYPE DEFROUTER HOSTID USER AUTHS FS_ALLOWED
-    ALLOWED_ADDRESS MAC VLANID GNIC NPROP UUID DEFAULT UPPER LOWER
+    ALLOWED_ADDRESS MAC VLANID GNIC NPROP UUID DEFAULT UPPER LOWER ALIAS
 %type <cmd> command
 %type <cmd> add_command ADD
 %type <cmd> cancel_command CANCEL
@@ -1091,6 +1091,7 @@ property_name: SPECIAL	{ $$ = PT_SPECIAL; }
 	| DEFAULT	{ $$ = PT_DEFAULT; }
 	| UPPER		{ $$ = PT_UPPER; }
 	| LOWER		{ $$ = PT_LOWER; }
+	| ALIAS		{ $$ = PT_ALIAS; }
 
 /*
  * The grammar builds data structures from the bottom up.  Thus various
diff --git a/usr/src/cmd/zonecfg/zonecfg_lex.l b/usr/src/cmd/zonecfg/zonecfg_lex.l
index 05b41df48b..0492100da8 100644
--- a/usr/src/cmd/zonecfg/zonecfg_lex.l
+++ b/usr/src/cmd/zonecfg/zonecfg_lex.l
@@ -339,6 +339,8 @@ static char *create_token(char *s);
 <TSTATE>upper { return UPPER; }
 <CSTATE>upper { return UPPER; }
 
+<TSTATE>alias		{ return ALIAS; }
+
 <TSTATE>=	{ return EQUAL; }
 <LSTATE>=	{ return EQUAL; }
 <CSTATE>=	{ return EQUAL; }
diff --git a/usr/src/head/libzonecfg.h b/usr/src/head/libzonecfg.h
index 4121b6a490..fc9506a093 100644
--- a/usr/src/head/libzonecfg.h
+++ b/usr/src/head/libzonecfg.h
@@ -253,6 +253,7 @@ struct zone_attrtab {
 
 struct zone_dstab {
 	char	zone_dataset_name[MAXNAMELEN];
+	char	zone_dataset_alias[MAXNAMELEN];
 };
 
 struct zone_psettab {
diff --git a/usr/src/lib/libzonecfg/common/libzonecfg.c b/usr/src/lib/libzonecfg/common/libzonecfg.c
index c524901d48..7868a17cb4 100644
--- a/usr/src/lib/libzonecfg/common/libzonecfg.c
+++ b/usr/src/lib/libzonecfg/common/libzonecfg.c
@@ -107,6 +107,7 @@
 
 #define	DTD_ATTR_ACTION		(const xmlChar *) "action"
 #define	DTD_ATTR_ADDRESS	(const xmlChar *) "address"
+#define	DTD_ATTR_ALIAS		(const xmlChar *) "alias"
 #define	DTD_ATTR_ALLOWED_ADDRESS	(const xmlChar *) "allowed-address"
 #define	DTD_ATTR_AUTOBOOT	(const xmlChar *) "autoboot"
 #define	DTD_ATTR_IPTYPE		(const xmlChar *) "ip-type"
@@ -7021,6 +7022,11 @@ zonecfg_add_ds_core(zone_dochandle_t handle, struct zone_dstab *tabptr)
 	if ((err = newprop(newnode, DTD_ATTR_NAME,
 	    tabptr->zone_dataset_name)) != Z_OK)
 		return (err);
+	if (tabptr->zone_dataset_alias[0] != '\0') {
+		if ((err = newprop(newnode, DTD_ATTR_ALIAS,
+		    tabptr->zone_dataset_alias)) != Z_OK)
+			return (err);
+	}
 	return (Z_OK);
 }
 
@@ -7051,7 +7057,9 @@ zonecfg_delete_ds_core(zone_dochandle_t handle, struct zone_dstab *tabptr)
 			continue;
 
 		if (match_prop(cur, DTD_ATTR_NAME,
-		    tabptr->zone_dataset_name)) {
+		    tabptr->zone_dataset_name) &&
+		    match_prop(cur, DTD_ATTR_ALIAS,
+		    tabptr->zone_dataset_alias)) {
 			xmlUnlinkNode(cur);
 			xmlFreeNode(cur);
 			return (Z_OK);
@@ -7106,6 +7114,7 @@ zonecfg_lookup_ds(zone_dochandle_t handle, struct zone_dstab *tabptr)
 	xmlNodePtr cur, firstmatch;
 	int err;
 	char dataset[MAXNAMELEN];
+	char alias[MAXNAMELEN];
 
 	if (tabptr == NULL)
 		return (Z_INVAL);
@@ -7129,6 +7138,25 @@ zonecfg_lookup_ds(zone_dochandle_t handle, struct zone_dstab *tabptr)
 					return (Z_INSUFFICIENT_SPEC);
 			}
 		}
+		if (strlen(tabptr->zone_dataset_alias) > 0) {
+			if ((fetchprop(cur, DTD_ATTR_ALIAS, alias,
+			    sizeof (alias)) == Z_OK)) {
+				if (strcmp(tabptr->zone_dataset_alias,
+				    alias) == 0) {
+					if (firstmatch == NULL)
+						firstmatch = cur;
+					else if (firstmatch != cur)
+						return (Z_INSUFFICIENT_SPEC);
+				} else {
+					/*
+					 * If another property matched but this
+					 * one doesn't then reset firstmatch.
+					 */
+					if (firstmatch == cur)
+						firstmatch = NULL;
+				}
+			}
+		}
 	}
 	if (firstmatch == NULL)
 		return (Z_NO_RESOURCE_ID);
@@ -7138,6 +7166,9 @@ zonecfg_lookup_ds(zone_dochandle_t handle, struct zone_dstab *tabptr)
 	if ((err = fetchprop(cur, DTD_ATTR_NAME, tabptr->zone_dataset_name,
 	    sizeof (tabptr->zone_dataset_name))) != Z_OK)
 		return (err);
+	if ((err = fetchprop(cur, DTD_ATTR_ALIAS, tabptr->zone_dataset_alias,
+	    sizeof (tabptr->zone_dataset_alias))) != Z_OK)
+		return (err);
 
 	return (Z_OK);
 }
@@ -7173,6 +7204,11 @@ zonecfg_getdsent(zone_dochandle_t handle, struct zone_dstab *tabptr)
 		handle->zone_dh_cur = handle->zone_dh_top;
 		return (err);
 	}
+	if ((err = fetchprop(cur, DTD_ATTR_ALIAS, tabptr->zone_dataset_alias,
+	    sizeof (tabptr->zone_dataset_alias))) != Z_OK) {
+		handle->zone_dh_cur = handle->zone_dh_top;
+		return (err);
+	}
 
 	handle->zone_dh_cur = cur->next;
 	return (Z_OK);
diff --git a/usr/src/lib/libzonecfg/dtd/zonecfg.dtd.1 b/usr/src/lib/libzonecfg/dtd/zonecfg.dtd.1
index 228bb8ace2..ee72fa0759 100644
--- a/usr/src/lib/libzonecfg/dtd/zonecfg.dtd.1
+++ b/usr/src/lib/libzonecfg/dtd/zonecfg.dtd.1
@@ -100,7 +100,8 @@
 
 <!ELEMENT dataset	EMPTY>
 
-<!ATTLIST dataset	name		CDATA #REQUIRED>
+<!ATTLIST dataset	name		CDATA #REQUIRED
+			alias		CDATA "">
 
 <!ELEMENT package	EMPTY>
 
diff --git a/usr/src/lib/libzpool/common/sys/zfs_context.h b/usr/src/lib/libzpool/common/sys/zfs_context.h
index 199f7203c9..517205e2ef 100644
--- a/usr/src/lib/libzpool/common/sys/zfs_context.h
+++ b/usr/src/lib/libzpool/common/sys/zfs_context.h
@@ -315,7 +315,7 @@ typedef struct callb_cpr {
 	mutex_exit((cp)->cc_lockp);				\
 }
 
-#define	zone_dataset_visible(x, y)	(1)
+#define	zone_dataset_visible(x, y, z)	(1)
 #define	INGLOBALZONE(z)			(1)
 extern uint32_t zone_get_hostid(void *zonep);
 
diff --git a/usr/src/uts/common/brand/lx/os/lx_brand.c b/usr/src/uts/common/brand/lx/os/lx_brand.c
index 974c8603e0..f3a66ccdca 100644
--- a/usr/src/uts/common/brand/lx/os/lx_brand.c
+++ b/usr/src/uts/common/brand/lx/os/lx_brand.c
@@ -1020,8 +1020,10 @@ lx_zone_get_zvols(zone_t *zone, ldi_handle_t lh, minor_t *emul_minor)
 			    strchr(zc->zc_name, '%') != NULL)
 				continue;
 
-			if (!zone_dataset_visible_inzone(zone, zc->zc_name, &w))
+			if (!zone_dataset_visible_inzone(zone, zc->zc_name, &w,
+			    B_TRUE)) {
 				continue;
+			}
 
 			if (zc->zc_objset_stats.dds_type == DMU_OST_ZVOL) {
 				lx_virt_disk_t *vd;
diff --git a/usr/src/uts/common/fs/dev/sdev_zvolops.c b/usr/src/uts/common/fs/dev/sdev_zvolops.c
index a52606aeda..c73c677467 100644
--- a/usr/src/uts/common/fs/dev/sdev_zvolops.c
+++ b/usr/src/uts/common/fs/dev/sdev_zvolops.c
@@ -863,6 +863,9 @@ sdev_iter_datasets(struct vnode *dvp, int arg, char *name)
 		sdcmn_err13(("  name %s", zc->zc_name));
 		if (strchr(zc->zc_name, '$') || strchr(zc->zc_name, '%'))
 			goto skip;
+		if (strrchr(zc->zc_name, '/') == NULL) {
+			goto skip;
+		}
 		ptr = strrchr(zc->zc_name, '/') + 1;
 		rc = devzvol_lookup(dvp, ptr, &vpp, NULL, 0, NULL,
 		    kcred, NULL, NULL, NULL);
diff --git a/usr/src/uts/common/fs/zfs/spa_config.c b/usr/src/uts/common/fs/zfs/spa_config.c
index 7d568ffcf8..2fe66dc2a0 100644
--- a/usr/src/uts/common/fs/zfs/spa_config.c
+++ b/usr/src/uts/common/fs/zfs/spa_config.c
@@ -322,7 +322,7 @@ spa_all_configs(uint64_t *generation)
 	mutex_enter(&spa_namespace_lock);
 	while ((spa = spa_next(spa)) != NULL) {
 		if (INGLOBALZONE(curproc) ||
-		    zone_dataset_visible(spa_name(spa), NULL)) {
+		    zone_dataset_visible(spa_name(spa), NULL, B_TRUE)) {
 			mutex_enter(&spa->spa_props_lock);
 			fnvlist_add_nvlist(pools, spa_name(spa),
 			    spa->spa_config);
diff --git a/usr/src/uts/common/fs/zfs/zfs_ioctl.c b/usr/src/uts/common/fs/zfs/zfs_ioctl.c
index ffdc9ad6a0..07f719996b 100644
--- a/usr/src/uts/common/fs/zfs/zfs_ioctl.c
+++ b/usr/src/uts/common/fs/zfs/zfs_ioctl.c
@@ -417,7 +417,17 @@ static int
 zfs_secpolicy_read(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)
 {
 	if (INGLOBALZONE(curproc) ||
-	    zone_dataset_visible(zc->zc_name, NULL))
+	    zone_dataset_visible(zc->zc_name, NULL, B_FALSE))
+		return (0);
+
+	return (SET_ERROR(ENOENT));
+}
+
+static int
+zfs_secpolicy_read_pool(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)
+{
+	if (INGLOBALZONE(curproc) ||
+	    zone_dataset_visible(zc->zc_name, NULL, B_TRUE))
 		return (0);
 
 	return (SET_ERROR(ENOENT));
@@ -433,7 +443,7 @@ zfs_dozonecheck_impl(const char *dataset, uint64_t zoned, cred_t *cr)
 	 * so they don't see EPERM on something they shouldn't know about.
 	 */
 	if (!INGLOBALZONE(curproc) &&
-	    !zone_dataset_visible(dataset, &writable))
+	    !zone_dataset_visible(dataset, &writable, B_FALSE))
 		return (SET_ERROR(ENOENT));
 
 	if (INGLOBALZONE(curproc)) {
@@ -1616,6 +1626,94 @@ zfs_ioc_pool_export(zfs_cmd_t *zc)
 	return (error);
 }
 
+static boolean_t
+zfs_ioc_zone_ds_matches(const char *dataset, zone_dataset_t *zd)
+{
+	size_t len;
+
+	len = strlen(zd->zd_dataset);
+	if (strlen(dataset) >= len &&
+	    bcmp(dataset, zd->zd_dataset, len) == 0 &&
+	    (dataset[len] == '\0' || dataset[len] == '/' ||
+	    dataset[len] == '@')) {
+		return (B_TRUE);
+	}
+
+	len = strlen(dataset);
+	if (dataset[len - 1] == '/')
+		len--;	/* Ignore trailing slash */
+	if (len < strlen(zd->zd_dataset) &&
+	    bcmp(dataset, zd->zd_dataset, len) == 0 &&
+	    zd->zd_dataset[len] == '/') {
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
+static int
+zfs_ioc_pool_configs_alias(nvlist_t **configs)
+{
+	nvlist_t *all = *configs;
+	nvlist_t *pool = NULL;
+	nvpair_t *elem = NULL;
+	char *name;
+	char aname[MAXPATHLEN];
+	size_t len;
+	zone_dataset_t *zd;
+	boolean_t found;
+	int error = 0;
+	zone_t *zone = curzone;
+
+	*configs = NULL;
+	VERIFY(nvlist_alloc(configs, NV_UNIQUE_NAME, KM_SLEEP) == 0);
+
+	/*
+	 * For each pool, we want to create an entry in the final list,
+	 * and possibly rename it to reflect an alias. It's also possible
+	 * we will need to do both (for two delegated datasets under the
+	 * same pool, one aliased and one not).
+	 *
+	 * Since we made configs with NV_UNIQUE_NAME, re-adding the same
+	 * pool multiple times is not really a problem, so we just do a
+	 * native nested loop over all of the possible combinations.
+	 */
+	while ((elem = nvlist_next_nvpair(all, elem)) != NULL) {
+		name = nvpair_name(elem);
+		VERIFY(nvpair_value_nvlist(elem, &pool) == 0);
+
+		found = B_FALSE;
+		for (zd = list_head(&zone->zone_datasets); zd != NULL;
+		    zd = list_next(&zone->zone_datasets, zd)) {
+			if (zfs_ioc_zone_ds_matches(name, zd) == B_TRUE) {
+				if (zd->zd_alias == NULL) {
+					VERIFY(nvlist_add_string(pool,
+					    "name", name) == 0);
+					VERIFY(nvlist_add_nvlist(*configs,
+					    name, pool) == 0);
+				} else {
+					VERIFY(nvlist_add_string(pool,
+					    "name", zd->zd_alias) == 0);
+					VERIFY(nvlist_add_nvlist(*configs,
+					    zd->zd_alias, pool) == 0);
+				}
+				found = B_TRUE;
+			}
+		}
+		/*
+		 * If we found no zone_dataset_t, it was a VFS-style pass-
+		 * through into the zone. This kind has no aliasing, so
+		 * add the pool under its usual name.
+		 */
+		if (found == B_FALSE)
+			VERIFY(nvlist_add_nvlist(*configs, name, pool) == 0);
+	}
+
+out:
+	nvlist_free(all);
+	return (error);
+}
+
 static int
 zfs_ioc_pool_configs(zfs_cmd_t *zc)
 {
@@ -1625,6 +1723,14 @@ zfs_ioc_pool_configs(zfs_cmd_t *zc)
 	if ((configs = spa_all_configs(&zc->zc_cookie)) == NULL)
 		return (SET_ERROR(EEXIST));
 
+	if (!INGLOBALZONE(curproc)) {
+		error = zfs_ioc_pool_configs_alias(&configs);
+		if (error != 0) {
+			nvlist_free(configs);
+			return (SET_ERROR(error));
+		}
+	}
+
 	error = put_nvlist(zc, configs);
 
 	nvlist_free(configs);
@@ -1651,6 +1757,30 @@ zfs_ioc_pool_stats(zfs_cmd_t *zc)
 	error = spa_get_stats(zc->zc_name, &config, zc->zc_value,
 	    sizeof (zc->zc_value));
 
+	/*
+	 * If we're returning the name property to a non-global zone, apply
+	 * aliases as needed.
+	 */
+	if (config != NULL && !INGLOBALZONE(curproc)) {
+		char *val = NULL;
+		zone_dataset_t *zd;
+		zone_t *zone = curzone;
+		boolean_t m;
+
+		if (nvlist_lookup_string(config, "name", &val) == 0) {
+			for (zd = list_head(&zone->zone_datasets); zd != NULL;
+			    zd = list_next(&zone->zone_datasets, zd)) {
+				if (zd->zd_alias == NULL)
+					continue;
+				m = zfs_ioc_zone_ds_matches(val, zd);
+				if (m == B_TRUE) {
+					VERIFY(nvlist_add_string(config,
+					    "name", zd->zd_alias) == 0);
+				}
+			}
+		}
+	}
+
 	if (config != NULL) {
 		ret = put_nvlist(zc, config);
 		nvlist_free(config);
@@ -2265,8 +2395,10 @@ dataset_name_hidden(const char *name)
 		return (B_TRUE);
 	if (strchr(name, '%') != NULL)
 		return (B_TRUE);
-	if (!INGLOBALZONE(curproc) && !zone_dataset_visible(name, NULL))
+	if (!INGLOBALZONE(curproc) && !zone_dataset_visible(name, NULL,
+	    B_FALSE)) {
 		return (B_TRUE);
+	}
 	return (B_FALSE);
 }
 
@@ -2941,6 +3073,7 @@ zfs_ioc_pool_get_props(zfs_cmd_t *zc)
 	spa_t *spa;
 	int error;
 	nvlist_t *nvp = NULL;
+	nvlist_t *temp;
 
 	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0) {
 		/*
@@ -2957,6 +3090,29 @@ zfs_ioc_pool_get_props(zfs_cmd_t *zc)
 		spa_close(spa, FTAG);
 	}
 
+	/* Apply aliases to pool info given to non-global zones. */
+	if (error == 0 && zc->zc_nvlist_dst != NULL &&
+	    !INGLOBALZONE(curproc) &&
+	    nvlist_lookup_nvlist(nvp, "name", &temp) == 0) {
+		char *val = NULL;
+		zone_dataset_t *zd;
+		zone_t *zone = curzone;
+		boolean_t m;
+
+		VERIFY(nvlist_lookup_string(temp, "value", &val) == 0);
+
+		for (zd = list_head(&zone->zone_datasets); zd != NULL;
+		    zd = list_next(&zone->zone_datasets, zd)) {
+			if (zd->zd_alias == NULL)
+				continue;
+			m = zfs_ioc_zone_ds_matches(val, zd);
+			if (m == B_TRUE) {
+				VERIFY(nvlist_add_string(temp,
+				    "value", zd->zd_alias) == 0);
+			}
+		}
+	}
+
 	if (error == 0 && zc->zc_nvlist_dst != NULL)
 		error = put_nvlist(zc, nvp);
 	else
@@ -6032,9 +6188,9 @@ zfs_ioctl_init(void)
 	    zfs_secpolicy_config, B_FALSE, POOL_CHECK_NONE);
 
 	zfs_ioctl_register_pool(ZFS_IOC_POOL_STATS, zfs_ioc_pool_stats,
-	    zfs_secpolicy_read, B_FALSE, POOL_CHECK_NONE);
+	    zfs_secpolicy_read_pool, B_FALSE, POOL_CHECK_NONE);
 	zfs_ioctl_register_pool(ZFS_IOC_POOL_GET_PROPS, zfs_ioc_pool_get_props,
-	    zfs_secpolicy_read, B_FALSE, POOL_CHECK_NONE);
+	    zfs_secpolicy_read_pool, B_FALSE, POOL_CHECK_NONE);
 
 	zfs_ioctl_register_pool(ZFS_IOC_ERROR_LOG, zfs_ioc_error_log,
 	    zfs_secpolicy_inject, B_FALSE, POOL_CHECK_SUSPENDED);
@@ -6253,6 +6409,9 @@ zfsdev_ioctl(dev_t dev, int cmd, intptr_t arg, int flag, cred_t *cr, int *rvalp)
 	const zfs_ioc_vec_t *vec;
 	char *saved_poolname = NULL;
 	nvlist_t *innvl = NULL;
+	char *oname = NULL;
+	zone_dataset_t *zd = NULL;
+	zone_t *zone = curzone;
 
 	if (minor != 0 &&
 	    zfsdev_get_soft_state(minor, ZSST_CTLDEV) == NULL)
@@ -6281,11 +6440,55 @@ zfsdev_ioctl(dev_t dev, int cmd, intptr_t arg, int flag, cred_t *cr, int *rvalp)
 			goto out;
 	}
 
+	/* Make certain zc_name is NULL-terminated. */
+	zc->zc_name[sizeof (zc->zc_name) - 1] = '\0';
+
 	/*
-	 * Ensure that all pool/dataset names are valid before we pass down to
-	 * the lower layers.
+	 * Non-global zones can have dataset aliases which need to be applied
+	 * before we pass down to lower layers.
+	 */
+	if (!INGLOBALZONE(curproc)) {
+		size_t len;
+		char *ptr;
+
+		switch (vec->zvec_namecheck) {
+		case POOL_NAME:
+			/*
+			 * Translate an alias pool back to the original parent
+			 * pool of the delegated dataset.
+			 */
+			for (zd = list_head(&zone->zone_datasets); zd != NULL;
+			    zd = list_next(&zone->zone_datasets, zd)) {
+				if (zd->zd_alias == NULL)
+					continue;
+
+				len = strlen(zd->zd_alias);
+				if (bcmp(zc->zc_name, zd->zd_alias, len) == 0
+				    && strlen(zc->zc_name) == len) {
+					(void) strcpy(zc->zc_name,
+					    zd->zd_dataset);
+					ptr = strchr(zc->zc_name, '/');
+					*ptr = '\0';
+					break;
+				}
+			}
+			break;
+		case DATASET_NAME:
+			oname = kmem_zalloc(MAXPATHLEN, KM_SLEEP);
+			(void) strcpy(oname, zc->zc_name);
+			error = zone_dataset_unalias(oname, zc->zc_name,
+			    MAXPATHLEN);
+			if (error != 0)
+				goto out;
+			break;
+		case NO_NAME:
+			break;
+		}
+	}
+
+	/*
+	 * Ensure that all pool/dataset names are valid.
 	 */
-	zc->zc_name[sizeof (zc->zc_name) - 1] = '\0';
 	switch (vec->zvec_namecheck) {
 	case POOL_NAME:
 		if (pool_namecheck(zc->zc_name, NULL, NULL) != 0)
@@ -6384,6 +6587,37 @@ zfsdev_ioctl(dev_t dev, int cmd, intptr_t arg, int flag, cred_t *cr, int *rvalp)
 		error = vec->zvec_legacy_func(zc);
 	}
 
+	/*
+	 * On successful returns to a non-global zone, make sure any necessary
+	 * un-aliasing we applied earlier to zc_name is returned to the way it
+	 * was before.
+	 */
+	if (error == 0 && !INGLOBALZONE(curproc)) {
+		/*
+		 * If we're a pool-related ioctl, we should have translated
+		 * our input string, earlier, so check that and change it
+		 * back.
+		 */
+		if (vec->zvec_namecheck == POOL_NAME) {
+			if (zd != NULL) {
+				if (bcmp(zd->zd_dataset, zc->zc_name,
+				    strlen(zc->zc_name)) == 0)
+					(void) strcpy(zc->zc_name,
+					    zd->zd_alias);
+			}
+		} else if (zc->zc_name[0] != '\0') {
+			/* Otherwise, try to alias as if it's a dataset. */
+			if (oname == NULL)
+				oname = kmem_zalloc(MAXPATHLEN, KM_SLEEP);
+			(void) strcpy(oname, zc->zc_name);
+			error = zone_dataset_alias(oname, zc->zc_name,
+			    MAXPATHLEN);
+			/* But ignore EINVAL, in case it's not actually one. */
+			if (error == EINVAL)
+				error = 0;
+		}
+	}
+
 out:
 	nvlist_free(innvl);
 	rc = ddi_copyout(zc, (void *)arg, sizeof (zfs_cmd_t), flag);
@@ -6400,6 +6634,8 @@ out:
 	}
 
 	kmem_free(zc, sizeof (zfs_cmd_t));
+	if (oname != NULL)
+		kmem_free(oname, MAXPATHLEN);
 	return (error);
 }
 
diff --git a/usr/src/uts/common/fs/zfs/zfs_vfsops.c b/usr/src/uts/common/fs/zfs/zfs_vfsops.c
index a5912b19ab..403e341b73 100644
--- a/usr/src/uts/common/fs/zfs/zfs_vfsops.c
+++ b/usr/src/uts/common/fs/zfs/zfs_vfsops.c
@@ -1547,6 +1547,7 @@ out:
 static int
 zfs_mount(vfs_t *vfsp, vnode_t *mvp, struct mounta *uap, cred_t *cr)
 {
+	boolean_t	free_osname = B_FALSE;
 	char		*osname;
 	pathname_t	spn;
 	int		error = 0;
@@ -1581,7 +1582,23 @@ zfs_mount(vfs_t *vfsp, vnode_t *mvp, struct mounta *uap, cred_t *cr)
 	if (error = pn_get(uap->spec, fromspace, &spn))
 		return (error);
 
-	osname = spn.pn_path;
+
+	/*
+	 * Non-global zones can be configured to know a delegated dataset by
+	 * an alias, rather than the full objset name.
+	 */
+	if (!INGLOBALZONE(curproc)) {
+		free_osname = B_TRUE;
+		osname = kmem_alloc(MAXPATHLEN, KM_SLEEP);
+
+		if (zone_dataset_unalias(spn.pn_path, osname,
+		    MAXPATHLEN) != 0) {
+			error = SET_ERROR(EINVAL);
+			goto out;
+		}
+	} else {
+		osname = spn.pn_path;
+	}
 
 	/*
 	 * Check for mount privilege?
@@ -1619,8 +1636,8 @@ zfs_mount(vfs_t *vfsp, vnode_t *mvp, struct mounta *uap, cred_t *cr)
 	 * Refuse to mount a filesystem if we are in a local zone and the
 	 * dataset is not visible.
 	 */
-	if (!INGLOBALZONE(curproc) &&
-	    (!zone_dataset_visible(osname, &canwrite) || !canwrite)) {
+	if (!INGLOBALZONE(curproc) && (!zone_dataset_visible(osname,
+	    &canwrite, B_FALSE) || !canwrite)) {
 		error = SET_ERROR(EPERM);
 		goto out;
 	}
@@ -1650,6 +1667,9 @@ zfs_mount(vfs_t *vfsp, vnode_t *mvp, struct mounta *uap, cred_t *cr)
 		VFS_HOLD(mvp->v_vfsp);
 
 out:
+	if (free_osname) {
+		kmem_free(osname, MAXPATHLEN);
+	}
 	pn_free(&spn);
 	return (error);
 }
diff --git a/usr/src/uts/common/os/zone.c b/usr/src/uts/common/os/zone.c
index a161fb85a2..cc2ac25e80 100644
--- a/usr/src/uts/common/os/zone.c
+++ b/usr/src/uts/common/os/zone.c
@@ -1374,6 +1374,9 @@ zone_free_datasets(zone_t *zone)
 		next = list_next(&zone->zone_datasets, t);
 		list_remove(&zone->zone_datasets, t);
 		kmem_free(t->zd_dataset, strlen(t->zd_dataset) + 1);
+		if (t->zd_alias != NULL) {
+			kmem_free(t->zd_alias, strlen(t->zd_alias) + 1);
+		}
 		kmem_free(t, sizeof (*t));
 	}
 	list_destroy(&zone->zone_datasets);
@@ -4921,15 +4924,67 @@ zone_set_label(zone_t *zone, const bslabel_t *lab, uint32_t doi)
 }
 
 /*
- * Parses a comma-separated list of ZFS datasets into a per-zone dictionary.
+ * Check for a valid ZFS dataset name.  This function mirrors the rules
+ * for ZFS dataset names checked by "dataset_namecheck()".
+ */
+
+static boolean_t
+parse_zfs_valid_char(char c)
+{
+	return ((c >= 'a' && c <= 'z') ||
+	    (c >= 'A' && c <= 'Z') ||
+	    (c >= '0' && c <= '9') ||
+	    c == '-' || c == '_' || c == '.' || c == ':' || c == ' ');
+}
+
+static void
+parse_zfs_insert(zone_t *zone, const char *dataset, size_t dataset_len,
+    const char *alias, size_t alias_len)
+{
+	zone_dataset_t *zd = kmem_zalloc(sizeof (zone_dataset_t), KM_SLEEP);
+
+	VERIFY(dataset != NULL);
+	VERIFY(dataset_len > 0);
+	zd->zd_dataset = kmem_alloc(dataset_len + 1, KM_SLEEP);
+	bcopy(dataset, zd->zd_dataset, dataset_len);
+	zd->zd_dataset[dataset_len] = '\0';
+
+	if (alias != NULL) {
+		VERIFY(alias_len > 0);
+		zd->zd_alias = kmem_alloc(alias_len + 1, KM_SLEEP);
+		bcopy(alias, zd->zd_alias, alias_len);
+		zd->zd_alias[alias_len] = '\0';
+	} else {
+		VERIFY(alias_len == 0);
+	}
+
+	list_insert_head(&zone->zone_datasets, zd);
+}
+
+/*
+ * Parses a list of ZFS datasets into a per-zone dictionary.  Each dataset
+ * in the list is separated by a comma.  If a dataset should be known by
+ * an alias from within the zone, that alias is specified after a pipe.
+ * The alias must be a valid dataset name with exactly one component.
+ * A trailing comma at the end of the list is allowed.
+ *
+ * For example:
+ *
+ *	Without any aliases:	"one,two/a/b/c,three"
+ *	With an alias:		"long/dataset/name|tank,another,athird"
  */
 static int
 parse_zfs(zone_t *zone, caddr_t ubuf, size_t buflen)
 {
+	int ret = 0;
 	char *kbuf;
-	char *dataset, *next;
-	zone_dataset_t *zd;
-	size_t len;
+	enum parse_zfs_state {
+		PZS_REST,
+		PZS_DATASET,
+		PZS_ALIAS
+	} pzs = PZS_REST;
+	const char *dataset = NULL, *alias = NULL;
+	size_t dataset_len = 0, alias_len = 0;
 
 	if (ubuf == NULL || buflen == 0)
 		return (0);
@@ -4942,31 +4997,127 @@ parse_zfs(zone_t *zone, caddr_t ubuf, size_t buflen)
 		return (EFAULT);
 	}
 
-	dataset = next = kbuf;
-	for (;;) {
-		zd = kmem_alloc(sizeof (zone_dataset_t), KM_SLEEP);
+	for (size_t i = 0; i < buflen; i++) {
+		char c = kbuf[i];
 
-		next = strchr(dataset, ',');
+		switch (pzs) {
+		case PZS_REST:
+			if (c == '\0') {
+				goto out;
 
-		if (next == NULL)
-			len = strlen(dataset);
-		else
-			len = next - dataset;
+			} else if (parse_zfs_valid_char(c)) {
+				/*
+				 * This is the beginning of a valid dataset
+				 * name.
+				 */
+				dataset = &kbuf[i];
+				dataset_len = 1;
+				alias = NULL;
+				alias_len = 0;
+				pzs = PZS_DATASET;
+
+			} else if (c != ',') {
+				/*
+				 * A trailing comma is allowed.
+				 */
+				ret = EINVAL;
+				goto out;
+			}
+			break;
+
+		case PZS_DATASET:
+			if (c == '\0' || c == ',') {
+				/*
+				 * End of dataset name, without an alias.
+				 * Commit to dictionary.
+				 */
+				parse_zfs_insert(zone, dataset, dataset_len,
+				    alias, alias_len);
+
+				pzs = PZS_REST;
+				if (c == '\0') {
+					goto out;
+				}
 
-		zd->zd_dataset = kmem_alloc(len + 1, KM_SLEEP);
-		bcopy(dataset, zd->zd_dataset, len);
-		zd->zd_dataset[len] = '\0';
+			} else if (c == '|') {
+				/*
+				 * The pipe separates this dataset name from
+				 * its alias name.
+				 */
+				pzs = PZS_ALIAS;
 
-		list_insert_head(&zone->zone_datasets, zd);
+			} else if (parse_zfs_valid_char(c) || c == '/') {
+				/*
+				 * The slash ('/') character is allowed within
+				 * a dataset name, but not an alias name,
+				 * so we mention it explicitly here.
+				 */
+				dataset_len++;
 
-		if (next == NULL)
+			} else {
+				ret = EINVAL;
+				goto out;
+			}
 			break;
 
-		dataset = next + 1;
+		case PZS_ALIAS:
+			if (c == '\0' || c == ',') {
+				if (alias == NULL) {
+					/*
+					 * If there was an alias separator,
+					 * there must then be an alias string.
+					 */
+					ret = EINVAL;
+					goto out;
+				}
+
+				/*
+				 * End of dataset name with an alias.  Commit
+				 * to dictionary.
+				 */
+				parse_zfs_insert(zone, dataset, dataset_len,
+				    alias, alias_len);
+
+				pzs = PZS_REST;
+				if (c == '\0') {
+					goto out;
+				}
+
+			} else if (parse_zfs_valid_char(c)) {
+				if (alias == NULL) {
+					alias = &kbuf[i];
+					alias_len = 1;
+				} else {
+					alias_len++;
+				}
+
+			} else {
+				ret = EINVAL;
+				goto out;
+			}
+			break;
+
+		default:
+			panic("parse_zfs(): unexpected state");
+		}
+	}
+
+out:
+	if (ret == 0) {
+		if ((pzs == PZS_ALIAS && alias != NULL) ||
+		    pzs == PZS_DATASET) {
+			parse_zfs_insert(zone, dataset, dataset_len,
+			    alias, alias_len);
+		} else if (pzs != PZS_REST) {
+			/*
+			 * The string ended unexpectedly.
+			 */
+			ret = EINVAL;
+		}
 	}
 
 	kmem_free(kbuf, buflen);
-	return (0);
+	return (ret);
 }
 
 /*
@@ -7483,12 +7634,146 @@ zone_shutdown_global(void)
 	mutex_exit(&zonehash_lock);
 }
 
+/*
+ * Gets the un-aliased system name for an aliased dataset within a zone.
+ *
+ * Returns 0 upon success and fills out the provided 'dataset' buffer.
+ */
+int
+zone_dataset_unalias(const char *alias, char *dataset, size_t sz)
+{
+	zone_dataset_t *zd;
+	zone_t *zone = curzone;
+	size_t len, alen;
+	boolean_t found = B_FALSE;
+	char *suffix;
+	const char *asuffix;
+
+	VERIFY(alias != NULL);
+	VERIFY(dataset != NULL);
+
+	if (alias[0] == '\0') {
+		dataset[0] = '\0';
+		return (0);
+	}
+
+	/*
+	 * Walk the list once, looking for datasets which match exactly, or
+	 * specify a dataset underneath an exported dataset.  If found, exit
+	 * the loop after unsetting 'ret', so we can process it further.
+	 */
+	for (zd = list_head(&zone->zone_datasets); zd != NULL;
+	    zd = list_next(&zone->zone_datasets, zd)) {
+		if (zd->zd_alias == NULL)
+			continue;
+
+		alen = strlen(zd->zd_alias);
+		if (strlen(alias) >= alen &&
+		    bcmp(alias, zd->zd_alias, alen) == 0 &&
+		    (alias[alen] == '\0' || alias[alen] == '/' ||
+		    alias[alen] == '@')) {
+			found = B_TRUE;
+			break;
+		}
+	}
+
+	/*
+	 * If we didn't find any zone_dataset_t that matched, assume the
+	 * dataset's system name is the same as the name the zone used
+	 * (ie, assume no aliasing is in effect).
+	 */
+	if (found == B_FALSE) {
+		len = strlen(alias);
+		if (len >= sz - 1)
+			return (ENOSPC);
+		bcopy(alias, dataset, len);
+		dataset[len] = '\0';
+		return (0);
+	}
+
+	/* If aliased: place dataset name, then suffix in buffer. */
+	len = strlen(zd->zd_dataset);
+	asuffix = &alias[alen];
+	if (strlen(asuffix) + len >= sz - 1)
+		return (ENOSPC);
+	bcopy(zd->zd_dataset, dataset, len);
+	suffix = &dataset[len];
+	(void) strcpy(suffix, asuffix);
+
+	return (0);
+}
+
+/*
+ * Gets the aliased name for a dataset within a zone.
+ *
+ * Returns 0 upon success and fills out the provided 'alias' buffer.
+ */
+int
+zone_dataset_alias(const char *dataset, char *alias, size_t sz)
+{
+	zone_dataset_t *zd;
+	zone_t *zone = curzone;
+	size_t len, alen;
+	boolean_t found = B_FALSE;
+	const char *suffix;
+	char *asuffix;
+
+	VERIFY(alias != NULL);
+	VERIFY(dataset != NULL);
+
+	if (dataset[0] == '\0') {
+		alias[0] = '\0';
+		return (0);
+	}
+
+	/*
+	 * Walk the list once, looking for datasets which match exactly, or
+	 * specify a dataset underneath an exported dataset.  If found, exit
+	 * the loop after unsetting 'ret', so we can process it further.
+	 */
+	for (zd = list_head(&zone->zone_datasets); zd != NULL;
+	    zd = list_next(&zone->zone_datasets, zd)) {
+		len = strlen(zd->zd_dataset);
+		if (strlen(dataset) >= len &&
+		    bcmp(dataset, zd->zd_dataset, len) == 0 &&
+		    (dataset[len] == '\0' || dataset[len] == '/' ||
+		    dataset[len] == '@')) {
+			found = B_TRUE;
+			break;
+		}
+	}
+
+	if (found == B_FALSE)
+		return (EINVAL);
+
+	if (zd->zd_alias == NULL) {
+		/* Simple case: just copy the whole name. */
+		alen = strlen(dataset);
+		if (alen >= sz - 1)
+			return (ENOSPC);
+		bcopy(dataset, alias, alen);
+		alias[alen] = '\0';
+	} else {
+		/* If aliased: place alias, then suffix in buffer. */
+		alen = strlen(zd->zd_alias);
+		suffix = &dataset[len];
+		if (strlen(suffix) + alen >= sz - 1)
+			return (ENOSPC);
+		bcopy(zd->zd_alias, alias, alen);
+		asuffix = &alias[alen];
+		(void) strcpy(asuffix, suffix);
+	}
+
+	return (0);
+}
+
 /*
  * Returns true if the named dataset is visible in the specified zone.
  * The 'write' parameter is set to 1 if the dataset is also writable.
  */
 int
-zone_dataset_visible_inzone(zone_t *zone, const char *dataset, int *write)
+zone_dataset_visible_inzone(zone_t *zone, const char *dataset, int *write,
+    boolean_t with_aliased_parents)
 {
 	static int zfstype = -1;
 	zone_dataset_t *zd;
@@ -7506,7 +7791,6 @@ zone_dataset_visible_inzone(zone_t *zone, const char *dataset, int *write)
 	 */
 	for (zd = list_head(&zone->zone_datasets); zd != NULL;
 	    zd = list_next(&zone->zone_datasets, zd)) {
-
 		len = strlen(zd->zd_dataset);
 		if (strlen(dataset) >= len &&
 		    bcmp(dataset, zd->zd_dataset, len) == 0 &&
@@ -7528,6 +7812,14 @@ zone_dataset_visible_inzone(zone_t *zone, const char *dataset, int *write)
 	for (zd = list_head(&zone->zone_datasets); zd != NULL;
 	    zd = list_next(&zone->zone_datasets, zd)) {
 
+		if (!with_aliased_parents && zd->zd_alias != NULL) {
+			/*
+			 * Ignore parent datasets when the exported dataset
+			 * has an alias.
+			 */
+			continue;
+		}
+
 		len = strlen(dataset);
 		if (dataset[len - 1] == '/')
 			len--;	/* Ignore trailing slash */
@@ -7602,11 +7894,13 @@ zone_dataset_visible_inzone(zone_t *zone, const char *dataset, int *write)
  * The 'write' parameter is set to 1 if the dataset is also writable.
  */
 int
-zone_dataset_visible(const char *dataset, int *write)
+zone_dataset_visible(const char *dataset, int *write,
+    boolean_t with_aliased_parents)
 {
 	zone_t *zone = curproc->p_zone;
 
-	return (zone_dataset_visible_inzone(zone, dataset, write));
+	return (zone_dataset_visible_inzone(zone, dataset, write,
+	    with_aliased_parents));
 }
 
 /*
diff --git a/usr/src/uts/common/sys/zone.h b/usr/src/uts/common/sys/zone.h
index e871689f5f..71016a0958 100644
--- a/usr/src/uts/common/sys/zone.h
+++ b/usr/src/uts/common/sys/zone.h
@@ -391,6 +391,7 @@ typedef struct zone_ref {
  */
 typedef struct zone_dataset {
 	char		*zd_dataset;
+	char		*zd_alias;
 	list_node_t	zd_linkage;
 } zone_dataset_t;
 
@@ -983,8 +984,14 @@ extern int zone_ncpus_online_get(zone_t *);
 /*
  * Returns true if the named pool/dataset is visible in the current zone.
  */
-extern int zone_dataset_visible(const char *, int *);
-extern int zone_dataset_visible_inzone(zone_t *, const char *, int *);
+extern int zone_dataset_visible_inzone(zone_t *, const char *, int *, boolean_t);
+
+/*
+ * Used to convert between a zone's local alias name for a dataset and
+ * the system's name.
+ */
+extern int zone_dataset_alias(const char *, char *, size_t);
+extern int zone_dataset_unalias(const char *, char *, size_t);
 
 /*
  * zone version of kadmin()
