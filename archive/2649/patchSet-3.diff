From 59e13d3f1aceb304a4c91adaa5ef7523acd7e02d Mon Sep 17 00:00:00 2001
From: Cody Peter Mello <cody.mello@joyent.com>
Date: Wed, 22 Mar 2017 21:11:20 +0000
Subject: [PATCH] MORAY-428 Make it safer to use reindexing buckets

---
 test/buckets.test.js                    | 435 ++++++++++++++++++++++++
 test/findobjects-requireindexes.test.js |  11 +-
 2 files changed, 441 insertions(+), 5 deletions(-)

diff --git a/test/buckets.test.js b/test/buckets.test.js
index c624f39..d91666d 100644
--- a/test/buckets.test.js
+++ b/test/buckets.test.js
@@ -63,6 +63,11 @@ var FULL_CFG = {
     options: {}
 };
 
+var REINDEX_OBJ = {
+    bar: 'hello',
+    foo: 'world'
+};
+
 var c; // client
 var server;
 var b; // bucket
@@ -123,6 +128,91 @@ function assertBucket(t, bucket, cfg) {
 }
 
 
+function setupReindexingBucket(t) {
+    var cfg1 = {
+        index: {
+            bar: {
+                type: 'string'
+            }
+        },
+        options: { version: 1 }
+    };
+
+    var cfg2 =  {
+        index: {
+            bar: {
+                type: 'string'
+            },
+            foo: {
+                type: 'string'
+            }
+        },
+        options: { version: 2 }
+    };
+
+    t.test('create bucket', function (t2) {
+        c.createBucket(b, cfg1, function (err) {
+            t2.ifError(err);
+            t2.end();
+        });
+    });
+
+    t.test('put object', function (t2) {
+        c.putObject(b, 'obj1', REINDEX_OBJ, function (err) {
+            t2.ifError(err);
+            t2.end();
+        });
+    });
+
+    t.test('update bucket', function (t2) {
+        c.updateBucket(b, cfg2, function (err) {
+            t2.ifErr(err);
+            t2.end();
+        });
+    });
+}
+
+
+function finishReindexingBucket(t, overrideObj) {
+    t.test('reindex objects', function (t2) {
+        c.reindexObjects(b, 1000, function (err, res) {
+            t2.ifError(err, 'reindexObjects() error');
+            t2.deepEqual({
+                processed: 1,
+                remaining: 0
+            }, res, 'reindex results');
+            t2.end();
+        });
+    });
+
+    t.test('reindex objects (finish)', function (t2) {
+        c.reindexObjects(b, 1000, function (err, res) {
+            t2.ifError(err, 'reindexObjects() error');
+            t2.deepEqual({
+                processed: 0,
+                remaining: 0
+            }, res, 'reindex results');
+            t2.end();
+        });
+    });
+
+    t.test('bucket correctly reindexed', function (t2) {
+        c.getObject(b, 'obj1', function (err, obj) {
+            t2.ifError(err, 'getObject() error');
+            t2.ok(obj, 'object returned');
+            if (obj) {
+                if (overrideObj) {
+                    t2.deepEqual(overrideObj, obj.value, 'correct value');
+                } else {
+                    t2.deepEqual(REINDEX_OBJ, obj.value, 'correct value');
+                }
+            }
+            t2.end();
+        });
+    });
+}
+
+
 ///--- tests
 
 
@@ -155,6 +245,350 @@ test('create bucket loaded', function (t) {
 });
 
 
+test('reindexing with no reindex_active present', function (t) {
+    /*
+     * When most Moray consumers first start up, they often try to make
+     * sure that their buckets are in a sane state. To do this, they'll
+     * usually initialize their buckets for the first time with
+     * createBucket(), and then do reindexObjects(). We replicate that
+     * kind of behaviour here, to make sure Moray is okay with reindexing
+     * buckets with no "reindex_active" field.
+     */
+    function doNeedlessReindex(t2) {
+        c.reindexObjects(b, 100, function (err, res) {
+            t2.ifError(err);
+            t2.deepEqual({ processed: 0 }, res);
+            t2.end();
+        });
+    }
+
+    var cfg = {
+        options: { version: 1 }
+    };
+
+    t.test('create bucket', function (t2) {
+        c.createBucket(b, cfg, function (err) {
+            t2.ifError(err);
+            t2.end();
+        });
+    });
+
+    t.test('check bucket', function (t2) {
+        c.getBucket(b, function (err, bucket) {
+            t2.ifError(err);
+            t2.ok(bucket);
+            t2.end();
+        });
+    });
+
+    t.test('reindex on empty, newly created bucket', doNeedlessReindex);
+
+    t.test('put an object', function (t2) {
+        c.putObject(b, 'k', { foo: 'hello' }, function (err) {
+            t2.ifError(err);
+            t2.end();
+        });
+    });
+
+    t.test('reindex on bucket w/ object', doNeedlessReindex);
+
+    t.test('update bucket', function (t2) {
+        c.updateBucket(b, {
+            index: { foo: { type: 'string' } },
+            options: { version: 2 }
+        }, function (err) {
+            t2.ifError(err);
+            t2.end();
+        });
+    });
+
+    t.test('reindex object', function (t2) {
+        c.reindexObjects(b, 100, function (err, res) {
+            t2.ifError(err);
+            t2.deepEqual(res, { processed: 1, remaining: 0 });
+            t2.end();
+        });
+    });
+
+    t.test('finish up reindexing', function (t2) {
+        c.reindexObjects(b, 100, function (err, res) {
+            t2.ifError(err);
+            t2.deepEqual(res, { processed: 0, remaining: 0 });
+            t2.end();
+        });
+    });
+
+    t.test('reindex w/ nothing to do', doNeedlessReindex);
+});
+
+
+test('getObject() is safe to use during reindexing', function (t) {
+    setupReindexingBucket(t);
+
+    function doGet(t2, opts) {
+        c.getObject(b, 'obj1', opts, function (err, obj) {
+            t2.ifError(err, 'getObject() error');
+            t2.ok(obj, 'object returned');
+            if (obj) {
+                t2.deepEqual(REINDEX_OBJ, obj.value, 'value has "foo" field');
+            }
+            t2.end();
+        });
+    }
+
+    t.test('object doesn\'t lose reindexing fields', function (t2) {
+        doGet(t2, {});
+    });
+
+    t.test('"requireOnlineReindexing" option', function (t2) {
+        doGet(t2, { requireOnlineReindexing: true });
+    });
+
+    finishReindexingBucket(t);
+});
+
+
+test('putObject() is safe to use during reindexing', function (t) {
+    var k = 'obj2';
+    var o = {
+        bar: 'hiya',
+        foo: 'earth'
+    };
+
+    function checkObject(t2) {
+        c.getObject(b, k, function (err, obj) {
+            t2.ifError(err, 'getObject() error');
+            t2.ok(obj, 'object returned');
+            if (obj) {
+                t2.deepEqual(o, obj.value, 'correct value');
+            }
+            t2.end();
+        });
+    }
+
+    setupReindexingBucket(t);
+
+    t.test('put new object', function (t2) {
+        c.putObject(b, k, o, function (err) {
+            t2.ifError(err, 'putObject() error');
+            t2.end();
+        });
+    });
+
+    t.test('fetch new object', checkObject);
+
+    finishReindexingBucket(t);
+
+    t.test('fetch new object (after reindexing)', checkObject);
+});
+
+
+test('findObjects() is safe to use during reindexing', function (t) {
+    setupReindexingBucket(t);
+
+    function doFind(t2, opts) {
+        var count = 0;
+        var req = c.findObjects(b, '(bar=hello)', opts);
+
+        req.on('error', function (err) {
+            t2.ifError(err, 'findObjects() error');
+            t2.end();
+        });
+
+        req.on('record', function (obj) {
+            count += 1;
+            t2.deepEqual(REINDEX_OBJ, obj.value);
+            t2.deepEqual(1, obj._count, 'object returned');
+        });
+
+        req.on('end', function (err) {
+            t2.deepEqual(1, count, 'one object returned');
+            t2.end();
+        });
+    }
+
+    t.test('reindexing fields are not lost', function (t2) {
+        doFind(t2, {});
+    });
+
+    t.test('"requireOnlineReindexing" option', function (t2) {
+        doFind(t2, { requireOnlineReindexing: true });
+    });
+
+    t.test('"requireOnlineReindexing" should prevent ' +
+        'querying reindexing fields', function (t2) {
+        var count = 0;
+        var req = c.findObjects(b, '(foo=world)', {
+            requireOnlineReindexing: true
+        });
+
+        req.on('error', function (err) {
+            t2.equal(count, 0, 'no records should be returned');
+            t2.ok(err, 'expected error');
+            if (err) {
+                t2.ok(VError.hasCauseWithName(err, 'NotIndexedError'),
+                    'expected "NotIndexedError"');
+            }
+            t2.end();
+        });
+
+        req.on('record', function (obj) {
+            count += 1;
+            t2.fail('no records should be returned');
+            t2.deepEqual(null, obj);
+        });
+
+        req.on('end', function (err) {
+            t2.fail('query should fail');
+            t2.end();
+        });
+    });
+
+    finishReindexingBucket(t);
+});
+
+
+test('updateObjects() is safe to use during reindexing', function (t) {
+    var updatedObj = {
+        bar: 'hi',
+        foo: 'world'
+    };
+
+    setupReindexingBucket(t);
+
+    t.test('filter containing reindexing field returns error', function (t2) {
+        c.updateObjects(b, { bar: 'bye' }, '(foo=world)', function (err) {
+            t2.ok(err, 'should return error');
+            if (err) {
+                t2.ok(VError.hasCauseWithName(err, 'NotIndexedError'),
+                    'NotIndexedError');
+            }
+            t2.end();
+        });
+    });
+
+    t.test('filter containing non-indexed field returns error', function (t2) {
+        c.updateObjects(b, { bar: 'bye' }, '(baz=world)', function (err) {
+            t2.ok(err, 'should return error');
+            if (err) {
+                t2.ok(VError.hasCauseWithName(err, 'NotIndexedError'),
+                    'NotIndexedError');
+            }
+            t2.end();
+        });
+    });
+
+    t.test('update containing reindexing field returns error', function (t2) {
+        c.updateObjects(b, { foo: 'hi' }, '(bar=hello)', function (err) {
+            t2.ok(err, 'should return error');
+            if (err) {
+                t2.ok(VError.hasCauseWithName(err, 'NotIndexedError'),
+                    'NotIndexedError');
+            }
+            t2.end();
+        });
+    });
+
+    t.test('update of indexed field is fine', function (t2) {
+        c.updateObjects(b, { bar: 'hi' }, '(bar=hello)', function (uErr, meta) {
+            t2.ifError(uErr, 'should not return error');
+            t2.ok(meta, 'should return object');
+            if (meta) {
+                t2.deepEqual(1, meta.count, 'correct count returned');
+                t2.ok(meta.etag, 'etag returned');
+            }
+
+            c.getObject(b, 'obj1', function (gErr, obj) {
+                t2.ifError(gErr, 'should not return error');
+                t2.ok(obj, 'should return object');
+                if (obj) {
+                    t2.deepEqual(updatedObj, obj.value, 'should return object');
+                    t2.deepEqual(meta.etag, obj._etag, 'etags should match');
+                }
+                t2.end();
+            });
+        });
+    });
+
+    finishReindexingBucket(t, updatedObj);
+});
+
+
+test('deleteMany() is safe to use during reindexing', function (t) {
+    var cfg3 = {
+        index: {
+            bar: {
+                type: 'string'
+            },
+            foo: {
+                type: 'string'
+            },
+            quux: {
+                type: 'string'
+            }
+        },
+        options: { version: 3 }
+    };
+
+    setupReindexingBucket(t);
+
+    t.test('filter containing reindexing field returns error', function (t2) {
+        c.deleteMany(b, '(foo=hello)', function (err) {
+            t2.ok(err, 'should return error');
+            if (err) {
+                t2.ok(VError.hasCauseWithName(err, 'NotIndexedError'),
+                    'NotIndexedError');
+            }
+            t2.end();
+        });
+    });
+
+    t.test('filter containing unindexed field returns error', function (t2) {
+        c.deleteMany(b, '(baz=world)', function (err) {
+            t2.ok(err, 'should return error');
+            if (err) {
+                t2.ok(VError.hasCauseWithName(err, 'NotIndexedError'),
+                    'NotIndexedError');
+            }
+            t2.end();
+        });
+    });
+
+    finishReindexingBucket(t);
+
+    t.test('update bucket again', function (t2) {
+        c.updateBucket(b, cfg3, function (err) {
+            t2.ifErr(err);
+            t2.end();
+        });
+    });
+
+    t.test('filter containing indexed fields works', function (t2) {
+        c.deleteMany(b, '(foo=world)', function (err, res) {
+            t2.ifError(err, 'deleteMany() error');
+            t2.ok(res, 'result');
+            if (res) {
+                t2.deepEqual({
+                    count: 1
+                }, res, 'result');
+            }
+            t2.end();
+        });
+    });
+
+    t.test('reindex objects finds nothing (finish version 3)', function (t2) {
+        c.reindexObjects(b, 1000, function (err, res) {
+            t2.ifError(err, 'reindexObjects() error');
+            t2.deepEqual({
+                processed: 0,
+                remaining: 0
+            }, res, 'reindex results should be 0');
+            t2.end();
+        });
+    });
+});
+
+
 test('update bucket', function (t) {
     c.createBucket(b, FULL_CFG, function (err) {
         t.ifError(err);
@@ -489,6 +923,7 @@ test('good index names', function (t) {
     });
 });
 
+
 test('create bucket triggers not function', function (t) {
     c.createBucket(b, {pre: ['foo']}, function (err) {
         t.ok(err);
diff --git a/test/findobjects-requireindexes.test.js b/test/findobjects-requireindexes.test.js
index 42022af..0526d15 100644
--- a/test/findobjects-requireindexes.test.js
+++ b/test/findobjects-requireindexes.test.js
@@ -247,10 +247,11 @@ tape.test('client() - findobjects()', function (t) {
              */
             error: false,
             /*
-             * However, because the second index added to the bucket hasn't been
-             * reindexed yet, the findObjects request will return no record.
+             * Because the field is being reindexed, Moray will drop it from
+             * the WHERE clause, and check the value of the field after fetching
+             * it.
              */
-            nbRecordsFound: 0
+            nbRecordsFound: 1
         }
     });
 });
@@ -262,7 +263,7 @@ tape.test('client() - findobjects({requireIndexes: false})', function (t) {
         findObjectsOpts: {requireIndexes: false},
         expectedResults: {
             error: false,
-            nbRecordsFound: 0
+            nbRecordsFound: 1
         }
     });
 });
@@ -409,7 +410,7 @@ tape.test('client({requireIndexes: true}) - findobjects({requireIndexes: ' +
              * findObjects requests _not_ result in an error.
              */
             error: false,
-            nbRecordsFound: 0
+            nbRecordsFound: 1
         }
     });
 });
-- 
2.21.0

