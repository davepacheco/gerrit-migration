commit 697fa22fbae8bdf61025e16584f3668254cc06d9 (refs/changes/23/2223/8)
Author: Jordan Hendricks <jordan.hendricks@joyent.com>
Date:   2017-10-27T18:24:36+00:00 (1 year, 11 months ago)
    
    MANTA-3350 Add query parameter to muskie that allows operators to delete upload directories and parts
    Reviewed by: David Pacheco <dap@joyent.com>
    Reviewed by: Trent Mick <trentm@gmail.com>
    Approved by: Trent Mick <trentm@gmail.com>

diff --git a/README.md b/README.md
index 2b6def4..eb288a2 100644
--- a/README.md
+++ b/README.md
@@ -35,23 +35,28 @@ prerequisites in your development environment:
    to Manta.  The manta-deployment zone includes a tool called add-dev-user that
    can be used to do this.  You can find it at
    /opt/smartdc/manta-deployment/tools/add-dev-user.
-   Note: You should not use the "poseidon" user for running the tests.
 2. The ssh key that you use to authenticate as this account should be
    passwordless.  It must also be stored locally, with the public key being
    called $HOME/.ssh/id\_rsa.pub.
-3. Your SDC and Manta environment variables should point at the SDC and Manta
+3. Some tests also require an operator account to test with.  By default, the
+   tests will use the "poseidon" account, but you must provide a valid private
+   key for the poseidon account at `$HOME/.ssh/id_rsa_poseidon`.
+   Optionally, you can provide a separate operator SDC account by setting
+   `MUSKIETEST_OPERATOR_USER` and the location of its private key at
+   `MUSKIETEST_OPERATOR_KEYFILE` in your environment.
+4. Your SDC and Manta environment variables should point at the SDC and Manta
    instances that you're testing with.  The SDC and Manta variables should refer
    to the same user account, and they should both refer to the ssh key stored in
    $HOME/.ssh/id\_rsa.pub mentioned above.
-4. Before running the tests, you must set the `MUSKIE_SALT`, `MUSKIE_KEY`, and
-   `MUSKIE_IV` environment variables to the same values being used for the
-   muskie instances in your existing Manta installation.  You can find these
-   values in SAPI, using:
+5. Before running the tests, you must set the `MUSKIE_SALT`, `MUSKIE_KEY`, and
+   `MUSKIE_IV` environment variables to the same values being used for the muskie
+   instances in your existing Manta installation.  You can find these values in
+   SAPI, using:
 
         sdc-sapi /services?application_uuid="$(sdc-sapi \
             /applications?name=manta | json -H application_uuid)&name=webapi" |
             json -H -a metadata
-5. You'll need to create a muskie configuration file that's appropriate for your
+6. You'll need to create a muskie configuration file that's appropriate for your
    environment.  The easiest way to do this is to copy "etc/config.coal.json" in
    this repo into a new file "config.json".  Then:
 
@@ -81,6 +86,8 @@ In summary, you should make sure these environment variables are set properly:
 | `MANTA_USER`              | refers to your non-operator user created above |
 | `MANTA_KEY_ID`            | refers to a passwordless ssh key in $HOME/.ssh/id\_rsa |
 | `MANTA_TLS_INSECURE `     | usually 1 in an environment with self-signed certificates |
+| `MUSKIETEST_OPERATOR_USER`| operator account for testing (optional, "poseidon" used by default) |
+| `MUSKIETEST_OPERATOR_KEYFILE` | path to a passwordless ssh key for `MUSKIETEST_OPERATOR_USER` (optional, `$HOME/.ssh/id_rsa_poseidon` used by default) |
 | `SDC_URL`                 | points to the SDC deployment that you're using to test |
 | `SDC_ACCOUNT`             | same value as `MANTA_USER` |
 | `SDC_KEY_ID`              | same value as `MANTA_KEY_ID` |
diff --git a/lib/server.js b/lib/server.js
index b04eb4b..fe4bb97 100644
--- a/lib/server.js
+++ b/lib/server.js
@@ -444,13 +444,15 @@ function createServer(options, clearProxy) {
     return (server);
 }
 
+
 function forbiddenHandler(req, res, next) {
-        req.log.info('Method ' + req.method + ' disallowed for ' + req.url);
-        res.send(405);
-        next(false);
+    req.log.debug('Method ' + req.method + ' disallowed for ' + req.url);
+    res.send(405);
+    next(false);
 }
 
 
+
 /*
  * This adds the routes for the majority of multipart upload API endpoints,
  * including:
@@ -541,24 +543,6 @@ function addMultipartUploadRoutes(server) {
         contentType: '*/*'
     }, uploads.redirectHandler());
 
-    /*
-     * Path: /:account/uploads/[0-f]/:id
-     *
-     * Allowed: GET (list-parts), HEAD
-     * Disallowed: PUT, POST, DELETE
-     */
-    server.put({
-        path: '/:account/uploads/[0-f]+/:id'
-    }, forbiddenHandler);
-
-    server.post({
-        path: '/:account/uploads/[0-f]+/:id'
-    }, forbiddenHandler);
-
-    server.del({
-        path: '/:account/uploads/[0-f]+/:id'
-    }, forbiddenHandler);
-
     /*
      * Path: /:account/uploads/[0-f]/:id/state
      *
@@ -648,12 +632,36 @@ function addMultipartUploadRoutes(server) {
  * API -- that is, the uploading of parts.
  */
 function addMultipartUploadDataPlaneRoutes(server) {
+    /*
+     * Path: /:account/uploads/[0-f]/:id
+     *
+     * Allowed: GET (list-parts), HEAD
+     * Disallowed: PUT, POST, DELETE (except with override query param)
+     */
+    server.del({
+        path: '/:account/uploads/[0-f]+/:id',
+        name: 'DelUploadDir'
+    }, uploads.delUploadDirHandler());
+
+    server.put({
+        path: '/:account/uploads/[0-f]+/:id'
+    }, forbiddenHandler);
+
+    server.post({
+        path: '/:account/uploads/[0-f]+/:id'
+    }, forbiddenHandler);
+
     /*
      * Path: /:account/uploads/[0-f]/:id/:partNum
      *
      * Allowed: PUT (upload-part), HEAD
-     * Disallowed: GET, POST, DELETE
+     * Disallowed: GET, POST, DELETE (except with override query param)
      */
+    server.del({
+        path: '/:account/uploads/[0-f]+/:id/:partNum',
+        name: 'DelPart'
+    }, uploads.delPartHandler());
+
     server.put({
         path: '/:account/uploads/[0-f]+/:id/:partNum',
         name: 'UploadPart',
@@ -667,12 +675,9 @@ function addMultipartUploadDataPlaneRoutes(server) {
     server.post({
         path: '/:account/uploads/[0-f]+/:id/:partNum'
     }, forbiddenHandler);
-
-    server.del({
-        path: '/:account/uploads/[0-f]+/:id/:partNum'
-    }, forbiddenHandler);
 }
 
+
 ///--- Exports
 
 module.exports = {
diff --git a/lib/uploads/del.js b/lib/uploads/del.js
new file mode 100644
index 0000000..4ca4f68
--- /dev/null
+++ b/lib/uploads/del.js
@@ -0,0 +1,67 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var dir = require('../dir');
+var obj = require('../obj');
+
+
+/*
+ * Typically, deletion of parts and uploaded directories from MPUs is not
+ * allowed. However, we make this available to operator accounts provided
+ * the query parameter "allowMpuDeletes=true" is provided in the URL.
+ *
+ * After verifying these checks, we call into the existing handlers for deleting
+ * objects or directories to finish the DELETE.
+ */
+
+
+function checkOperator(req, res, next) {
+    if (!req.caller.account.isOperator) {
+        res.send(405);
+        next(false);
+    } else {
+        next();
+    }
+}
+
+
+function checkQueryParam(req, res, next) {
+    if (req.query.allowMpuDeletes === 'true') {
+        next();
+    } else {
+        res.send(422);
+        next(false);
+    }
+}
+
+
+///--- Exports
+
+module.exports = {
+
+    delUploadDirHandler: function delUploadDirHandler() {
+        var chain = [
+            checkOperator,
+            checkQueryParam,
+            dir.deleteDirectoryHandler()
+        ];
+        return (chain);
+    },
+
+
+    delPartHandler: function delPartHandler() {
+        var chain = [
+            checkOperator,
+            checkQueryParam,
+            obj.deleteObjectHandler()
+        ];
+        return (chain);
+    }
+};
diff --git a/lib/uploads/index.js b/lib/uploads/index.js
index da67ab5..ff61c30 100644
--- a/lib/uploads/index.js
+++ b/lib/uploads/index.js
@@ -21,9 +21,10 @@ function reExport(obj) {
 ///--- Exports
 
 module.exports = {};
+reExport(require('./abort'));
 reExport(require('./create'));
-reExport(require('./upload'));
 reExport(require('./commit'));
-reExport(require('./abort'));
+reExport(require('./del'));
 reExport(require('./get'));
 reExport(require('./redirect'));
+reExport(require('./upload'));
diff --git a/package.json b/package.json
index 490ff4a..16192a4 100644
--- a/package.json
+++ b/package.json
@@ -36,6 +36,7 @@
         "moray": "3.3.0",
         "once": "1.3.0",
         "restify": "2.6.3",
+        "sshpk": "1.13.1",
         "vasync": "^1.5.0",
         "verror": "^1.9.0",
         "watershed": "0.3.0",
diff --git a/test/mpu/del.test.js b/test/mpu/del.test.js
new file mode 100644
index 0000000..e6177e1
--- /dev/null
+++ b/test/mpu/del.test.js
@@ -0,0 +1,377 @@
+/*
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ */
+
+/*
+ * Copyright (c) 2017, Joyent, Inc.
+ */
+
+var path = require('path');
+var uuid = require('node-uuid');
+var vasync = require('vasync');
+var verror = require('verror');
+
+if (require.cache[path.join(__dirname, '/../helper.js')])
+    delete require.cache[path.join(__dirname, '/../helper.js')];
+if (require.cache[__dirname + '/helper.js'])
+    delete require.cache[__dirname + '/helper.js'];
+var testHelper = require('../helper.js');
+var helper = require('./helper.js');
+
+var after = testHelper.after;
+var before = testHelper.before;
+var test = testHelper.test;
+
+var ifErr = helper.ifErr;
+
+
+before(function (cb) {
+    helper.initMPUTester.call(this, cb);
+});
+
+
+after(function (cb) {
+    helper.cleanupMPUTester.call(this, cb);
+});
+
+
+// Delete parts/upload directories: allowed cases
+
+test('del upload directory with operator override', function (t) {
+    var self = this;
+
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        var opts = {
+            query: {
+                allowMpuDeletes: true
+            }
+        };
+        self.operatorClient.unlink(self.uploadPath(), opts,
+        function (err2, res) {
+            if (ifErr(t, err2, 'unlink')) {
+                t.end();
+                return;
+            }
+
+            t.ok(res);
+            t.checkResponse(res, 204);
+            t.end();
+        });
+    });
+});
+
+
+test('del part with operator override', function (t) {
+    var self = this;
+
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        var pn = helper.MIN_PART_NUM;
+        self.writeTestObject(self.uploadId, pn, function (err2, _) {
+            if (ifErr(t, err, 'uploaded part')) {
+                t.end();
+                return;
+            }
+
+            var opts = {
+                query: {
+                    allowMpuDeletes: true
+                }
+            };
+            self.operatorClient.unlink(self.uploadPath(pn), opts,
+            function (err3, res) {
+                if (ifErr(t, err3, 'unlink')) {
+                    t.end();
+                    return;
+                }
+
+                t.ok(res);
+                t.checkResponse(res, 204);
+                t.end();
+            });
+        });
+    });
+});
+
+
+// Delete parts/upload directories: operator, no override provided
+
+test('del upload directory: operator but no override', function (t) {
+    var self = this;
+
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        self.operatorClient.unlink(self.uploadPath(), function (err2, res) {
+            t.ok(err2);
+            if (!err2) {
+                return (t.end());
+            }
+            t.ok(verror.hasCauseWithName(err2,
+                'UnprocessableEntityError'), err2);
+            t.checkResponse(res, 422);
+            t.end();
+        });
+    });
+});
+
+
+test('del part: operator but no override', function (t) {
+    var self = this;
+
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        var pn = helper.MIN_PART_NUM;
+        self.writeTestObject(self.uploadId, pn, function (err2, _) {
+            if (ifErr(t, err, 'uploaded part')) {
+                t.end();
+                return;
+            }
+
+            self.operatorClient.unlink(self.uploadPath(pn),
+            function (err3, res) {
+                t.ok(err3);
+                if (!err3) {
+                    return (t.end());
+                }
+                t.ok(verror.hasCauseWithName(err3,
+                    'UnprocessableEntityError'), err3);
+                t.checkResponse(res, 422);
+                t.end();
+            });
+        });
+    });
+});
+
+
+// Delete parts/upload directories: non-operator, override provided
+
+test('del upload directory: non-operator with override', function (t) {
+    var self = this;
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        var opts = {
+            query: {
+                allowMpuDeletes: true
+            }
+        };
+
+        self.client.unlink(self.uploadPath(), opts, function (err2, res) {
+            t.ok(err2);
+            if (!err2) {
+                return (t.end());
+            }
+            t.ok(verror.hasCauseWithName(err2,
+                'MethodNotAllowedError'), err2);
+            t.checkResponse(res, 405);
+            t.end();
+        });
+    });
+});
+
+
+test('del part: non-operator with override', function (t) {
+    var self = this;
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        var pn = helper.MIN_PART_NUM;
+        self.writeTestObject(self.uploadId, pn, function (err2, _) {
+            if (ifErr(t, err2, 'uploaded part')) {
+                t.end();
+                return;
+            }
+
+            var opts = {
+                query: {
+                    allowMpuDeletes: true
+                }
+            };
+
+            self.client.unlink(self.uploadPath(pn), opts, function (err3, res) {
+                t.ok(err3);
+                if (!err3) {
+                    return (t.end());
+                }
+                t.ok(verror.hasCauseWithName(err3,
+                    'MethodNotAllowedError'), err3);
+                t.checkResponse(res, 405);
+                t.end();
+            });
+        });
+    });
+});
+
+
+// Delete parts/upload directories: operator, but query param is not `true`
+
+test('del upload directory: operator but query param is false', function (t) {
+    var self = this;
+
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        var opts = {
+            query: {
+                allowMpuDeletes: false
+            }
+        };
+
+        self.operatorClient.unlink(self.uploadPath(), opts,
+        function (err2, res) {
+            t.ok(err2);
+            if (!err2) {
+                return (t.end());
+            }
+            t.ok(verror.hasCauseWithName(err2,
+                'UnprocessableEntityError'), err2);
+            t.checkResponse(res, 422);
+            t.end();
+        });
+    });
+});
+
+
+test('del part: operator but query param is false', function (t) {
+    var self = this;
+
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        var pn = helper.MIN_PART_NUM;
+        self.writeTestObject(self.uploadId, pn, function (err2, _) {
+            if (ifErr(t, err, 'uploaded part')) {
+                t.end();
+                return;
+            }
+
+            var opts = {
+                query: {
+                    allowMpuDeletes: false
+                }
+            };
+
+            self.operatorClient.unlink(self.uploadPath(pn), opts,
+            function (err3, res) {
+                t.ok(err3);
+                if (!err3) {
+                    return (t.end());
+                }
+                t.ok(verror.hasCauseWithName(err3,
+                    'UnprocessableEntityError'), err3);
+                t.checkResponse(res, 422);
+                t.end();
+            });
+        });
+    });
+});
+
+
+test('del upload directory: operator but query param is not bool',
+function (t) {
+    var self = this;
+
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        var opts = {
+            query: {
+                allowMpuDeletes: 1
+            }
+        };
+
+        self.operatorClient.unlink(self.uploadPath(), opts,
+        function (err2, res) {
+            t.ok(err2);
+            if (!err2) {
+                return (t.end());
+            }
+            t.ok(verror.hasCauseWithName(err2,
+                'UnprocessableEntityError'), err2);
+            t.checkResponse(res, 422);
+            t.end();
+        });
+    });
+});
+
+
+test('del part: operator but query param is not bool', function (t) {
+    var self = this;
+
+    var h = {};
+    self.createUpload(self.path, h, function (err, o) {
+        if (ifErr(t, err, 'created upload')) {
+            t.end();
+            return;
+        }
+
+        var pn = helper.MIN_PART_NUM;
+        self.writeTestObject(self.uploadId, pn, function (err2, _) {
+            if (ifErr(t, err, 'uploaded part')) {
+                t.end();
+                return;
+            }
+
+            var opts = {
+                query: {
+                    allowMpuDeletes: false
+                }
+            };
+
+            self.operatorClient.unlink(self.uploadPath(pn), opts,
+            function (err3, res) {
+                t.ok(err3);
+                if (!err3) {
+                    return (t.end());
+                }
+                t.ok(verror.hasCauseWithName(err3,
+                    'UnprocessableEntityError'), err3);
+                t.checkResponse(res, 422);
+                t.end();
+            });
+        });
+    });
+});
diff --git a/test/mpu/helper.js b/test/mpu/helper.js
index cada050..afe6dec 100644
--- a/test/mpu/helper.js
+++ b/test/mpu/helper.js
@@ -11,9 +11,12 @@
 var assert = require('assert-plus');
 var crypto = require('crypto');
 var jsprim = require('jsprim');
+var fs = require('fs');
+var manta = require('manta');
 var MemoryStream = require('stream').PassThrough;
 var obj = require('../../lib/obj');
 var path = require('path');
+var sshpk = require('sshpk');
 var util = require('util');
 var uuid = require('node-uuid');
 
@@ -41,6 +44,14 @@ var ZERO_BYTE_MD5 = obj.ZERO_BYTE_MD5;
 var TEXT = 'The lazy brown fox \nsomething \nsomething foo';
 var TEXT_MD5 = crypto.createHash('md5').update(TEXT).digest('base64');
 
+/*
+ * We need an operator account for some tests, so we use poseidon, unless an
+ * alternate one is provided.
+ */
+var TEST_OPERATOR = process.env.MUSKIETEST_OPERATOR_USER || 'poseidon';
+var TEST_OPERATOR_KEY = process.env.MUSKIETEST_OPERATOR_KEYFILE ||
+        (process.env.HOME + '/.ssh/id_rsa_poseidon');
+
 
 ///--- Helpers
 
@@ -60,6 +71,8 @@ function initMPUTester(tcb) {
 
     self.client = testHelper.createClient();
     self.userClient = testHelper.createUserClient('muskie_test_user');
+    self.operatorClient = createOperatorClient(TEST_OPERATOR,
+        TEST_OPERATOR_KEY);
 
     self.uploadsRoot = '/' + self.client.user + '/uploads';
     self.root = '/' + self.client.user + '/stor';
@@ -74,36 +87,36 @@ function initMPUTester(tcb) {
 
     // Thin wrappers around the MPU API.
     self.createUpload = function create(p, headers, cb) {
-        createUploadHelper.call(self, p, headers, false, cb);
+        createUploadHelper.call(self, p, headers, self.client, cb);
     };
     self.abortUpload = function abort(id, cb) {
-        abortUploadHelper.call(self, id, false, cb);
+        abortUploadHelper.call(self, id, self.client, cb);
     };
     self.commitUpload = function commit(id, etags, cb) {
-        commitUploadHelper.call(self, id, etags, false, cb);
+        commitUploadHelper.call(self, id, etags, self.client, cb);
     };
     self.getUpload = function get(id, cb) {
-        getUploadHelper.call(self, id, false, cb);
+        getUploadHelper.call(self, id, self.client, cb);
     };
     self.writeTestObject = function writeObject(id, partNum, cb) {
-        writeObjectHelper.call(self, id, partNum, TEXT, false, cb);
+        writeObjectHelper.call(self, id, partNum, TEXT, self.client, cb);
     };
 
     // Wrappers using subusers as the caller.
     self.createUploadSubuser = function createSubuser(p, headers, cb) {
-        createUploadHelper.call(self, p, headers, true, cb);
+        createUploadHelper.call(self, p, headers, self.userClient, cb);
     };
     self.abortUploadSubuser = function abortSubuser(id, cb) {
-        abortUploadHelper.call(self, id, true, cb);
+        abortUploadHelper.call(self, id, self.userClient, cb);
     };
     self.commitUploadSubuser = function commitSubuser(id, etags, cb) {
-        commitUploadHelper.call(self, id, etags, true, cb);
+        commitUploadHelper.call(self, id, etags, self.userClient, cb);
     };
     self.getUploadSubuser = function getSubuser(id, cb) {
-        getUploadHelper.call(self, id, true, cb);
+        getUploadHelper.call(self, id, self.userClient, cb);
     };
     self.writeTestObjectSubuser = function writeObjectSubuser(id, partNum, cb) {
-        writeObjectHelper.call(self, id, partNum, TEXT, true, cb);
+        writeObjectHelper.call(self, id, partNum, TEXT, self.userClient, cb);
     };
 
    /*
@@ -191,6 +204,38 @@ function cleanupMPUTester(cb) {
 }
 
 
+/*
+ * Helper to create a Manta client for the operator account.
+ *
+ * Parameters:
+ *  - user: the operator account
+ *  - keyFile: local path to the private key for this account
+ */
+function createOperatorClient(user, keyFile) {
+    var key = fs.readFileSync(keyFile);
+    var keyId = sshpk.parseKey(key, 'auto').fingerprint('md5').toString();
+
+    var log = testHelper.createLogger();
+    var client = manta.createClient({
+        agent: false,
+        connectTimeout: 2000,
+        log: log,
+        retry: false,
+        sign: manta.privateKeySigner({
+            key: key,
+            keyId: keyId,
+            log: log,
+            user: user
+        }),
+        rejectUnauthorized: false,
+        url: process.env.MANTA_URL || 'http://localhost:8080',
+        user: user
+    });
+
+    return (client);
+}
+
+
 /*
  * Helper that creates an upload and passes the object returned from `create`
  * to the callback. On success, it will do a basic sanity check on the object
@@ -199,12 +244,13 @@ function cleanupMPUTester(cb) {
  * Parameters:
  *  - p: the target object path to pass to `create`
  *  - h: a headers object to pass to `create`
- *  - subuser: bool representing whether to try with a subuser
+ *  - client: client to use for the request
  *  - cb: callback of the form cb(err, object)
  */
-function createUploadHelper(p, h, subuser, cb) {
+function createUploadHelper(p, h, client, cb) {
     var self = this;
     assert.object(self);
+    assert.object(client);
     assert.func(cb);
 
     var opts = {
@@ -215,11 +261,6 @@ function createUploadHelper(p, h, subuser, cb) {
         path: self.uploadsRoot
     };
 
-    var client = self.client;
-    if (subuser) {
-        client = self.userClient;
-    }
-
     client.signRequest({
         headers: opts.headers
     }, function (err) {
@@ -260,21 +301,16 @@ function createUploadHelper(p, h, subuser, cb) {
  *
  * Parameters:
  *  - id: the upload ID to `get`
- *  - subuser: bool representing whether to try with a subuser
+ *  - client: client to use for the request
  *  - cb: callback of the form cb(err, upload)
  */
-function getUploadHelper(id, subuser, cb) {
+function getUploadHelper(id, client, cb) {
     var self = this;
     assert.object(self);
     assert.string(id);
-    assert.bool(subuser);
+    assert.object(client);
     assert.func(cb);
 
-    var client = self.client;
-    if (subuser) {
-        client = self.userClient;
-    }
-
     var opts = {
         account: self.client.user,
         partsDirectory: self.uploadPath()
@@ -300,21 +336,16 @@ function getUploadHelper(id, subuser, cb) {
  *
  * Parameters:
  *  - id: the upload ID
- *  - subuser: bool representing whether to try with a subuser
+ *  - client: client to use for the request
  *  - cb: callback of the form cb(err)
  */
-function abortUploadHelper(id, subuser, cb) {
+function abortUploadHelper(id, client, cb) {
     var self = this;
     assert.object(self);
     assert.string(id);
-    assert.bool(subuser);
+    assert.object(client);
     assert.func(cb);
 
-    var client = self.client;
-    if (subuser) {
-        client = self.userClient;
-    }
-
     var opts = {
         account: self.client.user,
         partsDirectory: self.uploadPath()
@@ -338,21 +369,16 @@ function abortUploadHelper(id, subuser, cb) {
  * Parameters:
  *  - id: the upload ID
  *  - etags: an array of etags representing parts to commit
- *  - subuser: bool representing whether to try with a subuser
+ *  - client: client to use for the request
  *  - cb: callback of the form cb(err)
  */
-function commitUploadHelper(id, etags, subuser, cb) {
+function commitUploadHelper(id, etags, client, cb) {
     var self = this;
     assert.object(self);
     assert.string(id);
-    assert.bool(subuser);
+    assert.object(client);
     assert.func(cb);
 
-    var client = self.client;
-    if (subuser) {
-        client = self.userClient;
-    }
-
     var opts = {
         account: self.client.user,
         partsDirectory: self.uploadPath()
@@ -376,18 +402,15 @@ function commitUploadHelper(id, etags, subuser, cb) {
  *  - id: the upload ID
  *  - partNum: the part number
  *  - string: string representing the object data
- *  - subuser: bool representing whether to try with a subuser
+ *  - client: client to use for the request
  *  - cb: callback of the form cb(err, res)
  */
-function writeObjectHelper(id, partNum, string, subuser, cb) {
+function writeObjectHelper(id, partNum, string, client, cb) {
     var self = this;
     assert.object(self);
     assert.string(string);
-
-    var client = self.client;
-    if (subuser) {
-        client = self.userClient;
-    }
+    assert.object(client);
+    assert.func(cb);
 
     var opts = {
         account: self.client.user,
